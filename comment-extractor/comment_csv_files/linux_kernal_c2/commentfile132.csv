 SPDX-License-Identifier: GPL-2.0+
  comedidriversdt9812.c
    COMEDI driver for DataTranslation DT9812 USB module
  Copyright (C) 2005 Anders Blomdell <anders.blomdell@control.lth.se>
  COMEDI - Linux Control and Measurement Device Interface
  Driver: dt9812
  Description: Data Translation DT9812 USB module
  Devices: [Data Translation] DT9812 (dt9812)
  Author: anders.blomdell@control.lth.se (Anders Blomdell)
  Status: in development
  Updated: Sun Nov 20 20:18:34 EST 2005
  This driver works, but bulk transfers not implemented. Might be a
  starting point for someone else. I found out too late that USB has
  too high latencies (>1 ms) for my needs.
  Nota Bene:
    1. All writes to command pipe has to be 32 bytes (ISP1181B SHRTP=0 ?)
    2. The DDK source (as of sep 2005) is in error regarding the
       input MUX bits (example code says P4, but firmware schematics
       says P1).
 usb_bulk_msg() timeout in milliseconds 
  See Silican Laboratories C8051F020123 manual
 AD  DA  DI  DO  CT 
  8    2   8   8   1  +- 10V 
  8    2   8   8   1  0-2.44V 
 Write Flash memory 
 Read Flash memory misc config info 
	
	  Register readwrite commands for processor
 Read a single byte of USB memory 
 Write a single byte of USB memory 
 Multiple Reads of USB memory 
 Multiple Writes of USB memory 
 Read, (AND) with mask, OR value, then write (single) 
 Read, (AND) with mask, OR value, then write (multiple) 
	
	  Register readwrite commands for SMBus
 Read a single byte of SMBus 
 Write a single byte of SMBus 
 Multiple Reads of SMBus 
 Multiple Writes of SMBus 
	
	  Register readwrite commands for a device
 Read a single byte of a device 
 Write a single byte of a device 
 Multiple Reads of a device 
 Multiple Writes of a device 
 Not sure if we'll need this 
 Set interrupt on change mask 
 Write (or Clear) the CGL for the ADC 
 Multiple Reads of USB memory 
 Multiple Writes to USB memory 
 Issue a start command to a given subsystem 
 Issue a stop command to a given subsystem 
 calibrate the board using CAL_POT_CMD 
 set the DAC FIFO size 
 Write or Clear the CGL for the DAC 
 Read a single value from a subsystem 
 Write a single value to a subsystem 
 Valid DT9812_USB_FIRMWARE_CMD_CODE's will be less than this number 
 DT9812 only responds to 32 byte writes!! 
 DT9812 only responds to 32 byte writes!! 
 DT9812 only responds to 32 byte writes!! 
 DT9812 only responds to 32 byte writes!! 
		
		  bits 0-6 in F020_SFR_P3 are bits 0-6 in the digital
		  input port bit 3 in F020_SFR_P1 is bit 7 in the
		  digital input port
 In the DT981210V MUX is selected by P1.5-7 
 In the DT98122.5V, internal mux is selected by bits 0:2 
 In the DT981210V, there is an external gain of 0.5 
		
		  000 -> Gain =  1
		  001 -> Gain =  2
		  010 -> Gain =  4
		  011 -> Gain =  8
		  10x -> Gain = 16
		  11x -> Gain =  0.5
 this should never happen, just use a gain of 1 
 1 select the gain 
 2 set the MUX to select the channel 
 3 start conversion 
 read the status and ADC 
	
	  An ADC conversion takes 16 SAR clocks cycles, i.e. about 9us.
	  Therefore, between the instant that AD0BUSY was set via
	  dt9812_rmw_multiple_registers and the read of AD0BUSY via
	  dt9812_read_multiple_registers, the conversion should be complete
	  since these two operations require two USB transactions each taking
	  at least a millisecond to complete.  However, lets make sure that
	  conversion is finished.
			
			  For DT9812-10V the personality module set the
			  encoding to 2's complement. Hence, convert it before
			  returning it
 1. Set DAC mode 
 2. load lsb of DAC value first 
 3. load msb of DAC value next to latch the 12-bit value 
 1. Set DAC mode 
 2. load lsb of DAC value first 
 3. load msb of DAC value next to latch the 12-bit value 
 unused message pipe 
 unused write stream 
 unused read stream 
		
		  Seems like a configuration reset is necessary if driver is
		  reloaded while device is attached
 let the user know what node this device is now attached to 
 Digital Input subdevice 
 Digital Output subdevice 
 Analog Input subdevice 
 Analog Output subdevice 
 SPDX-License-Identifier: GPL-2.0
  adv_pci1710.c
  Comedi driver for Advantech PCI-1710 series boards
  Author: Michal Dobes <dobes@tesnet.cz>
  Thanks to ZhenGang Shang <ZhenGang.Shang@Advantech.com.cn>
  for testing and information.
  Driver: adv_pci1710
  Description: Comedi driver for Advantech PCI-1710 series boards
  Devices: [Advantech] PCI-1710 (adv_pci1710), PCI-1710HG, PCI-1711,
    PCI-1713, PCI-1731
  Author: Michal Dobes <dobes@tesnet.cz>
  Updated: Fri, 29 Oct 2015 17:19:35 -0700
  Status: works
  Configuration options: not applicable, uses PCI auto config
  This driver supports AI, AO, DI and DO subdevices.
  AI subdevice supports cmd and insn interface,
  other subdevices support only insn interface.
  The PCI-1710 and PCI-1710HG have the same PCI device ID, so the
  driver cannot distinguish between them, as would be normal for a
  PCI driver.
  PCI BAR2 Register map (dev->iobase)
 R:   AD data 
 W:   soft trigger for AD 
 W:   AD gainrange register 
 W:   AD multiplexor control 
 R:   status register 
 1=IRQ occurred 
 1=FIFO is full, fatal error 
 1=FIFO is half full 
 1=FIFO is empty 
 W:   control register 
 1=ext. clk, 0=int. 100kHz clk 
 1=on FIFO half full, 0=on sample 
 1=enable IRQ 
 1=enable ext. trigger GATE (8254?) 
 1=enable ext. trigger source 
 1=enable int. 8254 trigger source 
 1=enable software trigger source 
 W:   clear interrupts request 
 W:   clear FIFO 
 W:   DA register 
 W:   DA reference control 
 R:   digital inputs 
 W:   digital outputs 
 RW: 8254 timer 
 gain 1   (0x00) 
 gain 2   (0x01) 
 gain 4   (0x02) 
 gain 8   (0x03) 
 gain 0.5 (0x04) 
 gain 1   (0x00 | UNI) 
 gain 2   (0x01 | UNI) 
 gain 4   (0x02 | UNI) 
 gain 8   (0x03 | UNI) 
 gain 1    (0x00) 
 gain 10   (0x01) 
 gain 100  (0x02) 
 gain 1000 (0x03) 
 gain 0.5  (0x04) 
 gain 5    (0x05) 
 gain 50   (0x06) 
 gain 500  (0x07) 
 gain 1    (0x00 | UNI) 
 gain 10   (0x01 | UNI) 
 gain 100  (0x02 | UNI) 
 gain 1000 (0x03 | UNI) 
 gain 1  (0x00) 
 gain 2  (0x01) 
 gain 4  (0x02) 
 gain 8  (0x03) 
 gain 16 (0x04) 
 internal -5V ref 
 internal -10V ref 
 external -Vref (+-10V max) 
 control register value 
 used to switch from TRIG_EXT to TRIG_xxx 
 used to set the channel interval to scan 
  list of scanned channel 
 len of the non-repeating chanlist 
  copy of DA outpit range register 
 adjust for unipolar gain codes 
 first channel is always ok 
  we detected a loop, stop 
 next correct channel in list 
  store range list to card 
 select channel and set range 
 store remainder of channel list 
 select channel interval to scan 
		
		  The upper 4 bits of the 16-bit sample are the channel number
		  that the sample was acquired from. Verify that this channel
		  number matches the expected channel number.
 enable software trigger 
 start conversion 
 disable software trigger 
 disable AD triggers and interrupt sources 
 preserve counter 0 clk src 
 disable pacer 
 clear AD FIFO and any pending interrutps 
  is device attached? 
  no, exit 
  is this interrupt from our board? 
  no, exit 
  Switch from initial TRIG_EXT to TRIG_xxx. 
 set software trigger 
 no sample on this interrupt; reset the channel interval 
 TRIG_NOW 
 TRIG_EXT 
 Step 1 : check if triggers are trivially valid 
 step 2a: make sure trigger sources are unique 
 step 2b: and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_FOLLOW 
 TRIG_NONE 
 step 4: fix up any arguments 
 Step 5: check channel list 
 internal 
 external 
	
	  Disable AD triggers and interrupt sources, set counter 0
	  to use internal 1 MHz clock.
 clear AD FIFO and any pending interrutps 
 set DACs to 0..5V and outputs to 0V 
 set digital outputs to 0 
 all boards have analog inputs 
		
		  All other boards have digital inputs and outputs as
		  well as a user counter.
 Analog Input subdevice 
 find the value needed to adjust for unipolar gain codes 
 Analog Output subdevice 
 Digital Input subdevice 
 Digital Output subdevice 
 Counter subdevice (8254) 
 counters 1 and 2 are used internally for the pacer 
 max_samples is half the FIFO size (2 bytessample) 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  COMEDI driver for Advantech PCI-1720U
  Copyright (c) 2015 H Hartley Sweeten <hsweeten@visionengravers.com>
  Separated from the adv_pci1710 driver written by:
  Michal Dobes <dobes@tesnet.cz>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: adv_pci1720
  Description: 4-channel Isolated DA Output board
  Devices: [Advantech] PCI-7120U (adv_pci1720)
  Author: H Hartley Sweeten <hsweeten@visionengravers.com>
  Updated: Fri, 29 Oct 2015 17:19:35 -0700
  Status: untested
  Configuration options: not applicable, uses PCI auto config
  The PCI-1720 has 4 isolated 12-bit analog output channels with multiple
  output ranges. It also has a BoardID switch to allow differentiating
  multiple boards in the system.
  The analog outputs can operate in two modes, immediate and synchronized.
  This driver currently does not support the synchronized output mode.
  Jumpers JP1 to JP4 are used to set the current sink ranges for each
  analog output channel. In order to use the current sink ranges, the
  unipolar 5V range must be used. The voltage output and sink output for
  each channel is available on the connector as separate pins.
  Jumper JP5 controls the "hot" reset state of the analog outputs.
  Depending on its setting, the analog outputs will either keep the
  last settings and output values or reset to the default state after
  a "hot" reset. The default state for all channels is uniploar 5V range
  and all the output values are 0V. To allow this feature to work, the
  analog outputs are not "reset" when the driver attaches.
  PCI BAR2 Register map (dev->iobase)
 set the channel range and polarity 
 conversion time is 2us (500 kHz throughput) 
 Analog Output subdevice 
 Digital Input subdevice (BoardID SW1) 
 disable synchronized output, channels update when written 
 SPDX-License-Identifier: GPL-2.0+
  Comedi driver for CIO-DAS16M1
  Author: Frank Mori Hess, based on code from the das16 driver.
  Copyright (C) 2001 Frank Mori Hess <fmhess@users.sourceforge.net>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: das16m1
  Description: CIO-DAS16M1
  Author: Frank Mori Hess <fmhess@users.sourceforge.net>
  Devices: [Measurement Computing] CIO-DAS16M1 (das16m1)
  Status: works
  This driver supports a single board - the CIO-DAS16M1. As far as I know,
  there are no other boards that have the same register layout. Even the
  CIO-DAS16M116 is significantly different.
  I was _barely_ able to reach the full 1 MHz capability of this board, using
  a hard real-time interrupt (set the TRIG_RT flag in your struct comedi_cmd
  and use rtlinux or RTAI). The board can't do dma, so the bottleneck is
  pulling the data across the ISA bus. I timed the interrupt handler, and it
  took my computer ~470 microseconds to pull 512 samples from the board. So
  at 1 Mhz sampling rate, expect your CPU to be spending almost all of its
  time in the interrupt handler.
  This board has some unusual restrictions for its channelgain list.  If the
  list has 2 or more channels in it, then two conditions must be satisfied:
  (1) - evenodd channels must appear at evenodd indices in the list
  (2) - the list must have an even number of entries.
  Configuration options:
    [0] - base io address
    [1] - irq (optional, but you probably want it)
  irq can be omitted, although the cmd interface will not work without it.
  Register map (dev->iobase)
 16-bit register 
 # samples 
	
	  The fifo values have the channel number in the lower 4-bits and
	  the sample in the upper 12-bits. This just shifts the values
	  to remove the channel numbers.
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 internal trigger 
 TRIG_NONE 
 step 4: fix up arguments 
 Step 5: check channel list if it exists 
  set software count 
	
	  Initialize lower half of hardware counter, used to determine how
	  many samples are in fifo.  Value doesn't actually load into counter
	  until counter's next clock (the next ad conversion).
	
	  Remember current reading of counter so we know when counter has
	  actually been loaded.
 enable interrupts and set internal pacer counter mode and counts 
 TRIG_EXT 
  set control & status register 
	
	  If we are using external start trigger (also board dislikes having
	  both start and conversion triggers external simultaneously).
 clear interrupt 
 disable interrupts and pacer 
 clear interrupt 
 trigger conversion 
 figure out how many samples are in fifo 
	
	  Make sure hardware counter reading is not bogus due to initial
	  value not having been loaded yet.
		
		  The calculation of num_samples looks odd, but it uses the
		  following facts. 16 bit hardware counter is initialized with
		  value of zero (which really means 0x1000).  The counter
		  decrements by one on each conversion (when the counter
		  decrements from zero it goes to 0xffff).  num_samples is a
		  16 bit variable, so it will roll over in a similar fashion
		  to the hardware counter.  Work it out, and this is what you
		  get.
  check if we only need some of the points 
  make sure we don't try to get too many points if fifo has overrun 
 end of acquisition 
	
	  This probably won't catch overruns since the card doesn't generate
	  overrun interrupts, but we might as well try.
  prevent race with interrupt handler 
  prevent race with comedi_poll() 
 clear interrupt 
 Request an additional region for the 8255 and 3rd 8254 
 only irqs 2, 3, 4, 5, 6, 7, 10, 11, 12, 14, and 15 are valid 
 Analog Input subdevice 
 Digital Input subdevice 
 Digital Output subdevice 
 Digital IO subdevice (8255) 
  initialize digital output lines 
 set the interrupt level 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriversrti800.c
  Hardware driver for Analog Devices RTI-800815 board
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1998 David A. Schleef <ds@schleef.org>
  Driver: rti800
  Description: Analog Devices RTI-800815
  Devices: [Analog Devices] RTI-800 (rti800), RTI-815 (rti815)
  Author: David A. Schleef <ds@schleef.org>
  Status: unknown
  Updated: Fri, 05 Sep 2008 14:50:44 +0100
  Configuration options:
    [0] - IO port base address
    [1] - IRQ (not supported  unused)
    [2] - AD muxreference (number of channels)
 	   0 = differential
 	   1 = pseudodifferential (common)
 	   2 = single-ended
    [3] - AD range
 	   0 = [-10,10]
 	   1 = [-5,5]
 	   2 = [0,10]
    [4] - AD encoding
 	   0 = two's complement
 	   1 = straight binary
    [5] - DAC 0 range
 	   0 = [-10,10]
 	   1 = [0,10]
    [6] - DAC 0 encoding
 	   0 = two's complement
 	   1 = straight binary
    [7] - DAC 1 range (same as DAC 0)
    [8] - DAC 1 encoding (same as DAC 0)
  Register map
		
		  Without a delay here, the RTI_CSR_OVERRUN bit
		  gets set, and you will have an error.
 Outputs are inverted... 
 invalid, forces the MUXGAIN register to be set when first used 
 ai subdevice 
 ao subdevice (only on rti815) 
 di 
 do 
	
	  There is also an Am9513 timer on these boards. This subdevice
	  is not currently supported.
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  addi_apci_1500.c
  Copyright (C) 2004,2005  ADDI-DATA GmbH for the source code of this module.
 	ADDI-DATA GmbH
 	Dieselstrasse 3
 	D-77833 Ottersweier
 	Tel: +19(0)72239493-0
 	Fax: +49(0)72239493-92
 	http:www.addi-data.com
 	info@addi-data.com
  PCI Bar 0 Register map (devpriv->amcc)
  see amcc_s5933.h for register and bit defines
  PCI Bar 1 Register map (dev->iobase)
  see z8536.h for Z8536 internal registers and bit defines
  PCI Bar 2 Register map (devpriv->addon)
 Digital trigger configuration [0]=AND [1]=OR 
 Pattern Mask 
 Pattern Transition 
 Pattern Polarity 
	
	  Even if the state of the Z8536 is not known, the following
	  sequence will reset it and put it in State 0.
 Disable all Ports and CounterTimers 
	
	  Port A is connected to Ditial Input channels 0-7.
	  Configure the port to allow interrupt detection.
	
	  Port B is connected to Ditial Input channels 8-13.
	  Configure the port to allow interrupt detection.
	 
	  NOTE: Bits 7 and 6 of Port B are connected to internal
	  diagnostic signals and bit 7 is inverted.
	
	  Not sure what Port C is connected to...
	
	  Clear and disable all interrupt sources.
	 
	  Just in case, the reset of the Z8536 should have already
	  done this.
 Disable all interrupts 
 preserve any write bits 
 port a event (inputs 0-7) 
 Tests if this is an external error 
 voltage error 
 short circuit error 
 port b event (inputs 8-13) 
	
	  NOTE: The 'status' returned by the sample matches the
	  interrupt mask information from the APCI-1500 Users Manual.
	 
	     Mask     Meaning
	  ----------  ------------------------------------------
	  0b00000001  Event 1 has occurred
	  0b00000010  Event 2 has occurred
	  0b00000100  Countertimer 1 has run down (not implemented)
	  0b00001000  Countertimer 2 has run down (not implemented)
	  0b00010000  Counter 3 has run down (not implemented)
	  0b00100000  Watchdog has run down (not implemented)
	  0b01000000  Voltage error
	  0b10000000  Short-circuit error
 Disables the main interrupt on the board 
 Disable Ports A & B 
 Ack any pending interrupts 
 Disable pattern interrupts 
 Enable Ports A & B 
 Disable Ports A & B 
 Set Port A for selected trigger pattern 
 Set Port B for selected trigger pattern 
 Set Port A trigger mode (if enabled) and enable interrupt 
 Set Port B trigger mode (if enabled) and enable interrupt 
 Enable Ports A & B 
 Authorizes the main interrupt on the board 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
	
	  Internal start source triggers:
	 
	    0	AND mode for Port A (digital inputs 0-7)
	 	AND mode for Port B (digital inputs 8-13 and internal signals)
	 
	    1	OR mode for Port A (digital inputs 0-7)
	 	AND mode for Port B (digital inputs 8-13 and internal signals)
	 
	    2	AND mode for Port A (digital inputs 0-7)
	 	OR mode for Port B (digital inputs 8-13 and internal signals)
	 
	    3	OR mode for Port A (digital inputs 0-7)
	 	OR mode for Port B (digital inputs 8-13 and internal signals)
 Step 4: fix up any arguments 
 Step 5: check channel list if it exists 
  The pattern-recognition logic must be configured before the digital
  input async command is started.
  Digital input channels 0 to 13 can generate interrupts. Channels 14
  and 15 are connected to internal board statusdiagnostic signals.
  Channel 14 - Voltage error (the external supply is < 5V)
  Channel 15 - Short-circuitovertemperature error
 	data[0] : INSN_CONFIG_DIGITAL_TRIG
 	data[1] : trigger number
 		  0 = AND mode
 		  1 = OR mode
 	data[2] : configuration operation:
 	          COMEDI_DIGITAL_TRIG_DISABLE = no interrupts
 	          COMEDI_DIGITAL_TRIG_ENABLE_EDGES = edge interrupts
 	          COMEDI_DIGITAL_TRIG_ENABLE_LEVELS = level interrupts
 	data[3] : left-shift for data[4] and data[5]
 	data[4] : rising-edgehigh level channels
 	data[5] : falling-edgelow level channels
 clear trigger configuration 
 enable channels 
 enable edge detection 
 rising-edge channels 
 falling-edge channels 
 enable channels 
 enable level detection 
 high level channels 
 low level channels 
	
	  The AND mode trigger can only have one channel (max) enabled
	  for edge detection.
 save the trigger configuration 
 Simulate the 8254 timer modes 
 Interrupt on Terminal Count 
 Hardware Retriggerable One-Shot 
 Rate Generator 
 Square Wave Mode 
 Software Triggered Strobe 
 Hardware Triggered Strobe (watchdog) 
 111.86 kHz  2 
 17879 ns (approx) 
 3.49 kHz  2 
 573066 ns (approx) 
 1.747 kHz  2 
 1164822 ns (approx) 
 preserve gate 
 set trigger 
 software trigger a timer, it only makes sense to do one write 
 preserve gate 
 set RCC 
 Digital Input subdevice 
 Digital Output subdevice 
 reset all the digital outputs 
 CounterTimer(Watchdog) subdevice 
 Enable the PCI interrupt 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriversni_labpc.c
  Driver for National Instruments Lab-PC series boards and compatibles
  Copyright (C) 2001-2003 Frank Mori Hess <fmhess@users.sourceforge.net>
  Driver: ni_labpc
  Description: National Instruments Lab-PC (& compatibles)
  Devices: [National Instruments] Lab-PC-1200 (lab-pc-1200),
    Lab-PC-1200AI (lab-pc-1200ai), Lab-PC+ (lab-pc+)
  Author: Frank Mori Hess <fmhess@users.sourceforge.net>
  Status: works
  Configuration options - ISA boards:
    [0] - IO port base address
    [1] - IRQ (optional, required for timed or externally triggered
 		conversions)
    [2] - DMA channel (optional)
  Tested with lab-pc-1200.  For the older Lab-PC+, not all input
  ranges and analog references will work, the available rangesarefs
  will depend on how you have configured the jumpers on your board
  (see your owner's manual).
  Kernel-level ISA plug-and-play support for the lab-pc-1200 boards
  has not yet been added to the driver, mainly due to the fact that
  I don't know the device id numbers. If you have one of these boards,
  please file a bug report at https:comedi.org so I can get the
  necessary information from you.
  The 1200 series boards have onboard calibration dacs for correcting
  analog inputoutput offsets and gains. The proper settings for these
  caldacs are stored on the board's eeprom. To read the caldac values
  from the eeprom and store them into a file that can be then be used
  by comedilib, use the comedi_calibrate program.
  The Lab-pc+ has quirky chanlist requirements when scanning multiple
  channels. Multiple channel scan sequence must start at highest channel,
  then decrement down to channel 0. The rest of the cards can scan down
  like lab-pc+ or scan up from channel zero. Chanlists consisting of all
  one channel are also legal, and allow you to pace conversions in bursts.
  NI manuals:
  341309a (labpc-1200 register manual)
  320502b (lab-pc+)
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  c6xdigio.c
  Hardware driver for Mechatronic Systems Inc. C6x_DIGIO DSP daughter card.
  http:web.archive.orgweb%2Ahttp:robot0.ge.uiuc.edu~spongmecha
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1999 Dan Block
  Driver: c6xdigio
  Description: Mechatronic Systems Inc. C6x_DIGIO DSP daughter card
  Author: Dan Block
  Status: unknown
  Devices: [Mechatronic Systems Inc.] C6x_DIGIO DSP daughter card (c6xdigio)
  Updated: Sun Nov 20 20:18:34 EST 2005
  Configuration Options:
 	[0] - base address
  Register IO map
	
	  There are only 2 PWM channels and they have a maxdata of 500.
	  Instead of allocating private data to save the values in for
	  readback this driver just packs the values for the two channels
	  in the s->state.
 munge two's complement value to offset binary 
 Initialize the PWM 
 Reset the encoders 
 Standard LPT Printer Port 
 ECP Printer Port 
  Make sure that PnP ports get activated 
 pwm output subdevice 
 encoder (counter) subdevice 
  I will call this init anyway but more than likely the DSP board 
  will not be connected when device driver is loaded. 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  ni_at_ao.c
  Driver for NI AT-AO-610 boards
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000,2002 David A. Schleef <ds@schleef.org>
  Driver: ni_at_ao
  Description: National Instruments AT-AO-610
  Devices: [National Instruments] AT-AO-6 (at-ao-6), AT-AO-10 (at-ao-10)
  Status: should work
  Author: David A. Schleef <ds@schleef.org>
  Updated: Sun Dec 26 12:26:28 EST 2004
  Configuration options:
    [0] - IO port base address
    [1] - IRQ (unused)
    [2] - DMA (unused)
    [3] - analog output range, set by jumpers on hardware
          0 for -10 to 10V bipolar
          1 for 0V to 10V unipolar
  Register map
  Register-level programming information can be found in NI
  document 320379.pdf.
 registers with _2_ are accessed when GRP2WR is set in CFG1 
 Used for caldac readback 
 the hardware expects two's complement values 
  There are three DAC8800 TrimDACs on the board. These are 8-channel,
  8-bit DACs that are used to calibrate the Analog Output channels.
  The factory default calibration values are stored in the EEPROM.
  The TrimDACs, and EEPROM addresses, are mapped as:
         Channel       EEPROM  Description
    -----------------  ------  -----------------------------------
     0 - DAC0 Chan 0    0x30   AO Channel 0 Offset
     1 - DAC0 Chan 1    0x31   AO Channel 0 Gain
     2 - DAC0 Chan 2    0x32   AO Channel 1 Offset
     3 - DAC0 Chan 3    0x33   AO Channel 1 Gain
     4 - DAC0 Chan 4    0x34   AO Channel 2 Offset
     5 - DAC0 Chan 5    0x35   AO Channel 2 Gain
     6 - DAC0 Chan 6    0x36   AO Channel 3 Offset
     7 - DAC0 Chan 7    0x37   AO Channel 3 Gain
     8 - DAC1 Chan 0    0x38   AO Channel 4 Offset
     9 - DAC1 Chan 1    0x39   AO Channel 4 Gain
    10 - DAC1 Chan 2    0x3a   AO Channel 5 Offset
    11 - DAC1 Chan 3    0x3b   AO Channel 5 Gain
    12 - DAC1 Chan 4    0x3c   2.5V Offset
    13 - DAC1 Chan 5    0x3d   AO Channel 6 Offset (at-ao-10 only)
    14 - DAC1 Chan 6    0x3e   AO Channel 6 Gain   (at-ao-10 only)
    15 - DAC1 Chan 7    0x3f   AO Channel 7 Offset (at-ao-10 only)
    16 - DAC2 Chan 0    0x40   AO Channel 7 Gain   (at-ao-10 only)
    17 - DAC2 Chan 1    0x41   AO Channel 8 Offset (at-ao-10 only)
    18 - DAC2 Chan 2    0x42   AO Channel 8 Gain   (at-ao-10 only)
    19 - DAC2 Chan 3    0x43   AO Channel 9 Offset (at-ao-10 only)
    20 - DAC2 Chan 4    0x44   AO Channel 9 Gain   (at-ao-10 only)
         DAC2 Chan 5    0x45   Reserved
         DAC2 Chan 6    0x46   Reserved
         DAC2 Chan 7    0x47   Reserved
 write the channel and last data value to the caldac 
 clock the bitstring to the caldac; MSB -> LSB 
 strobe the caldac to load the value 
 This is the reset sequence described in the manual 
 Put outputs of counter 1 and counter 2 in a high state 
 Analog Output subdevice 
 Digital IO subdevice 
 caldac subdevice 
 EEPROM subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriversamplc_pci230.c
  Driver for Amplicon PCI230 and PCI260 Multifunction IO boards.
  Copyright (C) 2001 Allan Willcox <allanwillcox@ozemail.com.au>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: amplc_pci230
  Description: Amplicon PCI230, PCI260 Multifunction IO boards
  Author: Allan Willcox <allanwillcox@ozemail.com.au>,
    Steve D Sharples <steve.sharples@nottingham.ac.uk>,
    Ian Abbott <abbotti@mev.co.uk>
  Updated: Mon, 01 Sep 2014 10:09:16 +0000
  Devices: [Amplicon] PCI230 (amplc_pci230), PCI230+, PCI260, PCI260+
  Status: works
  Configuration options:
    none
  Manual configuration of PCI cards is not supported; they are configured
  automatically.
  The PCI230+ and PCI260+ have the same PCI device IDs as the PCI230 and
  PCI260, but can be distinguished by the size of the PCI regions.  A
  card will be configured as a "+" model if detected as such.
  Subdevices:
                  PCI230(+)    PCI260(+)
                  ---------    ---------
    Subdevices       3            1
          0          AI           AI
          1          AO
          2          DIO
  AI Subdevice:
    The AI subdevice has 16 single-ended channels or 8 differential
    channels.
    The PCI230 and PCI260 cards have 12-bit resolution.  The PCI230+ and
    PCI260+ cards have 16-bit resolution.
    For differential mode, use inputs 2N and 2N+1 for channel N (e.g. use
    inputs 14 and 15 for channel 7).  If the card is physically a PCI230
    or PCI260 then it actually uses a "pseudo-differential" mode where the
    inputs are sampled a few microseconds apart.  The PCI230+ and PCI260+
    use true differential sampling.  Another difference is that if the
    card is physically a PCI230 or PCI260, the inverting input is 2N,
    whereas for a PCI230+ or PCI260+ the inverting input is 2N+1.  So if a
    PCI230 is physically replaced by a PCI230+ (or a PCI260 with a
    PCI260+) and differential mode is used, the differential inputs need
    to be physically swapped on the connector.
    The following input ranges are supported:
      0 => [-10, +10] V
      1 => [-5, +5] V
      2 => [-2.5, +2.5] V
      3 => [-1.25, +1.25] V
      4 => [0, 10] V
      5 => [0, 5] V
      6 => [0, 2.5] V
  AI Commands:
    +=========+==============+===========+============+==========+
    |start_src|scan_begin_src|convert_src|scan_end_src| stop_src |
    +=========+==============+===========+============+==========+
    |TRIG_NOW | TRIG_FOLLOW  |TRIG_TIMER | TRIG_COUNT |TRIG_NONE |
    |TRIG_INT |              |TRIG_EXT(3)|            |TRIG_COUNT|
    |         |              |TRIG_INT   |            |          |
    |         |--------------|-----------|            |          |
    |         | TRIG_TIMER(1)|TRIG_TIMER |            |          |
    |         | TRIG_EXT(2)  |           |            |          |
    |         | TRIG_INT     |           |            |          |
    +---------+--------------+-----------+------------+----------+
    Note 1: If AI command and AO command are used simultaneously, only
            one may have scan_begin_src == TRIG_TIMER.
    Note 2: For PCI230 and PCI230+, scan_begin_src == TRIG_EXT uses
            DIO channel 16 (pin 49) which will need to be configured as
            a digital input.  For PCI260+, the EXTTRIGEXTCONVCLK input
            (pin 17) is used instead.  For PCI230, scan_begin_src ==
            TRIG_EXT is not supported.  The trigger is a rising edge
            on the input.
    Note 3: For convert_src == TRIG_EXT, the EXTTRIGEXTCONVCLK input
            (pin 25 on PCI230(+), pin 17 on PCI260(+)) is used.  The
            convert_arg value is interpreted as follows:
              convert_arg == (CR_EDGE | 0) => rising edge
              convert_arg == (CR_EDGE | CR_INVERT | 0) => falling edge
              convert_arg == 0 => falling edge (backwards compatibility)
              convert_arg == 1 => rising edge (backwards compatibility)
    All entries in the channel list must use the same analogue reference.
    If the analogue reference is not AREF_DIFF (not differential) each
    pair of channel numbers (0 and 1, 2 and 3, etc.) must use the same
    input range.  The input ranges used in the sequence must be all
    bipolar (ranges 0 to 3) or all unipolar (ranges 4 to 6).  The channel
    sequence must consist of 1 or more identical subsequences.  Within the
    subsequence, channels must be in ascending order with no repeated
    channels.  For example, the following sequences are valid: 0 1 2 3
    (single valid subsequence), 0 2 3 5 0 2 3 5 (repeated valid
    subsequence), 1 1 1 1 (repeated valid subsequence).  The following
    sequences are invalid: 0 3 2 1 (invalid subsequence), 0 2 3 5 0 2 3
    (incompletely repeated subsequence).  Some versions of the PCI230+ and
    PCI260+ have a bug that requires a subsequence longer than one entry
    long to include channel 0.
  AO Subdevice:
    The AO subdevice has 2 channels with 12-bit resolution.
    The following output ranges are supported:
      0 => [0, 10] V
      1 => [-10, +10] V
  AO Commands:
    +=========+==============+===========+============+==========+
    |start_src|scan_begin_src|convert_src|scan_end_src| stop_src |
    +=========+==============+===========+============+==========+
    |TRIG_INT | TRIG_TIMER(1)| TRIG_NOW  | TRIG_COUNT |TRIG_NONE |
    |         | TRIG_EXT(2)  |           |            |TRIG_COUNT|
    |         | TRIG_INT     |           |            |          |
    +---------+--------------+-----------+------------+----------+
    Note 1: If AI command and AO command are used simultaneously, only
            one may have scan_begin_src == TRIG_TIMER.
    Note 2: scan_begin_src == TRIG_EXT is only supported if the card is
            configured as a PCI230+ and is only supported on later
            versions of the card.  As a card configured as a PCI230+ is
            not guaranteed to support external triggering, please consider
            this support to be a bonus.  It uses the EXTTRIG EXTCONVCLK
            input (PCI230+ pin 25).  Triggering will be on the rising edge
            unless the CR_INVERT flag is set in scan_begin_arg.
    The channels in the channel sequence must be in ascending order with
    no repeats.  All entries in the channel sequence must use the same
    output range.
  DIO Subdevice:
    The DIO subdevice is a 8255 chip providing 24 DIO channels.  The DIO
    channels are configurable as inputs or outputs in four groups:
      Port A  - channels  0 to  7
      Port B  - channels  8 to 15
      Port CL - channels 16 to 19
      Port CH - channels 20 to 23
    Only mode 0 of the 8255 chip is supported.
    Bit 0 of port C (DIO channel 16) is also used as an external scan
    trigger input for AI commands on PCI230 and PCI230+, so would need to
    be configured as an input to use it for that purpose.
  Extra triggered scan functionality, interrupt bug-fix added by Steve
  Sharples.  Support for PCI230+260+, more triggered scan functionality,
  and workarounds for (or detection of) various hardware problems added
  by Ian Abbott.
  PCI230 PCI configuration register information
  PCI230 io space 1 registers.
 User PPI (82C55) base 
 User PPI (82C55) port A 
 User PPI (82C55) port B 
 User PPI (82C55) port C 
 User PPI (82C55) control word 
 82C54 countertimer base 
 Group Z Clock Configuration 
 Group Z Gate Configuration 
 Interrupt source mask (w) 
 Interrupt status (r) 
  PCI230 io space 2 registers.
 DAC control 
 DAC channel 0 (w) 
 DAC channel 1 (w) (not FIFO mode) 
 ADC data (r) 
 ADC software trigger (w) 
 ADC control 
 ADC channel enable bits 
 ADC gain control bits 
 PCI230+ io space 2 additional registers. 
 ADC start acquisition trigger 
 ADC analog trigger threshold 
 ADC FIFO interrupt threshold 
 ADC FIFO level (r) 
 ADC pre-trigger sample count (r) 
 ADC analog trigger hysteresys 
 Extended functions 
 Hardware version (r) 
 PCI230+ hardware version 2 onwards. 
 DAC data (FIFO mode) (w) 
 DAC soft trigger (FIFO mode) (r) 
 DAC channel enable (FIFO mode) 
  DACCON read-write values.
 Output unipolar 
 Output bipolar 
  The following applies only if DAC FIFO support is enabled in the EXTFUNC
  register (and only for PCI230+ hardware version 2 onwards).
 FIFO enable 
  The following apply only if the DAC FIFO is enabled (and only for PCI230+
  hardware version 2 onwards).
 none 
 soft trig 
 ext + edge 
 ext - edge 
 Z2 CT0 out 
 Z2 CT1 out 
 Z2 CT2 out 
 FIFO wraparound mode 
 empty 
 !empty 
 !half 
 half 
 !full 
 full 
  DACCON read-only values.
 DAC busy. 
  The following apply only if the DAC FIFO is enabled (and only for PCI230+
  hardware version 2 onwards).
 Underrun error 
 FIFO empty 
 FIFO full 
 FIFO half full 
  DACCON write-only, transient values.
  The following apply only if the DAC FIFO is enabled (and only for PCI230+
  hardware version 2 onwards).
 Clear underrun 
 FIFO reset 
  PCI230+ hardware version 2 DAC FIFO levels.
 Free space in DAC FIFO. 
  ADCCON readwrite values.
 none 
 soft trig 
 ext + edge 
 ext - edge 
 Z2 CT0 out
 Z2 CT1 out 
 Z2 CT2 out 
 Input unipolar 
 Input bipolar 
 single ended 
 differential 
 FIFO enable 
 empty 
 !empty 
 !half 
 half 
 !full 
 full 
 threshold 
  ADCCON write-only, transient values.
 FIFO reset 
 Global reset 
  ADCCON read-only values.
 ADC busy 
 FIFO empty 
 FIFO full 
 FIFO half full 
 FIFO overrun occurred 
  PCI230 ADC FIFO levels.
 Value for FIFO half full 
 FIFO size 
  PCI230+ EXTFUNC values.
 Route EXTTRIG pin to external gate inputs. 
 PCI230+ hardware version 2 values. 
 Allow DAC FIFO to be enabled. 
  Countertimer clock input configuration sources.
 reserved (channel-specific clock) 
 internal 10 MHz clock 
 internal 1 MHz clock 
 internal 100 kHz clock 
 internal 10 kHz clock 
 internal 1 kHz clock 
 output of channel-1 modulo total 
 external clock 
  Countertimer gate input configuration sources.
 VCC (i.e. enabled) 
 GND (i.e. disabled) 
 external gate input (PPCn on PCI230) 
 inverted output of channel-2 modulo total 
  Summary of CLK_OUTNM1 and GAT_NOUTNM2 connections for PCI230 and PCI260:
               Channel's       Channel's
               clock input     gate input
  Channel      CLK_OUTNM1      GAT_NOUTNM2
  -------      ----------      -----------
  Z2-CT0       Z2-CT2-OUT      Z2-CT1-OUT
  Z2-CT1       Z2-CT0-OUT      Z2-CT2-OUT
  Z2-CT2       Z2-CT1-OUT      Z2-CT0-OUT
  Interrupt enablesstatus register values.
 For PCI230+ hardware version 2 when DAC FIFO enabled. 
  (Potentially) shared resources and their owners
 Z2-CT0 
 Z2-CT1 
 Z2-CT2 
 Owned by AI command 
 Owned by AO command 
 Number of owners 
  Handy macros.
 Combine old and new bits. 
 Current CPU.  XXX should this be hard_smp_processor_id()? 
  Board descriptions for the two boards supported.
 Minimum hardware version supported. 
 Interrupt spin lock 
 Shared resources spin lock 
 Spin lock for stopping AI command 
 Spin lock for stopping AO command 
 PCI230's DAQ IO space 
 ID of CPU running ISR 
 Hardware version (for '+' models) 
 ADCCON register value 
 DACCON register value 
 ADC FIFO threshold (PCI230+260+) 
 ADCG register value 
 Interrupt enable bits 
 Owned resources 
 Flag set in interrupt routine 
 Flag AI range is bipolar 
 Flag AO range is bipolar 
 Flag AI command started 
 Flag AO command started 
 PCI230 clock source periods in ns 
 PCI230 analogue input range table 
 PCI230 analogue gain bits for each input range. 
 PCI230 analogue output range table 
 Read sample. 
	
	  PCI230 is 12 bit - stored in upper bits of 16 bit register
	  (lower four bits reserved for expansion).  PCI230+ is 16 bit AI.
	 
	  If a bipolar range was specified, mangle it
	  (twos complement->straight binary).
	
	  PCI230 is 12 bit - stored in upper bits of 16 bit register (lower
	  four bits reserved for expansion).  PCI230+ is also 12 bit AO.
	
	  If a bipolar range was specified, mangle it
	  (straight binary->twos complement).
 Write mangled datum to appropriate DACOUT register. 
 Write mangled datum to appropriate DACDATA register. 
  Given desired period in ns, returns the required internal clock source
  and gets the initial count.
 Set mode. 
 Determine clock source and count. 
 Program clock source. 
 Set initial count. 
 Counter ct, 8254 mode 1, initial count not written. 
 Unpack channel and range. 
 Differential. 
	
	  Use Z2-CT2 as a conversion trigger instead of the built-in
	  software trigger, as otherwise triggering of differential channels
	  doesn't work properly for some versions of PCI230260.  Also set
	  FIFO mode because the ADC busy bit only works for software triggers.
 Set Z2-CT2 output low to avoid any false triggers. 
 Differential. 
			
			  Original PCI230260 expects both inputs of the
			  differential channel to be enabled.
			
			  PCI230+260+ expects only one input of the
			  differential channel to be enabled.
 Single ended. 
	
	  Enable only this channel in the scan list - otherwise by default
	  we'll get one sample from each channel.
 Set gain for channel. 
 Specify unibip, sediff, conversion source, and reset FIFO. 
 Convert n samples 
		
		  Trigger conversion by toggling Z2-CT2 output
		  (finish with output high).
 wait for conversion to end 
 read data 
 return the number of samples readwritten 
	
	  Set range - see analogue output range table; 0 => unipolar 10V,
	  1 => bipolar +-10V range scale
 Step 1 : check if triggers are trivially valid 
		
		  For PCI230+ hardware version 2 onwards, allow external
		  trigger from EXTTRIGEXTCONVCLK input (PCI230+ pin 25).
		 
		  FIXME: The permitted scan_begin_src values shouldn't depend
		  on devpriv->hwver (the detected card's actual hardware
		  version).  They should only depend on board->min_hwver
		  (the static capabilities of the configured card).  To fix
		  it, a new card model, e.g. "pci230+2" would have to be
		  defined with min_hwver set to 2.  It doesn't seem worth it
		  for this alone.  At the moment, please consider
		  scan_begin_src==TRIG_EXT support to be a bonus rather than a
		  guarantee!
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 8000 ns => 125 kHz 
  Comedi limit due to unsigned int cmd.  Driver limit =
  2^16 (16bit  counter)  1000000ns (1kHz onboard clock) = 65.536s
 4294967295ns = 4.29s 
		
		  External trigger - for PCI230+ hardware version 2 onwards.
 Trigger number must be 0. 
		
		  The only flags allowed are CR_EDGE and CR_INVERT.
		  The CR_EDGE flag is ignored.
 TRIG_NONE 
 Step 4: fix up any arguments 
 Step 5: check channel list if it exists 
 Stop scan rate generator. 
 Determine interrupt source. 
 Not using DAC FIFO.  Using CT1 interrupt. 
 Using DAC FIFO interrupt. 
	
	  Disable interrupt and wait for interrupt routine to finish running
	  unless we are called from the interrupt routine.
		
		  Using DAC FIFO.  Reset FIFO, clear underrun error,
		  disable FIFO.
 Release resources. 
  Loads DAC FIFO (if using it) from buffer.
  Returns false if AO finished due to completion or error, true if still going.
 Get DAC FIFO status. 
 Check for FIFO underrun. 
		
		  Check for buffer underrun if FIFO less than half full
		  (otherwise there will be loads of "DAC FIFO not half full"
		  interrupts).
 Determine how much room is in the FIFO (in samples). 
 Convert room to number of scans that can be added. 
 Determine number of scans to process. 
 Process scans. 
			
			  All data for the command has been written
			  to FIFO.  Set FIFO interrupt trigger level
			  to 'empty'.
 Check if FIFO underrun occurred while writing to FIFO. 
 Perform scan. 
 Not using DAC FIFO. 
 Using DAC FIFO. 
 Read DACSWTRIG register to trigger conversion. 
 Delay.  Should driver be responsible for this? 
 XXX TODO: See if DAC busy bit can be used. 
 Using DAC FIFO. 
 Preload FIFO data. 
 Stopped. 
 Set scan trigger source. 
 Trigger on EXTTRIGEXTCONVCLK pin. 
 +ve edge 
 -ve edge 
 Shouldn't get here. 
 Not using DAC FIFO. 
 Enable CT1 timer interrupt. 
 Set CT1 gate high to start counting. 
 Using DAC FIFO.  Enable DAC FIFO interrupt. 
 Get the command. 
 Claim Z2-CT1. 
	
	  Set range - see analogue output range table; 0 => unipolar 10V,
	  1 => bipolar +-10V range scale
 Use DAC FIFO for hardware version 2 onwards. 
 Set channel scan list. 
		
		  Enable DAC FIFO.
		  Set DAC scan source to 'none'.
		  Set DAC FIFO interrupt trigger level to 'not half full'.
		  Reset DAC FIFO and clear underrun.
		 
		  N.B. DAC FIFO interrupts are currently disabled.
 Set DACCON. 
 Preserve most of DACCON apart from write-only, transient bits. 
		
		  Set the counter timer 1 to the specified scan frequency.
		  cmd->scan_begin_arg is sampling period in ns.
		  Gate it off for now.
 N.B. cmd->start_src == TRIG_INT 
 Arithmetic overflow. 
			
			  Channel numbers must strictly increase or
			  subsequence must repeat exactly.
	
	  Buggy PCI230+ or PCI260+ requires channel 0 to be (first) in the
	  sequence if the sequence contains more than one channel. Hardware
	  versions 1 and 2 have the bug. There is no hardware version 3.
	 
	  Actually, there are two firmwares that report themselves as
	  hardware version 1 (the boards have different ADC chips with
	  slightly different timing requirements, which was supposed to
	  be invisible to software). The first one doesn't seem to have
	  the bug, but the second one does, and we can't tell them apart!
 Step 1 : check if triggers are trivially valid 
		
		  Unfortunately, we cannot trigger a scan off an external
		  source on the PCI260 board, since it uses the PPIC0 (DIO)
		  input, which isn't present on the PCI260.  For PCI260+
		  we can use the EXTTRIGEXTCONVCLK input on pin 17 instead.
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
	
	  If scan_begin_src is not TRIG_FOLLOW, then a monostable will be
	  set up to generate a fixed number of timed conversion pulses.
 Step 3: check if arguments are trivially valid 
 PCI230 SE:   3200 ns => 312.5 kHz 
 PCI230 DIFF: 8000 ns => 125 kHz 
 PCI230+:     4000 ns => 250 kHz 
  Comedi limit due to unsigned int cmd.  Driver limit =
  2^16 (16bit  counter)  1000000ns (1kHz onboard clock) = 65.536s
 4294967295ns = 4.29s 
			
			  PCI230 or PCI260.  Max speed depends whether
			  single-ended or pseudo-differential.
 Peek analogue reference of first channel. 
 No channel list.  Assume single-ended. 
 PCI230+ or PCI260+. 
		
		  external trigger
		 
		  convert_arg == (CR_EDGE | 0)
		                 => trigger on +ve edge.
		  convert_arg == (CR_EDGE | CR_INVERT | 0)
		                 => trigger on -ve edge.
 Trigger number must be 0. 
			
			  The only flags allowed are CR_INVERT and CR_EDGE.
			  CR_EDGE is required.
 Set CR_EDGE, preserve CR_INVERT. 
			
			  Backwards compatibility with previous versions:
			  convert_arg == 0 => trigger on -ve edge.
			  convert_arg == 1 => trigger on +ve edge.
 TRIG_NONE 
		
		  external "trigger" to begin each scan:
		  scan_begin_arg==0 => use PPC0 input -> gate of CT0 -> gate
		  of CT2 (sample convert trigger is CT2)
 The only flag allowed is CR_EDGE, which is ignored. 
 N.B. cmd->convert_arg is also TRIG_TIMER 
 Step 4: fix up any arguments 
 N.B. cmd->convert_arg is also TRIG_TIMER 
 Was below minimum required.  Round up. 
 Step 5: check channel list if it exists 
 PCI230+260+ programmable FIFO interrupt level. 
	
	  Trigger conversion by toggling Z2-CT2 output.
	  Finish with output high.
	
	  Delay.  Should driver be responsible for this?  An
	  alternative would be to wait until conversion is complete,
	  but we can't tell when it's complete because the ADC busy
	  bit has a different meaning when FIFO enabled (and when
	  FIFO not enabled, it only works for software triggers).
 PCI230260 in differential mode 
 single-ended or PCI230+260+ 
 Trigger scan by waggling CT0 gate source. 
 Stop conversion rate generator. 
 Stop scan period monostable. 
	
	  Disable ADC interrupt and wait for interrupt routine to finish
	  running unless we are called from the interrupt routine.
	
	  Reset FIFO, disable FIFO and set start conversion source to none.
	  Keep sediff and bipuni settings.
 Release resources. 
 Enable ADC FIFO trigger level interrupt. 
	
	  Update conversion trigger source which is currently set
	  to CT2 output, which is currently stuck high.
 Using CT2 output. 
 Trigger on +ve edge. 
 Trigger on -ve edge. 
 Backwards compatibility. 
 Trigger on +ve edge. 
 Trigger on -ve edge. 
		
		  Use CT2 output for software trigger due to problems
		  in differential mode on PCI230260.
	
	  Update FIFO interrupt trigger level, which is currently
	  set to "full".
 Update timer gates. 
			
			  Conversion timer CT2 needs to be gated by
			  inverted output of monostable CT2.
			
			  Conversion timer CT2 needs to be gated on
			  continuously.
 Set monostable CT0 trigger source. 
				
				  For CT0 on PCI230, the external trigger
				  (gate) signal comes from PPC0, which is
				  channel 16 of the DIO subdevice.  The
				  application needs to configure this as an
				  input in order to use it as an external scan
				  trigger.
				
				  Monostable CT0 triggered by rising edge on
				  inverted output of CT1 (falling edge on CT1).
				
				  Monostable CT0 is triggered by inttrig
				  function waggling the CT0 gate source.
				
				  Scan period timer CT1 needs to be
				  gated on to start counting.
 No longer need Z2-CT2. 
 Determine number of samples to read. 
 Read FIFO state. 
				
				  Report error otherwise FIFO overruns will go
				  unnoticed by the caller.
 FIFO empty. 
 FIFO half full. 
 Read PCI230+260+ ADC FIFO level. 
 Shouldn't happen. 
 FIFO not empty. 
 update FIFO interrupt trigger level if still running 
 Get the command. 
	
	  Determine which shared resources are needed.
	
	  Need Z2-CT2 to supply a conversion trigger source at a high
	  logic level, even if not doing timed conversions.
 Using Z2-CT0 monostable to gate Z2-CT2 conversion timer 
 Using Z2-CT1 for scan frequency 
 Claim resources. 
	
	  Steps:
	  - Set channel scan list.
	  - Set channel gains.
	  - Enable and reset FIFO, specify unibip, sediff, and set
	    start conversion source to point to something at a high logic
	    level (we use the output of countertimer 2 for this purpose.
	  - PAUSE to allow things to settle down.
	  - Reset the FIFO again because it needs resetting twice and there
	    may have been a false conversion trigger on some versions of
	    PCI230260 due to the start conversion source being set to a
	    high logic level.
	  - Enable ADC FIFO level interrupt.
	  - Set actual conversion trigger source and FIFO interrupt trigger
	    level.
	  - If convert_src is TRIG_TIMER, set up the timers.
 Differential - all channels must be differential. 
 Single ended - all channels must be single-ended. 
				
				  Original PCI230260 expects both inputs of
				  the differential channel to be enabled.
				
				  PCI230+260+ expects only one input of the
				  differential channel to be enabled.
 Set channel scan list. 
 Set channel gains. 
	
	  Set countertimer 2 output high for use as the initial start
	  conversion source.
	
	  Temporarily use CT2 output as conversion trigger source and
	  temporarily set FIFO interrupt trigger level to 'full'.
	
	  Enable and reset FIFO, specify FIFO trigger level full, specify
	  unibip, sediff, and temporarily set the start conversion source
	  to CT2 output.  Note that CT2 output is currently high, and this
	  will produce a false conversion trigger on some versions of the
	  PCI230260, but that will be dealt with later.
	
	  Delay -
	  Failure to include this will result in the first few channels'-worth
	  of data being corrupt, normally manifesting itself by large negative
	  voltages. It seems the board needs time to settle between the first
	  FIFO reset (above) and the second FIFO reset (below). Setting the
	  channel gains and scan list _before_ the first FIFO reset also
	  helps, though only slightly.
 Reset FIFO again. 
		
		  Set up CT2 as conversion timer, but gate it off for now.
		  Note, countertimer output 2 can be monitored on the
		  connector: PCI230 pin 21, PCI260 pin 18.
 Set countertimer 2 to the specified conversion period. 
			
			  Set up monostable on CT0 output for scan timing.  A
			  rising edge on the trigger (gate) input of CT0 will
			  trigger the monostable, causing its output to go low
			  for the configured period.  The period depends on
			  the conversion period and the number of conversions
			  in the scan.
			 
			  Set the trigger high before setting up the
			  monostable to stop it triggering.  The trigger
			  source will be changed later.
				
				  Monostable on CT0 will be triggered by
				  output of CT1 at configured scan frequency.
				 
				  Set up CT1 but gate it off for now.
 TRIG_NOW 
 Interrupt handler 
 Read interrupt statusenable register. 
	
	  Disable triggered interrupts.
	  (Only those interrupts that need re-enabling, are, later in the
	  handler).
	
	  Check the source of interrupt and handle it.
	  The PCI230 can cope with concurrent ADC, DAC, PPI C0 and C3
	  interrupts.  However, at present (Comedi-0.7.60) does not allow
	  concurrent execution of commands, instructions or a mixture of the
	  two.
 Reenable interrupts. 
 Check if PCI device matches a specific board. 
 assume pci_dev->device != PCI_DEVICE_ID_INVALID 
 Looking for a '+' model.  First check length of registers. 
 Not a '+' model. 
	
	  TODO: temporarily enable PCI device and read the hardware version
	  register.  For now, assume it's okay.
 Look for board matching PCI device. 
	
	  Read base addresses of the PCI230's two IO regions from PCI
	  configuration register.
 Read bits of DACCON register - only the output range. 
	
	  Read hardware version register and set extended function register
	  if they exist.
				
				  No DIO ports.  Route counters' external gates
				  to the EXTTRIG signal (PCI260+ pin 17).
				  (Otherwise, they would be routed to DIO
				  inputs PC0, PC1 and PC2 which don't exist
				  on PCI260[+].)
 Enable DAC FIFO functionality. 
			
			  Temporarily enable DAC FIFO, reset it and disable
			  FIFO wraparound.
 Clear DAC FIFO channel enable register. 
 Disable DAC FIFO. 
 Disable board's interrupts. 
 Set ADC to a reasonable state. 
 analog input subdevice 
 but there are restrictions. 
 analog output subdevice 
 digital io subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  fl512.c
  Anders Gnistrup <ex18@kalman.iau.dtu.dk>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: fl512
  Description: unknown
  Author: Anders Gnistrup <ex18@kalman.iau.dtu.dk>
  Devices: [unknown] FL512 (fl512)
  Status: unknown
  Digital IO is not supported.
  Configuration options:
    [0] - IO port base address
  Register IO map
 XXX should test "done" flag instead of delay 
 write LSB, MSB then trigger conversion 
 Analog Input subdevice 
 Analog Output subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  Comedi driver for NI PCMCIA MIO E series cards
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1997-2000 David A. Schleef <ds@schleef.org>
  Driver: ni_mio_cs
  Description: National Instruments DAQCard E series
  Author: ds
  Status: works
  Devices: [National Instruments] DAQCard-AI-16XE-50 (ni_mio_cs),
    DAQCard-AI-16E-4, DAQCard-6062E, DAQCard-6024E, DAQCard-6036E
  Updated: Thu Oct 23 19:43:17 CDT 2003
  See the notes in the ni_atmio.o driver.
  The real guts of the driver is in ni_mio_common.c, which is
  included by all the E series drivers.
  References for specifications:
 	341080a.pdf  DAQCard E Series Register Level Programmer Manual
   AT specific setup
 verified 
 verified 
 specs incorrect! 
 specs incorrect! 
 unknown 
 DAQCard-ai-16xe-50 
 DAQCard-ai-16e-4 
 DAQCard-6062E 
 DAQCard-6024E 
 DAQCard-6036E 
 SPDX-License-Identifier: GPL-2.0+
  comedidriversni_labpc_common.c
  Common support code for "ni_labpc", "ni_labpc_pci" and "ni_labpc_cs".
  Copyright (C) 2001-2003 Frank Mori Hess <fmhess@users.sourceforge.net>
  functions that do inboutb and readbwriteb so we can use
  function pointers to decide which to use
		
		  The LabPC-1200 boards do not have a gain
		  of '0x10'. Skip the range values that would
		  result in this gain.
 munge channel bits for differentialscan disabled mode 
 reference inputs to ground or common? 
 bipolar or unipolar range? 
  interrupt on fifo half full? 
 enable interrupt on counter a1 terminal count? 
 are we scanning up or down through channels? 
 disable timed conversions, interrupt generation and dma 
 setup cmd4 register 
 single-endeddifferential 
 initialize pacer counter to prevent any problems 
 trigger conversion 
 figures out what counter values to use based on command 
	
	  If both convert and scan triggers are TRIG_TIMER, then they
	  both rely on counter b0. If only one TRIG_TIMER is used, we
	  can use the generic cascaded timing functions.
		
		  pick the lowest divisor value we can (for maximum input
		  clock speed on convert and scan counters)
  set a0 for conversion frequency and b1 for scan frequency 
  make sure a0 and b1 values are acceptable 
  write corrected timings to command 
		
		  calculate cascaded counter values
		  that give desired scan timing
		  (pacer->next_div2  pacer->next_div1)
		
		  calculate cascaded counter values
		  that give desired conversion timing
		  (pacer->next_div  pacer->next_div1)
 transfer div2 value so correct timer gets updated 
 chanlist may be NULL during cmdtest 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 can't have external stop and start triggers at once 
 Step 3: check if arguments are trivially valid 
 start_arg value is ignored 
 make sure scan timing is not too fast 
		
		  TRIG_EXT doesn't care since it doesn't
		  trigger off a numbered channel
 step 4: fix up any arguments 
 Step 5: check channel list if it exists 
 make sure board is disabled before setting up acquisition 
  initialize software conversion count 
  setup hardware conversion counter 
		
		  load counter a1 with count of 3
		  (pc+ manual says this is minimum allowed) using mode 0
 just put counter a1 in mode 0 to set its output low 
 figure out what method we will use to transfer data 
		
		  dma unsafe at RT priority,
		  and too much setup time for CMDF_WAKE_EOS
		
		  pc-plus has no fifo-half full interrupt
		  wake-end-of-scan should interrupt on fifo not empty
		  make sure we are taking more than just a few points
 manual says to set scan enable bit on second pass 
		
		  Need a brief delay before enabling scan, or scan
		  list will get screwed when you switch between
		  scan up to scan down mode - dunno why.
  load count 
 set up pacing 
 set up conversion pacing 
 set up scan pacing 
  enable error interrupts 
  enable fifo not empty interrupt? 
  setup any external triggeringpacing (cmd4 register) 
	
	  XXX should discard first scan when using interval scanning
	  since manual says it is not synced with scan clock.
  single-endeddifferential 
  startup acquisition 
 use 2 cascaded counters for pacing 
 read all available samples from ai fifo 
  quit if we have all the data we want 
  Makes sure all data acquired by board is transferred to comedi (used
  when acquisition is terminated by stop_src == TRIG_EXT).
 interrupt service routine 
 read board status 
 clear error interrupt 
  clear it 
  clear error interrupt 
  handle external stop trigger 
 TRIG_COUNT end of acquisition 
	
	  Turn off pacing of analog output channel.
	  NOTE: hardware bug in daqcard-1200 means pacing cannot
	  be independently enableddisabled for its the two channels.
 set range 
  write to register 
 send data 
 lowlevel write to eepromdac 
  clear serial clock 
  send bits most significant bit first 
  set clock to load bit 
 lowlevel read from eeprom 
  number of bits wide values are 
  set serial clock 
  clear clock bit 
  read bits most significant bit first 
  bits to tell eeprom to expect a read 
  8 bit write lengths to eeprom 
  enable readwrite to eeprom 
  send read instruction 
  send 8 bit address to read from 
  read result 
  disable readwrite to eeprom 
  8 bit write lengths to eeprom 
  enable readwrite to eeprom 
  send read status instruction 
  read result 
  disable readwrite to eeprom 
  8 bit write lengths to eeprom 
  enable readwrite to eeprom 
  send write_enable instruction 
  send write instruction 
  send 8 bit address to write to 
  write value 
  disable readwrite to eeprom 
 writes to 8 bit calibration dacs 
  clear caldac load bit and make sure we don't write to eeprom 
  write 4 bit channel 
  write 8 bit caldac value 
  set and clear caldac bit to load caldac value 
	
	  Only write the last data value to the caldac. Preceding
	  data would be overwritten anyway.
 make sure there isn't already a write in progress 
 only allow writes to user area of eeprom 
	
	  Only write the last data value to the eeprom. Preceding
	  data would be overwritten anyway.
 initialize board's command registers 
 analog input subdevice 
 analog output 
 initialize analog outputs to a known value 
 8255 dio 
  calibration subdevices for boards that have one 
 EEPROM (256 bytes) 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriversni_labpc_pci.c
  Driver for National Instruments Lab-PC PCI-1200
  Copyright (C) 2001, 2002, 2003 Frank Mori Hess <fmhess@users.sourceforge.net>
  Driver: ni_labpc_pci
  Description: National Instruments Lab-PC PCI-1200
  Devices: [National Instruments] PCI-1200 (ni_pci-1200)
  Author: Frank Mori Hess <fmhess@users.sourceforge.net>
  Status: works
  This is the PCI-specific support split off from the ni_labpc driver.
  Configuration Options: not applicable, uses PCI auto config
  NI manuals:
  340914a (pci-1200)
 ripped from mite.h and mite_setup2() to avoid mite dependency 
 IO Device Window Base Size Register 
 window enable 
 ioremap the MITE registers (BAR 0) temporarily 
 set data window to main registers (BAR 1) 
 finished with MITE registers 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  cb_das16_cs.c
  Driver for Computer Boards PC-CARD DAS1616.
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000, 2001, 2002 David A. Schleef <ds@schleef.org>
  PCMCIA support code for this driver is adapted from the dummy_cs.c
  driver of the Linux PCMCIA Card Services package.
  The initial developer of the original code is David A. Hinds
  <dahinds@users.sourceforge.net>.  Portions created by David A. Hinds
  are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.
  Driver: cb_das16_cs
  Description: Computer Boards PC-CARD DAS1616
  Devices: [ComputerBoards] PC-CARD DAS1616 (cb_das16_cs),
    PC-CARD DAS1616-AO
  Author: ds
  Updated: Mon, 04 Nov 2002 20:04:21 -0800
  Status: experimental
  Register IO map
 1=enable; 0=disable 
 interrupt src 
 ro - 1=FIFO overflow 
 AI convert src 
 ro - 0=busy; 1=ready 
 0=diff; 1=se 
 ro - 0=latched; 1=cleared 
 ro - current ai mux 
 wo - DAC1 chip select 
 wo - Serial DAC clock 
 wo - Serial DAC data 
 wo - DAC0 chip select 
 1=burst enable; 0=disable 
 AI gain 
 +-10V 
 +-5V 
 +-2.5V 
 +-1.25V 
 1=dio7:4 output; 0=input 
 1=dio3:0 output; 0=input 
 1=active lo; 0=hi 
 1=edge; 0=level 
 ro - 1=FIFO not empty 
 wo - 1=clr (monstable) 
 1=10 MHz; 0=1 MHz 
 1=int. 100 kHz; 0=ext. clk 
 1=enable; 0=disable 
 unknown 
 disable interrupts, software convert 
 raise the DACxCS line for the non-selected channel 
		
		  Make both DAC0CS and DAC1CS high to load
		  the new data and update analog the output
 internal 100 kHz 
 external 
 unknown 
 Analog Input subdevice 
 Analog Output subdevice 
 Digital IO subdevice 
 Counter subdevice (8254) 
 counters 1 and 2 are used internally for the pacer 
 SPDX-License-Identifier: GPL-2.0+
  comedidrivers8255.c
  Driver for 8255
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1998 David A. Schleef <ds@schleef.org>
  Driver: 8255
  Description: generic 8255 support
  Devices: [standard] 8255 (8255)
  Author: ds
  Status: works
  Updated: Fri,  7 Jun 2002 12:56:45 -0700
  The classic in digital IO.  The 8255 appears in Comedi as a single
  digital IO subdevice with 24 channels.  The channel 0 corresponds
  to the 8255's port A, bit 0; channel 23 corresponds to port C, bit
  7.  Direction configuration is done in blocks, with channels 0-7,
  8-15, 16-19, and 20-23 making up the 4 blocks.  The only 8255 mode
  supported is mode 0.
  You should enable compilation this driver if you plan to use a board
  that has an 8255 chip.  For multifunction boards, the main driver will
  configure the 8255 subdevice automatically.
  This driver also works independently with ISA and PCI cards that
  directly map the 8255 registers to IO ports, including cards with
  multiple 8255 chips.  To configure the driver for such a card, the
  option list should be a list of the IO port bases for each of the
  8255 chips.  For example,
    comedi_config devcomedi0 8255 0x200,0x204,0x208,0x20c
  Note that most PCI 8255 boards do NOT work with this driver, and
  need a separate driver as a wrapper.  For those that do work, the
  IO port base address can be found in the output of 'lspci -v'.
		
		  __comedi_request_region() does not set dev->iobase.
		 
		  For 8255 devices that are manually attached using
		  comedi_config, the 'iobase' is the actual IO port
		  base address of the chip.
				
				  Release the IO port region here, as the
				  "detach" handler cannot find it.
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  me4000.c
  Source code for the Meilhaus ME-4000 board family.
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: me4000
  Description: Meilhaus ME-4000 series boards
  Devices: [Meilhaus] ME-4650 (me4000), ME-4670i, ME-4680, ME-4680i,
 	    ME-4680is
  Author: gg (Guenter Gebhardt <g.gebhardt@meilhaus.com>)
  Updated: Mon, 18 Mar 2002 15:34:01 -0800
  Status: untested
  Supports:
 	- Analog Input
 	- Analog Output
 	- Digital IO
 	- Counter
  Configuration Options: not applicable, uses PCI auto config
  The firmware required by these boards is available in the
  comedi_nonfree_firmware tarball available from
  https:www.comedi.org.
  ME4000 Register map and bit defines
 sample & hold (8 channels) 
  NOTE: the ranges here are inverted compared to the values
  written to the ME4000_AI_CHANNEL_LIST_REG,
  The ME4000_AI_LIST_RANGE() macro handles the inversion.
	
	  Set PLX local interrupt 2 polarity to high.
	  Interrupt is thrown by init pin of xilinx.
 Set CS and WRITE of the Xilinx 
 Init Xilinx with CS1 
 Wait until INIT pin is set 
 Reset CS and WRITE of the Xilinx 
 Download Xilinx firmware 
 Check if BUSY flag is low 
 If done flag is high download was successful 
 Set CS and WRITE 
 Stop any running conversion 
 Clear the control register 
 Disable interrupts on the PLX 
 Software reset the PLX 
 0x8000 to the DACs means an output voltage of 0V 
 Set both stop bits in the analog output control register 
 Set the adustment register for AO demux 
	
	  Set digital IO direction for port 0
	  to output on isolated versions
 read two's complement value and munge to offset binary 
 Enable channel list and data fifo for single acquisition mode 
 Generate channel list entry 
 Set the timer to maximum sample rate 
 start conversion by dummy read 
 Write timer arguments 
 Start sources 
 Stop triggers 
 Write the setup to the control register 
 Write the channel list 
 Start acquistion by dummy read 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 Round the timer arguments 
 TRIG_NONE 
	
	  Stage 4. Check for argument conflicts.
 Check timer arguments 
  66 ticks at least 
  66 ticks at least 
  At least one tick more 
 Check timer arguments 
  66 ticks at least 
  66 ticks at least 
 Check timer arguments 
  66 ticks at least 
  66 ticks at least 
  At least one tick more 
 Check timer arguments 
  66 ticks at least 
  66 ticks at least 
 Check timer arguments 
  66 ticks at least 
  66 ticks at least 
 Check timer arguments 
  66 ticks at least 
 Step 5: check channel list if it exists 
 Read status register to find out what happened 
 Work is done, so reset the interrupt 
 Acquisition is complete 
 Poll data until fifo empty 
 Work is done, so reset the interrupt 
 Stop any running conversion 
 Clear control register and set to single mode 
 Write data value 
 Store in the mirror 
	
	  Check for optoisolated ME-4000 version.
	  If one the first port is a fixed output
	  port and the second is a fixed input port.
 Enable interrupts on the PLX 
 Analog Input subdevice 
 Analog Output subdevice 
 Digital IO subdevice 
	
	  Check for optoisolated ME-4000 version. If one the first
	  port is a fixed output port and the second is a fixed input port.
 Counter subdevice (8254) 
 Disable interrupts on the PLX 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  das16.c
  DAS16 driver
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Copyright (C) 2000 Chris R. Baugher <baugher@enteract.com>
  Copyright (C) 2001,2002 Frank Mori Hess <fmhess@users.sourceforge.net>
  Driver: das16
  Description: DAS16 compatible boards
  Author: Sam Moore, Warren Jasper, ds, Chris Baugher, Frank Hess, Roman Fietze
  Devices: [Keithley Metrabyte] DAS-16 (das-16), DAS-16G (das-16g),
    DAS-16F (das-16f), DAS-1201 (das-1201), DAS-1202 (das-1202),
    DAS-1401 (das-1401), DAS-1402 (das-1402), DAS-1601 (das-1601),
    DAS-1602 (das-1602),
    [ComputerBoards] PC104-DAS16JR (pc104-das16jr),
    PC104-DAS16JR16 (pc104-das16jr16), CIO-DAS16 (cio-das16),
    CIO-DAS16F (cio-das16f), CIO-DAS16JR (cio-das16jr),
    CIO-DAS16JR16 (cio-das16jr16), CIO-DAS140112 (cio-das140112),
    CIO-DAS140212 (cio-das140212), CIO-DAS140216 (cio-das140216),
    CIO-DAS160112 (cio-das160112), CIO-DAS160212 (cio-das160212),
    CIO-DAS160216 (cio-das160216), CIO-DAS16330 (cio-das16330)
  Status: works
  Updated: 2003-10-12
  A rewrite of the das16 and das1600 drivers.
  Options:
 	[0] - base io address
 	[1] - irq (does nothing, irq is not used anymore)
 	[2] - dma channel (optional, required for comedi_command support)
 	[3] - master clock speed in MHz (optional, 1 or 10, ignored if
 		board can probe clock, defaults to 1)
 	[4] - analog input range lowest voltage in microvolts (optional,
 		only useful if your board does not have software
 		programmable gain)
 	[5] - analog input range highest voltage in microvolts (optional,
 		only useful if board does not have software programmable
 		gain)
 	[6] - analog output range lowest voltage in microvolts (optional)
 	[7] - analog output range highest voltage in microvolts (optional)
  Passing a zero for an option is the same as leaving it unspecified.
  Testing and debugging help provided by Daniel Koch.
  Keithley Manuals:
 	2309.PDF (das16)
 	4919.PDF (das1400, 1600)
 	4922.PDF (das-1400)
 	4923.PDF (das1200, 1400, 1600)
  Computer boards manuals also available from their website
  www.measurementcomputing.com
  size in bytes of allocated dma buffer 
  Register IO map
 to 0x0f 
  max conversion speed in nanosec 
  Period for timer interrupt in jiffies.  It's a function
  to deal with possibility of dynamic HZ patches
	
	  Determine dma size based on the buffer size plus the number of
	  unread samples and the number of samples remaining in the command.
	
	  The pc104-das16jr (at least) has problems if the dma
	  transfer is interrupted in the middle of transferring
	  a 16 bit sample.
 figure out how many samples to read 
 restart DMA if more samples are needed 
 set multiplexer 
 some boards do not have programmable gain 
	
	  Set gain (this is also burst rate register but according to
	  computer boards manual, burst rate does nothing, even on
	  keithley cards).
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
  make sure scan_begin_src and convert_src don't conflict 
 Step 3: check if arguments are trivially valid 
 internal trigger 
 check against maximum frequency 
 TRIG_NONE 
  step 4: fix up arguments 
 Step 5: check channel list if it exists 
 set mux and range for chanlist scan 
 set counter mode and counts 
 enable counters 
  set burst length 
 set up dma transfer 
  set up timer 
 enable DMA interrupt with external or internal pacing 
 disable interrupts, dma and pacer clocked conversions 
  disable SW timer 
 set mux and range for single channel 
 trigger conversion 
 diobits indicates boards 
 only DMA channels 3 and 1 are valid 
 DMA uses two buffers 
 get any user-defined input range 
 allocate single-range range table 
 initialize ai range 
 use software programmable range 
 get any user-defined output range 
 allocate single-range range table 
 initialize ao range 
  check that clock setting is valid 
 Request an additional region for the 8255 
  probe id bits to make sure they are consistent 
  get master clock speed 
 Analog Input subdevice 
 Analog Output subdevice 
 Digital Input subdevice 
 Digital Output subdevice 
 initialize digital output lines 
 8255 Digital IO subdevice 
 set the interrupt level 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  Driver for Amplicon PC263 relay board.
  Copyright (C) 2002 MEV Ltd. <https:www.mev.co.uk>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: amplc_pc263
  Description: Amplicon PC263
  Author: Ian Abbott <abbotti@mev.co.uk>
  Devices: [Amplicon] PC263 (pc263)
  Updated: Fri, 12 Apr 2013 15:19:36 +0100
  Status: works
  Configuration options:
    [0] - IO port base address
  The board appears as one subdevice, with 16 digital outputs, each
  connected to a reed-relay. Relay contacts are closed when output is 1.
  The state of the outputs can be read.
 PC263 registers 
 Digital Output subdevice 
 read initial relay state 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  Comedi driver for NI AT-MIO E series cards
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1997-2001 David A. Schleef <ds@schleef.org>
  Driver: ni_atmio
  Description: National Instruments AT-MIO-E series
  Author: ds
  Devices: [National Instruments] AT-MIO-16E-1 (ni_atmio),
    AT-MIO-16E-2, AT-MIO-16E-10, AT-MIO-16DE-10, AT-MIO-64E-3,
    AT-MIO-16XE-50, AT-MIO-16XE-10, AT-AI-16XE-10
  Status: works
  Updated: Thu May  1 20:03:02 CDT 2003
  The driver has 2.6 kernel isapnp support, and will automatically probe for
  a supported board if the IO base is left unspecified with comedi_config.
  However, many of the isapnp id numbers are unknown. If your board is not
  recognized, please send the output of 'cat procisapnp' (you may need to
  modprobe the isa-pnp module for procisapnp to exist) so the id numbers
  for your board can be added to the driver.
  Otherwise, you can use the isapnptools package to configure your board.
  Use isapnp to configure the IO base and IRQ for the board, and then pass
  the same values as parameters in comedi_config. A sample isapnp.conf file
  is included in the etc directory of Comedilib.
  Comedilib includes a utility to autocalibrate these boards. The boards
  seem to boot into a state where the all calibration DACs are at one
  extreme of their range, thus the default calibration is terrible.
  Calibration at boot is strongly encouraged.
  To use the extended digital IO on some of the boards, enable the
  8255 driver when configuring the Comedi source tree.
  External triggering is supported for some events. The channel index
  (scan_begin_arg, etc.) maps to PFI0 - PFI9.
  Some of the more esoteric triggering possibilities of these boards are
  not supported.
  The real guts of the driver is in ni_mio_common.c, which is included
  both here and in ni_pcimio.c
  Interrupt support added by Truxton Fulton <trux@truxton.com>
  References for specifications:
 	340747b.pdf  Register Level Programmer Manual (obsolete)
 	340747c.pdf  Register Level Programmer Manual (new)
 		     DAQ-STC reference manual
  Other possibly relevant info:
 	320517c.pdf  User manual (obsolete)
 	320517f.pdf  User manual (new)
 	320889a.pdf  delete
 	320906c.pdf  maximum signal ratings
 	321066a.pdf  about 16x
 	321791a.pdf  discontinuation of at-mio-16e-10 rev. c
 	321808a.pdf  about at-mio-16e-10 rev P
 	321837a.pdf  discontinuation of at-mio-16de-10 rev d
 	321838a.pdf  about at-mio-16de-10 rev N
  ISSUES:
  - need to deal with external reference for DAC, and other DAC
    properties in board properties
  - deal with at-mio-16de-10 revision D to N changes, etc.
 AT specific setup 
 XXX unknown 
 XXX unknown 
 XXX unknown 
 unknown 
 irq stuff 
 generic E series stuff in ni_mio_common.c 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  adv_pci1724.c
  Comedi driver for the Advantech PCI-1724U card.
  Author:  Frank Mori Hess <fmh6jj@gmail.com>
  Copyright (C) 2013 GnuBIO Inc
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
  Driver: adv_pci1724
  Description: Advantech PCI-1724U
  Devices: [Advantech] PCI-1724U (adv_pci1724)
  Author: Frank Mori Hess <fmh6jj@gmail.com>
  Updated: 2013-02-09
  Status: works
  Configuration Options: not applicable, uses comedi PCI auto config
  Subdevice 0 is the analog output.
  Subdevice 1 is the offset calibration for the analog output.
  Subdevice 2 is the gain calibration for the analog output.
  The calibration offset and gains have quite a large effect on the
  analog output, so it is possible to adjust the analog output to
  have an output range significantly different from the board's
  nominal output ranges. For a calibrated +-10V range, the analog
  output's offset will be set somewhere near mid-range (0x2000) and
  its gain will be near maximum (0x3fff).
  There is really no difference between the board's documented 0-20mA
  versus 4-20mA output ranges. To pick one or the other is simply a
  matter of adjusting the offset and gain calibration until the board
  outputs in the desired range.
  PCI bar 2 Register IO map (dev->iobase)
 any value works 
 turn off synchronous mode 
 Analog Output subdevice 
 Offset Calibration subdevice 
 Gain Calibration subdevice 
 SPDX-License-Identifier: GPL-2.0+
  dmm32at.c
  Diamond Systems Diamond-MM-32-AT Comedi driver
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: dmm32at
  Description: Diamond Systems Diamond-MM-32-AT
  Devices: [Diamond Systems] Diamond-MM-32-AT (dmm32at)
  Author: Perry J. Piplani <perry.j.piplani@nasa.gov>
  Updated: Fri Jun  4 09:13:24 CDT 2004
  Status: experimental
  Configuration Options:
 	comedi_config devcomedi0 dmm32at baseaddr,irq
  This driver is for the Diamond Systems MM-32-AT board
 	http:www.diamondsystems.comproductsdiamondmm32at
  It is being used on several projects inside NASA, without
  problems so far. For analog input commands, TRIG_EXT is not
  yet supported.
 Board register addresses 
 J3.42 - OUT2 (OUT2EN) 
 J3.43 
 J3.44 - OUT0 (OUT0EN) 
 J3.45 - ADCLK (CLKSEL) 
 J3.46 - GATE12 (GT12EN) 
 J3.47 - GATE0 (GT0EN) 
 J3.48 - CLK0 (SRC0) 
 1=see below  0=software 
 1=OUT2  0=EXTCLK 
 CLK12 1=100KHz 0=10MHz 
 CLK0  1=10KHz  0=10MHz 
 J3.42 1=OUT2 is DOUT2 
 J3,44 1=OUT0 is DOUT0 
 J3.47 1=DIN1 is GATE0 
 CLK0 is 0=FREQ0 1=J3.48 
 J3.46 1=DIN2 is GATE12 
 0=5V  1=10V 
 0=bipolar  1=unipolar 
 DMM32AT_AI_STATUS_STS 
 Page 1 registers 
 Board register values. 
 DMM32AT_AI_CFG_REG 0x0b 
 DMM32AT_CLKCT 0x0f 
 mode3 counter 1 - write low byte only 
  mode3 counter 2 - write high and low byte 
 board AI ranges in comedi structure 
 register values for above ranges 
 only one of these ranges is valid, as set by a jumper on the
  board. The application should only use the range set by the jumper
 munge two's complement value to offset binary 
 wait for circuit to settle 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_NONE 
 Step 4: fix up any arguments 
 Step 5: check channel list if it exists 
 based on 10mhz clock 
 set counter clocks to 10MHz, disable all aux dio 
 get access to the clock regs 
 write the counter 1 control word and low byte to counter 
 write the counter 2 control word and low byte then to counter 
 enable the ai conversion interrupt and the clock to start scans 
 reset the interrupt just in case 
	
	  wait for circuit to settle
	  we don't have the 'insn' here but it's not needed
 start the clock and enable the interrupts 
 start the interrupts and initiate a single scan 
 disable further interrupts and clocks 
 reset the interrupt 
 write LSB then MSB + chan to load DAC 
 wait for circuit to settle 
 dummy read to update DAC 
 get access to the DIO regs 
 Make sure the board is there and put it to a known state 
 reset the board 
 allow a millisecond to reset 
 zero scan and fifo control 
 zero interrupt and clock control 
 write a test channel range, the high 3 bits should drop 
 set the range at 10v unipolar 
 should take 10 us to settle, here's a hundred 
 read back the values 
	
	  NOTE: The (DMM32AT_AI_STATUS_SD1 | DMM32AT_AI_STATUS_SD0)
	  test makes this driver only work if the board is configured
	  with all AD channels set for single-ended operation.
 Analog Input subdevice 
 Analog Output subdevice 
 Digital IO subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  pcmad.c
  Hardware driver for Winsystems PCM-AD12 and PCM-AD16
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000,2001 David A. Schleef <ds@schleef.org>
  Driver: pcmad
  Description: Winsystems PCM-AD12, PCM-AD16
  Devices: [Winsystems] PCM-AD12 (pcmad12), PCM-AD16 (pcmad16)
  Author: ds
  Status: untested
  This driver was written on a bet that I couldn't write a driver
  in less than 2 hours.  I won the bet, but never got paid.  =(
  Configuration options:
    [0] - IO port base
    [1] - IRQ (unused)
    [2] - Analog input reference (must match jumpers)
 	   0 = single-ended (16 channels)
 	   1 = differential (8 channels)
    [3] - Analog input encoding (must match jumpers)
 	   0 = straight binary (0-5V input range)
 	   1 = two's complement (+-10V input range)
 data is shifted on the pcmad12, fix it 
 munge the two's complement value 
 8 differential channels 
 16 single-ended channels 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedi_8254.c
  Generic 8254 timercounter support
  Copyright (C) 2014 H Hartley Sweeten <hsweeten@visionengravers.com>
  Based on 8253.h and various subdevice implementations in comedi drivers.
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Module: comedi_8254
  Description: Generic 8254 timercounter support
  Author: H Hartley Sweeten <hsweeten@visionengravers.com>
  Updated: Thu Jan 8 16:45:45 MST 2015
  Status: works
  This module is not used directly by end-users. Rather, it is used by other
  drivers to provide support for an 8254 Programmable Interval Timer. These
  counters are typically used to generate the pacer clock used for data
  acquisition. Some drivers also expose the counters for general purpose use.
  This module provides the following basic functions:
  comedi_8254_init()  comedi_8254_mm_init()
 	Initializes this module to access the 8254 registers. The _mm version
 	sets up the module for MMIO register access the other for PIO access.
 	The pointer returned from these functions is normally stored in the
 	comedi_device dev->pacer and will be freed by the comedi core during
 	the driver (detach). If a driver has multiple 8254 devices, they need
 	to be stored in the drivers private data and freed when the driver is
 	detached.
 	NOTE: The counters are reset by setting them to I8254_MODE0 as part of
 	this initialization.
  comedi_8254_set_mode()
 	Sets a counters operation mode:
 		I8254_MODE0	Interrupt on terminal count
 		I8254_MODE1	Hardware retriggerable one-shot
 		I8254_MODE2	Rate generator
 		I8254_MODE3	Square wave mode
 		I8254_MODE4	Software triggered strobe
 		I8254_MODE5	Hardware triggered strobe (retriggerable)
 	In addition I8254_BCD and I8254_BINARY specify the counting mode:
 		I8254_BCD	BCD counting
 		I8254_BINARY	Binary counting
  comedi_8254_write()
 	Writes an initial value to a counter.
 	The largest possible initial count is 0; this is equivalent to 2^16
 	for binary counting and 10^4 for BCD counting.
 	NOTE: The counter does not stop when it reaches zero. In Mode 0, 1, 4,
 	and 5 the counter "wraps around" to the highest count, either 0xffff
 	for binary counting or 9999 for BCD counting, and continues counting.
 	Modes 2 and 3 are periodic; the counter reloads itself with the initial
 	count and continues counting from there.
  comedi_8254_read()
 	Reads the current value from a counter.
  comedi_8254_status()
 	Reads the status of a counter.
  comedi_8254_load()
 	Sets a counters operation mode and writes the initial value.
  Typically the pacer clock is created by cascading two of the 16-bit counters
  to create a 32-bit rate generator (I8254_MODE2). These functions are
  provided to handle the cascaded counters:
  comedi_8254_ns_to_timer()
 	Calculates the divisor value needed for a single counter to generate
 	ns timing.
  comedi_8254_cascade_ns_to_timer()
 	Calculates the two divisor values needed to the generate the pacer
 	clock (in ns).
  comedi_8254_update_divisors()
 	Transfers the intermediate divisor values to the current divisors.
  comedi_8254_pacer_enable()
 	Programs the mode of the cascaded counters and writes the current
 	divisor values.
  To expose the counters as a subdevice for general purpose use the following
  functions a provided:
  comedi_8254_subdevice_init()
 	Initializes a comedi_subdevice to use the 8254 timer.
  comedi_8254_set_busy()
 	Internally flags a counter as "busy". This is done to protect the
 	counters that are used for the cascaded 32-bit pacer.
  The subdevice provides (insn_read) and (insn_write) operations to read
  the current value and write an initial value to a counter. A (insn_config)
  operation is also provided to handle the following comedi instructions:
 	INSN_CONFIG_SET_COUNTER_MODE	calls comedi_8254_set_mode()
 	INSN_CONFIG_8254_READ_STATUS	calls comedi_8254_status()
  The (insn_config) member of comedi_8254 can be initialized by the external
  driver to handle any additional instructions.
  NOTE: Gate control, clock routing, and any interrupt handling for the
  counters is not handled by this module. These features are driver dependent.
  comedi_8254_status - return the status of a counter
  @i8254:	comedi_8254 struct for the timer
  @counter:	the counter number
  comedi_8254_read - read the current counter value
  @i8254:	comedi_8254 struct for the timer
  @counter:	the counter number
 latch counter 
 read LSB then MSB 
  comedi_8254_write - load a 16-bit initial counter value
  @i8254:	comedi_8254 struct for the timer
  @counter:	the counter number
  @val:	the initial value
 load LSB then MSB 
  comedi_8254_set_mode - set the mode of a counter
  @i8254:	comedi_8254 struct for the timer
  @counter:	the counter number
  @mode:	the I8254_MODEx and I8254_BCD|I8254_BINARY
 select counter 
 load LSB then MSB 
 mode and BCD|binary 
  comedi_8254_load - program the mode and initial count of a counter
  @i8254:	comedi_8254 struct for the timer
  @counter:	the counter number
  @mode:	the I8254_MODEx and I8254_BCD|I8254_BINARY
  @val:	the initial value
  comedi_8254_pacer_enable - set the mode and load the cascaded counters
  @i8254:	comedi_8254 struct for the timer
  @counter1:	the counter number for the first divisor
  @counter2:	the counter number for the second divisor
  @enable:	flag to enable (load) the counters
		
		  Divisors are loaded second counter then first counter to
		  avoid possible issues with the first counter expiring
		  before the second counter is loaded.
  comedi_8254_update_divisors - update the divisors for the cascaded counters
  @i8254:	comedi_8254 struct for the timer
 masking is done since counter maps zero to 0x10000 
  comedi_8254_cascade_ns_to_timer - calculate the cascaded divisor values
  @i8254:	comedi_8254 struct for the timer
  @nanosec:	the desired ns time
  @flags:	comedi_cmd flags
 exit early if everything is already correct 
 check for overflow 
  comedi_8254_ns_to_timer - calculate the divisor value for nanosec timing
  @i8254:	comedi_8254 struct for the timer
  @nanosec:	the desired ns time
  @flags:	comedi_cmd flags
  comedi_8254_set_busy - setclear the "busy" flag for a given counter
  @i8254:	comedi_8254 struct for the timer
  @counter:	the counter number
  @busy:	setclear flag
		
		  If available, call the driver provided (insn_config)
		  to handle any driver implemented instructions.
  comedi_8254_subdevice_init - initialize a comedi_subdevice for the 8254 timer
  @s:		comedi_subdevice struct
  @i8254:	comedi_8254 struct
 sanity check that the iosize is valid 
 default osc_base to the max speed of a generic 8254 timer 
 reset all the counters by setting them to I8254_MODE0 
  comedi_8254_init - allocate and initialize the 8254 device for pio access
  @iobase:	port IO base address
  @osc_base:	base time of the counter in ns
 		OPTIONAL - only used by comedi_8254_cascade_ns_to_timer()
  @iosize:	IO register size
  @regshift:	register gap shift
  comedi_8254_mm_init - allocate and initialize the 8254 device for mmio access
  @mmio:	memory mapped IO base address
  @osc_base:	base time of the counter in ns
 		OPTIONAL - only used by comedi_8254_cascade_ns_to_timer()
  @iosize:	IO register size
  @regshift:	register gap shift
 SPDX-License-Identifier: GPL-2.0+
  aio_iiro_16.c
  Comedi driver for Access IO Products 104-IIRO-16 board
  Copyright (C) 2006 C&C Technologies, Inc.
  Driver: aio_iiro_16
  Description: Access IO Products PC104 Isolated InputRelay Output Board
  Author: Zachary Ware <zach.ware@cctechnol.com>
  Devices: [Access IO] 104-IIRO-16 (aio_iiro_16)
  Status: experimental
  Configuration Options:
    [0] - IO port base address
    [1] - IRQ (optional)
  The board supports interrupts on change of state of the digital inputs.
  The sample data returned by the async command indicates which inputs
  changed state and the current state of the inputs:
 	Bit 23 - IRQ Enable (1)  Disable (0)
 	Bit 17 - Input 8-15 Changed State (1 = Changed, 0 = No Change)
 	Bit 16 - Input 0-7 Changed State (1 = Changed, 0 = No Change)
 	Bit 15 - Digital input 15
 	...
 	Bit 0  - Digital input 0
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 Step 4: fix up any arguments 
 Step 5: check channel list if it exists 
	
	  Digital input change of state interrupts are optionally supported
	  using IRQ 2-7, 10-12, 14, or 15.
 Digital Output subdevice 
 get the initial state of the relays 
 Digital Input subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  Hardware driver for DAQ-STC based boards
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1997-2001 David A. Schleef <ds@schleef.org>
  Copyright (C) 2002-2006 Frank Mori Hess <fmhess@users.sourceforge.net>
  This file is meant to be included by another file, e.g.,
  ni_atmio.c or ni_pcimio.c.
  Interrupt support originally added by Truxton Fulton <trux@truxton.com>
  References (ftp:ftp.natinst.comsupportmanuals):
    340747b.pdf  AT-MIO E series Register Level Programmer Manual
    341079b.pdf  PCI E Series RLPM
    340934b.pdf  DAQ-STC reference manual
  67xx and 611x registers (ftp:ftp.ni.comsupportdaqmhddkdocumentation)
    release_ni611x.pdf
    release_ni67xx.pdf
  Other possibly relevant info:
    320517c.pdf  User manual (obsolete)
    320517f.pdf  User manual (new)
    320889a.pdf  delete
    320906c.pdf  maximum signal ratings
    321066a.pdf  about 16x
    321791a.pdf  discontinuation of at-mio-16e-10 rev. c
    321808a.pdf  about at-mio-16e-10 rev P
    321837a.pdf  discontinuation of at-mio-16de-10 rev d
    321838a.pdf  about at-mio-16de-10 rev N
  ISSUES:
    - the interrupt routine needs to be cleaned up
  2006-02-07: S-Series PCI-6143: Support has been added but is not
  fully tested as yet. Terry Barnaby, BEAM Ltd.
 A timeout count 
 Note: this table must match the ai_gain_ definitions 
  We automatically take advantage of STC registers that can be
  readwritten directly in the IO space of the board.
  The AT-MIO and DAQCard devices map the low 8 STC registers to
  iobase+reg2.
  Most PCIMIO devices also map the low 8 STC registers but the
  611x devices map the read registers to iobase+(addr-1)2.
  For now non-windowed STC access is disabled if a PCIMIO device
  is detected (devpriv->mite has been initialized).
  The M series devices do not used windowed registers for the
  STC registers. The functions below handle the mapping of the
  windowed STC registers to the m series register offsets.
	
	  NISTC_DIO_OUT_REG maps to:
	  { NI_M_DIO_REG, 4 } and { NI_M_SCXI_SER_DO_REG, 1 }
 DOES NOT MAP CLEANLY 
 DOES NOT MAP CLEANLY 
 E-Series only 
 E-Series only 
 doc for following line: mhddknimseriesChipObjectstMSeries.h 
 Unknown 
 Unknown 
 selects the MITE channel to use for DMA 
 DMA channel setup 
	
	  XXX just guessing NI_STC_DMA_CHAN_SEL()
	  returns the right bits, under the assumption the cdio dma
	  selection works just like aiaogpct.
	  Definitely works for dma channels 0 and 1.
  PCIDMA 
  PCIDMA 
  PCIDMA 
	
	  e-series boards use the second irq signals to generate
	  dma requests for their counters
  PCIDMA 
  Flush the 6143 data FIFO 
  Wait for complete 
			
			  The NI example code does 3 convert pulses for 625x
			  boards, But that appears to be wrong in practice.
  ni_set_bits( ) allows different parts of the ni_mio_common driver to
  share registers (such as Interrupt_A_Register) without interfering with
  each other.
  NOTE: the switchcase statements are optimized out for a constant argument
  so this is actually quite fast---  If you must wrap another function around
  this make it inline to avoid a large speed penalty.
  value should only be 1 or 0.
		
		  If we poll too often, the pci bus activity seems
		  to slow the dma transfer down.
 PCIDMA 
 6711 only has 16 bit wide ao fifo 
   There's a small problem if the FIFO gets really low and we
   don't have the data to fill it.  Basically, if after we fill
   the FIFO with all the data available, the FIFO is _still_
   less than half full, we never clear the interrupt.  If the
   IRQ is in edge mode, we never get another interrupt, because
   this one wasn't cleared.  If in level mode, we get flooded
   with interrupts that we can't fulfill, because nothing ever
   gets put into the buffer.
   This kind of situation is recoverable, but it is easier to
   just pretend we had a FIFO underrun, since there is a good
   chance it will happen anyway.  This is _not_ the case for
   RT code, as RT code might purposely be running close to the
   metal.  Needs to be fixed eventually.
 reset fifo 
 load some data 
 This may get the hilo data in the wrong order 
 Check if there's a single sample stuck in the FIFO 
		
		  This just reads the FIFO assuming the data is present,
		  no checks on the FIFO status are performed.
 Assume there is a single sample stuck in the FIFO 
 Get stranded sample into FIFO 
 Empties the AI fifo 
 This may get the hilo data in the wrong order 
 This may get the hilo data in the wrong order 
  Check if stranded sample is present 
 Get stranded sample into FIFO 
 fifo empty 
 Check if there's a single sample stuck in the FIFO 
 Check if there's a single sample stuck in the FIFO 
 Get stranded sample into FIFO 
 This may get the hilo data in the wrong order 
 handle special case of single scan 
 test for all uncommon interrupt events at the same time 
			
			  We probably aren't even running a command now,
			  so it's a good idea to be careful.
		
		  PCMCIA cards (at least 6036) seem to stop producing
		  interrupts if we fail to get the fifo less than half
		  full, so loop to be sure.
  !PCIDMA 
 write alloc the entire buffer 
start the MITE 
 read alloc the entire buffer 
			
			  Doing 32 instead of 16 bit wide transfers from
			  memory makes the mite do 32 bit pci transfers,
			  doubling pci bandwidth.
  PCIDMA 
  used for both cancel ioctl and board initialization
  this is pretty harsh for a cancel, but it works...
 ai configuration 
| NISTC_AI_MODE1_TRIGGER_ONCE ,
 generate FIFO interrupts on non-empty 
	 the following registers should not be changed, because there
	  are no backup registers in devpriv.  If you want to change
	  any of these, add a backup register and other appropriate code:
	       NISTC_AI_MODE1_REG
	       NISTC_AI_MODE3_REG
	       NISTC_AI_PERSONAL_REG
	       NISTC_AI_OUT_CTRL_REG
 clear interrupts 
  lock to avoid race with interrupt handler 
  don't use 2's complement encoding 
  don't use 2's complement encoding 
  Notes on the 6110 and 6111:
  These boards a slightly different than the rest of the series, since
  they have multiple AD converters.
  From the driver side, the configuration memory is a
  little different.
  Configuration Memory Low:
    bits 15-9: same
    bit 8: unipolarbipolar (should be 0 for bipolar)
    bits 0-3: gain.  This is 4 bits instead of 3 for the other boards
        1001 gain=0.1 (+- 50)
        1010 0.2
        1011 0.1
        0001 1
        0010 2
        0011 5
        0100 10
        0101 20
        0110 50
  Configuration Memory High:
    bits 12-14: Channel Type
        001 for differential
        000 for calibration
    bit 11: coupling  (this is not currently handled)
        1 AC coupling
        0 DC coupling
    bits 0-2: channel
        valid channels are 0-3
  ready to go. 
  Set up Calibration mode if required 
  Strobe Relay enable bit 
 Allow relays to change 
  Strobe Relay disable bit 
 Allow relays to change 
 fix the externalinternal range differences 
 prime the channelgain list 
 The 611x has screwy 32-bit FIFOs. 
			
			  The 6143 has 32-bit FIFOs. You need to strobe a
			  bit to move a single 16bit stranded sample into
			  the FIFO.
 Get stranded sample into FIFO 
		
		  we can only transfer up to the size of the buffer.  In this
		  case, the user is expected to continue to write into the
		  comedi buffer (already implemented as a ring buffer).
 simultaneously-sampled inputs 
 multiplexed inputs 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 external trigger 
 TRIG_OTHER 
 external trigger 
 TRIG_NONE 
 step 4: fix up any arguments 
 mode1 is needed for both stop and convert 
 start configuration 
	
	  Disable analog triggering for now, since it interferes
	  with the use of pfi0.
 logic low 
  ai configuration memory 
  have to take 3 stage adc pipeline into account 
 stage number of scans 
 load SC (Scan Count) 
			
			  This is required to get the last sample for
			  chanlist_len > 1, not sure why.
 stage number of scans 
 load SC (Scan Count) 
		
		  stop bits for non 611x boards
		  NISTC_AI_MODE3_SI_TRIG_DELAY=0
		  NISTC_AI_MODE2_PRE_TRIGGER=0
		  NISTC_AI_START_STOP_REG:
		  NISTC_AI_START_POLARITY=0	(?) rising edge
		  NISTC_AI_START_EDGE=1	edge triggered
		  NISTC_AI_START_SYNC=1	(?)
		  NISTC_AI_START_SEL=0		SI_TC
		  NISTC_AI_STOP_POLARITY=0	rising edge
		  NISTC_AI_STOP_EDGE=0		level
		  NISTC_AI_STOP_SYNC=1
		  NISTC_AI_STOP_SEL=19		external pin (configuration mem)
 A 
 mode2 |= NISTC_AI_MODE2_SC_RELOAD_MODE; 
 load SI 
 falling edge 
 0,0 does not work 
 A 
 alternate 
 B 
 alternate 
 interrupt on FIFO, errors, SC_TC 
 wake on end-of-scan 
 FIFO interrupts and DMA requests on half-full 
 generate FIFO interrupts on non-empty 
 clear interrupts 
 interrupt on nothing 
 XXX start polling if necessary 
 end configuration 
 XXX ? 
 TRIG_INT 
 we don't care about actual channels 
 data[3] : chanlist_len 
 simultaneous output 
		
		  Munge data from unsigned to two's complement for
		  bipolar ranges.
 not all boards can deglitch, but this shouldn't hurt 
 analog reference 
 AREF_OTHER connects AO ground to AI ground, i think 
			
			  6xxx boards have bipolar outputs, munge the
			  unsigned comedi values to 2's complement
			
			  M-series boards use offset binary values for
			  bipolar and uinpolar outputs
			
			  Non-M series boards need two's complement values
			  for bipolar ranges.
  Arms the AO device in preparation for a trigger event.
  This function also allocates and prepares a DMA channel (or FIFO if DMA is
  not used).  As a part of this preparation, this function preloads the DAC
  registers with the first values of the output stream.  This ensures that the
  first clock cycle after the trigger can be used for output.
  Note that this function _must_ happen after a user has written data to the
  output buffers via either mmap or write(fileno,...).
	
	  Prevent ao from doing things like trying to allocate the ao dma
	  channel multiple times.
 wait for DACs to be loaded 
	
	  stc manual says we are need to clear error interrupt after
	  AO_TMRDACWRs_In_Progress_St clears
 we don't care about actual channels 
 data[3] : chanlist_len 
	
	  Require trig_num == cmd->start_arg when cmd->start_src == TRIG_INT.
	  For backwards compatibility, also allow trig_num == 0 when
	  cmd->start_src != TRIG_INT (i.e. when cmd->start_src == TRIG_EXT);
	  in that case, the internal trigger is being used as a pre-trigger
	  before the external trigger.
	
	  Null trig at beginning prevent ao start trigger from executing more
	  than once per command.
 only arm this device if it still needs arming 
  begin ni_ao_cmd.
  Organized similar to NI-STC and MHDDK examples.
  ni_ao_cmd is broken out into configuration sub-routines for clarity.
 fast CPU interface--only eseries 
 ((slow CPU interface) ? 0 : AO_Fast_CPU) | 
 (use_original_pulse ? 0 : NISTC_AO_PERSONAL_UPDATE_TIMEBASE)  |
	  
	    FIXME:  start setting following bit when appropriate.  Need to
	    determine whether board is E4 or E1.
	    FROM MHHDK:
	    if board is E4 or E1
	      Set bit "NISTC_AO_PERSONAL_UPDATE_PW" to 0
	    else
	      set it to 1
 FIXME:  when should we set following bit to zero? 
	
	  FIXME:
	  add something like ".has_individual_dacs = 0" to ni_board_struct
	  since, as F Hess pointed out, not all in m series have singles.  not
	  sure if e-series all have duals...
	
	  F Hess: windows driver does not set NISTC_AO_PERSONAL_NUM_DAC bit for
	  6281, verified with bus analyzer.
 sync 
 TRIG_EXT 
 0=active high, 1=active low. see daq-stc 3-24 (p186) 
 0=edge detection disabled, 1=enabled 
 AO_Delayed_START1 = 0, we do not support delayed start...yet 
 sync 
 select DA_START1 as PFI6AO_START1 when configured as an output 
 Not supporting 'waveform staging' or 'local buffer with pauses' 
	
	  This relies on ao_mode1(Trigger_Once | Continuous) being set in
	  set_trigger above.  It is unclear whether we really need to re-write
	  this register with these values.  The mhddk examples for e-series
	  show writing this in both places, but the examples for m-series show
	  a single write in the set_counters function (here).
 sync (upload number of buffer iterations -1) 
 indicate that we want to use BC_Load_A_Register as the source 
	
	  if the BC_TC interrupt is still issued in spite of UC, BC, UI
	  ignoring BC_TC, then we will need to find a way to ignore that
	  interrupt in continuous mode.
 iter once 
 sync (issue command to load number of buffer iterations -1) 
 sync (upload number of updates in buffer) 
 indicate that we want to use UC_Load_A_Register as the source 
	
	  if a user specifies '0', this automatically assumes the entire 24bit
	  address space is available for the (multiple iterations of single
	  buffer) MISB.  Otherwise, stop_arg specifies the MISB length that
	  will be used, regardless of whether we are in continuous mode or not.
	  In continuous mode, the output will just iterate indefinitely over
	  the MISB.
			
			  this is how the NI example code does it for m-series
			  boards, verified correct with 6259
 sync (issue cmd to load number of updates in MISB) 
 sync (issue cmd to load number of updates in MISB) 
			
			  sync (upload number of updates-1 in MISB)
			  --eseries only?
	
	  zero out these bit fields to be set below. Does an ao-reset do this
	  automatically?
		
		  NOTE: there are several other ways of configuring internal
		  updates, but we'll only support one for now:  using
		  AO_IN_TIMEBASE, wo waveform staging, wo a delay between
		  START1 and first update, and also wo local buffer mode w
		  pauses.
		
		  This is already done above:
		  devpriv->ao_mode1 &= ~(
		     set UPDATE_Source to UI_TC:
		    NISTC_AO_MODE1_UPDATE_SRC_MASK |
		     set UPDATE_Source_Polarity to rising (required?)
		    NISTC_AO_MODE1_UPDATE_SRC_POLARITY |
		     set UI_Source to AO_IN_TIMEBASE1:
		    NISTC_AO_MODE1_UI_SRC_MASK     |
		     set UI_Source_Polarity to rising (required?)
		    NISTC_AO_MODE1_UI_SRC_POLARITY
		  );
		
		  TODO:  use ao_ui_clock_source to allow all possible signals
		  to be routed to UI_Source_Select.  See tSTC.h for
		  eseriesni67xx and tMSeries.h for mseries.
		
		  Wait N TB3 ticks after the start trigger before
		  clocking (N must be >=2).
 following line: 2-1 per STC 
 TRIG_EXT 
 FIXME:  assert scan_begin_arg != 0, ret failure otherwise 
 Configure DAQ-STC for Timed update mode 
 We are not using UPDATE2-->don't have to set DACx_Source_Select 
	
	  Since we are not supporting waveform staging, we ignore these errors:
	  NISTC_AO_MODE3_STOP_ON_BC_TC_ERR,
	  NISTC_AO_MODE3_STOP_ON_BC_TC_TRIG_ERR
 NOTE:  this is where use_onboard_memory=True would be implemented 
 enable sending of ao fifo requests (dma request) 
 we are not supporting boards with virtual fifos 
 ni_ao_reset should have already been done 
 clearing fifo and preload happens elsewhere 
	
	  arm(ing) must happen later so that DMA can be setup and DACs
	  preloaded with the actual output buffer before starting.
	 
	  start(ing) must happen _after_ arming is completed.  Starting can be
	  done either via ni_ao_inttrig, or via an external trigger.
	 
	  Currently, ni_ao_inttrig will automatically attempt a call to
	  ni_ao_arm if the device still needs arming at that point.  This
	  allows backwards compatibility.
 end ni_ao_cmd 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_EXT 
 step 4: fix up any arguments 
 See 3.6.1.2 "Resetting", of DAQ-STC Technical Reference Manual 
	
	  In the following, the "--sync" comments are meant to denote
	  asynchronous boundaries for setting the registers as described in the
	  DAQ-STC mostly in the order also described in the DAQ-STC.
 --sync (reset AO) 
 following example in mhddk for m-series 
--sync (start config) 
--sync (Disarm) 
	
	  --sync
	  (clear bunch of registers--mseries mhddk examples do not include
	  this)
--sync (disable interrupts) 
--sync (ack) 
--not in DAQ-STC.  which doc? 
--end 
 digital io 
 Make sure we're not using the serial part of the dio 
 we don't care about actual channels 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
	
	  Although NI_D[IO]_SampleClock are the same, perhaps we should still,
	  for completeness, test whether the cmd is output or input?
 Step 4: fix up any arguments 
 Step 5: check channel list if it exists 
 read alloc the entire buffer 
	
	  XXX not sure what interrupt C group does
	  wait for dma to fill output fifo
	  ni_writeb(dev, NI_M_INTC_ENA, NI_M_INTC_ENA_REG);
	
	  Although NI_D[IO]_SampleClock are the same, perhaps we should still,
	  for completeness, test whether the cmd is output or input(?)
	
	  XXX not sure what interrupt C group does
	  ni_writeb(dev, 0, NI_M_INTC_ENA_REG);
 XXX just guessing this is needed and does something useful 
 s->async->events |= COMEDI_CB_EOA; 
  PCIDMA 
 Wait until STC says we're done, but don't loop infinitely. 
 Delay one bit per loop 
	
	  Delay for last bit. This delay is absolutely necessary, because
	  NISTC_STATUS1_SERIO_IN_PROG goes high one bit too early.
 Wait for one bit before transfer 
		
		  Output current bit; note that we cannot touch s->state
		  because it is a per-subdevice field, and serial is
		  a separate subdevice from DIO.
		
		  Assert SDCLK (active low, inverted), wait for half of
		  the delay, deassert SDCLK, and wait for the other half.
 Input current bit 
			
			  Warning: this clock speed is too fast to reliably
			  control SCXI.
			
			  Note: NISTC_CLK_FOUT_DIO_SER_OUT_DIV2 only affects
			  600ns1.2us. If you turn divide_by_2 off with the
			  slow clock, you will still get 10us, except then
			  all your delays are wrong.
 M-Series only 
 M-Series only 
 M-Series only 
 M-Series only 
 M-Series only 
 M-Series only 
 M-Series only 
 M-Series only 
 M-Series only 
 M-Series only 
 m-series only registers 
 32 bit registers 
 16 bit registers 
 m-series only registers 
 32 bit registers 
 16 bit registers 
 use the last data value to set the fout divider 
	
	  Fujitsu MB 88341
	  Note that address bits are reversed.  Thanks to
	  Ingo Keen for noticing this.
	 
	  Note also that the 88341 expects address values from
	  1-12, whereas we use channel numbers 0-11.  The NI
	  docs use 1-12, also, so be careful here.
 bits will be 0 if there is no caldac for the given addr 
 only bother writing the last sample to the channel 
  pre-m-series boards have fixed signals on pfi pins 
  pre-m-series boards have fixed signals on pfi pins 
 allow new and old names of pfi channels to work. 
 Sets the output mux for the specified PFI channel. 
 allow new and old names of pfi channels to work. 
 allow new and old names of pfi channels to work. 
 allow new and old names of pfi channels to work. 
 allow new and old names of pfi channels to work. 
	 give time for command to start being serially clocked into cs5529.
	  this insures that the NI67XX_CAL_STATUS_BUSY bit will get properly
	  set before we exit this function.
 cs5529 returns 16 bit signed data in bipolar mode 
	
	  Set calibration adc source.  Docs lie, reference select bits 8 to 11
	  do nothing. bit 12 seems to chooses internal reference voltage, bit
	  13 causes the adc input to go overrange (maybe reads external
	  reference?)
 do self-calibration 
 need to force a conversion for calibration to run 
 force gain calibration to 1 
  Find best multiplierdivider to try and get the PLL running at 80 MHz
  given an arbitrary frequency input clock.
	
	  m-series wants the phased-locked loop to output 80MHz, which is
	  divided by 4 to 20 MHz for most timing clocks
 return the actual period ( fudge factor for 80 to 20 MHz) 
	
	  These limits are somewhat arbitrary, but NI advertises 1 to 20MHz
	  range so we'll use that.
 pxi clock is 10MHz 
 it takes a few hundred microseconds for PLL to lock 
 allow new and old names of rtsi channels to work. 
		 probably should never reach this, since the
		  ni_valid_rtsi_output_source above errors out if chan is too
		  high
 allow new and old names of rtsi channels to work. 
 allow new and old names of rtsi channels to work. 
 allow new and old names of rtsi channels to work. 
  Default routing for RTSI trigger lines.
  These values are used here in the init function, as well as in the
  disconnect_route function, after a RTSI route has been disconnected.
  Route signals through RGOUT0 terminal.
  @reg: raw register value of RGOUT0 bits (only bit0 is important).
  @dev: comedi device handle.
  Route signals through RGOUT0 terminal and increment the RGOUT0 use for this
  particular route.
  @src: device-global signal name
  @dev: comedi device handle
  Return: -EINVAL if the source is not valid to route to RGOUT0;
 	   -EBUSY if the RGOUT0 is already used;
 	   0 if successful.
  Unroute signals through RGOUT0 terminal and deccrement the RGOUT0 use for
  this particular source.  This function does not actually unroute anything
  with respect to RGOUT0.  It does, on the other hand, decrement the usage
  counter for the current src->RGOUT0 mapping.
  Return: -EINVAL if the source is not already routed to RGOUT0 (or usage is
 	already at zero); 0 if successful.
 ok default? 
  Route signals through given NI_RTSI_BRD mux.
  @i: index of mux to route
  @reg: raw register value of RTSI_BRD bits
  @dev: comedi device handle
 value for e-series 
 clear out the current reg_i for ith brd 
 (softcopy) write the new reg_i for ith brd 
 (hardcopy) write the new reg_i for ith brd 
 value for e-series 
	
	  And now:
	  brd : device-global name
	  brd_index : index number of RTSI_BRD mux
  Route signals through NI_RTSI_BRD mux and increment the use counter for this
  particular route.
  Return: -EINVAL if the source is not valid to route to NI_RTSI_BRD(i);
 	   -EBUSY if all NI_RTSI_BRD muxes are already used;
 	   NI_RTSI_BRD(i) of allocated ith mux if successful.
 first look for a mux that is already configured to provide src 
 invalid route 
 found the first unused, but usable mux 
			
			  we've seen at least one possible route, so change the
			  final error to -EBUSY in case there are no muxes
			  available.
				
				  we've found a mux that is already being used
				  to provide the requested signal.  Reuse it.
 we did not find a mux to reuse, but there is at least one usable 
  Unroute signals through NI_RTSI_BRD mux and decrement the user counter for
  this particular route.
  Return: -EINVAL if the source is not already routed to rtsi_brd(i) (or usage
 	is already at zero); 0 if successful.
 ok default? 
  Initialises the RTSI bus signal switch to a default state 
	
	  Use 10MHz instead of 20MHz for RTSI clock frequency. Appears
	  to have no effect, at least on pxi-6281, which always uses
	  20MHz rtsi clock frequency
  Set clock mode to internal 
 default internal lines routing to RTSI bus lines 
	
	  Sets the source and direction of the 4 on board lines.
	  This configures all board lines to be:
	  for e-series:
	    1) inputs (not sure what "output" would mean)
	    2) copying TRIGGER_LINE(0) (or RTSI0) output
	  for m-series:
	    copying NI_PFI(0) output
 initialize rgout0 pin as unused. 
 Get route of GPFO_iCtrOut pins 
 Set route of GPFO_iCtrOut pins 
 Set route of GPFO_iCtrOut pins 
 clear reg 
 set reg 
 clear reg 
 set reg 
  Retrieves the current source of the output selector for the given
  destination.  If the terminal for the destination is not already configured
  as an output, this function returns -EINVAL as error.
  Return: the register value of the destination output selector;
 	   -EINVAL if terminal is not configured for output.
 prepare for lookup below 
 prepare for lookup 
		
		  not handled by ni_tio.  Only available for GPFO registers in
		  em series.
 there are only two g_out outputs. 
  Test a route:
  Return: -1 if not connectible;
 	    0 if connectible and not connected;
 	    1 if connectible and connected.
 Connect the actual route.  
 route is not valid 
 destination mux is already busy. complain, don't overwrite 
 The route is valid and available. Now connect... 
 set routing source, then open output 
 Attempt to allocate and  route (src->brd) 
 Now lookup the register value for (brd->dest) 
		
		  not handled by ni_tio.  Only available for GPFO registers in
		  em series.
 there are only two g_out outputs. 
		
		  we are adding back the channel modifier info to set
		  invertedge info passed by the user
 route is not valid 
 cannot disconnect something not connected 
 The route is valid and is connected.  Now disconnect... 
 set the pfi to high impedance, and disconnect 
 find which RTSI_BRD line is source for rtsi pin 
 decrementdisconnect RTSI_BRD line from source 
 set rtsi output selector to default state 
		
		  not handled by ni_tio.  Only available for GPFO registers in
		  em series.
 there are only two g_out outputs. 
	
	  This case is already handled one level up.
	  case INSN_DEVICE_CONFIG_GET_ROUTES:
 make sure dev->attached is checked 
  lock to avoid race with comedi_poll 
 handle any interrupt or dma events 
 handle any interrupt or dma events 
 prepare the device for globally-named routes. 
		
		  only(?) assign insn_device_config if we have global names for
		  this device.
 initialize clock dividers 
 BEAM is this needed for PCI-6143 ?? 
 Analog Input subdevice 
 reset the analog input configuration 
 Analog Output subdevice 
		
		  Along with the IRQ we need either a FIFO or DMA for
		  async command support.
 reset the analog output configuration 
 Digital IO subdevice 
 | SDF_CMD_READ ;
 M-series boards use DMA 
 reset DIO and set all channels to inputs 
 PCIDMA 
 set all channels to inputs 
 8255 device 
 formerly general purpose countertimer device, but no longer used 
 Calibration subdevice 
 internal PWM output used for AI nonlinearity calibration 
 internal PWM output used for AI nonlinearity calibration 
 setup the caldacs and find the real n_chan and maxdata 
 EEPROM subdevice 
 Digital IO (PFI) subdevice 
 cs5529 calibration adc 
  one channel for each analog output channel 
 XXX 
 Serial 
 RTSI 
 allocate and initialize the gpct counter device 
 Counter (gpct) subdevices 
 setup and initialize the counter 
 | SDF_CMD_WRITE ;
 Initialize GPFO_{0,1} to produce output of counters 
 output of counter 0; DAQ STC, p338 
 output of counter 1; DAQ STC, p338 
 Frequency output subdevice 
 DMA setup 
 SPDX-License-Identifier: GPL-2.0+
  comedidriversamplc_pci236.c
  Driver for Amplicon PCI236 DIO boards.
  Copyright (C) 2002-2014 MEV Ltd. <https:www.mev.co.uk>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: amplc_pci236
  Description: Amplicon PCI236
  Author: Ian Abbott <abbotti@mev.co.uk>
  Devices: [Amplicon] PCI236 (amplc_pci236)
  Updated: Fri, 25 Jul 2014 15:32:40 +0000
  Status: works
  Configuration options:
    none
  Manual configuration of PCI board (PCI236) is not supported; it is
  configured automatically.
  The PCI236 board has a single 8255 appearing as subdevice 0.
  Subdevice 1 pretends to be a digital input device, but it always
  returns 0 when read. However, if you run a command with
  scan_begin_src=TRIG_EXT, a rising edge on port C bit 3 acts as an
  external trigger, which can be used to wake up tasks.  This is like
  the comedi_parport device.  If no interrupt is connected, then
  subdevice 1 is unused.
 Disable, and clear, interrupts 
 Enable, and clear, interrupts 
 this will also clear the "local interrupt 1" latch 
 check if interrupt occurred 
 clear the interrupt 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routes.c
   Route information for NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  This is defined in ni_routingni_route_values.h:
  #define B(x)	((x) - NI_NAMES_BASE)
  These are defined in ni_routingni_route_values.h to identify clearly
  elements of the table that were set.  In other words, entries that are zero
  are invalid.  To get the value to use for the register, one must mask out the
  high bit.
  #define V(x)	((x) | 0x80)
  #define UNMARK(x)	((x) & (~(0x80)))
 Helper for accessing data. 
  Find the route values for a device family.
  Find the valid routes for a board.
  Find the proper route_values and ni_device_routes tables for this particular
  device.  Possibly try an alternate board name if device routes not found
  for the actual board name.
  Return: -ENODATA if either was not found; 0 if both were found.
 First, find the register_values table for this device family 
 Second, find the set of routes valid for this device. 
  ni_assign_device_routes() - Assign the proper lookup table for NI signal
 			       routing to the specified NI device.
  @device_family: Device family name (determines route values).
  @board_name: Board name (determines set of routes).
  @alt_board_name: Optional alternate board name to try on failure.
  @tables: Pointer to assigned routing information.
  Finds the route values for the device family and the set of valid routes
  for the board.  If valid routes could not be found for the actual board
  name and an alternate board name has been specified, try that one.
  On failure, the assigned routing information may be partially filled
  (for example, with the route values but not the set of valid routes).
  Return: -ENODATA if assignment was not successful; 0 if successful.
  ni_count_valid_routes() - Count the number of valid routes.
  @tables: Routing tables for which to count all valid routes.
 direct routing is valid 
  ni_get_valid_routes() - Implements INSN_DEVICE_CONFIG_GET_ROUTES.
  @tables:	pointer to relevant set of routing tables.
  @n_pairs:	Number of pairs for which memory is allocated by the user.  If
 		the user specifies '0', only the number of available pairs is
 		returned.
  @pair_data:	Pointer to memory allocated to return pairs back to user.  Each
 		even, odd indexed member of this array will hold source,
 		destination of a route pair respectively.
  Return: the number of valid routes if n_pairs == 0; otherwise, the number of
 	valid routes copied.
 direct routing is valid 
 indirect routing also valid 
  List of NI global signal names that, as destinations, are only routeable
  indirectly through the _arg elements of the comedi_cmd structure.
  ni_is_cmd_dest() - Determine whether the given destination is only
 		      configurable via a comedi_cmd struct.
  @dest: Destination to test.
  BEGIN Routes sort routines  
  ni_sort_device_routes() - Sort the list of valid device signal routes in
 			     preparation for use.
  @valid_routes:	pointer to ni_device_routes struct to sort.
 1. Count and set the number of ni_route_set objects. 
 2. sort all ni_route_set objects by destination. 
 3. Loop through each route_set for sorting. 
 3a. Count and set the number of sources. 
 3a. Sort sources. 
 sort all valid device signal routes in prep for use 
  BEGIN Routes search routines  
  ni_find_route_set() - Finds the proper route set with the specified
 			 destination.
  @destination: Destination of which to search for the route set.
  @valid_routes: Pointer to device routes within which to search.
  Return: NULL if no route_set is found with the specified @destination;
 	otherwise, a pointer to the route_set if found.
  ni_route_set_has_source() - Determines whether the given source is in
 			       included given route_set.
  Return: true if found; false otherwise.
  ni_lookup_route_register() - Look up a register value for a particular route
 				without checking whether the route is valid for
 				the particular device.
  @src:	global-identifier for route source
  @dest:	global-identifier for route destination
  @tables:	pointer to relevant set of routing tables.
  Return: -EINVAL if the specified route is not valid for this device family.
	
	  Be sure to use the B() macro to subtract off the NI_NAMES_BASE before
	  indexing into the route_values array.
 mask out the valid-value marking bit 
  ni_route_to_register() - Validates and converts the specified signal route
 			    (src-->dest) to the value used at the appropriate
 			    register.
  @src:	global-identifier for route source
  @dest:	global-identifier for route destination
  @tables:	pointer to relevant set of routing tables.
  Generally speaking, most routes require the first six bits and a few require
  7 bits.  Special handling is given for the return value when the route is to
  be handled by the RTSI sub-device.  In this case, the returned register may
  not be sufficient to define the entire route path, but rather may only
  indicate the intermediate route.  For example, if the route must go through
  the RGOUT0 pin, the (src->RGOUT0) register value will be returned.
  Similarly, if the route must go through the NI_RTSI_BRD lines, the BIT(6)
  will be set:
  if route does not need RTSI_BRD lines:
    bits 0:7 : register value
               for a route that must go through RGOUT0 pin, this will be equal
               to the (src->RGOUT0) register value.
  else:  route is (src->RTSI_BRD(x), RTSI_BRD(x)->TRIGGER_LINE(i)) 
    bits 0:5 : zero
    bits 6   : set to 1
    bits 7:7 : zero
  Return: register value to be used for source at destination with special
 	cases given above; Otherwise, -1 if the specified route is not valid for
 	this particular device.
 first check to see if source is listed with bunch of destinations. 
 2nd, check to see if destination is in list of source's targets. 
	
	  finally, check to see if we know how to route...
	  Be sure to use the B() macro to subtract off the NI_NAMES_BASE before
	  indexing into the route_values array.
	
	  if we did not validate the route, we'll see if we can route through
	  one of the muxes
 mask out the valid-value marking bit 
  ni_find_route_source() - Finds the signal source corresponding to a signal
 			    route (src-->dest) of the specified routing register
 			    value and the specified route destination on the
 			    specified device.
  Note that this function does _not_ validate the source based on device
  routes.
  Return: The NI signal value (e.g. NI_PFI(0) or PXI_Clk10) if found.
 	If the source was not found (i.e. the register value is not
 	valid for any routes to the destination), -EINVAL is returned.
 subtract NI names offset 
 ensure we are not going to underover run the route value table 
  END Routes search routines  
  BEGIN simple module entryexit functions  
www.comedi.org");
  END simple module entryexit functions  
 SPDX-License-Identifier: GPL-2.0+
  COMEDI driver for the watchdog subdevice found on some addi-data boards
  Copyright (c) 2013 H Hartley Sweeten <hsweeten@visionengravers.com>
  Based on implementations in various addi-data COMEDI drivers.
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1998 David A. Schleef <ds@schleef.org>
  The watchdog subdevice is configured with two INSN_CONFIG instructions:
  Enable the watchdog and set the reload timeout:
 	data[0] = INSN_CONFIG_ARM
 	data[1] = timeout reload value
  Disable the watchdog:
 	data[0] = INSN_CONFIG_DISARM
 Time base is 20ms, let the user know the timeout 
 "ping" the watchdog 
 SPDX-License-Identifier: GPL-2.0+
  addi_apci_3xxx.c
  Copyright (C) 2004,2005  ADDI-DATA GmbH for the source code of this module.
  Project manager: S. Weber
 	ADDI-DATA GmbH
 	Dieselstrasse 3
 	D-77833 Ottersweier
 	Tel: +19(0)72239493-0
 	Fax: +49(0)72239493-92
 	http:www.addi-data.com
 	info@addi-data.com
 Test if interrupt occur 
 Reset the interrupt 
 Clear the FIFO 
 Get and save the delay mode 
 Channel configuration selection 
 Make the configuration 
 Channel selection 
 Restore delay mode 
 Set the number of sequence to 1 
 Start the conversion 
 Wait the EOS 
 Read the analog value 
 time_base: 0 = ns, 1 = us, 2 = ms 
 skip unsupported time bases 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_NONE 
 step 4: fix up any arguments 
 Set the convert timing unit 
 Set the convert timing 
 Start the conversion 
 Set the range selection 
 Write the analog value to the selected channel 
 Wait the end of transfer 
	
	  Port 0 (channels 0-7) are always inputs
	  Port 1 (channels 8-15) are always outputs
	  Port 2 (channels 16-23) are programmable io
 ignore all other instructions for ports 0 and 1 
 changing any channel in port 2 changes the entire port 
 update port 2 configuration 
 Disable the interrupt 
 Clear the start command 
 Reset the interrupt flags 
 clear the EOS 
 Clear the FIFO 
 Enable the interrupt 
 Analog Input subdevice 
			
			  FIXME: The hardware supports multiple scan modes
			  but the original addi-data driver only supported
			  reading a single channel with interrupts. Need a
			  proper datasheet to fix this.
			 
			  The following scan modes are supported by the
			  hardware:
			    1) Single software scan
			    2) Single hardware triggered scan
			    3) Continuous software scan
			    4) Continuous software scan with timer delay
			    5) Continuous hardware triggered scan
			    6) Continuous hardware triggered scan with timer
			       delay
			 
			  For now, limit the chanlist to a single channel.
 Analog Output subdevice 
 Digital Input subdevice 
 Digital Output subdevice 
 TTL Digital IO subdevice 
 channels 0-7 are always outputs 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  addi_apci_3501.c
  Copyright (C) 2004,2005  ADDI-DATA GmbH for the source code of this module.
  Project manager: Eric Stolz
 	ADDI-DATA GmbH
 	Dieselstrasse 3
 	D-77833 Ottersweier
 	Tel: +19(0)72239493-0
 	Fax: +49(0)72239493-92
 	http:www.addi-data.com
 	info@addi-data.com
  Driver: addi_apci_3501
  Description: ADDI-DATA APCI-3501 Analog output board
  Devices: [ADDI-DATA] APCI-3501 (addi_apci_3501)
  Author: H Hartley Sweeten <hsweeten@visionengravers.com>
  Updated: Mon, 20 Jun 2016 10:57:01 -0700
  Status: untested
  Configuration Options: not applicable, uses comedi PCI auto config
  This board has the following features:
    - 4 or 8 analog output channels
    - 2 optically isolated digital inputs
    - 2 optically isolated digital outputs
    - 1 12-bit watchdogtimer
  There are 2 versions of the APCI-3501:
    - APCI-3501-4  4 analog output channels
    - APCI-3501-8  8 analog output channels
  These boards use the same PCI VendorDevice IDs. The number of output
  channels used by this driver is determined by reading the EEPROM on
  the board.
  The watchdogtimer subdevice is not currently supported.
  PCI bar 1 register IO map
  AMCC S5933 NVRAM
  Function types stored in the eeprom
	
	  All analog output channels have the same output range.
	 	14-bit bipolar: 0-10V
	 	13-bit unipolar: +-10V
	  Changing the range of one channel changes all of them!
 Add the offset to the start of the user data 
 Load the low 8 bit address 
 Load the high 8 bit address 
 Read the eeprom data byte 
 Read functionality details 
 No point reading the same EEPROM location more than once. 
 Reset all digital outputs to "0" 
 Default all analog outputs to 0V (bipolar) 
 Set all analog output channels 
 Initialize the analog output subdevice 
 Initialize the digital input subdevice 
 Initialize the digital output subdevice 
 TimerWatchdog subdevice 
 Initialize the eeprom subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  pcmda12.c
  Driver for Winsystems PC-104 based PCM-DA-12 8-channel AO board.
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2006 Calin A. Culianu <calin@ajvar.org>
  Driver: pcmda12
  Description: A driver for the Winsystems PCM-DA-12
  Devices: [Winsystems] PCM-DA-12 (pcmda12)
  Author: Calin Culianu <calin@ajvar.org>
  Updated: Fri, 13 Jan 2006 12:01:01 -0500
  Status: works
  A driver for the relatively straightforward-to-program PCM-DA-12.
  This board doesn't support commands, and the only way to set its
  analog output range is to jumper the board. As such,
  comedi_data_write() ignores the range value specified.
  The board uses 16 consecutive IO addresses starting at the IO port
  base address. Each address corresponds to the LSB then MSB of a
  particular channel from 0-7.
  Note that the board is not ISA-PNP capable and thus needs the IO
  port comedi_config parameter.
  Note that passing a nonzero value as the second config option will
  enable "simultaneous xfer" mode for this board, in which AO writes
  will not take effect until a subsequent read of any AO channel. This
  is so that one can speed up programming by preloading all AO registers
  with values before simultaneously setting them to take effect with one
  read command.
  Configuration Options:
    [0] - IO port base address
    [1] - Do Simultaneous Xfer (see description)
 AI range is not configurable, it's set by jumpers on the board 
		
		  Initiate transfer if not in simultaneaous xfer
		  mode by reading one of the AO registers.
	
	  Initiate simultaneaous xfer mode by reading one of the
	  AO registers. All analog outputs will then be updated.
 Initiate transfer by reading one of the AO registers. 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0
  comedidriverspcl730.c
  Driver for Advantech PCL-730 and clones
  Jos Luis Snchez
  Driver: pcl730
  Description: Advantech PCL-730 (& compatibles)
  Devices: [Advantech] PCL-730 (pcl730), PCM-3730 (pcm3730), PCL-725 (pcl725),
    PCL-733 (pcl733), PCL-734 (pcl734),
    [ADLink] ACL-7130 (acl7130), ACL-7225b (acl7225b),
    [ICP] ISO-730 (iso730), P8R8-DIO (p8r8dio), P16R16-DIO (p16r16dio),
    [Diamond Systems] OPMM-1616-XT (opmm-1616-xt), PEARL-MM-P (pearl-mm-p),
    IR104-PBF (ir104-pbf),
  Author: Jos Luis Snchez (jsanchezv@teleline.es)
  Status: untested
  Configuration options:
    [0] - IO port base
  Interrupts are not supported.
  The ACL-7130 card has an 8254 timercounter not supported by this driver.
  Register map
  The register map varies slightly depending on the board type but
  all registers are 8-bit.
  The boardinfo 'io_range' is used to allow comedi to request the
  proper range required by the board.
  The comedi_subdevice 'private' data is used to pass the register
  offset to the (insn_bits) functions to readwrite the correct
  registers.
  The basic register mapping looks like this:
      BASE+0  Isolated outputs 0-7 (write)  inputs 0-7 (read)
      BASE+1  Isolated outputs 8-15 (write)  inputs 8-15 (read)
      BASE+2  TTL outputs 0-7 (write)  inputs 0-7 (read)
      BASE+3  TTL outputs 8-15 (write)  inputs 8-15 (read)
  The pcm3730 board does not have register BASE+1.
  The pcl725 and p8r8dio only have registers BASE+0 and BASE+1:
      BASE+0  Isolated outputs 0-7 (write) (read back on p8r8dio)
      BASE+1  Isolated inputs 0-7 (read)
  The acl7225b and p16r16dio boards have this register mapping:
      BASE+0  Isolated outputs 0-7 (write) (read back)
      BASE+1  Isolated outputs 8-15 (write) (read back)
      BASE+2  Isolated inputs 0-7 (read)
      BASE+3  Isolated inputs 8-15 (read)
  The pcl733 and pcl733 boards have this register mapping:
      BASE+0  Isolated outputs 0-7 (write) or inputs 0-7 (read)
      BASE+1  Isolated outputs 8-15 (write) or inputs 8-15 (read)
      BASE+2  Isolated outputs 16-23 (write) or inputs 16-23 (read)
      BASE+3  Isolated outputs 24-31 (write) or inputs 24-31 (read)
  The opmm-1616-xt board has this register mapping:
      BASE+0  Isolated outputs 0-7 (write) (read back)
      BASE+1  Isolated outputs 8-15 (write) (read back)
      BASE+2  Isolated inputs 0-7 (read)
      BASE+3  Isolated inputs 8-15 (read)
      These registers are not currently supported:
      BASE+2  Relay select register (write)
      BASE+3  Board reset control register (write)
      BASE+4  Interrupt control register (write)
      BASE+4  Change detect 7-0 status register (read)
      BASE+5  LED control register (write)
      BASE+5  Change detect 15-8 status register (read)
  The pearl-mm-p board has this register mapping:
      BASE+0  Isolated outputs 0-7 (write)
      BASE+1  Isolated outputs 8-15 (write)
  The ir104-pbf board has this register mapping:
      BASE+0  Isolated outputs 0-7 (write) (read back)
      BASE+1  Isolated outputs 8-15 (write) (read back)
      BASE+2  Isolated outputs 16-19 (write) (read back)
      BASE+4  Isolated inputs 0-7 (read)
      BASE+5  Isolated inputs 8-15 (read)
      BASE+6  Isolated inputs 16-19 (read)
 only 4 are used 
 Isolated Digital Outputs 
 get the initial state if supported 
 Isolated Digital Inputs 
 TTL Digital Outputs 
 TTL Digital Inputs 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
   das08_isa.c
   comedi driver for DAS08 ISAPC-104 boards
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2000 David A. Schleef <ds@schleef.org>
   Copyright (C) 2001,2002,2003 Frank Mori Hess <fmhess@users.sourceforge.net>
   Copyright (C) 2004 Salvador E. Tropea <set@users.sf.net> <set@ieee.org>
  Driver: das08_isa
  Description: DAS-08 ISAPC-104 compatible boards
  Devices: [Keithley Metrabyte] DAS08 (isa-das08),
    [ComputerBoards] DAS08 (isa-das08), DAS08-PGM (das08-pgm),
    DAS08-PGH (das08-pgh), DAS08-PGL (das08-pgl), DAS08-AOH (das08-aoh),
    DAS08-AOL (das08-aol), DAS08-AOM (das08-aom), DAS08JR-AO (das08jr-ao),
    DAS08JR-16-AO (das08jr-16-ao), PC104-DAS08 (pc104-das08),
    DAS08JR16 (das08jr16)
  Author: Warren Jasper, ds, Frank Hess
  Updated: Fri, 31 Aug 2012 19:19:06 +0100
  Status: works
  This is the ISAPC-104-specific support split off from the das08 driver.
  Configuration Options:
 	[0] - base io address
 cio-das08.pdf 
 unchecked 
 cio-das08pgx.pdf 
 unchecked 
 cio-das08pgx.pdf 
 unchecked 
 cio-das08pgx.pdf 
 unchecked 
 cio-das08_aox.pdf 
 unchecked 
 cio-das08_aox.pdf 
 unchecked 
 cio-das08_aox.pdf 
 unchecked 
 cio-das08-jr-ao.pdf 
 unchecked 
 cio-das08jr-16-ao.pdf 
 unchecked 
 unchecked 
 unchecked 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  adl_pci6208.c
  Comedi driver for ADLink 6208 series cards
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: adl_pci6208
  Description: ADLink PCI-62086216 Series Multi-channel Analog Output Cards
  Devices: [ADLink] PCI-6208 (adl_pci6208), PCI-6216
  Author: nsyeow <nsyeow@pd.jaring.my>
  Updated: Wed, 11 Feb 2015 11:37:18 +0000
  Status: untested
  Configuration Options: not applicable, uses PCI auto config
  All supported devices share the same PCI device ID and are treated as a
  PCI-6216 with 16 analog output channels.  On a PCI-6208, the upper 8
  channels exist in registers, but don't go to DAC chips.
  PCI-62086216-GL register map
 DA transfer rate is 2.2us 
 the hardware expects two's complement values 
 analog output subdevice 
 Only 8 usable on PCI-6208 
 digital input subdevice 
 digital output subdevice 
	
	  Get the read back signals from the digital outputs
	  and save it as the initial state for the subdevice.
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriversadl_pci8164.c
  Hardware comedi driver for PCI-8164 Adlink card
  Copyright (C) 2004 Michel Lachine <mike@mikelachaine.ca>
  Driver: adl_pci8164
  Description: Driver for the Adlink PCI-8164 4 Axes Motion Control board
  Devices: [ADLink] PCI-8164 (adl_pci8164)
  Author: Michel Lachaine <mike@mikelachaine.ca>
  Status: experimental
  Updated: Mon, 14 Apr 2008 15:10:32 +0100
  Configuration Options: not applicable, uses PCI auto config
 read MSTS register  write CMD register for each axis (channel) 
 read SSTS register  write OTP register for each axis (channel) 
 readwrite BUF0 register for each axis (channel) 
 readwrite BUF1 register for each axis (channel) 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  addi_apci_1032.c
  Copyright (C) 2004,2005  ADDI-DATA GmbH for the source code of this module.
  Project manager: Eric Stolz
 	ADDI-DATA GmbH
 	Dieselstrasse 3
 	D-77833 Ottersweier
 	Tel: +19(0)72239493-0
 	Fax: +49(0)72239493-92
 	http:www.addi-data.com
 	info@addi-data.com
  Driver: addi_apci_1032
  Description: ADDI-DATA APCI-1032 Digital Input Board
  Author: ADDI-DATA GmbH <info@addi-data.com>,
    H Hartley Sweeten <hsweeten@visionengravers.com>
  Status: untested
  Devices: [ADDI-DATA] APCI-1032 (addi_apci_1032)
  Configuration options:
    None; devices are configured automatically.
  This driver models the APCI-1032 as a 32-channel, digital input subdevice
  plus an additional digital input subdevice to handle change-of-state (COS)
  interrupts (if an interrupt handler can be set up successfully).
  The COS subdevice supports comedi asynchronous read commands.
  Change-Of-State (COS) interrupt configuration:
  Channels 0 to 15 are interruptible. These channels can be configured
  to generate interrupts based on ANDOR logic for the desired channels.
    OR logic:
    - reacts to rising or falling edges
    - interrupt is generated when any enabled channel meets the desired
      interrupt condition
    AND logic:
    - reacts to changes in level of the selected inputs
    - interrupt is generated when all enabled channels meet the desired
      interrupt condition
    - after an interrupt, a change in level must occur on the selected
      inputs to release the IRQ logic
  The COS subdevice must be configured before setting up a comedi
  asynchronous command:
    data[0] : INSN_CONFIG_DIGITAL_TRIG
    data[1] : trigger number (= 0)
    data[2] : configuration operation:
              - COMEDI_DIGITAL_TRIG_DISABLE = no interrupts
              - COMEDI_DIGITAL_TRIG_ENABLE_EDGES = OR (edge) interrupts
              - COMEDI_DIGITAL_TRIG_ENABLE_LEVELS = AND (level) interrupts
    data[3] : left-shift for data[4] and data[5]
    data[4] : rising-edgehigh level channels
    data[5] : falling-edgelow level channels
  IO Register Map
 base of AMCC IO registers 
 rising-edgehigh level channels 
 falling-edgelow level channels 
 interrupt mode OR (edge) . AND (level) 
 disable the interrupts 
 Reset the interrupt status register 
 Disable the andor interrupt 
 switching to 'OR' mode 
 wipe old channels 
 preserve unspecified channels 
 configure specified channels 
 switching to 'AND' mode 
 wipe old channels 
 preserve unspecified channels 
 configure specified channels 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 Step 4: fix up any arguments 
 Step 5: check channel list if it exists 
  Change-Of-State (COS) 'do_cmd' operation
  Enable the COS interrupt as configured by apci1032_cos_insn_config().
 check interrupt is from this device 
 check interrupt is enabled 
 disable the interrupt 
 enable the interrupt 
  Allocate and Initialise DI Subdevice Structures 
 Change-Of-State (COS) interrupt subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0
  quatech_daqp_cs.c
  Quatech DAQP PCMCIA data capture cards COMEDI client driver
  Copyright (C) 2000, 2003 Brent Baccala <baccala@freesoft.org>
  The DAQP interface code in this file is released into the public domain.
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1998 David A. Schleef <ds@schleef.org>
  https:www.comedi.org
  Documentation for the DAQP PCMCIA cards can be found on Quatech's site:
 	ftp:ftp.quatech.comManualsdaqp-208.pdf
  This manual is for both the DAQP-208 and the DAQP-308.
  What works:
  - AD conversion
 	- 8 channels
 	- 4 gain ranges
 	- ground ref or differential
 	- single-shot and timed both supported
  - DA conversion, single-shot
  - digital IO
  What doesn't:
  - any kind of triggering - external or DA channel 1
  - the card's optional expansion board
  - the card's timer (for anything other than AD conversion)
  - DA update modes other than immediate (i.e, timed)
  - fancier timing modes
  - setting card's FIFO buffer thresholds to anything but default
  Driver: quatech_daqp_cs
  Description: Quatech DAQP PCMCIA data capture cards
  Devices: [Quatech] DAQP-208 (daqp), DAQP-308
  Author: Brent Baccala <baccala@freesoft.org>
  Status: works
  Register IO map
  The DA and timer registers can be accessed with 16-bit or 8-bit IO
  instructions. All other registers can only use 8-bit instructions.
  The FIFO and scanlist registers require two 8-bit instructions to
  access the 16-bit data. Data is transferred LSB then MSB.
 0=one-shot; 1=continuous 
 0=internal; 1=external 
 0=rising; 1=falling 
 these bits clear when the status register is read 
 the monostable bits are self-clearing after the function is complete 
 monostable 
 monostable 
 monostable 
 monostable 
 monostable 
 and 0x09 (16-bit) 
 and 0x0b (16-bit) 
 Auxiliary Control register bits (write) 
 Auxiliary Status register bits (read) 
 100 kHz in nanoseconds 
	
	  Reset any pending interrupts (my card has a tendency to require
	  multiple reads on the status register to achieve this).
	
	  Stop any conversions, disable interrupts, and clear
	  the status event flags.
	
	  Get a two's complement sample from the FIFO and
	  return the munged offset binary value.
 Reset scan list queue 
 Program one scan list entry 
 Reset data FIFO (see page 28 of DAQP User's Manual) 
 Set trigger - one-shot, internal, no interrupts 
 Start conversion 
 clear the status event flags 
 stop any conversions and clear the status event flags 
 This function converts ns nanoseconds to a counter value suitable
  for programming the device.  We always use the DAQP's 5 MHz clock,
  which with its 24-bit counter, allows values up to 84 seconds.
  Also, the function adjusts ns so that it cooresponds to the actual
  time that the device will use.
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 the async command requires a pacer 
 Step 3: check if arguments are trivially valid 
			
			  If both scan_begin and convert are both timer
			  values, the only way that can make sense is if
			  the scan time is the number of conversions times
			  the convert time.
 TRIG_NONE 
 step 4: fix up any arguments 
 Reset scan list queue 
	 Program pacer clock
	 
	  There's two modes we can operate in.  If convert_src is
	  TRIG_TIMER, then convert_arg specifies the time between
	  each conversion, so we program the pacer clock to that
	  frequency and set the SCANLIST_START bit on every scanlist
	  entry.  Otherwise, convert_src is TRIG_NOW, which means
	  we want the fastest possible conversions, scan_begin_src
	  is TRIG_TIMER, and scan_begin_arg specifies the time between
	  each scan, so we program the pacer clock to this frequency
	  and only set the SCANLIST_START bit on the first entry.
 Program scan list 
	 Now it's time to program the FIFO threshold, basically the
	  number of samples the card will buffer before it interrupts
	  the CPU.
	 
	  If we don't have a stop count, then use half the size of
	  the FIFO (the manufacturer's recommendation).  Consider
	  that the FIFO can hold 2K samples (4K bytes).  With the
	  threshold set at half the FIFO size, we have a margin of
	  error of 1024 samples.  At the chip's maximum sample rate
	  of 100,000 Hz, the CPU would have to delay interrupt
	  service for a full 10 milliseconds in order to lose data
	  here (as opposed to higher up in the kernel).  I've never
	  seen it happen.  However, for slow sample rates it may
	  buffer too much data and introduce too much delay for the
	  user application.
	 
	  If we have a stop count, then things get more interesting.
	  If the stop count is less than the FIFO size (actually
	  three-quarters of the FIFO size - see below), we just use
	  the stop count itself as the threshold, the card interrupts
	  us when that many samples have been taken, and we kill the
	  acquisition at that point and are done.  If the stop count
	  is larger than that, then we divide it by 2 until it's less
	  than three quarters of the FIFO size (we always leave the
	  top quarter of the FIFO as protection against sluggish CPU
	  interrupt response) and use that as the threshold.  So, if
	  the stop count is 4000 samples, we divide by two twice to
	  get 1000 samples, use that as the threshold, take four
	  interrupts to get our 4000 samples and are done.
	 
	  The algorithm could be more clever.  For example, if 81000
	  samples are requested, we could set the threshold to 1500
	  samples and take 54 interrupts to get 81000.  But 54 isn't
	  a power of two, so this algorithm won't find that option.
	  Instead, it'll set the threshold at 1266 and take 64
	  interrupts to get 81024 samples, of which the last 24 will
	  be discarded... but we won't get the last interrupt until
	  they've been collected.  To find the first option, the
	  computer could look at the prime decomposition of the
	  sample count (81000 = 3^4  5^3  2^3) and factor it into a
	  threshold (1500 = 3  5^3  2^2) and an interrupt count (54
	  = 3^3  2).  Hmmm... a one-line while loop or prime
	  decomposition of integers... I'll leave it the way it is.
	 
	  I'll also note a mini-race condition before ignoring it in
	  the code.  Let's say we're taking 4000 samples, as before.
	  After 1000 samples, we get an interrupt.  But before that
	  interrupt is completely serviced, another sample is taken
	  and loaded into the FIFO.  Since the interrupt handler
	  empties the FIFO before returning, it will read 1001 samples.
	  If that happens four times, we'll end up taking 4004 samples,
	  not 4000.  The interrupt handler will discard the extra four
	  samples (by halting the acquisition with four samples still
	  in the FIFO), but we will have to wait for them.
	 
	  In short, this code works pretty well, but for either of
	  the two reasons noted, might end up waiting for a few more
	  samples than actually requested.  Shouldn't make too much
	  of a difference.
	 Save away the number of conversions we should perform, and
	  compute the FIFO threshold (in bytes, not samples - that's
	  why we multiple devpriv->count by 2 = sizeof(sample))
 Reset data FIFO (see page 28 of DAQP User's Manual) 
	 Set FIFO threshold.  First two bytes are near-empty
	  threshold, which is unused; next two bytes are near-full
	  threshold.  We computed the number of bytes we want in the
	  FIFO when the interrupt is generated, what the card wants
	  is actually the number of available bytes left in the FIFO
	  when the interrupt is to happen.
 Set trigger - continuous, internal 
 Start conversion 
 Make sure DA update mode is direct update 
 DA transfer rate is about 8ms 
 write the two's complement value to the channel 
	
	  Digital Input subdevice
	  NOTE: The digital input lines are shared:
	 
	  Chan  Normal Mode        Expansion Mode
	  ----  -----------------  ----------------------------
	   0    DI0, ext. trigger  Same as normal mode
	   1    DI1                External gain select, lo bit
	   2    DI2, ext. clock    Same as normal mode
	   3    DI3                External gain select, hi bit
	
	  Digital Output subdevice
	  NOTE: The digital output lines share the same pins on the
	  interface connector as the four external channel selection
	  bits. If expansion mode is used the digital outputs do not
	  work.
 Mark the device as stopped, to block IO until later 
 SPDX-License-Identifier: GPL-2.0+
  gsc_hpdi.c
  Comedi driver the General Standards Corporation
  High Speed Parallel Digital Interface rs485 boards.
  Author:  Frank Mori Hess <fmhess@users.sourceforge.net>
  Copyright (C) 2003 Coherent Imaging Systems
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
  Driver: gsc_hpdi
  Description: General Standards Corporation High
     Speed Parallel Digital Interface rs485 boards
  Author: Frank Mori Hess <fmhess@users.sourceforge.net>
  Status: only receive mode works, transmit not supported
  Updated: Thu, 01 Nov 2012 16:17:38 +0000
  Devices: [General Standards Corporation] PCI-HPDI32 (gsc_hpdi),
    PMC-HPDI32
  Configuration options:
     None.
  Manual configuration of supported devices is not supported; they are
  configured automatically.
  There are some additional hpdi models available from GSC for which
  support could be added to this driver.
  PCI BAR2 Register map (dev->mmio)
 ch 0 only 
 20MHz master clock 
 dma buffers 
 physical addresses of dma buffers 
	
	  array of dma descriptors read by plx9080, allocated to get proper
	  alignment
 physical address of dma descriptor array 
 pointer to start of buffers indexed by descriptor 
 index of the dma descriptor that is currently being used 
 number of bytes at which to generate COMEDI_CB_BLOCK events 
 loop until we have read all the full buffers 
 transfer data from dma buffer to comedi buffer 
 XXX check for buffer overrun somehow 
 spin lock makes sure no one else changes plx dma control reg 
 dma chan 0 interrupt 
 spin lock makes sure no one else changes plx dma control reg 
 XXX  
 clear possible plx9080 interrupt sources 
 clear local doorbell interrupt 
 spinlock for plx dma controlstatus reg 
	
	  These register are supposedly unused during chained dma,
	  but I have found that left over values from last operation
	  occasionally cause problems with transfer of first dma
	  block.  Initializing them to zero seems to fix the problem.
 give location of first dma descriptor 
 enable dma transfer 
 clear overunder run status flags 
 enable interrupts 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_NONE 
 Step 4: fix up any arguments 
 Step 5: check channel list if it exists 
 setup dma descriptors so a link completes every 'len' bytes 
 fix last descriptor to point back to first 
 free pci dma buffers 
 free dma descriptors 
 wait 10usec after reset before accessing fifos 
 enable interrupts 
 configure dma0 mode 
 enable ready input 
 enable dma chaining 
	
	  enable interrupt on dma done
	  (probably don't need this, since chain never finishes)
	
	  don't increment local address during transfers
	  (we are transferring from a fixed fifo register)
 route dma interrupt to pci bus 
 enable demand mode 
 enable local burst mode 
 get irq 
 allocate pci dma buffers 
 allocate dma descriptors 
 Digital IO subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedi_8255.c
  Generic 8255 digital IO support
  Split from the Comedi "8255" driver module.
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1998 David A. Schleef <ds@schleef.org>
  Module: comedi_8255
  Description: Generic 8255 support
  Author: ds
  Updated: Fri, 22 May 2015 12:14:17 +0000
  Status: works
  This module is not used directly by end-users.  Rather, it is used by
  other drivers to provide support for an 8255 "Programmable Peripheral
  Interface" (PPI) chip.
  The classic in digital IO.  The 8255 appears in Comedi as a single
  digital IO subdevice with 24 channels.  The channel 0 corresponds to
  the 8255's port A, bit 0; channel 23 corresponds to port C, bit 7.
  Direction configuration is done in blocks, with channels 0-7, 8-15,
  16-19, and 20-23 making up the 4 blocks.  The only 8255 mode
  supported is mode 0.
 1 in io_bits indicates output, 1 in config indicates input 
  subdev_8255_init - initialize DIO subdevice for driving IO mapped 8255
  @dev: comedi device owning subdevice
  @s: comedi subdevice to initialize
  @io: (optional) register IO call-back function
  @regbase: offset of 8255 registers from dev->iobase, or call-back context
  Initializes a comedi subdevice as a DIO subdevice driving an 8255 chip.
  If the optional IO call-back function is provided, its prototype is of
  the following form:
    int my_8255_callback(struct comedi_device dev, int dir, int port,
                         int data, unsigned long regbase);
  where 'dev', and 'regbase' match the values passed to this function,
  'port' is the 8255 port number 0 to 3 (including the control port), 'dir'
  is the direction (0 for read, 1 for write) and 'data' is the value to be
  written.  It should return 0 if writing or the value read if reading.
  If the optional IO call-back function is not provided, an internal
  call-back function is used which uses consecutive IO port addresses
  starting at dev->iobase + regbase.
  Return: -ENOMEM if failed to allocate memory, zero on success.
  subdev_8255_mm_init - initialize DIO subdevice for driving mmio-mapped 8255
  @dev: comedi device owning subdevice
  @s: comedi subdevice to initialize
  @io: (optional) register IO call-back function
  @regbase: offset of 8255 registers from dev->mmio, or call-back context
  Initializes a comedi subdevice as a DIO subdevice driving an 8255 chip.
  If the optional IO call-back function is provided, its prototype is of
  the following form:
    int my_8255_callback(struct comedi_device dev, int dir, int port,
                         int data, unsigned long regbase);
  where 'dev', and 'regbase' match the values passed to this function,
  'port' is the 8255 port number 0 to 3 (including the control port), 'dir'
  is the direction (0 for read, 1 for write) and 'data' is the value to be
  written.  It should return 0 if writing or the value read if reading.
  If the optional IO call-back function is not provided, an internal
  call-back function is used which uses consecutive MMIO virtual addresses
  starting at dev->mmio + regbase.
  Return: -ENOMEM if failed to allocate memory, zero on success.
  subdev_8255_regbase - get offset of 8255 registers or call-back context
  @s: comedi subdevice
  Returns the 'regbase' parameter that was previously passed to
  subdev_8255_init() or subdev_8255_mm_init() to set up the subdevice.
  Only valid if the subdevice was set up successfully.
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  adl_pci9111.c
  Hardware driver for PCI9111 ADLink cards: PCI-9111HR
  Copyright (C) 2002-2005 Emmanuel Pacaud <emmanuel.pacaud@univ-poitiers.fr>
  Driver: adl_pci9111
  Description: Adlink PCI-9111HR
  Devices: [ADLink] PCI-9111HR (adl_pci9111)
  Author: Emmanuel Pacaud <emmanuel.pacaud@univ-poitiers.fr>
  Status: experimental
  Configuration options: not applicable, uses PCI auto config
  Supports:
  - ai_insn read
  - ao_insn readwrite
  - di_insn read
  - do_insn readwrite
  - ai_do_cmd mode with the following sources:
 	- start_src		TRIG_NOW
 	- scan_begin_src	TRIG_FOLLOW	TRIG_TIMER	TRIG_EXT
 	- convert_src				TRIG_TIMER	TRIG_EXT
 	- scan_end_src		TRIG_COUNT
 	- stop_src		TRIG_COUNT	TRIG_NONE
  The scanned channels must be consecutive and start from 0. They must
  all have the same range and aref.
  TODO:
  - Really test implemented functionality.
  - Add support for the PCI-9111DG with a probe routine to identify
    the card type (perhaps with the help of the channel number readback
    of the AD Data register).
  - Add external multiplexer support.
  IO address map and bit defines
 PLX 9052 Local Interrupt 1 enabled and active 
 PLX 9052 Local Interrupt 2 enabled and active 
 Read the current interrupt control bits 
 Shift the bits so they are compatible with the write register 
 Mask off the ISCx bits 
 Now set the new ISCx bits 
 To reset the FIFO, set FFEN sequence as 0 -> 1 -> 0 
  Disable interrupts 
 disable AD triggers (software trigger mode) and auto scan off 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_EXT 
 TRIG_FOLLOW || TRIG_EXT 
 TRIG_NONE 
 Step 4: fix up any arguments 
	
	  There's only one timer on this card, so the scan_begin timer
	  must be a multiple of chanlist_lenconvert_arg
 Step 5: check channel list if it exists 
  Set channel scan limit 
  PCI9111 allows only scanning from channel 0 to channel n 
  TODO: handle the case of an external multiplexer 
  Set gain - all channels use the same range 
  Set timer pacer 
 TRIG_EXT 
  Ignore interrupt before device fully attached. 
  Might not even have allocated subdevices yet! 
  Check if we are source of interrupt 
  Not the source of the interrupt. 
  (N.B. not using PLX9052_INTCSR_SOFTINT) 
  Interrupt comes from fifo_half-full signal 
 '0' means FIFO is full, data may have been lost 
 '0' means FIFO is half-full 
 Generate a software trigger 
  Set trigger source to software 
 disable AD triggers (software trigger mode) and auto scan off 
 { PCI_DEVICE(PCI_VENDOR_ID_ADLINK, PCI9111_HG_DEVICE_ID) }, 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriverscb_pcimdas.c
  Comedi driver for Computer Boards PCIM-DAS160216 and PCIe-DAS160216
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: cb_pcimdas
  Description: Measurement Computing PCI Migration series boards
  Devices: [ComputerBoards] PCIM-DAS160216 (cb_pcimdas), PCIe-DAS160216
  Author: Richard Bytheway
  Updated: Mon, 13 Oct 2014 11:57:39 +0000
  Status: experimental
  Written to support the PCIM-DAS160216 and PCIe-DAS160216.
  Configuration Options:
    none
  Manual configuration of PCI(e) cards is not supported; they are configured
  automatically.
  Developed from cb_pcidas and skel by Richard Bytheway (mocelet@sucs.org).
  Only supports DIO, AO and simple AI in it's present form.
  No interrupts, multi channel or FIFO AI,
  although the card looks like it could support this.
  https:www.mccdaq.comPDFsManualspcim-das1602-16.pdf
  https:www.mccdaq.comPDFsManualspcie-das1602-16.pdf
  PCI Bar 1 Register map
  see plx9052.h for register and bit defines
  PCI Bar 2 Register map (devpriv->daqio)
  PCI Bar 3 Register map (devpriv->BADR3)
  PCI Bar 4 Register map (dev->iobase)
  The Analog Output range is not programmable. The DAC ranges are
  jumper-settable on the board. The settings are not software-readable.
  this structure is for data unique to this hardware driver.  If
  several hardware drivers keep similar information in this structure,
  feel free to suggest moving the variable to the struct comedi_device
  struct.
 base addresses 
  only support sw initiated reads from a single channel 
 configure for sw initiated read 
 set bursting off, conversions on 
 set range 
 set mux for single channel scan 
 convert n samples 
 trigger conversion 
 wait for conversion to end 
 read data 
 return the number of samples readwritten 
 internal 100 kHz clock 
 external clk on pin 21 
 The Pacer Clock jumper selects a 10 MHz or 1 MHz clock 
	
	  The number of Analog Input channels is set with the
	  Analog Input Mode Switch on the board. The board can
	  have 16 single-ended or 8 differential channels.
	
	  The Analog Input range polarity is set with the
	  Analog Input Polarity Switch on the board. The
	  inputs can be set to Unipolar or Bipolar ranges.
 Analog Input subdevice 
 Analog Output subdevice 
 Digital IO subdevice 
 Digital Input subdevice (main connector) 
 Digital Output subdevice (main connector) 
 Counter subdevice (8254) 
 counters 1 and 2 are used internally for the pacer 
 PCIM-DAS160216 
 PCIe-DAS160216 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  cb_pcidas.c
  Developed by Ivan Martinez and Frank Mori Hess, with valuable help from
  David Schleef and the rest of the Comedi developers comunity.
  Copyright (C) 2001-2003 Ivan Martinez <imr@oersted.dtu.dk>
  Copyright (C) 2001,2002 Frank Mori Hess <fmhess@users.sourceforge.net>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
  Driver: cb_pcidas
  Description: MeasurementComputing PCI-DAS series
    with the AMCC S5933 PCI controller
  Devices: [Measurement Computing] PCI-DAS160216 (cb_pcidas),
    PCI-DAS160216jr, PCI-DAS160212, PCI-DAS1200, PCI-DAS1200jr,
    PCI-DAS1000, PCI-DAS1001, PCI_DAS1002
  Author: Ivan Martinez <imr@oersted.dtu.dk>,
    Frank Mori Hess <fmhess@users.sourceforge.net>
  Updated: 2003-3-11
  Status:
  There are many reports of the driver being used with most of the
  supported cards. Despite no detailed log is maintained, it can
  be said that the driver is quite tested and stable.
  The boards may be autocalibrated using the comedi_calibrate
  utility.
  Configuration options: not applicable, uses PCI auto config
  For commands, the scanned channels must be consecutive
  (i.e. 4-5-6-7, 2-3-4,...), and must all have the same
  range and aref.
  AI Triggering:
  For start_src == TRIG_EXT, the AD EXTERNAL TRIGGER IN (pin 45) is used.
  For 1602 series, the start_arg is interpreted as follows:
 	start_arg == 0                   => gated trigger (level high)
 	start_arg == CR_INVERT           => gated trigger (level low)
 	start_arg == CR_EDGE             => Rising edge
 	start_arg == CR_EDGE | CR_INVERT => Falling edge
  For the other boards the trigger will be done on rising edge
  TODO:
  analog triggering on 1602 series
 max ai fifo size 
 max ao fifo size 
  PCI BAR1 Register map (devpriv->pcibar1)
 INTERRUPT  ADC FIFO register 
 no int selected 
 int on end of scan 
 int on fifo half full 
 int on fifo not empty 
 mask of int select bits 
 int enable 
 dac half full int enable 
 end of acq. int enable 
 dac half full status  clear 
 end of acq. int status  clear 
 int status  clear 
 end of burst int status 
 half-full int status 
 fifo not empty int status (latch) 
 fifo not empty status (realtime) 
 dac empty int enable 
 fifo overflow  clear 
 dac fifo empty int status  clear 
 ADC CHANNEL MUX AND CONTROL reg 
 Inputs in single-ended mode 
 Analog front-end unipolar mode 
 software pacer 
 int. pacer 
 ext. falling edge 
 ext. rising edge 
 pacer source bits 
 adc not busy 
 TRIGGER CONTROLSTATUS register 
 no start trigger 
 software start trigger 
 ext. start trigger 
 ext. analog trigger 
 start trigger mask 
 invert trigger (1602 only) 
 edgelevel triggered (1602 only) 
 enable external start trigger 
 burst mode enable 
 clear external trigger 
 CALIBRATION register 
 select 8800 caldac 
 select ad7376 trim pot 
 select dac08 caldac 
 calibration source enable 
 serial data bit going to caldac 
 dac control and status register 
 fifo empty, write clear (1602) 
 dac enable 
 startarm fifo (1602) 
 (1602) 
 software pacer 
 int. pacer 
 ext. falling edge 
 ext. rising edge 
 pacer source bits 
 update both dacs 
  PCI BAR2 Register map (devpriv->pcibar2)
  PCI BAR3 Register map (dev->iobase)
  PCI BAR4 Register map (devpriv->pcibar4)
 analog input ranges for most boards 
 pci-das1001 input ranges 
 analog output ranges 
  fastest conversion period in ns 
  analog output scan speed for 1602 series 
  number of samples fifo can hold 
 aiao is 1=16-bit; 0=12-bit 
 use alternate ai range table 
 has 2 analog output channels 
 analog output has fifo 
 trimpot type 1=AD8402; 0=AD7376 
 base addresses 
 pcibar0 
 bits to write to registers 
 fifo buffers 
 enable calibration input if appropriate 
 set mux limits and gain 
 set unipolarbipolar 
 set single-endeddifferential 
 clear fifo 
 convert n samples 
 trigger conversion 
 wait for conversion to end 
 read data 
 return the number of samples readwritten 
 analog output insn for pcidas-1000 and 1200 series 
 set channel and range 
 analog output insn for pcidas-1602 series 
 clear dac fifo 
 set channel and range 
 make sure eeprom is ready 
 set address (chan) and read operation 
 wait for data to be returned 
 select trimpot 
 write bitstream to calibration device 
 select caldac 
 latch value to trimpotcaldac 
 write 11-bit channelvalue to caldac 
 latch the new value into the caldac 
 write 10-bit channelvalue to AD8402 trimpot 
 write 7-bit value to AD7376 trimpot 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 External trigger, only CR_EDGE and CR_INVERT flags allowed 
 TRIG_NONE 
 step 4: fix up any arguments 
 Step 5: check channel list if it exists 
  make sure PCIDAS_CALIB_EN is disabled 
  initialize before settings pacer source and count values 
  clear fifo 
  set mux limits, gain and pacer source 
  set unipolarbipolar 
  set singleendeddifferential 
  set pacer source 
  load counters 
  enable interrupts 
 interrupt end of burst 
 interrupt fifo not empty 
 interrupt fifo half full 
  enable (and clear) interrupts 
  set start trigger and burst mode 
 TRIG_EXT 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_NONE 
 step 4: fix up any arguments 
 Step 5: check channel list if it exists 
  disable interrupts 
  disable start trigger source and burst mode 
  enable dac half-full and empty interrupts 
  enable and clear interrupts 
  start dac 
  set channel limits, gain 
  enable channel 
  set range 
  disable analog out before settings pacer source and count values 
  clear fifo 
  load counters 
  set pacer source 
  disable interrupts 
  disable output 
 FIFO is half-full - read data 
 FIFO is not empty - read data until empty or timeoout 
  break if fifo is empty 
 check for fifo overflow 
  make sure mailbox 4 is empty 
  clear interrupt on amcc s5933 
 handle analog output interrupts 
 handle analog input interrupts 
  disable and clear interrupts on amcc s5933 
 Analog Input subdevice 
 Analog Output subdevice 
 8255 
 Memory subdevice - serial EEPROM 
 Calibration subdevice - 8800 caldac 
 write 11-bit channelvalue to caldac 
 Calibration subdevice - trim potentiometer 
		
		  pci-das160216 have an AD8402 trimpot:
		    chan 0 : adc gain
		    chan 1 : adc postgain offset
 all other boards have an AD7376 trimpot 
 Calibration subdevice - pci-das160216 pregain offset (dac08) 
  make sure mailbox 4 is empty 
 Set bits to enable incoming mailbox interrupts on amcc s5933. 
  clear and enable interrupt on amcc s5933 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  addi_apci_2200.c
  Copyright (C) 2004,2005  ADDI-DATA GmbH for the source code of this module.
  Project manager: Eric Stolz
 	ADDI-DATA GmbH
 	Dieselstrasse 3
 	D-77833 Ottersweier
 	Tel: +19(0)72239493-0
 	Fax: +49(0)72239493-92
 	http:www.addi-data.com
 	info@addi-data.com
  IO Register Map
 Initialize the digital input subdevice 
 Initialize the digital output subdevice 
 Initialize the watchdog subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriverss626.c
  Sensoray s626 Comedi driver
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Based on Sensoray Model 626 Linux driver Version 0.2
  Copyright (C) 2002-2004 Sensoray Co., Inc.
  Driver: s626
  Description: Sensoray 626 driver
  Devices: [Sensoray] 626 (s626)
  Authors: Gianluca Palli <gpalli@deis.unibo.it>,
  Updated: Fri, 15 Feb 2008 10:28:42 +0000
  Status: experimental
  Configuration options: not applicable, uses PCI auto config
  INSN_CONFIG instructions:
    analog input:
     none
    analog output:
     none
    digital channel:
     s626 has 3 dio subdevices (2,3 and 4) each with 16 io channels
     supported configuration options:
     INSN_CONFIG_DIO_QUERY
     COMEDI_INPUT
     COMEDI_OUTPUT
    encoder:
     Every channel must be configured before reading.
    Example code
     insn.insn=INSN_CONFIG;   configuration instruction
     insn.n=1;                number of operation (must be 1)
     insn.data=&initialvalue; initial value loaded into encoder
                              during configuration
     insn.subdev=5;           encoder subdevice
     insn.chanspec=CR_PACK(encoder_channel,0,AREF_OTHER); encoder_channel
                                                          to configure
     comedi_do_insn(cf,&insn); executing configuration
  struct s626_private - Working data for s626 driver.
  @ai_cmd_running: non-zero if ai_cmd is running.
  @ai_sample_timer: time between samples in units of the timer.
  @ai_convert_count: conversion counter.
  @ai_convert_timer: time between conversion in units of the timer.
  @counter_int_enabs: counter interrupt enable mask for MISC2 register.
  @adc_items: number of items in ADC poll list.
  @rps_buf: DMA buffer used to hold ADC (RPS1) program.
  @ana_buf:  DMA buffer used to receive ADC data and hold DAC data.
  @dac_wbuf: pointer to logical adrs of DMA buffer used to hold DAC data.
  @dacpol: image of DAC polarity register.
  @trim_setpoint: images of TrimDAC setpoints.
  @i2c_adrs: I2C device address for onboard EEPROM (board rev dependent)
 Counter overflowindex event flag masks for RDMISC2. 
  Enabledisable a function or test status bit(s) that are accessed
  through Main Control Registers 1 or 2.
 Write a time slot control record to TSL2. 
  Execute a DEBI transfer.  This must be called from within a critical section.
 Initiate upload of shadow RAM to DEBI control register 
	
	  Wait for completion of upload from shadow RAM to
	  DEBI control register.
 Wait until DEBI transfer is done 
  Read a value from a gate array register.
 Set up DEBI control register value in shadow RAM 
  Execute the DEBI transfer. 
  Write a value to a gate array register.
 Set up DEBI control register value in shadow RAM 
  Execute the DEBI transfer. 
  Replace the specified bits in a gate array register.  Imports: mask
  specifies bits that are to be preserved, wdata is new value to be
  or'd with the masked original.
   EEPROM ACCESS FUNCTIONS   
 Write I2C command to I2C Transfer Control shadow register 
	
	  Upload I2C shadow registers into working registers and
	  wait for upload confirmation.
 Wait until I2C bus transfer is finished or an error occurs 
 Return non-zero if I2C error occurred 
 Read u8 from EEPROM. 
	
	  Send EEPROM target address:
	   Byte2 = I2C command: write to I2C EEPROM device.
	   Byte1 = EEPROM internal target address.
	   Byte0 = Not sent.
 Abort function and declare error if handshake failed. 
	
	  Execute EEPROM read:
	   Byte2 = I2C command: read from I2C EEPROM device.
	   Byte1 receives uint8_t from EEPROM.
	   Byte0 = Not sent.
 Abort function and declare error if handshake failed. 
   DAC FUNCTIONS  
 TrimDac LogicalChan-to-PhysicalChan mapping table. 
 TrimDac LogicalChan-to-EepromAdrs mapping table. 
  Private helper function: Transmit serial data to DAC via Audio
  channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
  dacpol contains valid target image.
 START THE SERIAL CLOCK RUNNING ------------- 
	
	  Assert DAC polarity control and enable gating of DAC serial clock
	  and audio bit stream signals.  At this point in time we must be
	  assured of being in time slot 0.  If we are not in slot 0, the
	  serial clock and audio stream signals will be disabled; this is
	  because the following s626_debi_write statement (which enables
	  signals to be passed through the gate array) would execute before
	  the trailing edge of WS1WS3 (which turns off the signals), thus
	  causing the signals to be inactive during the DAC write.
 TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ---------------- 
 Copy DAC setpoint value to DAC's output DMA buffer. 
 writel(val, dev->mmio + (uint32_t)devpriv->dac_wbuf); 
	
	  Enable the output DMA transfer. This will cause the DMAC to copy
	  the DAC's data value to A2's output FIFO. The DMA transfer will
	  then immediately terminate because the protection address is
	  reached upon transfer of the first DWORD value.
 While the DMA transfer is executing ... 
	
	  Reset Audio2 output FIFO's underflow flag (along with any
	  other FIFO underflowoverflow flags). When set, this flag
	  will indicate that we have emerged from slot 0.
	
	  Wait for the DMA transfer to finish so that there will be data
	  available in the FIFO when time slot 1 tries to transfer a DWORD
	  from the FIFO to the output buffer register.  We test for DMA
	  Done by polling the DMAC enable flag; this flag is automatically
	  cleared when the transfer has finished.
 START THE OUTPUT STREAM TO THE TARGET DAC -------------------- 
	
	  FIFO data is now available, so we enable execution of time slots
	  1 and higher by clearing the EOS flag in slot 0.  Note that SD3
	  will be shifted in and stored in FB_BUFFER2 for end-of-slot-list
	  detection.
	
	  Wait for slot 1 to execute to ensure that the Packet will be
	  transmitted.  This is detected by polling the Audio2 output FIFO
	  underflow flag, which will be set when slot 1 execution has
	  finished transferring the DAC's data DWORD from the output FIFO
	  to the output buffer register.
	
	  Set up to trap execution at slot 0 when the TSL sequencer cycles
	  back to slot 0 after executing the EOS in slot 5.  Also,
	  simultaneously shift out and in the 0x00 that is ALWAYS the value
	  stored in the last byte to be shifted out of the FIFO's DWORD
	  buffer register.
 WAIT FOR THE TRANSACTION TO FINISH ----------------------- 
	
	  Wait for the TSL to finish executing all time slots before
	  exiting this function.  We must do this so that the next DAC
	  write doesn't start, thereby enabling clockchip select signals:
	 
	  1. Before the TSL sequence cycles back to slot 0, which disables
	     the clockcs signal gating and traps slot  list execution.
	     we have not yet finished slot 5 then the clockcs signals are
	     still gated and we have not finished transmitting the stream.
	 
	  2. While slots 2-5 are executing due to a late slot 0 trap.  In
	     this case, the slot sequence is currently repeating, but with
	     clockcs signals disabled.  We must wait for slot 0 to trap
	     execution before setting up the next DAC setpoint DMA transfer
	     and enabling the clockcs signals.  To detect the end of slot 5,
	     we test for the FB_BUFFER2 MSB contents to be equal to 0xFF.  If
	     the TSL has not yet finished executing slot 5 ...
		
		  The trap was set on time and we are still executing somewhere
		  in slots 2-5, so we now wait for slot 0 to execute and trap
		  TSL execution.  This is detected when FB_BUFFER2 MSB changes
		  from 0xFF to 0x00, which slot 0 causes to happen by shifting
		  outin on SD2 the 0x00 that is always referenced by slot 5.
	
	  Either (1) we were too late setting the slot 0 trap; the TSL
	  sequencer restarted slot 0 before we could set the EOS trap flag,
	  or (2) we were not late and execution is now trapped at slot 0.
	  In either case, we must now change slot 0 so that it will store
	  value 0xFF (instead of 0x00) to FB_BUFFER2 next time it executes.
	  In order to do this, we reprogram slot 0 so that it will shift in
	  SD3, which is driven only by a pull-up resistor.
	
	  Wait for slot 0 to execute, at which time the TSL is setup for
	  the next DAC write.  This is detected when FB_BUFFER2 MSB changes
	  from 0x00 to 0xFF.
  Private helper function: Write setpoint to an application DAC channel.
	
	  Adjust DAC data polarity and set up Polarity Control Register image.
 Limit DAC setpoint value to valid range. 
	
	  Set up TSL2 records (aka "vectors") for DAC update.  Vectors V2
	  and V3 transmit the setpoint to the target DAC.  V4 and V5 send
	  data to a non-existent TrimDac channel just to keep the clock
	  running after sending data to the target DAC.  This is necessary
	  to eliminate the clock glitch that would otherwise occur at the
	  end of the target DAC's serial data stream.  When the sequence
	  restarts at V0 (after executing V5), the gate array automatically
	  disables gating for the DAC clock and all DAC chip selects.
 Choose DAC chip select to be asserted 
 Slot 2: Transmit high data byte to target DAC 
 Slot 3: Transmit low data byte to target DAC 
 Slot 4: Transmit to non-existent TrimDac channel to keep clock 
 Slot 5: running after writing target DAC's low data byte 
	
	  Construct and transmit target DAC's serial packet:
	  (A10D DDDD), (DDDD DDDD), (0x0F), (0x00) where A is chan<0>,
	  and D<12:0> is the DAC setpoint.  Append a WORD value (that writes
	  to a  non-existent TrimDac channel) that serves to keep the clock
	  running after the packet has been sent to the target DAC.
	val = 0x0F000000;	 Continue clock after target DAC data
				  (write to non-existent trimdac).
	val |= 0x00004000;	 Address the two main dual-DAC devices
				  (TSL's chip select enables target device).
	val |= ((u32)(chan & 1) << 15);	 Address the DAC channel
					  within the device.
 Include DAC setpoint data. 
	
	  Save the new setpoint in case the application needs to read it back
	  later.
 Map logical channel number to physical channel number. 
	
	  Set up TSL2 records for TrimDac write operation.  All slots shift
	  0xFF in from pulled-up SD3 so that the end of the slot sequence
	  can be detected.
 Slot 2: Send high uint8_t to target TrimDac 
 Slot 3: Send low uint8_t to target TrimDac 
 Slot 4: Send NOP high uint8_t to DAC0 to keep clock running 
 Slot 5: Send NOP low  uint8_t to DAC0 
	
	  Construct and transmit target DAC's serial packet:
	  (0000 AAAA), (DDDD DDDD), (0x00), (0x00) where A<3:0> is the
	  DAC channel's address, and D<7:0> is the DAC setpoint.  Append a
	  WORD value (that writes a channel 0 NOP command to a non-existent
	  main DAC channel) that serves to keep the clock running after the
	  packet has been sent to the target DAC.
	
	  Address the DAC channel within the trimdac device.
	  Include DAC setpoint data.
 Copy TrimDac setpoint values from EEPROM to TrimDacs. 
   COUNTER FUNCTIONS   
  All counter functions address a specific counter by means of the
  "Counter" argument, which is a logical counter number.  The Counter
  argument may have any of the following legal values: 0=0A, 1=1A,
  2=2A, 3=0B, 4=1B, 5=2B.
  Returnset a counter pair's latch trigger source.  0: On read
  access, 1: A index latches A, 2: B index latches B, 3: A overflow
  latches B.
  Write value into counter preload register.
   PRIVATE COUNTER FUNCTIONS  
  Reset a counter's index and overflow event capture flags.
  Set the operating mode for the specified counter.  The setup
  parameter is treated as a COUNTER_SETUP data type.  The following
  parameters are programmable (all other parms are ignored): ClkMult,
  ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
 Initialize CRA and CRB images. 
 Preload trigger is passed through. 
 IndexSrc is passed through. 
 Reset any pending CounterA event captures. 
 Clock enable is passed through. 
 Force IntSrc to Disabled if disable_int_src is asserted. 
 Populate all mode-dependent attributes of CRA & CRB images. 
 Extender Mode: 
 Force to Timer mode (Extender valid only for B counters). 
 Fall through to case S626_ENCMODE_TIMER: 
 Timer Mode: 
 CntSrcA<1> selects system clock 
 Count direction (CntSrcA<0>) obtained from ClkPol. 
 ClkPolA behaves as always-on clock enable. 
 ClkMult must be 1x. 
 Counter Mode: 
 Select ENC_C and ENC_D as clockdirection inputs. 
 Clock polarity is passed through. 
 Force multiplier to x1 if not legal, else pass through. 
	
	  Force positive index polarity if IndxSrc is software-driven only,
	  otherwise pass it through.
	
	  If IntSrc has been forced to Disabled, update the MISC2 interrupt
	  enable mask to indicate the counter interrupt is disabled.
	
	  While retaining CounterB and LatchSrc configurations, program the
	  new counter operating mode.
 Initialize CRA and CRB images. 
 IndexSrc is passed through. 
 Reset event captures and disable interrupts. 
 Clock enable is passed through. 
 Preload trigger source is passed through. 
 Force IntSrc to Disabled if disable_int_src is asserted. 
 Populate all mode-dependent attributes of CRA & CRB images. 
 Timer Mode: 
 CntSrcB<1> selects system clock 
 with direction (CntSrcB<0>) obtained from ClkPol. 
 ClkPolB behaves as always-on clock enable. 
 ClkMultB must be 1x. 
 Extender Mode: 
 CntSrcB source is OverflowA (same as "timer") 
 with direction obtained from ClkPol. 
 ClkPolB controls IndexB -- always set to active. 
 ClkMultB selects OverflowA as the clock source. 
 Counter Mode: 
 Select ENC_C and ENC_D as clockdirection inputs. 
 ClkPol is passed through. 
 Force ClkMult to x1 if not legal, otherwise pass through. 
	
	  Force positive index polarity if IndxSrc is software-driven only,
	  otherwise pass it through.
	
	  If IntSrc has been forced to Disabled, update the MISC2 interrupt
	  enable mask to indicate the counter interrupt is disabled.
	
	  While retaining CounterA and LatchSrc configurations, program the
	  new counter operating mode.
  Returnset a counter's enable.  enab: 0=always enabled, 1=enabled by index.
  Returnset the event that will trigger transfer of the preload
  register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
  2=OverflowA (B counters only), 3=disabled.
  Returnset counter interrupt source and clear any captured
  indexoverflow events.  int_source: 0=Disabled, 1=OverflowOnly,
  2=IndexOnly, 3=IndexAndOverflow.
 Reset any pending counter overflow or index captures 
 Program counter interrupt source 
 Cache writeable CRB register image 
 Reset any pending counter overflow or index captures 
 Program counter interrupt source 
 Update MISC2 interrupt enable mask. 
  Generate an index pulse.
 Pulse index 
 Pulse index 
 set channel to capture positive edge 
 enable interrupt on selected channel 
 enable edge capture write command 
 enable edge capture on selected channel 
 disable edge capture write command 
 enable edge capture on selected channel 
 disable edge capture write command 
 clear all dio pending events and interrupt 
 check if interrupt is an ai acquisition start trigger 
 Start executing the RPS program 
 Trigger ADC scan loop start 
 Trigger ADC scan loop start 
 read interrupt type 
 check if interrupt is generated from dio channels 
 read interrupt type 
 check interrupt on counters 
 clear interrupt capture flag 
 clear interrupt capture flag 
 clear interrupt capture flag 
 clear interrupt capture flag 
 clear interrupt capture flag 
 Trigger ADC scan loop start 
 clear interrupt capture flag 
 Trigger ADC scan loop start 
	
	  Init ptr to DMA buffer that holds new ADC data.  We skip the
	  first uint16_t in the buffer because it contains junk data
	  from the final ADC of the previous poll list scan.
 get the data and hand it over to comedi 
		
		  Convert ADC data to 16-bit integer values and copy
		  to application buffer.
 lock to avoid race with comedi_poll 
 save interrupt enable register state 
 read interrupt type 
 disable master interrupt 
 clear interrupt 
 end_of_scan occurs 
 check dio and counter interrupt 
 s626_dio_clear_irq(dev); 
 enable interrupt 
  This function builds the RPS program for hardware driven acquisition.
 Stop RPS program in case it is currently running 
 Set starting logical address to write RPS commands. 
 Initialize RPS instruction pointer 
 Construct RPS program in rps_buf DMA buffer 
 Wait for Start trigger. 
	
	  SAA7146 BUG WORKAROUND Do a dummy DEBI Write.  This is necessary
	  because the first RPS DEBI Write following a non-RPS DEBI write
	  seems to always fail.  If we don't do this dummy write, the ADC
	  gain might not be set to the value required for the first slot in
	  the poll list; the ADC gain would instead remain unchanged from
	  the previously programmed value.
 Write DEBI Write command and address to shadow RAM. 
 Write DEBI immediate data  to shadow RAM: 
 arbitrary immediate data  value. 
 Reset "shadow RAM  uploaded" flag. 
 Invoke shadow RAM upload. 
 Wait for shadow upload to finish. 
	
	  Digitize all slots in the poll list. This is implemented as a
	  for loop to limit the slot count to 16 in case the application
	  forgot to set the S626_EOPL flag in the final slot.
		
		  Convert application's poll list item to private board class
		  format.  Each app poll list item is an uint8_t with form
		  (EOPL,x,x,RANGE,CHAN<3:0>), where RANGE code indicates 0 =
		  +-10V, 1 = +-5V, and EOPL = End of Poll List marker.
 Switch ADC analog gain. 
 Write DEBI command and address to shadow RAM. 
 Write DEBI immediate data to shadow RAM. 
 Reset "shadow RAM uploaded" flag. 
 Invoke shadow RAM upload. 
 Wait for shadow upload to finish. 
 Select ADC analog input channel. 
 Write DEBI command and address to shadow RAM. 
 Write DEBI immediate data to shadow RAM. 
 Reset "shadow RAM uploaded" flag. 
 Invoke shadow RAM upload. 
 Wait for shadow upload to finish. 
		
		  Delay at least 10 microseconds for analog input settling.
		  Instead of padding with NOPs, we use S626_RPS_JUMP
		  instructions here; this allows us to produce a longer delay
		  than is possible with NOPs because each S626_RPS_JUMP
		  flushes the RPS' instruction prefetch pipeline.
 Repeat to implement time delay: 
 Jump to next RPS instruction. 
 Wait for Start trigger. 
 Start ADC by pulsing GPIO1. 
 Begin ADC Start pulse. 
 VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. 
 End ADC Start pulse. 
		
		  Wait for ADC to complete (GPIO2 is asserted high when ADC not
		  busy) and for data from previous conversion to shift into FB
		  BUFFER 1 register.
 Wait for ADC done. 
 Transfer ADC data from FB BUFFER 1 register to DMA buffer. 
		
		  If this slot's EndOfPollList flag is set, all channels have
		  now been processed.
 Adjust poll list item count. 
 Exit poll list processing loop. 
	
	  VERSION 2.01 CHANGE: DELAY CHANGED FROM 250NS to 2US.  Allow the
	  ADC to stabilize for 2 microseconds before starting the final
	  (dummy) conversion.  This delay is necessary to allow sufficient
	  time between last conversion finished and the start of the dummy
	  conversion.  Without this delay, the last conversion's data value
	  is sometimes set to the previous conversion's data value.
	
	  Start a dummy conversion to cause the data from the last
	  conversion of interest to be shifted in.
 Begin ADC Start pulse. 
 VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. 
 End ADC Start pulse. 
	
	  Wait for the data from the last conversion of interest to arrive
	  in FB BUFFER 1 register.
 Wait for ADC done. 
 Transfer final ADC data from FB BUFFER 1 register to DMA buffer. 
 Indicate ADC scan loop is finished. 
 Signal ReadADC() that scan is done. 
 rps++= S626_RPS_CLRSIGNAL | S626_RPS_SIGADC; 
 invoke interrupt 
 Restart RPS program at its beginning. 
 Branch to start of RPS program. 
 End of RPS program build 
	
	  Convert application's ADC specification into form
	   appropriate for register programming.
 Switch ADC analog gain. 
 Set gain. 
 Select ADC analog input channel. 
 Select channel. 
 Delay 10 microseconds for analog input settling. 
 Start ADC by pulsing GPIO1 low 
 Assert ADC Start command 
 and stretch it out 
 Negate ADC Start command 
		
		  Wait for ADC to complete (GPIO2 is asserted high when
		  ADC not busy) and for data from previous conversion to
		  shift into FB BUFFER 1 register.
 Wait for ADC done 
 Fetch ADC data 
		
		  Allow the ADC to stabilize for 4 microseconds before
		  starting the next (final) conversion.  This delay is
		  necessary to allow sufficient time between last
		  conversion finished and the start of the next
		  conversion.  Without this delay, the last conversion's
		  data value is sometimes set to the previous
		  conversion's data value.
	
	  Start a dummy conversion to cause the data from the
	  previous conversion to be shifted in.
 Assert ADC Start command 
 and stretch it out 
 Negate ADC Start command 
 Wait for the data to arrive in FB BUFFER 1 register. 
 Wait for ADC done 
 Fetch ADC data from audio interface's input shift register. 
 Fetch ADC data 
 Start executing the RPS program 
  This function doesn't require a particular form, this is just what
  happens to be used in some of the drivers.  It should convert ns
  nanoseconds to a counter value suitable for programming the device.
  Also, it should adjust ns so that it cooresponds to the actual time
  that the device will use.
 2MHz internal clock 
 Preload upon index. 
 Disable hardware index. 
 Operating mode is Timer. 
 Count direction is Down. 
 Clock multiplier is 1x. 
 Enabled by index 
 uint16_t enab = S626_CLKENAB_ALWAYS; 
 Set the preload register 
	
	  Software index pulse forces the preload register to load
	  into the counter
 set reload on counter overflow 
 set interrupt on overflow 
 s626_set_enable(dev, chan, (uint16_t)(enab != 0)); 
 TO COMPLETE  
 disable interrupt 
 clear interrupt request 
 clear any pending interrupt 
 s626_enc_clear_irq(dev); 
 reset ai_cmd_running flag 
		
		  set a counter to generate adc trigger at scan_begin_arg
		  interval
 load timer value and enable interrupt 
 set the digital line and interrupt for scan trigger 
		
		  set a counter to generate adc trigger at convert_arg
		  interval
 load timer value and enable interrupt 
 set the digital line and interrupt for convert trigger 
 Trigger ADC scan loop start 
 s626_mc_enable(dev, S626_MC2_ADC_RPS, S626_P_MC2); 
 Start executing the RPS program 
 configure DIO channel for acquisition trigger 
 enable interrupt 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 in nanoseconds 
 in nanoseconds 
		
		  external trigger
		  should be leveledge, hilo specification here
		  should specify multiple external triggers
		  err |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg, 9);
		
		  external trigger - see above
		  err |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg, 9);
 TRIG_NONE 
 step 4: fix up any arguments 
 Stop RPS program in case it is currently running 
 disable master interrupt 
  DIGITAL IO FUNCTIONS  
  All DIO functions address a group of DIO channels by means of
  "group" argument.  group may be 0, 1 or 2, which correspond to DIO
  ports A, B and C, respectively.
 Prepare to treat writes to WRCapSel as capture disables. 
 For each group of sixteen channels ... 
 Disable all interrupts 
 Disable all event captures 
 Init all DIOs to default edge polarity 
 Program all outputs to inactive state 
  Now this function initializes the value of the counter (data[0])
  and set the subdevice. To complete with trigger and interrupt
  configuration.
  FIXME: data[0] is supposed to be an INSN_CONFIG_xxx constant indicating
  what is being configured, but this function appears to be using data[0]
  as a variable.
 Preload upon index. 
 Disable hardware index. 
 Operating mode is Counter. 
 Active high clock. 
 Clock multiplier is 1x. 
 Enabled by index 
 uint16_t disable_int_src = true; 
Counter initial value 
 (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); 
		
		  Read the counter's output latch LSWMSW.
		  Latches on LSW read.
 Set the preload register 
	
	  Software index pulse forces the preload register to load
	  into the counter
 Preload upon index. 
 Disable hardware index. 
 Operating mode is counter. 
 Active high clock. 
 Clock multiplier is 1x. 
 Enabled by index 
	
	  Disable all counter interrupts and clear any captured counter events.
 Enable DEBI and audio pins, enable I2C interface 
	
	  Configure DEBI operating mode
	 
	   Local bus is 16 bits wide
	   Declare DEBI transfer timeout interval
	   Set up byte lane steering
	   Intel-compatible local bus (DEBI never times out)
 Disable MMU paging 
 Init GPIO so that ADC Start is negated 
 I2C device address for onboard eeprom (revb) 
	
	  Issue an I2C ABORT command to halt any I2C
	  operation in progress and reset BUSY flag.
	
	  Per SAA7146 data sheet, write to STATUS
	  reg twice to reset all  I2C error flags.
	
	  Init audio interface functional attributes: set DACADC
	  serial clock rates, invert DAC serial clock so that
	  DAC data setup times are satisfied, enable DAC serial
	  clock out.
	
	  Set up TSL1 slot list, which is used to control the
	  accumulation of ADC data: S626_RSD1 = shift data in on SD1.
	  S626_SIB_A1  = store data uint8_t at next available location
	  in FB BUFFER1 register.
 Enable TSL1 slot list so that it executes all the time 
	
	  Initialize RPS registers used for ADC
 Physical start of RPS program 
 RPS program performs no explicit mem writes 
 Disable RPS timeouts 
	
	  SAA7146 BUG WORKAROUND
	 
	  Initialize SAA7146 ADC interface to a known state by
	  invoking ADCs until FB BUFFER 1 register shows that it
	  is correctly receiving ADC data. This is necessary
	  because the SAA7146 ADC interface does not start up in
	  a defined state after a PCI reset.
 Create a simple polling list for analog input channel 0 
 Get initial ADC value 
		
		  VERSION 2.01 CHANGE: TIMEOUT ADDED TO PREVENT HANGED
		  EXECUTION.
		 
		  Invoke ADCs until the new ADC value differs from the initial
		  value or a timeout occurs.  The timeout protects against the
		  possibility that the driver is restarting and the ADC data is
		  a fixed value resulting from the applied ADC analog input
		  being unusually quiet or at the rail.
 SAA7146 BUG WORKAROUND 
	
	  Initialize the DAC interface
	
	  Init Audio2's output DMAC attributes:
	    burst length = 1 DWORD
	    threshold = 1 DWORD.
	
	  Init Audio2's output DMA physical addresses.  The protection
	  address is set to 1 DWORD past the base address so that a
	  single DWORD will be transferred each time a DMA transfer is
	  enabled.
	
	  Cache Audio2's output DMA buffer logical address.  This is
	  where DAC data is buffered for A2 output DMA transfers.
	
	  Audio2's output channels does not use paging.  The
	  protection violation handling bit is set so that the
	  DMAC will automatically halt and its PCI address pointer
	  will be reset when the protection address is reached.
	
	  Initialize time slot list 2 (TSL2), which is used to control
	  the clock generation for and serialization of data to be sent
	  to the DAC devices.  Slot 0 is a NOP that is used to trap TSL
	  execution; this permits other slots to be safely modified
	  without first turning off the TSL sequencer (which is
	  apparently impossible to do).  Also, SD3 (which is driven by a
	  pull-up resistor) is shifted in and stored to the MSB of
	  FB_BUFFER2 to be used as evidence that the slot sequence has
	  not yet finished executing.
 Slot 0: Trap TSL execution, shift 0xFF into FB_BUFFER2 
	
	  Initialize slot 1, which is constant.  Slot 1 causes a
	  DWORD to be transferred from audio channel 2's output FIFO
	  to the FIFO's output buffer so that it can be serialized
	  and sent to the DAC during subsequent slots.  All remaining
	  slots are dynamically populated as required by the target
	  DAC device.
 Slot 1: Fetch DWORD from Audio2's output FIFO 
 Start DAC's audio interface (TSL2) running 
	
	  Init Trim DACs to calibrated values.  Do it twice because the
	  SAA7146 audio channel does not always reset properly and
	  sometimes causes the first few TrimDAC writes to malfunction.
	
	  Manually init all gate array hardware in case this is a soft
	  reset (we have no way of determining whether this is a warm
	  or cold start).  This is necessary because the gate array will
	  reset only in response to a PCI hard reset; there is no soft
	  reset function.
	
	  Init all DAC outputs to 0V and init all DAC setpoint and
	  polarity images.
 Init counters 
	
	  Without modifying the state of the Battery Backup enab, disable
	  the watchdog timer, set DIO channels 0-5 to operate in the
	  standard DIO (vs. counter overflow) mode, disable the battery
	  charger, and reset the watchdog interval selector to zero.
 Initialize the digital IO subsystem 
 disable master interrupt 
 soft reset 
 analog input subdevice 
 analog output subdevice 
 digital IO subdevice 
 DIO group 0 
 digital IO subdevice 
 DIO group 1 
 digital IO subdevice 
 DIO group 2 
 encoder (counter) subdevice 
 stop ai_command 
 interrupt mask 
 Disable master interrupt 
 Clear board's IRQ status flag 
 Disable the watchdog timer and battery charger. 
 Close all interfaces on 7146 device 
  For devices with vendor:device id == 0x1131:0x7146 you must specify
  also subvendor:subdevice ids, because otherwise it will conflict with
  Philips SAA7146 mediadvb based cards.
 SPDX-License-Identifier: GPL-2.0+
  Comedi driver for NI 670x devices
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1997-2001 David A. Schleef <ds@schleef.org>
  Driver: ni_670x
  Description: National Instruments 670x
  Author: Bart Joris <bjoris@advalvas.be>
  Updated: Wed, 11 Dec 2002 18:25:35 -0800
  Devices: [National Instruments] PCI-6703 (ni_670x), PCI-6704
  Status: unknown
  Commands are not supported.
  Manuals:
    322110a.pdf	PCIPXI-6704 User Manual
    322110b.pdf	PCIPXI-67036704 User Manual
	
	  Channel number mapping:
	 
	  NI 6703 NI 6704 | NI 6704 Only
	  -------------------------------
	  vch(0)  :  0     | ich(16) :  1
	  vch(1)  :  2     | ich(17) :  3
	  ...              | ...
	  vch(15) : 30     | ich(31) : 31
 First write in channel register which channel to use 
 write channel value 
 ripped from mite.h and mite_setup2() to avoid mite dependency 
 IO Device Window Base Size Register 
 window enable 
 ioremap the MITE registers (BAR 0) temporarily 
 set data window to main registers (BAR 1) 
 finished with MITE registers 
 analog output subdevice 
 digital io subdevice 
 Config of misc registers 
 Config of ao registers 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  das6402.c
  Comedi driver for DAS6402 compatible boards
  Copyright(c) 2014 H Hartley Sweeten <hsweeten@visionengravers.com>
  Rewrite of an experimental driver by:
  Copyright (C) 1999 Oystein Svendsen <svendsen@pvv.org>
  Driver: das6402
  Description: Keithley Metrabyte DAS6402 (& compatibles)
  Devices: [Keithley Metrabyte] DAS6402-12 (das6402-12),
    DAS6402-16 (das6402-16)
  Author: H Hartley Sweeten <hsweeten@visionengravers.com>
  Updated: Fri, 14 Mar 2014 10:18:43 -0700
  Status: unknown
  Configuration Options:
    [0] - IO base address
    [1] - IRQ (optional, needed for async command support)
  Register IO map
  Analog output ranges are programmable on the DAS640212.
  For the DAS640216 the range bits have no function, the
  DAC ranges are selected by switches on the board.
 load the mux for chanlist conversion 
 enable interrupt and pacer trigger 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_NONE 
 step 4: fix up any arguments 
 Step 5: check channel list if it exists 
 enable software conversion trigger 
 load the mux for single channel conversion 
 set the range for this channel 
	
	  The DAS640216 has a jumper to select either individual
	  update (UPDATE) or simultaneous updating (XFER) of both
	  DAC's. In UPDATE mode, when the MSB is written, that DAC
	  is updated. In XFER mode, after both DAC's are loaded,
	  a read cycle of any DAC register will update both DAC's
	  simultaneously.
	 
	  If you have XFER mode enabled a (insn_read) will need
	  to be performed in order to update the DAC's with the
	  last value written.
			
			  DAS640212 has the two 8-bit DAC registers, left
			  justified (the 4 LSB bits are don't care). Data
			  can be written as one word.
			
			  DAS640216 uses both 8-bit DAC registers and needs
			  to be written LSB then MSB.
	
	  If XFER mode is enabled, reading any DAC register
	  will update both DAC's simultaneously.
 enable "Enhanced" mode 
 enable 10MHz pacer clock 
 enable software conversion trigger 
 default ADC to single-ended unipolar 10V inputs 
 default mux for single channel conversion (channel 0) 
 set both DAC's for unipolar 5V output range 
 set both DAC's to 0V 
 set all digital outputs low 
 IRQs 2,3,5,6,7, 10,11,15 are valid for "enhanced" mode 
 Analog Input subdevice 
 Analog Output subdevice 
 Digital Input subdevice 
 Digital Input subdevice 
 SPDX-License-Identifier: GPL-2.0+
  adq12b.c
  Driver for MicroAxial ADQ12-B data acquisition and control card
  written by jeremy theler <thelerg@ib.cnea.gov.ar>
 	instituto balseiro
 	commission nacional de energia atomica
 	universidad nacional de cuyo
 	argentina
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: adq12b
  Description: Driver for MicroAxial ADQ12-B data acquisition and control card
  Devices: [MicroAxial] ADQ12-B (adq12b)
  Author: jeremy theler <thelerg@ib.cnea.gov.ar>
  Updated: Thu, 21 Feb 2008 02:56:27 -0300
  Status: works
  Configuration options:
    [0] - IO base address (set with hardware jumpers)
 		address		jumper JADR
 		0x300		1 (factory default)
 		0x320		2
 		0x340		3
 		0x360		4
 		0x380		5
 		0x3A0		6
    [1] - Analog Input unipolarbipolar selection
 		selection	option	JUB
 		bipolar		0	2-3 (factory default)
 		unipolar	1	1-2
    [2] - Analog Input single-endeddifferential selection
 		selection	option	JCHA	JCHB
 		single-ended	0	1-2	1-2 (factory default)
 		differential	1	2-3	2-3
  Driver for the acquisition card ADQ12-B (without any add-on).
  - Analog input is subdevice 0 (16 channels single-ended or 8 differential)
  - Digital input is subdevice 1 (5 channels)
  - Digital output is subdevice 1 (8 channels)
  - The PACER is not supported in this version
 address scheme (page 2.17 of the manual) 
 enable pacer interrupt 
 enable pacer 
 timer 2 output state 
 pacer output state 
 AD end-of-conversion 
 available ranges through the PGA gains 
 change channel and range only if it is different from the previous 
 wait for the mux to settle 
 trigger AD 
 retriggers AD 
 only bits 0-4 have information about digital inputs 
 force ctreg update 
 Analog Input subdevice 
 Digital Input subdevice 
 Digital Output subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  Support for NI general purpose counters
  Copyright (C) 2006 Frank Mori Hess <fmhess@users.sourceforge.net>
  Module: ni_tio
  Description: National Instruments general purpose counters
  Author: J.P. Mellor <jpmellor@rose-hulman.edu>,
          Herman.Bruyninckx@mech.kuleuven.ac.be,
          Wim.Meeussen@mech.kuleuven.ac.be,
          Klaas.Gadeyne@mech.kuleuven.ac.be,
          Frank Mori Hess <fmhess@users.sourceforge.net>
  Updated: Thu Nov 16 09:50:32 EST 2006
  Status: works
  This module is not used directly by end-users.  Rather, it
  is used by other drivers (for example ni_660x and ni_pcimio)
  to provide support for NI's general purpose counters.  It was
  originally based on the counter code from ni_660x.c and
  ni_mio_common.c.
  References:
  DAQ 660x Register-Level Programmer Manual  (NI 370505A-01)
  DAQ 66016602 User Manual (NI 322137B-01)
  340934b.pdf  DAQ-STC reference manual
  TODO: Support use of both banks X and Y
  clock sources for ni e and m series boards,
  get bits with GI_SRC_SEL()
 20MHz 
 100KHz 
 Gi_Src_SubSelect=0 
 Gi_Src_SubSelect=1 
 80MHz, Gi_Src_SubSelect=0 
 Gi_Src_SubSelect=1 
  clock sources for ni_660x boards,
  get bits with GI_SRC_SEL()
 20MHz 
 100KHz 
 80MHz 
 ni m series gate_select 
 ni_660x gate select 
 ni_660x second gate select 
  ni_tio_write() - Write a TIO register using the driver provided callback.
  @counter: struct ni_gpct counter.
  @value: the value to write
  @reg: the register to write.
  ni_tio_read() - Read a TIO register using the driver provided callback.
  @counter: struct ni_gpct counter.
  @reg: the register to read.
		
		  clock period is specified by user with prescaling
		  already taken into account.
  ni_tio_set_bits() - Safely write a counter register.
  @counter: struct ni_gpct counter.
  @reg: the register to write.
  @mask: the bits to change.
  @value: the new bits value.
  Used to write to, and update the software copy, a register whose bits may
  be twiddled in interrupt context, or whose software copy may be read in
  interrupt context.
  ni_tio_get_soft_copy() - Safely read the software copy of a counter register.
  @counter: struct ni_gpct counter.
  @reg: the register to read.
  Used to get the software copy of a register whose bits might be modified
  in interrupt context, or whose software copy might need to be read in
  interrupt context.
 only m series and 660x variants have counting mode registers 
	
	  It's not clear what we should do if clock_period is unknown, so we
	  are not using the alt sync bit in that case.
 these bits map directly on to the mode register 
 only m series and 660x have counting mode registers 
			
			  for m series and 660x, pass-through the least
			  significant bits so we can figure out what select
			  later
 Gi_Source_Subselect is zero 
 Gi_Source_Subselect is one 
 Gi_Source_Subselect doesn't matter 
 ps to ns 
 Set the mode bits for gate. 
		
		  Allowing bitwise comparison here to allow non-zero raw
		  register value to be used for channel when disabling.
  Set the mode bits for gate2.
  Previously, the code this function represents did not actually write anything
  to the register.  Rather, writing to this register was reserved for the code
  ni ni_tio_set_gate2_raw.
	
	  The GI_GATE2_MODE bit was previously set in the code that also sets
	  the gate2 source.
	  We'll set mode bits _after_ source bits now, and thus, this function
	  will effectively enable the second gate after all bits are set.
		
		  Allowing bitwise comparison here to allow non-zero raw
		  register value to be used for channel when disabling.
	
	  FIXME: We don't know what the m-series second gate codes are,
	  so we'll just pass the bits through for now.
 1.  start by disabling gate 
 2.  set the requested gate source 
 3.  reenable & set mode to starts things back up 
 1.  start by disabling gate 
 2.  set the requested gate source 
 3.  reenable & set mode to starts things back up 
	
	  mask off disable flag.  This high bit still passes CR_CHAN.
	  Doing this allows one to both set the gate as disabled, but also
	  change the route value of the gate.
 1.  start by disabling gate 
 2.  set the requested gate source 
 3.  reenable & set mode to starts things back up 
 1.  start by disabling gate 
 2.  set the requested gate source 
 3.  reenable & set mode to starts things back up 
 allow for new device-global names 
 Disable gate 
 A,B,Z only valid for m-series 
 allow for new device-global names 
	
	  FIXME: the second gate sources for the m series are undocumented,
	  so we just return the raw bits for now.
  Retrieves the register value of the current source of the output selector for
  the given destination.
  If the terminal for the destination is not already configured as an output,
  this function returns -EINVAL as error.
  Return: the register value of the destination output selector;
          -EINVAL if terminal is not configured for output.
 we need to know the actual counter below... 
	
	  This case is not possible through this interface.  A user must use
	  INSN_CONFIG_SET_CLOCK_SRC instead.
	  } else if (dest >= NI_CtrSource(0) && dest <= NI_CtrSource(-1)) {
	 	ret = ni_tio_set_clock_src(counter, &reg, &period_ns);
  ni_tio_set_routing() - Sets the register value of the selector MUX for the given destination.
  @counter_dev: Pointer to general counter device.
  @dest:        Device-global identifier of route destination.
  @reg:
 		The first several bits of this value should store the desired
 		value to write to the register.  All other bits are for
 		transmitting information that modify the mode of the particular
 		destinationgate.  These mode bits might include a bitwise or of
 		CR_INVERT and CR_EDGE.  Note that the calling function should
 		have already validated the correctness of this value.
 we need to know the actual counter below... 
	
	  This case is not possible through this interface.  A user must use
	  INSN_CONFIG_SET_CLOCK_SRC instead.
	  } else if (dest >= NI_CtrSource(0) && dest <= NI_CtrSource(-1)) {
	 	ret = ni_tio_set_clock_src(counter, reg, period_ns);
  Sets the given destination MUX to its default value or disable it.
  Return: 0 if successful; -EINVAL if terminal is unknown.
 Disable gate (via mode bits) and set to default 0-value 
	
	  This case is not possible through this interface.  A user must use
	  INSN_CONFIG_SET_CLOCK_SRC instead.
	  if (dest >= NI_CtrSource(0) && dest <= NI_CtrSource(-1))
	 	return ni_tio_set_clock_src(counter, reg, period_ns);
	
	  The count doesn't get latched until the next clock edge, so it is
	  possible the count may change (once) while we are reading. Since
	  the read of the SW_Save_Reg isn't atomic (apparently even when it's
	  a 32 bit register according to 660x docs), we need to read twice
	  and make sure the reading hasn't changed. If it has, a third read
	  will be correct since the count value will definitely have latched
	  by then.
		
		  Unsafe if counter is armed.
		  Should probably check status and return -EBUSY if armed.
		
		  Don't disturb load source select, just use whichever
		  load register is already selected.
 restore load reg 
 initialize counter registers 
 SPDX-License-Identifier: GPL-2.0+
  comedi_bond.c
  A Comedi driver to 'bond' or merge multiple drivers and devices as one.
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Copyright (C) 2005 Calin A. Culianu <calin@ajvar.org>
  Driver: comedi_bond
  Description: A driver to 'bond' (merge) multiple subdevices from multiple
  devices together as one.
  Devices:
  Author: ds
  Updated: Mon, 10 Oct 00:18:25 -0500
  Status: works
  This driver allows you to 'bond' (merge) multiple comedi subdevices
  (coming from possibly difference boards andor drivers) together.  For
  example, if you had a board with 2 different DIO subdevices, and
  another with 1 DIO subdevice, you could 'bond' them with this driver
  so that they look like one big fat DIO subdevice.  This makes writing
  applications slightly easier as you don't have to worry about managing
  different subdevices in the application -- you just worry about
  indexing one linear array of channel id's.
  Right now only DIO subdevices are supported as that's the personal itch
  I am scratching with this driver.  If you want to add support for AI and AO
  subdevs, go right on ahead and do so!
  Commands aren't supported -- although it would be cool if they were.
  Configuration Options:
    List of comedi-minors to bond.  All subdevices of the same type
    within each minor will be concatenated together in the order given here.
 do a maximum of 32 channels, starting from base_chan. 
 base channel falls within bonded device 
			
			  Get num channels to do for bonded device and set
			  up mask and data bits for bonded device.
 ReadWrite the new digital lines. 
 Place read bits into data[1]. 
			
			  Set up for following bonded device (if still have
			  channels to readwrite).
 Skip bonded devices before base channel. 
	
	  Locate bonded subdevice and adjust channel.
	
	  The input or output configuration of each digital line is
	  configured by a special insn_config instruction.  chanspec
	  contains the channel to be changed, and data[0] contains the
	  configuration instruction INSN_CONFIG_DIO_OUTPUT,
	  INSN_CONFIG_DIO_INPUT or INSN_CONFIG_DIO_QUERY.
	 
	  Note that INSN_CONFIG_DIO_OUTPUT == COMEDI_OUTPUT,
	  and INSN_CONFIG_DIO_INPUT == COMEDI_INPUT.  This is deliberate ;)
	
	  Loop through all comedi devices specified on the command-line,
	  building our device list.
 Do DIO, as that's all we support now.. 
			
			  Now put bdev pointer at end of devpriv->devs array
			  list..
 ergh.. ugly.. we need to realloc :(  
 Append dev:subdev to devpriv->name 
	
	  Setup our bonding from config params.. sets up our private struct..
 SPDX-License-Identifier: GPL-2.0+
  ssv_dnp.c
  generic comedi driver for SSV Embedded Systems' DILNet-PCs
  Copyright (C) 2001 Robert Schwebel <robert@schwebel.de>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: ssv_dnp
  Description: SSV Embedded Systems DILNet-PC
  Author: Robert Schwebel <robert@schwebel.de>
  Devices: [SSV Embedded Systems] DILNet-PC 1486 (dnp-1486)
  Status: unknown
 include files ----------------------------------------------------------- 
 Some global definitions: the registers of the DNP ----------------------- 
 For port A and B the mode register has bits corresponding to the output   
 pins, where Bit-N = 0 -> input, Bit-N = 1 -> output. Note that bits       
 4 to 7 correspond to pin 0..3 for port C data register. Ensure that bits  
 0..3 remain unchanged! For details about Port C Mode Register see         
 the remarks in dnp_insn_config() below.                                   
 Chip Setup and Control Index Register     
 Chip Setup and Control Data Register      
 Port A Mode Register                      
 Port A Data Register                      
 Port B Mode Register                      
 Port B Data Register                      
 Port C Mode Register                      
 Port C Data Register                      
	
	  Ports A and B are straight forward: each bit corresponds to an
	  output pin with the same order. Port C is different: bits 0...3
	  correspond to bits 4...7 of the output register (PCDR).
 Port A 
 Port B 
 Port C 
		
		  We have to pay attention with port C.
		  This is the meaning of PCMR:
		    Bit in PCMR:              7 6 5 4 3 2 1 0
		    Corresponding port C pin: d 3 d 2 d 1 d 0   d= don't touch
		 
		  Multiplication by 2 brings bits into correct position
		  for PCMR!
	
	  We use IO ports 0x22, 0x23 and 0xa3-0xa9, which are always
	  allocated for the primary 8259, so we don't need to allocate
	  them ourselves.
 digital io subdevice                                             
 configure all ports as input (default)                            
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0
  ii_pci20kc.c
  Driver for Intelligent Instruments PCI-20001C carrier board and modules.
  Copyright (C) 2000 Markus Kempf <kempf@matsci.uni-sb.de>
  with suggestions from David Schleef		16.06.2000
  Driver: ii_pci20kc
  Description: Intelligent Instruments PCI-20001C carrier board
  Devices: [Intelligent Instrumentation] PCI-20001C (ii_pci20kc)
  Author: Markus Kempf <kempf@matsci.uni-sb.de>
  Status: works
  Supports the PCI-20001C-1a and PCI-20001C-2a carrier boards. The
  -2a version has 32 on-board DIO channels. Three add-on modules
  can be added to the carrier board for additional functionality.
  Supported add-on modules:
 	PCI-20006M-1   1 channel, 16-bit analog output module
 	PCI-20006M-2   2 channel, 16-bit analog output module
 	PCI-20341M-1A  4 channel, 16-bit analog input module
  Options:
    0   Board base address
    1   IRQ (not-used)
  Register IO map
 no on-board DIO 
 on-board DIO 
 1 AO channels 
 2 AO channels 
 4 AI channels 
 the AO range is set by jumpers on the 20006M module 
 Chan 0 - W1W3 in   Chan 1 - W2W4 in  
 Chan 0 - W1W3 out  Chan 1 - W2W4 in  
 Chan 0 - W1W3 in   Chan 1 - W2W4 out 
 gain 1 
 gain 10 
 gain 100 
 gain 200 
 munge the offset binary data to 2's complement 
 initialize module 
 software conversion 
 set the time base for the settling time counter based on the gain 
 set the settling time counter based on the gain 
 set number of input channels 
 set the channel list byte 
 reset settling time counter and trigger delay counter 
 reset channel scanner 
 generate a software start convert signal 
 munge the 2's complement data to offset binary 
 port 0 - channels 0-7 
 output port 
 input port 
 port 1 - channels 8-15 
 output port 
 input port 
 port 2 - channels 16-23 
 output port 
 input port 
 port 3 - channels 24-31 
 output port 
 input port 
 order is important 
 Analog Output subdevice 
 Analog Input subdevice 
 actually, a memory address 
 Digital IO subdevice 
 default all channels to input 
 actually, a memory address 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  COMEDI ISA DMA support functions
  Copyright (c) 2014 H Hartley Sweeten <hsweeten@visionengravers.com>
  comedi_isadma_program - program and enable an ISA DMA transfer
  @desc:	the ISA DMA cookie to program and enable
  comedi_isadma_disable - disable the ISA DMA channel
  @dma_chan:	the DMA channel to disable
  Returns the residue (remaining bytes) left in the DMA transfer.
  comedi_isadma_disable_on_sample - disable the ISA DMA channel
  @dma_chan:	the DMA channel to disable
  @size:	the sample size (in bytes)
  Returns the residue (remaining bytes) left in the DMA transfer.
 residue is a partial sample, enable DMA to allow more data 
 is DMA stalled? 
  comedi_isadma_poll - poll the current DMA transfer
  @dma:	the ISA DMA to poll
  Returns the position (in bytes) of the current DMA transfer.
	
	  Read the counter again and choose higher value in order to
	  avoid reading during counter lower byte roll over if the
	  isa_dma_bridge_buggy is set.
  comedi_isadma_set_mode - set the ISA DMA transfer direction
  @desc:	the ISA DMA cookie to set
  @dma_dir:	the DMA direction
  comedi_isadma_alloc - allocate and initialize the ISA DMA
  @dev:	comedi_device struct
  @n_desc:	the number of cookies to allocate
  @dma_chan1:	DMA channel for the first cookie
  @dma_chan2:	DMA channel for the second cookie
  @maxsize:	the size of the buffer to allocate for each cookie
  @dma_dir:	the DMA direction
  Returns the allocated and initialized ISA DMA or NULL if anything fails.
 Fall back to using the "class" device. 
 Need 24-bit mask for ISA DMA. 
  comedi_isadma_free - free the ISA DMA
  @dma:	the ISA DMA to free
 SPDX-License-Identifier: GPL-2.0+
  Comedi driver for National Instruments PCMCIA DAQ-Card DIO-24
  Copyright (C) 2002 Daniel Vecino Castel <dvecino@able.es>
  PCMCIA crap at end of file is adapted from dummy_cs.c 1.31
  20010824 12:13:13 from the pcmcia package.
  The initial developer of the pcmcia dummy_cs.c code is David A. Hinds
  <dahinds@users.sourceforge.net>.  Portions created by David A. Hinds
  are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.
  Driver: ni_daq_dio24
  Description: National Instruments PCMCIA DAQ-Card DIO-24
  Author: Daniel Vecino Castel <dvecino@able.es>
  Devices: [National Instruments] PCMCIA DAQ-Card DIO-24 (ni_daq_dio24)
  Status: ?
  Updated: Thu, 07 Nov 2002 21:53:06 -0800
  This is just a wrapper around the 8255.o driver to properly handle
  the PCMCIA interface.
 8255 dio 
 daqcard-dio24 
 SPDX-License-Identifier: GPL-2.0+
  s526.c
  Sensoray s526 Comedi driver
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: s526
  Description: Sensoray 526 driver
  Devices: [Sensoray] 526 (s526)
  Author: Richie
 	   Everett Wang <everett.wang@everteq.com>
  Updated: Thu, 14 Sep. 2006
  Status: experimental
  Encoder works
  Analog input works
  Analog output works
  PWM output works
  Commands are not supported yet.
  Configuration Options:
    [0] - IO port base address
  Register IO map
 irq on DIO3 negpos edge 
 irq on DIO2 negpos edge 
 irq on DIO1 negpos edge 
 irq on DIO0 negpos edge 
 irq on DIO[4-7] negpos edge 
 status only 
 these 3 bits can be OR'ed 
 if count direction control set to quadrature 
 if count direction control set to software control 
 if count direction control set to software control 
 ControlStatus - R = readable, W = writeable, C = write 1 to clear 
 RC 
 these 4 bits can be OR'ed 
 R 
 R 
 W 
 these 4 bits can be OR'ed 
 W 
 these 3 bits can be OR'ed 
 W 
 W 
 W 
 write high word then low word 
 read the low word then high word 
	
	  Check what type of Counter the user requested
	  data[0] contains the Application type
		
		  data[0]: Application Type
		  data[1]: Counter Mode Register Value
		  data[2]: Pre-load Register Value
		  data[3]: Conter Control Register
  Set Counter Mode Register 
  Reset the counter if it is software preload 
  Reset the counter 
			
			  Load the counter from PR0
			  outw(S526_GPCT_CTRL_CT_LOAD,
			       dev->iobase + S526_GPCT_CTRL_REG(chan));
  data[1] contains GPCT_X1, GPCT_X2 or GPCT_X4 
  When to take into account the indexpulse: 
		
		  if (data[2] == GPCT_IndexPhaseLowLow) {
		  } else if (data[2] == GPCT_IndexPhaseLowHigh) {
		  } else if (data[2] == GPCT_IndexPhaseHighLow) {
		  } else if (data[2] == GPCT_IndexPhaseHighHigh) {
		  }
  Take into account the index pulse? 
  Auto load with INDEX^ 
  Set Counter Mode Register 
  Load the pre-load register 
  Write the Counter Control Register 
  Reset the counter if it is software preload 
  Reset the counter 
  Load the counter from PR0 
		
		  data[0]: Application Type
		  data[1]: Counter Mode Register Value
		  data[2]: Pre-load Register 0 Value
		  data[3]: Pre-load Register 1 Value
		  data[4]: Conter Control Register
  Set Counter Mode Register 
 Select PR0 
 Load the pre-load register 0 
  Set Counter Mode Register 
 Select PR1 
 Load the pre-load register 1 
  Write the Counter Control Register 
		
		  data[0]: Application Type
		  data[1]: Counter Mode Register Value
		  data[2]: Pre-load Register 0 Value
		  data[3]: Pre-load Register 1 Value
		  data[4]: Conter Control Register
  Set Counter Mode Register 
 Select PR0 
 Load the pre-load register 0 
  Set Counter Mode Register 
 Select PR1 
 Load the pre-load register 1 
  Write the Counter Control Register 
 Is this required? 
  Check what Application of Counter this channel is configured for 
		
		  data[0] contains the PULSE_WIDTH
		  data[1] contains the PULSE_PERIOD
		  @pre PULSE_PERIOD > PULSE_WIDTH > 0
		  The above periods must be expressed as a multiple of the
		  pulse frequency on the selected source
 to write the PULSE_WIDTH 
 we got our eoc event, clear it 
		
		  The multiplexor needs to change, enable the 15us
		  delay for the first sample.
 trigger conversion 
 wait for conversion to end 
 wait for conversion to end 
	
	  Digital IO can be configured as inputs or outputs in
	  groups of 4; DIO group 1 (DIO0-3) and DIO group 2 (DIO4-7).
 General-Purpose CounterTimer (GPCT) 
	
	  Analog Input subdevice
	  channels 0 to 7 are the regular differential inputs
	  channel 8 is "reference 0" (+10V)
	  channel 9 is "reference 1" (0V)
 Analog Output subdevice 
 Digital IO subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriversrtd520.c
  Comedi driver for Real Time Devices (RTD) PCI4520DM7520
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2001 David A. Schleef <ds@schleef.org>
  Driver: rtd520
  Description: Real Time Devices PCI4520DM7520
  Devices: [Real Time Devices] DM7520HR-1 (DM7520), DM7520HR-8,
    PCI4520 (PCI4520), PCI4520-8
  Author: Dan Christian
  Status: Works. Only tested on DM7520-8. Not SMP safe.
  Configuration options: not applicable, uses PCI auto config
  Created by Dan Christian, NASA Ames Research Center.
  The PCI4520 is a PCI card. The DM7520 is a PC104-plus card.
  Both have:
    816 12 bit ADC with FIFO and channel gain table
    8 bits high speed digital out (for external MUX) (or 8 in or 8 out)
    8 bits high speed digital in with FIFO and interrupt on change (or 8 IO)
    2 12 bit DACs with FIFOs
    2 bits output
    2 bits input
    bus mastering DMA
    timers: ADC sample, pacer, burst, about, delay, DA1, DA2
    sample counter
    3 user timercounters (8254)
    external interrupt
  The DM7520 has slightly fewer features (fewer gain steps).
  These boards can support external multiplexors and multi-board
  synchronization, but this driver doesn't support that.
  Board docs: http:www.rtdusa.comPC104DManalog%20IOdm7520.htm
  Data sheet: http:www.rtdusa.compdfdm7520.pdf
  Example source: http:www.rtdusa.comexamplesdmdm7520.zip
  Call them and ask for the register level manual.
  PCI chip: http:www.plxtech.comproductsiopci9080
  Notes:
  This board is memory mapped. There is some IO stuff, but it isn't needed.
  I use a pretty loose naming style within the driver (rtd_blah).
  All externally visible names should be rtd520_blah.
  I use camelCase for structures (and inside them).
  I may also use upper CamelCase for function names (old habit).
  This board is somewhat related to the RTD PCI4400 board.
  I borrowed heavily from the ni_mio_common, ni_atmio16d, mite, and
  das1800, since they have the best documented code. Driver cb_pcidas64.c
  uses the same DMA controller.
  As far as I can tell, the About interrupt doesn't work if Sample is
  also enabled. It turns out that About really isn't needed, since
  we always count down samples read.
  driver status:
  Analog-In supports instruction and command mode.
  With DMA, you can sample at 1.15Mhz with 70% idle on a 400Mhz K6-2
  (single channel, 64K read buffer). I get random system lockups when
  using DMA with ALI-15xx based systems. I haven't been able to test
  any other chipsets. The lockups happen soon after the start of an
  acquistion, not in the middle of a long run.
  Without DMA, you can do 620Khz sampling with 20% idle on a 400Mhz K6-2
  (with a 256K read buffer).
  Digital-IO and Analog-Out only support instruction mode.
  Local Address Space 0 Offsets
 User IO 
 FIFO StatusSoftware AD Start 
 DAC1 FIFO not empty 
 DAC1 FIFO half empty 
 DAC1 FIFO not full 
 DAC2 FIFO not empty 
 DAC2 FIFO half empty 
 DAC2 FIFO not full 
 ADC FIFO not empty 
 ADC FIFO half empty 
 ADC FIFO not full 
 DIN FIFO not empty 
 DIN FIFO half empty 
 DIN FIFO not full 
 DAx Update (w) 
 Software Simultaneous Update (w) 
 Software Pacer StartStop 
 Timer StatusHDIN Software Trig. 
 Interrupt StatusEnable 
 ADC FIFO Write 
 Reset CGT 
 Pause CGT 
 About Counter out 
 Delay Counter out 
 ADC Sample Counter 
 DAC1 Update Counter 
 DAC2 Update Counter 
 User TC1 out 
 User TC1 out, inverted 
 User TC2 out 
 Digital Interrupt 
 External Interrupt 
 Ext Trigger rising-edge 
 Ext Trigger falling-edge 
 ClearSet Interrupt Clear Mask 
 Pending interruptsClear Overrun 
 Pacer Clock (24bit) 
 Burst Clock (10bit) 
 AD Sample counter (10bit) 
 DA1 Update counter (10 bit) 
 DA2 Update counter (10 bit) 
 Delay counter (16 bit) 
 About counter (16 bit) 
 DAC clock (16bit) 
 8254 timercounter base 
 Digital IO Port 0 
 Digital IO Port 1 
 Digital IO Control 
 Digital IO Status 
 Board reset 
 DMA 0 Sources select 
 DMA 1 Sources select 
 AD Conversion Signal select 
 Burst Clock Start Trigger select 
 Pacer Clock Start Trigger select 
 Pacer Clock Stop Trigger select 
 About Counter Stop Enable 
 Pacer Start Trigger Mode select 
 HiSpd DI Sampling Signal select 
 Digital Input FIFO Clear 
 AD FIFO Clear 
 Channel Gain Table Write 
 Channel Gain Latch Write 
 Digital Table Write 
 Channel Gain Table Enable 
 Digital Table Enable 
 Table Pause Enable 
 Reset Channel Gain Table 
 Clear Channel Gain Table 
 DAx typerange 
 DAx update source 
 DAx cycle mode 
 DAx FIFO reset 
 DAx FIFO clear 
 AD Sample Counter Source select 
 Pacer Clock select 
 SyncBus 0 Source select 
 SyncBus 0 enable 
 SyncBus 1 Source select 
 SyncBus 1 enable 
 SyncBus 2 Source select 
 SyncBus 2 enable 
 Ext. Trigger polarity select 
 Ext. Interrupt polarity select 
 8254 clock select 
 8254 gate select 
 User Output 0 source select 
 User Output 1 source select 
 DMA0 Request state machine reset 
 DMA1 Request state machine reset 
  Local Address Space 1 Offsets
 AD FIFO (16bit) 
 HiSpd DI FIFO (16bit) 
 DAx FIFO (16bit) 
  Driver specific stuff (tunable)
  We really only need 2 buffers.  More than that means being much
  smarter about knowing which ones are full.
 max DMA segmentsbuffers in a ring (min 2) 
 Target period for periodic transfers.  This sets the user read latency. 
 Note: There are certain rates where we give this up and transfer 12 FIFO 
 If this is too low, efficiency is poor 
 10 ms (in nanoseconds) 
 Set a practical limit on how long a list to support (affects memory use) 
 The board support a channel list up to the FIFO length (1K or 8K) 
 max channel list that we allow 
  Board specific stuff
 8Mhz onboard clock 
 clock period in ns 
 Note: these speed are slower than the spec, but fit the counter resolution
 when sampling, in nanoseconds 
 max speed if we don't have to wait for settling 
 if single channel, in nanoseconds 
 (24bit counter) in nanoseconds 
 min speed when only 1 channel (no burst counter) 
 200Hz, in nanoseconds 
 Setup continuous ring of 12 FIFO transfers.  See RTD manual p91 
 descriptors in PCI memory  PLX_DESC_IN_PCI_BIT \
 interrupt at end of block  | PLX_INTR_TERM_COUNT \
 from board to PCI 		| PLX_XFER_LOCAL_TO_PCI)
  Comedi specific stuff
  The board has 3 input modes and the gains of 1,2,4,...32 (, 64, 128)
 +-5V input range gain steps 
 +-10V input range gain steps 
 +10V input range gain steps 
 PCI4520 has two more gains (6 more entries) 
 +-5V input range gain steps 
 +-10V input range gain steps 
 +10V input range gain steps 
 Table order matches range values 
 start of +-10V range 
 start of +10V range 
 memory mapped board structures 
 total transfer size (samples) 
 # to transfer data. 0->12FIFO 
 flag event modes 
 8254 TimerCounter gate and clock sources 
 bit defines for "flags" 
 send End Of Scan events 
 DMA0 is active 
 DMA1 is active 
  Given a desired period and the clock period (both in ns), return the
  proper counter value (divider-1). Sets the original period to be the
  true value.
  Note: you have to check if the value is larger than the counter range!
 min is divide by 2 
	
	  Note: we don't check for max, because different timers
	  have different ranges
 countdown is divisor+1 
  Given a desired period (in ns), return the proper counter value
  (divider-1) for the internal clock. Sets the original period to
  be the true value.
 Convert a single comedi channel-gain entry to a RTD520 table entry 
 Note: we also setup the channel list bipolar flag array 
 +-5 range 
 +-10 range 
 +10 range 
 on-board ground 
 ref external analog common 
 differential inputs 
 ??? 
 Setup the channel-gain table from a comedi list 
 setup channel gain table 
 just use the channel gain latch 
  Determine fifo size by doing adc conversions until the fifo half
  empty status flag clears.
 ADC conversion trigger source: SOFTWARE 
 convert  samples 
 trigger conversion 
 clear any old fifo data 
 write channel to multiplexer and clear channel gain table 
 ADC conversion trigger source: SOFTWARE 
 convert n samples 
 trigger conversion 
 read data 
 low 3 bits are marker lines 
 convert bipolar data to comedi unsigned data 
 return the number of samples readwritten 
 done 
 low 3 bits are marker lines 
 convert bipolar data to comedi unsigned data 
 < 0, means read forever 
 check for FIFO full, this automatically halts the ADC! 
 0 -> full 
 if interrupt was not caused by our board, or handled above 
 sample count -> read FIFO 
		
		  since the priority interrupt controller may have queued
		  a sample counter interrupt, even though we have already
		  finished, we must handle the possibility that there is
		  no data here
 FIFO half full 
 FIFO not empty 
 clear the interrupt 
 clear the interrupt 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 Note: these are time periods, not actual rates 
 no scanning 
 external trigger 
 should be leveledge, hilo specification here 
 should specify multiple external triggers 
 no scanning 
 external trigger 
 see above 
 TRIG_NONE 
 step 4: fix up any arguments 
 stop anything currently running 
 pacer stop source: SOFTWARE 
 stop pacer 
 start configuration 
 load channel list and reset CGT 
 setup the common case and override if needed 
 pacer start source: SOFTWARE 
 burst trigger source: PACER 
 ADC conversion trigger source: BURST 
 single channel 
 pacer start source: SOFTWARE 
 ADC conversion trigger source: PACER 
 scan_begin_arg is in nanoseconds 
 find out how many samples to wait before transferring 
			
			  this may generate un-sustainable interrupt rates
			  the application is responsible for doing the
			  right thing
 arrange to transfer data periodically 
 transfer after each scan (and avoid 0) 
 make a multiple of scan length 
 out of counter range, use 12 fifo instead 
 interrupt for each transfer 
 unknown timing, just use 12 FIFO 
 pacer clock source: INTERNAL 8MHz 
 just interrupt, don't stop 
 BUG??? these look like enumerated values, but they are bit fields 
 First, setup when to stop 
 stop after N scans 
 stop when cancel is called 
 read forever 
 Scan timing 
 periodic scanning 
 set PACER clock 
 pacer start source: EXTERNAL 
 Sample timing within a scan 
 periodic 
 only needed for multi-channel 
 setup BURST clock 
 external 
 burst trigger source: EXTERNAL 
 end configuration 
	
	  This doesn't seem to work.  There is no way to clear an interrupt
	  that the priority controller has queued!
 TODO: allow multiple interrupt sources 
 transfer every N samples 
 BUG: start_src is ASSUMED to be TRIG_NOW 
 BUG? it seems like things are running before the "start" 
 start pacer 
 pacer stop source: SOFTWARE 
 stop pacer 
 stop and don't transfer any more 
 Configure the output range (table index matches the range values) 
 bipolar uses 2's complement values with an extended sign 
 shift the 12-bit data (+ sign) to match the register 
 TODO support digital match interrupts and strobes 
 set direction 
 clear interrupts 
 port1 can only be all input or all output 
 there are also 2 user input lines and 2 user output lines 
		
		  8254 TimerCounter gate sources:
		 
		  0 = Not gated, free running (reset state)
		  1 = Gated, off
		  2 = Ext. TC Gate 1
		  3 = Ext. TC Gate 2
		  4 = Previous TC out (chan 1 and 2 only)
		
		  8254 TimerCounter clock sources:
		 
		  0 = 8 MHz (reset state)
		  1 = Ext. TC Clock 1
		  2 = Ext. TX Clock 2
		  3 = Ext. Pacer Clock
		  4 = Previous TC out (chan 1 and 2 only)
		  5 = High-Speed Digital Input Sampling signal (chan 1 only)
 needed? 
  initialize board, per RTD spec
  also, initialize shadow registers
 clear digital IO fifo 
 TODO: set user out source ??? 
 The RTD driver does this 
 analog input subdevice 
 analog output subdevice 
 digital io subdevice 
 we only support port 0 right now.  Ignoring port 1 and user IO 
 8254 TimerCounter subdevice 
 Shut down any board ops by resetting it 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriversamplc_pci224.c
  Driver for Amplicon PCI224 and PCI234 AO boards.
  Copyright (C) 2005 MEV Ltd. <https:www.mev.co.uk>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1998,2000 David A. Schleef <ds@schleef.org>
  Driver: amplc_pci224
  Description: Amplicon PCI224, PCI234
  Author: Ian Abbott <abbotti@mev.co.uk>
  Devices: [Amplicon] PCI224 (amplc_pci224), PCI234
  Updated: Thu, 31 Jul 2014 11:08:03 +0000
  Status: works, but see caveats
  Supports:
    - ao_insn readwrite
    - ao_do_cmd mode with the following sources:
      - start_src         TRIG_INT        TRIG_EXT
      - scan_begin_src    TRIG_TIMER      TRIG_EXT
      - convert_src       TRIG_NOW
      - scan_end_src      TRIG_COUNT
      - stop_src          TRIG_COUNT      TRIG_EXT        TRIG_NONE
      The channel list must contain at least one channel with no repeated
      channels.  The scan end count must equal the number of channels in
      the channel list.
      There is only one external trigger source so only one of start_src,
      scan_begin_src or stop_src may use TRIG_EXT.
  Configuration options:
    none
  Manual configuration of PCI cards is not supported; they are configured
  automatically.
  Output range selection - PCI224:
    Output ranges on PCI224 are partly software-selectable and partly
    hardware-selectable according to jumper LK1.  All channels are set
    to the same range:
    - LK1 position 1-2 (factory default) corresponds to the following
      comedi ranges:
        0: [-10V,+10V]; 1: [-5V,+5V]; 2: [-2.5V,+2.5V], 3: [-1.25V,+1.25V],
        4: [0,+10V],    5: [0,+5V],   6: [0,+2.5V],     7: [0,+1.25V]
    - LK1 position 2-3 corresponds to the following Comedi ranges, using
      an external voltage reference:
        0: [-Vext,+Vext],
        1: [0,+Vext]
  Output range selection - PCI234:
    Output ranges on PCI234 are hardware-selectable according to jumper
    LK1 which affects all channels, and jumpers LK2, LK3, LK4 and LK5
    which affect channels 0, 1, 2 and 3 individually.  LK1 chooses between
    an internal 5V reference and an external voltage reference (Vext).
    LK2345 choose (per channel) to double the reference or not according
    to the following table:
      LK1 position   LK2345 pos  Comedi range
      -------------  -------------  --------------
      2-3 (factory)  1-2 (factory)  0: [-10V,+10V]
      2-3 (factory)  2-3            1: [-5V,+5V]
      1-2            1-2 (factory)  2: [-2Vext,+2Vext]
      1-2            2-3            3: [-Vext,+Vext]
  Caveats:
    1) All channels on the PCI224 share the same range.  Any change to the
       range as a result of insn_write or a streaming command will affect
       the output voltages of all channels, including those not specified
       by the instruction or command.
    2) For the analog output command,  the first scan may be triggered
       falsely at the start of acquisition.  This occurs when the DAC scan
       trigger source is switched from 'none' to 'timer' (scan_begin_src =
       TRIG_TIMER) or 'external' (scan_begin_src == TRIG_EXT) at the start
       of acquisition and the trigger source is at logic level 1 at the
       time of the switch.  This is very likely for TRIG_TIMER.  For
       TRIG_EXT, it depends on the state of the external line and whether
       the CR_INVERT flag has been set.  The remaining scans are triggered
       correctly.
  PCI224234 io space 1 (PCIBAR2) registers.
 82C54 countertimer 
 Group Z Clock Configuration Register 
 Group Z Gate Configuration Register 
 ISR Interrupt source mask register 
 Interrupt status 
  PCI224234 io space 2 (PCIBAR3) 16-bit registers.
 (w-o) DAC FIFO data. 
 (r-o) DAC software scan trigger. 
 (rw) DAC statusconfiguration. 
 (w-o) FIFO size for wraparound mode. 
 (w-o) DAC channel enable register. 
  DACCON values.
 (rw) Scan trigger. 
 none 
 soft trig 
 ext + edge 
 ext - edge 
 Z2 CT0 out 
 Z2 CT1 out 
 Z2 CT2 out 
 (rw) Polarity (PCI224 only, PCI234 always bipolar!). 
 [0,+V] 
 [-V,+V] 
 (rw) Internal Vref (PCI224 only, when LK1 in position 1-2). 
 1.25V 
 2.5V 
 5V 
 10V 
 (rw) Wraparound mode enable (to play back stored waveform). 
 (rw) FIFO enable.  It MUST be set! 
 (rw) FIFO interrupt trigger level (most values are not very useful). 
 empty 
 !empty 
 !half 
 half 
 !full 
 full 
 (r-o) FIFO fill level. 
 0 
 1-2048 
 2049-4095 
 4096 
 (r-o) DAC busy flag. 
 (w-o) FIFO reset. 
 (w-o) Global reset (not sure what it does). 
  DAC FIFO size.
  DAC FIFO guaranteed minimum room available, depending on reported fill level.
  The maximum room available depends on the reported fill level and how much
  has been written!
  Countertimer clock input configuration sources.
 reserved (channel-specific clock) 
 internal 10 MHz clock 
 internal 1 MHz clock 
 internal 100 kHz clock 
 internal 10 kHz clock 
 internal 1 kHz clock 
 output of channel-1 modulo total 
 external clock 
  Countertimer gate input configuration sources.
 VCC (i.e. enabled) 
 GND (i.e. disabled) 
 reserved (external gate input) 
 inverted output of channel-2 modulo total 
  Summary of CLK_OUTNM1 and GAT_NOUTNM2 connections for PCI224 and PCI234:
               Channel's       Channel's
               clock input     gate input
  Channel      CLK_OUTNM1      GAT_NOUTNM2
  -------      ----------      -----------
  Z2-CT0       Z2-CT2-OUT      Z2-CT1-OUT
  Z2-CT1       Z2-CT0-OUT      Z2-CT2-OUT
  Z2-CT2       Z2-CT1-OUT      Z2-CT0-OUT
  Interrupt enablestatus bits
 rising edge on external input 
 DAC (FIFO) interrupt 
 rising edge on Z2-CT1 output 
  Handy macros.
 Combine old and new bits. 
 Current CPU.  XXX should this be hard_smp_processor_id()? 
 State bits for use with atomic bit operations. 
  Range tables.
  The ranges for PCI224.
  These are partly hardware-selectable by jumper LK1 and partly
  software-selectable.
  All channels share the same hardware range.
 jumper LK1 in position 1-2 (factory default) 
 jumper LK1 in position 2-3 
 bipolar [-Vext,+Vext] 
 unipolar [0,+Vext] 
 jumper LK1 in position 1-2 (factory default) 
 jumper LK1 in position 2-3 
 Used to check all channels set to the same range on PCI224. 
  The ranges for PCI234.
  These are all hardware-selectable by jumper LK1 affecting all channels,
  and jumpers LK2, LK3, LK4 and LK5 affecting channels 0, 1, 2 and 3
  individually.
 LK1: 1-2 (fact def), LK2345: 2-3 (fac def) 
 LK1: 1-2 (fact def), LK2345: 1-2 
 LK1: 2-3, LK2345: 2-3 (fac def) 
 bipolar [-2Vext,+2Vext] 
 LK1: 2-3, LK2345: 1-2 
 bipolar [-Vext,+Vext] 
 N.B. PCI234 ignores the polarity bit, but software uses it. 
 Used to check all channels use same LK1 setting on PCI234. 
  Board descriptions.
 spinlock for AO command handling 
 max 16 channels so 'short' will do 
  Called from the 'insn_write' function to perform a single write.
 Enable the channel. 
 Set range and reset FIFO. 
	
	  Mangle the data.  The hardware expects:
	  - bipolar: 16-bit 2's complement
	  - unipolar: 16-bit unsigned
 Write mangled data to the FIFO. 
 Trigger the conversion. 
  Kills a command running on the AO subdevice.
 Kill the interrupts. 
	
	  Interrupt routine may or may not be running.  We may or may not
	  have been called from the interrupt routine (directly or
	  indirectly via a comedi_events() callback routine).  It's highly
	  unlikely that we've been called from some other interrupt routine
	  but who knows what strange things coders get up to!
	 
	  If the interrupt routine is currently running, wait for it to
	  finish, unless we appear to have been called via the interrupt
	  routine.
 Reconfigure DAC for insn_write usage. 
 Disable channels. 
  Handles start of acquisition for the AO subdevice.
 Enable interrupts. 
  Handles interrupts from the DAC FIFO.
 Determine how much room is in the FIFO (in samples). 
 FIFO empty at end of counted acquisition. 
 FIFO is less than half-full. 
 Nothing left to put in the FIFO. 
 Determine how many new scans can be put in the FIFO. 
 Determine how many scans to process. 
 Process scans. 
		
		  Change FIFO interrupt trigger level to wait
		  until FIFO is empty.
		
		  This is the initial DAC FIFO interrupt at the
		  start of the acquisition.  The DAC's scan trigger
		  has been set to 'none' up until now.
		 
		  Now that data has been written to the FIFO, the
		  DAC's scan trigger source can be set to the
		  correct value.
		 
		  BUG: The first scan will be triggered immediately
		  if the scan trigger source is at logic level 1.
 cmd->scan_begin_src == TRIG_EXT 
  'do_cmdtest' function for AO subdevice.
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
	
	  There's only one external trigger signal (which makes these
	  tests easier).  Only one thing can use it.
 Step 3: check if arguments are trivially valid 
 Force to external trigger 0. 
 The only flag allowed is CR_EDGE, which is ignored. 
 Force to external trigger 0. 
 Only allow flags CR_EDGE and CR_INVERT.  Ignore CR_EDGE. 
 Force to external trigger 0. 
 The only flag allowed is CR_EDGE, which is ignored. 
 Step 4: fix up any arguments. 
 Use two timers. 
 Step 5: check channel list if it exists 
	
	  The output of timer Z2-0 will be used as the scan trigger
	  source.
 Make sure Z2-0 is gated on.  
 Cascading with Z2-2. 
 Make sure Z2-2 is gated on.  
 Z2-2 needs 10 MHz clock. 
 Z2-0 is clocked from Z2-2's output. 
 Cannot handle nullempty chanlist. 
 Determine which channels are enabled and their load order.  
 Set enabled channels. 
 Determine range and polarity.  All channels the same.  
	
	  Set DAC range and polarity.
	  Set DAC scan trigger source to 'none'.
	  Set DAC FIFO interrupt trigger level to 'not half full'.
	  Reset DAC FIFO.
	 
	  N.B. DAC FIFO interrupts are currently disabled.
 TRIG_EXT 
 Enable external interrupt trigger to start acquisition. 
  'cancel' function for AO subdevice.
  'munge' data for AO command.
 The hardware expects 16-bit numbers. 
 Channels will be all bipolar or all unipolar. 
 Unipolar 
 Bipolar 
 Munge the data. 
  Interrupt handler.
 Temporarily disable interrupt sources. 
 Reenable interrupt sources. 
 Allocate buffer to hold values for AO channel scan. 
 Allocate buffer to hold AO channel scan order. 
 Disable interrupt sources. 
 Initialize the DAC hardware. 
 Analog output subdevice. 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriverscomedi_test.c
  Generates fake waveform signals that can be read through
  the command interface.  It does _not_ read from any board;
  it just generates deterministic waveforms.
  Useful for various testing purposes.
  Copyright (C) 2002 Joachim Wuttke <Joachim.Wuttke@icn.siemens.de>
  Copyright (C) 2002 Frank Mori Hess <fmhess@users.sourceforge.net>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: comedi_test
  Description: generates fake waveforms
  Author: Joachim Wuttke <Joachim.Wuttke@icn.siemens.de>, Frank Mori Hess
    <fmhess@users.sourceforge.net>, ds
  Devices:
  Status: works
  Updated: Sat, 16 Mar 2002 17:34:48 -0800
  This driver is mainly for testing purposes, but can also be used to
  generate sample waveforms on systems that don't have data acquisition
  hardware.
  Auto-configuration is the default mode if no parameter is supplied during
  module loading. Manual configuration requires COMEDI userspace tool.
  To disable auto-configuration mode, pass "noauto=1" parameter for module
  loading. Refer modinfo or MODULE_PARM_DESC description below for details.
  Auto-configuration options:
    Refer modinfo or MODULE_PARM_DESC description below for details.
  Manual configuration options:
    [0] - Amplitude in microvolts for fake waveforms (default 1 volt)
    [1] - Period in microseconds for fake waveforms (default 0.1 sec)
  Generates a sawtooth wave on channel 0, square wave on channel 1, additional
  waveforms could be added to other channels (currently they return flatline
  zero volts).
 Data unique to this driver 
 timer for AI commands 
 time of next AI conversion in usec 
 waveform amplitude in microvolts 
 waveform period in microseconds 
 current time in waveform period 
 AI scan period in usec 
 AI conversion period in usec 
 timer for AO commands 
 parent comedi device 
 time of previous AO scan in usec 
 AO scan period in usec 
 fake analog input ranges 
 get rid of sawtooth's dc offset and clamp value 
 negative saturation 
 positive saturation 
 get one of two values for square-wave and clamp 
 negative saturation 
 positive saturation 
 generates a different waveform depending on what channel is read 
  This is the background routine used to generate arbitrary data.
  It should run in the background; therefore it is scheduled by
  a timer mechanism.
 done last conversion in scan, so add dead time 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 scan period would be 0 
 Step 3: check if arguments are trivially valid 
 cmd->convert_src == TRIG_TIMER 
 cmd->scan_begin_src == TRIG_TIMER 
 cmd->stop_src == TRIG_NONE 
 step 4: fix up any arguments 
 round convert_arg to nearest microsecond 
 limit convert_arg to keep scan_begin_arg in range 
 round scan_begin_arg to nearest microsecond 
 but ensure scan_begin_arg is large enough 
 cmd->convert_src == TRIG_TIMER 
 cmd->scan_begin_src == TRIG_TIMER 
	
	  Simulate first conversion to occur at convert period after
	  conversion timer starts.  If scan_begin_src is TRIG_FOLLOW, assume
	  the conversion timer starts immediately.  If scan_begin_src is
	  TRIG_TIMER, assume the conversion timer starts after the scan
	  period.
 Determine time within waveform period at time of conversion. 
	
	  Schedule timer to expire just after first conversion time.
	  Seem to need an extra jiffy here, otherwise timer expires slightly
	  early!
 Assume we were called from the timer routine itself. 
  This is the background routine to handle AO commands, scheduled by
  a timer mechanism.
 determine number of scan periods since last time 
 determine scans in buffer, limit to scans to do this time 
 skip all but the last scan to save processing time 
 unexpected underrun! (cancelled?) 
 output the last scan 
 unexpected underrun! (cancelled?) 
 advance time of last scan 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 cmd->stop_src == TRIG_NONE 
 step 4: fix up any arguments 
 round scan_begin_arg to nearest microsecond 
 Assume we were called from the timer routine itself. 
		
		  input:  data[1], data[2] : scan_begin_src, convert_src
		  output: data[1], data[2] : scan_begin_min, convert_min
 exactly TRIG_FOLLOW case 
 we don't care about actual channels 
 scan_begin_min 
 convert_min 
 analog input subdevice 
 analog output subdevice (loopback) 
 do same as AI insn_read 
 Our default loopback value is just a 0V flatline 
 set default amplitude and period 
 1 volt 
 0.1 sec 
 set default amplitude and period 
 1 volt 
 0.1 sec 
  For auto-configuration, a device is created to stand in for a
  real hardware device.
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  dt282x.c
  Comedi driver for Data Translation DT2821 series
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
  Driver: dt282x
  Description: Data Translation DT2821 series (including DT-EZ)
  Author: ds
  Devices: [Data Translation] DT2821 (dt2821), DT2821-F-16SE (dt2821-f),
    DT2821-F-8DI (dt2821-f), DT2821-G-16SE (dt2821-g),
    DT2821-G-8DI (dt2821-g), DT2823 (dt2823), DT2824-PGH (dt2824-pgh),
    DT2824-PGL (dt2824-pgl), DT2825 (dt2825), DT2827 (dt2827),
    DT2828 (dt2828), DT2928 (dt2829), DT21-EZ (dt21-ez), DT23-EZ (dt23-ez),
    DT24-EZ (dt24-ez), DT24-EZ-PGL (dt24-ez-pgl)
  Status: complete
  Updated: Wed, 22 Aug 2001 17:11:34 -0700
  Configuration options:
    [0] - IO port base address
    [1] - IRQ (optional, required for async command support)
    [2] - DMA 1 (optional, required for async command support)
    [3] - DMA 2 (optional, required for async command support)
    [4] - AI jumpered for 0=single ended, 1=differential
    [5] - AI jumpered for 0=straight binary, 1=2's complement
    [6] - AO 0 data format (deprecated, see below)
    [7] - AO 1 data format (deprecated, see below)
    [8] - AI jumpered for 0=[-10,10]V, 1=[0,10], 2=[-5,5], 3=[0,5]
    [9] - AO channel 0 range (deprecated, see below)
    [10]- AO channel 1 range (deprecated, see below)
  Notes:
    - AO commands might be broken.
    - If you try to run a command on both the AI and AO subdevices
      simultaneously, bad things will happen.  The driver needs to
      be fixed to check for this situation and return an error.
    - AO range is not programmable. The AO subdevice has a range_table
      containing all the possible analog output ranges. Use the range
      that matches your board configuration to convert between data
      values and physical units. The format of the data written to the
      board is handled automatically based on the unipolarbipolar
      range that is selected.
  Register map
 Pacer Clock 
 4 MHz (in nanoseconds) 
  The Analog Output range is set per-channel using jumpers on the board.
  All of these ranges may not be available on some DT2821 series boards.
  The default jumper setting has both channels set for +-10V output.
 software copies of registers 
 0 and 1 are both divide by 1 
 restart the channel 
     Performs a single AD conversion.
       - Put channelgain into channel-gain list
       - preload multiplexer
       - trigger conversion and wait for it to finish
 XXX should we really be enabling the ad clock here? 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_EXT | TRIG_NONE 
 step 4: fix up any arguments 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_EXT | TRIG_NONE 
 step 4: fix up any arguments 
 clear all bits but the DIO direction bits 
 clear all bits but the DIO direction bits 
 DMA uses two 4K buffers with separate DMA channels 
 Initialize board 
	
	  At power up, some registers are in a well-known state.
	  Check them to see if a DT2821 series board is present.
 an IRQ and 2 DMA channels are required for async command support 
 Analog Input subdevice 
 Analog Output subdevice 
 ranges are per-channel, set by jumpers on the board 
 Digital IO subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0
  pcl724.c
  Comedi driver for 8255 based ISA and PC104 DIO boards
  Michal Dobes <dobes@tesnet.cz>
  Driver: pcl724
  Description: Comedi driver for 8255 based ISA DIO boards
  Devices: [Advantech] PCL-724 (pcl724), PCL-722 (pcl722), PCL-731 (pcl731),
   [ADLink] ACL-7122 (acl7122), ACL-7124 (acl7124), PET-48DIO (pet48dio),
   [WinSystems] PCM-IO48 (pcmio48),
   [Diamond Systems] ONYX-MM-DIO (onyx-mm-dio)
  Author: Michal Dobes <dobes@tesnet.cz>
  Status: untested
  Configuration options:
    [0] - IO Base
    [1] - IRQ (not supported)
    [2] - number of DIO (pcl722 and acl7122 boards)
 	   0, 144: 144 DIO configuration
 	   1,  96:  96 DIO configuration
 24 DIO channels 
 144 (or 96) DIO channels 
 48 DIO channels 
 144 (or 96) DIO channels 
 24 DIO channels 
 48 DIO channels 
 48 DIO channels 
 48 DIO channels 
 Handle PCL-724 in 96 DIO configuration 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  Comedi driver for Data Translation DT2811
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) David A. Schleef <ds@schleef.org>
  Driver: dt2811
  Description: Data Translation DT2811
  Author: ds
  Devices: [Data Translation] DT2811-PGL (dt2811-pgl), DT2811-PGH (dt2811-pgh)
  Status: works
  Configuration options:
    [0] - IO port base address
    [1] - IRQ (optional, needed for async command support)
    [2] - AD reference (# of analog inputs)
 	   0 = single-ended (16 channels)
 	   1 = differential (8 channels)
 	   2 = pseudo-differential (16 channels)
    [3] - AD range (deprecated, see below)
    [4] - DA 0 range (deprecated, see below)
    [5] - DA 1 range (deprecated, see below)
  Notes:
    - AD ranges are not programmable but the gain is. The AI subdevice has
      a range_table containing all the possible analog input rangegain
      options for the dt2811-pgh or dt2811-pgl. Use the range that matches
      your board configuration and the desired gain to correctly convert
      between data values and physical units and to set the correct output
      gain.
    - DA ranges are not programmable. The AO subdevice has a range_table
      containing all the possible analog output ranges. Use the range
      that matches your board configuration to convert between data
      values and physical units.
  Register IO map
 rw  AD ControlStatus 
 r      1=AD conv done 
 r      1=AD error 
 r      1=AD busy 
 rw    1=dma ena 
 rw    1=interrupts ena 
 rw  AD GainChannel 
 r   AD Data low byte 
 r   AD Data high byte 
 w DA Data low 
 w DA Data high 
 r   Digital Input Port 0 
 w   Digital Output Port 1 
 rw  TimerCounter 
 600 kHz = 1666.6667ns 
  Timer frequency control:
    DT2811_TMRCTR_MANTISSA	DT2811_TMRCTR_EXPONENT
    val  divisor  frequency	val  multiply divisordivide frequency by
     0      1      600 kHz	 0   1
     1     10       60 kHz	 1   10
     2      2      300 kHz	 2   100
     3      3      200 kHz	 3   1000
     4      4      150 kHz	 4   10000
     5      5      120 kHz	 5   100000
     6      6      100 kHz	 6   1000000
     7     12       50 kHz	 7   10000000
  The Analog Input range is set using jumpers on the board.
  Input Range		W9  W10
  -5V to +5V		In  Out
  -2.5V to +2.5V	In  In
  0V to +5V		Out In
  The gain may be set to 1, 2, 4, or 8 (on the dt2811-pgh) or to
  1, 10, 100, 500 (on the dt2811-pgl).
 range 0: gain=1 
 range 1: gain=2 
 range 2: gain=4 
 range 3: gain=8 
 range 0+4: gain=1 
 range 1+4: gain=2 
 range 2+4: gain=4 
 range 3+4: gain=8 
 range 0+8: gain=1 
 range 1+8: gain=2 
 range 2+8: gain=4 
 range 3+8: gain=8 
 range 0: gain=1 
 range 1: gain=10 
 range 2: gain=100 
 range 3: gain=500 
 range 0+4: gain=1 
 range 1+4: gain=10 
 range 2+4: gain=100 
 range 3+4: gain=500 
 range 0+8: gain=1 
 range 1+8: gain=10 
 range 2+8: gain=100 
 range 3+8: gain=500 
  The Analog Output range is set per-channel using jumpers on the board.
 			DAC0 Jumpers		DAC1 Jumpers
  Output Range		W5  W6  W7  W8		W1  W2  W3  W4
  -5V to +5V		In  Out In  Out		In  Out In  Out
  -2.5V to +2.5V	In  Out Out In		In  Out Out In
  0 to +5V		Out In  Out In		Out In  Out In
 default setting from factory 
	
	  Mode 0
	  Single conversion
	 
	  Loading a chanspec will trigger a conversion.
		
		  Mode 1
		  Continuous conversion, internal trigger and clock
		 
		  This resets the trigger flip-flop, disabling AD strobes.
		  The timercounter register is loaded with the division
		  ratio which will give the required sample rate.
		 
		  Loading the first chanspec sets the trigger flip-flop,
		  enabling the timercounter. AD strobes are then generated
		  at the rate set by the internal clockdivider.
 TRIG_EXT 
			
			  Mode 2
			  Continuous conversion, external trigger
			 
			  Similar to Mode 1, with the exception that the
			  trigger flip-flop must be set by a negative edge
			  on the external trigger input.
 TRIG_EXT 
			
			  Mode 3
			  Continuous conversion, external trigger, clock
			 
			  Similar to Mode 2, with the exception that the
			  conversion rate is set by the frequency on the
			  external clockdivider.
 load timer 
 load chanspec - enables timer 
	
	  Work through all the dividermultiplier values to find the two
	  closest divisors to generate the requested nanosecond timing.
			
			  The timer can be configured to run at a slowest
			  speed of 0.005hz (600 Khz120000000), which requires
			  37-bits to represent the nanosecond value. Limit the
			  slowest timing to what comedi handles (32-bits).
 Check for fastest found timing 
 Check for slowest found timing 
	
	  The slowest found timing will be invalid if the requested timing
	  is faster than what can be generated by the timer. Fix it so that
	  CMDF_ROUND_UP returns valid timing.
	
	  The fastest found timing will be invalid if the requested timing
	  is less than what can be generated by the timer. Fix it so that
	  CMDF_ROUND_NEAREST and CMDF_ROUND_DOWN return valid timing.
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_NONE 
 Step 4: fix up any arguments 
 TRIG_EXT 
 The convert_arg is used to set the divisor. 
 Step 5: check channel list if it exists 
 We will already be in Mode 0 
 load chanspec and trigger conversion 
 This is the initialization sequence from the users manual 
 IRQ's 2,3,5,7 are valid for async command support 
 Analog Input subdevice 
 Analog Output subdevice 
 Digital Input subdevice 
 Digital Output subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0
  comedidriverspcl812.c
  Author: Michal Dobes <dobes@tesnet.cz>
  hardware driver for Advantech cards
   card:   PCL-812, PCL-812PG, PCL-813, PCL-813B
   driver: pcl812,  pcl812pg,  pcl813,  pcl813b
  and for ADlink cards
   card:   ACL-8112DG, ACL-8112HG, ACL-8112PG, ACL-8113, ACL-8216
   driver: acl8112dg,  acl8112hg,  acl8112pg,  acl8113,  acl8216
  and for ICP DAS cards
   card:   ISO-813, A-821PGH, A-821PGL, A-821PGL-NDA, A-822PGH, A-822PGL,
   driver: iso813,  a821pgh,  a-821pgl, a-821pglnda,  a822pgh,  a822pgl,
   card:   A-823PGH, A-823PGL, A-826PG
  driver:  a823pgh,  a823pgl,  a826pg
  Driver: pcl812
  Description: Advantech PCL-812PG, PCL-813B,
 	     ADLink ACL-8112DGHGPG, ACL-8113, ACL-8216,
 	     ICP DAS A-821PGHPGLPGL-NDA, A-822PGHPGL, A-823PGHPGL, A-826PG,
 	     ICP DAS ISO-813
  Author: Michal Dobes <dobes@tesnet.cz>
  Devices: [Advantech] PCL-812 (pcl812), PCL-812PG (pcl812pg),
 	PCL-813 (pcl813), PCL-813B (pcl813b), [ADLink] ACL-8112DG (acl8112dg),
 	ACL-8112HG (acl8112hg), ACL-8113 (acl-8113), ACL-8216 (acl8216),
 	[ICP] ISO-813 (iso813), A-821PGH (a821pgh), A-821PGL (a821pgl),
 	A-821PGL-NDA (a821pclnda), A-822PGH (a822pgh), A-822PGL (a822pgl),
 	A-823PGH (a823pgh), A-823PGL (a823pgl), A-826PG (a826pg)
  Updated: Mon, 06 Aug 2007 12:03:15 +0100
  Status: works (I hope. My board fire up under my hands
 	       and I cann't test all features.)
  This driver supports insn and cmd interfaces. Some boards support only insn
  because their hardware don't allow more (PCL-813B, ACL-8113, ISO-813).
  Data transfer over DMA is supported only when you measure only one
  channel, this is too hardware limitation of these boards.
  Options for PCL-812:
    [0] - IO Base
    [1] - IRQ  (0=disable, 2, 3, 4, 5, 6, 7; 10, 11, 12, 14, 15)
    [2] - DMA  (0=disable, 1, 3)
    [3] - 0=trigger source is internal 8253 with 2MHz clock
          1=trigger source is external
    [4] - 0=AD input range is +-10V
 	   1=AD input range is +-5V
 	   2=AD input range is +-2.5V
 	   3=AD input range is +-1.25V
 	   4=AD input range is +-0.625V
 	   5=AD input range is +-0.3125V
    [5] - 0=DA outputs 0-5V  (internal reference -5V)
 	   1=DA outputs 0-10V (internal reference -10V)
 	   2=DA outputs unknown (external reference)
  Options for PCL-812PG, ACL-8112PG:
    [0] - IO Base
    [1] - IRQ  (0=disable, 2, 3, 4, 5, 6, 7; 10, 11, 12, 14, 15)
    [2] - DMA  (0=disable, 1, 3)
    [3] - 0=trigger source is internal 8253 with 2MHz clock
 	   1=trigger source is external
    [4] - 0=AD have max +-5V input
 	   1=AD have max +-10V input
    [5] - 0=DA outputs 0-5V  (internal reference -5V)
 	   1=DA outputs 0-10V (internal reference -10V)
 	   2=DA outputs unknown (external reference)
  Options for ACL-8112DGHG, A-822PGLPGH, A-823PGLPGH, ACL-8216, A-826PG:
    [0] - IO Base
    [1] - IRQ  (0=disable, 2, 3, 4, 5, 6, 7; 10, 11, 12, 14, 15)
    [2] - DMA  (0=disable, 1, 3)
    [3] - 0=trigger source is internal 8253 with 2MHz clock
 	   1=trigger source is external
    [4] - 0=AD channels are S.E.
 	   1=AD channels are DIFF
    [5] - 0=DA outputs 0-5V  (internal reference -5V)
 	   1=DA outputs 0-10V (internal reference -10V)
 	   2=DA outputs unknown (external reference)
  Options for A-821PGLPGH:
    [0] - IO Base
    [1] - IRQ  (0=disable, 2, 3, 4, 5, 6, 7)
    [2] - 0=AD channels are S.E.
 	   1=AD channels are DIFF
    [3] - 0=DA output 0-5V  (internal reference -5V)
 	   1=DA output 0-10V (internal reference -10V)
  Options for A-821PGL-NDA:
    [0] - IO Base
    [1] - IRQ  (0=disable, 2, 3, 4, 5, 6, 7)
    [2] - 0=AD channels are S.E.
 	   1=AD channels are DIFF
  Options for PCL-813:
    [0] - IO Base
  Options for PCL-813B:
    [0] - IO Base
    [1] - 0= bipolar inputs
 	   1= unipolar inputs
  Options for ACL-8113, ISO-813:
    [0] - IO Base
    [1] - 0= 10V bipolar inputs
 	   1= 10V unipolar inputs
 	   2= 20V bipolar inputs
 	   3= 20V unipolar inputs
  Register IO map
 length of scan list 
 and ACL-8112PG 
 ACL-8112DGHG, A-822PGLPGH, A-823PGLPGH 
 and ICP DAS A-826PG 
 PGH, PGL, PGLNDA versions 
 8 differential 
 8 differential 
 8 differential 
 8 differential 
 8 differential 
 8 differential 
 8 differential 
 8 differential 
 8 differential 
 8 differential 
 8 differential 
 =1 we must add 1 to range number 
 stored INT number for some cards 
 how many samples transfer poll 
 settling time for gain 
 if using EOS, adapt DMA buffer to one scan 
	
	  Determine dma size based on the buffer size plus the number of
	  unread samples and the number of samples remaining in the command.
		
		  XXX this depends on selected range and can be very long for
		  some high gain ranges!
 writing any value clears the interrupt request 
 writing any value triggers a software conversion 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_EXT 
 TRIG_NONE 
 step 4: fix up any arguments 
  check if we can use DMA transfer 
  we cann't use DMA :-( 
  don't we want wake up every scan? 
  DMA is useless for this situation 
 setup and enable dma for the first buffer 
 Set up next channel. Added by abbotti 2010-01-20, but untested. 
 restart dma with the next buffer 
 poll is valid only for DMA transfer 
 new buffer position 
 no new samples 
 disable analog input trigger 
	
	  Invalidate last_ai_chanspec then set analog input to
	  known channelrange.
 set analog output channels to 0V 
 set all digital outputs low 
 only DMA channels 3 and 1 are valid 
 DMA uses two 8K buffers 
 we need an IRQ to do DMA on channel 3 or 1 
 differential analog inputs? 
 all boardtypes have analog inputs 
 Analog Input subdevice 
 analog output 
 Digital Input subdevice 
 Digital Output subdevice 
  we use external trigger 
 maybe there must by greatest timeout 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriversmite.c
  Hardware driver for NI Mite PCI interface chip
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1997-2002 David A. Schleef <ds@schleef.org>
  The PCI-MIO E series driver was originally written by
  Tomasz Motylewski <...>, and ported to comedi by ds.
  References for specifications:
     321747b.pdf  Register Level Programmer Manual (obsolete)
     321747c.pdf  Register Level Programmer Manual (new)
     DAQ-STC reference manual
  Other possibly relevant info:
     320517c.pdf  User manual (obsolete)
     320517f.pdf  User manual (new)
     320889a.pdf  delete
     320906c.pdf  maximum signal ratings
     321066a.pdf  about 16x
     321791a.pdf  discontinuation of at-mio-16e-10 rev. c
     321808a.pdf  about at-mio-16e-10 rev P
     321837a.pdf  discontinuation of at-mio-16de-10 rev d
     321838a.pdf  about at-mio-16de-10 rev N
  ISSUES:
  Mite registers
 chip signature 
 pci=0x3 
 minimite=1 
 mite=0, minimite=1 
 channel operation 
 stop without emptying fifo 
 stop after emptying fifo 
 channel control 
 transfer count 
 memory config 
 memory address 
 device config 
 device address 
 link config 
 link address 
 see tnt5002 manual 
 base address 
 base count 
 ? address 
 ? 
 ? 
 channel status 
 ??? 
 fifo count 
 common bits for the memorydevicelink config registers 
 This also works on m-series when using channels (drq_line) 4 or 5. 
  mite_bytes_in_transit() - Returns the number of unread bytes in the fifo.
  @mite_chan: MITE dma channel.
 returns lower bound for number of bytes transferred from device to memory 
 returns upper bound for number of bytes transferred from device to memory 
 returns lower bound for number of bytes read from memory to device 
 returns upper bound for number of bytes read from memory to device 
 write alloc as much as we can 
	
	  it's possible count will be negative due to conservative value
	  returned by mite_bytes_written_to_memory_lb
 read alloc as much as we can 
		
		  This is a special case where we continuously output a finite
		  buffer.  In this case, we do not free any of the memory,
		  hence we expect that old_alloc_count will reach a maximum of
		  stop_count bytes.
  mite_sync_dma() - Sync the MITE dma with the COMEDI async buffer.
  @mite_chan: MITE dma channel.
  @s: COMEDI subdevice.
  mite_ack_linkc() - Check and ack the LINKC interrupt,
  @mite_chan: MITE dma channel.
  @s: COMEDI subdevice.
  @sync: flag to force a mite_sync_dma().
  This will also ack the DONE interrupt if active.
  mite_done() - Check is a MITE dma transfer is complete.
  @mite_chan: MITE dma channel.
  This will also ack the DONE interrupt if active.
  mite_dma_arm() - Start a MITE dma transfer.
  @mite_chan: MITE dma channel.
	
	  memory barrier is intended to insure any twiddling with the buffer
	  is done before writing to the mite to arm dma transfer
 arm 
  mite_dma_disarm() - Stop a MITE dma transfer.
  @mite_chan: MITE dma channel.
 disarm 
  mite_prep_dma() - Prepare a MITE dma channel for transfers.
  @mite_chan: MITE dma channel.
  @num_device_bits: device transfer size (8, 16, or 32-bits).
  @num_memory_bits: memory transfer size (8, 16, or 32-bits).
 short link chaining mode 
	
	  Link Complete Interrupt: interrupt every time a link
	  in MITE_RING is completed. This can generate a lot of
	  extra interrupts, but right now we update the values
	  of buf_int_ptr and buf_int_count at each interrupt. A
	  better method is to poll the MITE before each user
	  "read()" to calculate the number of bytes available.
		
		  Doing a combined 32 and 16 bit byteswap gets the 16 bit
		  samples into the fifo in the right order. Tested doing 32 bit
		  memory to 16 bit device transfers to the analog out of a
		  pxi-6281, which has mite version = 1, type = 4. This also
		  works for dma reads from the counters on e-series boards.
 tofrom memory 
 fromto device 
 reset the DAR 
 the link is 32bits 
 starting address for link chaining 
  mite_request_channel_in_range() - Request a MITE dma channel.
  @mite: MITE device.
  @ring: MITE dma ring.
  @min_channel: minimum channel index to use.
  @max_channel: maximum channel index to use.
	
	  spin lock so mite_release_channel can be called safely
	  from interrupts
  mite_request_channel() - Request a MITE dma channel.
  @mite: MITE device.
  @ring: MITE dma ring.
  mite_release_channel() - Release a MITE dma channel.
  @mite_chan: MITE dma channel.
 spin lock to prevent races with mite_request_channel 
		
		  disable all channel's interrupts (do it after disarmreset so
		  MITE_CHCR reg isn't changed while dma is still active!)
  mite_init_ring_descriptors() - Initialize a MITE dma ring descriptors.
  @ring: MITE dma ring.
  @s: COMEDI subdevice.
  @nbytes: the size of the dma ring (in bytes).
  Initializes the ring buffer descriptors to provide correct DMA transfer
  links to the exact amount of memory required. When the ring buffer is
  allocated by mite_buf_change(), the default is to initialize the ring
  to refer to the entire DMA data buffer. A command may call this function
  later to re-initialize and shorten the amount of memory that will be
  transferred.
 We set the descriptors for all full links. 
 the last link is either a remainder or was a full link. 
 set the lesser count for the remainder link 
 Assign the last link->next to point back to the head of the list. 
	
	  barrier is meant to insure that all the writes to the dma descriptors
	  have completed before the dma controller is commanded to read them
  mite_buf_change() - COMEDI subdevice (buf_change) for a MITE dma ring.
  @ring: MITE dma ring.
  @s: COMEDI subdevice.
  mite_alloc_ring() - Allocate a MITE dma ring.
  @mite: MITE device.
  mite_free_ring() - Free a MITE dma ring and its descriptors.
  @ring: MITE dma ring.
	
	  Make sure dma bursts work. I got this from running a bus analyzer
	  on a pxi-6281 and a pxi-6713. 6713 powered up with register value
	  of 0x61f and bursts worked. 6281 powered up with register value of
	  0x1f and bursts didn't work. The NI windows driver reads the
	  register, then does a bitwise-or of 0x600 with it and writes it back.
	 
	  The bits 0x90180700 in MITE_UNKNOWN_DMA_BURST_REG can be
	  written and read back.  The bits 0x1f always read as 1.
	  The rest always read as zero.
 get the wpdep bits and convert it to the write port fifo depth 
 disable interrupts 
  mite_attach() - Allocate and initialize a MITE device for a comedi driver.
  @dev: COMEDI device.
  @use_win1: flag to use IO Window 1 instead of IO Window 0.
  Called by a COMEDI drivers (auto_attach).
  Returns a pointer to the MITE device on success, or NULL if the MITE cannot
  be allocated or remapped.
  mite_detach() - Unmap and free a MITE device for a comedi driver.
  @mite: MITE device.
  Called by a COMEDI drivers (detach).
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriversdt2817.c
  Hardware driver for Data Translation DT2817
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1998 David A. Schleef <ds@schleef.org>
  Driver: dt2817
  Description: Data Translation DT2817
  Author: ds
  Status: complete
  Devices: [Data Translation] DT2817 (dt2817)
  A very simple digital IO card.  Four banks of 8 lines, each bank
  is configurable for input or output.  One wonders why it takes a
  50 page manual to describe this thing.
  The driver (which, btw, is much less than 50 pages) has 1 subdevice
  with 32 channels, configurable in groups of 8.
  Configuration options:
  [0] - IO port base base address
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  Comedi driver for Keithley DAS-1700DAS-1800 series boards
  Copyright (C) 2000 Frank Mori Hess <fmhess@users.sourceforge.net>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: das1800
  Description: Keithley Metrabyte DAS1800 (& compatibles)
  Author: Frank Mori Hess <fmhess@users.sourceforge.net>
  Devices: [Keithley Metrabyte] DAS-1701ST (das-1701st),
    DAS-1701ST-DA (das-1701st-da), DAS-1701AO (das-1701ao),
    DAS-1702ST (das-1702st), DAS-1702ST-DA (das-1702st-da),
    DAS-1702HR (das-1702hr), DAS-1702HR-DA (das-1702hr-da),
    DAS-1702AO (das-1702ao), DAS-1801ST (das-1801st),
    DAS-1801ST-DA (das-1801st-da), DAS-1801HC (das-1801hc),
    DAS-1801AO (das-1801ao), DAS-1802ST (das-1802st),
    DAS-1802ST-DA (das-1802st-da), DAS-1802HR (das-1802hr),
    DAS-1802HR-DA (das-1802hr-da), DAS-1802HC (das-1802hc),
    DAS-1802AO (das-1802ao)
  Status: works
  Configuration options:
    [0] - IO port base address
    [1] - IRQ (optional, required for analog input cmd support)
    [2] - DMA0 (optional, requires irq)
    [3] - DMA1 (optional, requires irq and dma0)
  analog input cmd triggers supported:
    start_src		TRIG_NOW	command starts immediately
 			TRIG_EXT	command starts on external pin TGIN
    scan_begin_src	TRIG_FOLLOW	pacedexternal scans start immediately
 			TRIG_TIMER	burst scans start periodically
 			TRIG_EXT	burst scans start on external pin XPCLK
    scan_end_src	TRIG_COUNT	scan ends after last channel
    convert_src	TRIG_TIMER	pacedburst conversions are timed
 			TRIG_EXT	conversions on external pin XPCLK
 					(requires scan_begin_src == TRIG_FOLLOW)
    stop_src		TRIG_COUNT	command stops after stop_arg scans
 			TRIG_EXT	command stops on external pin TGIN
 			TRIG_NONE	command runs until canceled
  If TRIG_EXT is used for both the start_src and stop_src, the first TGIN
  trigger starts the command, and the second trigger will stop it. If only
  one is TRIG_EXT, the first trigger will either stop or start the command.
  The external pin TGIN is normally set for negative edge triggering. It
  can be set to positive edge with the CR_INVERT flag. If TRIG_EXT is used
  for both the start_src and stop_src they must have the same polarity.
  Minimum conversion speed is limited to 64 microseconds (convert_arg <= 64000)
  for 'burst' scans. This limitation does not apply for 'paced' scans. The
  maximum conversion speed is limited by the board (convert_arg >= ai_speed).
  Maximum conversion speeds are not always achievable depending on the
  board setup (see user manual).
  NOTES:
  Only the DAS-1801ST has been tested by me.
  Unipolar and bipolar ranges cannot be mixed in the channelgain list.
  The waveform analog output on the 'ao' cards is not supported.
  If you need it, send me (Frank Hess) an email.
 misc. defines 
 uses 16 io addresses 
  1024 sample fifo 
  size in bytes of dma buffers 
 Registers for the das1800 
 bipolar gain = 1 
 bipolar gain = 10 
 bipolar gain = 50 
 bipolar gain = 250 
 unipolar gain = 1 
 unipolar gain = 10 
 unipolar gain = 50 
 unipolar gain = 250 
 bipolar gain = 1 
 bipolar gain = 2 
 bipolar gain = 4 
 bipolar gain = 8 
 unipolar gain = 1 
 unipolar gain = 2 
 unipolar gain = 4 
 unipolar gain = 8 
  The waveform analog outputs on the 'ao' boards are not currently
  supported. They have a comedi_lrange of:
  { 2, { BIP_RANGE(10), BIP_RANGE(5) } }
 board probe id values (hi byte of the digital input register) 
  figure out how many points to read 
  switch to other channel and flush it 
  get any remaining samples in fifo 
 re-enable dma channel 
  clear DMATC interrupt bit 
  switch dma channels for next time, if appropriate 
 disable and stop conversions 
 select adc register (spinlock is already held) 
 get samples with dma, fifo, or polled as necessary 
 if the card's fifo has overflowed 
  clear OVF interrupt bit 
  stop taking data if appropriate 
 stop_src TRIG_EXT 
  clear CT0TC interrupt bit 
 get all remaining samples before quitting 
	
	  Protects the indirect addressing selected by DAS1800_SELECT
	  in das1800_ai_handler() also prevents race with das1800_interrupt().
	
	  Protects the indirect addressing selected by DAS1800_SELECT
	  in das1800_ai_handler() also prevents race with das1800_ai_poll().
 if interrupt was not caused by das-1800 
 clear the interrupt status bit INT 
  handle interrupt 
	
	  Paced mode:
	 	scan_begin_src is TRIG_FOLLOW
	 	convert_src is TRIG_TIMER
	 
	  The convert_arg sets the pacer sample acquisition time.
	  The max acquisition speed is limited to the boards
	  'ai_speed' (this was already verified). The min speed is
	  limited by the cascaded 8254 timer.
	
	  Burst mode:
	 	scan_begin_src is TRIG_TIMER or TRIG_EXT
	 	convert_src is TRIG_TIMER
	 
	  The convert_arg sets burst sample acquisition time.
	  The max acquisition speed is limited to the boards
	  'ai_speed' (this was already verified). The min speed is
	  limiited to 64 microseconds,
 round to microseconds then verify 
	
	  The pacer can be used to set the scan sample rate. The max scan
	  speed is limited by the conversion speed and the number of channels
	  to convert. The min speed is limited by the cascaded 8254 timer.
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 burst scans must use timed conversions 
 the external pin TGIN must use the same polarity 
 Step 3: check if arguments are trivially valid 
 Step 4: fix up any arguments 
 TRIG_TIMER or TRIG_EXT 
 Step 5: check channel list if it exists 
 for timed modes, make dma buffer fill in 'ns' time 
 not in burst mode 
 limit samples to what is remaining in the command 
 determine a dma transfer size to fill buffer in 0.3 sec 
 set up dual dma if appropriate 
 protects the indirect addressing selected by DAS1800_SELECT 
 select QRAM register and set start address 
 make channel  gain list 
 finish write to QRAM 
	
	  Disable dma on CMDF_WAKE_EOS, or CMDF_PRIORITY (because dma in
	  handler is unsafe at hard real-time priority).
  interrupt on end of conversion for CMDF_WAKE_EOS 
  interrupt fifo not empty 
  interrupt fifo half full 
 TRIG_NOW 
 set clock source to internal or external 
 not in burst mode 
 trig on cascaded counters 
 TRIG_EXT 
 trig on falling edge of external trigger 
 burst mode with internal pacer clock 
 TRIG_EXT 
 burst mode with external trigger 
 setup cascaded counters for conversionscan frequency 
 setup counter 0 for 'about triggering' 
  set conversion rate and length for burst mode 
 microseconds - 1 
 enable and start conversions 
 software pacer 
 enable conversions 
 reset fifo 
 protects the indirect addressing selected by DAS1800_SELECT 
 select ai fifo register 
 trigger conversion 
 protects the indirect addressing selected by DAS1800_SELECT 
 load this channel (and update if it's the last channel) 
 update all channels 
	
	  it->options[2] is DMA channel 0
	  it->options[3] is DMA channel 1
	 
	  Encode the DMA channels into 2 digit hexadecimal for switch.
  dma0 == 5 
  dma0 == 6 
  dma0 == 7 
  dma0 == 5, dma1 == 6 
  dma0 == 6, dma1 == 7 
  dma0 == 7, dma1 == 5 
 DMA can use 1 or 2 buffers, each with a separate channel 
	
	  The dev->board_ptr will be set by comedi_device_attach() if the
	  board name provided by the user matches a board->name in this
	  driver. If so, this function sanity checks the id to verify that
	  the board is correct.
	 
	   If the dev->board_ptr is not set, the user is trying to attach
	   an unspecified board to this driver. In this case the id is used
	   to 'probe' for the dev->board_ptr.
 das-1701st-da, das-1702st-da, das-1801st-da, das-1802st-da 
 das-1702hr-da, das-1802hr-da 
 das-1701ao, das-1702ao, das-1801ao, das-1802ao 
  das-1702hr, das-1802hr 
 das-1701st, das-1702st, das-1801st, das-1802st 
 das-1801hc, das-1802hc 
 waveform 'ao' boards have additional io ports 
 an irq and one dma channel is required to use dma 
	
	  Analog Input subdevice
	 
	  The "hc" type boards have 64 analog input channels and a 64
	  entry QRAM fifo.
	 
	  All the other board types have 16 on-board channels. Each channel
	  can be expanded to 16 channels with the addition of an EXP-1800
	  expansion board for a total of 256 channels. The QRAM fifo on
	  these boards has 256 entries.
	 
	  From the datasheets it's not clear what the comedi channel to
	  actual physical channel mapping is when EXP-1800 boards are used.
 Analog Output subdevice 
 initialize all channels to 0V 
 spinlock is not necessary during the attach 
		
		  'ao' boards have waveform analog outputs that are not
		  currently supported.
 Digital Input subdevice 
 Digital Output subdevice 
  initialize digital out channels 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  addi_apci_2032.c
  Copyright (C) 2004,2005  ADDI-DATA GmbH for the source code of this module.
  Project manager: Eric Stolz
 	ADDI-DATA GmbH
 	Dieselstrasse 3
 	D-77833 Ottersweier
 	Tel: +19(0)72239493-0
 	Fax: +49(0)72239493-92
 	http:www.addi-data.com
 	info@addi-data.com
  PCI bar 1 IO Register map
 protects the following members 
 an async command is running 
 mask of enabled interrupt channels 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_NONE 
 Step 4: fix up any arguments 
 Step 5: check channel list if it exists 
 Check if VCC OR CC interrupt has occurred 
 Disable triggered interrupt sources. 
	
	  Note: We don't reenable the triggered interrupt sources because they
	  are level-sensitive, hardware error status interrupt sources and
	  they'd keep triggering interrupts repeatedly.
 Bits in scan data correspond to indices in channel list. 
 Initialize the digital output subdevice 
 Initialize the watchdog subdevice 
 Initialize the interrupt subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriversamplc_pc236.c
  Driver for Amplicon PC36AT DIO boards.
  Copyright (C) 2002 MEV Ltd. <https:www.mev.co.uk>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: amplc_pc236
  Description: Amplicon PC36AT
  Author: Ian Abbott <abbotti@mev.co.uk>
  Devices: [Amplicon] PC36AT (pc36at)
  Updated: Fri, 25 Jul 2014 15:32:40 +0000
  Status: works
  Configuration options - PC36AT:
    [0] - IO port base address
    [1] - IRQ (optional)
  The PC36AT board has a single 8255 appearing as subdevice 0.
  Subdevice 1 pretends to be a digital input device, but it always returns
  0 when read. However, if you run a command with scan_begin_src=TRIG_EXT,
  a rising edge on port C bit 3 acts as an external trigger, which can be
  used to wake up tasks.  This is like the comedi_parport device, but the
  only way to physically disable the interrupt on the PC36AT is to remove
  the IRQ jumper.  If no interrupt is connected, then subdevice 1 is
  unused.
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriverscontec_pci_dio.c
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: contec_pci_dio
  Description: Contec PIO1616L digital IO board
  Devices: [Contec] PIO1616L (contec_pci_dio)
  Author: Stefano Rivoir <s.rivoir@gts.it>
  Updated: Wed, 27 Jun 2007 13:00:06 +0100
  Status: works
  Configuration Options: not applicable, uses comedi PCI auto config
  Register map
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriverscb_pcimdda.c
  Computer Boards PCIM-DDA06-16 Comedi driver
  Author: Calin Culianu <calin@ajvar.org>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: cb_pcimdda
  Description: Measurement Computing PCIM-DDA06-16
  Devices: [Measurement Computing] PCIM-DDA06-16 (cb_pcimdda)
  Author: Calin Culianu <calin@ajvar.org>
  Updated: Mon, 14 Apr 2008 15:15:51 +0100
  Status: works
  All features of the PCIM-DDA06-16 board are supported.
  This board has 6 16-bit AO channels, and the usual 8255 DIO setup.
  (24 channels, configurable in banks of 8 and 4, etc.).
  This board does not support commands.
  The board has a peculiar way of specifying AO gainrange settings -- You have
  1 jumper bank on the card, which either makes all 6 AO channels either
  5 Volt unipolar, 5V bipolar, 10 Volt unipolar or 10V bipolar.
  Since there is absolutely _no_ way to tell in software how this jumper is set
  (well, at least according to the rather thin spec. from Measurement Computing
  that comes with the board), the driver assumes the jumper is at its factory
  default setting of +-5V.
  Also of note is the fact that this board features another jumper, whose
  state is also completely invisible to software.  It toggles two possible AO
  output modes on the board:
    - Update Mode: Writing to an AO channel instantaneously updates the actual
      signal output by the DAC on the board (this is the factory default).
    - Simultaneous XFER Mode: Writing to an AO channel has no effect until
      you read from any one of the AO channels.  This is useful for loading
      all 6 AO values, and then reading from any one of the AO channels on the
      device to instantly update all 6 AO values in unison.  Useful for some
      control apps, I would assume? If your jumper is in this setting, then you
      need to issue your comedi_data_write()s to load all the values you want,
      then issue one comedi_data_read() on any channel on the AO subdevice
      to initiate the simultaneous XFER.
  Configuration Options: not applicable, uses PCI auto config
  This is a driver for the Computer Boards PCIM-DDA06-16 Analog Output
  card.  This board has a unique register layout and as such probably
  deserves its own driver file.
  It is theoretically possible to integrate this board into the cb_pcidda
  file, but since that isn't my code, I didn't want to significantly
  modify that file to support this board (I thought it impolite to do so).
  At any rate, if you feel ambitious, please feel free to take
  the code out of this file and combine it with a more unified driver
  file.
  I would like to thank Timothy Curry <Timothy.Curry@rdec.redstone.army.mil>
  for lending me a board so that I could write this driver.
  -Calin Culianu <calin@ajvar.org>
 device ids of the cards we support -- currently only 1 card supported 
  Register map, 8-bit access only
		
		  Write the LSB then MSB.
		 
		  If the simultaneous xfer mode is selected by the
		  jumper on the card, a read instruction is needed
		  in order to initiate the simultaneous transfer.
		  Otherwise, the DAC will be updated when the MSB
		  is written.
 Initiate the simultaneous transfer 
 analog output subdevice 
 digital io subdevice 
 SPDX-License-Identifier: GPL-2.0+
  comedidriversamplc_dio200.c
  Driver for Amplicon PC212E, PC214E, PC215E, PC218E, PC272E.
  Copyright (C) 2005-2013 MEV Ltd. <https:www.mev.co.uk>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1998,2000 David A. Schleef <ds@schleef.org>
  Driver: amplc_dio200
  Description: Amplicon 200 Series ISA Digital IO
  Author: Ian Abbott <abbotti@mev.co.uk>
  Devices: [Amplicon] PC212E (pc212e), PC214E (pc214e), PC215E (pc215e),
    PC218E (pc218e), PC272E (pc272e)
  Updated: Mon, 18 Mar 2013 14:40:41 +0000
  Status: works
  Configuration options:
    [0] - IO port base address
    [1] - IRQ (optional, but commands won't work without it)
  Passing a zero for an option is the same as leaving it unspecified.
  SUBDEVICES
                      PC212E         PC214E         PC215E
                   -------------  -------------  -------------
    Subdevices           6              4              5
     0                 PPI-X          PPI-X          PPI-X
     1                 CTR-Y1         PPI-Y          PPI-Y
     2                 CTR-Y2         CTR-Z1        CTR-Z1
     3                 CTR-Z1       INTERRUPT       CTR-Z2
     4                 CTR-Z2                      INTERRUPT
     5               INTERRUPT
                      PC218E         PC272E
                   -------------  -------------
    Subdevices           7              4
     0                 CTR-X1         PPI-X
     1                 CTR-X2         PPI-Y
     2                 CTR-Y1         PPI-Z
     3                 CTR-Y2       INTERRUPT
     4                 CTR-Z1
     5                 CTR-Z2
     6               INTERRUPT
  Each PPI is a 8255 chip providing 24 DIO channels.  The DIO channels
  are configurable as inputs or outputs in four groups:
    Port A  - channels  0 to  7
    Port B  - channels  8 to 15
    Port CL - channels 16 to 19
    Port CH - channels 20 to 23
  Only mode 0 of the 8255 chips is supported.
  Each CTR is a 8254 chip providing 3 16-bit counter channels.  Each
  channel is configured individually with INSN_CONFIG instructions.  The
  specific type of configuration instruction is specified in data[0].
  Some configuration instructions expect an additional parameter in
  data[1]; others return a value in data[1].  The following configuration
  instructions are supported:
    INSN_CONFIG_SET_COUNTER_MODE.  Sets the counter channel's mode and
      BCDbinary setting specified in data[1].
    INSN_CONFIG_8254_READ_STATUS.  Reads the status register value for the
      counter channel into data[1].
    INSN_CONFIG_SET_CLOCK_SRC.  Sets the counter channel's clock source as
      specified in data[1] (this is a hardware-specific value).  Not
      supported on PC214E.  For the other boards, valid clock sources are
      0 to 7 as follows:
        0.  CLK n, the counter channel's dedicated CLK input from the SK1
          connector.  (N.B. for other values, the counter channel's CLKn
          pin on the SK1 connector is an output!)
        1.  Internal 10 MHz clock.
        2.  Internal 1 MHz clock.
        3.  Internal 100 kHz clock.
        4.  Internal 10 kHz clock.
        5.  Internal 1 kHz clock.
        6.  OUT n-1, the output of counter channel n-1 (see note 1 below).
        7.  Ext Clock, the counter chip's dedicated Ext Clock input from
          the SK1 connector.  This pin is shared by all three counter
          channels on the chip.
    INSN_CONFIG_GET_CLOCK_SRC.  Returns the counter channel's current
      clock source in data[1].  For internal clock sources, data[2] is set
      to the period in ns.
    INSN_CONFIG_SET_GATE_SRC.  Sets the counter channel's gate source as
      specified in data[2] (this is a hardware-specific value).  Not
      supported on PC214E.  For the other boards, valid gate sources are 0
      to 7 as follows:
        0.  VCC (internal +5V d.c.), i.e. gate permanently enabled.
        1.  GND (internal 0V d.c.), i.e. gate permanently disabled.
        2.  GAT n, the counter channel's dedicated GAT input from the SK1
          connector.  (N.B. for other values, the counter channel's GATn
          pin on the SK1 connector is an output!)
        3.  OUT n-2, the inverted output of counter channel n-2 (see note
          2 below).
        4.  Reserved.
        5.  Reserved.
        6.  Reserved.
        7.  Reserved.
    INSN_CONFIG_GET_GATE_SRC.  Returns the counter channel's current gate
      source in data[2].
  Clock and gate interconnection notes:
    1.  Clock source OUT n-1 is the output of the preceding channel on the
    same counter subdevice if n > 0, or the output of channel 2 on the
    preceding counter subdevice (see note 3) if n = 0.
    2.  Gate source OUT n-2 is the inverted output of channel 0 on the
    same counter subdevice if n = 2, or the inverted output of channel n+1
    on the preceding counter subdevice (see note 3) if n < 2.
    3.  The counter subdevices are connected in a ring, so the highest
    counter subdevice precedes the lowest.
  The 'INTERRUPT' subdevice pretends to be a digital input subdevice.  The
  digital inputs come from the interrupt status register.  The number of
  channels matches the number of interrupt sources.  The PC214E does not
  have an interrupt status register; see notes on 'INTERRUPT SOURCES'
  below.
  INTERRUPT SOURCES
                      PC212E         PC214E         PC215E
                   -------------  -------------  -------------
    Sources              6              1              6
     0               PPI-X-C0       JUMPER-J5      PPI-X-C0
     1               PPI-X-C3                      PPI-X-C3
     2              CTR-Y1-OUT1                    PPI-Y-C0
     3              CTR-Y2-OUT1                    PPI-Y-C3
     4              CTR-Z1-OUT1                   CTR-Z1-OUT1
     5              CTR-Z2-OUT1                   CTR-Z2-OUT1
                      PC218E         PC272E
                   -------------  -------------
    Sources              6              6
     0              CTR-X1-OUT1     PPI-X-C0
     1              CTR-X2-OUT1     PPI-X-C3
     2              CTR-Y1-OUT1     PPI-Y-C0
     3              CTR-Y2-OUT1     PPI-Y-C3
     4              CTR-Z1-OUT1     PPI-Z-C0
     5              CTR-Z2-OUT1     PPI-Z-C3
  When an interrupt source is enabled in the interrupt source enable
  register, a rising edge on the source signal latches the corresponding
  bit to 1 in the interrupt status register.
  When the interrupt status register value as a whole (actually, just the
  6 least significant bits) goes from zero to non-zero, the board will
  generate an interrupt.  No further interrupts will occur until the
  interrupt status register is cleared to zero.  To clear a bit to zero in
  the interrupt status register, the corresponding interrupt source must
  be disabled in the interrupt source enable register (there is no
  separate interrupt clear register).
  The PC214E does not have an interrupt source enable register or an
  interrupt status register; its 'INTERRUPT' subdevice has a single
  channel and its interrupt source is selected by the position of jumper
  J5.
  COMMANDS
  The driver supports a read streaming acquisition command on the
  'INTERRUPT' subdevice.  The channel list selects the interrupt sources
  to be enabled.  All channels will be sampled together (convert_src ==
  TRIG_NOW).  The scan begins a short time after the hardware interrupt
  occurs, subject to interrupt latencies (scan_begin_src == TRIG_EXT,
  scan_begin_arg == 0).  The value read from the interrupt status register
  is packed into a short value, one bit per requested channel, in the
  order they appear in the channel list.
  Board descriptions.
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriverscb_pcidda.c
  Driver for the ComputerBoards  MeasurementComputing PCI-DDA series.
  Copyright (C) 2001 Ivan Martinez <ivanmr@altavista.com>
  Copyright (C) 2001 Frank Mori Hess <fmhess@users.sourceforge.net>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
  Driver: cb_pcidda
  Description: MeasurementComputing PCI-DDA series
  Devices: [Measurement Computing] PCI-DDA0812 (pci-dda0812),
    PCI-DDA0412 (pci-dda0412), PCI-DDA0212 (pci-dda0212),
    PCI-DDA0816 (pci-dda0816), PCI-DDA0416 (pci-dda0416),
    PCI-DDA0216 (pci-dda0216)
  Author: Ivan Martinez <ivanmr@altavista.com>
 	   Frank Mori Hess <fmhess@users.sourceforge.net>
  Status: works
  Configuration options: not applicable, uses PCI auto config
  Only simple analog output writing is supported.
  number of entries in eeprom 
 maximum number of ao channels for supported boards 
 Digital IO registers 
 DAC registers 
 DA Control Register  
  Simultaneous update  
  Enable specified DAC 
  Specify DAC channel  
  2.5V range           
  5V range             
  10V range            
  Unipolar range       
  DA CALIBRATION REGISTER 1 
 write bits 
 serial data input for eeprom, caldacs, reference dac 
 read bits 
 calibration counter overflow status bit 
 analog output is less than reference dac voltage 
  serial data out, for reading from eeprom 
  DA CALIBRATION REGISTER 2 
  send serial data in to eeprom 
 don't send serial data to MAX542 reference dac 
 don't send serial data to caldac n 
 manual says to set this bit with no explanation 
 Offsets for the caldac channels 
 bits last written to da calibration register 1 
 current range settings for output channels 
  software copy of board's eeprom 
 lowlevel read from eeprom 
  number of bits wide values are 
  read bits most significant bit first 
 lowlevel write to eepromdac 
  send bits most significant bit first 
 reads a 16 bit value from board's eeprom 
 one caldac for every two dac channels 
 bits to send to tell eeprom we want to read 
  send serial output stream to eeprom 
  deactivate caldacs (one caldac for every two channels) 
  tell eeprom we want to read 
  send address we want to read from 
  deactivate eeprom 
 writes to 8 bit calibration dacs 
 caldacs use 3 bit channel specification 
  8 bit calibration dacs 
 one caldac for every two dac channels 
 write 3 bit channel 
  write 8 bit caldac value 
  latch stream into appropriate caldac deselect reference dac
  deactivate caldacs (one caldac for every two channels) 
  activate the caldac we want 
  deactivate caldac 
 set caldacs to eeprom values for given channel and range 
 two caldacs per channel 
 caldac channel base 
 save range so we can tell when we need to readjust calibration 
 get values from eeprom data 
 set caldacs 
 analog output subdevice 
 two 8255 digital io subdevices 
 Read the caldac eeprom data 
  set calibrations dacs 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  dac02.c
  Comedi driver for DAC02 compatible boards
  Copyright (C) 2014 H Hartley Sweeten <hsweeten@visionengravers.com>
  Based on the poc driver
  Copyright (C) 2000 Frank Mori Hess <fmhess@users.sourceforge.net>
  Copyright (C) 2001 David A. Schleef <ds@schleef.org>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1998 David A. Schleef <ds@schleef.org>
  Driver: dac02
  Description: Comedi driver for DAC02 compatible boards
  Devices: [Keithley Metrabyte] DAC-02 (dac02)
  Author: H Hartley Sweeten <hsweeten@visionengravers.com>
  Updated: Tue, 11 Mar 2014 11:27:19 -0700
  Status: unknown
  Configuration options:
 	[0] - IO port base
  The output range is selected by jumpering pins on the IO connector.
 	    Range      Chan #   Jumper pins        Output
 	-------------  ------  -------------  -----------------
 	   0 to 5V       0        21 to 22      24
 	                 1        15 to 16      18
 	   0 to 10V      0        20 to 22      24
 	                 1        14 to 16      18
 	    +-5V        0        21 to 22      23
 	                 1        15 to 16      17
 	    +-10V       0        20 to 22      23
 	                 1        14 to 16      17
 	  4 to 20mA      0        21 to 22      25
 	                 1        15 to 16      19
 	AC reference     0      In on pin 22    24 (2-quadrant)
 	                        In on pin 22    23 (4-quadrant)
 	                 1      In on pin 16    18 (2-quadrant)
 	                        In on pin 16    17 (4-quadrant)
  Register IO map
		
		  Unipolar outputs are true binary encoding.
		  Bipolar outputs are complementary offset binary
		  (that is, 0 = +full scale, maxdata = -full scale).
		
		  DACs are double-buffered.
		  Write LSB then MSB to latch output.
 Analog Output subdevice 
 SPDX-License-Identifier: GPL-2.0+
   Copyright (C) 2004-2019 Bernd Porr, mail@berndporr.me.uk
  Driver: usbduxfast
  Description: University of Stirling USB DAQ & INCITE Technology Limited
  Devices: [ITL] USB-DUX-FAST (usbduxfast)
  Author: Bernd Porr <mail@berndporr.me.uk>
  Updated: 16 Nov 2019
  Status: stable
  I must give credit here to Chris Baugher who
  wrote the driver for AT-MIO-16d. I used some parts of this
  driver. I also must give credits to David Brownell
  who supported me with the USB development.
  Bernd Porr
  Revision history:
  1.0: Fixed a rounding error in usbduxfast_ai_cmdtest
  0.9: Dropping the first data packet which seems to be from the last transfer.
       Buffer overflows in the FX2 are handed over to comedi.
  0.92: Dropping now 4 packets. The quad buffer has to be emptied.
        Added insn command basically for testing. Sample rate is
        1MHz16ch=62.5kHz
  0.99: Ian Abbott pointed out a bug which has been corrected. Thanks!
  0.99a: added external trigger.
  1.00: added firmware kernel request to the driver which fixed
        udev coldplug problem
  timeout for the USB-transfer
  constants for "firmware" upload and download
  internal addresses of the 8051 processor
  max length of the transfer-buffer for software upload
  input endpoint number
  endpoint for the AD channellist: bulk OUT
  number of channels
  size of the waveform descriptor
  size of one AD value
  size of the input-buffer IN BYTES
  16 bytes
  size of the buffer for the dux commands in bytes
  number of in-URBs which receive the data: min=5
  min delay steps for more than one channel
  basically when the mux gives up ;-)
  steps at 30MHz in the FX2
  max number of 130MHz delay steps
  number of received packets to ignore before we start handing data
  over to comedi, it's quad buffering and we have to ignore 4 packets
  comedi constants
  private structure of one subdevice
  this is the structure which holds all the data of this driver
  one sub device just now: AD
 BULK-transfer handling: urb 
 asynchronous command is running 
 counter which ignores the first buffers 
  bulk transfers to usbduxfast
 Set the GPIF bytes, the first byte is the command byte 
 stop aquistion 
 kill the running transfer 
 if command is still running, resubmit urb for BULK transfer 
 exit if not running a command, do not resubmit urb 
 after an unlink command, unplug, ... etc 
 a real error 
	
	  comedi_handle_events() cannot be used in this driver. The (cancel)
	  operation would unlink the urb.
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 external start trigger is only valid for 1 or 16 channels 
	
	  Validate the conversion timing:
	  for 1 channel the timing in 30MHz "steps" is:
	 	steps <= MAX_SAMPLING_PERIOD
	  for all other chanlist_len it is:
	 	MIN_SAMPLING_PERIOD <= steps <= MAX_SAMPLING_PERIOD
 TRIG_NONE 
 Step 4: fix up any arguments 
 Step 5: check channel list if it exists 
	
	  ignore the first buffers from the device if there
	  is an error condition
		
		  one channel
		
		  for external trigger: looping in this state until
		  the RDY0 pin becomes zero
 we loop here until ready has been set 
 branch back to state 0 
 deceision state wo data 
 RDY0 = 0 
 we just proceed to state 1 
 for fast single channel aqu without mux 
				
				  we just stay here at state 1 and rexecute
				  the same state this gives us 30MHz sampling
				  rate
 branch back to state 1 
 deceision state with data 
 doesn't matter 
				
				  we loop through two states: data and delay
				  max rate is 15MHz
 data 
 doesn't matter 
 branch back to state 1 
 deceision state wo data 
 doesn't matter 
			
			  we loop through 3 states: 2x delay and 1x data
			  this gives a min sampling rate of 60kHz
 we have 1 state with duration 1 
 do the first part of the delay 
 and the second part 
 get the data and branch back 
 branch back to state 1 
 deceision state w data 
 doesn't matter 
		
		  two channels
		  commit data to the FIFO
 data 
 we have 1 state with duration 1: state 0 
 do the first part of the delay 
 count 
 and the second part 
 data 
		
		  we have 2 states with duration 1: step 6 and
		  the IDLE state
 do the first part of the delay 
 reset 
 and the second part 
		
		  three channels
			
			  commit data to the FIFO and do the first part
			  of the delay
 data 
 no change 
 do the second part of the delay 
 no data 
 count 
 2 steps with duration 1: the idele step and step 6: 
 commit data to the FIFO and do the first part of the delay 
 data 
 do the second part of the delay 
 no data 
 reset 
			
			  we loop here until ready has been set
 branch back to state 0 
 deceision state wo data 
 reset 
 RDY0 = 0 
			
			  we just proceed to state 1
 30us reset pulse 
 reset 
 commit data to the FIFO 
 data 
 we have 2 states with duration 1 
 do the first part of the delay 
 and the second part 
 branch back to state 1 
 deceision state wo data 
 doesn't matter 
 0 means that the AD commands are sent 
 enable this acquisition operation 
 fixme: unlink here?? 
 TRIG_INT 
  Mode 0 is used to get a single conversion on demand.
 set command for the first channel 
 commit data to the FIFO 
 data 
 do the first part of the delay 
 second part 
 we generate a local buffer for the firmware 
 we need a malloc'ed buffer for usb_control_msg() 
 stop the current firmware on the device 
 7f92 to one 
 upload the new firmware to the device 
 start the new firmware on the device 
 7f92 to zero 
 Analog Input subdevice 
 12-bit + 1 overflow bit 
 waits until a running transfer is over 
 { USB_DEVICE(0x4b4, 0x8613) }, testing 
 real ID 
 real ID 
 SPDX-License-Identifier: GPL-2.0+
      comedidriversni_daq_700.c
      Driver for DAQCard-700 DIOAI
      copied from 8255
      COMEDI - Linux Control and Measurement Device Interface
      Copyright (C) 1998 David A. Schleef <ds@schleef.org>
  Driver: ni_daq_700
  Description: National Instruments PCMCIA DAQCard-700
  Author: Fred Brooks <nsaspook@nsaspook.com>,
    based on ni_daq_dio24 by Daniel Vecino Castel <dvecino@able.es>
  Devices: [National Instruments] PCMCIA DAQ-Card-700 (ni_daq_700)
  Status: works
  Updated: Wed, 21 May 2014 12:07:20 +0000
  The daqcard-700 appears in Comedi as a  digital IO subdevice (0) with
  16 channels and a analog input subdevice (1) with 16 single-ended channels
  or 8 differential channels, and three input ranges.
  Digital:  The channel 0 corresponds to the daqcard-700's output
  port, bit 0; channel 8 corresponds to the input port, bit 0.
  Digital direction configuration: channels 0-7 output, 8-15 input.
  Analog: The input  range is 0 to 4095 with a default of -10 to +10 volts.
  Valid ranges:
        0 for -10 to 10V bipolar
        1 for -5 to 5V bipolar
        2 for -2.5 to 2.5V bipolar
  IRQ is assigned but not used.
  Manuals:	Register level:	https:www.ni.compdfmanuals340698.pdf
 		User Manual:	https:www.ni.compdfmanuals320676d.pdf
 daqcard700 registers 
 WO 8bit 
 RO 8bit 
 WO 8bit 
 RW 8bit 
 W0 8bit 
 RO 8bit 
 RO 8bit 
 RO 16bit 
 WO 8bit 
 RW 8bit 
 RW 8bit 
 RW 8bit 
 RO 8bit 
 WO 8bit 
 daqcard700 modes 
 diff mode 
 The DIO channels are not configurable, fix the io_bits 
 set channel input modes 
 write channel moderange 
 convert range to hardware value 
 write channel to multiplexer 
 set mask scan bit high to disable scanning 
 mux needs 2us to really settle [Fred Brooks]. 
 convert n samples 
 trigger conversion with out0 L to H 
 enable ADC conversions 
 mode 0 out0 L, from H 
 clear the ADC FIFO 
 read 16bit junk from FIFO to clear 
 mode 1 out0 H, L to H, start conversion 
 wait for conversion to end 
 read data 
 mangle the data as necessary 
 Bipolar Offset Binary: 0 to 4095 for -10 to +10 
  Data acquisition is enabled.
  The counter 0 output is high.
  The IO connector pin CLK1 drives counter 1 source.
  Multiple-channel scanning is disabled.
  All interrupts are disabled.
  The analog input range is set to +-10 V
  The analog input mode is single-ended.
  The analog input circuitry is initialized to channel 0.
  The AD FIFO is cleared.
 disable scanning, ADC to chan 0 
 clear all bits 
 set +-10 range 
 config counter mode1, out0 to H 
 clear counter interrupt 
 clear the ADC FIFO 
 read 16bit junk from FIFO to clear 
 DAQCard-700 dio 
 DAQCard-700 ai 
 SPDX-License-Identifier: GPL-2.0
  comedidriverspcl818.c
  Driver: pcl818
  Description: Advantech PCL-818 cards, PCL-718
  Author: Michal Dobes <dobes@tesnet.cz>
  Devices: [Advantech] PCL-818L (pcl818l), PCL-818H (pcl818h),
    PCL-818HD (pcl818hd), PCL-818HG (pcl818hg), PCL-818 (pcl818),
    PCL-718 (pcl718)
  Status: works
  All cards have 16 SE8 DIFF ADCs, one or two DACs, 16 DI and 16 DO.
  Differences are only at maximal sample speed, range list and FIFO
  support.
  The driver support AI mode 0, 1, 3 other subdevices (AO, DI, DO) support
  only mode 0. If DMAFIFOINT are disabled then AI support only mode 0.
  PCL-818HD and PCL-818HG support 1kword FIFO. Driver support this FIFO
  but this code is untested.
  A word or two about DMA. Driver support DMA operations at two ways:
  1) DMA uses two buffers and after one is filled then is generated
     INT and DMA restart with second buffer. With this mode I'm unable run
     more that 80Ksamplessecs without data dropouts on K6233.
  2) DMA uses one buffer and run in autoinit mode and the data are
     from DMA buffer moved on the fly with 2kHz interrupts from RTC.
     This mode is used if the interrupt 8 is available for allocation.
     If not, then first DMA mode is used. With this I can run at
     full speed one card (100ksamplessecs) or two cards with
     60ksamplessecs each (more is problem on account of ISA limitations).
     To use this mode you must have compiled  kernel with disabled
     "Enhanced Real Time Clock Support".
     Maybe you can have problems if you use xntpd or similar.
     If you've data dropouts with DMA mode 2 then:
      a) disable IDE DMA
      b) switch text mode console to fb.
   Options for PCL-818L:
   [0] - IO Base
   [1] - IRQ        (0=disable, 2, 3, 4, 5, 6, 7)
   [2] - DMA        (0=disable, 1, 3)
   [3] - 0, 10=10MHz clock for 8254
             1= 1MHz clock for 8254
   [4] - 0,  5=AD input  -5V.. +5V
         1, 10=AD input -10V..+10V
   [5] - 0,  5=DA output 0-5V  (internal reference -5V)
         1, 10=DA output 0-10V (internal reference -10V)
         2    =DA output unknown (external reference)
   Options for PCL-818, PCL-818H:
   [0] - IO Base
   [1] - IRQ        (0=disable, 2, 3, 4, 5, 6, 7)
   [2] - DMA        (0=disable, 1, 3)
   [3] - 0, 10=10MHz clock for 8254
             1= 1MHz clock for 8254
   [4] - 0,  5=DA output 0-5V  (internal reference -5V)
         1, 10=DA output 0-10V (internal reference -10V)
         2    =DA output unknown (external reference)
   Options for PCL-818HD, PCL-818HG:
   [0] - IO Base
   [1] - IRQ        (0=disable, 2, 3, 4, 5, 6, 7)
   [2] - DMAFIFO  (-1=use FIFO, 0=disable both FIFO and DMA,
                     1=use DMA ch 1, 3=use DMA ch 3)
   [3] - 0, 10=10MHz clock for 8254
             1= 1MHz clock for 8254
   [4] - 0,  5=DA output 0-5V  (internal reference -5V)
         1, 10=DA output 0-10V (internal reference -10V)
         2    =DA output unknown (external reference)
   Options for PCL-718:
   [0] - IO Base
   [1] - IRQ        (0=disable, 2, 3, 4, 5, 6, 7)
   [2] - DMA        (0=disable, 1, 3)
   [3] - 0, 10=10MHz clock for 8254
             1= 1MHz clock for 8254
   [4] -     0=AD Range is +-10V
             1=             +-5V
             2=             +-2.5V
             3=             +-1V
             4=             +-0.5V
             5=             user defined bipolar
             6=             0-10V
             7=             0-5V
             8=             0-2V
             9=             0-1V
            10=             user defined unipolar
   [5] - 0,  5=DA outputs 0-5V  (internal reference -5V)
         1, 10=DA outputs 0-10V (internal reference -10V)
             2=DA outputs unknown (external reference)
   [6] - 0, 60=max  60kHz AD sampling
         1,100=max 100kHz AD sampling (PCL-718 with Option 001 installed)
  Register IO map
 0=ext clk 
 W: fifo enabledisable 
 W: fifo interrupt clear 
 W: fifo interrupt clear 
 R: fifo status 
 R: one record from FIFO 
  manimal allowed delay between samples (in us) for actual card 
  MUX setting for actual AI operations 
  how long is actual MUX list 
  actual position in MUX list 
	
	  Determine dma size based on the buffer maxsize plus the number of
	  unread samples and the number of samples remaining in the command.
 store range list to card 
 writing any value clears the interrupt request 
 writing any value triggers a software conversion 
 restart dma with the next buffer 
		
		  The cleanup from ai_cancel() has been delayed
		  until now because the card doesn't seem to like
		  being reprogrammed while a DMA transfer is in
		  progress.
 correct channel and range number check itself comedirange.c 
  first channel is every time ok 
  build part of chanlist 
 we detect loop, this must by finish 
  channel list isn't continuous :-( 
  well, this is next correct channel in list 
  check whole chanlist 
  changain list is strange 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_EXT 
 TRIG_NONE 
 step 4: fix up any arguments 
 step 5: complain about special chanlist considerations 
  incorrect channels list 
 setup and enable dma for the first buffer 
 enable FIFO 
				
				  Wait for running dma transfer to end,
				  do cleanup in interrupt.
  FIFO shutdown 
 flush and disable the FIFO 
 disable analog input trigger 
 stop pacer 
 set analog output channels to 0V 
 set all digital outputs low 
 default to the range table from the boardinfo 
 now check the user config option based on the boardtype 
 secondary range list jumper selectable 
 only DMA channels 3 and 1 are valid 
 DMA uses two 16K buffers 
 we can use IRQ 2-7 for async command support 
 should we use the FIFO? 
 we need an IRQ to do DMA on channel 3 or 1 
 use 1MHz or 10MHz oscilator 
 max sampling speed 
 extended PCL718 to 100kHz DAC 
 Analog Output subdevice 
 Digital Input subdevice 
 Digital Output subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  ni_65xx.c
  Comedi driver for National Instruments PCI-65xx static dio boards
  Copyright (C) 2006 Jon Grierson <jd@renko.co.uk>
  Copyright (C) 2006 Frank Mori Hess <fmhess@users.sourceforge.net>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1999,2002,2003 David A. Schleef <ds@schleef.org>
  Driver: ni_65xx
  Description: National Instruments 65xx static dio boards
  Author: Jon Grierson <jd@renko.co.uk>,
 	   Frank Mori Hess <fmhess@users.sourceforge.net>
  Status: testing
  Devices: [National Instruments] PCI-6509 (pci-6509), PXI-6509 (pxi-6509),
    PCI-6510 (pci-6510), PCI-6511 (pci-6511), PXI-6511 (pxi-6511),
    PCI-6512 (pci-6512), PXI-6512 (pxi-6512), PCI-6513 (pci-6513),
    PXI-6513 (pxi-6513), PCI-6514 (pci-6514), PXI-6514 (pxi-6514),
    PCI-6515 (pxi-6515), PXI-6515 (pxi-6515), PCI-6516 (pci-6516),
    PCI-6517 (pci-6517), PCI-6518 (pci-6518), PCI-6519 (pci-6519),
    PCI-6520 (pci-6520), PCI-6521 (pci-6521), PXI-6521 (pxi-6521),
    PCI-6528 (pci-6528), PXI-6528 (pxi-6528)
  Updated: Mon, 21 Jul 2014 12:49:58 +0000
  Configuration Options: not applicable, uses PCI auto config
  Based on the PCI-6527 driver by ds.
  The interrupt subdevice (subdevice 3) is probably broken for all
  boards except maybe the 6514.
  This driver previously inverted the outputs on PCI-6513 through to
  PCI-6519 and on PXI-6513 through to PXI-6515.  It no longer inverts
  outputs on those cards by default as it didn't make much sense.  If
  you require the outputs to be inverted on those cards for legacy
  reasons, set the module parameter "legacy_invert_outputs=true" when
  loading the module, or set "ni_65xx.legacy_invert_outputs=true" on
  the kernel command line if the driver is built in to the kernel.
  Manuals (available from ftp:ftp.natinst.comsupportmanuals)
 	370106b.pdf	6514 Register Level Programmer Manual
  PCI BAR1 Register Map
 Non-recurring Registers (8-bit except where noted) 
 32-bit 
 32-bit 
 16-bit 
 16-bit 
 16-bit 
 16-bit 
 PXI-6528 only 
 32-bit 
 Recurring port registers (8-bit) 
 disable input filtering on all ports 
 set filter interval to 0 (32bit reg) 
 updates edge detection for base_chan to base_chan+31 
 clear edge detection for channels 0 to 31 
 clear edge detection for channels 32 to 63 
 clear edge detection for channels 64 to 95 
		
		  The deglitch filter interval is specified in nanoseconds.
		  The hardware supports intervals in 200ns increments. Round
		  the user values up and return the actual interval.
		
		  Enabledisable the channel for deglitch filtering. Note
		  that the filter interval is never set to '0'. This is done
		  because other channels might still be enabled for filtering.
 update the outputs 
 invert if necessary 
 invert back 
 read back the actual state 
 invert if necessary 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 Step 4: fix up any arguments 
 Step 5: check channel list if it exists 
 add instruction to check_insn_config_length() 
 update edge detection for channels 0 to 31 
 clear edge detection for channels 32 to 63 
 clear edge detection for channels 64 to 95 
 check trigger number 
 check digital trigger operation 
			
			  update edge detection for channels data[3]
			  to (data[3] + 31)
 ripped from mite.h and mite_setup2() to avoid mite dependency 
 IO Device Window Base Size Register 
 window enable 
 ioremap the MITE registers (BAR 0) temporarily 
 set data window to main registers (BAR 1) 
 finished with MITE registers 
 the input ports always start at port 0 
 the output ports always start after the input ports 
		
		  Use the io_bits to handle the inverted outputs.  Inverted
		  outputs are only supported if the "legacy_invert_outputs"
		  module parameter is set to "true".
 reset all output ports to comedi '0' 
 inverted if necessary 
 the inputoutput ports always start at port 0 
 configure all ports for input 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  Command support for NI general purpose counters
  Copyright (C) 2006 Frank Mori Hess <fmhess@users.sourceforge.net>
  Module: ni_tiocmd
  Description: National Instruments general purpose counters command support
  Author: J.P. Mellor <jpmellor@rose-hulman.edu>,
          Herman.Bruyninckx@mech.kuleuven.ac.be,
          Wim.Meeussen@mech.kuleuven.ac.be,
          Klaas.Gadeyne@mech.kuleuven.ac.be,
          Frank Mori Hess <fmhess@users.sourceforge.net>
  Updated: Fri, 11 Apr 2008 12:32:35 +0100
  Status: works
  This module is not used directly by end-users.  Rather, it
  is used by other drivers (for example ni_660x and ni_pcimio)
  to provide command support for NI's general purpose counters.
  It was originally split out of ni_tio.c to stop the 'ni_tio'
  module depending on the 'mite' module.
  References:
  DAQ 660x Register-Level Programmer Manual  (NI 370505A-01)
  DAQ 66016602 User Manual (NI 322137B-01)
  340934b.pdf  DAQ-STC reference manual
  TODO: Support use of both banks X and Y
 write alloc the entire buffer 
 TRIG_NOW || TRIG_EXT || TRIG_OTHER 
 using a device-global name. lookup reg 
 mark this as a raw register value 
 Lookup and use the real register values 
			
			  This function must be used separately since it does
			  not expect real register values and attempts to
			  convert these to real register values.
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 start_arg is the start_trigger passed to ni_tio_arm() 
		
		  This should be done, but we don't yet know the actual
		  register values.  These should be tested and then documented
		  in the ni_route_valuesni_.csv files, with indication of
		  whowhenwhichhow these were tested.
		  When at least a em660x series have been tested, this code
		  should be uncommented:
		 
		  err |= ni_check_trigger_arg(CR_CHAN(cmd->start_arg),
		 			    NI_CtrArmStartTrigger(cidx),
		 			    routing_tables);
	
	  It seems that convention is to allow either scan_begin_arg or
	  convert_arg to specify the Gate source, with scan_begin_arg taking
	  precedence.
 Step 4: fix up any arguments 
 Step 5: check channel list if it exists 
		
		  not sure if 660x really supports gate interrupts
		  (the bits are not listed in register-level manual)
		
		  During buffered input counter operation for e-series,
		  the gate interrupt is acked automatically by the dma
		  controller, due to the Gi_ReadWrite_Acknowledges_IRQ
		  bits in the input select register.
			
			  660x don't support automatic acknowledgment
			  of gate interrupt via dma readwrite
			  and report bogus gate errors
 SPDX-License-Identifier: GPL-2.0+
  dt3000.c
  Data Translation DT3000 series driver
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1999 David A. Schleef <ds@schleef.org>
  Driver: dt3000
  Description: Data Translation DT3000 series
  Devices: [Data Translation] DT3001 (dt3000), DT3001-PGL, DT3002, DT3003,
    DT3003-PGL, DT3004, DT3005, DT3004-200
  Author: ds
  Updated: Mon, 14 Apr 2008 15:41:24 +0100
  Status: works
  Configuration Options: not applicable, uses PCI auto config
  There is code to support AI commands, but it may not work.
  AO commands are not supported.
  The DT3000 series is Data Translation's attempt to make a PCI
  data acquisition board.  The design of this series is very nice,
  since each board has an on-board DSP (Texas Instruments TMS320C52).
  However, a few details are a little annoying.  The boards lack
  bus-mastering DMA, which eliminates them from serious work.
  They also are not capable of autocalibration, which is a common
  feature in modern hardware.  The default firmware is pretty bad,
  making it nearly impossible to write an RT compatible driver.
  It would make an interesting project to write a decent firmware
  for these boards.
  Data Translation originally wanted an NDA for the documentation
  for the 3k series.  However, if you ask nicely, they might send
  you the docs without one, also.
  PCI BAR0 - dual-ported RAM location definitions (dev->mmio)
 a.k.a. 3004-200 
 FIXME! Assumes shared interrupt is for this card. 
 What's this debug_n_ints stuff? Obviously needs some work... 
 This function needs improvement 
 Don't know if divider==0 works. 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_NONE 
 step 4: fix up any arguments 
 XXX docs don't explain how to select aref 
 XXX 
 XXX write 0 to DPR_PARAMS(1) and DPR_PARAMS(2) ? 
 Analog Input subdevice 
 XXX 
 Analog Output subdevice 
 Digital IO subdevice 
 Memory subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  aio_aio12_8.c
  Driver for Access IO Products PC-104 AIO12-8 Analog IO Board
  Copyright (C) 2006 C&C Technologies, Inc.
  Driver: aio_aio12_8
  Description: Access IO Products PC-104 AIO12-8 Analog IO Board
  Author: Pablo Mejia <pablo.mejia@cctechnol.com>
  Devices: [Access IO] PC-104 AIO12-8 (aio_aio12_8),
    [Access IO] PC-104 AI12-8 (aio_ai12_8),
    [Access IO] PC-104 AO12-4 (aio_ao12_4)
  Status: experimental
  Configuration Options:
    [0] - IO port base address
  Notes:
  Only synchronous operations are supported.
  Register map
	
	  Setup the control byte for internal 2MHz clock, 3uS conversion,
	  at the desired range of the requested channel.
 Read status to clear EOC latch 
  Setup and start conversion 
  Wait for conversion to complete 
 munge bipolar 2's complement data to offset binary 
 enable DACs 
		
		  Channels 0 and 2 have external clock sources.
		  Channel 1 has a fixed 1 MHz clock source.
 Analog Input subdevice 
 Analog Output subdevice 
 Digital IO subdevice (8255) 
 Counter subdevice (8254) 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0
  comedidriversadv_pci_dio.c
  Author: Michal Dobes <dobes@tesnet.cz>
   Hardware driver for Advantech PCI DIO cards.
  Driver: adv_pci_dio
  Description: Advantech Digital IO Cards
  Devices: [Advantech] PCI-1730 (adv_pci_dio), PCI-1733,
    PCI-1734, PCI-1735U, PCI-1736UP, PCI-1739U, PCI-1750,
    PCI-1751, PCI-1752, PCI-1753, PCI-1753+PCI-1753E,
    PCI-1754, PCI-1756, PCI-1761, PCI-1762
  Author: Michal Dobes <dobes@tesnet.cz>
  Updated: Fri, 25 Aug 2017 07:23:06 +0300
  Status: untested
  Configuration Options: not applicable, uses PCI auto config
  Register offset definitions
 PCI-1730, PCI-1733, PCI-1736 interrupt control registers 
 RW: enabledisable 
 RW: fallingrising edge 
 R: status 
 W: clear 
 IDI0 edge occurred 
 IDI1 edge occurred 
 DI0 edge occurred 
 DI1 edge occurred 
 PCI-1739U, PCI-1750, PCI1751 interrupt control registers 
 RW: statuscontrol 
 PCI-1753, PCI-1753E interrupt control registers 
 RW: control group 0 to 3 
 RW: control group 0 to 3 
 PCI-1754, PCI-1756 interrupt control registers 
 RW: control group 0 to 3 
 PCI-1752, PCI-1756 special registers 
 RW: channel freeze function 
 PCI-1761 interrupt control registers 
 RW: enabledisable interrupts 
 RW: fallingrising edge 
 RW: clear interrupts 
 PCI-1762 interrupt control registers 
 RW: statuscontrol 
 maximum number of subdevice descriptions in the boardinfo 
 2 x 81632 input channels max 
 2 x 81632 output channels max 
 2 x any number of 8255 devices max 
 4 x 1 input IRQ channels max 
  num of chans or 8255 devices 
  PCI address offset 
 interrupt enablestatus bit 
 PCI address offset 
  board name 
 DI, IDI, DO, IDO, ID, IRQ_DI0, IRQ_DI1, IRQ_IDI0, IRQ_IDI1 
 DI 0-15 
 ISO DI 0-15 
 DO 0-15 
 ISO DO 0-15 
 DI 0 
 DI 1 
 ISO DI 0 
 ISO DI 1 
 ISO DI 0-31 
 ISO DO 0-31 
 DI 0-31 
 DO 0-31 
 ISO DI 0-15 
 ISO DO 0-15 
 8255 DIO 
 ISO DI 0-15 
 ISO DO 0-15 
 8255 DIO 
 DO 0-31 
 DO 32-63 
 8255 DIO 
 8255 DIO 
 8255 DIO 
 DI 0-31 
 DI 32-63 
 DI 0-31 
 DO 0-31 
 ISO DI 0-7 
 RELAY DO 0-7 
 ISO DI 0-15 
 ISO DO 0-15 
 spin-lock for cmd_running 
 Ignore interrupt before device fully attached. 
 Might not even have allocated subdevices yet! 
 Check if we are source of interrupt 
 clear all current interrupt flags 
 check irq subdevice triggers 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
	
	  For scan_begin_arg, the trigger number must be 0 and the only
	  allowed flags are CR_EDGE and CR_INVERT.  CR_EDGE is ignored,
	  CR_INVERT sets the trigger to falling edge.
 Step 4: fix up any arguments 
 Step 5: check channel list if it exists 
 falling edge 
 rising edge 
 enable interrupt source 
 same as _insn_bits_di_ because the IRQ-pins are the DI-ports  
 disable channel freeze function on the PCI-17521756 boards 
 disable and clear interrupts 
 Reset all 4 Int Flags 
 Rising Edge => IRQ . On all 4 Pins 
 disable interrupts 
 clear interrupts 
 set rising edge trigger 
 request IRQ if device has irq subdevices 
 reset all outputs to 0 
 first interrupt subdevice index 
	
	  Change cardtype from TYPE_PCI1753 to TYPE_PCI1753E if expansion
	  board available.  Need to enable PCI device and request the main
	  registers PCI BAR temporarily to perform the test.
		
		  This test is based on Advantech's "advdaq" driver source
		  (which declares its module licence as "GPL" although the
		  driver source does not include a "COPYING" file).
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriversme_daq.c
  Hardware driver for Meilhaus data acquisition cards:
    ME-2000i, ME-2600i, ME-3000vm1
  Copyright (C) 2002 Michael Hillmann <hillmann@syscongroup.de>
  Driver: me_daq
  Description: Meilhaus PCI data acquisition cards
  Devices: [Meilhaus] ME-2600i (me-2600i), ME-2000i (me-2000i)
  Author: Michael Hillmann <hillmann@syscongroup.de>
  Status: experimental
  Configuration options: not applicable, uses PCI auto config
  Supports:
     Analog Input, Analog Output, Digital IO
 Xilinx registers 
  PCI BAR2 Memory map (dev->mmio)
 R (ai start) | W 
 R (dac update) | W 
 R | W (clears interrupts) 
 R | W 
 R | W 
 - | W 
 R (fifo) | W (chanlist) 
 R (updates) | W 
 - | W 
 - | W 
 - | W 
 R | - 
 PLX configuration base address 
 Mirror of CONTROL_1 register 
 Mirror of CONTROL_2 register 
 Mirror of the DAC_CONTROL register 
	
	  For differential operation, there are only 8 input channels
	  and only bipolar ranges are available.
 clear chanlist and ad fifo 
 clear interrupts 
 enable the chanlist and ADC fifo 
 write to channel list fifo 
 set ADC mode to software trigger 
 start ai conversion 
 wait for ADC fifo not empty flag 
 get value from ADC fifo 
 munge 2's complement value to offset binary 
 stop any running conversion 
 Enable all DAC 
 and set DAC to "buffered" mode 
 Set dac-control register 
 Update dac-control register 
 Set data register 
 Update dac with data registers 
 disable irq's on PLX 
 First, make a dummy read to reset xilinx 
 Wait until reset is over 
 Write a dummy value to Xilinx 
	
	  Format of the firmware
	  Build longs from the byte-wise coded header
	  Byte 1-3:   length of the array
	  Byte 4-7:   version
	  Byte 8-11:  date
	  Byte 12-15: reserved
	
	  Loop for writing firmware byte by byte to xilinx
	  Firmware data start at offset 16
 Write 5 dummy values to xilinx 
 Test if there was an error during download -> INTB was thrown 
 Disable interrupt 
 Wait until the Xilinx is ready for real work 
 Enable PLX-Interrupts 
 Reset board 
 clear interrupts 
 Save values in the board context 
 Download firmware and reset card 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriversdaqboard2000.c
  hardware driver for IOtech DAQboard2000
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1999 Anders Blomdell <anders.blomdell@control.lth.se>
  Driver: daqboard2000
  Description: IOTech DAQBoard2000
  Author: Anders Blomdell <anders.blomdell@control.lth.se>
  Status: works
  Updated: Mon, 14 Apr 2008 15:28:52 +0100
  Devices: [IOTech] DAQBoard2000 (daqboard2000)
  Much of the functionality of this driver was determined from reading
  the source code for the Windows driver.
  The FPGA on the board requires firmware, which is available from
  https:www.comedi.org in the comedi_nonfree_firmware tarball.
  Configuration options: not applicable, uses PCI auto config
  This card was obviously never intended to leave the Windows world,
  since it lacked all kind of hardware documentation (except for cable
  pinouts, plug and pray has something to catch up with yet).
  With some help from our swedish distributor, we got the Windows sourcecode
  for the card, and here are the findings so far.
  1. A good document that describes the PCI interface chip is 9080db-106.pdf
     available from http:www.plxtech.comproductsiopci9080
  2. The initialization done so far is:
       a. program the FPGA (windows code sans a lot of error messages)
       b.
  3. Analog out seems to work OK with DAC's disabled, if DAC's are enabled,
     you have to output values to all enabled DAC's until result appears, I
     guess that it has something to do with pacer clocks, but the source
     gives me no clues. I'll keep it simple so far.
  4. Analog in.
     Each channel in the scanlist seems to be controlled by four
     control words:
 	Word0:
 	  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 	  ! | | | ! | | | ! | | | ! | | | !
 	  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 	Word1:
 	  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 	  ! | | | ! | | | ! | | | ! | | | !
 	  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 	   |             |       | | | | |
 	   +------+------+       | | | | +-- Digital input (??)
 		  |		 | | | +---- 10 us settling time
 		  |		 | | +------ Suspend acquisition (last to scan)
 		  |		 | +-------- Simultaneous sample and hold
 		  |		 +---------- Signed data format
 		  +------------------------- Correction offset low
 	Word2:
 	  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 	  ! | | | ! | | | ! | | | ! | | | !
 	  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 	   |     | |     | | | | | |     |
 	   +-----+ +--+--+ +++ +++ +--+--+
 	      |       |     |   |     +----- Expansion channel
 	      |       |     |   +----------- Expansion gain
 	      |       |     +--------------- Channel (low)
 	      |       +--------------------- Correction offset high
 	      +----------------------------- Correction gain low
 	Word3:
 	  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 	  ! | | | ! | | | ! | | | ! | | | !
 	  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 	   |             | | | |   | | | |
 	   +------+------+ | | +-+-+ | | +-- Low bank enable
 		  |	   | |   |   | +---- High bank enable
 		  |	   | |   |   +------ Hilow select
 		  |	   | |   +---------- Gain (1,?,2,4,8,16,32,64)
 		  |	   | +-------------- differentialsingle ended
 		  |	   +---------------- Unipolar
 		  +------------------------- Correction gain high
  999. The card seems to have an incredible amount of capabilities, but
       trying to reverse engineer them from the Windows source is beyond my
       patience.
  Register Memory Map
 u16 (w) 
 u16 (r) 
 u16 
 u32 
 u16 
 u16 
 u16 
 u16 
 u16 
 u16 
 u16 
 u16 (w) 
 u16 (r) 
 s16 
 u16 
 u16 
 u16 
 s16 
 u16 
 u16 
 s16 
 s16 
 u16 
 s16 
 u16 
 u16 
 u16 
 u16 
 u16 
 u16 
 s16 
 CPLD registers 
 u16 (r) 
 u16 (w) 
 Scan Sequencer programming 
 Prepare for acquisition 
 Pacer Clock Control 
 Acquisition status bits 
 DAC status 
 DAC control 
 Trigger Control 
 Reference Dac Selection 
 CPLD status bits 
 "New CPLD" signature. 
 false: 4 AO chans; true: 2 AO chans 
 Channel 0-7 diff, channel 8-23 single ended 
 Last scan 
 These should be read from EEPROM 
 offset 
 gain 
	
	  If pacer clock is not set to some high value (> 10 us), we
	  risk multiple samples to be put into the result FIFO.
 1 second, should be long enough 
	
	  This doesn't look efficient.  I decided to take the conservative
	  approach when I did the insn conversion.  Perhaps it would be
	  better to have broken it completely, then someone would have been
	  forced to fix it.  --ds
 Enable reading from the scanlist FIFO 
 Not in the original code, but I like symmetry... 
 timeout after 50 tries -> 5ms 
 Time out after 200 tries -> 20ms 
 General Purpose Input (USERI) set on FPGA "DONE". 
 Look for FPGA start sequence in firmware. 
 Check length is even. 
 Strip firmware header. 
 Check to make sure the serial eeprom is present on the board 
 Disable hardware triggers 
 Stop the scan list FIFO from loading the configuration pipe 
 Stop the pacer clock 
 Stop the input dma (abort channel 1) 
  Set the + reference dac value in the FPGA 
  Set the - reference dac value in the FPGA 
 ai subdevice 
 ao subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriversdas800.c
  Driver for Keitley das800 series boards and compatibles
  Copyright (C) 2000 Frank Mori Hess <fmhess@users.sourceforge.net>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: das800
  Description: Keithley Metrabyte DAS800 (& compatibles)
  Author: Frank Mori Hess <fmhess@users.sourceforge.net>
  Devices: [Keithley Metrabyte] DAS-800 (das-800), DAS-801 (das-801),
  DAS-802 (das-802),
  [Measurement Computing] CIO-DAS800 (cio-das800),
  CIO-DAS801 (cio-das801), CIO-DAS802 (cio-das802),
  CIO-DAS80216 (cio-das80216)
  Status: works, cio-das80216 untested - email me if you have tested it
  Configuration options:
  [0] - IO port base address
  [1] - IRQ (optional, required for timed or externally triggered conversions)
  Notes:
 	IRQ can be omitted, although the cmd interface will not work without it.
 	All entries in the channelgain list must use the same gain and be
 	consecutive channels counting upwards in channel number (these are
 	hardware limitations.)
 	I've never tested the gain setting stuff since I only have a
 	DAS-800 board with fixed gain.
 	The cio-das80216 does not have a fifo-empty status bit!  Therefore
 	only fifo-half-full transfers are possible with this card.
  cmd triggers supported:
 	start_src:      TRIG_NOW | TRIG_EXT
 	scan_begin_src: TRIG_FOLLOW
 	scan_end_src:   TRIG_COUNT
 	convert_src:    TRIG_TIMER | TRIG_EXT
 	stop_src:       TRIG_NONE | TRIG_COUNT
  number of analog input channels 
 Registers for the das800 
 cio-das80216 fifo overflow 
 cio-das80216 fifo half full int ena 
 digital output bits 
	
	  Select dev->iobase + 2 to be desired register
	  then write to that register.
	
	  Select dev->iobase + 7 to be desired register
	  then read from that register.
  enable fifo-half full interrupts for cio-das80216 
 enable hardware triggering 
 enable card's interrupt 
 disable hardware triggering of conversions 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_NONE 
 step 4: fix up any arguments 
 Step 5: check channel list if it exists 
 set scan limits 
 set gain 
	 enable auto channel scan, send interrupts on end of conversion
	  and set clock source to internal or external
	
	  Don't release spinlock yet since we want to make sure
	  no one else disables hardware conversions.
 if hardware conversions are not enabled, then quit 
 cio-das80216 has no fifo empty status bit 
 12-bit sample 
		
		  Re-enable card's interrupt.
		  We already have spinlock, so indirect addressing is safe
 otherwise, stop taking data 
 set multiplexer 
 set gain  range 
 trigger conversion 
 12-bit sample 
	
	  The dev->board_ptr will be set by comedi_device_attach() if the
	  board name provided by the user matches a board->name in this
	  driver. If so, this function sanity checks the id_bits to verify
	  that the board is correct.
	 
	  If the dev->board_ptr is not set, the user is trying to attach
	  an unspecified board to this driver. In this case the id_bits
	  are used to 'probe' for the correct dev->board_ptr.
 Analog Input subdevice 
 Digital Input subdevice 
 Digital Output subdevice 
 initialize digital out channels 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedi_parport.c
  Comedi driver for standard parallel port
  For more information see:
 	http:retired.beyondlogic.orgsppparallel.htm
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1998,2001 David A. Schleef <ds@schleef.org>
  Driver: comedi_parport
  Description: Standard PC parallel port
  Author: ds
  Status: works in immediate mode
  Devices: [standard] parallel port (comedi_parport)
  Updated: Tue, 30 Apr 2002 21:11:45 -0700
  A cheap and easy way to get a few more digital IO lines. Steal
  additional parallel ports from old computers or your neighbors'
  computers.
  Option list:
    0: IO port base for the parallel port.
    1: IRQ (optional)
  Parallel Port Lines:
 	 pin   subdev  chan  type  name
 	-----  ------  ----  ----  --------------
 	  1      2       0    DO   strobe
 	  2      0       0    DIO  data 0
 	  3      0       1    DIO  data 1
 	  4      0       2    DIO  data 2
 	  5      0       3    DIO  data 3
 	  6      0       4    DIO  data 4
 	  7      0       5    DIO  data 5
 	  8      0       6    DIO  data 6
 	  9      0       7    DIO  data 7
 	 10      1       3    DI   ack
 	 11      1       4    DI   busy
 	 12      1       2    DI   paper out
 	 13      1       1    DI   select in
 	 14      2       1    DO   auto LF
 	 15      1       0    DI   error
 	 16      2       2    DO   init
 	 17      2       3    DO   select printer
 	18-25                      ground
  When an IRQ is configured subdevice 3 pretends to be a digital
  input subdevice, but it always returns 0 when read. However, if
  you run a command with scan_begin_src=TRIG_EXT, it uses pin 10
  as a external trigger, which can be used to wake up tasks.
  Register map
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 Step 4: fix up any arguments 
 Step 5: check channel list if it exists 
 Digial IO subdevice - Parallel port DATA register 
 Digial Input subdevice - Parallel port STATUS register 
 Digial Output subdevice - Parallel port CONTROL register 
 Digial Input subdevice - Interrupt support 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriversjr3_pci.c
  hardware driver for JR3PCI force sensor board
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2007 Anders Blomdell <anders.blomdell@control.lth.se>
  Driver: jr3_pci
  Description: JR3PCI force sensor board
  Author: Anders Blomdell <anders.blomdell@control.lth.se>
  Updated: Thu, 01 Nov 2012 17:34:55 +0000
  Status: works
  Devices: [JR3] PCI force sensor board (jr3_pci)
  Configuration options:
    None
  Manual configuration of comedi devices is not supported by this
  driver; supported PCI devices are configured as comedi devices
  automatically.
  The DSP on the board requires initialization code, which can be
  loaded by placing it in libfirmwarecomedi.  The initialization
  code should be somewhere on the media you got with your card.  One
  version is available from https:www.comedi.org in the
  comedi_nonfree_firmware tarball.  The file is called "jr3pci.idm".
 Make sure that 0 <= num <= 15 
 No sensor or sensor changed 
 Restart polling 
 Skip over non hex 
 Collect value 
	
	  IDM file format is:
	    { count, address, data <count> } 
	    ffff
 16 bit data, never seen in real life!! 
 jr3[addr + 0x20000  pnum] = data1; 
 Download 24 bit program 
 verify IDM file format 
 write firmware to each subdevice 
 Sensor communication lost? force poll mode 
			
			  Still no sensor, keep on polling.
			  Since it takes up to 10 seconds for offsets to
			  stabilize, polling each second should suffice.
			
			  Wait for offeset to stabilize
			  (< 10 s according to manual)
 Transformation all zeros 
 Allow 20 ms for completion 
 Set full scale 
 Allow 20 ms for completion 
 Use ranges in kN or we will overflow around 2000N! 
 the next five are questionable 
 Allow 40 ms for completion 
 Poll all sensors that are ready to be polled 
				
				  Wake up as late as possible ->
				  poll as many sensors as possible at once.
 Channel specific range and maxdata 
 Reset DSP card 
	
	  TODO: use firmware to load preferred offset tables. Suggested
	  format:
	      model serial Fx Fy Fz Mx My Mz\n
	 
	      comedi_load_firmware(dev, &comedi_to_pci_dev(dev)->dev,
	                           "comedijr3_offsets_table",
	                           jr3_download_firmware, 1);
	
	  It takes a few milliseconds for software to settle as much as we
	  can read firmware version
 Start card timer 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  ke_counter.c
  Comedi driver for Kolter-Electronic PCI Counter 1 Card
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: ke_counter
  Description: Driver for Kolter Electronic Counter Card
  Devices: [Kolter Electronic] PCI Counter Card (ke_counter)
  Author: Michael Hillmann
  Updated: Mon, 14 Apr 2008 15:42:42 +0100
  Status: tested
  Configuration Options: not applicable, uses PCI auto config
  PCI BAR 0 Register IO map
 Order matters 
 Order matters 
 default 
 option 
 Pin 21 on D-sub 
 50ns 
 250ns 
 Unknown 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  rti802.c
  Comedi driver for Analog Devices RTI-802 board
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1999 Anders Blomdell <anders.blomdell@control.lth.se>
  Driver: rti802
  Description: Analog Devices RTI-802
  Author: Anders Blomdell <anders.blomdell@control.lth.se>
  Devices: [Analog Devices] RTI-802 (rti802)
  Status: works
  Configuration Options:
    [0] - io base
    [1] - unused
    [2,4,6,8,10,12,14,16] - dac#[0-7]  0=two's comp, 1=straight
    [3,5,7,9,11,13,15,17] - dac#[0-7]  0=bipolar, 1=unipolar
  Register IO map
 munge offset binary to two's complement if needed 
 Analog Output subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  pcmmio.c
  Driver for Winsystems PC-104 based multifunction IO board.
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2007 Calin A. Culianu <calin@ajvar.org>
  Driver: pcmmio
  Description: A driver for the PCM-MIO multifunction board
  Devices: [Winsystems] PCM-MIO (pcmmio)
  Author: Calin Culianu <calin@ajvar.org>
  Updated: Wed, May 16 2007 16:21:10 -0500
  Status: works
  A driver for the PCM-MIO multifunction board from Winsystems. This
  is a PC-104 based IO board. It contains four subdevices:
 	subdevice 0 - 16 channels of 16-bit AI
 	subdevice 1 - 8 channels of 16-bit AO
 	subdevice 2 - first 24 channels of the 48 channel of DIO
 			(with edge-triggered interrupt support)
 	subdevice 3 - last 24 channels of the 48 channel DIO
 			(no interrupt support for this bank of channels)
  Some notes:
  Synchronous reads and writes are the only things implemented for analog
  input and output. The hardware itself can do streaming acquisition, etc.
  Asynchronous IO for the DIO subdevices is implemented, however! They
  are basically edge-triggered interrupts for any configuration of the
  channels in subdevice 2.
  Also note that this interrupt support is untested.
  A few words about edge-detection IRQ support (commands on DIO):
  To use edge-detection IRQ support for the DIO subdevice, pass the IRQ
  of the board to the comedi_config command. The board IRQ is not jumpered
  but rather configured through software, so any IRQ from 1-15 is OK.
  Due to the genericity of the comedi API, you need to create a special
  comedi_command in order to use edge-triggered interrupts for DIO.
  Use comedi_commands with TRIG_NOW.  Your callback will be called each
  time an edge is detected on the specified DIO line(s), and the data
  values will be two sample_t's, which should be concatenated to form
  one 32-bit unsigned int. This value is the mask of channels that had
  edges detected from your channel list. Note that the bits positions
  in the mask correspond to positions in your chanlist when you
  specified the command and not channel id's!
  To set the polarity of the edge-detection interrupts pass a nonzero value
  for either CR_RANGE or CR_AREF for edge-up polarity, or a zero
  value for both CR_RANGE and CR_AREF if you want edge-down polarity.
  Configuration Options:
    [0] - IO port base address
    [1] - IRQ (optional -- for edge-detect interrupt support only,
 		leave out if you don't need this feature)
  Register IO map
  WinSystems WS16C48
  Offset    Page 0       Page 1       Page 2       Page 3
  ------  -----------  -----------  -----------  -----------
   0x10   Port 0 IO   Port 0 IO   Port 0 IO   Port 0 IO
   0x11   Port 1 IO   Port 1 IO   Port 1 IO   Port 1 IO
   0x12   Port 2 IO   Port 2 IO   Port 2 IO   Port 2 IO
   0x13   Port 3 IO   Port 3 IO   Port 3 IO   Port 3 IO
   0x14   Port 4 IO   Port 4 IO   Port 4 IO   Port 4 IO
   0x15   Port 5 IO   Port 5 IO   Port 5 IO   Port 5 IO
   0x16   INT_PENDING  INT_PENDING  INT_PENDING  INT_PENDING
   0x17    PageLock    PageLock    PageLock    PageLock
   0x18       NA         POL_0       ENAB_0       INT_ID0
   0x19       NA         POL_1       ENAB_1       INT_ID1
   0x1a       NA         POL_2       ENAB_2       INT_ID2
 protects the page registers 
 protects the member variables 
 Port registers are valid for any page 
 Port registers are valid for any page 
  Each channel can be individually programmed for input or output.
  Writing a '0' to a channel causes the corresponding output pin
  to go to a high-z state (pulled high by an external 10K resistor).
  This allows it to be used as an input. When used in the input mode,
  a read reflects the inverted state of the IO pin, such that a
  high on the pin will read as a '0' in the register. Writing a '1'
  to a bit position causes the pin to sink current (up to 12mA),
  effectively pulling it low.
 subdevice 2 uses ports 0-2, subdevice 3 uses ports 3-5 
		
		  Outputs are inverted, invert the state and
		  update the channels.
		 
		  The s->io_bits mask makes sure the input channels
		  are '0' so that the outputs pins stay in a high
		  z-state.
 get inverted state of the channels from the port 
 return the true state of the channels 
 subdevice 2 uses ports 0-2, subdevice 3 uses ports 3-5 
 Clear all the DIO port bits 
 Clear all the paged registers 
 devpriv->spinlock is already locked 
 disable all dio interrupts 
 are there any interrupts pending 
 get, and clear, the pending interrupts 
 devpriv->spinlock is already locked 
 set polarity and enable interrupts 
  'do_cmd' function for an 'INTERRUPT' subdevice.
 Set up start of acquisition. 
 TRIG_NOW 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_NONE 
 step 4: fix up any arguments 
 if (err) return 4; 
	
	  The PCM-MIO uses two Linear Tech LTC1859CG 8-channel AD converters.
	  The devices use a full duplex serial interface which transmits and
	  receives data simultaneously. An 8-bit command is shifted into the
	  ADC interface to configure it for the next conversion. At the same
	  time, the data from the previous conversion is shifted out of the
	  device. Consequently, the conversion result is delayed by one
	  conversion from the command word.
	 
	  Setup the cmd for the conversions then do a dummy conversion to
	  flush the junk data. Then do each conversion requested by the
	  comedi_insn. Note that the last conversion will leave junk data
	  in ADC which will get flushed on the next comedi_insn.
 bipolar data is two's complement 
	
	  The PCM-MIO has two Linear Tech LTC2704 DAC devices. Each device
	  is a 4-channel converter with software-selectable output range.
 set the range for the channel 
 write the data to the channel 
 configure the interrupt routing on the board 
 Analog Input subdevice 
 initialize the resource enable register by clearing it 
 Analog Output subdevice 
 initialize the resource enable register by clearing it 
 Digital IO subdevice with interrupt support 
 Digital IO subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  Driver for Amplicon PCI263 relay board.
  Copyright (C) 2002 MEV Ltd. <https:www.mev.co.uk>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: amplc_pci263
  Description: Amplicon PCI263
  Author: Ian Abbott <abbotti@mev.co.uk>
  Devices: [Amplicon] PCI263 (amplc_pci263)
  Updated: Fri, 12 Apr 2013 15:19:36 +0100
  Status: works
  Configuration options: not applicable, uses PCI auto config
  The board appears as one subdevice, with 16 digital outputs, each
  connected to a reed-relay. Relay contacts are closed when output is 1.
  The state of the outputs can be read.
 PCI263 registers 
 Digital Output subdevice 
 read initial relay state 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriversdas08.c
  comedi module for common DAS08 support (used by ISAPCIPCMCIA drivers)
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Copyright (C) 2001,2002,2003 Frank Mori Hess <fmhess@users.sourceforge.net>
  Copyright (C) 2004 Salvador E. Tropea <set@users.sf.net> <set@ieee.org>
  Data format of DAS08_AI_LSB_REG and DAS08_AI_MSB_REG depends on
  'ai_encoding' member of board structure:
  das08_encode12     : DATA[11..4] = MSB[7..0], DATA[3..0] = LSB[7..4].
  das08_pcm_encode12 : DATA[11..8] = MSB[3..0], DATA[7..9] = LSB[7..0].
  das08_encode16     : SIGN = MSB[7], MAGNITUDE[14..8] = MSB[6..0],
                       MAGNITUDE[7..0] = LSB[7..0].
                       SIGN==0 for negative input, SIGN==1 for positive input.
                       Note: when read a second time after conversion
                             complete, MSB[7] is an "over-range" bit.
 (R) AI least significant bits 
 (R) AI most significant bits 
 (W) AI software trigger 
 (R) status 
 AI conversion in progress 
  The IRQ status bit is set to 1 by a rising edge on the external interrupt
  input (which may be jumpered to the pacer output).  It is cleared by
  setting the INTE control bit to 0.  Not present on "JR" boards.
 latched interrupt input 
 digital inputs (not "JR" boards) 
 (W) control 
  Note: The AI multiplexor channel can also be read from status register using
  the same mask.
 multiplexor channel mask 
 mux channel 
 interrupt enable (not "JR" boards) 
 digital outputs mask (not "JR") 
 digital outputs (not "JR" boards) 
  (RW) programmable AI gain ("PGx" and "AOx" boards):
  + bits 3..0 (RW) showset the gain for the current AI mux channel
  + bits 6..4 (R) show the current AI mux channel
  + bit 7 (R) not unused
 (R) digital inputs ("JR" boards) 
 (W) digital outputs ("JR" boards) 
 (W) analog output l.s.b. registers for 2 channels ("JR" boards) 
 (W) analog output m.s.b. registers for 2 channels ("JR" boards) 
  (R) update analog outputs ("JR" boards set for simultaneous output)
      (same register as digital inputs)
 (W) analog output l.s.b. registers for 2 channels ("AOx" boards) 
 (W) analog output m.s.b. registers for 2 channels ("AOx" boards) 
  (R) update analog outputs ("AOx" boards set for simultaneous output)
      (any of the analog output registers could be used for this)
 gainlist same as _pgx_ below 
 clear crap 
 set multiplexer 
 lock to prevent race with digital output 
 set gainrange 
 clear over-range bits for 16-bit boards 
 trigger conversion 
			
			  "JR" 16-bit boards are sign-magnitude.
			 
			  XXX The manual seems to imply that 0 is full-scale
			  negative and 65535 is full-scale positive, but the
			  original COMEDI patch to add support for the
			  DAS08JR16 and DAS08JR16-AO boards have it
			  encoded as sign-magnitude.  Assume the original
			  COMEDI code is correct for now.
			
			  MSB bit 7 is 0 for negative, 1 for positive voltage.
			  COMEDI 16-bit bipolar data value for 0V is 0x8000.
 prevent race with setting of analog input mux 
 load DACs 
 load DACs 
 ai 
		
		  XXX some boards actually have differential
		  inputs instead of single ended.
		  The driver does nothing with arefs though,
		  so it's no big deal.
 ao 
 initialize all channels to 0V 
 di 
 do 
 8255 
 Counter subdevice (8254) 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  addi_apci_1516.c
  Copyright (C) 2004,2005  ADDI-DATA GmbH for the source code of this module.
  Project manager: Eric Stolz
 	ADDI-DATA GmbH
 	Dieselstrasse 3
 	D-77833 Ottersweier
 	Tel: +19(0)72239493-0
 	Fax: +49(0)72239493-92
 	http:www.addi-data.com
 	info@addi-data.com
  PCI bar 1 IO Register map - Digital inputoutput
  PCI bar 2 IO Register map - Watchdog (APCI-1516 and APCI-2016)
 Initialize the digital input subdevice 
 Initialize the digital output subdevice 
 Initialize the watchdog subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  COMEDI driver for generic PCI based 8255 digital io boards
  Copyright (C) 2012 H Hartley Sweeten <hsweeten@visionengravers.com>
  Based on the tested adl_pci7296 driver written by:
 	Jon Grierson <jd@renko.co.uk>
  and the experimental cb_pcidio driver written by:
 	Yoshiya Matsuzaka
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: 8255_pci
  Description: Generic PCI based 8255 Digital IO boards
  Devices: [ADLink] PCI-7224 (adl_pci-7224), PCI-7248 (adl_pci-7248),
    PCI-7296 (adl_pci-7296),
    [Measurement Computing] PCI-DIO24 (cb_pci-dio24),
    PCI-DIO24H (cb_pci-dio24h), PCI-DIO48H (cb_pci-dio48h),
    PCI-DIO96H (cb_pci-dio96h),
    [National Instruments] PCI-DIO-96 (ni_pci-dio-96),
    PCI-DIO-96B (ni_pci-dio-96b), PXI-6508 (ni_pxi-6508),
    PCI-6503 (ni_pci-6503), PCI-6503B (ni_pci-6503b),
    PCI-6503X (ni_pci-6503x), PXI-6503 (ni_pxi-6503)
  Author: H Hartley Sweeten <hsweeten@visionengravers.com>
  Updated: Wed, 12 Sep 2012 11:52:01 -0700
  Status: untested
  These boards have one or more 8255 digital IO chips, each of which
  is supported as a separate 24-channel DIO subdevice.
  Boards with 24 DIO channels (1 DIO subdevice):
    PCI-7224, PCI-DIO24, PCI-DIO24H, PCI-6503, PCI-6503B, PCI-6503X,
    PXI-6503
  Boards with 48 DIO channels (2 DIO subdevices):
    PCI-7248, PCI-DIO48H
  Boards with 96 DIO channels (4 DIO subdevices):
    PCI-7296, PCI-DIO96H, PCI-DIO-96, PCI-DIO-96B, PXI-6508
  Some of these boards also have an 8254 programmable timercounter
  chip.  This chip is not currently supported by this driver.
  Interrupt support for these boards is also not currently supported.
  Configuration Options: not applicable, uses PCI auto config.
 ripped from mite.h and mite_setup2() to avoid mite dependency 
 IO Device Window Base Size Register 
 window enable 
 ioremap the MITE registers (BAR 0) temporarily 
 set data window to main registers (BAR 1) 
 finished with MITE registers 
	
	  One, two, or four subdevices are setup by this driver depending
	  on the number of channels provided by the board. Each subdevice
	  has 24 channels supported by the 8255 module.
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0
  pcm3724.c
  Comedi driver for Advantech PCM-3724 Digital IO board
  Drew Csillag <drew_csillag@yahoo.com>
  Driver: pcm3724
  Description: Advantech PCM-3724
  Devices: [Advantech] PCM-3724 (pcm3724)
  Author: Drew Csillag <drew_csillag@yahoo.com>
  Status: tested
  This is driver for digital IO boards PCM-3724 with 48 DIO.
  It needs 8255.o for operations and only immediate mode is supported.
  See the source for configuration details.
  Copypastedhacked from pcm724.c
  Configuration Options:
    [0] - IO port base address
  Register IO Map
  This board has two standard 8255 devices that provide six 8-bit DIO ports
  (48 channels total). Six 74HCT245 chips (one for each port) buffer the
  IO lines to increase driving capability. Because the 74HCT245 is a
  bidirectional, tri-state line buffer, two additional IO ports are used
  to control the direction of data and the enable of each port.
 used to track configured dios 
 1 in io_bits indicates output 
 1 in io_bits indicates output, 1 in config indicates input 
 overriding the 8255 insn config 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
 comedidriversamplc_dio200_pci.c
  Driver for Amplicon PCI215, PCI272, PCIe215, PCIe236, PCIe296.
  Copyright (C) 2005-2013 MEV Ltd. <https:www.mev.co.uk>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1998,2000 David A. Schleef <ds@schleef.org>
  Driver: amplc_dio200_pci
  Description: Amplicon 200 Series PCI Digital IO
  Author: Ian Abbott <abbotti@mev.co.uk>
  Devices: [Amplicon] PCI215 (amplc_dio200_pci), PCIe215, PCIe236,
    PCI272, PCIe296
  Updated: Mon, 18 Mar 2013 15:03:50 +0000
  Status: works
  Configuration options:
    none
  Manual configuration of PCI(e) cards is not supported; they are configured
  automatically.
  SUBDEVICES
                      PCI215         PCIe215        PCIe236
                   -------------  -------------  -------------
    Subdevices           5              8              8
     0                 PPI-X          PPI-X          PPI-X
     1                 PPI-Y          UNUSED         UNUSED
     2                 CTR-Z1         PPI-Y          UNUSED
     3                 CTR-Z2         UNUSED         UNUSED
     4               INTERRUPT        CTR-Z1         CTR-Z1
     5                                CTR-Z2         CTR-Z2
     6                                TIMER          TIMER
     7                              INTERRUPT      INTERRUPT
                      PCI272         PCIe296
                   -------------  -------------
    Subdevices           4              8
     0                 PPI-X          PPI-X1
     1                 PPI-Y          PPI-X2
     2                 PPI-Z          PPI-Y1
     3               INTERRUPT        PPI-Y2
     4                                CTR-Z1
     5                                CTR-Z2
     6                                TIMER
     7                              INTERRUPT
  Each PPI is a 8255 chip providing 24 DIO channels.  The DIO channels
  are configurable as inputs or outputs in four groups:
    Port A  - channels  0 to  7
    Port B  - channels  8 to 15
    Port CL - channels 16 to 19
    Port CH - channels 20 to 23
  Only mode 0 of the 8255 chips is supported.
  Each CTR is a 8254 chip providing 3 16-bit counter channels.  Each
  channel is configured individually with INSN_CONFIG instructions.  The
  specific type of configuration instruction is specified in data[0].
  Some configuration instructions expect an additional parameter in
  data[1]; others return a value in data[1].  The following configuration
  instructions are supported:
    INSN_CONFIG_SET_COUNTER_MODE.  Sets the counter channel's mode and
      BCDbinary setting specified in data[1].
    INSN_CONFIG_8254_READ_STATUS.  Reads the status register value for the
      counter channel into data[1].
    INSN_CONFIG_SET_CLOCK_SRC.  Sets the counter channel's clock source as
      specified in data[1] (this is a hardware-specific value).  Not
      supported on PC214E.  For the other boards, valid clock sources are
      0 to 7 as follows:
        0.  CLK n, the counter channel's dedicated CLK input from the SK1
          connector.  (N.B. for other values, the counter channel's CLKn
          pin on the SK1 connector is an output!)
        1.  Internal 10 MHz clock.
        2.  Internal 1 MHz clock.
        3.  Internal 100 kHz clock.
        4.  Internal 10 kHz clock.
        5.  Internal 1 kHz clock.
        6.  OUT n-1, the output of counter channel n-1 (see note 1 below).
        7.  Ext Clock, the counter chip's dedicated Ext Clock input from
          the SK1 connector.  This pin is shared by all three counter
          channels on the chip.
      For the PCIe boards, clock sources in the range 0 to 31 are allowed
      and the following additional clock sources are defined:
        8.  HIGH logic level.
        9.  LOW logic level.
       10.  "Pattern present" signal.
       11.  Internal 20 MHz clock.
    INSN_CONFIG_GET_CLOCK_SRC.  Returns the counter channel's current
      clock source in data[1].  For internal clock sources, data[2] is set
      to the period in ns.
    INSN_CONFIG_SET_GATE_SRC.  Sets the counter channel's gate source as
      specified in data[2] (this is a hardware-specific value).  Not
      supported on PC214E.  For the other boards, valid gate sources are 0
      to 7 as follows:
        0.  VCC (internal +5V d.c.), i.e. gate permanently enabled.
        1.  GND (internal 0V d.c.), i.e. gate permanently disabled.
        2.  GAT n, the counter channel's dedicated GAT input from the SK1
          connector.  (N.B. for other values, the counter channel's GATn
          pin on the SK1 connector is an output!)
        3.  OUT n-2, the inverted output of counter channel n-2 (see note
          2 below).
        4.  Reserved.
        5.  Reserved.
        6.  Reserved.
        7.  Reserved.
      For the PCIe boards, gate sources in the range 0 to 31 are allowed;
      the following additional clock sources and clock sources 6 and 7 are
      (re)defined:
        6.  GAT n, negated version of the counter channel's dedicated
          GAT input (negated version of gate source 2).
        7.  OUT n-2, the non-inverted output of counter channel n-2
          (negated version of gate source 3).
        8.  "Pattern present" signal, HIGH while pattern present.
        9.  "Pattern occurred" latched signal, latches HIGH when pattern
          occurs.
       10.  "Pattern gone away" latched signal, latches LOW when pattern
          goes away after it occurred.
       11.  Negated "pattern present" signal, LOW while pattern present
          (negated version of gate source 8).
       12.  Negated "pattern occurred" latched signal, latches LOW when
          pattern occurs (negated version of gate source 9).
       13.  Negated "pattern gone away" latched signal, latches LOW when
          pattern goes away after it occurred (negated version of gate
          source 10).
    INSN_CONFIG_GET_GATE_SRC.  Returns the counter channel's current gate
      source in data[2].
  Clock and gate interconnection notes:
    1.  Clock source OUT n-1 is the output of the preceding channel on the
    same counter subdevice if n > 0, or the output of channel 2 on the
    preceding counter subdevice (see note 3) if n = 0.
    2.  Gate source OUT n-2 is the inverted output of channel 0 on the
    same counter subdevice if n = 2, or the inverted output of channel n+1
    on the preceding counter subdevice (see note 3) if n < 2.
    3.  The counter subdevices are connected in a ring, so the highest
    counter subdevice precedes the lowest.
  The 'TIMER' subdevice is a free-running 32-bit timer subdevice.
  The 'INTERRUPT' subdevice pretends to be a digital input subdevice.  The
  digital inputs come from the interrupt status register.  The number of
  channels matches the number of interrupt sources.  The PC214E does not
  have an interrupt status register; see notes on 'INTERRUPT SOURCES'
  below.
  INTERRUPT SOURCES
                      PCI215         PCIe215        PCIe236
                   -------------  -------------  -------------
    Sources              6              6              6
     0               PPI-X-C0       PPI-X-C0       PPI-X-C0
     1               PPI-X-C3       PPI-X-C3       PPI-X-C3
     2               PPI-Y-C0       PPI-Y-C0        unused
     3               PPI-Y-C3       PPI-Y-C3        unused
     4              CTR-Z1-OUT1    CTR-Z1-OUT1    CTR-Z1-OUT1
     5              CTR-Z2-OUT1    CTR-Z2-OUT1    CTR-Z2-OUT1
                      PCI272         PCIe296
                   -------------  -------------
    Sources              6              6
     0               PPI-X-C0       PPI-X1-C0
     1               PPI-X-C3       PPI-X1-C3
     2               PPI-Y-C0       PPI-Y1-C0
     3               PPI-Y-C3       PPI-Y1-C3
     4               PPI-Z-C0      CTR-Z1-OUT1
     5               PPI-Z-C3      CTR-Z2-OUT1
  When an interrupt source is enabled in the interrupt source enable
  register, a rising edge on the source signal latches the corresponding
  bit to 1 in the interrupt status register.
  When the interrupt status register value as a whole (actually, just the
  6 least significant bits) goes from zero to non-zero, the board will
  generate an interrupt.  The interrupt will remain asserted until the
  interrupt status register is cleared to zero.  To clear a bit to zero in
  the interrupt status register, the corresponding interrupt source must
  be disabled in the interrupt source enable register (there is no
  separate interrupt clear register).
  COMMANDS
  The driver supports a read streaming acquisition command on the
  'INTERRUPT' subdevice.  The channel list selects the interrupt sources
  to be enabled.  All channels will be sampled together (convert_src ==
  TRIG_NOW).  The scan begins a short time after the hardware interrupt
  occurs, subject to interrupt latencies (scan_begin_src == TRIG_EXT,
  scan_begin_arg == 0).  The value read from the interrupt status register
  is packed into a short value, one bit per requested channel, in the
  order they appear in the channel list.
  Board descriptions.
  This function does some special set-up for the PCIe boards
  PCIe215, PCIe236, PCIe296.
	
	  The board uses Altera Cyclone IV with PCI-Express hard IP.
	  The FPGA configuration has the PCI-Express Avalon-MM Bridge
	  Control registers in PCI BAR 0, offset 0, and the length of
	  these registers is 0x4000.
	 
	  We need to write 0x80 to the "Avalon-MM to PCI-Express Interrupt
	  Enable" register at offset 0x50 to allow generation of PCIe
	  interrupts when RXmlrq_i is asserted in the SOPC Builder system.
 Enable "enhanced" features of board. 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  comedidriversdt2815.c
  Hardware driver for Data Translation DT2815
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1999 Anders Blomdell <anders.blomdell@control.lth.se>
  Driver: dt2815
  Description: Data Translation DT2815
  Author: ds
  Status: mostly complete, untested
  Devices: [Data Translation] DT2815 (dt2815)
  I'm not sure anyone has ever tested this board.  If you have information
  contrary, please update.
  Configuration options:
  [0] - IO port base base address
  [1] - IRQ (unused)
  [2] - Voltage unipolarbipolar configuration
 	0 == unipolar 5V  (0V -- +5V)
 	1 == bipolar 5V  (-5V -- +5V)
  [3] - Current offset configuration
 	0 == disabled  (0mA -- +32mAV)
 	1 == enabled  (+4mA -- +20mAV)
  [4] - Firmware program configuration
 	0 == program 1 (see manual table 5-4)
 	1 == program 2 (see manual table 5-4)
 	2 == program 3 (see manual table 5-4)
 	3 == program 4 (see manual table 5-4)
  [5] - Analog output 0 range configuration
 	0 == voltage
 	1 == current
  [6] - Analog output 1 range configuration (same options)
  [7] - Analog output 2 range configuration (same options)
  [8] - Analog output 3 range configuration (same options)
  [9] - Analog output 4 range configuration (same options)
  [10] - Analog output 5 range configuration (same options)
  [11] - Analog output 6 range configuration (same options)
  [12] - Analog output 7 range configuration (same options)
 FIXME: lo bit 0 chooses voltage output or current output 
  options[0]   Board base address
  options[1]   IRQ (not applicable)
  options[2]   Voltage unipolarbipolar configuration
 		0 == unipolar 5V  (0V -- +5V)
 		1 == bipolar 5V  (-5V -- +5V)
  options[3]   Current offset configuration
 		0 == disabled  (0mA -- +32mAV)
 		1 == enabled  (+4mA -- +20mAV)
  options[4]   Firmware program configuration
 		0 == program 1 (see manual table 5-4)
 		1 == program 2 (see manual table 5-4)
 		2 == program 3 (see manual table 5-4)
 		3 == program 4 (see manual table 5-4)
  options[5]   Analog output 0 range configuration
 		0 == voltage
 		1 == current
  options[6]   Analog output 1 range configuration
  ...
  options[12]   Analog output 7 range configuration
 		0 == voltage
 		1 == current
 ao subdevice 
 Init the 2815 
 This is incredibly slow (approx 20 ms) 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  adv_pci1723.c
  Comedi driver for the Advantech PCI-1723 card.
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: adv_pci1723
  Description: Advantech PCI-1723
  Author: yonggang <rsmgnu@gmail.com>, Ian Abbott <abbotti@mev.co.uk>
  Devices: [Advantech] PCI-1723 (adv_pci1723)
  Updated: Mon, 14 Apr 2008 15:12:56 +0100
  Status: works
  Configuration Options: not applicable, uses comedi PCI auto config
  Subdevice 0 is 8-channel AO, 16-bit, range +- 10 V.
  Subdevice 1 is 16-channel DIO.  The channels are configurable as
  input or output in 2 groups (0 to 7, 8 to 15). Configuring any
  channel implicitly configures all channels in the same group.
  TODO:
  1. Add the two milliamp ranges to the AO subdevice (0 to 20 mA,
     4 to 20 mA).
  2. Read the initial ranges and values of the AO subdevice at
     start-up instead of reinitializing them.
  3. Implement calibration.
  PCI Bar 2 IO Register map (dev->iobase)
 assume output 
 low byte input 
 high byte input 
 synchronously reset all analog outputs to 0V, +-10V range 
 disable syncronous control 
 get initial DIO direction and state 
 low byte output 
 high byte output 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0
  comedidriversdt2801.c
  Device Driver for DataTranslation DT2801
  Driver: dt2801
  Description: Data Translation DT2801 series and DT01-EZ
  Author: ds
  Status: works
  Devices: [Data Translation] DT2801 (dt2801), DT2801-A, DT28015716A,
  DT2805, DT28055716A, DT2808, DT2818, DT2809, DT01-EZ
  This driver can autoprobe the type of board.
  Configuration options:
  [0] - IO port base address
  [1] - unused
  [2] - AD reference 0=differential, 1=single-ended
  [3] - AD range
 	  0 = [-10, 10]
 	  1 = [0,10]
  [4] - DA 0 range
 	  0 = [-10, 10]
 	  1 = [-5,5]
 	  2 = [-2.5,2.5]
 	  3 = [0,10]
 	  4 = [0,5]
  [5] - DA 1 range (same choices)
 Hardware Configuration 
 ====================== 
 define's 
 ====================== 
 Commands 
  Command modifiers (only used with readwrite), EXTTRIG can be
  used with some other commands.
 Bits in status register 
 registers 
 ignore 'defined but not used' warning 
 ignore 'defined but not used' warning 
  Typeid's for the different boards of the DT2801-series
  (taken from the test-software, that comes with the board)
  These are the low-level routines:
  writecommand: write a command to the board
  writedata: write data byte
  readdata: read data byte
  Only checks DataOutReady-flag, not the Ready-flag as it is done
   in the examples of the manual. I don't see why this should be
   necessary.
 pull random data from data port 
 dt2801_writecmd(dev,DT_C_STOP); 
 dt2801_wait_for_ready(dev); 
 dt2801_readdata(dev,&board_code); 
 dt2801_writecmd(dev,DT_C_RESET); 
  options:
 	[0] - io base
 	[1] - unused
 	[2] - ad 0=differential, 1=single-ended
 	[3] - ad range 0=[-10,10], 1=[0,10]
 	[4] - dac0 range 0=[-10,10], 1=[-5,5], 2=[-2.5,2.5] 3=[0,10], 4=[0,5]
 	[5] - dac1 range 0=[-10,10], 1=[-5,5], 2=[-2.5,2.5] 3=[0,10], 4=[0,5]
 do some checking 
 heh.  if it didn't work, try it again. 
 ai subdevice 
 ao subdevice 
 1st digital subdevice 
 2nd digital subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  COMEDI driver for the ADLINK PCI-723x743x series boards.
  Copyright (C) 2012 H Hartley Sweeten <hsweeten@visionengravers.com>
  Based on the adl_pci7230 driver written by:
 	David Fernandez <dfcastelao@gmail.com>
  and the adl_pci7432 driver written by:
 	Michel Lachaine <mike@mikelachaine.ca>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: adl_pci7x3x
  Description: 3264-Channel Isolated Digital IO Boards
  Devices: [ADLink] PCI-7230 (adl_pci7230), PCI-7233 (adl_pci7233),
    PCI-7234 (adl_pci7234), PCI-7432 (adl_pci7432), PCI-7433 (adl_pci7433),
    PCI-7434 (adl_pci7434)
  Author: H Hartley Sweeten <hsweeten@visionengravers.com>
  Updated: Fri, 20 Nov 2020 14:49:36 +0000
  Status: works (tested on PCI-7230)
  One or two subdevices are setup by this driver depending on
  the number of digital inputs andor outputs provided by the
  board. Each subdevice has a maximum of 32 channels.
 	PCI-7230 - 4 subdevices: 0 - 16 input, 1 - 16 output,
 	                         2 - IRQ_IDI0, 3 - IRQ_IDI1
 	PCI-7233 - 1 subdevice: 0 - 32 input
 	PCI-7234 - 1 subdevice: 0 - 32 output
 	PCI-7432 - 2 subdevices: 0 - 32 input, 1 - 32 output
 	PCI-7433 - 2 subdevices: 0 - 32 input, 1 - 32 input
 	PCI-7434 - 2 subdevices: 0 - 32 output, 1 - 32 output
  The PCI-7230, PCI-7432 and PCI-7433 boards also support external
  interrupt signals on digital input channels 0 and 1. The PCI-7233
  has dual-interrupt sources for change-of-state (COS) on any 16
  digital input channels of LSB and for COS on any 16 digital input
  lines of MSB.
  Currently, this driver only supports interrupts for PCI-7230.
  Configuration Options: not applicable, uses comedi PCI auto config
  Register IO map (32-bit access only)
 in the DigIO Port area 
 in the DigIO Port area 
 IDI, IDO, IRQ_IDI0, IRQ_IDI1 
 spin-lock for cmd_running 
 Ignore interrupt before device fully attached. 
 Might not even have allocated subdevices yet! 
 Check if we are source of interrupt 
 clear all current interrupt flags 
 Fixme: Reset all 2 Int Flags 
 SubDev 2, 3 = Isolated DigIn , on "SCSI2" jack!
 0x0005 LINTi1 is Enabled && IDI0 is 1 
 0x0028 LINTi2 is Enabled && IDI1 is 1 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 Step 4: fix up any arguments 
 Step 5: check channel list if it exists 
 enable LINTi1 == IDI sdi[0] Ch 0 IRQ ActHigh 
 enable LINTi2 == IDI sdi[0] Ch 1 IRQ ActHigh 
 disable Interrupts 
 same as _di_insn_bits because the IRQ-pins are the DI-ports  
			
			  It seems the PCI-7230 needs the 16-bit DO state
			  to be shifted left by 16 bits before being written
			  to the 32-bit register.  Set the value in both
			  halves of the register to be sure.
 disable Interrupts 
 Disable PCI + LINTi2 + LINTi1 
 discard all evtl. old IRQs 
 0x52 PCI + IDI Ch 1 Ch 0 IRQ Off ActHigh 
 Isolated digital inputs 0 to 1531 
 Isolated digital inputs 32 to 63 
 Isolated digital outputs 0 to 1531 
 Isolated digital outputs 32 to 63 
 Isolated digital inputs 0 or 1 
 SPDX-License-Identifier: GPL-2.0+
  comedidriversdyna_pci10xx.c
  Copyright (C) 2011 Prashant Shah, pshah.mumbai@gmail.com
  Driver: dyna_pci10xx
  Description: Dynalog India PCI DAQ Cards, http:www.dynalogindia.com
  Devices: [Dynalog] PCI-1050 (dyna_pci1050)
  Author: Prashant Shah <pshah.mumbai@gmail.com>
  Status: Stable
  Developed at Automation Labs, Chemical Dept., IIT Bombay, India.
  Prof. Kannan Moudgalya <kannan@iitb.ac.in>
  http:www.iitb.ac.in
  Notes :
  - Dynalog India Pvt. Ltd. does not have a registered PCI Vendor ID and
    they are using the PLX Technlogies Vendor ID since that is the PCI Chip
    used in the card.
  - Dynalog India Pvt. Ltd. has provided the internal register specification
    for their cards in their manuals.
 get the channel number and range 
 convert n samples 
 trigger conversion 
 read data 
 mask the first 4 bits - EOC bits 
 return the number of samples readwritten 
 analog output callback 
 trigger conversion and write data 
 digital input bit interface 
 on return the data[0] contains output and data[1] contains input 
 analog input 
 analog output 
 digital input 
 digital output 
 SPDX-License-Identifier: GPL-2.0+
  pcl711.c
  Comedi driver for PC-LabCard PCL-711 and AdSys ACL-8112 and compatibles
  Copyright (C) 1998 David A. Schleef <ds@schleef.org>
 		      Janne Jalkanen <jalkanen@cs.hut.fi>
 		      Eric Bunn <ebu@cs.hut.fi>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1998 David A. Schleef <ds@schleef.org>
  Driver: pcl711
  Description: Advantech PCL-711 and 711b, ADLink ACL-8112
  Devices: [Advantech] PCL-711 (pcl711), PCL-711B (pcl711b),
    [ADLink] ACL-8112HG (acl8112hg), ACL-8112DG (acl8112dg)
  Author: David A. Schleef <ds@schleef.org>
 	   Janne Jalkanen <jalkanen@cs.hut.fi>
 	   Eric Bunn <ebu@cs.hut.fi>
  Updated:
  Status: mostly complete
  Configuration Options:
    [0] - IO port base
    [1] - IRQ, optional
  IO port register map
 any value will work 
 any value will work 
	
	  The pcl711b board uses bits in the mode register to select the
	  interrupt. The other boards supported by this driver all use
	  jumpers on the board.
	 
	  Enables the interrupt when needed on the pcl711b board. These
	  bits do nothing on the other boards.
 Select the correct MPC508A chip 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 TRIG_NONE 
 step 4 
 Analog Input subdevice 
 Analog Output subdevice 
 Digital Input subdevice 
 Digital Output subdevice 
 clear DAC 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  addi_apci_1564.c
  Copyright (C) 2004,2005  ADDI-DATA GmbH for the source code of this module.
 	ADDI-DATA GmbH
 	Dieselstrasse 3
 	D-77833 Ottersweier
 	Tel: +19(0)72239493-0
 	Fax: +49(0)72239493-92
 	http:www.addi-data.com
 	info@addi-data.com
  Driver: addi_apci_1564
  Description: ADDI-DATA APCI-1564 Digital IO board
  Devices: [ADDI-DATA] APCI-1564 (addi_apci_1564)
  Author: H Hartley Sweeten <hsweeten@visionengravers.com>
  Updated: Thu, 02 Jun 2016 13:12:46 -0700
  Status: untested
  Configuration Options: not applicable, uses comedi PCI auto config
  This board has the following features:
    - 32 optically isolated digital inputs (24V), 16 of which can
      generate change-of-state (COS) interrupts (channels 4 to 19)
    - 32 optically isolated digital outputs (10V to 36V)
    - 1 8-bit watchdog for resetting the outputs
    - 1 12-bit timer
    - 3 32-bit counters
    - 2 diagnostic inputs
  The COS, timer, and counter subdevices all use the dev->read_subdev to
  return the interrupt status. The sample data is updated and returned when
  any of these subdevices generate an interrupt. The sample data format is:
     Bit   Description
    -----  ------------------------------------------
     31    COS interrupt
     30    timer interrupt
     29    counter 2 interrupt
     28    counter 1 interrupt
     27    counter 0 interrupt
    26:20  not used
    19:4   COS digital input state (channels 19 to 4)
     3:0   not used
  The COS interrupts must be configured using an INSN_CONFIG_DIGITAL_TRIG
  instruction before they can be enabled by an async command. The COS
  interrupts will stay active until canceled.
  The timer subdevice does not use an async command. All control is handled
  by the (insn_config).
  FIXME: The format of the ADDI_TCW_TIMEBASE_REG is not descibed in the
  datasheet I have. The INSN_CONFIG_SET_CLOCK_SRC currently just writes
  the raw data[1] to this register along with the raw data[2] value to the
  ADDI_TCW_RELOAD_REG. If anyone tests this and can determine the actual
  timebasereload operation please let me know.
  The counter subdevice also does not use an async command. All control is
  handled by the (insn_config).
  FIXME: The operation of the counters is not really described in the
  datasheet I have. The (insn_config) needs more work.
  PCI BAR 0
  PLD Revision 1.0 IO Mapping
    0x00         93C76 EEPROM
    0x04 - 0x18  Timer 12-Bit
  PLD Revision 2.x IO Mapping
    0x00         93C76 EEPROM
    0x04 - 0x14  Digital Input
    0x18 - 0x25  Digital Output
    0x28 - 0x44  Watchdog 8-Bit
    0x48 - 0x64  Timer 12-Bit
  PCI BAR 1
  PLD Revision 1.0 IO Mapping
    0x00 - 0x10  Digital Input
    0x14 - 0x20  Digital Output
    0x24 - 0x3c  Watchdog 8-Bit
  PLD Revision 2.x IO Mapping
    0x00         Counter_0
    0x20         Counter_1
    0x30         Counter_3
  dev->iobase Register Map
    PLD Revision 1.0 - PCI BAR 1 + 0x00
    PLD Revision 2.x - PCI BAR 0 + 0x04
 chans [19:4] 
 1=AND, 0=OR 
  devpriv->timer Register Map (see addi_tcw.h for registerbit defines)
    PLD Revision 1.0 - PCI BAR 0 + 0x04
    PLD Revision 2.x - PCI BAR 0 + 0x48
  devpriv->counters Register Map (see addi_tcw.h for registerbit defines)
    PLD Revision 2.x - PCI BAR 1 + 0x00
  The dev->read_subdev is used to return the interrupt events along with
  the state of the interrupt capable inputs.
 counter 0-2 
 all but [19:4] 
 base address of EEPROM register 
 base address of 12-bit timer 
 base address of 32-bit counters 
 rising-edgehigh level channels 
 falling-edgelow level channels 
 interrupt mode OR (edge) . AND (level) 
 Disable the input interrupts and reset status register 
 Reset the output channels and disable interrupts 
 Reset the watchdog registers 
 Reset the timer registers 
 Reset the counter registers 
 get the COS interrupt state and set the event flag 
 clear the interrupt 
 clear the interrupt 
 clear the interrupt 
  Change-Of-State (COS) interrupt configuration
  Channels 4 to 19 are interruptible. These channels can be configured
  to generate interrupts based on ANDOR logic for the desired channels.
 	OR logic
 		- reacts to rising or falling edges
 		- interrupt is generated when any enabled channel
 		  meet the desired interrupt condition
 	AND logic
 		- reacts to changes in level of the selected inputs
 		- interrupt is generated when all enabled channels
 		  meet the desired interrupt condition
 		- after an interrupt, a change in level must occur on
 		  the selected inputs to release the IRQ logic
  The COS interrupt must be configured before it can be enabled.
 	data[0] : INSN_CONFIG_DIGITAL_TRIG
 	data[1] : trigger number (= 0)
 	data[2] : configuration operation:
 	          COMEDI_DIGITAL_TRIG_DISABLE = no interrupts
 	          COMEDI_DIGITAL_TRIG_ENABLE_EDGES = OR (edge) interrupts
 	          COMEDI_DIGITAL_TRIG_ENABLE_LEVELS = AND (level) interrupts
 	data[3] : left-shift for data[4] and data[5]
 	data[4] : rising-edgehigh level channels
 	data[5] : falling-edgelow level channels
 switching to 'OR' mode 
 wipe old channels 
 preserve unspecified channels 
 configure specified channels 
 switching to 'AND' mode 
 wipe old channels 
 preserve unspecified channels 
 configure specified channels 
 ensure the mode bits are in-range for channels [19:4] 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 Step 4: fix up any arguments 
 Step 5: check channel list if it exists 
  Change-Of-State (COS) 'do_cmd' operation
  Enable the COS interrupt as configured by apci1564_cos_insn_config().
 just write the last to the reload register 
 return the actual value of the timer 
		
		  FIXME: The counter operation is not described in the
		  datasheet. For now just write the raw data[1] value to
		  the control register.
 just write the last to the reload register 
 return the actual value of the counter 
 read the EEPROM register and check the IO map revision 
 PLD Revision 1.0 IO Mapping 
 PLD Revision 2.x IO Mapping 
  Allocate and Initialise DI Subdevice Structures 
  Allocate and Initialise DO Subdevice Structures 
 Change-Of-State (COS) interrupt subdevice 
 Timer subdevice 
 Counter subdevice 
 Initialize the watchdog subdevice 
 Initialize the diagnostic status subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  icp_multi.c
  Comedi driver for Inova ICP_MULTI board
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1997-2002 David A. Schleef <ds@schleef.org>
  Driver: icp_multi
  Description: Inova ICP_MULTI
  Devices: [Inova] ICP_MULTI (icp_multi)
  Author: Anne Smorthit <anne.smorthit@sfwte.ch>
  Status: works
  Configuration options: not applicable, uses PCI auto config
  The driver works for analog input and output and digital input and
  output. It does not work with interrupts or with the counters. Currently
  no support for DMA.
  It has 16 single-ended or 8 differential Analogue Input channels with
  12-bit resolution.  Ranges : 5V, 10V, +-5V, +-10V, 0..20mA and 4..20mA.
  Input ranges can be individually programmed for each channel.  Voltage or
  current measurement is selected by jumper.
  There are 4 x 12-bit Analogue Outputs.  Ranges : 5V, 10V, +-5V, +-10V
  16 x Digital Inputs, 24V
  8 x Digital Outputs, 24V, 1A
  4 x 16-bit counters - not implemented
 RW: ADC commandstatus register 
 Start ADC 
 ADC busy 
 Bipolar input range 
 Input range 0 = 5V, 1 = 10V 
 Input mode 1 = differential 
 R:   Analogue input data 
 RW: DAC commandstatus register 
 Start DAC 
 DAC busy 
 Bipolar output range 
 Output range 0 = 5V, 1 = 10V 
 RW: Analogue output data 
 RW: Digital inputs 
 RW: Digital outputs 
 RW: Interrupt enable register 
 RW: Interrupt status register 
 AD conversion ready interrupt 
 DA conversion ready interrupt 
 Digital output error interrupt 
 Digital input status change int. 
 Counter 0 overrun interrupt 
 Counter 1 overrun interrupt 
 Counter 2 overrun interrupt 
 Counter 3 overrun interrupt 
 All interrupts 
 RW: Counter 0 
 RW: counter 1 
 RW: Counter 2 
 RW: Counter 3 
 analog input and output have the same range options 
 Set mode and range data for specified channel 
  Set start ADC bit 
  Wait for conversion to complete, or get fed up waiting 
 Select channel and range 
 Wait for analog output to be ready for new data 
 Set start conversion bit to write data to channel 
 Disable all interrupts and clear any requests 
 Reset the analog output channels to 0V 
 Select channel and 0..5V range 
 Output 0V 
 Set start conversion bit to write data to channel 
 Digital outputs to 0 
 Analog Input subdevice 
 Analog Output subdevice 
 Digital Input subdevice 
 Digital Output subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0
   comedidriversadl_pci9118.c
   hardware driver for ADLink cards:
    card:   PCI-9118DG, PCI-9118HG, PCI-9118HR
    driver: pci9118dg,  pci9118hg,  pci9118hr
  Author: Michal Dobes <dobes@tesnet.cz>
  Driver: adl_pci9118
  Description: Adlink PCI-9118DG, PCI-9118HG, PCI-9118HR
  Author: Michal Dobes <dobes@tesnet.cz>
  Devices: [ADLink] PCI-9118DG (pci9118dg), PCI-9118HG (pci9118hg),
  PCI-9118HR (pci9118hr)
  Status: works
  This driver supports AI, AO, DI and DO subdevices.
  AI subdevice supports cmd and insn interface,
  other subdevices support only insn interface.
  For AI:
  - If cmd->scan_begin_src=TRIG_EXT then trigger input is TGIN (pin 46).
  - If cmd->convert_src=TRIG_EXT then trigger input is EXTTRG (pin 44).
  - If cmd->start_srcstop_src=TRIG_EXT then trigger input is TGIN (pin 46).
  - It is not necessary to have cmd.scan_end_arg=cmd.chanlist_len but
  cmd.scan_end_arg modulo cmd.chanlist_len must by 0.
  - If return value of cmdtest is 5 then you've bad channel list
  (it isn't possible mixture S.E. and DIFF inputs or bipolar and unipolar
  ranges).
  There are some hardware limitations:
  a) You cann't use mixture of unipolarbipoar ranges or differencialsingle
   ended inputs.
  b) DMA transfers must have the length aligned to two samples (32 bit),
   so there is some problems if cmd->chanlist_len is odd. This driver tries
   bypass this with adding one sample to the end of the every scan and discard
   it on output but this can't be used if cmd->scan_begin_src=TRIG_FOLLOW
   and is used flag CMDF_WAKE_EOS, then driver switch to interrupt driven mode
   with interrupt after every sample.
  c) If isn't used DMA then you can use only mode where
   cmd->scan_begin_src=TRIG_FOLLOW.
  Configuration options:
  [0] - PCI bus of device (optional)
  [1] - PCI slot of device (optional)
 	 If busslot is not specified, then first available PCI
 	 card will be used.
  [2] - 0= standard 8 DIFF16 SE channels configuration
 	 n = external multiplexer connected, 1 <= n <= 256
  [3] - ignored
  [4] - sample&hold signal - card can generate signal for external S&H board
 	 0 = use SSHO(pin 45) signal is generated in onboard hardware S&H logic
 	 0 != use ADCHN7(pin 23) signal is generated from driver, number say how
 		long delay is requested in ns and sign polarity of the hold
 		(in this case external multiplexor can serve only 128 channels)
  [5] - ignored
  FIXME
  All the supported boards have the same PCI vendor and device IDs, so
  auto-attachment of PCI devices will always find the first board type.
  Perhaps the boards have different subdevice IDs that we could use to
  distinguish them?
  Need some device attributes so the board type can be corrected after
  attachment if necessary, and possibly to set other options supported by
  manual attachment.
  PCI BAR2 Register map (dev->iobase)
 0=FIFO full (fatal) 
 0=FIFO half full 
 0=FIFO empty 
 1=about trigger complete 
 1=ext. digital trigger 
 1=burst overrun (fatal) 
 1=AD over speed (warn) 
 1=AD overrun (fatal) 
 1=AD ready 
 1=unipolar 
 1=differential inputs 
 1=8254 software gate 
 1=8254 TGIN(pin 46) gate 
 1=ext. trigger (pin 44) 
 1=8254 is trigger source 
 1=enable interrupt 
 1=enable DMA 
 1=positive trigger 
 1=positive ext. trigger 
 1=with sample & hold 
 1=burst mode 
 1=burst mode start 
 1=post trigger 
 1=about trigger 
 1=trigger start 
 timer interrupt 
 about trigger complete 
 AD FIFO half full 
 ext. digital trigger 
 start measure on external trigger 
 stop measure on external trigger 
 stop measure on internal trigger 
 virtual address of buffer 
 hardware (bus) address of buffer 
 size of dma buffer in bytes 
 which size we may now use for transfer 
 base+size for AMCC chip 
 what do AI? 0=nothing, 1 to 4 mode 
	unsigned int ai_n_realscanlen;	
					  what we must transfer for one
					  outgoing scan include frontback adds
 position in actual real stream 
	unsigned int ai_add_front;	
					  how many channels we must add
					  before scan to satisfy S&H?
	unsigned int ai_add_back;	
					  how many channels we must add
					  before scan to satisfy DMA?
	char ai12_startstop;		
					  measure can startstop
					  on external trigger
 which buffer is used now 
	int softsshdelay;		
					  >0 use software S&H,
					  numer is requested delay in ns
	unsigned char softsshsample;	
					  polarity of S&H signal
					  in sample state
	unsigned char softsshhold;	
					  polarity of S&H signal
					  in hold state
 set the master write address and transfer count 
 enabledisable interrupt for AMCC Incoming Mailbox 4 (32-bit) 
 writing any value resets the AD FIFO 
 single channel scans are always ok 
	
	  Configure analog input based on the first chanlist entry.
	  All entries are either unipolar or bipolar and single-ended
	  or differential.
 gods know why this sequence! 
 insert channels for S&H 
 store chanlist 
 insert channels to fit onto 32bit DMA 
 close scan queue 
 udelay(100); important delay, or first sample will be crippled 
 use all samples 
	
	  Not all samples are to be used.  Buffer contents consist of a
	  possibly non-whole number of spans and a region of each span
	  is to be used.
	 
	  Account for samples in whole number of spans.
	
	  Deal with remaining samples which could overlap up to two spans.
 Skip samples before start position. 
 Include samples before stop position. 
 Advance to next span. 
 All samples are to be copied. 
		
		  Not all samples are to be copied.  Buffer contents consist
		  of a possibly non-whole number of spans and a region of
		  each span is to be copied.
 Skip samples before start position. 
 Copy samples before stop position. 
 Advance to next span. 
 Update position in span for next time. 
 convert timer (burst) 
 scan timer 
 major timer is c1c2 
 real convert timer 
 use BSSH signal 
 set default config (disable burst and triggers) 
 reset acquisition control 
 reset scan queue 
 determine whether more DMA buffers to do after this one 
 switch DMA buffers and restart DMA if double buffering 
 restart DMA if not double buffering 
 IRQ reasons from card 
 INT register from AMCC chip 
 STATUS register 
 startstop of measure 
 deactivate EXT trigger 
 start pacer 
 deactivate EXT trigger 
 on next interrupt measure will stop 
 isn't output buff smaller that our DMA buff? 
 align to 32bit down 
 align to 32bit down 
 we want wake up every scan? 
 uff, too short DMA buffer, disable EOS support! 
 short first DMA buffer to one scan 
 uff, too short DMA buffer, disable EOS support! 
 short second DMA buffer to one scan 
 transfer without CMDF_WAKE_EOS 
 if it's possible then align DMA buffers to length of scan 
 uff. very long scan? 
 uff. very long scan? 
		
		  if measure isn't neverending then test, if it fits whole
		  into one or two DMA buffers
 fits whole measure into one DMA buffer? 
 fits whole measure into two DMA buffer? 
 these DMA buffer size will be used 
 init DMA transfer 
 outl(0x02000000|AINT_WRITE_COMPL, devpriv->iobase_a+AMCC_OP_REG_INTCSR); 
 allow bus mastering 
 prepare for startstop conditions 
	
	  use additional sample at end of every scan
	  to satisty DMA 32 bit transfer?
					
					  use INT transfer if scanlist
					  have only one channel
				
				  XXX maybe can be corrected to use 16 bit DMA
			} else {	
					  well, we must insert one sample
					  to end of EOS to meet 32 bit transfer
 interrupt transfer don't need any correction 
	
	  we need software S&H signal?
	  It adds two samples before every scan as minimum
 move it to front 
 uff, still short 
 round up to 32 bit 
 well, we now know what must be all added 
	
	  what we must take from card in real to have cmd->scan_end_arg
	  on output?
	
	  Configure analog input and load the chanlist.
	  The acquisition control bits are enabled later.
 Determine acquisition mode and calculate timing 
 cascaded timers 1 and 2 are used for convert timing 
 double timed action 
 external trigger conversion 
 set default config (disable burst and triggers) 
 clear AD and INT status registers 
 start async command now or wait for internal trigger 
 enable external trigger for command startstop 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 start_arg is the internal trigger (any value) 
 TRIG_NONE 
 step 4: fix up any arguments 
 Step 5: check channel list if it exists 
 writing any value triggers an AD conversion 
	 Configure analog input based on the chanspec.
	 Acqusition is software controlled without interrupts.
 set default config (disable burst and triggers) 
	
	  The digital inputs and outputs share the read register.
	  bits [7:4] are the digital outputs
	  bits [3:0] are the digital inputs
	
	  The digital outputs are set with the same register that
	  the digital inputs and outputs are read from. But the
	  outputs are set with bits [3:0] so we can simply write
	  the s->state to set them.
 reset analog input subsystem 
 clear any pending interrupts and status 
 reset DMA and scan queue 
 reset analog outputs to 0V 
 requested particular busslot 
 max 256 channels! 
 select sample&hold signal polarity 
 Enable parity check for parity error 
 Analog Input subdevice 
		
		  16-bit samples are from an ADS7805 AD converter.
		  Minimum sampling rate is 10us.
		
		  12-bit samples are from an ADS7800 AD converter.
		  Minimum sampling rate is 3us.
 Analog Output subdevice 
 the analog outputs were reset to 0V, make the readback match 
 Digital Input subdevice 
 Digital Output subdevice 
 get the current state of the digital outputs 
	
	  Need to 'get' the PCI device to match the 'put' in pci9118_detach().
	  (The 'put' also matches the implicit 'get' by pci9118_find_pci().)
 no external mux, no sample-hold delay 
 FIXME: All the supported board types have the same device ID! 
	{ PCI_VDEVICE(AMCC, 0x80d9), BOARD_PCI9118HG }, 
	{ PCI_VDEVICE(AMCC, 0x80d9), BOARD_PCI9118HR }, 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  COMEDI driver for the Advantech PCI-1760
  Copyright (C) 2015 H Hartley Sweeten <hsweeten@visionengravers.com>
  Based on the pci1760 support in the adv_pci_dio driver written by:
 	Michal Dobes <dobes@tesnet.cz>
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  Driver: adv_pci1760
  Description: Advantech PCI-1760 Relay & Isolated Digital Input Card
  Devices: [Advantech] PCI-1760 (adv_pci1760)
  Author: H Hartley Sweeten <hsweeten@visionengravers.com>
  Updated: Fri, 13 Nov 2015 12:34:00 -0700
  Status: untested
  Configuration Options: not applicable, uses PCI auto config
  PCI-1760 Register Map
  Outgoing Mailbox Bytes
  OMB3: Not used (must be 0)
  OMB2: The command code to the PCI-1760
  OMB1: The hi byte of the parameter for the command in OMB2
  OMB0: The lo byte of the parameter for the command in OMB2
  Incoming Mailbox Bytes
  IMB3: The Isolated Digital Input status (updated every 100us)
  IMB2: The current command (matches OMB2 when command is successful)
  IMB1: The hi byte of the feedback data for the command in OMB2
  IMB0: The lo byte of the feedback data for the command in OMB2
  Interrupt ControlStatus
  INTCSR3: Not used (must be 0)
  INTCSR2: The interrupt status (read only)
  INTCSR1: Interrupt enabledisable
  INTCSR0: Not used (must be 0)
 PCI-1760 command codes 
 Clears IMB2 
 Set output state 
 Read output status 
 Read current status 
 Read firmware version 
 Read hardware version 
 Set "hi" period 
 Set "lo" period 
 Set burst count 
 Enable PWM outputs 
 Enable input filter 
 Enable input pattern match 
 Set input pattern match 
 Enable input rising edge 
 Enable input falling edge 
 Enable counter 
 Reset counter 
 Enable counter overflow 
 Enable counter match 
 Set counter edge 
 Reads counter value 
 Set "hi" sample time 
 Set "lo" sample time 
 Set counter reset val 
 Set counter match val 
 Read interrupt flags 
 Read edge change flags 
 Read counter oflowmatch 
 250 usec timeout 
 limit number of retries 
 1 unit = 100 usec 
 send the command and parameter 
 datasheet says to allow up to 250 usec for the command to complete 
 command success; return the feedback data 
 send PCI1760_CMD_CLR_IMB2 between identical commands 
 timeout? try it once more 
 datasheet says to keep retrying the command 
 command failed! 
 disable interrupts (intcsr2 is read-only) 
 disable counters 
 disable overflow interrupts 
 disable match 
 set match and counter reset values 
 reset counters to reset values 
 set counter count edges 
 disable input filters 
 disable pattern matching 
 set pattern match value 
 Digital Input subdevice 
 Digital Output subdevice 
 get the current state of the outputs 
 PWM subdevice 
 Counter subdevice 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  Comedi driver for National Instruments PCI-DIO-32HS
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1999,2002 David A. Schleef <ds@schleef.org>
  Driver: ni_pcidio
  Description: National Instruments PCI-DIO32HS, PCI-6533
  Author: ds
  Status: works
  Devices: [National Instruments] PCI-DIO-32HS (ni_pcidio)
    [National Instruments] PXI-6533, PCI-6533 (pxi-6533)
    [National Instruments] PCI-6534 (pci-6534)
  Updated: Mon, 09 Jan 2012 14:27:23 +0000
  The DIO32HS board appears as one subdevice, with 32 channels. Each
  channel is individually IO configurable. The channel order is 0=A0,
  1=A1, 2=A2, ... 8=B0, 16=C0, 24=D0. The driver only supports simple
  digital IO; no handshaking is supported.
  DMA mostly works for the PCI-DIO32HS, but only in timed input mode.
  The PCI-DIO-32HSPCI-6533 has a configurable external trigger. Setting
  scan_begin_arg to 0 or CR_EDGE triggers on the leading edge. Setting
  scan_begin_arg to CR_INVERT or (CR_EDGE | CR_INVERT) triggers on the
  trailing edge.
  This driver could be easily modified to support AT-MIO32HS and AT-MIO96.
  The PCI-6534 requires a firmware upload after power-up to work, the
  firmware data and instructions for loading it with comedi_config
  it are contained in the comedi_nonfree_firmware tarball available from
  https:www.comedi.org
 defines for the PCI-DIO-32HS 
 W 
 R 
 W 
 R 
 R 
 R 
 #define SerialRose 
 #define ReqRose 
 #define Paused 
 W 
 W 
 W 
 W 
 W 
 W 
 16 bit 
 bits same as flags 
 channel zero is none 
 32 bit 
 Firmware files for PCI-6524 
 16 bit 
 main fpga registers (32 bit)
write-clear 
write-clear 
write-clear 
write-clear 
 nanoseconds 
 write alloc the entire buffer 
 interrupcions parasites 
 assume it's from another card 
 Lock to avoid race with comedi_poll 
 XXX need to byteswap sync'ed dma 
 we don't care about actual channels 
 Step 1 : check if triggers are trivially valid 
 Step 2a : make sure trigger sources are unique 
 Step 2b : and mutually compatible 
 Step 3: check if arguments are trivially valid 
 in nanoseconds 
 no minimum speed 
 TRIG_EXT 
 should be leveledge, hilo specification here 
 TRIG_NONE 
 step 4: fix up any arguments 
 XXX configure ports for input 
 enable fifos A B C D 
 set transfer width a 32 bits 
 protocol configuration 
 page 4-5, "input with internal REQs" 
		
		  manual, page 4-5:
		  CLOCK_SPEED comment is incorrectly listed on DAQ_OPTIONS
 TRIG_EXT 
 page 4-5, "input with external REQs" 
 Leading Edge 
 Trailing Edge 
 XXX 
 clear and enable interrupts 
 writeb(CLEAR_EXPIRED, dev->mmio+GROUP_1_SECOND_CLEAR); 
 TRIG_TIMER 
 start 
 TRIG_INT 
 loaded into scarab A for DI 
 loaded into scarab B for DO 
 loaded into main FPGA 
 load main FPGA first, then the two scarabs 
 disable interrupts on board 
 use win0 
 XXX 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
  addi_apci_16xx.c
  Copyright (C) 2004,2005  ADDI-DATA GmbH for the source code of this module.
  Project manager: S. Weber
 	ADDI-DATA GmbH
 	Dieselstrasse 3
 	D-77833 Ottersweier
 	Tel: +19(0)72239493-0
 	Fax: +49(0)72239493-92
 	http:www.addi-data.com
 	info@addi-data.com
  Register IO map
 2 subdevices 
 3 subdevices 
	
	  Work out the number of subdevices needed to support all the
	  digital io channels on the board. Each subdevice supports
	  up to 32 channels.
 Initialize the TTL digital io subdevices 
 Default all channels to inputs 
www.comedi.org");
 SPDX-License-Identifier: GPL-2.0+
   comedidriverstestsni_routes_test.c
   Unit tests for NI routes (ni_routes.c module).
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  BEGIN fake board data  
 These have to be defs to be used in init code below 
 I1 and I2 should not call O(...).  Mostly here to shut checkpatch.pl up 
 O9 is build to call O(...) for each arg 
1, 2, 3, 4, 5, 6, 7, 8, 9)},
2, 3, 4, 5, 6, 7, 8, 9)},
 ith route_set 
 6, 7, 8, 9)},
 7, 8, 9)},
 next one will not have valid reg values 
 8, 9)},
)},
 indirect routes done through muxes 
 This table is indexed as RV[destination][source] 
1, 2, 3, 4, 5, 6, 7, 8, 9)},
 2, 3, 4, 5, 6, 7, 8, 9)},
3, 4, 5, 6, 7, 8, 9)},
4, 5, 6, 7, 8, 9)},
5, 6, 7, 8, 9)},
6, 7, 8, 9)},
7, 8, 9)},
 [7] is intentionaly left absent to test invalid routes 
9)},
)},
 some tests for needing extra muxes 
  END fake board data  
  BEGIN board data initializers  
  END board data initializers  
 Tests that route_sets are in order of the signal destination. 
 Tests that all route_set->src are in order of the signal source. 
 We begin by sorting the device routes for use in later tests 
 now we test that sorting. 
 choice of trigger line in the following is somewhat random 
  BEGIN simple module entryexit functions  
www.comedi.org");
  END simple module entryexit functions  
 SPDX-License-Identifier: GPL-2.0+
   comedidriverstestscomedi_example_test.c
   Example set of unit tests.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  BEGIN fake board data  
  END fake board data  
  BEGIN fake data init  
  END fake data init  
  BEGIN simple module entryexit functions  
  END simple module entryexit functions  
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_route_values.c
   Route information for NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  This file includes the tables that are a list of all the values of various
  signals routes available on NI hardware.  In many cases, one does not
  explicitly make these routes, rather one might indicate that something is
  used as the source of one particular trigger or another (using
  _src=TRIG_EXT).
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routes.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 SPDX-License-Identifier: GPL-2.0+
  write out
  {
    "family" : "<family-name>",
    "register_values": {
       <destination0>:[src0, src1, ...],
       <destination0>:[src0, src1, ...],
       ...
    }
  }
 no data here 
  write out
  {
    "family" : "<family-name>",
    "register_values": {
       <destination0>:[src0, src1, ...],
       <destination0>:[src0, src1, ...],
       ...
    }
  }
 write route register values 
 write valid device routes 
 finish; close file 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_route_valuesni_660x.c
   Route information for NI_660X boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  This file includes a list of all the values of various signals routes
  available on NI 660x hardware.  In many cases, one does not explicitly make
  these routes, rather one might indicate that something is used as the source
  of one particular trigger or another (using _src=TRIG_EXT).
  The contents of this file can be generated using the tools in
  comedidriversni_routingtools.  This file also contains specific notes to
  this family of devices.
  Please use those tools to help maintain the contents of this file, but be
  mindful to not lose the notes already made in this file, since these notes
  are critical to a complete undertsanding of the register values of this
  family.
		
		  destination = {
		               source          = register value,
		               ...
		  }
 These are not currently implemented in ni modules 
 or 1 ),
 These are not currently implemented in ni modules 
 or 1 ),
 These are not currently implemented in ni modules 
 or 1 ),
 These are not currently implemented in ni modules 
 or 1 ),
 These are not currently implemented in ni modules 
 or 1 ),
 These are not currently implemented in ni modules 
 or 1 ),
 These are not currently implemented in ni modules 
 or 1 ),
 These are not currently implemented in ni modules 
 or 1 ),
 or 1 ),
 or 30 ),
 or 1 ),
 or 30 ),
 or 1 ),
 or 30 ),
 or 1 ),
 or 30 ),
 or 1 ),
 or 30 ),
 or 1 ),
 or 30 ),
 or 1 ),
 or 30 ),
 or 1 ),
 or 30 ),
 or 1 ),
 or 1 ),
 or 1 ),
 or 1 ),
 or 1 ),
 or 1 ),
 or 1 ),
 or 1 ),
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_route_valuesni_mseries.c
   Route information for NI_MSERIES boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  This file includes a list of all the values of various signals routes
  available on NI 660x hardware.  In many cases, one does not explicitly make
  these routes, rather one might indicate that something is used as the source
  of one particular trigger or another (using _src=TRIG_EXT).
  The contents of this file can be generated using the tools in
  comedidriversni_routingtools.  This file also contains specific notes to
  this family of devices.
  Please use those tools to help maintain the contents of this file, but be
  mindful to not lose the notes already made in this file, since these notes
  are critical to a complete undertsanding of the register values of this
  family.
  GATE SELECT NOTE:
  CtrAux and CtrArmStartrigger register values are not documented in the
  DAQ-STC.  There is some evidence that using CtrGate values is valid (see
  comedi.h).  Some information and hints exist in the M-Series user manual
  (ni-62xx user-manual 371022K-01).
		
		  destination = {
		               source          = register value,
		               ...
		  }
			
			  for (->TRIGGER_LINE()) MUX, a value of 12 should be
			  RTSI_OSC according to MHDDK mseries source.  There
			  are hints in comedi that show that this is actually a
			  20MHz source for 628x cards(?)
			
			  for (->TRIGGER_LINE()) MUX, a value of 12 should be
			  RTSI_OSC according to MHDDK mseries source.  There
			  are hints in comedi that show that this is actually a
			  20MHz source for 628x cards(?)
			
			  for (->TRIGGER_LINE()) MUX, a value of 12 should be
			  RTSI_OSC according to MHDDK mseries source.  There
			  are hints in comedi that show that this is actually a
			  20MHz source for 628x cards(?)
			
			  for (->TRIGGER_LINE()) MUX, a value of 12 should be
			  RTSI_OSC according to MHDDK mseries source.  There
			  are hints in comedi that show that this is actually a
			  20MHz source for 628x cards(?)
			
			  for (->TRIGGER_LINE()) MUX, a value of 12 should be
			  RTSI_OSC according to MHDDK mseries source.  There
			  are hints in comedi that show that this is actually a
			  20MHz source for 628x cards(?)
			
			  for (->TRIGGER_LINE()) MUX, a value of 12 should be
			  RTSI_OSC according to MHDDK mseries source.  There
			  are hints in comedi that show that this is actually a
			  20MHz source for 628x cards(?)
			
			  for (->TRIGGER_LINE()) MUX, a value of 12 should be
			  RTSI_OSC according to MHDDK mseries source.  There
			  are hints in comedi that show that this is actually a
			  20MHz source for 628x cards(?)
			
			  for (->TRIGGER_LINE()) MUX, a value of 12 should be
			  RTSI_OSC according to MHDDK mseries source.  There
			  are hints in comedi that show that this is actually a
			  20MHz source for 628x cards(?)
 These are not currently implemented in ni modules 
 These are not currently implemented in ni modules 
 source:  mhddk examples ),
 source for following line:  mhddk GP examples 
 source for following line:  mhddk examples 
 source for following line:  mhddk GP examples 
 these are just a guess; see GATE SELECT NOTE 
 source for following line:  mhddk GP examples 
 these are just a guess; see GATE SELECT NOTE 
 source for following line:  mhddk GP examples 
			
			  See nimseriesExamples for outputs; inputs a guess
			  from device routes shown on NI-MAX.
			  see M-Series user manual (371022K-01)
			
			  See nimseriesExamples for outputs; inputs a guess
			  from device routes shown on NI-MAX.
			  see M-Series user manual (371022K-01)
			
			  See nimseriesExamples for outputs; inputs a guess
			  from device routes shown on NI-MAX.
			  see M-Series user manual (371022K-01)
			
			  See nimseriesExamples for outputs; inputs a guess
			  from device routes shown on NI-MAX.
			  see M-Series user manual (371022K-01)
			
			  See nimseriesExamples for outputs; inputs a guess
			  from device routes shown on NI-MAX.
			  see M-Series user manual (371022K-01)
			
			  See nimseriesExamples for outputs; inputs a guess
			  from device routes shown on NI-MAX.
			  see M-Series user manual (371022K-01)
 these are just a guess; see GATE SELECT NOTE 
 source for following line:  mhddk GP examples 
 these are just a guess; see GATE SELECT NOTE 
 source for following line:  mhddk GP examples 
 These are not currently implemented in ni modules 
			
			  For routes (->NI_AI_SampleClockTimebase) and
			  (->NI_AO_SampleClockTimebase), tMSeries.h of MHDDK
			  shows 0 value as selecting ground (case ground?) and
			  28 value selecting TIMEBASE 1.
 These are not currently implemented in ni modules 
 source for following line:  mhddk example headers 
 source for following line:  mhddk example headers 
 These are not currently implemented in ni modules 
 These are not currently implemented in ni modules 
 These are not currently implemented in ni modules 
			
			  For routes (->NI_AI_SampleClockTimebase) and
			  (->NI_AO_SampleClockTimebase), tMSeries.h of MHDDK
			  shows 0 value as selecting ground (case ground?) and
			  28 value selecting TIMEBASE 1.
			
			  for the signal route
			  (NI_AI_StartTrigger->NI_AO_StartTrigger), DAQ-STC &
			  MHDDK disagreed for e-series.  MHDDK for m-series
			  agrees with DAQ-STC description and uses the value 18
			  for the route
			  (NI_AI_ReferenceTrigger->NI_AO_StartTrigger).  The
			  m-series devices are supposed to have DAQ-STC2.
			  There are no DAQ-STC2 docs to compare with.
 These are not currently implemented in ni modules 
 These are not currently implemented in ni modules 
		
		  This symbol is not defined and nothing for this is
		  implemented--just including this because data was found in
		  the NI-STC for it--can't remember where.
		  [B(NI_FrequencyOutTimebase)] = {
		 	 These are not currently implemented in ni modules 
		 	[B(NI_20MHzTimebase)]	= U(0),
		 	[B(NI_100kHzTimebase)]	= U(1),
		  },
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_route_valuesni_eseries.c
   Route information for NI_ESERIES boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  This file includes a list of all the values of various signals routes
  available on NI 660x hardware.  In many cases, one does not explicitly make
  these routes, rather one might indicate that something is used as the source
  of one particular trigger or another (using _src=TRIG_EXT).
  The contents of this file can be generated using the tools in
  comedidriversni_routingtools.  This file also contains specific notes to
  this family of devices.
  Please use those tools to help maintain the contents of this file, but be
  mindful to not lose the notes already made in this file, since these notes
  are critical to a complete undertsanding of the register values of this
  family.
  Note that for e-series devices, the backplane TRIGGER_LINE(6) is generally
  not connected to RTSI(6).
		
		  destination = {
		               source          = register value,
		               ...
		  }
 These are not currently implemented in ni modules 
 These are not currently implemented in ni modules 
 These are not currently implemented in ni modules 
 These are not currently implemented in ni modules 
 These are not currently implemented in ni modules 
 These are not currently implemented in ni modules 
 These are not currently implemented in ni modules 
			
			  for the signal route
			  (NI_AI_StartTrigger->NI_AO_StartTrigger), MHDDK says
			  used register value 18 and DAQ-STC says 19.
			  Hoping that the MHDDK is correct--being a "working"
			  example.
 These are not currently implemented in ni modules 
 These are not currently implemented in ni modules 
		
		  This symbol is not defined and nothing for this is
		  implemented--just including this because data was found in
		  the NI-STC for it--can't remember where.
		  [B(NI_FrequencyOutTimebase)] = {
		 	 These are not currently implemented in ni modules 
		 	[B(NI_20MHzTimebase)]	= U(0),
		 	[B(NI_100kHzTimebase)]	= U(1),
		  },
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespci-6254.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespxi-6030e.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespxie-6738.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespxi-6224.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespci-6070e.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespci-6259.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespxi-6251.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespxie-6251.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespci-6723.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespci-6221.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespci-6733.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespxie-6535.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespci-6251.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespci-6713.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespci-6534.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespci-6229.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespxi-6733.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespxi-6225.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespci-6220.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
   comedidriversni_routingni_device_routespci-6602.c
   List of valid routes for specific NI boards.
   COMEDI - Linux Control and Measurement Device Interface
   Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  The contents of this file are generated using the tools in
  comedidriversni_routingtools
  Please use those tools to help maintain the contents of this file.
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination 
 Termination of list 
 SPDX-License-Identifier: GPL-2.0+
  kcomedilibkcomedilib.c
  a comedlib interface for kernel modules
  COMEDI - Linux Control and Measurement Device Interface
  Copyright (C) 1997-2000 David A. Schleef <ds@schleef.org>
 a subdevice instruction 
 XXX check lock 
 XXX should check instruction length 
	
	  Most drivers ignore the base channel in insn->chanspec.
	  Fix this here if the subdevice has <= 32 channels.
 SPDX-License-Identifier: GPL-2.0-only
  Swap block device support for MTDs
  Turns an MTD device into a swap device with block wear leveling
  Copyright  2007,2011 Nokia Corporation. All rights reserved.
  Authors: Jarkko Lavinen <jarkko.lavinen@nokia.com>
  Based on Richard Purdie's earlier implementation in 2007. Background
  support and lock-less operation written by Adrian Hunter.
  The number of free eraseblocks when GC should stop
  Number of free eraseblocks below which GC can also collect low frag
  blocks.
  Wear level cost amortization. We want to do wear leveling on the background
  without disturbing gc too much. This is made by defining max GC frequency.
  Frequency value 6 means 16 of the GC passes will pick an erase block based
  on the biggest wear difference rather than the biggest dirtiness.
  The lower freq2 should be chosen so that it makes sure the maximum erase
  difference will decrease even if a malicious application is deliberately
  trying to make erase differences large.
 speeds up pointer decrement 
 Before marking erase block bad 
  In the worst case mtdswap_writesect() has allocated the last clean
  page from the current block and is then pre-empted by the GC
  thread. The thread can consume a full erase block when moving a
  block.
 false 
 badblocks not supported 
 Check first if the block is bad. 
  Are there any erase blocks without MAGIC_CLEAN header, presumably
  because power was cut off after erase but before header write? We
  need to guestimate the erase count.
  Place eblk into a tree corresponding to its number of active blocks
  it contains.
	
	  Calculate linear ramp down from f1 to f2 when maxdiff goes from
	  MAX_ERASE_DIFF to MAX_ERASE_DIFF + COLLECT_NONDIRTY_BASE.  Similar
	  to triangle with height f1 - f1 and width COLLECT_NONDIRTY_BASE.
	
	  Modelling the slop as right angular triangle with base
	  COLLECT_NONDIRTY_BASE and height freq1 - freq2. The ratio yx is
	  equal to the ratio hbase.
 Ignore writes to the header page 
 Provide a dummy swap header for the kernel 
 SPDX-License-Identifier: GPL-2.0-only
  MTD OopsPanic logger
  Copyright  2007 Nokia Corporation. All rights reserved.
  Author: Richard Purdie <rpurdie@openedhand.com>
 Maximum MTD partition size 
 Mark pages as unused 
 Scheduled work - when we can't proceed without erasing a block 
 We were unregistered 
 Add mtdoops header to the buffer 
 Assume the page is used 
 Only dump oopses if dump_oops is set 
 Panics must be written immediately 
 For other cases, schedule work to write it "nicely" 
 oops_page_used is a bit field 
 Setup the MTD device to use 
 SPDX-License-Identifier: GPL-2.0-or-later
  MTD device concatenation layer
  Copyright  2002 Robert Kaiser <rkaiser@sysgo.de>
  Copyright  2002-2010 David Woodhouse <dwmw2@infradead.org>
  NAND support by Christian Gan <cgan@iders.ca>
  Our storage structure:
  Subdev points to an array of pointers to struct mtd_info objects
  which is allocated along with this structure
  how to calculate the size required for the above structure,
  including the pointer array subdev points to:
  Given a pointer to the MTD object in the mtd_concat structure,
  we can retrieve the pointer to that structure with this macro.
  MTD methods which look up the relevant subdevice, translate the
  effective address and pass through to the subdevice.
 Not destined for this subdev 
 First part goes into this subdev 
 Entire transaction goes into this subdev 
 Save information about bitflips! 
 Do not overwrite -EBADMSG !! 
 Calculate total length of data 
 Check alignment 
 make a copy of vecs 
 store for future use 
 partial read ? 
 Save information about bitflips! 
 Do not overwrite -EBADMSG !! 
 partial write ? 
	
	  Check for proper erase block alignment of the to-be-erased area.
	  It is easier to do this based on the super device's erase
	  region info rather than looking at each particular sub-device
	  in turn.
 the easy case: device has uniform erase block size 
 device has variable erase size 
		
		  Find the erase region where the to-be-erased area begins:
		
		  Now erase_regions[i] is the region in which the
		  to-be-erased area begins. Verify that the starting
		  offset is aligned to this region's erase size:
		
		  now find the erase region where the to-be-erased area ends:
		
		  check if the ending offset is aligned to this region's erase size
 make a local copy of instr to avoid modifying the caller's struct 
	
	  find the subdevice where the to-be-erased area begins, adjust
	  starting offset to be relative to the subdevice start
 must never happen since size limit has been verified above 
 now do the erase: 
 loop for all subdevices affected by this request 
 get current subdevice 
 limit length to subdevice's size: 
			 sanity check: should never happen since
		
		  erase->addr specifies the offset of the area to be
		  erased within the current subdevice. It can be
		  non-zero only the first time through this loop, i.e.
		  for the first subdevice where blocks need to be erased.
		  All the following erases must begin at the start of the
		  current subdevice, i.e. at offset zero.
  This function constructs a virtual MTD device by concatenating
  num_devs MTD devices. A pointer to the new device object is
  stored to new_dev upon success. This function does _not_
  register any devices: this is the caller's responsibility.
 subdevices to concatenate 
 number of subdevices      
 name for the new device   
 allocate the device structure 
	
	  Set up the new "super" device's MTD object structure, check for
	  incompatibilities between the subdevices.
			
			  Expect all flags except MTD_WRITEABLE to be
			  equal on all subdevices.
				 if writeable attribute differs,
			
			  Check against subdev[i] for data members, because
			  subdev's attributes may be different from master
			  mtd device. Check against subdev's master mtd
			  device for callbacks, because the existence of
			  subdev's callbacks is decided by master mtd device.
	
	  Combine the erase block size info of the subdevices:
	 
	  first, walk the map of the new device and see how
	  many changes in erase size we have
 current subdevice has uniform erase size 
 if it differs from the last subdevice's erase size, count it 
 current subdevice has variable erase size 
 walk the list of erase regions, count any changes 
		
		  All subdevices have the same uniform erase size.
		  This is easy:
		
		  erase block size varies across the subdevices: allocate
		  space to store the data describing the variable erase regions
		
		  walk the map of the new device once more and fill in
		  in erase region info:
 current subdevice has uniform erase size 
					
					   fill in an mtd_erase_region_info structure for the area
					   we have walked so far:
 current subdevice has variable erase size 
 walk the list of erase regions, count any changes 
 Now write the final entry 
 Cleans the context obtained from mtd_concat_create() 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright  1999-2010 David Woodhouse <dwmw2@infradead.org>
  Data structure to hold the pointer to the mtd device as well
  as mode information of various use cases.
 You can't open the RO devices RW 
 You can't open it RW if it's not a writeable device 
 mtdchar_open 
====================================================================
 Only sync if opened RW 
 mtdchar_close 
 Back in June 2001, dwmw2 wrote:
    FIXME: This _really_ needs to die. In 2.5, we should lock the
    userspace buffer down and use it directly with readvwritev.
  The implementation below, using mtd_kmalloc_up_to, mitigates
  allocation failures when the system is under low-memory situations
  or if memory is highly fragmented at the cost of reducing the
  performance of the requested transfer due to a smaller buffer size.
  A more complex but more memory-efficient implementation based on
  get_user_pages and iovecs to cover extents of those pages is a
  longer-term goal, as intimated by dwmw2 above. However, for the
  write case, this requires yet more complex head and tail transfer
  handling when those head and tail offsets and sizes are such that
  alignment requirements are not met in the NAND subdriver.
		 Nand returns -EBADMSG on ECC errors, but it returns
		  the data. For our userspace tools it is important
		  to dump areas with ECC errors!
		  For kernel internal usage it also might return -EUCLEAN
		  to signal the caller that a bitflip has occurred and has
		  been corrected by the ECC algorithm.
		  Userspace software which accesses NAND this way
		  must be aware of the fact that it deals with NAND
 mtdchar_read 
		
		  Return -ENOSPC only if no data could be written at all.
		  Otherwise just return the number of bytes that actually
		  have been written.
 mtdchar_write 
======================================================================
    IOCTL calls for getting device parameters.
	
	  NAND returns -EBADMSG on ECC errors, but it returns the OOB
	  data. For our userspace tools it is important to dump areas
	  with ECC errors!
	  For kernel internal usage it also might return -EUCLEAN
	  to signal the caller that a bitflip has occurred and has
	  been corrected by the ECC algorithm.
	 
	  Note: currently the standard NAND function, nand_read_oob_std,
	  does not calculate ECC for the OOB area, so do not rely on
	  this behavior unless you have replaced it with your own.
  Copies (and truncates, if necessary) OOB layout information to the
  deprecated layout struct, nand_ecclayout_user. This is necessary only to
  support the deprecated API ioctl ECCGETLAYOUT while allowing all new
  functionality to use mtd_ooblayout_ops flexibly (i.e. mtd_ooblayout_ops
  can describe any kind of OOB layout with almost zero overhead from a
  memory usage point of view).
 Only master mtd device must be used to add partitions 
 Sanitize user input 
	
	  Check the file mode to require "dangerous" commands to have write
	  permissions.
 "safe" commands 
 "dangerous" commands 
 The below field is obsolete 
 NOTE: writes return length to buf_user->length 
 NOTE: writes return length to buf_user->start 
 Legacy interface 
 This ioctl is being deprecated - it truncates the ECC layout 
 No reread partition feature. Just return ok 
 memory_ioctl 
 unsigned char 
 NOTE: writes return length to buf->start 
 Convert from blkpg_compat_ioctl_arg to blkpg_ioctl_arg 
 CONFIG_COMPAT 
  try to determine where a shared mapping can be made
  - only supported for NOMMU at the moment (MMU can't doesn't copy private
    mappings)
  set up a mapping for shared memory segments
         This is broken because it assumes the MTD device is map-based
	   and that mtd->priv is a valid struct map_info.  It should be
	   replaced with something that uses the mtd_get_unmapped_area()
mtd->type == MTD_RAM || mtd->type == MTD_ROM) {
 SPDX-License-Identifier: GPL-2.0-or-later
  Direct MTD block device access
  Copyright  1999-2010 David Woodhouse <dwmw2@infradead.org>
  Copyright  2000-2003 Nicolas Pitre <nico@fluxnic.net>
  Cache stuff...
  Since typical flash erasable sectors are much larger than what Linux's
  buffer cache can handle, we must implement read-modify-write on flash
  sectors for each block write requests.  To avoid over-erasing flash sectors
  and to speed things up, we locally cache a whole flash sector while it is
  being written to until a different sector is required.
	
	  First, let's erase the flash block.
	
	  Next, write the data to flash.
	
	  Here we could arguably set the cache state to STATE_CLEAN.
	  However this could lead to inconsistency since we will not
	  be notified if this content is altered on the flash by other
	  means.  Let's declare it empty and leave buffering tasks to
	  the buffer cache instead.
	 
	  If this cache_offset points to a bad block, data cannot be
	  written to the device. Clear cache_state to avoid writing to
	  bad blocks repeatedly.
			
			  We are covering a whole sector.  Thus there is no
			  need to bother with the cache while it may still be
			  useful for other partial writes.
 Partial sector: need to use the cache 
 fill the cache with the current sector 
 write data to our local cache 
		
		  Check if the requested data is already cached
		  Read the requested amount of data from our internal cache if it
		  contains what we want, otherwise we read the data directly
		  from flash.
		 -EINTR is not really correct, but it is the best match
		  documented in man 2 write for all cases.  We could also
		  return -EAGAIN sometimes, but why bother?
 OK, it's not open. Create cache info for it 
		
		  It was the last usage. Free the cache, but only sync if
		  opened for writing.
 SPDX-License-Identifier: GPL-2.0-or-later
  inftlcore.c -- Linux driver for Inverse Flash Translation Layer (INFTL)
  Copyright  2002, Greg Ungerer (gerg@snapgear.com)
  Based heavily on the nftlcore.c code which is:
  Copyright  1999 Machine Vision Holdings, Inc.
  Copyright  1999 David Woodhouse <dwmw2@infradead.org>
  Maximum number of loops while examining next block, to have a
  chance to detect consistency problems (they should never happen
  because of the checks done in the mounting.
 OK, this is moderately ugly.  But probably safe.  Alternatives? 
 OK, it's a new one. Set up all the data structures. 
 Calculate geometry 
		
		  Oh no we don't have
		   mbd.size == heads  cylinders  sectors
  Actual INFTL access routines.
  Read oob data from flash
  Write oob data to flash
  Write data and oob to flash
  INFTL_findfreeblock: Find a free Erase Unit on the INFTL partition.
 	This function is used when the give Virtual Unit Chain.
	
	  Normally, we force a fold to happen before we run out of free
	  blocks completely.
 Scan for a free block 
	
	  Scan to find the Erase Unit which holds the actual data for each
	  512-byte block within the Chain.
	
	  OK. We now know the location of every block in the Virtual Unit
	  Chain, and the Erase Unit into which we are supposed to be copying.
	  Go for it.
		
		  If it's in the target EUN already, or if it's pending write,
		  do nothing.
		
		  Copy only in non free block (free blocks can only
                  happen in case of media errors or deleted blocks).
	
	  Newest unit in chain now contains data from _all_ older units.
	  So go through and erase each unit in chain, oldest first. (This
	  is important, by doing oldest first if we crashreboot then it
	  it is relatively simple to clean up the mess).
 Find oldest unit in chain. 
 Check if we are all done 
 Unlink the last block from the chain. 
 Now try to erase it. 
			
			  Could not erase : mark block as reserved.
 Correctly erased : mark it as free 
	
	  This is the part that needs some cleverness applied.
	  For now, I'm doing the minimum applicable to actually
	  get the thing to work.
	  Wear-levelling and other clever stuff needs to be implemented
	  and we also need to do some assessment of the results when
	  the system loses power half-way through the routine.
				
				  Actually, don't return failure.
				  Just ignore this chain and get on with it.
  INFTL_findwriteunit: Return the unit number into which we can write
                       for this block. Make it available if it isn't already.
		
		  Scan the media to find a unit in the VUC which has
		  a free space for the block in question.
 Can't go any further 
				
				  Invalid block. Don't use it any more.
				  Must implement.
 Skip to next block in chain 
		
		  OK. We didn't find one in the existing chain, or there
		  is no existing chain. Allocate a new one.
			
			  That didn't work - there were no free blocks just
			  waiting to be picked up. We're going to have to fold
			  a chain to make room.
			
			  Hopefully we free something, lets try again.
			  This time we are desperate...
				
				  Ouch. This should never happen - we should
				  always be able to make some room somehow.
				  If we get here, we've allocated more storage
				  space than actual media, or our makefreeblock
				  routine is missing something.
		
		  Insert new block into virtual chain. Firstly update the
		  block headers in flash...
 Also back up header... 
  Given a Virtual Unit Chain, see if it can be deleted, and if so do it.
	
	  Scan through the Erase Units to determine whether any data is in
	  each of the 512-byte blocks within the Chain.
	
	  For each block in the chain free it and make it available
	  for future use. Erase from the oldest unit first.
 If the chain is all gone already, we're done 
 Find oldest unit in chain. 
			
			  Could not erase : mark block as reserved.
 Correctly erased : mark it as free 
 Now sort out whatever was pointing to it... 
		 Ideally we'd actually be responsive to new
		   requests while we're doing this -- if there's
 Is block all zero? 
			
			  If we _still_ haven't got a block to use,
			  we're screwed.
		
		  need to write SECTOR_USED flags since they are not written
		  in mtd_writeecc
 The requested block is not on the media, return all 0x00 
 Handle corrected bit flips gracefully 
 SPDX-License-Identifier: GPL-2.0-or-later
  NFTL mount code with extensive checks
  Author: Fabrice Bellard (fabrice.bellard@netgem.com)
  Copyright  2000 Netgem S.A.
  Copyright  1999-2010 David Woodhouse <dwmw2@infradead.org>
 find_boot_record: Find the NFTL Media Header and its Spare copy which contains the
 	various device information of the NFTL partition and Bad Unit Table. Update
 	the ReplUnitTable[] table according to the Bad Unit Table. ReplUnitTable[]
 	is used for management of Erase Unit in other routines in nftl.c and nftlmount.c
         Assume logical EraseSize == physical erasesize for starting the scan.
	 Actually, we won't.  The new DiskOnChip driver has already scanned
	   the MediaHeader and adjusted the virtual erasesize it presents in
	   the mtd device accordingly.  We could even get rid of
 search for a valid boot record 
		 Check for ANAND header first. Then can whinge if it's found but later
		 We ignore ret in case the ECC of the MediaHeader is invalid
 ANAND\0 not found. Continue 
 To be safer with BIOS, also use erase mark as discriminant 
#if 0  Some people seem to have devices without ECC or erase marks
	 on the Media Header blocks. There are enough other sanity
	 checks in here that we can probably do without it.
 Finally reread to check ECC 
 Paranoia. Check the ANAND header is still there after the ECC read 
 OK, we like it. 
			 We've already processed one. So we just check if
 if (debug) Print both side by side 
 We haven't yet seen two real ones 
 Mark this boot record (NFTL MediaHeader) block as reserved 
 This is the first we've seen. Copy the media header structure into place 
 Do some sanity checks on it 
		 If we're not using the last sectors in the device for some reason,
 XXX: will be suppressed 
 memory alloc 
 mark the bios blocks (blocks before NFTL MediaHeader) as reserved 
 mark all remaining blocks as potentially containing data 
 Mark this boot record (NFTL MediaHeader) block as reserved 
 read the Bad Erase Unit Table and modify ReplUnitTable[] accordingly 
 read one sector for every SECTORSIZE of blocks 
 mark the Bad Erase Unit as RESERVED in ReplUnitTable 
 foreach (block) 
 check_free_sector: check if a free sector is actually FREE, i.e. All 0xff in data and oob area 
 NFTL_format: format a Erase Unit by erasing ALL Erase Zones in the Erase Unit and
               Update NFTL metadata. Each erase operation is checked with check_free_sectors
  Return: 0 when succeed, -1 on error.
   ToDo: 1. Is it necessary to check_free_sector after erasing ??
 Read the Unit Control Information #1 for Wear-Leveling 
 XXX: use async erase interface, XXX: test return code 
 increase and write Wear-Leveling info 
 wrap (almost impossible with current flash) or free block 
	 check the "freeness" of Erase Unit before updating metadata
	  FixMe:  is this check really necessary ? since we have check the
	          return code after the erase operation.
	 could not format, update the bad block table (caller is responsible
 check_sectors_in_chain: Check that each sector of a Virtual Unit Chain is correct.
 	Mark as 'IGNORE' each incorrect sector. This check is only done if the chain
 	was being folded when NFTL was interrupted.
 	The check_free_sectors in this function is necessary. There is a possible
 	situation that after writing the Data area, the Block Control Information is
 	not updated according (due to power failure or something) which leaves the block
 	in an inconsistent state. So we have to check if a block is really FREE in this
				 verify that the sector is really free. If not, mark
 sector not free actually : mark it as SECTOR_IGNORE  
 proceed to next Erase Unit on the chain 
 calc_chain_length: Walk through a Virtual Unit Chain and estimate chain length 
		 avoid infinite loops, although this is guaranteed not to
 format_chain: Format an invalid Virtual Unit chain. It frees all the Erase Units in a
 	Virtual Unit Chain, i.e. all the units are disconnected.
 	It is not strictly correct to begin from the first block of the chain because
 	if we stop the code, we may see again a valid chain if there was a first_block
 	flag in a block inside it. But is it really a problem ?
  FixMe: Figure out what the last statement means. What if power failure when we are
 	in the for (;;) loop formatting blocks ??
 cannot format !!!! Mark it as Bad Unit 
 goto next block on the chain 
 check_and_mark_free_block: Verify that a block is free in the NFTL sense (valid erase mark) or
 	totally free (only 0xff).
  Definition: Free Erase Unit -- A properly erasedformatted Free Erase Unit should have meet the
 	following criteria:
 check erase mark. 
		 if no erase mark, the block must be totally free. This is
 free block : write erase mark 
 if erase mark present, need to skip it when doing check 
 check free sector 
 skip erase mark 
 get_fold_mark: Read fold mark from Unit Control Information #2, we use FOLD_MARK_IN_PROGRESS
 	to indicate that we are in the progression of a Virtual Unit Chain folding. If the UCI #2
 	is FOLD_MARK_IN_PROGRESS when mounting the NFTL, the (previous) folding process is interrupted
 	for some reason. A clean upcheck of the VUC is necessary in this case.
  WARNING: return 0 if read error
 search for NFTL MediaHeader and Spare NFTL Media Header 
 init the logical to physical table 
 first pass : explore each block chain 
 if the block was not already explored, we can look at it 
 read the block header. If error, we format the chain 
 invalidfree block test 
 if not currently in a chain, we can handle it safely 
 not really free: format it 
 could not format: reserve the block 
 free block: mark it 
 directly examine the next block. 
						 the block was in a chain : this is bad. We
 we accept only first blocks here 
					 this block is not the first block in chain :
					   ignore it, it will be included in a chain
						 the chain is incorrect : we must format it,
						 we accept that a block is marked as first
						   block while being last block in a chain
							 the chain is incorrect : we must format it,
 no more blocks after 
					 same problem as previous 'is_first_block' test:
					   we accept that the last block of a chain has
					   the first_block flag set if folding is in
					   progress. We handle here the case where the
 EUNtable[] will be set after 
 XXX: should handle correctly fold in progress chains 
 this is OK 
			 the chain was completely explored. Now we can decide
 invalid chain : format it 
 valid chain : get foldmark 
 cannot get foldmark : format the chain 
					 now handle the case where we find two chains at the
					   same virtual address : we select the longer one,
					   because the shorter one is the one which was being
 XXX: what to do if same length ? 
 second pass to format unreferenced blocks  and init free block count 
 SPDX-License-Identifier: GPL-2.0-only
  rfd_ftl.c -- resident flash disk (flash translation layer)
  Copyright  2005  Sean Young <sean@mess.org>
  This type of flash translation layer (FTL) is used by the Embedded BIOS
  by General Software. It is known as the Resident Flash Disk (RFD), see:
 	http:www.gensw.compagesprodbiosrfd.htm
  based on ftl.c
 This major has been assigned by device@lanana.org 
 Maximum number of partitions in an FTL region 
 An erase unit should start with this value 
 the second value is 0xffff or 0xffc8; function unknown 
 the third value is always 0xffff, ignored 
 next is an array of mapping for each corresponding sector 
 size of erase unit 
 number of erase units 
 header sectors in erase unit 
 data sectors in erase unit 
 sectors in translated disk 
 bytes in header sector 
 block next up for reclaim 
 block to write to 
 cached header 
 each erase block has three bytes header, followed by the map 
 already warned about and ignored in build_block_map() 
 we have a race if sync doesn't exist 
 MAX_INT 
		
		  Postpone reclaiming if there is a free sector as
		  more removed sectors is more efficient (have to move
		  less).
 no point in moving a full block 
  IMPROVE: It would be best to choose the block with the most deleted sectors,
  because if we fill that one up first it'll have the most chance of having
  the least live sectors at reclaim.
 This version ported to the Linux-MTD system by dwmw2@infradead.org
  Fixes: Arnaldo Carvalho de Melo <acme@conectiva.com.br>
  - fixes some leaks on failure in build_maps and ftl_notify_add, cleanups
  Based on:
======================================================================
    A Flash Translation Layer memory card driver
    This driver implements a disk-like block device driver with an
    apparent block size of 512 bytes for flash memory cards.
    ftl_cs.c 1.62 20000201 00:59:04
    The contents of this file are subject to the Mozilla Public
    License Version 1.1 (the "License"); you may not use this file
    except in compliance with the License. You may obtain a copy of
    the License at http:www.mozilla.orgMPL
    Software distributed under the License is distributed on an "AS
    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
    implied. See the License for the specific language governing
    rights and limitations under the License.
    The initial developer of the original code is David A. Hinds
    <dahinds@users.sourceforge.net>.  Portions created by David A. Hinds
    are Copyright  1999 David A. Hinds.  All Rights Reserved.
    Alternatively, the contents of this file may be used under the
    terms of the GNU General Public License version 2 (the "GPL"), in
    which case the provisions of the GPL are applicable instead of the
    above.  If you wish to allow the use of your version of this file
    only under the terms of the GPL and not to allow others to use
    your version of this file under the MPL, indicate your decision
    by deleting the provisions above and replace them with the notice
    and other provisions required by the GPL.  If you do not delete
    the provisions above, a recipient may use your version of this
    file under either the MPL or the GPL.
    LEGAL NOTE: The FTL format is patented by M-Systems.  They have
    granted a license for its use with PCMCIA devices:
     "M-Systems grants a royalty-free, non-exclusive license under
      any presently existing M-Systems intellectual property rights
      necessary for the design and development of FTL-compatible
      drivers, file systems and utilities using the data formats with
      PCMCIA PC Cards as described in the PCMCIA Flash Translation
      Layer (FTL) Specification."
    Use of the FTL format for non-PCMCIA applications may be an
    infringement of these patents.  For additional information,
    contact M-Systems directly. M-Systems since acquired by Sandisk. 
#define PSYCHO_DEBUG 
====================================================================
 Parameters that can be set with 'insmod' 
====================================================================
 Major device # for FTL device 
====================================================================
 Maximum number of separate memory devices we'll allow 
 Maximum number of regions per device 
 Maximum number of partitions in an FTL region 
 Maximum number of outstanding erase requests per socket 
 Sector size -- shouldn't need to change 
 Each memory region corresponds to a minor device 
 Partition state flags 
 Transfer unit states 
======================================================================
    Scan_header() checks to see if a memory region contains an FTL
    partition.  build_maps() reads all the erase unit headers, builds
    the erase unit map, and then builds the virtual page map.
 Search first megabyte for a valid FTL header 
 Set up erase unit maps 
 Is this a transfer partition? 
 Pick anything reasonable for the erase count 
 Check for format trouble 
 Set up virtual page map 
 build_maps 
======================================================================
    Erase_xfer() schedules an asynchronous erase operation for a
    transfer unit.
 Is there a free erase slot? Always in MTD. 
 erase_xfer 
======================================================================
    Prepare_xfer() takes a freshly erased transfer unit and gives
    it an appropriate header.
 Write the transfer unit header 
 Write the BAM stub 
 prepare_xfer 
======================================================================
    Copy_erase_unit() takes a full erase block and a transfer unit,
    copies everything to the transfer unit, then swaps the block
    pointers.
    All data blocks are copied to the corresponding blocks in the
    target unit, so the virtual block map does not need to be
    updated.
 Read current BAM 
 mark the cache bad, in case we get an error later 
 Write the LogicalEUN for the transfer unit 
 Bad! 
 Copy all data blocks from source unit to transfer unit 
 This gets updated later 
 All other blocks must be free 
 Write the BAM to the transfer unit 
 All clear? Then update the LogicalEUN again 
 Update the maps and usage stats
 Now, the cache should be valid for the new block 
 copy_erase_unit 
======================================================================
    reclaim_block() picks a full erase unit and a transfer unit and
    then calls copy_erase_unit() to copy one to the other.  Then, it
    schedules an erase on the expired block.
    What's a good way to decide which transfer unit and which erase
    unit to use?  Beats me.  My way is to always pick the transfer
    unit with the fewest erases, and usually pick the data unit with
    the most deleted blocks.  But with a small probability, pick the
    oldest data unit instead.  This means that we generally postpone
    the next reclamation as long as possible, but shuffle static
    stuff around a bit for wear leveling.
 Pick the least erased transfer unit 
 reclaim_block 
======================================================================
    Find_free() searches for a free block.  If necessary, it updates
    the BAM cache for the erase unit containing the free block.  It
    returns the block index -- the erase unit is just the currently
    cached unit.  If there are no free blocks, it returns 0 -- this
    is never a valid data block because it contains the header.
 Find an erase unit with some free space 
 Wrap around at end of table 
 Is this unit's BAM cached? 
 Invalidate cache 
 Find a free block 
 find_free 
======================================================================
    Read a series of sectors from an FTL partition.
 ftl_read 
======================================================================
    Write a series of sectors to an FTL partition
 set_bam_entry 
 See if we need to reclaim space, before we start 
 Grab a free block 
 Tag the BAM entry, and write the new block 
 Only delete the old entry when the new entry is ready 
 Finally, set up the new pointers 
 ftl_write 
 Sort of arbitrary: round size down to 4KiB boundary 
====================================================================
 ftl_freepart 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright  2009 - Maxim Levitsky
  SmartMediaxD translation layer
 ------------------- sysfs attributes ---------------------------------- 
 Initialize sysfs attributes 
 Create array of pointers to the attributes 
 Finally create the attribute group 
 ----------------------- oob helpers -------------------------------------- 
 check fixed bits 
 check parity - endianness doesn't matter 
  Read LBA associated with block
  returns -1, if block is erased
  returns -2 if error happens
 First test for erased block 
 Now check is both copies of the LBA differ too much 
 And read it 
 Make offset from parts 
 Breaks offset into parts 
 ---------------------- low level IO ------------------------------------- 
 Reads a sector + oob
 FTL can contain -1 entries that are by default filled with bits 
 User might not need the oob, but we do for data verification 
		 Avoid infinite recursion on CIS reads, sm_recheck_media
		  won't help anyway
 Test if media is stable 
	 Unfortunately, oob read will _always_ succeed,
	  despite card removal.....
 Test for unknown errors 
 Do a basic test on the oob, to guard against returned garbage 
 This should never happen, unless there is a bug in the mtd driver 
 Test if sector marked as bad 
 Test ECC
 Writes a sector to media 
 Now we assume that hardware will catch write bitflip errors 
 This should never happen, unless there is a bug in the driver 
 ------------------------ block IO ------------------------------------- 
 Write a block using data and lba, and invalid sector bitmap 
 Initialize the oob with requested values 
 If write fails. try to erase the block 
			 This is safe, because we never write in blocks
			  that contain valuable data.
			  This is intended to repair block that are marked
			  as erased, but that isn't fully erased
 Mark whole block at offset 'offs' as bad. 
 We aren't checking the return value, because we don't care 
	 This also fails on fake xD cards, but I guess these won't expose
	  any bad blocks till fail completely
  Erase a block within a zone
  If erase succeeds, it updates free block fifo, otherwise marks block as bad
 Thoroughly test that block is valid. 
 First just check that block doesn't look fishy 
	 Only blocks that are valid or are sliced in two parts, are
	  accepted
 This shouldn't happen anyway 
 If we found three different LBAs, something is fishy 
 If the block is sliced (partially erased usually) erase it 
 ----------------- media scanning --------------------------------- 
 Find out media parameters.
  This ideally has to be based on nand id, but for now device size is enough
 Manual settings for very old devices 
 1 MiB flashrom SmartMedia card (256 byte pages)
 2 MiB flash SmartMedia (256 byte pages)
 2 MiB rom SmartMedia 
 4 MiB flashrom SmartMedia device 
 8 MiB flashrom SmartMedia device 
	 Minimum xD size is 16MiB. Also, all xD cards have standard zone
	  sizes. SmartMedia cards exist up to 128 MiB and have same layout
 Test for proper write,erase and oob sizes 
 We use OOB 
 Find geometry information 
 Validate the CIS 
 Scan the media for the CIS 
 Search for first valid block 
 Search for first valid sector in this block 
 Basic test to determine if underlying mtd device if functional 
 Initialize a FTL zone 
 Allocate memory for FTL table 
 Allocate memory for free sectors FIFO 
 Now scan the zone 
 Skip blocks till the CIS (including) 
 Read the oob of first sector 
		 Test to see if block is erased. It is enough to test
		  first sector, because erase happens in one shot
 If block is marked as bad, skip it 
 This assumes we can trust first sector
		 However the way the block valid status is defined, ensures
		  very low probability of failure here
 Invalid LBA means that block is damaged. 
		 We can try to erase it, or mark it as bad, but
		  lets leave that to recovery application
		 If there is no collision,
		  just put the sector in the FTL table
 Test that this block is valid
 Test now the old block 
		 If both blocks are valid and share same LBA, it means that
		  they hold different versions of same data. It not
		  known which is more recent, thus just erase one of them
	 No free sectors, means that the zone is heavily damaged, write won't
	  work, but it can still can be (partially) read
 Randomize first block we write to 
 Get and automatically initialize an FTL mapping for one zone 
 ----------------- cache handling ------------------------------------------
 Initialize the one block cache 
memset(ftl->cache_data, 0xAA, ftl->block_size);
 Put sector in one block cache 
 Read a sector from the cache 
 Write the cache to hardware 
 Try to read all unread areas of the cache block
 If there are no spare blocks, 
	 we could still continue by erasingwriting the current block,
	  but for such worn out media it doesn't worth the trouble,
	  and the dangers
 Update the FTL table 
 Write succesfull, so erase and free the old block 
 flush timer, runs a second after last write 
 cache flush work, kicked by timer 
 ---------------- outside interface -------------------------------------- 
 outside interface: read a sector 
 Have to look at cache first 
 Translate the block and return if doesn't exist in the table 
 outside interface: write a sector 
 No need in flush thread running now 
 If entry is not in cache, flush it 
 outside interface: flush everything 
 outside interface: device is released 
 outside interface: get geometry 
 external interface: main initialization function 
 Allocate & initialize our private structure 
 Read media information 
 Allocate temporary CIS buffer for read retry support 
 Allocate zone array, it will be initialized on demand 
 Allocate the cache
 Allocate upper layer structure and initialize it 
 Register device
 main interface: device {surprise,} removal 
 SPDX-License-Identifier: GPL-2.0-or-later
  inftlmount.c -- INFTL mount code with extensive checks.
  Author: Greg Ungerer (gerg@snapgear.com)
  Copyright  2002-2003, Greg Ungerer (gerg@snapgear.com)
  Based heavily on the nftlmount.c code which is:
  Author: Fabrice Bellard (fabrice.bellard@netgem.com)
  Copyright  2000 Netgem S.A.
  find_boot_record: Find the INFTL Media Header and its Spare copy which
 	contains the various device information of the INFTL partition and
 	Bad Unit Table. Update the PUtable[] table according to the Bad
 	Unit Table. PUtable[] is used for management of Erase Unit in
 	other routines in inftlcore.c and inftlmount.c.
struct inftl_oob oob;
	  Assume logical EraseSize == physical erasesize for starting the
	  scan. We'll sort it out later if we find a MediaHeader which says
	  otherwise.
 Search for a valid boot record 
		
		  Check for BNAND header first. Then whinge if it's found
		  but later checks fail.
		 We ignore ret in case the ECC of the MediaHeader is invalid
 BNAND\0 not found. Continue 
 To be safer with BIOS, also use erase mark as discriminant 
		
		  This is the first we've seen.
		  Copy the media header structure into place.
 Read the spare media header at offset 4096 
 Check if this one is the same as the first one we found. 
 Scan the partitions 
				
				  	Most likely this is using the
				  	undocumented qiuck mount feature.
				  	We don't support that, we will need
				  	to erase the hidden block for full
				  	compatibility.
		
		  Block count is set to last used EUN (we won't need to keep
		  any meta-data past that point).
 Memory alloc 
 Mark the blocks before INFTL MediaHeader as reserved 
 Mark all remaining blocks as potentially containing data 
 Mark this boot record (NFTL MediaHeader) block as reserved 
 Read Bad Erase Unit Table and modify PUtable[] accordingly 
			 If any of the physical eraseblocks are bad, don't
 Not found. 
  check_free_sector: check if a free sector is actually FREE,
 	i.e. All 0xff in data and oob area.
  INFTL_format: format a Erase Unit by erasing ALL Erase Zones in the Erase
 		 Unit and Update INFTL metadata. Each erase operation is
 		 checked with check_free_sectors.
  Return: 0 when succeed, -1 on error.
  ToDo: 1. Is it necessary to check_free_sector after erasing ??
	 FIXME: Shouldn't we be setting the 'discarded' flag to zero
 Use async erase interface, test return code 
	 Erase one physical eraseblock at a time, even though the NAND api
	   allows us to group them.  This way we if we have a failure, we can
		
		  Check the "freeness" of Erase Unit before updating metadata.
		  FixMe: is this check really necessary? Since we have check
		  the return code after the erase operation.
	 could not format, update the bad block table (caller is responsible
  format_chain: Format an invalid Virtual Unit chain. It frees all the Erase
 	Units in a Virtual Unit Chain, i.e. all the units are disconnected.
 	Since the chain is invalid then we will have to erase it from its
 	head (normally for INFTL we go from the oldest). But if it has a
 	loop then there is no oldest...
			
			  Cannot format !!!! Mark it as Bad Unit,
 Goto next block on the chain 
 Search for INFTL MediaHeader and Spare INFTL Media Header 
 Init the logical to physical table 
 Temporary buffer to store ANAC numbers. 
	
	  First pass is to explore each physical unit, and construct the
	  virtual chains that exist (newest physical unit goes into VUtable).
	  Any block that is in any way invalid will be left in the
	  NOTEXPLORED state. Then at the end we will try to format it and
	  mark it as free.
 Nothing to do here, onto next block 
 Should never happen? 
 Previous block is relative to start of Partition 
 Already explored partial chain? 
 Check if chain for this logical 
 Check for invalid block 
				
				  Assume end of chain, probably incomplete
				  folderase...
 Check for it being free already then... 
 Sanity checks on block numbers 
 Normal for folded chain... 
			
			  Current block is valid, so if we followed a virtual
			  chain to get here then we can set the previous
			  block pointer in our PUtable now. Then move onto
			  the previous block in the chain.
 Check for end of chain 
 Validate next block before following it... 
		
		  Looks like a valid chain then. It may not really be the
		  newest block in the chain, but it is the newest we have
		  found so far. We might update it in later iterations of
		  this loop if we find something newer.
	
	  Second pass, check for infinite loops in chains. These are
	  possible because we don't update the previous pointers when
	  we fold chains. No big deal, just fix them up in PUtable.
 Check for freereservednil 
				
				  Chain must point back to itself. This is ok,
				  but we will need adjust the tables with this
				  newest block and oldest block.
			
			  Uhoo, infinite chain with valid ANACS!
			  Format whole chain...
	
	  Third pass, format unreferenced blocks and init free block count.
 SPDX-License-Identifier: GPL-2.0-only
  Linux driver for SSFDC Flash Translation Layer (Read only)
   2005 Eptar srl
  Author: Claudio Lanconelli <lanconelli.claudio@eptar.com>
  Based on NTFL and MTDBLOCK_RO drivers
 block n. containing CISIDI 
 phys_block_size 
	unsigned short logic_block_map;  all zones (max 8192 phys blocks on
 n. phys_blocks on the card 
 CHS Table
		1MiB	2MiB	4MiB	8MiB	16MiB	32MiB	64MiB	128MiB
NCylinder	125	125	250	250	500	500	500	500
NHead		4	4	4	4	4	8	8	16
NSector		4	8	8	16	16	16	32	32
SumSector	2,000	4,000	8,000	16,000	32,000	64,000	128,000	256,000
SectorSize	512	512	512	512	512	512	512	512
 Must be ordered by size 
 These bytes are the signature for the CISIDI sector 
 Read and check for a valid CIS sector 
	
	  Look for CISIDI sector on the first GOOD block (give up after 4 bad
	  blocks). If the first good block doesn't contain CIS number the flash
	  is not SSFDC formatted
 CIS pattern match on the sector buffer 
 Found 
 Read physical sector (wrapper to MTD_READ) 
 Read redundancy area (wrapper to MTD_READ_OOB 
 Parity calculator on a word of n bit size 
 Read and validate the logical block address field stored in the OOB 
 offset of the 2 address fields within OOB 
	
	  Look for the first valid logical address
	  Valid address has fixed pattern on most significant bits and
	  parity check
 Check for the signature bits in the address field (MSBits) 
 Build the logic block map 
 Scan every physical block, skip CIS block 
 skip bad blocks 
 Skip invalid addresses 
 Check for small page NAND flash 
 Check for SSDFC format by reading CISIDI sector 
 Set geometry 
 Allocate logical block map 
 Build logical block map 
 Register device + partitions 
  Module stuff
 SPDX-License-Identifier: GPL-2.0-or-later
  Linux driver for NAND Flash Translation Layer
  Copyright  1999 Machine Vision Holdings, Inc.
  Copyright  1999-2010 David Woodhouse <dwmw2@infradead.org>
 maximum number of loops while examining next block, to have a
   chance to detect consistency problems (they should never happen
 OK, this is moderately ugly.  But probably safe.  Alternatives? 
 OK, it's a new one. Set up all the data structures. 
 Calculate geometry 
		
		  Oh no we don't have
		   mbd.size == heads  cylinders  sectors
  Read oob data from flash
  Write oob data to flash
  Write data and oob to flash
 Actual NFTL access routines 
 NFTL_findfreeblock: Find a free Erase Unit on the NFTL partition. This function is used
 	when the give Virtual Unit Chain
	 For a given Virtual Unit Chain: find or create a free block and
	 We're passed the number of the last EUN in the chain, to save us from
 Normally, we force a fold to happen before we run out of free blocks completely 
 Scan for a free block 
		 This will probably point to the MediaHdr unit itself,
		   right at the beginning of the partition. But that unit
		   (and the backup unit too) should have the UCI set
	 Scan to find the Erase Unit which holds the actual data for each
	   512-byte block within the Chain.
					 There's no other reason not to do inplace,
					   except ones that come later. So we don't need
		 We're being asked to be a fold-in-place. Check
		   that all blocks which actually have data associated
		   with them (i.e. BlockMap[block] != BLOCK_NIL) are
		   either already present or SECTOR_FREE in the target
		   block. If not, we're going to have to fold out-of-place
		   anyway.
 We need to find a targetEUN to fold into. 
			 Ouch. Now we're screwed. We need to do a
			   fold-in-place of another chain to make room
			   for this one. We need a better way of selecting
			   which chain to fold, because makefreeblock will
			   only ask us to fold the same one again.
		 We put a fold mark in the chain we are folding only if we
               fold in place to help the mount check code. If we do not fold in
               place, it is possible to find the valid chain by selecting the
	 OK. We now know the location of every block in the Virtual Unit Chain,
	   and the Erase Unit into which we are supposed to be copying.
	   Go for it.
 If it's in the target EUN already, or if it's pending write, do nothing 
		 copy only in non free block (free blocks can only
 add the header so that it is now a valid chain 
 OK. We've moved the whole lot into the new block. Now we have to free the original blocks. 
	 At this point, we have two different chains for this Virtual Unit, and no way to tell
	   them apart. If we crash now, we get confused. However, both contain the same data, so we
	   shouldn't actually lose data in this case. It's just that when we load up on a medium which
	   has duplicate chains, we need to free one of the chains because it's not necessary any more.
	 For each block in the old chain (except the targetEUN of course),
			 could not erase : mark block as reserved
 correctly erased : mark it as free 
 Make this the new start of chain for thisVUC 
	 This is the part that needs some cleverness applied.
	   For now, I'm doing the minimum applicable to actually
	   get the thing to work.
	   Wear-levelling and other clever stuff needs to be implemented
	   and we also need to do some assessment of the results when
	   the system loses power half-way through the routine.
printk("VUC %d reaches len %d with EUN %d\n", chain, thislen, EUN);
				 Actually, don't return failure. Just ignore this chain and
printk("New longest chain is %d with length %d\n", chain, thislen);
 NFTL_findwriteunit: Return the unit number into which we can write
                       for this block. Make it available if it isn't already
		 Scan the media to find a unit in the VUC which has
		   a free space for the block in question.
		 This condition catches the 0x[7f]fff cases, as well as
		   being a sanity check for past-end-of-media access
 Invalid block. Don't use it any more. Must implement.
 Skip to next block in chain 
		 OK. We didn't find one in the existing chain, or there
 Try to find an already-free block 
			 That didn't work - there were no free blocks just
			   waiting to be picked up. We're going to have to fold
			   a chain to make room.
 First remember the start of this chain 
u16 startEUN = nftl->EUNtable[thisVUC];
printk("Write to VirtualUnitChain %d, calling makefreeblock()\n", thisVUC);
				 OK, we accept that the above comment is
				   lying - there may have been free blocks
				   last time we called NFTL_findfreeblock(),
				   but they are reserved for when we're
				   desperate. Well, now we're desperate.
				 Ouch. This should never happen - we should
				   always be able to make some room somehow.
				   If we get here, we've allocated more storage
				   space than actual media, or our makefreeblock
				   routine is missing something.
printk("Restarting scan\n");
 We've found a free block. Insert it into the chain. 
 It's a replacement block 
 The first block in a new chain 
 set up the actual EUN we're writing into 
 Both in our cache... 
 ... and on the flash itself 
		 we link the new block to the chain only after the
                   block is ready. It avoids the case where the chain
 Both in our cache... 
 ... and on the flash itself 
 If we _still_ haven't got a block to use, we're screwed 
 CONFIG_NFTL_RW 
 no modification of a sector should follow a free sector 
 the requested block is not on the media, return all 0x00 
  Module stuff
 SPDX-License-Identifier: GPL-2.0-or-later
  Core registration and callback routines for MTD
  drivers and users.
  Copyright  1999-2010 David Woodhouse <dwmw2@infradead.org>
  Copyright  2006      Red Hat UK Limited 
 These are exported solely for the purpose of mtd_blkdevs.c. You
 REVISIT once MTD uses the driver model better, whoever allocates
  the mtd_info will probably want to use the release() hook...
 remove devmtdXro node 
 ecc stats corrected 
 ecc stats errors 
  mtd_wunit_to_pairing_info - get pairing information of a wunit
  @mtd: pointer to new MTD device info structure
  @wunit: write unit we are interested in
  @info: returned pairing information
  Retrieve pairing information associated to the wunit.
  This is mainly useful when dealing with MLCTLC NANDs where pages can be
  paired together, and where programming a page may influence the page it is
  paired with.
  The notion of page is replaced by the term wunit (write-unit) to stay
  consistent with the ->writesize field.
  The @wunit argument can be extracted from an absolute offset using
  mtd_offset_to_wunit(). @info is filled with the pairing information attached
  to @wunit.
  From the pairing info the MTD user can find all the wunits paired with
  @wunit using the following loop:
  for (i = 0; i < mtd_pairing_groups(mtd); i++) {
 	info.pair = i;
 	mtd_pairing_info_to_wunit(mtd, &info);
 	...
  }
  mtd_pairing_info_to_wunit - get wunit from pairing information
  @mtd: pointer to new MTD device info structure
  @info: pairing information struct
  Returns a positive number representing the wunit associated to the info
  struct, or a negative error code.
  This is the reverse of mtd_wunit_to_pairing_info(), and can help one to
  iterate over all wunits of a given pair (see mtd_wunit_to_pairing_info()
  doc).
  It can also be used to only program the first page of each pair (i.e.
  page attached to group 0), which allows one to use an MLC NAND in
  software-emulated SLC mode:
  info.group = 0;
  npairs = mtd_wunit_per_eb(mtd)  mtd_pairing_groups(mtd);
  for (info.pair = 0; info.pair < npairs; info.pair++) {
 	wunit = mtd_pairing_info_to_wunit(mtd, &info);
 	mtd_write(mtd, mtd_wunit_to_offset(mtd, blkoffs, wunit),
 		  mtd->writesize, &retlen, buf + (i  mtd->writesize));
  }
  mtd_pairing_groups - get the number of pairing groups
  @mtd: pointer to new MTD device info structure
  Returns the number of pairing groups.
  This number is usually equal to the number of bits exposed by a single
  cell, and can be used in conjunction with mtd_pairing_info_to_wunit()
  to iterate over all pages of a given pair.
 Just ignore if there is no NVMEM support in the kernel 
 	add_mtd_device - register an MTD device
 	@mtd: pointer to new MTD device info structure
 	Add a device to the list of MTD devices present in the system, and
 	notify each currently active MTD 'user' of its arrival. Returns
 	zero on success or non-zero on failure.
	
	  May occur, for instance, on buggy drivers which call
	  mtd_device_parse_register() multiple times on the same master MTD,
	  especially with CONFIG_MTD_PARTITIONED_MASTER=y.
	
	  MTD drivers should implement ->_{write,read}() or
	  ->_{write,read}_oob(), but not both.
	
	  MTD_SLC_ON_MLC_EMULATION can only be set on partitions, when the
	  master is an MLC NAND and has a proper pairing scheme defined.
	  We also reject masters that implement ->_writev() for now, because
	  NAND controller drivers don't implement this hook, and adding the
	  SLC -> MLC addresslength conversion to this path is useless if we
	  don't have a user.
 default value if not set by driver 
 Some chips always power up locked. Unlock them now 
 Ignore unlock failures? 
	 Caller should have set dev.parent to match the
	  physical device, if appropriate.
 Add the nvmem provider 
	 No need to get a refcount on the module containing
	 We _know_ we aren't being removed, because
	   our caller is still holding us here. So none
	   of this try_ nonsense, and no bitching about it
 	del_mtd_device - unregister an MTD device
 	@mtd: pointer to MTD device info structure
 	Remove a device from the list of MTD devices present in the system,
 	and notify each currently active MTD 'user' of its departure.
 	Returns zero on success or 1 on failure, which currently will happen
 	if the requested device does not appear to be present in the list.
	 No need to get a refcount on the module containing
 Try to remove the NVMEM provider 
  Set a few defaults based on the parent devices, if not provided by the
  driver
 ENODATA means there is no OTP region. 
 DT binding is optional 
 OTP nvmem will be registered on the physical device 
 just reuse the compatible as name 
 Just ignore if there is no NVMEM support in the kernel 
  mtd_device_parse_register - parse partitions and register an MTD device.
  @mtd: the MTD device to register
  @types: the list of MTD partition probes to try, see
          'parse_mtd_partitions()' for more information
  @parser_data: MTD partition parser-specific data
  @parts: fallback partition information to register, if parsing fails;
          only valid if %nr_parts > %0
  @nr_parts: the number of partitions in parts, if zero then the full
             MTD device is registered if no partition info is found
  This function aggregates MTD partitions parsing (done by
  'parse_mtd_partitions()') and MTD device and partitions registering. It
  basically follows the most common pattern found in many MTD drivers:
   If the MTD_PARTITIONED_MASTER option is set, then the device as a whole is
    registered first.
   Then It tries to probe partitions on MTD device @mtd using parsers
    specified in @types (if @types is %NULL, then the default list of parsers
    is used, see 'parse_mtd_partitions()' for more information). If none are
    found this functions tries to fallback to information specified in
    @parts@nr_parts.
   If no partitions were found this function just registers the MTD device
    @mtd and exits.
  Returns zero in case of success and a negative error code in case of failure.
 Prefer parsed partitions over driver-provided fallback 
	
	  FIXME: some drivers unfortunately call this function more than once.
	  So we have to check if we've already assigned the reboot notifier.
	 
	  Generally, we can make multiple calls work for most cases, but it
	  does cause problems with parse_mtd_partitions() above (e.g.,
	  cmdlineparts will register partitions more than once).
  mtd_device_unregister - unregister an existing MTD device.
  @master: the MTD device to unregister.  This will unregister both the master
           and any partitions if registered.
 	register_mtd_user - register a 'user' of MTD devices.
 	@new: pointer to notifier info structure
 	Registers a pair of callbacks function to be called upon addition
 	or removal of MTD devices. Causes the 'add' callback to be immediately
 	invoked for each MTD device currently present in the system.
 	unregister_mtd_user - unregister a 'user' of MTD devices.
 	@old: pointer to notifier info structure
 	Removes a callback function pair from the list of 'users' to be
 	notified upon addition or removal of MTD devices. Causes the
 	'remove' callback to be immediately invoked for each MTD device
 	currently present in the system.
 	get_mtd_device - obtain a validated handle for an MTD device
 	@mtd: last known address of the required MTD device
 	@num: internal device number of the required MTD device
 	Given a number and NULL address, return the num'th entry in the device
 	table, if any.	Given an address and num == -1, search the device table
 	for a device with that address and return if it's still present. Given
 	both, return the num'th driver only if its address matches. Return
 	error code if not.
 	get_mtd_device_nm - obtain a validated handle for an MTD device by
 	device name
 	@name: MTD device name to open
  	This function returns MTD device description structure in case of
  	success and an error code in case of failure.
  Erase is an synchronous operation. Device drivers are epected to return a
  negative error code if the operation failed and update instr->fail_addr
  to point the portion that was not properly erased.
  This stuff for eXecute-In-Place. phys is optional and may be set to NULL.
 We probably shouldn't allow XIP if the unpoint isn't a NULL 
  Allow NOMMU mmap() to directly map the device (if not NULL)
  - return the address to which the offset maps
  - return -ENOSYS to indicate refusal to do the mapping
  In blackbox flight recorder like scenarios we want to make successful writes
  in interrupt context. panic_write() is only intended to be called when its
  known the kernel is about to panic and we need the write to succeed. Since
  the kernel is not going to be running for much longer, this function can
  break locks and delay to ensure the write succeeds (but not sleep).
	
	  Some users are setting ->datbuf or ->oobbuf to NULL, but are leaving
	  ->len or ->ooblen uninitialized. Force ->len and ->ooblen to 0 in
	   this case.
 Check the validity of a potential fallback on mtd->_read 
	
	  In cases where ops->datbuf != NULL, mtd->_read_oob() has semantics
	  similar to mtd->_read(), returning a non-negative integer
	  representing max bitflips. In other cases, mtd->_read_oob() may
	  return -EUCLEAN. In all cases, perform similar logic to mtd_read().
 device lacks ecc 
 Check the validity of a potential fallback on mtd->_write 
  mtd_ooblayout_ecc - Get the OOB region definition of a specific ECC section
  @mtd: MTD device structure
  @section: ECC section. Depending on the layout you may have all the ECC
 	     bytes stored in a single contiguous section, or one section
 	     per ECC chunk (and sometime several sections for a single ECC
 	     ECC chunk)
  @oobecc: OOB region struct filled with the appropriate ECC position
 	    information
  This function returns ECC section information in the OOB area. If you want
  to get all the ECC bytes information, then you should call
  mtd_ooblayout_ecc(mtd, section++, oobecc) until it returns -ERANGE.
  Returns zero on success, a negative error code otherwise.
  mtd_ooblayout_free - Get the OOB region definition of a specific free
 			section
  @mtd: MTD device structure
  @section: Free section you are interested in. Depending on the layout
 	     you may have all the free bytes stored in a single contiguous
 	     section, or one section per ECC chunk plus an extra section
 	     for the remaining bytes (or other funky layout).
  @oobfree: OOB region struct filled with the appropriate free position
 	     information
  This function returns free bytes position in the OOB area. If you want
  to get all the free bytes information, then you should call
  mtd_ooblayout_free(mtd, section++, oobfree) until it returns -ERANGE.
  Returns zero on success, a negative error code otherwise.
  mtd_ooblayout_find_region - Find the region attached to a specific byte
  @mtd: mtd info structure
  @byte: the byte we are searching for
  @sectionp: pointer where the section id will be stored
  @oobregion: used to retrieve the ECC position
  @iter: iterator function. Should be either mtd_ooblayout_free or
 	  mtd_ooblayout_ecc depending on the region type you're searching for
  This function returns the section id and oobregion information of a
  specific byte. For example, say you want to know where the 4th ECC byte is
  stored, you'll use:
  mtd_ooblayout_find_region(mtd, 3, &section, &oobregion, mtd_ooblayout_ecc);
  Returns zero on success, a negative error code otherwise.
	
	  Adjust region info to make it start at the beginning at the
	  'start' ECC byte.
  mtd_ooblayout_find_eccregion - Find the ECC region attached to a specific
 				  ECC byte
  @mtd: mtd info structure
  @eccbyte: the byte we are searching for
  @section: pointer where the section id will be stored
  @oobregion: OOB region information
  Works like mtd_ooblayout_find_region() except it searches for a specific ECC
  byte.
  Returns zero on success, a negative error code otherwise.
  mtd_ooblayout_get_bytes - Extract OOB bytes from the oob buffer
  @mtd: mtd info structure
  @buf: destination buffer to store OOB bytes
  @oobbuf: OOB buffer
  @start: first byte to retrieve
  @nbytes: number of bytes to retrieve
  @iter: section iterator
  Extract bytes attached to a specific category (ECC or free)
  from the OOB buffer and copy them into buf.
  Returns zero on success, a negative error code otherwise.
  mtd_ooblayout_set_bytes - put OOB bytes into the oob buffer
  @mtd: mtd info structure
  @buf: source buffer to get OOB bytes from
  @oobbuf: OOB buffer
  @start: first OOB byte to set
  @nbytes: number of OOB bytes to set
  @iter: section iterator
  Fill the OOB buffer with data provided in buf. The category (ECC or free)
  is selected by passing the appropriate iterator.
  Returns zero on success, a negative error code otherwise.
  mtd_ooblayout_count_bytes - count the number of bytes in a OOB category
  @mtd: mtd info structure
  @iter: category iterator
  Count the number of bytes in a given category.
  Returns a positive value on success, a negative error code otherwise.
  mtd_ooblayout_get_eccbytes - extract ECC bytes from the oob buffer
  @mtd: mtd info structure
  @eccbuf: destination buffer to store ECC bytes
  @oobbuf: OOB buffer
  @start: first ECC byte to retrieve
  @nbytes: number of ECC bytes to retrieve
  Works like mtd_ooblayout_get_bytes(), except it acts on ECC bytes.
  Returns zero on success, a negative error code otherwise.
  mtd_ooblayout_set_eccbytes - set ECC bytes into the oob buffer
  @mtd: mtd info structure
  @eccbuf: source buffer to get ECC bytes from
  @oobbuf: OOB buffer
  @start: first ECC byte to set
  @nbytes: number of ECC bytes to set
  Works like mtd_ooblayout_set_bytes(), except it acts on ECC bytes.
  Returns zero on success, a negative error code otherwise.
  mtd_ooblayout_get_databytes - extract data bytes from the oob buffer
  @mtd: mtd info structure
  @databuf: destination buffer to store ECC bytes
  @oobbuf: OOB buffer
  @start: first ECC byte to retrieve
  @nbytes: number of ECC bytes to retrieve
  Works like mtd_ooblayout_get_bytes(), except it acts on free bytes.
  Returns zero on success, a negative error code otherwise.
  mtd_ooblayout_set_databytes - set data bytes into the oob buffer
  @mtd: mtd info structure
  @databuf: source buffer to get data bytes from
  @oobbuf: OOB buffer
  @start: first ECC byte to set
  @nbytes: number of ECC bytes to set
  Works like mtd_ooblayout_set_bytes(), except it acts on free bytes.
  Returns zero on success, a negative error code otherwise.
  mtd_ooblayout_count_freebytes - count the number of free bytes in OOB
  @mtd: mtd info structure
  Works like mtd_ooblayout_count_bytes(), except it count free bytes.
  Returns zero on success, a negative error code otherwise.
  mtd_ooblayout_count_eccbytes - count the number of ECC bytes in OOB
  @mtd: mtd info structure
  Works like mtd_ooblayout_count_bytes(), except it count ECC bytes.
  Returns zero on success, a negative error code otherwise.
  Method to access the protection register area, present in some flash
  devices. The user data is one time programmable but the factory data is read
  only.
	
	  If no data could be written at all, we are out of memory and
	  must return -ENOSPC.
 Chip-supported device locking 
  default_mtd_writev - the default writev method
  @mtd: mtd device description object pointer
  @vecs: the vectors to write
  @count: count of vectors in @vecs
  @to: the MTD device offset to write to
  @retlen: on exit contains the count of bytes written to the MTD device.
  This function returns zero in case of success and a negative error code in
  case of failure.
  mtd_writev - the vector-based MTD write method
  @mtd: mtd device description object pointer
  @vecs: the vectors to write
  @count: count of vectors in @vecs
  @to: the MTD device offset to write to
  @retlen: on exit contains the count of bytes written to the MTD device.
  This function returns zero in case of success and a negative error code in
  case of failure.
  mtd_kmalloc_up_to - allocate a contiguous buffer up to the specified size
  @mtd: mtd device description object pointer
  @size: a pointer to the ideal or maximum size of the allocation, points
         to the actual allocation size on success.
  This routine attempts to allocate a contiguous kernel buffer up to
  the specified size, backing off the size of the request exponentially
  until the request succeeds or until the allocation size falls below
  the system page size. This attempts to make sure it does not adversely
  impact system performance, so when allocating more than one page, we
  ask the memory allocator to avoid re-trying, swapping, writing back
  or performing IO.
  Note, this function also makes sure that the allocated buffer is aligned to
  the MTD device's min. IO unit, i.e. the "mtd->writesize" value.
  This is called, for example by mtd_{read,write} and jffs2_scan_medium,
  to handle smaller (i.e. degraded) buffer allocations under low- or
  fragmented-memory situations where such reduced allocations, from a
  requested ideal, are allowed.
  Returns a pointer to the allocated buffer on success; otherwise, NULL.
	
	  For the last resort allocation allow 'kmalloc()' to do all sorts of
	  things (write-back, dropping caches, etc) by using GFP_KERNEL.
====================================================================
 Support for procmtd 
 CONFIG_PROC_FS 
====================================================================
 Init code 
	
	  We put '-0' suffix to the name to get the same name format as we
	  used to get. Since this is called only once, we get a unique name. 
 SPDX-License-Identifier: GPL-2.0-or-later
 MTD-based superblock management
  Copyright  2001-2007 Red Hat, Inc. All Rights Reserved.
  Copyright  2001-2010 David Woodhouse <dwmw2@infradead.org>
  Written by:  David Howells <dhowells@redhat.com>
               David Woodhouse <dwmw2@infradead.org>
  compare superblocks to see if they're equivalent
  - they are if the underlying MTD device is the same
  mark the superblock by the MTD device it is using
  - set the device number to be the correct MTD block device for pesuperstence
    of NFS exports
  get a superblock on an MTD-backed filesystem
 new mountpoint for an already mounted superblock 
 fresh new superblock 
  get a superblock on an MTD-backed filesystem by MTD device number
  get_tree_mtd - Get a superblock based on a single MTD device
  @fc: The filesystem context holding the parameters
  @fill_super: Helper to initialise a new superblock
	 the preferred way of mounting in future; especially when
	  CONFIG_BLOCK=n - we specify the underlying MTD device by number or
	  by name, so that we don't require block device support to be present
	  in the kernel.
 mount by MTD device name 
 mount by MTD device number name 
 It was a valid number 
	 try the old way - the hack where we allowed users to mount
	  devmtdblock$(n) but didn't actually _use_ the blockdev
 CONFIG_BLOCK 
  destroy an MTD-based superblock
 SPDX-License-Identifier: GPL-2.0-or-later
  Simple read-only (writable only for RAM) mtdblock driver
  Copyright  2001-2010 David Woodhouse <dwmw2@infradead.org>
 SPDX-License-Identifier: GPL-2.0
 removed bit map 
 used bit map 
	
	  used for panic write
	  As there are no block_isbad for panic case, we should keep this
	  status before panic to ensure panic_write not failed.
 bad block bit map 
  called while removing file
  Avoiding over erasing, do erase block only when the whole block is unused.
  If the block contains valid log, do erase lazily on flush_removed() when
  unregister.
 If the block still has valid data, mtdpstore do erase lazily 
 all zones are unused, erase it 
  What is security for mtdpstore?
  As there is no erase for panic case, we should ensure at least one zone
  is writable. Otherwise, panic write will fail.
  If zone is used, write operation will return -ENOMSG, which means that
  pstoreblk will try one by one until gets an empty zone. So, it is not
  needed to ensure the next zone is empty, but at least one.
 found empty zone 
 If there is no any empty zone, we have no way but to do erase 
 zone is used, please try next one 
  All zones will be read as pstoreblk will read zone one by one when do
  recover.
 the zone may be broken, try next one 
		
		  ECC error. The impact on log data is so small. Maybe we can
		  still read it and try to understand. So mtdpstore just hands
		  over what it gets and user can judge whether the data is
		  valid or not.
 driver may not set retlen when ecc error 
 zone is used, please try next one 
	
	  kmsg_size must be aligned to 4096 Bytes, which is limited by
	  psblk. The default value of kmsg_size is 64KB. If kmsg_size
	  is larger than erasesize, some errors will occur since mtdpsotre
	  is designed on it.
 just support dmesg right now 
 1st. read to cache 
 2nd. erase block 
 3rd. write back 
 there is valid data on block, write back 
  What does mtdpstore_flush_removed() do?
  When user remove any log file on pstore filesystem, mtdpstore should do
  something to ensure log file removed. If the whole block is no longer used,
  it's nice to erase the block. However if the block still contains valid log,
  what mtdpstore can do is to erase and write the valid log back.
 Setup the MTD device to use 
 SPDX-License-Identifier: GPL-2.0-or-later
  Simple MTD partitioning layer
  Copyright  2000 Nicolas Pitre <nico@fluxnic.net>
  Copyright  2002 Thomas Gleixner <gleixner@linutronix.de>
  Copyright  2000-2010 David Woodhouse <dwmw2@infradead.org>
  MTD methods which simply translate the effective address and pass through
  to the _real_ device.
 allocate the partition structure 
 set up the MTD object for this partition 
	 NOTE: Historically, we didn't arrange MTDs as a tree out of
	  concern for showing the same data in multiple partitions.
	  However, it is very useful to have the master node present,
	  so the MTD_PARTITIONED_MASTER option allows that. The master
	  will have device nodes etc only if this is set, so make the
	  parent conditional on that option. Note, this is a way to
	  distinguish between the parent and its partitions in sysfs.
 register to preserve ordering 
 let's do some sanity checks 
 let's register it anyway to preserve ordering 
 Initialize ->erasesize to make add_mtd_device() happy. 
 Deal with variable erase size stuff 
		 Find the first erase regions which is part of this
 The loop searched for the region _behind_ the first one 
 Pick biggest erasesize 
 Single erase size 
	
	  Child erasesize might differ from the parent one if the parent
	  exposes several regions with different erasesize. Adjust
	  wr_alignment accordingly.
 Doesn't start on a boundary of major erase size 
		 FIXME: Let it be writable if it is on a boundary of
 mtd partition offset 
 the direct offset is expected 
  __mtd_del_partition - delete MTD partition
  @mtd: MTD structure to be deleted
  This function must be called with the partitions mutex locked.
  This function unregisters and destroy all slave MTD objects which are
  attached to the given MTD object, recursively.
  This function, given a parent MTD object and a partition table, creates
  and registers the child MTD objects which are bound to the parent according
  to the partition definitions.
  For historical reasons, this function's caller only registers the parent
  if the MTD_PARTITIONED_MASTER config option is set.
 Look for subpartitions 
  Many partition parsers just expected the core to kfree() all their data in
  one chunk. Do that by default.
  Do not forget to update 'parse_mtd_partitions()' kerneldoc comment if you
  are changing this array!
 Check DT only when looking for subpartitions. 
  mtd_part_get_compatible_parser - find MTD parser by a compatible string
  @compat: compatible string describing partitions in a device tree
  MTD parsers can specify supported partitions by providing a table of
  compatibility strings. This function finds a parser that advertises support
  for a passed value of "compatible".
	
	  For backward compatibility we have to try the "fixed-partitions"
	  parser. It supports old DT format with partitions specified as a
	  direct subnodes of a flash device DT node without any compatibility
	  specified we could match.
  parse_mtd_partitions - parse and register MTD partitions
  @master: the master partition (describes whole MTD device)
  @types: names of partition parsers to try or %NULL
  @data: MTD partition parser-specific data
  This function tries to find & register partitions on MTD device @master. It
  uses MTD partition parsers, specified in @types. However, if @types is %NULL,
  then the default list of parsers is used. The default list contains only the
  "cmdlinepart" and "ofpart" parsers ATM.
  Note: If there are more then one parser in @types, the kernel only takes the
  partitions parsed out by the first parser.
  This function may return:
  o a negative error code in case of failure
  o number of found partitions otherwise
		
		  ofpart is a special type that means OF partitioning info
		  should be used. It requires a bit different logic so it is
		  handled in a separated function.
 Found partitions! 
		
		  Stash the first error we see; only report it if no parser
		  succeeds
 Returns the size of the entire flash chip 
 SPDX-License-Identifier: GPL-2.0-or-later
  Interface to Linux block layer for MTD 'translation layers'.
  Copyright  2003-2010 David Woodhouse <dwmw2@infradead.org>
				
				  Do background processing just once per idle
				  period.
 Use first free number 
 Found a free devnum. Plug it in here 
 Required number taken 
 Required number was free 
	 Check that the device and any partitions will get valid
	  minor numbers and that the disk naming code below can cope
 Create gendisk 
 Create the request queue 
 Stop new requests to arrive 
 Kill current requests 
 freeze+quiesce queue to ensure all requests are flushed 
	 If the device is currently open, tell trans driver to close it,
	 Register the notifier ifwhen the first device type is
	   registered, to prevent the linkinit ordering from fucking
 Remove it from the list of active majors 
	 No race here -- if someone's currently in register_mtd_blktrans
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2019 Texas Instruments Incorporated - https:
 Author: Vignesh Raghavendra <vigneshr@ti.com>
 end of table  }
 SPDX-License-Identifier: GPL-2.0
  Linux driver for RPC-IF HyperFlash
  Copyright (C) 2019-2020 Cogent Embedded, Inc.
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2019 Texas Instruments Incorporated - https:
 Author: Vignesh Raghavendra <vigneshr@ti.com>
  Common Flash Interface support:
    ST Advanced Architecture Command Set (ID 0x0020)
  (C) 2000 Red Hat. GPL'd
  10102000	Nicolas Pitre <nico@fluxnic.net>
  	- completely revamped method functions so they are aware and
  	  independent of the flash geometry (buswidth, interleave, etc.)
  	- scalability vs code size is completely set at compile-time
  	  (see includelinuxmtdcfi.h for selection)
 	- optimized write buffer method
  06212002	Joern Engel <joern@wh.fh-wedel.de> and others
 	- modified Intel Command Set 0x0001 to support ST Advanced Architecture
 	  (command set 0x0020)
 	- added a writev function
  07132005	Joern Engel <joern@wh.fh-wedel.de>
  	- Plugged memory leak in cfi_staa_writev().
 Not usable directly 
 #define DEBUG_LOCK_BITS 
#define DEBUG_CFI_FEATURES
 This routine is made available to other mtd code via
  inter_module_register.  It must only be accessed through
  inter_module_get which will bump the use count of this module.  The
  addresses passed back in cfi are valid as long as the use count of
  this module is non-zero, i.e. between inter_module_get and
  inter_module_put.  Keith Owens <kaos@ocs.com.au> 29 Oct 2000.
		
		  It's a real CFI chip, not one for which the probe
		  routine faked a CFI structure. So we read the feature
		  table from it.
 Do some byteswapping if necessary 
 Tell the user about it in lots of lovely detail 
 Install our own private info structure 
printk(KERN_DEBUG "number of CFI chips: %d\n", cfi->numchips);
 Argh 
 Also select the correct geometry setup too 
 FIXME: Should be 0 for STMicro flashes wout ECC 
 Ensure cmd readwrites are aligned. 
 Let's determine this according to the interleave only once 
	 Check that the chip's ready to talk to us.
	  If it's in FL_ERASING state, suspend it and make it talk now.
 We don't support erase suspend 
		 If the flash has finished erasing, then 'erase suspend'
		  appears to make some (28F320) flash devices switch to
		  'read' mode.  Make sure that we switch to 'read status'
		  mode so we get the right data. --rmk
		printk("Erase suspending at 0x%lx\n", cmd_addr);
 Urgh 
 make sure we're in 'read status' mode 
 Not quite yet 
 Urgh. Chip not yet ready to talk to us. 
 Latency issues. Drop the lock, wait a while and retry 
		 Stick ourselves on a wait queue to be woken when
		 What if one interleaved chip has finished and the
		   other hasn't? The old code would leave the finished
		   one in READY mode. That's bad, and caused -EROFS
		   errors to be returned from do_erase_oneblock because
		   that's the only bit it checked for at the time.
		   As the state machine appears to explicitly allow
		   sending the 0x70 (Read Status) command to an erasing
		   chip and expecting it to be ignored, that's what we
 ofs: offset within the first chip that the first read should start 
 M58LW064A requires bus alignment for buffer wriets -- saw 
 Let's determine this according to the interleave only once 
	 Check that the chip's ready to talk to us.
	  Later, we can actually think about interrupting it
	  if it's in FL_ERASING state.
	  Not just yet, though.
 Urgh. Chip not yet ready to talk to us. 
 Latency issues. Drop the lock, wait a while and retry 
		 Stick ourselves on a wait queue to be woken when
 Argh. Not ready for write to buffer 
 Write length of data to come 
 Write data 
 GO GO GO 
 Someone's suspended the write. Sleep 
 FIXME 
 OK Still waiting 
 clear status 
 put back into read status register mode 
 Latency issues. Drop the lock, wait a while and retry 
 Done and happy. 
 check for errors: 'lock bit', 'VPP', 'dead cell''unerased cell' or 'incorrect cmd' -- saw 
 clear status 
 put back into read status register mode 
 Write buffer is worth it only if more than one word to write... 
 We must not cross write block boundaries 
  Writev for ECC-Flashes is a little more complicated. We need to maintain
  a small buffer for this.
  XXX: If the buffer size is not a multiple of 2, this will break
		 We should fall back to a general writev implementation.
		  Until that is written, just break.
 FIXME: Might be unnecessary. Check that 
 cut off head 
 just accumulate 
 write clean aligned data 
 cut off tail 
 flush last page, even if not full 
 This is sometimes intended behaviour, really 
 Let's determine this according to the interleave only once 
 Check that the chip's ready to talk to us. 
 Urgh. Chip not yet ready to talk to us. 
 Latency issues. Drop the lock, wait a while and retry 
		 Stick ourselves on a wait queue to be woken when
 Clear the status register first 
 Now erase 
 FIXME. Use a timer to check this, and return immediately. 
 Once the state machine's known to be working I'll do that 
 Someone's suspended the erase. Sleep 
 FIXME 
 OK Still waiting 
 Latency issues. Drop the lock, wait a while and retry 
 We've broken this before. It doesn't hurt to be safe 
 check for lock bit 
 Reset the error bits 
 Protection bit set 
 Voltage 
	 Check that both start and end of the requested erase are
	  aligned with the erasesize at the appropriate addresses.
	 Skip all erase regions which are ended before the start of
	   the requested erase. Actually, to save on the calculations,
	   we skip to the first erase region which starts after the
	   start of the requested erase, and then go back one.
	 OK, now i is pointing at the erase region in which this
	   erase request starts. Check the start of the requested
	   erase range is aligned with the erase size which is in
	   effect here.
 Remember the erase region we start on 
	 Next, check that the end of the requested erase is aligned
	  with the erase region at that address.
	 As before, drop back one to point at the region in which
	   the address actually falls
			 No need to wake_up() on this state change -
			  as the whole point is that nobody can do anything
			  with the chip now anyway.
 Not an idle state 
 Unlock the chips again 
 Let's determine this according to the interleave only once 
 Check that the chip's ready to talk to us. 
 Urgh. Chip not yet ready to talk to us. 
 Latency issues. Drop the lock, wait a while and retry 
		 Stick ourselves on a wait queue to be woken when
 FIXME. Use a timer to check this, and return immediately. 
 Once the state machine's known to be working I'll do that 
 OK Still waiting 
 Latency issues. Drop the lock, wait a while and retry 
 Done and happy. 
 Let's determine this according to the interleave only once 
 Check that the chip's ready to talk to us. 
 Urgh. Chip not yet ready to talk to us. 
 Latency issues. Drop the lock, wait a while and retry 
		 Stick ourselves on a wait queue to be woken when
 FIXME. Use a timer to check this, and return immediately. 
 Once the state machine's known to be working I'll do that 
 OK Still waiting 
 Latency issues. Drop the unlock, wait a while and retry 
 Done and happy. 
			 No need to wake_up() on this state change -
			  as the whole point is that nobody can do anything
			  with the chip now anyway.
 Unlock the chips again 
				 No need to force it into a known state here,
				   because we're returning failure, and it didn't
 Go to known state. Chip may have been power cycled 
  Common Flash Interface support:
    Intel Extended Vendor Command Set (ID 0x0001)
  (C) 2000 Red Hat. GPL'd
  10102000	Nicolas Pitre <nico@fluxnic.net>
  	- completely revamped method functions so they are aware and
  	  independent of the flash geometry (buswidth, interleave, etc.)
  	- scalability vs code size is completely set at compile-time
  	  (see includelinuxmtdcfi.h for selection)
 	- optimized write buffer method
  02052002	Christopher Hoover <ch@hpl.hp.com><ch@murgatroid.com>
 	- reworked lockunlockerase support for var size flash
  21032007   Rodolfo Giometti <giometti@linux.it>
  	- auto unlock sectors on resume for auto locking flash on power up
 #define CMDSET0001_DISABLE_ERASE_SUSPEND_ON_WRITE 
 #define CMDSET0001_DISABLE_WRITE_SUSPEND 
 debugging, turns off buffer write mode if set to 1
 Intel chips 
 STMicroelectronics chips 
 Atmel chips 
 Sharp chips 
    SETUP AND PROBE BITS  
 Not usable directly 
 #define DEBUG_LOCK_BITS 
 #define DEBUG_CFI_FEATURES 
 Atmel chips don't use the same PRI format as Intel chips 
 Reverse byteswapping 
 chip erase supported 
 erase suspend supported 
 program suspend supported 
 simultaneous operations supported 
 page mode read supported 
 queued erase supported 
 Protection bits supported 
 burst write mode not supported 
 Some Intel Strata Flash prior to FPO revision C has bugs in this area 
 Not supported 
 Not supported 
 Note this is done after the region info is endian swapped 
 Sharp LH28F640BF Family 
	 Reset the Partition Configuration Register on LH28F640BF
		 We have set one single partition thus
  Some chips power-up with all sectors locked by default.
 M28W320CT  fixup_st_m28w320ct },
 M28W320CB  fixup_st_m28w320cb },
	 The CFI vendor ids and the JEDEC vendor IDs appear
	  to be common.  It is like the devices id's are as
	  well.  This table is to pick all cases where
	  we know that is the case.
	
	  Micron(was Numonyx) 1Gbit bottom boot are buggy w.r.t
	  Erase Supend for their small Erase Blocks(0x8000)
 Do some byteswapping if necessary 
 Protection Register info 
 Burst Read info 
 Number of hardware-partitions 
 skip the sizeof(partregion) field in CFI 1.4 
 Fill in the default mtd operations 
		
		  It's a real CFI chip, not one for which the probe
		  routine faked a CFI structure. So we read the feature
		  table from it.
 Install our own private info structure 
 Tell the user about it in lots of lovely detail 
 Apply jedec specific fixups 
 Apply generic fixups 
 No default; if it isn't specified, we won't use it 
printk(KERN_DEBUG "number of CFI chips: %d\n", cfi->numchips);
 Argh 
	 This function has the potential to distort the reality
	
	  Probing of multi-partition flash chips.
	 
	  To support multiple partitions when available, we simply arrange
	  for each of them to have their own flchip structure even if they
	  are on the same physical chip.  This means completely recreating
	  a new cfi_private structure right here which is a blatent code
	  layering violation, but this is still the least intrusive
	  arrangement at this point. This can be rearranged in the future
	  if someone feels motivated enough.  --nico
 Protection Register info 
 Burst Read info 
 Number of partition regions 
 skip the sizeof(partregion) field in CFI 1.4 
 Number of hardware partitions 
 Programming Region info 
		
		  All functions below currently rely on all chips having
		  the same geometry so we'll just assume that all hardware
		  partitions are of the same size too.
				 those should be reset too since
    CHIP ACCESS FUNCTIONS 
 Prevent setting state FL_SYNCING for chip in suspended state. 
			 At this point we're fine with write operations
 Someone else might have been playing with it. 
 Do not allow suspend iff readwrite to EB address 
 do not suspend small EBs, buggy Micron Chips 
 Erase suspend 
		 If the flash has finished erasing, then 'erase suspend'
		  appears to make some (28F320) flash devices switch to
		  'read' mode.  Make sure that we switch to 'read status'
		  mode so we get the right data. --rmk
				 Urgh. Resume and pretend we weren't here.
			 Nobody will touch it while it's in state FL_ERASE_SUSPENDING.
 The machine is rebooting now,so no one can get chip anymore 
 Only if there's no operation suspended... 
		
		  OK. We have possibility for contention on the writeerase
		  operations which are global to the real chip and not per
		  partition.  So let's fight it over in the partition which
		  currently has authority on the operation.
		 
		  The rules are as follows:
		 
		  - any write operation must own shared->writing.
		 
		  - any erase operation must own _both_ shared->writing and
		    shared->erasing.
		 
		  - contention arbitration is handled in the owner's context.
		 
		  The 'shared' struct can be read andor written only when
		  its lock is taken.
			
			  The engine to perform desired operation on this
			  partition is already in use by someone else.
			  Let's fight over it in the context of the chip
			  currently using it.  If it is possible to suspend,
			  that other partition will do just that, otherwise
			  it'll happily send us to sleep.  In any case, when
			  get_chip returns success we're clear to go ahead.
			 We should not own chip if it is already
		 Check if we already have suspended erase
 We now own it 
 We own the ability to write, but we're done 
 give back ownership to who we loaned it from 
			
			  We own the ability to erase without the ability
			  to write, which means the erase was suspended
			  and some other partition is currently writing.
			  Don't let the switch below mess things up since
			  we don't have ownership to resume anything.
		 What if one interleaved chip has finished and the
		   other hasn't? The old code would leave the finished
		   one in READY mode. That's bad, and caused -EROFS
		   errors to be returned from do_erase_oneblock because
		   that's the only bit it checked for at the time.
		   As the state machine appears to explicitly allow
		   sending the 0x70 (Read Status) command to an erasing
		   chip and expecting it to be ignored, that's what we
  No interrupt what so ever can be serviced while the flash isn't in array
  mode.  This is ensured by the xip_disable() and xip_enable() functions
  enclosing any code path where the flash is known not to be in array mode.
  And within a XIP disabled code path, only functions marked with __xipram
  may be called and nothing else (it's a good thing to inspect generated
  assembly to make sure inline functions were actually inlined and that gcc
  didn't emit calls to its own support functions). Also configuring MTD CFI
  support to a single buswidth and a single interleave is also recommended.
 TODO: chips with no XIP use should ignore and return 
 ensure mmu mapping is up to date 
  When a delay is required for the flash operation to complete, the
  xip_wait_for_operation() function is polling for both the given timeout
  and pending (but still masked) hardware interrupts.  Whenever there is an
  interrupt pending then the flash erase or write operation is suspended,
  array mode restored and interrupts unmasked.  Task scheduling might also
  happen at that point.  The CPU eventually returns from the interrupt or
  the call to schedule() and the suspended flash operation is resumed for
  the remaining of the delay period.
  Warning: this function _will_ fool interrupt latency tracing tools.
			
			  Let's suspend the erase or write operation when
			  supported.  Note that we currently don't try to
			  suspend interleaved chips if there is already
			  another operation suspended (imagine what happens
			  when one chip was already done with the current
			  operation while another chip suspended it, then
			  we resume the whole thing at once).  Yes, it
			  can happen!
					
					  The chip doesn't want to suspend
					  after waiting for 100 msecs.
					  This is a critical error but there
					  is not much we can do here.
 Suspend succeeded 
			
			  We're back.  However someone else might have
			  decided to go write to the chip if we are in
			  a suspended erase state.  If so let's wait
			  until it's done.
 Disallow XIP again 
 Resume the write or erase operation 
			
			  Try to save on CPU power when waiting delay
			  is at least a system timer tick period.
			  No need to be extremely accurate here.
  The INVALIDATE_CACHED_RANGE() macro is normally used in parallel while
  the flash is actively programming or erasing since we have to poll for
  the operation to complete anyway.  We can't do that in a generic way with
  a XIP setup so do it before the actual flash operation in this case
  and stub it out from INVAL_CACHE_AND_WAIT.
 Someone's suspended the operation: sleep 
 Erase suspend occurred while sleep: reset timeout 
 Write suspend occurred while sleep: reset timeout 
 OK Still waiting. Drop the lock, wait a while and retry. 
			
			  Half of the normal delay still remaining
			  can be performed with a sleeping delay instead
			  of busy waiting.
 Done and happy. 
 Ensure cmd readwrites are aligned. 
 Now lock the chip(s) to POINT state 
 ofs: offset within the first chip that the first read should start 
 We cannot point across chips that are virtually disjoint 
 Now unlock the chip(s) POINT state 
 ofs: offset within the first chip that the first read should start 
 Ensure cmd readwrites are aligned. 
 ofs: offset within the first chip that the first read should start 
 check for errors 
 reset status 
 If it's not bus-aligned, do the first byte write 
	 Sharp LH28F640BF chips need the first address for the
	  Page Buffer Program command. See Table 5 of
 Let's determine this according to the interleave only once 
	 4.8 of the 28FxxxJ3A datasheet says "Any time SR.4 andor SR.5 is set
	   [...], the device will not accept any more Write to Buffer commands".
	   So we must check here and reset those bits if they're set. Otherwise
 Argh. Not ready for write to buffer 
 Figure out the number of words to write 
 Write length of data to come 
 Write data 
 GO GO GO 
 check for errors 
 reset status 
 We must not cross write block boundaries 
		 Be nice and reschedule with the chip in a usable state for other
 Clear the status register first 
 Now erase 
 We've broken this before. It doesn't hurt to be safe 
 check for errors 
 Reset the error bits 
 Protection bit set 
 Voltage 
			 No need to wake_up() on this state change -
			  as the whole point is that nobody can do anything
			  with the chip now anyway.
 Unlock the chips again 
	
	  If Instant Individual Block Locking supported then no need
	  to delay.
	
	  Unlocking may take up to 1.4 seconds on some Intel flashes. So
	  lets use a max of 1.5 seconds (1500ms) as timeout.
	 
	  See "Clear Block Lock-Bits Time" on page 40 in
	  "3 Volt Intel StrataFlash Memory" 28F128J3,28F640J3,28F320J3 manual
	  from February 2003
 let's ensure we're not reading back cached data from array mode 
 then ensure we don't keep OTP data in the cache 
 make sure area matches group boundaries 
 Check that we actually have some OTP registers 
 we need real chips here not virtual ones 
	 Some chips have OTP located in the _top_ partition only.
 first OTP region 
 flash geometry fixup 
 skip over factory reg area 
					
					  Special case: if action is NULL
					  we fill buf with otp_info records.
 next OTP region 
 place the chip in a known state before suspend 
				 No need to wake_up() on this state change -
				  as the whole point is that nobody can do anything
				  with the chip now anyway.
 There seems to be an operation pending. We must wait for it. 
			 Should we actually wait? Once upon a time these routines weren't
			   allowed to. Or should we return -EAGAIN, because the upper layers
			   ought to have already shut down anything which was using the device
 Unlock the chips again 
				 No need to force it into a known state here,
				   because we're returning failure, and it didn't
 Go to known state. Chip may have been power cycled 
 Refresh LH28F640BF Partition Config. Register 
		 force the completion of any ongoing operation
		   and switch to array mode so any bootloader in
  Common code to handle map devices which are simple RAM
  (C) 2000 Red Hat. GPL'd.
 Check the first byte is RAM 
 Check the last byte is RAM 
 OK. It seems to be RAM. 
	 Yeah, it's inefficient. Who cares? It's faster than a _real_
 Nothing to see here 
  Common Flash Interface support:
    AMD & Fujitsu Standard Vendor Command Set (ID 0x0002)
  Copyright (C) 2000 Crossnet Co. <info@crossnet.co.jp>
  Copyright (C) 2004 Arcom Control Systems Ltd <linux@arcom.com>
  Copyright (C) 2005 MontaVista Software Inc. <source@mvista.com>
  2_by_8 routines added by Simon Munton
  4_by_16 work by Carolyn J. Smith
  XIP support hooks by Vitaly Wool (based on code for Intel flash
  by Nicolas Pitre)
  25092008 Christopher Moore: TopBottom fixup for many Macronix with CFI V1.0
  Occasionally maintained by Thayne Harbaugh tharbaugh at lnxi dot com
  This code is GPL
  Status Register bit description. Used by flash devices that don't
  support DQ polling (e.g. HyperFlash)
 Not usable directly 
  Use status register to poll for Erasewrite completion when DQ is not
  supported. This is indicated by Bit[1:0] of SoftwareFeatures field in
  CFI Primary Vendor-Specific Extended Query table 1.5
 The error bits are invalid while the chip's busy 
 EraseProgram status bits are set on the operation failure 
 #define DEBUG_CFI_FEATURES 
 Wheee. Bring me the head of someone at AMD. 
 CFI version 1.0 => don't trust bootloc 
		 AFAICS all 29LV400 with a bottom boot block have a device ID
		  of 0x22BA in 16-bit mode and 0xBA in 8-bit mode.
		  These were badly detected as they have the 0x80 bit set
		  so treat them as a special case.
			 Macronix added CFI to their 2nd generation
			  MX29LV400C BT but AFAICS no other 29LV400 (AMD,
			  Fujitsu, Spansion, EON, ESI and older Macronix)
			  has CFI.
			 
			  Therefore also check the manufacturer.
			  This reduces the risk of false detection due to
			  the 8-bit device ID.
 bottom boot 
 top boot 
 bottom boot 
 !FORCE_WORD_WRITE 
 Atmel chips don't use the same PRI format as AMD chips 
 Some chips got it backwards... 
 burst write mode not supported 
 Setup for chips with a secsi area 
  Some Atmel chips (e.g. the AT49BV6416) power-up with all sectors
  locked by default.
	
	  These flashes report two separate eraseblock regions based on the
	  sector_erase-size and block_erase-size, although they both operate on the
	  same memory. This is not allowed according to CFI, so we just pick the
	  sector_erase-size.
	
	  CFI reports 1024 sectors (0x03ff+1) of 64KBytes (0x0100256) where
	  it should report a size of 8KBytes (0x0020256).
	
	   S29NS512P flash uses more than 8bits to report number of sectors,
	  which is not permitted by CFI.
 Used to fix CFI-Tables of chips without Extended Query Tables 
 SST39VF1602 
 SST39VF1601 
 SST39VF3202 
 SST39VF3201 
 SST39VF3202B 
 SST39VF3201B 
 SST39VF6402B 
 SST39VF6401B 
 SST38VF6402 
 SST38VF6401 
 SST38VF6404 
 SST38VF6403 
	 The CFI vendor ids and the JEDEC vendor IDs appear
	  to be common.  It is like the devices id's are as
	  well.  This table is to pick all cases where
	  we know that is the case.
			
			  Samsung K8P2815UQB and K8D6x16UxM chips
			  report major=0  minor=0.
			  K8D3x16UxC chips report major=3  minor=3.
	
	  SST 38VF640x chips report major=0xFF  minor=0xFF.
  From TN-13-07: Patching the Linux Kernel and U-Boot for M29 Flash, page 20:
  Some revisions of the M29EW suffer from erase suspend hang ups. In
  particular, it can occur when the sequence
  Erase Confirm -> Suspend -> Program -> Resume
  causes a lockup due to internal timing issues. The consequence is that the
  erase cannot be resumed without inserting a dummy command after programming
  and prior to resuming. [...] The work-around is to issue a dummy write cycle
  that writes an F0 command code before the RESUME command.
 before resume, insert a dummy 0xF0 cycle for Micron M29EW devices 
  From TN-13-07: Patching the Linux Kernel and U-Boot for M29 Flash, page 22:
  Some revisions of the M29EW (for example, A1 and A2 step revisions)
  are affected by a problem that could cause a hang up when an ERASE SUSPEND
  command is issued after an ERASE RESUME operation without waiting for a
  minimum delay.  The result is that once the ERASE seems to be completed
  (no bits are toggling), the contents of the Flash memory block on which
  the erase was ongoing could be inconsistent with the expected values
  (typically, the array value is stuck to the 0xC0, 0xC4, 0x80, or 0x84
  values), causing a consequent failure of the ERASE operation.
  The occurrence of this issue could be high, especially when file system
  operations on the Flash are intensive.  As a result, it is recommended
  that a patch be applied.  Intensive file system operations can cause many
  calls to the garbage routine to free Flash space (also by erasing physical
  Flash blocks) and as a result, many consecutive SUSPEND and RESUME
  commands can occur.  The problem disappears when a delay is inserted after
  the RESUME command by using the udelay() function available in Linux.
  The DELAY value must be tuned based on the customer's platform.
  The maximum value that fixes the problem in all cases is 500us.
  But, in our experience, a delay of 30 s to 50 s is sufficient
  in most cases.
  We have chosen 500s because this latency is acceptable.
	
	  Resolving the Delay After Resume Issue see Micron TN-13-07
	  Worst case delay must be 500s but 30-50s should be ok as well
 Fill in the default mtd operations 
			
			  It's a real CFI chip, not one for which the probe
			  routine faked a CFI structure.
			
			  Valid primary extension versions are: 1.0, 1.1, 1.2, 1.3, 1.4, 1.5
			  see: http:cs.ozerki.netzappubaxim-x5docscfi_r20.pdf, page 19 
			       http:www.spansion.comSupportAppNotescfi_100_20011201.pdf
			       http:www.spansion.comSupportDatasheetss29ws-p_00_a12_e.pdf
			       http:www.spansion.comSupportDatasheetsS29GL_128S_01GS_00_02_e.pdf
 Install our own private info structure 
 Apply cfi device specific fixups 
 Tell the user about it in lots of lovely detail 
 Set the default CFI lockunlock addresses 
 CFI mode 
 Apply jedec specific fixups 
 Apply generic fixups 
		
		  First calculate the timeout max according to timeout field
		  of struct cfi_ident that probed from chip's CFI aera, if
		  available. Specify a minimum of 2000us, in case the CFI data
		  is wrong.
 Select the correct geometry setup 
 Argh 
  Return true if the chip is ready.
  Ready is one of: read mode, query mode, erase-suspend-read mode (in any
  non-suspended sector) and is indicated by no toggle bits toggling.
  Note that anything more complicated than checking if no bits are toggling
  (including checking DQ5 for an error status) is tricky to get working
  correctly and is therefore not done	(particularly with interleaved chips
  as each chip must be checked independently of the others).
		
		  For chips that support status register, check device
		  ready bit
  Return true if the chip is ready and has the correct value.
  Ready is one of: read mode, query mode, erase-suspend-read mode (in any
  non-suspended sector) and it is indicated by no bits toggling.
  Error are indicated by toggling bits or bits held with the wrong value,
  or with bits toggling.
  Note that anything more complicated than checking if no bits are toggling
  (including checking DQ5 for an error status) is tricky to get working
  correctly and is therefore not done	(particularly with interleaved chips
  as each chip must be checked independently of the others).
		
		  For chips that support status register, check device
		  ready bit
 Someone else might have been playing with it. 
 Do not allow suspend iff readwrite to EB address 
 Erase suspend 
		 It's harmless to issue the Erase-Suspend and Erase-Resume
				 Should have suspended the erase by now.
				  Send an Erase-Resume command as either
				  there was an error (so leave the erase
				  routine to recover from it) or we trying to
			 Nobody will touch it while it's in state FL_ERASE_SUSPENDING.
 The machine is rebooting 
 Only if there's no operation suspended... 
  No interrupt what so ever can be serviced while the flash isn't in array
  mode.  This is ensured by the xip_disable() and xip_enable() functions
  enclosing any code path where the flash is known not to be in array mode.
  And within a XIP disabled code path, only functions marked with __xipram
  may be called and nothing else (it's a good thing to inspect generated
  assembly to make sure inline functions were actually inlined and that gcc
  didn't emit calls to its own support functions). Also configuring MTD CFI
  support to a single buswidth and a single interleave is also recommended.
 TODO: chips with no XIP use should ignore and return 
 ensure mmu mapping is up to date 
  When a delay is required for the flash operation to complete, the
  xip_udelay() function is polling for both the given timeout and pending
  (but still masked) hardware interrupts.  Whenever there is an interrupt
  pending then the flash erase operation is suspended, array mode restored
  and interrupts unmasked.  Task scheduling might also happen at that
  point.  The CPU eventually returns from the interrupt or the call to
  schedule() and the suspended flash operation is resumed for the remaining
  of the delay period.
  Warning: this function _will_ fool interrupt latency tracing tools.
			
			  Let's suspend the erase operation when supported.
			  Note that we currently don't try to suspend
			  interleaved chips if there is already another
			  operation suspended (imagine what happens
			  when one chip was already done with the current
			  operation while another chip suspended it, then
			  we resume the whole thing at once).  Yes, it
			  can happen!
					
					  The chip doesn't want to suspend
					  after waiting for 100 msecs.
					  This is a critical error but there
					  is not much we can do here.
 Suspend succeeded 
			
			  We're back.  However someone else might have
			  decided to go write to the chip if we are in
			  a suspended erase state.  If so let's wait
			  until it's done.
 Disallow XIP again 
 Correct Erase Suspend Hangups for M29EW 
 Resume the write or erase operation 
			
			  Try to save on CPU power when waiting delay
			  is at least a system timer tick period.
			  No need to be extremely accurate here.
  The INVALIDATE_CACHED_RANGE() macro is normally used in parallel while
  the flash is actively programming or erasing since we have to poll for
  the operation to complete anyway.  We can't do that in a generic way with
  a XIP setup so do it before the actual flash operation in this case
  and stub it out from INVALIDATE_CACHE_UDELAY.
  Extra notes:
  Activating this XIP support changes the way the code works a bit.  For
  example the code to suspend the current process when concurrent access
  happens is never executed because xip_udelay() will always return with the
  same chip state as it was entered with.  This is why there is no care for
  the presence of add_wait_queue() or schedule() calls from within a couple
  xip_disable()'d  areas of code, like in do_erase_oneblock for example.
  The queueing and scheduling are always happening within xip_udelay().
  Similarly, get_chip() and put_chip() just happen to always be executed
  with chip->state set to FL_READY (or FL_XIP_WHILE_) where flash state
  is in array mode, therefore never executing many cases therein and not
  causing any problem with XIP.
 Ensure cmd readwrites are aligned. 
 ofs: offset within the first chip that the first read should start 
 ofs: offset within the first chip that the first read should start 
 8 secsi bytes per chip 
 partial write of a word, load old contents 
 make sure area matches group boundaries 
 Enter lock register command 
 read lock register 
 set bit 0 to protect extended memory block 
 set bit 0 to protect extended memory block 
 write lock register 
 wait for chip to become ready 
 exit protection commands 
 Micron M29EW family 
			 check whether secsi area is factory locked
 factory locked 
 customer lockable 
 Enter lock register command 
 read lock register 
 exit protection commands 
 return otpinfo 
	
	  We use a 1ms + 1 jiffies generic timeout for writes (most devices
	  have a max write time of a few hundreds usec). However, we should
	  use the maximum timeout value given by the chip at probe time
	  instead.  Unfortunately, struct flchip does have a field for
	  maximum timeout, only for typical which can be far too short
	  depending of the conditions.	 The ' + 1' is to avoid having a
	  timeout of 0 jiffies if HZ is smaller than 1000.
 See comment above for timeout value. 
 Someone's suspended the write. Sleep 
 FIXME 
		
		  We check "time_after" and "!chip_good" before checking
		  "chip_good" to avoid the failure due to scheduling.
 Latency issues. Drop the lock, wait a while and retry 
	
	  Check for a NOP for the case when the datum to write is already
	  present - it saves time and works around buggy chips that corrupt
	  data at other locations when 0xff is written to a location that
	  already contains 0xff.
 reset on all failures. 
 FIXME - should have reset delay before continuing 
 If it's not bus-aligned, do the first byte write 
 Load 'tmp_buf' with old contents of flash 
 Number of bytes to copy from buffer 
 We are now aligned, write as much as possible 
 Write the trailing bytes if any 
	
	  Timeout is calculated according to CFI data, if available.
	  See more comments in cfi_cmdset_0002().
 Someone's suspended the write. Sleep 
 FIXME 
		
		  We check "time_after" and "!chip_good" before checking
		  "chip_good" to avoid the failure due to scheduling.
 Latency issues. Drop the lock, wait a while and retry 
	
	  Recovery from write-buffer programming failures requires
	  the write-to-buffer-reset sequence.  Since the last part
	  of the sequence also works as a normal reset, we can run
	  the same commands regardless of why we are here.
	  See e.g.
	  http:www.spansion.comSupportApplication%20NotesMirrorBit_Write_Buffer_Prog_Page_Buffer_Read_AN.pdf
 FIXME - should have reset delay before continuing 
  FIXME: interleaved mode not tested, and probably not supported!
 Write Buffer Load 
 Write length of data to come 
 Write data 
 Write Buffer Program Confirm: GO GO GO 
 If it's not bus-aligned, do the first word write 
 Write buffer is worth it only if more than one word to write... 
 We must not cross write block boundaries 
 !FORCE_WORD_WRITE 
  Wait for the flash chip to become ready to write data
  This is only called during the panic_write() path. When panic_write()
  is called, the kernel is in the process of a panic, and will soon be
  dead. Therefore we don't take any locks, and attempt to get access
  to the chip as soon as possible.
	
	  If the driver thinks the chip is idle, and no toggle bits
	  are changing, then the chip is actually idle for sure.
	
	  Try several times to reset the chip and then wait for it
	  to become idle. The upper limit of a few milliseconds of
	  delay isn't a big problem: the kernel is dying anyway. It
	  is more important to save the messages.
 send the reset command 
 wait for the chip to become ready 
 the chip never became ready 
  Write out one word of data to a single flash chip during a kernel panic
  This is only called during the panic_write() path. When panic_write()
  is called, the kernel is in the process of a panic, and will soon be
  dead. Therefore we don't take any locks, and attempt to get access
  to the chip as soon as possible.
  The implementation of this routine is intentionally similar to
  do_write_oneword(), in order to ease code maintenance.
	
	  Check for a NOP for the case when the datum to write is already
	  present - it saves time and works around buggy chips that corrupt
	  data at other locations when 0xff is written to a location that
	  already contains 0xff.
 reset on all failures. 
 FIXME - should have reset delay before continuing 
  Write out some data during a kernel panic
  This is used by the mtdoops driver to save the dying messages from a
  kernel which has panic'd.
  This routine ignores all of the locking used throughout the rest of the
  driver, in order to ensure that the data gets written out no matter what
  state this driver (and the flash chip itself) was in when the kernel crashed.
  The implementation of this routine is intentionally similar to
  cfi_amdstd_write_words(), in order to ease code maintenance.
 If it's not bus aligned, do the first byte write 
 Load 'tmp_buf' with old contents of flash 
 Number of bytes to copy from buffer 
 We are now aligned, write as much as possible 
 Write the trailing bytes if any 
  Handle devices with one erase region, that only implement
  the chip erase command.
 Someone's suspended the erase. Sleep 
			 This erase was suspended and resumed.
 FIXME 
 Latency issues. Drop the lock, wait a while and retry 
 Did we succeed? 
 reset on all failures. 
 FIXME - should have reset delay before continuing 
 Someone's suspended the erase. Sleep 
			 This erase was suspended and resumed.
 FIXME 
 Latency issues. Drop the lock, wait a while and retry 
 Did we succeed? 
 reset on all failures. 
 FIXME - should have reset delay before continuing 
  Advanced Sector Protection - PPB (Persistent Protection Bit) locking
 PPB entry command 
		
		  Unlocking of one specific sector is not supported, so we
		  have to unlock all sectors of this device instead
 Return locked status: 0->locked, 1->unlocked 
	
	  Wait for some time as unlocking of all sectors takes quite long
 2s max (un)locking 
 Exit BC commands 
	
	  PPB unlocking always unlocks all sectors of the flash chip.
	  We need to re-lock all previously locked sectors. So lets
	  first check the locking status of all sectors and save
	  it for future use.
	
	  This code to walk all sectors is a slightly modified version
	  of the cfi_varsize_frob() code.
		
		  Only test sectors that shall not be unlocked. The other
		  sectors shall be unlocked, so lets keep their locking
		  status at "unlocked" (locked=0) for the final re-locking.
 Now unlock the whole chip 
	
	  PPB unlocking always unlocks all sectors of the flash chip.
	  We need to re-lock all previously locked sectors.
			 No need to wake_up() on this state change -
			  as the whole point is that nobody can do anything
			  with the chip now anyway.
 Not an idle state 
 Unlock the chips again 
			 No need to wake_up() on this state change -
			  as the whole point is that nobody can do anything
			  with the chip now anyway.
 Unlock the chips again 
  Ensure that the flash device is put back into read array mode before
  unloading the driver or rebooting.  On some systems, rebooting while
  the flash is in queryprogramerase mode will prevent the CPU from
  fetching the bootloader code, requiring a hard reset or power cycle.
  Common code to handle map devices which are simple ROM
  (C) 2000 Red Hat. GPL'd.
 Nothing to see here 
 We do our best 8) 
  Routines common to all CFI-type probes.
  (C) 2001-2003 Red Hat, Inc.
  GPL'd
 First probe the map to see if we have CFI stuff there. 
 OK we liked it. Now find a driver for the command set it talks 
 First the primary cmdset 
 Then the secondary 
	 Call the probetype-specific code with all permutations of
 The probe didn't like it 
#if 0  Let the CFI probe routine do this sanity check. The Intel and AMD
	 probe routines won't ever return a broken CFI structure anyway,
	 because they make them up themselves.
	
	  Allocate memory for bitmap of valid chips.
	  Align bitmap storage size to full byte.
 Mark first chip valid 
	
	  Now probe for other chips, checking sensibly for aliases while
	  we're at it. The new_chip probe above should have let the first
	  chip in read mode.
	
	  Now allocate the space for the structures we need to return to
	  our caller, and copy the appropriate data into them.
 At most 4-bytes wide. 
 And minimum 1 
		 Minimum device size. Don't look for one 8-bit device
 If it was happy, it'll have increased its own use count 
		 We need these for the !CONFIG_MODULES case,
 SPDX-License-Identifier: GPL-2.0-only
  Registration for chip drivers
	 Hide all the horrid details, like some silly person taking
	 We decrease the use count here. It may have been a
	   probe-only module, which is no longer required from this
	   point, having given us a handle on (and increased the use
	   count of) the actual driver code.
  Destroy an MTD device which was created for a map device.
  Make sure the MTD device is already unregistered before calling this
   Common Flash Interface probe code.
   (C) 2000 Red Hat. GPL'd.
#define DEBUG_CFI
 only needed for short periods, so this is rather simple 
  This fixup occurs immediately after reading the CFI structure and can affect
  the number of chips detected, unlike cfi_fixup, which occurs after an
  mtd_info structure has been created for the chip.
 check for QRY.
   in: interleave,type,mode
   ret: table index, <0 for error
		 This is the first time we're called. Set up the CFI
 Check each previous chip to see if it's an alias 
 Skip location; no valid chip at this address 
		 This chip should be in read mode if it's one
			 Eep. This chip also had the QRY marker.
 If the QRY marker goes away, it's an alias 
			 Yes, it's actually got QRY for data. Most
			  unfortunate. Stick the new chip in read mode
 FIXME: Use other modes to do a proper check 
	 OK, if we got to here, then none of the previous chips appear to
 Update chip map 
 Put it back into Read Mode 
	
	  S70GL02GS flash reports a single 256 MiB chip, but is really made up
	  of two 128 MiB chips with 1024 sectors each.
 Read the CFI info structure 
 Do any necessary byteswapping 
 Dump the information therein 
	
	  Note we put the device back into Read Mode BEFORE going into Auto
	  Select Mode, as some devices support nesting of modes, others
	  don't. This way should always work.
	  On cmdset 0001 the writes of 0xaa and 0x55 are not needed, and
	  so should be treated as nops or illegal (and so put the device
	  back into Read Mode, which is a nop in this case).
 Get AMDSpansion extended JEDEC ID 
 Put it back into Read Mode 
 DEBUG_CFI 
	
	  Just use the generic probe stuff to call our CFI-specific
	  chip_probe routine in all the possible permutations, etc.
  Common Flash Interface support:
    Generic utility functions not dependent on command set
  Copyright (C) 2002 Red Hat
  Copyright (C) 2003 STMicroelectronics Limited
  This code is covered by the GPL.
  Returns the command address according to the given geometry.
	 Modify the unlock address if we are in compatibility mode.
	  For 16bit devices on 8 bit busses
	  and 32bit devices on 16 bit busses
	  set the low bit of the alternating bit sequence of the address.
  Transforms the CFI command for the given geometry (bus width & interleave).
  It looks too long to be inline, but in the common case it should almost all
  get optimised away.
	 We do it this way to give the compiler a fighting chance
	   of optimising away all the crap for 'bankwidth' larger than
	   an unsigned long, in the common case where that support is
 i.e. normally 1
	 First, determine what the bit-pattern should be for a single
	 Now replicate it across the size of an unsigned long, or
	 And finally, for the multi-word case, replicate it
	 We do it this way to give the compiler a fighting chance
	   of optimising away all the crap for 'bankwidth' larger than
	   an unsigned long, in the common case where that support is
 i.e. normally 1
 Or all status words together 
	 Last, determine what the bit-pattern should be for a single
  Sends a CFI command to a bank of flash for the given geometry.
  Returns the offset in flash where the command was written.
  If prev_val is non-null, it will be set to the value at the command address,
  before the command was written.
 scale factor 
 "QRY" found 
 QRY not found probably we deal with some odd CFI chips 
 Some revisions of some old Intel chips? 
 ST M29DW chips 
 some old SST chips, e.g. 39VF160x39VF320x 
 SST 39VF640xB 
 QRY not found 
	 M29W128G flashes require an additional reset command
 cfi->chips[0].start;
 Switch it into Query Mode 
 Read in the Extended Query Table 
 Make sure it returns to read mode 
	 Check that both start and end of the requested erase are
	  aligned with the erasesize at the appropriate addresses.
	 Skip all erase regions which are ended before the start of
	   the requested erase. Actually, to save on the calculations,
	   we skip to the first erase region which starts after the
	   start of the requested erase, and then go back one.
	 OK, now i is pointing at the erase region in which this
	   erase request starts. Check the start of the requested
	   erase range is aligned with the erase size which is in
	   effect here.
 Remember the erase region we start on 
	 Next, check that the end of the requested erase is aligned
	  with the erase region at that address.
	 As before, drop back one to point at the region in which
	   the address actually falls
 SPDX-License-Identifier: GPL-2.0-only
  Common code to handle absent "placeholder" devices
  Copyright 2001 Resilience Corporation <ebrower@resilience.com>
  This map driver is used to allocate "placeholder" MTD
  devices on systems that have socketedremovable media.
  Use of this driver as a fallback preserves the expected
  registration of MTD device nodes regardless of probe outcome.
  A usage example is as follows:
 		my_dev[i] = do_map_probe("cfi", &my_map[i]);
 		if(NULL == my_dev[i]) {
 			my_dev[i] = do_map_probe("map_absent", &my_map[i]);
 		}
  Any device 'probed' with this driver will return -ENODEV
  upon open.
 nop 
 nop 
   Common Flash Interface probe code.
   (C) 2000 Red Hat. GPL'd.
   See JEDEC (http:www.jedec.org) standard JESD21C (section 3.5)
   for the standard this probe goes back to.
   Occasionally maintained by Thayne Harbaugh tharbaugh at lnxi dot com
 AMD 
 Atmel 
 Eon 
 Fujitsu 
 Hyundai 
 Intel 
 Macronix 
 NEC 
 PMC 
 Sharp 
 ST - www.st.com 
 SST 
 Toshiba 
 Winbond 
  Unlock address sets for AMD command sets.
  Intel command sets use the MTD_UADDR_UNNECESSARY.
  Each identifier, except MTD_UADDR_UNNECESSARY, and
  MTD_UADDR_NO_SUPPORT must be defined below in unlock_addrs[].
  MTD_UADDR_NOT_SUPPORTED must be 0 so that structure
  initialization need not require initializing all of the
  unlock addresses for all bit widths.
 data width not supported 
 Requires an arbitrary address 
 Does not require any address 
  I don't like the fact that the first entry in unlock_addrs[]
  exists, but is for MTD_UADDR_NOT_SUPPORTED - and, therefore,
  should not be used.  The  problem is that structures with
  initializers have extra fields initialized to 0.  It is _very_
  desirable to have the unlock address entries for unsupported
  data widths automatically initialized - that means that
  MTD_UADDR_NOT_SUPPORTED must be 0 and the first entry here
  must go unused.
 Doesn't matter which address 
 is used - must be last entry 
 Bitmask for x8, x16 etc. 
 unlock addrs for 8, 16, 32, 64 
  Please keep this list ordered by manufacturer!
  Fortunately, the list isn't searched often and so a
  slow, linear search isn't so bad.
 add DL 
 ???? 
 ???? 
 ???? 
 ???? 
 should be CFI 
 should be CFI 
 CFI is broken: reports AMD_STD, but needs custom uaddr 
 CFI is broken: reports AMD_STD, but needs custom uaddr 
 should be CFI 
 FIXME - CFI device? 
 FIXME - CFI device? 
 FIXME - CFI device? 
 ???? 
 FIXME - CFI device? 
 ???? 
	 According to JEDEC "Standard Manufacturer's Identification Code"
	  (http:www.jedec.orgdownloadsearchjep106W.pdf)
	  several first banks can contain 0x7f instead of actual ID
 Reset 
	 after checking the datasheets for SST, MACRONIX and ATMEL
	  (oh and incidentaly the jedec spec - 3.5.3.3) the reset
	  sequence is supposed to be 0xaa at 0x5555, 0x55 at
	  0x2aaa, 0xF0 at 0x5555 this will not affect the AMD chips
	  as they will ignore the writes and don't care what address
	 Some misdesigned Intel chips do not respond for 0xF0 for a reset,
	  so ensure we're in read mode.  Send both the Intel and the AMD command
	  for this.  Intel uses 0xff for this, AMD uses 0xff for NOP, so
	  this should be safe.
 FIXME - should have reset delay before continuing 
xx printk(KERN_WARNING "%s: kmalloc failed for CFI ident structure\n", map->name);
 This may be redundant for some cases, but it doesn't hurt 
	 The table has unlock addresses in _bytes_, and we try not to let
	   our brains explode when we see the datasheets talking about address
	   lines numbered from A-1 to A18. The CFI table has unlock addresses
 ok 
  There is a BIG problem properly ID'ing the JEDEC device and guaranteeing
  the mapped address, unlock addresses, and proper chip ID.  This function
  attempts to minimize errors.  It is doubtfull that this probe will ever
  be perfect - consequently there should be some module parameters that
  could be manually specified to force the chip info.
 failure until all tests pass 
	
	  The IDs must match.  For X16 and X32 devices operating in
	  a lower width ( X8 or X16 ), the device ID's are usually just
	  the lower byte(s) of the larger device ID for wider mode.  If
	  a part is found that doesn't fit this assumption (device id for
	  smaller width mode is completely unrealated to full-width mode)
	  then the jedec_table[] will have to be augmented with the IDs
	  for different widths.
		 bjd: it seems that if we do this, we can end up
		  detecting 16bit flashes as an 8bit device, even though
		  there aren't.
 the part size must fit in the memory window 
	
	  Make sure the ID's disappear when the device is taken out of
	  ID mode.  The only time this should fail when it should succeed
	  is when the ID's are written as data to the same
	  addresses.  For this rare and unfortunate case the chip
	  cannot be probed correctly.
	  FIXME - write a driver that takes all of the chip info as
	  module parameters, doesn't probe but forces a load.
 all tests passed - mark  as success 
	
	  Put the device back in ID mode - only need to do this if we
	  were truly frobbing a real device.
 FIXME - should have a delay before continuing 
 Make certain we aren't probing past the end of map 
 Ensure the unlock addresses we try stay inside the map 
 Reset 
 Autoselect Mode 
 FIXME - should have a delay before continuing 
		 This is the first time we're called. Set up the CFI
 Make sure it is a chip of the same manufacturer and id 
 Check each previous chip locations to see if it's an alias 
 Skip location; no valid chip at this address 
			 Eep. This chip also looks like it's in autoselect mode.
 If the device IDs go away, it's an alias 
			 Yes, it's actually got the device IDs as data. Most
			  unfortunate. Stick the new chip in read mode
 FIXME: Use other modes to do a proper check 
	 OK, if we got to here, then none of the previous chips appear to
 Update chip map 
 Put it back into Read Mode 
	
	  Just use the generic probe stuff to call our CFI-specific
	  chip_probe routine in all the possible permutations, etc.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2006-2008 Nokia Corporation
  Test OOB read and write on MTD device.
  Author: Adrian Hunter <ext-adrian.hunter@nokia.com>
  Display the address, offset and data bytes at comparison failure.
  Return number of bitflips encountered.
  Compare with 0xff and show the address, offset and data bytes at
  comparison failure. Return number of bitflips encountered.
 verify pre-offset area for 0xff 
 verify post-(use_offset + use_len) area for 0xff 
 read entire block's OOB at one go 
 verify one page OOB at a time for bitflip per page limit check 
 First test: write all OOB, read it back and verify 
	
	  Second test: write all OOB, a block at a time, read it back and
	  verify.
 Check all eraseblocks 
	
	  Third test: write OOB at varying offsets and lengths, read it back
	  and verify.
 Write all eraseblocks 
 Check all eraseblocks 
 Fourth test: try to write off end of device 
 Attempt to write off end of OOB 
 Attempt to read off end of OOB 
 Attempt to write off end of device 
 Attempt to read off end of device 
 Attempt to write off end of device 
 Attempt to read off end of device 
 Fifth test: write  read across block boundaries 
 Erase all eraseblocks 
 Write all eraseblocks 
 Check all eraseblocks 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2006-2008 Nokia Corporation
  Check MTD device read.
  Author: Adrian Hunter <ext-adrian.hunter@nokia.com>
 Read all eraseblocks 1 page at a time 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2007 Nokia Corporation
  Test read and write speed of a MTD device.
  Author: Adrian Hunter <adrian.hunter@nokia.com>
 Write all eraseblocks, 1 eraseblock at a time 
 Read all eraseblocks, 1 eraseblock at a time 
 Write all eraseblocks, 1 page at a time 
 Read all eraseblocks, 1 page at a time 
 Write all eraseblocks, 2 pages at a time 
 Read all eraseblocks, 2 pages at a time 
 Erase all eraseblocks 
 Multi-block erase all eraseblocks 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2006-2008 Artem Bityutskiy
  Copyright (C) 2006-2008 Jarkko Lavinen
  Copyright (C) 2006-2008 Adrian Hunter
  Authors: Artem Bityutskiy, Jarkko Lavinen, Adria Hunter
  WARNING: this test program may kill your flash and your device. Do not
  use it unless you know what you do. Authors are not responsible for any
  damage caused by this program.
 This buffer contains 0x555555...0xAAAAAA... pattern 
 This buffer contains 0xAAAAAA...0x555555... pattern 
 This buffer contains all 0xFF bytes 
 This a temporary buffer is use when checking data 
 How many erase cycles were done 
  Check that the contents of eraseblock number @enbum is equivalent to the
  @buf buffer.
 Try read again 
 Initialize patterns 
 Check if the eraseblocks contain only 0xFF bytes 
 Write the pattern 
 Verify what we wrote 
  Report the detailed information about how the read EB differs from what was
  written.
  Count the number of differing bytes and bits and return the first differing
  offset.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright  2012 NetCommWireless
  Iwo Mergler <Iwo.Mergler@netcommwireless.com.au>
  Test for multi-bit error recovery on a NAND page This mostly tests the
  ECC controller  driver.
  There are two test modes:
 	0 - artificially inserting bit errors until the ECC fails
 	    This is the default method and fairly quick. It should
 	    be independent of the quality of the FLASH.
 	1 - re-writing the same pattern repeatedly until the ECC fails.
 	    This method relies on the physics of NAND FLASH to eventually
 	    generate '0' bits if '1' has been written sufficient times.
 	    Depending on the NAND, the first bit errors will appear after
 	    1000 or more writes and then will usually snowball, reaching the
 	    limits of the ECC quickly.
 	    The test stops after 10000 cycles, should your FLASH be
 	    exceptionally good and not generate bit errors before that. Try
 	    a different page in that case.
  Please note that neither of these tests will significantly 'use up' any
  FLASH endurance. Only a maximum of two erase operations will be performed.
 Offset of the page we're using. 
 Eraseblock number for our page. 
 We assume that the ECC can correct up to a certain number
 Size of subpages 
 Number of subpages per page 
 MTD device 
 One page write  compare buffer 
 One page read buffer 
 'random' bytes from known offsets 
 Reverse bits of result. 
 Writes wbuffer to page 
 Re-writes the data area while leaving the OOB alone. 
 No ECC 
 Reads page into rbuffer. Returns number of corrected bit errors (>=0)
 Saving last mtd stats 
 Verifies rbuffer against random sequence 
 Finds the first '1' bit in wbuffer starting at offset 'byte'
 Writes 'random' data to page and then introduces deliberate bit
 Writes 'random' data to page and then re-writes that same data repeatedly.
   This eventually develops bit errors (bits written as '1' will slowly become
	 We don't expect more than this many correctable bit errors per
 bit error histogram. 
 err < 0 
	 At this point bitstats[0] contains the number of ops with no bit
 We leave the block un-erased in case of test failure. 
 Nothing 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2006-2007 Nokia Corporation
  Test sub-page read and write on MTD device.
  Author: Adrian Hunter <ext-adrian.hunter@nokia.com>
 Write all eraseblocks 
 Check all eraseblocks 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2006-2008 Nokia Corporation
  Test page read and write on MTD device.
  Author: Adrian Hunter <ext-adrian.hunter@nokia.com>
 Do a read to set the internal dataRAMs to different data 
 Check boundary between eraseblocks 
 Do a read to set the internal dataRAMs to different data 
 Read 2nd-to-last page to pp1 
 Read 3rd-to-last page to pp1 
 Read first page to pp2 
 Read last page to pp3 
 Read first page again to pp4 
 pp2 and pp4 should be the same 
 Erase all eraseblocks 
 Write all eraseblocks 
 Check all eraseblocks 
 SPDX-License-Identifier: GPL-2.0-only
  Test the implementation for software ECC
  No actual MTD device is needed, So we don't need to warry about losing
  important data by human error.
  This covers possible patterns of corruption which can be reliably corrected
  or detected.
  The reason for this __change_bit_le() instead of __change_bit() is to inject
  bit error properly within the region which is not a multiple of
  sizeof(unsigned long) on big-endian systems
		
		  Don't inject a bit error into the insignificant bits (16th
		  and 17th bit) in ECC code for 256 byte data block
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2006-2008 Nokia Corporation
  Test random reads, writes and erases on MTD device.
  Author: Adrian Hunter <ext-adrian.hunter@nokia.com>
 Read or write up 2 eraseblocks at a time - hence 'ebcnt - 1' 
 Read or write up 2 eraseblocks at a time 
 Do operations 
 SPDX-License-Identifier: GPL-2.0
 Ignore corrected ECC errors 
 SPDX-License-Identifier: GPL-2.0+
  Generic Error-Correcting Code (ECC) engine
  Copyright (C) 2019 Macronix
  Author:
      Miqul RAYNAL <miquel.raynal@bootlin.com>
  This file describes the abstraction of any NAND ECC engine. It has been
  designed to fit most cases, including parallel NANDs and SPI-NANDs.
  There are three main situations where instantiating this ECC engine makes
  sense:
    - external: The ECC engine is outside the NAND pipeline, typically this
                is a software ECC engine, or an hardware engine that is
                outside the NAND controller pipeline.
    - pipelined: The ECC engine is inside the NAND pipeline, ie. on the
                 controller's side. This is the case of most of the raw NAND
                 controllers. In the pipeline case, the ECC bytes are
                 generateddata corrected on the fly when a page is
                 writtenread.
    - ondie: The ECC engine is inside the NAND pipeline, on the chip's side.
             Some NAND chips can correct themselves the data.
  Besides the initial setup and final cleanups, the interfaces are rather
  simple:
    - prepare: Prepare an IO request. Enabledisable the ECC engine based on
               the IO request type. In case of software correction or external
               engine, this step may involve to derive the ECC bytes and place
               them in the OOB area before a write.
    - finish: Finish an IO request. Correct the data in case of a read
              request and report the number of corrected bitsuncorrectable
              errors. Most likely empty for write operations, unless you have
              hardware specific stuff to do, like shutting down the engine to
              save power.
  The IO request should be enclosed in a prepare()finish() pair of calls
  and will behave differently depending on the requested IO type:
    - raw: Correction disabled
    - ecc: Correction enabled
  The request direction is impacting the logic as well:
    - read: Load data from the NAND chip
    - write: Store data in the NAND chip
  Mixing all this combinations together gives the following behavior.
  Those are just examples, drivers are free to add custom steps in their
  preparefinish hook.
  [external ECC engine]
    - external + prepare + raw + read: do nothing
    - external + finish  + raw + read: do nothing
    - external + prepare + raw + write: do nothing
    - external + finish  + raw + write: do nothing
    - external + prepare + ecc + read: do nothing
    - external + finish  + ecc + read: calculate expected ECC bytes, extract
                                       ECC bytes from OOB buffer, correct
                                       and report any bitfliperror
    - external + prepare + ecc + write: calculate ECC bytes and store them at
                                        the right place in the OOB buffer based
                                        on the OOB layout
    - external + finish  + ecc + write: do nothing
  [pipelined ECC engine]
    - pipelined + prepare + raw + read: disable the controller's ECC engine if
                                        activated
    - pipelined + finish  + raw + read: do nothing
    - pipelined + prepare + raw + write: disable the controller's ECC engine if
                                         activated
    - pipelined + finish  + raw + write: do nothing
    - pipelined + prepare + ecc + read: enable the controller's ECC engine if
                                        deactivated
    - pipelined + finish  + ecc + read: check the status, report any
                                        errorbitflip
    - pipelined + prepare + ecc + write: enable the controller's ECC engine if
                                         deactivated
    - pipelined + finish  + ecc + write: do nothing
  [ondie ECC engine]
    - ondie + prepare + raw + read: send commands to disable the on-chip ECC
                                    engine if activated
    - ondie + finish  + raw + read: do nothing
    - ondie + prepare + raw + write: send commands to disable the on-chip ECC
                                     engine if activated
    - ondie + finish  + raw + write: do nothing
    - ondie + prepare + ecc + read: send commands to enable the on-chip ECC
                                    engine if deactivated
    - ondie + finish  + ecc + read: send commands to check the status, report
                                    any errorbitflip
    - ondie + prepare + ecc + write: send commands to enable the on-chip ECC
                                     engine if deactivated
    - ondie + finish  + ecc + write: do nothing
  nand_ecc_init_ctx - Init the ECC engine context
  @nand: the NAND device
  On success, the caller is responsible of calling @nand_ecc_cleanup_ctx().
  nand_ecc_cleanup_ctx - Cleanup the ECC engine context
  @nand: the NAND device
  nand_ecc_prepare_io_req - Prepare an IO request
  @nand: the NAND device
  @req: the IO request
  nand_ecc_finish_io_req - Finish an IO request
  @nand: the NAND device
  @req: the IO request
 Define default OOB placement schemes for large and small page devices 
  Support the old "large page" layout used for 1-bit Hamming ECC where ECC
  are placed at a fixed offset.
  nand_ecc_is_strong_enough - Check if the chip configuration meets the
                              datasheet requirements.
  @nand: Device to check
  If our configuration corrects A bits per B bytes and the minimum
  required correction level is X bits per Y bytes, then we must ensure
  both of the following are true:
  (1) A  B >= X  Y
  (2) A >= X
  Requirement (1) ensures we can correct for the required bitflip density.
  Requirement (2) ensures we can correct even when all bitflips are clumped
  in the same sector.
 Not enough information 
	
	  We get the number of corrected bits per page to compare
	  the correction density.
 ECC engine driver internal helpers 
 Let the user decide the exact length of each buffer 
  Ensure data and OOB area is fully readwritten otherwise the correction might
  not work as expected.
 Save the original request 
 Ensure the request covers the entire page 
 Copy the data that must be writen in the bounce buffers, if needed 
 Restore the data read from the bounce buffers, if needed 
 Ensure the original request is restored 
 SPDX-License-Identifier: GPL-2.0-or-later
  This file provides ECC correction for more than 1 bit per block of data,
  using binary BCH codes. It relies on the generic BCH library libbch.c.
  Copyright  2011 Ivan Djelic <ivan.djelic@parrot.com>
  nand_ecc_sw_bch_calculate - Calculate the ECC corresponding to a data block
  @nand: NAND device
  @buf: Input buffer with raw data
  @code: Output buffer with ECC
 apply mask so that an erased page is a valid codeword 
  nand_ecc_sw_bch_correct - Detect, correct and report bit error(s)
  @nand: NAND device
  @buf: Raw data read from the chip
  @read_ecc: ECC bytes from the chip
  @calc_ecc: ECC calculated from the raw data
  Detect and correct bit errors for a data block.
 The error is in the data area: correct it 
 Otherwise the error is in the ECC area: nothing to do 
  nand_ecc_sw_bch_cleanup - Cleanup software BCH ECC resources
  @nand: NAND device
  nand_ecc_sw_bch_init - Initialize software BCH ECC engine
  @nand: NAND device
  Returns: a pointer to a new NAND BCH control structure, or NULL upon failure
  Initialize NAND BCH error correction. @nand.ecc parameters 'step_size' and
  'bytes' are used to compute the following BCH parameters:
      m, the Galois field order
      t, the error correction capability
  'bytes' should be equal to the number of bytes required to store m  t
  bits, where m is such that 2^m - 1 > step_size  8.
  Example: to configure 4 bit correction per 512 bytes, you should pass
  step_size = 512 (thus, m = 13 is the smallest integer such that 2^m - 1 > 512  8)
  bytes = 7 (7 bytes are required to store m  t = 13  4 = 52 bits)
 Compute and store the inverted ECC of an erased step 
 Verify that the number of code bytes has the expected value 
 Sanity checks 
 Only large page NAND chips may use BCH 
	
	  Board driver should supply ECC size and ECC strength
	  values to select how many bits are correctable.
	  Otherwise, default to 512 bytes for large page devices and 256 for
	  small page devices.
 Maximize 
 Reserve 2 bytes for the BBM 
 Verify the layout validity 
 Nothing to do for a raw operation 
 This engine does not provide BBMfree OOB bytes protection 
 No more preparation for page read 
 Preparation for page write: derive the ECC bytes and place them 
 Nothing to do for a raw operation 
 This engine does not provide BBMfree OOB bytes protection 
 No more preparation for page write 
 Finish a page read: retrieve the (raw) ECC bytes
 Calculate the ECC bytes 
 Finish a page read: compare and correct 
 SPDX-License-Identifier: GPL-2.0-or-later
  This file contains an ECC algorithm that detects and corrects 1 bit
  errors in a 256 byte block of data.
  Copyright  2008 Koninklijke Philips Electronics NV.
                   Author: Frans Meulenbroeks
  Completely replaces the previous ECC implementation which was written by:
    Steven J. Hill (sjhill@realitydiluted.com)
    Thomas Gleixner (tglx@linutronix.de)
  Information on how this algorithm works and how it was developed
  can be found in Documentationdriver-apimtdnand_ecc.rst
  invparity is a 256 byte table that contains the odd parity
  for each byte. So if the number of bits in a byte is even,
  the array element is 1, and when the number of bits is odd
  the array eleemnt is 0.
  bitsperbyte contains the number of bits per byte
  this is only used for testing and repairing parity
  (a precalculated value slightly improves performance)
  addressbits is a lookup table to filter out the bits from the xor-ed
  ECC data that identify the faulty location.
  this is only used for repairing parity
  see the comments in nand_ecc_sw_hamming_correct for more details
 current value in buffer 
 rp0..rp17 are the various accumulated parities (per byte) 
 Cumulative parity for all data 
 Cumulative parity at the end of the loop (rp12, rp14, rp16) 
	
	  The loop is unrolled a number of times;
	  This avoids if statements to decide on which rp value to update
	  Also we process the data by longwords.
	  Note: passing unaligned data might give a performance penalty.
	  It is assumed that the buffers are aligned.
	  tmppar is the cumulative sum of this iteration.
	  needed for calculating rp12, rp14, rp16 and par
	  also used as a performance improvement for rp6, rp8 and rp10
	
	  handle the fact that we use longword operations
	  we'll bring rp4..rp14..rp16 back to single byte entities by
	  shifting and xoring first fold the upper and lower 16 bits,
	  then the upper and lower 8 bits.
	
	  we also need to calculate the row parity for rp0..rp3
	  This is present in par, because par is now
	  rp3 rp3 rp2 rp2 in little endian and
	  rp2 rp2 rp3 rp3 in big endian
	  as well as
	  rp1 rp0 rp1 rp0 in little endian and
	  rp0 rp1 rp0 rp1 in big endian
	  First calculate rp2 and rp3
 reduce par to 16 bits then calculate rp1 and rp0 
 finally reduce par to 8 bits 
	
	  and calculate rp5..rp15..rp17
	  note that par = rp4 ^ rp5 and due to the commutative property
	  of the ^ operator we can say:
	  rp5 = (par ^ rp4);
	  The & 0xff seems superfluous, but benchmarking learned that
	  leaving it out gives slightly worse results. No idea why, probably
	  it has to do with the way the pipeline in pentium is organized.
	
	  Finally calculate the ECC bits.
	  Again here it might seem that there are performance optimisations
	  possible, but benchmarks showed that on the system this is developed
	  the code below is the fastest
  nand_ecc_sw_hamming_calculate - Calculate 3-byte ECC for 256512-byte block
  @nand: NAND device
  @buf: Input buffer with raw data
  @code: Output buffer with ECC
	
	  b0 to b2 indicate which bit is faulty (if any)
	  we might need the xor result  more than once,
	  so keep them in a local var
 check if there are any bitfaults 
 repeated if statements are slightly more efficient than switch ... 
 ordered in order of likelihood 
 no error 
 single bit error 
		
		  rp17rp15131197531 indicate which byte is the faulty
		  byte, cp 531 indicate the faulty bit.
		  A lookup table (called addressbits) is used to filter
		  the bits from the byte they are in.
		  A marginal optimisation is possible by having three
		  different lookup tables.
		  One as we have now (for b0), one for b2
		  (that would avoid the >> 1), and one for b1 (with all values
		  << 4). However it was felt that introducing two more tables
		  hardly justify the gain.
		 
		  The b2 shift is there to get rid of the lowest two bits.
		  We could also do addressbits[b2] >> 1 but for the
		  performance it does not make any difference
 flip the bit 
 count nr of bits; use table lookup, faster than calculating it 
 error in ECC data; no action needed 
  nand_ecc_sw_hamming_correct - Detect and correct bit error(s)
  @nand: NAND device
  @buf: Raw data read from the chip
  @read_ecc: ECC bytes read from the chip
  @calc_ecc: ECC calculated from the raw data
  Detect and correct up to 1 bit error per 256512-byte block.
 Use the strongest configuration by default 
 Nothing to do for a raw operation 
 This engine does not provide BBMfree OOB bytes protection 
 No more preparation for page read 
 Preparation for page write: derive the ECC bytes and place them 
 Nothing to do for a raw operation 
 This engine does not provide BBMfree OOB bytes protection 
 No more preparation for page write 
 Finish a page read: retrieve the (raw) ECC bytes
 Calculate the ECC bytes 
 Finish a page read: compare and correct 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2017 Free Electrons
  Authors:
 	Boris Brezillon <boris.brezillon@free-electrons.com>
 	Peter Pan <peterpandong@micron.com>
  nanddev_bbt_init() - Initialize the BBT (Bad Block Table)
  @nand: NAND device
  Initialize the in-memory BBT.
  Return: 0 in case of success, a negative error code otherwise.
  nanddev_bbt_cleanup() - Cleanup the BBT (Bad Block Table)
  @nand: NAND device
  Undoes what has been done in nanddev_bbt_init()
  nanddev_bbt_update() - Update a BBT
  @nand: nand device
  Update the BBT. Currently a NOP function since on-flash bbt is not yet
  supported.
  Return: 0 in case of success, a negative error code otherwise.
  nanddev_bbt_get_block_status() - Return the status of an eraseblock
  @nand: nand device
  @entry: the BBT entry
  Return: a positive number nand_bbt_block_status status or -%ERANGE if @entry
 	   is bigger than the BBT size.
  nanddev_bbt_set_block_status() - Update the status of an eraseblock in the
 				    in-memory BBT
  @nand: nand device
  @entry: the BBT entry to update
  @status: the new status
  Update an entry of the in-memory BBT. If you want to push the updated BBT
  the NAND you should call nanddev_bbt_update().
  Return: 0 in case of success or -%ERANGE if @entry is bigger than the BBT
 	   size.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2017 Free Electrons
  Authors:
 	Boris Brezillon <boris.brezillon@free-electrons.com>
 	Peter Pan <peterpandong@micron.com>
  nanddev_isbad() - Check if a block is bad
  @nand: NAND device
  @pos: position pointing to the block we want to check
  Return: true if the block is bad, false otherwise.
 Lazy block status retrieval 
  nanddev_markbad() - Mark a block as bad
  @nand: NAND device
  @pos: position of the block to mark bad
  Mark a block bad. This function is updating the BBT if available and
  calls the low-level markbad hook (nand->ops->markbad()).
  Return: 0 in case of success, a negative error code otherwise.
  nanddev_isreserved() - Check whether an eraseblock is reserved or not
  @nand: NAND device
  @pos: NAND position to test
  Checks whether the eraseblock pointed by @pos is reserved or not.
  Return: true if the eraseblock is reserved, false otherwise.
 Return info from the table 
  nanddev_erase() - Erase a NAND portion
  @nand: NAND device
  @pos: position of the block to erase
  Erases the block if it's not bad.
  Return: 0 in case of success, a negative error code otherwise.
  nanddev_mtd_erase() - Generic mtd->_erase() implementation for NAND devices
  @mtd: MTD device
  @einfo: erase request
  This is a simple mtd->_erase() implementation iterating over all blocks
  concerned by @einfo and calling nand->ops->erase() on each of them.
  Note that mtd->_erase should not be directly assigned to this helper,
  because there's no locking here. NAND specialized layers should instead
  implement there own wrapper around nanddev_mtd_erase() taking the
  appropriate lock before calling nanddev_mtd_erase().
  Return: 0 in case of success, a negative error code otherwise.
  nanddev_mtd_max_bad_blocks() - Get the maximum number of bad eraseblock on
 				  a specific region of the NAND device
  @mtd: MTD device
  @offs: offset of the NAND region
  @len: length of the NAND region
  Default implementation for mtd->_max_bad_blocks(). Only works if
  nand->memorg.max_bad_eraseblocks_per_lun is > 0.
  Return: a positive number encoding the maximum number of eraseblocks on a
  portion of memory, a negative error code otherwise.
  nanddev_get_ecc_engine() - Find and get a suitable ECC engine
  @nand: NAND device
 Read the user desires in terms of ECC engineconfiguration 
  nanddev_put_ecc_engine() - Dettach and put the in-use ECC engine
  @nand: NAND device
  nanddev_find_ecc_configuration() - Find a suitable ECC configuration
  @nand: NAND device
  nanddev_ecc_engine_init() - Initialize an ECC engine for the chip
  @nand: NAND device
 Look for the ECC engine to use 
 No ECC engine requested 
 Configure the engine: balance user input and chip requirements 
  nanddev_ecc_engine_cleanup() - Cleanup ECC engine initializations
  @nand: NAND device
  nanddev_init() - Initialize a NAND device
  @nand: NAND device
  @ops: NAND device operations
  @owner: NAND device owner
  Initializes a NAND device object. Consistency checks are done on @ops and
  @nand->memorg. Also takes care of initializing the BBT.
  Return: 0 in case of success, a negative error code otherwise.
  nanddev_cleanup() - Release resources allocated in nanddev_init()
  @nand: NAND device
  Basically undoes what has been done in nanddev_init().
 SPDX-License-Identifier: GPL-2.0-or-later
  NAND flash simulator.
  Author: Artem B. Bityuckiy <dedekind@oktetlabs.ru>, <dedekind@infradead.org>
  Copyright (C) 2004 Nokia Corporation
  Note: NS means "NAND Simulator".
  Note: Input means input TO flash chip, output means output FROM chip.
 Default simulator parameters values 
 No byte 
 No byte 
 Page and erase block positions for the following parameters are independent of any partitions 
 The largest possible page size 
 Simulator's output macros (logging, debugging, warning, error) 
 Busy-wait delay macros (microseconds, milliseconds) 
 Is the nandsim structure initialized ? 
 Good operation completion status 
 Operation failed completion status 
 Calculate the page offset in flash RAM image by (row, column) address 
 Calculate the OOB offset in flash RAM image by (row, column) address 
 After a command is input, the simulator goes to one of the following states 
 read data from the beginning of page 
 read data from the second half of page 
 read data second command (large page devices) 
 start page program 
 read OOB area 
 sector erase first command 
 read status 
 sequential data input 
 read ID 
 sector erase second command 
 reset 
 random output command 
 random output start command 
 command states mask 
 After an address is input, the simulator goes to one of these states 
 full (row, column) address is accepted 
 sector address was accepted 
 column address was accepted 
 one byte zero address was accepted 
 address states mask 
 During data inputoutput the simulator is in these states 
 waiting for data input 
 data input states mask 
 waiting for page data output 
 waiting for ID bytes output 
 waiting for status output 
 data output states mask 
 Previous operation is done, ready to accept new requests 
 This state is used to mark that the next state isn't known yet 
 Simulator's actions bit masks 
 copy pageOOB to the internal buffer 
 program the internal buffer to flash 
 erase sector 
 don't add any offset to address 
 add to address half of page 
 add to address OOB offset 
 action mask 
 Number of operations supported by the simulator 
 Maximum number of states in operation 
 any chip supports this operation 
 512-byte  page chips 
 2048-byte page chips 
 512-byte page chips with 8-bit bus width 
 4096-byte page chips 
 2048 & 4096-byte page chips 
 512-byte page chips 
 Remove action bits from state 
  Maximum previous states which need to be saved. Currently saving is
  only needed for page program operation with preceded read command
  (which is only valid for 512-byte pages).
 Maximum page cache pages needed to read or write a NAND page to the cache_file 
  A union to represent flash memory contents and flash buffer.
 for byte access 
 for 16-bit word access 
  The structure which describes all the internal simulator data.
 flash chip bus width (8 or 16) 
 chip's ID bytes 
 chip's characteristic bits 
 current chip state 
 next expected state 
 current operation, NULL operations isn't known yet  
 previous states 
 number of previous states saved 
 current state index 
 The simulated NAND flash pages array 
 Slab allocator for nand pages 
 Internal buffer of page + OOB size bytes 
 NAND flash "geometry" 
 total flash size, bytes 
 flash sector (erase block) size, bytes 
 NAND flash page size, bytes 
 page OOB area size, bytes 
 total flash size including OOB, bytes 
 page size including OOB , bytes
 sector size including OOB, bytes 
 total number of pages 
 number of pages per sector 
 bits number in sector size 
 bits number in page size 
 bytes per page address 
 bytes per sector address 
 the number ID bytes that this chip outputs 
 NAND flash internal registers 
 the command register 
 the status register 
 the page number 
 the offset within page 
 internal counter 
 number of bytes which must be processed 
 fixed page offset 
 NAND flash lines state 
 chip Enable 
 command Latch Enable 
 address Latch Enable 
 write Protect 
 Fields needed when using a cache file 
 Open file 
 Which pages have been written 
 debugfs entry 
  Operations array. To perform any operation the simulator must pass
  through the correspondent states chain.
 options which are required to perform the operation 
 operation's states 
 Read page + OOB from the beginning 
 Read page + OOB from the second half 
 Read OOB 
 Program page starting from the beginning 
 Program page starting from the beginning 
 Program page starting from the second half 
 Program OOB 
 Erase sector 
 Read status 
 Read ID 
 Large page devices read page 
 Large page devices random page read 
 MTD structure for NAND controller 
 Calc wear stats 
 Output wear report 
  ns_debugfs_create - initialize debugfs
  @ns: nandsim device description object
  This function creates all debugfs files for UBI device @ubi. Returns zero in
  case of success and a negative error code in case of failure.
	
	  Just skip debugfs initialization when the debugfs directory is
	  missing.
  Allocate array of page pointers, create slab allocation for an array
  and initialize the array by NULL pointers.
  RETURNS: 0 if success, -ENOMEM if memory alloc fails.
  Free any allocated pages, and free the array of page pointers.
  Initialize the nandsim structure.
  RETURNS: 0 if success, -ERRNO if failure.
 Initialize the NAND flash parameters 
 Fill the partition_info structure 
 Allocate  initialize the internal buffer 
  Free the nandsim structure.
	
	  TODO: Notify this through a debugfs entry,
	  instead of showing an error message.
  Returns the string representation of 'state' state.
  Check if command is valid.
  RETURNS: 1 if wrong command, 0 if right.
  Returns state after command is accepted by command number.
  Move an address byte to the correspondent internal register.
  Switch to STATE_READY state.
  If the operation isn't known yet, try to find it in the global array
  of supported operations.
  Operation can be unknown because of the following.
    1. New command was accepted and this is the first call to find the
       correspondent states chain. In this case ns->npstates = 0;
    2. There are several operations which begin with the same command(s)
       (for example program from the second half and read from the
       second half operations both begin with the READ1 command). In this
       case the ns->pstates[] array contains previous states.
  Thus, the function tries to find operation containing the following
  states (if the 'flag' parameter is 0):
     ns->pstates[0], ... ns->pstates[ns->npstates], ns->state
  If (one and only one) matching operation is found, it is accepted (
  ns->ops, ns->state, ns->nxstate are initialized, ns->npstate is
  zeroed).
  If there are several matches, the current state is pushed to the
  ns->pstates.
  The operation can be unknown only while commands are input to the chip.
  As soon as address command is accepted, the operation must be known.
  In such situation the function is called with 'flag' != 0, and the
  operation is searched using the following pattern:
      ns->pstates[0], ... ns->pstates[ns->npstates], <address input>
  It is supposed that this pattern must either match one operation or
  none. There can't be ambiguity in that case.
  If no matches found, the function does the following:
    1. if there are saved states present, try to ignore them and search
       again only using the last command. If nothing was found, switch
       to the STATE_READY state.
    2. if there are no saved states, switch to the STATE_READY state.
  RETURNS: -2 - no matched operations found.
           -1 - several matches.
            0 - operation is found.
 Ignore operations we can't perform 
 Exact match 
			
			  In this case the find_operation function was
			  called when address has just began input. But it isn't
			  yet fully input and the current state must
			  not be one of STATE_ADDR_, but the STATE_ADDR_
			  state must be the next state (ns->nxstate).
 Nothing was found. Try to ignore previous commands (if any) and search again 
 This shouldn't happen 
 Get page cache pages in advance to provide NOFS memory allocation 
  Returns a pointer to the current page.
  Retuns a pointer to the current byte, within the current page.
  Fill the NAND buffer with data read from the specified page.
  Erase all pages in the specified sector.
  Program the specified page with the contents from the NAND buffer.
		
		  We allocate memory with GFP_NOFS because a flash FS may
		  utilize this. If it is holding an FS lock, then gets here,
		  then kernel memory alloc runs writeback which goes to the FS
		  again and deadlocks. This was seen in practice.
  If state has any action bit, perform this action.
  RETURNS: 0 if success, -1 if error.
 Check that page address input is correct 
		
		  Copy page data to the internal buffer.
 Column shouldn't be very large 
		
		  Erase sector.
		
		  Program page - move internal buffer data to the page.
  Switch simulator's state.
		
		  The current operation have already been identified.
		  Just follow the states chain.
 See, whether we need to do some action 
		
		  We don't yet know which operation we perform.
		  Try to identify it.
		
		   The only event causing the switch_state function to
		   be called with yet unknown operation is new command.
 For 16x devices column means the page offset in words 
		
		  The current state is the last. Return to STATE_READY
 In case of data states, see if all bytes were inputoutput 
		
		  If the next state is data inputoutput, switch to it now
		
		  Set the internal register to the count of bytes which
		  are expected to be input or output
		
		  If the next state is address input, set the internal
		  register to the number of expected address bytes
 Column address is always 2 bytes 
		
		  Just reset internal counters.
 Sanity and correctness checks 
 Status register may be read as many times as it is wanted 
 Check if there is any data in the internal buffer which may be read 
 Sanity and correctness checks 
		
		  The byte written is a command.
 Check that the command byte is correct 
 Check if chip is expecting command 
 Do not warn if only 2 id bytes are read 
				
				  We are in situation when something else (not command)
				  was expected but command was input. In this case ignore
				  previous command(s)state(s) and accept the last one.
		
		  The byte written is an address.
 Check that chip is expecting address 
 Check if this is expected byte 
		
		  The byte written is an input data.
 Check that chip is expecting data input 
 Check if this is expected byte 
 Check that chip is expecting data input 
 Check if these are expected bytes 
 Sanity and correctness checks 
 Check if these are expected bytes 
 we are always ready 
 Use 512-byte ecc blocks 
 Do not bother supporting small page devices 
  Module initialization function
 The NAND_SKIP_BBTSCAN option is necessary for 'overridesize' 
 and 'badblocks' parameters to work 
	
	  Perform minimum nandsim structure initialization to handle
	  the initial ID read command correctly
 temporary value 
 N.B. This relies on nand_scan not doing anything with the size before we change it 
 Register NAND partitions 
  Module clean-up function
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2017 Free Electrons
  Copyright (C) 2017 NextThing Co
  Author: Boris Brezillon <boris.brezillon@free-electrons.com>
 RANDEN and RANDOPT OTP bits are programmed 
 Subpage write is prohibited in randomizer operatoin 
  Macronix AC series does not support using SETGET_FEATURES to change
  the timings unlike what is declared in the parameter page. Unflag
  this feature to avoid unnecessary downturns.
  Macronix NAND supports Block Protection by Protectoin(PT) pin;
  active high at power-on which protects the entire chip even the #WP is
  disabled. Lockunlock protection area can be partition according to
  protection bits, i.e. upper 12 locked, upper 14 locked and so on.
	
	  Toggle #CS pin to resume NAND device and don't care
	  of the others CLE, #WE, #RE pins status.
	  A NAND controller ensure it is able to assertde-assert #CS
	  by sending any byte over the NAND bus.
	  i.e.,
	  NAND power down command or reset command wo RB# status checking.
 The minimum of a recovery time tRDP is 35 us 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2017 Free Electrons
  Copyright (C) 2017 NextThing Co
  Author: Boris Brezillon <boris.brezillon@free-electrons.com>
 New Samsung (6 byte ID): Samsung K9GAG08U0F (p.44) 
 Get pagesize 
 Get oobsize 
			
			  We should never reach this case, but if that
			  happens, this probably means Samsung decided to use
			  a different extended ID format, and we should find
			  a way to support it.
 Get blocksize 
 Extract ECC requirements from 5th id byte
 K9F4G08U0D-S[I|C]B0(T00) 
 K9F1G08U0E 21nm chips do not support subpage write 
 SPDX-License-Identifier: GPL-2.0-only
   Overview:
    This is the generic MTD driver for NAND flash devices. It should be
    capable of working with almost all NAND chips currently available.
 	Additional technical information is available on
 	http:www.linux-mtd.infradead.orgdocnand.html
   Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
 		  2002-2006 Thomas Gleixner (tglx@linutronix.de)
   Credits:
 	David Woodhouse for adding multichip support
 	Aleph One Ltd. and Toby Churchill Ltd. for supporting the
 	rework for 2K page size chips
   TODO:
 	Enable cached programming for 2k page size chips
 	Check, if mtd->ecctype should be set to MTD_ECC_HW
 	if we have HW ECC support.
 	BBT table is not serialized, has to be fixed
 Start address must align on block boundary 
 Length must align on block boundary 
  nand_extract_bits - Copy unaligned bits from one buffer to another one
  @dst: destination buffer
  @dst_off: bit offset at which the writing starts
  @src: source buffer
  @src_off: bit offset at which the reading starts
  @nbits: number of bits to copy from @src to @dst
  Copy bits from one memory region to another (overlap authorized).
  nand_select_target() - Select a NAND target (A.K.A. die)
  @chip: NAND chip object
  @cs: the CS line to select. Note that this CS id is always from the chip
 	PoV, not the controller one
  Select a NAND target so that further operations executed on @chip go to the
  selected NAND target.
	
	  cs should always lie between 0 and nanddev_ntargets(), when that's
	  not the case it's a bug and the caller should be fixed.
  nand_deselect_target() - Deselect the currently selected target
  @chip: NAND chip object
  Deselect the currently selected NAND target. The result of operations
  executed on @chip after the target has been deselected is undefined.
  nand_release_device - [GENERIC] release chip
  @chip: NAND chip object
  Release chip lock and wake up anyone waiting on the device.
 Release the controller and the chip 
  nand_bbm_get_next_page - Get the next page for bad block markers
  @chip: NAND chip object
  @page: First page to start checking for bad block marker usage
  Returns an integer that corresponds to the page offset within a block, for
  a page that is used to store bad block markers. If no more pages are
  available, -EINVAL is returned.
  nand_block_bad - [DEFAULT] Read bad block marker from the chip
  @chip: NAND chip object
  @ofs: offset from device start
  Check, if the block is bad.
  nand_region_is_secured() - Check if the region is secured
  @chip: NAND chip object
  @offset: Offset of the region to check
  @size: Size of the region to check
  Checks if the region is secured by comparing the offset and size with the
  list of secure regions obtained from DT. Returns true if the region is
  secured else false.
 Skip touching the secure regions if present 
 Check if the region is secured 
  nand_get_device - [GENERIC] Get chip for selected access
  @chip: NAND chip structure
  Lock the device and its controller for exclusive access
  Return: -EBUSY if the chip has been suspended, 0 otherwise
  nand_check_wp - [GENERIC] check if the chip is write protected
  @chip: NAND chip object
  Check, if the device is write protected. The function expects, that the
  device is already selected.
 Broken xD cards report WP despite being writable 
 Check the WP bit 
  nand_fill_oob - [INTERN] Transfer client buffer to oob
  @chip: NAND chip object
  @oob: oob data buffer
  @len: oob data write length
  @ops: oob ops structure
	
	  Initialise to all 0xFF, to avoid the possibility of left over OOB
	  data from a previous OOB read.
  nand_do_write_oob - [MTD Interface] NAND write out-of-band
  @chip: NAND chip object
  @to: offset to write to
  @ops: oob operation description structure
  NAND write out-of-band.
 Do not allow write past end of page 
 Check if the region is secured 
	
	  Reset the chip. Some chips (like the Toshiba TC5832DC found in one
	  of my DiskOnChip 2000 test units) will clear the whole data page too
	  if we don't do this. I have no clue why, but I seem to have 'fixed'
	  it in the doc2000 driver in August 1999.  dwmw2.
 Shift to get page 
 Check, if it is write protected 
 Invalidate the page cache, if we write to the cached page 
  nand_default_block_markbad - [DEFAULT] mark a block bad via bad block marker
  @chip: NAND chip object
  @ofs: offset from device start
  This is the default implementation, which can be overridden by a hardware
  specific driver. It provides the details for writing a bad block marker to a
  block.
  nand_markbad_bbm - mark a block by updating the BBM
  @chip: NAND chip object
  @ofs: offset of the block to mark bad
  nand_block_markbad_lowlevel - mark a block bad
  @chip: NAND chip object
  @ofs: offset from device start
  This function performs the generic NAND bad block marking steps (i.e., bad
  block table(s) andor marker(s)). We only allow the hardware driver to
  specify how to write bad block markers to OOB (chip->legacy.block_markbad).
  We try operations in the following order:
   (1) erase the affected block, to allow OOB marker to be written cleanly
   (2) write bad block marker to OOB area of affected block (unless flag
       NAND_BBT_NO_OOB_BBM is present)
   (3) update the BBT
  Note that we retain the first error encountered in (2) or (3), finish the
  procedures, and dump the error in the end.
 Attempt erase before marking OOB 
 Write bad block marker to OOB 
 Mark block bad in BBT 
  nand_block_isreserved - [GENERIC] Check if a block is marked reserved.
  @mtd: MTD device structure
  @ofs: offset from device start
  Check if the block is marked as reserved.
 Return info from the table 
  nand_block_checkbad - [GENERIC] Check if a block is marked bad
  @chip: NAND chip object
  @ofs: offset from device start
  @allowbbt: 1, if its allowed to access the bbt area
  Check, if the block is bad. Either by reading the bad block table or
  calling of the scan function.
 Return info from the table 
  nand_soft_waitrdy - Poll STATUS reg until RDY bit is set to 1
  @chip: NAND chip structure
  @timeout_ms: Timeout in ms
  Poll the STATUS register using ->exec_op() until the RDY bit becomes 1.
  If that does not happen whitin the specified timeout, -ETIMEDOUT is
  returned.
  This helper is intended to be used when the controller does not have access
  to the NAND RB pin.
  Be aware that calling this helper from an ->exec_op() implementation means
  ->exec_op() must be re-entrant.
  Return 0 if the NAND chip is ready, a negative error otherwise.
 Wait tWB before polling the STATUS reg. 
	
	  +1 below is necessary because if we are now in the last fraction
	  of jiffy and msecs_to_jiffies is 1 then we will wait only that
	  small jiffy fraction - possibly leading to false timeout
		
		  Typical lowest execution time for a tR on most NANDs is 10us,
		  use this as polling delay before doing something smarter (ie.
		  deriving a delay from the timeout value, timeout_msratio).
	
	  We have to exit READ_STATUS mode in order to read real data on the
	  bus in case the WAITRDY instruction is preceding a DATA_IN
	  instruction.
  nand_gpio_waitrdy - Poll RB GPIO pin until ready
  @chip: NAND chip structure
  @gpiod: GPIO descriptor of RB pin
  @timeout_ms: Timeout in ms
  Poll the RB GPIO pin until it becomes ready. If that does not happen
  whitin the specified timeout, -ETIMEDOUT is returned.
  This helper is intended to be used when the controller has access to the
  NAND RB pin over GPIO.
  Return 0 if the RB pin indicates chip is ready, a negative error otherwise.
	
	  Wait until RB pin indicates chip is ready or timeout occurs.
	  +1 below is necessary because if we are now in the last fraction
	  of jiffy and msecs_to_jiffies is 1 then we will wait only that
	  small jiffy fraction - possibly leading to false timeout.
  panic_nand_wait - [GENERIC] wait until the command is done
  @chip: NAND chip structure
  @timeo: timeout
  Wait for command done. This is a helper function for nand_wait used when
  we are in interrupt context. May happen when in panic and trying to write
  an oops through mtdoops.
  nand_reset_interface - Reset data interface and timings
  @chip: The NAND chip
  @chipnr: Internal die id
  Reset the Data interface and timings to ONFI mode 0.
  Returns 0 for success or negative error code otherwise.
	
	  The ONFI specification says:
	  "
	  To transition from NV-DDR or NV-DDR2 to the SDR data
	  interface, the host shall use the Reset (FFh) command
	  using SDR timing mode 0. A device in any timing mode is
	  required to recognize Reset (FFh) command issued in SDR
	  timing mode 0.
	  "
	 
	  Configure the data interface in SDR mode and set the
	  timings to timing mode 0.
  nand_setup_interface - Setup the best data interface and timings
  @chip: The NAND chip
  @chipnr: Internal die id
  Configure what has been reported to be the best data interface and NAND
  timings supported by the chip and the driver.
  Returns 0 for success or negative error code otherwise.
	
	  A nand_reset_interface() put both the NAND chip and the NAND
	  controller in timings mode 0. If the default mode for this chip is
	  also 0, no need to proceed to the change again. Plus, at probe time,
	  nand_setup_interface() uses ->setget_features() which would
	  fail anyway as the parameter page is not available yet.
 Change the mode on the chip side (if supported by the NAND chip) 
 Change the mode on the controller side 
 Check the mode has been accepted by the chip, if supported 
	
	  Fallback to mode 0 if the chip explicitly did not ack the chosen
	  timing mode.
  nand_choose_best_sdr_timings - Pick up the best SDR timings that both the
                                 NAND controller and the NAND chip support
  @chip: the NAND chip
  @iface: the interface configuration (can eventually be updated)
  @spec_timings: specific timings, when not fitting the ONFI specification
  If specific timings are provided, use them. Otherwise, retrieve supported
  timing modes from ONFI information.
 Verify the controller supports the requested interface 
 Fallback to slower modes 
  nand_choose_best_nvddr_timings - Pick up the best NVDDR timings that both the
                                   NAND controller and the NAND chip support
  @chip: the NAND chip
  @iface: the interface configuration (can eventually be updated)
  @spec_timings: specific timings, when not fitting the ONFI specification
  If specific timings are provided, use them. Otherwise, retrieve supported
  timing modes from ONFI information.
 Verify the controller supports the requested interface 
 Fallback to slower modes 
  nand_choose_best_timings - Pick up the best NVDDR or SDR timings that both
                             NAND controller and the NAND chip support
  @chip: the NAND chip
  @iface: the interface configuration (can eventually be updated)
  If specific timings are provided, use them. Otherwise, retrieve supported
  timing modes from ONFI information.
 Try the fastest timings: NV-DDR 
 Fallback to SDR timings otherwise 
  nand_choose_interface_config - find the best data interface and timings
  @chip: The NAND chip
  Find the best data interface and NAND timings supported by the chip
  and the driver. Eventually let the NAND manufacturer driver propose his own
  set of timings.
  After this function nand_chip->interface_config is initialized with the best
  timing mode available.
  Returns 0 for success or negative error code otherwise.
  nand_fill_column_cycles - fill the column cycles of an address
  @chip: The NAND chip
  @addrs: Array of address cycles to fill
  @offset_in_page: The offset in the page
  Fills the first or the first two bytes of the @addrs field depending
  on the NAND bus width and the page size.
  Returns the number of cycles needed to encode the column, or a negative
  error code in case one of the arguments is invalid.
 Make sure the offset is less than the actual page size. 
	
	  On small page NANDs, there's a dedicated command to access the OOB
	  area, and the column address is relative to the start of the OOB
	  area, not the start of the page. Asjust the address accordingly.
	
	  The offset in page is expressed in bytes, if the NAND bus is 16-bit
	  wide, then it must be divided by 2.
	
	  Small page NANDs use 1 cycle for the columns, while large page NANDs
	  need 2
 Drop the DATA_IN instruction if len is set to 0. 
 Drop the DATA_IN instruction if len is set to 0. 
  nand_read_page_op - Do a READ PAGE operation
  @chip: The NAND chip
  @page: page to read
  @offset_in_page: offset within the page
  @buf: buffer used to store the data
  @len: length of the buffer
  This function issues a READ PAGE operation.
  This function does not selectunselect the CS line.
  Returns 0 on success, a negative error code otherwise.
  nand_read_param_page_op - Do a READ PARAMETER PAGE operation
  @chip: The NAND chip
  @page: parameter page to read
  @buf: buffer used to store the data
  @len: length of the buffer
  This function issues a READ PARAMETER PAGE operation.
  This function does not selectunselect the CS line.
  Returns 0 on success, a negative error code otherwise.
 Drop the DATA_IN instruction if len is set to 0. 
  nand_change_read_column_op - Do a CHANGE READ COLUMN operation
  @chip: The NAND chip
  @offset_in_page: offset within the page
  @buf: buffer used to store the data
  @len: length of the buffer
  @force_8bit: force 8-bit bus access
  This function issues a CHANGE READ COLUMN operation.
  This function does not selectunselect the CS line.
  Returns 0 on success, a negative error code otherwise.
 Small page NANDs do not support column change. 
 Drop the DATA_IN instruction if len is set to 0. 
  nand_read_oob_op - Do a READ OOB operation
  @chip: The NAND chip
  @page: page to read
  @offset_in_oob: offset within the OOB area
  @buf: buffer used to store the data
  @len: length of the buffer
  This function issues a READ OOB operation.
  This function does not selectunselect the CS line.
  Returns 0 on success, a negative error code otherwise.
		
		  The first instruction will be dropped if we're dealing
		  with a large page NAND and adjusted if we're dealing
		  with a small page NAND and the page offset is > 255.
 Drop the last two instructions if we're not programming the page. 
 Also drop the DATA_OUT instruction if empty. 
		
		  Small pages need some more tweaking: we have to adjust the
		  first instruction depending on the page offset we're trying
		  to access.
		
		  Drop the first command if we're dealing with a large page
		  NAND.
  nand_prog_page_begin_op - starts a PROG PAGE operation
  @chip: The NAND chip
  @page: page to write
  @offset_in_page: offset within the page
  @buf: buffer containing the data to write to the page
  @len: length of the buffer
  This function issues the first half of a PROG PAGE operation.
  This function does not selectunselect the CS line.
  Returns 0 on success, a negative error code otherwise.
  nand_prog_page_end_op - ends a PROG PAGE operation
  @chip: The NAND chip
  This function issues the second half of a PROG PAGE operation.
  This function does not selectunselect the CS line.
  Returns 0 on success, a negative error code otherwise.
  nand_prog_page_op - Do a full PROG PAGE operation
  @chip: The NAND chip
  @page: page to write
  @offset_in_page: offset within the page
  @buf: buffer containing the data to write to the page
  @len: length of the buffer
  This function issues a full PROG PAGE operation.
  This function does not selectunselect the CS line.
  Returns 0 on success, a negative error code otherwise.
  nand_change_write_column_op - Do a CHANGE WRITE COLUMN operation
  @chip: The NAND chip
  @offset_in_page: offset within the page
  @buf: buffer containing the data to send to the NAND
  @len: length of the buffer
  @force_8bit: force 8-bit bus access
  This function issues a CHANGE WRITE COLUMN operation.
  This function does not selectunselect the CS line.
  Returns 0 on success, a negative error code otherwise.
 Small page NANDs do not support column change. 
 Drop the DATA_OUT instruction if len is set to 0. 
  nand_readid_op - Do a READID operation
  @chip: The NAND chip
  @addr: address cycle to pass after the READID command
  @buf: buffer used to store the ID
  @len: length of the buffer
  This function sends a READID command and reads back the ID returned by the
  NAND.
  This function does not selectunselect the CS line.
  Returns 0 on success, a negative error code otherwise.
 READ_ID data bytes are received twice in NV-DDR mode 
 Drop the DATA_IN instruction if len is set to 0. 
  nand_status_op - Do a STATUS operation
  @chip: The NAND chip
  @status: out variable to store the NAND status
  This function sends a STATUS command and reads back the status returned by
  the NAND.
  This function does not selectunselect the CS line.
  Returns 0 on success, a negative error code otherwise.
 The status data byte will be received twice in NV-DDR mode 
  nand_exit_status_op - Exit a STATUS operation
  @chip: The NAND chip
  This function sends a READ0 command to cancel the effect of the STATUS
  command to avoid reading only the status until a new read command is sent.
  This function does not selectunselect the CS line.
  Returns 0 on success, a negative error code otherwise.
  nand_erase_op - Do an erase operation
  @chip: The NAND chip
  @eraseblock: block to erase
  This function sends an ERASE command and waits for the NAND to be ready
  before returning.
  This function does not selectunselect the CS line.
  Returns 0 on success, a negative error code otherwise.
  nand_set_features_op - Do a SET FEATURES operation
  @chip: The NAND chip
  @feature: feature id
  @data: 4 bytes of data
  This function sends a SET FEATURES command and waits for the NAND to be
  ready before returning.
  This function does not selectunselect the CS line.
  Returns 0 on success, a negative error code otherwise.
  nand_get_features_op - Do a GET FEATURES operation
  @chip: The NAND chip
  @feature: feature id
  @data: 4 bytes of data
  This function sends a GET FEATURES command and waits for the NAND to be
  ready before returning.
  This function does not selectunselect the CS line.
  Returns 0 on success, a negative error code otherwise.
 GET_FEATURE data bytes are received twice in NV-DDR mode 
 Apply delay or wait for readybusy pin 
  nand_reset_op - Do a reset operation
  @chip: The NAND chip
  This function sends a RESET command and waits for the NAND to be ready
  before returning.
  This function does not selectunselect the CS line.
  Returns 0 on success, a negative error code otherwise.
  nand_read_data_op - Read data from the NAND
  @chip: The NAND chip
  @buf: buffer used to store the data
  @len: length of the buffer
  @force_8bit: force 8-bit bus access
  @check_only: do not actually run the command, only checks if the
               controller driver supports it
  This function does a raw data read on the bus. Usually used after launching
  another NAND operation like nand_read_page_op().
  This function does not selectunselect the CS line.
  Returns 0 on success, a negative error code otherwise.
		
		  Parameter payloads (ID, status, features, etc) do not go
		  through the same pipeline as regular data, hence the
		  force_8bit flag must be set and this also indicates that in
		  case NV-DDR timings are being used the data will be received
		  twice.
  nand_write_data_op - Write data from the NAND
  @chip: The NAND chip
  @buf: buffer containing the data to send on the bus
  @len: length of the buffer
  @force_8bit: force 8-bit bus access
  This function does a raw data write on the bus. Usually used after launching
  another NAND operation like nand_write_page_begin_op().
  This function does not selectunselect the CS line.
  Returns 0 on success, a negative error code otherwise.
  struct nand_op_parser_ctx - Context used by the parser
  @instrs: array of all the instructions that must be addressed
  @ninstrs: length of the @instrs array
  @subop: Sub-operation to be passed to the NAND controller
  This structure is used by the core to split NAND operations into
  sub-operations that can be handled by the NAND controller.
  nand_op_parser_must_split_instr - Checks if an instruction must be split
  @pat: the parser pattern element that matches @instr
  @instr: pointer to the instruction to check
  @start_offset: this is an inout parameter. If @instr has already been
 		  split, then @start_offset is the offset from which to start
 		  (either an address cycle or an offset in the data buffer).
 		  Conversely, if the function returns true (ie. instr must be
 		  split), this parameter is updated to point to the first
 		  dataaddress cycle that has not been taken care of.
  Some NAND controllers are limited and cannot send X address cycles with a
  unique operation, or cannot readwrite more than Y bytes at the same time.
  In this case, split the instruction that does not fit in a single
  controller-operation into two or more chunks.
  Returns true if the instruction must be split, false otherwise.
  The @start_offset parameter is also updated to the offset at which the next
  bundle of instruction must start (if an address or a data instruction).
  nand_op_parser_match_pat - Checks if a pattern matches the instructions
 			      remaining in the parser context
  @pat: the pattern to test
  @ctx: the parser context structure to match with the pattern @pat
  Check if @pat matches the set or a sub-set of instructions remaining in @ctx.
  Returns true if this is the case, false ortherwise. When true is returned,
  @ctx->subop is updated with the set of instructions to be passed to the
  controller driver.
		
		  The pattern instruction does not match the operation
		  instruction. If the instruction is marked optional in the
		  pattern definition, we skip the pattern element and continue
		  to the next one. If the element is mandatory, there's no
		  match and we can return false directly.
		
		  Now check the pattern element constraints. If the pattern is
		  not able to handle the whole instruction in a single step,
		  we have to split it.
		  The last_instr_end_off value comes back updated to point to
		  the position where we have to split the instruction (the
		  start of the next subop chunk).
	
	  This can happen if all instructions of a pattern are optional.
	  Still, if there's not at least one instruction handled by this
	  pattern, this is not a match, and we should try the next one (if
	  any).
	
	  We had a match on the pattern head, but the pattern may be longer
	  than the instructions we're asked to execute. We need to make sure
	  there's no mandatory elements in the pattern tail.
	
	  We have a match: update the subop structure accordingly and return
	  true.
 NOP 
  nand_op_parser_exec_op - exec_op parser
  @chip: the NAND chip
  @parser: patterns description provided by the controller driver
  @op: the NAND operation to address
  @check_only: when true, the function only checks if @op can be handled but
 		does not execute the operation
  Helper function designed to ease integration of NAND controller drivers that
  only support a limited set of instruction sequences. The supported sequences
  are described in @parser, and the framework takes care of splitting @op into
  multiple sub-operations (if required) and pass them back to the ->exec()
  callback of the matching pattern if @check_only is set to false.
  NAND controller drivers should call this function from their own ->exec_op()
  implementation.
  Returns 0 on success, a negative error code otherwise. A failure can be
  caused by an unsupported operation (none of the supported patterns is able
  to handle the requested operation), or an error returned by one of the
  matching pattern->exec() hook.
		
		  Update the context structure by pointing to the start of the
		  next subop.
  nand_subop_get_addr_start_off - Get the start offset in an address array
  @subop: The entire sub-operation
  @instr_idx: Index of the instruction inside the sub-operation
  During driver development, one could be tempted to directly use the
  ->addr.addrs field of address instructions. This is wrong as address
  instructions might be split.
  Given an address instruction, returns the offset of the first cycle to issue.
  nand_subop_get_num_addr_cyc - Get the remaining address cycles to assert
  @subop: The entire sub-operation
  @instr_idx: Index of the instruction inside the sub-operation
  During driver development, one could be tempted to directly use the
  ->addr->naddrs field of a data instruction. This is wrong as instructions
  might be split.
  Given an address instruction, returns the number of address cycle to issue.
  nand_subop_get_data_start_off - Get the start offset in a data array
  @subop: The entire sub-operation
  @instr_idx: Index of the instruction inside the sub-operation
  During driver development, one could be tempted to directly use the
  ->data->buf.{in,out} field of data instructions. This is wrong as data
  instructions might be split.
  Given a data instruction, returns the offset to start from.
  nand_subop_get_data_len - Get the number of bytes to retrieve
  @subop: The entire sub-operation
  @instr_idx: Index of the instruction inside the sub-operation
  During driver development, one could be tempted to directly use the
  ->data->len field of a data instruction. This is wrong as data instructions
  might be split.
  Returns the length of the chunk of data to sendreceive.
  nand_reset - Reset and initialize a NAND device
  @chip: The NAND chip
  @chipnr: Internal die id
  Save the timings data structure, then apply SDR timings mode 0 (see
  nand_reset_interface for details), do the reset operation, and apply
  back the previous timings.
  Returns 0 on success, a negative error code otherwise.
	
	  The CS line has to be released before we can apply the new NAND
	  interface settings, hence this weird nand_select_target()
	  nand_deselect_target() dance.
  nand_get_features - wrapper to perform a GET_FEATURE
  @chip: NAND chip info structure
  @addr: feature address
  @subfeature_param: the subfeature parameters, a four bytes array
  Returns 0 for success, a negative error otherwise. Returns -ENOTSUPP if the
  operation cannot be handled.
  nand_set_features - wrapper to perform a SET_FEATURE
  @chip: NAND chip info structure
  @addr: feature address
  @subfeature_param: the subfeature parameters, a four bytes array
  Returns 0 for success, a negative error otherwise. Returns -ENOTSUPP if the
  operation cannot be handled.
  nand_check_erased_buf - check if a buffer contains (almost) only 0xff data
  @buf: buffer to test
  @len: buffer length
  @bitflips_threshold: maximum number of bitflips
  Check if a buffer contains only 0xff, which means the underlying region
  has been erased and is ready to be programmed.
  The bitflips_threshold specify the maximum number of bitflips before
  considering the region is not erased.
  Note: The logic of this function has been extracted from the memweight
  implementation, except that nand_check_erased_buf function exit before
  testing the whole buffer if the number of bitflips exceed the
  bitflips_threshold value.
  Returns a positive number of bitflips less than or equal to
  bitflips_threshold, or -ERROR_CODE for bitflips in excess of the
  threshold.
  nand_check_erased_ecc_chunk - check if an ECC chunk contains (almost) only
 				 0xff data
  @data: data buffer to test
  @datalen: data length
  @ecc: ECC buffer
  @ecclen: ECC length
  @extraoob: extra OOB buffer
  @extraooblen: extra OOB length
  @bitflips_threshold: maximum number of bitflips
  Check if a data buffer and its associated ECC and OOB data contains only
  0xff pattern, which means the underlying region has been erased and is
  ready to be programmed.
  The bitflips_threshold specify the maximum number of bitflips before
  considering the region as not erased.
  Note:
  1 ECC algorithms are working on pre-defined block sizes which are usually
     different from the NAND page size. When fixing bitflips, ECC engines will
     report the number of errors per chunk, and the NAND core infrastructure
     expect you to return the maximum number of bitflips for the whole page.
     This is why you should always use this function on a single chunk and
     not on the whole page. After checking each chunk you should update your
     max_bitflips value accordingly.
  2 When checking for bitflips in erased pages you should not only check
     the payload data but also their associated ECC data, because a user might
     have programmed almost all bits to 1 but a few. In this case, we
     shouldn't consider the chunk as erased, and checking ECC bytes prevent
     this case.
  3 The extraoob argument is optional, and should be used if some of your OOB
     data are protected by the ECC engine.
     It could also be used if you support subpages and want to attach some
     extra OOB data to an ECC chunk.
  Returns a positive number of bitflips less than or equal to
  bitflips_threshold, or -ERROR_CODE for bitflips in excess of the
  threshold. In case of success, the passed buffers are filled with 0xff.
  nand_read_page_raw_notsupp - dummy read raw page function
  @chip: nand chip info structure
  @buf: buffer to store read data
  @oob_required: caller requires OOB data read to chip->oob_poi
  @page: page number to read
  Returns -ENOTSUPP unconditionally.
  nand_read_page_raw - [INTERN] read raw page data without ecc
  @chip: nand chip info structure
  @buf: buffer to store read data
  @oob_required: caller requires OOB data read to chip->oob_poi
  @page: page number to read
  Not for syndrome calculating ECC controllers, which use a special oob layout.
  nand_monolithic_read_page_raw - Monolithic page read in raw mode
  @chip: NAND chip info structure
  @buf: buffer to store read data
  @oob_required: caller requires OOB data read to chip->oob_poi
  @page: page number to read
  This is a raw page read, ie. without any error detectioncorrection.
  Monolithic means we are requesting all the relevant data (main plus
  eventually OOB) to be loaded in the NAND cache and sent over the
  bus (from the NAND chip to the NAND controller) in a single
  operation. This is an alternative to nand_read_page_raw(), which
  first reads the main data, and if the OOB data is requested too,
  then reads more data on the bus.
  nand_read_page_raw_syndrome - [INTERN] read raw page data without ecc
  @chip: nand chip info structure
  @buf: buffer to store read data
  @oob_required: caller requires OOB data read to chip->oob_poi
  @page: page number to read
  We need a special oob layout and handling even when OOB isn't used.
  nand_read_page_swecc - [REPLACEABLE] software ECC based page read function
  @chip: nand chip info structure
  @buf: buffer to store read data
  @oob_required: caller requires OOB data read to chip->oob_poi
  @page: page number to read
  nand_read_subpage - [REPLACEABLE] ECC based sub-page read function
  @chip: nand chip info structure
  @data_offs: offset of requested data within the page
  @readlen: data length
  @bufpoi: buffer to store read data
  @page: page number to read
 Column address within the page aligned to ECC size (256bytes) 
 Data size aligned to ECC ecc.size 
 If we read not a page aligned data 
 Calculate ECC 
	
	  The performance is faster if we position offsets according to
	  ecc.pos. Let's make sure that there are no gaps in ECC positions.
		
		  Send the command to read the particular ECC bytes take care
		  about buswidth alignment in read_buf.
 check for empty pages with bitflips 
  nand_read_page_hwecc - [REPLACEABLE] hardware ECC based page read function
  @chip: nand chip info structure
  @buf: buffer to store read data
  @oob_required: caller requires OOB data read to chip->oob_poi
  @page: page number to read
  Not for syndrome calculating ECC controllers which need a special oob layout.
 check for empty pages with bitflips 
  nand_read_page_syndrome - [REPLACEABLE] hardware ECC syndrome based page read
  @chip: nand chip info structure
  @buf: buffer to store read data
  @oob_required: caller requires OOB data read to chip->oob_poi
  @page: page number to read
  The hw generator calculates the error syndrome automatically. Therefore we
  need a special oob layout and handling.
 check for empty pages with bitflips 
 Calculate remaining oob bytes 
  nand_transfer_oob - [INTERN] Transfer oob to client buffer
  @chip: NAND chip object
  @oob: oob destination address
  @ops: oob ops structure
  @len: size of oob to transfer
  nand_setup_read_retry - [INTERN] Set the READ RETRY mode
  @chip: NAND chip object
  @retry_mode: the retry mode to use
  Some vendors supply a special command to shift the Vt threshold, to be used
  when there are too many bitflips in a page (i.e., ECC error). After setting
  a new threshold, the host should retry reading the page.
  nand_do_read_ops - [INTERN] Read data with ECC
  @chip: NAND chip object
  @from: offset to read from
  @ops: oob ops structure
  Internal function. Called with chip held.
 Check if the region is secured 
 Is the current page in the buffer? 
			
			  Now read the page into the buffer.  Absent an error,
			  the read methods return max bitflips per ecc step.
 Invalidate page cache 
			
			  Copy back the data in the initial buffer when reading
			  partial pages or when a bounce buffer is required.
 Invalidate page cache 
 Reset ecc_stats; retry 
 No more retry modes; real failure 
 Reset to retry mode 0 
 For subsequent reads align to page boundary 
 Increment page address 
 Check, if we cross a chip boundary 
  nand_read_oob_std - [REPLACEABLE] the most common OOB data read function
  @chip: nand chip info structure
  @page: page number to read
  nand_read_oob_syndrome - [REPLACEABLE] OOB data read function for HW ECC
 			    with syndromes
  @chip: nand chip info structure
  @page: page number to read
  nand_write_oob_std - [REPLACEABLE] the most common OOB data write function
  @chip: nand chip info structure
  @page: page number to write
  nand_write_oob_syndrome - [REPLACEABLE] OOB data write function for HW ECC
 			     with syndrome - only for large page flash
  @chip: nand chip info structure
  @page: page number to write
	
	  data-ecc-data-ecc ... ecc-oob
	  or
	  data-pad-ecc-pad-data-pad .... ecc-pad-oob
  nand_do_read_oob - [INTERN] NAND read out-of-band
  @chip: NAND chip object
  @from: offset to read from
  @ops: oob operations description structure
  NAND read out-of-band data from the spare area.
 Check if the region is secured 
 Shift to get page 
 Increment page address 
 Check, if we cross a chip boundary 
  nand_read_oob - [MTD Interface] NAND read data andor out-of-band
  @mtd: MTD device structure
  @from: offset to read from
  @ops: oob operation description structure
  NAND read data andor out-of-band data.
  nand_write_page_raw_notsupp - dummy raw page write function
  @chip: nand chip info structure
  @buf: data buffer
  @oob_required: must write chip->oob_poi to OOB
  @page: page number to write
  Returns -ENOTSUPP unconditionally.
  nand_write_page_raw - [INTERN] raw page write function
  @chip: nand chip info structure
  @buf: data buffer
  @oob_required: must write chip->oob_poi to OOB
  @page: page number to write
  Not for syndrome calculating ECC controllers, which use a special oob layout.
  nand_monolithic_write_page_raw - Monolithic page write in raw mode
  @chip: NAND chip info structure
  @buf: data buffer to write
  @oob_required: must write chip->oob_poi to OOB
  @page: page number to write
  This is a raw page write, ie. without any error detectioncorrection.
  Monolithic means we are requesting all the relevant data (main plus
  eventually OOB) to be sent over the bus and effectively programmed
  into the NAND chip arrays in a single operation. This is an
  alternative to nand_write_page_raw(), which first sends the main
  data, then eventually send the OOB data by latching more data
  cycles on the NAND bus, and finally sends the program command to
  synchronyze the NAND chip cache.
  nand_write_page_raw_syndrome - [INTERN] raw page write function
  @chip: nand chip info structure
  @buf: data buffer
  @oob_required: must write chip->oob_poi to OOB
  @page: page number to write
  We need a special oob layout and handling even when ECC isn't checked.
  nand_write_page_swecc - [REPLACEABLE] software ECC based page write function
  @chip: nand chip info structure
  @buf: data buffer
  @oob_required: must write chip->oob_poi to OOB
  @page: page number to write
 Software ECC calculation 
  nand_write_page_hwecc - [REPLACEABLE] hardware ECC based page write function
  @chip: nand chip info structure
  @buf: data buffer
  @oob_required: must write chip->oob_poi to OOB
  @page: page number to write
  nand_write_subpage_hwecc - [REPLACEABLE] hardware ECC based subpage write
  @chip:	nand chip info structure
  @offset:	column address of subpage within the page
  @data_len:	data length
  @buf:	data buffer
  @oob_required: must write chip->oob_poi to OOB
  @page: page number to write
 configure controller for WRITE access 
 write data (untouched subpages already masked by 0xFF) 
 mask ECC of un-touched subpages by padding 0xFF 
 mask OOB of un-touched subpages by padding 0xFF 
 if oob_required, preserve OOB metadata of written subpage 
 copy calculated ECC for whole page to chip->buffer->oob 
 this include masked-value(0xFF) for unwritten subpages 
 write OOB buffer to NAND device 
  nand_write_page_syndrome - [REPLACEABLE] hardware ECC syndrome based page write
  @chip: nand chip info structure
  @buf: data buffer
  @oob_required: must write chip->oob_poi to OOB
  @page: page number to write
  The hw generator calculates the error syndrome automatically. Therefore we
  need a special oob layout and handling.
 Calculate remaining oob bytes 
  nand_write_page - write one page
  @chip: NAND chip descriptor
  @offset: address offset within the page
  @data_len: length of actual data to be written
  @buf: the data to write
  @oob_required: must write chip->oob_poi to OOB
  @page: page number to write
  @raw: use _raw version of write_page
  nand_do_write_ops - [INTERN] NAND write with ECC
  @chip: NAND chip object
  @to: offset to write to
  @ops: oob operations description structure
  NAND write with ECC.
 Reject writes, which are not page aligned 
 Check if the region is secured 
 Check, if it is write protected 
 Invalidate the page cache, when we write to the cached page 
 Don't allow multipage oob writes with offset 
		
		  Copy the data from the initial buffer when doing partial page
		  writes or when a bounce buffer is required.
 We still need to erase leftover OOB data 
 Check, if we cross a chip boundary 
  panic_nand_write - [MTD Interface] NAND write with ECC
  @mtd: MTD device structure
  @to: offset to write to
  @len: number of bytes to write
  @retlen: pointer to variable to store the number of written bytes
  @buf: the data to write
  NAND write with ECC. Used when performing writes in interrupt context, this
  may for example be called by mtdoops when writing an oops while in panic.
 Wait for the device to get ready 
  nand_write_oob - [MTD Interface] NAND write data andor out-of-band
  @mtd: MTD device structure
  @to: offset to write to
  @ops: oob operation description structure
  nand_erase - [MTD Interface] erase block(s)
  @mtd: MTD device structure
  @instr: erase instruction
  Erase one ore more blocks.
  nand_erase_nand - [INTERN] erase block(s)
  @chip: NAND chip object
  @instr: erase instruction
  @allowbbt: allow erasing the bbt area
  Erase one ore more blocks.
 Check if the region is secured 
 Grab the lock and see if the device is available 
 Shift to get first page 
 Calculate pages in each block 
 Select the NAND device 
 Check, if it is write protected 
 Loop through the pages 
 Check if we have a bad block, we do not erase bad blocks! 
		
		  Invalidate the page cache, if we erase the block which
		  contains the current cached page.
 Increment page address and decrement length 
 Check, if we cross a chip boundary 
 Deselect and wake up anyone waiting on the device 
 Return more or less happy 
  nand_sync - [MTD Interface] sync
  @mtd: MTD device structure
  Sync is actually a wait for chip ready function.
 Grab the lock and see if the device is available 
 Release it and go back 
  nand_block_isbad - [MTD Interface] Check if block at offset is bad
  @mtd: MTD device structure
  @offs: offset relative to mtd start
 Select the NAND device 
  nand_block_markbad - [MTD Interface] Mark block at the given offset as bad
  @mtd: MTD device structure
  @ofs: offset relative to mtd start
 If it was bad already, return success and do nothing 
  nand_suspend - [MTD Interface] Suspend the NAND flash
  @mtd: MTD device structure
  Returns 0 for success or negative error code otherwise.
  nand_resume - [MTD Interface] Resume the NAND flash
  @mtd: MTD device structure
  nand_shutdown - [MTD Interface] Finish the current NAND operation and
                  prevent further operations
  @mtd: MTD device structure
  nand_lock - [MTD Interface] Lock the NAND flash
  @mtd: MTD device structure
  @ofs: offset byte address
  @len: number of bytes to lock (must be a multiple of blockpage size)
  nand_unlock - [MTD Interface] Unlock the NAND flash
  @mtd: MTD device structure
  @ofs: offset byte address
  @len: number of bytes to unlock (must be a multiple of blockpage size)
 Set default functions 
 If no controller is provided, use the dummy, legacy one. 
 Sanitize ONFI strings so we can safely print them 
 Null terminate 
 Remove non printable chars 
 Remove trailing spaces 
  nand_id_has_period - Check if an ID string has a given wraparound period
  @id_data: the ID string
  @arrlen: the length of the @id_data array
  @period: the period of repitition
  Check if an ID string is repeated within a given sequence of bytes at
  specific repetition interval period (e.g., {0x20,0x01,0x7F,0x20} has a
  period of 3). This is a helper function for nand_id_len(). Returns non-zero
  if the repetition has a period of @period; otherwise, returns zero.
  nand_id_len - Get the length of an ID string returned by CMD_READID
  @id_data: the ID string
  @arrlen: the length of the @id_data array
  Returns the length of the ID string, according to known wraparoundtrailing
  zero patterns. If no pattern exists, returns the length of the array.
 Find last non-zero byte 
 All zeros 
 Calculate wraparound period 
 There's a repeated pattern 
 There are trailing zeros 
 No pattern detected 
 Extract the bits of per cell from the 3rd byte of the extended ID 
  Many new NAND share similar device ID codes, which represent the size of the
  chip. The rest of the parameters must be decoded according to generic or
  manufacturer-specific "extended ID" decoding patterns.
 The 3rd id byte holds MLC  multichip data 
 The 4th id byte is the important one 
 Calc pagesize 
 Calc oobsize 
 Calc blocksize. Blocksize is multiples of 64KiB 
 Get buswidth information 
  Old devices have chip data hardcoded in the device ID table. nand_decode_id
  decodes a matching ID table entry and assigns the MTD size parameters for
  the chip.
 All legacy ID NAND are small-page, SLC 
  Set the bad block markerindicator (BBMBBI) patterns according to some
  heuristic patterns using various detected parameters (e.g., manufacturer,
  page size, cell-type information).
 Set the bad block position 
  Manufacturer detection. Only used when the NAND is not ONFI or JEDEC
  compliant and does not have a full-id or legacy-id entry in the nand_ids
  table.
	
	  Try manufacturer detection if available and use
	  nand_decode_ext_id() otherwise.
 The 3rd id byte holds MLC  multichip data 
  Manufacturer initialization. This function is called for all NANDs including
  ONFI and JEDEC compliant ones.
  Manufacturer drivers should put all their specific initialization code in
  their ->init() hook.
  Manufacturer cleanup. This function is called for all NANDs including
  ONFI and JEDEC compliant ones.
  Manufacturer drivers should put all their specific cleanup code in their
  ->cleanup() hook.
 Release manufacturer private data 
  Get the flash and manufacturer id and lookup if the type is supported.
	
	  Let's start by initializing memorg fields that might be left
	  unassigned by the ID-based detection logic.
	
	  Reset the chip, required by some chips (e.g. Micron MT29FxGxxxxx)
	  after power-up.
 Select the device 
 Send the command for reading device ID 
 Read manufacturer and device IDs 
	
	  Try again to make sure, as some systems the bus-hold or other
	  interface concerns can cause random data which looks like a
	  possibly credible NAND flash to appear. If the two results do
	  not match, ignore the device completely.
 Read entire ID string 
 Try to identify manufacturer 
	
	  Save the NAND_BUSWIDTH_16 flag before letting auto-detection logic
	  override it.
	  This is required to make sure initial NAND bus width set by the
	  NAND controller driver is coherent with the real NAND bus width
	  (extracted by auto-detection code).
	
	  The flag is only set (never cleared), reset it to its default value
	  before starting auto-detection.
 Check if the chip is ONFI compliant 
 Check if the chip is JEDEC compliant 
 Get chip options 
		
		  Check, if buswidth is correct. Hardware drivers should set
		  chip correct!
 Calculate the address shift from the page size 
 Convert chipsize to number of pages per chip -1 
 Only proceed if the "secure-regions" property is present in DT 
  rawnand_dt_parse_gpio_cs - Parse the gpio-cs property of a controller
  @dev: Device that will be parsed. Also used for managed allocations.
  @cs_array: Array of GPIO desc pointers allocated on success
  @ncs_array: Number of entries in @cs_array updated on success.
  @return 0 on success, an error otherwise.
	
	  If neither the user nor the NAND controller have requested a specific
	  ECC engine type, we will default to NAND_ECC_ENGINE_TYPE_ON_HOST.
	
	  Use the user requested engine type, unless there is none, in this
	  case default to the NAND controller choice, otherwise fallback to
	  the raw NAND default one.
  nand_scan_ident - Scan for the NAND device
  @chip: NAND chip object
  @maxchips: number of chips to scan for
  @table: alternative NAND ID table
  This is the first phase of the normal nand_scan() function. It reads the
  flash ID and sets up MTD fields accordingly.
  This helper used to be called directly from controller drivers that needed
  to tweak some ECC-related parameters before nand_scan_tail(). This separation
  prevented dynamic allocations during this phase which was unconvenient and
  as been banned for the benefit of the ->init_ecc()cleanup_ecc() hooks.
 Assume all dies are deselected when we enter nand_scan_ident(). 
 Enforce the right timings for resetdetection 
 Set the default functions 
 Read the flash type 
 Check for a chip array 
 See comment in nand_get_flash_type for reset 
 Send the command for reading device ID 
 Read manufacturer and device IDs 
 Store the number of chips and calc total size for mtd 
 Use standard hwecc read page function? 
 Use standard syndrome readwrite page function? 
		
		  We can only maximize ECC config when the default layout is
		  used, otherwise we don't know how many bytes can really be
		  used.
  nand_check_ecc_caps - check the sanity of preset ECC settings
  @chip: nand chip info structure
  @caps: ECC caps info structure
  @oobavail: OOB size that the ECC engine can use
  When ECC step size and strength are already set, check if they are supported
  by the controller and the calculated ECC bytes fit within the chip's OOB.
  On success, the calculated ECC bytes is set.
  nand_match_ecc_req - meet the chip's requirement with least ECC bytes
  @chip: nand chip info structure
  @caps: ECC engine caps info structure
  @oobavail: OOB size that the ECC engine can use
  If a chip's ECC requirement is provided, try to meet it with the least
  number of ECC bytes (i.e. with the largest number of OOB-free bytes).
  On success, the chosen ECC settings are set.
 No information provided by the NAND chip 
 number of correctable bits the chip requires in a page 
			
			  If both step size and strength are smaller than the
			  chip's requirement, it is not easy to compare the
			  resulted reliability.
			
			  We assume the best is to meet the chip's requrement
			  with the least number of ECC bytes.
  nand_maximize_ecc - choose the max ECC strength available
  @chip: nand chip info structure
  @caps: ECC engine caps info structure
  @oobavail: OOB size that the ECC engine can use
  Choose the max ECC strength that is supported on the controller, and can fit
  within the chip's OOB.  On success, the chosen ECC settings are set.
 If chip->ecc.size is already set, respect it 
			
			  If the number of correctable bits is the same,
			  bigger step_size has more reliability.
  nand_ecc_choose_conf - Set the ECC strength and ECC step size
  @chip: nand chip info structure
  @caps: ECC engine caps info structure
  @oobavail: OOB size that the ECC engine can use
  Choose the ECC configuration according to following logic.
  1. If both ECC step size and ECC strength are already set (usually by DT)
     then check if it is supported by this controller.
  2. If the user provided the nand-ecc-maximize property, then select maximum
     ECC strength.
  3. Otherwise, try to match the ECC step size and ECC strength closest
     to the chip's requirement. If available OOB size can't fit the chip
     requirement then fallback to the maximum ECC step size and ECC strength.
  On success, the chosen ECC settings are set.
  nand_scan_tail - Scan for the NAND device
  @chip: NAND chip object
  This is the second phase of the normal nand_scan() function. It fills out
  all the uninitialized function pointers with the defaults and scans for a
  bad block table if appropriate.
 New bad blocks should be marked in OOB, flash-based BBT, or both 
	
	  FIXME: some NAND manufacturer drivers expect the first die to be
	  selected when manufacturer->init() is called. They should be fixed
	  to explictly select the relevant die when interacting with the NAND
	  chip.
 Set the internal oob buffer location, just after the page data 
	
	  If no default placement scheme is given, select an appropriate one.
			
			  Expose the whole OOB area to users if ECC_NONE
			  is passed. We could do that for all kind of
			  ->oobsize, but we must keep the old largesmall
			  page with ECC layout when ->oobsize <= 128 for
			  compatibility reasons.
	
	  Check ECC mode, default to software if 3byte512byte hardware ECC is
	  selected and we have 256 byte pagesize fallback to software ECC
 For many systems, the standard OOB write also works for raw 
 propagate ecc info to mtd_info 
	
	  Set the number of read  write steps for one page depending on ECC
	  mode.
	
	  The number of bytes available for a client to place data into
	  the out of band area.
 ECC sanity check: warn if it's too weak 
 Allow subpage writes up to ecc.steps. Not possible for MLC flash 
 Invalidate the pagebuffer reference 
 Large page NAND with SOFT_ECC should support subpage reads 
 Adjust the MTD_CAP_ flags when NAND_ROM is set. 
 Fill in remaining MTD driver data 
	
	  Initialize bitflip_threshold to its default prior scan_bbt() call.
	  scan_bbt() might invoke mtd_read(), thus bitflip_threshold must be
	  properly set.
 Find the fastest data interface for this chip 
 Enter fastest possible mode on all dies. 
	
	  Look for secure regions in the NAND chip. These regions are supposed
	  to be protected by a secure element like Trustzone. So the readwrite
	  accesses to these regions will be blocked in the runtime by this
	  driver.
 Check, if we should skip the bad block table scan 
 Build bad block table 
  nand_scan_with_ids - [NAND Interface] Scan for the NAND device
  @chip: NAND chip object
  @maxchips: number of chips to scan for.
  @ids: optional flash IDs table
  This fills out all the uninitialized function pointers with the defaults.
  The flash ID is read and the mtdchip structures are filled with the
  appropriate values.
  nand_cleanup - [NAND Interface] Free resources held by the NAND device
  @chip: NAND chip object
 Free secure regions data 
 Free bad block table memory 
 Free bad block descriptor memory 
 Free the data interface 
 Free manufacturer priv data. 
 Free controller specific allocations after chip identification 
 Free identification phase allocations 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright  2004 Texas Instruments, Jian Zhang <jzhang@ti.com>
  Copyright  2004 Micron Technology Inc.
  Copyright  2004 David Brownell
 4 bit padding to make byte aligned, 56 = 52 + 4 
 GPMC ecc engine settings for read 
 BCH wrap mode 1 
 ecc_size0 = 26 
 ecc_size1 = 2 
 ecc_size0 = 13 
 ecc_size1 = 3 
 GPMC ecc engine settings for write 
 BCH wrap mode 6 
 ecc_size0 = 0, no oob protection 
 ecc_size1 = 32 
 read 
 write 
 Interface to GPMC 
 fields specific for BCHx_HW ECC scheme 
 NAND ready gpio 
  omap_prefetch_enable - configures and starts prefetch transfer
  @cs: cs (chip select) number
  @fifo_th: fifo threshold to be used for read write
  @dma_mode: dma mode enable (1) or disable (0)
  @u32_count: number of bytes to be transferred
  @is_write: prefetch read(0) or write post(1) mode
  @info: NAND device structure containing platform data
 Set the amount of bytes to be prefetched 
	 Set dmampu mode, the prefetch read  post write and
	  enable the engine. Set which cs is has requested for.
  Start the prefetch engine 
  omap_prefetch_reset - disables and stops the prefetch engine
 check if the same modulecs is trying to reset 
 Stop the PFPW engine 
 Resetdisable the PFPW engine 
  omap_hwcontrol - hardware specific access to control-lines
  @chip: NAND chip object
  @cmd: command to device
  @ctrl:
  NAND_NCE: bit 0 -> don't care
  NAND_CLE: bit 1 -> Command Latch
  NAND_ALE: bit 2 -> Address Latch
  NOTE: boards may use different bits for these!!
 NAND_NCE 
  omap_read_buf8 - read data from NAND controller into buffer
  @mtd: MTD device structure
  @buf: buffer to store date
  @len: number of bytes to read
  omap_write_buf8 - write buffer to NAND controller
  @mtd: MTD device structure
  @buf: data buffer
  @len: number of bytes to write
 wait until buffer is available for write 
  omap_read_buf16 - read data from NAND controller into buffer
  @mtd: MTD device structure
  @buf: buffer to store date
  @len: number of bytes to read
  omap_write_buf16 - write buffer to NAND controller
  @mtd: MTD device structure
  @buf: data buffer
  @len: number of bytes to write
 FIXME try bursts of writesw() or DMA ... 
 wait until buffer is available for write 
  omap_read_buf_pref - read data from NAND controller into buffer
  @chip: NAND chip object
  @buf: buffer to store date
  @len: number of bytes to read
 take care of subpage reads 
 configure and start prefetch transfer 
 PFPW engine is busy, use cpu copy method 
 disable and stop the PFPW engine 
  omap_write_buf_pref - write buffer to NAND controller
  @chip: NAND chip object
  @buf: data buffer
  @len: number of bytes to write
 take care of subpage writes 
  configure and start prefetch transfer 
 PFPW engine is busy, use cpu copy method 
 wait for data to flushed-out before reset the prefetch 
 disable and stop the PFPW engine 
  omap_nand_dma_callback: callback on the completion of dma transfer
  @data: pointer to completion data structure
  omap_nand_dma_transfer: configure and start dma transfer
  @mtd: MTD device structure
  @addr: virtual address in RAM of sourcedestination
  @len: number of data bytes to be transferred
  @is_write: flag for readwrite operation
 setup and start DMA using dma_addr 
  configure and start prefetch transfer 
 PFPW engine is busy, use cpu copy method 
 disable and stop the PFPW engine 
  omap_read_buf_dma_pref - read data from NAND controller into buffer
  @chip: NAND chip object
  @buf: buffer to store date
  @len: number of bytes to read
 start transfer in DMA mode 
  omap_write_buf_dma_pref - write buffer to NAND controller
  @chip: NAND chip object
  @buf: data buffer
  @len: number of bytes to write
 start transfer in DMA mode 
  omap_nand_irq - GPMC irq handler
  @this_irq: gpmc irq number
  @dev: omap_nand_info structure pointer is passed here
 io in multiple of 4 bytes 
 checks for write io 
  omap_read_buf_irq_pref - read data from NAND controller into buffer
  @chip: NAND chip object
  @buf: buffer to store date
  @len: number of bytes to read
  configure and start prefetch transfer 
 PFPW engine is busy, use cpu copy method 
 waiting for read to complete 
 disable and stop the PFPW engine 
  omap_write_buf_irq_pref - write buffer to NAND controller
  @chip: NAND chip object
  @buf: data buffer
  @len: number of bytes to write
 configure and start prefetch transfer : size=24 
 PFPW engine is busy, use cpu copy method 
 waiting for write to complete 
 wait for data to flushed-out before reset the prefetch 
 disable and stop the PFPW engine 
  gen_true_ecc - This function will generate true ECC value
  @ecc_buf: buffer to store ecc code
  This generated true ECC value can be used when correcting
  data read from NAND flash memory core
  omap_compare_ecc - Detect (2 bits) and correct (1 bit) error in data
  @ecc_data1:  ecc code from nand spare area
  @ecc_data2:  ecc code from hardware register obtained from hardware ecc
  @page_data:  page data
  This function compares two ECC's and indicates if there is an error.
  If the error can be corrected it will be corrected to the buffer.
  If there is no error, %0 is returned. If there is an error but it
  was corrected, %1 is returned. Otherwise, %-1 is returned.
 read from NAND memory 
 read from register 
		 Not reached because this function is not called if
		   ECC values are equal
 Uncorrectable error 
 UN-Correctable error 
 Correctable error 
  omap_correct_data - Compares the ECC read with HW generated ECC
  @chip: NAND chip object
  @dat: page data
  @read_ecc: ecc read from nand flash
  @calc_ecc: ecc read from HW ECC registers
  Compares the ecc read from nand spare area with ECC registers values
  and if ECC's mismatched, it will call 'omap_compare_ecc' for error
  detection and correction. If there are no errors, %0 is returned. If
  there were errors and all of the errors were corrected, the number of
  corrected errors is returned. If uncorrectable errors exist, %-1 is
  returned.
 Ex NAND_ECC_HW12_2048 
 keep track of the number of corrected errors 
  omap_calculate_ecc - Generate non-inverted ECC bytes.
  @chip: NAND chip object
  @dat: The pointer to data on which ecc is computed
  @ecc_code: The ecc_code buffer
  Using noninverted ECC can be considered ugly since writing a blank
  page ie. padding will clear the ECC bytes. This is no problem as long
  nobody is trying to write data on the seemingly unused page. Reading
  an erased page will produce an ECC mismatch between generated and read
  ECC bytes that has to be dealt with separately.
 read ecc result 
 P128e, ..., P1e 
 P128o, ..., P1o 
 P2048o, P1024o, P512o, P256o, P2048e, P1024e, P512e, P256e 
  omap_enable_hwecc - This function enables the hardware ecc functionality
  @chip: NAND chip object
  @mode: ReadWrite mode
 clear ecc and enable bits 
 program ecc and result sizes 
 (ECC 16 or 8 bit col) | ( CS  )  | ECC Enable 
  omap_wait - wait until the command is done
  @this: NAND Chip structure
  Wait function is called during Program and erase operations and
  the way it is called from MTD layer, we should wait till the NAND
  chip is ready after the programmingerase operation has completed.
  Erase can take up to 400ms and program up to 20ms according to
  general NAND and SmartMedia specs
  omap_dev_ready - checks the NAND Ready GPIO line
  @chip: NAND chip object
  Returns true if ready and false if busy.
  omap_enable_hwecc_bch - Program GPMC to perform BCH ECC calculation
  @chip: NAND chip object
  @mode: ReadWrite mode
  When using BCH with SW correction (i.e. no ELM), sector size is set
  to 512 bytes and we use BCH_WRAPMODE_6 wrapping mode
  for both reading and writing with:
  eccsize0 = 0  (no additional protected byte in spare area)
  eccsize1 = 32 (skip 32 nibbles = 16 bytes per sector in spare area)
 GPMC configurations for calculating ECC 
 ECC bits in nibbles per sector 
 non-ECC bits in nibbles per sector 
 extra bits in nibbles per sector 
 OOB bits in nibbles per sector 
 Configure ecc size for BCH 
 BCH configuration 
 enable BCH 
 BCH4BCH8BCH16 
 wrap mode 
 bus width 
 number of sectors 
 ECC CS 
 enable ECC 
 Clear ecc and enable bits 
  _omap_calculate_ecc_bch - Generate ECC bytes for one sector
  @mtd:	MTD device structure
  @dat:	The pointer to data on which ecc is computed
  @ecc_calc:	The ecc_code buffer
  @i:		The sector number (for a multi sector page)
  Support calculating of BCH4816 ECC vectors for one sector
  within a page. Sector number is in @i.
 ECC scheme specific syndrome customizations 
		 Add constant polynomial to remainder, so that
		  ECC of blank pages results in 0x0 on reading back
 Set  8th ECC byte as 0x0 for ROM compatibility 
		 Add constant polynomial to remainder, so that
		  ECC of blank pages results in 0x0 on reading back
 Set 14th ECC byte as 0x0 for ROM compatibility 
  omap_calculate_ecc_bch_sw - ECC generator for sector for SW based correction
  @chip:	NAND chip object
  @dat:	The pointer to data on which ecc is computed
  @ecc_calc:	Buffer storing the calculated ECC bytes
  Support calculating of BCH4816 ECC vectors for one sector. This is used
  when SW based correction is required as ECC is required for one sector
  at a time.
  omap_calculate_ecc_bch_multi - Generate ECC for multiple sectors
  @mtd:	MTD device structure
  @dat:	The pointer to data on which ecc is computed
  @ecc_calc:	Buffer storing the calculated ECC bytes
  Support calculating of BCH4816 ecc vectors for the entire page in one go.
  erased_sector_bitflips - count bit flips
  @data:	data sector buffer
  @oob:	oob buffer
  @info:	omap_nand_info
  Check the bit flips in erased page falls below correctable level.
  If falls below, report the page as erased with correctable bit
  flip, else report as uncorrectable page.
	
	  Bit flips falls in correctable level.
	  Fill data area with 0xFF
  omap_elm_correct_data - corrects page data area in case error reported
  @chip:	NAND chip object
  @data:	page data
  @read_ecc:	ecc read from nand flash
  @calc_ecc:	ecc read from HW ECC registers
  Calculated ecc vector reported as zero in case of non-error pages.
  In case of non-zero ecc vector, first filter out erased-pages, and
  then process data via ELM to detect bit-flips.
 omit  7th ECC byte reserved for ROM code compatibility 
 omit 14th ECC byte reserved for ROM code compatibility 
 Initialize elm error vector to zero 
 initialize eccflag 
		
		  Check any error reported,
		  In case of error, non zero ecc reported.
 non zero ecc, error present 
				
				  calc_ecc[] matches pattern for ECC(all 0xff)
				  so this is definitely an erased-page
				
				  count number of 0-bits in read_buf.
				  This check can be removed once a similar
				  check is introduced in generic NAND driver
					
					  number of 0-bits within ECC limits
					  So this may be an erased-page
					
					  Too many 0-bits. It may be a
					  - programmed-page, OR
					  - erased-page with many bit-flips
					  So this page requires check by ELM
 Update the ecc vector 
 Check if any error reported 
 Decode BCH error using ELM module 
 Add 4 bits to take care of padding 
 Calculate bit position of error 
 Calculate byte position of error 
 Update number of correctable errors 
 Update page data with sector size 
  omap_write_page_bch - BCH ecc based write page function for entire page
  @chip:		nand chip info structure
  @buf:		data buffer
  @oob_required:	must write chip->oob_poi to OOB
  @page:		page
  Custom write page method evolved to support multi sector writing in one shot
 Enable GPMC ecc engine 
 Write data 
 Update ecc vector from GPMC result registers 
 Write ecc vector to OOB area 
  omap_write_subpage_bch - BCH hardware ECC based subpage write
  @chip:	nand chip info structure
  @offset:	column address of subpage within the page
  @data_len:	data length
  @buf:	data buffer
  @oob_required: must write chip->oob_poi to OOB
  @page: page number to write
  OMAP optimized subpage write method.
	
	  Write entire page at one go as it would be optimal
	  as ECC is calculated by hardware.
	  ECC is calculated for all subpages but we choose
	  only what we want.
 Enable GPMC ECC engine 
 Write data 
 Mask ECC of un-touched subpages with 0xFFs 
		
		  Copy the calculated ECC for the whole page including the
		  masked values (0xFF) corresponding to unwritten subpages.
 write OOB buffer to NAND device 
  omap_read_page_bch - BCH ecc based page read function for entire page
  @chip:		nand chip info structure
  @buf:		buffer to store read data
  @oob_required:	caller requires OOB data read to chip->oob_poi
  @page:		page number to read
  For BCH ecc scheme, GPMC used for syndrome calculation and ELM module
  used for error correction.
  Custom method evolved to support ELM error correction & multi sector
  reading. On reading page data area is read along with OOB data with
  ecc engine enabled. ecc vector updated after read of OOB data.
  For non error pages ecc vector reported as zero.
 Enable GPMC ecc engine 
 Read data 
 Read oob bytes 
 Calculate ecc bytes 
  is_elm_present - checks for presence of ELM module by scanning DT nodes
  @info: NAND device structure containing platform data
  @elm_node: ELM's DT node
 check whether elm-id is passed via DT 
 check whether ELM device is registered 
 ELM module available, now configure it 
 detect availability of ELM module. Won't be present pre-OMAP4 
 select ecc-scheme for NAND 
 select data transfer mode 
	
	  When SW correction is employed, one OMAP specific marker byte is
	  reserved after each ECC step.
	
	  When SW correction is employed, one OMAP specific marker byte is
	  reserved after each ECC step.
 Re-populate low-level callbacks based on xfer modes 
 Use nand_base defaults for {read,write}_buf 
	
	  Bail out earlier to let NAND_ECC_ENGINE_TYPE_SOFT code create its own
	  ooblayout instead of using ours.
 Populate MTD interface based on ECC scheme 
 Reserve one byte for the OMAP marker 
 Software BCH library is used for locating errors 
 14th bit is kept reserved for ROM-code compatibility 
 Reserve one byte for the OMAP marker 
 Software BCH library is used for locating errors 
 14th bit is kept reserved for ROM-code compatibility 
 Check if NAND device's OOB is enough to store ECC signatures 
 Shared among all NAND instances to synchronize access to the ECC Engine 
	
	  If RDYBSY line is connected to OMAP then use the omap ready
	  function and the generic nand_wait function which reads the status
	  register after monitoring the RDYBSY line. Otherwise use a standard
	  chip delay which is slightly more than tR (AC Timing) of the NAND
	  device and read status register until you get a failure or success
 scan NAND device connected to chip controller 
 SPDX-License-Identifier: GPL-2.0
   Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
 		  2002-2006 Thomas Gleixner (tglx@linutronix.de)
   Credits:
 	David Woodhouse for adding multichip support
 	Aleph One Ltd. and Toby Churchill Ltd. for supporting the
 	rework for 2K page size chips
  This file contains all ONFI helpers.
 Parse the Extended Parameter Page. 
	
	  Use the Change Read Column command to skip the ONFI param pages and
	  ensure we read at the right location.
	
	  Check the signature.
	  Do not strictly follow the ONFI spec, maybe changed in future.
 find the ECC section. 
 get the info we want. 
  Recover data with bit-wise majority
  Check if the NAND chip is ONFI compliant, returns 1 if it is, 0 otherwise.
 Try ONFI for unknown chip or LP 
 ONFI chip: allocate a buffer to hold its parameter page 
 Check version 
	
	  pages_per_block and blocks_per_lun may not be a power-of-2 size
	  (don't ask me who thought of this...). MTD assumes that these
	  dimensions will be power-of-2, so just truncate the remaining area.
 See erasesize comment 
		
		  The nand_flash_detect_ext_param_page() uses the
		  Change Read Column command which maybe not supported
		  by the chip->legacy.cmdfunc. So try to update the
		  chip->legacy.cmdfunc now. We do not replace user supplied
		  command function.
 The Extended Parameter Page is supported since ONFI 2.1. 
 Save some parameters from the parameter page for future use 
 Identification done, free the full ONFI parameter page and exit 
 SPDX-License-Identifier: GPL-2.0
  Arasan NAND Flash Controller Driver
  Copyright (C) 2014 - 2020 Xilinx, Inc.
  Author:
    Miquel Raynal <miquel.raynal@bootlin.com>
  Original work (fully rewritten):
    Punnaiah Choudary Kalluri <punnaia@xilinx.com>
    Naga Sureshkumar Relli <nagasure@xilinx.com>
  struct anfc_op - Defines how to execute an operation
  @pkt_reg: Packet register
  @addr1_reg: Memory address 1 register
  @addr2_reg: Memory address 2 register
  @cmd_reg: Command register
  @prog_reg: Program register
  @steps: Number of "packets" to readwrite
  @rdy_timeout_ms: Timeout for waits on ReadyBusy pin
  @len: Data transfer length
  @read: Data transfer direction from the controller point of view
  @buf: Data buffer
  struct anand - Defines the NAND chip related information
  @node:		Used to store NAND chips into a list
  @chip:		NAND chip information structure
  @rb:			Ready-busy line
  @page_sz:		Register value of the page_sz field to use
  @clk:		Expected clock frequency to use
  @data_iface:		Data interface timing mode to use
  @timings:		NV-DDR specific timings to use
  @ecc_conf:		Hardware ECC configuration value
  @strength:		Register value of the ECC strength
  @raddr_cycles:	Row address cycle information
  @caddr_cycles:	Column address cycle information
  @ecc_bits:		Exact number of ECC bits per syndrome
  @ecc_total:		Total number of ECC bytes
  @errloc:		Array of errors located with soft BCH
  @hw_ecc:		Buffer to store syndromes computed by hardware
  @bch:		BCH structure
  @cs_idx:		Array of chip-select for this device, values are indexes
 			of the controller structure @gpio_cs array
  @ncs_idx:		Size of the @cs_idx array
  struct arasan_nfc - Defines the Arasan NAND flash controller driver instance
  @dev:		Pointer to the device structure
  @base:		Remapped register area
  @controller_clk:		Pointer to the system clock
  @bus_clk:		Pointer to the flash clock
  @controller:		Base controller structure
  @chips:		List of all NAND chips attached to the controller
  @cur_clk:		Current clock rate
  @cs_array:		CS array. Native CS are left empty, the other cells are
 			populated with their corresponding GPIO descriptor.
  @ncs:		Size of @cs_array
  @cur_cs:		Index in @cs_array of the currently in use CS
  @native_cs:		Currently selected native CS
  @spare_cs:		Native CS that is not wired (may be selected when a GPIO
 			CS is in use)
 There is no RB interrupt, we must poll a register 
 CS did not change: do nothing 
 Deassert the previous CS if it was a GPIO 
 Assert the new one 
 Update the controller timings and the potential ECC configuration 
 Update clock frequency 
  When using the embedded hardware ECC engine, the controller is in charge of
  feeding the engine with, first, the ECC residue present in the data array.
  A typical read operation is:
  1 Assert the read operation by sending the relevant commandaddress cycles
     but targeting the column of the first ECC bytes in the OOB area instead of
     the main data directly.
  2 After having read the relevant number of ECC bytes, the controller uses
     the RNDOUTRNDSTART commands which are set into the "ECC Spare Command
     Register" to move the pointer back at the beginning of the main data.
  3 It will read the content of the main area for a given size (pktsize) and
     will feed the ECC engine with this buffer again.
  4 The ECC engine derives the ECC bytes for the given data and compare them
     with the ones already received. It eventually trigger status flags and
     then set the "Buffer Read Ready" flag.
  5 The corrected data is then available for reading from the data port
     register.
  The hardware BCH ECC engine is known to be inconstent in BCH mode and never
  reports uncorrectable errors. Because of this bug, we have to use the
  software BCH implementation in the read path.
 Store the raw OOB bytes as well 
	
	  For each step, compute by softare the BCH syndrome over the raw data.
	  Compare the theoretical amount of errors and compare with the
	  hardware engine feedback.
 Extract the syndrome, it is not necessarily aligned 
 Only correct the data, not the syndrome 
 Spare data is not protected 
 NAND framework ->exec_op() hooks and related helpers 
			
			  Number of DATA cycles must be aligned on 4, this
			  means the controller might readwrite more than
			  requested. This is harmless most of the time as extra
			  DATA are discarded in the write path and read pointer
			  adjusted in the read path.
			 
			  FIXME: The core should mark operations where
			  readingwriting more is allowed so the exec_op()
			  implementation can take the right decision when the
			  alignment constraint is not met: adjust the number of
			  DATA cycles when it's allowed, reject the operation
			  otherwise.
	
	  Experience shows that while in SDR mode sending a CHANGE READ COLUMN
	  command through the READ PAGE "type" always works fine, when in
	  NV-DDR mode the same command simply fails. However, it was also
	  spotted that any CHANGE READ COLUMN command sent through the CHANGE
	  READ COLUMN ENHANCED "type" would correctly work in both cases (SDR
	  and NV-DDR). So, for simplicity, let's program the controller with
	  the CHANGE READ COLUMN ENHANCED "type" whenever we are requested to
	  perform a CHANGE READ COLUMN operation.
 See anfc_check_op() for details about this constraint 
	
	  The controller abstracts all the NAND operations and do not support
	  data only operations.
	 
	  TODO: The nand_op_parser framework should be extended to
	  support custom checks on DATA instructions.
	
	  The controller does not allow to proceed with a CMD+DATA_IN cycle
	  manually on the bus by reading data from the data register. Instead,
	  the controller abstract a status read operation with its own status
	  register after ordering a read status operation. Hence, we cannot
	  support any CMD+DATA_IN operation other than a READ STATUS.
	 
	  TODO: The nand_op_parser() framework should be extended to describe
	  fixed patterns instead of open-coding this check here.
		
		  The controller only supports data payload requests which are
		  a multiple of 4. In practice, most data accesses are 4-byte
		  aligned and this is not an issue. However, rounding up will
		  simply be refused by the controller if we reached the end of
		  the device and we are using the NV-DDR interface(!). In
		  this situation, unaligned data requests ending at the device
		  boundary will confuse the controller and cannot be performed.
		 
		  This is something that happens in nand_read_subpage() when
		  selecting software ECC support and must be avoided.
	
	  Due to a hardware bug in the ZynqMP SoC, SDR timing modes 0-1 work
	  with f > 90MHz (default clock is 100MHz) but signals are unstable
	  with higher modes. Hence we decrease a little bit the clock rate to
	  80MHz when using SDR modes 2-5 with this SoC.
 Enforce bit swapping to fit the hardware 
 These hooks are valid for all ECC providers 
 Chip-select init 
 Ready-busy init 
 Disable interrupt signals 
 Enable interrupt status 
 Check the gpio-cs property 
	
	  The controller native CS cannot be both disabled at the same time.
	  Hence, only one native CS can be used if GPIO CS are needed, so that
	  the other is selected when a non-native CS must be asserted (not
	  wired physically or configured as GPIO instead of NAND CS). In this
	  case, the "not" chosen CS is assigned to nfc->spare_cs and selected
	  whenever a GPIO CS must be asserted.
 SPDX-License-Identifier: GPL-2.0
  ST Microelectronics
  Flexible Static Memory Controller (FSMC)
  Driver for NAND portions
  Copyright  2010 ST Microelectronics
  Vipin Kumar <vipin.kumar@st.com>
  Ashish Priyadarshi
  Based on driversmtdnandnomadik_nand.c (removed in v3.8)
   Copyright  2007 STMicroelectronics Pvt. Ltd.
   Copyright  2009 Alessandro Rubini
 fsmc controller registers for NOR flash 
 ctrl register definitions 
 ctrl_tim register definitions 
 fsmc controller registers for NAND flash 
 pc register definitions 
 sts register definitions 
 comm register definitions 
  struct fsmc_nand_data - structure for FSMC NAND device state
  @base:		Inherit from the nand_controller struct
  @pid:		Part ID on the AMBA PrimeCell format
  @nand:		Chip related info for a NAND flash.
  @bank:		Bank number for probed device.
  @dev:		Parent device
  @mode:		Access mode
  @clk:		Clock structure for FSMC.
  @read_dma_chan:	DMA channel for read access
  @write_dma_chan:	DMA channel for write access to NAND
  @dma_access_complete: Completion structure
  @dev_timings:	NAND timings
  @data_pa:		NAND Physical port for Data.
  @data_va:		NAND port for Data.
  @cmd_va:		NAND port for Command.
  @addr_va:		NAND port for Address.
  @regs_va:		Registers base address for a given bank.
 DMA related objects 
  ECC placement definitions in oobfree type format.
  There are 13 bytes of ecc for every 512 byte block and it has to be read
  consecutively and immediately after the 512 byte data block for hardware to
  generate the error bit offsets in 512 byte data.
  fsmc_nand_setup - FSMC (Flexible Static Memory Controller) init routine
  This routine initializes timing parameters related to NAND memory access in
  FSMC registers
  fsmc_enable_hwecc - Enables Hardware ECC through FSMC registers
  fsmc_read_hwecc_ecc4 - Hardware ECC calculator for ecc4 option supported by
  FSMC. ECC is 13 bytes for 512 bytes of data (supports error correction up to
  max of 8-bits)
  fsmc_read_hwecc_ecc1 - Hardware ECC calculator for ecc1 option supported by
  FSMC. ECC is 3 bytes for 512 bytes of data (supports error correction up to
  max of 1-bit)
 Count the number of 0's in buff upto a max of max_bits 
  fsmc_write_buf - write buffer to chip
  @host:	FSMC NAND controller
  @buf:	data buffer
  @len:	number of bytes to write
  fsmc_read_buf - read chip data into buffer
  @host:	FSMC NAND controller
  @buf:	buffer to store date
  @len:	number of bytes to read
  fsmc_read_buf_dma - read chip data into buffer
  @host:	FSMC NAND controller
  @buf:	buffer to store date
  @len:	number of bytes to read
  fsmc_write_buf_dma - write buffer to chip
  @host:	FSMC NAND controller
  @buf:	data buffer
  @len:	number of bytes to write
  fsmc_exec_op - hook called by the core to execute NAND operations
  This controller is simple enough and thus does not need to use the parser
  provided by the core, instead, handle every situation here.
  fsmc_read_page_hwecc
  @chip:	nand chip info structure
  @buf:	buffer to store read data
  @oob_required:	caller expects OOB data read to chip->oob_poi
  @page:	page number to read
  This routine is needed for fsmc version 8 as reading from NAND chip has to be
  performed in a strict sequence as follows:
  data(512 byte) -> ecc(13 byte)
  After this read, fsmc hardware generates and reports error data bits(up to a
  max of 8 bits)
	
	  ecc_oob is intentionally taken as u16. In 16bit devices, we
	  end up reading 14 bytes (7 words) from oob. The local array is
	  to maintain word alignment
			
			  length is intentionally kept a higher multiple of 2
			  to read at least 13 bytes even in case of 16 bit NAND
			  devices
  fsmc_bch8_correct_data
  @mtd:	mtd info structure
  @dat:	buffer of read data
  @read_ecc:	ecc read from device spare area
  @calc_ecc:	ecc calculated from read data
  calc_ecc is a 104 bit information containing maximum of 8 error
  offset information of 13 bits each in 512 bytes of read data.
 no bit flipping 
 too many errors 
		
		  This is a temporary erase check. A newly erased page read
		  would result in an ecc error because the oob data is also
		  erased to FF and the calculated ecc for an FF data is not
		  FF..FF.
		  This is a workaround to skip performing correction in case
		  data is FF..FF
		 
		  Logic:
		  For every page, each bit written as 0 is counted until these
		  number of bits are greater than 8 (the maximum correction
		  capability of FSMC for each 512 + 13 bytes)
	
	  ------------------- calc_ecc[] bit wise -----------|--13 bits--|
	  |---idx[7]--|--.....-----|---idx[2]--||---idx[1]--||---idx[0]--|
	 
	  calc_ecc is a 104 bit information containing maximum of 8 error
	  offset information of 13 bits each. calc_ecc is copied into a
	  u64 array and error offset indexes are populated in err_idx
	  array
 Set default NAND bank to 0 
	
	  Don't set layout for BCH4 SW ECC. This will be
	  generated later during BCH initialization.
  fsmc_nand_disable() - Disables the NAND bank
  @host: The instance to disable
  fsmc_nand_probe - Probe function
  @pdev:       platform device structure
 Allocate memory for the device structure (and zero it) 
	
	  This device ID is actually a common AMBA ID as used on the
	  AMBA PrimeCell bus. However it is not a PrimeCell.
 Link all private pointers 
	
	  Scan to find existence of the device
  Clean up routine
 SPDX-License-Identifier: GPL-2.0-only
   Copyright  2008 Ilya Yanok, Emcraft Systems
  socrates_nand_write_buf -  write buffer to chip
  @this:	NAND chip object
  @buf:	data buffer
  @len:	number of bytes to write
  socrates_nand_read_buf -  read chip data into buffer
  @this:	NAND chip object
  @buf:	buffer to store date
  @len:	number of bytes to read
  socrates_nand_read_byte -  read one byte from the chip
  @mtd:	MTD device structure
  Hardware specific access to control-lines
  Read the Device Ready pin.
 busy 
  Probe for the NAND device.
 Allocate memory for the device structure (and zero it) 
 link the private data structures 
 TODO: I have no idea what real delay is. 
 20us command delay time 
	
	  This driver assumes that the default ECC engine should be TYPE_SOFT.
	  Set ->engine_type before registering the NAND devices in order to
	  provide a driver specific default value.
  Remove a NAND device.
 SPDX-License-Identifier: GPL-2.0
  SuperH FLCTL nand controller
  Copyright (c) 2008 Renesas Solutions Corp.
  Copyright (c) 2008 Atom Create Engineering Co., Ltd.
  Based on fsl_elbc_nand.c, Copyright (c) 2006-2007 Freescale Semiconductor
 We can only either use DMA for both Tx and Rx or not use it at all 
 ERASE1 
 SEQIN, READ0, etc.. 
 big than 128MB 
 check FIFO 
 check FIFO 
	
	  First this loops checks in FLDTCNTR if we are ready to read out the
	  oob data. This is the case if either all went fine without errors or
	  if the bottom part of the loop corrected the errors or marked them as
	  uncorrectable and the controller is given time to push the data into
	  the FIFO.
 check if all is ok and we can read out the OOB 
 check if a correction code has been calculated 
			
			  either we wait for the fifo to be filled or a
			  correction pattern is being generated
 check for an uncorrectable error 
 check if we face a non-empty page 
 can't correct 
 start error correction 
 timeout 
 check FLECFIFO 
 DMA failed, fall back to PIO 
 ret > 0 is success 
 initiate DMA transfer 
 DMA success 
 do polling transfer 
 initiate DMA transfer 
 DMA success 
 do polling transfer 
 Set SNAND bit if page size is 2048byte 
 default FLCMDCR val 
 Set for FLCMDCR 
 This case is that cmd is READ0 or READ1 or READ00 
 ONLY execute 1st cmd 
 Set address bytes parameter 
 Now actually write 
 set read size 
 read page with hwecc 
 read page with hwecc 
 READID is always performed using an 8-bit bus 
 set read size 
 output read command 
 set 0 size 
 write page with hwecc 
 set write size 
 set read size 
 read and end 
 set 0 size 
 set read size 
	
	  NAND_BUSWIDTH_16 may have been set by nand_scan_ident().
	  Add the SEL_16BIT flag in flctl->flcmncr_base.
 big than 32MB 
 big than 128KB 
 big than 128MB 
 big than 512KB 
 4 symbols ECC enabled 
 set SoC specific options 
 FLDTFIFO 
 Set address of hardware control function 
 20 us command delay time 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2004-2008 Freescale Semiconductor, Inc.
  Copyright 2009 Semihalf.
  Approved as OSADL project by a majority of OSADL members and funded
  by OSADL membership fees in 2009;  for details see www.osadl.org.
  Based on original driver from Freescale Semiconductor
  written by John Rigby <jrigby@freescale.com> on basis of mxc_nand.c.
  Reworked and extended by Piotr Ziecik <kosmo@semihalf.com>.
 Addresses for NFC MAIN RAM BUFFER areas 
 Addresses for NFC SPARE BUFFER areas 
 MPC5121 NFC registers 
 Bit Definitions: NFC_BUF_ADDR 
 Bit Definitions: NFC_CONFIG 
 Bit Definitions: NFC_CONFIG1 
 Bit Definitions: NFC_CONFIG2 
 Bit Definitions: NFC_WRPROT 
 Timeouts 
 1 ms 
 110 s 
 Read NFC register 
 Write NFC register 
 Set bits in NFC register 
 Clear bits in NFC register 
 Invoke address cycle 
 Invoke command cycle 
 Send data from NFC buffers to NAND flash 
 Receive data from NAND flash 
 Receive ID from NAND flash 
 Receive status from NAND flash 
 NFC interrupt handler 
 Wait for operation complete 
 Do address cycle(s) 
 Control chip select signals 
 Init external chip select logic on ADS5121 board 
 CPLD Register 9 controls NAND CE Lines 
 Control chips select signal on ADS5121 board 
 Read NAND ReadyBusy signal 
	
	  NFC handles readybusy signal internally. Therefore, this function
	  always returns status as ready.
 Write command to NAND flash 
	
	  NFC does not support sub-page reads and writes,
	  so emulate them using full page transfers.
 Copy data fromto NFC spare buffers. 
	
	  NAND spare area is available through NFC spare buffers.
	  The NFC divides spare area into (page_size  512) chunks.
	  Each chunk is placed into separate spare memory area, using
	  first (spare_size  num_of_chunks) bytes of the buffer.
	 
	  For NAND device in which the spare area is not divided fully
	  by the number of chunks, number of used bytes in each spare
	  buffer is rounded down to the nearest even number of bytes,
	  and all remaining bytes are added to the last used spare area.
	 
	  For more information read section 26.6.10 of MPC5121e
	  Microcontroller Reference Manual, Rev. 3.
 Calculate number of valid bytes in each spare buffer 
 Calculate spare buffer number 
		
		  Calculate offset to requested data block in selected spare
		  buffer and its size.
 Copy data fromto NFC main and spare buffers 
 Handle spare area access 
 Calculate offset from beginning of spare area 
	
	  Handle main area access - limit copy length to prevent
	  crossing mainspare boundary.
 Handle crossing mainspare boundary 
 Read data from NFC buffers 
 Write data to NFC buffers 
 Read byte from NFC buffers 
  Read NFC configuration from Reset Config Word
  NFC is configured during reset in basis of information stored
  in Reset Config Word. There is no other way to set NAND block
  size, spare size and bus width.
 Bit 6: NFC bus width 
 Bit 7: NFC PageSpare size 
 Bits [22:21]: ROM Location 
 Decode RCW bits 
 Free driver resources 
	
	  Check SoC revision. This driver supports only NFC
	  in MPC5121 revision 2 and MPC5123 revision 3.
 Read NFC configuration from Reset Config Word 
 Support external chip-select logic on ADS5121 board 
 Enable NFC clock 
 Reset NAND Flash controller 
 Enable write to NFC memory 
 Enable write to all NAND pages 
	
	  Setup NFC:
	 	- Big Endian transfers,
	 	- Interrupt after full page readwrite.
 Set spare area size 
	
	  This driver assumes that the default ECC engine should be TYPE_SOFT.
	  Set ->engine_type before registering the NAND devices in order to
	  provide a driver specific default value.
 Detect NAND chips 
 Set erase block size 
 Register device in MTD 
 SPDX-License-Identifier: GPL-2.0+
  Cadence NAND flash controller driver
  Copyright (C) 2019 Cadence
  Author: Piotr Sroka <piotrs@cadence.com>
  HPNFC can work in 3 modes:
  -  PIO - can work in master or slave DMA
  -  CDMA - needs Master DMA for accessing command descriptors.
  -  Generic mode - can use only slave DMA.
  CDMA and PIO modes can be used to execute only base commands.
  Generic mode can be used to execute any command
  on NAND flash memory. Driver uses CDMA mode for
  block erasing, page reading, page programing.
  Generic mode is used for executing rest of commands.
 Register definition. 
  Command register 0.
  Writing data to this register will initiate a new transaction
  of the NF controller.
 Command type field mask. 
 Command type CDMA. 
 Command type generic. 
 Command thread number field mask. 
 Command register 2. 
 Command register 3. 
 Pointer register to select which thread status will be selected. 
 Command status register for selected thread. 
 Interrupt status register. 
 Interrupt enable register. 
 Controller internal state. 
 Command Engine threads state. 
 Command Engine interrupt thread error status. 
 Command Engine interrupt thread error enable. 
 Command Engine interrupt thread complete status. 
  Transfer config 0 register.
  Configures data transfer parameters.
 Offset value from the beginning of the page. 
 Numbers of sectors to transfer within singlNF device's page. 
  Transfer config 1 register.
  Configures data transfer parameters.
 Size of last data sector. 
 Size of not-last data sector. 
 ECC engine configuration register 0. 
 Correction strength. 
 Enable erased pages detection mechanism. 
 Enable controller ECC check bits generation and correction. 
 ECC engine configuration register 1. 
 Multiplane settings register. 
 Cache operation settings. 
 DMA settings register. 
 Enable SDMA error report on access unprepared slave DMA interface. 
 Transferred data block size for the slave DMA module. 
 Thread number associated with transferred data block
  for the slave DMA module.
 Thread number mask. 
 Thread number mask. 
 Available hardware features of the controller. 
 Support for NV-DDR23 work mode. 
 Support for NV-DDR work mode. 
 Support for asynchronous work mode. 
 Support for asynchronous work mode. 
 Slave and Master DMA data width. 
 Availability of Control Data feature.
 BCH Engine identification register 0 - correction strengths. 
 BCH Engine identification register 1 - correction strengths. 
 BCH Engine identification register 2 - sector sizes. 
 BCH Engine identification register 3. 
 ReadyBusy# line status. 
 Common settings. 
 16 bit device connected to the NAND Flash interface. 
 Skip_bytes registers. 
 Timings configuration. 
 Configuration of the resynchronization of slave DLL of PHY. 
 Register controlling DQ related timing. 
 Register controlling DSQ related timing.  
 Register controlling the gate and loopback control related timing. 
 Register holds the control for the master DLL logic. 
 Register holds the control for the slave DLL logic. 
 This register handles the global control settings for the PHY. 
  This register handles the global control settings
  for the termination selects for reads.
 Generic command layout. 
  This bit informs the minicotroller if it has to wait for tWB
  after sending the last CMDADDRDATA in the sequence.
 Type of generic instruction. 
 Generic CMD sequence type. 
 Generic ADDR sequence type. 
 Generic data transfer sequence type. 
 Input part of generic command type of input is command. 
 Generic command address sequence - address fields. 
 Generic command address sequence - address size. 
 Transfer direction field of generic command data sequence. 
 Read transfer direction of generic command data sequence. 
 Write transfer direction of generic command data sequence. 
 ECC enabled flag of generic command data sequence - ECC enabled. 
 Generic command data sequence - sector size. 
 Generic command data sequence - sector count. 
 Generic command data sequence - last sector size. 
 CDMA descriptor fields. 
 Erase command type of CDMA descriptor. 
 Program page command type of CDMA descriptor. 
 Read page command type of CDMA descriptor. 
 Flash pointer memory shift. 
 Flash pointer memory mask. 
  Command DMA descriptor flags. If set causes issue interrupt after
  the completion of descriptor processing.
  Command DMA descriptor flags - the next descriptor
  address field is valid and descriptor processing should continue.
 DMA master flag of command DMA descriptor. 
 Operation complete status of command descriptor. 
 Operation complete status of command descriptor. 
 Command descriptor status - operation fail. 
 Command descriptor status - page erased. 
 Command descriptor status - timeout occurred. 
  Maximum amount of correction applied to one ECC sector.
  It is part of command descriptor status.
 Command descriptor status - uncorrectable ECC error. 
 Command descriptor status - descriptor error. 
 Status of operation - OK. 
 Status of operation - FAIL. 
 Status of operation - uncorrectable ECC error. 
 Status of operation - page erased. 
 Status of operation - correctable ECC error. 
 Status of operation - unsuspected state. 
 Status of operation - operation is not completed yet. 
 Command DMA descriptor. 
 Next descriptor address. 
 Flash address is a 32-bit address comprising of BANK and ROW ADDR. 
field appears in HPNFC version 13
 Operation the controller needs to perform. 
 Flags for operation of this command. 
 Systemhost memory address required for data DMA commands. 
 Status of operation. 
 Address pointer to sync buffer location. 
 Controls the buffer sync mechanism. 
 Control data pointer. 
 Interrupt status. 
 Thread operation complete status. 
 Thread operation error. 
 Controller status. 
 Cadence NAND flash controller capabilities get from driver data. 
 Skew value of the output signals of the NAND Flash interface. 
 It informs if slave DMA interface is connected to DMA engine. 
 Cadence NAND flash controller capabilities read from registers. 
 Maximum number of banks supported by hardware. 
 Slave and Master DMA data width in bytes (4 or 8). 
 Control Data feature supported. 
 Is PHY type DLL. 
 IP capability. 
 Register interface. 
 Interrupts that have happened. 
 Interrupts we are waiting for. 
 Protect irq_mask and irq_status. 
	
	  Estimated Board delay. The value includes the total
	  round trip delay for the signals and is used for deciding on values
	  associated with data read capture.
	
	  part of oob area of NAND flash memory page.
	  This part is available for user to read or write.
 Sector size. There are few sectors per mtd->writesize 
 Offset of BBM. 
 Number of bytes reserved for BBM. 
 ECC strength index. 
 Functions enablesdisables hardware detection of erased data 
  This is the interrupt service routine. It handles all interrupts
  sent to this device.
 Handle interrupt. 
 First acknowledge it. 
 Status in the device context for someone to read. 
 Notify anyone who cares that it happened. 
 Tell the OS that we've handled this. 
 Timeout error. 
 Execute generic command on NAND controller. 
 Select generic command. 
 Thread number. 
 Issue command. 
 Wait for data on slave DMA interface. 
 Prepare CDMA descriptor. 
 Set fields for one descriptor. 
 Descriptor finished with no errors. 
 Last descriptor.  
 Wait for thread ready. 
 Select CDMA mode. 
 Thread number. 
 Issue command. 
 Send SDMA command and wait for finish. 
  ECC size depends on configured ECC strength and on maximum supported
  ECC step size.
 Function reads BCH capabilities. 
 ECC strengths are common for all step infos. 
 Hardware initialization. 
 Disable cache and multiplane. 
 Clear all interrupts. 
	
	  Set IO width access to 8.
	  It is because during SW device discovering width access
	  is expected to be 8.
 Prepare size of data to transfer. 
	
	  Read only bad block marker from offset
	  defined by a memory manufacturer.
 Set oob data to 0xFF. 
 Transfer the data to the oob area. 
	
	  Fill the buffer with 0xff first except the full page transfer.
	  This simplifies the logic.
 Arrange the buffer for syndrome payloadecc layout. 
 BBM at the beginning of the OOB area. 
 OOB free. 
 OOB ECC. 
	
	  If data buffer can be accessed by DMA and data_control feature
	  is supported then transfer data and oob directly.
 Otherwise use bounce buffer. 
 Reads OOB data from the device. 
 Arrange the buffer for syndrome payloadecc layout. 
 OOB free. 
 BBM at the beginning of the OOB area. 
 OOB ECC 
 Wait until slave DMA interface is ready to data transfer. 
 read alingment data 
 read rest data from slave DMA interface if any 
 copy rest of data 
 If DMA transfer is not possible or failed then use bounce buffer. 
 Wait until slave DMA interface is ready to data transfer. 
 copy rest of data 
 write all expected by nand controller data 
 If DMA transfer is not possible or failed then use bounce buffer. 
	
	  Callers of this function do not verify if the NAND is using a 16-bit
	  an 8-bit bus for normal operations, so we need to take care of that
	  here by leaving the configuration unchanged if the NAND does not have
	  the NAND_BUSWIDTH_16 flag set.
	
	  If it is not an erase operation then handle operation
	  by calling exec_op function.
 Calculate max data valid window. 
 Calculate data valid window. 
 Sampling point calculation. 
	
	  The idea of those calculation is to get the optimum value
	  for tRP and tRH timings. If it is NOT possible to sample data
	  with optimal tRPtRH settings, the parameters will be extended.
	  If clk_period is 50ns (the lowest value) this condition is met
	  for SDR timing modes 1, 2, 3, 4 and 5.
	  If clk_period is 20ns the condition is met only for SDR timing
	  mode 5.
 Performance mode. 
		
		  Check if data valid window and sampling point can be found
		  and is not on the edge (ie. we have hold margin).
		  If not extend the tRP timings.
				
				  No valid sampling point so the RE pulse need
				  to be widen widening by half clock cycle.
			
			  There is no valid window
			  to be able to sample data the tRP need to be widen.
			  Very safe calculations are performed here.
 Extended read mode. 
		
		  Check if data valid window and sampling point can be found
		  or if it is at the edge check if previous is valid
		  - if not extend the tRP timings.
				
				  Data valid window width is lower than
				  sampling resolution and do not hit any
				  sampling point to be sure the sampling point
				  will be found the RE low pulse width will be
				   extended by one clock cycle.
			
			  There is no valid window to be able to sample data.
			  The tRP need to be widen.
			  Very safe calculations are performed here.
	
	  If timing exceeds delay field in timing register
	  then use maximum value.
 The following is related to single signal so skew is not needed. 
	
	  Because of the two stage syncflop the value must be increased by 3
	  first value is related with sync, second value is related
	  with output if delay.
	
	  The following is related to the we edge of the random data input
	  sequence so skew is not needed.
 Sampling point calculation. 
				
				  Calculation for sampling point at the edge
				  of data and being odd number.
 this value should be even number 
 Error correction configuration. 
 Override the default read operations. 
 Is 32-bit DMA supported? 
 Allocate the nand chip structure. 
 Retrieve CS id. 
	
	  Default to HW ECC engine mode. If the nand-ecc-mode property is given
	  in the DT node, this entry will be overwritten in nand_scan_ident().
 Disable interrupts. 
 Driver exit point. 
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2009-2015 Freescale Semiconductor, Inc. and others
  Description: MPC5125, VF610, MCF54418 and Kinetis K70 Nand driver.
  Jason ported to M54418TWR and MVFA5 (VF610).
  Authors: Stefan Agner <stefan.agner@toradex.com>
           Bill Pringlemeir <bpringlemeir@nbsps.com>
           Shaohui Xie <b21989@freescale.com>
           Jason Jin <Jason.jin@freescale.com>
  Based on original driver mpc5121_nfc.c.
  Limitations:
  - Untested on MPC5125 and M54418.
  - DMA and pipelining not used.
  - 2K pages or less.
  - HW ECC: Only 2K page with 64+ OOB.
  - HW ECC: Only 24 and 32-bit error correction implemented.
 Register Offsets 
 Addresses for NFC MAIN RAM BUFFER areas 
 NFC_CMD2[CODE] controller cycle bit masks 
 NFC ECC mode define 
 Register Mask and bit definitions 
 NFC_FLASH_CMD1 Field 
 NFC_FLASH_CM2 Field 
 NFC_COL_ADDR Field 
 NFC_ROW_ADDR Field 
 NFC_FLASH_STATUS2 Field 
 NFC_FLASH_CONFIG Field 
 NFC_IRQ_STATUS Field 
  ECC status - seems to consume 8 bytes (double word). The documented
  status byte is located in the lowest byte of the second word (which is
  the 4th or 7th byte depending on endianness).
  Calculate an offset to store the ECC status at the end of the buffer.
 Status and ID are in alternate locations. 
	
	  Indicate that user data is accessed (full pageoob). This is
	  useful to indicate the driver whether to swap byte endianness.
	  See comments in vf610_nfc_rd_from_sramvf610_nfc_wr_to_sram.
  Read accessor for internal SRAM buffer
  @dst: destination address in regular memory
  @src: source address in SRAM buffer
  @len: bytes to copy
  @fix_endian: Fix endianness if required
  Use this accessor for the internal SRAM buffers. On the ARM
  Freescale Vybrid SoC it's known that the driver can treat
  the SRAM buffer as if it's memory. Other platform might need
  to treat the buffers differently.
  The controller stores bytes from the NAND chip internally in big
  endianness. On little endian platforms such as Vybrid this leads
  to reversed byte order.
  For performance reason (and earlier probably due to unawareness)
  the driver avoids correcting endianness where it has control over
  write and read side (e.g. page wise data access).
  Write accessor for internal SRAM buffer
  @dst: destination address in SRAM buffer
  @src: source address in regular memory
  @len: bytes to copy
  @fix_endian: Fix endianness if required
  Use this accessor for the internal SRAM buffers. On the ARM
  Freescale Vybrid SoC it's known that the driver can treat
  the SRAM buffer as if it's memory. Other platform might need
  to treat the buffers differently.
  The controller stores bytes from the NAND chip internally in big
  endianness. On little endian platforms such as Vybrid this leads
  to reversed byte order.
  For performance reason (and earlier probably due to unawareness)
  the driver avoids correcting endianness where it has control over
  write and read side (e.g. page wise data access).
 Clear flags for upcoming command 
	
	  Barrier is needed after this write. This write need
	  to be done before reading the next register the first
	  time.
	  vf610_nfc_set implicates such a barrier by using writel
	  to write to the register.
	
	  Some ops are optional, but the hardware requires the operations
	  to be in this exact order.
	  The op parser enforces the order and makes sure that there isn't
	  a read and write element in a single operation.
		
		  Don't fix endianness on page access for historical reasons.
		  See comment in vf610_nfc_wr_to_sram
		
		  Don't fix endianness on page access for historical reasons.
		  See comment in vf610_nfc_rd_from_sram
  This function supports Vybrid only (MPC5125 would have full RB and four CS)
 Vybrid only (MPC5125 would have full RB and four CS) 
	
	  On an erased page, bit count (including OOB) should be zero or
	  at least less then half of the ECC strength.
	
	  Don't fix endianness on page access for historical reasons.
	  See comment in vf610_nfc_rd_from_sram
	
	  Don't fix endianness on page access for historical reasons.
	  See comment in vf610_nfc_wr_to_sram
 sentinel  }
 Disable virtual pages, only one elementary transfer unit 
 Set ECC status offset in SRAM 
 Enable ECC status in SRAM 
 Bad block options. 
 Single buffer only, max 256 OOB minus ECC status 
 Only 64 byte ECC layouts known 
 Use default large page ECC layout defined in NAND core 
 Scan the NAND chip 
 Register device in MTD 
 SPDX-License-Identifier: GPL-2.0
  NAND Flash Controller Device Driver for DT
  Copyright  2011, Picochip.
 core clock 
 bus interface clock 
 ECC circuit clock 
 core reset 
 register reset 
 sentinel  }
	
	  Deassert the register reset, and the core reset in this order.
	  Deasserting the core reset while the register reset is asserted
	  will cause unpredictable behavior in the controller.
	
	  When the reset is deasserted, the initialization sequence is kicked
	  (bootstrap process). The driver must wait until it finished.
	  Otherwise, it will result in unpredictable behavior.
 SPDX-License-Identifier: GPL-2.0-or-later
   Overview:
    Platform independent driver for NDFC (NanD Flash Controller)
    integrated into EP440 cores
    Ported to an OF platform driver by Sean MacLennan
    The NDFC supports multiple chips, but this driver only supports a
    single chip since I do not have access to any boards with
    multiple chips.
   Author: Thomas Gleixner
   Copyright 2006 IBM
   Copyright 2008 PIKA Technologies
     Sean MacLennan <smaclennan@pikatech.com>
 The NDFC uses Smart Media (SMC) bytes order 
  Speedups for buffer readwriteverify
  NDFC allows 32bit readwrite of data. So we can speed up the buffer
  functions. No further checking, as nand_base will always readwrite
  page aligned.
  Initialize chip structure
 Read the reg property to get the chip select 
 It is ok if ccr does not exist - just default to 0 
 Set the bank settings if given 
 SPDX-License-Identifier: GPL-2.0-only
  Generic NAND driver
  Author: Vitaly Wool <vitalywool@gmail.com>
  Probe for the NAND device.
 Allocate memory for the device structure (and zero it) 
 Handle any platform specific setup 
	
	  This driver assumes that the default ECC engine should be TYPE_SOFT.
	  Set ->engine_type before registering the NAND devices in order to
	  provide a driver specific default value.
 Scan to find existence of the device 
  Remove a NAND device.
 SPDX-License-Identifier: GPL-2.0-only
  Updated, and converted to generic GPIO based driver by Russell King.
  Written by Ben Dooks <ben@simtec.co.uk>
    Based on 2.4 version by Mark Whittaker
   2004 Simtec Electronics
  Device driver for NAND flash that uses a memory mapped interface to
  readwrite the NAND commands and data, and GPIO pins for control signals
  (the DT binding refers to this as "GPIO assisted NAND flash")
 Optional chip enable 
 Optional write protection 
 gpio_nand_dosync()
  Make sure the GPIO state changes occur in-order with writes to NAND
  memory region.
  Needed on PXA due to bus-reordering within the SoC itself (see section on
  IO ordering in PXA manual (section 2.3, p35)
		
		  Linux memory barriers don't cater for what's required here.
		  What's required is what's here - a read from a separate
		  region with a dependency on that read.
 CONFIG_OF 
 CONFIG_OF 
 Enable write protection and disable the chip 
 Just enable the chip 
 We disable write protection once we know probe() will succeed 
 Disable write protection, if wired up 
	
	  This driver assumes that the default ECC engine should be TYPE_SOFT.
	  Set ->engine_type before registering the NAND devices in order to
	  provide a driver specific default value.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2016, The Linux Foundation. All rights reserved.
 NANDc reg offsets 
 dummy register offsets, used by write_reg_dma 
 NAND_FLASH_CMD bits 
 NAND_FLASH_CHIP_SELECT bits 
 NAND_FLASH_STATUS bits 
 NAND_BUFFER_STATUS bits 
 NAND_DEVn_CFG0 bits 
 NAND_DEVn_CFG0 bits 
 NAND_DEV0_ECC_CFG bits 
 NAND_DEV_CMD1 bits 
 NAND_DEV_CMD_VLD bits 
 NAND_EBI2_ECC_BUF_CFG bits 
 NAND_ERASED_CW_DETECT_CFG bits 
 NAND_ERASED_CW_DETECT_STATUS bits 
 NAND_READ_LOCATION_n bits 
 Version Mask 
 NAND OP_CMDs 
 Default Value for NAND_DEV_CMD_VLD 
 NAND_CTRL bits 
  the NAND controller performs readswrites with ECC in 516 byte chunks.
  the driver calls the chunks 'step' or 'codeword' interchangeably
  the largest page size we support is 8K, this will have 16 stepscodewords
  of 512 bytes each
 we read at most 3 registers per codeword scan 
 ECC modes supported by the controller 
  Returns the actual register address for all NAND_DEV_ registers
  (i.e. NAND_DEV_CMD0, NAND_DEV_CMD1, NAND_DEV_CMD2 and NAND_DEV_CMD_VLD)
 Returns the NAND register physical address 
 Returns the dma address for reg read buffer 
  Flags used in DMA descriptor preparation helper functions
  (i.e. read_reg_dmawrite_reg_dmaread_data_dmawrite_data_dma)
 Don't set the EOT in current tx BAM sgl 
 Set the NWD flag in current BAM sgl 
 Finish writing in the current BAM sgl and start writing in another BAM sgl 
  Erased codeword status is being used two times in single transfer so this
  flag will determine the current value of erased codeword status register
  This data type corresponds to the BAM transaction which will be used for all
  NAND transfers.
  @bam_ce - the array of BAM command elements
  @cmd_sgl - sgl for NAND BAM command pipe
  @data_sgl - sgl for NAND BAM consumerproducer pipe
  @bam_ce_pos - the index in bam_ce which is available for next sgl
  @bam_ce_start - the index in bam_ce which marks the start position ce
 		   for current sgl. It will be used for size calculation
 		   for current sgl
  @cmd_sgl_pos - current index in command sgl.
  @cmd_sgl_start - start index in command sgl.
  @tx_sgl_pos - current index in data sgl for tx.
  @tx_sgl_start - start index in data sgl for tx.
  @rx_sgl_pos - current index in data sgl for rx.
  @rx_sgl_start - start index in data sgl for rx.
  @wait_second_completion - wait for second DMA desc completion before making
 			     the NAND transfer completion.
  @txn_done - completion for NAND transfer.
  @last_data_desc - last DMA desc in data channel (txrx).
  @last_cmd_desc - last DMA desc in command channel.
  This data type corresponds to the nand dma descriptor
  @list - list for desc_info
  @dir - DMA transfer direction
  @adm_sgl - sgl which will be used for single sgl dma descriptor. Only used by
 	      ADM
  @bam_sgl - sgl which will be used for dma descriptor. Only used by BAM
  @sgl_cnt - number of SGL in bam_sgl. Only used by BAM
  @dma_desc - low level DMA engine descriptor
  holds the current register values that we want to write. acts as a contiguous
  chunk of memory which we use to write the controller registers through DMA.
  NAND controller data struct
  @controller:			base controller structure
  @host_list:			list containing all the chips attached to the
 				controller
  @dev:			parent device
  @base:			MMIO base
  @base_phys:			physical base address of controller registers
  @base_dma:			dma base address of controller registers
  @core_clk:			controller clock
  @aon_clk:			another controller clock
  @chan:			dma channel
  @cmd_crci:			ADM DMA CRCI for command flow control
  @data_crci:			ADM DMA CRCI for data flow control
  @desc_list:			DMA descriptor list (list of desc_infos)
  @data_buffer:		our local DMA buffer for page readwrites,
 				used when we can't use the buffer provided
 				by upper layers directly
  @buf_sizecountstart:	markers for chip->legacy.read_bufwrite_buf
 				functions
  @reg_read_buf:		local buffer for reading back registers via DMA
  @reg_read_dma:		contains dma address for register read buffer
  @reg_read_pos:		marker for data read in reg_read_buf
  @regs:			a contiguous chunk of memory for DMA register
 				writes. contains the register values to be
 				written to controller
  @cmd1vld:			some fixed controller register values
  @props:			properties of current NAND controller,
 				initialized via DT match data
  @max_cwperpage:		maximum QPIC codewords required. calculated
 				from all connected NAND devices pagesize
 will be used only by QPIC for BAM DMA 
 will be used only by EBI2 for ADM DMA 
  NAND chip structure
  @chip:			base NAND chip structure
  @node:			list node to add itself to host_list in
 				qcom_nand_controller
  @cs:				chip select value for this chip
  @cw_size:			the number of bytes in a single stepcodeword
 				of a page, consisting of all data, ecc, spare
 				and reserved bytes
  @cw_data:			the number of bytes within a codeword protected
 				by ECC
  @use_ecc:			request the controller to use ECC for the
 				upcoming readwrite
  @bch_enabled:		flag to tell whether BCH ECC mode is used
  @ecc_bytes_hw:		ECC bytes used by controller hardware for this
 				chip
  @status:			value to be returned if NAND_CMD_STATUS command
 				is executed
  @last_command:		keeps track of last command on this chip. used
 				for reading correct status
  @cfg0, cfg1, cfg0_raw..:	NANDc register configurations needed for
 				eccnon-ecc mode for the current nand flash
 				device
  This data type corresponds to the NAND controller properties which varies
  among different NAND controllers.
  @ecc_modes - ecc mode for NAND
  @is_bam - whether NAND controller is using BAM
  @is_qpic - whether NAND CTRL is part of qpic IP
  @qpic_v2 - flag to indicate QPIC IP version 2
  @dev_cmd_reg_start - NAND_DEV_CMD_ registers starting offset
 Frees the BAM transaction memory 
 Allocates and Initializes the BAM transaction 
 Clears the BAM transaction indexes 
 Callback for DMA descriptor completion 
	
	  In case of data transfer with NAND, 2 callbacks will be generated.
	  One for command channel and another one for data channel.
	  If current transaction has data descriptors
	  (i.e. wait_second_completion is true), then set this to false
	  and wait for second DMA descriptor completion.
 Helper to check the code word, whether it is last cw or not 
 helper to configure location register values 
 helper to configure address register values 
  update_rw_regs:	set up readwrite register values, these will be
 			written to the NAND controller registers via DMA
  @num_cw:		number of steps for the readwrite operation
  @read:		read or write operation
  @cw	:		which code word
  Maps the scatter gather list for DMA transfer and forms the DMA descriptor
  for BAM. This descriptor will be added in the NAND DMA descriptor queue
  which will be submitted to DMA engine.
 update last datacommand descriptor 
  Prepares the command descriptor for BAM DMA which will be used for NAND
  register reads and writes. The command descriptor requires the command
  to be formed in command element type so this function uses the command
  element from bam transaction ce array and fills the same with required
  data. A single SGL can contain multiple command elements so
  NAND_BAM_NEXT_SGL will be used for starting the separate SGL
  after the current command element.
 fill the command desc 
 use the separate sgl after this command 
  Prepares the data descriptor for BAM DMA which will be used for NAND
  data reads and writes.
		
		  BAM will only set EOT for DMA_PREP_INTERRUPT so if this flag
		  is not set, form the DMA descriptor
  read_reg_dma:	prepares a descriptor to read a given number of
 			contiguous registers to the reg_read_buf pointer
  @first:		offset of the first register in the contiguous block
  @num_regs:		number of registers to read
  @flags:		flags to control DMA descriptor preparation
  write_reg_dma:	prepares a descriptor to write a given number of
 			contiguous registers
  @first:		offset of the first register in the contiguous block
  @num_regs:		number of registers to write
  @flags:		flags to control DMA descriptor preparation
  read_data_dma:	prepares a DMA descriptor to transfer data from the
 			controller's internal buffer to the buffer 'vaddr'
  @reg_off:		offset within the controller's data buffer
  @vaddr:		virtual address of the buffer we want to write to
  @size:		DMA transaction size in bytes
  @flags:		flags to control DMA descriptor preparation
  write_data_dma:	prepares a DMA descriptor to transfer data from
 			'vaddr' to the controller's internal buffer
  @reg_off:		offset within the controller's data buffer
  @vaddr:		virtual address of the buffer we want to read from
  @size:		DMA transaction size in bytes
  @flags:		flags to control DMA descriptor preparation
  Helper to prepare DMA descriptors for configuring registers
  before reading a NAND page.
  Helper to prepare DMA descriptors for configuring registers
  before reading each codeword in NAND page.
  Helper to prepare dma descriptors to configure registers needed for reading a
  single codeword in page
  Helper to prepare DMA descriptors used to configure registers needed for
  before writing a NAND page.
  Helper to prepare DMA descriptors for configuring registers
  before writing each codeword in NAND page.
  the following functions are used within chip->legacy.cmdfunc() to
  perform different NAND_CMD_ commands
 sets up descriptors for NAND_CMD_PARAM 
	
	  NAND_CMD_PARAM is called before we know much about the FLASH chip
	  in use. we configure the controller to perform a raw read of 512
	  bytes to read onfi params
 configure CMD1 and VLD for ONFI param probing in QPIC v1 
 restore CMD1 and VLD regs 
 sets up descriptors for NAND_CMD_ERASE1 
 sets up descriptors for NAND_CMD_READID 
 sets up descriptors for NAND_CMD_RESET 
 helpers to submitfree our list of dma descriptors 
 reset the register read buffer for next NAND operation 
  this is called after NAND_CMD_PAGEPROG and NAND_CMD_ERASE1 to set our
  privately maintained status byte, this status byte can be read after
  NAND_CMD_STATUS is called
  Implements chip->legacy.cmdfunc. It's  only used for a limited set of
  commands. The rest of the commands wouldn't be called by upper layers.
  For example, NAND_CMD_READOOB would never be called because we have our own
  versions of read_oob ops for nand_ecc_ctrl.
 we read the entire page for now 
  when using BCH ECC, the HW flags an error in NAND_FLASH_STATUS if it read
  an erased CW, and reports an erased CW in NAND_ERASED_CW_DETECT_STATUS.
  when using RS ECC, the HW reports the same erros when reading an erased CW,
  but it notifies that it is an erased CW by placing special characters at
  certain offsets in the buffer.
  verify if the page is erased or not, and fix up the page for RS ECC by
  replacing the special characters with 0xff.
	
	  an erased page flags an error in NAND_FLASH_STATUS, check if the page
	  is erased by looking for 0x54s at offsets 3 and 175 from the
	  beginning of each codeword
	
	  if the erased codework markers, if they exist override them with
	  0xffs
	
	  check if the entire chunk contains 0xffs or not. if it doesn't, then
	  restore the original values at the special offsets
 reads back FLASH_STATUS register set by the controller 
 performs raw read for one codeword 
  Bitflips can happen in erased codewords also so this function counts the
  number of 0 in each CW for which ECC engine returns the uncorrectable
  error. The page will be assumed as erased if this count is less than or
  equal to the ecc->strength for each CW.
  1. Both DATA and OOB need to be checked for number of 0. The
     top-level API can be called with only data buf or OOB buf so use
     chip->data_buf if data buf is null and chip->oob_poi if oob buf
     is null for copying the raw bytes.
  2. Perform raw read for all the CW which has uncorrectable errors.
  3. For each CW, check the number of 0 in cw_data and usable OOB bytes.
     The BBM and spare bytes bit flip wont affect the ECC so dont check
     the number of bitflips in this area.
 determine starting buffer address for current CW 
		
		  make sure it isn't an erased page reported
		  as not-erased by HW because of a few bitflips
  reads back status registers set by the controller to notify page read
  errors. this is equivalent to what 'ecc->correct()' would do.
		
		  Check ECC failure for each codeword. ECC failure can
		  happen in either of the following conditions
		  1. If number of bitflips are greater than ECC engine
		     capability.
		  2. If this codeword contains all 0xff for which erased
		     codeword detection check will be done.
			
			  For BCH ECC, ignore erased codeword errors, if
			  ERASED_CW bits are set.
			
			  For RS ECC, HW reports the erased CW by placing
			  special characters at certain offsets in the buffer.
			  These special characters will be valid only if
			  complete page is read i.e. data_buf is not NULL.
		
		  Check if MPU or any other operational error (timeout,
		  device failure, etc.) happened for this codeword and
		  make flash_op_err true. If flash_op_err is set, then
		  EIO will be returned for page read.
		
		  No ECC or operational errors happened. Check the number of
		  bits corrected and update the ecc_stats.corrected.
  helper to perform the actual page read operation, used by ecc->read_page(),
  ecc->read_oob()
 queue cmd descs for each codeword 
		
		  when ecc is enabled, the controller doesn't read the real
		  or dummy bad block markers in each chunk. To maintain a
		  consistent layout across RAW and ECC reads, we just
		  leave the realdummy BBM offsets empty (i.e, filled with
		  0xffs)
  a helper that copies the last stepcodeword of a page (containing free oob)
  into our local buffer
 prepare a clean read buffer 
 implements ecc->read_page() 
 implements ecc->read_page_raw() 
 implements ecc->read_oob() 
 implements ecc->write_page() 
		
		  when ECC is enabled, we don't really need to write anything
		  to oob for the first n - 1 codewords since these oob regions
		  just contain ECC bytes that's written by the controller
		  itself. For the last codeword, we skip the bbm positions and
		  write to the free oob area.
 implements ecc->write_page_raw() 
  implements ecc->write_oob()
  the NAND controller cannot write only data or only OOB within a codeword
  since ECC is calculated for the combined codeword. So update the OOB from
  chip->oob_poi, and pad the data area with OxFF before writing.
 calculate the data and oob size for the last codewordstep 
 override new oob content to last codeword 
	
	  configure registers for a raw sub page read, the address is set to
	  the beginning of the last codeword, we don't care about reading ecc
	  portion of oob. we just want the first few bytes from this codeword
	  that contains the BBM
	
	  to mark the BBM as bad, we flash the entire last codeword with 0s.
	  we don't care about the rest of the content in the codeword since
	  we aren't going to use this block again
 prepare write 
  the three functions below implement chip->legacy.read_byte(),
  chip->legacy.read_buf() and chip->legacy.write_buf() respectively. these
  aren't used for readingwriting page data, they are used for smaller data
  like reading	id, status etc
 we support only one external chip for now 
  NAND controller page layout info
  Layout with ECC enabled:
  |----------------------|  |---------------------------------|
  |           xx.......yy|  |             xx.......yy|
  |    DATA   xx..ECC..yy|  |    DATA     SPARExx..ECC..yy|
  |   (516)   xx.......yy|  |  (516-n4)  (n4)xx.......yy|
  |           xx.......yy|  |             xx.......yy|
  |----------------------|  |---------------------------------|
      codeword 1,2..n-1                  codeword n
   <---(528532 Bytes)-->    <-------(528532 Bytes)--------->
  n = Number of codewords in the page
  . = ECC bytes
   = Sparefree bytes
  x = Unused byte(s)
  y = Reserved byte(s)
  2K page: n = 4, spare = 16 bytes
  4K page: n = 8, spare = 32 bytes
  8K page: n = 16, spare = 64 bytes
  the qcom nand controller operates at a sub pagecodeword level. each
  codeword is 528 and 532 bytes for 4 bit and 8 bit ECC modes respectively.
  the number of ECC bytes vary based on the ECC strength and the bus width.
  the first n - 1 codewords contains 516 bytes of user data, the remaining
  1216 bytes consist of ECC and reserved data. The nth codeword contains
  both user data and spare(oobavail) bytes that sum up to 516 bytes.
  When we access a page with ECC enabled, the reserved bytes(s) are not
  accessible at all. When reading, we fill up these unreadable positions
  with 0xffs. When writing, the controller skips writing the inaccessible
  bytes.
  Layout with ECC disabled:
  |------------------------------|  |---------------------------------------|
  |         yy          xx.......|  |         bb          xx.......|
  |  DATA1  yy  DATA2   xx..ECC..|  |  DATA1  bb  DATA2   SPARExx..ECC..|
  | (size1) yy (size2)  xx.......|  | (size1) bb (size2)  (n4)xx.......|
  |         yy          xx.......|  |         bb          xx.......|
  |------------------------------|  |---------------------------------------|
          codeword 1,2..n-1                        codeword n
   <-------(528532 Bytes)------>    <-----------(528532 Bytes)----------->
  n = Number of codewords in the page
  . = ECC bytes
   = Sparefree bytes
  x = Unused byte(s)
  y = Dummy Bad Bock byte(s)
  b = Real Bad Block byte(s)
  size1size2 = function of codeword size and 'n'
  when the ECC block is disabled, one reserved byte (or two for 16 bit bus
  width) is now accessible. For the first n - 1 codewords, these are dummy Bad
  Block Markers. In the last codeword, this position contains the real BBM
  In order to have a consistent layout between RAW and ECC modes, we assume
  the following OOB layout arrangement:
  |-----------|  |--------------------|
  |yyxx.......|  |bbxx.......|
  |yyxx..ECC..|  |bbFREEOOBxx..ECC..|
  |yyxx.......|  |bbxx.......|
  |yyxx.......|  |bbxx.......|
  |-----------|  |--------------------|
   first n - 1       nth OOB region
   OOB regions
  n = Number of codewords in the page
  . = ECC bytes
   = FREE OOB bytes
  y = Dummy bad block byte(s) (inaccessible when ECC enabled)
  x = Unused byte(s)
  b = Real bad block byte(s) (inaccessible when ECC enabled)
  This layout is read as is when ECC is disabled. When ECC is enabled, the
  inaccessible Bad Block byte(s) are ignored when we write to a pageoob,
  and assumed as 0xffs when we read a pageoob. The ECC, unused and
  dummyreal bad block bytes are grouped as ecc bytes (i.e, ecc->bytes is
  the sum of the three).
 controller only supports 512 bytes data steps 
	
	  Each CW has 4 available OOB bytes which will be protected with ECC
	  so remaining bytes can be used for ECC.
 8 bit ECC defaults to BCH ECC on all platforms 
		
		  if the controller supports BCH for 4 bit ECC, the controller
		  uses lesser bytes for ECC. If RS is used, the ECC bytes is
		  always 10 bytes
 BCH 
 RS 
	
	  we consider ecc->bytes as the sum of all the non-data content in a
	  step. It gives us a clean representation of the oob area (even if
	  all the bytes aren't used for ECC).It is always 16 bytes for 8 bit
	  ECC and 12 bytes for 4 bit ECC
	
	  DATA_UD_BYTES varies based on whether the readwrite command protects
	  spare data with ECC too. We protect spare data by default, so we set
	  it to main + spare data, which are 512 and 4 bytes respectively.
	
	  total bytes in a step, either 528 bytes for 4 bit ECC, or 532 bytes
	  for 8 bit ECC
	
	  we use the internal buffer for reading ONFI params, reading small
	  data like ID and status, and preforming read-copy-write operations
	  when writing to a codeword partially. 532 is the maximum possible
	  size of a codeword for our nand controller
		
		  Initially allocate BAM transaction to read ONFI param page.
		  After detecting all the devices, this BAM transaction will
		  be freed and the next BAM tranasction will be allocated with
		  maximum codeword size
 one time setup of a few nand controller registers 
 kill onenand 
 enable ADM or BAM DMA 
		
		 NAND_CTRL is an operational registers, and CPU
		  access to operational registers are read only
		  in BAM mode. So update the NAND_CTRL register
		  only if it is not in BAM mode. In most cases BAM
		  mode will be enabled in bootloader
 save the original values of these registers 
	
	  the bad block marker is readable only when we read the last codeword
	  of a page with ECC disabled. currently, the nand_base and nand_bbt
	  helpers don't allow us to read BB from a nand chip with ECC
	  disabled (MTD_OPS_PLACE_OOB is set by default). use the block_bad
	  and block_markbad helpers until we permanently switch to using
	  MTD_OPS_RAW for all drivers (with the help of badblockbits)
 set up initial status value 
 parse custom DT properties here 
  data will hold a struct pointer containing more differences once we support
  more controller variants
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2017 Free Electrons
  Copyright (C) 2017 NextThing Co
  Author: Boris Brezillon <boris.brezillon@free-electrons.com>
  Special Micron status bit 3 indicates that the block has been
  corrected by on-die ECC and should be rewritten.
  On chips with 8-bit ECC and additional bit can be used to distinguish
  cases where a errors were corrected without needing a rewrite
  Bit 4 Bit 3 Bit 0 Description
  ----- ----- ----- -----------
  0     0     0     No Errors
  0     0     1     Multiple uncorrected errors
  0     1     0     4 - 6 errors corrected, recommend rewrite
  0     1     1     Reserved
  1     0     0     1 - 3 errors corrected
  1     0     1     Reserved
  1     1     0     7 - 8 errors corrected, recommend rewrite
  Configure chip properties from Micron vendor-specific ONFI table
	
	  The internal ECC doesn't tell us the number of bitflips that have
	  been corrected, but tells us if it recommends to rewrite the block.
	  If it's the case, we need to read the page in raw mode and compare
	  its content to the corrected version to extract the actual number of
	  bitflips.
	  But before we do that, we must make sure we have all OOB bytes read
	  in non-raw mode, even if the user did not request those bytes.
		
		  We first check which operation is supported by the controller
		  before running it. This trick makes it possible to support
		  all controllers, even the most constraints, without almost
		  any performance hit.
		 
		  TODO: could be enhanced to avoid repeating the same check
		  over and over in the fast path.
	
	  With 8512 we have more information but still don't know precisely
	  how many bit-flips were seen.
 rewrite recommended 
 rewrite recommended 
	
	  We first check which operation is supported by the controller before
	  running it. This trick makes it possible to support all controllers,
	  even the most constraints, without almost any performance hit.
	 
	  TODO: could be enhanced to avoid repeating the same check over and
	  over in the fast path.
 The NAND flash doesn't support on-die ECC 
	
	  The NAND flash supports on-die ECC and it can be
	  enableddisabled by a set features command.
	
	  The NAND flash supports on-die ECC, and it cannot be
	  disabled.
  Try to detect if the NAND support on-die ECC. To do this, we enable
  the feature, and read back if it has been enabled as expected. We
  also check if it can be disabled, because some Micron NANDs do not
  allow disabling the on-die ECC and we don't support such NANDs for
  now.
  This function also has the side effect of disabling on-die ECC if
  it had been left enabled by the firmwarebootloader.
	
	  We only support on-die ECC of 4512 or 8512
 0x2 means on-die ECC is available. 
	
	  It seems that there are devices which do not support ECC officially.
	  At least the MT29F2G08ABAGA  MT29F2G08ABBGA devices supports
	  enabling the ECC feature but don't reflect that to the READ_ID table.
	  So we have to guarantee that we disable the ECC feature directly
	  after we did the READ_ID table command. Later we can evaluate the
	  ECC_ENABLE support.
	
	  We only support on-die ECC of 4512 or 8512
		
		  In case of 4bit on-die ECC, we need a buffer to store a
		  page dumped in raw mode so that we can compare its content
		  to the same page after ECC correction happened and extract
		  the real number of bitflips from this comparison.
		  That's not needed for 8-bit ECC, because the status expose
		  a better approximation of the number of bitflips in a page.
	
	  MT29F1G08ABAFAWP-ITE:F and possibly others report 00 00 for the
	  revision number field of the ONFI parameter page. Assume ONFI
	  version 1.0 if the revision number is 00 00.
 SPDX-License-Identifier: GPL-2.0-only
  TXx9 NAND flash memory controller driver
  Based on RBTX49xx patch from CELF patch archive.
  (C) Copyright TOSHIBA CORPORATION 2004-2007
  All Rights Reserved.
 TXX9 NDFMC Registers 
 not TX4939 
 NDFMCR : NDFMC Mode Control 
 TX4925TX4926 only 
 TX4939 only 
 NDFMCR : NDFMC Status 
 TX4939 only 
 NDFMCR : NDFMC Reset 
 in gbusclock 
 in gbusclock 
 TXX9_NDFMCR_CE bit is 0:high 1:low 
 dummy write to update external latch 
 no NDFRSTR.  Write to NDFSPR resets the NDFMC. 
 reset NDFMC 
 setup Hold Time, Strobe Pulse Width 
 tDH 
 max(tREADID, tWP, tRP) 
 actual hold time : (HOLD + 2) BUSCLK 
 actual wait time : (SPW + 1) BUSCLK 
 SPDX-License-Identifier: GPL-2.0 OR MIT
  Rockchip NAND Flash controller driver.
  Copyright (C) 2020 Rockchip Inc.
  Author: Yifeng Zhao <yifeng.zhao@rock-chips.com>
  NFC Page Data Layout:
 	1024 bytes data + 4Bytes sys data + 28Bytes~124Bytes ECC data +
 	1024 bytes data + 4Bytes sys data + 28Bytes~124Bytes ECC data +
 	......
  NAND Page Data Layout:
 	1024  n data + m Bytes oob
  Original Bad Block Mask Location:
 	First byte of oob(spare).
  nand_chip->oob_poi data layout:
 	4Bytes sys data + .... + 4Bytes sys data + ECC data.
 NAND controller register definition 
 0: read, 1: write 
 Auto correct error bits. 
 0: write, 1: read 
 0: 1, 1: 2, 2: 4 
 0: 1, 3: 4, 5: 8, 7: 16 
 1 - 16 
 Some Socs only have 1 or 2 CSs. 
 4 bytes sys data in oob pre 1024 data.
 150 Mhz 
  struct rk_ecc_cnt_status: represent a ecc status data.
  @err_flag_bit: error flag bit index at register.
  @low: ECC count low bit index at register.
  @low_mask: mask bit.
  @low_bn: ECC count low bit number.
  @high: ECC count high bit index at register.
  @high_mask: mask bit
  @type: NFC version
  @ecc_strengths: ECC strengths
  @ecc_cfgs: ECC config values
  @flctl_off: FLCTL register offset
  @bchctl_off: BCHCTL register offset
  @dma_data_buf_off: DMA_DATA_BUF register offset
  @dma_oob_buf_off: DMA_OOB_BUF register offset
  @dma_cfg_off: DMA_CFG register offset
  @dma_st_off: DMA_ST register offset
  @bch_st_off: BCG_ST register offset
  @randmz_off: RANDMZ register offset
  @int_en_off: interrupt enable register offset
  @int_clr_off: interrupt clean register offset
  @int_st_off: interrupt status register offset
  @oob0_off: oob0 register offset
  @oob1_off: oob1 register offset
  @ecc0: represent ECC0 status data
  @ecc1: represent ECC1 status data
 Nothing after this field. 
 Save chip ECC setting 
 Deselect the currently selected target. 
	
	  Compare current chip timing with selected chip timing and
	  change if needed.
	
	  Compare current chip ECC setting with selected chip ECC setting and
	  change if needed.
 Turn clock rate into kHz. 
	
	  ACCON: access timing control register
	  -------------------------------------
	  31:18: reserved
	  17:12: csrw, clock cycles from the falling edge of CSn to the
	    falling edge of RDn or WRn
	  11:11: reserved
	  10:05: rwpw, the width of RDn or WRn in processor clock cycles
	  04:00: rwcs, clock cycles from the rising edge of RDn or WRn to the
	    rising edge of CSn
 Save chip timing 
		
		  There's currently no method to notify the MTD framework that
		  a different ECC strength is in use for the boot blocks.
 Copy data to the NFC buffer. 
		
		  The first four bytes of OOB are reserved for the
		  boot ROM. In some debugging cases, such as with a
		  read, erase and write back test these 4 bytes stored
		  in OOB also need to be written back.
		 
		  The function nand_block_bad detects bad blocks like:
		 
		  bad = chip->oob_poi[chip->badblockpos];
		 
		  chip->badblockpos == 0 for a large page NAND Flash,
		  so chip->oob_poi[0] is the bad block mask (BBM).
		 
		  The OOB data layout on the NFC is:
		 
		     PA0  PA1  PA2  PA3  | BBM OOB1 OOB2 OOB3 | ...
		 
		  or
		 
		     0xFF 0xFF 0xFF 0xFF | BBM OOB1 OOB2 OOB3 | ...
		 
		  The code here just swaps the first 4 bytes with the last
		  4 bytes without losing any data.
		 
		  The chip->oob_poi data layout:
		 
		     BBM  OOB1 OOB2 OOB3 |......|  PA0  PA1  PA2  PA3
		 
		  The rk_nfc_ooblayout_free() function already has reserved
		  these 4 bytes with:
		 
		  oob_region->offset = NFC_SYS_DATA_SIZE + 2;
 Copy ECC data to the NFC buffer. 
	
	  The first blocks (4, 8 or 16 depending on the device) are used
	  by the boot ROM and the first 32 bits of OOB need to link to
	  the next page address in the same block. We can't directly copy
	  OOB data from the MTD framework, because this page address
	  conflicts for example with the bad block marker (BBM),
	  so we shift all OOB data including the BBM with 4 byte positions.
	  As a consequence the OOB size available to the MTD framework is
	  also reduced with 4 bytes.
	 
	     PA0  PA1  PA2  PA3 | BBM OOB1 OOB2 OOB3 | ...
	 
	  If a NAND is not a boot medium or the page is not a boot block,
	  the first 4 bytes are left untouched by writing 0xFF to them.
	 
	    0xFF 0xFF 0xFF 0xFF | BBM OOB1 OOB2 OOB3 | ...
	 
	  Configure the ECC algorithm supported by the boot ROM.
	
	  Whether the DMA transfer is completed or not. The driver
	  needs to check the NFC`s status register to see if the data
	  transfer was completed.
		
		  There's currently no method to notify the MTD framework that
		  a different ECC strength is in use for the boot blocks.
		
		  The first four bytes of OOB are reserved for the
		  boot ROM. In some debugging cases, such as with a read,
		  erase and write back test, these 4 bytes also must be
		  saved somewhere, otherwise this information will be
		  lost during a write back.
 Copy ECC data from the NFC buffer. 
 Copy data from the NFC buffer. 
	
	  The first blocks (4, 8 or 16 depending on the device)
	  are used by the boot ROM.
	  Configure the ECC algorithm supported by the boot ROM.
	
	  Whether the DMA transfer is completed or not. The driver
	  needs to check the NFC`s status register to see if the data
	  transfer was completed.
 Disable flash wp. 
 Config default timing 40ns at 150 Mhz NFC clock. 
 Disable randomizer and DMA. 
	
	  The beginning of the OOB area stores the reserved data for the NFC,
	  the size of the reserved data is NFC_SYS_DATA_SIZE bytes.
 If optional dt settings not present. 
		
		  HW ECC always requests the number of ECC bytes per 1024 byte
		  blocks. The first 4 OOB bytes are reserved for sys data.
 Check buffer first, avoid duplicate alloc buffer. 
 Set default mode in case dt entry is missing. 
 sentinel  }
 Some earlier models, such as rk3066, have no NFC clk. 
 Reset NAND chip if VCC was powered off. 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 Macronix International Co., Ltd.
  Author:
 	Mason Yang <masonccyang@mxic.com.tw>
	
	  A constant delay range from 0x0 ~ 0x1F for input delay,
	  the unit is 78 ps, the max input delay is 2.418 ns.
	
	  Phase degree = 360  freq  output-delay
	  where output-delay is a constant value 1 ns in FPGA.
	 
	  Get Phase degree = 360  freq  1 ns
	                   = 360  freq  1 sec  1000000000
	                   = 9  freq  25000000
 SPDX-License-Identifier: GPL-2.0-only
  Copyright  2009 - Maxim Levitsky
  Common routines & support for xD format
 reserved 
 LBA1 
 LBA2 
 NOTE: This layout is is not compatabable with SmartMedia, 
 because the 256 byte devices have page depenent oob layout 
 However it does preserve the bad block markers 
 If you use smftl, it will bypass this and work correctly 
 If you not, then you break SmartMedia compliance anyway 
 reserved 
 LBA1 
	 As long as this function is called on erase block boundaries
 Bad block marker position 
 ECC layout 
 Scan for card properties 
 SPDX-License-Identifier: GPL-2.0-only
   Copyright (C) 2002 Thomas Gleixner (tglx@linutronix.de)
  The chip ID list:
     name, device ID, page size, chip size in MiB, eraseblock size, options
  If page size and eraseblock size are 0, the sizes are taken from the
  extended chip ID.
	
	  Some incompatible NAND chips share device ID's and so must be
	  listed by full ID. We list them first so that we can easily identify
	  the most specific match.
	
	  These are the new chips with large page size. Their page size and
	  eraseblock size are determined from the extended ID bytes.
 512 Megabit 
 1 Gigabit 
 2 Gigabit 
 4 Gigabit 
 8 Gigabit 
 16 Gigabit 
 32 Gigabit 
 64 Gigabit 
 128 Gigabit 
 256 Gigabit 
 512 Gigabit 
 Manufacturer IDs 
  nand_get_manufacturer_desc - Get manufacturer information from the
                               manufacturer ID
  @id: manufacturer ID
  Returns a nand_manufacturer_desc object if the manufacturer is defined
  in the NAND manufacturers database, NULL otherwise.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2017 Free Electrons
  Copyright (C) 2017 NextThing Co
  Author: Boris Brezillon <boris.brezillon@free-electrons.com>
 Bit for detecting BENAND 
 Recommended to rewrite for BENAND 
 ECC Status Read Command for BENAND 
 ECC Status Mask for BENAND 
 Uncorrectable Error for BENAND 
 Max ECC Steps for BENAND 
 Check Status 
	
	  Fallback to regular status check if
	  toshiba_nand_benand_read_eccstatus_op() failed.
 uncorrected 
 corrected 
	
	  On BENAND, the entire OOB region can be used by the MTD user.
	  The calculated ECC bytes are stored into other isolated
	  area which is not accessible to users.
	  This is why chip->ecc.bytes = 0.
	
	  Toshiba 24nm raw SLC (i.e., not BENAND) have 32B OOB per
	  512B page. For Toshiba SLC, we decode the 5th6th byte as
	  follows:
	  - ID byte 6, bits[2:0]: 100b -> 43nm, 101b -> 32nm,
	                          110b -> 24nm
	  - ID byte 5, bit[7]:    1 -> BENAND, 0 -> raw SLC
 24nm  &&
 !BENAND ) {
	
	  Extract ECC requirements from 6th id byte.
	  For Toshiba SLC, ecc requrements are as follows:
	   - 43nm: 1 bit ECC for each 512Byte is required.
	   - 32nm: 4 bit ECC for each 512Byte is required.
	   - 24nm: 8 bit ECC for each 512Byte is required.
 Start with timings from the closest timing mode, mode 4. 
 Patch timings that differ from mode 4. 
 Patch timings not part of onfi timing mode. 
 Check that chip is BENAND and ECC mode is on-die 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2017 Free Electrons
  Copyright (C) 2017 NextThing Co
  Author: Boris Brezillon <boris.brezillon@free-electrons.com>
	
	  Check for SpansionAMD ID + repeating 5th, 6th byte since
	  some Spansion chips have erasesize that conflicts with size
	  listed in nand_ids table.
	  Data sheet (5 byte ID): Spansion S30ML-P ORNAND (p.39)
		
		  According to the datasheet of some Cypress SLC NANDs,
		  the bad block markers can be in the first, second or last
		  page of a block. So let's check all three locations.
 SPDX-License-Identifier: GPL-2.0-only
   Copyright (C) 2014 Free Electrons
   Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
  For non-ONFI chips we use the highest possible value for tPROG and tBERS.
  tR and tCCS will take the default values precised in the ONFI specification
  for timing mode 0, respectively 200us and 500ns.
  These four values are tweaked to be more accurate in the case of ONFI chips.
 Mode 0 
 Mode 1 
 Mode 2 
 Mode 3 
 Mode 4 
 Mode 5 
 Mode 0 
 Mode 1 
 Mode 2 
 Mode 3 
 Mode 4 
 Mode 5 
 All NAND chips share the same reset data interface: SDR mode 0 
  onfi_find_closest_sdr_mode - Derive the closest ONFI SDR timing mode given a
                               set of timings
  @spec_timings: the timings to challenge
  onfi_find_closest_nvddr_mode - Derive the closest ONFI NVDDR timing mode
                                 given a set of timings
  @spec_timings: the timings to challenge
  onfi_fill_sdr_interface_config - Initialize a SDR interface config from a
                                   given ONFI mode
  @chip: The NAND chip
  @iface: The interface configuration to fill
  @timing_mode: The ONFI timing mode
	
	  Initialize timings that cannot be deduced from timing mode:
	  tPROG, tBERS, tR and tCCS.
	  These information are part of the ONFI parameter page.
 microseconds -> picoseconds 
 nanoseconds -> picoseconds 
  onfi_fill_nvddr_interface_config - Initialize a NVDDR interface config from a
                                     given ONFI mode
  @chip: The NAND chip
  @iface: The interface configuration to fill
  @timing_mode: The ONFI timing mode
	
	  Initialize timings that cannot be deduced from timing mode:
	  tPROG, tBERS, tR, tCCS and tCAD.
	  These information are part of the ONFI parameter page.
 microseconds -> picoseconds 
 nanoseconds -> picoseconds 
  onfi_fill_interface_config - Initialize an interface config from a given
                               ONFI mode
  @chip: The NAND chip
  @iface: The interface configuration to fill
  @type: The interface type
  @timing_mode: The ONFI timing mode
 SPDX-License-Identifier: GPL-2.0-only
  Driver for One Laptop Per Child CAF controller, aka Marvell 88ALP01
  The data sheet for this device can be found at:
     http:wiki.laptop.orggoDatasheets 
  Copyright  2006 Red Hat, Inc.
  Copyright  2006 David Woodhouse <dwmw2@infradead.org>
 Missing from the datasheet: bit 19 of CTRL1 sets CE0 vs. CE1 
 Hrm. Why isn't this already conditional on something in the struct device? 
 Make it easier to switch to PIO if we need to 
 Second half of a command we already calculated 
 Reset ECC engine 
 Emulate NAND_CMD_READOOB on large-page chips 
	 FIXME: Do we need to send read command before sending data
 Set command valid bit, mask in the chip select bit  
 Set RD or WR bits as appropriate 
 rd 
 Always 5 bytes, for now 
 And one address cycle -- even for STATUS, since the controller doesn't work without 
 rd 
 For now, assume just read to end of page 
 wr 
 Set number of address bytes 
		 Ignore the first command of a pair; the hardware
 RNDOUT and READ0 commands need a following byte 
 NB: The datasheet lies -- we really should be subtracting 1 here 
 If WR or RD bits set, set up DMA 
 It's a read 
			 ... so it's done when the DMA is done, not just
	 Apply this short delay always to ensure that we do wait tWB in
	 Mask the appropriate bit into the stored value of ctl1
 Don't use -- use nand_read_oob_std for now 
  cafe_nand_read_page_syndrome - [REPLACEABLE] hardware ecc syndrome based page read
  @chip:	nand chip info structure
  @buf:	buffer to store read data
  @oob_required:	caller expects OOB data read to chip->oob_poi
  @page:	page number to read
  The hw generator calculates the error syndrome automatically. Therefore
  we need a special oob layout and handling.
 The 12-bit symbols are mapped to bytes here 
 out of range 
 high four bits do not correspond to data 
 Ick. The BBT code really ought to be able to work this bit out
 Set up ECC autogeneration 
 F_2[X](X6+X+1)  
 F_64[X](X2+X+A-1) with A the generator of F_64[X]  
 Set up DMA address 
 Restore the DMA flag 
 Reed-Solomon ECC 
 2KiB page size 
 Set up ECC according to the type of chip we found 
	 Very old versions shared the same PCI ident for all three
 Enable the following for a flash based bad block table 
 Start off by resetting the NAND controller completely 
 Disable master reset, enable NAND clock 
 Enable NAND IRQ in global IRQ mask register 
 Do not use the DMA during the NAND identification 
 Scan to find existence of the device 
 Disable NAND IRQ in global IRQ mask register 
 Disable NAND IRQ in global IRQ mask register 
 Start off by resetting the NAND controller completely 
 Restore timing configuration 
 Disable master reset, enable NAND clock 
 Set up DMA address 
 Shift in two parts to shut the compiler up 
 Enable NAND IRQ in global IRQ mask register 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright  2004-2008 Simtec Electronics
 	http:armlinux.simtec.co.uk
 	Ben Dooks <ben@simtec.co.uk>
  Samsung S3C2410S3C2440S3C2412 NAND driver
 new oob placement block for use with hardware ecc generation
 controller and mtd information 
  struct s3c2410_nand_mtd - driver MTD structure
  @mtd: The MTD instance to pass to the MTD layer.
  @chip: The NAND chip information.
  @set: The platform information supplied for this set of NAND chips.
  @info: Link back to the hardware information.
 overview of the s3c2410 nand state 
  struct s3c2410_nand_info - NAND controller state.
  @controller: Base controller structure.
  @mtds: An array of MTD instances on this controller.
  @platform: The platform data for this board.
  @device: The platform device we bound to.
  @clk: The clock resource for this controller.
  @regs: The area mapped for the hardware registers.
  @sel_reg: Pointer to the register controlling the NAND selection.
  @sel_bit: The bit in @sel_reg to select the NAND chip.
  @mtd_count: The number of MTDs created from this controller.
  @save_sel: The contents of @sel_reg to be saved over suspend.
  @clk_rate: The clock rate from @clk.
  @clk_state: The current clock state.
  @cpu_type: The exact type of this controller.
  @freq_transition: CPUFreq notifier block
 mtd info 
 device info 
 conversion functions 
  s3c2410_nand_clk_set_state - Enable, disable or suspend NAND clock.
  @info: The controller instance.
  @new_state: State to which clock should be set.
 timing calculations 
  s3c_nand_calc_rate - calculate timing data.
  @wanted: The cycle time in nanoseconds.
  @clk: The clock rate in kHz.
  @max: The maximum divider value.
  Calculate the timing value from the given parameters.
 controller setup 
  s3c2410_nand_setrate - setup controller timing information.
  @info: The controller instance.
  Given the information supplied by the platform, calculate and set
  the necessary timing registers in the hardware to generate the
  necessary timing cycles to the hardware.
 calculate the timing information for the controller 
 turn clock into kHz for ease of use 
 default timings 
  s3c2410_nand_inithw - basic hardware initialisation
  @info: The hardware state.
  Do the basic initialisation of the hardware, using s3c2410_nand_setrate()
  to setup the hardware access speeds and set the controller to be enabled.
 enable the controller and de-assert nFCE 
  s3c2410_nand_select_chip - select the given nand chip
  @this: NAND chip object.
  @chip: The chip number.
  This is called by the MTD layer to either select a given chip for the
  @mtd instance, or to indicate that the access has finished and the
  chip can be de-selected.
  The routine ensures that the nFCE line is correctly setup, and any
  platform specific selection code is called to route nFCE to the specific
  chip.
 s3c2410_nand_hwcontrol
  Issue command and address cycles to the chip
 command and control functions 
 s3c2410_nand_devready()
  returns 0 if the nand is busy, 1 if it is ready
 ECC handling functions 
 ECC is ok 
	 sometimes people do not think about using the ECC, so check
	  to see if we have an 0xff,0xff,0xff read ECC and then ignore
	  the error, on the assumption that this is an un-eccd page.
	 Can we correct this ECC (ie, one row and column change).
 calculate the bit position of the error 
 calculate the byte position of the error 
	 if there is only one bit difference in the ECC, then
	  one of only a row or column parity has changed, which
 equal to "(diff0 & ~(1 << __ffs(diff0)))" 
 ECC functions
  These allow the s3c2410 and s3c2440 to use the controller's ECC
  generator block to ECC the data as it passes through]
 over-ride the standard functions for a little more speed. We can
  use readwrite block to move the data buffers tofrom the controller
 cleanup if we've got less than a word to do 
 cleanup any fractional write 
 cpufreq driver support 
 device management functions 
	 Release all our mtds  and their partitions, then go through
	  freeing the resources used
 free the common resources 
  s3c2410_nand_init_chip - initialise a single instance of an chip
  @info: The base NAND controller the chip is on.
  @nmtd: The new controller MTD instance to fill in.
  @set: The information passed from the board specific platform data.
  Initialise the given @nmtd from the information in @info and @set. This
  readies the structure for use with the MTD layer functions by ensuring
  all pointers are setup and the necessary control routines selected.
	
	  let's keep behavior unchanged for legacy boards booting via pdata and
	  auto-detect timings only when booting with a device tree.
	
	  If you use u-boot BBT creation code, specifying this flag will
	  let the kernel fish out the BBT from the NAND.
  s3c2410_nand_attach_chip - Init the ECC engine after NAND scan
  @chip: The NAND chip
  This hook is called by the core after the identification of the NAND chip,
  once the relevant per-chip information is up to date.. This call ensure that
  we update the internal state accordingly.
  The internal state is currently limited to the ECC state information.
		
		  This driver expects Hamming based ECC when engine_type is set
		  to NAND_ECC_ENGINE_TYPE_SOFT. Force ecc.algo to
		  NAND_ECC_ALGO_HAMMING to avoid adding an extra ecc_algo field
		  to s3c2410_platform_nand.
		 change the behaviour depending on whether we are using
 also compatible with s3c6400 
 sentinel  }
 s3c24xx_nand_probe
  called by device layer when it finds a device matching
  one our driver can handled. This code checks to see if
  it can allocate all necessary resources then calls the
  nand layer to look for devices
 get the clock source and enable it 
 allocate and map the resource 
 currently we assume we have the one resource 
 allocate our information 
 initialise all possible chips 
 initialise the hardware 
 PM Support 
		 For the moment, we must ensure nFCE is high during
		  the time we are suspended. This really should be
		  handled by suspending the MTDs we are using, but
 Restore the state of the nFCE line. 
 driver device registration 
 compatible with 2412 
 SPDX-License-Identifier: GPL-2.0
   Copyright (C) 2006 Jonathan McDowell <noodles@earth.li>
   Derived from driversmtdnandtoto.c (removed in v2.6.28)
     Copyright (c) 2003 Texas Instruments
     Copyright (c) 2002 Thomas Gleixner <tgxl@linutronix.de>
   Converted to platform driver by Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
   Partially stolen from plat_nand.c
   Overview:
    This is a device driver for the NAND flash device found on the
    Amstrad E3 (Delta).
  MTD structure for E3 (Delta)
  Main initialization routine
 Allocate memory for MTD device structure and private data 
 Set chip enabled but write protected 
 Request array of data pins, initialize them as input 
 Initialize the NAND controller object embedded in gpio_nand. 
	
	  FIXME: We should release write protection only after nand_scan() to
	  be on the safe side but we can't do that until we have a generic way
	  to assertdeassert WP from the core.  Even if the core shouldn't
	  write things in the nand_scan() path, it should have control on this
	  pin just in case we ever need to disable write protection during
	  chip detectioninitialization.
 Release write protection 
	
	  This driver assumes that the default ECC engine should be TYPE_SOFT.
	  Set ->engine_type before registering the NAND devices in order to
	  provide a driver specific default value.
 Scan to find existence of the device 
 Register the partitions 
  Clean up routine
 Apply write protection 
 Unregister device 
 sentinel 
 sentinel 
 SPDX-License-Identifier: GPL-2.0-or-later
  Freescale Integrated Flash Controller NAND driver
  Copyright 2011-2012 Freescale Semiconductor, Inc
  Author: Dipen Dudhat <Dipen.Dudhat@freescale.com>
#define ERR_BYTE		0xFF  Value returned for read
#define IFC_TIMEOUT_MSECS	500   Maximum number of mSecs to wait
 mtd information per set 
 Chip select bank number		
 bufnum = page & bufnum_mask 
 Chip select base virtual address	
 overview of the fsl ifc controller 
 Address of assigned IFC buffer	
 Last page written to  read from	
 Number of bytes read during command	
 Saved column from SEQIN		
 Pointer to next byte to 'read'	
 Non zero if operating on OOB data	
 Non zero for a full-page ECC read	
 counter for the initializations	
 Saved during READ0 cmd		
  Generic flash bbt descriptors
 0 on 8-bit small page 
 0 on 8-bit small page 
  Set up the IFC hardware block and page address fields, and the ifc nand
  structure addr field to point to the correct IFC buffer in memory
 Program ROW0COL0 
 for OOB data point to the second half of the buffer 
 returns nonzero if entire page is blank 
  execute IFC NAND command and wait for it to complete
 set the chip select for NAND Transaction 
 start readwrite seq 
 wait for command complete flag or timeout 
 ctrl->nand_stat will be updated from IRQ context 
				
				  Uncorrectable error.
				  We'll check for blank pages later.
				 
				  We disable ECCER reporting due to...
				  erratum IFC-A002770 -- so report it now if we
				  see an uncorrectable error in ECCSTAT.
 Program FIRIFC_NAND_FCR0 for SmallLarge page 
 cmdfunc send commands to the IFC NAND Machine 
 clear the read buffer 
 READ0 read the entire buffer to use hardware ECC. 
 READOOB reads only the OOB because no ECC is performed. 
		
		  For READID, read 8 bytes that are currently used.
		  For PARAM, read all 3 copies of 256-bytes pages.
 ERASE1 stores the block and page address 
 ERASE2 uses the block and page address from ERASE1 
 SEQIN sets up the addr buffer and all registers except the length 
 OOB area --> READOOB 
 PAGEPROG reuses all of the setup from SEQIN and adds the length 
		
		  The chip always seems to report that it is
		  write-protected, even when it is not.
	 The hardware does not seem to support multiple
	  chips per bank.
  Write buf to the IFC NAND Controller Data Buffer
  Read a byte from either the IFC hardware buffer
  read function for 8-bit buswidth
	
	  If there are still bytes in the IFC buffer, then use the
	  next byte.
  Read two bytes from the IFC hardware buffer
  read function for 16-bit buswith
	
	  If there are still bytes in the IFC buffer, then use the
	  next byte.
  Read from the IFC Controller Data Buffer
  This function is called after Program and Erase Operations to
  check for success or failure.
 Use READ_STATUS command, but wait for the device to be ready 
	
	  The chip always seems to report that it is
	  write-protected, even when it is not.
  The controller does not check for bitflips in erased pages,
  therefore software must check instead.
 ECC will be calculated automatically, and errors will be detected in
  waitfunc.
 Must also set CSOR_NAND_ECC_ENC_EN if DEC_EN set 
 Hardware generates ECC per 512 Bytes 
 Trigger auto initialization 
 Wait until done 
 Save CSOR and CSOR_ext 
 chage PageSize 8K and SpareSize 1K
 READID 
 Program ROW0COL0 
 set the chip select for NAND Transaction 
 start read seq 
 wait for command complete flag or timeout 
 Restore CSOR and CSOR_ext 
 Fill in fsl_ifc_mtd structure 
 fill in nand_chip structure 
 set up function call table 
 set up nand options 
 Avoid conflict with bad block marker 
	
	  As IFC version 2.0.0 has 16KB of internal SRAM as compared to older
	  versions which had 8KB. Hence bufnum mask needs to be updated.
 get, allocate and map the memory resource 
 find which chip select it is connected to 
 enable NAND Machine Interrupts 
	 First look for RedBoot table or partitions on the command
 SPDX-License-Identifier: GPL-2.0-or-later
  Freescale UPM NAND driver.
  Copyright  2007-2008  MontaVista Software, Inc.
  Author: Anton Vorontsov <avorontsov@ru.mvista.com>
 SPDX-License-Identifier: GPL-2.0
  NAND Flash Controller Device Driver
  Copyright  2009-2010, Intel Corporation and its suppliers.
  Copyright (c) 2017-2019 Socionext Inc.
    Reworked by Masahiro Yamada <yamada.masahiro@socionext.com>
 for Indexed Addressing 
 direct access to buffer 
 readwrite pages in PIO 
 high-level control plane 
 direct controller access 
 MAP11 access cycle type 
 command cycle 
 address cycle 
 data cycle 
  Direct Addressing - the slave address forms the control information (command
  type, bank, block, and page address).  The slave data is the actual data to
  be transferred.  This mode requires 28 bits of address region allocated.
  Indexed Addressing - address translation module intervenes in passing the
  control information.  This mode reduces the required address range.  The
  control information and transferred data are latched by the registers in
  the translation module.
 write one to clear bits 
 return immediately if the IRQ has already happened. 
 update timing registers unless NAND_KEEP_TIMINGS is set 
 This chunk overwraps the BBM area. Must be split 
 BBM at the beginning of the OOB area 
 The last chunk includes OOB free 
 This chunk overwraps the BBM area. Must be split 
		
		  This flag is set when uncorrectable error occurs at least in
		  one ECC sector.  We can not know "how many sectors", or
		  "which sector(s)".  We need erase-page check for all sectors.
	
	  The register holds the maximum of per-sector corrected bitflips.
	  This is suitable for the return value of the ->read_page() callback.
	  Unfortunately, we can not know the total number of corrected bits in
	  the page.  Increase the stats by max_bitflips. (compromised solution)
 reset the bitflip counter when crossing ECC sector 
			
			  Check later if this is a real ECC error, or
			  an erased sector.
			
			  If err_byte is larger than ecc_size, means error
			  happened in OOB, so we ignore it. It's no need for
			  us to correct it err_device is represented the NAND
			  error bits are happened in if there are more than
			  one NAND connected.
 correct the ECC error 
	
	  Once handle all ECC errors, controller will trigger an
	  ECC_TRANSACTION_DONE interrupt.
 DMA is a three step process 
	
	  1. setup transfer type, interrupt when complete,
	     burst len = 64 bytes, the number of pages
 2. set memory low address 
 3. set memory high address 
 DMA is a four step process 
 1. setup transfer type and # of pages 
 2. set memory high address bits 23:8 
 3. set memory low address bits 23:8 
 4. interrupt when complete, burst len = 64 bytes 
		
		  INTR__PROGRAM_COMP is never asserted for the DMA transfer.
		  We can use INTR__DMA_CMD_COMP instead.  This flag is asserted
		  when the page program is completed.
	
	  The ->setup_dma() hook kicks DMA by using the datacommand
	  interface, which belongs to a different AXI port from the
	  register interface.  Read back the register to avoid a race.
 clk_x period in picoseconds 
	
	  The bus interface clock, clk_x, is phase aligned with the core clock.
	  The clk_x is an integral multiple N of the core clk.  The value N is
	  configured at IP delivery time, and its available value is 4, 5, 6.
 tRWH -> RE_2_WE 
 tRHZ -> RE_2_RE 
	
	  tCCS, tWHR -> WE_2_RE
	 
	  With WE_2_RE properly set, the Denali controller automatically takes
	  care of the delay; the driver need not set NAND_WAIT_TCCS.
 tADL -> ADDR_2_DATA 
 for older versions, ADDR_2_DATA is only 6 bit wide 
 tREH, tWH -> RDWR_EN_HI_CNT 
	
	  tREA -> ACC_CLKS
	  tRP, tWP, tRHOH, tRC, tWC -> RDWR_EN_LO_CNT
	
	  Determine the minimum of acc_clks to meet the setup timing when
	  capturing the incoming data.
	 
	  The delay on the chip side is well-defined as tREA, but we need to
	  take additional delay into account. This includes a certain degree
	  of unknowledge, such as signal propagation delays on the PCB and
	  in the SoC, load capacity of the IO pins, etc.
 Determine the minimum of rdwr_en_lo_cnt from RE#WE# pulse width 
 Extend rdwr_en_lo to meet the data hold timing 
 Extend rdwr_en_lo to meet the requirement for RE#WE# cycle time 
 Center the data latch timing for extra safety 
 tCS, tCEA -> CS_SETUP_CNT 
 BCH code.  Denali requires ecc.bytes to be multiple of 2 
	
	  Support for multi device:
	  When the IP configuration is x16 capable and two x8 chips are
	  connected in parallel, DEVICES_CONNECTED should be set to 2.
	  In this case, the core framework knows nothing about this fact,
	  so we should tell it the _logical_ pagesize and anything necessary.
	
	  On some SoCs, DEVICES_CONNECTED is not auto-detected.
	  For those, DEVICES_CONNECTED is left to 0.  Set 1 if it is the case.
 2 chips in parallel 
 bit 31:24 and 15:8 are used for DDR 
 RB# pin transitioned from low to high? 
 Just in case nand_operation has multiple NAND_OP_WAITRDY_INSTR. 
	
	  Some commands contain NAND_OP_WAITRDY_INSTR.
	  irq must be cleared here to catch the RB# interrupt there.
 sanity checks for bank numbers 
	
	  Fallback to the default name if DT did not give "label" property.
	  Use "label" property if multiple chips are connected.
 clk rate info is needed for setup_interface 
	
	  The REVISION register may not be reliable. Platforms are allowed to
	  override it.
 the encoding changed from rev 5.0 to 5.1 
	
	  Set how many bytes should be skipped before writing data in OOB.
	  If a platform requests a non-zero value, set it to the register.
	  Otherwise, read the value out, expecting it has already been set up
	  by firmware.
 SPDX-License-Identifier: GPL-2.0-or-later
  Error Location Module
  Copyright (C) 2012 Texas Instruments Incorporated - https:www.ti.com
 ELM Interrupt Status Register 
 ELM Interrupt Enable Register 
 ELM Location Configuration Register 
 ELM syndrome 
 ELM_LOCATION_STATUS Register 
 ELM_ERROR_LOCATION_0-15 Registers 
  elm_config - Configure ELM module
  @dev:	ELM device
  @bch_type:	Type of BCH ecc
  @ecc_steps:	ECC steps to assign to config
  @ecc_step_size:	ECC step size to assign to config
  @ecc_syndrome_size:	ECC syndrome size to assign to config
 ELM cannot detect ECC errors for chunks > 1KB 
 ELM support 8 error syndrome process 
  elm_configure_page_mode - EnableDisable page mode
  @info:	elm info
  @index:	index number of syndrome fragment vector
  @enable:	enabledisable flag for page mode
  Enable page mode for syndrome fragment index
 enable page mode 
 disable page mode 
  elm_load_syndrome - Load ELM syndrome reg
  @info:	elm info
  @err_vec:	elm error vectors
  @ecc:	buffer with calculated ecc
  Load syndrome fragment registers with calculated ecc in reverse order.
 Check error reported 
 syndrome fragment 0 = ecc[9-12B] 
 syndrome fragment 1 = ecc[5-8B] 
 syndrome fragment 2 = ecc[1-4B] 
 syndrome fragment 3 = ecc[0B] 
 syndrome fragment 0 = ecc[20-52b] bits 
 syndrome fragment 1 = ecc[0-20b] bits 
 Update ecc pointer with ecc byte size 
  elm_start_processing - start elm syndrome processing
  @info:	elm info
  @err_vec:	elm error vectors
  Set syndrome valid bit for syndrome fragment registers for which
  elm syndrome fragment registers are loaded. This enables elm module
  to start processing syndrome vectors.
	
	  Set syndrome vector valid, so that ELM module
	  will process it for vectors error is reported
  elm_error_correction - locate correctable error position
  @info:	elm info
  @err_vec:	elm error vectors
  On completion of processing by elm module, error location status
  register updated with correctableuncorrectable error information.
  In case of correctable errors, number of errors located from
  elm location status register & read the positions from
  elm error location register.
 Check error reported 
 Check correctable error or not 
 Read count of correctable errors 
 Update the error locations in error vector 
 Update error location register 
 Clearing interrupts for processed error vectors 
 Disable page mode 
  elm_decode_bch_error_page - Locate error position
  @dev:	device pointer
  @ecc_calc:	calculated ECC bytes from GPMC
  @err_vec:	elm error vectors
  Called with one or more error reported vectors & vectors with
  error reported is updated in err_vec[].error_reported
 Enable page mode interrupt 
 Load valid ecc byte to syndrome fragment register 
 Enable syndrome processing for which syndrome fragment is updated 
 Wait for ELM module to finish locating error correction 
 Disable page mode interrupt 
 All error vectors processed 
  elm_context_save
  saves ELM configurations to preserve them across Hardware powered-down
		 ELM SYNDROME_VALID bit in SYNDROME_FRAGMENT_6[] needs
  elm_context_restore
  writes configurations saved duing power-down back into ELM registers
 ELM_SYNDROME_VALID bit to be set in last to trigger FSM 
 SPDX-License-Identifier: GPL-2.0
  Marvell NAND flash controller driver
  Copyright (C) 2017 Marvell
  Author: Miquel RAYNAL <miquel.raynal@free-electrons.com>
  This NAND controller driver handles two versions of the hardware,
  one is called NFCv1 and is available on PXA SoCs and the other is
  called NFCv2 and is available on Armada SoCs.
  The main visible difference is that NFCv1 only has Hamming ECC
  capabilities, while NFCv2 also embeds a BCH ECC engine. Also, DMA
  is not used with NFCv2.
  The ECC layouts are depicted in details in Marvell AN-379, but here
  is a brief description.
  When using Hamming, the data is split in 512B chunks (either 1, 2
  or 4) and each chunk will have its own ECC "digest" of 6B at the
  beginning of the OOB area and eventually the remaining free OOB
  bytes (also called "spare" bytes in the driver). This engine
  corrects up to 1 bit per chunk and detects reliably an error if
  there are at most 2 bitflips. Here is the page layout used by the
  controller when Hamming is chosen:
  +-------------------------------------------------------------+
  | Data 1 | ... | Data N | ECC 1 | ... | ECCN | Free OOB bytes |
  +-------------------------------------------------------------+
  When using the BCH engine, there are N identical (data + free OOB +
  ECC) sections and potentially an extra one to deal with
  configurations where the chosen (data + free OOB + ECC) sizes do
  not align with the page (data + OOB) size. ECC bytes are always
  30B per ECC chunk. Here is the page layout used by the controller
  when BCH is chosen:
  +-----------------------------------------
  | Data 1 | Free OOB bytes 1 | ECC 1 | ...
  +-----------------------------------------
       -------------------------------------------
        ... | Data N | Free OOB bytes N | ECC N |
       -------------------------------------------
            --------------------------------------------+
             Last Data | Last Free OOB bytes | Last ECC |
            --------------------------------------------+
  In both cases, the layout seen by the user is always: all data
  first, then all free OOB bytes and finally all ECC bytes. With BCH,
  ECC bytes are 30B long and are padded with 0xFF to align on 32
  bytes.
  The controller has certain limitations that are handled by the
  driver:
    - It can only read 2k at a time. To overcome this limitation, the
      driver issues data cycles on the bus, without issuing new
      CMD + ADDR cycles. The Marvell term is "naked" operations.
    - The ECC strength in BCH mode cannot be tuned. It is fixed 16
      bits. What can be tuned is the ECC block size as long as it
      stays between 512B and 2kiB. It's usually chosen based on the
      chip ECC requirements. For instance, using 2kiB ECC chunks
      provides 4b512B correctability.
    - The controller will always treat data bytes, free OOB bytes
      and ECC bytes in that order, no matter what the real layout is
      (which is usually all data then all OOB bytes). The
      marvell_nfc_layouts array below contains the currently
      supported layouts.
    - Because of these weird layouts, the Bad Block Markers can be
      located in data section. In this case, the NAND_BBT_NO_OOB_BBM
      option must be set to prevent scanningwriting bad block
      markers.
 Data FIFO granularity, FIFO readswrites must be a multiple of this length 
 NFC does not support transfers of larger chunks at a time 
 NFCv1 cannot read more that 7 bytes of ID 
 Polling is done at a pace of POLL_PERIOD us until POLL_TIMEOUT is reached 
 Interrupt maximum wait period in ms 
 Latency in clock cycles between SoC pins and NFC logic 
 Maximum number of contiguous address cycles 
 System control registersbits to enable the NAND controller on some SoCs 
 NAND controller data flash control register 
 NAND interface timing parameter 0 register 
 NAND interface timing parameter 1 register 
 NAND controller status register 
 NAND ECC control register 
 NAND controller data buffer register 
 NAND controller command buffer 0 register 
 NAND controller command buffer 1 register 
 NAND controller command buffer 2 register 
 NAND controller command buffer 3 register 
 NAND controller command buffer 0 register 'type' and 'xtype' fields 
  struct marvell_hw_ecc_layout - layout of Marvell ECC
  Marvell ECC engine works differently than the others, in order to limit the
  size of the IP, hardware engineers chose to set a fixed strength at 16 bits
  per subpage, and depending on a the desired strength needed by the NAND chip,
  a particular layout mixing dataspareecc is defined, with a possible last
  chunk smaller that the others.
  @writesize:		Full page size on which the layout applies
  @chunk:		Desired ECC chunk size on which the layout applies
  @strength:		Desired ECC strength (per chunk size bytes) on which the
 			layout applies
  @nchunks:		Total number of chunks
  @full_chunk_cnt:	Number of full-sized chunks, which is the number of
 			repetitions of the pattern:
 			(data_bytes + spare_bytes + ecc_bytes).
  @data_bytes:		Number of data bytes per chunk
  @spare_bytes:	Number of spare bytes per chunk
  @ecc_bytes:		Number of ecc bytes per chunk
  @last_data_bytes:	Number of data bytes in the last chunk
  @last_spare_bytes:	Number of spare bytes in the last chunk
  @last_ecc_bytes:	Number of ecc bytes in the last chunk
 Constraints 
 Corresponding layout 
 Layouts explained in AN-379_Marvell_SoC_NFC_ECC 
  struct marvell_nand_chip_sel - CS line description
  The Nand Flash Controller has up to 4 CE and 2 RB pins. The CE selection
  is made by a field in NDCB0 register, and in another field in NDCB2 register.
  The datasheet describes the logic with an error: ADDR5 field is once
  declared at the beginning of NDCB2, and another time at its end. Because the
  ADDR5 field of NDCB2 may be used by other bytes, it would be more logical
  to use the last bit of this field instead of the first ones.
  @cs:			Wanted CE lane.
  @ndcb0_csel:		Value of the NDCB0 register with or without the flag
 			selecting the wanted CE lane. This is set once when
 			the Device Tree is probed.
  @rb:			ReadyBusy pin for the flash chip
  struct marvell_nand_chip - stores NAND chip device related information
  @chip:		Base NAND chip structure
  @node:		Used to store NAND chips into a list
  @layout:		NAND layout when using hardware ECC
  @ndcr:		Controller register value for this NAND chip
  @ndtr0:		Timing registers 0 value for this NAND chip
  @ndtr1:		Timing registers 1 value for this NAND chip
  @addr_cyc:		Amount of cycles needed to pass column address
  @selected_die:	Current active CS
  @nsels:		Number of CS lines required by the NAND chip
  @sels:		Array of CS lines descriptions
  struct marvell_nfc_caps - NAND controller capabilities for distinction
                            between compatible strings
  @max_cs_nb:		Number of Chip Select lines available
  @max_rb_nb:		Number of ReadyBusy lines available
  @need_system_controller: Indicates if the SoC needs to have access to the
                       system controller (ie. to enable the NAND controller)
  @legacy_of_bindings:	Indicates if DT parsing must be done using the old
 			fashion way
  @is_nfcv2:		NFCv2 has numerous enhancements compared to NFCv1, ie.
 			BCH error detection and correction algorithm,
 			NDCB3 register has been added
  @use_dma:		Use dma for data transfers
  struct marvell_nfc - stores Marvell NAND controller information
  @controller:		Base controller structure
  @dev:		Parent device (used to print error messages)
  @regs:		NAND controller registers
  @core_clk:		Core clock
  @reg_clk:		Registers clock
  @complete:		Completion object to wait for NAND controller events
  @assigned_cs:	Bitmask describing already assigned CS lines
  @chips:		List containing all the NAND chips attached to
 			this NAND controller
  @selected_chip:	Currently selected target chip
  @caps:		NAND controller capabilities for each compatible string
  @use_dma:		Whetner DMA is used
  @dma_chan:		DMA channel (NFCv1 only)
  @dma_buf:		32-bit aligned buffer for DMA transfers (NFCv1 only)
 DMA (NFCv1 only) 
  struct marvell_nfc_timings - NAND controller timings expressed in NAND
                               Controller clock cycles
  @tRP:		ND_nRE pulse width
  @tRH:		ND_nRE high duration
  @tWP:		ND_nWE pulse time
  @tWH:		ND_nWE high duration
  @tCS:		Enable signal setup time
  @tCH:		Enable signal hold time
  @tADL:		Address to write data delay
  @tAR:		ND_ALE low to ND_nRE low delay
  @tWHR:		ND_nWE high to ND_nRE low for status read
  @tRHW:		ND_nRE high duration, read to write delay
  @tR:			ND_nWE high to ND_nRE low for read
 NDTR0 fields 
 NDTR1 fields 
  TO_CYCLES() - Derives a duration in numbers of clock cycles.
  @ps: Duration in pico-seconds
  @period_ns:  Clock period in nano-seconds
  Convert the duration in nano-seconds, then divide by the period and
  return the number of clock periods.
  struct marvell_nfc_op - filled during the parsing of the ->exec_op()
                          subop subset of instructions.
  @ndcb:		Array of values written to NDCBx registers
  @cle_ale_delay_ns:	Optional delay after the last CMD or ADDR cycle
  @rdy_timeout_ms:	Timeout for waits on ReadyBusy pin
  @rdy_delay_ns:	Optional delay after waiting for the RB pin
  @data_delay_ns:	Optional delay after the data xfer
  @data_instr_idx:	Index of the data instruction in the subop
  @data_instr:		Pointer to the data instruction in the subop
  Internal helper to conditionnally apply a delay (from the above structure,
  most of the time).
  The controller has many flags that could generate interrupts, most of them
  are disabled and polling is used. For the very slow signals, using interrupts
  may relax the CPU charge.
 Writing 1 disables the interrupt 
 Writing 0 enables the interrupt 
	
	  Callers of this function do not verify if the NAND is using a 16-bit
	  an 8-bit bus for normal operations, so we need to take care of that
	  here by leaving the configuration unchanged if the NAND does not have
	  the NAND_BUSWIDTH_16 flag set.
	
	  The command is being processed, wait for the ND_RUN bit to be
	  cleared by the NFC. If not, we must clear it by hand.
  Any time a command has to be sent to the controller, the following sequence
  has to be followed:
  - call marvell_nfc_prepare_cmd()
       -> activate the ND_RUN bit that will kind of 'start a job'
       -> wait the signal indicating the NFC is waiting for a command
  - send the command (cmd and address cycles)
  - enventually send or receive the data
  - call marvell_nfc_end_cmd() with the corresponding flag
       -> wait the flag to be triggered or cancel the job with a timeout
  The following helpers are here to factorize the code a bit so that
  specialized functions responsible for executing the actual NAND
  operations do not have to replicate the same code blocks.
 Poll ND_RUN and clear NDSR before issuing any command 
 Assert ND_RUN bit and wait the NFC to be ready 
 Command may be written, clear WRCMDREQ status bit 
	
	  Write NDCB0 four times only if LEN_OVRD is set or if ADDR6 or ADDR7
	  fields are used (only available on NFCv2).
	
	  DMA function uses this helper to poll on CMDD bits without wanting
	  them to be cleared.
 Timeout is expressed in ms 
	
	  In case the interrupt was not served in the required time frame,
	  check if the ISR was not served or if something went actually wrong.
	
	  Reset the NDCR register to a clean state for this particular chip,
	  also clear ND_RUN bit.
 Also reset the interrupt status register 
	
	  RDY interrupt mask is one bit in NDCR while there are two status
	  bit in NDSR (RDY[cs0cs2] and RDY[cs1cs3]).
 HW ECC related functions 
		
		  When enabling BCH, set threshold to 0 to always know the
		  number of corrected bitflips.
 DMA related helpers 
 Readwrite PIODMA accessors 
 Prepare the DMA transfer 
 Do the task and wait for it to finish 
	
	  Blank pages (all 0xFF) that have not been written may be recognized
	  as bad if bitflips occur, so whenever an uncorrectable error occurs,
	  check if the entire page (with ECC bytes) is actually blank or not.
 Update the stats and max_bitflips 
  Check if a chunk is correct or not according to the hardware ECC engine.
  mtd->ecc_stats.corrected is updated, as well as max_bitflips, however
  mtd->ecc_stats.failure is not, the function will instead return a non-zero
  value indicating that a check on the emptyness of the subpage must be
  performed before actually declaring the subpage as "corrupted".
 Check uncorrectable error flag 
		
		  Do not increment ->ecc_stats.failed now, instead, return a
		  non-zero value to indicate that this chunk was apparently
		  bad, and it should be check to see if it empty or not. If
		  the chunk (with ECC bytes) is not declared empty, the calling
		  function must increment the failure count.
 Check correctable error flag 
 Update the stats and max_bitflips 
 Hamming read helpers 
 NFCv2 needs more information about the operation being executed 
	
	  Read the page then the OOB area. Unlike what is shown in current
	  documentation, spare bytes are protected by the ECC engine, and must
	  be at the beginning of the OOB area or running this driver on legacy
	  systems will prevent the discovery of the BBMBBT.
	
	  When ECC failures are detected, check if the full page has been
	  written or not. Ignore the failure if it is actually empty.
  Spare area in Hamming layouts is not protected by the ECC engine (even if
  it appears before the ECC bytes when reading), the ->read_oob_raw() function
  also stands for ->read_oob().
 Hamming write helpers 
 NFCv2 needs more information about the operation being executed 
 Write the page then the OOB area 
  Spare area in Hamming layouts is not protected by the ECC engine (even if
  it appears before the ECC bytes when reading), the ->write_oob_raw() function
  also stands for ->write_oob().
 BCH read helpers 
 Update last chunk length 
 Read data bytes
 Read spare bytes 
 Read ECC bytes 
	
	  Trigger the monolithic read on the first chunk, then naked read on
	  intermediate chunks and finally a last naked read on the last chunk.
	
	  According to the datasheet, when reading from NDDB
	  with BCH enabled, after each 32 bytes reads, we
	  have to make sure that the NDSR.RDDREQ bit is set.
	 
	  Drain the FIFO, 8 32-bit reads at a time, and skip
	  the polling on the last read.
	 
	  Length is a multiple of 32 bytes, hence it is a multiple of 8 too.
	
	  With BCH, OOB is not fully used (and thus not read entirely), not
	  expected bytes could show up at the end of the OOB buffer if not
	  explicitly erased.
 Update length for the last chunk 
 Read the chunk and detect number of bitflips 
	
	  Please note that dumping the ECC bytes during a normal read with OOB
	  area would add a significant overhead as ECC bytes are "consumed" by
	  the controller in normal mode and must be re-read in raw mode. To
	  avoid dropping the performances, we prefer not to include them. The
	  user should re-read the page in raw mode if ECC bytes are required.
	
	  In case there is any subpage read error, we usually re-read only ECC
	  bytes in raw mode and check if the whole page is empty. In this case,
	  it is normal that the ECC check failed and we just ignore the error.
	 
	  However, it has been empirically observed that for some layouts (e.g
	  2k page, 8b strength per 512B chunk), the controller tries to correct
	  bits and may create itself bitflips in the erased area. To overcome
	  this strange behavior, the whole page is re-read in raw mode, not
	  only the ECC bytes.
 No failure reported for this chunk, move to the next one 
		
		  Only re-read the ECC bytes, unless we are using the 2k8b
		  layout which is buggy in the sense that the ECC engine will
		  try to correct data bytes anyway, creating bitflips. In this
		  case, re-read the entire page.
 Check the entire chunk (data + spare + ecc) for emptyness 
 BCH write helpers 
 Point to the column of the next chunk 
 Write the data 
 Write the spare bytes 
 Write the ECC bytes 
	
	  First operation dispatches the CMD_SEQIN command, issue the address
	  cycles and asks for the first chunk of data.
	  All operations in the middle (if any) will issue a naked write and
	  also ask for data.
	  Last operation (if any) asks for the last chunk of data through a
	  last naked write.
 Always dispatch the PAGEPROG command on the last chunk 
 Transfer the contents 
 Spare data will be written anyway, so clear it to avoid garbage 
		
		  Waiting only for CMDD or PAGED is not enough, ECC are
		  partially written. No flag is set once the operation is
		  really finished but the ND_RUN bit is cleared, so wait for it
		  before stepping into the next command.
 NAND framework ->exec_op() hooks and related helpers 
 Reset the input structure as most of its fields will be OR'ed 
	
	  NDCR ND_RUN bit should be cleared automatically at the end of each
	  operation but experience shows that the behavior is buggy when it
	  comes to writes (with LEN_OVRD). Clear it by hand in this case.
	
	  Naked access are different in that they need to be flagged as naked
	  by the controller. Reset the controller registers fields that inform
	  on the type and refill them according to the ongoing operation.
 This should never happen 
	
	  NDCR ND_RUN bit should be cleared automatically at the end of each
	  operation but experience shows that the behavior is buggy when it
	  comes to writes (with LEN_OVRD). Clear it by hand in this case.
 Monolithic readswrites 
 Naked commands 
 Naked commands not supported, use a function for each pattern 
  Layouts were broken in old pxa3xx_nand driver, these are supposed to be
  usable.
	
	  Bootrom looks in bytes 0 & 5 for bad blocks for the
	  4KB page  4bit BCH combination.
 Special care for the layout 2k8-bit512B  
 Last 8 blocks in each chip 
 Last 8 blocks in each chip 
	
	  SDR timings are given in pico-seconds while NFC timings must be
	  expressed in NAND controller clock cycles, which is half of the
	  frequency of the accessible ECC clock retrieved by clk_get_rate().
	  This is not written anywhere in the datasheet but was observed
	  with an oscilloscope.
	 
	  NFC datasheet gives equations from which thoses calculations
	  are derived, they tend to be slightly more restrictives than the
	  given core timings and may improve the overall speed.
	
	  Read delay is the time of propagation from SoC pins to NFC internal
	  logic. With non-EDO timings, this is MIN_RD_DEL_CNT clock cycles. In
	  EDO mode, an additional delay of tRH must be taken into account so
	  the data is sampled on the falling edge instead of the rising edge.
	
	  tWHR and tRHW are supposed to be read to write delays (and vice
	  versa) but in some cases, ie. when doing a change column, they must
	  be greater than that to be sure tCCS delay is respected.
	
	  NFCv2: Use WAIT_MODE (wait for RB line), do not rely only on delays.
	  NFCv1: No WAIT_MODE, tR must be maximal.
		
		  We'll use a bad block table stored in-flash and don't
		  allow writing the bad block marker to the flash.
 Save the chip-specific fields of NDCR 
	
	  On small page NANDs, only one cycle is needed to pass the
	  column address.
	
	  Now add the number of cycles needed to pass the row
	  address.
	 
	  Addressing a chip using CS 2 or 3 should also need the third row
	  cycle but due to inconsistance in the documentation and lack of
	  hardware to test this situation, this case is not supported.
		
		  Subpage write not available with hardware ECC, prohibit also
		  subpage read as in userspace subpage access would still be
		  allowed and subpage write, if used, would lead to numerous
		  uncorrectable ECC errors.
		
		  We keep the MTD name unchanged to avoid breaking platforms
		  where the MTD cmdline parser is used and the bootloader
		  has not been updated to use the new naming scheme.
		
		  If the new bindings are used and the bootloader has not been
		  updated to pass a new mtdparts parameter on the cmdline, you
		  should define the following property in your NAND node, ie:
		 
		 	label = "main-storage";
		 
		  This way, mtd->name will be set by the core when
		  nand_set_flash_node() is called.
	
	  The legacy "num-cs" property indicates the number of CS on the only
	  chip connected to the controller (legacy bindings does not support
	  more than one chip). The CS and RB pins are always the #0.
	 
	  When not using legacy bindings, a couple of "reg" and "nand-rb"
	  properties must be filled. For each chip, expressed as a subnode,
	  "reg" points to the CS lines and "nand-rb" to the RB line.
 Alloc the nand chip structure 
			
			  Legacy bindings use the CS lines in natural
			  order (0, 1, ...)
 Retrieve CS id 
		
		  The cs variable represents the chip select id, which must be
		  converted in bit fields for NDCB0 and NDCB2 to select the
		  right chip. Unfortunately, due to a lack of information on
		  the subject and incoherent documentation, the user should not
		  use CS1 and CS3 at all as asserting them is not supported in
		  a reliable way (due to multiplexing inside ADDR5 field).
 Retrieve RB id 
 Legacy bindings always use RB #0 
	
	  Save a reference value for timing registers before
	  ->setup_interface() is called.
 Legacy bindings support only one chip 
	
	  Legacy bindings do not use child nodes to exhibit NAND chip
	  properties and layout. Instead, NAND properties are mixed with the
	  controller ones, and partitions are defined as direct subnodes of the
	  NAND controller node.
	
	  DMA must act on length multiple of 32 and this length may be
	  bigger than the destination buffer. Use this buffer instead
	  for DMA transfers and then copy the desired amount of data to
	  the provided buffer.
	
	  ECC operations and interruptions are only enabled when specifically
	  needed. ECC shall not be activated in the early stages (fails probe).
	  Arbiter flag, even if marked as "reserved", must be set (empirical).
	  SPARE_EN bit must always be set or ECC bytes will not be at the same
	  offset in the read page and this will fail the protection.
	
	  Some SoCs like A7kA8k need to enable manually the NAND
	  controller, gated clocks and reset bits to avoid being bootloader
	  dependent. This is done through the use of the System Functions
	  registers.
 Configure the DMA if appropriate 
 Managed the legacy case (when the first clock was not named) 
 Get NAND controller capabilities 
 Init the controller and then probe the chips 
	
	  Reset nfc->selected_chip so the next command will cause the timing
	  registers to be restored in marvell_nfc_select_target().
 Reset registers that have lost their contents 
 sentinel  },
 Support for olddeprecated bindings: 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2017 Free Electrons
  Copyright (C) 2017 NextThing Co
  Author: Boris Brezillon <boris.brezillon@free-electrons.com>
  struct hynix_read_retry - read-retry data
  @nregs: number of register to set when applying a new read-retry mode
  @regs: register offsets (NAND chip dependent)
  @values: array of values to set in registers. The array size is equal to
 	    (nregs  nmodes)
  struct hynix_nand - private Hynix NAND struct
  @nand_technology: manufacturing process expressed in picometer
  @read_retry: read-retry information
  struct hynix_read_retry_otp - structure describing how the read-retry OTP
 				 area
  @nregs: number of hynix private registers to set before reading the reading
 	   the OTP area
  @regs: registers that should be configured
  @values: values that should be set in regs
  @page: the address to pass to the READ_PAGE command. Depends on the NAND
 	  chip
  @size: size of the read-retry OTP section
 Enter 'Set Hynix Parameters' mode 
	
	  Configure the NAND in the requested read-retry mode.
	  This is done by setting pre-defined values in internal NAND
	  registers.
	 
	  The set of registers is NAND specific, and the values are either
	  predefined or extracted from an OTP area on the NAND (values are
	  probably tweaked at production in this case).
 Apply the new settings. 
  hynix_get_majority - get the value that is occurring the most in a given
 			set of values
  @in: the array of values to test
  @repeat: the size of the in array
  @out: pointer used to store the output value
  This function implements the 'majority check' logic that is supposed to
  overcome the unreliability of MLC NANDs when reading the OTP area storing
  the read-retry parameters.
  It's based on a pretty simple assumption: if we repeat the same value
  several times and then take the one that is occurring the most, we should
  find the correct value.
  Let's hope this dummy algorithm prevents us from losing the read-retry
  parameters.
	
	  We only test the first half of the in array because we must ensure
	  that the value is at least occurring repeat  2 times.
	 
	  This loop is suboptimal since we may count the occurrences of the
	  same value several time, but we are doing that on small sets, which
	  makes it acceptable.
 Count all values that are matching the one at index i. 
 We found a value occurring more than repeat  2. 
 Sequence to enter OTP mode? 
 Now read the page 
 Put everything back to normal 
	
	  We only support read-retry for 1xnm NANDs, and those NANDs all
	  expose a valid JEDEC ID.
 1xnm technology 
				
				  FIXME: Hynix recommend to copy the
				  read-retry OTP area into a normal page.
			
			  We should never reach this case, but if that
			  happens, this probably means Hynix decided to use
			  a different extended ID format, and we should find
			  a way to support it.
			
			  We should never reach this case, but if that
			  happens, this probably means Hynix decided to use
			  a different extended ID format, and we should find
			  a way to support it.
		
		  The datasheet of H27UCG8T2BTR mentions that the "Redundant
		  Area Size" is encoded "per 8KB" (page size). This chip uses
		  a page size of 16KiB. The datasheet mentions an OOB size of
		  1.280 bytes, but the OOB size encoded in the ID bytes (using
		  the existing logic above) is 640 bytes.
		  Update the OOB size for this chip by taking the value
		  determined above and scaling it to the actual page size (so
		  the actual OOB size for this chip is: 640  16k  8k).
 Reference: H27UCG8T2E datasheet 
			
			  We should never reach this case, but if that
			  happens, this probably means Hynix decided to use
			  a different extended ID format, and we should find
			  a way to support it.
		
		  The ECC requirements field meaning depends on the
		  NAND technology.
 > 26nm, reference: H27UBG8T2A datasheet 
				
				  We should never reach this case, but if that
				  happens, this probably means Hynix decided
				  to use a different extended ID format, and
				  we should find a way to support it.
 <= 26nm, reference: H27UBG8T2B datasheet 
 We need scrambling on all TLC NANDs
 And on MLC NANDs with sub-3xnm process 
 < 3xnm 
 < 32nm 
	
	  Exclude all SLC NANDs from this advanced detection scheme.
	  According to the ranges defined in several datasheets, it might
	  appear that even SLC NANDs could fall in this extended ID scheme.
	  If that the case rework the test to let SLC NANDs go through the
	  detection process.
 Extract pagesize 
	
	  When bit7 is set that means we start counting at 1MiB, otherwise
	  we start counting at 128KiB and shift this value the content of
	  ID[3][4:5].
	  The only exception is when ID[3][4:5] == 3 and ID[3][7] == 0, in
	  this case the erasesize is set to 768KiB.
	
	  Modern Toggle DDR NANDs have a valid JEDECID even though they are
	  not exposing a valid JEDEC parameter table.
	  These NANDs use a different NAND ID scheme.
  NAND support for Marvell Orion SoC platforms
  Tzachi Perelstein <tzachi@marvell.com>
  This file is licensed under  the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
		
		  Since GCC has no proper constraint (PR 43518)
		  force x variable to r2r3 registers as ldrd instruction
		  requires first register to be even.
	 Not all platforms can gate the clock, so it is not
	
	  This driver assumes that the default ECC engine should be TYPE_SOFT.
	  Set ->engine_type before registering the NAND devices in order to
	  provide a driver specific default value.
 SPDX-License-Identifier: GPL-2.0-or-later
 Freescale Enhanced Local Bus Controller NAND driver
  Copyright  2006-2007, 2010 Freescale Semiconductor
  Authors: Nick Spence <nick.spence@freescale.com>,
           Scott Wood <scottwood@freescale.com>
           Jack Lan <jack.lan@freescale.com>
           Roy Zang <tie-fei.zang@freescale.com>
 Value returned for read bytes when read failed 
 Maximum number of mSecs to wait for FCM 
 mtd information per set 
 Chip select bank number           
 Chip select base virtual address  
 NAND page size (0=512, 1=2048)    
 FCM Flash Mode Register value     
 Freescale eLBC FCM controller information 
 Address of assigned FCM buffer        
 Last page written to  read from      
 Number of bytes read during command   
 Saved column from SEQIN               
 Pointer to next byte to 'read'        
 status read from LTESR after last op  
 UPMFCM Data Register value           
 Non zero if the MDR is to be set      
 Non zero if operating on OOB data     
 counter for the initializations	  
 Saved during READ0 cmd		  
 These map to the positions used by the FCM hardware ECC generator 
  ELBC may use HW ECC, so that OOB offsets, that NAND core uses for bbt,
  interfere with ECC positions, that's why we implement our own descriptors.
  OOB {11, 5}, works for both SP and LP chips, with ECCM = 1 and ECCM = 0.
=================================
  Set up the FCM hardware block and page address fields, and the fcm
  structure addr field to point to the correct FCM buffer in memory
		
		  large page size chip : FPAR[PI] save the lowest 6 bits,
		                         FBAR[BLK] save the other bits.
		
		  small page size chip : FPAR[PI] save the lowest 5 bits,
		                         FBAR[BLK] save the other bits.
 for OOB data point to the second half of the buffer 
  execute FCM command and wait for it to complete
 Setup the FMR[OP] to execute without write protection 
 execute special operation 
 wait for FCM complete flag or timeout 
 store mdr value in case it was needed 
		
		  if command was a full page read and the ELBC
		  has the LTECCR register, then bits 12-15 (ppc order) of
		  LTECCR indicates which 512 byte sub-pages had fixed errors.
		  bits 28-31 are uncorrectable errors, marked elsewhere.
		  for small page nand only 1 bit is used.
		  if the ELBC doesn't have the lteccr register it reads 0
		  FIXME: 4 bits can be corrected on NANDs with 2k pages, so
		  count the number of sub-pages with bitflips and update
		  ecc_stats.corrected accordingly.
 clear lteccr 
 cmdfunc send commands to the FCM 
 clear the read buffer 
 READ0 and READ1 read the entire buffer to use hardware ECC. 
 read entire page to enable ECC 
 RNDOUT moves the pointer inside the page 
 READOOB reads only the OOB because no ECC is performed. 
		
		  although currently it's 8 bytes for READID, we always read
		  the maximum 256 bytes(for PARAM)
 ERASE1 stores the block and page address 
 ERASE2 uses the block and page address from ERASE1 
 SEQIN sets up the addr buffer and all registers except the length 
 OOB area 
 OOB area --> READOOB 
 First 256 bytes --> READ0 
 PAGEPROG reuses all of the setup from SEQIN and adds the length 
		 if the write did not start at 0 or is not a full page
		  then set the exact length, otherwise use a full page
		  write so the HW generates the ECC.
 CMD_STATUS must read the status byte while CEB is active 
 Note - it does not wait for the ready line 
		 The chip always seems to report that it is
		  write-protected, even when it is not.
 RESET without waiting for the ready line 
	 The hardware does not seem to support multiple
	  chips per bank.
  Write buf to the FCM Controller Data Buffer
	
	  This is workaround for the weird elbc hangs during nand write,
	  Scott Wood says: "...perhaps difference in how long it takes a
	  write to make it through the localbus compared to a write to IMMR
	  is causing problems, and sync isn't helping for some reason."
	  Reading back the last byte helps though.
  read a byte from either the FCM hardware buffer if it has any data left
  otherwise issue a command to read a single byte.
 If there are still bytes in the FCM, then use the next byte. 
  Read from the FCM Controller Data Buffer
 This function is called after Program and Erase Operations to
  check for success or failure.
	 The chip always seems to report that it is
	  write-protected, even when it is not.
 ECC will be calculated automatically, and errors will be detected in
  waitfunc.
 ECC will be calculated automatically, and errors will be detected in
  waitfunc.
 Fill in fsl_elbc_mtd structure 
 set timeout to maximum 
 fill in nand_chip structure 
 set up function call table 
 set up nand options 
	
	  if ECC was not chosen in DT, decide whether to use HW or SW ECC from
	  CS Base Register
 If CS Base Register selects full hardware ECC then use it 
 otherwise fall back to default software ECC 
 if SW ECC was chosen in DT, we do not need to set anything here 
 should we also implement _ECC_ENGINE_CONTROLLER to do as above? 
 calculate FMR Address Length field 
 adjust Option Register and ECC to match Flash page size 
 get, allocate and map the memory resource 
 find which chip select it is connected to 
	 First look for RedBoot table or partitions on the command
 SPDX-License-Identifier: GPL-2.0-only
  (C) 2005, 2006 Red Hat Inc.
  Author: David Woodhouse <dwmw2@infradead.org>
 	   Tom Sylla <tom.sylla@amd.com>
   Overview:
    This is a device driver for the NAND flash controller found on
    the AMD CS5535CS5536 companion chipsets for the Geode processor.
    mtd-id for command line partitioning is cs553x_nand_cs[0-3]
    where 0-3 reflects the chip select for NAND.
 DIVIL capabilitiies 
 NAND Timing MSRs 
 NAND Flash Data Timing MSR 
 NAND Flash Control Timing 
 Reserved 
 NAND BAR MSRs 
 Flash Chip Select 0 
 Flash Chip Select 1 
 Flash Chip Select 2 
 Flash Chip Select 3 
 Each made up of... 
 1 for NAND 
 1 for MMIO 
 IO BARs have BASE_ADDR in bits 15:4, IO_MASK in 47:36 
 MMIO BARs have BASE_ADDR in bits 31:12, MEM_MASK in 63:44 
 Pin function selection MSR (IDE vs. flash on the IDE pins) 
 0 for flash, 1 for IDE 
 Registers within the NAND flash controller BAR -- memory mapped 
 0 to 0x7ff, in fact 
 Any even address 0x800-0x80e 
 Any odd address 0x801-0x80f 
 Registers within the NAND flash controller BAR -- IO mapped 
 0 to 3, in fact 
 Enable NAND Distract interrupt 
 Enable RDYBUSY# interrupt 
 Keep low; 1 to reset 
 De-assert the CE pin 
 Re-assert the CE pin. 
 Allocate memory for MTD device structure and private data 
 Link the private data with the MTD structure 
 map physical address 
 Enable the following for a flash based bad block table 
 Scan to find existence of the device 
 These are the CPUs which will have a CS553[56] companion chip 
 Geode LX 
 Geode GX (ne GX2) 
 If the CPU isn't a Geode GX or LX, abort 
 If it doesn't have the CS553[56], abort 
 If it doesn't have the NAND controller enabled, abort 
	 Register all devices together here. This means we can easily hack it to
 If any devices registered, return success. Else the last error. 
 Release resources, unregister device 
 unmap physical address 
 Free the MTD device structure 
 SPDX-License-Identifier: GPL-2.0-only
   Copyright (C) 2004 Embedded Edge, LLC
  au_write_buf -  write buffer to chip
  @this:	NAND chip object
  @buf:	data buffer
  @len:	number of bytes to write
  write function for 8bit buswidth
 drain writebuffer 
  au_read_buf -  read chip data into buffer
  @this:	NAND chip object
  @buf:	buffer to store date
  @len:	number of bytes to read
  read function for 8bit buswidth
 drain writebuffer 
  au_write_buf16 -  write buffer to chip
  @this:	NAND chip object
  @buf:	data buffer
  @len:	number of bytes to write
  write function for 16bit buswidth
 drain writebuffer 
  au_read_buf16 -  read chip data into buffer
  @this:	NAND chip object
  @buf:	buffer to store date
  @len:	number of bytes to read
  read function for 16bit buswidth
 drain writebuffer 
 CSx 
 STADDRx 
 figure out the decoded range of this CS 
 Drain the writebuffer 
 Drain the writebuffer 
 assert (force assert) chip enable 
 Drain the writebuffer 
 deassert chip enable 
 Drain the writebuffer 
 figure out which CS# r->start belongs to 
	
	  This driver assumes that the default ECC engine should be TYPE_SOFT.
	  Set ->engine_type before registering the NAND devices in order to
	  provide a driver specific default value.
 SPDX-License-Identifier: GPL-2.0-only
   Copyright (C) 2004 Richard Purdie
   Copyright (C) 2008 Dmitry Baryshkov
   Based on Sharp's NAND driver sharp_sl.c
 register offset 
 line parity 7 - 0 bit 
 line parity 15 - 8 bit 
 column parity 5 - 0 bit 
 ECC byte counter 
 cleare ECC 
 Flash IO 
 Flash Control 
 Flash control bit 
 	hardware specific access to control-lines
 	ctrl:
 	NAND_CNE: bit 0 -> ! bit 0 & 4
 	NAND_CLE: bit 1 -> bit 1
 	NAND_ALE: bit 2 -> bit 2
  Main initialization routine
 Allocate memory for MTD device structure and private data 
 map physical address 
 Get pointer to private data 
 Link the private data with the MTD structure 
	
	  PXA initialize
 Set address of NAND IO lines 
 Set address of hardware control function 
 15 us command delay time 
 Scan to find existence of the device 
 Register the partitions 
 Return happy 
  Clean up routine
 Unregister device 
 Release resources 
 Free the driver's structure 
 SPDX-License-Identifier: GPL-2.0-only
   Copyright  2012 John Crispin <john@phrozen.org>
   Copyright  2016 Hauke Mehrtens <hauke@hauke-m.de>
 nand registers 
 NAND flash status output 
 NAND WriteRead complete 
  nand commands
  The pins of the NAND chip are selected based on the address bits of the
  "register" read and write. There are no special registers, but an
  address range and the lower address bits are used to activate the
  correct line. For example when the bit (1 << 2) is set in the address
  the ALE pin will be activated.
 address latch enable 
 command latch enable 
 chip select 
 spare area access latch 
 write protect 
 we need to tel the ebu which addr we mapped the nand to 
 we need to tell the EBU that we have nand attached and set it up properly 
  Probe for the NAND device.
 Allocate memory for the device structure (and zero it) 
 load our CS from the DT. Either we find a valid 1 or default to 0 
 setup the EBU to run in NAND mode on our base addr 
	
	  This driver assumes that the default ECC engine should be TYPE_SOFT.
	  Set ->engine_type before registering the NAND devices in order to
	  provide a driver specific default value.
 Scan to find existence of the device 
  Remove a NAND device.
 SPDX-License-Identifier: GPL-2.0
  NAND Flash Controller Device Driver
  Copyright  2009-2010, Intel Corporation and its suppliers.
 List of platforms this NAND controller has be integrated into 
 end: all zeroes  }
 50 MHz 
 200 MHz 
 SPDX-License-Identifier: GPL-2.0 OR MIT
  MTK NAND Flash controller driver.
  Copyright (C) 2016 MediaTek Inc.
  Authors:	Xiaolei Li		<xiaolei.li@mediatek.com>
 		Jorge Ramirez-Ortiz	<jorge.ramirez-ortiz@linaro.org>
 NAND controller register definition 
 NFI control 
 burst  read 
 burst  write 
 Timming control register 
  FDM: region used to store free OOB data
 nothing after this field 
  supported spare size of each IP.
  order should be the same with the spare size bitfiled defination of
  register NFI_PAGEFMT.
	 map the sector's FDM data to free oob:
	  the beginning of the oob area stores the FDM data of bad mark sectors
 reset all registers and force the NFI master to terminate 
 wait for the master to finish the last transaction 
 ensure any status register affected by the NFI master is reset 
	
	  the hardware will double the value for this eccsize, so we need to
	  halve it
 after each byte read, the NFI_STA reg is reset by the hardware 
		
		  set to max sector to allow the HW to continue reading over
		  unaligned accesses
 trigger to fetch data 
 There is a frequency divider in some IPs 
 turn clock rate into KHZ 
 sdr interface has no tCR which means CE# low to RE# low 
 Calculate real WE#RE# hold time in nanosecond 
 nanosecond to picosecond 
	
	  WE# low level time should be expaned to meet WE# pulse time
	  and WE# cycle time at the same time.
	
	  RE# low level time should be expaned to meet RE# pulse time
	  and RE# cycle time at the same time.
 Calculate RE# pulse time in nanosecond. 
 nanosecond to picosecond 
	
	  If RE# access time is bigger than RE# pulse time,
	  delay sampling data timing.
	
	  ACCON: access timing control register
	  -------------------------------------
	  31:28: tpoecs, minimum required time for CS post pulling down after
	         accessing the device
	  27:22: tprecs, minimum required time for CS pre pulling down before
	         accessing the device
	  21:16: tc2r, minimum required time from NCEB low to NREB low
	  15:12: tw2r, minimum required time from NWEB high to NREB low.
	  11:08: twh, write enable hold time
	  07:04: twst, write wait states
	  03:00: trlt, read wait states
 nop 
 program the CRC back to the OOB 
 OOB => FDM: from register,  ECC: from HW 
 clear NFI config 
 write OOB into the FDM registers (OOB area in MTK NAND) 
 use the data in the private buffer (now with FDM and CRC) 
 clear NFI_CNFG 
	
	  CNRNB: nand readybusy register
	  -------------------------------
	  7:4: timeout register for polling the NAND busyready signal
	  0  : poll the status of the busyready signal after [7:4]16 cycles.
 bad block mark storage 
 support only ecc hw mode 
 if optional dt settings not present 
 use datasheet requirements 
		
		  align eccstrength and eccsize
		  this controller only supports 512 and 1024 sizes
 calculate oob bytes except ecc parity data 
		
		  enhance ecc strength if oob left is bigger than max FDM size
		  or reduce ecc strength if oob size is not enough for ecc
		  parity data.
 store bbt magic in page, cause OOB is not protected 
 set default mode in case dt entry is missing 
 probe defer if not ready 
 reset NAND chip if VCC was powered off 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018 Toradex AG
  Author: Marcel Ziswiler <marcel.ziswiler@toradex.com>
 Extract ECC requirements from 5th id byte. 
		
		  It is known that some ESMT SLC NANDs have been shipped
		  with the factory bad block markers in the first or last page
		  of the block, instead of the first or second page. To be on
		  the safe side, let's check all three locations.
 SPDX-License-Identifier: (GPL-2.0+ OR MIT)
  Amlogic Meson Nand Flash Controller Driver
  Copyright (c) 2018 Amlogic, inc.
  Author: Liang Yang <liang.yang@amlogic.com>
 eMMC clock register, misc control 
 nand flash controller delay 3 ns 
	
	  Insert two commands to make sure all valid commands are finished.
	 
	  The Nand flash controller is designed as two stages pipleline -
	   a) fetch and b) excute.
	  There might be cases when the driver see command queue is empty,
	  but the Nand flash controller still has two commands buffered,
	  one is fetched into NFC request queue (ready to run), and another
	  is actively executing. So pushing 2 "IDLE" commands guarantees that
	  the pipeline is emptied.
 wait cmd fifo is empty 
 use the max erase time as the maximum clock for waiting RB 
 subtract cmd1 
 info is updated by nfc dma engine
 request core clock 
 init SD_EMMC_CLOCK to sane defaults wmin clock rate 
 SPDX-License-Identifier: GPL-2.0-or-later
  davinci_nand.c - NAND Flash Driver for DaVinci family chips
  Copyright  2006 Texas Instruments.
  Port to 2.6.23 Copyright  2008 by:
    Sander Huijsen <Shuijsen@optelecom-nkf.com>
    Troy Kisky <troy.kisky@boundarydevices.com>
    Dirk Behme <Dirk.Behme@gmail.com>
  This is a device driver for the NAND flash controller found on the
  various DaVinci family chips.  It handles up to four SoC chipselects,
  and some flavors of secondary chipselect (e.g. based on A12) as used
  with multichip packages.
  The 1-bit ECC hardware is supported, as well as the newer 4-bit ECC
  available on chips like the DM355 and OMAP-L137 and needed with the
  more error-prone MLC NAND chips.
  This driver assumes EM_WAIT connects all the NAND devices' RDYnBUSY
  outputs in a "wire-AND" configuration, with no per-chip signals.
----------------------------------------------------------------------
  1-bit hardware ECC ... context maintained for each core chipselect
 Reset ECC hardware 
 Restart ECC hardware 
  Read hardware ECC value and pack into three bytes
 invert so that erased block ecc is correct 
 Correctable error 
			 Single bit ECC error in the ECC itself,
 Uncorrectable error 
----------------------------------------------------------------------
  4-bit hardware ECC ... context maintained over entire AEMIF
  This is a syndrome engine, but we avoid NAND_ECC_PLACEMENT_INTERLEAVED
  since that forces use of a problematic "infix OOB" layout.
  Among other things, it trashes manufacturer bad block markers.
  Also, and specific to this hardware, it ECC-protects the "prepad"
  in the OOB ... while having ECC protection for parts of OOB would
  seem useful, the current MTD stack sometimes wants to update the
  OOB without recomputing ECC.
 Reset ECC hardware 
 Start 4-bit ECC calculation for readwrite 
 Read raw ECC code after writing to NAND. 
 Terminate read ECC; or return ECC (as bytes) of data written to NAND. 
	 After a read, terminate ECC calculation by a dummy read
	  of some 4-bit ECC register.  ECC covers everything that
	  was read; correct() just uses the hardware state, so
	  ecc_code is not needed.
	 Pack eight raw 10-bit ecc values into ten bytes, making
	  two passes which each convert four values (in upper and
	  lower halves of two 32-bit words) into five bytes.  The
	  ROM boot loader uses this same packing scheme.
 Correct up to 4 bits in data we just read, using state left in the
  hardware plus the ecc_code computed when it was first written.
	 Unpack ten bytes into eight 10 bit values.  We know we're
	  little-endian, and use type punning for less shiftingmasking.
 Tell ECC controller about the expected ECC codes. 
	 Allow time for syndrome calculation ... then read it.
	  A syndrome of all zeroes 0 means no detected errors.
	
	  Clear any previous address calculation by doing a dummy read of an
	  error address register.
	 Start address calculation, and wait for it to complete.
	  We _could_ start reading more data while this is working,
	  to speed up the overall page read.
	
	  ECC_STATE field reads 0x3 (Error correction complete) immediately
	  after setting the 4BITECC_ADD_CALC_START bit. So if you immediately
	  begin trying to poll for the state, you may fall right out of your
	  loop without any of the correction calculations having taken place.
	  The recommendation from the hardware team is to initially delay as
	  long as ECC_STATE reads less than 4. After that, ECC HW has entered
	  correction state.
 no error, should not happen 
 five or more errors detected 
 error addresses computed 
 still working on it 
 correct each error 
  nand_read_page_hwecc_oob_first - hw ecc, read oob first
  @chip: nand chip info structure
  @buf: buffer to store read data
  @oob_required: caller requires OOB data read to chip->oob_poi
  @page: page number to read
  Hardware ECC for large page chips, require OOB to be read first. For this
  ECC mode, the write_page method is re-used from ECC_HW. These methods
  readwrite ECC from the OOB area, unlike the ECC_HW_SYNDROME support with
  multiple ECC steps, follows the "infix ECC" scheme and readswrites ECC from
  the data area, by overwriting the NAND manufacturer bad block markings.
 Read the OOB area first 
 check for empty pages with bitflips 
----------------------------------------------------------------------
 An ECC layout for using 4-bit ECC with small-page flash, storing
  ten ECC bytes plus the manufacturer's bad block marker byte, and
  and not overlapping the default BBT markers.
		
		  Since kernel v4.8, this driver has been fixed to enable
		  use of 4-bit hardware ECC with subpages and verified on
		  TI's keystone EVMs (K2L, K2HK and K2E).
		  However, in the interest of not breaking systems using
		  existing UBI partitions, sub-page writes are not being
		  (re)enabled. If you want to use subpage writes on Keystone
		  platforms (i.e. do not have any existing UBI partitions),
		  then use "ti,davinci-nand" as the compatible in your
		  device-tree file.
 Use board-specific ECC config 
		
		  This driver expects Hamming based ECC when engine_type is set
		  to NAND_ECC_ENGINE_TYPE_SOFT. Force ecc.algo to
		  NAND_ECC_ALGO_HAMMING to avoid adding an extra ->ecc_algo
		  field to davinci_nand_pdata.
			
			  No sanity checks:  CPUs must support this,
			  and the chips may not use NAND_BUSWIDTH_16.
 No sharing 4-bit hardware between chipselects yet 
			
			  Update ECC layout if needed ... for 1-bit HW ECC, the
			  default is OK, but it allocates 6 bytes when only 3
			  are needed (for each 512 bytes). For 4-bit HW ECC,
			  the default is not usable: 10 bytes needed, not 6.
			 
			  For small page chips, preserve the manufacturer's
			  badblock marking data ... and make sure a flash BBT
			  table marker fits in the free bytes.
 1bit ecc hamming 
 insist on board-specific configuration 
 which external chipselect will we be managing? 
	
	  This registers range is used to setup NAND settings. In case with
	  TI AEMIF driver, the same memory address range is requested already
	  by AEMIF, so we cannot request it twice, just ioremap.
	  The AEMIF and NAND drivers not use the same registers in this range.
 options such as NAND_BBT_USE_FLASH 
 options such as 16-bit widths 
 use nandboot-capable ALECLE masks by default 
 put CSxNAND into NAND mode 
 Scan to find existence of the device(s) 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) STMicroelectronics 2018
  Author: Christophe Kerello <christophe.kerello@st.com>
 Bad block marker length 
 ECC step size 
 BCHDSRx registers length 
 HECCR length 
 Max requests done for a 8k nand page size 
 Max chip enable 
 Max ECC buffer length 
 Timings 
 FMC2 Controller Registers 
 Register: FMC2_BCR1 
 Register: FMC2_PCR 
 Register: FMC2_SR 
 Register: FMC2_PMEM 
 Register: FMC2_PATT 
 Register: FMC2_ISR 
 Register: FMC2_ICR 
 Register: FMC2_CSQCR 
 Register: FMC2_CSQCFGR1 
 Register: FMC2_CSQCFGR2 
 Register: FMC2_CSQCFGR3 
 Register: FMC2_CSQCAR1 
 Register: FMC2_CSQCAR2 
 Register: FMC2_CSQIER 
 Register: FMC2_CSQICR 
 Register: FMC2_CSQEMSR 
 Register: FMC2_BCHIER 
 Register: FMC2_BCHICR 
 Register: FMC2_BCHDSR0 
 Register: FMC2_BCHDSR1 
 Register: FMC2_BCHDSR2 
 Register: FMC2_BCHDSR3 
 Register: FMC2_BCHDSR4 
 Set tclrtar timings 
 Set tsettwaittholdthiz timings in common bank 
 Set tsettwaittholdthiz timings in attribut bank 
 Configure ECC algorithm (default configuration is Hamming) 
 Set buswidth 
 Set ECC sector size 
		
		  Hamming: we read HECCR register
		  BCH4BCH8: we read BCHDSRSx registers
 Calculate ECC length needed for one sector 
  Enable ECC logic and reset syndromeparity bits previously calculated
  Syndromeparity bits is cleared by setting the ECCEN bit to 0
  ECC Hamming calculation
  ECC is 3 bytes for 512 bytes of data (supports error correction up to
  max of 1-bit)
 Indicate which bit and byte is faulty (if any) 
 No errors 
 Calculate bit position 
 Calculate byte position 
 Flip the bit 
  ECC BCH calculation and correction
  ECC is 713 bytes for 512 bytes of data (supports error correction up to
  max of 4-bit8-bit)
 Wait until the BCH code is ready 
 Read parity bits 
 No errors found 
 Too many errors detected 
 Wait until the decoding error is ready 
 Read the nand page sector (512 bytes) 
 Read the corresponding ECC bytes 
 Correct the data 
 Check for empty pages with bitflips 
 Read oob 
 Sequencer readwrite configuration 
	
	  cfg[0] => csqcfgr1, cfg[1] => csqcfgr2, cfg[2] => csqcfgr3
	  cfg[3] => csqar1, cfg[4] => csqar2
	
	  - Set Program PagePage Read command
	  - Enable DMA request data
	  - Set timings
	
	  - Set Random Data InputRandom Data Read command
	  - Enable the sequencer to access the Spare data area
	  - Enable  DMA request status decoding for read
	  - Set timings
	
	  - Set the number of sectors to be written
	  - Set timings
	
	  Set the fourth first address cycles
	  Byte 1 and byte 2 => column, we start at 0x0
	  Byte 3 and byte 4 => page
	
	  - Set chip enable number
	  - Set ECC byte offset in the spare area
	  - Calculate the number of address cycles to be issued
	  - Set byte 5 of address cycle if needed
 Readwrite data fromto a page 
 Configure DMA data 
 Configure DMA ECC status 
 Start the transfer 
 Wait end of sequencer transfer 
 Wait DMA data transfer completion 
 Wait DMA ECC transfer completion 
 Configure the sequencer 
 Write the page 
 Write oob 
 Get a status indicating which sectors have errors 
 Ecc_sta = FMC2_HECCR 
			
			  Ecc_sta[0] = FMC2_BCHDSR0
			  Ecc_sta[1] = FMC2_BCHDSR1
			  Ecc_sta[2] = FMC2_BCHDSR2
			  Ecc_sta[3] = FMC2_BCHDSR3
			  Ecc_sta[4] = FMC2_BCHDSR4
 Check for empty pages with bitflips 
 Configure the sequencer 
 Read the page 
 Check if errors happen 
 Read oob 
 Correct data 
 Configure the sequencer 
 Read the page 
 Read oob 
 Sequencer is used 
 BCH is used 
 Reconfigure bus width to 8-bit 
 Buf is aligned 
 Read remaining bytes 
 Reconfigure bus width to 16-bit 
 Reconfigure bus width to 8-bit 
 Buf is aligned 
 Write remaining bytes 
 Reconfigure bus width to 16-bit 
 Check if there is no pending requests to the NAND flash 
 Wait tWB before RB# signal is low 
 RB# signal is low, clear high level flag 
 Wait RB# signal is high 
 Set CS used to undefined 
 Enable wait feature and nand flash memory bank 
 Set buswidth to 8 bits mode for identification 
 ECC logic is disabled 
 Default mode 
 Set default ECC sector size 
 Set default tclrtar timings 
 Enable FMC2 controller 
	
	  tWAIT > tRP
	  tWAIT > tWP
	  tWAIT > tREA + tIO
	
	  tSETUP_MEM > tCS - tWAIT
	  tSETUP_MEM > tALS - tWAIT
	  tSETUP_MEM > tDS - (tWAIT - tHIZ)
	
	  tHOLD_MEM > tCH
	  tHOLD_MEM > tREH - tSETUP_MEM
	  tHOLD_MEM > max(tRC, tWC) - (tSETUP_MEM + tWAIT)
	
	  tSETUP_ATT > tCS - tWAIT
	  tSETUP_ATT > tCLS - tWAIT
	  tSETUP_ATT > tALS - tWAIT
	  tSETUP_ATT > tRHW - tHOLD_MEM
	  tSETUP_ATT > tDS - (tWAIT - tHIZ)
	
	  tHOLD_ATT > tALH
	  tHOLD_ATT > tCH
	  tHOLD_ATT > tCLH
	  tHOLD_ATT > tCOH
	  tHOLD_ATT > tDH
	  tHOLD_ATT > tWB + tIO + tSYNC - tSETUP_MEM
	  tHOLD_ATT > tADL - tSETUP_MEM
	  tHOLD_ATT > tWH - tSETUP_MEM
	  tHOLD_ATT > tWHR - tSETUP_MEM
	  tHOLD_ATT > tRC - (tSETUP_ATT + tWAIT)
	  tHOLD_ATT > tWC - (tSETUP_ATT + tWAIT)
 Allocate a buffer to store ECC status registers 
	
	  Specific callbacks to readwrite a page depending on
	  the mode (pollingsequencer) and the algo used (Hamming, BCH).
 DMA => use sequencer mode callbacks 
 No DMA => use polling mode callbacks 
 Hamming is used 
 BCH is used 
 Specific configurations depending on the algo used 
 Hamming 
 BCH8 
 BCH4 
	
	  Only NAND_ECC_ENGINE_TYPE_ON_HOST mode is actually supported
	  Hamming => ecc.strength = 1
	  BCH4 => ecc.strength = 4
	  BCH8 => ecc.strength = 8
	  ECC sector size = 512
 Default ECC settings in case they are not set in the device tree 
 Scan to find existence of the device 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2013 Boris BREZILLON <b.brezillon.dev@gmail.com>
  Derived from:
 	https:github.comyuqsunxi-nfc-mtd
 	Copyright (C) 2013 Qiang Yu <yuq825@gmail.com>
 	https:github.comhnoAllwinner-Info
 	Copyright (C) 2013 Henrik Nordstrm <Henrik Nordstrm>
 	Copyright (C) 2013 Dmitriy B. <rzk333@gmail.com>
 	Copyright (C) 2013 Sergey Lapin <slapin@ossfans.org>
 define bit use in NFC_CTL 
 define bit use in NFC_ST 
 define bit use in NFC_INT 
 define bit use in NFC_TIMING_CTL 
 define NFC_TIMING_CFG register layout 
 define bit use in NFC_CMD 
 define bit use in NFC_RCMD_SET 
 define bit use in NFC_WCMD_SET 
 define bit use in NFC_ECC_CTL 
 define bit use in NFC_ECC_ST 
  struct sunxi_nand_chip_sel - stores information related to NAND Chip Select
  @cs: the NAND CS id used to communicate with a NAND Chip
  @rb: the ReadyBusy pin ID. -1 means no RB pin connected to the NFC
  struct sunxi_nand_hw_ecc - stores information related to HW ECC support
  @mode: the sunxi ECC mode field deduced from ECC requirements
  struct sunxi_nand_chip - stores NAND chip device related information
  @node: used to store NAND chips into a list
  @nand: base NAND chip structure
  @ecc: ECC controller structure
  @clk_rate: clk_rate required for this NAND chip
  @timing_cfg: TIMING_CFG register value for this NAND chip
  @timing_ctl: TIMING_CTL register value for this NAND chip
  @nsels: number of CS lines required by the NAND chip
  @sels: array of CS lines descriptions
  NAND Controller capabilities structure: stores NAND controller capabilities
  for distinction between compatible strings.
  @has_mdma:		Use mbus dma mode, otherwise general dma
 			through MBUS on A23A33 needs extra configuration.
  @reg_io_data:	IO data register
  @dma_maxburst:	DMA maxburst
  struct sunxi_nfc - stores sunxi NAND controller information
  @controller: base controller structure
  @dev: parent device (used to print error messages)
  @regs: NAND controller registers
  @ahb_clk: NAND controller AHB clock
  @mod_clk: NAND controller mod clock
  @reset: NAND controller reset line
  @assigned_cs: bitmask describing already assigned CS lines
  @clk_rate: NAND controller current clock rate
  @chips: a list containing all the NAND chips attached to this NAND
 	   controller
  @complete: a completion object used to wait for NAND controller events
  @dmac: the DMA channel attached to the NAND controller
  @caps: NAND Controller capabilities
 Arbitrary limit for polling mode 
 Arbitrary limit for polling mode 
 These seed values have been extracted from Allwinner's BSP 
  sunxi_nfc_randomizer_ecc512_seeds and sunxi_nfc_randomizer_ecc1024_seeds
  have been generated using
  sunxi_nfc_randomizer_step(seed, (step_size  8) + 15), which is what
  the randomizer engine does internally before descrambling OOB data.
  Those tables are statically defined to avoid calculating randomizer state
  at runtime.
	
	  This loop is just a simple implementation of a Fibonacci LFSR using
	  the x16 + x15 + 1 polynomial.
 De-randomize the Bad Block Marker. 
 Randomize the Bad Block Marker. 
		
		  Re-read the data with the randomizer disabled to identify
		  bitflips in erased pages.
 ECC errors are handled in the second loop. 
 TODO: use DMA to retrieve OOB 
			
			  Re-read the data with the randomizer disabled to
			  identify bitflips in erased pages.
			  TODO: use DMA to read page in raw mode
 TODO: use DMA to retrieve OOB 
 Fallback to PIO mode 
 Fallback to PIO mode 
 TODO: use DMA to transfer extra OOB bytes ? 
 Send command to program the OOB data 
 Doesn't fit 
 T1 <=> tCLS 
 T2 <=> tCLH 
 T3 <=> tCS 
 T4 <=> tCH 
 T5 <=> tWP 
 T6 <=> tWH 
 T7 <=> tALS 
 T8 <=> tDS 
 T9 <=> tDH 
 T10 <=> tRR 
 T11 <=> tALH 
 T12 <=> tRP 
 T13 <=> tREH 
 T14 <=> tRC 
 T15 <=> tWC 
 T16 - T19 + tCAD 
	
	  In non-EDO, tREA should be less than tRP to guarantee that the
	  controller does not sample the IO lines too early. Unfortunately,
	  the sunxi NAND controller does not allow us to have different
	  values for tRP and tREH (tRP = tREH = tRW  2).
	 
	  We have 2 options to overcome this limitation:
	 
	  1 Extend tRC to fulfil the tREA <= tRC  2 constraint
	  2 Use EDO mode (only works if timings->tRLOH > 0)
	
	  TODO: according to ONFI specs this value only applies for DDR NAND,
	  but Allwinner seems to set this to 0x7. Mimic them for now.
 TODO: A83 has some more bits for CDQSS, CS, CLHZ, CCS, WC 
 Convert min_clk_period from picoseconds to nanoseconds 
	
	  Unlike what is stated in Allwinner datasheet, the clk_rate should
	  be set to (1  min_clk_period), and not (2  min_clk_period).
	  This new formula was verified with a scope and validated by
	  Allwinner engineers.
	
	  ONFI specification 3.1, paragraph 4.15.2 dictates that EDO data
	  output cycle timings shall be used if the host drives tRC less than
	  30 ns. We should also use EDO mode if tREA is bigger than tRP.
	
	  The first 2 bytes are used for BB markers, hence we
	  only have 2 bytes available in the first user data
	  section.
 Reserve 2 bytes for the BBM 
 4 non-ECC bytes are added before each ECC bytes section 
 and bytes has to be even. 
 Prefer 1k ECC chunk over 512 ones 
 Add ECC info retrieval from DT 
			
			  Update ecc->strength value with the actual strength
			  that will be used by the ECC engine.
 HW ECC always request ECC bytes for 1024 bytes blocks 
 HW ECC always work with even numbers of ECC bytes 
 TODO: support DMA for raw accesses and subpage write 
 Default tR value specified in the ONFI spec (chapter 4.15.1) 
	
	  Set the ECC mode to the default value in case nothing is specified
	  in the DT.
 Ignore errors to fall back to PIO mode 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  Copyright  2009 - Maxim Levitsky
  driver for Ricoh xD readers
 read register 
 write register 
 read dword sized register 
 write dword sized register 
 returns pointer to our private structure 
 check if controller supports dma 
  Enable dma. Enables ether first or second stage of the DMA,
  Expects dev->dma_dir and dev->dma_state be set
 Set up dma settings 
 Precaution to make sure HW doesn't write 
 to random kernel memory 
 Precaution: make sure write reached the device 
 Set dma irq 
  Disable dma, called from the interrupt handler, which specifies
  success of the operation via 'error' argument
 Precaution to make sure HW doesn't write to random kernel memory 
  Wait, till dma is done, which includes both phases of it
  ReadWrite one page using dma. Only pages can be read (512 bytes)
 Set dma direction 
	 Set initial dma state: for reading first fill on board buffer,
 if incoming buffer is not page aligned, we should do bounce 
 Enable DMA 
 Wait till complete 
  Program data lines of the nand chip to send data to it
 Don't allow any access to hardware if we suspect card removal 
 Special case for whole sector read 
 write DWORD chinks - faster 
 write rest 
  Read data lines of the nand chip to retrieve data
		 since we can't signal error here, at least, return
 special case for whole sector read 
 read in dword sized chunks 
 read the reset by bytes 
  Read one byte from nand chip
 Same problem as in r852_read_buf.... 
  Control several chip lines & send commands
 when write is stareted, enable write access 
	  HACK: NAND_CMD_SEQIN is called without NAND_CTRL_CHANGE, but we need
  Wait till card is ready.
  based on nand_wait, but returns errors on DMA error
 Unfortunelly, no way to send detailed error status... 
  Check if card is ready
  Set ECC engine mode
 enable ecc generationcheck
 flush ecc buffer 
 disable ecc generation 
  Calculate ECC, only used for writes
  Correct the data using ECC, hw did almost everything for us
 ecc uncorrectable error 
 correctable error 
  This is copy of nand_read_oob_std
  nand_read_oob_syndrome assumes we can send column address - we can't
  Start the nand engine
  Stop the nand engine
  Test if card is present
  Update card detection IRQ state according to current card state
  which is read in r852_card_update_present
 Detect properties of card in slot 
  Register the nand device
  Called when the card is detected
 Force card redetect 
  Unregister the card
 Card state updater 
 False alarm 
 Read media properties 
 Register the card 
 Ack + disable IRQ generation 
 Interrupt handler 
 handle card detection interrupts first 
		 we shouldn't receive any interrupts if we wait for card
 disable irqs while card is unstable 
 this will timeout DMA if active, but better that garbage 
 let, card state to settle a bit, and then do the work 
 Handle dma interrupts 
 received DMA interrupt out of nowhere? 
 done device access 
 done memory DMA 
 Enable 2nd half of dma dance 
 Operation done 
 Handle unknown interrupts 
 TODO: hack 
 pci initialization 
 init nand chip, but register it only on card insert 
 commands 
 IO 
 init our device structure 
 shutdown everything - precation 
register irq handler
 kick initial present test 
	 Stop detect workqueue -
 Unregister the device, this might make more IO 
 Stop interrupts 
 Cleanup 
 Shutdown the PCI device 
 First make sure the detect work is gone 
 Turn off the interrupts and stop the device 
	 If card was pulled off just during the suspend, which is very
		unlikely, we will remove it on resume, it too late now
 If card status changed, just do the work 
 Otherwise, initialize the card 
 Program card detection IRQ 
  Toshiba TMIO NAND flash controller driver
  Slightly murky pre-git history of the driver:
  Copyright (c) Ian Molton 2004, 2005, 2008
     Original work, independent of sharps code. Included hardware ECC support.
     Hard ECC did not work for writes in the early revisions.
  Copyright (c) Dirk Opfer 2005.
     Modifications developed from sharps code but
     NOT containing any, ported onto Ians base.
  Copyright (c) Chris Humbert 2005
  Copyright (c) Dmitry Baryshkov 2008
     Minor fixes
  Parts copyright Sebastian Carlier
  This file is licensed under
  the terms of the GNU General Public License version 2. This program
  is licensed "as is" without any warranty of any kind, whether express
  or implied.
--------------------------------------------------------------------------
  NAND Flash Host Controller Configuration Register
 w Command				
 l NAND Flash Control Reg Base Addr	
 b Interrupt Pin			
 b Interrupt Enable			
 b Event Control			
 b Internal Clock Control		
 b ECC Control			
 b NAND Flash Transaction Control	
 b NAND Flash Monitor			
 b NAND Flash Power Supply Control	
 b NAND Flash Detect Control		
  NAND Flash Control Register
 bwl Data Register			
 b Mode Register			
 b Status Register			
 b Interrupt Status Register		
 b Interrupt Mask Register		
 FCR_MODE Register Command List 
 Data Data_Mode 
 Data Command_Mode 
 Data Address_Mode 
 HW-ECC Data 
 HW-ECC Calc result Read_Mode 
 HW-ECC Reset 
 Power Supply ON  to SSFDC card 
 Power Supply OFF to SSFDC card 
 LED OFF 
 LED ON 
 Ejection events active  
 Ejection events ignored 
 Lock_Mode. Eject Switch Invalid 
 UnLock_Mode. Eject Switch is valid 
 Controller ID Read 
 SSFDC card Changes Standby State 
--------------------------------------------------------------------------
 for tmio_nand_read_byte 
--------------------------------------------------------------------------
 disable RDYREQ interrupt 
  The TMIO core has a RDYREQ interrupt on the posedge of #SMRB.
  This interrupt is normally disabled, but for long operations like
  erase and write, we enable it to wake us up.  The irq handler
  disables the interrupt.
 enable RDYREQ interrupt 
  The TMIO controller combines two 8-bit data bytes into one 16-bit
  word. This function separates them so nand_base.c works as expected,
  especially its NAND_CMD_READID routines.
  To prevent stale data from being read, tmio_nand_hwcontrol() clears
  tmio->read_good.
  The TMIO controller converts an 8-bit NAND interface to a 16-bit
  bus interface, so all data reads and writes must be 16-bit wide.
  Thus, we implement 16-bit versions of the read, write, and verify
  buffer functions.
 dummy read 
 000-255 LP7-0 
 000-255 LP15-8 
 000-255 CP5-0,11b 
 256-511 LP7-0 
 256-511 LP15-8 
 256-511 CP5-0,11b 
 assume ecc.size = 512 and ecc.bytes = 6 
 (4Ch) CLKRUN Enable    1st spcrunc 
 (10h)BaseAddress    0x1000 spba.spba2 
 (04h)Command Register IO spcmd 
 (62h) Power Supply Control ssmpwc 
 HardPowerOFF - SuspendOFF - PowerSupplyWait_4MS 
 (63h) Detect Control ssmdtc 
 Interrupt status register clear sintst 
 After power supply, Media are reset smode 
 Standby Mode smode 
 Set address of NAND IO lines 
 Set address of hardware control function 
 15 us command delay time 
 Scan to find existence of the device 
 Register the partitions 
	 FIXME - is this required or merely another attack of the broken
	  SHARP platform? Looks suspicious.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2006-2007 PA Semi, Inc
  Author: Egor Martovetsky <egor@pasemi.com>
  Maintained by: Olof Johansson <olof@lixom.net>
  Driver for the PWRficient onchip NAND flash interface
 Push out posted writes 
 We only support one device at the moment 
 Allocate memory for MTD device structure and private data 
 Link the private data with the MTD structure 
 Enable the following for a flash based bad block table 
	
	  This driver assumes that the default ECC engine should be TYPE_SOFT.
	  Set ->engine_type before registering the NAND devices in order to
	  provide a driver specific default value.
 Scan to find existence of the device 
 Release resources, unregister device 
 Free the MTD device structure 
 SPDX-License-Identifier: GPL-2.0
   Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
 		  2002-2006 Thomas Gleixner (tglx@linutronix.de)
   Credits:
 	David Woodhouse for adding multichip support
 	Aleph One Ltd. and Toby Churchill Ltd. for supporting the
 	rework for 2K page size chips
  This file contains all ONFI helpers.
  Check if the NAND chip is JEDEC compliant, returns 1 if it is, 0 otherwise.
 Try JEDEC for unknown chip or LP 
 JEDEC chip: allocate a buffer to hold its parameter page 
 Check version 
 vendor specific version 
 Please reference to the comment for nand_flash_detect_onfi. 
 Please reference to the comment for nand_flash_detect_onfi. 
 ECC info 
 SPDX-License-Identifier: GPL-2.0-or-later
  Hisilicon NAND Flash controller driver
  Copyright  2012-2014 HiSilicon Technologies Co., Ltd.
               http:www.hisilicon.com
  Author: Zhou Wang <wangzhou.bry@gmail.com>
  The initial developer of the original code is Zhiyong Cai
  <caizhiyong@huawei.com>
 interrupt status 
 nfc is ready 
 wait cmd timeout 
 sanity check 
 Serially input address 
 Adjust columns for 16 bit buswidth 
 store interrupts state 
 errors which can not be corrected by ECC 
 TODO: need add other ECC modes! 
 default page size: 2K, ecc_none. need modify 
 enable DMA irq 
 FIXME: add ECC bytes position 
 TODO: add more page size support 
 TODO: add more ecc strength support 
 add ecc type configure 
 enable ecc irq 
	
	  TODO: add more pagesize support,
	  default pagesize has been set in hisi_nfc_host_init
 SPDX-License-Identifier: GPL-2.0
   Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
 		  2002-2006 Thomas Gleixner (tglx@linutronix.de)
   Credits:
 	David Woodhouse for adding multichip support
 	Aleph One Ltd. and Toby Churchill Ltd. for supporting the
 	rework for 2K page size chips
  This file contains all legacy helperscode that should be removed
  at some point.
  nand_read_byte - [DEFAULT] read one byte from the chip
  @chip: NAND chip object
  Default read function for 8bit buswidth
  nand_read_byte16 - [DEFAULT] read one byte endianness aware from the chip
  @chip: NAND chip object
  Default read function for 16bit buswidth with endianness conversion.
  nand_select_chip - [DEFAULT] control CE line
  @chip: NAND chip object
  @chipnr: chipnumber to select, -1 for deselect
  Default select function for 1 chip devices.
  nand_write_byte - [DEFAULT] write single byte to chip
  @chip: NAND chip object
  @byte: value to write
  Default function to write a byte to IO[7:0]
  nand_write_byte16 - [DEFAULT] write single byte to a chip with width 16
  @chip: NAND chip object
  @byte: value to write
  Default function to write a byte to IO[7:0] on a 16-bit wide chip.
	
	  It's not entirely clear what should happen to IO[15:8] when writing
	  a byte. The ONFi spec (Revision 3.1; 2012-09-19, Section 2.16) reads:
	 
	     When the host supports a 16-bit bus width, only data is
	     transferred at the 16-bit width. All address and command line
	     transfers shall use only the lower 8-bits of the data bus. During
	     command transfers, the host may place any value on the upper
	     8-bits of the data bus. During address transfers, the host shall
	     set the upper 8-bits of the data bus to 00h.
	 
	  One user of the write_byte callback is nand_set_features. The
	  four parameters are specified to be written to IO[7:0], but this is
	  neither an address nor a command transfer. Let's assume a 0 on the
	  upper IO lines is OK.
  nand_write_buf - [DEFAULT] write buffer to chip
  @chip: NAND chip object
  @buf: data buffer
  @len: number of bytes to write
  Default write function for 8bit buswidth.
  nand_read_buf - [DEFAULT] read chip data into buffer
  @chip: NAND chip object
  @buf: buffer to store date
  @len: number of bytes to read
  Default read function for 8bit buswidth.
  nand_write_buf16 - [DEFAULT] write buffer to chip
  @chip: NAND chip object
  @buf: data buffer
  @len: number of bytes to write
  Default write function for 16bit buswidth.
  nand_read_buf16 - [DEFAULT] read chip data into buffer
  @chip: NAND chip object
  @buf: buffer to store date
  @len: number of bytes to read
  Default read function for 16bit buswidth.
  panic_nand_wait_ready - [GENERIC] Wait for the ready pin after commands.
  @chip: NAND chip object
  @timeo: Timeout
  Helper function for nand_wait_ready used when needing to wait in interrupt
  context.
 Wait for the device to get ready 
  nand_wait_ready - [GENERIC] Wait for the ready pin after commands.
  @chip: NAND chip object
  Wait for the ready pin after a command, and warn if a timeout occurs.
 Wait until command is processed or timeout occurs 
  nand_wait_status_ready - [GENERIC] Wait for the ready status after commands.
  @chip: NAND chip object
  @timeo: Timeout in ms
  Wait for status ready (i.e. command done) or timeout.
  nand_command - [DEFAULT] Send command to NAND device
  @chip: NAND chip object
  @command: the command to be sent
  @column: the column address for this command, -1 if none
  @page_addr: the page address for this command, -1 if none
  Send command to NAND device. This function is used for small page devices
  (512 Bytes per page).
 Write out the command to the device 
 OOB area 
 First 256 bytes --> READ0 
 Address cycle, when necessary 
 Serially input address 
 Adjust columns for 16 bit buswidth 
	
	  Program and erase have their own busy handlers status and sequential
	  in needs no delay
 EZ-NAND can take upto 250ms as per ONFi v4.0 
 This applies to read commands 
		
		  READ0 is sometimes used to exit GET STATUS mode. When this
		  is the case no address cycles are requested, and we can use
		  this information to detect that we should not wait for the
		  device to be ready.
		
		  If we don't have access to the busy pin, we apply the given
		  command delay
	
	  Apply this short delay always to ensure that we do wait tWB in
	  any case on any machine.
	
	  The controller already takes care of waiting for tCCS when the RNDIN
	  or RNDOUT command is sent, return directly.
	
	  Wait tCCS_min if it is correctly defined, otherwise wait 500ns
	  (which should be safe for all NANDs).
  nand_command_lp - [DEFAULT] Send command to NAND large page device
  @chip: NAND chip object
  @command: the command to be sent
  @column: the column address for this command, -1 if none
  @page_addr: the page address for this command, -1 if none
  Send command to NAND device. This is the version for the new large page
  devices. We don't have the separate regions as we have in the small page
  devices. We must emulate NAND_CMD_READOOB to keep the code compatible.
 Emulate NAND_CMD_READOOB 
 Command latch cycle 
 Serially input address 
 Adjust columns for 16 bit buswidth 
 Only output a single addr cycle for 8bits opcodes. 
	
	  Program and erase have their own busy handlers status, sequential
	  in and status need no delay.
 EZ-NAND can take upto 250ms as per ONFi v4.0 
 No ready  busy check necessary 
		
		  READ0 is sometimes used to exit GET STATUS mode. When this
		  is the case no address cycles are requested, and we can use
		  this information to detect that READSTART should not be
		  issued.
 This applies to read commands 
		
		  If we don't have access to the busy pin, we apply the given
		  command delay.
	
	  Apply this short delay always to ensure that we do wait tWB in
	  any case on any machine.
  nand_get_set_features_notsupp - setget features stub returning -ENOTSUPP
  @chip: nand chip info structure
  @addr: feature address.
  @subfeature_param: the subfeature parameters, a four bytes array.
  Should be used by NAND controller drivers that do not support the SETGET
  FEATURES operations.
  nand_wait - [DEFAULT] wait until the command is done
  @chip: NAND chip structure
  Wait for command done. This applies to erase and program only.
	
	  Apply this short delay always to ensure that we do wait tWB in any
	  case on any machine.
 This can happen if in case of timeout or buggy dev_ready 
 check for proper chip_delay setup, set 20us if not 
 check, if a user supplied command function given 
 check, if a user supplied wait function given 
 If called twice, pointers that depend on busw may need to be reset 
 Do not replace user supplied command function! 
	
	  ->legacy.cmdfunc() is legacy and will only be used if ->exec_op() is
	  not populated.
	
	  Default functions assigned for ->legacy.cmdfunc() and
	  ->legacy.select_chip() both expect ->legacy.cmd_ctrl() to be
	   populated.
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  Copyright 2008 Sascha Hauer, kernel@pengutronix.de
 Addresses for NFC registers 
  Operation modes for the NFC. Valid for v1, v2 and v3
  type controllers.
	
	  On i.MX21 the CONFIG2:INT bit cannot be read if interrupts are masked
	  (CONFIG1:INT_MSK is set). To handle this the driver uses
	  enable_irqdisable_irq_nosync instead of CONFIG1:INT_MSK
 We assume that src (IO) is always 32bit aligned 
 __iowrite32_copy use 32bit size values so divide by 4 
 We assume that trg (IO) is always 32bit aligned 
  The controller splits a page into data chunks of 512 bytes + partial oob.
  There are writesize  512 such chunks, the size of the partial oob parts is
  oobsize  #chunks rounded down to a multiple of 2. The last oob chunk then
  contains additionally the byte lost by rounding (if any).
  This function handles the needed shuffling between host->data_buf (which
  holds a page in natural order, i.e. writesize bytes data + oobsize bytes
  spare) and the NFC buffer.
 size of oob chunk for all but possibly the last one 
 the last chunk 
 the last chunk 
  MXC NANDFC can only perform full page+spare or spare-only readwrite.  When
  the upper layers perform a readwrite buf operation, the saved column address
  is used to index into the full page. So usually this function is called with
  column == 0 (unless no column cycle is needed indicated by column == -1)
 Write out column address, if necessary 
 another col addr cycle for 2k page 
 Write out page address, if necessary 
 paddr_0 - p_addr_7 
 paddr_8 - paddr_15 
 paddr_8 - paddr_15 
 paddr_8 - paddr_15 
 paddr_8 - paddr_15 
 This function polls the NANDFC to wait for the basic operation to
  complete by checking the INT bit of config2 register.
	
	  If operation is already complete, don't bother to setup an irq or a
	  loop.
 fill command 
 send out command 
 Wait for operation to complete 
 This function issues the specified command to the NAND device and
 Reset completion is indicated by NFC_CONFIG2 
 being set to 0 
 Wait for operation to complete 
 fill address 
 send out address 
 This function sends an address (or partial address) to the
  NAND device. The address is used to select the sourcedestination for
 Wait for operation to complete 
 transfer data from NFC ram to nand 
 NANDFC buffer 0 is used for page readwrite 
 Wait for operation to complete 
 NANDFC buffer 0 is used for page readwrite 
 Wait for operation to complete 
 Read ID into main buffer 
 Request the NANDFC to perform a read of the NAND device ID. 
 NANDFC buffer 0 is used for device ID output 
 Wait for operation to complete 
 This function requests the NANDFC to perform a read of the
	
	  The device status is stored in main_area0. To
	  prevent corruption of the buffer save the value
	  and restore it afterwards.
 This functions is used by upper layer to checks if device is ready 
	
	  NFC handles RB internally. Therefore, this function
	  always returns status as ready.
 NANDFC buffer 0 is used for page readwrite 
 Wait for operation to complete 
 Check for status request 
 only take the lower byte of each word 
 Write data of length len to buffer buf. The data to be
  written on NAND Flash is first copied to RAMbuffer. After the Data Input
 Read the data buffer from the NAND Flash. To read the data from NAND
  Flash first the data output cycle is initiated by the NFC, which copies
  the data to RAMbuffer. This data of length len is then copied to buffer buf.
 This function is used by upper layer for select and
 Disable the NFC clock 
 Enable the NFC clock 
 Disable the NFC clock 
 Enable the NFC clock 
  v2 and v3 type controllers can do 4bit or 8bit ecc depending
  on how much oob the nand chip has. For 8bit ecc we need at least
  26 bytes of oob data per 512 byte block.
 preset operation 
 Unlock the internal RAM Buffer 
 Blocks to be unlocked 
 Unlock Block Command for given address range 
	
	  For tRC < 30ns we have to use EDO mode. In this case the controller
	  does one access per clock cycle. Otherwise the controller does one
	  access in two clock cycles, thus we have to double the rate to the
	  controller.
	
	  The timing values compared against are from the i.MX25 Automotive
	  datasheet, Table 50. NFC Timing Parameters
 preset operation 
 spare area size in 16-bit half-words 
 Unlock the internal RAM Buffer 
 Blocks to be unlocked 
 Unlock Block Command for given address range 
 Unlock the internal RAM Buffer 
 Blocks to be unlocked 
 Reset default 
 Used by the upper layer to write command to NAND Flash for
 Reset command state information 
 Command pre-processing step 
  The generic flash bbt descriptors overlap with our ecc
  hardware, so define some i.MX specific ones.
 v1 + irqpending_quirk: i.MX21 
 v1 + !irqpending_quirk: i.MX27, i.MX31 
 v21: i.MX25, i.MX35 
 v3.2a: i.MX51 
 v3.2b: i.MX53 
 sentinel  }
 Allocate the right size buffer now 
 Call preset again, with correct writesize chip time 
	
	  Experimentation shows that i.MX NFC can only handle up to 218 oob
	  bytes. Limit used_oobsize to 218 so as to not confuse copy_spare()
	  into copying invalid data tofrom the spare IO buffer, as this
	  might cause ECC data corruption when doing sub-page write to a
	  partially written page.
 Allocate memory for MTD device structure and private data 
 allocate a temporary buffer for the nand_scan_ident() 
 structures must be linked 
 50 us command delay time 
	
	  Use host->devtype_data->irq_control() here instead of irq_control()
	  because we must not disable_irq_nosync without having requested the
	  irq.
	
	  Now that we "own" the interrupt make sure the interrupt mask bit is
	  cleared on i.MX21. Otherwise we can't read the interrupt status bit
	  on this machine.
 Scan the NAND device 
 Register the partitions 
 SPDX-License-Identifier: GPL-2.0-only
   Overview:
    Bad block table support for the NAND driver
   Copyright  2004 Thomas Gleixner (tglx@linutronix.de)
  Description:
  When nand_scan_bbt is called, then it tries to find the bad block table
  depending on the options in the BBT descriptor(s). If no flash based BBT
  (NAND_BBT_USE_FLASH) is specified then the device is scanned for factory
  marked good  bad blocks. This information is used to create a memory BBT.
  Once a new bad block is discovered then the "factory" information is updated
  on the device.
  If a flash based BBT is specified then the function first tries to find the
  BBT on flash. If a BBT is found then the contents are read and the memory
  based BBT is created. If a mirrored BBT is selected then the mirror is
  searched too and the versions are compared. If the mirror has a greater
  version number, then the mirror BBT is used to build the memory based BBT.
  If the tables are not versioned, then we "or" the bad block information.
  If one of the BBTs is out of date or does not exist it is (re)created.
  If no BBT exists at all then the device is scanned for factory marked
  good  bad blocks and the bad block tables are created.
  For manufacturer created BBTs like the one found on M-SYS DOC devices
  the BBT is searched and read but never created
  The auto generated bad block table is located in the last good blocks
  of the device. The table is mirrored, so it can be updated eventually.
  The table is marked in the OOB area with an ident pattern and a version
  number which indicates which of both tables is more up to date. If the NAND
  controller needs the complete OOB area for the ECC information then the
  option NAND_BBT_NO_OOB should be used (along with NAND_BBT_USE_FLASH, of
  course): it moves the ident pattern and the version byte into the data area
  and the OOB area will remain untouched.
  The table uses 2 bits per block
  11b:		block is good
  00b:		block is factory marked bad
  01b, 10b:	block is marked bad due to wear
  The memory bad block table uses the following scheme:
  00b:		block is good
  01b:		block is marked bad due to wear
  10b:		block is reserved (to protect the bbt area)
  11b:		block is factory marked bad
  Multichip devices like DOC store the bad block info per floor.
  Following assumptions are made:
  - bbts start at a page boundary, if autolocated on a block boundary
  - the space necessary for a bbt in FLASH does not exceed a block boundary
  check_pattern - [GENERIC] check if a pattern is in the buffer
  @buf: the buffer to search
  @len: the length of buffer to search
  @paglen: the pagelength
  @td: search pattern descriptor
  Check for a pattern at the given place. Used to search bad block tables and
  good  bad block identifiers.
 Compare the pattern 
  check_short_pattern - [GENERIC] check if a pattern is in the buffer
  @buf: the buffer to search
  @td:	search pattern descriptor
  Check for a pattern at the given place. Used to search bad block tables and
  good  bad block identifiers. Same as check_pattern, but no optional empty
  check.
 Compare the pattern 
  add_marker_len - compute the length of the marker in data area
  @td: BBT descriptor used for computation
  The length will be 0 if the marker is located in OOB area.
  read_bbt - [GENERIC] Read the bad block table starting from page
  @this: NAND chip object
  @buf: temporary buffer
  @page: the starting page
  @num: the number of bbt descriptors to read
  @td: the bbt describtion table
  @offs: block number offset in the table
  Read the bad block table starting from page.
			
			  In case the BBT marker is not in the OOB area it
			  will be just in the first page.
 Analyse data 
				
				  Leave it for now, if it's matured we can
				  move this message to pr_debug.
 Factory marked bad or worn out? 
  read_abs_bbt - [GENERIC] Read the bad block table starting at a given page
  @this: NAND chip object
  @buf: temporary buffer
  @td: descriptor for the bad block table
  @chip: read the table for a specific chip, -1 read all chips; applies only if
         NAND_BBT_PERCHIP option is set
  Read the bad block table for all chips starting at a given page. We assume
  that the bbt bits are in consecutive order.
 BBT marker is in the first page, no OOB 
  scan_read_oob - [GENERIC] Scan data+OOB region to buffer
  @this: NAND chip object
  @buf: temporary buffer
  @offs: offset at which to scan
  @len: length of data region to read
  Scan read data from data+OOB. May traverse multiple pages, interleaving
  page,OOB,page,OOB,... in buf. Completes transfer and returns the "strongest"
  ECC condition (error or bitflip). May quit on the first (non-ECC) error.
 Scan write data with oob to flash 
  read_abs_bbts - [GENERIC] Read the bad block table(s) for all chips starting at a given page
  @this: NAND chip object
  @buf: temporary buffer
  @td: descriptor for the bad block table
  @md:	descriptor for the bad block table mirror
  Read the bad block table(s) for all chips starting at a given page. We
  assume that the bbt bits are in consecutive order.
 Read the primary version, if available 
 Read the mirror version, if available 
 Scan a given block partially 
		
		  Read the full oob until read_oob is fixed to handle single
		  byte reads for 16 bit buswidth.
 Ignore ECC errors when checking for BBM 
 Check if a potential BBT block is marked as bad 
	
	  No need to check for a bad BBT block if the BBM area overlaps with
	  the bad block table marker area in OOB since writing a BBM here
	  invalidates the bad block table marker anyway.
	
	  There is no point in checking for a bad block marker if writing
	  such marker is not supported
  create_bbt - [GENERIC] Create a bad block table by scanning the device
  @this: NAND chip object
  @buf: temporary buffer
  @bd: descriptor for the goodbad block search pattern
  @chip: create the table for a specific chip, -1 read all chips; applies only
         if NAND_BBT_PERCHIP option is set
  Create a bad block table by scanning the device for the given goodbad block
  identify pattern.
  search_bbt - [GENERIC] scan the device for a specific bad block table
  @this: NAND chip object
  @buf: temporary buffer
  @td: descriptor for the bad block table
  Read the bad block table by searching for a given ident pattern. Search is
  preformed either from the beginning up or from the end of the device
  downwards. The search starts always at the start of a block. If the option
  NAND_BBT_PERCHIP is given, each chip is searched for a bbt, which contains
  the bad block information of this chip. This is necessary to provide support
  for certain DOC devices.
  The bbt ident pattern resides in the oob area of the first page in a block.
 Search direction top -> down? 
 Do we have a bbt per chip? 
 Reset version information 
 Scan the maximum number of blocks 
 Check if block is marked bad 
 Read first page 
 Check, if we found a bbt for each requested chip 
  search_read_bbts - [GENERIC] scan the device for bad block table(s)
  @this: NAND chip object
  @buf: temporary buffer
  @td: descriptor for the bad block table
  @md: descriptor for the bad block table mirror
  Search and read the bad block table(s).
 Search the primary table 
 Search the mirror table 
  get_bbt_block - Get the first valid eraseblock suitable to store a BBT
  @this: the NAND device
  @td: the BBT description
  @md: the mirror BBT descriptor
  @chip: the CHIP selector
  This functions returns a positive block number pointing a valid eraseblock
  suitable to store a BBT (i.e. in the range reserved for BBT), or -ENOSPC if
  all blocks are already used of marked bad. If td->pages[chip] was already
  pointing to a valid block we re-use it, otherwise we search for the next
  valid one.
	
	  There was already a version of the table, reuse the page. This
	  applies for absolute placement too, as we have the page number in
	  td->pages.
	
	  Automatic placement of the bad block table. Search direction
	  top -> down?
 Check, if the block is bad 
 Check, if the block is used by the mirror table 
  mark_bbt_block_bad - Mark one of the block reserved for BBT bad
  @this: the NAND device
  @td: the BBT description
  @chip: the CHIP selector
  @block: the BBT block to mark
  Blocks reserved for BBT can become bad. This functions is an helper to mark
  such blocks as bad. It takes care of updating the in-memory BBT, marking the
  block as bad using a bad block marker and invalidating the associated
  td->pages[] entry.
  write_bbt - [GENERIC] (Re)write the bad block table
  @this: NAND chip object
  @buf: temporary buffer
  @td: descriptor for the bad block table
  @md: descriptor for the bad block table mirror
  @chipsel: selector for a specific chip, -1 for all
  (Re)write the bad block table.
 Write bad block table per chip rather than per device? 
 Full device write or specific chip? 
 Loop through the chips 
		
		  get_bbt_block() returns a block number, shift the value to
		  get a page number.
 Set up shift count and masks for the flash table 
 Must we save the block contents? 
 Make it block aligned 
 Read oob data 
 Calc the byte offset in the buffer 
 Preset the bbt area with 0xff 
 The version byte 
 Calc length 
 Make it page aligned! 
 Preset the buffer with 0xff 
 Pattern is located at the begin of first page 
 Calc length 
 Make it page aligned! 
 Preset the buffer with 0xff 
 Pattern is located in oob area of first page 
 Walk through the memory table 
 Do not store the reserved bbt blocks! 
 Mark it as used 
  nand_memory_bbt - [GENERIC] create a memory based bad block table
  @this: NAND chip object
  @bd: descriptor for the goodbad block search pattern
  The function creates a memory based bbt by scanning the device for
  manufacturer  software marked good  bad blocks.
  check_create - [GENERIC] create and write bbt(s) if necessary
  @this: the NAND device
  @buf: temporary buffer
  @bd: descriptor for the goodbad block search pattern
  The function checks the results of the previous call to read_bbt and creates
   updates the bbt(s) if necessary. Creation is necessary if no bbt was found
  for the chipdevice. Update is necessary if one of the tables is missing or
  the version nr. of one table is less than the other.
 Do we have a bbt per chip? 
 Per chip or per device? 
 Mirrored table available? 
 Create the bad block table by scanning the device? 
 Create the table in memory by scanning the chip(s) 
 Read back first? 
 Mark table as invalid 
 If they weren't versioned, read both 
 Mark table as invalid 
 Scrub the flash table(s)? 
 Update version numbers before writing 
 Write the bad block table to the device? 
 Write the mirror bad block table to the device? 
  nand_update_bbt - update bad block table(s)
  @this: the NAND device
  @offs: the offset of the newly marked block
  The function updates the bad block table(s).
 Allocate a temporary buffer for one eraseblock incl. oob 
 Do we have a bbt per chip? 
 Write the bad block table to the device? 
 Write the mirror bad block table to the device? 
  mark_bbt_region - [GENERIC] mark the bad block table regions
  @this: the NAND device
  @td: bad block table descriptor
  The bad block table regions are marked as "bad" to prevent accidental
  erasures  writes. The regions are identified by the mark 0x02.
 Do we have a bbt per chip? 
		
		  If we want reserved blocks to be recorded to flash, and some
		  new ones have been marked, then we need to update the stored
		  bbts.  This should only happen once.
  verify_bbt_descr - verify the bad block description
  @this: the NAND device
  @bd: the table to verify
  This functions performs a few sanity checks on the bad block description
  table.
  nand_scan_bbt - [NAND Interface] scan, find, read and maybe create bad block table(s)
  @this: the NAND device
  @bd: descriptor for the goodbad block search pattern
  The function checks, if a bad block table(s) isare already available. If
  not it scans the device for manufacturer marked good  bad blocks and writes
  the bad block table(s) to the selected place.
  The bad block table memory is allocated here. It must be freed by calling
  the nand_free_bbt function.
	
	  Allocate memory (2bit per block) and clear the memory bad block
	  table.
	
	  If no primary table descriptor is given, scan the device to build a
	  memory based bad block table.
 Allocate a temporary buffer for one eraseblock incl. oob 
 Is the bbt at a given page? 
 Search the bad block table using a pattern in oob 
 Prevent the bbt regions from erasing  writing 
  Define some generic bad  good block scan pattern which are used
  while scanning a device for factory marked good  bad blocks.
 Generic flash bbt descriptors 
  nand_create_badblock_pattern - [INTERN] Creates a BBT descriptor structure
  @this: NAND chip to create descriptor for
  This function allocates and initializes a nand_bbt_descr for BBM detection
  based on the properties of @this. The new descriptor is stored in
  this->badblock_pattern. Thus, this->badblock_pattern should be NULL when
  passed to this function.
  nand_create_bbt - [NAND Interface] Select a default bad block table for the device
  @this: NAND chip object
  This function selects the default bad block table support for the device and
  calls the nand_scan_bbt function.
 Is a flash based bad block table requested? 
 Use the default pattern descriptors 
  nand_isreserved_bbt - [NAND Interface] Check if a block is reserved
  @this: NAND chip object
  @offs: offset in the device
  nand_isbad_bbt - [NAND Interface] Check if a block is bad
  @this: NAND chip object
  @offs: offset in the device
  @allowbbt: allow access to bad block table region
  nand_markbad_bbt - [NAND Interface] Mark a block bad in the BBT
  @this: NAND chip object
  @offs: offset of the bad block
 Mark bad block in memory 
 Update flash-based bad block table 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for NAND MLC Controller in LPC32xx
  Author: Roland Stigge <stigge@antcom.de>
  Copyright  2011 WORK Microwave GmbH
  Copyright  2011, 2012 Roland Stigge
  NAND Flash Controller Operation:
  - Read: Auto Decode
  - Write: Auto Encode
  - Tested Page Sizes: 2048, 4096
 MLC NAND controller register offsets
 MLC_CMD bit definitions
 MLC_ICR bit definitions
 unsupported by LPC32x0! 
 MLC_TIME_REG bit definitions
 MLC_IRQ_MR and MLC_IRQ_SR bit definitions
 MLC_LOCK_PR bit definitions
 MLC_ISR bit definitions
 MLC_CEH bit definitions
	
	  Physical addresses of ECC buffer, DMA data buffers, OOB data buffer
	
	  Virtual addresses of ECC buffer, DMA data buffers, OOB data buffer
 Physical address of DMA base address 
 number of 512bytes-subpages 
  ActivateDeactivate DMA Operation:
  Using the PL080 DMA Controller for transferring the 512 byte subpages
  instead of doing readl()  writel() in a loop slows it down significantly.
  Measurements via getnstimeofday() upon 512 byte subpage reads reveal:
  - readl() of 128 x 32 bits in a loop: ~20us
  - DMA read of 512 bytes (32 bit, 4...128 words bursts): ~60us
  - DMA read of 512 bytes (32 bit, no bursts): ~100us
  This applies to the transfer itself. In the DMA case: only the
  wait_for_completion() (DMA setup _not_ included).
  Note that the 512 bytes subpage transfer is done directly fromto a
  FIFObuffer inside the NAND controller. Most of the time (~400-800us for a
  2048 bytes page) is spent waiting for the NAND IRQ, anyway. (The NAND
  controller transferring data between its internal buffer tofrom the NAND
  chip.)
  Therefore, using the PL080 DMA is disabled by default, for now.
 Reset MLC controller 
 Get base clock for MLC block 
	 Unlock MLC_ICR
 Configure MLC Controller: Large Block, 5 Byte Address 
	 Unlock MLC_TIME_REG
 Compute clock setup values, see LPC and NAND manual 
 Enable IRQ for CONTROLLER_READY and NAND_READY 
 Normal nCE operation: nCE controlled by controller 
  Hardware specific access to control lines
  Read Device Ready (NAND device _and_ controller ready)
 Clear interrupt flag by reading status 
 Seems to be delayed sometimes by controller 
  Enable NAND write protect
  Disable NAND write protect
 Writing Command and Address 
 For all sub-pages 
 Start Auto Decode Command 
 Wait for Controller Ready 
 Check ECC Error status 
 Read 512 + 16 Bytes 
 Start Encode 
 Write 512 + 6 Bytes to Buffer 
 Auto Encode w Bit 8 = 0 (see LPC MLC Controller manual) 
 Wait for Controller Ready 
 Read whole page - necessary with MLC controller! 
 None, write_oob conflicts with the automatic LPC MLC ECC decoder! 
 Prepares MLC for transfers with HW ECC enabled: always enabled anyway 
 Always enabled! 
	
	  Set direction to a sensible value even if the dmaengine driver
	  should ignore it. With the default (DMA_MEM_TO_MEM), the amba-pl08x
	  driver criticizes it as "alien transfer direction".
 DMA controller does flow control: 
  Probe for NAND controller
 Allocate memory for the device structure (and zero it) 
 link the private data structures 
 Get NAND clock 
 us 
 Init NAND controller 
 Initialize function pointers 
 initially clear interrupt status 
	
	  Scan to find existence of the device and get the type of NAND device:
	  SMALL block or LARGE block.
  Remove NAND device
 Re-enable NAND clock 
 Fresh init of NAND controller 
 Disable write protect 
 Enable write protect for safety 
 Disable clock 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
  Oxford Semiconductor OXNAS NAND driver
  Copyright (C) 2016 Neil Armstrong <narmstrong@baylibre.com>
  Heavily based on plat_nand.c :
  Author: Vitaly Wool <vitalywool@gmail.com>
  Copyright (C) 2013 Ma Haijun <mahaijuns@gmail.com>
  Copyright (C) 2012 John Crispin <blogic@openwrt.org>
 Nand commands 
 Single CS command control 
  Probe for the NAND device.
 Allocate memory for the device structure (and zero it) 
 Only a single chip node is supported 
 Scan to find existence of the device 
 Exit if no chips found 
 SPDX-License-Identifier: GPL-2.0 OR MIT
  MTK ECC controller driver.
  Copyright (C) 2016  MediaTek Inc.
  Authors:	Xiaolei Li		<xiaolei.li@mediatek.com>
 		Jorge Ramirez-Ortiz	<jorge.ramirez-ortiz@linaro.org>
 ecc strength that each IP supports 
			
			  Clear decode IRQ status once again to ensure that
			  there will be no extra IRQ.
 configure ECC encoder (in bits) 
 configure ECC decoder (in bits) 
 uncorrectable errors 
		
		  For ECC_NFI_MODE, if ecc->caps->pg_irq_sel is 1, then it
		  means this chip can only generate one ecc irq during page
		  read  write. If is 0, generate one ecc irq each ecc step.
 find out the running operation 
 disable it 
		
		  Clear decode IRQ status in case there is a timeout to wait
		  decode IRQ.
 Program ECC bytes to OOB: per sector oob = FDM + ECC + SPARE 
 write the parity bytes generated by the ECC back to temp buffer 
 copy into possibly unaligned OOB region with actual length 
 SPDX-License-Identifier: GPL-2.0+
 Copyright (c) 2020 Intel Corporation. 
 5 bits 26:22 included for comparison in the ADDR_SELx 
 Wait DMA to finish the data transfer.
 clear first, will update later 
 Default to an ECC size of 512 
 BCH ECC algorithm Settings for number of bits per 512B1024B 
 Scan to find existence of the device 
 SPDX-License-Identifier: GPL-2.0
  ARM PL35X NAND flash controller driver
  Copyright (C) 2017 Xilinx, Inc
  Author:
    Miquel Raynal <miquel.raynal@bootlin.com>
  Original work (rewritten):
    Punnaiah Choudary Kalluri <punnaia@xilinx.com>
    Naga Sureshkumar Relli <nagasure@xilinx.com>
 SMC controller status register (RO) 
 SMC clear config register (WO) 
 SMC direct command register (WO) 
 SMC set cycles register (WO) 
 SMC set opmode register (WO) 
 SMC ECC status register (RO) 
 SMC ECC configuration register 
 SMC ECC command 1 register 
 SMC ECC command 2 register 
 SMC ECC value registers (RO) 
 NAND AXI interface 
  struct pl35x_nandc - NAND flash controller driver structure
  @dev: Kernel device
  @conf_regs: SMC configuration registers for command phase
  @io_regs: NAND data registers for data phase
  @controller: Core NAND controller structure
  @chip: NAND chip information structure
  @selected_chip: NAND chip currently selected by the controller
  @assigned_cs: List of assigned CS
  @ecc_buf: Temporary buffer to extract ECC bytes
 Generic flash bbt decriptors 
 Setup the timings 
 Configure the ECC engine 
 No working extra flags on unaligned data accesses 
 No working extra flags on unaligned data accesses 
 No error 
 One error in the main data; to be corrected 
 Bits [11:3] of error code give the byte offset 
 Bits [2:0] of error code give the bit offset 
 Toggle the faulty bit 
 One error in the ECC data; no action needed 
 Read ECC value for each chunk 
 Send the command and address cycles 
 Write the data with the engine enabled 
 Copy the HW calculated ECC bytes in the OOB buffer 
 Write the spare area with ECC bytes 
  This functions reads data and checks the data integrity by comparing hardware
  generated ECC values and read ECC values from spare area.
  There is a limitation with SMC controller: ECC_LAST must be set on the
  last data access to tell the ECC engine not to expect any further data.
  In practice, this implies to shrink the last data transfert by eg. 4 bytes,
  and doing a last 4-byte transfer with the additional bit set. The last block
  should be aligned with the end of an ECC block. Because of this limitation,
  it is not possible to use the core routines.
 Send the command and address cycles 
 Wait the data to be available in the NAND cache 
 Retrieve the raw data with the engine enabled 
 Retrieve the stored ECC bytes 
 Correct the data and report failures 
 Command phase 
 Data phase 
	
	  SDR timings are given in pico-seconds while NFC timings must be
	  expressed in NAND controller clock cycles. We use the TO_CYCLE()
	  macro to convert from one to the other.
	
	  PL35X SMC needs one extra read cycle in SDR Mode 5. This is not
	  written anywhere in the datasheet but is an empirical observation.
	
	  For all SDR modes, PL35X SMC needs tREA_max being 1,
	  this is also an empirical result.
 Legacy Xilinx layout 
 Keep these legacy BBT descriptors for ON_DIE situations 
 Disable interrupts and clear their status 
 Set default bus width to 8-bit 
 Ensure the ECC controller is bypassed by default 
	
	  Configure the commands that the ECC block uses to detect the
	  operations it should startend.
 SPDX-License-Identifier: GPL-2.0-only
  (C) 2003 Red Hat, Inc.
  (C) 2004 Dan Brown <dan_brown@ieee.org>
  (C) 2004 Kalev Lember <kalev@smartlink.ee>
  Author: David Woodhouse <dwmw2@infradead.org>
  Additional Diskonchip 2000 and Millennium support by Dan Brown <dan_brown@ieee.org>
  Diskonchip Millennium Plus support by Kalev Lember <kalev@smartlink.ee>
  Error correction code lifted from the old docecc code
  Author: Fabrice Bellard (fabrice.bellard@netgem.com)
  Copyright (C) 2000 Netgem S.A.
  converted to the generic Reed-Solomon library by Thomas Gleixner <tglx@linutronix.de>
  Interface to generic NAND code for M-Systems DiskOnChip devices
 Where to look for the devices? 
 The number of chips detected on each floor 
 Handle the last stage of initialization (BBT scan, partitioning) 
 This is the ecc value computed by the HW ecc generator upon writing an empty
 Sector size for HW ECC 
 The sector bytes are packed into NB_DATA 10 bit words 
 Number of roots 
 First consective root 
 Number of symbols 
  The HW decoder in the DoC ASIC's provides us a error syndrome,
  which we must convert to a standard syndrome usable by the generic
  Reed-Solomon library code.
  Fabrice Bellard figured this out in the old docecc code. I added
  some comments, improved a minor bit and converted it to make use
  of the generic Reed-Solomon library. tglx
 Convert the ecc bytes into words 
 Initialize the syndrome buffer 
	
	   Evaluate
	   s[i] = ds[3]x^3 + ds[2]x^2 + ds[1]x^1 + ds[0]
	   where x = alpha^(FCR + i)
 Calc syn[i] = s[i]  alpha^(v + i) 
 Call the decoder library 
 Incorrectable errors ? 
	
	  Correct the errors. The bitpositions are a bit of magic,
	  but they are given by the design of the deencoder circuit
	  in the DoC ASIC's.
 extract bit position (MSB first) 
			 now correct the following 10 bits. At most two bytes
 If the parity is wrong, no rescue possible 
 DOC_WaitReady: Wait for RDY line to be asserted by the flash chip 
 Out-of-line routine to wait for chip response 
 Call the out-of-line routine to wait 
 Call the out-of-line routine to wait 
  We need our own readid() here because it's called before the NAND chip
  has been initialized, and calling nand_op_readid() would lead to a NULL
  pointer exception when dereferencing the NAND timings.
 First chip probe. See if we get same results by 32-bit access 
 Max 4 chips per floor on DiskOnChip 2000 
 Find out what the first chip is 
 Find how many chips in each floor. 
 Terminate write pipeline 
 Start read pipeline 
 Terminate read pipeline 
 Start read pipeline 
 Terminate read pipeline 
 11.4.3 -- 4 NOPs after CSDNControl write 
 Assert CE pin 
 De-assert CE pin 
 deassert ALE 
 Assert ChipEnable and deassert WriteProtect 
 De-assert ChipEnable 
 Prime the ECC engine 
 Prime the ECC engine 
 This code is only called on write 
 flush the pipeline 
 If emptymatch=1, we might have an all-0xff data buffer.  Check. 
		 Note: this somewhat expensive test should not be triggered
		   often.  It could be optimized away by examining the data in
	 If emptymatch still =1, we do have an all-0xff data buffer.
	   Return all-0xff ecc value instead of the computed one, so
 flush the pipeline 
 Error occurred ? 
u_char mydatabuf[528];
	
	  The strange out-of-order free bytes definition is a (possibly
	  unneeded) attempt to retain compatibility.  It used to read:
	 	.oobfree = { {8, 8} }
	  Since that leaves two bytes unusable, it was changed.  But the
	  following scheme might affect existing jffs2 installs by moving the
	  cleanmarker:
	 	.oobfree = { {6, 10} }
	  jffs2 seems to handle the above gracefully, but the current scheme
	  seems safer. The only problem with it is that any code retrieving
	  free bytes position must be able to handle out-of-order segments.
 Find the (I)NFTL Media Header, and optionally also the mirror media header.
   On successful return, buf will contain a copy of the media header for
   further processing.  id is the string to scan for, and will presumably be
   either "ANAND" or "BNAND".  If findmirror=1, also look for the mirror media
   header.  The page #s of the found media headers are placed in mh0_page and
	 Only one mediaheader was found.  We want buf to contain a
 Insanity.  Give up. 
		 Auto-determine UnitSizeFactor.  The constraints are:
		   - There can be at most 32768 virtual blocks.
		   - There can be at most (virtual block size - page size)
		   virtual blocks (because MediaHeader+BBT must fit in 1).
	 NOTE: The lines below modify internal variables of the NAND and MTD
	   layers; variables with have already been configured by nand_scan.
	   Unfortunately, we didn't know before this point what these values
	   should be.  Thus, this code is somewhat dependent on the exact
 Skip past the media headers. 
 This is a stripped-down copy of the code in inftlmount.c 
 Scan the partitions 
	 On NFTL, we have to find the media headers before we can read the
	 At least for now, require the INFTL Media Header.  We could probably
	   do without it for non-INFTL use, since all it gives us is
		 It's not a Millennium; it's one of the newer
		   DiskOnChip 2000 units with a similar ASIC.
		   Treat it like a Millennium, except that it
 Bog-standard Millennium 
	 It's not possible to cleanly detect the DiskOnChip - the
	  bootup procedure will put the device into reset mode, and
	  it's not possible to talk to it without actually writing
	  to the DOCControl register. So we store the current contents
	  of the DOCControl register's location, in case we later decide
	  that it's not a DiskOnChip, and want to put it back how we
	  found it.
 Reset the DiskOnChip ASIC 
 Enable the DiskOnChip ASIC 
 Possible Millennium Plus, need to do more checks 
 Possibly release from power down mode 
 Reset the Millennium Plus ASIC 
 Enable the Millennium Plus ASIC 
 Check the TOGGLE bit in the ECC register 
		 Use the alias resolution register to determine if this is
		   in fact the same DOC aliased to a new address.  If writes
		   to one chip's alias resolution register change the value on
 restore it
 restore it
	
	  Allocate a RS codec instance
	 
	  Symbolsize is 10 (bits)
	  Primitve polynomial is x^10+x^3+1
	  First consecutive root is 510
	  Primitve element to generate roots = 1
	  Generator polinomial degree = 4
 Skip the automatic BBT scan so we can run it manually 
		 DBB note: i believe nand_cleanup is necessary here, as
		   buffers may have been allocated in nand_base.  Check with
 Success! 
	 Put back the contents of the DOCControl register, in case it's not
	 No banner message any more. Print a message if no DiskOnChip
 Cleanup the nandDoC resources 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018 Stefan Agner <stefan@agner.ch>
  Copyright (C) 2014-2015 Lucas Stach <dev@lynxeye.de>
  Copyright (C) 2012 Avionic Design GmbH
	
	  The bit name is somewhat missleading: This is also set when
	  HW ECC was successful. The data sheet states:
	  Correctable OR Un-correctable errors occurred in the DMA transfer...
 handle DMA interrupts 
 clear interrupts 
 Abort current commandDMA operation 
 clear interrupts 
 Lower 16-bits are column, by default 0 
 No correctable or un-correctable errors, page must have 0 bitflips 
	
	  Correctable or un-correctable errors occurred. Use DEC_STAT_BUF
	  which contains information for all ECC selections.
	 
	  Note that since we do not use Command Queues DEC_RESULT does not
	  state the number of pages we can read from the DEC_STAT_BUF. But
	  since CORRFAIL_ERR did occur during page read we do have a valid
	  result in DEC_STAT_BUF.
		
		  Since we do not support subpage writes, a complete page
		  is either written or not. We can take a shortcut here by
		  checking wheather any of the sector has been successful
		  read. If at least one sectors has been read successfully,
		  the page must have been a written previously. It cannot
		  be an erased page.
		 
		  E.g. controller might return fail_sec_flag with 0x4, which
		  would mean only the third sector failed to correct. The
		  page must have been written and the third sector is really
		  not correctable anymore.
		
		  All sectors failed to correct, but the ECC isn't smart
		  enough to figure out if a page is really just erased.
		  Read OOB data and check whether dataOOB is completely
		  erased or if error correction just failed for all sub-
		  pages.
		
		  The value returned in the register is the maximum of
		  bitflips encountered in any of the ECC regions. As there is
		  no way to get the number of bitflips in a specific regions
		  we are not able to deliver correct stats but instead
		  overestimate the number of corrected bitflips by assuming
		  that all regions where errors have been corrected
		  encountered the maximum number of bitflips.
	
	  The period (and all other timings in this function) is in ps,
	  so need to take care here to avoid integer overflows.
	
	  Loop through available strengths. Backwards in case we try to
	  maximize the BCH strength.
 Check whether strength fits OOB 
 Store complete configuration for HW ECC in config_ecc 
 Non-HW ECC readwrites complete OOB 
 Retrieve CS id, currently only single die NAND supported 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
  NXP LPC32XX NAND SLC driver
  Authors:
     Kevin Wells <kevin.wells@nxp.com>
     Roland Stigge <stigge@antcom.de>
  Copyright  2011 NXP Semiconductors
  Copyright  2012 Roland Stigge
 SLC NAND controller register offsets
 slc_ctrl register definitions
 Reset the NAND controller bit 
 Reset ECC bit 
 Start DMA channel bit 
 slc_cfg register definitions
 Force CE low bit 
 Enable DMA ECC bit 
 ECC enable bit 
 DMA burst bit 
 DMA write(0)read(1) bit 
 External device width, 0=8bit 
 slc_stat register definitions
 DMA FIFO has data bit 
 SLC FIFO has data bit 
 NAND device is ready bit 
 slc_int_stat, slc_ien, slc_isr, and slc_icr register definitions
 Transfer count bit 
 Ready interrupt bit 
 slc_tac register definitions
 Computation of clock cycles on basis of controller and device clock rates 
 Clock setting for RDY write sample wait time in 2n clocks 
 Write pulse width in clock cycles, 1 to 16 clocks 
 Write hold time of control and data signals, 1 to 16 clocks 
 Write setup time of control and data signals, 1 to 16 clocks 
 Clock setting for RDY read sample wait time in 2n clocks 
 Read pulse width in clock cycles, 1 to 16 clocks 
 Read hold time of control and data signals, 1 to 16 clocks 
 Read setup time of control and data signals, 1 to 16 clocks 
 slc_ecc register definitions
 ECC line party fetch macro 
  DMA requires storage space for the DMA local buffer and the hardware ECC
  storage area. The DMA local buffer is only used if DMA mapping fails
  during runtime.
 Number of bytes used for ECC stored in NAND per 256 bytes 
  If the NAND base clock frequency can't be fetched, this frequency will be
  used instead as the base. This rate is used to setup the timing registers
  used for NAND accesses.
 Milliseconds for DMA FIFO timeout (unlikely anyway) 
  NAND ECC Layout for small page NAND devices
  Note: For large and huge page devices, the default layouts are used
  Small page FLASH BBT descriptors, marker at offset 0, version at offset 6
  Note: Large page devices used the default layout
  NAND platform configuration structure
	
	  DMA and CPU addresses of ECC work area and data buffer
 Reset SLC controller 
 Basic setup 
 Get base clock for SLC block 
 Compute clock setup values 
  Hardware specific access to control lines
 Does CE state need to be changed? 
  Read the Device Ready pin
  Enable NAND write protect
  Disable NAND write protect
  Prepares SLC for transfers with HW ECC enabled
 Hardware ECC is enabled automatically in hardware as needed 
  Calculates the ECC for the data
	
	  ECC is calculated automatically in hardware during syndrome read
	  and write operations, so it doesn't need to be calculated here.
  Read a single byte from NAND device
  Simple device read without ECC
 Direct device read with no ECC 
  Simple device write without ECC
 Direct device write with no ECC 
  Read the OOB data from the device without ECC using FIFO method
  Write the OOB data to the device without ECC using FIFO method
  Fills in the ECC fields in the OOB buffer with the hardware generated ECC
 DMA controller does flow control: 
  DMA readwrite transfers with ECC support
 Clear initial ECC 
 Transfer size is data area only 
 Start transfer in the NAND controller 
 Data 
 Always _read_ ECC 
 ECC availability delayed on write 
	
	  According to NXP, the DMA can be finished here, but the NAND
	  controller may still have buffered data. After porting to using the
	  dmaengine DMA driver (amba-pl080), the condition (DMA_FIFO empty)
	  appears to be always true, according to tests. Keeping the check for
	  safety reasons for now.
 Read last calculated ECC value 
 Flush DMA 
 Something is left in the FIFO, something is wrong 
 Stop DMA & HW ECC 
  Read the data and OOB data from the device, use ECC correction with the
  data, disable ECC for the OOB data
 Issue read command 
 Read data and oob, calculate ECC 
 Get OOB data 
 Convert to stored ECC format 
 Pointer to ECC data retrieved from NAND spare area 
  Read the data and OOB data from the device, no ECC correction with the
  data or OOB data
 Issue read command 
 Raw reads can just use the FIFO interface 
  Write the data and OOB data to the device, use ECC with the data,
  disable ECC for the OOB data
 Write data, calculate ECC on outbound data 
	
	  The calculated ECC needs some manual work done to it before
	  committing it to NAND. Process the calculated ECC and place
 Write ECC data to device 
  Write the data and OOB data to the device, no ECC correction with the
  data or OOB data
 Raw writes can just use the FIFO interface 
 OOB and ECC CPU and DMA work areas 
	
	  Small page FLASH has a unique OOB layout, but large and huge
	  page FLASH use the standard layout. Small page FLASH uses a
	  custom BBT marker layout.
 These sizes remain the same regardless of page size 
	
	  Use a custom BBT marker setup for small page FLASH that
	  won't interfere with the ECC layout. Large and huge page
	  FLASH use the standard layout.
  Probe for NAND controller
 Allocate memory for the device structure (and zero it) 
 Get NAND clock 
 Set NAND IO addresses and commandready functions 
 20us command delay time 
 Init NAND controller 
 NAND callbacks for LPC32xx SLC hardware 
	
	  Allocate a large enough buffer for a single huge page plus
	  extra space for the spare area and ECC storage area
 Find NAND device 
  Remove NAND device.
 Force CE high 
 Re-enable NAND clock 
 Fresh init of NAND controller 
 Disable write protect 
 Force CE high 
 Enable write protect for safety 
 Disable clock 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
  Copyright  2015 Broadcom Corporation
 SPDX-License-Identifier: GPL-2.0-only
  Copyright  2010-2015 Broadcom Corporation
  This flag controls if WP stays on between erasewrite commands to mitigate
  flash corruption due to power glitches. Values:
  0: NAND_WP is not used or not available
  1: NAND_WP is set by default, cleared for erasewrite operations
  2: NAND_WP is always cleared
  Definitions
 Bitfields for brcm_nand_dma_desc::status_valid 
 Bitfields for DMA_MODE 
 stop in Uncorr ECC error 
 link list 
 512B flash cache in the NAND controller HW 
 edu registers 
 flash_dma registers 
 flash_dma registers v0
 flash_dma registers v1
 flash_dma registers v4 
 Controller feature flags 
 flash cache 
 Some SoCs provide custom interrupt status register(s) 
 Some SoCs have a gateable clock for the controller 
 List of NAND hosts (one for each chip-select) 
 EDU info, per-transaction 
 spare area size, per flash cache 
 flash_dma reg 
 in-memory cache of the FLASH_CACHE, used only for some commands 
 Controller revision details 
 between CS1, CS2, ... regs 
 within each chip-select 
 within CS0, if different 
 for low-power standbyresume only 
 use for low-power standbyresume only 
 CS1 regs, if non-contiguous 
 offset 0x10, if non-contiguous 
 offset 0x10, if non-contiguous 
 BRCMNAND v2.1-v2.2 
 BRCMNAND v3.3-v4.0 
 BRCMNAND v5.0 
 BRCMNAND v6.0 - v7.1 
 BRCMNAND v7.1 
 BRCMNAND v7.2 
 Per chip-select offsets for v7.1 
 Per chip-select offsets for pre v7.1, except CS0 on <= v5.0 
 Per chip-select offset for <= v5.0 on CS0 only 
  Bitfields for the CFG and CFG_EXT registers. Pre-v7.1 controllers only had
  one config register, but once the bitfields overflowed, newer controllers
  (v7.1 and newer) added a CFG_EXT register and shuffled a few fields around.
 Only for v2.1 
 Only for pre-v7.1 (with no CFG_EXT register) 
 Only for v7.1+ (with CFG_EXT register) 
 BRCMNAND_INTFC_STATUS 
 Only support v2.1+ 
 Register offsets 
 Chip-select stride 
 Per chip-select registers 
 v3.3-5.0 have a different CS0 offset layout 
 Page  block sizes 
 >= v7.1 use nice power-of-2 values! 
 Maximum spare area sector size (per 512B) 
 v6.0 and newer (except v6.1) have prefetch support 
	
	  v6.x has cache mode, but it's implemented differently. Ignore it for
	  now.
 flash_dma register offsets 
 Clear error addresses 
  NAND ACC CONTROL bitfield
  Some bits have remained constant throughout hardware revision, while
  others have shifted around.
 Constant for all versions (where supported) 
 See BRCMNAND_HAS_CACHE_MODE 
 See BRCMNAND_HAS_PREFETCH 
 v7.2 includes additional ECC levels 
 enable RDWR ECC 
 disable RDWR ECC 
  CS_NAND_SELECT
  Flash DMA
 Low-level operation types: command, address, write, or read 
  Internal support functions
  Set mtd->ooblayout to the appropriate mtd_ooblayout_ops given
  the layoutconfiguration.
  Returns -ERRCODE on failure.
 Large page NAND uses first 2 bytes for BBI 
 Small page NAND uses last byte before ECC for BBI 
	
	  CONTROLLER_VERSION:
	    < v5.0: ECC_REQ = ceil(BCH_T  138)
	   >= v5.0: ECC_REQ = ceil(BCH_T  148)
	  But we will just be conservative.
		
		  make sure ctrlflash ready before and after
		  changing state of #WP pin
 NAND_STATUS_WP 0x00 = protected, 0x80 = not protected 
 Helper functions for reading and writing OOB registers 
  read_oob_from_regs - read data from OOB registers
  @ctrl: NAND controller
  @i: sub-page sector index
  @oob: buffer to read to
  @sas: spare area sector size (i.e., OOB size per FLASH_CACHE)
  @sector_1k: 1 for 1KiB sectors, 0 for 512B, other values are illegal
 Adjust OOB values for 1K sector size 
  write_oob_to_regs - write data to OOB registers
  @i: sub-page sector index
  @oob: buffer to write from
  @sas: spare area sector size (i.e., OOB size per FLASH_CACHE)
  @sector_1k: 1 for 1KiB sectors, 0 for 512B, other values are illegal
 Adjust OOB values for 1K sector size 
 initialize edu 
 edu irq 
 flush previous writes 
 Discard all NAND_CTLRDY interrupts during DMA 
 check if you need to piggy back on the ctrlrdy irq 
 Discard interrupts while using dedicated edu irq 
 no registered edu irq, call handler 
 Handle SoC-specific interrupt hardware 
 flush previous writes 
  NAND MTD API: readprogramerase
 intentionally left blank 
 switch to interrupt polling and PIO mode 
 wait for completion interrupt 
 WE | ALE 
 WE 
 RE 
 RETURN_IDLE 
 Avoid propagating a negative, don't-care address 
		
		  HW quirk: PARAMETER_CHANGE_COL requires SECTOR_SIZE_1K=0
		  NB: hwcfg.sector_size_1k may not be initialized yet
 Copy flash cache word-wise 
		
		  Must cache the FLASH_CACHE now, since changes in
		  SECTOR_SIZE_1K may invalidate it
			
			  Flash cache is big endian for parameter pages, at
			  least on STB SoCs
 Cleanup from HW quirk: restore SECTOR_SIZE_1K 
 Re-enable protection is necessary only after erase 
 hide WP status 
 At FC_BYTES boundary, switch to next column 
   Kick EDU engine
 Start edu engine 
 flush previous writes 
 read last subpage oob 
 for program page check NAND status 
 Make sure the EDU status is clean 
 force stop 
		
		  check for ECC errors here, subpage ECC errors are
		  retained in ECC error address register
  Construct a FLASH_DMA descriptor as part of a linked list. You must know the
  following ahead of time:
   - Is this descriptor the beginning or end of a linked list?
   - What is the (DMA) address of the next descriptor in the linked list?
 Descriptors are written in native byte order (wordwise) 
 IRQ | STOP 
 head, tail 
  Kick the FLASH_DMA engine, with a given DMA descriptor
 Start FLASH_DMA engine 
 flush previous writes 
 wake | run 
 force stop 
  Assumes proper CS is already set
 SPARE_AREA_READ does not use ECC, so just use PAGE_READ 
  Check a page to see if it is erased (w bitflips) after an uncorrectable ECC
  error
  Because the HW ECC signals an ECC error if an erase paged has even a single
  bitflip, we must check each ECC error to see if it is actually an erased
  page with bitflips, not a truly corrupted page.
  On a real error, return a negative error code (-EBADMSG for ECC error), and
  buf will contain raw data.
  Otherwise, buf gets filled with 0xffs and return the maximum number of
  bitflips-per-ECC-sector to the caller.
 read without ecc for verification 
		
		  On controller version and 7.0, 7.1 , DMA read after a
		  prior PIO read that reported uncorrectable error,
		  the DMA engine captures this error following DMA read
		  cleared only on subsequent DMA read, so just retry once
		  to clear a possible false error reported for current DMA
		  read
		
		  Controller version 7.2 has hw encoder to detect erased page
		  bitflips, apply sw verification for older controllers only
 erased page bitflips corrected 
 NAND layer expects zero on ECC errors 
 in case of EDU correctable error we read again using PIO 
 Always exceed the software-imposed threshold 
 switch to interrupt polling and PIO mode 
 full address MUST be set before populating FC 
 we cannot use SPARE_AREA_PROGRAM when PARTIAL_PAGE_EN=0 
  Per-CS setup (1 NAND device)
 threshold = ceil(BCH-level  0.75) 
 Account for Hamming ECC and for BCH 512B vs 1KiB sectors 
  Minimum number of bytes to address a page. Calculated as:
      roundup(log2(size  page-size)  8)
  NB: the following does not "round up" for non-power-of-2 'size'; but this is
      OK because many other things will break if 'size' is irregular...
 Use detected size 
	
	  Set oobsize to be consistent with controller's spare_area_size, as
	  the rest is inaccessible.
 Default to Hamming for 1-bit ECC, if unspecified 
 Otherwise, BCH 
 use detected ECC parameters 
 Configure ACC_CONTROL 
 We need to turn on Read from erased paged protected by ECC 
	
	  Avoid (for instance) kmap()'d buffers from JFFS2, which we can't DMA
	  tofrom, and have nand_base pass us a bounce buffer instead, as
	  needed.
 only use our internal HW threshold 
 If OOB is written with ECC enabled it will cause ECC errors 
	
	  The bootloader might have configured 16bit mode but
	  NAND READID command only works in 8bit mode. We force
	  8bit mode here to ensure that NAND READID commands works.
 Clearre-enable interrupt 
 Reset the chip, required by some chips after power-up 
  Platform driver setup (per controller)
 initialize edu 
 We only support device-tree instantiation 
 NAND register range 
 Enable clock before using NAND registers 
 Initialize NAND revision 
	
	  Most chips have this cache at a fixed offset within 'nand' block.
	  Some must specify this region separately.
 FLASH_DMA 
 initialize the dma version 
 linked-list and stop on error 
 Allocate descriptor(s) 
 set flash dma transfer function to call 
 set edu transfer function to call 
 Disable automatic device ID config, direct addressing 
 Disable XOR addressing 
 Permanently disable write protection 
 IRQ 
	
	  Some SoCs integrate this controller (e.g., its interrupt bits) in
	  interesting ways
 Enable interrupt 
 Use standard interrupt infrastructure 
 Try all chip-selects 
 No chip-selects could initialize properly 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright  2015 Broadcom Corporation
	
	  In the case of BE or when dealing with NAND data, alway configure
	  the APB bus to LE mode before accessing the FIFO and back to BE mode
	  after the access is done
 when in LE accessing the parameter page, keep APB in BE 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2015 Simon Arlott
  Derived from bcm63138_nand.c:
  Copyright  2015 Broadcom Corporation
  Derived from bcm963xx_4.12L.06B_consumersharedopensourceincludebcm963xx63268_map_part.h:
  Copyright 2000-2010 Broadcom Corporation
  Derived from bcm963xx_4.12L.06B_consumersharedopensourceflashnandflash.c:
  Copyright 2000-2010 Broadcom Corporation
 Ack interrupt 
 Don't ack any interrupts 
 Disable and ack all interrupts  
 SPDX-License-Identifier: GPL-2.0-only
  Copyright  2015 Broadcom Corporation
 SPDX-License-Identifier: GPL-2.0
  JZ4780 BCH controller driver
  Copyright (c) 2015 Imagination Technologies
  Author: Alex Smith <alex.smith@imgtec.com>
 Timeout for BCH calculationcorrection. 
 Clear interrupt status. 
 Set up BCH count register. 
 Initialise and enable BCH. 
	
	  While we could use interrupts here and sleep until the operation
	  completes, the controller works fairly quickly (usually a few
	  microseconds) and so the overhead of sleeping until we get an
	  interrupt quite noticeably decreases performance.
 Correct any detected errors. 
 SPDX-License-Identifier: GPL-2.0
  JZ47xx ECC common code
  Copyright (c) 2015 Imagination Technologies
  Author: Alex Smith <alex.smith@imgtec.com>
  ingenic_ecc_calculate() - calculate ECC for a data buffer
  @ecc: ECC device.
  @params: ECC parameters.
  @buf: input buffer with raw data.
  @ecc_code: output buffer with ECC.
  Return: 0 on success, -ETIMEDOUT if timed out while waiting for ECC
  controller.
  ingenic_ecc_correct() - detect and correct bit errors
  @ecc: ECC device.
  @params: ECC parameters.
  @buf: raw data read from the chip.
  @ecc_code: ECC read from the chip.
  Given the raw data and the ECC read from the NAND device, detects and
  corrects errors in the data.
  Return: the number of bit errors corrected, -EBADMSG if there are too many
  errors to correct or -ETIMEDOUT if we timed out waiting for the controller.
  ingenic_ecc_get() - get the ECC controller device
  @np: ECC device tree node.
  Gets the ECC controller device from the specified device tree node. The
  device must be released with ingenic_ecc_release() when it is no longer being
  used.
  Return: a pointer to ingenic_ecc, errors are encoded into the pointer.
  PTR_ERR(-EPROBE_DEFER) if the device hasn't been initialised yet.
  of_ingenic_ecc_get() - get the ECC controller from a DT node
  @of_node: the node that contains an ecc-engine property.
  Get the ecc-engine property from the given device tree
  node and pass it to ingenic_ecc_get to do the work.
  Return: a pointer to ingenic_ecc, errors are encoded into the pointer.
  PTR_ERR(-EPROBE_DEFER) if the device hasn't been initialised yet.
	
	  If the ecc-engine property is not found, check for the deprecated
	  ingenic,bch-controller property
  ingenic_ecc_release() - release the ECC controller device
  @ecc: ECC device.
 SPDX-License-Identifier: GPL-2.0
  JZ4725B BCH controller driver
  Copyright (C) 2019 Paul Cercueil <paul@crapouillou.net>
  Based on jz4780_bch.c
 Timeout for BCH calculationcorrection. 
 Clear interrupt status. 
 Initialise and enable BCH. 
 calculate ECC from data 
 correct data from ECC 
 Set up BCH count register. 
 Clear interrupts 
 Disable the hardware 
	
	  While we could use interrupts here and sleep until the operation
	  completes, the controller works fairly quickly (usually a few
	  microseconds) and so the overhead of sleeping until we get an
	  interrupt quite noticeably decreases performance.
 Data and ECC is all 0xff or 0x00 - nothing to correct 
 Uncorrectable ECC error 
 Correct any detected errors. 
 SPDX-License-Identifier: GPL-2.0
  Ingenic JZ47xx NAND driver
  Copyright (c) 2015 Imagination Technologies
  Author: Alex Smith <alex.smith@imgtec.com>
	
	  Don't need to generate the ECC when reading, the ECC engine does it
	  for us as part of decodingcorrection.
 JZ4740 uses 9 bytes of ECC to correct maximum 4 errors 
 The NAND core will generate the ECC layout for SW ECC 
 Generate ECC layout. ECC codes are right aligned in the OOB area. 
	
	  The generic layout for BBT markers will most likely overlap with our
	  ECC bytes in the OOB, so move the BBT markers outside the OOB area.
 For legacy reasons we use a different layout on the qi,lb60 board. 
	
	  The rb-gpios semantics was undocumented and qi,lb60 (along with
	  the ingenic driver) got it wrong. The active state encodes the
	  NAND ready state, which is high level. Since there's no signal
	  inverter on this board, it should be active-high. Let's fix that
	  here for older DTs so we can re-use the generic nand_gpio_waitrdy()
	  helper, and be consistent with what other drivers do.
	
	  Check for ECC HW before we call nand_scan_ident, to prevent us from
	  having to call it again if the ECC driver returns -EPROBE_DEFER.
 SPDX-License-Identifier: GPL-2.0
  JZ4740 ECC controller driver
  Copyright (c) 2019 Paul Cercueil <paul@crapouillou.net>
  based on jz4740-nand.c
 Clear interrupt status 
 Initialize and enable ECC hardware 
 calculate ECC from data 
 correct data from ECC 
	
	  If the written data is completely 0xff, we also want to write 0xff as
	  ECC, otherwise we will get in trouble when doing subpage writes.
 SPDX-License-Identifier: GPL-2.0-only
  BCM47XX NAND flash driver
  Copyright (C) 2012 Rafa Miecki <zajec5@gmail.com>
 Broadcom uses 1'000'000 but it seems to be too many. Tests on WNDR4500 has
 Update column with value from BCMA_CC_NFLASH_COL_ADDR 
 Update row (page) with value from BCMA_CC_NFLASH_ROW_ADDR 
  Various helpers
  RW
	 Don't validate column using nand_chip->page_shift, it may be bigger
 We can read maximum of 0x200 bytes at once 
 Set page and column 
 Prepare to read 
 Eventually read some data :) 
 Last read goes without that 
	 Don't validate column using nand_chip->page_shift, it may be bigger
 Last read goes without that 
  NAND chip ops
 nCS is not needed for reset command 
 Default nand_select_chip calls cmd_ctrl, which is not used in BCM4706 
  Default nand_command and nand_command_lp don't match BCM4706 hardware layout.
  For example, reading chip id is performed in a non-standard way.
  Setting column and page is also handled differently, we use a special
  registers of ChipCommon core. Hacking cmd_ctrl to understand and convert
  standard commands would be much more complicated.
		
		  Reading is specific, last one has to go without NCTL_CSA
		  bit. We don't know how many reads NAND subsystem is going
		  to perform, so cache everything.
 Set page and column 
 Prepare to write 
  Init
 MiB 
 TODO: implement ECC 
 Enable NAND flash access 
 Configure wait counters 
 400 MHz 
 Fixed reference clock 25 MHz and m = 2 
 Scan NAND 
 Configure FLASH 
 find first bit set 
 Broadcom increases index by 20, we increase pos 
 SPDX-License-Identifier: GPL-2.0-only
  BCM47XX NAND flash driver
  Copyright (C) 2012 Rafa Miecki <zajec5@gmail.com>
 SPDX-License-Identifier: GPL-2.0+
  Freescale GPMI NAND Flash Driver
  Copyright (C) 2010-2015 Freescale Semiconductor, Inc.
  Copyright (C) 2008 Embedded Alley Solutions, Inc.
 Resource names for the GPMI NAND driver. 
 Converts time to clock cycles 
  Clear the bit and poll it cleared.  This is usually called with
  a reset address and mask being either SFTRST(bit 31) or CLKGATE
  (bit 30).
 clear the bit 
	
	  SFTRST needs 3 GPMI clocks to settle, the reference manual
	  recommends to wait 1us.
 poll the bit becoming clear 
 nothing ;
  The current mxs_reset_block() will do two things:
   [1] enable the module.
   [2] reset the module.
  In most of the cases, it's ok.
  But in MX23, there is a hardware bug in the BCH block (see erratum #2847).
  If you try to soft reset the BCH block, it becomes unusable until
  the next hard reset. This case occurs in the NAND boot mode. When the board
  boots by NAND, the ROM of the chip will initialize the BCH blocks itself.
  So If the driver tries to reset the BCH again, the BCH will not work anymore.
  You will see a DMA timeout in this case. The bug has been fixed
  in the following chips, such as MX28.
  To avoid this bug, just add a new parameter `just_enable` for
  the mxs_reset_block(), and rewrite it here.
 clear and poll SFTRST 
 clear CLKGATE 
 set SFTRST to reset the block 
 poll CLKGATE becoming set 
 nothing ;
 clear and poll SFTRST 
 clear and poll CLKGATE 
	
	  Reset BCH here, too. We got failures otherwise :(
	  See later BCH reset for explanation of MX23 and MX28 handling
 Choose NAND mode. 
 Set the IRQ polarity. 
 Disable Write-Protection. 
 Select BCH ECC. 
	
	  Decouple the chip select from dma channel. We use dma0 for all
	  the chips, force all NAND RDY_BUSY inputs to be sourced from
	  RDY_BUSY0.
 This function is very useful. It is called only when the bug occur. 
 start to print out the BCH info 
 Do the sanity check. 
 The mx23mx28 only support the GF13. 
  If we can get the ECC information from the nand chip, we do not
  need to calculate them ourselves.
  We may have available oob space in this case.
 Keep the C >= O 
 The default value, see comment in the legacy_set_geometry(). 
	
	  Now, the NAND chip with 2K page(data chunk is 512byte) shows below:
	 
	     |                          P                            |
	     |<----------------------------------------------------->|
	     |                                                       |
	     |                                        (Block Mark)   |
	     |                      P'                      |      | |     |
	     |<-------------------------------------------->|  D   | |  O' |
	     |                                              |<---->| |<--->|
	     V                                              V      V V     V
	     +---+----------+-+----------+-+----------+-+----------+-+-----+
	     | M |   data   |E|   data   |E|   data   |E|   data   |E|     |
	     +---+----------+-+----------+-+----------+-+----------+-+-----+
	                                                    ^              ^
	                                                    |      O       |
	                                                    |<------------>|
	                                                    |              |
	 
	 	P : the page size for BCH module.
	 	E : The ECC strength.
	 	G : the length of Galois Field.
	 	N : The chunk count of per page.
	 	M : the metasize of per page.
	 	C : the ecc chunk size, aka the "data" above.
	 	P': the nand chip's page size.
	 	O : the nand chip's oob size.
	 	O': the free oob.
	 
	 	The formula for P is :
	 
	 	            E  G  N
	 	       P = ------------ + P' + M
	                       8
	 
	  The position of block mark moves forward in the ECC-based view
	  of page, and the delta is:
	 
	                    E  G  (N - 1)
	              D = (---------------- + M)
	                           8
	 
	  Please see the comment in legacy_set_geometry().
	  With the condition C >= O , we still can get same result.
	  So the bit position of the physical block mark within the ECC-based
	  view of the page is :
	              (P' - D)  8
 For bit swap. 
   Calculate the ECC strength by hand:
 	E : The ECC strength.
 	G : the length of Galois Field.
 	N : The chunk count of per page.
 	O : the oobsize of the NAND chip.
 	M : the metasize of per page.
 	The formula is :
 		E  G  N
 	      ------------ <= (O - M)
                   8
       So, we get E by:
                     (O - M)  8
               E <= -------------
                        G  N
 We need the minor even number. 
	
	  The size of the metadata can be changed, though we set it to 10
	  bytes now. But it can't be too large, because we have to save
	  enough space for BCH.
 The default for the length of Galois Field. 
 The default for chunk size. 
 keep C >= O 
 We use the same ECC strength for all chunks. 
	
	  The auxiliary buffer contains the metadata and the ECC status. The
	  metadata is padded to the nearest 32-bit boundary. The ECC status
	  contains one byte for every ECC chunk, and is also padded to the
	  nearest 32-bit boundary.
	
	  We need to compute the byte and bit offsets of
	  the physical block mark within the ECC-based view of the page.
	 
	  NAND chip with 2K page shows below:
	                                              (Block Mark)
	                                                    |      |
	                                                    |  D   |
	                                                    |<---->|
	                                                    V      V
	     +---+----------+-+----------+-+----------+-+----------+-+
	     | M |   data   |E|   data   |E|   data   |E|   data   |E|
	     +---+----------+-+----------+-+----------+-+----------+-+
	 
	  The position of block mark moves forward in the ECC-based view
	  of page, and the delta is:
	 
	                    E  G  (N - 1)
	              D = (---------------- + M)
	                           8
	 
	  With the formula to compute the ECC strength, and the condition
	        : C >= O         (C is the ecc chunk size)
	 
	  It's easy to deduce to the following result:
	 
	          E  G       (O - M)      C - M         C - M
	       ----------- <= ------- <=  --------  <  ---------
	            8            N           N          (N - 1)
	 
	   So, we get:
	 
	                    E  G  (N - 1)
	              D = (---------------- + M) < C
	                           8
	 
	   The above inequality means the position of block mark
	   within the ECC-based view of the page is still in the data chunk,
	   and it's NOT in the ECC bits of the chunk.
	 
	   Use the following to compute the bit position of the
	   physical block mark within the ECC-based view of the page:
	           (page_size - D)  8
	 
	   --Huang Shijie
 Configures the geometry for BCH.  
	
	 Due to erratum #2847 of the MX23, the BCH cannot be soft reset on this
	 chip, otherwise it will lock up. So we skip resetting BCH on the MX23.
	 and MX28.
 Set all chip selects to use layout 0. 
  <1> Firstly, we should know what's the GPMI-clock means.
      The GPMI-clock is the internal clock in the gpmi nand controller.
      If you set 100MHz to gpmi nand controller, the GPMI-clock's period
      is 10ns. Mark the GPMI-clock's period as GPMI-clock-period.
  <2> Secondly, we should know what's the frequency on the nand chip pins.
      The frequency on the nand chip pins is derived from the GPMI-clock.
      We can get it from the following equation:
          F = G  (DS + DH)
          F  : the frequency on the nand chip pins.
          G  : the GPMI clock, such as 100MHz.
          DS : GPMI_HW_GPMI_TIMING0:DATA_SETUP
          DH : GPMI_HW_GPMI_TIMING0:DATA_HOLD
  <3> Thirdly, when the frequency on the nand chip pins is above 33MHz,
      the nand EDO(extended Data Out) timing could be applied.
      The GPMI implements a feedback read strobe to sample the read data.
      The feedback read strobe can be delayed to support the nand EDO timing
      where the read strobe may deasserts before the read data is valid, and
      read data is valid for some time after read strobe.
      The following figure illustrates some aspects of a NAND Flash read:
                    |<---tREA---->|
                    |             |
                    |         |   |
                    |<--tRP-->|   |
                    |         |   |
                   __          ___|__________________________________
      RDN            \________   |
                                  |
                                  ---------\
      Read Data    --------------<           >---------
                                  \---------
                                 |     |
                                 |<-D->|
      FeedbackRDN  ________             ____________
                           \___________
           D stands for delay, set in the HW_GPMI_CTRL1:RDN_DELAY.
  <4> Now, we begin to describe how to compute the right RDN_DELAY.
   4.1) From the aspect of the nand chip pins:
         Delay = (tREA + C - tRP)               {1}
         tREA : the maximum read access time.
         C    : a constant to adjust the delay. default is 4000ps.
         tRP  : the read pulse width, which is exactly:
                    tRP = (GPMI-clock-period)  DATA_SETUP
   4.2) From the aspect of the GPMI nand controller:
          Delay = RDN_DELAY  0.125  RP        {2}
          RP   : the DLL reference period.
             if (GPMI-clock-period > DLL_THRETHOLD)
                    RP = GPMI-clock-period  2;
             else
                    RP = GPMI-clock-period;
             Set the HW_GPMI_CTRL1:HALF_PERIOD if GPMI-clock-period
             is greater DLL_THRETHOLD. In other SOCs, the DLL_THRETHOLD
             is 16000ps, but in mx6q, we use 12000ps.
   4.3) since {1} equals {2}, we get:
                      (tREA + 4000 - tRP)  8
          RDN_DELAY = -----------------------     {3}
                            RP
 ONFI non-EDO modes [0-3] 
 ONFI EDO mode 4 
 ONFI EDO mode 5 
 SDR core timings are given in picoseconds 
	
	  Derive NFC ideal delay from {3}:
	 
	                      (tREA + 4000 - tRP)  8
	          RDN_DELAY = -----------------------
	                                 RP
	
	  Clear several CTRL1 fields, DLL must be disabled when setting
	  RDN_DELAY or HALF_PERIOD.
 Wait 64 clock cycles before using the GPMI after enabling the DLL 
 Wait for the DLL to settle. 
 Retrieve required NAND timings 
 Only MX6 GPMI controller can reach EDO timings 
 Stop here if this call was just a check 
 Do the actual derivation of the controller timings 
 Clears a BCH interrupt. 
 We use the DMA channel 0 to access all the nand chips. 
 This will be called after the DMA operation is finished. 
	
	  raw_len is the length to readwrite including bch data which
	  we are passed in exec_op. Calculate the data length from it.
 Can we use the upper's buffer directly for DMA? 
 first try to map the upper buffer directly 
 We have to use our own DMA buffer. 
 add our owner bbt descriptor 
  We may change the layout if we can get the ECC info from the datasheet,
  else we will use all the (page + OOB).
 The available oob size we have. 
 request dma channel 
		
		  Set the default value for the gpmi clock.
		 
		  If you want to use the ONFI nand which is in the
		  Synchronous Mode, you should change the clock as you need.
 Allocate the DMA buffers 
	
	  [2] Allocate a readwrite data buffer.
	      The gpmi_alloc_dma_buffer can be called twice.
	      We allocate a PAGE_SIZE length buffer if gpmi_alloc_dma_buffer
	      is called before the NAND identification; and we allocate a
	      buffer of the real NAND page size when the gpmi_alloc_dma_buffer
	      is called after.
  Handles block mark swapping.
  It can be called in swapping the block mark, or swapping it back,
  because the the operations are the same.
	
	  If control arrives here, we're swapping. Make some convenience
	  variables.
	
	  Get the byte from the data area that overlays the block mark. Since
	  the ECC engine applies its own view to the bits in the page, the
	  physical block mark won't (in general) appear on a byte boundary in
	  the data.
 Get the byte from the OOB. 
 Swap them. 
 Loop over status bytes, accumulating ECC status. 
 Read ECC bytes into our internal raw_buffer 
			
			  ECC data are not byte aligned and we may have
			  in-band data in the first and last byte of
			  eccbuf. Set non-eccbits to one so that
			  nand_check_erased_ecc_chunk() does not count them
			  as bitflips.
			
			  The ECC hardware has an uncorrectable ECC status
			  code in case we have bitflips in an erased page. As
			  nothing was written into this subpage the ECC is
			  obviously wrong and we can not trust it. We assume
			  at this point that we are reading an erased page and
			  try to correct the bitflips in buffer up to
			  ecc_strength bitflips. If this is a page with random
			  data, we exceed this number of bitflips and have a
			  ECC failure. Otherwise we use the corrected buffer.
 The first block includes metadata 
 handle the block mark swapping 
		
		  It's time to deliver the OOB bytes. See gpmi_ecc_read_oob()
		  for details about our policy for delivering the OOB.
		 
		  We fill the caller's buffer with set bits, and then copy the
		  block mark to th caller's buffer. Note that, if block mark
		  swapping was necessary, it has already been done, so we can
		  rely on the first byte of the auxiliary buffer to contain
		  the block mark.
 Fake a virtual small page for the subpage read 
 ECC chunk size 
 The size of ECC parity 
 Align it with the chunk size 
		
		  Find the chunk which contains the Block Marker.
		  If this chunk is in the range of [first, last],
		  we have to read out the whole page.
		  Why? since we had swapped the data at the position of Block
		  Marker to the metadata which is bound with the chunk 0.
		
		  When doing bad block marker swapping we must always copy the
		  input buffer as we can't modify the const buffer.
  There are several places in this driver where we have to handle the OOB and
  block marks. This is the function where things are the most complicated, so
  this is where we try to explain it all. All the other places refer back to
  here.
  These are the rules, in order of decreasing importance:
  1) Nothing the caller does can be allowed to imperil the block mark.
  2) In read operations, the first byte of the OOB we return must reflect the
     true state of the block mark, no matter where that block mark appears in
     the physical page.
  3) ECC-based read operations return an OOB full of set bits (since we never
     allow ECC-based writes to the OOB, it doesn't matter what ECC-based reads
     return).
  4) "Raw" read operations return a direct view of the physical bytes in the
     page, using the conventional definition of which bytes are data and which
     are OOB. This gives the caller a way to see the actual, physical bytes
     in the page, without the distortions applied by our ECC engine.
  What we do for this specific read operation depends on two questions:
  1) Are we doing a "raw" read, or an ECC-based read?
  2) Are we using block mark swapping or transcription?
  There are four cases, illustrated by the following Karnaugh map:
                     |           Raw           |         ECC-based       |
        -------------+-------------------------+-------------------------+
                     | Read the conventional   |                         |
                     | OOB at the end of the   |                         |
        Swapping     | page and return it. It  |                         |
                     | contains exactly what   |                         |
                     | we want.                | Read the block mark and |
        -------------+-------------------------+ return it in a buffer   |
                     | Read the conventional   | full of set bits.       |
                     | OOB at the end of the   |                         |
                     | page and also the block |                         |
        Transcribing | mark in the metadata.   |                         |
                     | Copy the block mark     |                         |
                     | into the first byte of  |                         |
                     | the OOB.                |                         |
        -------------+-------------------------+-------------------------+
  Note that we break rule #4 in the TranscribingRaw case because we're not
  giving an accurate view of the actual, physical bytes in the page (we're
  overwriting the block mark). That's OK because it's more important to follow
  rule #2.
  It turns out that knowing whether we want an "ECC-based" or "raw" read is not
  easy. When reading a page, for example, the NAND Flash MTD code calls our
  ecc.read_page or ecc.read_page_raw function. Thus, the fact that MTD wants an
  ECC-based or raw view of the page is implicit in which function it calls
  (there is a similar pair of ECC-basedraw functions for writing).
 clear the OOB buffer 
 Read out the conventional OOB. 
	
	  Now, we want to make sure the block mark is correct. In the
	  non-transcribing case (!GPMI_IS_MX23()), we already have it.
	  Otherwise, we need to explicitly read it.
 Read the block mark into the first byte of the OOB buffer. 
 Do we have available oob area? 
  This function reads a NAND page without involving the ECC engine (no HW
  ECC correction).
  The tricky part in the GPMIBCH controller is that it stores ECC bits
  inline (interleaved with payload DATA), and do not align data chunk on
  byte boundaries.
  We thus need to take care moving the payload data and ECC bits stored in the
  page into the provided buffers, which is why we're using nand_extract_bits().
  See set_geometry_by_ecc_info inline comments to have a full description
  of the layout used by the GPMI controller.
	
	  If required, swap the bad block marker and the data stored in the
	  metadata section, so that we don't wrongly consider a block as bad.
	 
	  See the layout description for a detailed explanation on why this
	  is needed.
	
	  Copy the metadata section into the oob buffer (this section is
	  guaranteed to be aligned on a byte boundary).
 Extract interleaved payload data and ECC bits 
 Align last ECC block to align a byte boundary 
  This function writes a NAND page without involving the ECC engine (no HW
  ECC generation).
  The tricky part in the GPMIBCH controller is that it stores ECC bits
  inline (interleaved with payload DATA), and do not align data chunk on
  byte boundaries.
  We thus need to take care moving the OOB area at the right place in the
  final page, which is why we're using nand_extract_bits().
  See set_geometry_by_ecc_info inline comments to have a full description
  of the layout used by the GPMI controller.
	
	  Initialize all bits to 1 in case we don't have a buffer for the
	  payload or oob data in order to leave unspecified bits of data
	  to their initial state.
	
	  First copy the metadata section (stored in oob buffer) at the
	  beginning of the page, as imposed by the GPMI layout.
 Interleave payload data and ECC bits 
 Align last ECC block to align a byte boundary 
	
	  If required, swap the bad block marker and the first byte of the
	  metadata section, so that we don't modify the bad block marker.
	 
	  See the layout description for a detailed explanation on why this
	  is needed.
 Write the block mark. 
 bad block marker 
 Shift to get page 
	
	  Set the boot block stride size.
	 
	  In principle, we should be reading this from the OTP bits, since
	  that's where the ROM is going to get it. In fact, we don't have any
	  way to read the OTP bits, so we go with the default and hope for the
	  best.
	
	  Set the search area stride exponent.
	 
	  In principle, we should be reading this from the OTP bits, since
	  that's where the ROM is going to get it. In fact, we don't have any
	  way to read the OTP bits, so we go with the default and hope for the
	  best.
 Compute the number of strides in a search area. 
	
	  Loop through the first search area, looking for the NCB fingerprint.
 Compute the page addresses. 
		
		  Read the NCB fingerprint. The fingerprint is four bytes long
		  and starts in the 12th byte of the page.
 Look for the fingerprint. 
 Writes a transcription stamp. 
 Compute the search area geometry. 
 Loop over blocks in the first search area, erasing them. 
 Erase this block. 
 Write the NCB fingerprint into the page buffer. 
 Loop through the first search area, writing NCB fingerprints. 
 Compute the page addresses. 
 Write the first page of the current stride. 
	
	  If control arrives here, we can't use block mark swapping, which
	  means we're forced to use transcription. First, scan for the
	  transcription stamp. If we find it, then we don't have to do
	  anything -- the block marks are already transcribed.
	
	  If control arrives here, we couldn't find a transcription stamp, so
	  so we presume the block marks are in the conventional location.
 Compute the number of blocks in the entire medium. 
	
	  Loop over all the blocks in the medium, transcribing block marks as
	  we go.
		
		  Compute the chip, page and byte addresses for this block's
		  conventional mark.
 Send the command to read the conventional block mark. 
		
		  Check if the block is marked bad. If so, we need to mark it
		  again, but this time the result will be a mark in the
		  location where we transcribe block marks.
 Write the stamp that indicates we've transcribed the block marks. 
 This is ROM arch-specific initilization before the BBT scanning. 
 Free the temporary DMA memory for reading ID. 
 Set up the NFC geometry which is used by BCH. 
 Alloc the new DMA buffers according to the pagesize and oobsize 
 Set up the medium geometry 
 Init the nand_ecc_ctrl{} 
	
	  We only enable the subpage read when:
	   (1) the chip is imx6, and
	   (2) the size of the ECC parity is byte aligned.
 [1] send out the PIO words 
	
	  This driver currently supports only one NAND chip. Plus, dies share
	  the same configuration. So once timings have been applied on the
	  controller side, they will not change anymore. When the time will
	  come, the check on must_apply_timings will have to be dropped.
			
			  When this command has an address cycle chain it
			  together with the address cycle
 init the MTD data structures 
 init the nand_chip{}, we don't support a 16-bit NAND Flash bus. 
 Set up swap_block_mark, must be set before the gpmi_set_geometry() 
	
	  Allocate a temporary DMA buffer for reading ID in the
	  nand_scan_ident().
 re-init the GPMI registers 
 Set flag to get timing setup restored for next exec_op 
 re-init the BCH registers 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2017 ATMEL
  Copyright 2017 Free Electrons
  Author: Boris Brezillon <boris.brezillon@free-electrons.com>
  Derived from the atmel_nand.c driver which contained the following
  copyrights:
    Copyright 2003 Rick Bronson
    Derived from driversmtdnandautcpu12.c (removed in v3.8)
 	Copyright 2001 Thomas Gleixner (gleixner@autronix.de)
    Derived from driversmtdspia.c (removed in v3.8)
 	Copyright 2000 Steven J. Hill (sjhill@cotw.com)
    Add Hardware ECC support for AT91SAM9260  AT91SAM9263
 	Richard Genoud (richard.genoud@gmail.com), Adeneo Copyright 2007
    Derived from Das U-Boot source code
 	(u-boot-1.1.5boardatmelat91sam9263eknand.c)
 	Copyright 2006 ATMEL Rousset, Lacressonniere Nicolas
    Add Programmable Multibit ECC support for various AT91 SoC
 	Copyright 2012 ATMEL, Hong Xu
    Add Nand Flash Controller support for SAMA5 SoC
 	Copyright 2013 ATMEL, Josh Wu (josh.wu@atmel.com)
  A few words about the naming convention in this file. This convention
  applies to structure and function names.
  Prefixes:
  - atmel_nand_: all generic structuresfunctions
  - atmel_smc_nand_: all structuresfunctions specific to the SMC interface
 		      (at91sam9 and avr32 SoCs)
  - atmel_hsmc_nand_: all structuresfunctions specific to the HSMC interface
 		       (sama5 SoCs and later)
  - atmel_nfc_: all structuresfunctions used to manipulate the NFC sub-block
 		 that is available in the HSMC block
  - <soc>_nand_: all SoC specific structuresfunctions
 Only used when instantiating from legacy DT bindings. 
 Clear all flags. 
 Send the command. 
 Reset the op state. 
	
	  If the controller supports DMA, the buffer address is DMA-able and
	  len is long enough to make DMA transfers profitable, let's trigger
	  a DMA transfer. If it fails, fallback to PIO mode.
	
	  If the controller supports DMA, the buffer address is DMA-able and
	  len is long enough to make DMA transfers profitable, let's trigger
	  a DMA transfer. If it fails, fallback to PIO mode.
 Falling back to CPU copy. 
 Falling back to CPU copy. 
		
		  2 address cycles for the column offset on large page NANDs.
	
	  Optimized read page accessors only work when the NAND RB pin is
	  connected to a native SoC RB pin. If that's not the case, fallback
	  to the non-optimized one.
		
		  Nothing to do, the core will initialize everything for us.
 Other modes are not supported. 
 Adjust the ECC operations for the HSMC IP. 
 DDR interface not supported. 
	
	  tRC < 30ns implies EDO mode. This controller does not support this
	  mode.
	
	  Set write pulse timing. This one is easy to extract:
	 
	  NWE_PULSE = tWP
	
	  The write setup timing depends on the operation done on the NAND.
	  All operations goes through the same data bus, but the operation
	  type depends on the address we are writing to (ALECLE address
	  lines).
	  Since we have no way to differentiate the different operations at
	  the SMC level, we must consider the worst case (the biggest setup
	  time among all operation types):
	 
	  NWE_SETUP = max(tCLS, tCS, tALS, tDS) - NWE_PULSE
	
	  As for the write setup timing, the write hold timing depends on the
	  operation done on the NAND:
	 
	  NWE_HOLD = max(tCLH, tCH, tALH, tDH, tWH)
	
	  The write cycle timing is directly matching tWC, but is also
	  dependent on the other timings on the setup and hold timings we
	  calculated earlier, which gives:
	 
	  NWE_CYCLE = max(tWC, NWE_SETUP + NWE_PULSE + NWE_HOLD)
	
	  We don't want the CS line to be toggled between each byteword
	  transfer to the NAND. The only way to guarantee that is to have the
	  NCS_{WR,RD}_{SETUP,HOLD} timings set to 0, which in turn means:
	 
	  NCS_WR_PULSE = NWE_CYCLE
	
	  As for the write setup timing, the read hold timing depends on the
	  operation done on the NAND:
	 
	  NRD_HOLD = max(tREH, tRHOH)
	
	  TDF = tRHZ - NRD_HOLD
	
	  In ONFI 4.0 specs, tRHZ has been increased to support EDO NANDs and
	  we might end up with a config that does not fit in the TDF field.
	  Just take the max value in this case and hope that the NAND is more
	  tolerant than advertised.
	
	  Read pulse timing directly matches tRP:
	 
	  NRD_PULSE = tRP
	
	  The write cycle timing is directly matching tWC, but is also
	  dependent on the setup and hold timings we calculated earlier,
	  which gives:
	 
	  NRD_CYCLE = max(tRC, NRD_PULSE + NRD_HOLD)
	 
	  NRD_SETUP is always 0.
	
	  We don't want the CS line to be toggled between each byteword
	  transfer from the NAND. The only way to guarantee that is to have
	  the NCS_{WR,RD}_{SETUP,HOLD} timings set to 0, which in turn means:
	 
	  NCS_RD_PULSE = NRD_CYCLE
 Txxx timings are directly matching tXXX ones. 
	
	  Version 4 of the ONFI spec mandates that tADL be at least 400
	  nanoseconds, but, depending on the master clock rate, 400 ns may not
	  fit in the tADL field of the SMC reg. We need to relax the check and
	  accept the -ERANGE return code.
	 
	  Note that previous versions of the ONFI spec had a lower tADL_min
	  (100 or 200 ns). It's not clear why this timing constraint got
	  increased but it seems most NANDs are fine with values lower than
	  400ns, so we should be safe.
 Attach the CS line to the NFC logic. 
 Set the appropriate data bus width. 
 Operate in NRDNWE READWRITEMODE. 
	
	  Use a bounce buffer when the buffer passed by the MTD user is not
	  suitable for DMA.
 Default to HW ECC if pmecc is available. 
 Attach the CS to the NAND Flash logic. 
 No card inserted, skip this NAND. 
	
	  Legacy bindings only allow connecting a single NAND with a unique CS
	  line to the controller.
	
	  The old driver was hardcoding the CS id to 3 for all sama5
	  controllers. Since this id is only meaningful for the sama5
	  controller we can safely assign this id to 3 no matter the
	  controller.
	  If one wants to connect a NAND to a different CS line, he will
	  have to use the new bindings.
 RB GPIO. 
 CS GPIO. 
 Card detect GPIO. 
 We do not retrieve the SMC syscon when parsing old DTs. 
 sentinel  },
		
		  We keep the MTD name unchanged to avoid breaking platforms
		  where the MTD cmdline parser is used and the bootloader
		  has not been updated to use the new naming scheme.
		
		  If the new bindings are used and the bootloader has not been
		  updated to pass a new mtdparts parameter on the cmdline, you
		  should define the following property in your nand node:
		 
		 	label = "atmel_nand";
		 
		  This way, mtd->name will be set by the core when
		  nand_set_flash_node() is called.
 We do not retrieve the SMC syscon when parsing old DTs. 
 We do not retrieve the EBICSA regmap when parsing old DTs. 
	
	  The at91sam9263 has 2 EBIs, if the NAND controller is under EBI1
	  add 4 to ->ebi_csa->offs.
 Make sure all irqs are masked before registering our IRQ handler. 
 Initial NFC configuration. 
 Only used to parse old bindings. 
  The SMC reg layout of at91rm9200 is completely different which prevents us
  from re-using atmel_smc_nand_setup_interface() for the
  ->setup_interface() hook.
  At this point, there's no support for the at91rm9200 SMC IP, so we leave
  ->setup_interface() unassigned.
 Only used to parse old bindings. 
 Support for olddeprecated bindings: 
 sentinel  },
		
		  If we are parsing legacy DT props and the DT contains a
		  valid NFC node, forward the request to the sama5 logic.
		
		  Even if the compatible says we are dealing with an
		  at91rm9200 controller, the atmel,nand-has-dma specify that
		  this controller supports DMA, which means we are in fact
		  dealing with an at91sam9g45+ controller.
		
		  All SoCs except the at91sam9261 are assigning ALE to A21 and
		  CLE to A22. If atmel,nand-addr-offset != 21 this means we're
		  actually dealing with an at91sam9261 controller.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2017 ATMEL
  Copyright 2017 Free Electrons
  Author: Boris Brezillon <boris.brezillon@free-electrons.com>
  Derived from the atmel_nand.c driver which contained the following
  copyrights:
    Copyright 2003 Rick Bronson
    Derived from driversmtdnandautcpu12.c (removed in v3.8)
 	Copyright 2001 Thomas Gleixner (gleixner@autronix.de)
    Derived from driversmtdspia.c (removed in v3.8)
 	Copyright 2000 Steven J. Hill (sjhill@cotw.com)
    Add Hardware ECC support for AT91SAM9260  AT91SAM9263
 	Richard Genoud (richard.genoud@gmail.com), Adeneo Copyright 2007
    Derived from Das U-Boot source code
 	(u-boot-1.1.5boardatmelat91sam9263eknand.c)
       Copyright 2006 ATMEL Rousset, Lacressonniere Nicolas
    Add Programmable Multibit ECC support for various AT91 SoC
 	Copyright 2012 ATMEL, Hong Xu
    Add Nand Flash Controller support for SAMA5 SoC
 	Copyright 2013 ATMEL, Josh Wu (josh.wu@atmel.com)
  The PMECC is an hardware assisted BCH engine, which means part of the
  ECC algorithm is left to the software. The hardwaresoftware repartition
  is explained in the "PMECC Controller Functional Description" chapter in
  Atmel datasheets, and some of the functions in this file are directly
  implementing the algorithms described in the "Software Implementation"
  sub-section.
  TODO: it seems that the software BCH implementation in libbch.c is already
  providing some of the logic we are implementing here. It would be smart
  to expose the needed libbch.c helpersfunctions and re-use them here.
 Galois field dimension 
 Primitive Polynomial used by PMECC 
 Time out value for reading PMECC status register 
 PMECC Register Definitions 
 PMERRLOC Register Definitions 
 polynomial degree is the most-significant bit index 
 primitive polynomial must be of degree m 
 polynomial is not primitive (a^i=1 with 0<i<2^m-1) 
 Reserve space for partial_syn, si and smu 
 Reserve space for lmu. 
 Reserve space for mu, dmu and delta. 
 Fill odd syndromes 
	
	  si[] is a table that holds the current syndrome value,
	  an element of that table belongs to the field
 Computation 2t syndromes based on S(x) 
 Odd syndromes 
 Even syndrome = (Odd syndrome)  2 
 index of largest delta 
 First Row 
 Mu 
 discrepancy set to 1 
 polynom order set to 0 
 Second Row 
 Mu 
 Sigma(x) set to 1 
 discrepancy set to S1 
 polynom order set to 0 
 Init the Sigma(x) last row 
 Begin Computing Sigma (Mu+1) and L(mu) 
 check if discrepancy is set to 0 
 copy polynom 
 copy previous polynom order to the next 
 find largest delta with dmu != 0 
 compute difference 
 Compute degree of the new smu polynomial 
 Init smu[i+1] with 0 
 Compute smu[i+1] 
 End Computing Sigma (Mu+1) and L(mu) 
 In either case compute delta 
 Do not compute discrepancy for the last iteration 
 Number of roots == degree of smu hence <= cap 
	
	  Number of roots does not match the degree of smu
	  unable to correct error.
 Disable all interrupts before registering the PMECC handler. 
 sentinel  }
		
		  Support old DT bindings: in this case the PMECC iomem
		  resources are directly defined in the user pdev at position
		  1 and 2. Extract all relevant information from there.
 No PMECC engine available. 
 Find the caps associated to the NAND dev node. 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
   Copyright  2005-2009 Samsung Electronics
   Copyright  2007 Nokia Corporation
   Kyungmin Park <kyungmin.park@samsung.com>
   Credits:
 	Adrian Hunter <ext-adrian.hunter@nokia.com>:
 	auto-placement support, read-while load support, various fixes
 	Vishak G <vishak.g at samsung.com>, Rohit Hagargundgi <h.rohit at samsung.com>
 	Flex-OneNAND support
 	Amul Kumar Saha <amul.saha at samsung.com>
 	OTP support
  Multiblock erase if number of blocks to erase is 2 or more.
  Maximum number of blocks for simultaneous erase is 64.
 Default Flex-OneNAND boundary and lock respectively 
 Default OneNANDFlex-OneNAND OTP options
  flexonenand_oob_128 - oob info for Flex-Onenand with 4KB page
  For now, we expose only 64 out of 80 ecc bytes
  onenand_oob_128 - oob info for OneNAND with 4KB page
  Based on specification:
  4Gb M-die OneNAND Flash (KFM4G16Q4M, KFN8G16Q4M). Rev. 1.3, Apr. 2010
	
	  free bytes are using the spare area fields marked as
	  "Managed by internal ECC logic for Logical Sector Number area"
  onenand_oob_32_64 - oob info for large (2KB) page
 16 
 32 
 48 
 64 
 80 
 96 
 112 
 128 
  onenand_readw - [OneNAND Interface] Read OneNAND register
  @addr:		address to read
  Read OneNAND register
  onenand_writew - [OneNAND Interface] Write OneNAND register with value
  @value:		value to write
  @addr:		address to write
  Write OneNAND register with value
  onenand_block_address - [DEFAULT] Get block address
  @this:		onenand chip data structure
  @block:		the block
  @return		translated block address if DDP, otherwise same
  Setup Start Address 1 Register (F100h)
 Device Flash Core select, NAND Flash Block Address 
  onenand_bufferram_address - [DEFAULT] Get bufferram address
  @this:		onenand chip data structure
  @block:		the block
  @return		set DBS value if DDP, otherwise 0
  Setup Start Address 2 Register (F101h) for DDP
 Device BufferRAM Select 
  onenand_page_address - [DEFAULT] Get page address
  @page:		the page address
  @sector:	the sector address
  @return		combined page and sector address
  Setup Start Address 8 Register (F107h)
 Flash Page Address, Flash Sector Address 
  onenand_buffer_address - [DEFAULT] Get buffer address
  @dataram1:	DataRAM index
  @sectors:	the sector address
  @count:		the number of sectors
  Return:		the start buffer value
  Setup Start Buffer Register (F200h)
 BufferRAM Sector Address 
 DataRAM1 
 DataRAM0 
 BufferRAM Sector Count 
  flexonenand_block- For given address return block number
  @this:         - OneNAND device structure
  @addr:		- Address for which block number is needed
  flexonenand_addr - Return address of the block
  @this:		OneNAND device structure
  @block:		Block number on Flex-OneNAND
  Return address of the block
  onenand_get_density - [DEFAULT] Get OneNAND density
  @dev_id:	OneNAND device ID
  Get OneNAND density from device ID
  flexonenand_region - [Flex-OneNAND] Return erase region of addr
  @mtd:		MTD device structure
  @addr:		address whose erase region needs to be identified
  onenand_command - [DEFAULT] Send command to OneNAND device
  @mtd:		MTD device structure
  @cmd:		the command to be sent
  @addr:		offset to read from or write to
  @len:		number of bytes to read or write
  Send command to OneNAND device. This function is used for middlelarge page
  devices (1KB2KB Bytes per page)
 Address translation 
 addr contains die index 
 Make the even block number 
 Is it the odd plane? 
 NOTE: The setting order of the registers is very important! 
 Select DataRAM for DDP 
 It is always BufferRAM0 
 Switch to the next data buffer 
 Write 'DFS, FBA' of Flash 
 Select DataRAM for DDP 
 Now we use page size operation 
 It is always BufferRAM0 
 Write 'FPA, FSA' of Flash 
 Write 'BSA, BSC' of DataRAM 
 Interrupt clear 
 Write command 
  onenand_read_ecc - return ecc status
  @this:		onenand chip structure
  onenand_wait - [DEFAULT] wait until the command is done
  @mtd:		MTD device structure
  @state:		state to select the max. timeout value
  Wait for command done. This applies to all OneNAND command
  Read can take up to 30us, erase up to 2ms and program up to 350us
  according to general OneNAND specs
 The 20 msec is enough 
 To get correct interrupt status in timeout case 
	
	  In the Spec. it checks the controller status first
	  However if you get the correct information in case of
	  power off recovery (POR) test, it should read ECC status first
 If there's controller error, it's a real error 
  onenand_interrupt - [DEFAULT] onenand interrupt handler
  @irq:		onenand interrupt number
  @dev_id:	interrupt data
  complete the work
 To handle shared interrupt 
  onenand_interrupt_wait - [DEFAULT] wait until the command is done
  @mtd:		MTD device structure
  @state:		state to select the max. timeout value
  Wait for command done.
  onenand_try_interrupt_wait - [DEFAULT] try interrupt wait
  @mtd:		MTD device structure
  @state:		state to select the max. timeout value
  Try interrupt based wait (It is used one-time)
 We use interrupt wait first 
 Release the irq 
  onenand_setup_wait - [OneNAND Interface] setup onenand wait method
  @mtd:		MTD device structure
  There's two method to wait onenand work
  1. polling - read interrupt status register
  2. interrupt - use the kernel interrupt method
 If we can't get irq, use the normal wait 
 Enable interrupt 
  onenand_bufferram_offset - [DEFAULT] BufferRAM offset
  @mtd:		MTD data structure
  @area:		BufferRAM area
  @return		offset given area
  Return BufferRAM offset given area
 Note: the 'this->writesize' is a real page size 
  onenand_read_bufferram - [OneNAND Interface] Read the bufferram area
  @mtd:		MTD data structure
  @area:		BufferRAM area
  @buffer:	the databuffer to putget data
  @offset:	offset to read from or write to
  @count:		number of bytes to readwrite
  Read the BufferRAM area
 Align with word(16-bit) size 
 Read word and save byte 
  onenand_sync_read_bufferram - [OneNAND Interface] Read the bufferram area with Sync. Burst mode
  @mtd:		MTD data structure
  @area:		BufferRAM area
  @buffer:	the databuffer to putget data
  @offset:	offset to read from or write to
  @count:		number of bytes to readwrite
  Read the BufferRAM area with Sync. Burst Mode
 Align with word(16-bit) size 
 Read word and save byte 
  onenand_write_bufferram - [OneNAND Interface] Write the bufferram area
  @mtd:		MTD data structure
  @area:		BufferRAM area
  @buffer:	the databuffer to putget data
  @offset:	offset to read from or write to
  @count:		number of bytes to readwrite
  Write the BufferRAM area
 Align with word(16-bit) size 
 Calculate byte access offset 
 Read word and save byte 
  onenand_get_2x_blockpage - [GENERIC] Get blockpage at 2x program mode
  @mtd:		MTD data structure
  @addr:		address to check
  @return		blockpage address
  Get blockpage address at 2x program mode
 Calculate the even block number 
 Is it the odd plane? 
  onenand_check_bufferram - [GENERIC] Check BufferRAM information
  @mtd:		MTD data structure
  @addr:		address to check
  @return		1 if there are valid data, otherwise 0
  Check bufferram if there is data we required
 Is there valid data? 
 Check another BufferRAM 
 Select DataRAM for DDP 
  onenand_update_bufferram - [GENERIC] Update BufferRAM information
  @mtd:		MTD data structure
  @addr:		address to update
  @valid:		valid flag
  Update BufferRAM information
 Invalidate another BufferRAM 
 Update BufferRAM 
  onenand_invalidate_bufferram - [GENERIC] Invalidate BufferRAM information
  @mtd:		MTD data structure
  @addr:		start address to invalidate
  @len:		length to invalidate
  Invalidate BufferRAM information
 Invalidate BufferRAM 
  onenand_get_device - [GENERIC] Get chip for selected access
  @mtd:		MTD device structure
  @new_state:	the state which is requested
  Get the device and lock it for exclusive access
	
	  Grab the lock and see if the device is available
  onenand_release_device - [GENERIC] release chip
  @mtd:		MTD device structure
  Deselect, release chip lock and wake up anyone waiting on the device
 Release the chip 
  onenand_transfer_auto_oob - [INTERN] oob auto-placement transfer
  @mtd:		MTD device structure
  @buf:		destination address
  @column:	oob offset to read from
  @thislen:	oob length to read
  onenand_recover_lsb - [Flex-OneNAND] Recover LSB page data
  @mtd:		MTD device structure
  @addr:		address to recover
  @status:	return value from onenand_wait  onenand_bbt_wait
  MLC NAND Flash cell has paired pages - LSB page and MSB page. LSB page has
  lower page address and MSB page has higher page address in paired pages.
  If power off occurs during MSB page program, the paired LSB page data can
  become corrupt. LSB page recovery read is a way to read LSB page though page
  data are corrupted. When uncorrectable error occurs as a result of LSB page
  read after power up, issue LSB page recovery read.
 Recovery is only for Flex-OneNAND 
 check if we failed due to uncorrectable error 
 check if address lies in MLC region 
	 We are attempting to reread, so decrement stats.failed
	  which was incremented by onenand_wait due to read failure
 Issue the LSB page recovery command 
  onenand_mlc_read_ops_nolock - MLC OneNAND read main andor out-of-band
  @mtd:		MTD device structure
  @from:		offset to read from
  @ops:		oob operation description structure
  MLC OneNAND  Flex-OneNAND has 4KB page size and 4KB dataram.
  So, read-while-load is not present.
 Do not allow reads past end of device 
	
	  Return success, if no ECC failures, else -EBADMSG
	  fs driver will take care of that, because
	  retlen == desired len and result == -EBADMSG
 return max bitflips per ecc step; ONENANDs correct 1 bit only 
  onenand_read_ops_nolock - [OneNAND Interface] OneNAND read main andor out-of-band
  @mtd:		MTD device structure
  @from:		offset to read from
  @ops:		oob operation description structure
  OneNAND read main andor out-of-band data
 Do not allow reads past end of device 
 Read-while-load method 
 Do first load to bufferRAM 
 If there is more to load then start next load 
			
			  Chip boundary handling in DDP
			  Now we issued chip 1 read and pointed chip 1
			  bufferram so we have to point chip 0 bufferram.
 While load is going, read from last bufferRAM 
 Read oob area if needed 
 See if we are done 
 Set up for next read from bufferRAM 
 Now wait for load 
	
	  Return success, if no ECC failures, else -EBADMSG
	  fs driver will take care of that, because
	  retlen == desired len and result == -EBADMSG
 return max bitflips per ecc step; ONENANDs correct 1 bit only 
  onenand_read_oob_nolock - [MTD Interface] OneNAND read out-of-band
  @mtd:		MTD device structure
  @from:		offset to read from
  @ops:		oob operation description structure
  OneNAND read out-of-band data from the spare area
 Initialize return length value 
 Read more? 
 Page size 
  onenand_read_oob - [MTD Interface] Read main andor out-of-band
  @mtd:		MTD device structure
  @from:		offset to read from
  @ops:		oob operation description structure
  Read main andor out-of-band
 Not implemented yet 
  onenand_bbt_wait - [DEFAULT] wait until the command is done
  @mtd:		MTD device structure
  @state:		state to select the max. timeout value
  Wait for command done.
 The 20 msec is enough 
 To get correct interrupt status in timeout case 
 Initial bad block case: 0x2400 or 0x0400 
  onenand_bbt_read_oob - [MTD Interface] OneNAND read out-of-band for bbt scan
  @mtd:		MTD device structure
  @from:		offset to read from
  @ops:		oob operation description structure
  OneNAND read out-of-band data from the spare area for bbt scan
 Initialize return value 
 Do not allow reads past end of device 
 Grab the lock and see if the device is available 
 Read more? 
 Update Page size 
 Deselect and wake up anyone waiting on the device 
  onenand_verify_oob - [GENERIC] verify the oob contents after a write
  @mtd:		MTD device structure
  @buf:		the databuffer to verify
  @to:		offset to read from
  onenand_verify - [GENERIC] verify the chip contents after a write
  @mtd:          MTD device structure
  @buf:          the databuffer to verify
  @addr:         offset to read from
  @len:          number of bytes to read and compare
  onenand_panic_write - [MTD Interface] write buffer to FLASH in a panic context
  @mtd:		MTD device structure
  @to:		offset to write to
  @len:		number of bytes to write
  @retlen:	pointer to variable to store the number of written bytes
  @buf:		the data to write
  Write with ECC
 Wait for any existing operation to clear 
 Reject writes, which are not page aligned 
 Loop until all data write 
 Partial page write 
 In partial page write we don't update bufferram 
  onenand_fill_auto_oob - [INTERN] oob auto-placement transfer
  @mtd:		MTD device structure
  @oob_buf:	oob buffer
  @buf:		source address
  @column:	oob offset to write to
  @thislen:	oob length to write
  onenand_write_ops_nolock - [OneNAND Interface] write main andor out-of-band
  @mtd:		MTD device structure
  @to:		offset to write to
  @ops:		oob operation description structure
  Write main andor oob with ECC
 Initialize retlen, in case of early exit 
 Reject writes, which are not page aligned 
 Check zero length 
 Loop until all data write 
 Partial page write 
				 We send data to spare ram with oobsize
		
		  2 PLANE, MLC, and Flex-OneNAND do not support
		  write-while-program feature.
 In partial page write we don't update bufferram 
 Only check verify write turn on 
 Exclude 1st OTP and OTP blocks for cache program feature 
		
		  2 PLANE, MLC, and Flex-OneNAND wait here
 In partial page write we don't update bufferram 
 Only check verify write turn on 
 In error case, clear all bufferrams 
  onenand_write_oob_nolock - [INTERN] OneNAND write out-of-band
  @mtd:		MTD device structure
  @to:			offset to write to
  @ops:                oob operation description structure
  OneNAND write out-of-band
 Initialize retlen, in case of early exit 
 For compatibility with NAND: Do not allow write past end of page 
 Loop until all data write 
		 We send data to spare ram with oobsize
 Set main area of DataRAM to 0xff
  onenand_write_oob - [MTD Interface] NAND write data andor out-of-band
  @mtd:		MTD device structure
  @to:			offset to write
  @ops:		oob operation description structure
 Not implemented yet 
  onenand_block_isbad_nolock - [GENERIC] Check if a block is marked bad
  @mtd:		MTD device structure
  @ofs:		offset from device start
  @allowbbt:	1, if its allowed to access the bbt area
  Check, if the block is bad. Either by reading the bad block table or
  calling of the scan function.
 Return info from the table 
  onenand_multiblock_erase - [INTERN] erase block(s) using multiblock erase
  @mtd:		MTD device structure
  @instr:		erase instruction
  @block_size:		block size
  Erase one or more blocks up to 64 block at a time
 Pre-check bbs 
 Check if we have a bad block, we do not erase bad blocks 
 loop over 64 eb batches 
 do not cross chip boundary 
 last block of 64-eb series 
 Check if it is write protected 
 verify 
  onenand_block_by_block_erase - [INTERN] erase block(s) using regular erase
  @mtd:		MTD device structure
  @instr:		erase instruction
  @region:	erase region
  @block_size:	erase block size
  Erase one or more blocks one block at a time
 region is set for Flex-OneNAND 
 Loop through the blocks 
 Check if we have a bad block, we do not erase bad blocks 
 Check, if it is write protected 
 FIXME: This should be handled at MTD partitioning level. 
  onenand_erase - [MTD Interface] erase block(s)
  @mtd:		MTD device structure
  @instr:		erase instruction
  Erase one or more blocks
 Find the eraseregion of this address 
		 Start address within region must align on block boundary.
		  Erase region's start offset is always block start address.
 Start address must align on block boundary 
 Length must align on block boundary 
 Grab the lock and see if the device is available 
 region is set for Flex-OneNAND (no mb erase) 
 Deselect and wake up anyone waiting on the device 
  onenand_sync - [MTD Interface] sync
  @mtd:		MTD device structure
  Sync is actually a wait for chip ready function
 Grab the lock and see if the device is available 
 Release it and go back 
  onenand_block_isbad - [MTD Interface] Check whether the block at the given offset is bad
  @mtd:		MTD device structure
  @ofs:		offset relative to mtd start
  Check whether the block is bad
  onenand_default_block_markbad - [DEFAULT] mark a block bad
  @mtd:		MTD device structure
  @ofs:		offset from device start
  This is the default implementation, which can be overridden by
  a hardware specific driver.
 Get block number 
 We write two bytes, so we don't have to mess with 16-bit access 
	 FIXME : What to do when marking SLC block in partition
	  	   with MLC erasesize? For now, it is not advisable to
	 	   create partitions containing both SLC and MLC regions.
  onenand_block_markbad - [MTD Interface] Mark the block at the given offset as bad
  @mtd:		MTD device structure
  @ofs:		offset relative to mtd start
  Mark the block as bad
 If it was bad already, return success and do nothing 
  onenand_do_lock_cmd - [OneNAND Interface] Lock or unlock block(s)
  @mtd:		MTD device structure
  @ofs:		offset relative to mtd start
  @len:		number of bytes to lock or unlock
  @cmd:		lock or unlock command
  Lock or unlock one or more blocks
 Continuous lock scheme 
 Set start block address 
 Set end block address 
 Write lock command 
 There's no return value 
 Sanity check 
 Check lock status 
 Block lock scheme 
 Set block address 
 Select DataRAM for DDP 
 Set start block address 
 Write lock command 
 There's no return value 
 Sanity check 
 Check lock status 
  onenand_lock - [MTD Interface] Lock block(s)
  @mtd:		MTD device structure
  @ofs:		offset relative to mtd start
  @len:		number of bytes to unlock
  Lock one or more blocks
  onenand_unlock - [MTD Interface] Unlock block(s)
  @mtd:		MTD device structure
  @ofs:		offset relative to mtd start
  @len:		number of bytes to unlock
  Unlock one or more blocks
  onenand_check_lock_status - [OneNAND Interface] Check lock status
  @this:		onenand chip data structure
  Check lock status
 Set block address 
 Select DataRAM for DDP 
 Set start block address 
 Check lock status 
  onenand_unlock_all - [OneNAND Interface] unlock all blocks
  @mtd:		MTD device structure
  Unlock all blocks
 Set start block address 
 Write unlock command 
 There's no return value 
 Sanity check 
 Don't check lock status 
 Check lock status 
 Workaround for all block unlock in DDP 
 All blocks on another chip 
  onenand_otp_command - Send OTP specific command to OneNAND device
  @mtd:	 MTD device structure
  @cmd:	 the command to be sent
  @addr:	 offset to read from or write to
  @len:	 number of bytes to read or write
 Address translation 
 Make the even block number 
 Is it the odd plane? 
 Write 'DFS, FBA' of Flash 
 Now we use page size operation 
 Write 'FPA, FSA' of Flash 
 Write 'BSA, BSC' of DataRAM 
 Interrupt clear 
 Write command 
  onenand_otp_write_oob_nolock - [INTERN] OneNAND write out-of-band, specific to OTP
  @mtd:		MTD device structure
  @to:			offset to write to
  @ops:                oob operation description structure
  OneNAND write out-of-band only for OTP
 Initialize retlen, in case of early exit 
 Loop until all data write 
		
		  Write 'DFS, FBA' of Flash
		  Add: F100h DQ=DFS, FBA
		
		  Select DataRAM for DDP
		  Add: F101h DQ=DBS
		
		  Enter OTP access mode
		 We send data to spare ram with oobsize
		
		  Write Data into DataRAM
		  Add: 8th Word
		  in sector0sparepage0
		  DQ=XXFCh
 Exit OTP access mode 
 Internal OTP operation 
  do_otp_read - [DEFAULT] Read OTP block area
  @mtd:		MTD device structure
  @from:		The offset to read
  @len:		number of bytes to read
  @retlen:	pointer to variable to store the number of readbytes
  @buf:		the databuffer to putget data
  Read OTP block area.
 Enter OTP access mode 
 Exit OTP access mode 
  do_otp_write - [DEFAULT] Write OTP block area
  @mtd:		MTD device structure
  @to:		The offset to write
  @len:		number of bytes to write
  @retlen:	pointer to variable to store the number of write bytes
  @buf:		the databuffer to putget data
  Write OTP block area.
 Force buffer page aligned 
 Enter OTP access mode 
 Exit OTP access mode 
  do_otp_lock - [DEFAULT] Lock OTP block area
  @mtd:		MTD device structure
  @from:		The offset to lock
  @len:		number of bytes to lock
  @retlen:	pointer to variable to store the number of lock bytes
  @buf:		the databuffer to putget data
  Lock OTP block area.
 Enter OTP access mode 
		
		  For Flex-OneNAND, we write lock mark to 1st word of sector 4 of
		  main area of page 49.
 Exit OTP access mode 
  onenand_otp_walk - [DEFAULT] Handle OTP operation
  @mtd:		MTD device structure
  @from:		The offset to readwrite
  @len:		number of bytes to readwrite
  @retlen:	pointer to variable to store the number of read bytes
  @buf:		the databuffer to putget data
  @action:	do given action
  @mode:		specify user and factory
  Handle OTP operation.
 Check UserFactory boundary 
 OTP Info functions 
  onenand_get_fact_prot_info - [MTD Interface] Read factory OTP info
  @mtd:		MTD device structure
  @len:		number of bytes to read
  @retlen:	pointer to variable to store the number of read bytes
  @buf:		the databuffer to putget data
  Read factory OTP info.
  onenand_read_fact_prot_reg - [MTD Interface] Read factory OTP area
  @mtd:		MTD device structure
  @from:		The offset to read
  @len:		number of bytes to read
  @retlen:	pointer to variable to store the number of read bytes
  @buf:		the databuffer to putget data
  Read factory OTP area.
  onenand_get_user_prot_info - [MTD Interface] Read user OTP info
  @mtd:		MTD device structure
  @retlen:	pointer to variable to store the number of read bytes
  @len:		number of bytes to read
  @buf:		the databuffer to putget data
  Read user OTP info.
  onenand_read_user_prot_reg - [MTD Interface] Read user OTP area
  @mtd:		MTD device structure
  @from:		The offset to read
  @len:		number of bytes to read
  @retlen:	pointer to variable to store the number of read bytes
  @buf:		the databuffer to putget data
  Read user OTP area.
  onenand_write_user_prot_reg - [MTD Interface] Write user OTP area
  @mtd:		MTD device structure
  @from:		The offset to write
  @len:		number of bytes to write
  @retlen:	pointer to variable to store the number of write bytes
  @buf:		the databuffer to putget data
  Write user OTP area.
  onenand_lock_user_prot_reg - [MTD Interface] Lock user OTP area
  @mtd:		MTD device structure
  @from:		The offset to lock
  @len:		number of bytes to unlock
  Write lock mark on spare area in page 0 in OTP block
	
	  Write lock mark to 8th word of sector0 of page0 of the spare0.
	  We write 16 bytes spare area instead of 2 bytes.
	  For Flex-OneNAND, we write lock mark to 1st word of sector 4 of
	  main area of page 49.
	
	  Note: OTP lock operation
	        OTP block : 0xXXFC			XX 1111 1100
	        1st block : 0xXXF3 (If chip support)	XX 1111 0011
	        Both      : 0xXXF0 (If chip support)	XX 1111 0000
 ONENAND_OTP_AREA | ONENAND_OTP_BLOCK0 | ONENAND_OTP_AREA_BLOCK0 
 CONFIG_MTD_ONENAND_OTP 
  onenand_check_features - Check and set OneNAND features
  @mtd:		MTD data structure
  Check and set OneNAND features
  - lock scheme
  - two plane
 Lock scheme depends on density and process 
 Lock scheme 
			
			  There are two different 4KiB pagesize chips
			  and no way to detect it by HW config values.
			 
			  To detect the correct NOP for each chips,
			  It should check the version ID as workaround.
			 
			  Now it has as following
			  KFM4G16Q4M has NOP 4 with version ID 0x0131
			  KFM4G16Q5M has NOP 1 with versoin ID 0x013e
 2Gb DDP does not have 2 plane 
 A-Die has all block unlock 
 Some OneNAND has continuous lock scheme 
 The MLC has 4KiB pagesize. 
  onenand_print_device_info - Print device & version ID
  @device:        device ID
  @version:	version ID
  Print device & version ID
  onenand_check_maf - Check manufacturer ID
  @manuf:         manufacturer ID
  Check manufacturer ID
  flexonenand_get_boundary	- Reads the SLC boundary
  @mtd:		MTD data structure
 Disable ECC 
 Enable ECC 
  flexonenand_get_size - Fill up fields in onenand_chip and mtd_info
  			  boundary[], diesize[], mtd->size, mtd->erasesize
  @mtd:		- MTD device structure
 This fills up the device boundary 
 Expose MLC erase size except when all blocks are SLC 
  flexonenand_check_blocks_erased - Check if blocks are erased
  @mtd:	mtd info structure
  @start:	first erase block to check
  @end:	last erase block to check
  Converting an unerased block from MLC to SLC
  causes byte values to change. Since both data and its ECC
  have changed, reads on the block give uncorrectable error.
  This might lead to the block being detected as bad.
  Avoid this by ensuring that the block to be converted is
  erased.
		
		  Since main area write results in ECC write to spare,
		  it is sufficient to check only ECC bytes for change.
  flexonenand_set_boundary	- Writes the SLC boundary
 Change only once for SDP Flex-OneNAND 
 boundary value of -1 indicates no required change 
 Check if converting blocks are erased 
 Check is boundary is locked 
 Recalculate device size on boundary change
  onenand_chip_probe - [OneNAND Interface] The generic chip probe
  @mtd:		MTD device structure
  OneNAND detection method:
    Compare the values from command with ones from register
 Save system configuration 1 
 Clear Sync. Burst Read mode to read BootRAM 
 Send the command for reading device ID from BootRAM 
 Read manufacturer and device IDs from BootRAM 
 Reset OneNAND to read default register values 
 Wait reset 
 Restore system configuration 1 
 Check manufacturer ID 
 Read manufacturer and device IDs from Register 
 Check OneNAND device 
  onenand_probe - [OneNAND Interface] Probe the OneNAND device
  @mtd:		MTD device structure
 Device and version IDs from Register 
 Flash device information 
 Check OneNAND features 
 Maximum possible erase regions 
	
	  For Flex-OneNAND, chipsize represents maximum possible device size.
	  mtd->size represents the actual device size.
 OneNAND page size & block size 
 The data buffer size is equal to page size 
 We use the full BufferRAM 
 Pages per a block are always 64 in OneNAND 
	
	  Flex-OneNAND SLC area has 64 pages per block.
	  Flex-OneNAND MLC area has 128 pages per block.
	  Expose MLC erase size to find erase_shift and page_mask.
 Set density mask. it is used for DDP 
 It's real page size 
 REVISIT: Multichip handling 
	
	  We emulate the 4KiB page and 256KiB erase block size
	  But oobsize is still 64 bytes.
	  It is only valid if you turn on 2X program support,
	  Otherwise it will be ignored by compiler.
  onenand_suspend - [MTD Interface] Suspend the OneNAND flash
  @mtd:		MTD device structure
  onenand_resume - [MTD Interface] Resume the OneNAND flash
  @mtd:		MTD device structure
  onenand_scan - [OneNAND Interface] Scan for the OneNAND device
  @mtd:		MTD device structure
  @maxchips:	Number of chips to scan for
  This fills out all the not initialized function pointers
  with the defaults.
  The flash ID is read and the mtdchip structures are
  filled with the appropriate values.
 Set Sync. Burst Read after probing 
 Allocate buffers, if necessary 
	
	  Allow subpage writes up to oobsize.
 To prevent kernel oops 
	
	  The number of bytes available for a client to place data into
	  the out of band area
 Fill in remaining MTD driver data 
 Unlock whole block 
 Set the bad block marker position 
 Change Flex-OneNAND boundaries if required 
  onenand_release - [OneNAND Interface] Free resources held by the OneNAND device
  @mtd:		MTD device structure
 Deregister partitions 
 Free bad block table memory, if allocated 
 Buffers allocated by onenand_scan 
 SPDX-License-Identifier: GPL-2.0-only
  Samsung S3C64XXS5PC1XX OneNAND driver
   Copyright  2008-2010 Samsung Electronics
   Kyungmin Park <kyungmin.park@samsung.com>
   Marek Szyprowski <m.szyprowski@samsung.com>
  Implementation:
 	S3C64XX: emulate the pseudo BufferRAM
 	S5PC110: use DMA
 S5PC110 specific definitions 
 Clear interrupt 
 Clear the ECC status 
 It's used for probing time 
 Used at unlock all status 
 BootRAM access control 
 It's used for probing time 
 Locklock-tightunlockunlock_all 
 BootRAM access control 
 The 20 msec is enough 
 To get correct interrupt status in timeout case 
	
	  In the Spec. it checks the controller status first
	  However if you get the correct information in case of
	  power off recovery (POR) test, it should read ECC status first
	
	  Emulate Two BufferRAMs and access with 4 bytes pointer
 Main 
 Main 
 Spare 
 Main 
 Main - dummy write 
 Spare 
	
	  There's no exact timeout values at Spec.
	  In real case it takes under 1 msec.
	  So 20 msecs are enough.
 Handle vmalloc address 
 Page offset 
 DMA routine 
 DMA routine 
 Copy the bufferram to memory to prevent unaligned access 
 Now just return 0 
 The 20 msec is enough 
 To get correct interrupt status in timeout case 
 Write unlock command 
 No need to check return value 
 Workaround for all block unlock in DDP 
 All blocks on another chip 
 Use generic onenand functions 
 No need to check pdata. the platform data is optional 
 Set onenand_chip also 
 Use runtime badblock check 
 Allocate 4KiB BufferRAM 
 Allocate 128 SpareRAM 
 S3C doesn't handle subpage write 
 S5PC110 
 Interrupt support 
 S3C doesn't handle subpage write 
 SPDX-License-Identifier: GPL-2.0-only
   Copyright (c) 2005 Samsung Electronics
   Kyungmin Park <kyungmin.park@samsung.com>
   Overview:
    This is a device driver for the OneNAND flash for generic boards.
  Note: Driver name and platform data format have been updated!
  This version of the driver is named "onenand-flash" and takes struct
  onenand_platform_data as platform data. The old ARM-specific version
  with the name "onenand" used to take struct flash_platform_data.
 SPDX-License-Identifier: GPL-2.0-only
   OneNAND driver for OMAP2  OMAP3
   Copyright  2005-2006 Nokia Corporation
   Author: Jarkko Lavinen <jarkko.lavinen@nokia.com> and Juha Yrjl
   IRQ and DMA support written by Timo Teras
 continuous 
 Continue in wait for interrupt branch 
 Turn interrupts on 
 Add a delay to let GPIO settle 
 Timeout after 20ms 
					
					  The operation seems to be still going
					  so give it some more time.
 Turn interrupts off 
 Timeout after 20ms 
					
					  The operation seems to be still going
					  so give it some more time.
	
	  If the buffer address is not DMA-able, len is not long enough to
	  make DMA transfers profitable or if invoked from panic_write()
	  fallback to PIO mode.
	
	  If the buffer address is not DMA-able, len is not long enough to
	  make DMA transfers profitable or if invoked from panic_write()
	  fallback to PIO mode.
	 With certain content in the buffer RAM, the OMAP boot ROM code
	  can recognize the flash chip incorrectly. Zero it out before
	  soft reset.
 Just try again if this happens 
 40 MHz or lower 
 SPDX-License-Identifier: GPL-2.0
   Bad Block Table support for the OneNAND driver
   Copyright(c) 2005 Samsung Electronics
   Kyungmin Park <kyungmin.park@samsung.com>
   Derived from nand_bbt.c
   TODO:
     Split BBT core and chip specific BBT.
  check_short_pattern - [GENERIC] check if a pattern is in the buffer
  @buf:		the buffer to search
  @len:		the length of buffer to search
  @paglen:	the pagelength
  @td:		search pattern descriptor
  Check for a pattern at the given place. Used to search bad block
  tables and good  bad block identifiers. Same as check_pattern, but
  no optional empty check and the pattern is expected to start
  at offset 0.
 Compare the pattern 
  create_bbt - [GENERIC] Create a bad block table by scanning the device
  @mtd:		MTD device structure
  @buf:		temporary buffer
  @bd:		descriptor for the goodbad block search pattern
  @chip:		create the table for a specific chip, -1 read all chips.
               Applies only if NAND_BBT_PERCHIP option is set
  Create a bad block table by scanning the device
  for the given goodbad block identify pattern
 We need only read few bytes from the OOB area 
 chip == -1 case only 
	 Note that numblocks is 2  (real numblocks) here;
	  see i += 2 below as it makses shifting and masking less painful
			 No need to read pages fully,
 If it is a initial bad block, just ignore it 
  onenand_memory_bbt - [GENERIC] create a memory based bad block table
  @mtd:		MTD device structure
  @bd:		descriptor for the goodbad block search pattern
  The function creates a memory based bbt by scanning the device
  for manufacturer  software marked good  bad blocks
  onenand_isbad_bbt - [OneNAND Interface] Check if a block is bad
  @mtd:		MTD device structure
  @offs:		offset in the device
  @allowbbt:	allow access to bad block table region
 Get block number  2 
  onenand_scan_bbt - [OneNAND Interface] scan, find, read and maybe create bad block table(s)
  @mtd:		MTD device structure
  @bd:		descriptor for the goodbad block search pattern
  The function checks, if a bad block table(s) isare already
  available. If not it scans the device for manufacturer
  marked good  bad blocks and writes the bad block table(s) to
  the selected place.
  The bad block table memory is allocated here. It is freed
  by the onenand_release function.
 Allocate memory (2bit per block) and clear the memory bad block table 
 Set erase shift 
 Scan the device to build a memory based bad block table 
  Define some generic bad  good block scan pattern which are used
  while scanning a device for factory marked good  bad blocks.
  onenand_default_bbt - [OneNAND Interface] Select a default bad block table for the device
  @mtd:		MTD device structure
  This function selects the default bad block table
  support for the device and calls the onenand_scan_bbt function
 1KB page has same configuration as 2KB page 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2017 exceet electronics GmbH
  Authors:
 	Frieder Schrempf <frieder.schrempf@exceet.de>
 	Boris Brezillon <boris.brezillon@bootlin.com>
	
	  Make sure all dies are in buffer read mode and not continuous read
	  mode.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2016-2017 Micron Technology, Inc.
  Authors:
 	Peter Pan <peterpandong@micron.com>
  As per datasheet, die selection is done by the 6th bit of Die
  Select Register (Address 0xD0).
 Micron  MT29F2G01AAAED Device 
 Reserve 2 bytes for the BBM. 
 section 0 has two bytes reserved for the BBM 
 M79A 2Gb 3.3V 
 M79A 2Gb 1.8V 
 M78A 1Gb 3.3V 
 M78A 1Gb 1.8V 
 M79A 4Gb 3.3V 
 M70A 4Gb 3.3V 
 M70A 4Gb 1.8V 
 M70A 8Gb 3.3V 
 M70A 8Gb 1.8V 
 M69A 2Gb 3.3V 
	
	  M70A device series enable Continuous Read feature at Power-up,
	  which is not supported. Disable this bit to avoid any possible
	  failure.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 exceet electronics GmbH
  Copyright (c) 2018 Kontron Electronics GmbH
  Author: Frieder Schrempf <frieder.schrempf@kontron.de>
 Kioxia is new name of Toshiba memory. 
  Backward compatibility for 1st generation Serial NAND devices
  which don't support Quad Program Load operation.
 2 bytes reserved for BBM 
		
		  Let's try to retrieve the real maximum number of bitflips
		  in order to avoid forcing the wear-leveling layer to move
		  data around if it's not necessary.
 3.3V 1Gb (1st generation) 
 3.3V 2Gb (1st generation) 
 3.3V 4Gb (1st generation) 
 1.8V 1Gb (1st generation) 
 1.8V 2Gb (1st generation) 
 1.8V 4Gb (1st generation) 
	
	  2nd generation serial nand has HOLD_D which is equivalent to
	  QE_BIT.
 3.3V 1Gb (2nd generation) 
 3.3V 2Gb (2nd generation) 
 3.3V 4Gb (2nd generation) 
 3.3V 8Gb (2nd generation) 
 1.8V 1Gb (2nd generation) 
 1.8V 2Gb (2nd generation) 
 1.8V 4Gb (2nd generation) 
 1.8V 8Gb (2nd generation) 
 SPDX-License-Identifier: GPL-2.0
  Author:
 	Chuanhong Guo <gch981213@gmail.com>
 section 0 has one byte reserved for bad block mark 
 1-7 bits are flipped. return the maximum. 
 Reserve 1 bytes for the BBM. 
 Valid for Q4Q5 and Q6 (untested) devices 
		
		  Read status2 register to determine a more fine grained
		  bit error status
		
		  4 ... 7 bits are flipped (1..4 can't be detected, so
		  report the maximum of 4 in this case
 bits sorted this way (3...0): ECCS1,ECCS0,ECCSE1,ECCSE0 
		
		  Read status2 register to determine a more fine grained
		  bit error status
		
		  1 ... 4 bits are flipped (and corrected)
 bits sorted this way (1...0): ECCSE1, ECCSE0 
 (2 << 4) through (6 << 4) are 4-8 corrected errors 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 Jeff Kletsky
  Author: Jeff Kletsky <git-commits@allycomm.com>
 4 BBM + 2 user bytes 
 Return upper limit by convention 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2016-2017 Micron Technology, Inc.
  Authors:
 	Peter Pan <peterpandong@micron.com>
 	Boris Brezillon <boris.brezillon@bootlin.com>
  spinand_upd_cfg() - Update the configuration register
  @spinand: the spinand device
  @mask: the mask encoding the bits to update in the config reg
  @val: the new value to apply
  Update the configuration register.
  Return: 0 on success, a negative error code otherwise.
  spinand_select_target() - Select a specific NAND targetdie
  @spinand: the spinand device
  @target: the targetdie to select
  Select a new targetdie. If chip only has one die, this function is a NOOP.
  Return: 0 on success, a negative error code otherwise.
		
		  We use spinand_read_reg_op() instead of spinand_get_cfg()
		  here to bypass the config cache.
		
		  We have no way to know exactly how many bitflips have been
		  fixed, so let's return the maximum possible value so that
		  wear-leveling layers move the data immediately.
 Reserve 2 bytes for the BBM. 
 Only enable or disable the engine 
 Nothing to do when finishing a page write 
 Finish a page read: check the status, report errorsbitflips 
	
	  Looks like PROGRAM LOAD (AKA write cache) does not necessarily reset
	  the cache content to 0xFF (depends on vendor implementation), so we
	  must fill the page cache entirely even if we only want to program
	  the data portion of the page, otherwise we might corrupt the BBM or
	  user data previously programmed in OOB area.
	 
	  Only reset the data buffer manually, the OOB buffer is prepared by
	  ECC engines ->prepare_io_req() callback.
	
	  Extra read, just in case the STATUS_READY bit has changed
	  since our last check
 The plane number is passed in MSB just above the column address 
 Release manufacturer private data 
  spinand_match_and_init() - Try to find a match between a device ID and an
 			      entry in a spinand_info table
  @spinand: SPI NAND object
  @table: SPI NAND device description table
  @table_size: size of the device description table
  @rdid_method: read id method to match
  Match between a device ID retrieved through the READ_ID command and an
  entry in the SPI NAND description table. If a match is found, the spinand
  object will be initialized with information provided by the matching
  spinand_info entry.
  Return: 0 on success, a negative error code otherwise.
 After power up, all blocks are locked, so unlock them here. 
	
	  We need a scratch buffer because the spi_mem interface requires that
	  buf passed in spi_mem_op->data.buf be DMA-able.
	
	  Use kzalloc() instead of devm_kzalloc() here, because some drivers
	  may use this buffer for DMA access.
	  Memory allocated by devm_ does not guarantee DMA-safe alignment.
 SPI-NAND default ECC engine is on-die 
 Propagate ECC information to mtd_info 
 sentinel  },
 sentinel  },
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 Macronix
  Author: Boris Brezillon <boris.brezillon@bootlin.com>
		
		  Let's try to retrieve the real maximum number of bitflips
		  in order to avoid forcing the wear-leveling layer to move
		  data around if it's not necessary.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright  2007 Eugene Konev <ejka@openwrt.org>
  TI AR7 flash partition table.
  Based on ar7 map by Felix Fietkau <nbd@openwrt.org>
 Try 10 blocks starting from master->erasesize 
 SPDX-License-Identifier: GPL-2.0-or-later
  BCM63XX CFE image tag parser
  Copyright  2006-2008  Florian Fainelli <florian@openwrt.org>
 			  Mike Albon <malbon@openwrt.org>
  Copyright  2009-2010  Daniel Dickinson <openwrt@cshore.neomailbox.net>
  Copyright  2011-2013  Jonas Gorski <jonas.gorski@gmail.com>
 CONFIG_MIPS 
 always at least 64KiB 
 Ensure strings read from flash structs are null terminated 
 CONFIG_MIPS 
 extract nvram data 
 Start building partition list 
 Global partition "linux" to make easy firmware upgrade 
 SPDX-License-Identifier: GPL-2.0-or-later
  BCM63XX CFE image tag parser
  Copyright  2006-2008  Florian Fainelli <florian@openwrt.org>
 			  Mike Albon <malbon@openwrt.org>
  Copyright  2009-2010  Daniel Dickinson <openwrt@cshore.neomailbox.net>
  Copyright  2011-2013  Jonas Gorski <jonas.gorski@gmail.com>
 Ensure strings read from flash structs are null terminated 
 CFE, NVRAM and global Linux are always present 
 Get the tag 
		
		  Addresses are flash absolute, so convert to partition
		  relative addresses. Assume either kernel or rootfs will
		  directly follow the image tag.
 default Broadcom layout 
 OpenWrt layout 
 Determine number of partitions 
 Start building partition list 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2021 Rafa Miecki <rafal@milecki.pl>
 Check CFE environment variable 
 SPDX-License-Identifier: GPL-2.0-only
  BCM47XX MTD partitioning
  Copyright  2012 Rafa Miecki <zajec5@gmail.com>
  NAND flash on Netgear R6250 was verified to contain 15 partitions.
  This will result in allocating too big array for some old devices, but the
  memory will be freed soon anyway (see mtd_device_parse_register).
  Amount of bytes we read when analyzing each block of flash memory.
  Set it big enough to allow detecting partition and reading important data.
 Magics 
 MPFR 
 1EFC 
 FCTY 
 FLSH 
 POTT 
 OP 
 shsq (weird ZTE H218N endianness) 
  bcm47xxpart_bootpartition - gets index of TRX partition used by bootloader
  Some devices may have more than one TRX partition. In such case one of them
  is the main one and another a failsafe one. Bootloader may fallback to the
  failsafe firmware if it detects corruption of the main image.
  This function provides info about currently used TRX partition. It's the one
  containing kernel started by the bootloader.
 Check CFE environment variable 
 Array with indexes of TRX partitions 
 Number of found TRX partitions 
	
	  Some really old flashes (like AT45DB) had smaller erasesize-s, but
	  partitions were aligned to at least 0x1000 anyway.
 Alloc 
 Parse block by block looking for magics 
 Nothing more in higher memory on BCM47XX (MIPS) 
 Read beginning of the block 
 Magic or small NVRAM at 0x400 
		
		  board_data starts with board_id which differs across boards,
		  but we can use 'MPFR' (hopefully) magic at 0x100
 Found on Huawei E970 
 POT(TOP) 
 ML 
 TRX 
			
			  Try to find TRX size. The "length" field isn't fully
			  reliable as it could be decreased to make CRC32 cover
			  only part of TRX data. It's commonly used as checksum
			  can't cover e.g. ever-changing rootfs partition.
			  Use offsets as helpers for assuming min TRX size.
			
			  Skip the TRX data. Decrease offset by block size as
			  the next loop iteration will increase it.
 Squashfs on devices not using TRX 
		
		  New (ARM?) devices may have NVRAM in some middle block. Last
		  block will be checked later, so skip it.
 Read middle of the block 
 Some devices (ex. WNDR3700v3) don't have a standard 'MPFR' 
 Look for NVRAM at the end of the last block. 
 Standard NVRAM 
	
	  Assume that partitions end at the beginning of the one they are
	  followed by.
 If there was TRX parse it now 
 SPDX-License-Identifier: GPL-2.0-or-later
  Read flash partition table from command line
  Copyright  2002      SYSGO Real-Time Solutions GmbH
  Copyright  2002-2010 David Woodhouse <dwmw2@infradead.org>
  The format for the command line is as follows:
  mtdparts=<mtddef>[;<mtddef]
  <mtddef>  := <mtd-id>:<partdef>[,<partdef>]
  <partdef> := <size>[@<offset>][<name>][ro][lk][slc]
  <mtd-id>  := unique name used in mapping driverdevice (mtd->name)
  <size>    := standard linux memsize OR "-" to denote all remaining space
               size is automatically truncated at end of device
               if specified or truncated size is 0 the part is skipped
  <offset>  := standard linux memsize
               if omitted the part will immediately follow the previous part
               or 0 if the first part
  <name>    := '(' NAME ')'
               NAME will appear in procmtd
  <size> and <offset> can be specified such that the parts are out of order
  in physical memory and may even overlap.
  The parts are assigned MTD numbers in the order they are specified in the
  command line regardless of their order in physical memory.
  Examples:
  1 NOR Flash, with 1 single writable partition:
  edb7312-nor:-
  1 NOR Flash with 2 partitions, 1 NAND with one
  edb7312-nor:256k(ARMboot)ro,-(root);edb7312-nand:-(home)
 debug macro 
 special size referring to all the remaining space in a partition 
 mtdpart_setup() parses into here 
 the command line passed to mtdpart_setup() 
  Parse one partition definition for an MTD. Since there can be many
  comma separated partition definitions, this function calls itself
  recursively until no more partition definitions are found. Nice side
  effect: the memory to keep the mtd_partition structs and the names
  is allocated upon the last definition being found. At that point the
  syntax has been verified ok.
 fetch the partition size 
 assign all remaining space to this partition 
 fetch partition name and flags 
 this is going to be a regular partition 
 check for offset 
 now look for name 
 Partition_000 
 record name length for memory allocation later 
 test for options 
 if lk is found do NOT unlock the MTD partition
 if slc is found use emulated SLC mode on this partition
 test if more partitions are following 
 more partitions follow, parse them 
 this is the last partition: allocate space for all 
	
	  enter this partition (offset will be calculated later if it is
	  OFFSET_CONTINUOUS at this point)
 return (updated) pointer to extra_mem memory 
 return (updated) pointer command line string 
 return partition table 
  Parse the command line.
		
		  Replace the first ';' by a NULL char so strrchr can work
		  properly.
		
		  make sure that part-names with ":" will not be handled as
		  part of the mtd-id with an ":"
		
		  fetch <mtd-id>. We use strrchr to ignore all ':' that could
		  be present in the MTD name, only the last one is interpreted
		  as an <mtd-id><part-definition> separator.
 Restore the '(' now. 
 Restore the ';' now. 
		
		  parse one mtd. have it reserve memory for the
		  struct cmdline_mtd_partition and the mtd-id string.
 cmdline 
 out: updated cmdline ptr 
 out: number of parts 
 first partition 
 out: extra mem 
alignment);
			
			  An error occurred. We're either:
			  a) out of memory, or
			  b) in the middle of the partition spec
			  Either way, this mtd is hosed and we're
			  unlikely to succeed in parsing any more
 align this_mtd 
 enter results 
 link into chain 
 EOS - we're done 
 does another spec follow? 
  Main function to be called from the MTD mapping driverdevice to
  obtain the partitioning information. At this point the command line
  arguments will actually be parsed and turned to struct mtd_partition
  information. It returns partitions for the requested mtd device, or
  the first one in the chain if a NULL mtd_id is passed in.
 parse command line 
	
	  Search for the partition definition matching master->name.
	  If master->name is not set, stop at first partition definition.
  This is the handler for our kernel parameter, called from
  main.c::checksetup(). Note that we can not yet kmalloc() anything,
  so we only save the commandline for later processing.
  This function needs to be visible for bootloaders.
 SPDX-License-Identifier: GPL-2.0-or-later
  Flash partitions described by the OF (or flattened) device tree
  Copyright  2006 MontaVista Software Inc.
  Author: Vitaly Wool <vwool@ru.mvista.com>
  Revised to handle newer style flash binding by:
    Copyright  2007 David Gibson, IBM Corporation.
 Pull of_node from the master device node 
 Master 
			
			  We might get here even when ofpart isn't used at all (e.g.,
			  when using another parser), so don't be louder than
			  KERN_DEBUG
 Partition 
 The 'partitions' subnode might be used by another parser 
 First count the subnodes 
 Generic 
 Customized 
 Pull of_node from the master device node 
 No partitions found 
 bit 0 set signifies read only partition 
  When MTD core cannot find the requested parser, it tries to load the module
  with the same name. Since we provide the ofoldpart parser, we should have
  the corresponding alias.
 SPDX-License-Identifier: GPL-2.0-only
  Parser for TRX format partitions
  Copyright (C) 2012 - 2017 Rafa Miecki <rafal@milecki.pl>
 Magics 
 UBI# 
 Get different magic from device tree if specified 
 We have LZMA loader if there is address in offset[2] 
	
	  Assume that every partition ends at the beginning of the one it is
	  followed by.
 SPDX-License-Identifier: GPL-2.0-or-later
  Parse RedBoot-style Flash Image System (FIS) tables and
  produce a Linux partition array to match.
  Copyright  2001      Red Hat UK Limited
  Copyright  2001-2010 David Woodhouse <dwmw2@infradead.org>
 Null terminated name
 Address within FLASH of image
 Address in memory where it executes
 Length of image
 Execution entry point
 Length of actual data
 Checksum over image descriptor
 Checksum over image data
 RedBoot doesn't actually write the desc_cksum field yet AFAICT 
	
	  Assign the block found in the device tree to the local
	  directory block pointer.
			 This is apparently the FIS directory entry for the
			  FIS directory itself.  The FIS directory size is
			  one erase block; if the buf[i].size field is
			  swab32(erasesize) then we know we are looking at
			  a byte swapped FIS directory - swap all the entries!
			  (NOTE: this is 'size' not 'data_length'; size is
			  the full size of the entry.)
			 RedBoot can combine the FIS directory and
			   config partitions into a single eraseblock;
			   we assume wrong-endian if either the swapped
			   'size' matches the eraseblock size precisely,
			   or if the swapped size actually fits in an
 Update numslots based on actual FIS directory size 
					 A single 0xff denotes a deleted entry.
					  Two of them in a row is the end of the table.
					 The unsigned long fields were written with the
					  wrong byte sex, name and pad have no byte sex.
 Update numslots based on actual FIS directory size 
 Didn't find it 
		 I'm sure the JFFS2 code has done me permanent damage.
		  I now think the following is _normal_
 mtd parsers will request the module by parser name 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2021 Rafa Miecki <rafal@milecki.pl>
  sharpslpart.c - MTD partition parser for NAND flash using the SHARP FTL
  for logical addressing, as used on the PXA models of the SHARP SL Series.
  Copyright (C) 2017 Andrea Adami <andrea.adami@gmail.com>
  Based on SHARP GPL 2.4 sources:
    http:support.ezaurus.comdevelopersourcesource_dl.asp
      driversmtdnandsharp_sl_logical.c
      linuxincludeasm-armsharp_nand_logical.h
  Copyright (C) 2002 SHARP
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 oob structure 
 factory defaults 
  struct sharpsl_ftl - Sharp FTL Logical Table
  @logmax:		number of logical blocks
  @log2phy:		the logical-to-physical table
  Structure containing the logical-to-physical translation table
  used by the SHARP SL FTL.
 verify that the OOB bytes 8 to 15 are free and available for the FTL 
  The logical block number assigned to a physical block is stored in the OOB
  of the first page, in 3 16-bit copies with the following layout:
  01234567 89abcdef
  -------- --------
  ECC BB   xyxyxy
  When reading we check that the first two copies agree.
  In case of error, matching is tried using the following pairs.
  Reserved values 0xffff mean the block is kept for wear leveling.
  01234567 89abcdef
  -------- --------
  ECC BB   xyxy    oob[8]==oob[10] && oob[9]==oob[11]   -> byte0=8   byte1=9
  ECC BB     xyxy  oob[10]==oob[12] && oob[11]==oob[13] -> byte0=10  byte1=11
  ECC BB   xy  xy  oob[12]==oob[8] && oob[13]==oob[9]   -> byte0=12  byte1=13
 parity check 
 reserved 
 FTL reserves 5% of the blocks + 1 spare  
 initialize ftl->log2phy 
 create physical-logical table 
 get logical block 
 cut-off errors and skip the out-of-range values 
 Ignore corrected ECC errors 
  MTD Partition Parser
  Sample values read from SL-C860
  # cat procmtd
  dev:    size   erasesize  name
  mtd0: 006d0000 00020000 "Filesystem"
  mtd1: 00700000 00004000 "smf"
  mtd2: 03500000 00004000 "root"
  mtd3: 04400000 00004000 "home"
  PARTITIONINFO1
  0x00060000: 00 00 00 00 00 00 70 00 42 4f 4f 54 00 00 00 00  ......p.BOOT....
  0x00060010: 00 00 70 00 00 00 c0 03 46 53 52 4f 00 00 00 00  ..p.....FSRO....
  0x00060020: 00 00 c0 03 00 00 00 04 46 53 52 57 00 00 00 00  ........FSRW....
 check for magics 
 fixup for hardcoded value 64 MiB (for older models) 
 extra sanity check 
 check that OOB bytes 8 to 15 used by the FTL are actually free 
 init logical mgmt (FTL) 
 read and validate first partition table 
 fallback: read second partition table 
 cleanup logical mgmt (FTL) 
 original names 
 SPDX-License-Identifier: GPL-2.0-only
  Qualcomm SMEM NAND flash partition parser
  Copyright (C) 2020, Linaro Ltd.
  struct smem_flash_pentry - SMEM Flash partition entry
  @name: Name of the partition
  @offset: Offset in blocks
  @length: Length of the partition in blocks
  @attr: Flags for this partition
  struct smem_flash_ptable - SMEM Flash partition table
  @magic1: Partition table Magic 1
  @magic2: Partition table Magic 2
  @version: Partition table version
  @numparts: Number of partitions in this ptable
  @pentry: Flash partition entries belonging to this ptable
 Verify ptable magic 
 Ensure that # of partitions is less than the max we have allocated 
 Find out length of partition data based on table version 
	
	  Now that the partition table header has been parsed, verified
	  and the length of the partition table calculated, read the
	  complete partition table
 Convert name to lower case 
 SPDX-License-Identifier: GPL-2.0-or-later
======================================================================
    driversmtdafs.c: ARM Flash LayoutPartitioning
    Copyright  2000 ARM Limited
    Copyright (C) 2019 Linus Walleij
   This is access code for flashes using ARM's flash partitioning
   standards.
 "FLSH" 
 "FOOT" 
 Address of first word of ImageFooter  
 Start of area reserved by this footer 
 'Magic' number proves it's a footer   
 Area type: ARM Image, SIB, customer   
 Just this structure                   
 Boot flags, compression etc.          
 Unique number, selects for boot etc.  
 Address program should be loaded to   
 Actual size of image                  
 Image is executed from here           
 Null terminated                       
 Flash Address of any stripped header  
 Length of header in memory            
 AIF, RLF, s-record etc.               
 Image checksum (inc. this struct)     
 The magic is 12 bytes from the end of the erase block 
 The magic is the 8 last bytes of the erase block 
	
	  Static checks cannot see that we bail out if we have an error
	  reading the footer.
	
	  This is the address mask; we use this to mask off out of
	  range address bits.
	
	  Check the checksum.
	
	  Hide the SIB (System Information Block)
	
	  Check the image info base.  This can not
	  be located after the footer structure.
	
	  Check the start of this image.  The image
	  data can not be located after this block.
 Read the image info block 
	
	  Validate the name - it must be NUL terminated.
 First read the footer 
 Then read the image information 
 32bit platforms have 4 bytes padding 
 64bit platforms have 8 bytes padding 
 Align partition to end of erase block 
 Create one partition per region 
 Count the partitions by looping over all erase blocks 
	
	  Identify the partitions
  pcmciamtd.c - MTD driver for PCMCIA flash memory cards
  Author: Simon Evans <spse@secret.org.uk>
  Copyright (C) 2002 Simon Evans
  Licence: GPL
 Size of the PCMCIA address space: 26 bits = 64 MB 
 ioremapped address of PCMCIA window 
 size of window 
 offset into card the window currently points at 
 Module parameters 
 2 = do 16-bit transfers, 1 = do 8-bit transfers 
 Speed of memory accesses, in ns 
 Force the size of an SRAM card 
 Force Vpp 
 Set Vpp 
 Force card to be treated as FLASH, ROM or RAM 
 readwrite{8,16} copy_{from,to} routines with window remapping
  to access whole card
 readwrite{8,16} copy_{from,to} routines with direct access 
 first nested 'on' 
 last nested 'off' 
 Shut up, gcc 
 from here on: DEBUG only 
 from here on: DEBUG only 
	 Request a memory window for PCMCIA. Some architeures can map windows
	  up to the maximum that PCMCIA can support (64MiB) - this is ideal and
	  we aim for a window the size of the whole card - otherwise we try
	  smaller windows until we succeed
 Get write protect status 
		 Since we are using a default name, make it better by adding
		  in the size
 <1MiB in size, show size in KiB 
	 If the memory found is fits completely into the mapped PCMCIA window,
 get_lock(link); 
 free_lock(link); 
 Create new memory card device 
 the following was commented out in pcmcia-cs-3.2.7 
 PCMCIA_DEVICE_PROD_ID12("RATOC Systems,Inc.", "SmartMedia ADAPTER PC Card", 0xf4a2fefe, 0x5885b2ae), 
 SPDX-License-Identifier: GPL-2.0-only
       nettel.c -- mappings for NETtelSecureEdgeSnapGear (x86) boards.
       (C) Copyright 2000-2001, Greg Ungerer (gerg@snapgear.com)
       (C) Copyright 2001-2002, SnapGear (www.snapgear.com)
 	PAR masks and shifts, assuming 64K pages.
 Cache disabled, 64K page 
 	Set the Intel flash back to read mode since some old boot
 	loaders don't.
 Make sure all FLASH chips are put back into read mode 
 Set CPU clock to be 33.000MHz 
	
	 	Save the CS settings then ensure ROMCS1 and ROMCS2 are off,
	 	otherwise they might clash with where we try to map BOOTCS.
	
	 	The first thing to do is determine if we have a separate
	 	boot FLASH device. Typically this is a small (1 to 2MB)
	 	AMD FLASH part. It seems that device size is about the
	 	only way to tell if this is the case...
 The high BIOS partition is only present for 2MB units 
 Don't add the partition until after the primary INTEL's 
		
		 	Map the Intel flash into memory after the AMD
		 	It has to start on a multiple of maxsize.
 INTEL boot FLASH 
 Kernel base is on ROMCS1, not BOOTCS 
 Destroy useless AMD MTD mapping 
 Only AMD flash supported 
	
	 	We have determined the INTEL FLASH configuration, so lets
	 	go ahead and probe for them now.
 Set PAR to the maximum size 
 Turn other PAR off so the first probe doesn't find it 
 Probe for the size of the first Intel flash 
 Set PAR to the detected size 
	
	 	Map second Intel FLASH right after first. Set its size to the
	 	same maxsize used for the first Intel FLASH.
 Delete the old map and probe again to do both chips 
		
		 	Adjust offset and size of last boot partition.
		 	Must allow for BIOS region at end of FLASH.
 No BIOS regions when AMD boot 
 SPDX-License-Identifier: GPL-2.0-only
  ck804xrom.c
  Normal mappings of chips in physical memory
  Dave Olsen <dolsen@lnxi.com>
  Ryan Jackson <rjackson@lnxi.com>
  The following applies to ck804 only:
  The 2 bits controlling the window size are often set to allow reading
  the BIOS, but too small to allow writing, since the lock registers are
  4MiB lower in the address space than the data.
  This is intended to prevent flashing the bios, perhaps accidentally.
  This parameter allows the normal driver to override the BIOS settings.
  The bits are 6 and 7.  If both bits are set, it is a 5MiB window.
  If only the 7 Bit is set, it is a 4MiB window.  Otherwise, a
  64KiB window.
  The following applies to mcp55 only:
  The 15 bits controlling the window size are distributed as follows: 
  byte @0x88: bit 0..7
  byte @0x8c: bit 8..15
  word @0x90: bit 16..30
  If all bits are enabled, we have a 16? MiB window
  Please set win_size_bits to 0x7fffffff if you actually want to do something
 Disable writes through the rom window 
 Free all of the mtd devices 
 Remember the pci dev I find the window in 
		 Enable the selected rom window.  This is often incorrectly
		  set up by the BIOS, and the 4MiB offset for the lock registers
		  requires the full 5MiB of window space.
		 
		  This 'write, then read' approach leaves the bits for
		  other uses of the hardware info.
 Assume the rom window is properly setup, and find it's size 
 5MiB 
 4MiB 
 64KiB 
 16MiB, hardcoded for now 
	
	  Try to reserve the window mem region.  If this fails then
	  it is likely due to a fragment of the window being
	  "reserved" by the BIOS.  In the case that the
	  request_mem_region() fails then once the rom size is
	  discovered we will try to reserve the unreserved fragment.
 Enable writes through the rom window 
 FIXME handle registers 0x80 - 0x8C the bios region locks 
 For write accesses caches are useless 
 Get the first address to look for a rom chip at 
	 The probe sequence run over the firmware hub lock
	  registers sets them to 0x7 (no access).
	  Probe at most the last 4MiB of the address space.
	 Loop  through and look for rom chips.  Since we don't know the
	  starting address for each chip, probe every ROM_PROBE_STEP_SIZE
	  bytes from the starting address of the window.
 Set the name of the map to the address I am trying 
 There is no generic VPP support 
 Skip bankwidths that are not supported 
 Setup the map methods 
 Try all of the probe methods 
 Trim the size if we are larger than the map 
			
			  Registering the MTD device in iomem may not be possible
			  if there is a BIOS "reserved" and BUSY range.  If this
			  fails then continue anyway.
 Make the whole region visible in the map 
 Now that the mtd devices is complete claim and export it 
 Calculate the new value of map_top 
 File away the map structure 
 Free any left over map structures 
 See if I have any map structures 
 SPDX-License-Identifier: GPL-2.0-only
  BIOS Flash chip on Intel 440GX board.
  Bugs this currently does not work under linuxBIOS.
 Is this really the vpp port? 
 first nested 'on' 
 last nested 'off' 
	 FIXME verify that this is the
	  appripriate code for vpp enabledisable
	 Setup the pm iobase resource
	  This code should move into some kind of generic bridge
	  driver but for the moment I'm content with getting the
	  allocation correct.
 Put the current value in the resource 
 Allocate the resource region 
 Set the iobase 
 Set XBCS# 
 Supply write voltage to the chip 
 Enable the gate on the WE line 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2020 BAIKAL ELECTRONICS, JSC
  Authors:
    Serge Semin <Sergey.Semin@baikalelectronics.ru>
  Baikal-T1 Physically Mapped Internal ROM driver
  Baikal-T1 SoC ROMs are only accessible by the dword-aligned instructions.
  We have to take this into account when implementing the data read-methods.
  Note there is no need in bothering with endianness, since both Baikal-T1
  CPU and MMIO are LE.
 Read data within offset dword. 
 Read data from the next dword. 
 Make sure we don't go over the map limit. 
	
	  Since requested data size can be pretty big we have to implement
	  the copy procedure as optimal as possible. That's why it's split
	  up into the next three stages: unaligned head, aligned body,
	  unaligned tail.
 It's supposed to be read-only MTD. 
 Multiplatform guard. 
 Sanity check the device parameters retrieved from DTB. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Versatile OF physmap driver add-on
  Copyright (c) 2016, Linaro Limited
  Author: Linus Walleij <linus.walleij@linaro.org>
  Flash protection handling for the IntegratorAP
 The manual says bit 2, the code says bit 3, trust the code 
 Look up the EBI 
 Clear VPP and write protection bits 
 Unlock the EBI 
 Enable write cycles on the EBI, CSR1 (flash) 
 Lock the EBI again 
  Flash protection handling for the IntegratorCP
  Flash protection handling for the Versatiles and RealViews
 Not all flash chips use this protection line 
 For first chip probed, look up the syscon regmap 
 SPDX-License-Identifier: GPL-2.0-only
  Out-of-line map IO functions for simple maps when CONFIG_COMPLEX_MAPPINGS
  is enabled.
   Copyright  2001 Flaga hf. Medical Devices, Kri Davsson <kd@flaga.is>
   This program is free software; you can redistribute  it andor modify it
   under  the terms of  the GNU General  Public License as published by the
   Free Software Foundation;  either version 2 of the  License, or (at your
   option) any later version.
   THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
   WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   You should have received a copy of the  GNU General Public License along
   with this program; if not, write  to the Free Software Foundation, Inc.,
   675 Mass Ave, Cambridge, MA 02139, USA.
 We split the flash chip up into four parts.
  1: bootloader first 128k			(0x00000000 - 0x0001FFFF) size 0x020000
  2: kernel 640k					(0x00020000 - 0x000BFFFF) size 0x0A0000
  3: compressed 1536k root ramdisk	(0x000C0000 - 0x0023FFFF) size 0x180000
  4: writeable diskpartition (jffs)(0x00240000 - 0x003FFFFF) size 0x1C0000
 SPDX-License-Identifier: GPL-2.0
  Intel IXP4xx OF physmap add-on
  Copyright (C) 2019 Linus Walleij <linus.walleij@linaro.org>
  Based on the ixp4xx.c map driver, originally written by:
  Intel Corporation
  Deepak Saxena <dsaxena@mvista.com>
  Copyright (C) 2002 Intel Corporation
  Copyright (C) 2003-2004 MontaVista Software, Inc.
  Readwrite a 16 bit word from flash address 'addr'.
  When the cpu is in little-endian mode it swizzles the address lines
  ('address coherency') so we need to undo the swizzling to ensure commands
  and the like end up on the correct flash address.
  To further complicate matters, due to the way the expansion bus controller
  handles 32 bit reads, the byte stream ABCD is stored on the flash as:
      D15    D0
      +---+---+
      | A | B | 0
      +---+---+
      | C | D | 2
      +---+---+
  This means that on LE systems each 16 bit word must be swapped. Note that
  this requires CONFIG_MTD_CFI_BE_BYTE_SWAP to be enabled to 'unswap' the CFI
  data and other flash commands which are always in D7-D0.
  The IXP4xx expansion bus only allows 16-bit wide acceses
  when attached to a 16-bit wide device (such as the 28F128J3A),
  so we can't just memcpy_fromio().
 Multiplatform guard 
 SPDX-License-Identifier: GPL-2.0-only
  ichxrom.c
  Normal mappings of chips in physical memory
 64KiB 
 Disable writes through the rom window 
 Free all of the mtd devices 
	 For now I just handle the ichx and I assume there
	  are not a lot of resources up at the top of the address
	  space.  It is possible to handle other devices in the
	  top 16MB but it is very painful.  Also since
	  you can only really attach a FWH to an ICHX there
	  a number of simplifications you can make.
	 
	  Also you can page firmware hubs if an 8MB window isn't enough
	  but don't currently handle that case either.
 Find a region continuous to the end of the ROM window  
 Enable writes through the rom window 
		 The BIOS will generate an error if I enable
		  this device, so don't even try.
	
	  Try to reserve the window mem region.  If this fails then
	  it is likely due to the window being "reserved" by the BIOS.
 Map the firmware hub into my address space. 
 Get the first address to look for an rom chip at 
	 The probe sequence run over the firmware hub lock
	  registers sets them to 0x7 (no access).
	  Probe at most the last 4M of the address space.
 Loop through and look for rom chips 
 Set the name of the map to the address I am trying 
		 Firmware hubs only use vpp when being programmed
		  in a factory setting.  So in-place programming
		  needs to use a different method.
 Skip bankwidths that are not supported 
 Setup the map methods 
 Try all of the probe methods 
 Trim the size if we are larger than the map 
			
			  Registering the MTD device in iomem may not be possible
			  if there is a BIOS "reserved" and BUSY range.  If this
			  fails then continue anyway.
 Make the whole region visible in the map 
 Now that the mtd devices is complete claim and export it 
 Calculate the new value of map_top 
 File away the map structure 
 Free any left over map structures 
 See if I have any map structures 
 SPDX-License-Identifier: GPL-2.0-only
  rbtx4939-flash (based on physmap.c)
  This is a simplified physmap driver with map_init callback function.
  Copyright (C) 2009 Atsushi Nemoto <anemo@mba.ocn.ne.jp>
 SPDX-License-Identifier: GPL-2.0-only
   linuxdriversmtdmapspci.c
   Copyright (C) 2001 Russell King, All rights reserved.
  Generic PCI memory map driver.  We support the following boards:
   - Intel IQ80310 ATU.
   - Intel EBSA285 (blank rom programming mode). Tested working 27092001
  Intel IOP80310 Flash driver
	
	  We want to base the memory window at Xscale
	  bus address 0, not 0x1000.
	
	  This mundges the flash location so we avoid
	  the first 80 bytes (they appear to read nonsense).
  Intel DC21285 driver
		
		  No ROM resource
		
		  We need to re-allocate PCI BAR2 address range to the
		  PCI ROM BAR, and disable PCI BAR2.
		
		  Hmm, if an address was allocated to the ROM resource, but
		  not enabled, should we be allocating a new resource for it
		  or simply enabling it?
	
	  We need to undo the PCI BAR2PCI ROM BAR address alteration.
  PCI device ID table
 DC21285 defaults to 0 on reset 
 DC21285 defaults to 0 on reset 
  Generic code follows.
  Flash and EPROM on Hitachi Solution Engine and similar boards.
  (C) 2001 Red Hat, Inc.
  GPL'd
 First probe at offset 0 
 Not there. Try swapping 
 Eep. 
 SPDX-License-Identifier: GPL-2.0-only
  amd76xrom.c
  Normal mappings of chips in physical memory
 64KiB 
 The 2 bits controlling the window size are often set to allow reading
  the BIOS, but too small to allow writing, since the lock registers are
  4MiB lower in the address space than the data.
  This is intended to prevent flashing the bios, perhaps accidentally.
  This parameter allows the normal driver to over-ride the BIOS settings.
  The bits are 6 and 7.  If both bits are set, it is a 5MiB window.
  If only the 7 Bit is set, it is a 4MiB window.  Otherwise, a
  64KiB window.
 Disable writes through the rom window 
 Free all of the mtd devices 
 Remember the pci dev I find the window in - already have a ref 
	 Enable the selected rom window.  This is often incorrectly
	  set up by the BIOS, and the 4MiB offset for the lock registers
	  requires the full 5MiB of window space.
	 
	  This 'write, then read' approach leaves the bits for
	  other uses of the hardware info.
 Assume the rom window is properly setup, and find it's size 
 5MiB 
 4MiB 
 64KiB 
	
	  Try to reserve the window mem region.  If this fails then
	  it is likely due to a fragment of the window being
	  "reserved" by the BIOS.  In the case that the
	  request_mem_region() fails then once the rom size is
	  discovered we will try to reserve the unreserved fragment.
 Enable writes through the rom window 
 FIXME handle registers 0x80 - 0x8C the bios region locks 
 For write accesses caches are useless 
 Get the first address to look for an rom chip at 
	 The probe sequence run over the firmware hub lock
	  registers sets them to 0x7 (no access).
	  Probe at most the last 4M of the address space.
 Loop  through and look for rom chips 
 Set the name of the map to the address I am trying 
 There is no generic VPP support 
 Skip bankwidths that are not supported 
 Setup the map methods 
 Try all of the probe methods 
 Trim the size if we are larger than the map 
			
			  Registering the MTD device in iomem may not be possible
			  if there is a BIOS "reserved" and BUSY range.  If this
			  fails then continue anyway.
 Make the whole region visible in the map 
 Now that the mtd devices is complete claim and export it 
 Calculate the new value of map_top 
 File away the map structure 
 Free any left over map structures 
 See if I have any map structures 
 amd8111 support 
 SPDX-License-Identifier: GPL-2.0+
  Normal mappings of chips in physical memory
  Copyright (C) 2003 MontaVista Software Inc.
  Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
  031022 - [jsun] add run-time configure and partition setup
  Device tree support:
     Copyright (C) 2006 MontaVista Software Inc.
     Author: Vitaly Wool <vwool@ru.mvista.com>
     Revised to handle newer style flash binding by:
     Copyright (C) 2007 David Gibson, IBM Corporation.
  GPIO address extension:
     Handle the case where a flash device is mostly addressed using physical
     line and supplemented by GPIOs.  This way you can hook up say a 8MiB flash
     to a 2MiB memory range and use the GPIOs to select a particular range.
     Copyright  2000 Nicolas Pitre <nico@cam.org>
     Copyright  2005-2009 Analog Devices Inc.
 first nested 'on' 
 last nested 'off' 
		
		  FIXME: JEDEC chips can't be safely and reliably
		  probed, although the mtd code gets it right in
		  practice most of the time.  We should use the
		  vendor and device ids specified by the binding to
		  bypass the heuristic probe code, but the mtd layer
		  provides, at present, no interface for doing so
		  :(.
 sentinel  },
		
		  On some platforms (e.g. MPC5200) a direct 1:1 mapping
		  may cause problems with JFFS2 usage, as the local bus (LPB)
		  doesn't support unaligned accesses as implemented in the
		  JFFS2 code via memcpy(). By setting NO_XIP, the
		  flash will not be exposed directly to the MTD users
		  (e.g. JFFS2) any more.
 IS_ENABLED(CONFIG_MTD_PHYSMAP_OF) 
 IS_ENABLED(CONFIG_MTD_PHYSMAP_OF) 
		
		  Only use the simple_map implementation if map hooks are not
		  implemented. Since map->read() is mandatory checking for its
		  presence is enough.
		
		  We detected multiple devices. Concatenate them together.
 legacy platform drivers can't hotplug or coldplg 
 work with hotplug and coldplug 
 	uclinux.c -- generic memory mapped MTD driver for uclinux
 	(C) Copyright 2002, Greg Ungerer (gerg@snapgear.com)
       License: GPL
	
	  The filesystem is guaranteed to be in direct mapped memory. It is
	  directly following the kernels own bss region. Following the same
	  mechanism used by architectures setting up traditional initrds we
	  use phys_to_virt to get the virtual address of its start.
 SPDX-License-Identifier: GPL-2.0-only
   Copyright (C) 2004 Liu Peng Infineon IFAP DC COM CPE
   Copyright (C) 2010 John Crispin <john@phrozen.org>
  The NOR flash is connected to the same external bus unit (EBU) as PCI.
  To make PCI work we need to enable the endianness swapping for the address
  written to the EBU. This endianness swapping works for PCI correctly but
  fails for attached NOR devices. To workaround this we need to use a complex
  map. The workaround involves swapping all addresses whilst probing the chip.
  Once probing is complete we stop swapping the addresses but swizzle the
  unlock addresses to ensure that access to the NOR device works correctly.
  The following 2 functions copy data between iomem and a cached memory
  section. As memcpy() makes use of pre-fetching we cannot use it here.
  The normal alternative of using memcpy_{to,from}io also makes use of
  memcpy() on MIPS so it is not applicable either. We are therefore stuck
  with having to use our own loop.
 SPDX-License-Identifier: GPL-2.0-or-later
 driversmtdmapsplat-ram.c
  (c) 2004-2005 Simtec Electronics
 	http:www.simtec.co.ukproductsSWLINUX
 	Ben Dooks <ben@simtec.co.uk>
  Generic platform device based RAM map
 private structure for each mtd platform ram device created 
 to_platram_info()
  device private data to struct platram_info conversion
 platram_setrw
  call the platform device's set rwro control
  to = 0 => read-only
     = 1 => read-write
 platram_remove
  called to remove the device from the driver's control
 ensure ram is left read-only 
 platram_probe
  called from device drive system when a device matching our
  driver is found.
 get the resource for the memory mapping 
 setup map parameters 
	 probe for the right mtd map driver
 fallback to map_ram 
	 check to see if there are any available partitions, or whether
 add the whole device. 
 device driver info 
 work with hotplug and coldplug 
 SPDX-License-Identifier: GPL-2.0-or-later
  ts5500_flash.c -- MTD map driver for Technology Systems TS-5500 board
  Copyright (C) 2004 Sean Young <sean@mess.org>
  Note:
  - In order for detection to work, jumper 3 must be set.
  - Drive A and B use the resident flash disk (RFD) flash translation layer.
  - If you have created your own jffs file system and the bios overwrites
    it during boot, try disabling Drive A: and B: in the boot order.
 SPDX-License-Identifier: GPL-2.0-only
  Flash memory access on SA11x0 based devices
  (C) 2000 Nicolas Pitre <nico@fluxnic.net>
 first nested 'on' 
 last nested 'off' 
	
	  Retrieve the bankwidth from the MSC registers.
	  We currently only implement CS0 and CS1 here.
	
	  Now let's probe for the actual flash.  Do it here since
	  specific machine settings might have been set above.
	
	  Count number of devices.
	
	  Allocate the map_info structs in one go.
	
	  Claim and then map the memory regions.
	
	  ENXIO is special.  It means we didn't find a chip when we probed.
	
	  If we found one device, don't bother with concat support.  If
	  we found multiple devices, use concat if we have it available,
	  otherwise fail.  Either way, it'll be called "sa1100".
		
		  We detected multiple devices.  Concatenate them together.
	
	  Partition selection stuff.
 SPDX-License-Identifier: GPL-2.0-only
  driversmtdmapsixp4xx.c
  MTD Map file for IXP4XX based systems. Please do not make per-board
  changes in here. If your board needs special setup, do it in your
  platform level code in archarmmach-ixp4xxboard-setup.c
  Original Author: Intel Corporation
  Maintainer: Deepak Saxena <dsaxena@mvista.com>
  Copyright (C) 2002 Intel Corporation
  Copyright (C) 2003-2004 MontaVista Software, Inc.
  Readwrite a 16 bit word from flash address 'addr'.
  When the cpu is in little-endian mode it swizzles the address lines
  ('address coherency') so we need to undo the swizzling to ensure commands
  and the like end up on the correct flash address.
  To further complicate matters, due to the way the expansion bus controller
  handles 32 bit reads, the byte stream ABCD is stored on the flash as:
      D15    D0
      +---+---+
      | A | B | 0
      +---+---+
      | C | D | 2
      +---+---+
  This means that on LE systems each 16 bit word must be swapped. Note that
  this requires CONFIG_MTD_CFI_BE_BYTE_SWAP to be enabled to 'unswap' the CFI
  data and other flash commands which are always in D7-D0.
  The IXP4xx expansion bus only allows 16-bit wide acceses
  when attached to a 16-bit wide device (such as the 28F128J3A),
  so we can't just memcpy_fromio().
  Unaligned writes are ignored, causing the 8-bit
  probe to fail and proceed to the 16-bit probe (which succeeds).
  Fast write16 function without the probing check above
	
	  Tell the MTD layer we're not 1:1 mapped so that it does
	  not attempt to do a direct access on us.
	
	  We only support 16-bit accesses for now. If and when
	  any board use 8-bit access, we'll fixup the driver to
	  handle that.
 Use the fast version 
 SPDX-License-Identifier: GPL-2.0-only
  esb2rom.c
  Normal mappings of flash chips in physical memory
  through the Intel ESB2 Southbridge.
  This was derived from ichxrom.c in May 2006 by
 	Lew Glendenning <lglendenning@lnxi.com>
  Eric Biederman, of course, was a major help in this effort.
 64KiB 
 This became a 16-bit register, and EN2 has disappeared 
 reserved  0x0020 and 0x0010 
 these are 32-bit values 
 Disable writes through the rom window 
 Free all of the mtd devices 
	 For now I just handle the ecb2 and I assume there
	  are not a lot of resources up at the top of the address
	  space.  It is possible to handle other devices in the
	  top 16MiB but it is very painful.  Also since
	  you can only really attach a FWH to an ICHX there
	  a number of simplifications you can make.
	 
	  Also you can page firmware hubs if an 8MiB window isn't enough
	  but don't currently handle that case either.
 RLG:  experiment 2.  Force the window registers to the widest values 
	pci_read_config_word(pdev, FWH_DEC_EN1, &word);
	printk(KERN_DEBUG "Original FWH_DEC_EN1 : %x\n", word);
	pci_write_config_byte(pdev, FWH_DEC_EN1, 0xff);
	pci_read_config_byte(pdev, FWH_DEC_EN1, &byte);
	printk(KERN_DEBUG "New FWH_DEC_EN1 : %x\n", byte);
	pci_read_config_byte(pdev, FWH_DEC_EN2, &byte);
	printk(KERN_DEBUG "Original FWH_DEC_EN2 : %x\n", byte);
	pci_write_config_byte(pdev, FWH_DEC_EN2, 0x0f);
	pci_read_config_byte(pdev, FWH_DEC_EN2, &byte);
	printk(KERN_DEBUG "New FWH_DEC_EN2 : %x\n", byte);
 Find a region continuous to the end of the ROM window  
 reserved  0x0020 and 0x0010 
 Enable writes through the rom window 
		 The BIOS will generate an error if I enable
		  this device, so don't even try.
	
	  Try to reserve the window mem region.  If this fails then
	  it is likely due to the window being "reserved" by the BIOS.
 Map the firmware hub into my address space. 
 Get the first address to look for an rom chip at 
 if not aligned on 4MiB, look 4MiB lower in address space 
	 The probe sequence run over the firmware hub lock
	  registers sets them to 0x7 (no access).
	  (Insane hardware design, but most copied Intel's.)
	  ==> Probe at most the last 4M of the address space.
 Loop through and look for rom chips 
 Set the name of the map to the address I am trying 
		 Firmware hubs only use vpp when being programmed
		  in a factory setting.  So in-place programming
		  needs to use a different method.
 Skip bankwidths that are not supported 
 Setup the map methods 
 Try all of the probe methods 
 Trim the size if we are larger than the map 
			
			  Registering the MTD device in iomem may not be possible
			  if there is a BIOS "reserved" and BUSY range.  If this
			  fails then continue anyway.
 Make the whole region visible in the map 
 Now that the mtd devices is complete claim and export it 
 Calculate the new value of map_top 
 File away the map structure 
 Free any left over map structures 
 See if I have any map structures 
 SPDX-License-Identifier: GPL-2.0
  Cortina Systems Gemini OF physmap add-on
  Copyright (C) 2017 Linus Walleij <linus.walleij@linaro.org>
  This SoC has an elaborate flash control register, so we need to
  detect and set it up when booting on this platform.
  The Flash-relevant parts of the global status register
  These would also be relevant for a NAND driver.
 if parallel 
 else 8 bit 
 if serial 
 else STM 
 and more 
 and more 
 and less 
 and more 
 and less 
 else low pin cnt 
 Static local state 
 Multiplatform guard 
	
	  It would be contradictory if a physmap flash was NOT parallel.
	
	  Complain if DT data and hardware definition is different.
 SPDX-License-Identifier: GPL-2.0-only
  Map driver for Intel XScale PXA2xx platforms.
  Author:	Nicolas Pitre
  Copyright:	(C) 2001 MontaVista Software Inc.
 invalidate D cache line 
 SPDX-License-Identifier: GPL-2.0-only
  Handle mapping of the NOR flash on implementa A7 boards
  Copyright 2002 SYSGO Real-Time Solutions GmbH
 physical properties of flash 
 physical properties of flash 
 prefix for our printk()'s 
 for mtdparts= partitioning 
  MTD partitioning stuff
 SPDX-License-Identifier: GPL-2.0-or-later
 netsc520.c -- MTD map driver for AMD NetSc520 Demonstration Board
  Copyright (C) 2001 Mark Langsdorf (mark.langsdorf@amd.com)
 	based on sc520cdp.c by Sysgo Real-Time Solutions GmbH
  The NetSc520 is a demonstration board for the Elan Sc520 processor available
  from AMD.  It has a single back of 16 megs of 32-bit Flash ROM and another
  16 megs of SDRAM.
 The single, 16 megabyte flash bank is divided into four virtual
 partitions.  The first partition is 768 KiB and is intended to
 store the kernel image loaded by the bootstrap loader.  The second
 partition is 256 KiB and holds the BIOS image.  The third
 partition is 14.5 MiB and is intended for the flash file system
 image.  The last partition is 512 KiB and contains another copy
 of the BIOS image and the reset vector.
 Only the third partition should be mounted.  The first partition
 should not be mounted, but it can erased and written to using the
 MTD character routines.  The second and fourth partitions should
 not be touched - it is possible to corrupt the BIOS image by
 mounting these partitions, and potentially the board will not be
 recoverable afterwards.
 partition_info gives details on the logical partitions that the split the
  single flash device into. If the size if zero we use up to the end of the
 SPDX-License-Identifier: GPL-2.0-only
 sun_uflash.c - Driver for user-programmable flash on
                 Sun Microsystems SME boardsets.
  This driver does NOT provide access to the OBP-flash for
  safety reasons-- use <linux>driverssbuscharflash.c instead.
  Copyright (c) 2001 Eric Brower (ebrower@usa.net)
 EBus is 8-bit 
 device name 
 mtd map info 
 mtd info 
		 Non-CFI userflash device-- once I find one we
		  can work on supporting it.
 copy defaults and tweak parameters 
 MTD registration 
	 Flashprom must have the "user" property in order to
	  be used by this driver.
 SPDX-License-Identifier: GPL-2.0-or-later
 sbc_gxx.c -- MTD map driver for Arcom Control Systems SBC-MediaGX,
                SBC-GXm and SBC-GX1 series boards.
   Copyright (C) 2001 Arcom Control System Ltd
The SBC-MediaGX  SBC-GXx has up to 16 MiB of
Intel StrataFlash (28F32028F640) in x8 mode.
This driver uses the CFI probe and Intel Extended Command Set drivers.
The flash is accessed as follows:
   16 KiB memory window at 0xdc000-0xdffff
   Two IO address locations for paging
   0x258
       bit 0-7: address bit 14-21
   0x259
       bit 0-1: address bit 22-23
       bit 7:   0 - resetpowered down
                1 - device enabled
The single flash device is divided into 3 partition which appear as
separate MTD devices.
25042001 AJL (Arcom)  Modified signon strings and partition sizes
                        (to support bzImages up to 638KiB-ish)
 Includes
 Defines
 - Hardware specific
 Number of bits in offset. 
 The bits for the offset into the window. 
 bit 7 of 0x259 must be 1 to enable device. 
 - Flash  Partition sizing
 Globals
 Current page in window.
 partition_info gives details on the logical partitions that the split the
  single flash device into. If the size if zero we use up to the end of the
	.size = MAX_SIZE_KiB1024,  this must be set to a maximum possible amount
			 of flash so the cfi probe routines find all
 MTD device for all of the flash. 
 Probe for chip. 
 Create MTD devices for each partition. 
 SPDX-License-Identifier: GPL-2.0
  tsunami_flash.c
  flash chip on alpha ds10...
  Deliberately don't provide operations wider than 8 bits.  I don't
  have then and it scares me to think how you could mess up if
  you tried to use them.   Buswidth is correctly so I'm safe.
 SPDX-License-Identifier: GPL-2.0-only
 linuxdriversmtdmapsscx200_docflash.c
   Copyright (c) 2001,2002 Christer Weinigel <wingel@nano-system.com>
   National Semiconductor SCx200 flash mapped with DOCCS
 Don't autoprobe 
 16 MiB the whole ISA address space 
 Default to 8 bits wide 
 calculate from flash size 
 calculate from flash size 
 check that we have found the configuration block 
 Try to use the present flash mapping if any 
 SPDX-License-Identifier: GPL-2.0-only
 vmu-flash.c
  Driver for SEGA Dreamcast Visual Memory Unit
  Copyright (c) Adrian McMenamin 2002 - 2009
  Copyright (c) Paul Mundt 2001
 Cache 
 Which block was cached 
 When was it cached? 
 block number 
 block offset 
 Maple bus callback function for reads 
 copy the read in data 
 Interface with maple bus to read blocks
  caching the results so that other parts
 prepare the cache for this block 
	
	 Reads may be phased - again the hardware spec
	 supports this - though may not be any devices in
	 the wild that implement it, but we will here
 Very long timeouts seem to be needed when box is stressed 
		
		 MTD layer does not handle hotplugging well
		 so have to return errors when VMU is unplugged
		 in the middle of a read (busy == 2)
 communicate with maple bus for phased writing 
		 wait until the device is not busy doing something else
 mtd function to simulate reading byte by byte 
 mtd higher order function to read flash 
 Have we cached this bit already? 
 Have we cached this and is the cache valid and timely? 
 we have cached it, so do necessary copying 
 only a bit of this block to copy 
 otherwise copy remainder of whole block 
			
			 Not cached so read one byte -
			 but cache the rest of the block
 Read in the block we are to write to 
 write out new buffer 
 invalidate the cache 
 Do nothing here 
 Maple bus callback function to recursively query hardware details 
	
	 Set up a recursive call to the (probably theoretical)
	 second or more partition
 Handles very basic info about the flash, queries for details 
	 Need to count how many bits are set - to find out which
	  function_data element has details of the memory card
	
	 Not sure there are actually any multi-partition devices in the
	 real world, but the hardware supports them, so, so will we
	
	 We want to trap meminfo not get cond
	 so set interval to zero, but rely on maple bus
	 driver to pass back the results of the meminfo
 Make sure we are clear to go 
	
	 Set up the minfo call: vmu_queryblocks will handle
	 the information passed back
 Callback to handle eccentricities of both mtd subsystem
  and general flakyness of Dreamcast VMUs
 SPDX-License-Identifier: GPL-2.0-only
  MTD map driver for BIOS Flash on Intel SCB2 boards
  Copyright (C) 2002 Sun Microsystems, Inc.
  Tim Hockin <thockin@sun.com>
  A few notes on this MTD map:
  This was developed with a small number of SCB2 boards to test on.
  Hopefully, Intel has not introducted too many unaccounted variables in the
  making of this board.
  The BIOS marks its own memory region as 'reserved' in the e820 map.  We
  try to request it here, but if it fails, we carry on anyway.
  This is how the chip is attached, so said the schematic:
   a 4 MiB (32 Mib) 16 bit chip
   a 1 MiB memory region
   A20 and A21 pulled up
   D8-D15 ignored
  What this means is that, while we are addressing bytes linearly, we are
  really addressing words, and discarding the other byte.  This means that
  the chip MUST BE at least 2 MiB.  This also means that every block is
  actually half as big as the chip reports.  It also means that accesses of
  logical address 0 hit higher-address sections of the chip, not physical 0.
  One can only hope that these 4MiB x16 chips were a lot cheaper than 1MiB x8
  chips.
  This driver assumes the chip is not write-protected by an external signal.
  As of the this writing, that is true, but may change, just to spite me.
  The actual BIOS layout has been mostly reverse engineered.  Intel BIOS
  updates for this board include 10 related (.bio - &.bi9) binary files and
  another separate (.bbo) binary file.  The 10 files are 64k of data + a
  small header.  If the headers are stripped off, the 10 64k files can be
  concatenated into a 640k image.  This is your BIOS image, proper.  The
  separate .bbo file also has a small header.  It is the 'Boot Block'
  recovery BIOS.  Once the header is stripped, no further prep is needed.
  As best I can tell, the BIOS is arranged as such:
  offset 0x00000 to 0x4ffff (320k):  unknown - SCSI BIOS, etc?
  offset 0x50000 to 0xeffff (640k):  BIOS proper
  offset 0xf0000 ty 0xfffff (64k):   Boot Block region
  Intel's BIOS update program flashes the BIOS and Boot Block in separate
  steps.  Probably a wise thing to do.
 barf if this doesn't look right 
 I wasn't here. I didn't see. dwmw2. 
 the chip is sometimes bigger than the map - what a waste 
	
	  We only REALLY get half the chip, due to the way it is
	  wired up - D8-D15 are tossed away.  We read linear bytes,
	  but in reality we are getting 12 of each 16-bit read,
	  which LOOKS linear to us.  Because CFI code accounts for
	  things like lockunlockerase by eraseregions, we need to
	  fudge them to reflect this.  Erases go like this:
	     send an erase to an address
	     the chip samples the address and erases the block
	     add the block erasesize to the address and repeat
	    -- the problem is that addresses are 16-bit addressable
	    -- we end up erasing every-other block
	
	  If the chip is bigger than the map, it is wired with the high
	  address lines pulled up.  This makes us access the top portion of
	  the chip, so all our erase-region info is wrong.  Start cutting from
	  the bottom.
 CSB5's 'Function Control Register' has bits for decoding @ >= 0xffc00000 
 enable decoding of the flash region in the south bridge 
		
		  The BIOS seems to mark the flash region as 'reserved'
		  in the e820 map.  Warn and go about our business.
 remap the IO window (wo caching) 
 try to find a chip 
 disable flash writes 
  MTD map driver for flash on the DC21285 (the StrongARM-110 companion chip)
  (C) 2000  Nicolas Pitre <nico@fluxnic.net>
  This code is GPL
  This is really ugly, but it seams to be the only
  realiable way to do it, as the cpld state machine
  is unpredictible. So we have a 25us penalty per
  write access.
	
	  we want to write a bit pattern XXX1 to Xilinx to enable
	  the write gate, which will be open for about the next 2ms.
	
	  let the ISA bus to catch on...
 Partition stuff 
 Determine bankwidth 
 Let's map the flash area 
		
		  Flash timing is determined with bits 19-16 of the
		  CSR_SA110_CNTL.  The value is the number of wait cycles, or
		  0 for 16 cycles (the default).  Cycles are 20 ns.
		  Here we use 7 for 140 ns flash chips.
 access time 
 burst time 
 tristate time 
 SPDX-License-Identifier: GPL-2.0-only
  PISMO memory driver - http:www.pismoworld.org
  For ARM Realview and Versatile platforms
	
	  FIXME: may need to the platforms memory controller here, but at
	  the moment we assume that it has already been correctly setup.
	  The memory controller can also tell us the base address as well.
 static DOC 
 static NOR 
 static RAM 
 SPDX-License-Identifier: GPL-2.0-or-later
 sc520cdp.c -- MTD map driver for AMD SC520 Customer Development Platform
  Copyright (C) 2001 Sysgo Real-Time Solutions GmbH
  The SC520CDP is an evaluation board for the Elan SC520 processor available
  from AMD. It has two banks of 32-bit Flash ROM, each 8 Megabytes in size,
  and up to 512 KiB of 8-bit DIL Flash ROM.
  For details see https:www.amd.comproductsepddesigingevalboards18.elansc520520_cdp_briefindex.html
 The Embedded Systems BIOS decodes the first FLASH starting at
 0x8400000. This is a terrible place for it because accessing
 the flash at this location causes the A22 address line to be high
 (that's what 0x8400000 binary's ought to be). But this is the highest
 order address line on the raw flash devices themselves!!
 This causes the top HALF of the flash to be accessed first. Beyond
 the physical limits of the flash, the flash chip aliases over (to
 0x880000 which causes the bottom half to be accessed. This splits the
 flash into two and inverts it! If you then try to access this from another
 program that does NOT do this insanity, then you will access the
 first half of the flash, but not find what you expect there. That
 stuff is in the second half! Similarly, the address used by the
 BIOS for the second FLASH bank is also quite a bad choice.
 If REPROGRAM_PAR is defined below (the default), then this driver will
 choose more useful addresses for the FLASH banks by reprogramming the
 responsible PARxx registers in the SC520's MMCR region. This will
 cause the settings to be incompatible with the BIOS's settings, which
 shouldn't be a problem since you are running Linux, (i.e. the BIOS is
 not much use anyway). However, if you need to be compatible with
 the BIOS for some reason, just undefine REPROGRAM_PAR.
 These are the addresses we want.. 
 .. and these are the addresses the BIOS gives us 
 The SC520 MMCR (memory mapped control register) region resides
 at 0xFFFEF000. The 16 Programmable Address Region (PAR) registers
 are at offset 0x88 in the MMCR:
 total number of PAR registers 
 The highest three bits in a PAR register determine what target
 device is controlled by this PAR. Here, only ROMCS? and BOOTCS
 devices are of interest.
 Bits 28 thru 26 determine some attributes for the
 region controlled by the PAR. (We only use non-cacheable)
 write protected       
 non-cacheable         
 code execution denied 
 Bit 25 determines the granularity: 4K or 64K
 Build a value to be written into a PAR register.
 We only need ROM entries, 64K page size:
 Flash Bank #0: selected by ROMCS0 
 Flash Bank #1: selected by ROMCS1 
 DIL (BIOS) Flash: selected by BOOTCS 
 map in SC520's MMCR area 
 ioremap failed: skip the PAR reprogramming 
 force physical address fields to BIOS defaults: 
	
	 Find the PARxx registers that are responsible for activating
	 ROMCS0, ROMCS1 and BOOTCS. Reprogram each of these with a
	 new value from the table.
 for each par_table entry  
 for each PAR register     
 if target device field matches, reprogram the PAR 
 no matching PAR found: try default BIOS address 
 reprogram PAR registers so flash appears at the desired addresses 
 Combine the two flash banks into a single MTD device & register it: 
 register the third (DIL-Flash) device 
  driversmtdmapsintel_vr_nor.c
  An MTD map driver for a NOR flash bank on the Expansion Bus of the Intel
  Vermilion Range chipset.
  The Vermilion Range Expansion Bus supports four chip selects, each of which
  has 64MiB of address space.  The 2nd BAR of the Expansion Bus PCI Device
  is a 256MiB memory region containing the address spaces for all four of the
  chip selects, with start addresses hardcoded on 64MiB boundaries.
  This map driver only supports NOR flash on chip select 0.  The buswidth
  (either 8 bits or 16 bits) is determined by reading the Expansion Bus Timing
  and Control Register for Chip Select 0 (EXP_TIMING_CS0).  This driver does
  not modify the value in the EXP_TIMING_CS0 register except to enable writing
  and disable boot acceleration.  The timing parameters in the register are
  assumed to have been properly initialized by the BIOS.  The reset default
  timing parameters are maximally conservative (slow), so access to the flash
  will be slower than it should be if the BIOS has not initialized the timing
  parameters.
  Author: Andy Lowe <alowe@mvista.com>
  2006 (c) MontaVista Software, Inc. This file is licensed under
  the terms of the GNU General Public License version 2. This program
  is licensed "as is" without any warranty of any kind, whether express
  or implied.
 Expansion Bus Configuration and Status Registers are in BAR 0 
 Expansion Bus Memory Window is BAR 1 
 Maximum address space for Chip Select 0 is 64MiB 
 Chip Select 0 is at offset 0 in the Memory Window 
 Chip Select 0 Timing Register is at offset 0 in CSR 
 Chip Select Enable 
 Boot Acceleration Disable 
 Write Enable 
 8-bit vs 16-bit bus 
 register the flash bank 
 partition the flash bank 
 write-protect the flash bank 
 unmap the flash window 
 unmap the csr window 
  Initialize the map_info structure and map the flash.
  Returns 0 on success, nonzero otherwise.
 Enable writes to flash bank 
 write-protect the flash bank 
 unmap the flash window 
 unmap the csr window 
 SPDX-License-Identifier: GPL-2.0
  SPI NOR Software Write Protection logic.
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
 Reserved one for "protect none" and one for "protect all". 
 No protection 
  Return true if the entire region is locked (if @locked is true) or unlocked
  (if @locked is false); false otherwise.
 Requested range is a sub-range of locked range 
 Requested range does not overlap with locked range 
  Lock a region of the flash. Compatible with ST Micro and similar flash.
  Supports the block protection bits BP{0,1,2}BP{0,1,2,3} in the status
  register
  (SR). Does not support these features found in newer SR bitfields:
    - SEC: sectorblock protect - only handle SEC=0 (block protect)
    - CMP: complement protect - only support CMP=0 (range is not complemented)
  Support for the following is provided conditionally for some flash:
    - TB: topbottom protect
  Sample table portion for 8MB flash (Winbond w25q64fw):
    SEC  |  TB   |  BP2  |  BP1  |  BP0  |  Prot Length  | Protected Portion
   --------------------------------------------------------------------------
     X   |   X   |   0   |   0   |   0   |  NONE         | NONE
     0   |   0   |   0   |   0   |   1   |  128 KB       | Upper 164
     0   |   0   |   0   |   1   |   0   |  256 KB       | Upper 132
     0   |   0   |   0   |   1   |   1   |  512 KB       | Upper 116
     0   |   0   |   1   |   0   |   0   |  1 MB         | Upper 18
     0   |   0   |   1   |   0   |   1   |  2 MB         | Upper 14
     0   |   0   |   1   |   1   |   0   |  4 MB         | Upper 12
     X   |   X   |   1   |   1   |   1   |  8 MB         | ALL
   ------|-------|-------|-------|-------|---------------|-------------------
     0   |   1   |   0   |   0   |   1   |  128 KB       | Lower 164
     0   |   1   |   0   |   1   |   0   |  256 KB       | Lower 132
     0   |   1   |   0   |   1   |   1   |  512 KB       | Lower 116
     0   |   1   |   1   |   0   |   0   |  1 MB         | Lower 18
     0   |   1   |   1   |   0   |   1   |  2 MB         | Lower 14
     0   |   1   |   1   |   1   |   0   |  4 MB         | Lower 12
  Returns negative on errors, 0 on success.
 If nothing in our range is unlocked, we don't need to do anything 
 If anything below us is unlocked, we can't use 'bottom' protection 
 If anything above us is unlocked, we can't use 'top' protection 
 Prefer top, if both are valid 
 lock_len: length of region that should end up locked 
 Don't "lock" with no region! 
 Disallow further writes if WP pin is asserted 
 Don't bother if they're the same 
 Only modify protection if it will not unlock other areas 
  Unlock a region of the flash. See spi_nor_sr_lock() for more info
  Returns negative on errors, 0 on success.
 If nothing in our range is locked, we don't need to do anything 
 If anything below us is locked, we can't use 'top' protection 
 If anything above us is locked, we can't use 'bottom' protection 
 Prefer top, if both are valid 
 lock_len: length of region that should remain locked 
 fully unlocked 
 Some power-of-two sizes are not supported 
 Don't protect status register if we're fully unlocked 
 Don't bother if they're the same 
 Only modify protection if it will not lock other areas 
  Check if a region of the flash is (completely) locked. See spi_nor_sr_lock()
  for more info.
  Returns 1 if entire region is locked, 0 if any portion is unlocked, and
  negative on errors.
  spi_nor_try_unlock_all() - Tries to unlock the entire flash memory array.
  @nor:	pointer to a 'struct spi_nor'.
  Some SPI NOR flashes are write protected by default after a power-on reset
  cycle, in order to avoid inadvertent writes during power-up. Backward
  compatibility imposes to unlock the entire flash memory array at power-up
  by default.
  Unprotecting the entire flash array will fail for boards which are hardware
  write-protected. Thus any errors are ignored.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
	
	  W25Q256JV supports 4B opcodes but W25Q256FV does not.
	  Unfortunately, Winbond has re-used the same JEDEC ID for both
	  variants which prevents us from defining a new entry in the parts
	  table.
	  To differentiate between W25Q256JV and W25Q256FV check SFDP header
	  version: only JV has JESD216A compliant structure (version 5).
 Winbond -- w25x "blocks" are 64K, "sectors" are 4KiB 
  winbond_set_4byte_addr_mode() - Set 4-byte address mode for Winbond flashes.
  @nor:	pointer to 'struct spi_nor'.
  @enable:	true to enter the 4-byte address mode, false to exit the 4-byte
 		address mode.
  Return: 0 on success, -errno otherwise.
	
	  On Winbond W25Q256FV, leaving 4byte mode causes the Extended Address
	  Register to be set to 1, so all 3-byte-address reads come from the
	  second 16M. We must clear the register to enable normal behavior.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
 XMC (Wuhan Xinxin Semiconductor Manufacturing Corp.) 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
 We only support unlocking the entire flash array. 
 SST -- large erase sizes are "overlays", "sectors" are 4K 
 Start write from odd address. 
 write one byte. 
 Write out most of the data here. 
 write two bytes. 
 Write out trailing byte if it exists. 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
 EON -- en25xxx 
 SPDX-License-Identifier: GPL-2.0
  OTP support for SPI NOR flashes
  Copyright (C) 2021 Michael Walle <michael@walle.cc>
  spi_nor_otp_read_secr() - read security register
  @nor:	pointer to 'struct spi_nor'
  @addr:       offset to read from
  @len:        number of bytes to read
  @buf:        pointer to dst buffer
  Read a security register by using the SPINOR_OP_RSECR commands.
  In WinbondGigaDevice datasheets the term "security register" stands for
  an one-time-programmable memory area, consisting of multiple bytes (usually
  256). Thus one "security register" maps to one OTP region.
  This method is used on GigaDevice and Winbond flashes.
  Please note, the read must not span multiple registers.
  Return: number of bytes read successfully, -errno otherwise
  spi_nor_otp_write_secr() - write security register
  @nor:        pointer to 'struct spi_nor'
  @addr:       offset to write to
  @len:        number of bytes to write
  @buf:        pointer to src buffer
  Write a security register by using the SPINOR_OP_PSECR commands.
  For more information on the term "security register", see the documentation
  of spi_nor_otp_read_secr().
  This method is used on GigaDevice and Winbond flashes.
  Please note, the write must not span multiple registers.
  Return: number of bytes written successfully, -errno otherwise
	
	  We only support a write to one single page. For now all winbond
	  flashes only have one page per security register.
  spi_nor_otp_erase_secr() - erase a security register
  @nor:        pointer to 'struct spi_nor'
  @addr:       offset of the security register to be erased
  Erase a security register by using the SPINOR_OP_ESECR command.
  For more information on the term "security register", see the documentation
  of spi_nor_otp_read_secr().
  This method is used on GigaDevice and Winbond flashes.
  Return: 0 on success, -errno otherwise
  spi_nor_otp_lock_sr2() - lock the OTP region
  @nor:        pointer to 'struct spi_nor'
  @region:     OTP region
  Lock the OTP region by writing the status register-2. This method is used on
  GigaDevice and Winbond flashes.
  Return: 0 on success, -errno otherwise.
 no need to write the register if region is already locked 
  spi_nor_otp_is_locked_sr2() - get the OTP region lock status
  @nor:        pointer to 'struct spi_nor'
  @region:     OTP region
  Retrieve the OTP region lock bit by reading the status register-2. This
  method is used on GigaDevice and Winbond flashes.
  Return: 0 on success, -errno otherwise.
 Translate the file offsets from and to OTP regions. 
	
	  If any of the affected OTP regions are locked the entire range is
	  considered locked.
 take the branch it is locked or in case of an error 
 don't access beyond the end 
		
		  The OTP regions are mapped into a contiguous area starting
		  at 0 as expected by the MTD layer. This will map the MTD
		  file offsets to the address of an OTP region as used in the
		  actual SPI commands.
		
		  The size of a OTP region is expected to be a power of two,
		  thus we can just mask the lower bits and get the offset into
		  a region.
 don't access beyond one OTP region 
 OTP erase is optional 
 the user has to explicitly ask for whole regions 
 the user has to explicitly ask for whole regions 
	
	  We only support user_prot callbacks (yet).
	 
	  Some SPI NOR flashes like Macronix ones can be ordered in two
	  different variants. One with a factory locked OTP area and one where
	  it is left to the user to write to it. The factory locked OTP is
	  usually preprogrammed with an "electrical serial number". We don't
	  support these for now.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
 Fujitsu 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
	
	  Some manufacturer like GigaDevice may use different
	  bit to set QE on different memories, so the MFR can't
	  indicate the quad_enable method for this case, we need
	  to set it in the default_init fixup hook.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
 ESMT 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
 Xilinx S3AN Internal Flash 
  This code converts an address to the Default Address Mode, that has non
  power of two page sizes. We must support this mode because it is the default
  mode supported by Xilinx tools, it can access the whole flash area and
  changing over to the Power-of-two mode is irreversible and corrupts the
  original data.
  Addr can safely be unsigned int, the biggest S3AN device is smaller than
  4 MiB.
	
	  This flashes have a page size of 264 or 528 bytes (known as
	  Default addressing mode). It can be changed to a more standard
	  Power of two mode where the page size is 256512. This comes
	  with a price: there is 3% less of space, the data is corrupted
	  and the page size cannot be changed back to default addressing
	  mode.
	 
	  The current addressing mode can be read from the XRDSR register
	  and should not be changed, because is a destructive operation.
 Flash in Power of 2 mode 
 Flash in Default addressing mode 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
 Everspin 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Based on m25p80.c, by Mike Lavender (mike@steroidmicros.com), with
  influence from lart.c (Abraham Van Der Merwe) and mtd_dataflash.c
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
 Define max times to check status register before we give up. 
  For everything but full-chip erase; probably could be much smaller, but kept
  around for safety for now
  For full-chip erase, calibrated to a 2MB flash (M25P16); should be scaled up
  for larger flash
  spi_nor_get_cmd_ext() - Get the command opcode extension based on the
 			   extension type.
  @nor:		pointer to a 'struct spi_nor'
  @op:			pointer to the 'struct spi_mem_op' whose properties
 			need to be initialized.
  Right now, only "repeat" and "invert" are supported.
  Return: The opcode extension.
  spi_nor_spimem_setup_op() - Set up common properties of a spi-mem op.
  @nor:		pointer to a 'struct spi_nor'
  @op:			pointer to the 'struct spi_mem_op' whose properties
 			need to be initialized.
  @proto:		the protocol from which the properties need to be set.
		
		  SPIMEM supports mixed DTR modes, but right now we can only
		  have all phases either DTR or STR. IOW, SPIMEM can have
		  something like 4S-4D-4D, but SPI NOR can't. So, set all 4
		  phases to either DTR or STR.
 2 bytes per clock cycle in DTR mode. 
  spi_nor_spimem_bounce() - check if a bounce buffer is needed for the data
                            transfer
  @nor:        pointer to 'struct spi_nor'
  @op:         pointer to 'struct spi_mem_op' template for transfer
  If we have to use the bounce buffer, the data field in @op will be updated.
  Return: true if the bounce buffer is needed, false if not
 op->data.buf.in occupies the same memory as op->data.buf.out 
  spi_nor_spimem_exec_op() - execute a memory operation
  @nor:        pointer to 'struct spi_nor'
  @op:         pointer to 'struct spi_mem_op' template for transfer
  Return: 0 on success, -error otherwise.
  spi_nor_spimem_read_data() - read data from flash's memory region via
                               spi-mem
  @nor:        pointer to 'struct spi_nor'
  @from:       offset to read from
  @len:        number of bytes to read
  @buf:        pointer to dst buffer
  Return: number of bytes read successfully, -errno otherwise
 convert the dummy cycles to the number of bytes 
  spi_nor_read_data() - read data from flash memory
  @nor:        pointer to 'struct spi_nor'
  @from:       offset to read from
  @len:        number of bytes to read
  @buf:        pointer to dst buffer
  Return: number of bytes read successfully, -errno otherwise
  spi_nor_spimem_write_data() - write data to flash memory via
                                spi-mem
  @nor:        pointer to 'struct spi_nor'
  @to:         offset to write to
  @len:        number of bytes to write
  @buf:        pointer to src buffer
  Return: number of bytes written successfully, -errno otherwise
  spi_nor_write_data() - write data to flash memory
  @nor:        pointer to 'struct spi_nor'
  @to:         offset to write to
  @len:        number of bytes to write
  @buf:        pointer to src buffer
  Return: number of bytes written successfully, -errno otherwise
  spi_nor_write_enable() - Set write enable latch with Write Enable command.
  @nor:	pointer to 'struct spi_nor'.
  Return: 0 on success, -errno otherwise.
  spi_nor_write_disable() - Send Write Disable instruction to the chip.
  @nor:	pointer to 'struct spi_nor'.
  Return: 0 on success, -errno otherwise.
  spi_nor_read_sr() - Read the Status Register.
  @nor:	pointer to 'struct spi_nor'.
  @sr:		pointer to a DMA-able buffer where the value of the
               Status Register will be written. Should be at least 2 bytes.
  Return: 0 on success, -errno otherwise.
			
			  We don't want to read only one byte in DTR mode. So,
			  read 2 and then discard the second byte.
  spi_nor_read_fsr() - Read the Flag Status Register.
  @nor:	pointer to 'struct spi_nor'
  @fsr:	pointer to a DMA-able buffer where the value of the
               Flag Status Register will be written. Should be at least 2
               bytes.
  Return: 0 on success, -errno otherwise.
			
			  We don't want to read only one byte in DTR mode. So,
			  read 2 and then discard the second byte.
  spi_nor_read_cr() - Read the Configuration Register using the
  SPINOR_OP_RDCR (35h) command.
  @nor:	pointer to 'struct spi_nor'
  @cr:		pointer to a DMA-able buffer where the value of the
               Configuration Register will be written.
  Return: 0 on success, -errno otherwise.
  spi_nor_set_4byte_addr_mode() - EnterExit 4-byte address mode.
  @nor:	pointer to 'struct spi_nor'.
  @enable:	true to enter the 4-byte address mode, false to exit the 4-byte
 		address mode.
  Return: 0 on success, -errno otherwise.
  spansion_set_4byte_addr_mode() - Set 4-byte address mode for Spansion
  flashes.
  @nor:	pointer to 'struct spi_nor'.
  @enable:	true to enter the 4-byte address mode, false to exit the 4-byte
 		address mode.
  Return: 0 on success, -errno otherwise.
  spi_nor_write_ear() - Write Extended Address Register.
  @nor:	pointer to 'struct spi_nor'.
  @ear:	value to write to the Extended Address Register.
  Return: 0 on success, -errno otherwise.
  spi_nor_xread_sr() - Read the Status Register on S3AN flashes.
  @nor:	pointer to 'struct spi_nor'.
  @sr:		pointer to a DMA-able buffer where the value of the
               Status Register will be written.
  Return: 0 on success, -errno otherwise.
  spi_nor_xsr_ready() - Query the Status Register of the S3AN flash to see if
  the flash is ready for new commands.
  @nor:	pointer to 'struct spi_nor'.
  Return: 1 if ready, 0 if not ready, -errno on errors.
  spi_nor_clear_sr() - Clear the Status Register.
  @nor:	pointer to 'struct spi_nor'.
  spi_nor_sr_ready() - Query the Status Register to see if the flash is ready
  for new commands.
  @nor:	pointer to 'struct spi_nor'.
  Return: 1 if ready, 0 if not ready, -errno on errors.
		
		  WEL bit remains set to one when an erase or page program
		  error occurs. Issue a Write Disable command to protect
		  against inadvertent writes that can possibly corrupt the
		  contents of the memory.
  spi_nor_clear_fsr() - Clear the Flag Status Register.
  @nor:	pointer to 'struct spi_nor'.
  spi_nor_fsr_ready() - Query the Flag Status Register to see if the flash is
  ready for new commands.
  @nor:	pointer to 'struct spi_nor'.
  Return: 1 if ready, 0 if not ready, -errno on errors.
		
		  WEL bit remains set to one when an erase or page program
		  error occurs. Issue a Write Disable command to protect
		  against inadvertent writes that can possibly corrupt the
		  contents of the memory.
  spi_nor_ready() - Query the flash to see if it is ready for new commands.
  @nor:	pointer to 'struct spi_nor'.
  Return: 1 if ready, 0 if not ready, -errno on errors.
  spi_nor_wait_till_ready_with_timeout() - Service routine to read the
  Status Register until ready, or timeout occurs.
  @nor:		pointer to "struct spi_nor".
  @timeout_jiffies:	jiffies to wait until timeout.
  Return: 0 on success, -errno otherwise.
  spi_nor_wait_till_ready() - Wait for a predefined amount of time for the
  flash to be ready, or timeout occurs.
  @nor:	pointer to "struct spi_nor".
  Return: 0 on success, -errno otherwise.
  spi_nor_global_block_unlock() - Unlock Global Block Protection.
  @nor:	pointer to 'struct spi_nor'.
  Return: 0 on success, -errno otherwise.
  spi_nor_write_sr() - Write the Status Register.
  @nor:	pointer to 'struct spi_nor'.
  @sr:		pointer to DMA-able buffer to write to the Status Register.
  @len:	number of bytes to write to the Status Register.
  Return: 0 on success, -errno otherwise.
  spi_nor_write_sr1_and_check() - Write one byte to the Status Register 1 and
  ensure that the byte written match the received value.
  @nor:	pointer to a 'struct spi_nor'.
  @sr1:	byte value to be written to the Status Register.
  Return: 0 on success, -errno otherwise.
  spi_nor_write_16bit_sr_and_check() - Write the Status Register 1 and the
  Status Register 2 in one shot. Ensure that the byte written in the Status
  Register 1 match the received value, and that the 16-bit Write did not
  affect what was already in the Status Register 2.
  @nor:	pointer to a 'struct spi_nor'.
  @sr1:	byte value to be written to the Status Register 1.
  Return: 0 on success, -errno otherwise.
 Make sure we don't overwrite the contents of Status Register 2. 
		
		  If the Status Register 2 Read command (35h) is not
		  supported, we should at least be sure we don't
		  change the value of the SR2 Quad Enable bit.
		 
		  We can safely assume that when the Quad Enable method is
		  set, the value of the QE bit is one, as a consequence of the
		  nor->params->quad_enable() call.
		 
		  We can safely assume that the Quad Enable bit is present in
		  the Status Register 2 at BIT(1). According to the JESD216
		  revB standard, BFPT DWORDS[15], bits 22:20, the 16-bit
		  Write Status (01h) command is available just for the cases
		  in which the QE bit is described in SR2 at BIT(1).
  spi_nor_write_16bit_cr_and_check() - Write the Status Register 1 and the
  Configuration Register in one shot. Ensure that the byte written in the
  Configuration Register match the received value, and that the 16-bit Write
  did not affect what was already in the Status Register 1.
  @nor:	pointer to a 'struct spi_nor'.
  @cr:		byte value to be written to the Configuration Register.
  Return: 0 on success, -errno otherwise.
 Keep the current value of the Status Register 1. 
  spi_nor_write_sr_and_check() - Write the Status Register 1 and ensure that
  the byte written match the received value without affecting other bits in the
  Status Register 1 and 2.
  @nor:	pointer to a 'struct spi_nor'.
  @sr1:	byte value to be written to the Status Register.
  Return: 0 on success, -errno otherwise.
  spi_nor_write_sr2() - Write the Status Register 2 using the
  SPINOR_OP_WRSR2 (3eh) command.
  @nor:	pointer to 'struct spi_nor'.
  @sr2:	pointer to DMA-able buffer to write to the Status Register 2.
  Return: 0 on success, -errno otherwise.
  spi_nor_read_sr2() - Read the Status Register 2 using the
  SPINOR_OP_RDSR2 (3fh) command.
  @nor:	pointer to 'struct spi_nor'.
  @sr2:	pointer to DMA-able buffer where the value of the
 		Status Register 2 will be written.
  Return: 0 on success, -errno otherwise.
  spi_nor_erase_chip() - Erase the entire flash memory.
  @nor:	pointer to 'struct spi_nor'.
  Return: 0 on success, -errno otherwise.
 No conversion found, keep input op code. 
  Initiate the erasure of a single sector
	
	  Default implementation, if driver doesn't have a specialized HW
	  control
  spi_nor_div_by_erase_size() - calculate remainder and update new dividend
  @erase:	pointer to a structure that describes a SPI NOR erase type
  @dividend:	dividend value
  @remainder:	pointer to u32 remainder (will be updated)
  Return: the result of the division
 JEDEC JESD216B Standard imposes erase sizes to be power of 2. 
  spi_nor_find_best_erase_type() - find the best erase type for the given
 				    offset in the serial flash memory and the
 				    number of bytes to erase. The region in
 				    which the address fits is expected to be
 				    provided.
  @map:	the erase map of the SPI NOR
  @region:	pointer to a structure that describes a SPI NOR erase region
  @addr:	offset in the serial flash memory
  @len:	number of bytes to erase
  Return: a pointer to the best fitted erase type, NULL otherwise.
	
	  Erase types are ordered by size, with the smallest erase type at
	  index 0.
 Does the erase region support the tested erase type? 
 Alignment is not mandatory for overlaid regions 
 Don't erase more than what the user has asked for. 
  spi_nor_region_next() - get the next spi nor region
  @region:	pointer to a structure that describes a SPI NOR erase region
  Return: the next spi nor region or NULL if last region.
  spi_nor_find_erase_region() - find the region of the serial flash memory in
 				 which the offset fits
  @map:	the erase map of the SPI NOR
  @addr:	offset in the serial flash memory
  Return: a pointer to the spi_nor_erase_region struct, ERR_PTR(-errno)
 	   otherwise.
  spi_nor_init_erase_cmd() - initialize an erase command
  @region:	pointer to a structure that describes a SPI NOR erase region
  @erase:	pointer to a structure that describes a SPI NOR erase type
  Return: the pointer to the allocated erase command, ERR_PTR(-errno)
 	   otherwise.
  spi_nor_destroy_erase_cmd_list() - destroy erase command list
  @erase_list:	list of erase commands
  spi_nor_init_erase_cmd_list() - initialize erase command list
  @nor:	pointer to a 'struct spi_nor'
  @erase_list:	list of erase commands to be executed once we validate that the
 		erase can be performed
  @addr:	offset in the serial flash memory
  @len:	number of bytes to erase
  Builds the list of best fitted erase commands and verifies if the erase can
  be performed.
  Return: 0 on success, -errno otherwise.
  spi_nor_erase_multi_sectors() - perform a non-uniform erase
  @nor:	pointer to a 'struct spi_nor'
  @addr:	offset in the serial flash memory
  @len:	number of bytes to erase
  Build a list of best fitted erase commands and execute it once we validate
  that the erase can be performed.
  Return: 0 on success, -errno otherwise.
  Erase an address range on the nor chip.  The address range may extend
  one or more erase sectors. Return an error if there is a problem erasing.
 whole-chip erase? 
		
		  Scale the timeout linearly with the size of the flash, with
		  a minimum calibrated to an old 2MB flash. We could try to
		  pull these from CFISFDP, but these values should be good
		  enough for now.
	 REVISIT in some cases we could speed up erasing large regions
	  by using SPINOR_OP_SE instead of SPINOR_OP_BE_4K.  We may have set up
	  to use "small sector erase", but that's not always optimal.
 "sector"-at-a-time erase 
 erase multiple sectors 
  spi_nor_sr1_bit6_quad_enable() - Set the Quad Enable BIT(6) in the Status
  Register 1.
  @nor:	pointer to a 'struct spi_nor'
  Bit 6 of the Status Register 1 is the QE bit for Macronix like QSPI memories.
  Return: 0 on success, -errno otherwise.
  spi_nor_sr2_bit1_quad_enable() - set the Quad Enable BIT(1) in the Status
  Register 2.
  @nor:       pointer to a 'struct spi_nor'.
  Bit 1 of the Status Register 2 is the QE bit for Spansion like QSPI memories.
  Return: 0 on success, -errno otherwise.
  spi_nor_sr2_bit7_quad_enable() - set QE bit in Status Register 2.
  @nor:	pointer to a 'struct spi_nor'
  Set the Quad Enable (QE) bit in the Status Register 2.
  This is one of the procedures to set the QE bit described in the SFDP
  (JESD216 rev B) specification but no manufacturer using this procedure has
  been identified yet, hence the name of the function.
  Return: 0 on success, -errno otherwise.
 Check current Quad Enable bit value. 
 Update the Quad Enable bit. 
 Read back and check it. 
 We shouldn't see 0-length reads 
  Write an address range to the nor chip.  Data must be written in
  FLASH_PAGESIZE chunks.  The address range may be any size provided
  it is within the physical boundaries.
		
		  If page_size is a power of two, the offset can be quickly
		  calculated with an AND operation. On the other cases we
		  need to do a modulus operation (more expensive).
 the size of data remaining on the first page 
  spi_nor_spimem_check_op - check if the operation is supported
                            by controller
 @nor:        pointer to a 'struct spi_nor'
 @op:         pointer to op template to be checked
  Returns 0 if operation is supported, -EOPNOTSUPP otherwise.
	
	  First test with 4 address bytes. The opcode itself might
	  be a 3B addressing opcode but we don't care, because
	  SPI controller implementation should not check the opcode,
	  but just the sequence.
 If flash size <= 16MB, 3 address bytes are sufficient 
  spi_nor_spimem_check_readop - check if the read op is supported
                                by controller
 @nor:         pointer to a 'struct spi_nor'
 @read:        pointer to op template to be checked
  Returns 0 if operation is supported, -EOPNOTSUPP otherwise.
 convert the dummy cycles to the number of bytes 
  spi_nor_spimem_check_pp - check if the page program op is supported
                            by controller
 @nor:         pointer to a 'struct spi_nor'
 @pp:          pointer to op template to be checked
  Returns 0 if operation is supported, -EOPNOTSUPP otherwise.
  spi_nor_spimem_adjust_hwcaps - Find optimal ReadWrite protocol
                                 based on SPI controller capabilities
  @nor:        pointer to a 'struct spi_nor'
  @hwcaps:     pointer to resulting capabilities after adjusting
               according to controller and flash's capability
 X-X-X modes are not supported yet, mask them all. 
	
	  If the reset line is broken, we do not want to enter a stateful
	  mode.
  spi_nor_set_erase_type() - set a SPI NOR erase type
  @erase:	pointer to a structure that describes a SPI NOR erase type
  @size:	the size of the sectorblock erased by the erase type
  @opcode:	the SPI command op code to erase the sectorblock
 JEDEC JESD216B Standard imposes erase sizes to be power of 2. 
  spi_nor_init_uniform_erase_map() - Initialize uniform erase map
  @map:		the erase map of the SPI NOR
  @erase_mask:		bitmask encoding erase types that can erase the entire
 			flash memory
  @flash_size:		the spi nor flash memory size
 Offset 0 with erase_mask and SNOR_LAST_REGION bit set 
	
	  In the SPI NOR framework, we don't need to make the difference
	  between mode clock cycles and wait state clock cycles.
	  Indeed, the value of the mode clock cycles is used by a QSPI
	  flash memory to know whether it should enter or leave its 0-4-4
	  (Continuous Read  XIP) mode.
	  eXecution In Place is out of the scope of the mtd sub-system.
	  Hence we choose to merge both mode and wait state clock cycles
	  into the so called dummy clock cycles.
  spi_nor_select_uniform_erase() - select optimum uniform erase type
  @map:		the erase map of the SPI NOR
  @wanted_size:	the erase type size to search for. Contains the value of
 			info->sector_size or of the "small sector" size in case
 			CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is defined.
  Once the optimum uniform sector erase command is found, disable all the
  other.
  Return: pointer to erase type on success, NULL otherwise.
		
		  If the current erase size is the one, stop here:
		  we have found the right uniform Sector Erase command.
		
		  Otherwise, the current erase size is still a valid candidate.
		  Select the biggest valid candidate.
 keep iterating to find the wanted_size 
 Disable all other Sector Erase commands. 
	
	  The previous implementation handling Sector Erase commands assumed
	  that the SPI flash memory has an uniform layout then used only one
	  of the supported erase sizes for all Sector Erase commands.
	  So to be backward compatible, the new implementation also tries to
	  manage the SPI flash memory as uniform with a single erase sector
	  size, when possible.
 prefer "small sector" erase if possible 
	
	  For non-uniform SPI flash memory, set mtd->erasesize to the
	  maximum erase sector size. No need to set nor->erase_opcode.
	
	  Keep only the hardware capabilities supported by both the SPI
	  controller and the SPI flash memory.
		
		  When called from spi_nor_probe(), all caps are set and we
		  need to discard some of them based on what the SPI
		  controller actually supports (using spi_mem_supports_op()).
		
		  SPI n-n-n protocols are not supported when the SPI
		  controller directly implements the spi_nor interface.
		  Yet another reason to switch to spi-mem.
 Select the (Fast) Read command. 
 Select the Page Program command. 
 Select the Sector Erase command. 
  spi_nor_manufacturer_init_params() - Initialize the flash's parameters and
  settings based on MFR register and ->default_init() hook.
  @nor:	pointer to a 'struct spi_nor'.
  spi_nor_sfdp_init_params() - Initialize the flash's parameters and settings
  based on JESD216 SFDP standard.
  @nor:	pointer to a 'struct spi_nor'.
  The method has a roll-back mechanism: in case the SFDP parsing fails, the
  legacy flash parameters and settings will be restored.
  spi_nor_info_init_params() - Initialize the flash's parameters and settings
  based on nor->info data.
  @nor:	pointer to a 'struct spi_nor'.
 Initialize default flash parameters and settings. 
 Default to 16-bit Write Status (01h) Command 
 Set SPI NOR sizes. 
 Default to Fast Read for DT and non-DT platform devices. 
 Mask out Fast Read if not requested at DT instantiation. 
 (Fast) Read settings. 
 Page Program settings. 
		
		  Since xSPI Page Program opcode is backward compatible with
		  Legacy SPI, use Legacy SPI opcode there as well.
	
	  Sector Erase settings. Sort Erase Types in ascending order, with the
	  smallest erase size starting at BIT(0).
  spi_nor_post_sfdp_fixups() - Updates the flash's parameters and settings
  after SFDP has been parsed (is also called for SPI NORs that do not
  support RDSFDP).
  @nor:	pointer to a 'struct spi_nor'
  Typically used to tweak various parameters that could not be extracted by
  other means (i.e. when information provided by the SFDPflash_info tables
  are incomplete or wrong).
  spi_nor_late_init_params() - Late initialization of default flash parameters.
  @nor:	pointer to a 'struct spi_nor'
  Used to set default flash parameters and settings when the ->default_init()
  hook or the SFDP parser let voids.
	
	  NOR protection support. When locking_ops are not provided, we pick
	  the default ones.
  spi_nor_init_params() - Initialize the flash's parameters and settings.
  @nor:	pointer to a 'struct spi_nor'.
  The flash parameters and settings are initialized based on a sequence of
  calls that are ordered by priority:
  1 Default flash parameters initialization. The initializations are done
     based on nor->info data:
 		spi_nor_info_init_params()
  which can be overwritten by:
  2 Manufacturer flash parameters initialization. The initializations are
     done based on MFR register, or when the decisions can not be done solely
     based on MFR, by using specific flash_info tweeks, ->default_init():
 		spi_nor_manufacturer_init_params()
  which can be overwritten by:
  3 SFDP flash parameters initialization. JESD216 SFDP is a standard and
     should be more accurate that the above.
 		spi_nor_sfdp_init_params()
     Please note that there is a ->post_bfpt() fixup hook that can overwrite
     the flash parameters and settings immediately after parsing the Basic
     Flash Parameter Table.
  which can be overwritten by:
  4 Post SFDP flash parameters initialization. Used to tweak various
     parameters that could not be extracted by other means (i.e. when
     information provided by the SFDPflash_info tables are incomplete or
     wrong).
 		spi_nor_post_sfdp_fixups()
  5 Late default flash parameters initialization, used when the
  ->default_init() hook or the SFDP parser do not set specific params.
 		spi_nor_late_init_params()
 spi_nor_octal_dtr_enable() - enable Octal DTR IO if needed
  @nor:                 pointer to a 'struct spi_nor'
  @enable:              whether to enable or disable Octal DTR
  Return: 0 on success, -errno otherwise.
  spi_nor_quad_enable() - enable Quad IO if needed.
  @nor:                pointer to a 'struct spi_nor'
  Return: 0 on success, -errno otherwise.
	
	  Some SPI NOR flashes are write protected by default after a power-on
	  reset cycle, in order to avoid inadvertent writes during power-up.
	  Backward compatibility imposes to unlock the entire flash memory
	  array at power-up by default. Depending on the kernel configuration
	  (1) do nothing, (2) always unlock the entire flash array or (3)
	  unlock the entire flash array only when the software write
	  protection bits are volatile. The latter is indicated by
	  SNOR_F_SWP_IS_VOLATILE.
		
		  If the RESET# pin isn't hooked up properly, or the system
		  otherwise doesn't perform a reset command in the boot
		  sequence, it's impossible to 100% protect against unexpected
		  reboots (e.g., crashes). Warn the user (or hopefully, system
		  designer) that this is bad.
  spi_nor_soft_reset() - Perform a software reset
  @nor:	pointer to 'struct spi_nor'
  Performs a "Soft Reset and Enter Default Protocol Mode" sequence which resets
  the device to its power-on-reset state. This is useful when the software has
  made some changes to device (volatile) registers and needs to reset it before
  shutting down, for example.
  Not every flash supports this sequence. The same set of opcodes might be used
  for some other operation on a flash that does not support this. Support for
  this sequence can be discovered via SFDP in the BFPT table.
  Return: 0 on success, -errno otherwise.
	
	  Software Reset is not instant, and the delay varies from flash to
	  flash. Looking at a few flashes, most range somewhere below 100
	  microseconds. So, sleep for a range of 200-400 us.
 mtd suspend handler 
 Disable octal DTR mode if we enabled it. 
 mtd resume handler 
 re-initialize the nor chip 
 restore the addressing mode 
 already configured from SFDP 
		
		  In 8D-8D-8D mode, one byte takes half a cycle to transfer. So
		  in this protocol an odd address width cannot be used because
		  then the address phase would only span a cycle and a half.
		  Half a cycle would be left over. We would then have to start
		  the dummy phase in the middle of a cycle and so too the data
		  phase, and we will end the transaction with half a cycle left
		  over.
		 
		  Force all 8D-8D-8D flashes to use an address width of 4 to
		  avoid this situation.
 enable 4-byte addressing if the device exceeds 16MiB 
 Set 4byte opcodes when possible. 
 Try to auto-detect if chip name wasn't specified or not found 
	
	  If caller has specified name of flash model that can normally be
	  detected using JEDEC, let's verify it.
			
			  JEDEC knows better, so overwrite platform ID. We
			  can't trust partitions any longer, but we'll let
			  mtd apply them anyway, since some partitions may be
			  marked read-only, and we don't want to lose that
			  information, even if it's not 100% accurate.
 Reset SPI protocol for all commands. 
	
	  We need the bounce buffer early to readwrite registers when going
	  through the spi-mem layer (buffers have to be DMA-able).
	  For spi-mem drivers, we'll reallocate a new buffer if
	  nor->page_size turns out to be greater than PAGE_SIZE (which
	  shouldn't happen before long since NOR pages are usually less
	  than 1KB) after spi_nor_scan() returns.
	
	  Make sure the XSR_RDY flag is set before calling
	  spi_nor_wait_till_ready(). Xilinx S3AN share MFR
	  with Atmel SPI NOR.
 Init flash parameters based on flash_info struct and SFDP 
	
	  Configure the SPI memory:
	  - select op codes for (Fast) Read, Page Program and Sector Erase.
	  - set the number of dummy cycles (mode cycles + wait states).
	  - set the SPI protocols for register and memory accesses.
 Send all the required SPI flash commands to initialize device 
 Configure OTP parameters and ops 
 convert the dummy cycles to the number of bytes 
	
	  Since spi_nor_spimem_setup_op() only sets buswidth when the number
	  of data bytes is non-zero, the data buswidth won't be set here. So,
	  do it explicitly.
	
	  Since spi_nor_spimem_setup_op() only sets buswidth when the number
	  of data bytes is non-zero, the data buswidth won't be set here. So,
	  do it explicitly.
	
	  Enable all caps by default. The core will mask them after
	  checking what's really supported using spi_mem_supports_op().
	
	  For some (historical?) reason many platforms provide two different
	  names in flash_platform_data: "name" and "type". Quite often name is
	  set to "m25p80" and then "type" provides a real chip name.
	  If that's the case, respect "type" and ignore a "name".
 auto-detect 
	
	  None of the existing parts have > 512B pages, but let's play safe
	  and add this logic so that if anyone ever adds support for such
	  a NOR we don't end up with buffer overflows.
 Clean up MTD stuff. 
  Do NOT add to this array without reading the following:
  Historically, many flash devices are bound to this driver by their name. But
  since most of these flash are compatible to some extent, and their
  differences can often be differentiated by the JEDEC read-ID command, we
  encourage new users to add support to the spi-nor library, and simply bind
  against a generic string here (e.g., "jedec,spi-nor").
  Many flash names are kept here in this list (as well as in spi-nor.c) to
  keep them available as module aliases for existing platforms.
	
	  Allow non-DT platform devices to bind to the "spi-nor" modalias, and
	  hack around the fact that the SPI core does not provide uevent
	  matching for .of_match_table
	
	  Entries not used in DTs that should be safe to drop after replacing
	  them with "spi-nor" in platform data.
	
	  Entries that were used in DTs without "jedec,spi-nor" fallback and
	  should be kept for backward compatibility.
 Flashes that can't be detected using JEDEC 
 Everspin MRAMs (non-JEDEC) 
 128 Kib, 40 MHz 
 256 Kib, 40 MHz 
   1 Mib, 40 MHz 
   4 Mib, 40 MHz 
	
	  Generic compatibility for SPI NOR that can be identified by the
	  JEDEC READ ID opcode (0x9F). Use this, if possible.
 sentinel  },
  REVISIT: many of these chips have deep power-down modes, which
  should clearly be entered on suspend() to minimize power use.
  And also when they're otherwise idle...
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
 Fast Read opcode in DTR mode 
 Read volatile register 
 Write volatile register 
 For setting octal DTR mode 
 For setting dummy cycles 
 Enable Octal DTR. 
 Enable Extended SPI (default) 
 Use 20 dummy cycles for memory array reads. 
 Read flash ID to make sure the switch was successful. 
 Set the Fast Read settings. 
	
	  The BFPT quad enable field is set to a reserved value so the quad
	  enable function is ignored by spi_nor_parse_bfpt(). Make sure we
	  disable it.
  st_micron_set_4byte_addr_mode() - Set 4-byte address mode for ST and Micron
  flashes.
  @nor:	pointer to 'struct spi_nor'.
  @enable:	true to enter the 4-byte address mode, false to exit the 4-byte
 		address mode.
  Return: 0 on success, -errno otherwise.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
  The Atmel AT25FS010AT25FS040 parts have some weird configuration for the
  block protection bits. We don't support them. But legacy behavior in linux
  is to unlock the whole flash array on startup. Therefore, we have to support
  exactly this operation.
 We only support unlocking the whole flash array 
 Write 0x00 to the status register to disable write protection 
  atmel_set_global_protection - Do a Global Protect or Unprotect command
  @nor:	pointer to 'struct spi_nor'
  @ofs:	offset in bytes
  @len:	len in bytes
  @is_protect:	if true do a Global Protect otherwise it is a Global Unprotect
  Return: 0 on success, -error otherwise.
 We only support locking the whole flash array 
 SRWD bit needs to be cleared, otherwise the protection doesn't change 
		
		  Set the SRWD bit again as soon as we are protecting
		  anything. This will ensure that the WP# pin is working
		  correctly. By doing this we also behave the same as
		  spi_nor_sr_lock(), which sets SRWD if any block protection
		  is active.
	
	  We cannot use the spi_nor_write_sr_and_check() because this command
	  isn't really setting any bits, instead it is an pseudo command for
	  "Global Unprotect" or "Global Protect"
 Atmel -- some are (confusingly) marketed as "DataFlash" 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
	
	  MX25L25635F supports 4B opcodes but MX25L25635E does not.
	  Unfortunately, Macronix has re-used the same JEDEC ID for both
	  variants which prevents us from defining a new entry in the parts
	  table.
	  We need a way to differentiate MX25L25635E and MX25L25635F, and it
	  seems that the F version advertises support for Fast Read 4-4-4 in
	  its BFPT table.
 Macronix 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
	
	  IS25LP256 supports 4B opcodes, but the BFPT advertises a
	  BFPT_DWORD1_ADDRESS_BYTES_3_ONLY address width.
	  Overwrite the address width advertised by the BFPT.
 ISSI 
 PMC 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
 IntelNumonyx -- xxxs33b 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
 Catalyst  On Semiconductor -- non-JEDEC 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
 Read any register 
 Write any register 
 Page size. 
  spi_nor_cypress_octal_dtr_enable() - Enable octal DTR on Cypress flashes.
  @nor:		pointer to a 'struct spi_nor'
  @enable:              whether to enable or disable Octal DTR
  This also sets the memory access latency cycles to 24 to allow the flash to
  run at up to 200MHz.
  Return: 0 on success, -errno otherwise.
 Use 24 dummy cycles for memory array reads. 
 Setunset the octal and DTR enable bits. 
 Read flash ID to make sure the switch was successful. 
	
	  On older versions of the flash the xSPI Profile 1.0 table has the
	  8D-8D-8D Fast Read opcode as 0x00. But it actually should be 0xEE.
 This flash is also missing the 4-byte Page Program opcode bit. 
	
	  Since xSPI Page Program opcode is backward compatible with
	  Legacy SPI, use Legacy SPI opcode there as well.
	
	  The xSPI Profile 1.0 table advertises the number of additional
	  address bytes needed for Read Status Register command as 0 but the
	  actual value for that is 4.
	
	  The BFPT table advertises a 512B page size but the page size is
	  actually configurable (with the default being 256B). Read from
	  CFR3V[4] and set the correct size.
	
	  The S25FS-S chip family reports 512-byte pages in BFPT but
	  in reality the write buffer still wraps at the safe default
	  of 256 bytes.  Overwrite the page size advertised by BFPT
	  to get the writes working.
	 SpansionCypress -- single (large) sector size only, at least
	  for the chips listed here (without boot sectors).
 No small sector erase for 4-byte command set 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005, Intec Automation Inc.
  Copyright (C) 2014, Freescale Semiconductor, Inc.
 Basic Flash Parameter Table 
 Sector Map Table 
 4-byte Address Instruction Table 
 xSPI Profile 1.0 table. 
#define SFDP_SCCR_MAP_ID	0xff87	
					  Status, Control and Configuration
					  Register Map.
 Ox50444653U <=> "SFDP" 
 0-base number of parameter headers 
 Basic Flash Parameter Table. 
 Fast Read settings. 
 The Fast Read x-y-z hardware capability in params->hwcaps.mask. 
	
	  The <supported_bit> bit in <supported_dword> BFPT DWORD tells us
	  whether the Fast Read x-y-z command is supported.
	
	  The half-word at offset <setting_shift> in <setting_dword> BFPT DWORD
	  encodes the op code, the number of mode clocks and the number of wait
	  states to be used by Fast Read x-y-z command.
 The SPI protocol for this Fast Read x-y-z command. 
	
	  The half-word at offset <shift> in DWORD <dword> encodes the
	  op code and erase sector size to be used by Sector Erase commands.
 The hardware capability. 
	
	  The <supported_bit> bit in DWORD1 of the 4BAIT tells us whether
	  the associated 4-byte address op code is supported.
  spi_nor_read_raw() - raw read of serial flash memory. read_opcode,
 			addr_width and read_dummy members of the struct spi_nor
 			should be previously
  set.
  @nor:	pointer to a 'struct spi_nor'
  @addr:	offset in the serial flash memory
  @len:	number of bytes to read
  @buf:	buffer where the data is copied into (dma-safe memory)
  Return: 0 on success, -errno otherwise.
  spi_nor_read_sfdp() - read Serial Flash Discoverable Parameters.
  @nor:	pointer to a 'struct spi_nor'
  @addr:	offset in the SFDP area to start reading data from
  @len:	number of bytes to read
  @buf:	buffer where the SFDP data are copied into (dma-safe memory)
  Whatever the actual numbers of bytes for address and dummy cycles are
  for (Fast) Read commands, the Read SFDP (5Ah) instruction is always
  followed by a 3-byte address and 8 dummy clock cycles.
  Return: 0 on success, -errno otherwise.
  spi_nor_read_sfdp_dma_unsafe() - read Serial Flash Discoverable Parameters.
  @nor:	pointer to a 'struct spi_nor'
  @addr:	offset in the SFDP area to start reading data from
  @len:	number of bytes to read
  @buf:	buffer where the SFDP data are copied into
  Wrap spi_nor_read_sfdp() using a kmalloc'ed bounce buffer as @buf is now not
  guaranteed to be dma-safe.
  Return: -ENOMEM if kmalloc() fails, the return code of spi_nor_read_sfdp()
           otherwise.
 Fast Read 1-1-2 
 Supported bit 
 Settings 
 Fast Read 1-2-2 
 Supported bit 
 Settings 
 Fast Read 2-2-2 
 Supported bit 
 Settings 
 Fast Read 1-1-4 
 Supported bit 
 Settings 
 Fast Read 1-4-4 
 Supported bit 
 Settings 
 Fast Read 4-4-4 
 Supported bit 
 Settings 
 Erase Type 1 in DWORD8 bits[15:0] 
 Erase Type 2 in DWORD8 bits[31:16] 
 Erase Type 3 in DWORD9 bits[15:0] 
 Erase Type 4 in DWORD9 bits[31:16] 
  spi_nor_set_erase_settings_from_bfpt() - set erase type settings from BFPT
  @erase:	pointer to a structure that describes a SPI NOR erase type
  @size:	the size of the sectorblock erased by the erase type
  @opcode:	the SPI command op code to erase the sectorblock
  @i:		erase type index as sorted in the Basic Flash Parameter Table
  The supported Erase Types will be sorted at init in ascending order, with
  the smallest Erase Type size being the first member in the erase_type array
  of the spi_nor_erase_map structure. Save the Erase Type index as sorted in
  the Basic Flash Parameter Table since it will be used later on to
  synchronize with the supported Erase Types defined in SFDP optional tables.
  spi_nor_map_cmp_erase_type() - compare the map's erase types by size
  @l:	member in the left half of the map's erase_type array
  @r:	member in the right half of the map's erase_type array
  Comparison function used in the sort() call to sort in ascending order the
  map's erase types, the smallest erase type size being the first member in the
  sorted erase_type array.
  Return: the result of @l->size - @r->size
  spi_nor_sort_erase_mask() - sort erase mask
  @map:	the erase map of the SPI NOR
  @erase_mask:	the erase type mask to be sorted
  Replicate the sort done for the map's erase types in BFPT: sort the erase
  mask in ascending order with the smallest erase type size starting from
  BIT(0) in the sorted erase mask.
  Return: sorted erase mask.
 Replicate the sort done for the map's erase types. 
  spi_nor_regions_sort_erase_types() - sort erase types in each region
  @map:	the erase map of the SPI NOR
  Function assumes that the erase types defined in the erase map are already
  sorted in ascending order, with the smallest erase type size being the first
  member in the erase_type array. It replicates the sort done for the map's
  erase types. Each region's erase bitmask will indicate which erase types are
  supported from the sorted erase types defined in the erase map.
  Sort the all region's erase type at init in order to speed up the process of
  finding the best erase command at runtime.
 Overwrite erase mask. 
  spi_nor_parse_bfpt() - read and parse the Basic Flash Parameter Table.
  @nor:		pointer to a 'struct spi_nor'
  @bfpt_header:	pointer to the 'struct sfdp_parameter_header' describing
 			the Basic Flash Parameter Table length and version
  The Basic Flash Parameter Table is the main and only mandatory table as
  defined by the SFDP (JESD216) specification.
  It provides us with the total size (memory density) of the data array and
  the number of address bytes for Fast Read, Page Program and Sector Erase
  commands.
  For Fast READ commands, it also gives the number of mode clock cycles and
  wait states (regrouped in the number of dummy clock cycles) for each
  supported instruction op code.
  For Page Program, the page size is now available since JESD216 rev A, however
  the supported instruction op codes are still not provided.
  For Sector Erase commands, this table stores the supported instruction op
  codes and the associated sector sizes.
  Finally, the Quad Enable Requirements (QER) are also available since JESD216
  rev A. The QER bits encode the manufacturer dependent procedure to be
  executed to set the Quad Enable (QE) bit in some internal register of the
  Quad SPI memory. Indeed the QE bit, when it exists, must be set before
  sending any Quad SPI command to the memory. Actually, setting the QE bit
  tells the memory to reassign its WP# and HOLD#RESET# pins to functions IO2
  and IO3 hence enabling 4 (Quad) IO lines.
  Return: 0 on success, -errno otherwise.
 JESD216 Basic Flash Parameter Table length is at least 9 DWORDs. 
 Read the Basic Flash Parameter Table. 
 Fix endianness of the BFPT DWORDs. 
 Number of address bytes. 
 Flash Memory Density (in bits). 
		
		  Prevent overflows on params->size. Anyway, a NOR of 2^64
		  bits is unlikely to exist so this error probably means
		  the BFPT we are reading is corruptedwrong.
 Convert to bytes. 
 Fast Read settings. 
	
	  Sector Erase settings. Reinitialize the uniform erase map using the
	  Erase Types defined in the bfpt table.
 erasesize == 0 means this Erase Type is not supported. 
	
	  Sort all the map's Erase Types in ascending order with the smallest
	  erase size being the first member in the erase_type array.
	
	  Sort the erase types in the uniform region in order to update the
	  uniform_erase_type bitmask. The bitmask will be used later on when
	  selecting the uniform erase.
 Stop here if not JESD216 rev A or later. 
 Page size: this field specifies 'N' so the page size = 2^N bytes. 
 Quad Enable Requirements. 
		
		  Writing only one byte to the Status Register has the
		  side-effect of clearing Status Register 2.
		
		  Read Configuration Register (35h) instruction is not
		  supported.
		
		  JESD216 rev B or later does not specify if writing only one
		  byte to the Status Register clears or not the Status
		  Register 2, so let's be cautious and keep the default
		  assumption of a 16-bit Write Status (01h) command.
 Soft Reset support. 
 Stop here if not JESD216 rev C or later. 
 8D-8D-8D command extension. 
  spi_nor_smpt_addr_width() - return the address width used in the
 			       configuration detection command.
  @nor:	pointer to a 'struct spi_nor'
  @settings:	configuration detection command descriptor, dword1
  spi_nor_smpt_read_dummy() - return the configuration detection command read
 			       latency, in clock cycles.
  @nor:	pointer to a 'struct spi_nor'
  @settings:	configuration detection command descriptor, dword1
  Return: the number of dummy cycles for an SMPT read
  spi_nor_get_map_in_use() - get the configuration map in use
  @nor:	pointer to a 'struct spi_nor'
  @smpt:	pointer to the sector map parameter table
  @smpt_len:	sector map parameter table length
  Return: pointer to the map in use, ERR_PTR(-errno) otherwise.
 Use a kmalloc'ed bounce buffer to guarantee it is DMA-able. 
 Determine if there are any optional Detection Command Descriptors 
		
		  Build an index value that is used to select the Sector Map
		  Configuration that is currently in use.
	
	  If command descriptors are provided, they always precede map
	  descriptors in the table. There is no need to start the iteration
	  over smpt array all over again.
	 
	  Find the matching configuration map.
		
		  If there are no more configuration map descriptors and no
		  configuration ID matched the configuration identifier, the
		  sector address map is unknown.
 increment the table index to the next map 
 fall through 
  spi_nor_region_check_overlay() - set overlay bit when the region is overlaid
  @region:	pointer to a structure that describes a SPI NOR erase region
  @erase:	pointer to a structure that describes a SPI NOR erase type
  @erase_type:	erase type bitmask
  spi_nor_init_non_uniform_erase_map() - initialize the non-uniform erase map
  @nor:	pointer to a 'struct spi_nor'
  @smpt:	pointer to the sector map parameter table
  Return: 0 on success, -errno otherwise.
	
	  The regions will be freed when the driver detaches from the
	  device.
 Populate regions. 
 index for the region dword 
		
		  Save the erase types that are supported in all regions and
		  can erase the entire flash memory.
		
		  regions_erase_type mask will indicate all the erase types
		  supported in this configuration map.
		
		  Roll back to the previous uniform_erase_type mask, SMPT is
		  broken.
	
	  BFPT advertises all the erase types supported by all the possible
	  map configurations. Mask out the erase types that are not supported
	  by the current map configuration.
  spi_nor_parse_smpt() - parse Sector Map Parameter Table
  @nor:		pointer to a 'struct spi_nor'
  @smpt_header:	sector map parameter table header
  This table is optional, but when available, we parse it to identify the
  location and size of sectors within the main data array of the flash memory
  device and to identify which Erase Types are supported by each sector.
  Return: 0 on success, -errno otherwise.
 Read the Sector Map Parameter Table. 
 Fix endianness of the SMPT DWORDs. 
 fall through 
  spi_nor_parse_4bait() - parse the 4-Byte Address Instruction Table
  @nor:		pointer to a 'struct spi_nor'.
  @param_header:	pointer to the 'struct sfdp_parameter_header' describing
 			the 4-Byte Address Instruction Table length and version.
  Return: 0 on success, -errno otherwise.
 not used ,		BIT(9) },
 not used ,		BIT(10) },
 not used ,		BIT(11) },
 not used ,		BIT(12) },
 Read the 4-byte Address Instruction Table. 
 Use a kmalloc'ed bounce buffer to guarantee it is DMA-able. 
 Fix endianness of the 4BAIT DWORDs. 
	
	  Compute the subset of (Fast) Read commands for which the 4-byte
	  version is supported.
	
	  Compute the subset of Page Program commands for which the 4-byte
	  version is supported.
		
		  The 4 Byte Address Instruction (Optional) Table is the only
		  SFDP table that indicates support for Page Program Commands.
		  Bypass the params->hwcaps.mask and consider 4BAIT the biggest
		  authority for specifying Page Program support.
	
	  Compute the subset of Sector Erase commands for which the 4-byte
	  version is supported.
 Replicate the sort done for the map's erase types in BFPT. 
	
	  We need at least one 4-byte op code per read, program and erase
	  operation; the .read(), .write() and .erase() hooks share the
	  nor->addr_width value.
	
	  Discard all operations from the 4-byte instruction set which are
	  not supported by this memory.
 Use the 4-byte address instruction set. 
 4BAIT is the only SFDP table that indicates page program support. 
		
		  Since xSPI Page Program opcode is backward compatible with
		  Legacy SPI, use Legacy SPI opcode there as well.
	
	  We set SNOR_F_HAS_4BAIT in order to skip spi_nor_set_4byte_opcodes()
	  later because we already did the conversion to 4byte opcodes. Also,
	  this latest function implements a legacy quirk for the erase size of
	  Spansion memory. However this quirk is no longer needed with new
	  SFDP compliant memories.
 fall through 
  spi_nor_parse_profile1() - parse the xSPI Profile 1.0 table
  @nor:		pointer to a 'struct spi_nor'
  @profile1_header:	pointer to the 'struct sfdp_parameter_header' describing
 			the Profile 1.0 Table length and version.
  Return: 0 on success, -errno otherwise.
 Get 8D-8D-8D fast read opcode and dummy cycles. 
 Set the Read Status Register dummy cycles and dummy address bytes. 
	
	  We don't know what speed the controller is running at. Find the
	  dummy cycles for the fastest frequency the flash can run at to be
	  sure we are never short of dummy cycles. A value of 0 means the
	  frequency is not supported.
	 
	  Default to PROFILE1_DUMMY_DEFAULT if we don't find anything, and let
	  flashes set the correct value if needed in their fixup hooks.
 Round up to an even value to avoid tripping controllers up. 
 Update the fast read settings. 
  spi_nor_parse_sccr() - Parse the Status, Control and Configuration Register
                         Map.
  @nor:		pointer to a 'struct spi_nor'
  @sccr_header:	pointer to the 'struct sfdp_parameter_header' describing
 			the SCCR Map table length and version.
  Return: 0 on success, -errno otherwise.
  spi_nor_parse_sfdp() - parse the Serial Flash Discoverable Parameters.
  @nor:		pointer to a 'struct spi_nor'
  The Serial Flash Discoverable Parameters are described by the JEDEC JESD216
  specification. This is a standard which tends to supported by almost all
  (Q)SPI memory manufacturers. Those hard-coded tables allow us to learn at
  runtime the main parameters needed to perform basic SPI flash operations such
  as Fast Read, Page Program or Sector Erase commands.
  Return: 0 on success, -errno otherwise.
 Get the SFDP header. 
 Check the SFDP header version. 
	
	  Verify that the first and only mandatory parameter header is a
	  Basic Flash Parameter Table header as specified in JESD216.
	
	  Allocate memory then read all parameter headers with a single
	  Read SFDP command. These parameter headers will actually be parsed
	  twice: a first time to get the latest revision of the basic flash
	  parameter table, then a second time to handle the supported optional
	  tables.
	  Hence we read the parameter headers once for all to reduce the
	  processing time. Also we use kmalloc() instead of devm_kmalloc()
	  because we don't need to keep these parameter headers: the allocated
	  memory is always released with kfree() before exiting this function.
	
	  Cache the complete SFDP data. It is not (easily) possible to fetch
	  SFDP after probe time and we need it for the sysfs access.
	
	  Limit the total size to a reasonable value to avoid allocating too
	  much memory just of because the flash returned some insane values.
	
	  The SFDP is organized in chunks of DWORDs. Thus, in theory, the
	  sfdp_size should be a multiple of DWORDs. But in case a flash
	  is not spec compliant, make sure that we have enough space to store
	  the complete SFDP data.
	
	  Check other parameter headers to get the latest revision of
	  the basic flash parameter table.
 Parse optional parameter tables. 
			
			  Let's not drop all information we extracted so far
			  if optional table parsers fail. In case of failing,
			  each optional parser is responsible to roll back to
			  the previously known spi_nor data.
 SPDX-License-Identifier: GPL-2.0-only
  SPI NOR driver for NXP SPI Flash Interface (SPIFI)
  Copyright (C) 2015 Joachim Eastwood <manabian@gmail.com>
  Based on Freescale QuadSPI driver:
  Copyright (C) 2013 Freescale Semiconductor, Inc.
 NXP SPIFI registers, bits and macros 
 Memory mode supports address length between 1 and 4 
 Setup control register defaults 
	
	  The first read on a hard reset isn't reliable so do a
	  dummy read of the id before calling spi_nor_scan().
	  The reason for this problem is unknown.
	 
	  The official NXP spifilib uses more or less the same
	  workaround that is applied here by reading the device
	  id multiple times.
 Initialize and reset device 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
  ASPEED Static Memory Controller driver
  Copyright (c) 2015-2016, IBM Corporation.
  The driver only support SPI flash
 maximum size of chip window 
 number of chip enables 
 flash type field exists in config reg 
 shift for write enable bit for CE0 
 offset in regs of ctl for CE0 
 base value without mode for other commands 
 command reg for (maybe fast) reads 
 command reg for writes 
 control register 
 base of chip window 
 chip mapping window size 
 control settings 
 what type of flash 
 controller access mutex 
 type info of controller 
 controller registers 
 per-chip windows resource 
 full mapping window size 
 pointers to attached chips 
  SPI Flash Configuration Register (AST2500 SPI)
      or
  Type setting Register (AST2500 FMC).
  CE0 and CE1 can only be of type SPI. CE2 can be of type NOR but the
  driver does not support it.
 1 
 AST2500 FMC only 
 AST2500 FMC only 
 AST2500 FMC only 
  CE Control Register
  CEx Control Register
 0 = 16T ... 15 = 1T   T=HCLK 
 others 
 AST2400 SPI 
  The Segment Register uses a 8MB unit to encode the start address
  and the end address of the mapping window of a flash SPI slave :
         | byte 1 | byte 2 | byte 3 | byte 4 |
         +--------+--------+--------+--------+
         |  end   |  start |   0    |   0    |
  In user mode all data bytes read or written to the chip decode address
  range are transferred to or from the SPI bus. The range is treated as a
  fifo of arbitratry 1, 2, or 4 byte width but each write has to be aligned
  to its size. The address within the multiple 8kB range is ignored when
  sending bytes to the SPI bus.
  On the arm architecture, as of Linux version 4.3, memcpy_fromio and
  memcpy_toio on little endian targets use the optimized memcpy routines
  that were designed for well behavied memory storage. These routines
  have a stutter if the source and destination are not both word aligned,
  once with a duplicate access to the source after aligning to the
  destination to a word boundary, and again with a duplicate access to
  the source when the final byte count is not word aligned.
  When writing or reading the fifo this stutter discards data or sends
  too much data to the fifo and can not be used by this driver.
  While the low level io string routines that implement the insl family do
  the desired accesses and memory increments, the cross architecture io
  macros make them essentially impossible to use on a memory mapped address
  instead of a a token from the call to iomap of an io port.
  These fifo routines use readl and friends to a constant io port and update
  the memory buffer pointer and count via explicit code. The final updates
  to len are optimistically suppressed.
	
	  When the chip is controlled in user mode, we need write
	  access to send the opcodes to it. So check the config.
 stop user CE control 
 default to fread or read mode 
  Each chip has a mapping window defined by a segment address
  register defining a start and an end address on the AHB bus. These
  addresses can be configured to fit the chip size and offer a
  contiguous memory region across chips. For the moment, we only
  check that each chip segment is valid.
	
	  If the chip size is not specified, use the default segment
	  size, but take into account the possible overlap with the
	  previous segment
	
	  The segment cannot exceed the maximum window size of the
	  controller.
	
	  Restore default value if something goes wrong. The chip
	  might have set some bogus value and we would loose access
	  to the chip.
  The segment register defines the mapping window on the AHB bus and
  it needs to be configured depending on the chip size. The segment
  register of the following CE also needs to be tuned in order to
  provide a contiguous window across multiple chips.
  This is expected to be called in increasing CE order
	
	  Each controller has a chip size limit for direct memory
	  access
	
	  The AST2400 SPI controller only handles one chip and does
	  not have segment registers. Let's use the chip size for the
	  AHB window.
	
	  The AST2500 SPI controller has a HW bug when the CE0 chip
	  size reaches 128MB. Enforce a size limit of 120MB to
	  prevent the controller from using bogus settings in the
	  segment register.
	
	  As a start address for the current segment, use the default
	  start address if we are handling CE0 or use the previous
	  segment ending address
 Update chip base address on the AHB bus 
	
	  Now, make sure the next segment does not overlap with the
	  current one we just configured, even if there is no
	  available chip. That could break access in Command Mode.
  The first chip of the AST2500 FMC flash controller is strapped by
  hardware, or autodetected, but other chips need to be set. Enforce
  the 4B setting for all chips.
  The AST2400 SPI flash controller does not have a CE Control
  register. It uses the CE0 control register to set 4Byte mode at the
  controller level.
	
	  Always turn on the write enable bit to allow opcodes to be
	  sent in user mode.
 The driver only supports SPI type flash 
	
	  Configure chip base address in memory
	
	  Get value of the inherited control register. U-Boot usually
	  does some timing calibration on the FMC chip, so it's good
	  to keep them. In the future, we should handle calibration
	  from Linux.
	
	  Retain the prior value of the control register as the
	  default if it was normal access mode. Otherwise start with
	  the sanitized base value set to read mode.
 This is for direct AHB access when using Command Mode. 
	
	  base mode has not been optimized yet. use it for writes.
	
	  TODO: Adjust clocks if fast read is supported and interpret
	  SPI NOR flags to adjust controller settings.
 This driver does not support NAND or NOR flash devices. 
		
		  TODO: Add support for Dual and Quad SPI protocols
		  attach when board support is present as determined
		  by of property.
 SPDX-License-Identifier: GPL-2.0-only
  Intel PCHPCU SPI flash driver.
  Copyright (C) 2016, Intel Corporation
  Author: Mika Westerberg <mika.westerberg@linux.intel.com>
 Offsets are from @ispi->base 
 HW sequencer opcodes 
 Offset is from @ispi->pregs 
 Offsets are from @ispi->sregs 
 CPU specifics 
 ms 
  struct intel_spi - Driver private data
  @dev: Device pointer
  @info: Pointer to board specific info
  @nor: SPI NOR layer structure
  @base: Beginning of MMIO space
  @pregs: Start of protection registers
  @sregs: Start of software sequencer registers
  @nregions: Maximum number of regions
  @pr_num: Maximum number of protected range registers
  @writeable: Is the chip writeable
  @locked: Is SPI setting locked
  @swseq_reg: Use SW sequencer in register readswrites
  @swseq_erase: Use SW sequencer in erase operation
  @erase_64k: 64k erase supported
  @atomic_preopcode: Holds preopcode when atomic sequence is requested
  @opcodes: Opcodes which are supported. This are programmed by BIOS
            before it locks down the controller.
 Reads max INTEL_SPI_FIFO_SZ bytes from the device fifo 
 Writes max INTEL_SPI_FIFO_SZ bytes to the device fifo 
 Disable write protection 
 Disable #SMI generation from HW sequencer 
	
	  Determine whether erase operation should use HW or SW sequencer.
	 
	  The HW sequencer has a predefined list of opcodes, with only the
	  erase opcode being programmable in LVSCC and UVSCC registers.
	  If these registers don't contain a valid erase opcode, erase
	  cannot be done using HW sequencer.
 SPI controller on Intel BXT supports 64K erase opcode 
	
	  Some controllers can only do basic operations using hardware
	  sequencer. All other operations are supposed to be carried out
	  using software sequencer.
 Disable #SMI generation from SW sequencer 
 Check controller's lock status 
		
		  BIOS programs allowed opcodes and then locks down the
		  register. So read back what opcodes it decided to support.
		  That's the set we are going to support as well.
 The lock is off, so just use index 0 
	
	  Always clear it after each SW sequencer operation regardless
	  of whether it is successful or not.
 Only mark 'Data Cycle' bit when there is data to be transferred 
 Pick matching preopcode for the atomic sequence 
 Do nothing 
 Enable atomic sequence 
 Address of the first chip 
	
	  This is handled with atomic operation and preop code in Intel
	  controller so we only verify that it is available. If the
	  controller is not locked, program the opcode to the PREOP
	  register for later use.
	 
	  When hardware sequencer is used there is no need to program
	  any opcodes (it handles them automatically as part of a command).
		
		  This enables atomic sequence on next SW sycle. Will
		  be cleared after next operation.
	
	  We hope that HW sequencer will do the right thing automatically and
	  with the SW sequencer we cannot use preopcode anyway, so just ignore
	  the Write Disable operation and pretend it was completed
	  successfully.
 Write the value beforehand 
	
	  Atomic sequence is not expected with HW sequencer reads. Make
	  sure it is cleared regardless.
 Read cannot cross 4K boundary 
 Not needed with HW sequencer write, make sure it is cleared 
 Write cannot cross 4K boundary 
 Start the write now 
 If the hardware can do 64k erase use that when possible 
 Not needed with HW sequencer erase, make sure it is cleared 
  There will be a single partition holding all enabled flash regions. We
  call this "BIOS".
 Start from the mandatory descriptor region 
	
	  Now try to find where this partition ends based on the flash
	  region registers.
		
		  If any of the regions have protection bits set, make the
		  whole partition read-only to be on the safe side.
 Prevent writes if not explicitly enabled 
 SPDX-License-Identifier: GPL-2.0-only
  Intel PCHPCU SPI flash platform driver.
  Copyright (C) 2016, Intel Corporation
  Author: Mika Westerberg <mika.westerberg@linux.intel.com>
 SPDX-License-Identifier: GPL-2.0-or-later
  HiSilicon FMC SPI NOR flash controller driver
  Copyright (c) 2015-2016 HiSilicon Technologies Co., Ltd.
 Hardware register offsets and field definitions 
  Get spi flash device information and register it as a mtd device.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  Intel PCHPCU SPI flash PCI driver.
  Copyright (C) 2016, Intel Corporation
  Author: Mika Westerberg <mika.westerberg@linux.intel.com>
 Try to make the chip readwrite 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) International Business Machines Corp., 2006
  Copyright (c) Nokia Corporation, 2006, 2007
  Author: Artem Bityutskiy ( )
  UBI inputoutput sub-system.
  This sub-system provides a uniform way to work with all kinds of the
  underlying MTD devices. It also implements handy functions for reading and
  writing UBI headers.
  We are trying to have a paranoid mindset and not to trust to what we read
  from the flash media in order to be more secure and robust. So this
  sub-system validates every single header it reads from the flash media.
  Some words about how the eraseblock headers are stored.
  The erase counter header is always stored at offset zero. By default, the
  VID header is stored after the EC header at the closest aligned offset
  (i.e. aligned to the minimum IO unit size). Data starts next to the VID
  header at the closest aligned offset. But this default layout may be
  changed. For example, for different reasons (e.g., optimization) UBI may be
  asked to put the VID header at further offset, and even at an unaligned
  offset. Of course, if the offset of the VID header is unaligned, UBI adds
  proper padding in front of it. Data offset may also be changed but it has to
  be aligned.
  About minimal IO units. In general, UBI assumes flash device model where
  there is only one minimal IO unit size. E.g., in case of NOR flash it is 1,
  in case of NAND flash it is a NAND page, etc. This is reported by MTD in the
  @ubi->mtd->writesize field. But as an exception, UBI admits use of another
  (smaller) minimal IO unit size for EC and VID headers to make it possible
  to do different optimizations.
  This is extremely useful in case of NAND flashes which admit of several
  write operations to one NAND page. In this case UBI can fit EC and VID
  headers at one NAND page. Thus, UBI may use "sub-page" size as the minimal
  IO unit for the headers (the @ubi->hdrs_min_io_size field). But it still
  reports NAND page size (@ubi->min_io_size) as a minimal IO unit for the UBI
  users.
  Example: some Samsung NANDs with 2KiB pages allow 4x 512-byte writes, so
  although the minimal IO unit is 2K, UBI uses 512 bytes for EC and VID
  headers.
  Q: why not just to treat sub-page as a minimal IO unit of this flash
  device, e.g., make @ubi->min_io_size = 512 in the example above?
  A: because when writing a sub-page, MTD still writes a full 2K page but the
  bytes which are not relevant to the sub-page are 0xFF. So, basically,
  writing 4x512 sub-pages is 4 times slower than writing one 2KiB NAND page.
  Thus, we prefer to use sub-pages only for EC and VID headers.
  As it was noted above, the VID header may start at a non-aligned offset.
  For example, in case of a 2KiB page NAND flash with a 512 bytes sub-page,
  the VID header may reside at offset 1984 which is the last 64 bytes of the
  last sub-page (EC header is always at offset zero). This causes some
  difficulties when reading and writing VID headers.
  Suppose we have a 64-byte buffer and we read a VID header at it. We change
  the data and want to write this VID header out. As we can only write in
  512-byte chunks, we have to allocate one more buffer and copy our VID header
  to offset 448 of this buffer.
  The IO sub-system does the following trick in order to avoid this extra
  copy. It always allocates a @ubi->vid_hdr_alsize bytes buffer for the VID
  header and returns a pointer to offset @ubi->vid_hdr_shift of this buffer.
  When the VID header is being written out, it shifts the VID header pointer
  back and writes the whole sub-page.
  ubi_io_read - read data from a physical eraseblock.
  @ubi: UBI device description object
  @buf: buffer where to store the read data
  @pnum: physical eraseblock number to read from
  @offset: offset within the physical eraseblock from where to read
  @len: how many bytes to read
  This function reads data from offset @offset of physical eraseblock @pnum
  and stores the read data in the @buf buffer. The following return codes are
  possible:
  o %0 if all the requested data were successfully read;
  o %UBI_IO_BITFLIPS if all the requested data were successfully read, but
    correctable bit-flips were detected; this is harmless but may indicate
    that this eraseblock may become bad soon (but do not have to);
  o %-EBADMSG if the MTD subsystem reported about data integrity problems, for
    example it can be an ECC error in case of NAND; this most probably means
    that the data is corrupted;
  o %-EIO if some IO error occurred;
  o other negative error codes in case of other errors.
	
	  Deliberately corrupt the buffer to improve robustness. Indeed, if we
	  do not do this, the following may happen:
	  1. The buffer contains data from previous operation, e.g., read from
	     another PEB previously. The data looks like expected, e.g., if we
	     just do not read anything and return - the caller would not
	     notice this. E.g., if we are reading a VID header, the buffer may
	     contain a valid VID header from another PEB.
	  2. The driver is buggy and returns us success or -EBADMSG or
	     -EUCLEAN, but it does not actually put any data to the buffer.
	 
	  This may confuse UBI or upper layers - they may think the buffer
	  contains valid data while in fact it is just old data. This is
	  especially possible because UBI (and UBIFS) relies on CRC, and
	  treats data as correct even in case of ECC errors if the CRC is
	  correct.
	 
	  Try to prevent this situation by changing the first byte of the
	  buffer.
			
			  -EUCLEAN is reported if there was a bit-flip which
			  was corrected, so this is harmless.
			 
			  We do not report about it here unless debugging is
			  enabled. A corresponding message will be printed
			  later, when it is has been scrubbed.
		
		  The driver should never return -EBADMSG if it failed to read
		  all the requested data. But some buggy drivers might do
		  this, so we change it to -EIO.
  ubi_io_write - write data to a physical eraseblock.
  @ubi: UBI device description object
  @buf: buffer with the data to write
  @pnum: physical eraseblock number to write to
  @offset: offset within the physical eraseblock where to write
  @len: how many bytes to write
  This function writes @len bytes of data from buffer @buf to offset @offset
  of physical eraseblock @pnum. If all the data were successfully written,
  zero is returned. If an error occurred, this function returns a negative
  error code. If %-EIO is returned, the physical eraseblock most probably went
  bad.
  Note, in case of an error, it is possible that something was still written
  to the flash media, but may be some garbage.
 The area we are writing to has to contain all 0xFF bytes 
		
		  We write to the data area of the physical eraseblock. Make
		  sure it has valid EC and VID headers.
		
		  Since we always write sequentially, the rest of the PEB has
		  to contain only 0xFF bytes.
  do_sync_erase - synchronously erase a physical eraseblock.
  @ubi: UBI device description object
  @pnum: the physical eraseblock number to erase
  This function synchronously erases physical eraseblock @pnum and returns
  zero in case of success and a negative error code in case of failure. If
  %-EIO is returned, the physical eraseblock most probably went bad.
 Patterns to write to a physical eraseblock when torturing it 
  torture_peb - test a supposedly bad physical eraseblock.
  @ubi: UBI device description object
  @pnum: the physical eraseblock number to test
  This function returns %-EIO if the physical eraseblock did not pass the
  test, a positive number of erase operations done if the test was
  successfully passed, and other negative error codes in case of other errors.
 Make sure the PEB contains only 0xFF bytes 
 Write a pattern and check it 
		
		  If a bit-flip or data integrity error was detected, the test
		  has not passed because it happened on a freshly erased
		  physical eraseblock which means something is wrong with it.
  nor_erase_prepare - prepare a NOR flash PEB for erasure.
  @ubi: UBI device description object
  @pnum: physical eraseblock number to prepare
  NOR flash, or at least some of them, have peculiar embedded PEB erasure
  algorithm: the PEB is first filled with zeroes, then it is erased. And
  filling with zeroes starts from the end of the PEB. This was observed with
  Spansion S29GL512N NOR flash.
  This means that in case of a power cut we may end up with intact data at the
  beginning of the PEB, and all zeroes at the end of PEB. In other words, the
  EC and VID headers are OK, but a large chunk of data at the end of PEB is
  zeroed. This makes UBI mistakenly treat this PEB as used and associate it
  with an LEB, which leads to subsequent failures (e.g., UBIFS fails).
  This function is called before erasing NOR PEBs and it zeroes out EC and VID
  magic numbers in order to invalidate them and prevent the failures. Returns
  zero in case of success and a negative error code in case of failure.
	
	  Note, we cannot generally define VID header buffers on stack,
	  because of the way we deal with these buffers (see the header
	  comment in this file). But we know this is a NOR-specific piece of
	  code, so we can do this. But yes, this is error-prone and we should
	  (pre-)allocate VID header buffer instead.
	
	  If VID or EC is valid, we have to corrupt them before erasing.
	  It is important to first invalidate the EC header, and then the VID
	  header. Otherwise a power cut may lead to valid EC header and
	  invalid VID header, in which case UBI will treat this PEB as
	  corrupted and will try to preserve it, and print scary warnings.
	
	  The PEB contains a valid VID or EC header, but we cannot invalidate
	  it. Supposedly the flash media or the driver is screwed up, so
	  return an error.
  ubi_io_sync_erase - synchronously erase a physical eraseblock.
  @ubi: UBI device description object
  @pnum: physical eraseblock number to erase
  @torture: if this physical eraseblock has to be tortured
  This function synchronously erases physical eraseblock @pnum. If @torture
  flag is not zero, the physical eraseblock is checked by means of writing
  different patterns to it and reading them back. If the torturing is enabled,
  the physical eraseblock is erased more than once.
  This function returns the number of erasures made in case of success, %-EIO
  if the erasure failed or the torturing test failed, and other negative error
  codes in case of other errors. Note, %-EIO means that the physical
  eraseblock is bad.
	
	  If the flash is ECC-ed then we have to erase the ECC block before we
	  can write to it. But the write is in preparation to an erase in the
	  first place. This means we cannot zero out EC and VID before the
	  erase and we just have to hope the flash starts erasing from the
	  start of the page.
  ubi_io_is_bad - check if a physical eraseblock is bad.
  @ubi: UBI device description object
  @pnum: the physical eraseblock number to check
  This function returns a positive number if the physical eraseblock is bad,
  zero if not, and a negative error code if an error occurred.
  ubi_io_mark_bad - mark a physical eraseblock as bad.
  @ubi: UBI device description object
  @pnum: the physical eraseblock number to mark
  This function returns zero in case of success and a negative error code in
  case of failure.
  validate_ec_hdr - validate an erase counter header.
  @ubi: UBI device description object
  @ec_hdr: the erase counter header to check
  This function returns zero if the erase counter header is OK, and %1 if
  not.
  ubi_io_read_ec_hdr - read and check an erase counter header.
  @ubi: UBI device description object
  @pnum: physical eraseblock to read from
  @ec_hdr: a &struct ubi_ec_hdr object where to store the read erase counter
  header
  @verbose: be verbose if the header is corrupted or was not found
  This function reads erase counter header from physical eraseblock @pnum and
  stores it in @ec_hdr. This function also checks CRC checksum of the read
  erase counter header. The following codes may be returned:
  o %0 if the CRC checksum is correct and the header was successfully read;
  o %UBI_IO_BITFLIPS if the CRC is correct, but bit-flips were detected
    and corrected by the flash driver; this is harmless but may indicate that
    this eraseblock may become bad soon (but may be not);
  o %UBI_IO_BAD_HDR if the erase counter header is corrupted (a CRC error);
  o %UBI_IO_BAD_HDR_EBADMSG is the same as %UBI_IO_BAD_HDR, but there also was
    a data integrity error (uncorrectable ECC error in case of NAND);
  o %UBI_IO_FF if only 0xFF bytes were read (the PEB is supposedly empty)
  o a negative error code in case of failure.
		
		  We read all the data, but either a correctable bit-flip
		  occurred, or MTD reported a data integrity error
		  (uncorrectable ECC error in case of NAND). The former is
		  harmless, the later may mean that the read data is
		  corrupted. But we have a CRC check-sum and we will detect
		  this. If the EC header is still OK, we just report this as
		  there was a bit-flip, to force scrubbing.
		
		  The magic field is wrong. Let's check if we have read all
		  0xFF. If yes, this physical eraseblock is assumed to be
		  empty.
 The physical eraseblock is supposedly empty 
		
		  This is not a valid erase counter header, and these are not
		  0xFF bytes. Report that the header is corrupted.
 And of course validate what has just been read from the media 
	
	  If there was %-EBADMSG, but the header CRC is still OK, report about
	  a bit-flip to force scrubbing on this PEB.
  ubi_io_write_ec_hdr - write an erase counter header.
  @ubi: UBI device description object
  @pnum: physical eraseblock to write to
  @ec_hdr: the erase counter header to write
  This function writes erase counter header described by @ec_hdr to physical
  eraseblock @pnum. It also fills most fields of @ec_hdr before writing, so
  the caller do not have to fill them. Callers must only fill the @ec_hdr->ec
  field.
  This function returns zero in case of success and a negative error code in
  case of failure. If %-EIO is returned, the physical eraseblock most probably
  went bad.
  validate_vid_hdr - validate a volume identifier header.
  @ubi: UBI device description object
  @vid_hdr: the volume identifier header to check
  This function checks that data stored in the volume identifier header
  @vid_hdr. Returns zero if the VID header is OK and %1 if not.
		
		  Although from high-level point of view static volumes may
		  contain zero bytes of data, but no VID headers can contain
		  zero at these fields, because they empty volumes do not have
		  mapped logical eraseblocks.
  ubi_io_read_vid_hdr - read and check a volume identifier header.
  @ubi: UBI device description object
  @pnum: physical eraseblock number to read from
  @vidb: the volume identifier buffer to store data in
  @verbose: be verbose if the header is corrupted or wasn't found
  This function reads the volume identifier header from physical eraseblock
  @pnum and stores it in @vidb. It also checks CRC checksum of the read
  volume identifier header. The error codes are the same as in
  'ubi_io_read_ec_hdr()'.
  Note, the implementation of this function is also very similar to
  'ubi_io_read_ec_hdr()', so refer commentaries in 'ubi_io_read_ec_hdr()'.
  ubi_io_write_vid_hdr - write a volume identifier header.
  @ubi: UBI device description object
  @pnum: the physical eraseblock number to write to
  @vidb: the volume identifier buffer to write
  This function writes the volume identifier header described by @vid_hdr to
  physical eraseblock @pnum. This function automatically fills the
  @vidb->hdr->magic and the @vidb->hdr->version fields, as well as calculates
  header CRC checksum and stores it at vidb->hdr->hdr_crc.
  This function returns zero in case of success and a negative error code in
  case of failure. If %-EIO is returned, the physical eraseblock probably went
  bad.
  self_check_not_bad - ensure that a physical eraseblock is not bad.
  @ubi: UBI device description object
  @pnum: physical eraseblock number to check
  This function returns zero if the physical eraseblock is good, %-EINVAL if
  it is bad and a negative error code if an error occurred.
  self_check_ec_hdr - check if an erase counter header is all right.
  @ubi: UBI device description object
  @pnum: physical eraseblock number the erase counter header belongs to
  @ec_hdr: the erase counter header to check
  This function returns zero if the erase counter header contains valid
  values, and %-EINVAL if not.
  self_check_peb_ec_hdr - check erase counter header.
  @ubi: UBI device description object
  @pnum: the physical eraseblock number to check
  This function returns zero if the erase counter header is all right and and
  a negative error code if not or if an error occurred.
  self_check_vid_hdr - check that a volume identifier header is all right.
  @ubi: UBI device description object
  @pnum: physical eraseblock number the volume identifier header belongs to
  @vid_hdr: the volume identifier header to check
  This function returns zero if the volume identifier header is all right, and
  %-EINVAL if not.
  self_check_peb_vid_hdr - check volume identifier header.
  @ubi: UBI device description object
  @pnum: the physical eraseblock number to check
  This function returns zero if the volume identifier header is all right,
  and a negative error code if not or if an error occurred.
  self_check_write - make sure write succeeded.
  @ubi: UBI device description object
  @buf: buffer with data which were written
  @pnum: physical eraseblock number the data were written to
  @offset: offset within the physical eraseblock the data were written to
  @len: how many bytes were written
  This functions reads data which were recently written and compares it with
  the original data buffer - the data have to match. Returns zero if the data
  match and a negative error code if not or in case of failure.
  ubi_self_check_all_ff - check that a region of flash is empty.
  @ubi: UBI device description object
  @pnum: the physical eraseblock number to check
  @offset: the starting offset within the physical eraseblock to check
  @len: the length of the region to check
  This function returns zero if only 0xFF bytes are present at offset
  @offset of the physical eraseblock @pnum, and a negative error code if not
  or if an error occurred.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) International Business Machines Corp., 2006
  Author: Artem Bityutskiy ( ), Joern Engel
  This is a small driver which implements fake MTD devices on top of UBI
  volumes. This sounds strange, but it is in fact quite useful to make
  MTD-oriented software (including all the legacy software) work on top of
  UBI.
  Gluebi emulates MTD devices of "MTD_UBIVOLUME" type. Their minimal IO unit
  size (@mtd->writesize) is equivalent to the UBI minimal IO unit. The
  eraseblock size is equivalent to the logical eraseblock size of the volume.
  struct gluebi_device - a gluebi device description data structure.
  @mtd: emulated MTD device description object
  @refcnt: gluebi device reference count
  @desc: UBI volume descriptor
  @ubi_num: UBI device number this gluebi device works on
  @vol_id: ID of UBI volume this gluebi device works on
  @list: link in a list of gluebi devices
 List of all gluebi devices 
  find_gluebi_nolock - find a gluebi device.
  @ubi_num: UBI device number
  @vol_id: volume ID
  This function seraches for gluebi device corresponding to UBI device
  @ubi_num and UBI volume @vol_id. Returns the gluebi device description
  object in case of success and %NULL in case of failure. The caller has to
  have the &devices_mutex locked.
  gluebi_get_device - get MTD device reference.
  @mtd: the MTD device description object
  This function is called every time the MTD device is being opened and
  implements the MTD get_device() operation. Returns zero in case of success
  and a negative error code in case of failure.
		
		  The MTD device is already referenced and this is just one
		  more reference. MTD allows many users to open the same
		  volume simultaneously and do not distinguish between
		  readerswritersexclusivemeta openers as UBI does. So we do
		  not open the UBI volume again - just increase the reference
		  counter and return.
	
	  This is the first reference to this UBI volume via the MTD device
	  interface. Open the corresponding volume in read-write mode.
  gluebi_put_device - put MTD device reference.
  @mtd: the MTD device description object
  This function is called every time the MTD device is being put. Returns
  zero in case of success and a negative error code in case of failure.
  gluebi_read - read operation of emulated MTD devices.
  @mtd: MTD device description object
  @from: absolute offset from where to read
  @len: how many bytes to read
  @retlen: count of read bytes is returned here
  @buf: buffer to store the read data
  This function returns zero in case of success and a negative error code in
  case of failure.
  gluebi_write - write operation of emulated MTD devices.
  @mtd: MTD device description object
  @to: absolute offset where to write
  @len: how many bytes to write
  @retlen: count of written bytes is returned here
  @buf: buffer with data to write
  This function returns zero in case of success and a negative error code in
  case of failure.
  gluebi_erase - erase operation of emulated MTD devices.
  @mtd: the MTD device description object
  @instr: the erase operation description
  This function calls the erase callback when finishes. Returns zero in case
  of success and a negative error code in case of failure.
	
	  MTD erase operations are synchronous, so we have to make sure the
	  physical eraseblock is wiped out.
	 
	  Thus, perform leb_erase instead of leb_unmap operation - leb_erase
	  will wait for the end of operations
  gluebi_create - create a gluebi device for an UBI volume.
  @di: UBI device description object
  @vi: UBI volume description object
  This function is called when a new UBI volume is created in order to create
  corresponding fake MTD device. Returns zero in case of success and a
  negative error code in case of failure.
	
	  In case of dynamic a volume, MTD device size is just volume size. In
	  case of a static volume the size is equivalent to the amount of data
	  bytes.
 Just a sanity check - make sure this gluebi device does not exist 
  gluebi_remove - remove a gluebi device.
  @vi: UBI volume description object
  This function is called when an UBI volume is removed and it removes
  corresponding fake MTD device. Returns zero in case of success and a
  negative error code in case of failure.
  gluebi_updated - UBI volume was updated notifier.
  @vi: volume info structure
  This function is called every time an UBI volume is updated. It does nothing
  if te volume @vol is dynamic, and changes MTD device size if the
  volume is static. This is needed because static volumes cannot be read past
  data they contain. This function returns zero in case of success and a
  negative error code in case of error.
  gluebi_resized - UBI volume was re-sized notifier.
  @vi: volume info structure
  This function is called every time an UBI volume is re-size. It changes the
  corresponding fake MTD device size. This function returns zero in case of
  success and a negative error code in case of error.
  gluebi_notify - UBI notification handler.
  @nb: registered notifier block
  @l: notification type
  @ns_ptr: pointer to the &struct ubi_notification object
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) International Business Machines Corp., 2006
  Author: Artem Bityutskiy ( )
 This file mostly implements UBI kernel API functions 
  ubi_do_get_device_info - get information about UBI device.
  @ubi: UBI device description object
  @di: the information is stored here
  This function is the same as 'ubi_get_device_info()', but it assumes the UBI
  device is locked and cannot disappear.
  ubi_get_device_info - get information about UBI device.
  @ubi_num: UBI device number
  @di: the information is stored here
  This function returns %0 in case of success, %-EINVAL if the UBI device
  number is invalid, and %-ENODEV if there is no such UBI device.
  ubi_do_get_volume_info - get information about UBI volume.
  @ubi: UBI device description object
  @vol: volume description object
  @vi: the information is stored here
  ubi_get_volume_info - get information about UBI volume.
  @desc: volume descriptor
  @vi: the information is stored here
  ubi_open_volume - open UBI volume.
  @ubi_num: UBI device number
  @vol_id: volume ID
  @mode: open mode
  The @mode parameter specifies if the volume should be opened in read-only
  mode, read-write mode, or exclusive mode. The exclusive mode guarantees that
  nobody else will be able to open this volume. UBI allows to have many volume
  readers and one writer at a time.
  If a static volume is being opened for the first time since boot, it will be
  checked by this function, which means it will be fully read and the CRC
  checksum of each logical eraseblock will be checked.
  This function returns volume descriptor in case of success and a negative
  error code in case of failure.
	
	  First of all, we have to get the UBI device to prevent its removal.
 This is the first open - check the volume 
  ubi_open_volume_nm - open UBI volume by name.
  @ubi_num: UBI device number
  @name: volume name
  @mode: open mode
  This function is similar to 'ubi_open_volume()', but opens a volume by name.
 Walk all volumes of this UBI device 
	
	  We should put the UBI device even in case of success, because
	  'ubi_open_volume()' took a reference as well.
  ubi_open_volume_path - open UBI volume by its character device node path.
  @pathname: volume character device node path
  @mode: open mode
  This function is similar to 'ubi_open_volume()', but opens a volume the path
  to its character device node.
  ubi_close_volume - close UBI volume.
  @desc: volume descriptor
  leb_read_sanity_check - does sanity checks on read requests.
  @desc: volume descriptor
  @lnum: logical eraseblock number to read from
  @offset: offset within the logical eraseblock to read from
  @len: how many bytes to read
  This function is used by ubi_leb_read() and ubi_leb_read_sg()
  to perform sanity checks.
 Empty static UBI volume 
  ubi_leb_read - read data.
  @desc: volume descriptor
  @lnum: logical eraseblock number to read from
  @buf: buffer where to store the read data
  @offset: offset within the logical eraseblock to read from
  @len: how many bytes to read
  @check: whether UBI has to check the read data's CRC or not.
  This function reads data from offset @offset of logical eraseblock @lnum and
  stores the data at @buf. When reading from static volumes, @check specifies
  whether the data has to be checked or not. If yes, the whole logical
  eraseblock will be read and its CRC checksum will be checked (i.e., the CRC
  checksum is per-eraseblock). So checking may substantially slow down the
  read speed. The @check argument is ignored for dynamic volumes.
  In case of success, this function returns zero. In case of failure, this
  function returns a negative error code.
  %-EBADMSG error code is returned:
  o for both static and dynamic volumes if MTD driver has detected a data
    integrity problem (unrecoverable ECC checksum mismatch in case of NAND);
  o for static volumes in case of data CRC mismatch.
  If the volume is damaged because of an interrupted update this function just
  returns immediately with %-EBADF error code.
  ubi_leb_read_sg - read data into a scatter gather list.
  @desc: volume descriptor
  @lnum: logical eraseblock number to read from
  @sgl: UBI scatter gather list to store the read data
  @offset: offset within the logical eraseblock to read from
  @len: how many bytes to read
  @check: whether UBI has to check the read data's CRC or not.
  This function works exactly like ubi_leb_read_sg(). But instead of
  storing the read data into a buffer it writes to an UBI scatter gather
  list.
  ubi_leb_write - write data.
  @desc: volume descriptor
  @lnum: logical eraseblock number to write to
  @buf: data to write
  @offset: offset within the logical eraseblock where to write
  @len: how many bytes to write
  This function writes @len bytes of data from @buf to offset @offset of
  logical eraseblock @lnum.
  This function takes care of physical eraseblock write failures. If write to
  the physical eraseblock write operation fails, the logical eraseblock is
  re-mapped to another physical eraseblock, the data is recovered, and the
  write finishes. UBI has a pool of reserved physical eraseblocks for this.
  If all the data were successfully written, zero is returned. If an error
  occurred and UBI has not been able to recover from it, this function returns
  a negative error code. Note, in case of an error, it is possible that
  something was still written to the flash media, but that may be some
  garbage.
  If the volume is damaged because of an interrupted update this function just
  returns immediately with %-EBADF code.
  ubi_leb_change - change logical eraseblock atomically.
  @desc: volume descriptor
  @lnum: logical eraseblock number to change
  @buf: data to write
  @len: how many bytes to write
  This function changes the contents of a logical eraseblock atomically. @buf
  has to contain new logical eraseblock data, and @len - the length of the
  data, which has to be aligned. The length may be shorter than the logical
  eraseblock size, ant the logical eraseblock may be appended to more times
  later on. This function guarantees that in case of an unclean reboot the old
  contents is preserved. Returns zero in case of success and a negative error
  code in case of failure.
  ubi_leb_erase - erase logical eraseblock.
  @desc: volume descriptor
  @lnum: logical eraseblock number
  This function un-maps logical eraseblock @lnum and synchronously erases the
  correspondent physical eraseblock. Returns zero in case of success and a
  negative error code in case of failure.
  If the volume is damaged because of an interrupted update this function just
  returns immediately with %-EBADF code.
  ubi_leb_unmap - un-map logical eraseblock.
  @desc: volume descriptor
  @lnum: logical eraseblock number
  This function un-maps logical eraseblock @lnum and schedules the
  corresponding physical eraseblock for erasure, so that it will eventually be
  physically erased in background. This operation is much faster than the
  erase operation.
  Unlike erase, the un-map operation does not guarantee that the logical
  eraseblock will contain all 0xFF bytes when UBI is initialized again. For
  example, if several logical eraseblocks are un-mapped, and an unclean reboot
  happens after this, the logical eraseblocks will not necessarily be
  un-mapped again when this MTD device is attached. They may actually be
  mapped to the same physical eraseblocks again. So, this function has to be
  used with care.
  In other words, when un-mapping a logical eraseblock, UBI does not store
  any information about this on the flash media, it just marks the logical
  eraseblock as "un-mapped" in RAM. If UBI is detached before the physical
  eraseblock is physically erased, it will be mapped again to the same logical
  eraseblock when the MTD device is attached again.
  The main and obvious use-case of this function is when the contents of a
  logical eraseblock has to be re-written. Then it is much more efficient to
  first un-map it, then write new data, rather than first erase it, then write
  new data. Note, once new data has been written to the logical eraseblock,
  UBI guarantees that the old contents has gone forever. In other words, if an
  unclean reboot happens after the logical eraseblock has been un-mapped and
  then written to, it will contain the last written data.
  This function returns zero in case of success and a negative error code in
  case of failure. If the volume is damaged because of an interrupted update
  this function just returns immediately with %-EBADF code.
  ubi_leb_map - map logical eraseblock to a physical eraseblock.
  @desc: volume descriptor
  @lnum: logical eraseblock number
  This function maps an un-mapped logical eraseblock @lnum to a physical
  eraseblock. This means, that after a successful invocation of this
  function the logical eraseblock @lnum will be empty (contain only %0xFF
  bytes) and be mapped to a physical eraseblock, even if an unclean reboot
  happens.
  This function returns zero in case of success, %-EBADF if the volume is
  damaged because of an interrupted update, %-EBADMSG if the logical
  eraseblock is already mapped, and other negative error codes in case of
  other failures.
  ubi_is_mapped - check if logical eraseblock is mapped.
  @desc: volume descriptor
  @lnum: logical eraseblock number
  This function checks if logical eraseblock @lnum is mapped to a physical
  eraseblock. If a logical eraseblock is un-mapped, this does not necessarily
  mean it will still be un-mapped after the UBI device is re-attached. The
  logical eraseblock may become mapped to the physical eraseblock it was last
  mapped to.
  This function returns %1 if the LEB is mapped, %0 if not, and a negative
  error code in case of failure. If the volume is damaged because of an
  interrupted update this function just returns immediately with %-EBADF error
  code.
  ubi_sync - synchronize UBI device buffers.
  @ubi_num: UBI device to synchronize
  The underlying MTD device may cache data in hardware or in software. This
  function ensures the caches are flushed. Returns zero in case of success and
  a negative error code in case of failure.
  ubi_flush - flush UBI work queue.
  @ubi_num: UBI device to flush work queue
  @vol_id: volume id to flush for
  @lnum: logical eraseblock number to flush for
  This function executes all pending works for a particular volume id  logical
  eraseblock number pair. If either value is set to %UBI_ALL, then it acts as
  a wildcard for all of the corresponding volume numbers or logical
  eraseblock numbers. It returns zero in case of success and a negative error
  code in case of failure.
  ubi_register_volume_notifier - register a volume notifier.
  @nb: the notifier description object
  @ignore_existing: if non-zero, do not send "added" notification for all
                    already existing volumes
  This function registers a volume notifier, which means that
  'nb->notifier_call()' will be invoked when an UBI  volume is created,
  removed, re-sized, re-named, or updated. The first argument of the function
  is the notification type. The second argument is pointer to a
  &struct ubi_notification object which describes the notification event.
  Using UBI API from the volume notifier is prohibited.
  This function returns zero in case of success and a negative error code
  in case of failure.
	
	  We are going to walk all UBI devices and all volumes, and
	  notify the user about existing volumes by the %UBI_VOLUME_ADDED
	  event. We have to lock the @ubi_devices_mutex to make sure UBI
	  devices do not disappear.
  ubi_unregister_volume_notifier - unregister the volume notifier.
  @nb: the notifier description object
  This function unregisters volume notifier @nm and returns zero in case of
  success and a negative error code in case of failure.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) International Business Machines Corp., 2006
  Copyright (c) Nokia Corporation, 2006
  Author: Artem Bityutskiy ( )
  Jan 2007: Alexander Schmidt, hacked per-volume update.
  This file contains implementation of the volume update and atomic LEB change
  functionality.
  The update operation is based on the per-volume update marker which is
  stored in the volume table. The update marker is set before the update
  starts, and removed after the update has been finished. So if the update was
  interrupted by an unclean re-boot or due to some other reasons, the update
  marker stays on the flash media and UBI finds it when it attaches the MTD
  device next time. If the update marker is set for a volume, the volume is
  treated as damaged and most IO operations are prohibited. Only a new update
  operation is allowed.
  Note, in general it is possible to implement the update operation as a
  transaction with a roll-back capability.
  set_update_marker - set update marker.
  @ubi: UBI device description object
  @vol: volume description object
  This function sets the update marker flag for volume @vol. Returns zero
  in case of success and a negative error code in case of failure.
  clear_update_marker - clear update marker.
  @ubi: UBI device description object
  @vol: volume description object
  @bytes: new data size in bytes
  This function clears the update marker for volume @vol, sets new volume
  data size and clears the "corrupted" flag (static volumes only). Returns
  zero in case of success and a negative error code in case of failure.
  ubi_start_update - start volume update.
  @ubi: UBI device description object
  @vol: volume description object
  @bytes: update bytes
  This function starts volume update operation. If @bytes is zero, the volume
  is just wiped out. Returns zero in case of success and a negative error code
  in case of failure.
 Before updating - wipe out the volume 
  ubi_start_leb_change - start atomic LEB change.
  @ubi: UBI device description object
  @vol: volume description object
  @req: operation request
  This function starts atomic LEB change operation. Returns zero in case of
  success and a negative error code in case of failure.
  write_leb - write update data.
  @ubi: UBI device description object
  @vol: volume description object
  @lnum: logical eraseblock number
  @buf: data to write
  @len: data size
  @used_ebs: how many logical eraseblocks will this volume contain (static
  volumes only)
  This function writes update data to corresponding logical eraseblock. In
  case of dynamic volume, this function checks if the data contains 0xFF bytes
  at the end. If yes, the 0xFF bytes are cut and not written. So if the whole
  buffer contains only 0xFF bytes, the LEB is left unmapped.
  The reason why we skip the trailing 0xFF bytes in case of dynamic volume is
  that we want to make sure that more data may be appended to the logical
  eraseblock in future. Indeed, writing 0xFF bytes may have side effects and
  this PEB won't be writable anymore. So if one writes the file-system image
  to the UBI volume where 0xFFs mean free space - UBI makes sure this free
  space is writable after the update.
  We do not do this for static volumes because they are read-only. But this
  also cannot be done because we have to store per-LEB CRC and the correct
  data length.
  This function returns zero in case of success and a negative error code in
  case of failure.
		
		  When writing static volume, and this is the last logical
		  eraseblock, the length (@len) does not have to be aligned to
		  the minimal flash IO unit. The 'ubi_eba_write_leb_st()'
		  function accepts exact (unaligned) length and stores it in
		  the VID header. And it takes care of proper alignment by
		  padding the buffer. Here we just make sure the padding will
		  contain zeros, not random trash.
  ubi_more_update_data - write more update data.
  @ubi: UBI device description object
  @vol: volume description object
  @buf: write data (user-space memory buffer)
  @count: how much bytes to write
  This function writes more data to the volume which is being updated. It may
  be called arbitrary number of times until all the update data arriveis. This
  function returns %0 in case of success, number of bytes written during the
  last call if the whole volume update has been successfully finished, and a
  negative error code in case of failure.
	
	  When updating volumes, we accumulate whole logical eraseblock of
	  data and write it at once.
		
		  This is a write to the middle of the logical eraseblock. We
		  copy the data to our update buffer and wait for more data or
		  flush it if the whole eraseblock is written or the update
		  is finished.
			
			  OK, we gathered either the whole eraseblock or this
			  is the last chunk, it's time to flush the buffer.
	
	  If we've got more to write, let's continue. At this point we know we
	  are starting from the beginning of an eraseblock.
 The update is finished, clear the update marker 
  ubi_more_leb_change_data - accept more data for atomic LEB change.
  @ubi: UBI device description object
  @vol: volume description object
  @buf: write data (user-space memory buffer)
  @count: how much bytes to write
  This function accepts more data to the volume which is being under the
  "atomic LEB change" operation. It may be called arbitrary number of times
  until all data arrives. This function returns %0 in case of success, number
  of bytes written during the last call if the whole "atomic LEB change"
  operation has been successfully finished, and a negative error code in case
  of failure.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012 Linutronix GmbH
  Copyright (c) 2014 sigma star gmbh
  Author: Richard Weinberger <richard@nod.at>
  init_seen - allocate memory for used for debugging.
  @ubi: UBI device description object
  free_seen - free the seen logic integer array.
  @seen: integer array of @ubi->peb_count size
  set_seen - mark a PEB as seen.
  @ubi: UBI device description object
  @pnum: The PEB to be makred as seen
  @seen: integer array of @ubi->peb_count size
  self_check_seen - check whether all PEB have been seen by fastmap.
  @ubi: UBI device description object
  @seen: integer array of @ubi->peb_count size
  ubi_calc_fm_size - calculates the fastmap size in bytes for an UBI device.
  @ubi: UBI device description object
  new_fm_vhdr - allocate a new volume header for fastmap usage.
  @ubi: UBI device description object
  @vol_id: the VID of the new header
  Returns a new struct ubi_vid_hdr on success.
  NULL indicates out of memory.
	 UBI implementations without fastmap support have to delete the
	  fastmap.
  add_aeb - create and add a attach erase block to a given list.
  @ai: UBI attach info object
  @list: the target list
  @pnum: PEB number of the new attach erase block
  @ec: erease counter of the new LEB
  @scrub: scrub this PEB after attaching
  Returns 0 on success, < 0 indicates an internal error.
  add_vol - create and add a new volume to ubi_attach_info.
  @ai: ubi_attach_info object
  @vol_id: VID of the new volume
  @used_ebs: number of used EBS
  @data_pad: data padding value of the new volume
  @vol_type: volume type
  @last_eb_bytes: number of bytes in the last LEB
  Returns the new struct ubi_ainf_volume on success.
  NULL indicates an error.
  assign_aeb_to_av - assigns a SEB to a given ainf_volume and removes it
  from it's original list.
  @ai: ubi_attach_info object
  @aeb: the to be assigned SEB
  @av: target scan volume
  update_vol - inserts or updates a LEB which was found a pool.
  @ubi: the UBI device object
  @ai: attach info object
  @av: the volume this LEB belongs to
  @new_vh: the volume header derived from new_aeb
  @new_aeb: the AEB to be examined
  Returns 0 on success, < 0 indicates an internal error.
		 This case can happen if the fastmap gets written
		  because of a volume change (creation, deletion, ..).
		  Then a PEB can be within the persistent EBA and the pool.
 new_aeb is newer 
 new_aeb is older 
 This LEB is new, let's add it to the volume 
  process_pool_aeb - we found a non-empty PEB in a pool.
  @ubi: UBI device object
  @ai: attach info object
  @new_vh: the volume header derived from new_aeb
  @new_aeb: the AEB to be examined
  Returns 0 on success, < 0 indicates an internal error.
 Find the volume this SEB belongs to 
  unmap_peb - unmap a PEB.
  If fastmap detects a free PEB in the pool it has to check whether
  this PEB has been unmapped after writing the fastmap.
  @ai: UBI attach info object
  @pnum: The PEB to be unmapped
  scan_pool - scans a pool for changed (no longer empty PEBs).
  @ubi: UBI device object
  @ai: attach info object
  @pebs: an array of all PEB numbers in the to be scanned pool
  @pool_size: size of the pool (number of entries in @pebs)
  @max_sqnum: pointer to the maximal sequence number
  @free: list of PEBs which are most likely free (and go into @ai->free)
  Returns 0 on success, if the pool is unusable UBI_BAD_FASTMAP is returned.
  < 0 indicates an internal error.
	
	  Now scan all PEBs in the pool to find changes which have been made
	  after the creation of the fastmap
		
		  Older UBI implementations have image_seq set to zero, so
		  we shouldn't fail if image_seq == 0.
 We are paranoid and fall back to scanning mode 
  count_fastmap_pebs - Counts the PEBs found by fastmap.
  @ai: The UBI attach info object
  ubi_attach_fastmap - creates ubi_attach_info from a fastmap.
  @ubi: UBI device object
  @ai: UBI attach info object
  @fm: the fastmap to be attached
  Returns 0 on success, UBI_BAD_FASTMAP if the found fastmap was unusable.
  < 0 indicates an internal error.
 read EC values from free list 
 read EC values from used list 
 read EC values from scrub list 
 read EC values from erase list 
 Iterate over all volumes and read their EBA table 
	
	  If fastmap is leaking PEBs (must not happen), raise a
	  fat warning and fall back to scanning mode.
	  We do this here because in ubi_wl_init() it's too late
	  and we cannot fall back to scanning.
  find_fm_anchor - find the most recent Fastmap superblock (anchor)
  @ai: UBI attach info to be filled
  ubi_scan_fastmap - scan the fastmap.
  @ubi: UBI device object
  @ai: UBI attach info to be filled
  @scan_ai: UBI attach info from the first 64 PEBs,
            used to find the most recent Fastmap data structure
  Returns 0 on success, UBI_NO_FASTMAP if no fastmap was found,
  UBI_BAD_FASTMAP if one was found but is not usable.
  < 0 indicates an internal error.
 Copy all (possible) fastmap blocks into our new attach structure. 
		
		  Older UBI implementations have image_seq set to zero, so
		  we shouldn't fail if image_seq == 0.
  ubi_write_fastmap - writes a fastmap.
  @ubi: UBI device object
  @new_fm: the to be written fastmap
  Returns 0 on success, < 0 indicates an internal error.
 the max sqnum will be filled in while reading the fastmap 
  erase_block - Manually erase a PEB.
  @ubi: UBI device object
  @pnum: PEB to be erased
  Returns the new EC value on success, < 0 indicates an internal error.
  invalidate_fastmap - destroys a fastmap.
  @ubi: UBI device object
  This function ensures that upon next UBI attach a full scan
  is issued. We need this if UBI is about to write a new fastmap
  but is unable to do so. In this case we have two options:
  a) Make sure that the current fastmap will not be usued upon
  attach time and contine or b) fall back to RO mode to have the
  current fastmap in a valid state.
  Returns 0 on success, < 0 indicates an internal error.
	
	  Create fake fastmap such that UBI will fall back
	  to scanning mode.
  return_fm_pebs - returns all PEBs used by a fastmap back to the
  WL sub-system.
  @ubi: UBI device object
  @fm: fastmap layout object
  ubi_update_fastmap - will be called by UBI if a volume changes or
  a fastmap pool becomes full.
  @ubi: UBI device object
  Returns 0 on success, < 0 indicates an internal error.
 Old fastmap is larger than the new one 
 no fresh anchor PEB was found, reuse the old one 
 we've got a new anchor PEB, return the old one 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) International Business Machines Corp., 2006
  Author: Artem Bityutskiy ( )
 Here we keep miscellaneous functions which are used all over the UBI code 
  calc_data_len - calculate how much real data is stored in a buffer.
  @ubi: UBI device description object
  @buf: a buffer with the contents of the physical eraseblock
  @length: the buffer length
  This function calculates how much "real data" is stored in @buf and returnes
  the length. Continuous 0xFF bytes at the end of the buffer are not
  considered as "real data".
 The resulting length must be aligned to the minimum flash IO size 
  ubi_check_volume - check the contents of a static volume.
  @ubi: UBI device description object
  @vol_id: ID of the volume to check
  This function checks if static volume @vol_id is corrupted by fully reading
  it and checking data CRC. This function returns %0 if the volume is not
  corrupted, %1 if it is corrupted and a negative error code in case of
  failure. Dynamic volumes are not checked and zero is returned immediately.
  ubi_update_reserved - update bad eraseblock handling accounting data.
  @ubi: UBI device description object
  This function calculates the gap between current number of PEBs reserved for
  bad eraseblock handling and the required level of PEBs that must be
  reserved, and if necessary, reserves more PEBs to fill that gap, according
  to availability. Should be called with ubi->volumes_lock held.
  ubi_calculate_reserved - calculate how many PEBs must be reserved for bad
  eraseblock handling.
  @ubi: UBI device description object
	
	  Calculate the actual number of PEBs currently needed to be reserved
	  for future bad eraseblock handling.
  ubi_check_pattern - check if buffer contains only a certain byte pattern.
  @buf: buffer to check
  @patt: the pattern to check
  @size: buffer size in bytes
  This function returns %1 in there are only @patt bytes in @buf, and %0 if
  something else was also found.
 Normal UBI messages 
 UBI warning messages 
 UBI error messages 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 Ezequiel Garcia
  Copyright (c) 2011 Free Electrons
  Driver parameter handling strongly based on driversmtdubibuild.c
    Copyright (c) International Business Machines Corp., 2006
    Copyright (c) Nokia Corporation, 2007
    Authors: Artem Bityutskiy, Frank Haverkamp
  Read-only block devices on top of UBI volumes
  A simple implementation to allow a block device to be layered on top of a
  UBI volume. The implementation is provided by creating a static 1-to-1
  mapping between the block device and the UBI volume.
  The addressed byte is obtained from the addressed block sector, which is
  mapped linearly into the corresponding LEB:
    LEB number = addressed byte  LEB size
  This feature is compiled in the UBI core, and adds a 'block' parameter
  to allow early creation of block devices on top of UBI volumes. Runtime
  block creationremoval for UBI volumes is provided through two UBI ioctls:
  UBI_IOCVOLCRBLK and UBI_IOCVOLRMBLK.
 Maximum number of supported devices 
 Maximum length of the 'block=' parameter 
 Maximum number of comma-separated items in the 'block=' parameter 
 Numbers of elements set in the @ubiblock_param array 
 MTD devices specification parameters 
 Linked list of all ubiblock instances 
 Protects ubiblock_devices and ubiblock_minor_idr 
 Get rid of the final newline 
 Two parameters: can be 'ubi, vol_id' or 'ubi, vol_name' 
 Second param can be a number or a name 
 One parameter: must be device path 
 Get LEB:offset address to read from 
		
		  We can only read one LEB at a time. Therefore if the read
		  length is larger than one LEB size, we split the operation.
		
		  The volume is already open, just increase the reference
		  counter.
	
	  We want users to be aware they should only mount us as read-only.
	  It's just a paranoid check, as write requests will get rejected
	  in any case.
 Some tools might require this information 
	
	  It is safe to ignore the return value of blk_rq_map_sg() because
	  the number of sg entries is limited to UBI_MAX_SG_COUNT
	  and ubi_read_sg() will check that limit.
 Check that the volume isn't already handled 
 Initialize the gendisk of this ubiblock device 
	
	  Create one workqueue per volume (per registered block device).
	  Rembember workqueues are cheap, they're not threads.
 Must be the last step: anyone can call file ops from now on 
 Stop new requests to arrive 
 Flush pending work 
 Finally destroy the blk queue 
 Found a device, let's lock it so we can check if it's busy 
 Remove from device list 
	
	  Need to lock the device list until we stop using the device,
	  otherwise the device struct might get released in
	  'ubiblock_remove()'.
		
		  We want to enforce explicit block device creation for
		  volumes, so when a volume is added we do nothing.
		
		  If the volume is static, a content update might mean the
		  size (i.e. used_bytes) was also changed.
 No ubi num, name must be a vol device path 
 No vol_id, must be vol_name 
	
	  If there is an error creating one of the ubiblocks, continue on to
	  create the following ubiblocks. This helps in a circumstance where
	  the kernel command-line specifies multiple block devices and some
	  may be broken, but we still want the working ones to come up.
 The module is being forcefully removed 
 Remove from device list 
	
	  Attach block devices from 'block=' module param.
	  Even if one block device in the param list fails to come up,
	  still allow the module to load and leave any others up.
	
	  Block devices are only created upon user requests, so we ignore
	  existing volumes.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) International Business Machines Corp., 2006
  Authors: Artem Bityutskiy ( ), Thomas Gleixner
  UBI wear-leveling sub-system.
  This sub-system is responsible for wear-leveling. It works in terms of
  physical eraseblocks and erase counters and knows nothing about logical
  eraseblocks, volumes, etc. From this sub-system's perspective all physical
  eraseblocks are of two types - used and free. Used physical eraseblocks are
  those that were "get" by the 'ubi_wl_get_peb()' function, and free physical
  eraseblocks are those that were put by the 'ubi_wl_put_peb()' function.
  Physical eraseblocks returned by 'ubi_wl_get_peb()' have only erase counter
  header. The rest of the physical eraseblock contains only %0xFF bytes.
  When physical eraseblocks are returned to the WL sub-system by means of the
  'ubi_wl_put_peb()' function, they are scheduled for erasure. The erasure is
  done asynchronously in context of the per-UBI device background thread,
  which is also managed by the WL sub-system.
  The wear-leveling is ensured by means of moving the contents of used
  physical eraseblocks with low erase counter to free physical eraseblocks
  with high erase counter.
  If the WL sub-system fails to erase a physical eraseblock, it marks it as
  bad.
  This sub-system is also responsible for scrubbing. If a bit-flip is detected
  in a physical eraseblock, it has to be moved. Technically this is the same
  as moving it for wear-leveling reasons.
  As it was said, for the UBI sub-system all physical eraseblocks are either
  "free" or "used". Free eraseblock are kept in the @wl->free RB-tree, while
  used eraseblocks are kept in @wl->used, @wl->erroneous, or @wl->scrub
  RB-trees, as well as (temporarily) in the @wl->pq queue.
  When the WL sub-system returns a physical eraseblock, the physical
  eraseblock is protected from being moved for some "time". For this reason,
  the physical eraseblock is not directly moved from the @wl->free tree to the
  @wl->used tree. There is a protection queue in between where this
  physical eraseblock is temporarily stored (@wl->pq).
  All this protection stuff is needed because:
   o we don't want to move physical eraseblocks just after we have given them
     to the user; instead, we first want to let users fill them up with data;
   o there is a chance that the user will put the physical eraseblock very
     soon, so it makes sense not to move it for some time, but wait.
  Physical eraseblocks stay protected only for limited time. But the "time" is
  measured in erase cycles in this case. This is implemented with help of the
  protection queue. Eraseblocks are put to the tail of this queue when they
  are returned by the 'ubi_wl_get_peb()', and eraseblocks are removed from the
  head of the queue on each erase operation (for any eraseblock). So the
  length of the queue defines how may (global) erase cycles PEBs are protected.
  To put it differently, each physical eraseblock has 2 main states: free and
  used. The former state corresponds to the @wl->free tree. The latter state
  is split up on several sub-states:
  o the WL movement is allowed (@wl->used tree);
  o the WL movement is disallowed (@wl->erroneous) because the PEB is
    erroneous - e.g., there was a read error;
  o the WL movement is temporarily prohibited (@wl->pq queue);
  o scrubbing is needed (@wl->scrub tree).
  Depending on the sub-state, wear-leveling entries of the used physical
  eraseblocks may be kept in one of those structures.
  Note, in this implementation, we keep a small in-RAM object for each physical
  eraseblock. This is surely not a scalable solution. But it appears to be good
  enough for moderately large flashes and it is simple. In future, one may
  re-work this sub-system and make it more scalable.
  At the moment this sub-system does not utilize the sequence number, which
  was introduced relatively recently. But it would be wise to do this because
  the sequence number of a logical eraseblock characterizes how old is it. For
  example, when we move a PEB with low erase counter, and we need to pick the
  target PEB, we pick a PEB with the highest EC if our PEB is "old" and we
  pick target PEB with an average EC if our PEB is not very "old". This is a
  room for future re-works of the WL sub-system.
 Number of physical eraseblocks reserved for wear-leveling purposes 
  Maximum difference between two erase counters. If this threshold is
  exceeded, the WL sub-system starts moving data from used physical
  eraseblocks with low erase counter to free physical eraseblocks with high
  erase counter.
  When a physical eraseblock is moved, the WL sub-system has to pick the target
  physical eraseblock to move to. The simplest way would be just to pick the
  one with the highest erase counter. But in certain workloads this could lead
  to an unlimited wear of one or few physical eraseblock. Indeed, imagine a
  situation when the picked physical eraseblock is constantly erased after the
  data is written to it. So, we have a constant which limits the highest erase
  counter of the free physical eraseblock to pick. Namely, the WL sub-system
  does not pick eraseblocks with erase counter greater than the lowest erase
  counter plus %WL_FREE_MAX_DIFF.
  Maximum number of consecutive background thread failures which is enough to
  switch to read-only mode.
  wl_tree_add - add a wear-leveling entry to a WL RB-tree.
  @e: the wear-leveling entry to add
  @root: the root of the tree
  Note, we use (erase counter, physical eraseblock number) pairs as keys in
  the @ubi->used and @ubi->free RB-trees.
  wl_tree_destroy - destroy a wear-leveling entry.
  @ubi: UBI device description object
  @e: the wear-leveling entry to add
  This function destroys a wear leveling entry and removes
  the reference from the lookup table.
  do_work - do one pending work.
  @ubi: UBI device description object
  This function returns zero in case of success and a negative error code in
  case of failure.
	
	  @ubi->work_sem is used to synchronize with the workers. Workers take
	  it in read mode, so many of them may be doing works at a time. But
	  the queue flush code has to be sure the whole queue of works is
	  done, and it takes the mutex in write mode.
	
	  Call the worker function. Do not touch the work structure
	  after this call as it will have been freed or reused by that
	  time by the worker function.
  in_wl_tree - check if wear-leveling entry is present in a WL RB-tree.
  @e: the wear-leveling entry to check
  @root: the root of the tree
  This function returns non-zero if @e is in the @root RB-tree and zero if it
  is not.
  in_pq - check if a wear-leveling entry is present in the protection queue.
  @ubi: UBI device description object
  @e: the wear-leveling entry to check
  This function returns non-zero if @e is in the protection queue and zero
  if it is not.
  prot_queue_add - add physical eraseblock to the protection queue.
  @ubi: UBI device description object
  @e: the physical eraseblock to add
  This function adds @e to the tail of the protection queue @ubi->pq, where
  @e will stay for %UBI_PROT_QUEUE_LEN erase operations and will be
  temporarily protected from the wear-leveling worker. Note, @wl->lock has to
  be locked.
  find_wl_entry - find wear-leveling entry closest to certain erase counter.
  @ubi: UBI device description object
  @root: the RB-tree where to look for
  @diff: maximum possible difference from the smallest erase counter
  This function looks for a wear leveling entry with erase counter closest to
  min + @diff, where min is the smallest erase counter.
  find_mean_wl_entry - find wear-leveling entry with medium erase counter.
  @ubi: UBI device description object
  @root: the RB-tree where to look for
  This function looks for a wear leveling entry with medium erase counter,
  but not greater or equivalent than the lowest erase counter plus
  %WL_FREE_MAX_DIFF2.
		 If no fastmap has been written and this WL entry can be used
		  as anchor PEB, hold it back and return the second best
  wl_get_wle - get a mean wl entry to be used by ubi_wl_get_peb() or
  refill_wl_user_pool().
  @ubi: UBI device description object
  This function returns a a wear leveling entry in case of success and
  NULL in case of failure.
	
	  Move the physical eraseblock to the protection queue where it will
	  be protected from being moved for some time.
  prot_queue_del - remove a physical eraseblock from the protection queue.
  @ubi: UBI device description object
  @pnum: the physical eraseblock to remove
  This function deletes PEB @pnum from the protection queue and returns zero
  in case of success and %-ENODEV if the PEB was not found.
  sync_erase - synchronously erase a physical eraseblock.
  @ubi: UBI device description object
  @e: the the physical eraseblock to erase
  @torture: if the physical eraseblock has to be tortured
  This function returns zero in case of success and a negative error code in
  case of failure.
		
		  Erase counter overflow. Upgrade UBI and use 64-bit
		  erase counters internally.
  serve_prot_queue - check if it is time to stop protecting PEBs.
  @ubi: UBI device description object
  This function is called after each erase operation and removes PEBs from the
  tail of the protection queue. These PEBs have been protected for long enough
  and should be moved to the used tree.
	
	  There may be several protected physical eraseblock to remove,
	  process them all.
			
			  Let's be nice and avoid holding the spinlock for
			  too long.
  __schedule_ubi_work - schedule a work.
  @ubi: UBI device description object
  @wrk: the work to schedule
  This function adds a work defined by @wrk to the tail of the pending works
  list. Can only be used if ubi->work_sem is already held in read mode!
  schedule_ubi_work - schedule a work.
  @ubi: UBI device description object
  @wrk: the work to schedule
  This function adds a work defined by @wrk to the tail of the pending works
  list.
  schedule_erase - schedule an erase work.
  @ubi: UBI device description object
  @e: the WL entry of the physical eraseblock to erase
  @vol_id: the volume ID that last used this PEB
  @lnum: the last used logical eraseblock number for the PEB
  @torture: if the physical eraseblock has to be tortured
  @nested: denotes whether the work_sem is already held in read mode
  This function returns zero in case of success and a %-ENOMEM in case of
  failure.
  do_sync_erase - run the erase worker synchronously.
  @ubi: UBI device description object
  @e: the WL entry of the physical eraseblock to erase
  @vol_id: the volume ID that last used this PEB
  @lnum: the last used logical eraseblock number for the PEB
  @torture: if the physical eraseblock has to be tortured
  wear_leveling_worker - wear-leveling worker function.
  @ubi: UBI device description object
  @wrk: the work object
  @shutdown: non-zero if the worker has to free memory and exit
  because the WL-subsystem is shutting down
  This function copies a more worn out physical eraseblock to a less worn out
  one. Returns zero in case of success and a negative error code in case of
  failure.
		
		  No free physical eraseblocks? Well, they must be waiting in
		  the queue to be erased. Cancel movement - it will be
		  triggered again when a free physical eraseblock appears.
		 
		  No used physical eraseblocks? They must be temporarily
		  protected from being moved. They will be moved to the
		  @ubi->used tree later and the wear-leveling will be
		  triggered again.
		 fm_next_anchor is no longer considered a good anchor
		  candidate.
		  NULL assignment also prevents multiple wear level checks
		  of this PEB.
		
		  Now pick the least worn-out used physical eraseblock and a
		  highly worn-out free physical eraseblock. If the erase
		  counters differ much enough, start wear-leveling.
 Give the unused PEB back 
 Perform scrubbing 
	
	  Now we are going to copy physical eraseblock @e1->pnum to @e2->pnum.
	  We so far do not know which logical eraseblock our physical
	  eraseblock (@e1) belongs to. We have to read the volume identifier
	  header first.
	 
	  Note, we are protected from this PEB being unmapped and erased. The
	  'ubi_wl_put_peb()' would wait for moving to be finished if the PEB
	  which is being moved was unmapped.
			
			  We are trying to move PEB without a VID header. UBI
			  always write VID headers shortly after the PEB was
			  given, so we have a situation when it has not yet
			  had a chance to write it, because it was preempted.
			  So add this PEB to the protection queue so far,
			  because presumably more data will be written there
			  (including the missing VID header), and then we'll
			  move it.
			
			  The same situation as %UBI_IO_FF, but bit-flips were
			  detected. It is better to schedule this PEB for
			  scrubbing.
			
			  While a full scan would detect interrupted erasures
			  at attach time we can face them here when attached from
			  Fastmap.
			
			  The LEB has not been moved because the volume is
			  being deleted or the PEB has been put meanwhile. We
			  should prevent this PEB from being selected for
			  wear-leveling movement again, so put it to the
			  protection queue.
			
			  Target PEB had bit-flips or write error - torture it.
			
			  An error happened while reading the source PEB. Do
			  not switch to RO mode in this case, and give the
			  upper layers a possibility to recover from this,
			  e.g. by unmapping corresponding LEB. Instead, just
			  put this PEB to the @ubi->erroneous list to prevent
			  UBI from trying to move it over and over again.
 The PEB has been successfully moved 
		
		  Well, the target PEB was put meanwhile, schedule it for
		  erasure.
	
	  For some reasons the LEB was not moved, might be an error, might be
	  something else. @e1 was not changed, so return it back. @e2 might
	  have been changed, schedule it for erasure.
  ensure_wear_leveling - schedule wear-leveling if it is needed.
  @ubi: UBI device description object
  @nested: set to non-zero if this function is called from UBI worker
  This function checks if it is time to start wear-leveling and schedules it
  if yes. This function returns zero in case of success and a negative error
  code in case of failure.
 Wear-leveling is already in the work queue 
	
	  If the ubi->scrub tree is not empty, scrubbing is needed, and the
	  the WL worker has to be scheduled anyway.
 No physical eraseblocks - no deal 
		
		  We schedule wear-leveling only if the difference between the
		  lowest erase counter of used physical eraseblocks and a high
		  erase counter of free physical eraseblocks is greater than
		  %UBI_WL_THRESHOLD.
  __erase_worker - physical eraseblock erase worker function.
  @ubi: UBI device description object
  @wl_wrk: the work object
  This function erases a physical eraseblock and perform torture testing if
  needed. It also takes care about marking the physical eraseblock bad if
  needed. Returns zero in case of success and a negative error code in case of
  failure.
			 Abort anchor production, if needed it will be
			  enabled again in the wear leveling started below.
		
		  One more erase operation has happened, take care about
		  protected physical eraseblocks.
 And take care about wear-leveling 
 Re-schedule the LEB for erasure 
		
		  If this is not %-EIO, we have no idea what to do. Scheduling
		  this physical eraseblock for erasure again would cause
		  errors again and again. Well, lets switch to RO mode.
 It is %-EIO, the PEB went bad 
			
			  The amount of reserved PEBs increased since we last
			  checked.
  ubi_wl_put_peb - return a PEB to the wear-leveling sub-system.
  @ubi: UBI device description object
  @vol_id: the volume ID that last used this PEB
  @lnum: the last used logical eraseblock number for the PEB
  @pnum: physical eraseblock to return
  @torture: if this physical eraseblock has to be tortured
  This function is called to return physical eraseblock @pnum to the pool of
  free physical eraseblocks. The @torture flag has to be set if an IO error
  occurred to this @pnum and it has to be tested. This function returns zero
  in case of success, and a negative error code in case of failure.
		
		  User is putting the physical eraseblock which was selected to
		  be moved. It will be scheduled for erasure in the
		  wear-leveling worker.
 Wait for the WL worker by taking the @ubi->move_mutex 
		
		  User is putting the physical eraseblock which was selected
		  as the target the data is moved to. It may happen if the EBA
		  sub-system already re-mapped the LEB in 'ubi_eba_copy_leb()'
		  but the WL sub-system has not put the PEB to the "used" tree
		  yet, but it is about to do this. So we just set a flag which
		  will tell the WL worker that the PEB is not needed anymore
		  and should be scheduled for erasure.
 Erroneous PEBs should be tortured 
  ubi_wl_scrub_peb - schedule a physical eraseblock for scrubbing.
  @ubi: UBI device description object
  @pnum: the physical eraseblock to schedule
  If a bit-flip in a physical eraseblock is detected, this physical eraseblock
  needs scrubbing. This function schedules a physical eraseblock for
  scrubbing which is done in background. This function returns zero in case of
  success and a negative error code in case of failure.
		
		  This physical eraseblock was used to move data to. The data
		  was moved but the PEB was not yet inserted to the proper
		  tree. We should just wait a little and let the WL worker
		  proceed.
	
	  Technically scrubbing is the same as wear-leveling, so it is done
	  by the WL worker.
  ubi_wl_flush - flush all pending works.
  @ubi: UBI device description object
  @vol_id: the volume id to flush for
  @lnum: the logical eraseblock number to flush for
  This function executes all pending works for a particular volume id 
  logical eraseblock number pair. If either value is set to %UBI_ALL, then it
  acts as a wildcard for all of the corresponding volume numbers or logical
  eraseblock numbers. It returns zero in case of success and a negative error
  code in case of failure.
	
	  Erase while the pending works queue is not empty, but not more than
	  the number of currently pending works.
	
	  Make sure all the works which have been done in parallel are
	  finished.
  ubi_bitflip_check - Check an eraseblock for bitflips and scrub it if needed.
  @ubi: UBI device description object
  @pnum: the physical eraseblock to schedule
  @force: dont't read the block, assume bitflips happened and take action.
  This function reads the given eraseblock and checks if bitflips occured.
  In case of bitflips, the eraseblock is scheduled for scrubbing.
  If scrubbing is forced with @force, the eraseblock is not read,
  but scheduled for scrubbing right away.
  Returns:
  %EINVAL, PEB is out of range
  %ENOENT, PEB is no longer used by UBI
  %EBUSY, PEB cannot be checked now or a check is currently running on it
  %EAGAIN, bit flips happened but scrubbing is currently not possible
  %EUCLEAN, bit flips happened and PEB is scheduled for scrubbing
  %0, no bit flips detected
	
	  Pause all parallel work, otherwise it can happen that the
	  erase worker frees a wl entry under us.
	
	  Make sure that the wl entry does not change state while
	  inspecting it.
	
	  Does it make sense to check this PEB?
		
		  Okay, bit flip happened, let's figure out what we can do.
		
		  Recheck. We released wl_lock, UBI might have killed the
		  wl entry under us.
		
		  Need to re-check state
			
			  This PEB is empty we can schedule it for
			  erasure right away. No wear leveling needed.
  tree_destroy - destroy an RB-tree.
  @ubi: UBI device description object
  @root: the root of the tree to destroy
  ubi_thread - UBI background thread.
  @u: the UBI device description object pointer
			
			  Check kthread_should_stop() after we set the task
			  state to guarantee that we either see the stop bit
			  and exit or the task state is reset to runnable such
			  that it's not scheduled out indefinitely and detects
			  the stop bit at kthread_should_stop().
				
				  Too many failures, disable the thread and
				  switch to read-only mode.
  shutdown_work - shutdown all pending works.
  @ubi: UBI device description object
  erase_aeb - erase a PEB given in UBI attach info PEB
  @ubi: UBI device description object
  @aeb: UBI attach info PEB
  @sync: If true, erase synchronously. Otherwise schedule for erasure
  ubi_wl_init - initialize the WL sub-system using attaching information.
  @ubi: UBI device description object
  @ai: attaching information
  This function returns zero in case of success, and a negative error code in
  case of failure.
			
			  Usually old Fastmap PEBs are scheduled for erasure
			  and we don't have to care about them but if we face
			  an power cut before scheduling them we need to
			  take care of them here.
			
			  The fastmap update code might not find a free PEB for
			  writing the fastmap anchor to and then reuses the
			  current fastmap anchor PEB. When this PEB gets erased
			  and a power cut happens before it is written again we
			  must make sure that the fastmap attach code doesn't
			  find any outdated fastmap anchors, hence we erase the
			  outdated fastmap anchor PEBs synchronously here.
 Schedule wear-leveling if needed 
  protection_queue_destroy - destroy the protection queue.
  @ubi: UBI device description object
  ubi_wl_close - close the wear-leveling sub-system.
  @ubi: UBI device description object
  self_check_ec - make sure that the erase counter of a PEB is correct.
  @ubi: UBI device description object
  @pnum: the physical eraseblock number to check
  @ec: the erase counter to check
  This function returns zero if the erase counter of physical eraseblock @pnum
  is equivalent to @ec, and a negative error code if not or if an error
  occurred.
 The header does not have to exist 
  self_check_in_wl_tree - check that wear-leveling entry is in WL RB-tree.
  @ubi: UBI device description object
  @e: the wear-leveling entry to check
  @root: the root of the tree
  This function returns zero if @e is in the @root RB-tree and %-EINVAL if it
  is not.
  self_check_in_pq - check if wear-leveling entry is in the protection
                         queue.
  @ubi: UBI device description object
  @e: the wear-leveling entry to check
  This function returns zero if @e is in @ubi->pq and %-EINVAL if it is not.
  produce_free_peb - produce a free physical eraseblock.
  @ubi: UBI device description object
  This function tries to make a free PEB by means of synchronous execution of
  pending works. This may be needed if, for example the background thread is
  disabled. Returns zero in case of success and a negative error code in case
  of failure.
  ubi_wl_get_peb - get a physical eraseblock.
  @ubi: UBI device description object
  This function returns a physical eraseblock in case of success and a
  negative error code in case of failure.
  Returns with ubi->fm_eba_sem held in read mode!
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012 Linutronix GmbH
  Copyright (c) 2014 sigma star gmbh
  Author: Richard Weinberger <richard@nod.at>
  update_fastmap_work_fn - calls ubi_update_fastmap from a work queue
  @wrk: the work description object
  find_anchor_wl_entry - find wear-leveling entry to used as anchor PEB.
  @root: the RB-tree where to look for
  return_unused_pool_pebs - returns unused PEB to the free tree.
  @ubi: UBI device description object
  @pool: fastmap pool description object
  ubi_wl_get_fm_peb - find a physical erase block with a given maximal number.
  @ubi: UBI device description object
  @anchor: This PEB will be used as anchor PEB by fastmap
  The function returns a physical erase block with a given maximal number
  and removes it from the wl subsystem.
  Must be called with wl_lock held!
	 remove it from the free list,
  ubi_refill_pools - refills all fastmap PEB pools.
  @ubi: UBI device description object
	 All available PEBs are in ubi->free, now is the time to get
	  the best anchor PEBs.
  produce_free_peb - produce a free physical eraseblock.
  @ubi: UBI device description object
  This function tries to make a free PEB by means of synchronous execution of
  pending works. This may be needed if, for example the background thread is
  disabled. Returns zero in case of success and a negative error code in case
  of failure.
  ubi_wl_get_peb - get a physical eraseblock.
  @ubi: UBI device description object
  This function returns a physical eraseblock in case of success and a
  negative error code in case of failure.
  Returns with ubi->fm_eba_sem held in read mode!
	 We check here also for the WL pool because at this point we can
 get_peb_for_wl - returns a PEB to be used internally by the WL sub-system.
  @ubi: UBI device description object
		 We cannot update the fastmap here because this
		  function is called in atomic context.
  ubi_ensure_anchor_pebs - schedule wear-leveling to produce an anchor PEB.
  @ubi: UBI device description object
 Do we have a next anchor? 
 Tell wear leveling to produce a new anchor PEB 
	 Do wear leveling to get a new anchor PEB or check the
	  existing next anchor candidate.
  ubi_wl_put_fm_peb - returns a PEB used in a fastmap to the wear-leveling
  sub-system.
  see: ubi_wl_put_peb()
  @ubi: UBI device description object
  @fm_e: physical eraseblock to return
  @lnum: the last used logical eraseblock number for the PEB
  @torture: if this physical eraseblock has to be tortured
	 This can happen if we recovered from a fastmap the very
	  first time and writing now a new one. In this case the wl system
	  has never seen any PEB used by the original fastmap.
  ubi_is_erase_work - checks whether a work is erase work.
  @wrk: The work object to be checked
  may_reserve_for_fm - tests whether a PEB shall be reserved for fastmap.
  See find_mean_wl_entry()
  @ubi: UBI device description object
  @e: physical eraseblock to return
  @root: RB tree to test against.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) International Business Machines Corp., 2006
  Author: Artem Bityutskiy ( )
  UBI attaching sub-system.
  This sub-system is responsible for attaching MTD devices and it also
  implements flash media scanning.
  The attaching information is represented by a &struct ubi_attach_info'
  object. Information about volumes is represented by &struct ubi_ainf_volume
  objects which are kept in volume RB-tree with root at the @volumes field.
  The RB-tree is indexed by the volume ID.
  Logical eraseblocks are represented by &struct ubi_ainf_peb objects. These
  objects are kept in per-volume RB-trees with the root at the corresponding
  &struct ubi_ainf_volume object. To put it differently, we keep an RB-tree of
  per-volume objects and each of these objects is the root of RB-tree of
  per-LEB objects.
  Corrupted physical eraseblocks are put to the @corr list, free physical
  eraseblocks are put to the @free list and the physical eraseblock to be
  erased are put to the @erase list.
  About corruptions
  ~~~~~~~~~~~~~~~~~
  UBI protects EC and VID headers with CRC-32 checksums, so it can detect
  whether the headers are corrupted or not. Sometimes UBI also protects the
  data with CRC-32, e.g., when it executes the atomic LEB change operation, or
  when it moves the contents of a PEB for wear-leveling purposes.
  UBI tries to distinguish between 2 types of corruptions.
  1. Corruptions caused by power cuts. These are expected corruptions and UBI
  tries to handle them gracefully, without printing too many warnings and
  error messages. The idea is that we do not lose important data in these
  cases - we may lose only the data which were being written to the media just
  before the power cut happened, and the upper layers (e.g., UBIFS) are
  supposed to handle such data losses (e.g., by using the FS journal).
  When UBI detects a corruption (CRC-32 mismatch) in a PEB, and it looks like
  the reason is a power cut, UBI puts this PEB to the @erase list, and all
  PEBs in the @erase list are scheduled for erasure later.
  2. Unexpected corruptions which are not caused by power cuts. During
  attaching, such PEBs are put to the @corr list and UBI preserves them.
  Obviously, this lessens the amount of available PEBs, and if at some  point
  UBI runs out of free PEBs, it switches to RO mode. UBI also loudly informs
  about such PEBs every time the MTD device is attached.
  However, it is difficult to reliably distinguish between these types of
  corruptions and UBI's strategy is as follows (in case of attaching by
  scanning). UBI assumes corruption type 2 if the VID header is corrupted and
  the data area does not contain all 0xFFs, and there were no bit-flips or
  integrity errors (e.g., ECC errors in case of NAND) while reading the data
  area.  Otherwise UBI assumes corruption type 1. So the decision criteria
  are as follows.
    o If the data area contains only 0xFFs, there are no data, and it is safe
      to just erase this PEB - this is corruption type 1.
    o If the data area has bit-flips or data integrity errors (ECC errors on
      NAND), it is probably a PEB which was being erased when power cut
      happened, so this is corruption type 1. However, this is just a guess,
      which might be wrong.
    o Otherwise this is corruption type 2.
  find_or_add_av - internal function to find a volume, add a volume or do
 		    both (find and add if missing).
  @ai: attaching information
  @vol_id: the requested volume ID
  @flags: a combination of the %AV_FIND and %AV_ADD flags describing the
 	   expected operation. If only %AV_ADD is set, -EEXIST is returned
 	   if the volume already exists. If only %AV_FIND is set, NULL is
 	   returned if the volume does not exist. And if both flags are
 	   set, the helper first tries to find an existing volume, and if
 	   it does not exist it creates a new one.
  @created: in value used to inform the caller whether it"s a newly created
 	     volume or not.
  This function returns a pointer to a volume description or an ERR_PTR if
  the operation failed. It can also return NULL if only %AV_FIND is set and
  the volume does not exist.
 Walk the volume RB-tree to look if this volume is already present 
 The volume is absent - add it 
  ubi_find_or_add_av - search for a volume in the attaching information and
 			add one if it does not exist.
  @ai: attaching information
  @vol_id: the requested volume ID
  @created: whether the volume has been created or not
  This function returns a pointer to the new volume description or an
  ERR_PTR if the operation failed.
  ubi_alloc_aeb - allocate an aeb element
  @ai: attaching information
  @pnum: physical eraseblock number
  @ec: erase counter of the physical eraseblock
  Allocate an aeb object and initialize the pnum and ec information.
  vol_id and lnum are set to UBI_UNKNOWN, and the other fields are
  initialized to zero.
  Note that the element is not added in any list or RB tree.
  ubi_free_aeb - free an aeb element
  @ai: attaching information
  @aeb: the element to free
  Free an aeb object. The caller must have removed the element from any list
  or RB tree.
  add_to_list - add physical eraseblock to a list.
  @ai: attaching information
  @pnum: physical eraseblock number to add
  @vol_id: the last used volume id for the PEB
  @lnum: the last used LEB number for the PEB
  @ec: erase counter of the physical eraseblock
  @to_head: if not zero, add to the head of the list
  @list: the list to add to
  This function allocates a 'struct ubi_ainf_peb' object for physical
  eraseblock @pnum and adds it to the "free", "erase", or "alien" lists.
  It stores the @lnum and @vol_id alongside, which can both be
  %UBI_UNKNOWN if they are not available, not readable, or not assigned.
  If @to_head is not zero, PEB will be added to the head of the list, which
  basically means it will be processed first later. E.g., we add corrupted
  PEBs (corrupted due to power cuts) to the head of the erase list to make
  sure we erase them first and get rid of corruptions ASAP. This function
  returns zero in case of success and a negative error code in case of
  failure.
  add_corrupted - add a corrupted physical eraseblock.
  @ai: attaching information
  @pnum: physical eraseblock number to add
  @ec: erase counter of the physical eraseblock
  This function allocates a 'struct ubi_ainf_peb' object for a corrupted
  physical eraseblock @pnum and adds it to the 'corr' list.  The corruption
  was presumably not caused by a power cut. Returns zero in case of success
  and a negative error code in case of failure.
  add_fastmap - add a Fastmap related physical eraseblock.
  @ai: attaching information
  @pnum: physical eraseblock number the VID header came from
  @vid_hdr: the volume identifier header
  @ec: erase counter of the physical eraseblock
  This function allocates a 'struct ubi_ainf_peb' object for a Fastamp
  physical eraseblock @pnum and adds it to the 'fastmap' list.
  Such blocks can be Fastmap super and data blocks from both the most
  recent Fastmap we're attaching from or from old Fastmaps which will
  be erased.
  validate_vid_hdr - check volume identifier header.
  @ubi: UBI device description object
  @vid_hdr: the volume identifier header to check
  @av: information about the volume this logical eraseblock belongs to
  @pnum: physical eraseblock number the VID header came from
  This function checks that data stored in @vid_hdr is consistent. Returns
  non-zero if an inconsistency was found and zero if not.
  Note, UBI does sanity check of everything it reads from the flash media.
  Most of the checks are done in the IO sub-system. Here we check that the
  information in the VID header is consistent to the information in other VID
  headers of the same volume.
		
		  This is not the first logical eraseblock belonging to this
		  volume. Ensure that the data in its VID header is consistent
		  to the data in previous logical eraseblock headers.
  add_volume - add volume to the attaching information.
  @ai: attaching information
  @vol_id: ID of the volume to add
  @pnum: physical eraseblock number
  @vid_hdr: volume identifier header
  If the volume corresponding to the @vid_hdr logical eraseblock is already
  present in the attaching information, this function does nothing. Otherwise
  it adds corresponding volume to the attaching information. Returns a pointer
  to the allocated "av" object in case of success and a negative error code in
  case of failure.
  ubi_compare_lebs - find out which logical eraseblock is newer.
  @ubi: UBI device description object
  @aeb: first logical eraseblock to compare
  @pnum: physical eraseblock number of the second logical eraseblock to
  compare
  @vid_hdr: volume identifier header of the second logical eraseblock
  This function compares 2 copies of a LEB and informs which one is newer. In
  case of success this function returns a positive value, in case of failure, a
  negative error code is returned. The success return codes use the following
  bits:
      o bit 0 is cleared: the first PEB (described by @aeb) is newer than the
        second PEB (described by @pnum and @vid_hdr);
      o bit 0 is set: the second PEB is newer;
      o bit 1 is cleared: no bit-flips were detected in the newer LEB;
      o bit 1 is set: bit-flips were detected in the newer LEB;
      o bit 2 is cleared: the older LEB is not corrupted;
      o bit 2 is set: the older LEB is corrupted.
		
		  This must be a really ancient UBI image which has been
		  created before sequence numbers support has been added. At
		  that times we used 32-bit LEB versions stored in logical
		  eraseblocks. That was before UBI got into mainline. We do not
		  support these images anymore. Well, those images still work,
		  but only if no unclean reboots happened.
 Obviously the LEB with lower sequence counter is older 
	
	  Now we know which copy is newer. If the copy flag of the PEB with
	  newer version is not set, then we just return, otherwise we have to
	  check data CRC. For the second PEB we already have the VID header,
	  for the first one - we'll need to re-read it from flash.
	 
	  Note: this may be optimized so that we wouldn't read twice.
 It is not a copy, so it is newer 
 It is not a copy, so it is newer 
 Read the data of the copy and check the CRC 
  ubi_add_to_av - add used physical eraseblock to the attaching information.
  @ubi: UBI device description object
  @ai: attaching information
  @pnum: the physical eraseblock number
  @ec: erase counter
  @vid_hdr: the volume identifier header
  @bitflips: if bit-flips were detected when this physical eraseblock was read
  This function adds information about a used physical eraseblock to the
  'used' tree of the corresponding volume. The function is rather complex
  because it has to handle cases when this is not the first physical
  eraseblock belonging to the same logical eraseblock, and the newer one has
  to be picked, while the older one has to be dropped. This function returns
  zero in case of success and a negative error code in case of failure.
	
	  Walk the RB-tree of logical eraseblocks of volume @vol_id to look
	  if this is the first instance of this logical eraseblock or not.
		
		  There is already a physical eraseblock describing the same
		  logical eraseblock present.
		
		  Make sure that the logical eraseblocks have different
		  sequence numbers. Otherwise the image is bad.
		 
		  However, if the sequence number is zero, we assume it must
		  be an ancient UBI image from the era when UBI did not have
		  sequence numbers. We still can attach these images, unless
		  there is a need to distinguish between old and new
		  eraseblocks, in which case we'll refuse the image in
		  'ubi_compare_lebs()'. In other words, we attach old clean
		  images, but refuse attaching old images with duplicated
		  logical eraseblocks because there was an unclean reboot.
		
		  Now we have to drop the older one and preserve the newer
		  one.
			
			  This logical eraseblock is newer than the one
			  found earlier.
			
			  This logical eraseblock is older than the one found
			  previously.
	
	  We've met this logical eraseblock for the first time, add it to the
	  attaching information.
  ubi_add_av - add volume to the attaching information.
  @ai: attaching information
  @vol_id: the requested volume ID
  This function returns a pointer to the new volume description or an
  ERR_PTR if the operation failed.
  ubi_find_av - find volume in the attaching information.
  @ai: attaching information
  @vol_id: the requested volume ID
  This function returns a pointer to the volume description or %NULL if there
  are no data about this volume in the attaching information.
  ubi_remove_av - delete attaching information about a volume.
  @ai: attaching information
  @av: the volume attaching information to delete
  early_erase_peb - erase a physical eraseblock.
  @ubi: UBI device description object
  @ai: attaching information
  @pnum: physical eraseblock number to erase;
  @ec: erase counter value to write (%UBI_UNKNOWN if it is unknown)
  This function erases physical eraseblock 'pnum', and writes the erase
  counter header to it. This function should only be used on UBI device
  initialization stages, when the EBA sub-system had not been yet initialized.
  This function returns zero in case of success and a negative error code in
  case of failure.
		
		  Erase counter overflow. Upgrade UBI and use 64-bit
		  erase counters internally.
  ubi_early_get_peb - get a free physical eraseblock.
  @ubi: UBI device description object
  @ai: attaching information
  This function returns a free physical eraseblock. It is supposed to be
  called on the UBI initialization stages when the wear-leveling sub-system is
  not initialized yet. This function picks a physical eraseblocks from one of
  the lists, writes the EC header if it is needed, and removes it from the
  list.
  This function returns a pointer to the "aeb" of the found free PEB in case
  of success and an error code in case of failure.
	
	  We try to erase the first physical eraseblock from the erase list
	  and pick it if we succeed, or try to erase the next one if not. And
	  so forth. We don't want to take care about bad eraseblocks here -
	  they'll be handled later.
  check_corruption - check the data area of PEB.
  @ubi: UBI device description object
  @vid_hdr: the (corrupted) VID header of this PEB
  @pnum: the physical eraseblock number to check
  This is a helper function which is used to distinguish between VID header
  corruptions caused by power cuts and other reasons. If the PEB contains only
  0xFF bytes in the data area, the VID header is most probably corrupted
  because of a power cut (%0 is returned in this case). Otherwise, it was
  probably corrupted for some other reasons (%1 is returned in this case). A
  negative error code is returned if a read error occurred.
  If the corruption reason was a power cut, UBI can safely erase this PEB.
  Otherwise, it should preserve it to avoid possibly destroying important
  information.
		
		  Bit-flips or integrity errors while reading the data area.
		  It is difficult to say for sure what type of corruption is
		  this, but presumably a power cut happened while this PEB was
		  erased, so it became unstable and corrupted, and should be
		  erased.
  scan_peb - scan and process UBI headers of a PEB.
  @ubi: UBI device description object
  @ai: attaching information
  @pnum: the physical eraseblock number
  @fast: true if we're scanning for a Fastmap
  This function reads UBI headers of PEB @pnum, checks them, and adds
  information about this PEB to the corresponding list or RB-tree in the
  "attaching info" structure. Returns zero if the physical eraseblock was
  successfully handled and a negative error code in case of failure.
 Skip bad physical eraseblocks 
		
		  We have to also look at the VID header, possibly it is not
		  corrupted. Set %bitflips flag in order to make this PEB be
		  moved and EC be re-created.
 Make sure UBI version is OK 
			
			  Erase counter overflow. The EC headers have 64 bits
			  reserved, but we anyway make use of only 31 bit
			  values, as this seems to be enough for any existing
			  flash. Upgrade UBI and use 64-bit erase counters
			  internally.
		
		  Make sure that all PEBs have the same image sequence number.
		  This allows us to detect situations when users flash UBI
		  images incorrectly, so that the flash has the new UBI image
		  and leftovers from the old one. This feature was added
		  relatively recently, and the sequence number was always
		  zero, because old UBI implementations always set it to zero.
		  For this reasons, we do not panic if some PEBs have zero
		  sequence number, while other PEBs have non-zero sequence
		  number.
 OK, we've done with the EC header, let's look at the VID header 
			
			  Both EC and VID headers are corrupted and were read
			  with data integrity error, probably this is a bad
			  PEB, bit it is not marked as bad yet. This may also
			  be a result of power cut during erasure.
			
			  If we're facing a bad VID header we have to drop all
			  Fastmap data structures we find. The most recent Fastmap
			  could be bad and therefore there is a chance that we attach
			  from an old one. On a fine MTD stack a PEB must not render
			  bad all of a sudden, but the reality is different.
			  So, let's be paranoid and help finding the root cause by
			  falling back to scanning mode instead of attaching with a
			  bad EBA table and cause data corruption which is hard to
			  analyze.
			
			  Both headers are corrupted. There is a possibility
			  that this a valid UBI PEB which has corresponding
			  LEB, but the headers are corrupted. However, it is
			  impossible to distinguish it from a PEB which just
			  contains garbage because of a power cut during erase
			  operation. So we just schedule this PEB for erasure.
			 
			  Besides, in case of NOR flash, we deliberately
			  corrupt both headers because NOR flash erasure is
			  slow and can start from the end.
			
			  The EC was OK, but the VID header is corrupted. We
			  have to check what is in the data area.
 This corruption is caused by a power cut 
 This is an unexpected corruption 
 Unsupported internal volume 
  late_analysis - analyze the overall situation with PEB.
  @ubi: UBI device description object
  @ai: attaching information
  This is a helper function which takes a look what PEBs we have after we
  gather information about all of them ("ai" is compete). It decides whether
  the flash is empty and should be formatted of whether there are too many
  corrupted PEBs and we should not attach this MTD device. Returns zero if we
  should proceed with attaching the MTD device, and %-EINVAL if we should not.
	
	  Few corrupted PEBs is not a problem and may be just a result of
	  unclean reboots. However, many of them may indicate some problems
	  with the flash HW or driver.
		
		  If too many PEBs are corrupted, we refuse attaching,
		  otherwise, only print a warning.
		
		  All PEBs are empty, or almost all - a couple PEBs look like
		  they may be bad PEBs which were not marked as bad yet.
		 
		  This piece of code basically tries to distinguish between
		  the following situations:
		 
		  1. Flash is empty, but there are few bad PEBs, which are not
		     marked as bad so far, and which were read with error. We
		     want to go ahead and format this flash. While formatting,
		     the faulty PEBs will probably be marked as bad.
		 
		  2. Flash contains non-UBI data and we do not want to format
		     it and destroy possibly important information.
  destroy_av - free volume attaching information.
  @av: volume attaching information
  @ai: attaching information
  @list: put the aeb elements in there if !NULL, otherwise free them
  This function destroys the volume attaching information.
  destroy_ai - destroy attaching information.
  @ai: attaching information
 Destroy the volume RB-tree 
  scan_all - scan entire MTD device.
  @ubi: UBI device description object
  @ai: attach info object
  @start: start scanning at this PEB
  This function does full scanning of an MTD device and returns complete
  information about it in form of a "struct ubi_attach_info" object. In case
  of failure, an error code is returned.
 Calculate mean erase counter 
	
	  In case of unknown erase counter we use the mean erase counter
	  value.
  scan_fast - try to find a fastmap and attach from it.
  @ubi: UBI device description object
  @ai: attach info object
  Returns 0 on success, negative return values indicate an internal
  error.
  UBI_NO_FASTMAP denotes that no fastmap was found.
  UBI_BAD_FASTMAP denotes that the found fastmap was invalid.
		
		  Didn't attach via fastmap, do a full scan but reuse what
		  we've aready scanned.
  ubi_attach - attach an MTD device.
  @ubi: UBI device descriptor
  @force_scan: if set to non-zero attach by scanning
  This function returns zero in case of success and a negative error code in
  case of failure.
 On small flash devices we disable fastmap in any case. 
  self_check_ai - check the attaching information.
  @ubi: UBI device description object
  @ai: attaching information
  This function returns zero if the attaching information is all right, and a
  negative error code if not or if an error occurred.
	
	  At first, check that attaching information is OK.
 Check that attaching information is correct 
	
	  Make sure that all the physical eraseblocks are in one of the lists
	  or trees.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) International Business Machines Corp., 2006
  Copyright (c) Nokia Corporation, 2006, 2007
  Author: Artem Bityutskiy ( )
  This file includes volume table manipulation code. The volume table is an
  on-flash table containing volume meta-data like name, number of reserved
  physical eraseblocks, type, etc. The volume table is stored in the so-called
  "layout volume".
  The layout volume is an internal volume which is organized as follows. It
  consists of two logical eraseblocks - LEB 0 and LEB 1. Each logical
  eraseblock stores one volume table copy, i.e. LEB 0 and LEB 1 duplicate each
  other. This redundancy guarantees robustness to unclean reboots. The volume
  table is basically an array of volume table records. Each record contains
  full information about the volume and protected by a CRC checksum. Note,
  nowadays we use the atomic LEB change operation when updating the volume
  table, so we do not really need 2 LEBs anymore, but we preserve the older
  design for the backward compatibility reasons.
  When the volume table is changed, it is first changed in RAM. Then LEB 0 is
  erased, and the updated volume table is written back to LEB 0. Then same for
  LEB 1. This scheme guarantees recoverability from unclean reboots.
  In this UBI implementation the on-flash volume table does not contain any
  information about how much data static volumes contain.
  But it would still be beneficial to store this information in the volume
  table. For example, suppose we have a static volume X, and all its physical
  eraseblocks became bad for some reasons. Suppose we are attaching the
  corresponding MTD device, for some reason we find no logical eraseblocks
  corresponding to the volume X. According to the volume table volume X does
  exist. So we don't know whether it is just empty or all its physical
  eraseblocks went bad. So we cannot alarm the user properly.
  The volume table also stores so-called "update marker", which is used for
  volume updates. Before updating the volume, the update marker is set, and
  after the update operation is finished, the update marker is cleared. So if
  the update operation was interrupted (e.g. by an unclean reboot) - the
  update marker is still there and we know that the volume's contents is
  damaged.
 Empty volume table record 
  ubi_update_layout_vol - helper for updatting layout volumes on flash
  @ubi: UBI device description object
  ubi_change_vtbl_record - change volume table record.
  @ubi: UBI device description object
  @idx: table index to change
  @vtbl_rec: new volume table record
  This function changes volume table record @idx. If @vtbl_rec is %NULL, empty
  volume table record is written. The caller does not have to calculate CRC of
  the record as it is done by this function. Returns zero in case of success
  and a negative error code in case of failure.
  ubi_vtbl_rename_volumes - rename UBI volumes in the volume table.
  @ubi: UBI device description object
  @rename_list: list of &struct ubi_rename_entry objects
  This function re-names multiple volumes specified in @req in the volume
  table. Returns zero in case of success and a negative error code in case of
  failure.
  vtbl_check - check if volume table is not corrupted and sensible.
  @ubi: UBI device description object
  @vtbl: volume table
  This function returns zero if @vtbl is all right, %1 if CRC is incorrect,
  and %-EINVAL if it contains inconsistent data.
 Checks that all names are unique 
  create_vtbl - create a copy of volume table.
  @ubi: UBI device description object
  @ai: attaching information
  @copy: number of the volume table copy
  @vtbl: contents of the volume table
  This function returns zero in case of success and a negative error code in
  case of failure.
 The EC header is already there, write the VID header 
 Write the layout volume contents 
	
	  And add it to the attaching information. Don't delete the old version
	  of this LEB as it will be deleted and freed in 'ubi_add_to_av()'.
		
		  Probably this physical eraseblock went bad, try to pick
		  another one.
  process_lvol - process the layout volume.
  @ubi: UBI device description object
  @ai: attaching information
  @av: layout volume attaching information
  This function is responsible for reading the layout volume, ensuring it is
  not corrupted, and recovering from corruptions if needed. Returns volume
  table in case of success and a negative error code in case of failure.
	
	  UBI goes through the following steps when it changes the layout
	  volume:
	  a. erase LEB 0;
	  b. write new data to LEB 0;
	  c. erase LEB 1;
	  d. write new data to LEB 1.
	 
	  Before the change, both LEBs contain the same data.
	 
	  Due to unclean reboots, the contents of LEB 0 may be lost, but there
	  should LEB 1. So it is OK if LEB 0 is corrupted while LEB 1 is not.
	  Similarly, LEB 1 may be lost, but there should be LEB 0. And
	  finally, unclean reboots may result in a situation when neither LEB
	  0 nor LEB 1 are corrupted, but they are different. In this case, LEB
	  0 contains more recent information.
	 
	  So the plan is to first check LEB 0. Then
	  a. if LEB 0 is OK, it must be containing the most recent data; then
	     we compare it with LEB 1, and if they are different, we copy LEB
	     0 to LEB 1;
	  b. if LEB 0 is corrupted, but LEB 1 has to be OK, and we copy LEB 1
	     to LEB 0.
 Read both LEB 0 and LEB 1 into memory 
			
			  Scrub the PEB later. Note, -EBADMSG indicates an
			  uncorrectable ECC error, but we have our own CRC and
			  the data will be checked later. If the data is OK,
			  the PEB will be scrubbed (because we set
			  aeb->scrub). If the data is not OK, the contents of
			  the PEB will be recovered from the second copy, and
			  aeb->scrub will be cleared in
			  'ubi_add_to_av()'.
 LEB 0 is OK 
 Both LEB 1 and LEB 2 are OK and consistent 
 LEB 0 is corrupted or does not exist 
 Both LEB 0 and LEB 1 are corrupted 
  create_empty_lvol - create empty layout volume.
  @ubi: UBI device description object
  @ai: attaching information
  This function returns volume table contents in case of success and a
  negative error code in case of failure.
  init_volumes - initialize volume information for existing volumes.
  @ubi: UBI device description object
  @ai: scanning information
  @vtbl: volume table
  This function allocates volume description objects for existing volumes.
  Returns zero in case of success and a negative error code in case of
  failure.
 Empty record 
 Auto re-size flag may be set only for one volume 
		
		  We use ubi->peb_count and not vol->reserved_pebs because
		  we want to keep the code simple. Otherwise we'd have to
		  resizecheck the bitmap upon volume resize too.
		  Allocating a few bytes more does not hurt.
		
		  In case of dynamic volume UBI knows nothing about how many
		  data is stored there. So assume the whole volume is used.
 Static volumes only 
			
			  No eraseblocks belonging to this volume found. We
			  don't actually know whether this static volume is
			  completely corrupted or just contains no data. And
			  we cannot know this as long as data size is not
			  stored on flash. So we just assume the volume is
			  empty. FIXME: this should be handled.
			
			  We found a static volume which misses several
			  eraseblocks. Treat it as corrupted.
 And add the layout volume 
  check_av - check volume attaching information.
  @vol: UBI volume description object
  @av: volume attaching information
  This function returns zero if the volume attaching information is consistent
  to the data read from the volume tabla, and %-EINVAL if not.
  check_attaching_info - check that attaching information.
  @ubi: UBI device description object
  @ai: attaching information
  Even though we protect on-flash data by CRC checksums, we still don't trust
  the media. This function ensures that attaching information is consistent to
  the information read from the volume table. Returns zero if the attaching
  information is OK and %-EINVAL if it is not.
			
			  During attaching we found a volume which does not
			  exist according to the information in the volume
			  table. This must have happened due to an unclean
			  reboot while the volume was being removed. Discard
			  these eraseblocks.
  ubi_read_volume_table - read the volume table.
  @ubi: UBI device description object
  @ai: attaching information
  This function reads volume table, checks it, recover from errors if needed,
  or creates it if needed. Returns zero in case of success and a negative
  error code in case of failure.
	
	  The number of supported volumes is limited by the eraseblock size
	  and by the UBI_MAX_VOLUMES constant.
		
		  No logical eraseblocks belonging to the layout volume were
		  found. This could mean that the flash is just empty. In
		  this case we create empty layout volume.
		 
		  But if flash is not empty this must be a corruption or the
		  MTD device just contains garbage.
 This must not happen with proper UBI images 
	
	  The layout volume is OK, initialize the corresponding in-RAM data
	  structures.
	
	  Make sure that the attaching information is consistent to the
	  information stored in the volume table.
  self_vtbl_check - check volume table.
  @ubi: UBI device description object
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) International Business Machines Corp., 2006
  Copyright (c) Nokia Corporation, 2007
  Author: Artem Bityutskiy ( ),
          Frank Haverkamp
  This file includes UBI initialization and building of UBI devices.
  When UBI is initialized, it attaches all the MTD devices specified as the
  module load parameters or the kernel boot parameters. If MTD devices were
  specified, UBI does not attach any MTD device, but it is possible to do
  later using the "UBI control device".
 Maximum length of the 'mtd=' parameter 
 Maximum number of comma-separated items in the 'mtd=' parameter 
 Maximum value for the number of bad PEBs per 1024 PEBs 
  struct mtd_dev_param - MTD device parameter description data structure.
  @name: MTD character device node path, MTD device name, or MTD device number
         string
  @ubi_num: UBI number
  @vid_hdr_offs: VID header offset
  @max_beb_per1024: maximum expected number of bad PEBs per 1024 PEBs
 Numbers of elements set in the @mtd_dev_param array 
 MTD devices specification parameters 
 UBI module parameter to enable fastmap automatically on non-fastmap images 
 Slab cache for wear-leveling entries 
 UBI control character device 
 All UBI devices in system 
 Serializes UBI devices creations and removals 
 Protects @ubi_devices and @ubi->ref_count 
 "Show" method for files in '<sysfs>classubi' 
 UBI version attribute ('<sysfs>classubiversion') 
 Root UBI "class" object (corresponds to '<sysfs>classubi') 
 UBI device attributes (correspond to files in '<sysfs>classubiubiX') 
  ubi_volume_notify - send a volume change notification.
  @ubi: UBI device description object
  @vol: volume description object of the changed volume
  @ntype: notification type to send (%UBI_VOLUME_ADDED, etc)
  This is a helper function which notifies all subscribers about a volume
  change event (creation, removal, re-sizing, re-naming, updating). Returns
  zero in case of success and a negative error code in case of failure.
  ubi_notify_all - send a notification to all volumes.
  @ubi: UBI device description object
  @ntype: notification type to send (%UBI_VOLUME_ADDED, etc)
  @nb: the notifier to call
  This function walks all volumes of UBI device @ubi and sends the @ntype
  notification for each volume. If @nb is %NULL, then all registered notifiers
  are called, otherwise only the @nb notifier is called. Returns the number of
  sent notifications.
		
		  Since the @ubi->device is locked, and we are not going to
		  change @ubi->volumes, we do not have to lock
		  @ubi->volumes_lock.
  ubi_enumerate_volumes - send "add" notification for all existing volumes.
  @nb: the notifier to call
  This function walks all UBI devices and volumes and sends the
  %UBI_VOLUME_ADDED notification for each volume. If @nb is %NULL, then all
  registered notifiers are called, otherwise only the @nb notifier is called.
  Returns the number of sent notifications.
	
	  Since the @ubi_devices_mutex is locked, and we are not going to
	  change @ubi_devices, we do not have to lock @ubi_devices_lock.
  ubi_get_device - get UBI device.
  @ubi_num: UBI device number
  This function returns UBI device description object for UBI device number
  @ubi_num, or %NULL if the device does not exist. This function increases the
  device reference count to prevent removal of the device. In other words, the
  device cannot be removed if its reference count is not zero.
  ubi_put_device - drop an UBI device reference.
  @ubi: UBI device description object
  ubi_get_by_major - get UBI device by character device major number.
  @major: major number
  This function is similar to 'ubi_get_device()', but it searches the device
  by its major number.
  ubi_major2num - get UBI device number by character device major number.
  @major: major number
  This function searches UBI device number object by its major number. If UBI
  device was not found, this function returns -ENODEV, otherwise the UBI device
  number is returned.
 "Show" method for files in '<sysfs>classubiubiX' 
	
	  The below code looks weird, but it actually makes sense. We get the
	  UBI device reference from the contained 'struct ubi_device'. But it
	  is unclear if the device was removed or not yet. Indeed, if the
	  device was removed before we increased its reference count,
	  'ubi_get_device()' will return -ENODEV and we fail.
	 
	  Remember, 'struct ubi_device' is freed in the release function, so
	  we still can use 'ubi->ubi_num'.
  kill_volumes - destroy all user volumes.
  @ubi: UBI device description object
  uif_init - initialize user interfaces for an UBI device.
  @ubi: UBI device description object
  This function initializes various user interfaces for an UBI device. If the
  initialization fails at an early stage, this function frees all the
  resources it allocated, returns an error.
  This function returns zero in case of success and a negative error code in
  case of failure.
	
	  Major numbers for the UBI character devices are allocated
	  dynamically. Major numbers of volume character devices are
	  equivalent to ones of the corresponding UBI character device. Minor
	  numbers of UBI character devices are 0, while minor numbers of
	  volume character devices start from 1. Thus, we allocate one major
	  number and ubi->vtbl_slots + 1 minor numbers.
  uif_close - close user interfaces for an UBI device.
  @ubi: UBI device description object
  Note, since this function un-registers UBI volume device objects (@vol->dev),
  the memory allocated voe the volumes is freed as well (in the release
  function).
  ubi_free_volumes_from - free volumes from specific index.
  @ubi: UBI device description object
  @from: the start index used for volume free.
  ubi_free_all_volumes - free all volumes.
  @ubi: UBI device description object
  ubi_free_internal_volumes - free internal volumes.
  @ubi: UBI device description object
		
		  Since max_beb_per1024 has not been set by the user in either
		  the cmdline or Kconfig, use mtd_max_bad_blocks to set the
		  limit if it is supported by the device.
	
	  Here we are using size of the entire flash chip and
	  not just the MTD partition size because the maximum
	  number of bad eraseblocks is a percentage of the
	  whole device and bad eraseblocks are not fairly
	  distributed over the flash chip. So the worst case
	  is that all the bad eraseblocks of the chip are in
	  the MTD partition we are attaching (ubi->mtd).
 Round it up 
  io_init - initialize IO sub-system for a given UBI device.
  @ubi: UBI device description object
  @max_beb_per1024: maximum expected number of bad PEB per 1024 PEBs
  If @ubi->vid_hdr_offset or @ubi->leb_start is zero, default offsets are
  assumed:
    o EC header is always at offset zero - this cannot be changed;
    o VID header starts just after the EC header at the closest address
      aligned to @io->hdrs_min_io_size;
    o data starts just after the VID header at the closest address aligned to
      @io->min_io_size
  This function returns zero in case of success and a negative error code in
  case of failure.
		
		  Some flashes have several erase regions. Different regions
		  may have different eraseblock size and other
		  characteristics. It looks like mostly multi-region flashes
		  have one "main" region and one or more small regions to
		  store boot loader code or boot parameters or whatever. I
		  guess we should just pick the largest region. But this is
		  not implemented.
	
	  Note, in this implementation we support MTD devices with 0x7FFFFFFF
	  physical eraseblocks maximum.
	
	  Make sure minimal IO unit is power of 2. Note, there is no
	  fundamental reason for this assumption. It is just an optimization
	  which allows us to avoid costly division operations.
	
	  Maximum write size has to be greater or equivalent to min. IO
	  size, and be multiple of min. IO size.
 Calculate default aligned sizes of EC and VID headers 
 Default offset 
 Similar for the data offset 
 The shift must be aligned to 32-bit boundary 
 Check sanity 
	
	  Set maximum amount of physical erroneous eraseblocks to be 10%.
	  Erroneous PEB are those which have read errors.
	
	  It may happen that EC and VID headers are situated in one minimal
	  IO unit. In this case we can only accept this UBI image in
	  read-only mode.
	
	  Note, ideally, we have to initialize @ubi->bad_peb_count here. But
	  unfortunately, MTD does not provide this information. We should loop
	  over all physical eraseblocks and invoke mtd->block_is_bad() for
	  each physical eraseblock. So, we leave @ubi->bad_peb_count
	  uninitialized so far.
  autoresize - re-size the volume which has the "auto-resize" flag set.
  @ubi: UBI device description object
  @vol_id: ID of the volume to re-size
  This function re-sizes the volume marked by the %UBI_VTBL_AUTORESIZE_FLG in
  the volume table to the largest possible size. See comments in ubi-header.h
  for more description of the flag. Returns zero in case of success and a
  negative error code in case of failure.
	
	  Clear the auto-resize flag in the volume in-memory copy of the
	  volume table, and 'ubi_resize_volume()' will propagate this change
	  to the flash.
		
		  No available PEBs to re-size the volume, clear the flag on
		  flash and exit.
  ubi_attach_mtd_dev - attach an MTD device.
  @mtd: MTD device description object
  @ubi_num: number to assign to the new UBI device
  @vid_hdr_offset: VID header offset
  @max_beb_per1024: maximum expected number of bad PEB per 1024 PEBs
  This function attaches MTD device @mtd_dev to UBI and assign @ubi_num number
  to the newly created UBI device, unless @ubi_num is %UBI_DEV_NUM_AUTO, in
  which case this function finds a vacant device number and assigns it
  automatically. Returns the new UBI device number in case of success and a
  negative error code in case of failure.
  Note, the invocations of this function has to be serialized by the
  @ubi_devices_mutex.
	
	  Check if we already have the same MTD device attached.
	 
	  Note, this function assumes that UBI devices creations and deletions
	  are serialized, so it does not take the &ubi_devices_lock.
	
	  Make sure this MTD device is not emulated on top of an UBI volume
	  already. Well, generally this recursion works fine, but there are
	  different problems like the UBI module takes a reference to itself
	  by attaching (and thus, opening) the emulated MTD device. This
	  results in inability to unload the module. And in general it makes
	  no sense to attach emulated MTD devices, so we prohibit this.
	
	  Both UBI and UBIFS have been designed for SLC NAND and NOR flashes.
	  MLC NAND is different and needs special care, otherwise UBI or UBIFS
	  will die soon and you will lose all your data.
	  Relax this rule if the partition we're attaching to operates in SLC
	  mode.
 Search for an empty slot in the @ubi_devices array 
 Make sure ubi_num is not busy 
	
	  fm_pool.max_size is 5% of the total number of PEBs but it's also
	  between UBI_FM_MAX_POOL_SIZE and UBI_FM_MIN_POOL_SIZE.
 Make device "available" before it becomes accessible via sysfs 
	
	  The below lock makes sure we do not race with 'ubi_thread()' which
	  checks @ubi->thread_enabled. Otherwise we may fail to wake it up.
  ubi_detach_mtd_dev - detach an MTD device.
  @ubi_num: UBI device number to detach from
  @anyway: detach MTD even if device reference count is not zero
  This function destroys an UBI device number @ubi_num and detaches the
  underlying MTD device. Returns zero in case of success and %-EBUSY if the
  UBI device is busy and cannot be destroyed, and %-EINVAL if it does not
  exist.
  Note, the invocations of this function has to be serialized by the
  @ubi_devices_mutex.
 This may only happen if there is a bug 
	 If we don't write a new fastmap at detach time we lose all
	  EC updates that have been made since the last written fastmap.
	  In case of fastmap debugging we omit the update to simulate an
	
	  Before freeing anything, we have to stop the background thread to
	  prevent it from doing anything on this device while we are freeing.
  open_mtd_by_chdev - open an MTD device by its character device node path.
  @mtd_dev: MTD character device node path
  This helper function opens an MTD device by its character node device path.
  Returns MTD device description object in case of success and a negative
  error code in case of failure.
 Probably this is an MTD character device node path 
 MTD device number is defined by the major  minor numbers 
		
		  Just do not think the "devmtdrX" devices support is need,
		  so do not support them to avoid doing extra work.
  open_mtd_device - open MTD device by name, character device path, or number.
  @mtd_dev: name, character device node path, or MTD device device number
  This function tries to open and MTD device described by @mtd_dev string,
  which is first treated as ASCII MTD device number, and if it is not true, it
  is treated as MTD device name, and if that is also not true, it is treated
  as MTD character device node path. Returns MTD device description object in
  case of success and a negative error code in case of failure.
		
		  This does not look like an ASCII integer, probably this is
		  MTD device name.
 Probably this is an MTD character device node path 
 Ensure that EC and VID headers have correct size 
 Create base sysfs directory and sysfs files 
 Attach MTD devices 
 See comment below re-ubi_is_module(). 
			
			  Originally UBI stopped initializing on any error.
			  However, later on it was found out that this
			  behavior is not very good when UBI is compiled into
			  the kernel and the MTD devices to attach are passed
			  through the command line. Indeed, UBI failure
			  stopped whole boot sequence.
			 
			  To fix this, we changed the behavior for the
			  non-module case, but preserved the old behavior for
			  the module case, just for compatibility. This is a
			  little inconsistent, though.
 See comment above re-ubi_is_module(). 
  bytes_str_to_int - convert a number of bytes string into an integer.
  @str: the string to convert
  This function returns positive resulting integer in case of success and a
  negative error code in case of failure.
  ubi_mtd_param_parse - parse the 'mtd=' UBI parameter.
  @val: the parameter value to parse
  @kp: not used
  This function returns zero in case of success and a negative error code in
  case of error.
 Get rid of the final newline 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) International Business Machines Corp., 2006
  Author: Artem Bityutskiy ( )
  ubi_dump_flash - dump a region of flash.
  @ubi: UBI device description object
  @pnum: the physical eraseblock number to dump
  @offset: the starting offset within the physical eraseblock to dump
  @len: the length of the region to dump
  ubi_dump_ec_hdr - dump an erase counter header.
  @ec_hdr: the erase counter header to dump
  ubi_dump_vid_hdr - dump a volume identifier header.
  @vid_hdr: the volume identifier header to dump
  ubi_dump_vol_info - dump volume information.
  @vol: UBI volume description object
  ubi_dump_vtbl_record - dump a &struct ubi_vtbl_record object.
  @r: the object to dump
  @idx: volume table index
  ubi_dump_av - dump a &struct ubi_ainf_volume object.
  @av: the object to dump
  ubi_dump_aeb - dump a &struct ubi_ainf_peb object.
  @aeb: the object to dump
  @type: object type: 0 - not corrupted, 1 - corrupted
  ubi_dump_mkvol_req - dump a &struct ubi_mkvol_req object.
  @req: the object to dump
  Root directory for UBI stuff in debugfs. Contains sub-directories which
  contain the stuff specific to particular UBI devices.
  ubi_debugfs_init - create UBI debugfs directory.
  Create UBI debugfs directory. Returns zero in case of success and a negative
  error code in case of failure.
  ubi_debugfs_exit - remove UBI debugfs directory.
 Read an UBI debugfs file 
 Write an UBI debugfs file 
 File operations for all UBI debugfs files except
  detailed_erase_block_info
 As long as the position is less then that total number of erase blocks,
  we still have more to print.
 Since we are using the position as the iterator, we just need to check if we
  are done and increment the position.
 If this is the start, print a header 
  ubi_debugfs_init_dev - initialize debugfs for an UBI device.
  @ubi: UBI device description object
  This function creates all debugfs files for UBI device @ubi. Returns zero in
  case of success and a negative error code in case of failure.
 The array size is too small 
  dbg_debug_exit_dev - free all debugfs files corresponding to device @ubi
  @ubi: UBI device description object
  ubi_dbg_power_cut - emulate a power cut if it is time to do so
  @ubi: UBI device description object
  @caller: Flags set to indicate from where the function is being called
  Returns non-zero if a power cut was emulated, zero if not.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) International Business Machines Corp., 2006
  Author: Artem Bityutskiy ( )
  The UBI Eraseblock Association (EBA) sub-system.
  This sub-system is responsible for IO tofrom logical eraseblock.
  Although in this implementation the EBA table is fully kept and managed in
  RAM, which assumes poor scalability, it might be (partially) maintained on
  flash in future implementations.
  The EBA sub-system implements per-logical eraseblock locking. Before
  accessing a logical eraseblock it is locked for reading or writing. The
  per-logical eraseblock locking is implemented by means of the lock tree. The
  lock tree is an RB-tree which refers all the currently locked logical
  eraseblocks. The lock tree elements are &struct ubi_ltree_entry objects.
  They are indexed by (@vol_id, @lnum) pairs.
  EBA also maintains the global sequence counter which is incremented each
  time a logical eraseblock is mapped to a physical eraseblock and it is
  stored in the volume identifier header. This means that each VID header has
  a unique sequence number. The sequence number is only increased an we assume
  64 bits is enough to never overflow.
 Number of physical eraseblocks reserved for atomic LEB change operation 
  struct ubi_eba_entry - structure encoding a single LEB -> PEB association
  @pnum: the physical eraseblock number attached to the LEB
  This structure is encoding a LEB -> PEB association. Note that the LEB
  number is not stored here, because it is the index used to access the
  entries table.
  struct ubi_eba_table - LEB -> PEB association information
  @entries: the LEB to PEB mapping (one entry per LEB).
  This structure is private to the EBA logic and should be kept here.
  It is encoding the LEB to PEB association table, and is subject to
  changes.
  next_sqnum - get next sequence number.
  @ubi: UBI device description object
  This function returns next sequence number to use, which is just the current
  global sequence counter value. It also increases the global sequence
  counter.
  ubi_get_compat - get compatibility flags of a volume.
  @ubi: UBI device description object
  @vol_id: volume ID
  This function returns compatibility flags for an internal volume. User
  volumes have no compatibility flags, so %0 is returned.
  ubi_eba_get_ldesc - get information about a LEB
  @vol: volume description object
  @lnum: logical eraseblock number
  @ldesc: the LEB descriptor to fill
  Used to query information about a specific LEB.
  It is currently only returning the physical position of the LEB, but will be
  extended to provide more information.
  ubi_eba_create_table - allocate a new EBA table and initialize it with all
 			  LEBs unmapped
  @vol: volume containing the EBA table to copy
  @nentries: number of entries in the table
  Allocate a new EBA table and initialize it with all LEBs unmapped.
  Returns a valid pointer if it succeed, an ERR_PTR() otherwise.
  ubi_eba_destroy_table - destroy an EBA table
  @tbl: the table to destroy
  Destroy an EBA table.
  ubi_eba_copy_table - copy the EBA table attached to vol into another table
  @vol: volume containing the EBA table to copy
  @dst: destination
  @nentries: number of entries to copy
  Copy the EBA table stored in vol into the one pointed by dst.
  ubi_eba_replace_table - assign a new EBA table to a volume
  @vol: volume containing the EBA table to copy
  @tbl: new EBA table
  Assign a new EBA table to the volume and release the old one.
  ltree_lookup - look up the lock tree.
  @ubi: UBI device description object
  @vol_id: volume ID
  @lnum: logical eraseblock number
  This function returns a pointer to the corresponding &struct ubi_ltree_entry
  object if the logical eraseblock is locked and %NULL if it is not.
  @ubi->ltree_lock has to be locked.
  ltree_add_entry - add new entry to the lock tree.
  @ubi: UBI device description object
  @vol_id: volume ID
  @lnum: logical eraseblock number
  This function adds new entry for logical eraseblock (@vol_id, @lnum) to the
  lock tree. If such entry is already there, its usage counter is increased.
  Returns pointer to the lock tree entry or %-ENOMEM if memory allocation
  failed.
		
		  This logical eraseblock is already locked. The newly
		  allocated lock entry is not needed.
		
		  No lock entry, add the newly allocated one to the
		  @ubi->ltree RB-tree.
  leb_read_lock - lock logical eraseblock for reading.
  @ubi: UBI device description object
  @vol_id: volume ID
  @lnum: logical eraseblock number
  This function locks a logical eraseblock for reading. Returns zero in case
  of success and a negative error code in case of failure.
  leb_read_unlock - unlock logical eraseblock.
  @ubi: UBI device description object
  @vol_id: volume ID
  @lnum: logical eraseblock number
  leb_write_lock - lock logical eraseblock for writing.
  @ubi: UBI device description object
  @vol_id: volume ID
  @lnum: logical eraseblock number
  This function locks a logical eraseblock for writing. Returns zero in case
  of success and a negative error code in case of failure.
  leb_write_trylock - try to lock logical eraseblock for writing.
  @ubi: UBI device description object
  @vol_id: volume ID
  @lnum: logical eraseblock number
  This function locks a logical eraseblock for writing if there is no
  contention and does nothing if there is contention. Returns %0 in case of
  success, %1 in case of contention, and and a negative error code in case of
  failure.
 Contention, cancel 
  leb_write_unlock - unlock logical eraseblock.
  @ubi: UBI device description object
  @vol_id: volume ID
  @lnum: logical eraseblock number
  ubi_eba_is_mapped - check if a LEB is mapped.
  @vol: volume description object
  @lnum: logical eraseblock number
  This function returns true if the LEB is mapped, false otherwise.
  ubi_eba_unmap_leb - un-map logical eraseblock.
  @ubi: UBI device description object
  @vol: volume description object
  @lnum: logical eraseblock number
  This function un-maps logical eraseblock @lnum and schedules corresponding
  physical eraseblock for erasure. Returns zero in case of success and a
  negative error code in case of failure.
 This logical eraseblock is already unmapped 
  check_mapping - check and fixup a mapping
  @ubi: UBI device description object
  @vol: volume description object
  @lnum: logical eraseblock number
  @pnum: physical eraseblock number
  Checks whether a given mapping is valid. Fastmap cannot track LEB unmap
  operations, if such an operation is interrupted the mapping still looks
  good, but upon first read an ECC is reported to the upper layer.
  Normaly during the full-scan at attach time this is fixed, for Fastmap
  we have to deal with it while reading.
  If the PEB behind a LEB shows this symthom we change the mapping to
  %UBI_LEB_UNMAPPED and schedule the PEB for erasure.
  Returns 0 on success, negative error code in case of failure.
  ubi_eba_read_leb - read data.
  @ubi: UBI device description object
  @vol: volume description object
  @lnum: logical eraseblock number
  @buf: buffer to store the read data
  @offset: offset from where to read
  @len: how many bytes to read
  @check: data CRC check flag
  If the logical eraseblock @lnum is unmapped, @buf is filled with 0xFF
  bytes. The @check flag only makes sense for static volumes and forces
  eraseblock data CRC checking.
  In case of success this function returns zero. In case of a static volume,
  if data CRC mismatches - %-EBADMSG is returned. %-EBADMSG may also be
  returned for any volume type if an ECC error was detected by the MTD device
  driver. Other negative error cored may be returned in case of other errors.
		
		  The logical eraseblock is not mapped, fill the whole buffer
		  with 0xFF bytes. The exception is static volumes for which
		  it is an error to read unmapped logical eraseblocks.
				
				  The header is either absent or corrupted.
				  The former case means there is a bug -
				  switch to read-only mode just in case.
				  The latter case means a real corruption - we
				  may try to recover data. FIXME: but this is
				  not implemented.
					
					  Ending up here in the non-Fastmap case
					  is a clear bug as the VID header had to
					  be present at scan time to have it referenced.
					  With fastmap the story is more complicated.
					  Fastmap has the mapping info without the need
					  of a full scan. So the LEB could have been
					  unmapped, Fastmap cannot know this and keeps
					  the LEB referenced.
					  This is valid and works as the layer above UBI
					  has to do bookkeeping about usedreferenced
					  LEBs in any case.
  ubi_eba_read_leb_sg - read data into a scatter gather list.
  @ubi: UBI device description object
  @vol: volume description object
  @lnum: logical eraseblock number
  @sgl: UBI scatter gather list to store the read data
  @offset: offset from where to read
  @len: how many bytes to read
  @check: data CRC check flag
  This function works exactly like ubi_eba_read_leb(). But instead of
  storing the read data into a buffer it writes to an UBI scatter gather
  list.
  try_recover_peb - try to recover from write failure.
  @vol: volume description object
  @pnum: the physical eraseblock to recover
  @lnum: logical eraseblock number
  @buf: data which was not written because of the write failure
  @offset: offset of the failed write
  @len: how many bytes should have been written
  @vidb: VID buffer
  @retry: whether the caller should retry in case of failure
  This function is called in case of a write failure and moves all good data
  from the potentially bad physical eraseblock to a good physical eraseblock.
  This function also writes the data which was not written due to the failure.
  Returns 0 in case of success, and a negative error code in case of failure.
  In case of failure, the %retry parameter is set to false if this is a fatal
  error (retrying won't help), and true otherwise.
 Read everything before the area where the write failure happened 
		
		  Bad luck? This physical eraseblock is bad too? Crud. Let's
		  try to get another one.
  recover_peb - recover from write failure.
  @ubi: UBI device description object
  @pnum: the physical eraseblock to recover
  @vol_id: volume ID
  @lnum: logical eraseblock number
  @buf: data which was not written because of the write failure
  @offset: offset of the failed write
  @len: how many bytes should have been written
  This function is called in case of a write failure and moves all good data
  from the potentially bad physical eraseblock to a good physical eraseblock.
  This function also writes the data which was not written due to the failure.
  Returns 0 in case of success, and a negative error code in case of failure.
  This function tries %UBI_IO_RETRIES before giving up.
  try_write_vid_and_data - try to write VID header and data to a new PEB.
  @vol: volume description object
  @lnum: logical eraseblock number
  @vidb: the VID buffer to write
  @buf: buffer containing the data
  @offset: where to start writing data
  @len: how many bytes should be written
  This function tries to write VID header and data belonging to logical
  eraseblock @lnum of volume @vol to a new physical eraseblock. Returns zero
  in case of success and a negative error code in case of failure.
  In case of error, it is possible that something was still written to the
  flash media, but may be some garbage.
  ubi_eba_write_leb - write data to dynamic volume.
  @ubi: UBI device description object
  @vol: volume description object
  @lnum: logical eraseblock number
  @buf: the data to write
  @offset: offset within the logical eraseblock where to write
  @len: how many bytes to write
  This function writes data to logical eraseblock @lnum of a dynamic volume
  @vol. Returns zero in case of success and a negative error code in case
  of failure. In case of error, it is possible that something was still
  written to the flash media, but may be some garbage.
  This function retries %UBI_IO_RETRIES times before giving up.
	
	  The logical eraseblock is not mapped. We have to get a free physical
	  eraseblock and write the volume identifier header there first.
		
		  Fortunately, this is the first write operation to this
		  physical eraseblock, so just put it and request a new one.
		  We assume that if this physical eraseblock went bad, the
		  erase code will handle that.
  ubi_eba_write_leb_st - write data to static volume.
  @ubi: UBI device description object
  @vol: volume description object
  @lnum: logical eraseblock number
  @buf: data to write
  @len: how many bytes to write
  @used_ebs: how many logical eraseblocks will this volume contain
  This function writes data to logical eraseblock @lnum of static volume
  @vol. The @used_ebs argument should contain total number of logical
  eraseblock in this static volume.
  When writing to the last logical eraseblock, the @len argument doesn't have
  to be aligned to the minimal IO unit size. Instead, it has to be equivalent
  to the real data size, although the @buf buffer has to contain the
  alignment. In all other cases, @len has to be aligned.
  It is prohibited to write more than once to logical eraseblocks of static
  volumes. This function returns zero in case of success and a negative error
  code in case of failure.
 If this is the last LEB @len may be unaligned 
  ubi_eba_atomic_leb_change - change logical eraseblock atomically.
  @ubi: UBI device description object
  @vol: volume description object
  @lnum: logical eraseblock number
  @buf: data to write
  @len: how many bytes to write
  This function changes the contents of a logical eraseblock atomically. @buf
  has to contain new logical eraseblock data, and @len - the length of the
  data, which has to be aligned. This function guarantees that in case of an
  unclean reboot the old contents is preserved. Returns zero in case of
  success and a negative error code in case of failure.
  UBI reserves one LEB for the "atomic LEB change" operation, so only one
  LEB change may be done at a time. This is ensured by @ubi->alc_mutex.
		
		  Special case when data length is zero. In this case the LEB
		  has to be unmapped and mapped somewhere else.
	
	  This flash device does not admit of bad eraseblocks or
	  something nasty and unexpected happened. Switch to read-only
	  mode just in case.
  is_error_sane - check whether a read error is sane.
  @err: code of the error happened during reading
  This is a helper function for 'ubi_eba_copy_leb()' which is called when we
  cannot read data from the target PEB (an error @err happened). If the error
  code is sane, then we treat this error as non-fatal. Otherwise the error is
  fatal and UBI will be switched to RO mode later.
  The idea is that we try not to switch to RO mode if the read error is
  something which suggests there was a real read problem. E.g., %-EIO. Or a
  memory allocation failed (-%ENOMEM). Otherwise, it is safer to switch to RO
  mode, simply because we do not know what happened at the MTD level, and we
  cannot handle this. E.g., the underlying driver may have become crazy, and
  it is safer to switch to RO mode to preserve the data.
  And bear in mind, this is about reading from the target PEB, i.e. the PEB
  which we have just written.
  ubi_eba_copy_leb - copy logical eraseblock.
  @ubi: UBI device description object
  @from: physical eraseblock number from where to copy
  @to: physical eraseblock number where to copy
  @vidb: data structure from where the VID header is derived
  This function copies logical eraseblock from physical eraseblock @from to
  physical eraseblock @to. The @vid_hdr buffer may be changed by this
  function. Returns:
    o %0 in case of success;
    o %MOVE_CANCEL_RACE, %MOVE_TARGET_WR_ERR, %MOVE_TARGET_BITFLIPS, etc;
    o a negative error code in case of failure.
	
	  Note, we may race with volume deletion, which means that the volume
	  this logical eraseblock belongs to might be being deleted. Since the
	  volume deletion un-maps all the volume's logical eraseblocks, it will
	  be locked in 'ubi_wl_put_peb()' and wait for the WL worker to finish.
 No need to do further work, cancel 
	
	  We do not want anybody to write to this logical eraseblock while we
	  are moving it, so lock it.
	 
	  Note, we are using non-waiting locking here, because we cannot sleep
	  on the LEB, since it may cause deadlocks. Indeed, imagine a task is
	  unmapping the LEB which is mapped to the PEB we are going to move
	  (@from). This task locks the LEB and goes sleep in the
	  'ubi_wl_put_peb()' function on the @ubi->move_mutex. In turn, we are
	  holding @ubi->move_mutex and go sleep on the LEB lock. So, if the
	  LEB is already locked, we just do not move it and return
	  %MOVE_RETRY. Note, we do not return %MOVE_CANCEL_RACE here because
	  we do not know the reasons of the contention - it may be just a
	  normal IO on this LEB, so we want to re-try.
	
	  The LEB might have been put meanwhile, and the task which put it is
	  probably waiting on @ubi->move_mutex. No need to continue the work,
	  cancel it.
	
	  OK, now the LEB is locked and we can safely start moving it. Since
	  this function utilizes the @ubi->peb_buf buffer which is shared
	  with some other functions - we lock the buffer by taking the
	  @ubi->buf_mutex.
	
	  Now we have got to calculate how much data we have to copy. In
	  case of a static volume it is fairly easy - the VID header contains
	  the data size. In case of a dynamic volume it is more difficult - we
	  have to read the contents, cut 0xFF bytes from the end and copy only
	  the first part. We must do this to avoid writing 0xFF bytes as it
	  may have some side-effects. And not only this. It is important not
	  to include those 0xFFs to CRC because later the they may be filled
	  by data.
	
	  It may turn out to be that the whole @from physical eraseblock
	  contains only 0xFF bytes. Then we have to only write the VID header
	  and do not write any data. This also means we should not set
	  @vid_hdr->copy_flag, @vid_hdr->data_size, and @vid_hdr->data_crc.
 Read the VID header back and check if it was written correctly 
  print_rsvd_warning - warn about not having enough reserved PEBs.
  @ubi: UBI device description object
  @ai: UBI attach info object
  This is a helper function for 'ubi_eba_init()' which is called when UBI
  cannot reserve enough PEBs for bad block handling. This function makes a
  decision whether we have to print a warning or not. The algorithm is as
  follows:
    o if this is a new UBI image, then just print the warning
    o if this is an UBI image which has already been used for some time, print
      a warning only if we can reserve less than 10% of the expected amount of
      the reserved PEB.
  The idea is that when UBI is used, PEBs become bad, and the reserved pool
  of PEBs becomes smaller, which is normal and we do not want to scare users
  with a warning every time they attach the MTD device. This was an issue
  reported by real users.
	
	  The 1 << 18 (256KiB) number is picked randomly, just a reasonably
	  large number to distinguish between newly flashed and used images.
  self_check_eba - run a self check on the EBA table constructed by fastmap.
  @ubi: UBI device description object
  @ai_fastmap: UBI attach info object created by fastmap
  @ai_scan: UBI attach info object created by scanning
  Returns < 0 in case of an internal error, 0 otherwise.
  If a bad EBA table entry was found it will be printed out and
  ubi_assert() triggers.
  ubi_eba_init - initialize the EBA sub-system using attaching information.
  @ubi: UBI device description object
  @ai: attaching information
  This function returns zero in case of success and a negative error code in
  case of failure.
				
				  This may happen in case of an unclean reboot
				  during re-size.
 No enough free physical eraseblocks 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) International Business Machines Corp., 2006
  Author: Artem Bityutskiy ( )
  This file includes implementation of UBI character device operations.
  There are two kinds of character devices in UBI: UBI character devices and
  UBI volume character devices. UBI character devices allow users to
  manipulate whole volumes: create, remove, and re-size them. Volume character
  devices provide volume IO capabilities.
  Major and minor numbers are assigned dynamically to both UBI and volume
  character devices.
  Well, there is the third kind of character devices - the UBI control
  character device, which allows to manipulate by UBI devices - create and
  delete them. In other words, it is used for attaching and detaching MTD
  devices.
  get_exclusive - get exclusive access to an UBI volume.
  @desc: volume descriptor
  This function changes UBI volume open mode to "exclusive". Returns previous
  mode value (positive integer) in case of success and a negative error code
  in case of failure.
  revoke_exclusive - revoke exclusive mode.
  @desc: volume descriptor
  @mode: new mode to switch to
 Update is in progress, seeking is prohibited 
  This function allows to directly write to dynamic UBI volumes, without
  issuing the volume update operation.
 We can write only in fractions of the minimum IO unit 
		
		  The operation is finished, @err contains number of actually
		  written bytes.
		
		  We voluntarily do not take into account the skip_check flag
		  as we want to make sure what we wrote was correctly written.
 Volume update command 
 Atomic logical eraseblock change command 
 Validate the request 
 Logical eraseblock erasure command 
 Logical eraseblock map command 
 Logical eraseblock un-map command 
 Check if logical eraseblock is mapped command 
 Set volume property command 
 Create a RO block device on top of the UBI volume 
 Remove the RO block device 
  verify_mkvol_req - verify volume creation request.
  @ubi: UBI device description object
  @req: the request to check
  This function zero if the request is correct, and %-EINVAL if not.
  verify_rsvol_req - verify volume re-size request.
  @ubi: UBI device description object
  @req: the request to check
  This function returns zero if the request is correct, and %-EINVAL if not.
  rename_volumes - rename UBI volumes.
  @ubi: UBI device description object
  @req: volumes re-name request
  This is a helper function for the volume re-name IOCTL which validates the
  the request, opens the volume and calls corresponding volumes management
  function. Returns zero in case of success and a negative error code in case
  of failure.
 Validate volume IDs and names in the request 
 Make sure volume IDs and names are unique 
 Create the re-name list 
 Skip this re-naming if the name does not really change 
 Find out the volumes which have to be removed 
		
		  Volume @re->vol_id is going to be re-named to
		  @re->new_name, while its current name is @name. If a volume
		  with name @re->new_name currently exists, it has to be
		  removed, unless it is also re-named in the request (@req).
		
		  It seems we need to remove volume with name @re->new_name,
		  if it exists.
 Re-naming into a non-existing volume name 
 The volume exists but busy, or an error occurred 
 Create volume command 
 Remove volume command 
		
		  The volume is deleted (unless an error occurred), and the
		  'struct ubi_volume' object will be freed when
		  'ubi_close_volume()' will call 'put_device()'.
 Re-size volume command 
 Re-name volumes command 
 Check a specific PEB for bitflips and scrub it if needed 
 Force scrubbing for a specific PEB 
 Attach an MTD device command 
		
		  Note, further request verification is done by
		  'ubi_attach_mtd_dev()'.
 @err contains UBI device number 
 Detach an MTD device command 
 UBI volume character device operations 
 UBI character device operations 
 UBI control character device operations 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) International Business Machines Corp., 2006
  Author: Artem Bityutskiy ( )
  This file contains implementation of volume creation, deletion, updating and
  resizing.
 Device attributes corresponding to files in '<sysfs>classubiubiX_Y' 
  "Show" method for files in '<sysfs>classubiubiX_Y'.
  Consider a situation:
  A. process 1 opens a sysfs file related to volume Y, say
     <sysfs>classubiubiX_Yreserved_ebs;
  B. process 2 removes volume Y;
  C. process 1 starts reading the <sysfs>classubiubiX_Yreserved_ebs file;
  In this situation, this function will return %-ENODEV because it will find
  out that the volume was removed from the @ubi->volumes array.
 Take a reference to prevent volume removal 
 This must be a bug 
 We've done the operation, drop volume and UBI device references 
 Release method for volume devices 
  ubi_create_volume - create volume.
  @ubi: UBI device description object
  @req: volume creation request
  This function creates volume described by @req. If @req->vol_id id
  %UBI_VOL_NUM_AUTO, this function automatically assign ID to the new volume
  and saves it in @req->vol_id. Returns zero in case of success and a negative
  error code in case of failure. Note, the caller has to have the
  @ubi->device_mutex locked.
 Find unused volume ID 
 Ensure that this volume does not exist 
 Ensure that the name is unique 
 Calculate how many eraseblocks are requested 
 Reserve physical eraseblocks 
	
	  Finish all pending erases because there may be some LEBs belonging
	  to the same volume ID.
 Make volume "available" before it becomes accessible via sysfs 
 Register character device for the volume 
 Fill volume table record 
	
	  We have registered our device, we should not free the volume
	  description object in this function in case of an error - it is
	  freed by the release function.
  ubi_remove_volume - remove volume.
  @desc: volume descriptor
  @no_vtbl: do not change volume table if not zero
  This function removes volume described by @desc. The volume has to be opened
  in "exclusive" mode. Returns zero in case of success and a negative error
  code in case of failure. The caller has to have the @ubi->device_mutex
  locked.
		
		  The volume is busy, probably someone is reading one of its
		  sysfs files.
  ubi_resize_volume - re-size volume.
  @desc: volume descriptor
  @reserved_pebs: new size in physical eraseblocks
  This function re-sizes the volume and returns zero in case of success, and a
  negative error code in case of failure. The caller has to have the
  @ubi->device_mutex locked.
 If the size is the same, we have nothing to do 
 Reserve physical eraseblocks 
	
	  When we shrink a volume we have to flush all pending (erase) work.
	  Otherwise it can happen that upon next attach UBI finds a LEB with
	  lnum > highest_lnum and refuses to attach.
 Change volume table record 
  ubi_rename_volumes - re-name UBI volumes.
  @ubi: UBI device description object
  @rename_list: list of &struct ubi_rename_entry objects
  This function re-names or removes volumes specified in the re-name list.
  Returns zero in case of success and a negative error code in case of
  failure.
  ubi_add_volume - add volume.
  @ubi: UBI device description object
  @vol: volume description object
  This function adds an existing volume and initializes all its data
  structures. Returns zero in case of success and a negative error code in
  case of failure.
 Register character device for the volume 
  ubi_free_volume - free volume.
  @ubi: UBI device description object
  @vol: volume description object
  This function frees all resources for volume @vol but does not remove it.
  Used only when the UBI device is detached.
  self_check_volume - check volume information.
  @ubi: UBI device description object
  @vol_id: volume ID
  Returns zero if volume is all right and a a negative error code if not.
  self_check_volumes - check information about all volumes.
  @ubi: UBI device description object
  Returns zero if volumes are all right and a a negative error code if not.
 SPDX-License-Identifier: GPL-2.0-or-later
  LPDDR2-NVM MTD driver. This module provides read, write, erase, lockunlock
  support for LPDDR2-NVM PCM memories
  Copyright  2012 Micron Technology, Inc.
  Vincenzo Aliberti <vincenzo.aliberti@gmail.com>
  Domenico Manna <domenico.manna@gmail.com>
  Many thanks to Andrea Vigilante for initial enabling
 Parameters 
 in Word 
 in Word 
 OW offset 
 x32 devices 
 PFOW symbols address offset 
 in Word 
 in Word 
 in Word 
 in Word 
 OW registers address 
 in Word 
 in Word 
 in Word 
 in Word 
 in Word 
 in Word 
 in Word 
 in Word 
 in Word 
 Datamask 
 LPDDR2-NVM Commands 
 LPDDR2-NVM Registers offset 
  Internal Type Definitions
  pcm_int_data contains memory controller details:
  @reg_data : LPDDR2_MODE_REG_DATA register address after remapping
  @reg_cfg  : LPDDR2_MODE_REG_CFG register address after remapping
  &bus_width: memory bus-width (eg: x16 2 Bytes, x32 4 Bytes)
  Build a map_word starting from an u_long
  Build Mode Register Configuration DataMask based on device bus-width
 x32 device 
  Build Status Register OK DataMask based on device bus-width
 x32 device 
  Evaluates Overlay Window Control Registers address
  Enable lpddr2-nvm Overlay Window
  Overlay Window is a memory mapped area containing all LPDDR2-NVM registers
  used by device commands as well as uservisible resources like Device Status
  Register, Device ID, etc
  Disable lpddr2-nvm Overlay Window
  Overlay Window is a memory mapped area containing all LPDDR2-NVM registers
  used by device commands as well as uservisible resources like Device Status
  Register, Device ID, etc
  Execute lpddr2-nvm operations
 only for 2x x16 devices stacked 
 Builds low and high words for OW Control Registers 
 only for 2x x16 
 Set Overlay Window Control Registers 
 2x16 devices stacked 
 Fill Program Buffer 
 Command Execute 
 2x16 devices stacked 
 Status Register Check 
 2x16 devices stacked 
  Execute lpddr2-nvm operations @ block level
  verify presence of PFOW string
 Load string from array 
 Verify the string loaded vs expected 
  lpddr2_nvm driver read method
  lpddr2_nvm driver write method
 Set start value for the variables 
 do sw program 
 2x16 devices 
 do buffer program 
  lpddr2_nvm driver erase method
  lpddr2_nvm driver unlock method
  lpddr2_nvm driver lock method
  lpddr2_nvm driver probe method
 Allocate memory control_regs data structures 
 Allocate memory for map_info & mtd_info data structures 
 lpddr2_nvm address range 
 Populate map_info data structure 
 fill with default methods 
 Populate mtd_info data structure 
 Verify the presence of the device looking for PFOW string 
 Parse partitions and register the MTD device 
  lpddr2_nvm driver remove method
 Initialize platform_driver data structure for lpddr2_nvm 
 SPDX-License-Identifier: GPL-2.0-or-later
  Probing flash chips with QINFO records.
  (C) 2008 Korolev Alexey <akorolev@infradead.org>
  (C) 2008 Vasiliy Leonenko <vasiliy.leonenko@gmail.com>
 General device info 
 Erase block information 
 Partition information 
 Optional features 
 Operation typical time 
 Write a request for the PFOW record 
 Check identification string 
 "PFOW" is found 
 Get the ManuID 
 Get the DeviceID 
 read parameters from chip qinfo table 
 Ok so we found a chip 
 First probe the map to see if we havecan open PFOW here 
 SPDX-License-Identifier: GPL-2.0-or-later
  LPDDR flash memory device operations. This module provides read, write,
  erase, lockunlock support for LPDDR flash memories
  (C) 2008 Korolev Alexey <akorolev@infradead.org>
  (C) 2008 Vasiliy Leonenko <vasiliy.leonenko@gmail.com>
  Many thanks to Roman Borisov for initial enabling
  TODO:
  Implement VPP management
  Implement XIP support
  Implement OTP support
 Fill in the default mtd operations 
			 those should be reset too since
 set our timeout to 8 times the expected delay 
 OK Still waiting. Drop the lock, wait a while and retry. 
			
			  Half of the normal delay still remaining
			  can be performed with a sleeping delay instead
			  of busy waiting.
 Someone's suspended the operation: sleep 
 Suspend has occurred while sleep: reset timeout 
 check status for errors 
 Clear DSR
		
		  OK. We have possibility for contension on the writeerase
		  operations which are global to the real chip and not per
		  partition.  So let's fight it over in the partition which
		  currently has authority on the operation.
		 
		  The rules are as follows:
		 
		  - any write operation must own shared->writing.
		 
		  - any erase operation must own _both_ shared->writing and
		    shared->erasing.
		 
		  - contension arbitration is handled in the owner's context.
		 
		  The 'shared' struct can be read andor written only when
		  its lock is taken.
			
			  The engine to perform desired operation on this
			  partition is already in use by someone else.
			  Let's fight over it in the context of the chip
			  currently using it.  If it is possible to suspend,
			  that other partition will do just that, otherwise
			  it'll happily send us to sleep.  In any case, when
			  get_chip returns success we're clear to go ahead.
			 We should not own chip if it is already in FL_SYNCING
		 Check if we have suspended erase on this chip.
 We now own it 
 Prevent setting state FL_SYNCING for chip in suspended state. 
 Oops. something got wrong. 
 Resume and pretend we weren't here.  
 Erase suspend 
 Only if there's no operation suspended... 
 We own the ability to write, but we're done 
 give back the ownership 
			
			  We own the ability to erase without the ability
			  to write, which means the erase was suspended
			  and some other partition is currently writing.
			  Don't let the switch below mess things up since
			  we don't have ownership to resume anything.
 Figure out the number of words to write 
 Write data 
 Get the program buffer offset from PFOW register data first
 GO GO GO 
 ofs: offset within the first chip that the first read should start 
 We cannot point across chips that are virtually disjoint 
 get the chip 
 ofs: offset within the first chip that the first read should start 
 We must not cross write block boundaries 
		 Be nice and reschedule with the chip in a usable
  block2mtd.c - create an mtd from a block device
  Copyright (C) 2001,2002	Simon Evans <spse@secret.org.uk>
  Copyright (C) 2004-2006	Joern Engel <joern@wh.fh-wedel.de>
  Licence: GPL
  When the first attempt at device initialization fails, we may need to
  wait a little bit and retry. This timeout, by default 3 seconds, gives
  device time to start up. Required on BCM2708 and a few other chipsets.
 Maximum number of comma-separated items in the 'block2mtd=' parameter 
 Info for the block device 
 Static info about the MTD, used in cleanup_module 
 erase a specified part of the device 
 page index
 multiple pages
 this page
 write data to the underlying device 
 page index
 page offset
 multiple pages
 this page
 sync the device - wait until the write queue is empty 
 Get a handle on the device 
	
	  We might not have the root device mounted at this point.
	  Try to resolve the device name by other means.
			
			  Calling wait_for_device_probe in the first loop
			  was not enough, sleep for a bit in subsequent
			  go-arounds.
 Setup the MTD structure 
 make the name contain the block device in 
 Device didn't get added, so free the entry 
 This function works similar to reguler strtoul.  In addition, it
  allows some suffixes for a more human-readable number format:
  ki, Ki, kiB, KiB	- multiply result with 1024
  Mi, MiB		- multiply result with 1024^2
  Gi, GiB		- multiply result with 1024^3
 By dwmw2 editorial decree, "ki", "Mi" or "Gi" are to be used. 
 80 for device, 12 for erase size 
 80 for device, 12 for erase size, 80 for name, 8 for timeout 
 Optional argument when custom label is used 
	 If more parameters are later passed in via
	   sysmoduleblock2mtdparametersblock2mtd
	   and block2mtd_init() has already been called,
	 During early boot stage, we only save the parameters
	   here. We must parse them later: if the param passed
	   from kernel boot command line, block2mtd_setup() is
	   called so early that it is not possible to resolve
	   the device (even kmalloc() fails). Deter that work to
 Remove the MTD devices 
 SPDX-License-Identifier: GPL-2.0
  Driver for Microchip 48L640 64 Kb SPI Serial EERAM
  Copyright Heiko Schocher <hs@denx.de>
  datasheet: http:ww1.microchip.comdownloadsenDeviceDoc20006055B.pdf
  we set continuous mode but readingwriting more bytes than
  pagesize seems to bring chip into state where readden values
  are wrong ... no idea why.
	
	  we set PRO bit (page rollover), but writing length > page size
	  does result in total chaos, so write in 32 byte chunks.
	
	  we set PRO bit (page rollover), but if read length > page size
	  does result in total chaos in result ...
 SPDX-License-Identifier: GPL-2.0-only
  MTD driver for the 28F160F3 Flash Memory (non-CFI) on LART.
  Author: Abraham vd Merwe <abraham@2d3d.co.za>
  Copyright (c) 2001, 2d3D, Inc.
  References:
     [1] 3 Volt Fast Boot Block Flash Memory" Intel Datasheet
            - Order Number: 290644-005
            - January 2000
     [2] MTD internal API documentation
            - http:www.linux-mtd.infradead.org 
  Limitations:
     Even though this driver is written for 3 Volt Fast Boot
     Block Flash Memory, it is rather specific to LART. With
     Minor modifications, notably the without dataaddress line
     mangling and different bus settings, etc. it should be
     trivial to adapt to other platforms.
     If somebody would sponsor me a different board, I'll
     adapt the driver (:
 debugging 
#define LART_DEBUG
  These values is specific to 28Fxxxx3 flash memory.
  See section 2.3.1 in "3 Volt Fast Boot Block Flash Memory" Intel Datasheet
  These values is specific to 28Fxxxx3 flash memory.
  See section 2.3.2 in "3 Volt Fast Boot Block Flash Memory" Intel Datasheet
  These values are specific to LART
 general 
 don't change this - a lot of the code _will_ break if you change this 
 see linuxarcharmmach-sa1100lart.c 
 blob 
 kernel 
 initial ramdisk 
  See section 4.0 in "3 Volt Fast Boot Block Flash Memory" Intel Datasheet
 Read ArrayReset 
 Read Identifier Codes 
 Block Erase 
 Block Erase and Program Resume 
 Program 
 Read Status Register 
 Clear Status Register 
 Write State Machine Status (WSMS) 
 Erase Status (ES) 
 Program Status (PS) 
  See section 4.2 in "3 Volt Fast Boot Block Flash Memory" Intel Datasheet
  The data line mapping on LART is as follows:
    	 U2  CPU |   U3  CPU
    	 -------------------
    	  0  20  |   0   12
    	  1  22  |   1   14
    	  2  19  |   2   11
    	  3  17  |   3   9
    	  4  24  |   4   0
    	  5  26  |   5   2
    	  6  31  |   6   7
    	  7  29  |   7   5
    	  8  21  |   8   13
    	  9  23  |   9   15
    	  10 18  |   10  10
    	  11 16  |   11  8
    	  12 25  |   12  1
    	  13 27  |   13  3
    	  14 30  |   14  6
    	  15 28  |   15  4
 Mangle data (x) 
 Unmangle data (x) 
  The address line mapping on LART is as follows:
    	 U3  CPU |   U2  CPU
    	 -------------------
    	  0  2   |   0   2
    	  1  3   |   1   3
    	  2  9   |   2   9
    	  3  13  |   3   8
    	  4  8   |   4   7
    	  5  12  |   5   6
    	  6  11  |   6   5
    	  7  10  |   7   4
    	  8  4   |   8   10
    	  9  5   |   9   11
    	 10  6   |   10  12
    	 11  7   |   11  13
    	 BOOT BLOCK BOUNDARY
    	 12  15  |   12  15
    	 13  14  |   13  14
    	 14  16  |   14  16
    	 MAIN BLOCK BOUNDARY
    	 15  17  |   15  18
    	 16  18  |   16  17
    	 17  20  |   17  20
    	 18  19  |   18  19
    	 19  21  |   19  21
  As we can see from above, the addresses aren't mangled across
  block boundaries, so we don't need to worry about address
  translations except for sendingreading commands during
  initialization
 Mangle address (x) on chip U2 
 Unmangle address (x) on chip U2 
 Mangle address (x) on chip U3 
 Unmangle address (x) on chip U3 
  Probe for 16mbit flash memory on a LART board without doing
  too much damage. Since we need to write 1 dword to memory,
  we're fcked if this happens to be DRAM since we can't
  restore the memory (otherwise we might exit Read Array mode).
  Returns 1 if we found 16mbit flash memory on LART, 0 otherwise.
 setup "Read Identifier Codes" mode 
    probe U2. U2U3 returns the same data since the first 3
 put the flash back into command mode 
  Erase one block of flash memory at offset ``offset'' which is any
  address within the block which should be erased.
  Returns 1 if successful, 0 otherwise.
 erase and confirm 
 wait for block erase to finish 
 put the flash back into command mode 
 was the erase successful? 
	 check that both start and end of the requested erase are
	 aligned with the erasesize at the appropriate addresses.
	
	 skip all erase regions which are ended before the start of
	 the requested erase. Actually, to save on the calculations,
	 we skip to the first erase region which starts after the
	 start of the requested erase, and then go back one.
	 ok, now i is pointing at the erase region in which this
	 erase request starts. Check the start of the requested
	 erase range is aligned with the erase size which is in
	 effect here.
 Remember the erase region we start on 
	 next, check that the end of the requested erase is aligned
	 with the erase region at that address.
	
	 as before, drop back one to point at the region in which
	 the address actually falls
 is the end aligned on a block boundary? 
 now erase those blocks 
 we always read len bytes 
 first, we read bytes until we reach a dword boundary 
 now we read dwords until we reach a non-dword boundary 
 top up the last unaligned bytes 
  Write one dword ``x'' to flash memory at offset ``offset''. ``offset''
  must be 32 bits, i.e. it must be on a dword boundary.
  Returns 1 if successful, 0 otherwise.
 setup writing 
 write the data 
 wait for the write to finish 
 put the flash back into command mode 
 was the write successful? 
 sanity checks 
 first, we write a 0xFF.... padded byte until we reach a dword boundary 
 now we write dwords until we reach a non-dword boundary 
 top up the last unaligned bytes, padded with 0xFF.... 
 parameter blocks 
 main blocks 
 blob 
 kernel 
 MTDPART_OFS_APPEND 
 initial ramdisk  file system 
 MTDPART_OFS_APPEND 
 MTDPART_SIZ_FULL 
 SPDX-License-Identifier: GPL-2.0-only
  sst25l.c
  Driver for SST25L SPI Flash chips
  Copyright  2009 Bluewater Systems Ltd
  Author: Andre Renaud <andre@bluewatersys.com>
  Author: Ryan Mallon
  Based on m25p80.c
 Erases can take up to 3 seconds! 
 Write status register 
 Write disable 
 Read status register 
 Write enable 
 High speed read 
 Enable write status register 
 Erase sector 
 Read device ID 
 Auto address increment 
 Chip is busy 
 Write enabled 
 Block protection 0 
 Block protection 1 
 Sanity checks 
 Wait for previous writeerase to complete 
 Write the first byte of the page 
		
		  Write the remaining bytes using auto address
		  increment mode
 SPDX-License-Identifier: GPL-2.0-or-later
  OPAL PNOR flash MTD abstraction
  Copyright IBM 2015
  This driver creates the a Linux MTD abstraction for platform PNOR flash
  backed by OPAL calls
  Don't return -ERESTARTSYS if we can't get a token, the MTD core
  might have split up the call from userspace and called into the
  driver more than once, we'll already have done some amount of work.
			
			  If we return the mtd core will free the
			  buffer we've just passed to OPAL but OPAL
			  will continue to read or write from that
			  memory.
			  It may be tempting to ultimately return 0
			  if we're doing a read or a write since we
			  are going to end up waiting until OPAL is
			  done. However, because the MTD core sends
			  us the userspace request in chunks, we need
			  it to know we've been interrupted.
	
	  OPAL does mutual exclusion on the flash, it will return
	  OPAL_BUSY.
	  During firmware updates by the service processor OPAL may
	  be (temporarily) prevented from accessing the flash, in
	  this case OPAL will also return OPAL_BUSY.
	  Both cases aren't errors exactly but the flash could have
	  changed, userspace should be informed.
  powernv_flash_read
  @mtd: the device
  @from: the offset to read from
  @len: the number of bytes to read
  @retlen: the number of bytes actually read
  @buf: the filled in buffer
  Returns 0 if read successful, or -ERRNO if an error occurred
  powernv_flash_write
  @mtd: the device
  @to: the offset to write to
  @len: the number of bytes to write
  @retlen: the number of bytes actually written
  @buf: the buffer to get bytes from
  Returns 0 if write successful, -ERRNO if error occurred
  powernv_flash_erase
  @mtd: the device
  @erase: the erase info
  Returns 0 if erase successful or -ERRNO if an error occurred
  powernv_flash_set_driver_info - Fill the mtd_info structure and docg3
  @dev: The device structure
  @mtd: The structure to fill
	
	  Going to have to check what details I need to set and how to
	  get them
  powernv_flash_probe
  @pdev: platform device
  Returns 0 on success, -ENOMEM, -ENXIO on error
	
	  The current flash that skiboot exposes is one contiguous flash chip
	  with an ffs partition at the start, it should prove easier for users
	  to deal with partitions or not as they see fit
  op_release - Release the driver
  @pdev: the platform device
  Returns 0
 All resources should be freed automatically 
 SPDX-License-Identifier: GPL-2.0-only
  PMC551 PCI Mezzanine Ram Device
  Author:
 	Mark Ferrell <mferrell@mvista.com>
 	Copyright 1999,2000 Nortel Networks
  Description:
 	This driver is intended to support the PMC551 PCI Ram device
 	from Ramix Inc.  The PMC551 is a PMC Mezzanine module for
 	cPCI embedded systems.  The device contains a single SROM
 	that initially programs the V370PDC chipset onboard the
 	device, and various banks of DRAMSDRAM onboard.  This driver
 	implements this PCI Ram device as an MTD (Memory Technology
 	Device) so that it can be used to hold a file system, or for
 	added swap space in embedded systems.  Since the memory on
 	this board isn't as fast as main memory we do not try to hook
 	it into main memory as that would simply reduce performance
 	on the system.  Using it as a block device allows us to use
 	it as high speed swap or for a high speed disk device of some
 	sort.  Which becomes very useful on diskless systems in the
 	embedded market I might add.
  Notes:
 	Due to what I assume is more buggy SROM, the 64M PMC551 I
 	have available claims that all 4 of its DRAM banks have 64MiB
 	of ram configured (making a grand total of 256MiB onboard).
 	This is slightly annoying since the BAR0 size reflects the
 	aperture size, not the dram size, and the V370PDC supplies no
 	other method for memory size discovery.  This problem is
 	mostly only relevant when compiled as a module, as the
 	unloading of the module with an aperture size smaller than
 	the ram will cause the driver to detect the onboard memory
 	size to be equal to the aperture size when the module is
 	reloaded.  Soooo, to help, the module supports an msize
 	option to allow the specification of the onboard memory, and
 	an asize option, to allow the specification of the aperture
 	size.  The aperture must be equal to or less then the memory
 	size, the driver will correct this if you screw it up.  This
 	problem is not relevant for compiled in drivers as compiled
 	in drivers only init once.
  Credits:
 	Saeed Karamooz <saeed@ramix.com> of Ramix INC. for the
 	initial example code of how to initialize this device and for
 	help with questions I had concerning operation of the device.
 	Most of the MTD code for this driver was originally written
 	for the slram.o module in the MTD drivers package which
 	allows the mapping of system memory into an MTD device.
 	Since the PMC551 memory module is accessed in the same
 	fashion as system memory, the slram.c code became a very nice
 	fit to the needs of this driver.  All we added was PCI
 	detectioninitialization to the driver and automatically figure
 	out the size via the PCI detection.o, later changes by Corey
 	Minyard set up the card to utilize a 1M sliding apature.
 	Corey Minyard <minyard@nortelnetworks.com>
 	 Modified driver to utilize a sliding aperture instead of
 	 mapping all memory into kernel space which turned out to
 	 be very wasteful.
 	 Located a bug in the SROM's initialization sequence that
 	 made the memory unusable, added a fix to code to touch up
 	 the DRAM some.
  BugsFIXMEs:
 	 MUST fix the init function to not spin on a register
 	waiting for it to set .. this does not safely handle busted
 	devices that never reset the register correctly which will
 	cause the system to hang w a reboot being the only chance at
 	recover. [sort of fixed, could be better]
 	 Add I2C handling of the SROM so we can read the SROM's information
 	about the aperture size.  This should always accurately reflect the
 	onboard memory size.
 	 Comb the init routine.  It's still a bit cludgy on a few things.
 start address offset hi 
 end address offset hilo 
		 The whole thing fits within one access, so just one shot
		 We have to do multiple writes to get all the data
 Cheap hack optimization 
 start address offset hi 
 end address offset hilo 
		 The whole thing fits within one access, so just one shot
		 We have to do multiple writes to get all the data
 start address offset hi 
 end address offset hilo 
		 The whole thing fits within one access, so just one shot
		 We have to do multiple writes to get all the data
  Fixup routines for the V370PDC
  PCI device ID 0x020011b0
  This function basically kick starts the DRAM oboard the card and gets it
  ready to be used.  Before this is done the device reads VERY erratic, so
  much that it can crash the Linux 2.2.x series kernels when a user cat's
  procpci .. though that is mainly a kernel bug in handling the PCI DEVSEL
  register.  FIXME: stop spinning on registers .. must implement a timeout
  mechanism
  returns the size of the memory region found.
 Sanity Check 
	
	  Attempt to reset the card
	  FIXME: Stop Spinning registers
 unlock registers 
 read in old data 
 bang the reset line up and down for a few 
	
	  Take care and turn off the memory on the device while we
	  tweak the configurations
	
	  Disable existing aperture before probing memory size
	
	  Grab old BAR0 config so that we can figure out memory size
	  This is another bit of kludge going on.  The reason for the
	  redundancy is I am hoping to retain the original configuration
	  previously assigned to the card by the BIOS or some previous
	  fixup routine in the kernel.  So we read the old config into cfg,
	  then write all 1's to the memory space, read back the result into
	  "size", and then write back all the old config.
	
	  Get the size of the memory by reading all the DRAM size values
	  and adding them up.
	 
	  KLUDGE ALERT: the boards we are using have invalid column and
	  row mux values.  We fix them here, but this will break other
	  memory configurations.
	
	  Oops .. something went wrong
 CONFIG_MTD_PMC551_BUGFIX 
	
	  Precharge Dram
	
	  Wait until command has gone through
	  FIXME: register spinning issue
	
	  Turn on auto refresh
	  The loop is taken directly from Ramix's example code.  I assume that
	  this must be held high for some duration of time, but I can find no
	  documentation refrencing the reasons why.
		
		  Make certain command has gone through
		  FIXME: register spinning issue
	
	  Wait until command completes
	  FIXME: register spinning issue
	
	  Check to make certain fast back-to-back, if not
	  then set it so
	
	  Check to make certain the DEVSEL is set correctly, this device
	  has a tendency to assert DEVSEL and TRDY when a write is performed
	  to the memory when memory is read-only
	
	  Set to be prefetchable and put everything back based on old cfg.
	  it's possible that the reset of the V370PDC nuked the original
	  setup
	
	   cfg |= PCI_BASE_ADDRESS_MEM_PREFETCH;
	   pci_write_config_dword( dev, PCI_BASE_ADDRESS_0, cfg );
	
	  Turn PCI memory and IO bus access back on
	
	  Some screen fun
	
	  Check to see the state of the memory
  Kernel version specific module stuffages
  Stuff these outside the ifdef so as to not bust compiled in driver support
  PMC551 Card Initialization
	
	  PCU-bus chipset probe.
		
		  The PMC551 device acts VERY weird if you don't init it
		  first.  i.e. it will not correctly report devsel.  If for
		  some reason the sdram is in a wrote-protected state the
		  device will DEVSEL when it is written to causing problems
		  with the oldproc.c driver in
		  some kernels (2.2.)
		
		  This is needed until the driver is capable of reading the
		  onboard I2C SROM to discover the "real" memory size.
 Keep a reference as the mtd_device_register worked 
 Exited early, reference left over 
  PMC551 Card Cleanup
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) ????		Jochen Schuble <psionic@psionic.de>
  Copyright (c) 2003-2004	Joern Engel <joern@wh.fh-wedel.de>
  Usage:
  one commend line parameter per device, each in the form:
    phram=<name>,<start>,<len>[,<erasesize>]
  <name> may be up to 63 characters.
  <start>, <len>, and <erasesize> can be octal, decimal or hexadecimal.  If followed
  by "ki", "Mi" or "Gi", the numbers will be interpreted as kilo, mega or
  gigabytes. <erasesize> is optional and defaults to PAGE_SIZE.
  Example:
 	phram=swap,64Mi,128Mi phram=test,900Mi,1Mi,64Ki
 By dwmw2 editorial decree, "ki", "Mi" or "Gi" are to be used. 
  This shall contain the module parameter if any. It is of the form:
  - phram=<device>,<address>,<size>[,<erasesize>] for module case
  - phram.phram=<device>,<address>,<size>[,<erasesize>] for built-in case
  We leave 64 bytes for the device name, 20 for the address , 20 for the
  size and 20 for the erasesize.
  Example: phram.phram=rootfs,0xa0000000,512Mi,65536
	
	  If more parameters are later passed in via
	  sysmodulephramparametersphram
	  and init_phram() has already been called,
	  we can parse the argument now.
	
	  During early boot stage, we only save the parameters
	  here. We must parse them later: if the param passed
	  from kernel boot command line, phram_param_call() is
	  called so early that it is not possible to resolve
	  the device (even kmalloc() fails). Defer that work to
	  phram_setup().
 SPDX-License-Identifier: GPL-2.0-only
  mchp23k256.c
  Driver for Microchip 23k256 SPI RAM chips
  Copyright  2016 Andrew Lunn <andrew@lunn.ch>
	
	  Address is sent in big endian (MSB first) and we skip
	  the first entry of the cmd array which contains the cmd
	  opcode.
  Set the device into sequential mode. This allows readwrites to the
  entire SRAM in a single operation
  SMI (Serial Memory Controller) device driver for Serial NOR Flash on
  SPEAr platform
  The serial nor interface is largely based on m25p80.c, however the SPI
  interface has been replaced by SMI.
  Copyright  2010 STMicroelectronics.
  Ashish Priyadarshi
  Shiraz Hashim <shiraz.linux.kernel@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 SMI clock rate 
 50 MHz 
 MAX time out to safely come out of a erase or write busy conditions 
 timeout for command completion 
 registers of smi 
 SMI control register 1 
 SMI control register 2 
 SMI status register 
 SMI transmit register 
 SMI receive register 
 defines for control_reg 1 
 enables all banks 
 Deselect time 6 + 1 SMI_CK periods 
 enables SW Mode 
 Write Burst Mode 
 Fast Mode 
 Clock Hold period selection 
 defines for control_reg 2 
 Send data 
 Transmission Flag Interrupt Enable 
 Write Complete Interrupt Enable 
 reads status reg 
 Write Enable 
 defines for status register 
 Write in progress 
 Write enable latch 
 Block protect 0 
 Block protect 1 
 Block protect 2 
 SR write protect 
 Transfer Finished Flag 
 Transfer Finished Flag 
 Forbidden Write Request 
 Forbidden Access 
 flash opcodes 
 Read JEDEC ID 
 Flash Device Ids maintenance section 
 data structure to maintain flash ids from different vendors 
 Define spear specific structures 
  struct spear_smi - Structure for SMI Device
  @clk: functional clock
  @status: current status register of SMI.
  @clk_rate: functional clock rate of SMI (default: SMI_MAX_CLOCK_FREQ)
  @lock: lock to prevent parallel access of SMI.
  @io_base: base address for registers of SMI.
  @pdev: platform device
  @cmd_complete: queue to wait for command completion of NOR-flash.
  @num_flashes: number of flashes actually present on board.
  @flash: separate structure for each Serial NOR-flash attached to SMI.
  struct spear_snor_flash - Structure for Serial NOR Flash
  @bank: Bank number(0, 1, 2, 3) for each NOR-flash.
  @dev_id: Device ID of NOR-flash.
  @lock: lock to manage flash read, write and erase operations
  @mtd: MTD info for each NOR-flash.
  @num_parts: Total number of partition in each bank of NOR-flash.
  @parts: Partition info for each bank of NOR-flash.
  @page_size: Page size of NOR-flash.
  @base_addr: Base address of NOR-flash.
  @erase_cmd: erase command may vary on different flash types
  @fast_mode: flash supports read in fast mode
  spear_smi_read_sr - Read status register of flash through SMI
  @dev: structure of SMI information.
  @bank: bank to which flash is connected
  This routine will return the status register of the flash chip present at the
  given bank.
 Will be set in interrupt handler 
 program smi in hw mode 
 performing a rsr instruction in hw mode 
 wait for tff 
 copy dev->status (lower 16 bits) in order to release lock 
 restore the ctrl regs state 
  spear_smi_wait_till_ready - wait till flash is ready
  @dev: structure of SMI information.
  @bank: flash corresponding to this bank
  @timeout: timeout for busy wait condition
  This routine checks for WIP (write in progress) bit in Status register
  If successful the routine returns 0 else -EBUSY
 try till finish 
  spear_smi_int_handler - SMI Interrupt Handler.
  @irq: irq number
  @dev_id: structure of SMI device, embedded in dev_id.
  The handler clears all interrupt conditions and records the status in
  dev->status which is used by the driver later.
 clear all interrupt conditions 
 copy the status register in dev->status 
 send the completion 
  spear_smi_hw_init - initializes the smi controller.
  @dev: structure of smi device
  this routine initializes the smi controller wit the default values
 functional clock of smi 
	
	  setting the standard values, fast mode, prescaler for
	  SMI_MAX_CLOCK_FREQ (50MHz) operation and bank enable
 clear all interrupt conditions 
  get_flash_index - match chip id from a flash list.
  @flash_id: a valid nor flash chip id obtained from board.
  try to validate the chip id by matching from a list, if not found then simply
  returns negative. In case of success returns index in to the flash devices
  array.
 Matches chip-id to entire list of 'serial-nor flash' ids 
 Memory chip is not listed and not supported 
  spear_smi_write_enable - Enable the flash to do write operation
  @dev: structure of SMI device
  @bank: enable write for flash connected to this bank
  Set write enable latch with Write Enable command.
  Returns 0 on success.
 Will be set in interrupt handler 
 program smi in hw mode 
 give the flash, write enable command 
 restore the ctrl regs state 
 check whether write mode status is set for required bank 
  spear_smi_erase_sector - erase one sector of flash
  @dev: structure of SMI information
  @command: erase command to be send
  @bank: bank to which this command needs to be send
  @bytes: size of command
  Erase one sector of flash memory at offset ``offset'' which is any
  address within the sector which should be erased.
  Returns 0 if successful, non-zero otherwise.
 send command in sw mode 
 success 
 restore ctrl regs 
  spear_mtd_erase - perform flash erase operation as requested by user
  @mtd: Provides the memory characteristics
  @e_info: Provides the erase information
  Erase an address range on the flash chip. The address range may extend
  one or more erase sectors. Return an error is there is a problem erasing.
 now erase sectors in loop 
 preparing the command for flash 
  spear_mtd_read - performs flash read operation as requested by the user
  @mtd: MTD information of the memory bank
  @from: Address from which to start read
  @len: Number of bytes to be read
  @retlen: Fills the Number of bytes actually read
  @buf: Fills this after reading
  Read an address range from the flash chip. The address range
  may be any size provided it is within the physical boundaries.
  Returns 0 on success, non zero otherwise
 select address as per bank number 
 wait till previous writeerase is done. 
 put smi in hw mode not wbt mode 
 restore ctrl reg1 
  The purpose of this function is to ensure a memcpy_toio() with byte writes
  only. Its structure is inspired from the ARM implementation of _memcpy_toio()
  which also does single byte writes but cannot be used here as this is just an
  implementation detail and not part of the API. Not mentioning the comment
  stating that _memcpy_toio() should be optimized.
 wait until finished previous write command. 
 put smi in write enable 
 put smi in hw, write burst mode 
	
	  In Write Burst mode (WB_MODE), the specs states that writes must be:
	  - incremental
	  - of the same size
	  The ARM implementation of memcpy_toio() will optimize the number of
	  IO by using as much 4-byte writes as possible, surrounded by
	  2-byte1-byte access if:
	  - the destination is not 4-byte aligned
	  - the length is not a multiple of 4-byte.
	  Avoid this alternance of write access size by using our own 'byte
	  access' helper if at least one of the two conditions above is true.
  spear_mtd_write - performs write operation as requested by the user.
  @mtd: MTD information of the memory bank.
  @to:	Address to write.
  @len: Number of bytes to be written.
  @retlen: Number of bytes actually wrote.
  @buf: Buffer from which the data to be taken.
  Write an address range to the flash chip. Data must be written in
  flash_page_size chunks. The address range may be any size provided
  it is within the physical boundaries.
  Returns 0 on success, non zero otherwise
 select address as per bank number 
 do if all the bytes fit onto one page 
 the size of data remaining on the first page 
 write everything in pagesize chunks 
  spear_smi_probe_flash - Detects the NOR Flash chip.
  @dev: structure of SMI information.
  @bank: bank on which flash must be probed
  This routine will check whether there exists a flash chip on a given memory
  bank ID.
  Return index of the probed flash in flash devices structure
 Will be set in interrupt handler 
 put smi in sw mode 
 send readid command in sw mode 
 wait for TFF 
 get memory chip id 
 clear sw mode 
 Fill structs for each subnode (flash device) 
 Read base-addr and size from DT 
 verify whether nor flash is really present on board 
 map the memory for nor flash chip 
  spear_smi_probe - Entry routine
  @pdev: platform device structure
  This is the first routine which gets invoked during booting and does all
  initializationallocation work. The routine looks for available memory banks,
  and do proper init for any found one.
  Returns 0 on success, non zero otherwise
 loop for each serial nor-flash which is connected to smi 
  spear_smi_remove - Exit routine
  @pdev: platform device structure
  free all allocations and delete the partitions.
 clean up for all nor flash 
 clean up mtd stuff 
 SPDX-License-Identifier: GPL-2.0-or-later
  Atmel AT45xxx DataFlash MTD driver for lightweight SPI framework
  Largely derived from at91_dataflash.c:
   Copyright (C) 2003-2005 SAN People (Pty) Ltd
  DataFlash is a kind of SPI flash.  Most AT45 chips have two buffers in
  each chip, which may be used for double buffered IO; but this driver
  doesn't (yet) use these for any kind of io overlap or prefetching.
  Sometimes DataFlash is packaged in MMC-format cards, although the
  MMC stack can't (yet?) distinguish between MMC and DataFlash
  protocols during enumeration.
 reads can bypass the buffers 
 group B requests can run even while status reports "busy" 
 group B 
 move data between host and buffer 
 group B 
 group B 
 group B 
 group B 
 erasing flash 
 move data between buffer and flash 
 sector must be pre-erased 
 sector must be pre-erased 
 write to buffer, then write-erase to flash 
 compare buffer to flash 
 read flash to buffer, then write-erase to flash 
 newer chips report JEDEC manufacturer and device IDs; chip
  serial number and OTP bits; and per-sector writeprotect.
 revision D 
 offset in flash address 
 of bytes per page 
 sentinel  }
 ......................................................................... 
  Return the status of the DataFlash device.
	 NOTE:  at45db321c over 25 MHz wants to write
	  a dummy byte after the opcode...
  Poll the DataFlash device until it is READY.
  This usually takes 5-20 msec or so; more for sector erase.
 RDYnBSY 
 ......................................................................... 
  Erase pages of flash.
		 Calculate flash page address; use block erase (for speed) if
		  we're at a block boundary and need to erase the whole block.
			 REVISIT:  can retry instr->retries times; or
			  giveup and instr->fail_addr = instr->addr;
  Read from the DataFlash device.
    from   : Start offset in flash device
    len    : Amount to read
    retlen : About of data actually read
    buf    : Buffer containing the data
 Calculate flash pagebyte address 
	 Continuous read, max clock = f(car) which may be less than
	  the peak rate available.  Some chips support commands with
	  fewer "don't care" bytes.  Both buffers stay unchanged.
 plus 4 "don't care" bytes 
  Write to the DataFlash device.
    to     : Start offset in flash device
    len    : Amount to write
    retlen : Amount of data actually written
    buf    : Buffer containing the data
		 REVISIT:
		  (a) each page in a sector must be rewritten at least
		      once every 10K sibling eraseprogram operations.
		  (b) for pages that are already erased, we could
		      use WRITE+MWRITE not PROGRAM for ~30% speedup.
		  (c) WRITE to buffer could be done while waiting for
		      a previous MWRITEMWERASE to complete ...
		  (d) error handling here seems to be mostly missing.
		 
		  Two persistent bits per page, plus a per-sector counter,
		  could support (a) and (b) ... we might consider using
		  the second half of sector zero, which is just one block,
		  to track that state.  (On AT91, that sector should also
		  support boot-from-DataFlash.)
 (1) Maybe transfer partial page to Buffer1 
 (2) Program full page via Buffer1 
 (3) Compare to Buffer1 
 Check result of the compare operation 
 CONFIG_MTD_DATAFLASH_WRITE_VERIFY 
 ......................................................................... 
	 Report both blocks as identical:  bytes 0..64, locked.
	  Unless the user block changed from all-ones, we can't
	  tell whether it's still writable; so we assume it isn't.
	 OUT: OP_READ_SECURITY, 3 don't-care bytes, zeroes
	  IN:  ignore 4 bytes, data bytes 0..N (max 127)
 64 bytes, from 0..63 ... start at 64 on-chip 
 64 bytes, from 0..63 ... start at 0 on-chip 
		
		  Attempting to write beyond the end of OTP memory,
		  no data can be written.
 Truncate the write to fit into OTP memory. 
	 OUT: OP_WRITE_SECURITY, 3 zeroes, 64 data-or-zero bytes
	  IN:  ignore all
	 Write the OTP bits, if they've not yet been written.
	  This modifies SRAM buffer1.
	 rev c parts (at45db321c and at45db1281 only!) use a
	  different write procedure; not (yet?) implemented.
 ......................................................................... 
  Register DataFlash device with MTD subsystem.
 name must be usable with cmdlinepart 
	 JEDEC id has a high byte of zero plus three data bytes:
	  the manufacturer id, then a two byte device id.
 The size listed here is what works with OP_ERASE_PAGE. 
 supports extended ID data 
 supports 2^N byte pages 
 uses 2^N byte pages 
	
	  NOTE:  chips with SUP_POW2PS (rev D and up) need two entries,
	  one with IS_POW2PS and the other without.  The entry with the
	  non-2^N byte page size can't name exact chip revisions without
	  losing backwards compatibility for cmdlinepart.
	 
	  These newer chips also support 128-byte security registers (with
	  64 bytes one-time-programmable) and software write-protection.
 rev C 
	
	  JEDEC also defines an optional "extended device information"
	  string for after vendor-specific data, after the three bytes
	  we use here.  Supporting some chips might require using it.
	 
	  If the vendor ID isn't Atmel's (0x1f), assume this call failed.
	  That's not an error; only rev C and newer chips handle it, and
	  only Atmel sells these chips.
	
	  First, try to match device using extended device
	  information
	
	  If that fails, make another pass using regular ID
	  information
	
	  Treat other chips as errors ... we won't know the right page
	  size (it might be binary) even when we can tell which density
	  class is involved (legacy chip id scheme).
  Detect and initialize DataFlash device, using JEDEC IDs on newer chips
  or else the ID code embedded in the status bits:
    Device      Density         ID code          #Pages PageSize  Offset
    AT45DB011B  1Mbit   (128K)  xx0011xx (0x0c)    512    264      9
    AT45DB021B  2Mbit   (256K)  xx0101xx (0x14)   1024    264      9
    AT45DB041B  4Mbit   (512K)  xx0111xx (0x1c)   2048    264      9
    AT45DB081B  8Mbit   (1M)    xx1001xx (0x24)   4096    264      9
    AT45DB0161B 16Mbit  (2M)    xx1011xx (0x2c)   4096    528     10
    AT45DB0321B 32Mbit  (4M)    xx1101xx (0x34)   8192    528     10
    AT45DB0642  64Mbit  (8M)    xx111xxx (0x3c)   8192   1056     11
    AT45DB1282  128Mbit (16M)   xx0100xx (0x10)  16384   1056     11
	
	  Try to detect dataflash by JEDEC ID.
	  If it succeeds we know we have either a C or D part.
	  D will support power of 2 pagesize option.
	  Both support the security register, though with different
	  write procedures.
	
	  Older chips support only legacy commands, identifing
	  capacity using bits in the status byte.
	 if there's a device there, assume it's dataflash.
	  board setup should have set spi->max_speed_max to
	  match f(car) for continuous reads, mode 0 or 3.
 0 0 1 1 x x 
 0 1 0 1 x x 
 0 1 1 1 x x 
 1 0 0 1 x x 
 1 0 1 1 x x 
 1 1 0 1 x x 
 1 1 1 x x x 
 obsolete AT45DB1282 not (yet?) supported 
 FIXME:  investigate suspend and resume... 
 SPDX-License-Identifier: GPL-2.0-or-later
  Handles the M-Systems DiskOnChip G3 chip
  Copyright (C) 2011 Robert Jarzmik
  This driver handles the DiskOnChip G3 flash memory.
  As no specification is available from M-SystemsSandisk, this drivers lacks
  several functions available on the chip, as :
   - IPL write
  The bus data width (8bits versus 16bits) is not handled (if_cfg flag), and
  the driver assumes a 16bits data bus.
  DocG3 relies on 2 ECC algorithms, which are handled in hardware :
   - a 1 byte Hamming code stored in the OOB for each page
   - a 7 bytes BCH code stored in the OOB for each page
  The BCH ECC is :
   - BCH is in GF(2^14)
   - BCH is over data of 520 bytes (512 page + 7 page_info bytes
                                    + 1 hamming byte)
   - BCH can correct up to 4 bits (t = 4)
   - BCH syndroms are calculated in hardware, and checked in hardware as well
 byte 7 is Hamming ECC, byte 8-14 are BCH ECC 
 free bytes: byte 0 until byte 6, byte 15 
  doc_delay - delay docg3 operations
  @docg3: the device
  @nbNOPs: the number of NOPs to issue
  As no specification is available, the right timings between chip commands are
  unknown. The only available piece of information are the observed nops on a
  working docg3 chip.
  Therefore, doc_delay relies on a busy loop of NOPs, instead of scheduler
  friendlier msleep() functions or blocking mdelay().
  doc_read_data_area - Read data from data area
  @docg3: the device
  @buf: the buffer to fill in (might be NULL is dummy reads)
  @len: the length to read
  @first: first time read, DOC_READADDRESS should be set
  Reads bytes from flash data. Handles the single byte  even bytes reads.
  doc_write_data_area - Write data into data area
  @docg3: the device
  @buf: the buffer to get input bytes from
  @len: the length to write
  Writes bytes into flash data. Handles the single byte  even bytes writes.
  doc_set_data_mode - Sets the flash to normal or reliable data mode
  @docg3: the device
  The reliable data mode is a bit slower than the fast mode, but less errors
  occur.  Entering the reliable mode cannot be done without entering the fast
  mode first.
  In reliable mode, pages 2n and 2n+1 are clones. Writing to page 0 of blocks
  (4,5) make the hardware write also to page 1 of blocks blocks(4,5). Reading
  from page 0 of blocks (4,5) or from page 1 of blocks (4,5) gives the same
  result, which is a logical and between bytes from page 0 and page 1 (which is
  consistent with the fact that writing to a page is _clearing_ bits of that
  page).
  doc_set_asic_mode - Set the ASIC mode
  @docg3: the device
  @mode: the mode
  The ASIC can work in 3 modes :
   - RESET: all registers are zeroed
   - NORMAL: receives and handles commands
   - POWERDOWN: minimal poweruse, flash parts shut off
  doc_set_device_id - Sets the devices id for cascaded G3 chips
  @docg3: the device
  @id: the chip to select (amongst 0, 1, 2, 3)
  There can be 4 cascaded G3 chips. This function selects the one which will
  should be the active one.
  doc_set_extra_page_mode - Change flash page layout
  @docg3: the device
  Normally, the flash page is split into the data (512 bytes) and the out of
  band data (16 bytes). For each, 4 more bytes can be accessed, where the wear
  leveling counters are stored.  To access this last area of 4 bytes, a special
  mode must be input to the flash ASIC.
  Returns 0 if no error occurred, -EIO else.
  doc_setup_addr_sector - Setup blockspageofs address for one plane
  @docg3: the device
  @sector: the sector
  doc_setup_writeaddr_sector - Setup blockspageofs address for one plane
  @docg3: the device
  @sector: the sector
  @ofs: the offset in the page, between 0 and (512 + 16 + 512)
  doc_seek - Set both flash planes to the specified block, page for reading
  @docg3: the device
  @block0: the first plane block index
  @block1: the second plane block index
  @page: the page index within the block
  @wear: if true, read will occur on the 4 extra bytes of the wear area
  @ofs: offset in page to read
  Programs the flash even and odd planes to the specific block and page.
  Alternatively, programs the flash to the wear area of the specified page.
  doc_write_seek - Set both flash planes to the specified block, page for writing
  @docg3: the device
  @block0: the first plane block index
  @block1: the second plane block index
  @page: the page index within the block
  @ofs: offset in page to write
  Programs the flash even and odd planes to the specific block and page.
  Alternatively, programs the flash to the wear area of the specified page.
  doc_read_page_ecc_init - Initialize hardware ECC engine
  @docg3: the device
  @len: the number of bytes covered by the ECC (BCH covered)
  The function does initialize the hardware ECC engine to compute the Hamming
  ECC (on 1 byte) and the BCH hardware ECC (on 7 bytes).
  Return 0 if succeeded, -EIO on error
  doc_write_page_ecc_init - Initialize hardware BCH ECC engine
  @docg3: the device
  @len: the number of bytes covered by the ECC (BCH covered)
  The function does initialize the hardware ECC engine to compute the Hamming
  ECC (on 1 byte) and the BCH hardware ECC (on 7 bytes).
  Return 0 if succeeded, -EIO on error
  doc_ecc_disable - Disable Hamming and BCH ECC hardware calculator
  @docg3: the device
  Disables the hardware ECC generator and checker, for unchecked reads (as when
  reading OOB only or write status byte).
  doc_hamming_ecc_init - Initialize hardware Hamming ECC engine
  @docg3: the device
  @nb_bytes: the number of bytes covered by the ECC (Hamming covered)
  This function programs the ECC hardware to compute the hamming code on the
  last provided N bytes to the hardware generator.
  doc_ecc_bch_fix_data - Fix if need be read data from flash
  @docg3: the device
  @buf: the buffer of read data (512 + 7 + 1 bytes)
  @hwecc: the hardware calculated ECC.
          It's in fact recv_ecc ^ calc_ecc, where recv_ecc was read from OOB
          area data, and calc_ecc the ECC calculated by the hardware generator.
  Checks if the received data matches the ECC, and if an error is detected,
  tries to fix the bit flips (at most 4) in the buffer buf.  As the docg3
  understands the (data, ecc, syndroms) in an inverted order in comparison to
  the BCH library, the function reverses the order of bits (ie. bit7 and bit0,
  bit6 and bit 1, ...) for all ECC data.
  The hardware ecc unit produces oob_ecc ^ calc_ecc.  The kernel's bch
  algorithm is used to decode this.  However the hw operates on page
  data in a bit order that is the reverse of that of the bch alg,
  requiring that the bits be reversed on the result.  Thanks to Ivan
  Djelic for his analysis.
  Returns number of fixed bits (0, 1, 2, 3, 4) or -EBADMSG if too many bit
  errors were detected and cannot be fixed.
 error is located in data, correct it 
  doc_read_page_prepare - Prepares reading data from a flash page
  @docg3: the device
  @block0: the first plane block index on flash memory
  @block1: the second plane block index on flash memory
  @page: the page index in the block
  @offset: the offset in the page (must be a multiple of 4)
  Prepares the page to be read in the flash memory :
    - tell ASIC to map the flash pages
    - tell ASIC to be in read mode
  After a call to this method, a call to doc_read_page_finish is mandatory,
  to end the read cycle of the flash.
  Read data from a flash page. The length to be read must be between 0 and
  (page_size + oob_size + wear_size), ie. 532, and a multiple of 4 (because
  the extra bytes reading is not implemented).
  As pages are grouped by 2 (in 2 planes), reading from a page must be done
  in two steps:
   - one read of 512 bytes at offset 0
   - one read of 512 bytes at offset 512 + 16
  Returns 0 if successful, -EIO if a read error occurred.
 Program the flash address block and page 
  doc_read_page_getbytes - Reads bytes from a prepared page
  @docg3: the device
  @len: the number of bytes to be read (must be a multiple of 4)
  @buf: the buffer to be filled in (or NULL is forget bytes)
  @first: 1 if first time read, DOC_READADDRESS should be set
  @last_odd: 1 if last read ended up on an odd byte
  Reads bytes from a prepared page. There is a trickery here : if the last read
  ended up on an odd offset in the 1024 bytes double page, ie. between the 2
  planes, the first byte must be read apart. If a word (16bit) read was used,
  the read would return the byte of plane 2 as low and high endian, which
  will mess the read.
  doc_write_page_putbytes - Writes bytes into a prepared page
  @docg3: the device
  @len: the number of bytes to be written
  @buf: the buffer of input bytes
  doc_get_bch_hw_ecc - Get hardware calculated BCH ECC
  @docg3: the device
  @hwecc:  the array of 7 integers where the hardware ecc will be stored
  doc_page_finish - Ends readingwriting of a flash page
  @docg3: the device
  doc_read_page_finish - Ends reading of a flash page
  @docg3: the device
  As a side effect, resets the chip selector to 0. This ensures that after each
  read operation, the floor 0 is selected. Therefore, if the systems halts, the
  reboot will boot on floor 0, where the IPL is.
  calc_block_sector - Calculate blocks, pages and ofs.
  @from: offset in flash
  @block0: first plane block index calculated
  @block1: second plane block index calculated
  @page: page calculated
  @ofs: offset in page
  @reliable: 0 if docg3 in normal mode, 1 if docg3 in fast mode, 2 if docg3 in
  reliable mode.
  The calculation is based on the reliablenormal mode. In normal mode, the 64
  pages of a block are available. In reliable mode, as pages 2n and 2n+1 are
  clones, only 32 pages per block are available.
  doc_read_oob - Read out of band bytes from flash
  @mtd: the device
  @from: the offset from first block and first page, in bytes, aligned on page
         size
  @ops: the mtd oob structure
  Reads flash memory OOB area of pages.
  Returns 0 if read successful, of -EIO, -EINVAL if an error occurred
  doc_block_isbad - Checks whether a block is good or not
  @mtd: the device
  @from: the offset to find the correct block
  Returns 1 if block is bad, 0 if block is good
  doc_get_erase_count - Get block erase count
  @docg3: the device
  @from: the offset in which the block is.
  Get the number of times a block was erased. The number is the maximum of
  erase times between first and second plane (which should be equal normally).
  Returns The number of erases, or -EINVAL or -EIO on error.
  doc_get_op_status - get erasewrite operation status
  @docg3: the device
  Queries the status from the chip, and returns it
  Returns the status (bits DOC_PLANES_STATUS_)
  doc_write_erase_wait_status - wait for write or erase completion
  @docg3: the device
  Wait for the chip to be ready again after erase or write operation, and check
  erasewrite status.
  Returns 0 if erase successful, -EIO if erasewrite issue, -ETIMEOUT if
  timeout
  doc_erase_block - Erase a couple of blocks
  @docg3: the device
  @block0: the first block to erase (leftmost plane)
  @block1: the second block to erase (rightmost plane)
  Erase both blocks, and return operation status
  Returns 0 if erase successful, -EIO if erase issue, -ETIMEOUT if chip not
  ready for too long
  doc_erase - Erase a portion of the chip
  @mtd: the device
  @info: the erase info
  Erase a bunch of contiguous blocks, by pairs, as a "mtd" page of 1024 is
  split into 2 pages of 512 bytes on 2 contiguous blocks.
  Returns 0 if erase successful, -EINVAL if addressing error, -EIO if erase
  issue
  doc_write_page - Write a single page to the chip
  @docg3: the device
  @to: the offset from first block and first page, in bytes, aligned on page
       size
  @buf: buffer to get bytes from
  @oob: buffer to get out of band bytes from (can be NULL if no OOB should be
        written)
  @autoecc: if 0, all 16 bytes from OOB are taken, regardless of HW Hamming or
            BCH computations. If 1, only bytes 0-7 and byte 15 are taken,
            remaining ones are filled with hardware Hamming and BCH
            computations. Its value is not meaningfull is oob == NULL.
  Write one full page (ie. 1 page split on two planes), of 512 bytes, with the
  OOB data. The OOB ECC is automatically computed by the hardware Hamming and
  BCH generator if autoecc is not null.
  Returns 0 if write successful, -EIO if write error, -EAGAIN if timeout
 Program the flash address block and page 
	
	  The wait status will perform another doc_page_finish() call, but that
	  seems to please the docg3, so leave it.
  doc_guess_autoecc - Guess autoecc mode from mbd_oob_ops
  @ops: the oob operations
  Returns 0 or 1 if success, -EINVAL if invalid oob mode
  doc_fill_autooob - Fill a 16 bytes OOB from 8 non-ECC bytes
  @dst: the target 16 bytes OOB buffer
  @oobsrc: the source 8 bytes non-ECC OOB buffer
  doc_backup_oob - Backup OOB into docg3 structure
  @docg3: the device
  @to: the page offset in the chip
  @ops: the OOB size and buffer
  As the docg3 should write a page with its OOB in one pass, and some userland
  applications do write_oob() to setup the OOB and then write(), store the OOB
  into a temporary storage. This is very dangerous, as 2 concurrent
  applications could store an OOB, and then write their pages (which will
  result into one having its OOB corrupted).
  The only reliable way would be for userland to call doc_write_oob() with both
  the page data _and_ the OOB area.
  Returns 0 if success, -EINVAL if ops content invalid
  doc_write_oob - Write out of band bytes to flash
  @mtd: the device
  @ofs: the offset from first block and first page, in bytes, aligned on page
        size
  @ops: the mtd oob structure
  Either write OOB data into a temporary buffer, for the subsequent write
  page. The provided OOB should be 16 bytes long. If a data buffer is provided
  as well, issue the page write.
  Or provide data without OOB, and then a all zeroed OOB will be used (ECC will
  still be filled in if asked for).
  Returns 0 is successful, EINVAL if length is not 14 bytes
  Debug sysfs entries
  doc_set_driver_info - Fill the mtd_info structure and docg3 structure
  @chip_id: The chip ID of the supported chip
  @mtd: The structure to fill
  doc_probe_device - Check if a device is available
  @cascade: the cascade of chips this devices will belong to
  @floor: the floor of the probed device
  @dev: the device
  Checks whether a device at the specified IO range, and floor is available.
  Returns a mtd_info struct if there is a device, ENODEV if none found, ENOMEM
  if a memory allocation failed. If floor 0 is checked, a reset of the ASIC is
  launched.
  doc_release_device - Release a docg3 floor
  @mtd: the device
  docg3_resume - Awakens docg3 floor
  @pdev: platfrom device
  Returns 0 (always successful)
  docg3_suspend - Put in low power mode the docg3 floor
  @pdev: platform device
  @state: power state
  Shuts off most of docg3 circuitery to lower power consumption.
  Returns 0 if suspend succeeded, -EIO if chip refused suspend
  doc_probe - Probe the IO space for a DiskOnChip G3 chip
  @pdev: platform device
  Probes for a G3 chip at the specified IO space in the platform data
  ressources. The floor 0 must be available.
  Returns 0 on success, -ENOMEM, -ENXIO on error
  docg3_release - Release the driver
  @pdev: the platform device
  Returns 0
  mtdram - a test mtd device
  Author: Alexander Larsson <alex@cendio.se>
  Copyright (c) 1999 Alexander Larsson <alex@cendio.se>
  Copyright (c) 2005 Joern Engel <joern@wh.fh-wedel.de>
  This code is GPL
 We could store these in the mtd structure, but we only support 1 device..
 Start address must align on block boundary 
 Length must align on block boundary 
 limit retlen to the number of contiguous physical pages 
 Setup the MTD structure 
 Allocate some memory 
 SPDX-License-Identifier: GPL-2.0-or-later
 	Copyright (c) 2001 Maciej W. Rozycki
  Addresses we probe for an MS02-NV at.  Modules may be located
  at any 8MiB boundary within a 0MiB up to 112MiB range or at any 32MiB
  boundary within a 0MiB up to 448MiB range.  We don't support a module
  at 0MiB, though.
	
	  The firmware writes MS02NV_ID at MS02NV_MAGIC and also
	  a diagnostic status at MS02NV_DIAG.
 The module decodes 8MiB of address space. 
 Firmware's diagnostic NVRAM area. 
 User-available general-purpose NVRAM area. 
 Control and status register. 
	
	  Hide the firmware's diagnostic area.  It may get destroyed
	  upon a reboot.  Take paging into account for mapping support.
 SPDX-License-Identifier: GPL-2.0-only
  Various helpers
  MTD ops
		 Newer flashes have "sub-sectors" which can be erased
		  independently with a new command: ST_SSE. The ST_SE command
		  erases 64KB just as before.
 Check address range 
 Read as much as possible using fast MMIO window 
 Use indirect access for content out of the window 
 Enable writes 
 Write first byte 
 Program page 
 1B written 
 Program page and set CSA (on newer chips we can continue writing) 
 Page boundary, another function call is needed 
 All done, drop CSA & poll 
 If we don't overwrite whole page, read it to the buffer first 
 250 us for AT45DB321B 
 Change buffer content with our data 
 Page boundary, another function call is needed 
 Program page with the buffer content 
	 Writing functions can return without writing all passed data, for
	  example when the hardware is too old or when we git page boundary.
  BCMA
	
	  On old MIPS devices cache was magically invalidated when needed,
	  allowing us to use cached access and gain some performance. Trying
	  the same on ARM based BCM53573 results in flash corruptions, we need
	  to use uncached access for it.
	 
	  It may be arch specific, but right now there is only 1 ARM SoC using
	  this driver, so let's follow Broadcom's reference code and check
	  ChipCommon revision.
  Init
 SPDX-License-Identifier: GPL-2.0-only
======================================================================
  This driver provides a method to access memory not used by the kernel
  itself (i.e. if the kernel commandline mem=xxx is used). To actually
  use slram at least mtdblock or mtdchar is required (for block or
  character device access).
  Usage:
  if compiled as loadable module:
    modprobe slram map=<name>,<start>,<endoffset>
  if statically linked into the kernel use the following kernel cmd.line
    slram=<name>,<start>,<endoffset>
  <name>: name of the device that will be listed in procmtd
  <start>: start of the memory region, decimal or hex (0xabcdef)
  <endoffset>: end of the memory region. It's possible to use +0x1234
                to specify the offset instead of the absolute address
  NOTE:
  With slram it's only possible to map a contiguous memory region. Therefore
  if there's a device mapped somewhere in the region specified slram will
  fail to load (see kernel log if modprobe fails).
  -
  Jochen Schaeuble <psionic@psionic.de>
 3 parameters  device 
====================================================================
 !MODULE 
 SPDX-License-Identifier: GPL-2.0-only
  st_spi_fsm.c	- ST Fast Sequence Mode (FSM) Serial Flash Controller
  Author: Angus Clark <angus.clark@st.com>
  Copyright (C) 2010-2014 STMicroelectronics Limited
  JEDEC probe based on driversmtddevicesm25p80.c
  FSM SPI Controller Registers
  Register: SPI_MODESELECT
  Register: SPI_CONFIGDATA
  Register: SPI_FAST_SEQ_TRANSFER_SIZE
  Register: SPI_FAST_SEQ_ADD_CFG
  Register: SPI_FAST_SEQ_n
  Register: SPI_FAST_SEQ_CFG
  Register: SPI_MODE_BITS
  Register: SPI_DUMMY_BITS
  Register: SPI_FAST_SEQ_FLASH_STA_DATA
  FSM SPI Instruction Opcodes
  FSM SPI Instructions (== opcode + operand).
 100 MHz 
 15ms 
 10 MHz 
 FSM execution time 
 S25FLxxxS commands 
#define S25FL_CMD_WRITE4       0x12     Note, opcode clashes with
					 'SPINOR_OP_WRITE_1_4_4'
 Status register 
 S25FL Error Flags 
 In Bytes    
 In uint32_t 
 Maximum 'CHIPERASE' time 
  Flags to tweak operation of default readwriteerase routines
 Parameters to configure a READ or WRITE FSM sequence 
 flags to support config 
 FLASH command 
 Write Sequence 
 No. of addr pads (MODE & DUMMY) 
 No. of data pads 
 MODE data 
 No. of MODE cycles 
 No. of DUMMY cycles 
 SPI Flash Device Table 
	
	  JEDEC id zero means "no ID" (most older chips); otherwise it has
	  a high byte of zero plus three data bytes: the manufacturer id,
	  then a two byte device id.
	
	  The size listed here is what works with SPINOR_OP_SE, which isn't
	  necessarily called a "sector" by the vendor.
	
	  Note, where FAST_READ is supported, freq_max specifies the
	  FAST_READ frequency, not the READ frequency.
	
	  ST MicroelectronicsNumonyx --
	  (newer production versions may have feature updates
	  (eg faster operating frequency)
	 Macronix MX25xxx
	      - Support for 'FLASH_FLAG_WRITE_1_4_4' is omitted for devices
	        where operating frequency must be reduced.
	
	  Spansion S25FLxxxP
	      - 256KiB and 64KiB sector variants (identified by ext. JEDEC)
	
	  Spansion S25FLxxxS
	      - 256KiB and 64KiB sector variants (identified by ext. JEDEC)
	      - RESET# signal supported by die but not bristled out on all
	        package types.  The package type is a function of board design,
	        so this information is captured in the board's flags.
	      - Supports 'DYB' sector protection. Depending on variant, sectors
	        may default to locked state on power-on.
 Winbond -- w25x "blocks" are 64K, "sectors" are 4KiB 
 Winbond -- w25q "blocks" are 64K, "sectors" are 4KiB 
 Sentinel 
  FSM message sequence configurations:
  All configs are presented in order of preference
 Default READ configurations, in order of preference 
 Default WRITE configurations 
  [N25Qxxx] Configuration
 N25Q 3-byte Address READ configurations
 	- 'FAST' variants configured for 8 dummy cycles.
  Note, the number of dummy cycles used for 'FAST' READ operations is
  configurable and would normally be tuned according to the READ command and
  operating frequency.  However, this applies universally to all 'FAST' READ
  commands, including those used by the SPIBoot controller, and remains in
  force until the device is power-cycled.  Since the SPIBoot controller is
  hard-wired to use 8 dummy cycles, we must configure the device to also use 8
  cycles.
 N25Q 4-byte Address READ configurations
 	- use special 4-byte address READ commands (reduces overheads, and
         reduces risk of hitting watchdog reset issues).
 	- 'FAST' variants configured for 8 dummy cycles (see note above.)
  [MX25xxx] Configuration
  [S25FLxxx] Configuration
  S25FLxxxS devices provide three ways of supporting 32-bit addressing: Bank
  Register, Extended Address Modes, and a 32-bit address command set.  The
  32-bit address command set is used here, since it avoids any problems with
  entering a state that is incompatible with the SPIBoot Controller.
  [W25Qxxx] Configuration
 'addr_cfg' configured during initialisation 
 Dummy sequence to read one byte of data from flash into the FIFO 
  Clear the data FIFO
  Typically, this is only required during driver initialisation, where no
  assumptions can be made regarding the state of the FIFO.
  The process of clearing the FIFO is complicated by fact that while it is
  possible for the FIFO to contain an arbitrary number of bytes [1], the
  SPI_FAST_SEQ_STA register only reports the number of complete 32-bit words
  present.  Furthermore, data can only be drained from the FIFO by reading
  complete 32-bit words.
  With this in mind, a two stage process is used to the clear the FIFO:
      1. Read any complete 32-bit words from the FIFO, as reported by the
         SPI_FAST_SEQ_STA register.
      2. Mop up any remaining bytes.  At this point, it is not known if there
         are 0, 1, 2, or 3 bytes in the FIFO.  To handle all cases, a dummy FSM
         sequence is used to load one byte at a time, until a complete 32-bit
         word is formed; at most, 4 bytes will need to be loaded.
  [1] It is theoretically possible for the FIFO to contain an arbitrary number
      of bits.  However, since there are no known use-cases that leave
      incomplete bytes in the FIFO, only words and bytes are considered here.
 1. Clear any 32-bit words 
	
	  2. Clear any remaining bytes
	     - Load the FIFO, one byte at a time, until a complete 32-bit word
	       is available.
    - A single word must be available now 
    - Read the 32-bit word 
 Use RDRS1 
 Load read_status sequence 
	
	  Repeat until busy bit is deasserted, or timeout, or error (S25FLxxxS)
 Restart 
  SoC reset on 'boot-from-spi' systems
  Certain modes of operation cause the Flash device to enter a particular state
  for a period of time (e.g. 'Erase Sector', 'Quad Enable', and 'Enter 32-bit
  Addr' commands).  On boot-from-spi systems, it is important to consider what
  happens if a warm reset occurs during this period.  The SPIBoot controller
  assumes that Flash device is in its default reset state, 24-bit address mode,
  and ready to accept commands.  This can be achieved using some form of
  on-board logiccontroller to force a device POR in response to a SoC-level
  reset or by making use of the device reset signal if available (limited
  number of devices only).
  Failure to take such precautions can cause problems following a warm reset.
  For some operations (e.g. ERASE), there is little that can be done.  For
  other modes of operation (e.g. 32-bit addressing), options are often
  available that can help minimise the window in which a reset could cause a
  problem.
 Reset signal is available on the board and supported by the device 
 Board-level logic forces a power-on-reset 
 Reset is not properly handled and may result in failure to reboot 
 Configure 'addr_cfg' according to addressing mode 
 Search for preferred configuration based on available flags 
 Prepare a READWRITE sequence according to configuration parameters 
 Add READWRITE OPC  
 Add WREN OPC for a WRITE sequence 
 Address configuration (24 or 32-bit addresses) 
 ADD1 cycles 
 ADD1 pads 
 ADD2 cycles 
 ADD2 pads 
 DataSequence configuration 
 Mode configuration (no. of pads taken from addr cfg) 
 data 
 cycles 
 pads 
 Dummy configuration (no. of pads taken from addr cfg) 
 cycles 
 pads 
 Instruction sequence 
 Prepare a READWRITEERASE 'default' sequences 
 Configure 'READ' sequence 
 Configure 'WRITE' sequence 
 Configure 'ERASE_SECTOR' sequence 
	
	  Use default READWRITE sequences
	
	  Configure 32-bit Address Support
 Configure 'enter_32bitaddr' FSM sequence 
			 If we can handle SoC resets, we enable 32-bit address
			 Else, enabledisable 32-bit addressing beforeafter
 Check status of 'QE' bit, update if required. 
 Set 'QE' 
 Clear 'QE' 
 Configure 'READ' sequence 
 Configure 'WRITE' sequence (default configs) 
  Configure 'ERASE_SECTOR' sequence 
 Configure 32-bit address support 
			
			  If we can handle SoC resets, we enable 32-bit
			  address mode pervasively
			
			  If not, enabledisable for WRITE and ERASE
			  operations (READ uses special commands)
	
	  Configure device to use 8 dummy cycles
		
		  Prepare ReadWriteErase sequences according to S25FLxxx
		  32-bit address command set
 Use default configurations for 24-bit addressing 
	
	  For devices that support 'DYB' sector locking, check lock status and
	  unlock sectors if necessary (some variants power-on with sectors
	  locked by default)
 Handle bottomtop 4KiB parameter sectors 
 Check status of 'QE' bit, update if required. 
 Set 'QE' 
 Clear 'QE' 
	
	  S25FLxxx devices support Program and Error error flags.
	  Configure driver to check flags and clear if necessary.
 Check status of 'QE' bit, update if required. 
 Set 'QE' 
 Clear 'QE' 
 Write status register 
 Enter 32-bit address mode, if required 
 Must read in multiples of 32 cycles (or 32pads8 Bytes) 
 Handle non-aligned buf 
 Handle non-aligned size 
 Handle non-aligned buf 
 Wait for sequence to finish 
 Exit 32-bit address mode, if required 
 Enter 32-bit address mode, if required 
 Must write in multiples of 32 cycles (or 32pads8 bytes) 
 Handle non-aligned buf 
 Handle non-aligned size 
	 Need to set FIFO to write mode, before writing data to FIFO (see
	  GNBvb79594)
	
	  Before writing data to the FIFO, apply a small delay to allow a
	  potential change of FIFO direction to complete.
 Write data to FIFO, before starting sequence (see GNBvd79593) 
 Handle non-aligned size 
 fill with 0xff's 
 Start sequence 
 Wait for sequence to finish 
 Wait for completion 
 Exit 32-bit address mode, if required 
  Read an address range from the flash chip. The address range
  may be any size provided it is within the physical boundaries.
 Enter 32-bit address mode, if required 
 Wait for completion 
 Exit 32-bit address mode, if required 
  Write an address range to the flash chip.  Data must be written in
  FLASH_PAGESIZE chunks.  The address range may be any size provided
  it is within the physical boundaries.
 Offset within page 
 Write up to page boundary 
 We are now page-aligned 
  Erase an address range on the flash chip. The address range may extend
  one or more erase sectors.  Return an error is there is a problem erasing.
 Whole-chip erase? 
	
	  JEDEC also defines an optional "extended device information"
	  string for after vendor-specific data, after the three bytes
	  we use here. Supporting some chips might require using it.
 Wait for controller to accept mode change 
	
	  Calculate clk_div - values between 2 and 128
	  Multiple of 2, rounded up
	
	  Determine a suitable delay for the IP to complete a change of
	  direction of the FIFO. The required delay is related to the clock
	  divider used. The following heuristics are based on empirical tests,
	  using a 100MHz EMI clock.
 Perform a soft reset of the FSM controller 
 Set clock to 'safe' frequency initially 
 Switch to FSM 
 Set timing parameters 
	
	  Set the FSM 'WAIT' delay to the minimum workable value.  Note, for
	  our purposes, the WAIT instruction is used purely to achieve
	  "sequence validity" rather than actually implement a delay.
 Clear FIFO, just in case 
 Value we read from boot_device_reg 
 Booting from SPI NOR Flash is the default 
 Where in the syscon the boot device information lives 
 Boot device value when booted from SPI NOR 
 Detect SPI FLASH device 
 Use device size to determine address width 
	
	  Configure READWRITEERASE sequences according to platform and
	  device flags.
 SPDX-License-Identifier: GPL-2.0-only
  Industry-pack bus support functions.
  Copyright (C) 2011-2012 CERN (www.cern.ch)
  Author: Samuel Iglesias Gonsalvez <siglesias@igalia.com>
  The algorithm in libcrc-ccitt.c does not seem to apply since it uses the
  opposite bit ordering.
	 Determine ID PROM Data Format.  If we find the ids "IPAC" or "IPAH"
	  we are dealing with a IndustryPack  format 1 device.  If we detect
	  "VITA4 " (16 bit big endian formatted) we are dealing with a
	 Obtain the amount of memory required to store a copy of the complete
 now we can finally work with the copy 
 if the device supports 32 MHz operation, use it. 
 SPDX-License-Identifier: GPL-2.0-only
  driver for the TEWS TPCI-200 device
  Copyright (C) 2009-2012 CERN (www.cern.ch)
  Author: Nicolas Serafini, EIC2 SA
  Author: Samuel Iglesias Gonsalvez <siglesias@igalia.com>
 Read status register 
 Did we cause the interrupt? 
 callback to the IRQ handler for the corresponding slot 
 uninstall handler 
	
	  WARNING: Setup Interrupt Vector in the IndustryPack device
	  before an IRQ request.
	  Read the User Manual of your IndustryPack device to know
	  where to write the vector in memory.
 Request IP interface register (Bar 2) 
 Request IO ID INT space (Bar 3) 
 Request MEM8 space (Bar 5) 
 Request MEM16 space (Bar 4) 
 Map internal tpci200 driver user space 
 Initialize lock that protects interface_regs 
	 Set the default parameters of the slot
	  INT0 disabled, level sensitive
	  INT1 disabled, level sensitive
	  error interrupt disabled
	  timeout interrupt disabled
	  recover time disabled
	  clock rate 8 MHz
 Obtain a mapping of the carrier's PCI configuration registers 
	 Disable byte swapping for 16 bit IP module access. This will ensure
	  that the Industrypack big endian byte order is preserved by the
 Save struct pci_dev pointer 
 register the device and initialize it 
 Register the carrier in the industry pack bus driver 
 save the bus number given by ipack to logging purpose 
 SPDX-License-Identifier: GPL-2.0-only
  driver for the GE IP-OCTAL boards
  Copyright (C) 2009-2012 CERN (www.cern.ch)
  Author: Nicolas Serafini, EIC2 SA
  Author: Samuel Iglesias Gonsalvez <siglesias@igalia.com>
	
	  Enable RX. TX will be enabled when
	  there is something to send
 Error: count statistics 
 Overrun doesn't affect the current character
		 Check if there are more characters in RX FIFO
		  If there are more, the isr register for this channel
		  has enabled the RxRDY|FFULL bit.
	 The HW is organized in pair of channels.  See which register we need
		 In case of RS-485, change from TX to RX when finishing TX.
 RX data 
 TX of each character 
 Clear the IPack device interrupt 
 Check all channels 
 Save the virtual address to access the registers easily 
 Disable RX and TX before touching anything 
 mr1 
 mr2 
 Dummy write 
 Register the TTY device 
 Each IP-OCTAL channel is a TTY port 
 Fill struct tty_driver with ipoctal data 
 Save struct tty_driver for use it when uninstalling the device 
	
	  IP-OCTAL has different addresses to copy its IRQ vector.
	  Depending of the carrier these addresses are accesible or not.
	  More info in the datasheet.
 Copy the bytes from the user buffer to the internal one 
 As the IP-OCTAL 485 only supports half duplex, do it manually 
	
	  Send a packet and then disable TX to avoid failure after several send
	  operations
 Disable and reset everything before change the setup 
 Set Bits per chars 
 By default, select CS8 
 Set Parity 
 Mark or space parity is not supported 
 Set stop bits 
 Set the flow control 
 Set baud rate 
 In case of default, we establish 38400 bps 
 Write the control registers 
 Enable again the RX, if it was before 
 release the carrier driver 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2019-2020 Intel Corporation
  Please see Documentationdriver-apiauxiliary_bus.rst for more information.
 use dev_name(&auxdev->dev) prefix before last '.' char to match to 
  auxiliary_device_init - check auxiliary_device and initialize
  @auxdev: auxiliary device struct
  This is the first step in the two-step process to register an
  auxiliary_device.
  When this function returns an error code, then the device_initialize will
  not have been performed, and the caller will be responsible to free any
  memory allocated for the auxiliary_device in the error path directly.
  It returns 0 on success.  On success, the device_initialize has been
  performed.  After this point any error unwinding will need to include a call
  to auxiliary_device_uninit().  In this post-initialize error scenario, a call
  to the device's .release callback will be triggered, and all memory clean-up
  is expected to be handled there.
  __auxiliary_device_add - add an auxiliary bus device
  @auxdev: auxiliary bus device to add to the bus
  @modname: name of the parent device's driver module
  This is the second step in the two-step process to register an
  auxiliary_device.
  This function must be called after a successful call to
  auxiliary_device_init(), which will perform the device_initialize.  This
  means that if this returns an error code, then a call to
  auxiliary_device_uninit() must be performed so that the .release callback
  will be triggered to free the memory associated with the auxiliary_device.
  The expectation is that users will call the "auxiliary_device_add" macro so
  that the caller's KBUILD_MODNAME is automatically inserted for the modname
  parameter.  Only if a user requires a custom name would this version be
  called directly.
  auxiliary_find_device - auxiliary device iterator for locating a particular device.
  @start: Device to begin with
  @data: Data to pass to match function
  @match: Callback function to check device
  This function returns a reference to a device that is 'found'
  for later use, as determined by the @match callback.
  The callback should return 0 if the device doesn't match and non-zero
  if it does.  If the callback returns non-zero, this function will
  return to the caller and not iterate over any more devices.
  __auxiliary_driver_register - register a driver for auxiliary bus devices
  @auxdrv: auxiliary_driver structure
  @owner: owning moduledriver
  @modname: KBUILD_MODNAME for parent driver
  auxiliary_driver_unregister - unregister a driver
  @auxdrv: auxiliary_driver structure
 SPDX-License-Identifier: GPL-2.0
  Software nodes for the firmware node framework.
  Copyright (C) 2018, Intel Corporation
  Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
 hierarchy 
 -------------------------------------------------------------------------- 
 property_entry processing 
 Find out the array length. 
 Return how many there are if strings is NULL. 
	
	  Properties with no data should not be marked as stored
	  out of line.
	
	  Reference properties are never stored inline as
	  they are too big.
  property_entries_dup - duplicate array of properties
  @properties: array of properties to copy
  This function creates a deep copy of the given NULL-terminated array
  of property entries.
  property_entries_free - free previously allocated array of properties
  @properties: array of properties to destroy
  This function frees given NULL-terminated array of property entries,
  along with their data.
 -------------------------------------------------------------------------- 
 fwnode operations 
 Figure out the prefix from the parents. 
 Guess something if prefix was NULL. 
	
	  We expect that references are never stored inline, even
	  single ones, as they are too big.
		
		  fwnode ports have naming style "port@", so we search for any
		  children that follow that convention.
 Ports have naming style "port@n", we need to select the n 
 -------------------------------------------------------------------------- 
  software_node_find_by_name - Find software node by name
  @parent: Parent of the software node
  @name: Name of the software node
  The function will find a node that is child of @parent and that is named
  @name. If no node is found, the function returns NULL.
  NOTE: you will need to drop the reference with fwnode_handle_put() after use.
	
	  Assign the flag only in the successful case, so
	  the above kobject_put() won't mess up with properties.
  software_node_register_nodes - Register an array of software nodes
  @nodes: Zero terminated array of software nodes to be registered
  Register multiple software nodes at once. If any node in the array
  has its .parent pointer set (which can only be to another software_node),
  then its parent must have been registered before it is; either outside
  of this function or by ordering the array such that parent comes before
  child.
  software_node_unregister_nodes - Unregister an array of software nodes
  @nodes: Zero terminated array of software nodes to be unregistered
  Unregister multiple software nodes at once. If parent pointers are set up
  in any of the software nodes then the array must be ordered such that
  parents come before their children.
  NOTE: If you are uncertain whether the array is ordered such that
  parents will be unregistered before their children, it is wiser to
  remove the nodes individually, in the correct order (child before
  parent).
  software_node_register_node_group - Register a group of software nodes
  @node_group: NULL terminated array of software node pointers to be registered
  Register multiple software nodes at once. If any node in the array
  has its .parent pointer set (which can only be to another software_node),
  then its parent must have been registered before it is; either outside
  of this function or by ordering the array such that parent comes before
  child.
  software_node_unregister_node_group - Unregister a group of software nodes
  @node_group: NULL terminated array of software node pointers to be unregistered
  Unregister multiple software nodes at once. If parent pointers are set up
  in any of the software nodes then the array must be ordered such that
  parents come before their children.
  NOTE: If you are uncertain whether the array is ordered such that
  parents will be unregistered before their children, it is wiser to
  remove the nodes individually, in the correct order (child before
  parent).
  software_node_register - Register static software node
  @node: The software node to be registered
  software_node_unregister - Unregister static software node
  @node: The software node to be unregistered
  device_add_software_node - Assign software node to a device
  @dev: The device the software node is meant for.
  @node: The software node.
  This function will make @node the secondary firmware node pointer of @dev. If
  @dev has no primary node, then @node will become the primary node. The
  function will register @node automatically if it wasn't already registered.
 Only one software node per device. 
	
	  If the device has been fully registered by the time this function is
	  called, software_node_notify() must be called separately so that the
	  symlinks get created and the reference count of the node is kept in
	  balance.
  device_remove_software_node - Remove device's software node
  @dev: The device with the software node.
  This function will unregister the software node of @dev.
  device_create_managed_software_node - Create a software node for a device
  @dev: The device the software node is assigned to.
  @properties: Device properties for the software node.
  @parent: Parent of the software node.
  Creates a software node as a managed resource for @dev, which means the
  lifetime of the newly created software node is tied to the lifetime of @dev.
  Software nodes created with this function should not be reused or shared
  because of that. The function takes a deep copy of @properties for the
  software node.
  Since the new software node is assigned directly to @dev, and since it should
  not be shared, it is not returned to the caller. The function returns 0 on
  success, and errno in case of an error.
 SPDX-License-Identifier: GPL-2.0
  Driver core interface to the pinctrl subsystem.
  Copyright (C) 2012 ST-Ericsson SA
  Written on behalf of Linaro for ST-Ericsson
  Based on bits of regulator core, gpio core and clk core
  Author: Linus Walleij <linus.walleij@linaro.org>
  pinctrl_bind_pins() - called by the device core before probe
  @dev: the device that is just about to probe
 Not supplying this state is perfectly legal 
	
	  If power management is enabled, we also look for the optional
	  sleep and idle pin states, with semantics as defined in
	  <linuxpinctrlpinctrl-state.h>
 Not supplying this state is perfectly legal 
 Not supplying this state is perfectly legal 
	
	  If no pinctrl handle or default state was found for this device,
	  let's explicitly free the pin container in the device, there is
	  no point in keeping it around.
 Return deferrals 
 Return serious errors 
 We ignore errors like -ENOENT meaning no pinctrl state 
 SPDX-License-Identifier: GPL-2.0
  driver.c - centralized device driver management
  Copyright (c) 2002-3 Patrick Mochel
  Copyright (c) 2002-3 Open Source Development Labs
  Copyright (c) 2007 Greg Kroah-Hartman <gregkh@suse.de>
  Copyright (c) 2007 Novell Inc.
  driver_for_each_device - Iterator for devices bound to a driver.
  @drv: Driver we're iterating.
  @start: Device to begin with
  @data: Data to pass to the callback.
  @fn: Function to call for each device.
  Iterate over the @drv's list of devices calling @fn for each one.
  driver_find_device - device iterator for locating a particular device.
  @drv: The device's driver
  @start: Device to begin with
  @data: Data to pass to match function
  @match: Callback function to check device
  This is similar to the driver_for_each_device() function above, but
  it returns a reference to a device that is 'found' for later use, as
  determined by the @match callback.
  The callback should return 0 if the device doesn't match and non-zero
  if it does.  If the callback returns non-zero, this function will
  return to the caller and not iterate over any more devices.
  driver_create_file - create sysfs file for driver.
  @drv: driver.
  @attr: driver attribute descriptor.
  driver_remove_file - remove sysfs file for driver.
  @drv: driver.
  @attr: driver attribute descriptor.
  driver_register - register driver with bus
  @drv: driver to register
  We pass off most of the work to the bus_add_driver() call,
  since most of the things we have to do deal with the bus
  structures.
  driver_unregister - remove driver from system.
  @drv: driver.
  Again, we pass off most of the work to the bus-level call.
  driver_find - locate driver on a bus by its name.
  @name: name of the driver.
  @bus: bus to scan for the driver.
  Call kset_find_obj() to iterate over list of drivers on
  a bus to find driver by name. Return driver if found.
  This routine provides no locking to prevent the driver it returns
  from being unregistered or unloaded while the caller is using it.
  The caller is responsible for preventing this.
 Drop reference added by kset_find_obj() 
 SPDX-License-Identifier: GPL-2.0
  bus.c - bus driver management
  Copyright (c) 2002-3 Patrick Mochel
  Copyright (c) 2002-3 Open Source Development Labs
  Copyright (c) 2007 Greg Kroah-Hartman <gregkh@suse.de>
  Copyright (c) 2007 Novell Inc.
 sysdevicessystem 
  sysfs bindings for drivers
  sysfs bindings for buses
 Manually detach a device from its associated driver. 
  Manually attach a device to a driver.
  Note: the driver must want to bind to the device,
  it is not possible to override the driver's id table.
 success 
  bus_for_each_dev - device iterator.
  @bus: bus type.
  @start: device to start iterating from.
  @data: data for the callback.
  @fn: function to be called for each device.
  Iterate over @bus's list of devices, and call @fn for each,
  passing it @data. If @start is not NULL, we use that device to
  begin iterating from.
  We check the return of @fn each time. If it returns anything
  other than 0, we break out and return that value.
  NOTE: The device that returns a non-zero value is not retained
  in any way, nor is its refcount incremented. If the caller needs
  to retain this data, it should do so, and increment the reference
  count in the supplied callback.
  bus_find_device - device iterator for locating a particular device.
  @bus: bus type
  @start: Device to begin with
  @data: Data to pass to match function
  @match: Callback function to check device
  This is similar to the bus_for_each_dev() function above, but it
  returns a reference to a device that is 'found' for later use, as
  determined by the @match callback.
  The callback should return 0 if the device doesn't match and non-zero
  if it does.  If the callback returns non-zero, this function will
  return to the caller and not iterate over any more devices.
  subsys_find_device_by_id - find a device with a specific enumeration number
  @subsys: subsystem
  @id: index 'id' in struct device
  @hint: device to check first
  Check the hint's next object and if it is a match return it directly,
  otherwise, fall back to a full list search. Either way a reference for
  the returned object is taken.
  bus_for_each_drv - driver iterator
  @bus: bus we're dealing with.
  @start: driver to start iterating on.
  @data: data to pass to the callback.
  @fn: function to call for each driver.
  This is nearly identical to the device iterator above.
  We iterate over each driver that belongs to @bus, and call
  @fn for each. If @fn returns anything but 0, we break out
  and return it. If @start is not NULL, we use it as the head
  of the list.
  NOTE: we don't return the driver that returns a non-zero
  value, nor do we leave the reference count incremented for that
  driver. If the caller needs to know that info, it must set it
  in the callback. It must also be sure to increment the refcount
  so it doesn't disappear before returning to the caller.
  bus_add_device - add device to bus
  @dev: device being added
  - Add device's bus attributes.
  - Create links to device's bus.
  - Add the device to its bus's list of devices.
  bus_probe_device - probe drivers for a new device
  @dev: device to probe
  - Automatically probe for a driver if the bus allows it.
  bus_remove_device - remove device from bus
  @dev: device to be removed
  - Remove device from all interfaces.
  - Remove symlink from bus' directory.
  - Delete device from bus's list.
  - Detach from its driver.
  - Drop reference taken in bus_add_device().
  bus_add_driver - Add a driver to the bus.
  @drv: driver.
 How the hell do we get out of this pickle? Give up 
 Ditto 
 drv->p is freed in driver_release()  
  bus_remove_driver - delete driver from bus's knowledge.
  @drv: driver.
  Detach the driver from the devices it controls, and remove
  it from its bus's list of drivers. Finally, we drop the reference
  to the bus we took in bus_add_driver().
 Helper for bus_rescan_devices's iter 
  bus_rescan_devices - rescan devices on the bus for possible drivers
  @bus: the bus to scan.
  This function will look for devices on the bus with no driver
  attached and rescan it against existing drivers to see if it matches
  any by calling device_attach() for the unbound devices.
  device_reprobe - remove driver for a device and probe for a new driver
  @dev: the device to reprobe
  This function detaches the attached driver (if any) for the given
  device and restarts the driver probing process.  It is intended
  to use if probing criteria changed during a devices lifetime and
  driver attachment should change accordingly.
  "open code" the old BUS_ATTR() macro here.  We want to use BUS_ATTR_WO()
  here, but can not use it as earlier in the file we have
  DEVICE_ATTR_WO(uevent), which would cause a clash with the with the store
  function name.
  bus_register - register a driver-core subsystem
  @bus: bus to register
  Once we have that, we register the bus with the kobject
  infrastructure, then register the children subsystems it has:
  the devices and drivers that belong to the subsystem.
  bus_unregister - remove a bus from the system
  @bus: bus.
  Unregister the child subsystems and the bus itself.
  Finally, we call bus_put() to release the refcount
  Yes, this forcibly breaks the klist abstraction temporarily.  It
  just wants to sort the klist, not change reference counts and
  takedrop locks rapidly in the process.  It does all this while
  holding the lock for the list, so objects can't otherwise be
  addedremoved while we're swizzling.
  subsys_dev_iter_init - initialize subsys device iterator
  @iter: subsys iterator to initialize
  @subsys: the subsys we wanna iterate over
  @start: the device to start iterating from, if any
  @type: device_type of the devices to iterate over, NULL for all
  Initialize subsys iterator @iter such that it iterates over devices
  of @subsys.  If @start is set, the list iteration will start there,
  otherwise if it is NULL, the iteration starts at the beginning of
  the list.
  subsys_dev_iter_next - iterate to the next device
  @iter: subsys iterator to proceed
  Proceed @iter to the next device and return it.  Returns NULL if
  iteration is complete.
  The returned device is referenced and won't be released till
  iterator is proceed to the next device or exited.  The caller is
  free to do whatever it wants to do with the device including
  calling back into subsys code.
  subsys_dev_iter_exit - finish iteration
  @iter: subsys iterator to finish
  Finish an iteration.  Always call this function after iteration is
  complete whether the iteration ran till the end or not.
  subsys_system_register - register a subsystem at sysdevicessystem
  @subsys: system subsystem
  @groups: default attributes for the root device
  All 'system' subsystems have a sysdevicessystem<name> root device
  with the name of the subsystem. The root device can carry subsystem-
  wide attributes. All registered devices are below this single root
  device and are named after the subsystem with a simple enumeration
  number appended. The registered devices are not explicitly named;
  only 'id' in the device needs to be set.
  Do not use this interface for anything new, it exists for compatibility
  with bad ideas only. New subsystems should use plain subsystems; and
  add the subsystem-wide attributes should be added to the subsystem
  directory itself and not some create fake root-device placed in
  sysdevicessystem<name>.
  subsys_virtual_register - register a subsystem at sysdevicesvirtual
  @subsys: virtual subsystem
  @groups: default attributes for the root device
  All 'virtual' subsystems have a sysdevicessystem<name> root device
  with the name of the subystem.  The root device can carry subsystem-wide
  attributes.  All registered devices are below this single root device.
  There's no restriction on device naming.  This is for kernel software
  constructs which need sysfs interface.
 SPDX-License-Identifier: GPL-2.0
  cacheinfo support - processor cache information via sysfs
  Based on archx86kernelcpuintel_cacheinfo.c
  Author: Sudeep Holla <sudeep.holla@arm.com>
 pointer to per cpu cacheinfo 
 OF properties to query for a given cache type 
 not cache_line_size() because that's a macro in includelinuxcache.h 
	
	  If the cache is fully associative, there is no need to
	  check the other properties.
	
	  init_cache_level must setup the cache level correctly
	  overriding the architecturally specified levels, so
	  if type is NONE at this stage, it should be unified
 skip if fw_token is already populated 
 cpu node itself 
 not all OF nodes populated 
	
	  For non-DTACPI systems, assume unique level 1 caches, system-wide
	  shared caches for all other levels. This will be used only if
	  arch specific code has not populated shared_cpu_map
 skip if shared_cpu_map is already populated 
 skip if itself or no cacheinfo 
 record the maximum cache line size 
 skip itself 
	
	  populate_cache_leaves() may completely setup the cache leaves and
	  shared_cpu_map or it may leave it partially setup.
	
	  For systems using DT for cache hierarchy, fw_token
	  and shared_cpu_map will be set up here only if they are
	  not populated already
 pointer to cpuXcache device 
 pointer to array of devices for cpuXcacheindexY 
 allow 0 = full associativity 
 Place holder for private group 
 AddRemove cache interface for CPU device 
 Allocate all required memory 
 SPDX-License-Identifier: GPL-2.0-only
  NUMA support, based on the x86 implementation.
  Copyright (C) 2015 Cavium Inc.
  Author: Ganapatrao Kulkarni <gkulkarni@cavium.com>
  Returns a pointer to the bitmask of CPUs on Node 'node'.
  Allocate node_to_cpumask_map based on number of available nodes
  Requires node_possible_map to be valid.
  Note: cpumask_of_node() is not valid until after this is done.
  (Use CONFIG_DEBUG_PER_CPU_MAPS to check this.)
 setup nr_node_ids if not done yet 
 allocate and clear the mapping 
 cpumask_of_node() will now work 
  Set the cpu to node and mem mapping
 fallback to node 0 
	
	  We should set the numa node of cpu0 as soon as possible, because it
	  has already been set up online before. cpu_to_node(0) will soon be
	  called.
		
		  Always reserve area for module percpu variables.  That's
		  what the legacy allocator did.
  numa_add_memblk() - Set node id to memblk
  @nid: NUMA node ID of the new memblk
  @start: Start address of the new memblk
  @end:  End address of the new memblk
  RETURNS:
  0 on success, -errno on failure.
  Initialize NODE_DATA for a node on the local memory
 report and initialize 
  numa_free_distance
  The current table is freed.
  Create a new NUMA distance table.
 fill with the default distances 
  numa_set_distance() - Set inter node NUMA distance from node to node.
  @from: the 'from' node to set distance
  @to: the 'to'  node to set distance
  @distance: NUMA distance
  Set the distance from node @from to @to to @distance.
  If distance table doesn't exist, a warning is printed.
  If @from or @to is higher than the highest known node or lower than zero
  or @distance doesn't make sense, the call is ignored.
  Return NUMA distance @from to @to
 Check that valid nid is set to memblks 
 Finally register nodes. 
 Setup online nodes to actual nodes
  dummy_numa_init() - Fallback dummy NUMA init
  Used if there's no underlying NUMA architecture, NUMA initialization
  fails, or NUMA is disabled on the command line.
  Must online at least one node (node 0) and add memory blocks that cover all
  allowed memory. It is unlikely that this function fails.
  Return: 0 on success, -errno on failure.
 Forced off on command line. 
  arch_numa_init() - Initialize NUMA
  Try each configured NUMA initialization method until one succeeds. The
  last fallback is dummy single node config encompassing whole memory.
 SPDX-License-Identifier: GPL-2.0
  System bus type for containers.
  Copyright (C) 2013, Intel Corporation
  Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
 SPDX-License-Identifier: GPL-2.0
  CPU subsystem support
 ACPI style match is the only one that may succeed. 
	
	  When hot adding memory to memoryless node and enabling a cpu
	  on the node, node number of the cpu may internally change.
 CONFIG_ARCH_CPU_PROBE_RELEASE 
 CONFIG_HOTPLUG_CPU 
	
	  Might be reading other cpu's data based on which cpu read thread
	  has been scheduled. But cpu data (memory) is allocated once during
	  boot up and this data does not change there after. Hence this
	  operation should be safe. No locking required.
  Print cpu online, possible, present, and system maps
 Keep in sync with cpu_subsys_attrs 
  Print values for NR_CPUS and offlined cpus
 arch-optional setting to enable display of offline cpus >= nr_cpu_ids 
 display offline cpus < nr_cpu_ids 
 display offline cpus >= nr_cpu_ids 
	
	  This is an empty function to prevent the driver core from spitting a
	  warning at us.  Yes, I know this is directly opposite of what the
	  documentation for the driver core and kobjects say, and the author
	  of this code has already been publically ridiculed for doing
	  something as foolish as this.  However, at this point in time, it is
	  the only way to handle the issue of statically allocated cpu
	  devices.  The different architectures will have their cpu device
	  code reworked to properly handle this in the near future, so this
	  function will then be changed to correctly free up the memory held
	  by the cpu device.
	 
	  Never copy this way of doing things, or you too will be made fun of
	  on the linux-kernel list, you have been warned.
  register_cpu - Setup a sysfs device for a CPU.
  @cpu - cpu->hotpluggable field set to 1 will generate a control file in
 	  sysfs for this CPU.
  @num - CPU number to use when creating the device.
  Initialize and register the CPU device.
 SPDX-License-Identifier: GPL-2.0
  class.c - basic device class management
  Copyright (c) 2002-3 Patrick Mochel
  Copyright (c) 2002-3 Open Source Development Labs
  Copyright (c) 2003-2004 Greg Kroah-Hartman
  Copyright (c) 2003-2004 IBM Corp.
 Hotplug events for classes go to the class subsys 
 set the default sysdev directory for devices of this class 
 let the block class directory show up in the root of sysfs 
  __class_create - create a struct class structure
  @owner: pointer to the module that is to "own" this struct class
  @name: pointer to a string for the name of this class.
  @key: the lock_class_key for this class; used by mutex lock debugging
  This is used to create a struct class pointer that can then be used
  in calls to device_create().
  Returns &struct class pointer on success, or ERR_PTR() on error.
  Note, the pointer created here is to be destroyed when finished by
  making a call to class_destroy().
  class_destroy - destroys a struct class structure
  @cls: pointer to the struct class that is to be destroyed
  Note, the pointer to be destroyed must have been created with a call
  to class_create().
  class_dev_iter_init - initialize class device iterator
  @iter: class iterator to initialize
  @class: the class we wanna iterate over
  @start: the device to start iterating from, if any
  @type: device_type of the devices to iterate over, NULL for all
  Initialize class iterator @iter such that it iterates over devices
  of @class.  If @start is set, the list iteration will start there,
  otherwise if it is NULL, the iteration starts at the beginning of
  the list.
  class_dev_iter_next - iterate to the next device
  @iter: class iterator to proceed
  Proceed @iter to the next device and return it.  Returns NULL if
  iteration is complete.
  The returned device is referenced and won't be released till
  iterator is proceed to the next device or exited.  The caller is
  free to do whatever it wants to do with the device including
  calling back into class code.
  class_dev_iter_exit - finish iteration
  @iter: class iterator to finish
  Finish an iteration.  Always call this function after iteration is
  complete whether the iteration ran till the end or not.
  class_for_each_device - device iterator
  @class: the class we're iterating
  @start: the device to start with in the list, if any.
  @data: data for the callback
  @fn: function to be called for each device
  Iterate over @class's list of devices, and call @fn for each,
  passing it @data.  If @start is set, the list iteration will start
  there, otherwise if it is NULL, the iteration starts at the
  beginning of the list.
  We check the return of @fn each time. If it returns anything
  other than 0, we break out and return that value.
  @fn is allowed to do anything including calling back into class
  code.  There's no locking restriction.
  class_find_device - device iterator for locating a particular device
  @class: the class we're iterating
  @start: Device to begin with
  @data: data for the match function
  @match: function to check device
  This is similar to the class_for_each_dev() function above, but it
  returns a reference to a device that is 'found' for later use, as
  determined by the @match callback.
  The callback should return 0 if the device doesn't match and non-zero
  if it does.  If the callback returns non-zero, this function will
  return to the caller and not iterate over any more devices.
  Note, you will need to drop the reference with put_device() after use.
  @match is allowed to do anything including calling back into class
  code.  There's no locking restriction.
  class_compat_register - register a compatibility class
  @name: the name of the class
  Compatibility class are meant as a temporary user-space compatibility
  workaround when converting a family of class devices to a bus devices.
  class_compat_unregister - unregister a compatibility class
  @cls: the class to unregister
  class_compat_create_link - create a compatibility class device link to
 			      a bus device
  @cls: the compatibility class
  @dev: the target bus device
  @device_link: an optional device to which a "device" link should be created
	
	  Optionally add a "device" link (typically to the parent), as a
	  class device would have one and we want to provide as much
	  backwards compatibility as possible.
  class_compat_remove_link - remove a compatibility class device link to
 			      a bus device
  @cls: the compatibility class
  @dev: the target bus device
  @device_link: an optional device to which a "device" link was previously
  		 created
 SPDX-License-Identifier: GPL-2.0
  MSI framework for platform devices
  Copyright (C) 2015 ARM Limited, All Rights Reserved.
  Author: Marc Zyngier <marc.zyngier@arm.com>
  Internal data structure containing a (made up, but unique) devid
  and the callback to write the MSI message.
 The devid allocator 
  Convert an msi_desc to a globaly unique identifier (per-device
  devid + msi_desc position in the msi_list).
 Clean up the mess 
  platform_msi_create_irq_domain - Create a platform MSI interrupt domain
  @fwnode:		Optional fwnode of the interrupt controller
  @info:	MSI domain info
  @parent:	Parent irq domain
  Updates the domain and chip ops and creates a platform MSI
  interrupt domain.
  Returns:
  A domain pointer or NULL in case of failure.
	
	  Limit the number of interrupts to 2048 per device. Should we
	  need to bump this up, DEV_ID_SHIFT should be adjusted
	  accordingly (which would impact the max number of MSI
	  capable devices).
 Already had a helping of MSI? Greed... 
  platform_msi_domain_alloc_irqs - Allocate MSI interrupts for @dev
  @dev:		The device for which to allocate interrupts
  @nvec:		The number of interrupts to allocate
  @write_msi_msg:	Callback to write an interrupt message for @dev
  Returns:
  Zero for success, or an error code in case of failure
  platform_msi_domain_free_irqs - Free MSI interrupts for @dev
  @dev:	The device for which to free interrupts
  platform_msi_get_host_data - Query the private data associated with
                               a platform-msi domain
  @domain:	The platform-msi domain
  Returns the private data provided when calling
  platform_msi_create_device_domain.
  __platform_msi_create_device_domain - Create a platform-msi domain
  @dev:		The device generating the MSIs
  @nvec:		The number of MSIs that need to be allocated
  @is_tree:		flag to indicate tree hierarchy
  @write_msi_msg:	Callback to write an interrupt message for @dev
  @ops:		The hierarchy domain operations to use
  @host_data:		Private data associated to this domain
  Returns an irqdomain for @nvec interrupts
  platform_msi_domain_free - Free interrupts associated with a platform-msi
                             domain
  @domain:	The platform-msi domain
  @virq:	The base irq from which to perform the free operation
  @nvec:	How many interrupts to free from @virq
  platform_msi_domain_alloc - Allocate interrupts associated with
 			       a platform-msi domain
  @domain:	The platform-msi domain
  @virq:	The base irq from which to perform the allocate operation
  @nr_irqs:	How many interrupts to free from @virq
  Return 0 on success, or an error code on failure. Must be called
  with irq_domain_mutex held (which can only be done as part of a
  top-level interrupt allocation).
 SPDX-License-Identifier: GPL-2.0
  Arch specific cpu topology information
  Copyright (C) 2016, ARM Ltd.
  Written by: Juri Lelli, ARM Ltd.
	
	  Task scheduler behavior depends on frequency invariance support,
	  either cpufreq or counter driven. If the support status changes as
	  a result of counter initialisation and use, retrigger the build of
	  scheduling domains to ensure the information is propagated properly.
	
	  Avoid calling rebuild_sched_domains() unnecessarily if FIE is
	  supported by cpufreq.
 Use ARCH provided counters whenever possible 
	
	  Make sure all references to previous sft_data are dropped to avoid
	  use-after-free races.
	
	  If the use of counters for FIE is enabled, just return as we don't
	  want to update the scale factor with information from CPUFREQ.
	  Instead the scale factor will be updated from arch_scale_freq_tick.
  Updating the sched_domains can't be done directly from cpufreq callbacks
  due to locking, so queue the work for later.
		
		  Update freq_factor for calculating early boot cpu capacities.
		  For non-clk CPU DVFS mechanism, there's no way to get the
		  frequency value now, assuming they are running at the same
		  frequency (by keeping the initial freq_factor value).
	
	  on ACPI-based systems we need to use the default cpu capacity
	  until we have the necessary code to parse the cpu capacity, so
	  skip registering cpufreq notifier.
  This function returns the logic cpu number of the node.
  There are basically three kinds of return values:
  (1) logic cpu number which is > 0.
  (2) -ENODEV when the device tree(DT) node is valid and found in the DT but
  there is no possible logical CPU in the kernel to match. This happens
  when CONFIG_NR_CPUS is configure to be smaller than the number of
  CPU nodes in DT. We need to just ignore this case.
  (3) -1 if the node does not exist in the device tree
	
	  First check for child clusters; we currently ignore any
	  information about the nesting of clusters and present the
	  scheduler with a flat list of them.
 Now check for cores 
	
	  When topology is provided cpu-map is essentially a root
	  cluster with restricted subnodes.
	
	  Check that all cores are in the topology; the SMP code will
	  only mark cores described in the DT as possible.
  cpu topology table
 Find the smaller of NUMA, core or LLC siblings 
 not numa in package, lets use the package siblings 
 update core and thread sibling masks 
	
	  Discard anything that was parsed if we hit an error so we
	  don't use partial information.
 SPDX-License-Identifier: GPL-2.0+
  driverbasetopology.c - Populate sysfs with cpu topology information
  Written by: Zhang Yanmin, Intel Corporation
  Copyright (C) 2006, Intel Corp.
  All rights reserved.
 AddRemove cpu_topology interface for CPU device 
 SPDX-License-Identifier: GPL-2.0
  driversbasedd.c - The core devicedriver interactions.
  This file contains the (sometimes tricky) code that controls the
  interactions between devices and drivers, which primarily includes
  driver binding and unbinding.
  All of this code used to exist in driversbasebus.c, but was
  relocated to here in the name of compartmentalization (since it wasn't
  strictly code just for the 'struct bus_type'.
  Copyright (c) 2002-5 Patrick Mochel
  Copyright (c) 2002-3 Open Source Development Labs
  Copyright (c) 2007-2009 Greg Kroah-Hartman <gregkh@suse.de>
  Copyright (c) 2007-2009 Novell Inc.
  Deferred Probe infrastructure.
  Sometimes driver probe order matters, but the kernel doesn't always have
  dependency information which means some drivers will get probed before a
  resource it depends on is available.  For example, an SDHCI driver may
  first need a GPIO line from an i2c GPIO controller before it can be
  initialized.  If a required resource is not available yet, a driver can
  request probing to be deferred by returning -EPROBE_DEFER from its probe hook
  Deferred probe maintains two lists of devices, a pending list and an active
  list.  A driver returning -EPROBE_DEFER causes the device to be added to the
  pending list.  A successful driver probe will trigger moving all devices
  from the pending to the active list so that the workqueue will eventually
  retry them.
  The deferred_probe_mutex must be held any time the deferred_probe__list
  of the (struct device)->p->deferred_probe pointers are manipulated
 Save the async probe drivers' name from kernel cmdline 
  In some cases, like suspend to RAM or hibernation, It might be reasonable
  to prohibit probing of devices as it could be unsafe.
  Once defer_all_probes is true all drivers probes will be forcibly deferred.
  deferred_probe_work_func() - Retry probing devices in the active list.
	
	  This block processes every device in the deferred 'active' list.
	  Each device is removed from the active list and passed to
	  bus_probe_device() to re-attempt the probe.  The loop continues
	  until every device in the active list is removed and retried.
	 
	  Note: Once the device is removed from the list and the mutex is
	  released, it is possible for the device get freed by another thread
	  and cause a illegal pointer dereference.  This code uses
	  getput_device() to ensure the device structure cannot disappear
	  from under our feet.
		
		  Drop the mutex while probing each device; the probe path may
		  manipulate the deferred list
		
		  Force the device to the end of the dpm_list since
		  the PM code assumes that the order we add things to
		  the list is a good order for suspend but deferred
		  probe makes that very unsafe.
  driver_deferred_probe_trigger() - Kick off re-probing deferred devices
  This functions moves all devices from the pending list to the active
  list and schedules the deferred probe workqueue to process them.  It
  should be called anytime a driver is successfully bound to a device.
  Note, there is a race condition in multi-threaded probe. In the case where
  more than one device is probing at the same time, it is possible for one
  probe to complete successfully while another is about to defer. If the second
  depends on the first, then it will get put on the pending list after the
  trigger event has already occurred and will be stuck there.
  The atomic 'deferred_trigger_count' is used to determine if a successful
  trigger has occurred in the midst of probing a driver. If the trigger count
  changes in the midst of a probe, then deferred processing should be triggered
  again.
	
	  A successful probe means that all the devices in the pending list
	  should be triggered to be reprobed.  Move all the deferred devices
	  into the active list so they can be retried by the workqueue
	
	  Kick the re-probe thread.  It may already be scheduled, but it is
	  safe to kick it again.
  device_block_probing() - Blockdefer device's probes
 	It will disable probing of devices and defer their probes instead.
 sync with probes to avoid races. 
  device_unblock_probing() - Unblockenable device's probes
 	It will restore normal behavior and trigger re-probing of deferred
  devices.
  device_set_deferred_probe_reason() - Set defer probe reason message for device
  @dev: the pointer to the struct device
  @vaf: the pointer to va_format structure with message
  deferred_devs_show() - Show the devices in the deferred probe pending list.
  driver_deferred_probe_check_state() - Check deferred probe state
  @dev: device to check
  Return:
  -ENODEV if initcalls have completed and modules are disabled.
  -ETIMEDOUT if the deferred probe timeout was set and has expired
   and modules are enabled.
  -EPROBE_DEFER in other cases.
  Drivers or subsystems can opt-in to calling this function instead of directly
  returning -EPROBE_DEFER.
  deferred_probe_initcall() - Enable probing of deferred devices
  We don't want to get in the way when the bulk of drivers are getting probed.
  Instead, this initcall makes sure that deferred probing is delayed until
  late_initcall time.
 Sort as many dependencies as possible before exiting initcalls 
	
	  Trigger deferred probe again, this time we won't defer anything
	  that is optional
  device_is_bound() - Check if device is bound to a driver
  @dev: device to check
  Returns true if passed device has already finished probing successfully
  against a driver.
  This function must be called with the device lock held.
	
	  Make sure the device is no longer in one of the deferred lists and
	  kick off retrying all pending devices
  device_bind_driver - bind a driver to one device.
  @dev: device.
  Allow manual attachment of a driver to a device.
  Caller must have already set @dev->driver.
  Note that this does not modify the bus reference count.
  Please verify that is accounted for before calling this.
  (It is ok to call with no other effort from a driver's probe() method.)
  This function must be called with the device lock held.
  Callers should prefer to use device_driver_attach() instead.
 Driver requested deferred probing 
 driver matched but the probe failed 
		
		  Value of defer_all_probes can be set only by
		  device_block_probing() which, in turn, will call
		  wait_for_device_probe() right after that to avoid any races.
 If using pinctrl, bind pins now before probing 
		
		  Return probe errors as positive values so that the callers
		  can distinguish them from other errors.
  For initcall_debug, show the driver probe time.
  driver_probe_done
  Determine if the probe sequence is finished or not.
  Should somehow figure out how to use a semaphore, not an atomic variable...
  wait_for_device_probe
  Wait for device probing to be completed.
 wait for probe timeout 
 wait for the deferred probe workqueue to finish 
 wait for the known devices to complete their probing 
  driver_probe_device - attempt to bind device & driver together
  @drv: driver to bind a device to
  @dev: device to try to bind to the driver
  This function returns -ENODEV if the device is not registered, -EBUSY if it
  already has a driver, 0 if the device is bound successfully and a positive
  (inverted) error code for failures from the ->probe method.
  This function must be called with @dev lock held.  When called for a
  USB interface, @dev->parent lock must be held as well.
  If the device has a parent, runtime-resume the parent before driver probing.
		
		  Did a trigger occur while probing? Need to re-trigger if yes
 The option format is "driver_async_probe=drv_name1,drv_name2,..." 
	
	  Indicates whether we are are considering asynchronous probing or
	  not. Only initial binding after device or driver registration
	  (including deferral processing) may be done asynchronously, the
	  rest is always synchronous, as we expect it is being done by
	  request from userspace.
	
	  Indicates if we are binding synchronous or asynchronous drivers.
	  When asynchronous probing is enabled we'll execute 2 passes
	  over drivers: first pass doing synchronous probing and second
	  doing asynchronous probing (if synchronous did not succeed -
	  most likely because there was no driver requiring synchronous
	  probing - and we found asynchronous driver during first pass).
	  The 2 passes are done because we can't shoot asynchronous
	  probe for given device and driver from bus_for_each_drv() since
	  driver pointer is not guaranteed to stay valid once
	  bus_for_each_drv() iterates to the next driver on the bus.
	
	  We'll set have_async to 'true' if, while scanning for matching
	  driver, we'll encounter one that requests asynchronous probing.
 no match 
 ret > 0 means positive match 
	
	  Ignore errors returned by ->probe so that the next driver can try
	  its luck.
	
	  Check if device has already been removed or claimed. This may
	  happen with driver loading, device discoveryregistration,
	  and deferred probe processing happens all at once with
	  multiple threads.
			
			  If we could not find appropriate driver
			  synchronously and we are allowed to do
			  async probes and there are drivers that
			  want to probe asynchronously, we'll
			  try them.
  device_attach - try to attach device to a driver.
  @dev: device.
  Walk the list of drivers that the bus has and call
  driver_probe_device() for each pair. If a compatible
  pair is found, break out and return.
  Returns 1 if the device was bound to a driver;
  0 if no matching driver was found;
  -ENODEV if the device is not registered.
  When called for a USB interface, @dev->parent lock must be held.
  __device_driver_lock - acquire locks needed to manipulate dev->drv
  @dev: Device we will update driver info for
  @parent: Parent device. Needed if the bus requires parent lock
  This function will take the required locks for manipulating dev->drv.
  Normally this will just be the @dev lock, but when called for a USB
  interface, @parent lock will be held as well.
  __device_driver_unlock - release locks needed to manipulate dev->drv
  @dev: Device we will update driver info for
  @parent: Parent device. Needed if the bus requires parent lock
  This function will release the required locks for manipulating dev->drv.
  Normally this will just be the the @dev lock, but when called for a
  USB interface, @parent lock will be released as well.
  device_driver_attach - attach a specific driver to a specific device
  @drv: Driver to attach
  @dev: Device to attach it to
  Manually attach driver to a device. Will acquire both @dev lock and
  @dev->parent lock if needed. Returns 0 on success, -ERR on failure.
 also return probe errors as normal negative errnos 
	
	  Lock device and try to bind to it. We drop the error
	  here and always return 0, because we need to keep trying
	  to bind to devices and some drivers will return an error
	  simply if it didn't support the device.
	 
	  driver_probe_device() will spit a warning if there
	  is an error.
 no match 
 ret > 0 means positive match 
		
		  Instead of probing the device synchronously we will
		  probe it asynchronously to allow for more parallelism.
		 
		  We only take the device lock here in order to guarantee
		  that the dev->driver and async_driver fields are protected
  driver_attach - try to bind driver to devices.
  @drv: driver.
  Walk the list of devices that the bus has on it and try to
  match the driver with each one.  If driver_probe_device()
  returns 0 and the @dev->driver is set, we've found a
  compatible pair.
  __device_release_driver() must be called with @dev lock held.
  When called for a USB interface, @dev->parent lock must be held as well.
			
			  A concurrent invocation of the same function might
			  have released the driver successfully while this one
			  was waiting, so check for that.
  device_release_driver - manually detach device from driver.
  @dev: device.
  Manually detach device from driver.
  When called for a USB interface, @dev->parent lock must be held.
  If this function is to be called with @dev->parent lock held, ensure that
  the device's consumers are unbound in advance or that their locks can be
  acquired under the @dev->parent lock.
	
	  If anyone calls device_release_driver() recursively from
	  within their ->remove callback for the same device, they
	  will deadlock right here.
  device_driver_detach - detach driver from a specific device
  @dev: device to detach driver from
  Detach driver from device. Will acquire both @dev lock and @dev->parent
  lock if needed.
  driver_detach - detach driver from all devices it controls.
  @drv: driver.
 SPDX-License-Identifier: GPL-2.0
  attribute_container.c - implementation of a simple container for classes
  Copyright (c) 2005 - James Bottomley <James.Bottomley@steeleye.com>
  The basic idea here is to enable a device to be attached to an
  aritrary numer of classes without having to allocate storage for them.
  Instead, the contained classes select the devices they need to attach
  to via a matching function.
 This is a private structure used to tie the classdev and the
  attribute_container_classdev_to_container - given a classdev, return the container
  @classdev: the class device created by attribute_container_add_device.
  Returns the container associated with this classdev.
  attribute_container_register - register an attribute container
  @cont: The container to register.  This must be allocated by the
         callee and should also be zeroed by it.
  attribute_container_unregister - remove a container registration
  @cont: previously registered container to remove
 private function used as class release 
  attribute_container_add_device - see if any container is interested in dev
  @dev: device to add attributes to
  @fn:	 function to trigger addition of class device.
  This function allocates storage for the class device(s) to be
  attached to dev (one for each matching attribute_container).  If no
  fn is provided, the code will simply register the class device via
  device_add.  If a function is provided, it is expected to add
  the class device at the appropriate time.  One of the things that
  might be necessary is to allocate and initialise the classdev and
  then add it a later time.  To do this, call this routine for
  allocation and initialisation and then use
  attribute_container_device_trigger() to call device_add() on
  it.  Note: after this, the class device contains a reference to dev
  which is not relinquished until the release of the classdev.
 FIXME: can't break out of this unless klist_iter_exit is also
  called before doing the break
  attribute_container_remove_device - make device eligible for removal.
  @dev:  The generic device
  @fn:	  A function to call to remove the device
  This routine triggers device removal.  If fn is NULL, then it is
  simply done via device_unregister (note that if something
  still has a reference to the classdev, then the memory occupied
  will not be freed until the classdev is released).  If you want a
  two phase release: remove from visibility and then delete the
  device, then you should use this routine with a fn that calls
  device_del() and then use attribute_container_device_trigger()
  to do the final put on the classdev.
 Attempt to undo the work partially done. 
  attribute_container_device_trigger_safe - execute a trigger for each
  matching classdev or fail all of them.
  @dev:  The generic device to run the trigger for
  @fn:   the function to execute for each classdev.
  @undo: A function to undo the work previously done in case of error
  This function is a safe version of
  attribute_container_device_trigger. It stops on the first error and
  undo the partial work that has been done, on previous classdev.  It
  is guaranteed that either they all succeeded, or none of them
  succeeded.
  attribute_container_device_trigger - execute a trigger for each matching classdev
  @dev:  The generic device to run the trigger for
  @fn:   the function to execute for each classdev.
  This function is for executing a trigger when you need to know both
  the container and the classdev.  If you only care about the
  container, then use attribute_container_trigger() instead.
  attribute_container_trigger - trigger a function for each matching container
  @dev:  The generic device to activate the trigger for
  @fn:	  the function to trigger
  This routine triggers a function that only needs to know the
  matching containers (not the classdev) associated with a device.
  It is more lightweight than attribute_container_device_trigger, so
  should be used in preference unless the triggering function
  actually needs to know the classdev.
  attribute_container_add_attrs - add attributes
  @classdev: The class device
  This simply creates all the class device sysfs files from the
  attributes listed in the container
  attribute_container_add_class_device - same function as device_add
  @classdev:	the class device to add
  This performs essentially the same function as device_add except for
  attribute containers, namely add the classdev to the system and then
  create the attribute files
  attribute_container_add_class_device_adapter - simple adapter for triggers
  @cont: the container to register.
  @dev:  the generic device to activate the trigger for
  @classdev:	the class device to add
  This function is identical to attribute_container_add_class_device except
  that it is designed to be called from the triggers
  attribute_container_remove_attrs - remove any attribute files
  @classdev: The class device to remove the files from
  attribute_container_class_device_del - equivalent of class_device_del
  @classdev: the class device
  This function simply removes all the attribute files and then calls
  device_del.
  attribute_container_find_class_device - find the corresponding class_device
  @cont:	the container
  @dev:	the generic device
  Looks up the device in the container's list of class devices and returns
  the corresponding class_device.
 FIXME: must exit iterator then break 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2002-3 Patrick Mochel
  Copyright (c) 2002-3 Open Source Development Labs
  driver_init - initialize driver model.
  Call the driver model init functions to initialize their
  subsystems. Called early from initmain.c.
 These are the core pieces 
	 These are also core pieces, but must come after the
	  core core pieces.
 SPDX-License-Identifier: GPL-2.0
  devtmpfs - kernel-maintained tmpfs-based dev
  Copyright (C) 2009, Kay Sievers <kay.sievers@vrfy.org>
  During bootup, before any driver core device is registered,
  devtmpfs, a tmpfs-based filesystem is created. Every driver-core
  device which requests a device node, will add a node in this
  filesystem.
  By default, all devices are named after the name of the device,
  owned by root and have a default mode of 0600. Subsystems can
  overwrite the default setting if needed.
 0 => delete 
 mark as kernel-created inode 
 parent directories do not exist, create them 
 mark as kernel-created inode 
 did we create it 
 does the dev_t match 
 ours 
			
			  before unlinking this node, reset permissions
			  of possible references like hardlinks
  If configured, or requested by the commandline, devtmpfs will be
  auto-mounted after the kernel mounted the root filesystem.
 will traverse into overmounted root 
  The __ref is because devtmpfs_setup needs to be __init for the routines it
  calls.  That call is done while devtmpfs_init, which is marked __init,
  synchronously waits for it to complete.
  Create devtmpfs instance, driver-core devices will add their device
  nodes here.
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2014 Intel Mobile Communications GmbH
  Copyright(c) 2015 Intel Deutschland GmbH
  Author: Johannes Berg <johannes@sipsolutions.net>
 global disable flag, for security purposes 
 if data isn't read by userspace after 5 minutes then delete it 
	
	  this seems racy, but I don't see a notifier or such on
	  a struct device to know when it goes away?
	
	  This essentially makes the attribute write-once, since you can't
	  go back to not having it disabled. This is intentional, it serves
	  as a system lockdown feature.
  dev_coredumpv - create device coredump with vmalloc data
  @dev: the struct device for the crashed device
  @data: vmalloc data containing the device coredump
  @datalen: length of the data
  @gfp: allocation flags
  This function takes ownership of the vmalloc'ed data and will free
  it when it is no longer used. See dev_coredumpm() for more information.
  devcd_free_sgtable - free all the memory of the given scatterlist table
  (i.e. both pages and scatterlist instances)
  NOTE: if two tables allocated with devcd_alloc_sgtable and then chained
  using the sg_chain function then that function should be called only once
  on the chained table
  @data: pointer to sg_table to free
  devcd_read_from_sgtable - copy data from sg_table to a given buffer
  and return the number of bytes read
  @buffer: the buffer to copy the data to it
  @buf_len: the length of the buffer
  @data: the scatterlist table to copy from
  @offset: start copy from @offset@ bytes from the head of the data
 	in the given scatterlist
  @data_len: the length of the data in the sg_table
  dev_coredumpm - create device coredump with readfree methods
  @dev: the struct device for the crashed device
  @owner: the module that contains the readfree functions, use %THIS_MODULE
  @data: data cookie for the @read@free functions
  @datalen: length of the data
  @gfp: allocation flags
  @read: function to read from the given buffer
  @free: function to free the given buffer
  Creates a new device coredump for the given device. If a previous one hasn't
  been read yet, the new coredump is discarded. The data lifetime is determined
  by the device coredump framework and when it is no longer needed the @free
  function will be called to free the data.
	
	  These should normally not fail, but there is no problem
	  continuing without the links, so just warn instead of
	  failing.
  dev_coredumpsg - create device coredump that uses scatterlist as data
  parameter
  @dev: the struct device for the crashed device
  @table: the dump data
  @datalen: length of the data
  @gfp: allocation flags
  Creates a new device coredump for the given device. If a previous one hasn't
  been read yet, the new coredump is discarded. The data lifetime is determined
  by the device coredump framework and when it is no longer needed
  it will free the data.
 SPDX-License-Identifier: GPL-2.0
  firmware.c - firmware subsystem hoohaw.
  Copyright (c) 2002-3 Patrick Mochel
  Copyright (c) 2002-3 Open Source Development Labs
  Copyright (c) 2007 Greg Kroah-Hartman <gregkh@suse.de>
  Copyright (c) 2007 Novell Inc.
 SPDX-License-Identifier: GPL-2.0
  platform.c - platform 'pseudo' bus for legacy devices
  Copyright (c) 2002-3 Patrick Mochel
  Copyright (c) 2002-3 Open Source Development Labs
  Please see Documentationdriver-apidriver-modelplatform.rst for more
  information.
 For automatically allocated device IDs 
  platform_get_resource - get a resource for a device
  @dev: platform device
  @type: resource type
  @num: resource index
  Return: a pointer to the resource or NULL on failure.
  devm_platform_get_and_ioremap_resource - call devm_ioremap_resource() for a
 					    platform device and get resource
  @pdev: platform device to use both for memory resource lookup as well as
         resource management
  @index: resource index
  @res: optional output parameter to store a pointer to the obtained resource.
  Return: a pointer to the remapped memory or an ERR_PTR() encoded error code
  on failure.
  devm_platform_ioremap_resource - call devm_ioremap_resource() for a platform
 				    device
  @pdev: platform device to use both for memory resource lookup as well as
         resource management
  @index: resource index
  Return: a pointer to the remapped memory or an ERR_PTR() encoded error code
  on failure.
  devm_platform_ioremap_resource_byname - call devm_ioremap_resource for
 					   a platform device, retrieve the
 					   resource by name
  @pdev: platform device to use both for memory resource lookup as well as
 	  resource management
  @name: name of the resource
  Return: a pointer to the remapped memory or an ERR_PTR() encoded error code
  on failure.
 CONFIG_HAS_IOMEM 
  platform_get_irq_optional - get an optional IRQ for a device
  @dev: platform device
  @num: IRQ number index
  Gets an IRQ for a platform device. Device drivers should check the return
  value for errors so as to not pass a negative integer value to the
  request_irq() APIs. This is the same as platform_get_irq(), except that it
  does not print an error message if an IRQ can not be obtained.
  For example::
 		int irq = platform_get_irq_optional(pdev, 0);
 		if (irq < 0)
 			return irq;
  Return: non-zero IRQ number on success, negative error number on failure.
 sparc does not have irqs represented as IORESOURCE_IRQ resources 
	
	  The resources may pass trigger flags to the irqs that need
	  to be set up. It so happens that the trigger flags for
	  IORESOURCE_BITS correspond 1-to-1 to the IRQF_TRIGGER
	  settings.
	
	  For the index 0 interrupt, allow falling back to GpioInt
	  resources. While a device could have both Interrupt and GpioInt
	  resources, making this fallback ambiguous, in many common cases
	  the device will only expose one IRQ, and this fallback
	  allows a common code path across either kind of resource.
 Our callers expect -ENXIO for missing IRQs. 
  platform_get_irq - get an IRQ for a device
  @dev: platform device
  @num: IRQ number index
  Gets an IRQ for a platform device and prints an error message if finding the
  IRQ fails. Device drivers should check the return value for errors so as to
  not pass a negative integer value to the request_irq() APIs.
  For example::
 		int irq = platform_get_irq(pdev, 0);
 		if (irq < 0)
 			return irq;
  Return: non-zero IRQ number on success, negative error number on failure.
  platform_irq_count - Count the number of IRQs a platform device uses
  @dev: platform device
  Return: Number of IRQs a platform device uses or EPROBE_DEFER
  devm_platform_get_irqs_affinity - devm method to get a set of IRQs for a
 				device using an interrupt affinity descriptor
  @dev: platform device pointer
  @affd: affinity descriptor
  @minvec: minimum count of interrupt vectors
  @maxvec: maximum count of interrupt vectors
  @irqs: pointer holder for IRQ numbers
  Gets a set of IRQs for a platform device, and updates IRQ afffinty according
  to the passed affinity descriptor
  Return: Number of vectors on success, negative error number on failure.
  platform_get_resource_byname - get a resource for a device by name
  @dev: platform device
  @type: resource type
  @name: resource name
  platform_get_irq_byname - get an IRQ for a device by name
  @dev: platform device
  @name: IRQ name
  Get an IRQ like platform_get_irq(), but then by name rather then by index.
  Return: non-zero IRQ number on success, negative error number on failure.
  platform_get_irq_byname_optional - get an optional IRQ for a device by name
  @dev: platform device
  @name: IRQ name
  Get an optional IRQ by name like platform_get_irq_byname(). Except that it
  does not print an error message if an IRQ can not be obtained.
  Return: non-zero IRQ number on success, negative error number on failure.
  platform_add_devices - add a numbers of platform devices
  @devs: array of platform devices to add
  @num: number of platform devices in array
  Set up default DMA mask for platform devices if the they weren't
  previously set by the architecture  DT.
  platform_device_put - destroy a platform device
  @pdev: platform device to free
  Free all memory associated with a platform device.  This function must
  _only_ be externally called in error cases.  All other usage is a bug.
  platform_device_alloc - create a platform device
  @name: base name of the device we're adding
  @id: instance id
  Create a platform device object which can have other objects attached
  to it, and which will have attached objects freed when it is released.
  platform_device_add_resources - add resources to a platform device
  @pdev: platform device allocated by platform_device_alloc to add resources to
  @res: set of resources that needs to be allocated for the device
  @num: number of resources
  Add a copy of the resources to the platform device.  The memory
  associated with the resources will be freed when the platform device is
  released.
  platform_device_add_data - add platform-specific data to a platform device
  @pdev: platform device allocated by platform_device_alloc to add resources to
  @data: platform specific data for this platform device
  @size: size of platform specific data
  Add a copy of platform specific data to the platform device's
  platform_data pointer.  The memory associated with the platform data
  will be freed when the platform device is released.
  platform_device_add - add a platform device to device hierarchy
  @pdev: platform device we're adding
  This is part 2 of platform_device_register(), though may be called
  separately _iff_ pdev was allocated by platform_device_alloc().
		
		  Automatically allocated device ID. We mark it as such so
		  that we remember it must be freed, and we append a suffix
		  to avoid namespace collision with explicit IDs.
  platform_device_del - remove a platform-level device
  @pdev: platform device we're removing
  Note that this function will also release all memory- and port-based
  resources owned by the device (@dev->resource).  This function must
  _only_ be externally called in error cases.  All other usage is a bug.
  platform_device_register - add a platform-level device
  @pdev: platform device we're adding
  platform_device_unregister - unregister a platform-level device
  @pdev: platform device we're unregistering
  Unregistration is done in 2 steps. First we release all resources
  and remove it from the subsystem, then we drop reference count by
  calling platform_device_put().
  platform_device_register_full - add a platform-level device with
  resources and platform-specific data
  @pdevinfo: data used to create device
  Returns &struct platform_device pointer on success, or ERR_PTR() on error.
  __platform_driver_register - register a driver for platform-level devices
  @drv: platform driver structure
  @owner: owning moduledriver
  platform_driver_unregister - unregister a driver for platform-level devices
  @drv: platform driver structure
  __platform_driver_probe - register driver for non-hotpluggable device
  @drv: platform driver structure
  @probe: the driver probe routine, probably from an __init section
  @module: module which will be the owner of the driver
  Use this instead of platform_driver_register() when you know the device
  is not hotpluggable and has already been registered, and you want to
  remove its run-once probe() infrastructure from memory after the driver
  has bound to the device.
  One typical use for this would be with drivers for controllers integrated
  into system-on-chip processors, where the controller devices have been
  configured as part of board setup.
  Note that this is incompatible with deferred probing.
  Returns zero if the driver registered and bound to a device, else returns
  a negative error code and with the driver not registered.
	
	  We have to run our probes synchronously because we check if
	  we find any devices to bind to and exit with error if there
	  are any.
	
	  Prevent driver from requesting probe deferral to avoid further
	  futile probe attempts.
 make sure driver won't have bindunbind attributes 
 temporary section violation during probe() 
	
	  Fixup that section violation, being paranoid about code scanning
	  the list of drivers in order to probe new devices.  Check to see
	  if the probe was successful, and make sure any forced probes of
	  new devices fail.
  __platform_create_bundle - register driver and create corresponding device
  @driver: platform driver structure
  @probe: the driver probe routine, probably from an __init section
  @res: set of resources that needs to be allocated for the device
  @n_res: number of resources
  @data: platform specific data for this platform device
  @size: size of platform specific data
  @module: module which will be the owner of the driver
  Use this in legacy-style modules that probe hardware directly and
  register a single platform device and corresponding platform driver.
  Returns &struct platform_device pointer on success, or ERR_PTR() on error.
  __platform_register_drivers - register an array of platform drivers
  @drivers: an array of drivers to register
  @count: the number of drivers to register
  @owner: module owning the drivers
  Registers platform drivers specified by an array. On failure to register a
  driver, all previously registered drivers will be unregistered. Callers of
  this API should use platform_unregister_drivers() to unregister drivers in
  the reverse order.
  Returns: 0 on success or a negative error code on failure.
  platform_unregister_drivers - unregister an array of platform drivers
  @drivers: an array of drivers to unregister
  @count: the number of drivers to unregister
  Unregisters platform drivers specified by an array. This is typically used
  to complement an earlier call to platform_register_drivers(). Drivers are
  unregistered in the reverse order in which they were registered.
 CONFIG_PM_SLEEP 
 CONFIG_SUSPEND 
 CONFIG_HIBERNATE_CALLBACKS 
 modalias support enables more hands-off userspace setup:
  (a) environment variable lets new-style hotplug events work once system is
      fully running:  "modprobe $MODALIAS"
  (b) sysfs attribute lets new-style coldplug recover from hotplug events
      mishandled before system is fully running:  "modprobe $(cat modalias)"
 We need to keep extra room for a newline 
  platform_match - bind platform device to platform driver.
  @dev: device.
  @drv: driver.
  Platform device IDs are assumed to be encoded like this:
  "<name><instance>", where <name> is a short description of the type of
  device, like "pci" or "floppy", and <instance> is the enumerated
  instance of the device, like '0' or '42'.  Driver IDs are simply
  "<name>".  So, extract the <name> from the platform_device structure,
  and compare it against the name of the driver. Return whether they match
  or not.
 When driver_override is set, only bind to the matching driver 
 Attempt an OF style match first 
 Then try ACPI style match 
 Then try to match against the id table 
 fall-back to driver name match 
 Some devices have extra OF data and an OF-style MODALIAS 
	
	  A driver registered using platform_driver_probe() cannot be bound
	  again later because the probe function usually lives in __init code
	  and so is gone. For these drivers .probe is set to
	  platform_probe_fail in __platform_driver_probe(). Don't even prepare
	  clocks and PM domains for these to match the traditional behaviour.
  platform_find_device_by_driver - Find a platform device with a given
  driver.
  @start: The device to start the search from.
  @drv: The device driver to look for.
 SPDX-License-Identifier: GPL-2.0
  driversbasecore.c - core driver model code (device registration, etc)
  Copyright (c) 2002-3 Patrick Mochel
  Copyright (c) 2002-3 Open Source Development Labs
  Copyright (c) 2006 Greg Kroah-Hartman <gregkh@suse.de>
  Copyright (c) 2006 Novell, Inc.
 for dma_default_coherent 
 Device links support. 
  fwnode_link_add - Create a link between two fwnode_handles.
  @con: Consumer end of the link.
  @sup: Supplier end of the link.
  Create a fwnode link between fwnode handles @con and @sup. The fwnode link
  represents the detail that the firmware lists @sup fwnode as supplying a
  resource to @con.
  The driver core will use the fwnode link to create a device link between the
  two device objects corresponding to @con and @sup when they are created. The
  driver core will automatically delete the fwnode link between @con and @sup
  after doing that.
  Attempts to create duplicate links between the same pair of fwnode handles
  are ignored and there is no reference counting.
  __fwnode_link_del - Delete a link between two fwnode_handles.
  @link: the fwnode_link to be deleted
  The fwnode_link_lock needs to be held when this function is called.
  fwnode_links_purge_suppliers - Delete all supplier links of fwnode_handle.
  @fwnode: fwnode whose supplier links need to be deleted
  Deletes all supplier links connecting directly to @fwnode.
  fwnode_links_purge_consumers - Delete all consumer links of fwnode_handle.
  @fwnode: fwnode whose consumer links need to be deleted
  Deletes all consumer links connecting directly to @fwnode.
  fwnode_links_purge - Delete all links connected to a fwnode_handle.
  @fwnode: fwnode whose links needs to be deleted
  Deletes all links connecting directly to a fwnode.
 Don't purge consumer links of an added child 
 !CONFIG_SRCU 
 !CONFIG_SRCU 
  device_is_dependent - Check if one device depends on another one
  @dev: Device to check dependencies for.
  @target: Device to check against.
  Check if @target depends on @dev or any device dependent on it (its child or
  its consumer etc).  Return 1 if that is the case or 0 otherwise.
	
	  The "ancestors" check is needed to catch the case when the target
	  device has not been completely initialized yet and it is still
	  missing from the list of children of its parent device.
			
			  A consumer driver can create a link to a supplier
			  that has not completed its probing yet as long as it
			  knows that the supplier is already functional (for
			  example, it has just acquired some resources from the
			  supplier).
	
	  Devices that have not been registered yet will be put to the ends
	  of the lists during the registration, so skip them here.
  device_pm_move_to_tail - Move set of devices to the end of device lists
  @dev: Device to move
  This is a device_reorder_to_tail() wrapper taking the requisite locks.
  It moves the @dev along with all of its children and all of its consumers
  to the ends of the device_kset and dpm_list, recursively.
 Ensure that all references to the link object have been dropped. 
	
	  It may take a while to complete this work because of the SRCU
	  synchronization in device_link_release_fn() and if the consumer or
	  supplier devices get deleted when it runs, so put it into the "long"
	  workqueue.
  device_link_add - Create a link between two devices.
  @consumer: Consumer end of the link.
  @supplier: Supplier end of the link.
  @flags: Link flags.
  The caller is responsible for the proper synchronization of the link creation
  with runtime PM.  First, setting the DL_FLAG_PM_RUNTIME flag will cause the
  runtime PM framework to take the link into account.  Second, if the
  DL_FLAG_RPM_ACTIVE flag is set in addition to it, the supplier devices will
  be forced into the active meta state and reference-counted upon the creation
  of the link.  If DL_FLAG_PM_RUNTIME is not set, DL_FLAG_RPM_ACTIVE will be
  ignored.
  If DL_FLAG_STATELESS is set in @flags, the caller of this function is
  expected to release the link returned by it directly with the help of either
  device_link_del() or device_link_remove().
  If that flag is not set, however, the caller of this function is handing the
  management of the link over to the driver core entirely and its return value
  can only be used to check whether or not the link is present.  In that case,
  the DL_FLAG_AUTOREMOVE_CONSUMER and DL_FLAG_AUTOREMOVE_SUPPLIER device link
  flags can be used to indicate to the driver core when the link can be safely
  deleted.  Namely, setting one of them in @flags indicates to the driver core
  that the link is not going to be used (by the given caller of this function)
  after unbinding the consumer or supplier driver, respectively, from its
  device, so the link can be deleted at that point.  If none of them is set,
  the link will be maintained until one of the devices pointed to by it (either
  the consumer or the supplier) is unregistered.
  Also, if DL_FLAG_STATELESS, DL_FLAG_AUTOREMOVE_CONSUMER and
  DL_FLAG_AUTOREMOVE_SUPPLIER are not set in @flags (that is, a persistent
  managed device link is being added), the DL_FLAG_AUTOPROBE_CONSUMER flag can
  be used to request the driver core to automatically probe for a consumer
  driver after successfully binding a driver to the supplier device.
  The combination of DL_FLAG_STATELESS and one of DL_FLAG_AUTOREMOVE_CONSUMER,
  DL_FLAG_AUTOREMOVE_SUPPLIER, or DL_FLAG_AUTOPROBE_CONSUMER set in @flags at
  the same time is invalid and will cause NULL to be returned upfront.
  However, if a device link between the given @consumer and @supplier pair
  exists already when this function is called for them, the existing link will
  be returned regardless of its current type and status (the link's flags may
  be modified then).  The caller of this function is then expected to treat
  the link as though it has just been created, so (in particular) if
  DL_FLAG_STATELESS was passed in @flags, the link needs to be released
  explicitly when not needed any more (as stated above).
  A side effect of the link creation is re-ordering of dpm_list and the
  devices_kset list by moving the consumer device and all devices depending
  on it to the ends of these lists (that does not happen to devices that have
  not been registered when this function is called).
  The supplier device is required to be registered when this function is called
  and NULL will be returned if that is not the case.  The consumer device need
  not be registered, however.
	
	  If the supplier has not been fully registered yet or there is a
	  reverse (non-SYNC_STATE_ONLY) dependency between the consumer and
	  the supplier already in the graph, return NULL. If the link is a
	  SYNC_STATE_ONLY link, we don't check for reverse dependencies
	  because it only affects sync_state() callbacks.
	
	  SYNC_STATE_ONLY links are useless once a consumer device has probed.
	  So, only create it if the consumer hasn't probed yet.
	
	  DL_FLAG_AUTOREMOVE_SUPPLIER indicates that the link will be needed
	  longer than for DL_FLAG_AUTOREMOVE_CONSUMER and setting them both
	  together doesn't make sense, so prefer DL_FLAG_AUTOREMOVE_SUPPLIER.
		
		  If the life time of the link following from the new flags is
		  longer than indicated by the flags of the existing link,
		  update the existing link to stay around longer.
 Determine the initial link state. 
	
	  Some callers expect the link creation during consumer driver probe to
	  resume the supplier even without DL_FLAG_RPM_ACTIVE.
	
	  Move the consumer and all of the devices depending on it to the end
	  of dpm_list and the devices_kset list.
	 
	  It is necessary to hold dpm_list locked throughout all that or else
	  we may end up suspending with a wrong ordering of it.
  device_link_del - Delete a stateless link between two devices.
  @link: Device link to delete.
  The caller must ensure proper synchronization of this function with runtime
  PM.  If the link was added multiple times, it needs to be deleted as often.
  Care is required for hotplugged devices:  Their links are purged on removal
  and calling device_link_del() is then no longer allowed.
  device_link_remove - Delete a stateless link between two devices.
  @consumer: Consumer end of the link.
  @supplier: Supplier end of the link.
  The caller must ensure proper synchronization of this function with runtime
  PM.
  device_links_check_suppliers - Check presence of supplier drivers.
  @dev: Consumer device.
  Check links from this device to any suppliers.  Walk the list of the device's
  links to suppliers and see if all of them are available.  If not, simply
  return -EPROBE_DEFER.
  We need to guarantee that the supplier will not go away after the check has
  been positive here.  It only can go away in __device_release_driver() and
  that function  checks the device's links to consumers.  This means we need to
  mark the link as "consumer probe in progress" to make the supplier removal
  wait for us to complete (or bad things may happen).
  Links without the DL_FLAG_MANAGED flag set are ignored.
	
	  Device waiting for supplier to become available is not allowed to
	  probe.
  __device_links_queue_sync_state - Queue a device for sync_state() callback
  @dev: Device to call sync_state() on
  @list: List head to queue the @dev on
  Queues a device for a sync_state() callback when the device links write lock
  isn't held. This allows the sync_state() execution flow to use device links
  APIs.  The caller must ensure this function is called with
  device_links_write_lock() held.
  This function does a get_device() to make sure the device is not freed while
  on this list.
  So the caller must also ensure that device_links_flush_sync_list() is called
  as soon as the caller releases device_links_write_lock().  This is necessary
  to make sure the sync_state() is called in a timely fashion and the
  put_device() is called on this device.
	
	  Set the flag here to avoid adding the same device to a list more
	  than once. This can happen if new consumers get added to the device
	  and probed before the list is flushed.
  device_links_flush_sync_list - Call sync_state() on a list of devices
  @list: List of devices to call sync_state() on
  @dont_lock_dev: Device for which lock is already held by the caller
  Calls sync_state() on all the devices that have been queued for it. This
  function is used in conjunction with __device_links_queue_sync_state(). The
  @dont_lock_dev parameter is useful when this function is called from a
  context where a device lock is already held.
		
		  Delete from deferred_sync list before queuing it to
		  sync_list because defer_sync is used for both lists.
  device_links_force_bind - Prepares device to be force bound
  @dev: Consumer device.
  device_bind_driver() force binds a device to a driver without calling any
  driver probe functions. So the consumer really isn't going to wait for any
  supplier before it's bound to the driver. We still want the device link
  states to be sensible when this happens.
  In preparation for device_bind_driver(), this function goes through each
  supplier device links and checks if the supplier is bound. If it is, then
  the device link status is set to CONSUMER_PROBE. Otherwise, the device link
  is dropped. Links without the DL_FLAG_MANAGED flag set are ignored.
  device_links_driver_bound - Update device links after probing its driver.
  @dev: Device to update the links for.
  The probe has been successful, so update links from this device to any
  consumers by changing their status to "available".
  Also change the status of @dev's links to suppliers to "active".
  Links without the DL_FLAG_MANAGED flag set are ignored.
	
	  If a device binds successfully, it's expected to have created all
	  the device links it needs to or make new device links as it needs
	  them. So, fw_devlink no longer needs to create device links to any
	  of the device's suppliers.
	 
	  Also, if a child firmware node of this bound device is not added as
	  a device by now, assume it is never going to be added and make sure
	  other devices don't defer probe indefinitely by waiting for such a
	  child device.
		
		  Links created during consumer probe may be in the "consumer
		  probe" state to start with if the supplier is still probing
		  when they are created and they may become "active" if the
		  consumer probe returns first.  Skip them here.
			
			  When DL_FLAG_SYNC_STATE_ONLY is set, it means no
			  other DL_MANAGED_LINK_FLAGS have been set. So, it's
			  save to drop the managed link completely.
		
		  This needs to be done even for the deleted
		  DL_FLAG_SYNC_STATE_ONLY device link in case it was the last
		  device link that was preventing the supplier from getting a
		  sync_state() call.
  __device_links_no_driver - Update links of a device without a driver.
  @dev: Device without a drvier.
  Delete all non-persistent links from this device to any suppliers.
  Persistent links stay around, but their status is changed to "available",
  unless they already are in the "supplier unbind in progress" state in which
  case they need not be updated.
  Links without the DL_FLAG_MANAGED flag set are ignored.
  device_links_no_driver - Update links after failing driver probe.
  @dev: Device whose driver has just failed to probe.
  Clean up leftover links to consumers for @dev and invoke
  %__device_links_no_driver() to update links to suppliers for it as
  appropriate.
  Links without the DL_FLAG_MANAGED flag set are ignored.
		
		  The probe has failed, so if the status of the link is
		  "consumer probe" or "active", it must have been added by
		  a probing consumer while this device was still probing.
		  Change its state to "dormant", as it represents a valid
		  relationship, but it is not functionally meaningful.
  device_links_driver_cleanup - Update links after driver removal.
  @dev: Device whose driver has just gone away.
  Update links to consumers for @dev by changing their status to "dormant" and
  invoke %__device_links_no_driver() to update links to suppliers for it as
  appropriate.
  Links without the DL_FLAG_MANAGED flag set are ignored.
		
		  autoremove the links between this @dev and its consumer
		  devices that are not active, i.e. where the link state
		  has moved to DL_STATE_SUPPLIER_UNBIND.
  device_links_busy - Check if there are any busy links to consumers.
  @dev: Device to check.
  Check each consumer of the device and return 'true' if its link's status
  is one of "consumer probe" or "active" (meaning that the given consumer is
  probing right now or its driver is present).  Otherwise, change the link
  state to "supplier unbind" to prevent the consumer from being probed
  successfully going forward.
  Return 'false' if there are no probing or active consumers.
  Links without the DL_FLAG_MANAGED flag set are ignored.
  device_links_unbind_consumers - Force unbind consumers of the given device.
  @dev: Device to unbind the consumers of.
  Walk the list of links to consumers for @dev and if any of them is in the
  "consumer probe" state, wait for all device probes in progress to complete
  and start over.
  If that's not the case, change the status of the link to "supplier unbind"
  and check if the link was in the "active" state.  If so, force the consumer
  driver to unbind and start over (the consumer will not re-probe as we have
  changed the state of the link already).
  Links without the DL_FLAG_MANAGED flag set are ignored.
  device_links_purge - Delete existing links to other devices.
  @dev: Target device.
	
	  Delete all of the remaining links from this device to any other
	  devices (either consumers or suppliers).
  fw_devlink_relax_cycle - Convert cyclic links to SYNC_STATE_ONLY links
  @con: Device to check dependencies for.
  @sup: Device to check against.
  Check if @sup depends on @con or any device dependent on it (its child or
  its consumer etc).  When such a cyclic dependency is found, convert all
  device links created solely by fw_devlink into SYNC_STATE_ONLY device links.
  This is the equivalent of doing fw_devlink=permissive just between the
  devices in the cycle. We need to do this because, at this point, fw_devlink
  can't tell which of these dependencies is not a real dependency.
  Return 1 if a cycle is found. Otherwise, return 0.
  fw_devlink_create_devlink - Create a device link from a consumer to fwnode
  @con: consumer device for the device link
  @sup_handle: fwnode handle of supplier
  @flags: devlink flags
  This function will try to create a device link between the consumer device
  @con and the supplier device represented by @sup_handle.
  The supplier has to be provided as a fwnode because incorrect cycles in
  fwnode links can sometimes cause the supplier device to never be created.
  This function detects such cases and returns an error if it cannot create a
  device link from the consumer to a missing supplier.
  Returns,
  0 on successfully creating a device link
  -EINVAL if the device link cannot be created as expected
  -EAGAIN if the device link cannot be created right now, but it may be
   possible to do that in the future
	
	  In some cases, a device P might also be a supplier to its child node
	  C. However, this would defer the probe of C until the probe of P
	  completes successfully. This is perfectly fine in the device driver
	  model. device_add() doesn't guarantee probe completion of the device
	  by the time it returns.
	 
	  However, there are a few drivers that assume C will finish probing
	  as soon as it's added and before P finishes probing. So, we provide
	  a flag to let fw_devlink know not to delay the probe of C until the
	  probe of P completes successfully.
	 
	  When such a flag is set, we can't create device links where P is the
	  supplier of C as that would delay the probe of C.
		
		  If it's one of those drivers that don't actually bind to
		  their device using driver core, then don't wait on this
		  supplier device indefinitely.
		
		  If this fails, it is due to cycles in device links.  Just
		  give up on this link and treat it as invalid.
 Supplier that's already initialized without a struct device. 
	
	  DL_FLAG_SYNC_STATE_ONLY doesn't block probing and supports
	  cycles. So cycle detection isn't necessary and shouldn't be
	  done.
	
	  If we can't find the supplier device from its fwnode, it might be
	  due to a cyclic dependency between fwnodes. Some of these cycles can
	  be broken by applying logic. Check for these types of cycles and
	  break them so that devices in the cycle probe properly.
	 
	  If the supplier's parent is dependent on the consumer, then the
	  consumer and supplier have a cyclic dependency. Since fw_devlink
	  can't tell which of the inferred dependencies are incorrect, don't
	  enforce probe ordering between any of the devices in this cyclic
	  dependency. Do this by relaxing all the fw_devlink device links in
	  this cycle and by treating the fwnode link between the consumer and
	  the supplier as an invalid dependency.
		
		  Can't check for cycles or no cycles. So let's try
		  again later.
  __fw_devlink_link_to_consumers - Create device links to consumers of a device
  @dev: Device that needs to be linked to its consumers
  This function looks at all the consumer fwnodes of @dev and creates device
  links between the consumer device and @dev (supplier).
  If the consumer device has not been added yet, then this function creates a
  SYNC_STATE_ONLY link between @dev (supplier) and the closest ancestor device
  of the consumer fwnode. This is necessary to make sure @dev doesn't get a
  sync_state() callback before the real consumer device gets to be added and
  then probed.
  Once device links are created from the real consumer to @dev (supplier), the
  fwnode links are deleted.
		
		  If consumer device is not available yet, make a "proxy"
		  SYNC_STATE_ONLY link from the consumer's parent device to
		  the supplier device. This is necessary to make sure the
		  supplier doesn't get a sync_state() callback before the real
		  consumer can create a device link to the supplier.
		 
		  This proxy link step is needed to handle the case where the
		  consumer's parent device is added before the supplier.
			
			  However, if the consumer's parent device is also the
			  parent of the supplier, don't create a
			  consumer-supplier link from the parent to its child
			  device. Such a dependency is impossible.
  __fw_devlink_link_to_suppliers - Create device links to suppliers of a device
  @dev: The consumer device that needs to be linked to its suppliers
  @fwnode: Root of the fwnode tree that is used to create device links
  This function looks at all the supplier fwnodes of fwnode tree rooted at
  @fwnode and creates device links between @dev (consumer) and all the
  supplier devices of the entire fwnode tree at @fwnode.
  The function creates normal (non-SYNC_STATE_ONLY) device links between @dev
  and the real suppliers of @dev. Once these device links are created, the
  fwnode links are deleted. When such device links are successfully created,
  this function is called recursively on those supplier devices. This is
  needed to detect and break some invalid cycles in fwnode links.  See
  fw_devlink_create_devlink() for more details.
  In addition, it also looks at all the suppliers of the entire fwnode tree
  because some of the child devices of @dev that have not been added yet
  (because @dev hasn't probed) might already have their suppliers added to
  driver core. So, this function creates SYNC_STATE_ONLY device links between
  @dev (consumer) and these suppliers to make sure they don't execute their
  sync_state() callbacks before these child devices have a chance to create
  their device links. The fwnode links that correspond to the child devices
  aren't delete because they are needed later to create the device links
  between the real consumer and supplier devices.
 If no device link was created, nothing more to do. 
		
		  If a device link was successfully created to a supplier, we
		  now need to try and link the supplier to all its suppliers.
		 
		  This is needed to detect and delete false dependencies in
		  fwnode links that haven't been converted to a device link
		  yet. See comments in fw_devlink_create_devlink() for more
		  details on the false dependency.
		 
		  Without deleting these false dependencies, some devices will
		  never probe because they'll keep waiting for their false
		  dependency fwnode links to be converted to device links.
	
	  Make "proxy" SYNC_STATE_ONLY device links to represent the needs of
	  all the descendants. This proxy link step is needed to handle the
	  case where the supplier is added before the consumer's parent device
	  (@dev).
 Device links support end. 
 Avoid busy looping (5 ms of sleep should do). 
  dev_driver_string - Return a device's driver name, if at all possible
  @dev: struct device to get the name of
  Will return the device's driver's name if it is bound to a device.  If
  the device is not bound to a driver, it will return the name of the bus
  it is attached to.  If it is not attached to a bus either, an empty
  string will be returned.
	 dev->driver can change to NULL underneath us because of unbinding,
	  so be careful about accessing it.  dev->bus and dev->class should
	  never change once they are set, so they don't need special care.
 Always return full write size even if we didn't consume all 
 Always return full write size even if we didn't consume all 
  device_release - free device structure.
  @kobj: device's kobject.
  This is called once the reference count for the object
  reaches 0. We forward the call to the device's release
  method, which should handle actually freeing the structure.
	
	  Some platform devices are driven without driver attached
	  and managed resources may have been acquired.  Make sure
	  all resources are released.
	 
	  Drivers still can add resources into device after device
	  is deleted but alive, so release devres here to avoid
	  possible memory leak.
 add device node properties if present 
 Add common DT information about the device 
 have the bus specific function add its stuff 
 have the class specific function add its stuff 
 have the device type specific function add its stuff 
 search the kset, the device belongs to 
 respect filter 
 let the kset specific function add its keys 
 copy keys to file 
  devm_device_add_group - given a device, create a managed attribute group
  @dev:	The device to create the group for
  @grp:	The attribute group to create
  This function creates a group for the first time.  It will explicitly
  warn and error if any of the attribute files being created already exist.
  Returns 0 on success or error code on failure.
  devm_device_remove_group: remove a managed group from a device
  @dev:	device to remove the group from
  @grp:	group to remove
  This function removes a group of attributes from a device. The attributes
  previously have to have been created for this group, otherwise it will fail.
 cast away const  (void )grp));
  devm_device_add_groups - create a bunch of managed attribute groups
  @dev:	The device to create the group for
  @groups:	The attribute groups to create, NULL terminated
  This function creates a bunch of managed attribute groups.  If an error
  occurs when creating a group, all previously created groups will be
  removed, unwinding everything back to the original state when this
  function was called.  It will explicitly warn and error if any of the
  attribute files being created already exist.
  Returns 0 on success or error code from sysfs_create_group on failure.
  devm_device_remove_groups - remove a list of managed groups
  @dev:	The device for the groups to be removed from
  @groups:	NULL terminated list of groups to be removed
  If groups is not NULL, remove the specified groups from the device.
 cast away const  (void )groups));
 sysdevices 
  devices_kset_move_before - Move device in the devices_kset's list.
  @deva: Device to move.
  @devb: Device @deva should come before.
  devices_kset_move_after - Move device in the devices_kset's list.
  @deva: Device to move
  @devb: Device @deva should come after.
  devices_kset_move_last - move the device to the end of devices_kset's list.
  @dev: device to move
  device_create_file - create sysfs attribute file for device.
  @dev: device.
  @attr: device attribute descriptor.
  device_remove_file - remove sysfs attribute file.
  @dev: device.
  @attr: device attribute descriptor.
  device_remove_file_self - remove sysfs attribute file from its own method.
  @dev: device.
  @attr: device attribute descriptor.
  See kernfs_remove_self() for details.
  device_create_bin_file - create sysfs binary attribute file for device.
  @dev: device.
  @attr: device binary attribute descriptor.
  device_remove_bin_file - remove sysfs binary attribute file
  @dev: device.
  @attr: device binary attribute descriptor.
  device_initialize - init device structure.
  @dev: device.
  This prepares the device for use by other layers by initializing
  its fields.
  It is the first half of device_register(), if called by
  that function, though it can also be called separately, so one
  may use @dev's fields. In particular, get_device()put_device()
  may be used for reference counting of @dev after calling this
  function.
  All fields in @dev must be initialized by the caller to 0, except
  for those explicitly set to some other value.  The simplest
  approach is to use kzalloc() to allocate the structure containing
  @dev.
  NOTE: Use put_device() to give up your reference instead of freeing
  @dev directly once you have called this function.
 block disks show up in sysblock 
		
		  If we have no parent, we live in "virtual".
		  Class-devices with a non class-device as parent, live
		  in a "glue" directory to prevent namespace collisions.
 find our class-directory at the parent and reference it 
 or create a new class-directory at the parent device 
 do not emit an uevent for this simple "glue" directory 
 subsystems can specify a default root directory for their devices 
  make sure cleaning up dir as the last step, we need to make
  sure .release handler of kobject is run with holding the
  global lock
 see if we live in a "glue" directory 
	
	  There is a race condition between removing glue directory
	  and adding a new device under the glue directory.
	 
	  CPU1:                                         CPU2:
	 
	  device_add()
	    get_device_parent()
	      class_dir_create_and_add()
	        kobject_add_internal()
	          create_dir()     create glue_dir
	 
	                                                device_add()
	                                                  get_device_parent()
	                                                    kobject_get()  get glue_dir
	 
	  device_del()
	    cleanup_glue_dir()
	      kobject_del(glue_dir)
	 
	                                                kobject_add()
	                                                  kobject_add_internal()
	                                                    create_dir()  in glue_dir
	                                                      sysfs_create_dir_ns()
	                                                        kernfs_create_dir_ns(sd)
	 
	        sysfs_remove_dir()  glue_dir->sd=NULL
	        sysfs_put()         free glue_dir->sd
	 
	                                                           sd is freed
	                                                          kernfs_new_node(sd)
	                                                            kernfs_get(glue_dir)
	                                                            kernfs_add_one()
	                                                            kernfs_put()
	 
	  Before CPU1 remove last child device under glue dir, if CPU2 add
	  a new device under glue dir, the glue_dir kobject reference count
	  will be increase to 2 in kobject_get(k). And CPU2 has been called
	  kernfs_create_dir_ns(). Meanwhile, CPU1 call sysfs_remove_dir()
	  and sysfs_put(). This result in glue_dir->sd is freed.
	 
	  Then the CPU2 will see a stale "empty" but still potentially used
	  glue dir around in kernfs_new_node().
	 
	  In order to avoid this happening, we also should make sure that
	  kernfs_node for glue_dir is released in CPU1 only when refcount
	  for glue_dir kobj is 1.
 An error here doesn't warrant bringing down the device 
 sysblock has directories and does not need symlinks 
 link in the class directory pointing to the device 
  dev_set_name - set a device name
  @dev: device
  @fmt: format string for the device's name
  device_to_dev_kobj - select a sysdev directory for the device
  @dev: device
  By default we select char for new entries.  Setting class->dev_obj
  to NULL prevents an entry from being created.  class->dev_kobj must
  be set (or cleared) before any devices are registered to the class
  otherwise device_create_sys_dev_entry() and
  device_remove_sys_dev_entry() will disagree about the presence of
  the link.
  device_add - add device to device hierarchy.
  @dev: device.
  This is part 2 of device_register(), though may be called
  separately _iff_ device_initialize() has been called separately.
  This adds @dev to the kobject hierarchy via kobject_add(), adds it
  to the global and sibling lists for the device, then
  adds it to the other relevant subsystems of the driver model.
  Do not call this routine or device_register() more than once for
  any device structure.  The driver model core is not designed to work
  with devices that get unregistered and then spring back to life.
  (Among other things, it's very hard to guarantee that all references
  to the previous incarnation of @dev have been dropped.)  Allocate
  and register a fresh new struct device instead.
  NOTE: _Never_ directly free @dev after calling this function, even
  if it returned an error! Always use put_device() to give up your
  reference instead.
  Rule of thumb is: if device_add() succeeds, you should call
  device_del() when you want to get rid of it. If device_add() has
  not succeeded, use only put_device() to drop the reference
  count.
	
	  for statically allocated devices, which should all be converted
	  some day, we need to initialize the name. We prevent reading back
	  the name, and force the use of dev_name()
 subsystems can specify simple device enumeration 
 use parent numa_node 
 first, register with generic layer. 
 we require the name to be set before, and pass NULL 
 notify platform of device entry 
	 Notify clients of device addition.  This call must come
	  after dpm_sysfs_add() and before kobject_uevent().
	
	  Check if any of the other devices (consumers) have been waiting for
	  this device (supplier) to be added so that they can create a device
	  link to it.
	 
	  This needs to happen after device_pm_add() because device_link_add()
	  requires the supplier be registered before it's called.
	 
	  But this also needs to happen before bus_probe_device() to make sure
	  waiting consumers can link to it before the driver is bound to the
	  device and the driver sync_state callback is called for this device.
	
	  If all driver registration is done and a newly added device doesn't
	  match with any driver, don't block its consumers from probing in
	  case the consumer device is able to operate without this supplier.
 tie the class to the device 
 notify any interfaces that the device is here 
  device_register - register a device with the system.
  @dev: pointer to the device structure
  This happens in two clean steps - initialize the device
  and add it to the system. The two steps can be called
  separately, but this is the easiest and most common.
  I.e. you should only call the two helpers separately if
  have a clearly defined need to use and refcount the device
  before it is added to the hierarchy.
  For more information, see the kerneldoc for device_initialize()
  and device_add().
  NOTE: _Never_ directly free @dev after calling this function, even
  if it returned an error! Always use put_device() to give up the
  reference initialized in this function instead.
  get_device - increment reference count for device.
  @dev: device.
  This simply forwards the call to kobject_get(), though
  we do take care to provide for the case that we get a NULL
  pointer passed in.
  put_device - decrement reference count.
  @dev: device in question.
 might_sleep(); 
	
	  Require the device lock and set the "dead" flag to guarantee that
	  the update behavior is consistent with the other bitfields near
	  it and that we cannot have an asynchronous probe routine trying
	  to run while we are tearing out the busclasssysfs from
	  underneath the device.
  device_del - delete device from system.
  @dev: device.
  This is the first part of the device unregistration
  sequence. This removes the device from the lists we control
  from here, has it removed from the other driver model
  subsystems it was added to in device_add(), and removes it
  from the kobject hierarchy.
  NOTE: this should be called manually _iff_ device_add() was
  also called manually.
	 Notify clients of device removal.  This call must come
	  before dpm_sysfs_remove().
 notify any interfaces that the device is now gone 
 remove the device from the class list 
  device_unregister - unregister device from system.
  @dev: device going away.
  We do this in two parts, like we do device_register(). First,
  we remove it from all the subsystems with device_del(), then
  we decrement the reference count via put_device(). If that
  is the final reference count, the device will be cleaned up
  via device_release() above. Otherwise, the structure will
  stick around until the final reference to the device is dropped.
  device_get_devnode - path of device node file
  @dev: device
  @mode: returned file access mode
  @uid: returned file owner
  @gid: returned file group
  @tmp: possibly allocated string
  Return the relative path of a possible device node.
  Non-default names may need to allocate a memory to compose
  a name. This memory is returned in tmp and needs to be
  freed by the caller.
 the device type may provide a specific name 
 the class may provide a specific name 
 return name without allocation, tmp == NULL 
 replace '!' in the name with '' 
  device_for_each_child - device child iterator.
  @parent: parent struct device.
  @fn: function to be called for each device.
  @data: data for the callback.
  Iterate over @parent's child devices, and call @fn for each,
  passing it @data.
  We check the return of @fn each time. If it returns anything
  other than 0, we break out and return that value.
  device_for_each_child_reverse - device child iterator in reversed order.
  @parent: parent struct device.
  @fn: function to be called for each device.
  @data: data for the callback.
  Iterate over @parent's child devices, and call @fn for each,
  passing it @data.
  We check the return of @fn each time. If it returns anything
  other than 0, we break out and return that value.
  device_find_child - device iterator for locating a particular device.
  @parent: parent struct device
  @match: Callback function to check device
  @data: Data to pass to match function
  This is similar to the device_for_each_child() function above, but it
  returns a reference to a device that is 'found' for later use, as
  determined by the @match callback.
  The callback should return 0 if the device doesn't match and non-zero
  if it does.  If the callback returns non-zero and a reference to the
  current device can be obtained, this function will return to the caller
  and not iterate over any more devices.
  NOTE: you will need to drop the reference with put_device() after use.
  device_find_child_by_name - device iterator for locating a child device.
  @parent: parent struct device
  @name: name of the child device
  This is similar to the device_find_child() function above, but it
  returns a reference to a device that has the name @name.
  NOTE: you will need to drop the reference with put_device() after use.
  device_offline - Prepare the device for hot-removal.
  @dev: Device to be put offline.
  Execute the device bus type's .offline() callback, if present, to prepare
  the device for a subsequent hot-removal.  If that succeeds, the device must
  not be used until either it is removed or its bus type's .online() callback
  is executed.
  Call under device_hotplug_lock.
  device_online - Put the device back online after successful device_offline().
  @dev: Device to be put back online.
  If device_offline() has been successfully executed for @dev, but the device
  has not been removed subsequently, execute its bus type's .online() callback
  to indicate that the device can be used again.
  Call under device_hotplug_lock.
  __root_device_register - allocate and register a root device
  @name: root device name
  @owner: owner module of the root device, usually THIS_MODULE
  This function allocates a root device and registers it
  using device_register(). In order to free the returned
  device, use root_device_unregister().
  Root devices are dummy devices which allow other devices
  to be grouped under sysdevices. Use this function to
  allocate a root device and then use it as the parent of
  any device which should appear under sysdevices{name}
  The sysdevices{name} directory will also contain a
  'module' symlink which points to the @owner directory
  in sysfs.
  Returns &struct device pointer on success, or ERR_PTR() on error.
  Note: You probably want to use root_device_register().
 gotta find a "cleaner" way to do this 
  root_device_unregister - unregister and free a root device
  @dev: device going away
  This function unregisters and cleans up a device that was created by
  root_device_register().
  device_create - creates a device and registers it with sysfs
  @class: pointer to the struct class that this device should be registered to
  @parent: pointer to the parent struct device of this new device, if any
  @devt: the dev_t for the char device to be added
  @drvdata: the data to be added to the device for callbacks
  @fmt: string for the device's name
  This function can be used by char device classes.  A struct device
  will be created in sysfs, registered to the specified class.
  A "dev" file will be created, showing the dev_t for the device, if
  the dev_t is not 0,0.
  If a pointer to a parent struct device is passed in, the newly created
  struct device will be a child of that device in sysfs.
  The pointer to the struct device will be returned from the call.
  Any further sysfs files that might be required can be created using this
  pointer.
  Returns &struct device pointer on success, or ERR_PTR() on error.
  Note: the struct class passed to this function must have previously
  been created with a call to class_create().
  device_create_with_groups - creates a device and registers it with sysfs
  @class: pointer to the struct class that this device should be registered to
  @parent: pointer to the parent struct device of this new device, if any
  @devt: the dev_t for the char device to be added
  @drvdata: the data to be added to the device for callbacks
  @groups: NULL-terminated list of attribute groups to be created
  @fmt: string for the device's name
  This function can be used by char device classes.  A struct device
  will be created in sysfs, registered to the specified class.
  Additional attributes specified in the groups parameter will also
  be created automatically.
  A "dev" file will be created, showing the dev_t for the device, if
  the dev_t is not 0,0.
  If a pointer to a parent struct device is passed in, the newly created
  struct device will be a child of that device in sysfs.
  The pointer to the struct device will be returned from the call.
  Any further sysfs files that might be required can be created using this
  pointer.
  Returns &struct device pointer on success, or ERR_PTR() on error.
  Note: the struct class passed to this function must have previously
  been created with a call to class_create().
  device_destroy - removes a device that was created with device_create()
  @class: pointer to the struct class that this device was registered with
  @devt: the dev_t of the device that was previously registered
  This call unregisters and cleans up a device that was created with a
  call to device_create().
  device_rename - renames a device
  @dev: the pointer to the struct device to be renamed
  @new_name: the new name of the device
  It is the responsibility of the caller to provide mutual
  exclusion between two different calls of device_rename
  on the same device to ensure that new_name is valid and
  won't conflict with other devices.
  Note: Don't call this function.  Currently, the networking layer calls this
  function, but that will change.  The following text from Kay Sievers offers
  some insight:
  Renaming devices is racy at many levels, symlinks and other stuff are not
  replaced atomically, and you get a "move" uevent, but it's not easy to
  connect the event to the old and new device. Device nodes are not renamed at
  all, there isn't even support for that in the kernel now.
  In the meantime, during renaming, your target name might be taken by another
  driver, creating conflicts. Or the old name is taken directly after you
  renamed it -- then you get events for the same DEVPATH, before you even see
  the "move" event. It's just a mess, and nothing new should ever rely on
  kernel device renaming. Besides that, it's not even implemented now for
  other things than (driver-core wise very simple) network devices.
  We are currently about to change network renaming in udev to completely
  disallow renaming of devices in the same namespace as the kernel uses,
  because we can't solve the problems properly, that arise with swapping names
  of multiple interfaces without races. Means, renaming of eth[0-9] will only
  be allowed to some other name than eth[0-9], for the aforementioned
  reasons.
  Make up a "real" name in the driver before you register anything, or add
  some other attributes for userspace to find the device, or use udev to add
  symlinks -- but never rename kernel devices later, it's a complete mess. We
  don't even want to get into that and try to implement the missing pieces in
  the core. We really have other pieces to fix in the driver core mess. :)
  device_move - moves a device to a new parent
  @dev: the pointer to the struct device to be moved
  @new_parent: the new parent of the device (can be NULL)
  @dpm_order: how to reorder the dpm_list
 We ignore errors on cleanup since we're hosed anyway... 
		
		  Change the device groups of the device class for @dev to
		  @kuid@kgid.
		
		  Change the device groups of the device type for @dev to
		  @kuid@kgid.
 Change the device groups of @dev to @kuid@kgid. 
 Change online device attributes of @dev to @kuid@kgid. 
  device_change_owner - change the owner of an existing device.
  @dev: device.
  @kuid: new owner's kuid
  @kgid: new owner's kgid
  This changes the owner of @dev and its corresponding sysfs entries to
  @kuid@kgid. This function closely mirrors how @dev was added via driver
  core.
  Returns 0 on success or error code on failure.
	
	  Change the kobject and the default attributes and groups of the
	  ktype associated with it to @kuid@kgid.
	
	  Change the uevent file for @dev to the new owner. The uevent file
	  was created in a separate step when @dev got added and we mirror
	  that step here.
	
	  Change the device groups, the device groups associated with the
	  device class, and the groups associated with the device type of @dev
	  to @kuid@kgid.
	
	  Change the owner of the symlink located in the class directory of
	  the device class associated with @dev which points to the actual
	  directory entry for @dev to @kuid@kgid. This ensures that the
	  symlink shows the same permissions as its target.
  device_shutdown - call ->shutdown() on each device to shutdown.
	
	  Walk the devices list backward, shutting down each in turn.
	  Beware that device unplug events may also start pulling
	  devices offline, even as the system is shutting down.
		
		  hold reference count of device's parent to
		  prevent it from being freed because parent's
		  lock is to be held
		
		  Make sure the device is off the kset list, in the
		  event that dev->->shutdown() doesn't remove it.
 hold lock to avoid race with proberelease 
 Don't allow any more runtime suspends 
  Device logging functions
	
	  Add device identifier DEVICE=:
	    b12:8         block dev_t
	    c127:3        char dev_t
	    n8            netdev ifindex
	    +sound:card0  subsystem:devname
  dev_err_probe - probe error check and log helper
  @dev: the pointer to the struct device
  @err: error value to test
  @fmt: printf-style format string
  @...: arguments as specified in the format string
  This helper implements common pattern present in probe functions for error
  checking: print debug or error message depending if the error value is
  -EPROBE_DEFER and propagate error upwards.
  In case of -EPROBE_DEFER it sets also defer probe reason, which can be
  checked later by reading devices_deferred debugfs attribute.
  It replaces code sequence::
  	if (err != -EPROBE_DEFER)
  		dev_err(dev, ...);
  	else
  		dev_dbg(dev, ...);
  	return err;
  with::
  	return dev_err_probe(dev, err, ...);
  Note that it is deemed acceptable to use this function for error
  prints during probe even if the @err is known to never be -EPROBE_DEFER.
  The benefit compared to a normal dev_err() is the standardized format
  of the error code and the fact that the error code is returned.
  Returns @err.
  set_primary_fwnode - Change the primary firmware node of a given device.
  @dev: Device to handle.
  @fwnode: New primary firmware node of the device.
  Set the device's firmware node pointer to @fwnode, but if a secondary
  firmware node of the device is present, preserve it.
  Valid fwnode cases are:
   - primary --> secondary --> -ENODEV
   - primary --> NULL
   - secondary --> -ENODEV
   - NULL
 Set fn->secondary = NULL, so fn remains the primary fwnode 
  set_secondary_fwnode - Change the secondary firmware node of a given device.
  @dev: Device to handle.
  @fwnode: New secondary firmware node of the device.
  If a primary firmware node of the device is present, set its secondary
  pointer to @fwnode.  Otherwise, set the device's firmware node pointer to
  @fwnode.
  device_set_of_node_from_dev - reuse device-tree node of another device
  @dev: device whose device-tree node is being set
  @dev2: device whose device-tree node is being reused
  Takes another reference to the new device-tree node after first dropping
  any reference held to the old node.
 SPDX-License-Identifier: GPL-2.0
  hypervisor.c - syshypervisor subsystem.
  Copyright (C) IBM Corp. 2006
  Copyright (C) 2007 Greg Kroah-Hartman <gregkh@suse.de>
  Copyright (C) 2007 Novell Inc.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) ST-Ericsson SA 2011
  Author: Lee Jones <lee.jones@linaro.org> for ST-Ericsson.
 Prototype to allow declarations of DEVICE_ATTR(<foo>) before soc_info_show 
 Unknown or unfilled attribute 
 Fetch a unique (reclaimable) SOC ID. 
 Ensure soc_dev->attr is freed after calling soc_device_unregister. 
  soc_device_match - identify the SoC in the machine
  @matches: zero-terminated array of possible matches
  returns the first matching entry of the argument array, or NULL
  if none of them match.
  This function is meant as a helper in place of of_match_node()
  in cases where either no device tree is available or the information
  in a device node is insufficient to identify a particular variant
  by its compatible strings or other properties. For new devices,
  the DT binding should always provide unique compatible strings
  that allow the use of of_match_node() instead.
  The calling function can use the .data entry of the
  soc_device_attribute to pass a structure or function pointer for
  each entry.
 SPDX-License-Identifier: GPL-2.0
  module.c - module sysfs fun for drivers
 Lookup built-in module entry in sysmodules 
 remember our module structure 
 kset_find_obj took a reference 
 Don't check return codes; these calls are idempotent 
 SPDX-License-Identifier: GPL-2.0
   linuxdriversbasemap.c
  (C) Copyright Al Viro 2002,2003
  NOTE: data structure needs to be changed.  It works, but for large dev_t
  it will be too slow.  It is isolated, though, so these changes will be
  local to that file.
 Currently ->owner protects _only_ ->probe() itself. 
 SPDX-License-Identifier: GPL-2.0
   syscore.c - Execution of system core operations.
   Copyright (C) 2011 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.
  register_syscore_ops - Register a set of system core operations.
  @ops: System core operations to register.
  unregister_syscore_ops - Unregister a set of system core operations.
  @ops: System core operations to unregister.
  syscore_suspend - Execute all the registered system core suspend callbacks.
  This function is executed with one CPU on-line and disabled interrupts.
 Return error code if there are any wakeup interrupts pending. 
  syscore_resume - Execute all the registered system core resume callbacks.
  This function is executed with one CPU on-line and disabled interrupts.
 CONFIG_PM_SLEEP 
  syscore_shutdown - Execute all the registered system core shutdown callbacks.
 SPDX-License-Identifier: GPL-2.0
  Componentized device handling.
  This is work in progress.  We gather up the component devices into a list,
  and bind them when instructed.  At the moment, we're specific to the DRM
  subsystem, and only handles one master device, but this doesn't have to be
  the case.
  DOC: overview
  The component helper allows drivers to collect a pile of sub-devices,
  including their bound drivers, into an aggregate driver. Various subsystems
  already provide functions to get hold of such components, e.g.
  of_clk_get_by_name(). The component helper can be used when such a
  subsystem-specific way to find a device is not available: The component
  helper fills the niche of aggregate drivers for specific hardware, where
  further standardization into a subsystem would not be practical. The common
  example is when a logical device (e.g. a DRM display driver) is spread around
  the SoC on various components (scanout engines, blending blocks, transcoders
  for various outputs and so on).
  The component helper also doesn't solve runtime dependencies, e.g. for system
  suspend and resume operations. See also :ref:`device links<device_link>`.
  Components are registered using component_add() and unregistered with
  component_del(), usually from the driver's probe and disconnect functions.
  Aggregate drivers first assemble a component match list of what they need
  using component_match_add(). This is then registered as an aggregate driver
  using component_master_add_with_match(), and unregistered using
  component_master_del().
	
	  Scan the array of match functions and attach
	  any components which are found to this master.
 Attach this component to the master 
 Detach component from associated master 
 Detach the component from this master. 
  Try to bring up a master.  If component is NULL, we're interested in
  this master, otherwise it's a component which must be present to try
  and bring up the master.
  Returns 1 for successful bringup, 0 if not ready, or -ve errno.
 Found all components 
  component_match_add_release - add a component match entry with release callback
  @master: device with the aggregate driver
  @matchptr: pointer to the list of component matches
  @release: release function for @compare_data
  @compare: compare function to match against all components
  @compare_data: opaque pointer passed to the @compare function
  Adds a new component match to the list stored in @matchptr, which the @master
  aggregate driver needs to function. The list of component matches pointed to
  by @matchptr must be initialized to NULL before adding the first match. This
  only matches against components added with component_add().
  The allocated match list in @matchptr is automatically released using devm
  actions, where upon @release will be called to free any references held by
  @compare_data, e.g. when @compare_data is a &device_node that must be
  released with of_node_put().
  See also component_match_add() and component_match_add_typed().
  component_match_add_typed - add a component match entry for a typed component
  @master: device with the aggregate driver
  @matchptr: pointer to the list of component matches
  @compare_typed: compare function to match against all typed components
  @compare_data: opaque pointer passed to the @compare function
  Adds a new component match to the list stored in @matchptr, which the @master
  aggregate driver needs to function. The list of component matches pointed to
  by @matchptr must be initialized to NULL before adding the first match. This
  only matches against components added with component_add_typed().
  The allocated match list in @matchptr is automatically released using devm
  actions.
  See also component_match_add_release() and component_match_add_typed().
  component_master_add_with_match - register an aggregate driver
  @parent: parent device of the aggregate driver
  @ops: callbacks for the aggregate driver
  @match: component match list for the aggregate driver
  Registers a new aggregate driver consisting of the components added to @match
  by calling one of the component_match_add() functions. Once all components in
  @match are available, it will be assembled by calling
  &component_master_ops.bind from @ops. Must be unregistered by calling
  component_master_del().
 Reallocate the match array for its true size 
 Add to the list of available masters. 
  component_master_del - unregister an aggregate driver
  @parent: parent device of the aggregate driver
  @ops: callbacks for the aggregate driver
  Unregisters an aggregate driver registered with
  component_master_add_with_match(). If necessary the aggregate driver is first
  disassembled by calling &component_master_ops.unbind from @ops.
 Release all resources claimed in the binding of this component 
  component_unbind_all - unbind all components of an aggregate driver
  @parent: parent device of the aggregate driver
  @data: opaque pointer, passed to all components
  Unbinds all components of the aggregate device by passing @data to their
  &component_ops.unbind functions. Should be called from
  &component_master_ops.unbind.
 Unbind components in reverse order 
	
	  Each component initialises inside its own devres group.
	  This allows us to roll-back a failed component without
	  affecting anything else.
	
	  Also open a group for the device itself: this allows us
	  to release the resources claimed against the sub-device
	  at the appropriate moment.
		
		  Close the component device's group so that resources
		  allocated in the binding are encapsulated for removal
		  at unbind.  Remove the group on the DRM device as we
		  can clean those resources up independently.
  component_bind_all - bind all components of an aggregate driver
  @parent: parent device of the aggregate driver
  @data: opaque pointer, passed to all components
  Binds all components of the aggregate @dev by passing @data to their
  &component_ops.bind functions. Should be called from
  &component_master_ops.bind.
 Bind components in match order 
  component_add_typed - register a component
  @dev: component device
  @ops: component callbacks
  @subcomponent: nonzero identifier for subcomponents
  Register a new component for @dev. Functions in @ops will be call when the
  aggregate driver is ready to bind the overall driver by calling
  component_bind_all(). See also &struct component_ops.
  @subcomponent must be nonzero and is used to differentiate between multiple
  components registerd on the same device @dev. These components are match
  using component_match_add_typed().
  The component needs to be unregistered at driver unloaddisconnect by
  calling component_del().
  See also component_add().
  component_add - register a component
  @dev: component device
  @ops: component callbacks
  Register a new component for @dev. Functions in @ops will be called when the
  aggregate driver is ready to bind the overall driver by calling
  component_bind_all(). See also &struct component_ops.
  The component needs to be unregistered at driver unloaddisconnect by
  calling component_del().
  See also component_add_typed() for a variant that allows multipled different
  components on the same device.
  component_del - unregister a component
  @dev: component device
  @ops: component callbacks
  Unregister a component added with component_add(). If the component is bound
  into an aggregate driver, this will force the entire aggregate driver, including
  all its components, to be unbound.
 SPDX-License-Identifier: GPL-2.0
  Basic Node interface support
  struct node_access_nodes - Access class device to hold user visible
  			      relationships to other nodes.
  @dev:	Device for this memory access class
  @list_node:	List element in the node's access list
  @access:	The access class rank
  @hmem_attrs: Heterogeneous memory performance attributes
  node_set_perf_attrs - Set the performance values for given access class
  @nid: Node identifier to be set
  @hmem_attrs: Heterogeneous memory performance attributes
  @access: The access class the for the given attributes
  struct node_cache_info - Internal tracking for memory node caches
  @dev:	Device represeting the cache level
  @node:	List element for tracking in the node
  @cache_attrs:Attributes for this cache level
  node_add_cache() - add cache attribute to a memory node
  @nid: Node identifier that has new cache attributes
  @cache_attrs: Attributes for the cache being added
	
	  buf is currently PAGE_SIZE in length and each node needs 4 chars
	  at the most (distance + space or newline).
  hugetlbfs per node attributes registration interface:
  Whenif hugetlb[fs] subsystem initializes [sometime after this module],
  it will register its per node attributes for all online nodes with
  memory.  It will also call register_hugetlbfs_with_node(), below, to
  register its attribute registration functions with this node driver.
  Once these hooks have been initialized, the node driver will call into
  the hugetlb module to [un]register attributes for hot-plugged nodes.
	
	  We schedule the work only when a memory section is
	  onlinedofflined on this node. When we come here,
	  all the memory on this node has been offlined,
	  so we won't enqueue new work to this work.
	 
	  The work is using node->node_work, so we should
	  flush work before freeing the memory.
  register_node - Setup a sysfs device for a node.
  @num - Node number to use when creating the device.
  Initialize and register the node device.
  unregister_node - unregister a node device
  @node: node going away
  Unregisters a node device @node.  All the devices on the node must be
  unregistered before calling this function.
 no-op, if memoryless node 
  register cpu under node
  register_memory_node_under_compute_node - link memory node to its compute
 					     node for a given access class.
  @mem_nid:	Memory node number
  @cpu_nid:	Cpu  node number
  @access:	Access class to register
  Description:
  	For use with platforms that may have separate memory and compute nodes.
  	This function will export node relationships linking which memory
  	initiator nodes can access memory targets at a given ranked access
  	class.
	
	  If this memory block spans multiple nodes, we only indicate
	  the last processed node.
 register memory section under specified node if it spans that node 
		
		  memory block could have several absent sections from start.
		  skip pfn range from absent section
		
		  We need to check if page belongs to nid only at the boot
		  case because node's ranges can be interleaved.
 mem section does not span the specified node 
  During hotplug we know that all pages in the memory block belong to the same
  node.
  Unregister a memory block device under the node it spans. Memory blocks
  with multiple nodes cannot be offlined and therefore also never be removed.
  Handle per node hstate attribute [un]registration on transistions
  tofrom memoryless state.
	
	  We only get here when a node transitions tofrom memoryless state.
	  We can detect which transition occurred by examining whether the
	  node has memory now.  hugetlb_register_node() already check this
	  so we try to register the attributes.  If that fails, then the
	  node has transitioned to memoryless, try to unregister the
	  attributes.
		
		  offload per node hstate [un]registration to a work thread
		  when transitioning tofrom memoryless state.
 CONFIG_HUGETLBFS 
 CONFIG_MEMORY_HOTPLUG 
 link cpu under this node 
 initialize work queue for memory hot plug 
  node states attributes
 lower than SLAB 
	
	  Note:  we're not going to unregister the node class if we fail
	  to register the node state class attribute files.
 SPDX-License-Identifier: GPL-2.0
  transport_class.c - implementation of generic transport classes
                      using attribute_containers
  Copyright (c) 2005 - James Bottomley <James.Bottomley@steeleye.com>
  The basic idea here is to allow any "device controller" (which
  would most often be a Host Bus Adapter to use the services of one
  or more tranport classes for performing transport specific
  services.  Transport specific services are things that the generic
  command layer doesn't want to know about (speed settings, line
  condidtioning, etc), but which the user might be interested in.
  Thus, the HBA's use the routines exported by the transport classes
  to perform these functions.  The transport classes export certain
  values to the user via sysfs using attribute containers.
  Note: because not every HBA will care about every transport
  attribute, there's a many to one relationship that goes like this:
  transport class<-----attribute container<----class device
  Usually the attribute container is per-HBA, but the design doesn't
  mandate that.  Although most of the services will be specific to
  the actual external storage connection used by the HBA, the generic
  transport class is framed entirely in terms of generic devices to
  allow it to be used by any physical HBA in the system.
  transport_class_register - register an initial transport class
  @tclass:	a pointer to the transport class structure to be initialised
  The transport class contains an embedded class which is used to
  identify it.  The caller should initialise this structure with
  zeros and then generic class must have been initialised with the
  actual transport class unique name.  There's a macro
  DECLARE_TRANSPORT_CLASS() to do this (declared classes still must
  be registered).
  Returns 0 on success or error on failure.
  transport_class_unregister - unregister a previously registered class
  @tclass: The transport class to unregister
  Must be called prior to deallocating the memory for the transport
  class.
 do nothing 
  anon_transport_class_register - register an anonymous class
  @atc: The anon transport class to register
  The anonymous transport class contains both a transport class and a
  container.  The idea of an anonymous class is that it never
  actually has any device attributes associated with it (and thus
  saves on container storage).  So it can only be used for triggering
  events.  Use prezero and then use DECLARE_ANON_TRANSPORT_CLASS() to
  initialise the anon transport class storage.
  anon_transport_class_unregister - unregister an anon class
  @atc: Pointer to the anon transport class to unregister
  Must be called prior to deallocating the memory for the anon
  transport class.
  transport_setup_device - declare a new dev for transport class association but don't make it visible yet.
  @dev: the generic device representing the entity being added
  Usually, dev represents some component in the HBA system (either
  the HBA itself or a device remote across the HBA bus).  This
  routine is simply a trigger point to see if any set of transport
  classes wishes to associate with the added device.  This allocates
  storage for the class device and initialises it, but does not yet
  add it to the system or add attributes to it (you do this with
  transport_add_device).  If you have no need for a separate setup
  and add operations, use transport_register_device (see
  transport_class.h).
  transport_add_device - declare a new dev for transport class association
  @dev: the generic device representing the entity being added
  Usually, dev represents some component in the HBA system (either
  the HBA itself or a device remote across the HBA bus).  This
  routine is simply a trigger point used to add the device to the
  system and register attributes for it.
  transport_configure_device - configure an already set up device
  @dev: generic device representing device to be configured
  The idea of configure is simply to provide a point within the setup
  process to allow the transport class to extract information from a
  device after it has been setup.  This is used in SCSI because we
  have to have a setup device to begin using the HBA, but after we
  send the initial inquiry, we use configure to extract the device
  parameters.  The device need not have been added to be configured.
  transport_remove_device - remove the visibility of a device
  @dev: generic device to remove
  This call removes the visibility of the device (to the user from
  sysfs), but does not destroy it.  To eliminate a device entirely
  you must also call transport_destroy_device.  If you don't need to
  do remove and destroy as separate operations, use
  transport_unregister_device() (see transport_class.h) which will
  perform both calls for you.
  transport_destroy_device - destroy a removed device
  @dev: device to eliminate from the transport class.
  This call triggers the elimination of storage associated with the
  transport classdev.  Note: all it really does is relinquish a
  reference to the classdev.  The memory will not be freed until the
  last reference goes to zero.  Note also that the classdev retains a
  reference count on dev, so dev too will remain for as long as the
  transport class device remains around.
 SPDX-License-Identifier: GPL-2.0
  driversbasedevres.c - device resource management
  Copyright (c) 2006  SUSE Linux Products GmbH
  Copyright (c) 2006  Tejun Heo <teheo@suse.de>
	
	  Some archs want to perform DMA into kmalloc caches
	  and need a guaranteed alignment larger than
	  the alignment of a 64-bit integer.
	  Thus we use ARCH_KMALLOC_MINALIGN here and get exactly the same
	  buffer alignment as if it was allocated by plain kmalloc().
 -- 8 pointers 
 CONFIG_DEBUG_DEVRES 
 CONFIG_DEBUG_DEVRES 
  Release functions for devres group.  These callbacks are used only
  for identification.
 noop 
 noop 
 We must catch any near-SIZE_MAX cases that could overflow. 
  __devres_alloc_node - Allocate device resource data
  @release: Release function devres will be associated with
  @size: Allocation size
  @gfp: Allocation flags
  @nid: NUMA node
  @name: Name of the resource
  Allocate devres of @size bytes.  The allocated area is zeroed, then
  associated with @release.  The returned pointer can be passed to
  other devres_() functions.
  RETURNS:
  Pointer to allocated devres on success, NULL on failure.
  devres_for_each_res - Resource iterator
  @dev: Device to iterate resource from
  @release: Look for resources associated with this release function
  @match: Match function (optional)
  @match_data: Data for the match function
  @fn: Function to be called for each matched resource.
  @data: Data for @fn, the 3rd parameter of @fn
  Call @fn for each devres of @dev which is associated with @release
  and for which @match returns 1.
  RETURNS:
  	void
  devres_free - Free device resource data
  @res: Pointer to devres data to free
  Free devres created with devres_alloc().
  devres_add - Register device resource
  @dev: Device to add resource to
  @res: Resource to register
  Register devres @res to @dev.  @res should have been allocated
  using devres_alloc().  On driver detach, the associated release
  function will be invoked and devres will be freed automatically.
  devres_find - Find device resource
  @dev: Device to lookup resource from
  @release: Look for resources associated with this release function
  @match: Match function (optional)
  @match_data: Data for the match function
  Find the latest devres of @dev which is associated with @release
  and for which @match returns 1.  If @match is NULL, it's considered
  to match all.
  RETURNS:
  Pointer to found devres, NULL if not found.
  devres_get - Find devres, if non-existent, add one atomically
  @dev: Device to lookup or add devres for
  @new_res: Pointer to new initialized devres to add if not found
  @match: Match function (optional)
  @match_data: Data for the match function
  Find the latest devres of @dev which has the same release function
  as @new_res and for which @match return 1.  If found, @new_res is
  freed; otherwise, @new_res is added atomically.
  RETURNS:
  Pointer to found or added devres.
  devres_remove - Find a device resource and remove it
  @dev: Device to find resource from
  @release: Look for resources associated with this release function
  @match: Match function (optional)
  @match_data: Data for the match function
  Find the latest devres of @dev associated with @release and for
  which @match returns 1.  If @match is NULL, it's considered to
  match all.  If found, the resource is removed atomically and
  returned.
  RETURNS:
  Pointer to removed devres on success, NULL if not found.
  devres_destroy - Find a device resource and destroy it
  @dev: Device to find resource from
  @release: Look for resources associated with this release function
  @match: Match function (optional)
  @match_data: Data for the match function
  Find the latest devres of @dev associated with @release and for
  which @match returns 1.  If @match is NULL, it's considered to
  match all.  If found, the resource is removed atomically and freed.
  Note that the release function for the resource will not be called,
  only the devres-allocated data will be freed.  The caller becomes
  responsible for freeing any other data.
  RETURNS:
  0 if devres is found and freed, -ENOENT if not found.
  devres_release - Find a device resource and destroy it, calling release
  @dev: Device to find resource from
  @release: Look for resources associated with this release function
  @match: Match function (optional)
  @match_data: Data for the match function
  Find the latest devres of @dev associated with @release and for
  which @match returns 1.  If @match is NULL, it's considered to
  match all.  If found, the resource is removed atomically, the
  release function called and the resource freed.
  RETURNS:
  0 if devres is found and freed, -ENOENT if not found.
	 First pass - move normal devres entries to @todo and clear
	  devres_group colors.
 clear color of group markers in the first pass 
 regular devres entry 
	 Second pass - Scan groups and color them.  A group gets
	  color value of two iff the group is wholly contained in
	  [current node, end). That is, for a closed group, both opening
	  and closing markers should be in the range, while just the
	  opening marker is enough for an open group.
			 No need to update current node or end. The removed
			  nodes are always before both.
	 Release.  Note that both devres and devres_group are
	  handled as devres in the following loop.  This is safe.
  devres_release_all - Release all managed resources
  @dev: Device to release resources for
  Release all resources associated with @dev.  This function is
  called on driver detach.
 Looks like an uninitialized device structure 
 Nothing to release if list is empty 
  devres_open_group - Open a new devres group
  @dev: Device to open devres group for
  @id: Separator ID
  @gfp: Allocation flags
  Open a new devres group for @dev with @id.  For @id, using a
  pointer to an object which won't be used for another group is
  recommended.  If @id is NULL, address-wise unique ID is created.
  RETURNS:
  ID of the new group, NULL on failure.
 Find devres group with ID @id.  If @id is NULL, look for the latest. 
  devres_close_group - Close a devres group
  @dev: Device to close devres group for
  @id: ID of target group, can be NULL
  Close the group identified by @id.  If @id is NULL, the latest open
  group is selected.
  devres_remove_group - Remove a devres group
  @dev: Device to remove group for
  @id: ID of target group, can be NULL
  Remove the group identified by @id.  If @id is NULL, the latest
  open group is selected.  Note that removing a group doesn't affect
  any other resources.
  devres_release_group - Release resources in a devres group
  @dev: Device to release group for
  @id: ID of target group, can be NULL
  Release all resources in the group identified by @id.  If @id is
  NULL, the latest open group is selected.  The selected group and
  groups properly nested inside the selected group are removed.
  RETURNS:
  The number of released non-group resources.
  Custom devres actions allow inserting a simple function call
  into the teadown sequence.
  devm_add_action() - add a custom action to list of managed resources
  @dev: Device that owns the action
  @action: Function that should be called
  @data: Pointer to data passed to @action implementation
  This adds a custom action to the list of managed resources so that
  it gets executed as part of standard resource unwinding.
  devm_remove_action() - removes previously added custom action
  @dev: Device that owns the action
  @action: Function implementing the action
  @data: Pointer to data passed to @action implementation
  Removes instance of @action previously added by devm_add_action().
  Both action and data should match one of the existing entries.
  devm_release_action() - release previously added custom action
  @dev: Device that owns the action
  @action: Function implementing the action
  @data: Pointer to data passed to @action implementation
  Releases and removes instance of @action previously added by
  devm_add_action().  Both action and data should match one of the
  existing entries.
  Managed kmallockfree
 noop 
  devm_kmalloc - Resource-managed kmalloc
  @dev: Device to allocate memory for
  @size: Allocation size
  @gfp: Allocation gfp flags
  Managed kmalloc.  Memory allocated with this function is
  automatically freed on driver detach.  Like all other devres
  resources, guaranteed alignment is unsigned long long.
  RETURNS:
  Pointer to allocated memory on success, NULL on failure.
 use raw alloc_dr for kmalloc caller tracing 
	
	  This is named devm_kzalloc_release for historical reasons
	  The initial implementation did not support kmalloc, only kzalloc
  devm_krealloc - Resource-managed krealloc()
  @dev: Device to re-allocate memory for
  @ptr: Pointer to the memory chunk to re-allocate
  @new_size: New allocation size
  @gfp: Allocation gfp flags
  Managed krealloc(). Resizes the memory chunk allocated with devm_kmalloc().
  Behaves similarly to regular krealloc(): if @ptr is NULL or ZERO_SIZE_PTR,
  it's the equivalent of devm_kmalloc(). If new_size is zero, it frees the
  previously allocated memory and returns ZERO_SIZE_PTR. This function doesn't
  change the order in which the release callback for the re-alloc'ed devres
  will be called (except when falling back to devm_kmalloc() or when freeing
  resources when new_size is zero). The contents of the memory are preserved
  up to the lesser of new and old sizes.
		
		  We cannot reliably realloc a const string returned by
		  devm_kstrdup_const().
	
	  If new size is smaller or equal to the actual number of bytes
	  allocated previously - just return the same pointer.
	
	  Otherwise: allocate new, larger chunk. We need to allocate before
	  taking the lock as most probably the caller uses GFP_KERNEL.
	
	  The spinlock protects the linked list against concurrent
	  modifications but not the resource itself.
	
	  We can copy the memory contents after releasing the lock as we're
	  no longer modyfing the list links.
	
	  Same for releasing the old devres - it's now been removed from the
	  list. This is also the reason why we must not use devm_kfree() - the
	  links are no longer valid.
  devm_kstrdup - Allocate resource managed space and
                 copy an existing string into that.
  @dev: Device to allocate memory for
  @s: the string to duplicate
  @gfp: the GFP mask used in the devm_kmalloc() call when
        allocating memory
  RETURNS:
  Pointer to allocated string on success, NULL on failure.
  devm_kstrdup_const - resource managed conditional string duplication
  @dev: device for which to duplicate the string
  @s: the string to duplicate
  @gfp: the GFP mask used in the kmalloc() call when allocating memory
  Strings allocated by devm_kstrdup_const will be automatically freed when
  the associated device is detached.
  RETURNS:
  Source string if it is in .rodata section otherwise it falls back to
  devm_kstrdup.
  devm_kvasprintf - Allocate resource managed space and format a string
 		     into that.
  @dev: Device to allocate memory for
  @gfp: the GFP mask used in the devm_kmalloc() call when
        allocating memory
  @fmt: The printf()-style format string
  @ap: Arguments for the format string
  RETURNS:
  Pointer to allocated string on success, NULL on failure.
  devm_kasprintf - Allocate resource managed space and format a string
 		    into that.
  @dev: Device to allocate memory for
  @gfp: the GFP mask used in the devm_kmalloc() call when
        allocating memory
  @fmt: The printf()-style format string
  @...: Arguments for the format string
  RETURNS:
  Pointer to allocated string on success, NULL on failure.
  devm_kfree - Resource-managed kfree
  @dev: Device this memory belongs to
  @p: Memory to free
  Free memory allocated with devm_kmalloc().
	
	  Special cases: pointer to a string in .rodata returned by
	  devm_kstrdup_const() or NULLZERO ptr.
  devm_kmemdup - Resource-managed kmemdup
  @dev: Device this memory belongs to
  @src: Memory region to duplicate
  @len: Memory region length
  @gfp: GFP mask to use
  Duplicate region of a memory using resource managed kmalloc
  devm_get_free_pages - Resource-managed __get_free_pages
  @dev: Device to allocate memory for
  @gfp_mask: Allocation gfp flags
  @order: Allocation size is (1 << order) pages
  Managed get_free_pages.  Memory allocated with this function is
  automatically freed on driver detach.
  RETURNS:
  Address of allocated memory on success, 0 on failure.
  devm_free_pages - Resource-managed free_pages
  @dev: Device this memory belongs to
  @addr: Memory to free
  Free memory allocated with devm_get_free_pages(). Unlike free_pages,
  there is no need to supply the @order.
  __devm_alloc_percpu - Resource-managed alloc_percpu
  @dev: Device to allocate per-cpu memory for
  @size: Size of per-cpu memory to allocate
  @align: Alignment of per-cpu memory to allocate
  Managed alloc_percpu. Per-cpu memory allocated with this function is
  automatically freed on driver detach.
  RETURNS:
  Pointer to allocated memory on success, NULL on failure.
  devm_free_percpu - Resource-managed free_percpu
  @dev: Device this memory belongs to
  @pdata: Per-cpu memory to free
  Free memory allocated with devm_alloc_percpu().
 SPDX-License-Identifier: GPL-2.0 
  Device core Trace Support
  Copyright (C) 2021, Intel Corporation
  Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
 SPDX-License-Identifier: GPL-2.0
  property.c - Unified device property interface.
  Copyright (C) 2014, Intel Corporation
  Authors: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
           Mika Westerberg <mika.westerberg@linux.intel.com>
  device_property_present - check if a property of a device is present
  @dev: Device whose property is being checked
  @propname: Name of the property
  Check if property @propname is present in the device firmware description.
  fwnode_property_present - check if a property of a firmware node is present
  @fwnode: Firmware node whose property to check
  @propname: Name of the property
  device_property_read_u8_array - return a u8 array property of a device
  @dev: Device to get the property of
  @propname: Name of the property
  @val: The values are stored here or %NULL to return the number of values
  @nval: Size of the @val array
  Function reads an array of u8 properties with @propname from the device
  firmware description and stores them to @val if found.
  Return: number of values if @val was %NULL,
          %0 if the property was found (success),
 	   %-EINVAL if given arguments are not valid,
 	   %-ENODATA if the property does not have a value,
 	   %-EPROTO if the property is not an array of numbers,
 	   %-EOVERFLOW if the size of the property is not as expected.
 	   %-ENXIO if no suitable firmware interface is present.
  device_property_read_u16_array - return a u16 array property of a device
  @dev: Device to get the property of
  @propname: Name of the property
  @val: The values are stored here or %NULL to return the number of values
  @nval: Size of the @val array
  Function reads an array of u16 properties with @propname from the device
  firmware description and stores them to @val if found.
  Return: number of values if @val was %NULL,
          %0 if the property was found (success),
 	   %-EINVAL if given arguments are not valid,
 	   %-ENODATA if the property does not have a value,
 	   %-EPROTO if the property is not an array of numbers,
 	   %-EOVERFLOW if the size of the property is not as expected.
 	   %-ENXIO if no suitable firmware interface is present.
  device_property_read_u32_array - return a u32 array property of a device
  @dev: Device to get the property of
  @propname: Name of the property
  @val: The values are stored here or %NULL to return the number of values
  @nval: Size of the @val array
  Function reads an array of u32 properties with @propname from the device
  firmware description and stores them to @val if found.
  Return: number of values if @val was %NULL,
          %0 if the property was found (success),
 	   %-EINVAL if given arguments are not valid,
 	   %-ENODATA if the property does not have a value,
 	   %-EPROTO if the property is not an array of numbers,
 	   %-EOVERFLOW if the size of the property is not as expected.
 	   %-ENXIO if no suitable firmware interface is present.
  device_property_read_u64_array - return a u64 array property of a device
  @dev: Device to get the property of
  @propname: Name of the property
  @val: The values are stored here or %NULL to return the number of values
  @nval: Size of the @val array
  Function reads an array of u64 properties with @propname from the device
  firmware description and stores them to @val if found.
  Return: number of values if @val was %NULL,
          %0 if the property was found (success),
 	   %-EINVAL if given arguments are not valid,
 	   %-ENODATA if the property does not have a value,
 	   %-EPROTO if the property is not an array of numbers,
 	   %-EOVERFLOW if the size of the property is not as expected.
 	   %-ENXIO if no suitable firmware interface is present.
  device_property_read_string_array - return a string array property of device
  @dev: Device to get the property of
  @propname: Name of the property
  @val: The values are stored here or %NULL to return the number of values
  @nval: Size of the @val array
  Function reads an array of string properties with @propname from the device
  firmware description and stores them to @val if found.
  Return: number of values read on success if @val is non-NULL,
 	   number of values available on success if @val is NULL,
 	   %-EINVAL if given arguments are not valid,
 	   %-ENODATA if the property does not have a value,
 	   %-EPROTO or %-EILSEQ if the property is not an array of strings,
 	   %-EOVERFLOW if the size of the property is not as expected.
 	   %-ENXIO if no suitable firmware interface is present.
  device_property_read_string - return a string property of a device
  @dev: Device to get the property of
  @propname: Name of the property
  @val: The value is stored here
  Function reads property @propname from the device firmware description and
  stores the value into @val if found. The value is checked to be a string.
  Return: %0 if the property was found (success),
 	   %-EINVAL if given arguments are not valid,
 	   %-ENODATA if the property does not have a value,
 	   %-EPROTO or %-EILSEQ if the property type is not a string.
 	   %-ENXIO if no suitable firmware interface is present.
  device_property_match_string - find a string in an array and return index
  @dev: Device to get the property of
  @propname: Name of the property holding the array
  @string: String to look for
  Find a given string in a string array and if it is found return the
  index back.
  Return: %0 if the property was found (success),
 	   %-EINVAL if given arguments are not valid,
 	   %-ENODATA if the property does not have a value,
 	   %-EPROTO if the property is not an array of strings,
 	   %-ENXIO if no suitable firmware interface is present.
  fwnode_property_read_u8_array - return a u8 array property of firmware node
  @fwnode: Firmware node to get the property of
  @propname: Name of the property
  @val: The values are stored here or %NULL to return the number of values
  @nval: Size of the @val array
  Read an array of u8 properties with @propname from @fwnode and stores them to
  @val if found.
  Return: number of values if @val was %NULL,
          %0 if the property was found (success),
 	   %-EINVAL if given arguments are not valid,
 	   %-ENODATA if the property does not have a value,
 	   %-EPROTO if the property is not an array of numbers,
 	   %-EOVERFLOW if the size of the property is not as expected,
 	   %-ENXIO if no suitable firmware interface is present.
  fwnode_property_read_u16_array - return a u16 array property of firmware node
  @fwnode: Firmware node to get the property of
  @propname: Name of the property
  @val: The values are stored here or %NULL to return the number of values
  @nval: Size of the @val array
  Read an array of u16 properties with @propname from @fwnode and store them to
  @val if found.
  Return: number of values if @val was %NULL,
          %0 if the property was found (success),
 	   %-EINVAL if given arguments are not valid,
 	   %-ENODATA if the property does not have a value,
 	   %-EPROTO if the property is not an array of numbers,
 	   %-EOVERFLOW if the size of the property is not as expected,
 	   %-ENXIO if no suitable firmware interface is present.
  fwnode_property_read_u32_array - return a u32 array property of firmware node
  @fwnode: Firmware node to get the property of
  @propname: Name of the property
  @val: The values are stored here or %NULL to return the number of values
  @nval: Size of the @val array
  Read an array of u32 properties with @propname from @fwnode store them to
  @val if found.
  Return: number of values if @val was %NULL,
          %0 if the property was found (success),
 	   %-EINVAL if given arguments are not valid,
 	   %-ENODATA if the property does not have a value,
 	   %-EPROTO if the property is not an array of numbers,
 	   %-EOVERFLOW if the size of the property is not as expected,
 	   %-ENXIO if no suitable firmware interface is present.
  fwnode_property_read_u64_array - return a u64 array property firmware node
  @fwnode: Firmware node to get the property of
  @propname: Name of the property
  @val: The values are stored here or %NULL to return the number of values
  @nval: Size of the @val array
  Read an array of u64 properties with @propname from @fwnode and store them to
  @val if found.
  Return: number of values if @val was %NULL,
          %0 if the property was found (success),
 	   %-EINVAL if given arguments are not valid,
 	   %-ENODATA if the property does not have a value,
 	   %-EPROTO if the property is not an array of numbers,
 	   %-EOVERFLOW if the size of the property is not as expected,
 	   %-ENXIO if no suitable firmware interface is present.
  fwnode_property_read_string_array - return string array property of a node
  @fwnode: Firmware node to get the property of
  @propname: Name of the property
  @val: The values are stored here or %NULL to return the number of values
  @nval: Size of the @val array
  Read an string list property @propname from the given firmware node and store
  them to @val if found.
  Return: number of values read on success if @val is non-NULL,
 	   number of values available on success if @val is NULL,
 	   %-EINVAL if given arguments are not valid,
 	   %-ENODATA if the property does not have a value,
 	   %-EPROTO or %-EILSEQ if the property is not an array of strings,
 	   %-EOVERFLOW if the size of the property is not as expected,
 	   %-ENXIO if no suitable firmware interface is present.
  fwnode_property_read_string - return a string property of a firmware node
  @fwnode: Firmware node to get the property of
  @propname: Name of the property
  @val: The value is stored here
  Read property @propname from the given firmware node and store the value into
  @val if found.  The value is checked to be a string.
  Return: %0 if the property was found (success),
 	   %-EINVAL if given arguments are not valid,
 	   %-ENODATA if the property does not have a value,
 	   %-EPROTO or %-EILSEQ if the property is not a string,
 	   %-ENXIO if no suitable firmware interface is present.
  fwnode_property_match_string - find a string in an array and return index
  @fwnode: Firmware node to get the property of
  @propname: Name of the property holding the array
  @string: String to look for
  Find a given string in a string array and if it is found return the
  index back.
  Return: %0 if the property was found (success),
 	   %-EINVAL if given arguments are not valid,
 	   %-ENODATA if the property does not have a value,
 	   %-EPROTO if the property is not an array of strings,
 	   %-ENXIO if no suitable firmware interface is present.
  fwnode_property_get_reference_args() - Find a reference with arguments
  @fwnode:	Firmware node where to look for the reference
  @prop:	The name of the property
  @nargs_prop:	The name of the property telling the number of
 		arguments in the referred node. NULL if @nargs is known,
 		otherwise @nargs is ignored. Only relevant on OF.
  @nargs:	Number of arguments. Ignored if @nargs_prop is non-NULL.
  @index:	Index of the reference, from zero onwards.
  @args:	Result structure with reference and integer arguments.
  Obtain a reference based on a named property in an fwnode, with
  integer arguments.
  Caller is responsible to call fwnode_handle_put() on the returned
  args->fwnode pointer.
  Returns: %0 on success
 	    %-ENOENT when the index is out of bounds, the index has an empty
 		     reference or the property was not found
 	    %-EINVAL on parse error
  fwnode_find_reference - Find named reference to a fwnode_handle
  @fwnode: Firmware node where to look for the reference
  @name: The name of the reference
  @index: Index of the reference
  @index can be used when the named reference holds a table of references.
  Returns pointer to the reference fwnode, or ERR_PTR. Caller is responsible to
  call fwnode_handle_put() on the returned fwnode pointer.
  device_remove_properties - Remove properties from a device object.
  @dev: Device whose properties to remove.
  The function removes properties previously associated to the device
  firmware node with device_add_properties(). Memory allocated to the
  properties will also be released.
  device_add_properties - Add a collection of properties to a device object.
  @dev: Device to add properties to.
  @properties: Collection of properties to add.
  Associate a collection of device properties represented by @properties with
  @dev. The function takes a copy of @properties.
  WARNING: The callers should not use this function if it is known that there
  is no real firmware node associated with @dev! In that case the callers
  should create a software node and assign it to @dev directly.
  fwnode_get_name - Return the name of a node
  @fwnode: The firmware node
  Returns a pointer to the node name.
  fwnode_get_name_prefix - Return the prefix of node for printing purposes
  @fwnode: The firmware node
  Returns the prefix of a node, intended to be printed right before the node.
  The prefix works also as a separator between the nodes.
  fwnode_get_parent - Return parent firwmare node
  @fwnode: Firmware whose parent is retrieved
  Return parent firmware node of the given node if possible or %NULL if no
  parent was available.
  fwnode_get_next_parent - Iterate to the node's parent
  @fwnode: Firmware whose parent is retrieved
  This is like fwnode_get_parent() except that it drops the refcount
  on the passed node, making it suitable for iterating through a
  node's parents.
  Returns a node pointer with refcount incremented, use
  fwnode_handle_node() on it when done.
  fwnode_get_next_parent_dev - Find device of closest ancestor fwnode
  @fwnode: firmware node
  Given a firmware node (@fwnode), this function finds its closest ancestor
  firmware node that has a corresponding struct device and returns that struct
  device.
  The caller of this function is expected to call put_device() on the returned
  device when they are done.
  fwnode_count_parents - Return the number of parents a node has
  @fwnode: The node the parents of which are to be counted
  Returns the number of parents a node has.
  fwnode_get_nth_parent - Return an nth parent of a node
  @fwnode: The node the parent of which is requested
  @depth: Distance of the parent from the node
  Returns the nth parent of a node. If there is no parent at the requested
  @depth, %NULL is returned. If @depth is 0, the functionality is equivalent to
  fwnode_handle_get(). For @depth == 1, it is fwnode_get_parent() and so on.
  The caller is responsible for calling fwnode_handle_put() for the returned
  node.
  fwnode_is_ancestor_of - Test if @test_ancestor is ancestor of @test_child
  @test_ancestor: Firmware which is tested for being an ancestor
  @test_child: Firmware which is tested for being the child
  A node is considered an ancestor of itself too.
  Returns true if @test_ancestor is an ancestor of @test_child.
  Otherwise, returns false.
  fwnode_get_next_child_node - Return the next child node handle for a node
  @fwnode: Firmware node to find the next child node for.
  @child: Handle to one of the node's child nodes or a %NULL handle.
  fwnode_get_next_available_child_node - Return the next
  available child node handle for a node
  @fwnode: Firmware node to find the next child node for.
  @child: Handle to one of the node's child nodes or a %NULL handle.
  device_get_next_child_node - Return the next child node handle for a device
  @dev: Device to find the next child node for.
  @child: Handle to one of the device's child nodes or a null handle.
 Try to find a child in primary fwnode 
 When no more children in primary, continue with secondary 
  fwnode_get_named_child_node - Return first matching named child node handle
  @fwnode: Firmware node to find the named child node for.
  @childname: String to match child node name against.
  device_get_named_child_node - Return first matching named child node handle
  @dev: Device to find the named child node for.
  @childname: String to match child node name against.
  fwnode_handle_get - Obtain a reference to a device node
  @fwnode: Pointer to the device node to obtain the reference to.
  Returns the fwnode handle.
  fwnode_handle_put - Drop reference to a device node
  @fwnode: Pointer to the device node to drop the reference to.
  This has to be used when terminating device_for_each_child_node() iteration
  with break or return to prevent stale device node references from being left
  behind.
  fwnode_device_is_available - check if a device is available for use
  @fwnode: Pointer to the fwnode of the device.
  For fwnode node types that don't implement the .device_is_available()
  operation, this function returns true.
  device_get_child_node_count - return the number of child nodes for device
  @dev: Device to cound the child nodes for
	 For DT, this is always supported.
	  For ACPI, this depends on CCA, which
	  is determined by the acpi_dma_supported().
  fwnode_get_phy_mode - Get phy mode for given firmware node
  @fwnode:	Pointer to the given node
  The function gets phy interface string from property 'phy-mode' or
  'phy-connection-type', and return its index in phy_modes table, or errno in
  error case.
  device_get_phy_mode - Get phy mode for given device
  @dev:	Pointer to the given device
  The function gets phy interface string from property 'phy-mode' or
  'phy-connection-type', and return its index in phy_modes table, or errno in
  error case.
  fwnode_irq_get - Get IRQ directly from a fwnode
  @fwnode:	Pointer to the firmware node
  @index:	Zero-based index of the IRQ
  Returns Linux IRQ number on success. Other values are determined
  accordingly to acpi_of_ irq_get() operation.
  fwnode_graph_get_next_endpoint - Get next endpoint firmware node
  @fwnode: Pointer to the parent firmware node
  @prev: Previous endpoint node or %NULL to get the first
  Returns an endpoint firmware node pointer or %NULL if no more endpoints
  are available.
	
	  If this function is in a loop and the previous iteration returned
	  an endpoint from fwnode->secondary, then we need to use the secondary
	  as parent rather than @fwnode.
  fwnode_graph_get_port_parent - Return the device fwnode of a port endpoint
  @endpoint: Endpoint firmware node of the port
  Return: the firmware node of the device the @endpoint belongs to.
  fwnode_graph_get_remote_port_parent - Return fwnode of a remote device
  @fwnode: Endpoint firmware node pointing to the remote endpoint
  Extracts firmware node of a remote device the @fwnode points to.
  fwnode_graph_get_remote_port - Return fwnode of a remote port
  @fwnode: Endpoint firmware node pointing to the remote endpoint
  Extracts firmware node of a remote port the @fwnode points to.
  fwnode_graph_get_remote_endpoint - Return fwnode of a remote endpoint
  @fwnode: Endpoint firmware node pointing to the remote endpoint
  Extracts firmware node of a remote endpoint the @fwnode points to.
  fwnode_graph_get_remote_node - get remote parent node for given portendpoint
  @fwnode: pointer to parent fwnode_handle containing graph portendpoint
  @port_id: identifier of the parent port node
  @endpoint_id: identifier of the endpoint node
  Return: Remote fwnode handle associated with remote endpoint node linked
 	   to @node. Use fwnode_node_put() on it when done.
  fwnode_graph_get_endpoint_by_id - get endpoint by port and endpoint numbers
  @fwnode: parent fwnode_handle containing the graph
  @port: identifier of the port node
  @endpoint: identifier of the endpoint node under the port node
  @flags: fwnode lookup flags
  Return the fwnode handle of the local endpoint corresponding the port and
  endpoint IDs or NULL if not found.
  If FWNODE_GRAPH_ENDPOINT_NEXT is passed in @flags and the specified endpoint
  has not been found, look for the closest endpoint ID greater than the
  specified one and return the endpoint that corresponds to it, if present.
  Do not return endpoints that belong to disabled devices, unless
  FWNODE_GRAPH_DEVICE_DISABLED is passed in @flags.
  The returned endpoint needs to be released by calling fwnode_handle_put() on
  it when it is not needed any more.
		
		  If the endpoint that has just been found is not the first
		  matching one and the ID of the one found previously is closer
		  to the requested endpoint ID, skip it.
  fwnode_graph_parse_endpoint - parse common endpoint node properties
  @fwnode: pointer to endpoint fwnode_handle
  @endpoint: pointer to the fwnode endpoint data structure
  Parse @fwnode representing a graph endpoint node and store the
  information in @endpoint. The caller must hold a reference to
  @fwnode.
  fwnode_connection_find_match - Find connection from a device node
  @fwnode: Device node with the connection
  @con_id: Identifier for the connection
  @data: Data for the match function
  @match: Function to check and convert the connection description
  Find a connection with unique identifier @con_id between @fwnode and another
  device node. @match will be used to convert the connection description to
  data the caller is expecting to be returned.
 SPDX-License-Identifier: GPL-2.0
  Memory subsystem support
  Written by Matt Tolentino <matthew.e.tolentino@intel.com>
             Dave Hansen <haveblue@us.ibm.com>
  This file provides the necessary infrastructure to represent
  a SPARSEMEM-memory-model system's physical memory in sysfs.
  All arch-independent code that assumes MEMORY_HOTPLUG requires
  SPARSEMEM should be contained here, or in mmmemory_hotplug.c.
  Memory blocks are cached in a local radix tree to avoid
  a costly linear search for the corresponding device on
  the subsystem bus.
  Memory groups, indexed by memory group id (mgid).
  Show the first physical section index (number) of this memory block.
  Legacy interface that we cannot remove. Always indicate "removable"
  with CONFIG_MEMORY_HOTREMOVE - bad heuristic.
  online, offline, going offline, etc.
	
	  We can probably put these states in a nice little array
	  so that they're not open-coded
	
	  Although vmemmap pages have a different lifecycle than the pages
	  they describe (they remain until the memory is unplugged), doing
	  their initialization and accounting at memory onliningofflining
	  stage helps to keep accounting easier to follow - e.g vmemmaps
	  belong to the same zone as the memory they backed.
	
	  Account once onlining succeeded. If the zone was unpopulated, it is
	  now already properly populated.
	
	  Unaccount before offlining, such that unpopulated zone and kthreads
	  can properly be torn down in offline_pages().
 offline_pages() failed. Account back. 
  MEMORY_HOTPLUG depends on SPARSEMEM in mmKconfig, so it is
  OK to have direct references to sparsemem variables in here.
 The device lock serializes operations on memory_subsys_[online|offline] 
	
	  When called via device_online() without configuring the online_type,
	  we want to default to MMOP_ONLINE.
 mem->online_type is protected by device_hotplug_lock 
 should never happen 
  Legacy interface that we cannot remove: s390x exposes the storage increment
  covered by a memory block, allowing for identifying which memory blocks
  comprise a storage increment. Since a memory block spans complete
  storage increments nowadays, this interface is basically unused. Other
  archs never exposed != 0.
	
	  Check the existing zone. Make sure that we do that only on the
	  online nodes otherwise the page_zone is not reliable
		
		  The block contains more than one zone can not be offlined.
		  This can happen e.g. for ZONE_DMA and ZONE_DMA32
  Show the memory block size (shared by all memory blocks).
  Memory auto online policy.
  Some architectures will have custom drivers to do this, and
  will not need to do it from userspace.  The fake hot-add code
  as well as ppc64 will do all of their discovery in userspace
  and will require this interface.
  Support for offlining pages of memory
 Soft offline a page 
 Forcibly offline a page, including killing processes. 
 See phys_device_show(). 
  A reference for the returned memory block device is acquired.
  Called under device_hotplug_lock.
  Called under device_hotplug_lock.
  register_memory - Setup a sysfs device for a memory block
 drop the ref. we got via find_memory_block() 
  Create memory block devices for the given memory area. Start and size
  have to be aligned to memory block granularity. Memory block devices
  will be initialized as offline.
  Called under device_hotplug_lock.
  Remove memory block devices for the given memory area. Start and size
  have to be aligned to memory block granularity. Memory block devices
  have to be offline.
  Called under device_hotplug_lock.
 return true if the memory block is offlined, otherwise, return false 
  Initialize the sysfs support for memory devices. At the time this function
  is called, we cannot have concurrent creationdeletion of memory block
  devices, the device_hotplug_lock is not needed.
 Validate the configured memory block size 
	
	  Create entries for memory sections that were found
	  during boot and have been initialized
  walk_memory_blocks - walk through all present memory blocks overlapped
 			by the range [start, start + size)
  @start: start address of the memory range
  @size: size of the memory range
  @arg: argument passed to func
  @func: callback for each memory section walked
  This function walks through all present memory blocks overlapped by the
  range [start, start + size), calling func on each memory block.
  In case func() returns an error, walking is aborted and the error is
  returned.
  Called under device_hotplug_lock.
  for_each_memory_block - walk through all present memory blocks
  @arg: argument passed to func
  @func: callback for each memory block walked
  This function walks through all present memory blocks, calling func on
  each memory block.
  In case func() returns an error, walking is aborted and the error is
  returned.
  This is an internal helper to unify allocation and initialization of
  memory groups. Note that the passed memory group will be copied to a
  dynamically allocated memory group. After this call, the passed
  memory group should no longer be used.
  memory_group_register_static() - Register a static memory group.
  @nid: The node id.
  @max_pages: The maximum number of pages we'll have in this static memory
 	       group.
  Register a new static memory group and return the memory group id.
  All memory in the group belongs to a single unit, such as a DIMM. All
  memory belonging to a static memory group is added in one go to be removed
  in one go -- it's static.
  Returns an error if out of memory, if the node id is invalid, if no new
  memory groups can be registered, or if max_pages is invalid (0). Otherwise,
  returns the new memory group id.
  memory_group_register_dynamic() - Register a dynamic memory group.
  @nid: The node id.
  @unit_pages: Unit in pages in which is memory addedremoved in this dynamic
 		memory group.
  Register a new dynamic memory group and return the memory group id.
  Memory within a dynamic memory group is addedremoved dynamically
  in unit_pages.
  Returns an error if out of memory, if the node id is invalid, if no new
  memory groups can be registered, or if unit_pages is invalid (0, not a
  power of two, smaller than a single memory block). Otherwise, returns the
  new memory group id.
  memory_group_unregister() - Unregister a memory group.
  @mgid: the memory group id
  Unregister a memory group. If any memory block still belongs to this
  memory group, unregistering will fail.
  Returns -EINVAL if the memory group id is invalid, returns -EBUSY if some
  memory blocks still belong to this memory group and returns 0 if
  unregistering succeeded.
  This is an internal helper only to be used in core memory hotplug code to
  lookup a memory group. We don't care about locking, as we don't expect a
  memory group to get unregistered while adding memory to it -- because
  the group and the memory is managed by the same driver.
  This is an internal helper only to be used in core memory hotplug code to
  walk all dynamic memory groups excluding a given memory group, either
  belonging to a specific node, or belonging to any node.
 CONFIG_NUMA 
 SPDX-License-Identifier: GPL-2.0
  ISA bus.
 SPDX-License-Identifier: GPL-2.0
  firmware fallback mechanism
 These getters are vetted to use int properly 
 These setters are vetted to use int properly 
  use small loading timeout for caching devices' firmware because all these
  firmware images have been loaded successfully at lease once, also system is
  ready for completing firmware loading now. The maximum size of firmware in
  current distributions is about 2M bytes, so 10 secs should be enough.
 Restores the timeout to the value last configured during normal operation 
	
	  There is a small window in which user can write to 'loading'
	  between loading doneaborted and disappearance of 'loading'
  timeout_store() - set number of seconds to wait for firmware
  @class: device class pointer
  @attr: device attribute pointer
  @buf: buffer to scan for timeout value
  @count: number of bytes in @buf
 	Sets the number of seconds to wait for the firmware.  Once
 	this expires an error will be returned to the driver and no
 	firmware will be provided.
 	Note: zero means 'wait forever'.
  firmware_loading_store() - set value in the 'loading' control file
  @dev: device pointer
  @attr: device attribute pointer
  @buf: buffer to scan for loading control value
  @count: number of bytes in @buf
 	The relevant values are:
 	 1: Start a load, discarding any previous partial load.
 	 0: Conclude the load and hand the data to the driver code.
 	-1: Conclude the load with an error and discard any written data.
 discarding any previous partial load 
			
			  Several loading requests may be pending on
			  one same firmware buf, so let all requests
			  see the mapped 'buf->data' once the loading
			  is completed.
			
			  Same logic as fw_load_abort, only the DONE bit
			  is ignored and we set ABORT only on failure.
  firmware_data_write() - write method for firmware
  @filp: open sysfs file
  @kobj: kobject for the device
  @bin_attr: bin_attr structure
  @buffer: buffer being written
  @offset: buffer offset for write in total data store area
  @count: buffer size
 	Data written to the 'data' attribute will be later handed to
 	the driver as a firmware image.
  fw_load_sysfs_fallback() - load a firmware via the sysfs fallback mechanism
  @fw_sysfs: firmware sysfs information for the firmware to load
  @timeout: timeout to wait for the load
  In charge of constructing a sysfs fallback interface for firmware loading.
 fall back on userspace loading 
 Also permit LSMs and IMA to fail firmware sysfs fallback 
  firmware_fallback_sysfs() - use the fallback mechanism to find firmware
  @fw: pointer to firmware image
  @name: name of firmware file to look for
  @device: device for which firmware is being loaded
  @opt_flags: options to control firmware loading behaviour, as defined by
 	       &enum fw_opt
  @ret: return value from direct lookup which triggered the fallback mechanism
  This function is called if direct lookup for the firmware failed, it enables
  a fallback mechanism through userspace by exposing a sysfs loading
  interface. Userspace is in charge of loading the firmware through the sysfs
  loading interface. This sysfs fallback mechanism may be disabled completely
  on a system by setting the proc sysctl value ignore_sysfs_fallback to true.
  If this is false we check if the internal API caller set the
  @FW_OPT_NOFALLBACK_SYSFS flag, if so it would also disable the fallback
  mechanism. A system may want to enforce the sysfs fallback mechanism at all
  times, it can do this by setting ignore_sysfs_fallback to false and
  force_sysfs_fallback to true.
  Enabling force_sysfs_fallback is functionally equivalent to build a kernel
  with CONFIG_FW_LOADER_USER_HELPER_FALLBACK.
 SPDX-License-Identifier: GPL-2.0
  firmware fallback configuration table
 SPDX-License-Identifier: GPL-2.0
 rc == -ENOENT when the fw was not found 
 SPDX-License-Identifier: GPL-2.0
  main.c - Multi purpose firmware loading support
  Copyright (c) 2003 Manuel Estrada Sainz
  Please see Documentationdriver-apifirmware for more information.
 firmware_buf instance will be added into the below list 
	
	  Names of firmware images which have been cached successfully
	  will be added into the below list so that device uncache
	  helper can trace which firmware images have been cached
	  before.
 fw_lock could be moved to 'struct fw_sysfs' but since it is just
 For a partial read, the buffer must be preallocated. 
 Only partial reads are allowed to use an offset. 
 Returns 1 for batching firmware requests with the same name 
	
	  Do not merge requests that are marked to be non-cached or
	  are performing partial reads.
 If the array of pages is too small, grow it 
 one pages buffer should be mappedunmapped only once 
  XZ-compressed firmware support
 show an error and return the standard error code 
 single-shot decompression onto the pre-allocated buffer 
 decompression on paged buffer and map it 
 decompress onto the new allocated page 
 partial decompression means either end or error 
 if the buffer is pre-allocated, we can perform in single-shot mode 
 CONFIG_FW_LOADER_COMPRESS 
 direct firmware loading support 
  Typical usage is that passing 'firmware_class.path=$CUSTOMIZED_PATH'
  from kernel command line because firmware_class is generally built in
  kernel instead of module.
 Already populated data member means we're loading into a buffer 
 skip the unset customized path 
		
		  The total file size is only examined when doing a partial
		  read; the "full read" case needs to fail if the whole
		  firmware was not completely loaded.
 load firmware files from the mount namespace of init 
 discard the superfluous original content 
 firmware holds the ownership of pages 
 Loaded directly? 
 store the pages buffer info firmware from buf 
 add firmware name into devres list 
	
	  add firmware name into devres list so that we can auto cache
	  and uncache firmware for device.
	 
	  device may has been deleted already, but the problem
	  should be fixed in devres or driver core.
 don't cache firmware handled without uevent 
	
	  After caching firmware image is started, let it piggyback
	  on request firmware.
 pass the pages buffer to driver at the last minute 
 prepare firmware and firmware_buf structs;
  return 0 if a firmware is already assigned, 1 if need to load one,
  or a negative error code
 assigned 
	
	  bind with 'priv' now to avoid warning in failure path
	  of requesting firmware.
 assigned 
 need to load 
  Batched requests need only one wake, we need to do this step last due to the
  fallback mechanism. The buf is protected with kref_get(), and it won't be
  released until the last user calls release_firmware().
  Failed batched requests are possible as well, in such cases we just share
  the struct fw_priv and won't release it until all requests are woken
  and have gone through this same path.
 Loaded directly? 
 called from request_firmware() and request_firmware_work_func() 
 error or already assigned 
 Only full reads can support decompression, platform, and sysfs. 
  request_firmware() - send firmware request and wait for it
  @firmware_p: pointer to firmware image
  @name: name of firmware file
  @device: device for which firmware is being loaded
       @firmware_p will be used to return a firmware image by the name
       of @name for device @device.
       Should be called from user context where sleeping is allowed.
       @name will be used as $FIRMWARE in the uevent environment and
       should be distinctive enough not to be confused with any other
       firmware image for this or any other device.
 	Caller must hold the reference count of @device.
 	The function can be called safely inside device's suspend and
 	resume callback.
 Need to pin this module until return 
  firmware_request_nowarn() - request for an optional fw module
  @firmware: pointer to firmware image
  @name: name of firmware file
  @device: device for which firmware is being loaded
  This function is similar in behaviour to request_firmware(), except it
  doesn't produce warning messages when the file is not found. The sysfs
  fallback mechanism is enabled if direct filesystem lookup fails. However,
  failures to find the firmware file with it are still suppressed. It is
  therefore up to the driver to check for the return value of this call and to
  decide when to inform the users of errors.
 Need to pin this module until return 
  request_firmware_direct() - load firmware directly without usermode helper
  @firmware_p: pointer to firmware image
  @name: name of firmware file
  @device: device for which firmware is being loaded
  This function works pretty much like request_firmware(), but this doesn't
  fall back to usermode helper even if the firmware couldn't be loaded
  directly from fs.  Hence it's useful for loading optional firmwares, which
  aren't always present, without extra long timeouts of udev.
  firmware_request_platform() - request firmware with platform-fw fallback
  @firmware: pointer to firmware image
  @name: name of firmware file
  @device: device for which firmware is being loaded
  This function is similar in behaviour to request_firmware, except that if
  direct filesystem lookup fails, it will fallback to looking for a copy of the
  requested firmware embedded in the platform's main (e.g. UEFI) firmware.
 Need to pin this module until return 
  firmware_request_cache() - cache firmware for suspend so resume can use it
  @name: name of firmware file
  @device: device for which firmware should be cached for
  There are some devices with an optimization that enables the device to not
  require loading firmware on system reboot. This optimization may still
  require the firmware present on resume from suspend. This routine can be
  used to ensure the firmware is present on resume from suspend in these
  situations. This helper is not compatible with drivers which use
  request_firmware_into_buf() or request_firmware_nowait() with no uevent set.
  request_firmware_into_buf() - load firmware into a previously allocated buffer
  @firmware_p: pointer to firmware image
  @name: name of firmware file
  @device: device for which firmware is being loaded and DMA region allocated
  @buf: address of buffer to load firmware into
  @size: size of buffer
  This function works pretty much like request_firmware(), but it doesn't
  allocate a buffer to hold the firmware data. Instead, the firmware
  is loaded directly into the buffer pointed to by @buf and the @firmware_p
  data member is pointed at @buf.
  This function doesn't cache firmware either.
  request_partial_firmware_into_buf() - load partial firmware into a previously allocated buffer
  @firmware_p: pointer to firmware image
  @name: name of firmware file
  @device: device for which firmware is being loaded and DMA region allocated
  @buf: address of buffer to load firmware into
  @size: size of buffer
  @offset: offset into file to read
  This function works pretty much like request_firmware_into_buf except
  it allows a partial read of the file.
  release_firmware() - release the resource associated with a firmware image
  @fw: firmware resource to release
 Async support 
 taken in request_firmware_nowait() 
  request_firmware_nowait() - asynchronous version of request_firmware
  @module: module requesting the firmware
  @uevent: sends uevent to copy the firmware image if this flag
 	is non-zero else the firmware copy must be done manually.
  @name: name of firmware file
  @device: device for which firmware is being loaded
  @gfp: allocation flags
  @context: will be passed over to @cont, and
 	@fw may be %NULL if firmware request fails.
  @cont: function will be called asynchronously when the firmware
 	request is over.
 	Caller must hold the reference count of @device.
 	Asynchronous variant of request_firmware() for user contexts:
 		- sleep for as small periods as possible since it may
 		  increase kernel boot time of built-in device drivers
 		  requesting firmware in their ->probe() methods, if
 		  @gfp is GFP_KERNEL.
 		- can't sleep at all if @gfp is GFP_ATOMIC.
  cache_firmware() - cache one firmware image in kernel memory space
  @fw_name: the firmware image name
  Cache firmware in kernel memory so that drivers can use it when
  system isn't ready for them to request firmware image from userspace.
  Once it returns successfully, driver can use request_firmware or its
  nowait version to get the cached firmware without any interacting
  with userspace
  Return 0 if the firmware image has been cached successfully
  Return !0 otherwise
  uncache_firmware() - remove one cached firmware image
  @fw_name: the firmware image name
  Uncache one firmware image which has been cached successfully
  before.
  Return 0 if the firmware cache has been removed successfully
  Return !0 otherwise
 called with dev->devres_lock held 
 only one cache entry for one firmware 
  device_cache_fw_images() - cache devices' firmware
  If one device called request_firmware or its nowait version
  successfully before, the firmware names are recored into the
  device's devres link list, so device_cache_fw_images can call
  cache_firmware() to cache these firmwares for the device,
  then the device driver can load its firmwares easily at
  time when system is not ready to complete loading firmware.
 cancel uncache work 
 wait for completion of caching firmware for all devices 
  device_uncache_fw_images() - uncache devices' firmware
  uncache all firmwares which have been cached successfully
  by device_uncache_fw_images earlier
  device_uncache_fw_images_delay() - uncache devices firmwares
  @delay: number of milliseconds to delay uncache device firmwares
  uncache all devices's firmwares which has been cached successfully
  by device_cache_fw_images after @delay milliseconds.
		
		  kill pending fallback requests with a custom fallback
		  to avoid stalling suspend.
		
		  In case that system sleep failed and syscore_suspend is
		  not called.
 stop caching firmware once syscore_suspend is reached 
	
	  Kill all pending fallback requests to avoid both stalling shutdown,
	  and avoid a deadlock with the usermode_lock.
 No need to unfold these on exit 
 SPDX-License-Identifier: GPL-2.0
 Builtin firmware support 
 Only if FW_LOADER=y 
  firmware_request_builtin() - load builtin firmware
  @fw: pointer to firmware struct
  @name: name of firmware file
  Some use cases in the kernel have a requirement so that no memory allocator
  is involved as these calls take place early in boot process. An example is
  the x86 CPU microcode loader. In these cases all the caller wants is to see
  if the firmware was built-in and if so use it right away. This can be used
  for such cases.
  This looks for the firmware in the built-in kernel. Only if the kernel was
  built-in with the firmware you are looking for will this return successfully.
  Callers of this API do not need to use release_firmware() as the pointer to
  the firmware is expected to be provided locally on the stack of the caller.
  firmware_request_builtin_buf() - load builtin firmware into optional buffer
  @fw: pointer to firmware struct
  @name: name of firmware file
  @buf: If set this lets you use a pre-allocated buffer so that the built-in
 	firmware into is copied into. This field can be NULL. It is used by
 	callers such as request_firmware_into_buf() and
 	request_partial_firmware_into_buf()
  @size: if buf was provided, the max size of the allocated buffer available.
 	If the built-in firmware does not fit into the pre-allocated @buf this
 	call will fail.
  This looks for the firmware in the built-in kernel. Only if the kernel was
  built-in with the firmware you are looking for will this call possibly
  succeed. If you passed a @buf the firmware will be copied into it iff the
  built-in firmware fits into the pre-allocated buffer size specified in
  @size.
  This caller is to be used internally by the firmware_loader only.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2014 Google, Inc.
 5 sec 
	
	  Determine if we have hit the "timeout" limit for the test if we
	  have then report it as an error, otherwise we wil sleep for the
	  required amount of time and then report completion.
	
	  Report NUMA mismatch if device node is set and we are not
	  performing an async init on that node.
	
	  The async events should have completed while we were taking care
	  of the synchronous events. We will now terminate any outstanding
	  asynchronous probe calls remaining by forcing timeout and remove
	  the driver before we return which should force the flush of the
	  pending asynchronous probe calls.
	 
	  Otherwise if they completed without errors or warnings then
	  report successful completion.
	
	  If err is already set then count that as an additional error for
	  the test. Otherwise we will report an invalid argument error and
	  not count that as we should have reached here as a result of
	  errors or warnings being reported by the probe routine.
 SPDX-License-Identifier: GPL-2.0
 Unit tests for property entries API
 Copyright 2019 Google LLC.
 Count 64-bit values as 16-bit 
 Count 64-bit values as 16-bit 
 Other way around 
 asking for more data returns what we have 
 NULL argument -> returns size 
 accessing array as single value 
 Verifies that small U8 array is stored inline when property is copied 
 Verifies that single string array is stored inline when property is copied 
 Handling of reference properties 
 wrong index 
 asking for more args, padded with zero data 
 wrong index 
 array of references 
 second reference in the array 
 wrong index 
 SPDX-License-Identifier: GPL-2.0
 Register cache access API - rbtree caching support
 Copyright 2011 Wolfson Microelectronics plc
 Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
 block of adjacent registers 
 Which registers are present 
 base register handled by this block 
 number of registers available in the block 
 the actual rbtree node holding this block 
 base and top registers of the current rbnode 
 base register of the rbnode to be added 
 if this register has already been inserted, just return 
 insert the node into the rbtree 
 if we've already been called then just return 
 free up the rbtree 
 release the resources 
 insert the register value in the correct place in the rbnode block 
 update the rbnode block, its size and the base register 
 If there is a read table then use it to guess at an allocation 
	 if we can't locate it in the cached rbnode we'll have
	  to traverse the rbtree looking for it.
 look for an adjacent register to the one we are about to add 
			
			  Keep looking, we want to choose the closest block,
			  otherwise we might end up creating overlapping
			  blocks, which breaks the rbtree.
		 We did not manage to find a place to insert it in
		  an existing block so create a new rbnode.
 SPDX-License-Identifier: GPL-2.0
 Register map access API - debugfs
 Copyright 2011 Wolfson Microelectronics plc
 Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
 Calculate the length of a fixed format  
  Work out where the start offset maps into register numbers, bearing
  in mind that we suppress hidden registers.
 Suppress the cache if we're using a subrange 
	
	  If we don't have a cache build one so we don't have to do a
	  linear scan each time.
 Skip unprinted registers, closing off cache entry 
 No cache entry?  Start a new one 
 Close the last entry off if we didn't scan beyond it 
	
	  This should never happen; we return above if we fail to
	  allocate and we should never be in this code if there are
	  no registers at all.
 Find the relevant block:offset 
 Calculate the length of a fixed format  
 : \n 
 Work out which register we're starting at 
 If we're in the region the user is trying to read 
 ...but not beyond it 
 Format the register 
 Format the value, write all X if we can't read 
  This can be dangerous especially when we have clients such as
  PMICs, therefore don't provide any real compile time configuration option
  for this feature, people who want to use this will need to modify
  the source code directly.
 Userspace has been fiddling around behind the kernel's back 
	 While we are at it, build the register dump cache
	  now so the read() operation on the `registers' file
	  can benefit from using the cache.  We do not care
	  about the file position information that is contained
	 Reset file pointer as the fixed-format of the `registers'
 Ignore registers which are neither readable nor writable 
 Format the register 
 Ignore malforned data like debugfs_write_file_bool() 
 Ignore malforned data like debugfs_write_file_bool() 
	
	  Userspace can initiate reads from the hardware over debugfs.
	  Normally internal regmap structures and buffers are protected with
	  a mutex or a spinlock, but if the regmap owner decided to disable
	  all locking mechanisms, this is no longer the case. For safety:
	  don't create the debugfs entries if locking is disabled.
 If we don't have the debugfs root yet, postpone init 
 SPDX-License-Identifier: GPL-2.0
 Register cache access API - flat caching support
 Copyright 2012 Wolfson Microelectronics plc
 Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
 SPDX-License-Identifier: GPL-2.0
 Register map access API - W1 (1-Wire) support
 Copyright (c) 2017 Radioavionica Corporation
 Author: Alex A. Mihaylov <minimumlaw@rambler.ru>
  1-Wire slaves registers with addess 8 bit and data 8 bit
  1-Wire slaves registers with addess 8 bit and data 16 bit
  1-Wire slaves registers with addess 16 bit and data 16 bit
  Various types of supported bus addressing
 SPDX-License-Identifier: GPL-2.0
 Register map access API - I2C support
 Copyright 2011 Wolfson Microelectronics plc
 Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
	 If the I2C controller can't do a gather tell the core, it
	  will substitute in a linear write for us.
 Current Address Read 
 everything else is not supported 
 SPDX-License-Identifier: GPL-2.0
 Register cache access API - LZO caching support
 Copyright 2011 Wolfson Microelectronics plc
 Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
	
	  allocate a bitmap to be used when syncing the cache with
	  the hardware.  Each time a register is modified, the corresponding
	  bit is set in the bitmap, so we know that we have to sync
	  that register.
 allocate the lzo blocks and initialize them 
 alloc the working space for the compressed block 
 compress the register map and fill the lzo blocks 
	
	  the pointer to the bitmap used for syncing the cache
	  is shared amongst all lzo_blocks.  Ensure it is freed
	  only once.
 each lzo_block is a pointer returned by kmalloc or NULL 
 index of the compressed lzo block 
 register index within the decompressed block 
 save the pointer and length of the compressed block 
 prepare the source to be the compressed block 
 decompress the block 
 fetch the value from the cache 
 restore the pointer and length of the compressed block 
 index of the compressed lzo block 
 register index within the decompressed block 
 save the pointer and length of the compressed block 
 prepare the source to be the compressed block 
 decompress the block 
 write the new value to the cache 
 prepare the source to be the decompressed block 
 compress the block 
 set the bit so we know we have to sync this register 
 Is this the hardware default?  If so skip. 
 SPDX-License-Identifier: GPL-2.0
 Register map access API - SCCB support
  sccb_is_available - Check if the adapter supports SCCB protocol
  @adap: I2C adapter
  Return true if the I2C adapter is capable of using SCCB helper functions,
  false otherwise.
	
	  If we ever want support for hardware doing SCCB natively, we will
	  introduce a sccb_xfer() callback to struct i2c_algorithm and check
	  for it here.
  regmap_sccb_read - Read data from SCCB slave device
  @context: Device that will be interacted with
  @reg: Register to be read from
  @val: Pointer to store read value
  This executes the 2-phase write transmission cycle that is followed by a
  2-phase read transmission cycle, returning negative errno else zero on
  success.
  regmap_sccb_write - Write data to SCCB slave device
  @context: Device that will be interacted with
  @reg: Register to write to
  @val: Value to be written
  This executes the SCCB 3-phase write transmission cycle, returning negative
  errno else zero on success.
 SPDX-License-Identifier: GPL-2.0
 regmap based irq_chip
 Copyright 2011 Wolfson Microelectronics plc
 Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
 Assume linear mapping 
	
	  If there's been a change in the mask write it back to the
	  hardware.  We rely on the use of the regmap core cache to
	  suppress pointless writes.
 set mask with mask_base register 
 clear mask with unmask_base register 
		
		  Ack all the masked interrupts unconditionally,
		  OR if there is masked interrupt which hasn't been Acked,
		  it'll be ignored in irq handler, then may introduce irq storm
 some chips ack by write 0 
 Don't update the type bits if we're using mask bits for irq type. 
 If we've changed our wakeup count propagate it to the parent 
	
	  The type_in_mask flag means that the underlying hardware uses
	  separate mask bits for rising and falling edge interrupts, but
	  we want to make them into a single virtual interrupt with
	  configurable edge.
	 
	  If the interrupt we're enabling defines the falling or rising
	  masks then instead of using the regular mask bits for this
	  interrupt, use the value previously written to the type buffer
	  at the corresponding offset in regmap_irq_set_type().
 Assume linear mapping 
	
	  Read only registers with active IRQs if the chip has 'main status
	  register'. Else read in the statuses, using a single bulk read if
	  possible in order to reduce the IO overheads.
 Clear the status buf as we don't read all status regs 
		 We could support bulk read for main status registers
		  but I don't expect to see devices with really many main
		  status registers so let's only support single reads for the
		  sake of simplicity. and add bulk reads only if needed
 Read sub registers with active IRQs 
	
	  Ignore masked IRQs and ack if we need to; we ack early so
	  there is no race between handling and acknowleding the
	  interrupt.  We assume that typically few of the interrupts
	  will fire simultaneously so don't worry about overhead from
	  doing a write per register.
  regmap_add_irq_chip_fwnode() - Use standard regmap IRQ controller handling
  @fwnode: The firmware node where the IRQ domain should be added to.
  @map: The regmap for the device.
  @irq: The IRQ the device uses to signal interrupts.
  @irq_flags: The IRQF_ flags to use for the primary interrupt.
  @irq_base: Allocate at specific IRQ number if irq_base > 0.
  @chip: Configuration for the interrupt controller.
  @data: Runtime data structure for the controller, allocated on success.
  Returns 0 on success or an errno on failure.
  In order for this to be efficient the chip really should use a
  register cache.  The chip driver is responsible for restoring the
  register values used by the IRQ controller over suspend and resume.
		
		  Create virt_buf[chip->num_extra_config_regs][chip->num_regs]
 Mask all the interrupts by default 
 Ack masked but set interrupts 
 Wake is disabled by default 
 Should really dispose of the domain but... 
  regmap_add_irq_chip() - Use standard regmap IRQ controller handling
  @map: The regmap for the device.
  @irq: The IRQ the device uses to signal interrupts.
  @irq_flags: The IRQF_ flags to use for the primary interrupt.
  @irq_base: Allocate at specific IRQ number if irq_base > 0.
  @chip: Configuration for the interrupt controller.
  @data: Runtime data structure for the controller, allocated on success.
  Returns 0 on success or an errno on failure.
  This is the same as regmap_add_irq_chip_fwnode, except that the firmware
  node of the regmap is used.
  regmap_del_irq_chip() - Stop interrupt handling for a regmap IRQ chip
  @irq: Primary IRQ for the device
  @d: &regmap_irq_chip_data allocated by regmap_add_irq_chip()
  This function also disposes of all mapped IRQs on the chip.
 Dispose all virtual irq from irq domain before removing it 
 Ignore hwirq if holes in the IRQ list 
		
		  Find the virtual irq of hwirq on chip and if it is
		  there then dispose it
  devm_regmap_add_irq_chip_fwnode() - Resource managed regmap_add_irq_chip_fwnode()
  @dev: The device pointer on which irq_chip belongs to.
  @fwnode: The firmware node where the IRQ domain should be added to.
  @map: The regmap for the device.
  @irq: The IRQ the device uses to signal interrupts
  @irq_flags: The IRQF_ flags to use for the primary interrupt.
  @irq_base: Allocate at specific IRQ number if irq_base > 0.
  @chip: Configuration for the interrupt controller.
  @data: Runtime data structure for the controller, allocated on success
  Returns 0 on success or an errno on failure.
  The &regmap_irq_chip_data will be automatically released when the device is
  unbound.
  devm_regmap_add_irq_chip() - Resource manager regmap_add_irq_chip()
  @dev: The device pointer on which irq_chip belongs to.
  @map: The regmap for the device.
  @irq: The IRQ the device uses to signal interrupts
  @irq_flags: The IRQF_ flags to use for the primary interrupt.
  @irq_base: Allocate at specific IRQ number if irq_base > 0.
  @chip: Configuration for the interrupt controller.
  @data: Runtime data structure for the controller, allocated on success
  Returns 0 on success or an errno on failure.
  The &regmap_irq_chip_data will be automatically released when the device is
  unbound.
  devm_regmap_del_irq_chip() - Resource managed regmap_del_irq_chip()
  @dev: Device for which which resource was allocated.
  @irq: Primary IRQ for the device.
  @data: &regmap_irq_chip_data allocated by regmap_add_irq_chip().
  A resource managed version of regmap_del_irq_chip().
  regmap_irq_chip_get_base() - Retrieve interrupt base for a regmap IRQ chip
  @data: regmap irq controller to operate on.
  Useful for drivers to request their own IRQs.
  regmap_irq_get_virq() - Map an interrupt on a chip to a virtual IRQ
  @data: regmap irq controller to operate on.
  @irq: index of the interrupt requested in the chip IRQs.
  Useful for drivers to request their own IRQs.
 Handle holes in the IRQ list 
  regmap_irq_get_domain() - Retrieve the irq_domain for the chip
  @data: regmap_irq controller to operate on.
  Useful for drivers to request their own IRQs and for integration
  with subsystems.  For ease of integration NULL is accepted as a
  domain, allowing devices to just call this even if no domain is
  allocated.
 SPDX-License-Identifier: GPL-2.0
 Register map access API - SPMI support
 Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
 Based on regmap-i2c.c:
 Copyright 2011 Wolfson Microelectronics plc
 Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
	
	  SPMI defines a more bandwidth-efficient 'Register 0 Write' sequence,
	  use it when possible.
	
	  Split accesses into two to take advantage of the more
	  bandwidth-efficient 'Extended Register Read' command when possible
 SPDX-License-Identifier: GPL-2.0
 Register map access API - AC'97 support
 Copyright 2013 Linaro Ltd.  All rights reserved.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2017, Linaro Ltd.
 SPDX-License-Identifier: GPL-2.0
 Clause-45 mask includes the device type (5 bit) and actual register number (16 bit) 
 SPDX-License-Identifier: GPL-2.0
 Register cache access API
 Copyright 2011 Wolfson Microelectronics plc
 Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
 calculate the size of reg_defaults 
 all registers are unreadable or volatile, so just bypass 
 Bypass the cache access till data read from HW 
 fill the reg_defaults 
	 We still need to ensure that the reg_defaults
	  won't vanish from under us.  We'll need to make
	  a copy of it.
		 Some devices such as PMICs don't have cache defaults,
		  we cope with this by reading back the HW registers and
		  crafting the cache defaults by hand.
  regcache_read - Fetch the value of a given register from the cache.
  @map: map to configure.
  @reg: The register index.
  @value: The value to be returned.
  Return a negative value on failure, 0 on success.
  regcache_write - Set the value of a given register in the cache.
  @map: map to configure.
  @reg: The register index.
  @value: The new register value.
  Return a negative value on failure, 0 on success.
 If we don't know the chip just got reset, then sync everything. 
 Is this the hardware default?  If so skip. 
  regcache_sync - Sync the register cache with the hardware.
  @map: map to configure.
  Any registers that should not be synced should be marked as
  volatile.  In general drivers can choose not to use the provided
  syncing functionality if they so require.
  Return a negative value on failure, 0 on success.
 Remember the initial bypass state 
 Apply any patch first 
 Restore the bypass state 
  regcache_sync_region - Sync part  of the register cache with the hardware.
  @map: map to sync.
  @min: first register to sync
  @max: last register to sync
  Write all non-default register values in the specified region to
  the hardware.
  Return a negative value on failure, 0 on success.
 Remember the initial bypass state 
 Restore the bypass state 
  regcache_drop_region - Discard part of the register cache
  @map: map to operate on
  @min: first register to discard
  @max: last register to discard
  Discard part of the register cache.
  Return a negative value on failure, 0 on success.
  regcache_cache_only - Put a register map into cache only mode
  @map: map to configure
  @enable: flag if changes should be written to the hardware
  When a register map is marked as cache only writes to the register
  map API will only update the register cache, they will not cause
  any hardware changes.  This is useful for allowing portions of
  drivers to act as though the device were functioning as normal when
  it is disabled for power saving reasons.
  regcache_mark_dirty - Indicate that HW registers were reset to default values
  @map: map to mark
  Inform regcache that the device has been powered down or reset, so that
  on resume, regcache_sync() knows to write out all non-default values
  stored in the cache.
  If this function is not called, regcache_sync() will assume that
  the hardware state still matches the cache state, modulo any writes that
  happened when cache_only was true.
  regcache_cache_bypass - Put a register map into cache bypass mode
  @map: map to configure
  @enable: flag if changes should not be written to the cache
  When a register map is marked with the cache bypass option, writes
  to the register map API will only update the hardware and not the
  the cache directly.  This is useful when syncing the cache back to
  the hardware.
 Use device native format if possible 
 Use device native format if possible 
 unreachable 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2015-17 Intel Corporation.
 All register are 8-bits wide as per MIPI Soundwire 1.0 Spec 
 Registers are 32 bits wide 
 SPDX-License-Identifier: GPL-2.0
 Register map access API - SPI AVMM support
 Copyright (C) 2018-2020 Intel Corporation. All rights reserved.
  This driver implements the regmap operations for a generic SPI
  master to access the registers of the spi slave chip which has an
  Avalone bus in it.
  The "SPI slave to Avalon Master Bridge" (spi-avmm) IP should be integrated
  in the spi slave chip. The IP acts as a bridge to convert encoded streams of
  bytes from the host to the internal register readwrite on Avalon bus. In
  order to issue register access requests to the slave chip, the host should
  send formatted bytes that conform to the transfer protocol.
  The transfer protocol contains 3 layers: transaction layer, packet layer
  and physical layer.
  Reference Documents could be found at:
  https:www.intel.comcontentwwwusenprogrammabledocumentationsfo1400787952932.html
  Chapter "SPI SlaveJTAG to Avalon Master Bridge Cores" is a general
  introduction to the protocol.
  Chapter "Avalon Packets to Transactions Converter Core" describes
  the transaction layer.
  Chapter "Avalon-ST Bytes to Packets and Packets to Bytes Converter Cores"
  describes the packet layer.
  Chapter "Avalon-ST Serial Peripheral Interface Core" describes the
  physical layer.
  When host issues a regmap readwrite, the driver will transform the request
  to byte stream layer by layer. It formats the register addr, value and
  length to the transaction layer request, then converts the request to packet
  layer bytes stream and then to physical layer bytes stream. Finally the
  driver sends the formatted byte stream over SPI bus to the slave chip.
  The spi-avmm IP on the slave chip decodes the byte stream and initiates
  register readwrite on its internal Avalon bus, and then encodes the
  response to byte stream and sends back to host.
  The driver receives the byte stream, reverses the 3 layers transformation,
  and finally gets the response value (read out data for register read,
  successful written size for register write).
 slave's register addr is 32 bits 
 slave's register value is 32 bits 
  max rx size could be larger. But considering the buffer consuming,
  it is proper that we limit 1KB xfer at max.
  In transaction layer,
  the write request format is: Transaction request header + data
  the read request format is: Transaction request header
  the write response format is: Transaction response header
  the read response format is: pure data, no Transaction response header
 tx & rx share one transaction layer buffer 
  In tx phase, the host prepares all the phy layer bytes of a request in the
  phy buffer and sends them in a batch.
  The packet layer and physical layer defines several special chars for
  various purpose, when a transaction layer byte hits one of these special
  chars, it should be escaped. The escape rule is, "Escape char first,
  following the byte XOR'ed with 0x20".
  This macro defines the max possible length of the phy data. In the worst
  case, all transaction layer bytes need to be escaped (so the data length
  doubles), plus 4 special chars (SOP, CHANNEL, CHANNEL_NUM, EOP). Finally
  we should make sure the length is aligned to SPI BPW.
  Unlike tx, phy rx is affected by possible PHY_IDLE bytes from slave, the max
  length of the rx bit stream is unpredictable. So the driver reads the words
  one by one, and parses each word immediately into transaction layer buffer.
  Only one word length of phy buffer is used for rx.
  struct spi_avmm_bridge - SPI slave to AVMM bus master bridge
  @spi: spi slave associated with this bridge.
  @word_len: bytes of word for spi transfer.
  @trans_len: length of valid data in trans_buf.
  @phy_len: length of valid data in phy_buf.
  @trans_buf: the bridge buffer for transaction layer data.
  @phy_buf: the bridge buffer for physical layer data.
  @swap_words: the word swapping cb for phy data. NULL if not needed.
  As a device's registers are implemented on the AVMM bus address space, it
  requires the driver to issue formatted requests to spi slave to AVMM bus
  master bridge to perform register access.
 bridge buffer used in translation between protocol layers 
  Format transaction layer data in br->trans_buf according to the register
  access request, Store valid transaction layer data length in br->trans_len.
 Store valid trans data length for next layer 
  Convert transaction layer data (in br->trans_buf) to phy layer data, store
  them in br->phy_buf. Pad the phy_buf aligned with SPI's BPW. Store valid phy
  layer data length in br->phy_len.
  phy_buf len should be aligned with SPI's BPW. Spare bytes should be padded
  with PHY_IDLE, then the slave will just drop them.
  The driver will not simply pad 4a at the tail. The concern is that driver
  will not store MISO data during tx phase, if the driver pads 4a at the tail,
  it is possible that if the slave is fast enough to response at the padding
  time. As a result these rx bytes are lost. In the following case, 7a,7c,00
  will lost.
  MOSI ...|7a|7c|00|10| |00|00|04|02| |4b|7d|5a|7b| |40|4a|4a|4a| |XX|XX|...
  MISO ...|4a|4a|4a|4a| |4a|4a|4a|4a| |4a|4a|4a|4a| |4a|7a|7c|00| |78|56|...
  So the driver moves EOP and bytes after EOP to the end of the aligned size,
  then fill the hole with PHY_IDLE. As following:
  before pad ...|7a|7c|00|10| |00|00|04|02| |4b|7d|5a|7b| |40|
  after pad  ...|7a|7c|00|10| |00|00|04|02| |4b|7d|5a|4a| |4a|4a|7b|40|
  Then if the slave will not get the entire packet before the tx phase is
  over, it can't responsed to anything either.
	
	  The driver doesn't support multiple channels so the channel number
	  is always 0.
 EOP should be inserted before the last valid char 
		
		  insert an ESCAPE char if the data value equals any special
		  char.
 The phy buffer is used out but transaction layer data remains 
 Store valid phy data length for spi transfer 
 Do phy buf padding if word_len > 1 byte. 
 move EOP and bytes after EOP to the end of aligned size 
 fill the hole with PHY_IDLEs 
 update the phy data length 
  In tx phase, the slave only returns PHY_IDLE (0x4a). So the driver will
  ignore rx in tx phase.
 reorder words for spi transfer 
 send all data in phy_buf  
  This function read the rx byte stream from SPI word by word and convert
  them to transaction layer data in br->trans_buf. It also stores the length
  of rx transaction layer data in br->trans_len
  The slave may send an unknown number of PHY_IDLEs in rx phase, so we cannot
  prepare a fixed length buffer to receive all of the rx data in a batch. We
  have to read word by word and convert them to transaction layer data at
  once.
 reorder the word back 
 drop everything before first SOP 
 drop PHY_IDLE 
			
			  We don't support multiple channels, so error out if
			  a non-zero channel number is found.
				
				  reset the parsing if a second SOP appears.
				
				  No special char is expected after ESC char.
				  No special char (except ESC & PHY_IDLE) is
				  expected after EOP char.
				 
				  The special chars are all dropped.
 Record the normal byte in trans_buf. 
				
				  We get the last normal byte after EOP, it is
				  time we finish. Normally the function should
				  return here.
 update poll timeout when we get valid word 
			
			  We timeout when rx keeps invalid for some time. But
			  it is possible we are scheduled out for long time
			  after a spi_read. So when we are scheduled in, a SW
			  timeout happens. But actually HW may have worked fine and
			  has been ready long time ago. So we need to do an extra
			  read, if we get a valid word then we could continue rx,
			  otherwise real a HW issue happens.
	
	  We have used out all transfer layer buffer but cannot find the end
	  of the byte stream.
  For read transactions, the avmm bus will directly return register values
  without transaction response header.
  For write transactions, the slave will return a transaction response
  header.
 error out if the trans code doesn't align with the val size 
 invalidate bridge buffers first 
 Only support BPW == 8 or 32 now. Try 32 BPW first. 
		
		  The protocol requires little endian byte order but MSB
		  first. So driver needs to swap the byte order word by word
		  if word length > 1.
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2020 Intel Corporation.
 MBQ-based controls are only 16-bits for now 
 Registers are 32 bits wide 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Synopsys, Inc. andor its affiliates.
 SPDX-License-Identifier: GPL-2.0
 Register map access API
 Copyright 2011 Wolfson Microelectronics plc
 Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
  Sometimes for failures during very early init the trace
  infrastructure isn't available early enough to be used.  For this
  sort of problem defining LOG_DEVICE will add printks for basic
  register IO on a specific device.
 Check "no ranges" first 
 In case zero "yes ranges" are supplied, any reg is OK 
	
	  We don't actually have anything to do here; the goal here
	  is not to manage the regmap but to provide a simple way to
	  get the regmap back given a struct device.
 Add a devres resource for dev_get_regmap() 
 Retrieve the endianness specification from the regmap config 
 If the regmap config specified a non-default value, use that 
 Retrieve the endianness specification from the bus config 
 If the bus specified a non-default value, use that 
 Use this if no other value was found 
 Retrieve the endianness specification from the regmap config 
 If the regmap config specified a non-default value, use that 
 If the firmware node exist try to get endianness from it 
 If the endianness was specified in fwnode, use that 
 Retrieve the endianness specification from the bus config 
 If the bus specified a non-default value, use that 
 Use this if no other value was found 
 Later error paths rely on this 
	
	  When we write in fast-paths with regmap_bulk_write() don't allocate
	  scratch buffers with sleeping allocations.
 Sanity check 
		 Make sure, that this register range has no selector
 Allow data window inside its own virtual range 
  devm_regmap_field_alloc() - Allocate and initialise a register field.
  @dev: Device that will be interacted with
  @regmap: regmap bank in which this register field is located.
  @reg_field: Register field with in the bank.
  The return value will be an ERR_PTR() on error or a valid pointer
  to a struct regmap_field. The regmap_field will be automatically freed
  by the device management code.
  regmap_field_bulk_alloc() - Allocate and initialise a bulk register field.
  @regmap: regmap bank in which this register field is located.
  @rm_field: regmap register fields within the bank.
  @reg_field: Register fields within the bank.
  @num_fields: Number of register fields.
  The return value will be an -ENOMEM on error or zero for success.
  Newly allocated regmap_fields should be freed by calling
  regmap_field_bulk_free()
  devm_regmap_field_bulk_alloc() - Allocate and initialise a bulk register
  fields.
  @dev: Device that will be interacted with
  @regmap: regmap bank in which this register field is located.
  @rm_field: regmap register fields within the bank.
  @reg_field: Register fields within the bank.
  @num_fields: Number of register fields.
  The return value will be an -ENOMEM on error or zero for success.
  Newly allocated regmap_fields will be automatically freed by the
  device management code.
  regmap_field_bulk_free() - Free register field allocated using
                        regmap_field_bulk_alloc.
  @field: regmap fields which should be freed.
  devm_regmap_field_bulk_free() - Free a bulk register field allocated using
                             devm_regmap_field_bulk_alloc.
  @dev: Device that will be interacted with
  @field: regmap field which should be freed.
  Free register field allocated using devm_regmap_field_bulk_alloc(). Usually
  drivers need not call this function, as the memory allocated via devm
  will be freed as per device-driver life-cycle.
  devm_regmap_field_free() - Free a register field allocated using
                             devm_regmap_field_alloc.
  @dev: Device that will be interacted with
  @field: regmap field which should be freed.
  Free register field allocated using devm_regmap_field_alloc(). Usually
  drivers need not call this function, as the memory allocated via devm
  will be freed as per device-driver life-cyle.
  regmap_field_alloc() - Allocate and initialise a register field.
  @regmap: regmap bank in which this register field is located.
  @reg_field: Register field with in the bank.
  The return value will be an ERR_PTR() on error or a valid pointer
  to a struct regmap_field. The regmap_field should be freed by the
  user once its finished working with it using regmap_field_free().
  regmap_field_free() - Free register field allocated using
                        regmap_field_alloc.
  @field: regmap field which should be freed.
  regmap_reinit_cache() - Reinitialise the current register cache
  @map: Register map to operate on.
  @config: New configuration.  Only the cache data will be used.
  Discard any existing register cache for the map and initialize a
  new cache.  This can be used to restore the cache to defaults or to
  update the cache configuration to reflect runtime discovery of the
  hardware.
  No explicit locking is done here, the user needs to ensure that
  this function will not race with other calls to regmap.
  regmap_exit() - Free a previously allocated register map
  @map: Register map to operate on.
 If the user didn't specify a name match any 
  dev_get_regmap() - Obtain the regmap (if any) for a device
  @dev: Device to retrieve the map for
  @name: Optional name for the register map, usually NULL.
  Returns the regmap for the device if one is present, or NULL.  If
  name is specified then it must match the name specified when
  registering the device, if it is NULL then the first regmap found
  will be used.  Devices with multiple register maps are very rare,
  generic code should normally not need to specify a name.
  regmap_get_device() - Obtain the device from a regmap
  @map: Register map to operate on.
  Returns the underlying device that the regmap has been created for.
 Bulk write shouldn't cross range boundary 
 ... or single page boundary 
	 It is possible to have selector register inside data window.
	   In that case, selector register is located on every page and
 Use separate work_buf during page switching 
	 Check for unwritable or noinc registers in range
	  before we start
 If the write goes beyond the end of the window split it 
	
	  Essentially all IO mechanisms will be faster with a single
	  buffer to write.  Since register syncs often generate raw
	  writes of single registers optimise that case.
 If the caller supplied the value we can use it safely. 
	 If we're doing a single register write we can probably just
	  send the work_buf directly, otherwise try to do a gather
	  write.
 If that didn't work fall back on linearising by hand. 
		 regcache_drop_region() takes lock that we already have,
		  thus call map->cache_ops->drop() directly
  regmap_can_raw_write - Test if regmap_raw_write() is supported
  @map: Map to check.
  regmap_get_raw_read_max - Get the maximum size we can read
  @map: Map to check.
  regmap_get_raw_write_max - Get the maximum size we can read
  @map: Map to check.
  regmap_write() - Write a value to a single register
  @map: Register map to write to
  @reg: Register to write to
  @val: Value to be written
  A value of zero will be returned on success, a negative errno will
  be returned in error cases.
  regmap_write_async() - Write a value to a single register asynchronously
  @map: Register map to write to
  @reg: Register to write to
  @val: Value to be written
  A value of zero will be returned on success, a negative errno will
  be returned in error cases.
 Write as many bytes as possible with chunk_size 
 Write remaining bytes 
  regmap_raw_write() - Write raw values to one or more registers
  @map: Register map to write to
  @reg: Initial register to write to
  @val: Block of data to be written, laid out for direct transmission to the
        device
  @val_len: Length of data pointed to by val.
  This function is intended to be used for things like firmware
  download where a large block of data needs to be transferred to the
  device.  No formatting will be done on the data provided.
  A value of zero will be returned on success, a negative errno will
  be returned in error cases.
  regmap_noinc_write(): Write data from a register without incrementing the
 			register number
  @map: Register map to write to
  @reg: Register to write to
  @val: Pointer to data buffer
  @val_len: Length of output buffer in bytes.
  The regmap API usually assumes that bulk bus write operations will write a
  range of registers. Some devices have certain registers for which a write
  operation can write to an internal FIFO.
  The target register must be volatile but registers after it can be
  completely unrelated cacheable registers.
  This will attempt multiple writes as required to write val_len bytes.
  A value of zero will be returned on success, a negative errno will be
  returned in error cases.
  regmap_field_update_bits_base() - Perform a readmodifywrite cycle a
                                    register field.
  @field: Register field to write to
  @mask: Bitmask to change
  @val: Value to be written
  @change: Boolean indicating if a write was done
  @async: Boolean indicating asynchronously
  @force: Boolean indicating use force update
  Perform a readmodifywrite cycle on the register field with change,
  async, force option.
  A value of zero will be returned on success, a negative errno will
  be returned in error cases.
  regmap_fields_update_bits_base() - Perform a readmodifywrite cycle a
                                     register field with port ID
  @field: Register field to write to
  @id: port ID
  @mask: Bitmask to change
  @val: Value to be written
  @change: Boolean indicating if a write was done
  @async: Boolean indicating asynchronously
  @force: Boolean indicating use force update
  A value of zero will be returned on success, a negative errno will
  be returned in error cases.
  regmap_bulk_write() - Write multiple registers to the device
  @map: Register map to write to
  @reg: First register to be write from
  @val: Block of data to be written, in native register size for device
  @val_count: Number of registers to write
  This function is intended to be used for writing a large block of
  data to the device either in single transfer or multiple transfer.
  A value of zero will be returned on success, a negative errno will
  be returned in error cases.
	
	  Some devices don't support bulk write, for them we have a series of
	  single write operations.
  _regmap_raw_multi_reg_write()
  the (register,newvalue) pairs in regs have not been formatted, but
  they are all in the same page and have been changed to being page
  relative. The page register has been written if that was necessary.
 We have to linearise by hand. 
	
	  the set of registers are not neccessarily in order, but
	  since the order of write must be preserved this algorithm
	  chops the set each time the page changes. This also applies
	  if there is a delay required at any point in the sequence.
		 If we have both a page change and a delay make sure to
		  write the regs and apply the delay before we change the
		  page.
				 For situations where the first write requires
				  a delay we need to make sure we don't call
				  raw_multi_reg_write with n=0
				  This can't occur with page breaks as we
				  never write on the first iteration
		 Coalesce all the writes between a page break or a delay
		  in a sequence
  regmap_multi_reg_write() - Write multiple registers to the device
  @map: Register map to write to
  @regs: Array of structures containing register,value to be written
  @num_regs: Number of registers to write
  Write multiple registers to the device where the set of register, value
  pairs are supplied in any order, possibly not all in a single range.
  The 'normal' block write mode will send ultimately send data on the
  target bus as R,V1,V2,V3,..,Vn where successively higher registers are
  addressed. However, this alternative block multi write mode will send
  the data as R1,V1,R2,V2,..,Rn,Vn on the target bus. The target device
  must of course support the mode.
  A value of zero will be returned on success, a negative errno will be
  returned in error cases.
  regmap_multi_reg_write_bypassed() - Write multiple registers to the
                                      device but not the cache
  @map: Register map to write to
  @regs: Array of structures containing register,value to be written
  @num_regs: Number of registers to write
  Write multiple registers to the device but not the cache where the set
  of register are supplied in any order.
  This function is intended to be used for writing a large block of data
  atomically to the device in single transfer for those I2C client devices
  that implement this alternative block write mode.
  A value of zero will be returned on success, a negative errno will
  be returned in error cases.
  regmap_raw_write_async() - Write raw values to one or more registers
                             asynchronously
  @map: Register map to write to
  @reg: Initial register to write to
  @val: Block of data to be written, laid out for direct transmission to the
        device.  Must be valid until regmap_async_complete() is called.
  @val_len: Length of data pointed to by val.
  This function is intended to be used for things like firmware
  download where a large block of data needs to be transferred to the
  device.  No formatting will be done on the data provided.
  If supported by the underlying bus the write will be scheduled
  asynchronously, helping maximise IO speed on higher speed buses
  like SPI.  regmap_async_complete() can be called to ensure that all
  asynchrnous writes have been completed.
  A value of zero will be returned on success, a negative errno will
  be returned in error cases.
  regmap_read() - Read a value from a single register
  @map: Register map to read from
  @reg: Register to be read from
  @val: Pointer to store read value
  A value of zero will be returned on success, a negative errno will
  be returned in error cases.
  regmap_raw_read() - Read raw data from the device
  @map: Register map to read from
  @reg: First register to be read from
  @val: Pointer to store read value
  @val_len: Size of data to read
  A value of zero will be returned on success, a negative errno will
  be returned in error cases.
 Read bytes that fit into whole chunks 
 Read remaining bytes 
		 Otherwise go word by word for the cache; should be low
		  cost as we expect to hit the cache.
  regmap_noinc_read(): Read data from a register without incrementing the
 			register number
  @map: Register map to read from
  @reg: Register to read from
  @val: Pointer to data buffer
  @val_len: Length of output buffer in bytes.
  The regmap API usually assumes that bulk bus read operations will read a
  range of registers. Some devices have certain registers for which a read
  operation read will read from an internal FIFO.
  The target register must be volatile but registers after it can be
  completely unrelated cacheable registers.
  This will attempt multiple reads as required to read val_len bytes.
  A value of zero will be returned on success, a negative errno will be
  returned in error cases.
  regmap_field_read(): Read a value to a single register field
  @field: Register field to read from
  @val: Pointer to store read value
  A value of zero will be returned on success, a negative errno will
  be returned in error cases.
  regmap_fields_read() - Read a value to a single register field with port ID
  @field: Register field to read from
  @id: port ID
  @val: Pointer to store read value
  A value of zero will be returned on success, a negative errno will
  be returned in error cases.
  regmap_bulk_read() - Read multiple registers from the device
  @map: Register map to read from
  @reg: First register to be read from
  @val: Pointer to store read value, in native register size for device
  @val_count: Number of registers to read
  A value of zero will be returned on success, a negative errno will
  be returned in error cases.
  regmap_update_bits_base() - Perform a readmodifywrite cycle on a register
  @map: Register map to update
  @reg: Register to update
  @mask: Bitmask to change
  @val: New value for bitmask
  @change: Boolean indicating if a write was done
  @async: Boolean indicating asynchronously
  @force: Boolean indicating use force update
  Perform a readmodifywrite cycle on a register map with change, async, force
  options.
  If async is true:
  With most buses the read must be done synchronously so this is most useful
  for devices with a cache which do not need to interact with the hardware to
  determine the current register value.
  Returns zero for success, a negative number on error.
  regmap_test_bits() - Check if all specified bits are set in a register.
  @map: Register map to operate on
  @reg: Register to read from
  @bits: Bits to test
  Returns 0 if at least one of the tested bits is not set, 1 if all tested
  bits are set and a negative error number if the underlying regmap_read()
  fails.
  regmap_async_complete - Ensure all asynchronous IO has completed.
  @map: Map to operate on.
  Blocks until any pending asynchronous IO has completed.  Returns
  an error code for any failed IO operations.
 Nothing to do with no async support 
  regmap_register_patch - Register and apply register updates to be applied
                          on device initialistion
  @map: Register map to apply updates to.
  @regs: Values to update.
  @num_regs: Number of entries in regs.
  Register a set of register updates to be applied to the device
  whenever the device registers are synchronised with the cache and
  apply them immediately.  Typically this is used to apply
  corrections to be applied to the device defaults on startup, such
  as the updates some vendors provide to undocumented registers.
  The caller must ensure that this function cannot be called
  concurrently with either itself or regcache_sync().
  regmap_get_val_bytes() - Report the size of a register value
  @map: Register map to operate on.
  Report the size of a register value, mainly intended to for use by
  generic infrastructure built on top of regmap.
  regmap_get_max_register() - Report the max register value
  @map: Register map to operate on.
  Report the max register value, mainly intended to for use by
  generic infrastructure built on top of regmap.
  regmap_get_reg_stride() - Report the register address stride
  @map: Register map to operate on.
  Report the register address stride, mainly intended to for use by
  generic infrastructure built on top of regmap.
 SPDX-License-Identifier: GPL-2.0
 Register map access API - MMIO support
 Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
 The core treats 0 as 1 
 SPDX-License-Identifier: GPL-2.0
 Register map access API - SPI support
 Copyright 2011 Wolfson Microelectronics plc
 Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
 SPDX-License-Identifier: GPL-2.0
  driversbasepowerclock_ops.c - Generic clock manipulation PM callbacks
  Copyright (c) 2011 Rafael J. Wysocki <rjw@sisk.pl>, Renesas Electronics Corp.
  pm_clk_list_lock - ensure exclusive access for modifying the PM clock
 		      entry list.
  @psd: pm_subsys_data instance corresponding to the PM clock entry list
 	 and clk_op_might_sleep count to be modified.
  Get exclusive access before modifying the PM clock entry list and the
  clock_op_might_sleep count to guard against concurrent modifications.
  This also protects against a concurrent clock_op_might_sleep and PM clock
  entry list usage in pm_clk_suspend()pm_clk_resume() that may or may not
  happen in atomic context, hence both the mutex and the spinlock must be
  taken here.
  pm_clk_list_unlock - counterpart to pm_clk_list_lock().
  @psd: the same pm_subsys_data instance previously passed to
 	 pm_clk_list_lock().
  pm_clk_op_lock - ensure exclusive access for performing clock operations.
  @psd: pm_subsys_data instance corresponding to the PM clock entry list
 	 and clk_op_might_sleep count being used.
  @flags: stored irq flags.
  @fn: string for the caller function's name.
  This is used by pm_clk_suspend() and pm_clk_resume() to guard
  against concurrent modifications to the clock entry list and the
  clock_op_might_sleep count. If clock_op_might_sleep is != 0 then
  only the mutex can be locked and those functions can only be used in
  non atomic context. If clock_op_might_sleep == 0 then these functions
  may be used in any context and only the spinlock can be locked.
  Returns -EINVAL if called in atomic context when clock ops might sleep.
 sparse annotations don't work here as exit state isn't static 
 the __release is there to work around sparse limitations 
 bail out if in atomic context 
 we must switch to the mutex 
	
	  There was a possibility for psd->clock_op_might_sleep
	  to become 0 above. Keep the mutex only if not the case.
  pm_clk_op_unlock - counterpart to pm_clk_op_lock().
  @psd: the same pm_subsys_data instance previously passed to
 	 pm_clk_op_lock().
  @flags: irq flags provided by pm_clk_op_lock().
 sparse annotations don't work here as entry state isn't static 
 the __acquire is there to work around sparse limitations 
  __pm_clk_enable - Enable a clock, reporting any errors
  @dev: The device for the given clock
  @ce: PM clock entry corresponding to the clock.
  pm_clk_acquire - Acquire a device clock.
  @dev: Device whose clock is to be acquired.
  @ce: PM clock entry corresponding to the clock.
 we defer preparing the clock in that case 
  pm_clk_add - Start using a device clock for power management.
  @dev: Device whose clock is going to be used for power management.
  @con_id: Connection ID of the clock.
  Add the clock represented by @con_id to the list of clocks used for
  the power management of @dev.
  pm_clk_add_clk - Start using a device clock for power management.
  @dev: Device whose clock is going to be used for power management.
  @clk: Clock pointer
  Add the clock to the list of clocks used for the power management of @dev.
  The power-management code will take control of the clock reference, so
  callers should not call clk_put() on @clk after this function sucessfully
  returned.
  of_pm_clk_add_clk - Start using a device clock for power management.
  @dev: Device whose clock is going to be used for power management.
  @name: Name of clock that is going to be used for power management.
  Add the clock described in the 'clocks' device-tree node that matches
  with the 'name' provided, to the list of clocks used for the power
  management of @dev. On success, returns 0. Returns a negative error
  code if the clock is not found or cannot be added.
  of_pm_clk_add_clks - Start using device clock(s) for power management.
  @dev: Device whose clock(s) is going to be used for power management.
  Add a series of clocks described in the 'clocks' device-tree node for
  a device to the list of clocks used for the power management of @dev.
  On success, returns the number of clocks added. Returns a negative
  error code if there are no clocks in the device node for the device
  or if adding a clock fails.
  __pm_clk_remove - Destroy PM clock entry.
  @ce: PM clock entry to destroy.
  pm_clk_remove - Stop using a device clock for power management.
  @dev: Device whose clock should not be used for PM any more.
  @con_id: Connection ID of the clock.
  Remove the clock represented by @con_id from the list of clocks used for
  the power management of @dev.
  pm_clk_remove_clk - Stop using a device clock for power management.
  @dev: Device whose clock should not be used for PM any more.
  @clk: Clock pointer
  Remove the clock pointed to by @clk from the list of clocks used for
  the power management of @dev.
  pm_clk_init - Initialize a device's list of power management clocks.
  @dev: Device to initialize the list of PM clocks for.
  Initialize the lock and clock_list members of the device's pm_subsys_data
  object, set the count of clocks that might sleep to 0.
  pm_clk_create - Create and initialize a device's list of PM clocks.
  @dev: Device to create and initialize the list of PM clocks for.
  Allocate a struct pm_subsys_data object, initialize its lock and clock_list
  members and make the @dev's power.subsys_data field point to it.
  pm_clk_destroy - Destroy a device's list of power management clocks.
  @dev: Device to destroy the list of PM clocks for.
  Clear the @dev's power.subsys_data field, remove the list of clock entries
  from the struct pm_subsys_data object pointed to by it before and free
  that object.
  pm_clk_suspend - Disable clocks in a device's PM clock list.
  @dev: Device to disable the clocks for.
  pm_clk_resume - Enable clocks in a device's PM clock list.
  @dev: Device to enable the clocks for.
  pm_clk_notify - Notify routine for device addition and removal.
  @nb: Notifier block object this function is a member of.
  @action: Operation being carried out by the caller.
  @data: Device the routine is being run for.
  For this function to work, @nb must be a member of an object of type
  struct pm_clk_notifier_block containing all of the requisite data.
  Specifically, the pm_domain member of that object is copied to the device's
  pm_domain field and its con_ids member is used to populate the device's list
  of PM clocks, depending on @action.
  If the device's pm_domain field is already populated with a value different
  from the one stored in the struct pm_clk_notifier_block object, the function
  does nothing.
 !CONFIG_PM_CLK 
  enable_clock - Enable a device clock.
  @dev: Device whose clock is to be enabled.
  @con_id: Connection ID of the clock.
  disable_clock - Disable a device clock.
  @dev: Device whose clock is to be disabled.
  @con_id: Connection ID of the clock.
  pm_clk_notify - Notify routine for device addition and removal.
  @nb: Notifier block object this function is a member of.
  @action: Operation being carried out by the caller.
  @data: Device the routine is being run for.
  For this function to work, @nb must be a member of an object of type
  struct pm_clk_notifier_block containing all of the requisite data.
  Specifically, the con_ids member of that object is used to enable or disable
  the device's clocks, depending on @action.
 !CONFIG_PM_CLK 
  pm_clk_add_notifier - Add bus type notifier for power management clocks.
  @bus: Bus type to add the notifier to.
  @clknb: Notifier to be added to the given bus type.
  The nb member of @clknb is not expected to be initialized and its
  notifier_call member will be replaced with pm_clk_notify().  However,
  the remaining members of @clknb should be populated prior to calling this
  routine.
 SPDX-License-Identifier: GPL-2.0
  driversbasepowerwakeup.c - System wakeup events framework
  Copyright (c) 2010 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.
  If set, the suspendhibernate code will abort transitions to a sleep state
  if wakeup events are registered during or immediately before the transition.
 First wakeup IRQ seen by the kernel in the last cycle. 
 If greater than 0 and the system is suspending, terminate the suspend. 
  Combined counters of registered wakeup events and wakeup events in progress.
  They need to be modified together atomically, so it's better to use one
  atomic variable to hold them both.
 A preserved old value of the events counter. 
  wakeup_source_create - Create a struct wakeup_source object.
  @name: Name of the new wakeup source.
  Record wakeup_source statistics being deleted into a dummy wakeup_source.
  wakeup_source_destroy - Destroy a struct wakeup_source object.
  @ws: Wakeup source to destroy.
  Use only for wakeup source objects created with wakeup_source_create().
  wakeup_source_add - Add given object to the list of wakeup sources.
  @ws: Wakeup source object to add to the list.
  wakeup_source_remove - Remove given object from the wakeup sources list.
  @ws: Wakeup source object to remove from the list.
	
	  Clear timer.function to make wakeup_source_not_registered() treat
	  this wakeup source as not registered.
  wakeup_source_register - Create wakeup source and add it to the list.
  @dev: Device this wakeup source is associated with (or NULL if virtual).
  @name: Name of the wakeup source to register.
  wakeup_source_unregister - Remove wakeup source from the list and remove it.
  @ws: Wakeup source object to unregister.
  wakeup_sources_read_lock - Lock wakeup source list for read.
  Returns an index of srcu lock for struct wakeup_srcu.
  This index must be passed to the matching wakeup_sources_read_unlock().
  wakeup_sources_read_unlock - Unlock wakeup source list.
  @idx: return value from corresponding wakeup_sources_read_lock()
  wakeup_sources_walk_start - Begin a walk on wakeup source list
  Returns first object of the list of wakeup sources.
  Note that to be safe, wakeup sources list needs to be locked by calling
  wakeup_source_read_lock() for this.
  wakeup_sources_walk_next - Get next wakeup source from the list
  @ws: Previous wakeup source object
  Note that to be safe, wakeup sources list needs to be locked by calling
  wakeup_source_read_lock() for this.
  device_wakeup_attach - Attach a wakeup source object to a device object.
  @dev: Device to handle.
  @ws: Wakeup source object to attach to @dev.
  This causes @dev to be treated as a wakeup device.
  device_wakeup_enable - Enable given device to be a wakeup source.
  @dev: Device to handle.
  Create a wakeup source object, register it and attach it to @dev.
  device_wakeup_attach_irq - Attach a wakeirq to a wakeup source
  @dev: Device to handle
  @wakeirq: Device specific wakeirq entry
  Attach a device wakeirq to the wakeup source so the device
  wake IRQ can be configured automatically for suspend and
  resume.
  Call under the device's power.lock lock.
  device_wakeup_detach_irq - Detach a wakeirq from a wakeup source
  @dev: Device to handle
  Removes a device wakeirq from the wakeup source.
  Call under the device's power.lock lock.
  device_wakeup_arm_wake_irqs -
  Iterates over the list of device wakeirqs to arm them.
  device_wakeup_disarm_wake_irqs -
  Iterates over the list of device wakeirqs to disarm them.
  device_wakeup_detach - Detach a device's wakeup source object from it.
  @dev: Device to detach the wakeup source object from.
  After it returns, @dev will not be treated as a wakeup device any more.
  device_wakeup_disable - Do not regard a device as a wakeup source any more.
  @dev: Device to handle.
  Detach the @dev's wakeup source object from it, unregister this wakeup source
  object and destroy it.
  device_set_wakeup_capable - Setreset device wakeup capability flag.
  @dev: Device to handle.
  @capable: Whether or not @dev is capable of waking up the system from sleep.
  If @capable is set, set the @dev's power.can_wakeup flag and add its
  wakeup-related attributes to sysfs.  Otherwise, unset the @dev's
  power.can_wakeup flag and remove its wakeup-related attributes from sysfs.
  This function may sleep and it can't be called from any context where
  sleeping is not allowed.
  device_init_wakeup - Device wakeup initialization.
  @dev: Device to handle.
  @enable: Whether or not to enable @dev as a wakeup device.
  By default, most devices should leave wakeup disabled.  The exceptions are
  devices that everyone expects to be wakeup sources: keyboards, power buttons,
  possibly network interfaces, etc.  Also, devices that don't generate their
  own wakeup requests but merely forward requests from one bus to another
  (like PCI bridges) should have wakeup enabled by default.
  device_set_wakeup_enable - Enable or disable a device to wake up the system.
  @dev: Device to handle.
  @enable: enabledisable flag
  wakeup_source_not_registered - validate the given wakeup source.
  @ws: Wakeup source to be validated.
	
	  Use timer struct to check if the given source is initialized
	  by wakeup_source_add.
  The functions below use the observation that each wakeup event starts a
  period in which the system should not be suspended.  The moment this period
  will end depends on how the wakeup event is going to be processed after being
  detected and all of the possible cases can be divided into two distinct
  groups.
  First, a wakeup event may be detected by the same functional unit that will
  carry out the entire processing of it and possibly will pass it to user space
  for further processing.  In that case the functional unit that has detected
  the event may later "close" the "no suspend" period associated with it
  directly as soon as it has been dealt with.  The pair of pm_stay_awake() and
  pm_relax(), balanced with each other, is supposed to be used in such
  situations.
  Second, a wakeup event may be detected by one functional unit and processed
  by another one.  In that case the unit that has detected it cannot really
  "close" the "no suspend" period associated with it, unless it knows in
  advance what's going to happen to the event during processing.  This
  knowledge, however, may not be available to it, so it can simply specify time
  to wait before the system can be suspended and pass it as the second
  argument of pm_wakeup_event().
  It is valid to call pm_relax() after pm_wakeup_event(), in which case the
  "no suspend" period will be ended either by the pm_relax(), or by the timer
  function executed when the timer expires, whichever comes first.
  wakeup_source_activate - Mark given wakeup source as active.
  @ws: Wakeup source to handle.
  Update the @ws' statistics and, if @ws has just been activated, notify the PM
  core of the event by incrementing the counter of of wakeup events being
  processed.
 Increment the counter of events in progress. 
  wakeup_source_report_event - Report wakeup event using the given source.
  @ws: Wakeup source to report the event for.
  @hard: If set, abort suspends in progress and wake up from suspend-to-idle.
 This is racy, but the counter is approximate anyway. 
  __pm_stay_awake - Notify the PM core of a wakeup event.
  @ws: Wakeup source object associated with the source of the event.
  It is safe to call this function from interrupt context.
  pm_stay_awake - Notify the PM core that a wakeup event is being processed.
  @dev: Device the wakeup event is related to.
  Notify the PM core of a wakeup event (signaled by @dev) by calling
  __pm_stay_awake for the @dev's wakeup source object.
  Call this function after detecting of a wakeup event if pm_relax() is going
  to be called directly after processing the event (and possibly passing it to
  user space for further processing).
  wakeup_source_deactivate - Mark given wakeup source as inactive.
  @ws: Wakeup source to handle.
  Update the @ws' statistics and notify the PM core that the wakeup source has
  become inactive by decrementing the counter of wakeup events being processed
  and incrementing the counter of registered wakeup events.
	
	  __pm_relax() may be called directly or from a timer function.
	  If it is called directly right after the timer function has been
	  started, but before the timer function calls __pm_relax(), it is
	  possible that __pm_stay_awake() will be called in the meantime and
	  will set ws->active.  Then, ws->active may be cleared immediately
	  by the __pm_relax() called from the timer function, but in such a
	  case ws->relax_count will be different from ws->active_count.
	
	  Increment the counter of registered wakeup events and decrement the
	  couter of wakeup events in progress simultaneously.
  __pm_relax - Notify the PM core that processing of a wakeup event has ended.
  @ws: Wakeup source object associated with the source of the event.
  Call this function for wakeup events whose processing started with calling
  __pm_stay_awake().
  It is safe to call it from interrupt context.
  pm_relax - Notify the PM core that processing of a wakeup event has ended.
  @dev: Device that signaled the event.
  Execute __pm_relax() for the @dev's wakeup source object.
  pm_wakeup_timer_fn - Delayed finalization of a wakeup event.
  @t: timer list
  Call wakeup_source_deactivate() for the wakeup source whose address is stored
  in @data if it is currently active and its timer has not been canceled and
  the expiration time of the timer is not in future.
  pm_wakeup_ws_event - Notify the PM core of a wakeup event.
  @ws: Wakeup source object associated with the event source.
  @msec: Anticipated event processing time (in milliseconds).
  @hard: If set, abort suspends in progress and wake up from suspend-to-idle.
  Notify the PM core of a wakeup event whose source is @ws that will take
  approximately @msec milliseconds to be processed by the kernel.  If @ws is
  not active, activate it.  If @msec is nonzero, set up the @ws' timer to
  execute pm_wakeup_timer_fn() in future.
  It is safe to call this function from interrupt context.
  pm_wakeup_dev_event - Notify the PM core of a wakeup event.
  @dev: Device the wakeup event is related to.
  @msec: Anticipated event processing time (in milliseconds).
  @hard: If set, abort suspends in progress and wake up from suspend-to-idle.
  Call pm_wakeup_ws_event() for the @dev's wakeup source object.
  pm_wakeup_pending - Check if power transition in progress should be aborted.
  Compare the current number of registered wakeup events with its preserved
  value from the past and return true if new wakeup events have been registered
  since the old value was stored.  Also return true if the current number of
  wakeup events being processed is different from zero.
  pm_get_wakeup_count - Read the number of registered wakeup events.
  @count: Address to store the value at.
  @block: Whether or not to block.
  Store the number of registered wakeup events at the address in @count.  If
  @block is set, block until the current number of wakeup events being
  processed is zero.
  Return 'false' if the current number of wakeup events being processed is
  nonzero.  Otherwise return 'true'.
  pm_save_wakeup_count - Save the current number of registered wakeup events.
  @count: Value to compare with the current number of registered wakeup events.
  If @count is equal to the current number of registered wakeup events and the
  current number of wakeup events being processed is zero, store @count as the
  old number of registered wakeup events for pm_check_wakeup_events(), enable
  wakeup events detection and return 'true'.  Otherwise disable wakeup events
  detection and return 'false'.
  pm_wakep_autosleep_enabled - Modify autosleep_enabled for all wakeup sources.
  @set: Whether to set or to clear the autosleep_enabled flags.
 CONFIG_PM_AUTOSLEEP 
  print_wakeup_source_stats - Print wakeup source statistics information.
  @m: seq_file to print the statistics into.
  @ws: Wakeup source object to print the statistics for.
  wakeup_sources_stats_seq_show - Print wakeup sources statistics information.
  @m: seq_file to print the statistics into.
  @v: wakeup_source of each iteration
 SPDX-License-Identifier: GPL-2.0
  driversbasepowerruntime.c - Helper functions for device runtime PM
  Copyright (c) 2009 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.
  Copyright (C) 2010 Alan Stern <stern@rowland.harvard.edu>
  update_pm_runtime_accounting - Update the time accounting of power states
  @dev: Device to update the accounting for
  In order to be able to have time accounting of the various power states
  (as used by programs such as PowerTOP to show the effectiveness of runtime
  PM), we need to track the time spent in each state.
  update_pm_runtime_accounting must be called each time before the
  runtime_status field is updated, to account the time in the old state
  correctly.
	
	  Because ktime_get_mono_fast_ns() is not monotonic during
	  timekeeping updates, ensure that 'now' is after the last saved
	  timesptamp.
  pm_runtime_deactivate_timer - Deactivate given device's suspend timer.
  @dev: Device to handle.
  pm_runtime_cancel_pending - Deactivate suspend timer and cancel requests.
  @dev: Device to handle.
	
	  In case there's a request pending, make sure its work function will
	  return without doing anything.
  pm_runtime_autosuspend_expiration - Get a device's autosuspend-delay expiration time.
  @dev: Device to handle.
  Compute the autosuspend-delay expiration time based on the device's
  power.last_busy time.  If the delay has already expired or is disabled
  (negative) or the power.use_autosuspend flag isn't set, return 0.
  Otherwise return the expiration time in nanoseconds (adjusted to be nonzero).
  This function may be called either with or without dev->power.lock held.
  Either way it can be racy, since power.last_busy may be updated at any time.
 Expires in the future 
  pm_runtime_set_memalloc_noio - Set a device's memalloc_noio flag.
  @dev: Device to handle.
  @enable: True for setting the flag and False for clearing the flag.
  Set the flag for all devices in the path from the device to the
  root device in the device tree if @enable is true, otherwise clear
  the flag for devices in the path whose siblings don't set the flag.
  The function should only be called by block device, or network
  device driver for solving the deadlock problem during runtime
  resumesuspend:
      If memory allocation with GFP_KERNEL is called inside runtime
      resumesuspend callback of any one of its ancestors(or the
      block device itself), the deadlock may be triggered inside the
      memory allocation since it might not complete until the block
      device becomes active and the involed page IO finishes. The
      situation is pointed out first by Alan Stern. Network device
      are involved in iSCSI kind of situation.
  The lock of dev_hotplug_mutex is held in the function for handling
  hotplug race because pm_runtime_set_memalloc_noio() may be called
  in async probe().
  The function should be called between device_add() and device_del()
  on the affected device(blocknetwork device).
 hold power lock since bitfield is not SMP-safe. 
		
		  not need to enable ancestors any more if the device
		  has been enabled.
		
		  clear flag of the parent device only if all the
		  children don't set the flag because ancestor's
		  flag was set by any one of the descendants.
  rpm_check_suspend_allowed - Test whether a device may be suspended.
  @dev: Device to test.
 Pending resume requests take precedence over suspends. 
 Ignore suppliers with disabled runtime PM. 
  __rpm_callback - Run a given runtime PM callback for a given device.
  @cb: Runtime PM callback to run.
  @dev: Device to run the callback for.
		
		  Resume suppliers if necessary.
		 
		  The device's runtime PM status cannot change until this
		  routine returns, so it is safe to read the status outside of
		  the lock.
		
		  If the device is suspending and the callback has returned
		  success, drop the usage counters of the suppliers that have
		  been reference counted on its resume.
		 
		  Do that if resume fails too.
  rpm_idle - Notify device bus type if the device can be suspended.
  @dev: Device to notify the bus type about.
  @rpmflags: Flag bits.
  Check if the device's runtime PM status allows it to be suspended.  If
  another idle notification has been started earlier, return immediately.  If
  the RPM_ASYNC flag is set then queue an idle-notification request; otherwise
  run the ->runtime_idle() callback directly. If the ->runtime_idle callback
  doesn't exist or if it returns 0, call rpm_suspend with the RPM_AUTO flag.
  This function must be called under dev->power.lock with interrupts disabled.
 Conditions are wrong. 
 Idle notifications are allowed only in the RPM_ACTIVE state. 
	
	  Any pending request other than an idle notification takes
	  precedence over us, except that the timer may be running.
 Act as though RPM_NOWAIT is always set. 
 Pending requests need to be canceled. 
 If no callback assume success. 
 Carry out an asynchronous or a synchronous idle notification. 
  rpm_callback - Run a given runtime PM callback for a given device.
  @cb: Runtime PM callback to run.
  @dev: Device to run the callback for.
		
		  Deadlock might be caused if memory allocation with
		  GFP_KERNEL happens inside runtime_suspend and
		  runtime_resume callbacks of one block device's
		  ancestor or the block device itself. Network
		  device might be thought as part of iSCSI block
		  device, so network device and its ancestor should
		  be marked as memalloc_noio too.
  rpm_suspend - Carry out runtime suspend of given device.
  @dev: Device to suspend.
  @rpmflags: Flag bits.
  Check if the device's runtime PM status allows it to be suspended.
  Cancel a pending idle notification, autosuspend or suspend. If
  another suspend has been started earlier, either return immediately
  or wait for it to finish, depending on the RPM_NOWAIT and RPM_ASYNC
  flags. If the RPM_ASYNC flag is set then queue a suspend request;
  otherwise run the ->runtime_suspend() callback directly. When
  ->runtime_suspend succeeded, if a deferred resume was requested while
  the callback was running then carry it out, otherwise send an idle
  notification for its parent (if the suspend succeeded and both
  ignore_children of parent->power and irq_safe of dev->power are not set).
  If ->runtime_suspend failed with -EAGAIN or -EBUSY, and if the RPM_AUTO
  flag is set and the next autosuspend-delay expiration time is in the
  future, schedule another autosuspend attempt.
  This function must be called under dev->power.lock with interrupts disabled.
 Conditions are wrong. 
 Synchronous suspends are not allowed in the RPM_RESUMING state. 
 If the autosuspend_delay time hasn't expired yet, reschedule. 
 Pending requests need to be canceled. 
			
			  Optimization: If the timer is already running and is
			  set to expire at or before the autosuspend delay,
			  avoid the overhead of resetting it.  Just let it
			  expire; pm_suspend_timer_fn() will take care of the
			  rest.
				
				  We add a slack of 25% to gather wakeups
				  without sacrificing the granularity.
 Other scheduled or pending requests need to be canceled. 
 Wait for the other suspend running in parallel with us. 
 Assume success. 
 Carry out an asynchronous or a synchronous suspend. 
 Maybe the parent is now able to suspend. 
 Maybe the suppliers are now able to suspend. 
		
		  If the callback routine failed an autosuspend, and
		  if the last_busy time has been updated so that there
		  is a new autosuspend expiration time, automatically
		  reschedule another autosuspend.
  rpm_resume - Carry out runtime resume of given device.
  @dev: Device to resume.
  @rpmflags: Flag bits.
  Check if the device's runtime PM status allows it to be resumed.  Cancel
  any scheduled or pending requests.  If another resume has been started
  earlier, either return immediately or wait for it to finish, depending on the
  RPM_NOWAIT and RPM_ASYNC flags.  Similarly, if there's a suspend running in
  parallel with this function, either tell the other process to resume after
  suspending (deferred_resume) or wait for it to finish.  If the RPM_ASYNC
  flag is set then queue a resume request; otherwise run the
  ->runtime_resume() callback directly.  Queue an idle notification for the
  device if the resume succeeded.
  This function must be called under dev->power.lock with interrupts disabled.
	
	  Other scheduled or pending requests need to be canceled.  Small
	  optimization: If an autosuspend timer is running, leave it running
	  rather than cancelling it now only to restart it again in the near
	  future.
 Wait for the operation carried out in parallel with us. 
	
	  See if we can skip waking up the parent.  This is safe only if
	  power.no_callbacks is set, because otherwise we don't know whether
	  the resume will actually succeed.
 Assume success. 
 Carry out an asynchronous or a synchronous resume. 
		
		  Increment the parent's usage counter and resume it if
		  necessary.  Not needed if dev is irq-safe; then the
		  parent is permanently resumed.
		
		  Resume the parent if it has runtime PM enabled and not been
		  set to ignore its children.
 Assume success. 
  pm_runtime_work - Universal runtime PM work function.
  @work: Work structure used for scheduling the execution of this function.
  Use @work to get the device object the work is to be done for, determine what
  is to be done and execute the appropriate runtime PM function.
  pm_suspend_timer_fn - Timer function for pm_schedule_suspend().
  @timer: hrtimer used by pm_schedule_suspend().
  Check if the time is right and queue a suspend request.
	
	  If 'expires' is after the current time, we've been called
	  too early.
  pm_schedule_suspend - Set up a timer to submit a suspend request in future.
  @dev: Device to suspend.
  @delay: Time to wait before submitting a suspend request, in milliseconds.
 Other scheduled or pending requests need to be canceled. 
  __pm_runtime_idle - Entry point for runtime idle operations.
  @dev: Device to send idle notification for.
  @rpmflags: Flag bits.
  If the RPM_GET_PUT flag is set, decrement the device's usage count and
  return immediately if it is larger than zero.  Then carry out an idle
  notification, either synchronous or asynchronous.
  This routine may be called in atomic context if the RPM_ASYNC flag is set,
  or if pm_runtime_irq_safe() has been called.
  __pm_runtime_suspend - Entry point for runtime putsuspend operations.
  @dev: Device to suspend.
  @rpmflags: Flag bits.
  If the RPM_GET_PUT flag is set, decrement the device's usage count and
  return immediately if it is larger than zero.  Then carry out a suspend,
  either synchronous or asynchronous.
  This routine may be called in atomic context if the RPM_ASYNC flag is set,
  or if pm_runtime_irq_safe() has been called.
  __pm_runtime_resume - Entry point for runtime resume operations.
  @dev: Device to resume.
  @rpmflags: Flag bits.
  If the RPM_GET_PUT flag is set, increment the device's usage count.  Then
  carry out a resume, either synchronous or asynchronous.
  This routine may be called in atomic context if the RPM_ASYNC flag is set,
  or if pm_runtime_irq_safe() has been called.
  pm_runtime_get_if_active - Conditionally bump up device usage counter.
  @dev: Device to handle.
  @ign_usage_count: Whether or not to look at the current usage counter value.
  Return -EINVAL if runtime PM is disabled for @dev.
  Otherwise, if the runtime PM status of @dev is %RPM_ACTIVE and either
  @ign_usage_count is %true or the runtime PM usage counter of @dev is not
  zero, increment the usage counter of @dev and return 1. Otherwise, return 0
  without changing the usage counter.
  If @ign_usage_count is %true, this function can be used to prevent suspending
  the device when its runtime PM status is %RPM_ACTIVE.
  If @ign_usage_count is %false, this function can be used to prevent
  suspending the device when both its runtime PM status is %RPM_ACTIVE and its
  runtime PM usage counter is not zero.
  The caller is responsible for decrementing the runtime PM usage counter of
  @dev after this function has returned a positive value for it.
  __pm_runtime_set_status - Set runtime PM status of a device.
  @dev: Device to handle.
  @status: New runtime PM status of the device.
  If runtime PM of the device is disabled or its power.runtime_error field is
  different from zero, the status may be changed either to RPM_ACTIVE, or to
  RPM_SUSPENDED, as long as that reflects the actual state of the device.
  However, if the device has a parent and the parent is not active, and the
  parent's power.ignore_children flag is unset, the device's status cannot be
  set to RPM_ACTIVE, so -EBUSY is returned in that case.
  If successful, __pm_runtime_set_status() clears the power.runtime_error field
  and the device parent's counter of unsuspended children is modified to
  reflect the new status.  If the new status is RPM_SUSPENDED, an idle
  notification request for the parent is submitted.
  If @dev has any suppliers (as reflected by device links to them), and @status
  is RPM_ACTIVE, they will be activated upfront and if the activation of one
  of them fails, the status of @dev will be changed to RPM_SUSPENDED (instead
  of the @status value) and the suppliers will be deacticated on exit.  The
  error returned by the failing supplier activation will be returned in that
  case.
	
	  Prevent PM-runtime from being enabled for the device or return an
	  error if it is enabled already and working.
	
	  If the new status is RPM_ACTIVE, the suppliers can be activated
	  upfront regardless of the current status, because next time
	  rpm_put_suppliers() runs, the rpm_active refcounts of the links
	  involved will be dropped down to one anyway.
		
		  It is invalid to put an active child under a parent that is
		  not active, has runtime PM enabled and the
		  'power.ignore_children' flag unset.
  __pm_runtime_barrier - Cancel pending requests and wait for completions.
  @dev: Device to handle.
  Flush all pending requests for the device from pm_wq and wait for all
  runtime PM operations involving the device in progress to complete.
  Should be called under dev->power.lock with interrupts disabled.
 Suspend, wake-up or idle notification in progress. 
  pm_runtime_barrier - Flush pending requests and wait for completions.
  @dev: Device to handle.
  Prevent the device from being suspended by incrementing its usage counter and
  if there's a pending resume request for the device, wake the device up.
  Next, make sure that all pending requests for the device have been flushed
  from pm_wq and wait for all runtime PM operations involving the device in
  progress to complete.
  Return value:
  1, if there was a resume request pending and the device had to be woken up,
  0, otherwise
  __pm_runtime_disable - Disable runtime PM of a device.
  @dev: Device to handle.
  @check_resume: If set, check if there's a resume request for the device.
  Increment power.disable_depth for the device and if it was zero previously,
  cancel all pending runtime PM requests for the device and wait for all
  operations in progress to complete.  The device can be either active or
  suspended after its runtime PM has been disabled.
  If @check_resume is set and there's a resume request pending when
  __pm_runtime_disable() is called and power.disable_depth is zero, the
  function will wake up the device before disabling its runtime PM.
	
	  Wake up the device if there's a resume request pending, because that
	  means there probably is some IO to process and disabling runtime PM
	  shouldn't prevent the device from processing the IO.
		
		  Prevent suspends and idle notifications from being carried
		  out after we have woken up the device.
 Update time accounting before disabling PM-runtime. 
  pm_runtime_enable - Enable runtime PM of a device.
  @dev: Device to handle.
 About to enable runtime pm, set accounting_timestamp to now 
  devm_pm_runtime_enable - devres-enabled version of pm_runtime_enable.
  @dev: Device to handle.
  pm_runtime_forbid - Block runtime PM of a device.
  @dev: Device to handle.
  Increase the device's usage count and clear its power.runtime_auto flag,
  so that it cannot be suspended at run time until pm_runtime_allow() is called
  for it.
  pm_runtime_allow - Unblock runtime PM of a device.
  @dev: Device to handle.
  Decrease the device's usage count and set its power.runtime_auto flag.
  pm_runtime_no_callbacks - Ignore runtime PM callbacks for a device.
  @dev: Device to handle.
  Set the power.no_callbacks flag, which tells the PM core that this
  device is power-managed through its parent and has no runtime PM
  callbacks of its own.  The runtime sysfs attributes will be removed.
  pm_runtime_irq_safe - Leave interrupts disabled during callbacks.
  @dev: Device to handle
  Set the power.irq_safe flag, which tells the PM core that the
  ->runtime_suspend() and ->runtime_resume() callbacks for this device should
  always be invoked with the spinlock held and interrupts disabled.  It also
  causes the parent's usage counter to be permanently incremented, preventing
  the parent from runtime suspending -- otherwise an irq-safe child might have
  to wait for a non-irq-safe parent.
  update_autosuspend - Handle a change to a device's autosuspend settings.
  @dev: Device to handle.
  @old_delay: The former autosuspend_delay value.
  @old_use: The former use_autosuspend value.
  Prevent runtime suspend if the new delay is negative and use_autosuspend is
  set; otherwise allow it.  Send an idle notification if suspends are allowed.
  This function must be called under dev->power.lock with interrupts disabled.
 Should runtime suspend be prevented now? 
 If it used to be allowed then prevent it. 
 Runtime suspend should be allowed now. 
 If it used to be prevented then allow it. 
 Maybe we can autosuspend now. 
  pm_runtime_set_autosuspend_delay - Set a device's autosuspend_delay value.
  @dev: Device to handle.
  @delay: Value of the new delay in milliseconds.
  Set the device's power.autosuspend_delay value.  If it changes to negative
  and the power.use_autosuspend flag is set, prevent runtime suspends.  If it
  changes the other way, allow runtime suspends.
  __pm_runtime_use_autosuspend - Set a device's use_autosuspend flag.
  @dev: Device to handle.
  @use: New value for use_autosuspend.
  Set the device's power.use_autosuspend flag, and allow or prevent runtime
  suspends as needed.
  pm_runtime_init - Initialize runtime PM fields in given device object.
  @dev: Device object to initialize.
  pm_runtime_reinit - Re-initialize runtime PM fields in given device object.
  @dev: Device object to re-initialize.
  pm_runtime_remove - Prepare for removing a device from device hierarchy.
  @dev: Device object being removed from device hierarchy.
  pm_runtime_get_suppliers - Resume and reference-count supplier devices.
  @dev: Consumer device.
  pm_runtime_put_suppliers - Drop references to supplier devices.
  @dev: Consumer device.
  pm_runtime_drop_link - Prepare for device link removal.
  @link: Device link going away.
  Drop the link count of the consumer end of @link and decrement the supplier
  device's runtime PM usage counter as many times as needed to drop all of the
  PM runtime reference to it from the consumer.
  pm_runtime_force_suspend - Force a device into suspend state if needed.
  @dev: Device to suspend.
  Disable runtime PM so we safely can check the device's runtime PM status and
  if it is active, invoke its ->runtime_suspend callback to suspend it and
  change its runtime PM status field to RPM_SUSPENDED.  Also, if the device's
  usage and children counters don't indicate that the device was in use before
  the system-wide transition under way, decrement its parent's children counter
  (if there is a parent).  Keep runtime PM disabled to preserve the state
  unless we encounter errors.
  Typically this function may be invoked from a system suspend callback to make
  sure the device is put into low power state and it should only be used during
  system-wide PM transitions to sleep states.  It assumes that the analogous
  pm_runtime_force_resume() will be used to resume the device.
	
	  If the device can stay in suspend after the system-wide transition
	  to the working state that will follow, drop the children counter of
	  its parent, but set its status to RPM_SUSPENDED anyway in case this
	  function will be called again for it in the meantime.
  pm_runtime_force_resume - Force a device into resume state if needed.
  @dev: Device to resume.
  Prior invoking this function we expect the user to have brought the device
  into low power state by a call to pm_runtime_force_suspend(). Here we reverse
  those actions and bring the device into full power, if it is expected to be
  used on system resume.  In the other case, we defer the resume to be managed
  via runtime PM.
  Typically this function may be invoked from a system resume callback.
	
	  The value of the parent's children counter is correct already, so
	  just update the status of the device.
 SPDX-License-Identifier: GPL-2.0
 Device wakeirq helper functions 
  dev_pm_attach_wake_irq - Attach device interrupt as a wake IRQ
  @dev: Device entry
  @wirq: Wake irq specific data
  Internal function to attach a dedicated wake-up interrupt as a wake IRQ.
  dev_pm_set_wake_irq - Attach device IO interrupt as wake IRQ
  @dev: Device entry
  @irq: Device IO interrupt
  Attach a device IO interrupt as a wake IRQ. The wake IRQ gets
  automatically configured for wake-up from suspend  based
  on the device specific sysfs wakeup entry. Typically called
  during driver probe after calling device_init_wakeup().
  dev_pm_clear_wake_irq - Detach a device IO interrupt wake IRQ
  @dev: Device entry
  Detach a device wake IRQ and free resources.
  Note that it's OK for drivers to call this without calling
  dev_pm_set_wake_irq() as all the driver instances may not have
  a wake IRQ configured. This avoid adding wake IRQ specific
  checks into the drivers.
  handle_threaded_wake_irq - Handler for dedicated wake-up interrupts
  @irq: Device specific dedicated wake-up interrupt
  @_wirq: Wake IRQ data
  Some devices have a separate wake-up interrupt in addition to the
  device IO interrupt. The wake-up interrupt signals that a device
  should be woken up from it's idle state. This handler uses device
  specific pm_runtime functions to wake the device, and then it's
  up to the device to do whatever it needs to. Note that as the
  device may need to restore context and start up regulators, we
  use a threaded IRQ.
  Also note that we are not resending the lost device interrupts.
  We assume that the wake-up interrupt just needs to wake-up the
  device, and then device's pm_runtime_resume() can deal with the
  situation.
 Maybe abort suspend? 
 We don't want RPM_ASYNC or RPM_NOWAIT here 
 Prevent deferred spurious wakeirqs with disable_irq_nosync() 
	
	  Consumer device may need to power up and restore state
	  so we use a threaded irq.
  dev_pm_set_dedicated_wake_irq - Request a dedicated wake-up interrupt
  @dev: Device entry
  @irq: Device wake-up interrupt
  Unless your hardware has separate wake-up interrupts in addition
  to the device IO interrupts, you don't need this.
  Sets up a threaded interrupt handler for a device that has
  a dedicated wake-up interrupt in addition to the device IO
  interrupt.
  The interrupt starts disabled, and needs to be managed for
  the device by the bus code or the device driver using
  dev_pm_enable_wake_irq() and dev_pm_disable_wake_irq()
  functions.
  dev_pm_set_dedicated_wake_irq_reverse - Request a dedicated wake-up interrupt
                                          with reverse enable ordering
  @dev: Device entry
  @irq: Device wake-up interrupt
  Unless your hardware has separate wake-up interrupts in addition
  to the device IO interrupts, you don't need this.
  Sets up a threaded interrupt handler for a device that has a dedicated
  wake-up interrupt in addition to the device IO interrupt. It sets
  the status of WAKE_IRQ_DEDICATED_REVERSE to tell rpm_suspend()
  to enable dedicated wake-up interrupt after running the runtime suspend
  callback for @dev.
  The interrupt starts disabled, and needs to be managed for
  the device by the bus code or the device driver using
  dev_pm_enable_wake_irq() and dev_pm_disable_wake_irq()
  functions.
  dev_pm_enable_wake_irq - Enable device wake-up interrupt
  @dev: Device
  Optionally called from the bus code or the device driver for
  runtime_resume() to override the PM runtime core managed wake-up
  interrupt handling to enable the wake-up interrupt.
  Note that for runtime_suspend()) the wake-up interrupts
  should be unconditionally enabled unlike for suspend()
  that is conditional.
  dev_pm_disable_wake_irq - Disable device wake-up interrupt
  @dev: Device
  Optionally called from the bus code or the device driver for
  runtime_suspend() to override the PM runtime core managed wake-up
  interrupt handling to disable the wake-up interrupt.
  dev_pm_enable_wake_irq_check - Checks and enables wake-up interrupt
  @dev: Device
  @can_change_status: Can change wake-up interrupt status
  Enables wakeirq conditionally. We need to enable wake-up interrupt
  lazily on the first rpm_suspend(). This is needed as the consumer device
  starts in RPM_SUSPENDED state, and the the first pm_runtime_get() would
  otherwise try to disable already disabled wakeirq. The wake-up interrupt
  starts disabled with IRQ_NOAUTOEN set.
  Should be only called from rpm_suspend() and rpm_resume() path.
  Caller must hold &dev->power.lock to change wirq->status
  dev_pm_disable_wake_irq_check - Checks and disables wake-up interrupt
  @dev: Device
  @cond_disable: if set, also check WAKE_IRQ_DEDICATED_REVERSE
  Disables wake-up interrupt conditionally based on status.
  Should be only called from rpm_suspend() and rpm_resume() path.
  dev_pm_enable_wake_irq_complete - enable wake IRQ not enabled before
  @dev: Device using the wake IRQ
  Enable wake IRQ conditionally based on status, mainly used if want to
  enable wake IRQ after running ->runtime_suspend() which depends on
  WAKE_IRQ_DEDICATED_REVERSE.
  Should be only called from rpm_suspend() path.
  dev_pm_arm_wake_irq - Arm device wake-up
  @wirq: Device wake-up interrupt
  Sets up the wake-up event conditionally based on the
  device_may_wake().
  dev_pm_disarm_wake_irq - Disarm device wake-up
  @wirq: Device wake-up interrupt
  Clears up the wake-up event conditionally based on the
  device_may_wake().
 SPDX-License-Identifier: GPL-2.0
  driversbasepowerdomain.c - Common code related to device power domains.
  Copyright (C) 2011 Rafael J. Wysocki <rjw@sisk.pl>, Renesas Electronics Corp.
 Approximate 
	
	  Warn once if an IRQ safe device is attached to a no sleep domain, as
	  to indicate a suboptimal configuration for PM. For an always on
	  domain this isn't case, thus don't warn.
  Get the generic PM domain for a particular struct device.
  This validates the struct device pointer, the PM domain pointer,
  and checks that the PM domain pointer is a real generic PM domain.
  Any failure results in NULL being returned.
 A genpd's always have its ->runtime_suspend() callback assigned. 
  This should only be used where we are certain that the pm_domain
  attached to the device is a genpd domain.
	
	  If genpd->status is active, it means we are just
	  out of off and so update the idle time and vice
	  versa.
 New requested state is same as Max requested state 
 New requested state is higher than Max requested state 
 Traverse all devices within the domain 
	
	  Traverse all sub-domains within the domain. This can be
	  done without any additional locking as the link->performance_state
	  field is protected by the parent genpd->lock, which is already taken.
	 
	  Also note that link->performance_state (subdomain's performance state
	  requirement to parent domain) is different from
	  link->child->performance_state (current performance state requirement
	  of the devicessub-domains of the subdomain) and so can have a
	  different value.
	 
	  Note that we also take vote from powered-off sub-domains into account
	  as the same is done for devices right now.
 Propagate to parents of genpd 
 Find parent's performance state 
 Encountered an error, lets rollback 
  dev_pm_genpd_set_performance_state- Set performance state of device's power
  domain.
  @dev: Device for which the performance-state needs to be set.
  @state: Target performance state of the device. This can be set as 0 when the
 	   device doesn't have any performance state constraints left (And so
 	   the device wouldn't participate anymore to find the target
 	   performance state of the genpd).
  It is assumed that the users guarantee that the genpd wouldn't be detached
  while this routine is getting called.
  Returns 0 on success and negative error values on failures.
  dev_pm_genpd_set_next_wakeup - Notify PM framework of an impending wakeup.
  @dev: Device to handle
  @next: impending interruptwakeup for the device
  Allow devices to inform of the next wakeup. It's assumed that the users
  guarantee that the genpd wouldn't be detached while this routine is getting
  called. Additionally, it's also assumed that @dev isn't runtime suspended
  (RPM_SUSPENDED)."
  Although devices are expected to update the next_wakeup after the end of
  their usecase as well, it is possible the devices themselves may not know
  about that, so stale @next will be ignored when powering off the domain.
 Notify consumers that we are about to power on. 
 Notify consumers that we are about to power off. 
  genpd_queue_power_off_work - Queue up the execution of genpd_power_off().
  @genpd: PM domain to power off.
  Queue up the execution of genpd_power_off() unless it's already been done
  before.
  genpd_power_off - Remove power from a given PM domain.
  @genpd: PM domain to power down.
  @one_dev_on: If invoked from genpd's ->runtime_suspend|resume() callback, the
  RPM status of the releated device is in an intermediate state, not yet turned
  into RPM_SUSPENDED. This means genpd_power_off() must allow one device to not
  be RPM_SUSPENDED, while it tries to power off the PM domain.
  @depth: nesting count for lockdep.
  If all of the @genpd's devices have been suspended and all of its subdomains
  have been powered down, remove power from @genpd.
	
	  Do not try to power off the domain in the following situations:
	  (1) The domain is already in the "power off" state.
	  (2) System suspend is in progress.
	
	  Abort power off for the PM domain in the following situations:
	  (1) The domain is configured as always on.
	  (2) When the domain has a subdomain being powered on.
		
		  Do not allow PM domain to be powered off, when an IRQ safe
		  device is part of a non-IRQ safe domain.
 Default to shallowest state. 
 Don't power off, if a child domain is waiting to power on. 
  genpd_power_on - Restore power to a given PM domain and its parents.
  @genpd: PM domain to power up.
  @depth: nesting count for lockdep.
  Restore power to @genpd and all of its parents so that it is possible to
  resume a device belonging to it.
	
	  The list is guaranteed not to change while the loop below is being
	  executed, unless one of the parents' .power_on() callbacks fiddles
	  with it.
  genpd_power_off_work_fn - Power off PM domain whose subdomain count is 0.
  @work: Work structure used for scheduling the execution of this function.
  __genpd_runtime_suspend - walk the hierarchy of ->runtime_suspend() callbacks
  @dev: Device to handle.
  __genpd_runtime_resume - walk the hierarchy of ->runtime_resume() callbacks
  @dev: Device to handle.
  genpd_runtime_suspend - Suspend a device belonging to IO PM domain.
  @dev: Device to suspend.
  Carry out a runtime suspend of a device under the assumption that its
  pm_domain field points to the domain member of an object of type
  struct generic_pm_domain representing a PM domain consisting of IO devices.
	
	  A runtime PM centric subsystemdriver may re-use the runtime PM
	  callbacks for other purposes than runtime PM. In those scenarios
	  runtime PM is disabled. Under these circumstances, we shall skip
	  validatingmeasuring the PM QoS latency.
 Measure suspend latency. 
 Update suspend latency value if the measured time exceeds it. 
	
	  If power.irq_safe is set, this routine may be run with
	  IRQs disabled, so suspend only if the PM domain also is irq_safe.
  genpd_runtime_resume - Resume a device belonging to IO PM domain.
  @dev: Device to resume.
  Carry out a runtime resume of a device under the assumption that its
  pm_domain field points to the domain member of an object of type
  struct generic_pm_domain representing a PM domain consisting of IO devices.
	
	  As we don't power off a non IRQ safe domain, which holds
	  an IRQ safe device, we don't need to restore power to it.
 Measure resume latency. 
 Update resume latency value if the measured time exceeds it. 
  genpd_power_off_unused - Power off all PM domains with no devices in use.
  genpd_sync_power_off - Synchronously power off a PM domain and its parents.
  @genpd: PM domain to power off, if possible.
  @use_lock: use the lock.
  @depth: nesting count for lockdep.
  Check if the given PM domain can be powered off (during system suspend or
  hibernation) and do that if so.  Also, in that case propagate to its parents.
  This function is only called in "noirq" and "syscore" stages of system power
  transitions. The "noirq" callbacks may be executed asynchronously, thus in
  these cases the lock must be held.
 Choose the deepest state when suspending 
  genpd_sync_power_on - Synchronously power on a PM domain and its parents.
  @genpd: PM domain to power on.
  @use_lock: use the lock.
  @depth: nesting count for lockdep.
  This function is only called in "noirq" and "syscore" stages of system power
  transitions. The "noirq" callbacks may be executed asynchronously, thus in
  these cases the lock must be held.
  genpd_prepare - Start power transition of a device in a PM domain.
  @dev: Device to start the transition of.
  Start a power transition of a device (during a system-wide power transition)
  under the assumption that its pm_domain field points to the domain member of
  an object of type struct generic_pm_domain representing a PM domain
  consisting of IO devices.
 Never return 1, as genpd don't cope with the direct_complete path. 
  genpd_finish_suspend - Completion of suspend or hibernation of device in an
    IO pm domain.
  @dev: Device to suspend.
  @poweroff: Specifies if this is a poweroff_noirq or suspend_noirq callback.
  Stop the device and remove power from the domain if all devices in it have
  been stopped.
  genpd_suspend_noirq - Completion of suspend of device in an IO PM domain.
  @dev: Device to suspend.
  Stop the device and remove power from the domain if all devices in it have
  been stopped.
  genpd_resume_noirq - Start of resume of device in an IO PM domain.
  @dev: Device to resume.
  Restore power to the device's PM domain, if necessary, and start the device.
  genpd_freeze_noirq - Completion of freezing a device in an IO PM domain.
  @dev: Device to freeze.
  Carry out a late freeze of a device under the assumption that its
  pm_domain field points to the domain member of an object of type
  struct generic_pm_domain representing a power domain consisting of IO
  devices.
  genpd_thaw_noirq - Early thaw of device in an IO PM domain.
  @dev: Device to thaw.
  Start the device, unless power has been removed from the domain already
  before the system transition.
  genpd_poweroff_noirq - Completion of hibernation of device in an
    IO PM domain.
  @dev: Device to poweroff.
  Stop the device and remove power from the domain if all devices in it have
  been stopped.
  genpd_restore_noirq - Start of restore of device in an IO PM domain.
  @dev: Device to resume.
  Make sure the domain will be in the same power state as before the
  hibernation the system is resuming from and start the device if necessary.
	
	  At this point suspended_count == 0 means we are being run for the
	  first time for the given domain in the present cycle.
		
		  The boot kernel might put the domain into arbitrary state,
		  so make it appear as powered off to genpd_sync_power_on(),
		  so that it tries to power it on in case it was really off.
  genpd_complete - Complete power transition of a device in a power domain.
  @dev: Device to complete the transition of.
  Complete a power transition of a device (during a system-wide power
  transition) under the assumption that its pm_domain field points to the
  domain member of an object of type struct generic_pm_domain representing
  a power domain consisting of IO devices.
  dev_pm_genpd_suspend - Synchronously try to suspend the genpd for @dev
  @dev: The device that is attached to the genpd, that can be suspended.
  This routine should typically be called for a device that needs to be
  suspended during the syscore suspend phase. It may also be called during
  suspend-to-idle to suspend a corresponding CPU device that is attached to a
  genpd.
  dev_pm_genpd_resume - Synchronously try to resume the genpd for @dev
  @dev: The device that is attached to the genpd, which needs to be resumed.
  This routine should typically be called for a device that needs to be resumed
  during the syscore resume phase. It may also be called during suspend-to-idle
  to resume a corresponding CPU device that is attached to a genpd.
 !CONFIG_PM_SLEEP 
 CONFIG_PM_SLEEP 
  pm_genpd_add_device - Add a device to an IO PM domain.
  @genpd: PM domain to add the device to.
  @dev: Device to be added.
  pm_genpd_remove_device - Remove a device from an IO PM domain.
  @dev: Device to be removed.
  dev_pm_genpd_add_notifier - Add a genpd power onoff notifier for @dev
  @dev: Device that should be associated with the notifier
  @nb: The notifier block to register
  Users may call this function to add a genpd power onoff notifier for an
  attached @dev. Only one notifier per device is allowed. The notifier is
  sent when genpd is powering onoff the PM domain.
  It is assumed that the user guarantee that the genpd wouldn't be detached
  while this routine is getting called.
  Returns 0 on success and negative error values on failures.
  dev_pm_genpd_remove_notifier - Remove a genpd power onoff notifier for @dev
  @dev: Device that is associated with the notifier
  Users may call this function to remove a genpd power onoff notifier for an
  attached @dev.
  It is assumed that the user guarantee that the genpd wouldn't be detached
  while this routine is getting called.
  Returns 0 on success and negative error values on failures.
	
	  If the domain can be powered onoff in an IRQ safe
	  context, ensure that the subdomain can also be
	  powered onoff in that context.
  pm_genpd_add_subdomain - Add a subdomain to an IO PM domain.
  @genpd: Leader PM domain to add the subdomain to.
  @subdomain: Subdomain to be added.
  pm_genpd_remove_subdomain - Remove a subdomain from an IO PM domain.
  @genpd: Leader PM domain to remove the subdomain from.
  @subdomain: Subdomain to be removed.
  pm_genpd_init - Initialize a generic IO PM domain object.
  @genpd: PM domain object to initialize.
  @gov: PM domain governor to associate with the domain (may be NULL).
  @is_off: Initial value of the domain's power_is_off field.
  Returns 0 on successful initialization, else a negative error code.
 Always-on domains must be powered on at initialization. 
 Use only one "off" state if there were no states declared 
  pm_genpd_remove - Remove a generic IO PM domain
  @genpd: Pointer to PM domain that is to be removed.
  To remove the PM domain, this function:
   - Removes the PM domain as a subdomain to any parent domains,
     if it was added.
   - Removes the PM domain from the list of registered PM domains.
  The PM domain will only be removed, if the associated provider has
  been removed, it is not a parent to any other PM domain and has no
  devices associated with it.
  Device Tree based PM domain providers.
  The code below implements generic device tree based PM domain providers that
  bind device tree nodes with generic PM domains registered in the system.
  Any driver that registers generic PM domains and needs to support binding of
  devices to these domains is supposed to register a PM domain provider, which
  maps a PM domain specifier retrieved from the device tree to a PM domain.
  Two simple mapping functions have been provided for convenience:
   - genpd_xlate_simple() for 1:1 device tree node to PM domain mapping.
   - genpd_xlate_onecell() for mapping of multiple PM domains per node by
     index.
  struct of_genpd_provider - PM domain provider registration structure
  @link: Entry in global list of PM domain providers
  @node: Pointer to device tree node of PM domain provider
  @xlate: Provider-specific xlate callback mapping a set of specifier cells
          into a PM domain.
  @data: context pointer to be passed into @xlate callback
 List of registered PM domain providers. 
 Mutex to protect the list above. 
  genpd_xlate_simple() - Xlate function for direct node-domain mapping
  @genpdspec: OF phandle args to map into a PM domain
  @data: xlate function private data - pointer to struct generic_pm_domain
  This is a generic xlate function that can be used to model PM domains that
  have their own device tree nodes. The private data of xlate function needs
  to be a valid pointer to struct generic_pm_domain.
  genpd_xlate_onecell() - Xlate function using a single index.
  @genpdspec: OF phandle args to map into a PM domain
  @data: xlate function private data - pointer to struct genpd_onecell_data
  This is a generic xlate function that can be used to model simple PM domain
  controllers that have one device tree node and provide multiple PM domains.
  A single cell is used as an index into an array of PM domains specified in
  the genpd_onecell_data struct when registering the provider.
  genpd_add_provider() - Register a PM domain provider for a node
  @np: Device node pointer associated with the PM domain provider.
  @xlate: Callback for decoding PM domain from phandle arguments.
  @data: Context pointer for @xlate callback.
  of_genpd_add_provider_simple() - Register a simple PM domain provider
  @np: Device node pointer associated with the PM domain provider.
  @genpd: Pointer to PM domain associated with the PM domain provider.
 Parse genpd OPP table 
		
		  Save table for faster processing while setting performance
		  state.
  of_genpd_add_provider_onecell() - Register a onecell PM domain provider
  @np: Device node pointer associated with the PM domain provider.
  @data: Pointer to the data associated with the PM domain provider.
 Parse genpd OPP table 
			
			  Save table for faster processing while setting
			  performance state.
  of_genpd_del_provider() - Remove a previously registered PM domain provider
  @np: Device node pointer associated with the PM domain provider
			
			  For each PM domain associated with the
			  provider, set the 'has_provider' to false
			  so that the PM domain can be safely removed.
  genpd_get_from_provider() - Look-up PM domain
  @genpdspec: OF phandle args to use for look-up
  Looks for a PM domain provider under the node specified by @genpdspec and if
  found, uses xlate function of the provider to map phandle args to a PM
  domain.
  Returns a valid pointer to struct generic_pm_domain on success or ERR_PTR()
  on failure.
 Check if we have such a provider in our array 
  of_genpd_add_device() - Add a device to an IO PM domain
  @genpdspec: OF phandle args to use for look-up PM domain
  @dev: Device to be added.
  Looks-up an IO PM domain based upon phandle args provided and adds
  the device to the PM domain. Returns a negative error code on failure.
  of_genpd_add_subdomain - Add a subdomain to an IO PM domain.
  @parent_spec: OF phandle args to use for parent PM domain look-up
  @subdomain_spec: OF phandle args to use for subdomain look-up
  Looks-up a parent PM domain and subdomain based upon phandle args
  provided and adds the subdomain to the parent PM domain. Returns a
  negative error code on failure.
  of_genpd_remove_subdomain - Remove a subdomain from an IO PM domain.
  @parent_spec: OF phandle args to use for parent PM domain look-up
  @subdomain_spec: OF phandle args to use for subdomain look-up
  Looks-up a parent PM domain and subdomain based upon phandle args
  provided and removes the subdomain from the parent PM domain. Returns a
  negative error code on failure.
  of_genpd_remove_last - Remove the last PM domain registered for a provider
  @np: Pointer to device node associated with provider
  Find the last PM domain that was added by a particular provider and
  remove this PM domain from the list of PM domains. The provider is
  identified by the 'provider' device structure that is passed. The PM
  domain will only be removed, if the provider associated with domain
  has been removed.
  Returns a valid pointer to struct generic_pm_domain on success or
  ERR_PTR() on failure.
  genpd_dev_pm_detach - Detach a device from its PM domain.
  @dev: Device to detach.
  @power_off: Currently not used
  Try to locate a corresponding generic PM domain, which the device was
  attached to previously. If such is found, the device is detached from it.
 Drop the default performance state 
 Check if PM domain can be powered off after removing this device. 
 Unregister the device if it was created by genpd. 
 Set the default performance state 
  genpd_dev_pm_attach - Attach a device to its PM domain using DT.
  @dev: Device to attach.
  Parse device's OF node to find a PM domain specifier. If such is found,
  attaches the device to retrieved pm_domain ops.
  Returns 1 on successfully attached PM domain, 0 when the device don't need a
  PM domain or when multiple power-domains exists for it, else a negative error
  code. Note that if a power-domain exists for the device, but it cannot be
  found or turned on, then return -EPROBE_DEFER to ensure that the device is
  not probed and to re-try again later.
	
	  Devices with multiple PM domains must be attached separately, as we
	  can only attach one PM domain per device.
  genpd_dev_pm_attach_by_id - Associate a device with one of its PM domains.
  @dev: The device used to lookup the PM domain.
  @index: The index of the PM domain.
  Parse device's OF node to find a PM domain specifier at the provided @index.
  If such is found, creates a virtual device and attaches it to the retrieved
  pm_domain ops. To deal with detaching of the virtual device, the ->detach()
  callback in the struct dev_pm_domain are assigned to genpd_dev_pm_detach().
  Returns the created virtual device if successfully attached PM domain, NULL
  when the device don't need a PM domain, else an ERR_PTR() in case of
  failures. If a power-domain exists for the device, but cannot be found or
  turned on, then ERR_PTR(-EPROBE_DEFER) is returned to ensure that the device
  is not probed and to re-try again later.
 Verify that the index is within a valid range. 
 Allocate and register device on the genpd bus. 
 Try to attach the device to the PM domain at the specified index. 
  genpd_dev_pm_attach_by_name - Associate a device with one of its PM domains.
  @dev: The device used to lookup the PM domain.
  @name: The name of the PM domain.
  Parse device's OF node to find a PM domain specifier using the
  power-domain-names DT property. For further description see
  genpd_dev_pm_attach_by_id().
 Loop over the phandles until all the requested entry is found 
  of_genpd_parse_idle_states: Return array of idle states for the genpd.
  @dn: The genpd device node
  @states: The pointer to which the state array will be saved.
  @n: The count of elements in the array returned from this function.
  Returns the device states parsed from the OF node. The memory for the states
  is allocated by this function and is the responsibility of the caller to
  free the memory after use. If any or zero compatible domain idle states is
  found it returns 0 and in case of errors, a negative error code is returned.
  pm_genpd_opp_to_performance_state - Gets performance state of the genpd from its OPP node.
  @genpd_dev: Genpd's device for which the performance-state needs to be found.
  @opp: struct dev_pm_opp of the OPP for which we need to find performance
 	state.
  Returns performance state encoded in the OPP of the genpd. This calls
  platform specific genpd->opp_to_performance_state() callback to translate
  power domain OPP to performance state.
  Returns performance state on success and 0 on failure.
 CONFIG_PM_GENERIC_DOMAINS_OF 
        debugfs support        
  TODO: This function is a slightly modified version of rtpm_status_show
  from sysfs.c, so generalize it.
	
	  Modifications on the list require holding locks on both
	  parent and child, so we are safe.
	  Also genpd->name is immutable.
 CONFIG_DEBUG_FS 
 SPDX-License-Identifier: GPL-2.0
  driversbasepowerdomain_governor.c - Governors for device PM domains.
  Copyright (C) 2011 Rafael J. Wysocki <rjw@sisk.pl>, Renesas Electronics Corp.
		
		  Only take suspend-time QoS constraints of devices into
		  account, because constraints updated after the device has
		  been suspended are not guaranteed to be taken into account
		  anyway.  In order for them to take effect, the device has to
		  be resumed and suspended again.
		
		  The child is not in a domain and there's no info on its
		  suspendresume latencies, so assume them to be negligible and
		  take its current PM QoS constraint (that's the only thing
		  known at this point anyway).
  default_suspend_ok - Default PM domain governor routine to suspend devices.
  @dev: Device to check.
	
	  We can walk the children without any additional locking, because
	  they all have been suspended at this point and their
	  effective_constraint_ns fields won't be modified in parallel with us.
 "No restriction", so the device is allowed to suspend. 
		
		  This triggers if one of the children that don't belong to a
		  domain has a zero PM QoS constraint and it's better not to
		  suspend then.  effective_constraint_ns is zero already and
		  cached_suspend_ok is false, so bail out.
		
		  effective_constraint_ns is zero already and cached_suspend_ok
		  is false, so if the computed value is not positive, return
		  right away.
	
	  The children have been suspended already, so we don't need to take
	  their suspend latencies into account here.
	
	  Devices that have a predictable wakeup pattern, may specify
	  their next wakeup. Let's find the next wakeup from all the
	  devices attached to this domain and from all the sub-domains.
	  It is possible that component's a next wakeup may have become
	  stale when we read that here. We will ignore to ensure the domain
	  is able to enter its optimal idle state.
	
	  Check if subdomains can be off for enough time.
	 
	  All subdomains have been powered off already at this point.
		
		  Check if the subdomain is allowed to be off long enough for
		  the current domain to turn off and on (that's how much time
		  it will have to wait worst case).
	
	  Check if the devices in the domain can be off enough time.
		
		  Check if the device is allowed to be off long enough for the
		  domain to turn off and on (that's how much time it will
		  have to wait worst case).
		
		  Zero means "no suspend at all" and this runs only when all
		  devices in the domain are suspended, so it must be positive.
	
	  If the computed minimum device off time is negative, there are no
	  latency constraints, so the domain can spend arbitrary time in the
	  "off" state.
	
	  The difference between the computed minimum subdomain or device off
	  time and the time needed to turn the domain on is the maximum
	  theoretical time this domain can spend in the "off" state.
  _default_power_down_ok - Default generic PM domain power off governor routine.
  @pd: PM domain to check.
  @now: current ktime.
  This routine must be executed under the PM domain's lock.
	
	  Find the next wakeup from devices that can determine their own wakeup
	  to find when the domain would wakeup and do it for every device down
	  the hierarchy. It is not worth while to sleep if the state's residency
	  cannot be met.
 Let's find out the deepest domain idle state, the devices prefer 
	
	  We have to invalidate the cached results for the parents, so
	  use the observation that default_power_down_ok() is not
	  going to be called for any parent until this instance
	  returns.
	
	  Find a state to power down to, starting from the state
	  determined by the next wakeup.
 Validate dev PM QoS constraints. 
	
	  Find the next wakeup for any of the online CPUs within the PM domain
	  and its subdomains. Note, we only need the genpd->cpus, as it already
	  contains a mask of all CPUs from subdomains.
 The minimum idle duration is from now - until the next wakeup. 
	
	  Find the deepest idle state that has its residency value satisfied
	  and by also taking into account the power off latency for the state.
	  Start at the state picked by the dev PM QoS constraint validation.
  pm_genpd_gov_always_on - A governor implementing an always-on policy
 SPDX-License-Identifier: GPL-2.0
  Copyright 2019 NXP
 Basic test for aggregating two "min" requests 
 Test that requests for MAX_DEFAULT_VALUE have no effect 
 Add max 1000 
 Add max 2000, no impact 
 Remove max 1000, new max 2000 
  Test that a freq_qos_request can be added again after removal
  This issue was solved by commit 05ff1ba412fd ("PM: QoS: Invalidate frequency
  QoS requests after removal")
 Add 
 Remove 
 Add again 
 SPDX-License-Identifier: GPL-2.0
 sysfs entries for device PM 
 	control - Reportchange current runtime PM setting of the device
 	Runtime power management of a device can be blocked with the help of
 	this attribute.  All devices have one of the following two values for
 	the powercontrol file:
 	 + "auto\n" to allow the device to be power managed at run time;
 	 + "on\n" to prevent the device from being power managed at run time;
 	The default for all devices is "auto", which means that devices may be
 	subject to automatic power management, depending on their drivers.
 	Changing this attribute to "on" prevents the driver from power managing
 	the device at run time.  Doing that while the device is suspended causes
 	it to be woken up.
 	wakeup - Reportchange current wakeup option for device
 	Some devices support "wakeup" events, which are hardware signals
 	used to activate devices from suspended or low power states.  Such
 	devices have one of three values for the sysfs powerwakeup file:
 	 + "enabled\n" to issue the events;
 	 + "disabled\n" not to do so; or
 	 + "\n" for temporary or permanent inability to issue wakeup.
 	(For example, unconfigured USB devices can't issue wakeups.)
 	Familiar examples of devices that can issue wakeup events include
 	keyboards and mice (both PS2 and USB styles), power buttons, modems,
 	"Wake-On-LAN" Ethernet links, GPIO lines, and more.  Some events
 	will wake the entire system from a suspend state; others may just
 	wake up the device (if the system as a whole is already active).
 	Some wakeup events use normal IRQ lines; other use special out
 	of band signaling.
 	It is the responsibility of device drivers to enable (or disable)
 	wakeup signaling as part of changing device power states, respecting
 	the policy choices provided through the driver model.
 	Devices may not be able to generate wakeup events from all power
 	states.  Also, the events may be ignored in some configurations;
 	for example, they might need help from other devices that aren't
 	active, or which may have wakeup disabled.  Some drivers rely on
 	wakeup events internally (unless they are disabled), keeping
 	their hardware in low power modes whenever they're unused.  This
 	saves runtime power, without requiring system-wide sleep states.
 	async - Reportchange current async suspend setting for the device
 	Asynchronous suspend and resume of the device during system-wide power
 	state transitions can be enabled by writing "enabled" to this file.
 	Analogously, if "disabled" is written to this file, the device will be
 	suspended and resumed synchronously.
 	All devices have one of the following two values for powerasync:
 	 + "enabled\n" to permit the asynchronous suspendresume of the device;
 	 + "disabled\n" to forbid it;
 	NOTE: It generally is unsafe to permit the asynchronous suspendresume
 	of a device unless it is certain that all of the PM dependencies of the
 	device are known to the PM core.  However, for some devices this
 	attribute is set to "enabled" by bus type code or device drivers and in
 	that cases it should be safe to leave the default value.
 	autosuspend_delay_ms - Reportchange a device's autosuspend_delay value
 	Some drivers don't want to carry out a runtime suspend as soon as a
 	device becomes idle; they want it always to remain idle for some period
 	of time before suspending it.  This period is the autosuspend_delay
 	value (expressed in milliseconds) and it can be controlled by the user.
 	If the value is negative then the device will never be runtime
 	suspended.
 	NOTE: The autosuspend_delay_ms attribute and the autosuspend_delay
 	value are used only if the driver calls pm_runtime_use_autosuspend().
 	wakeup_count - Report the number of wakeup events related to the device
		
		  Prevent users from writing negative or "no constraint" values
		  directly.
 Users can't write negative values directly 
 CONFIG_PM_AUTOSLEEP 
 CONFIG_PM_SLEEP 
 CONFIG_PM_SLEEP 
 CONFIG_PM_ADVANCED_DEBUG 
 CONFIG_PM_ADVANCED_DEBUG 
 No need to create PM sysfs if explicitly disabled. 
 SPDX-License-Identifier: GPL-2.0
  Wakeup statistics in sysfs
  Copyright (c) 2019 Linux Foundation
  Copyright (c) 2019 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
  Copyright (c) 2019 Google Inc.
  wakeup_source_sysfs_add - Add wakeup_source attributes to sysfs.
  @parent: Device given wakeup source is associated with (or NULL if virtual).
  @ws: Wakeup source to be added in sysfs.
  pm_wakeup_source_sysfs_add - Add wakeup_source attributes to sysfs
  for a device if they're missing.
  @parent: Device given wakeup source is associated with
  wakeup_source_sysfs_remove - Remove wakeup_source attributes from sysfs.
  @ws: Wakeup source to be removed from sysfs.
 SPDX-License-Identifier: GPL-2.0
  driversbasepowergeneric_ops.c - Generic PM callbacks for subsystems
  Copyright (c) 2010 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.
  pm_generic_runtime_suspend - Generic runtime suspend callback for subsystems.
  @dev: Device to suspend.
  If PM operations are defined for the @dev's driver and they include
  ->runtime_suspend(), execute it and return its error code.  Otherwise,
  return 0.
  pm_generic_runtime_resume - Generic runtime resume callback for subsystems.
  @dev: Device to resume.
  If PM operations are defined for the @dev's driver and they include
  ->runtime_resume(), execute it and return its error code.  Otherwise,
  return 0.
 CONFIG_PM 
  pm_generic_prepare - Generic routine preparing a device for power transition.
  @dev: Device to prepare.
  Prepare a device for a system-wide power transition.
  pm_generic_suspend_noirq - Generic suspend_noirq callback for subsystems.
  @dev: Device to suspend.
  pm_generic_suspend_late - Generic suspend_late callback for subsystems.
  @dev: Device to suspend.
  pm_generic_suspend - Generic suspend callback for subsystems.
  @dev: Device to suspend.
  pm_generic_freeze_noirq - Generic freeze_noirq callback for subsystems.
  @dev: Device to freeze.
  pm_generic_freeze_late - Generic freeze_late callback for subsystems.
  @dev: Device to freeze.
  pm_generic_freeze - Generic freeze callback for subsystems.
  @dev: Device to freeze.
  pm_generic_poweroff_noirq - Generic poweroff_noirq callback for subsystems.
  @dev: Device to handle.
  pm_generic_poweroff_late - Generic poweroff_late callback for subsystems.
  @dev: Device to handle.
  pm_generic_poweroff - Generic poweroff callback for subsystems.
  @dev: Device to handle.
  pm_generic_thaw_noirq - Generic thaw_noirq callback for subsystems.
  @dev: Device to thaw.
  pm_generic_thaw_early - Generic thaw_early callback for subsystems.
  @dev: Device to thaw.
  pm_generic_thaw - Generic thaw callback for subsystems.
  @dev: Device to thaw.
  pm_generic_resume_noirq - Generic resume_noirq callback for subsystems.
  @dev: Device to resume.
  pm_generic_resume_early - Generic resume_early callback for subsystems.
  @dev: Device to resume.
  pm_generic_resume - Generic resume callback for subsystems.
  @dev: Device to resume.
  pm_generic_restore_noirq - Generic restore_noirq callback for subsystems.
  @dev: Device to restore.
  pm_generic_restore_early - Generic restore_early callback for subsystems.
  @dev: Device to resume.
  pm_generic_restore - Generic restore callback for subsystems.
  @dev: Device to restore.
  pm_generic_complete - Generic routine completing a device power transition.
  @dev: Device to handle.
  Complete a device power transition during a system-wide power transition.
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0
  driversbasepowercommon.c - Common device power management code.
  Copyright (C) 2011 Rafael J. Wysocki <rjw@sisk.pl>, Renesas Electronics Corp.
  dev_pm_get_subsys_data - Create or refcount power.subsys_data for device.
  @dev: Device to handle.
  If power.subsys_data is NULL, point it to a new object, otherwise increment
  its reference counter.  Return 0 if new object has been created or refcount
  increased, otherwise negative error code.
 kfree() verifies that its argument is nonzero. 
  dev_pm_put_subsys_data - Drop reference to power.subsys_data.
  @dev: Device to handle.
  If the reference counter of power.subsys_data is zero after dropping the
  reference, power.subsys_data is removed.
  dev_pm_domain_attach - Attach a device to its PM domain.
  @dev: Device to attach.
  @power_on: Used to indicate whether we should power on the device.
  The @dev may only be attached to a single PM domain. By iterating through
  the available alternatives we try to find a valid PM domain for the device.
  As attachment succeeds, the ->detach() callback in the struct dev_pm_domain
  should be assigned by the corresponding attach function.
  This function should typically be invoked from subsystem level code during
  the probe phase. Especially for those that holds devices which requires
  power management through PM domains.
  Callers must ensure proper synchronization of this function with power
  management callbacks.
  Returns 0 on successfully attached PM domain, or when it is found that the
  device doesn't need a PM domain, else a negative error code.
  dev_pm_domain_attach_by_id - Associate a device with one of its PM domains.
  @dev: The device used to lookup the PM domain.
  @index: The index of the PM domain.
  As @dev may only be attached to a single PM domain, the backend PM domain
  provider creates a virtual device to attach instead. If attachment succeeds,
  the ->detach() callback in the struct dev_pm_domain are assigned by the
  corresponding backend attach function, as to deal with detaching of the
  created virtual device.
  This function should typically be invoked by a driver during the probe phase,
  in case its device requires power management through multiple PM domains. The
  driver may benefit from using the received device, to configure device-links
  towards its original device. Depending on the use-case and if needed, the
  links may be dynamically changed by the driver, which allows it to control
  the power to the PM domains independently from each other.
  Callers must ensure proper synchronization of this function with power
  management callbacks.
  Returns the virtual created device when successfully attached to its PM
  domain, NULL in case @dev don't need a PM domain, else an ERR_PTR().
  Note that, to detach the returned virtual device, the driver shall call
  dev_pm_domain_detach() on it, typically during the remove phase.
  dev_pm_domain_attach_by_name - Associate a device with one of its PM domains.
  @dev: The device used to lookup the PM domain.
  @name: The name of the PM domain.
  For a detailed function description, see dev_pm_domain_attach_by_id().
  dev_pm_domain_detach - Detach a device from its PM domain.
  @dev: Device to detach.
  @power_off: Used to indicate whether we should power off the device.
  This functions will reverse the actions from dev_pm_domain_attach() and
  dev_pm_domain_attach_by_id(), thus it detaches @dev from its PM domain.
  Typically it should be invoked during the remove phase, either from
  subsystem level code or from drivers.
  Callers must ensure proper synchronization of this function with power
  management callbacks.
  dev_pm_domain_start - Start the device through its PM domain.
  @dev: Device to start.
  This function should typically be called during probe by a subsystemdriver,
  when it needs to start its device from the PM domain's perspective. Note
  that, it's assumed that the PM domain is already powered on when this
  function is called.
  Returns 0 on success and negative error values on failures.
  dev_pm_domain_set - Set PM domain of a device.
  @dev: Device whose PM domain is to be set.
  @pd: PM domain to be set, or NULL.
  Sets the PM domain the device belongs to. The PM domain of a device needs
  to be set before its probe finishes (it's bound to a driver).
  This function must be called with the device lock held.
 SPDX-License-Identifier: GPL-2.0
  Devices PM QoS constraints management
  Copyright (C) 2011 Texas Instruments, Inc.
  This module exposes the interface to kernel space for specifying
  per-device PM QoS dependencies. It provides infrastructure for registration
  of:
  Dependents on a QoS value : register requests
  Watchers of QoS value : get notified when target QoS value changes
  This QoS design is best effort based. Dependents register their QoS needs.
  Watchers register to keep track of the current QoS needs of the system.
  Watchers can register a per-device notification callback using the
  dev_pm_qos__notifier API. The notification chain data is stored in the
  per-device constraint data struct.
  Note about the per-device constraint data struct allocation:
  . The per-device constraints data struct ptr is stored into the device
     dev_pm_info.
  . To minimize the data usage by the per-device constraints, the data struct
    is only allocated at the first call to dev_pm_qos_add_request.
  . The data is later free'd when the device is removed from the system.
   . A global mutex protects the constraints users from the data being
      allocated and free'd.
  __dev_pm_qos_flags - Check PM QoS flags for a given device.
  @dev: Device to check the PM QoS flags for.
  @mask: Flags to check against.
  This routine must be called with dev->power.lock held.
  dev_pm_qos_flags - Check PM QoS flags for a given device (locked).
  @dev: Device to check the PM QoS flags for.
  @mask: Flags to check against.
  __dev_pm_qos_resume_latency - Get resume latency constraint for a given device.
  @dev: Device to get the PM QoS constraint value for.
  This routine must be called with dev->power.lock held.
  dev_pm_qos_read_value - Get PM QoS constraint for a given device (locked).
  @dev: Device to get the PM QoS constraint value for.
  @type: QoS request type.
  apply_constraint - Addmodifyremove device PM QoS request.
  @req: Constraint request to apply
  @action: Action to perform (addupdateremove).
  @value: Value to assign to the QoS request.
  Internal function to update the constraints list using the PM QoS core
  code and if needed call the per-device callbacks.
  dev_pm_qos_constraints_allocate
  @dev: device to allocate data for
  Called at the first call to add_request, for constraint data allocation
  Must be called with the dev_pm_qos_mtx mutex held
  dev_pm_qos_constraints_destroy
  @dev: target device
  Called from the device PM subsystem on device removal under device_pm_lock().
	
	  If the device's PM QoS resume latency limit or PM QoS flags have been
	  exposed to user space, they have to be hidden at this point.
 Flush the constraints lists for the device. 
		
		  Update constraints list and call the notification
		  callbacks if needed
  dev_pm_qos_add_request - inserts new qos request into the list
  @dev: target device for the constraint
  @req: pointer to a preallocated handle
  @type: type of the request
  @value: defines the qos request
  This function inserts a new entry in the device constraints list of
  requested qos performance characteristics. It recomputes the aggregate
  QoS expectations of parameters and initializes the dev_pm_qos_request
  handle.  Caller needs to save this handle for later use in updates and
  removal.
  Returns 1 if the aggregated constraint value has changed,
  0 if the aggregated constraint value has not changed,
  -EINVAL in case of wrong parameters, -ENOMEM if there's not enough memory
  to allocate for data structures, -ENODEV if the device has just been removed
  from the system.
  Callers should ensure that the target device is not RPM_SUSPENDED before
  using this function for requests of type DEV_PM_QOS_FLAGS.
  __dev_pm_qos_update_request - Modify an existing device PM QoS request.
  @req : PM QoS request to modify.
  @new_value: New value to request.
guard against callers passing in null 
  dev_pm_qos_update_request - modifies an existing qos request
  @req : handle to list element holding a dev_pm_qos request to use
  @new_value: defines the qos request
  Updates an existing dev PM qos request along with updating the
  target value.
  Attempts are made to make this code callable on hot code paths.
  Returns 1 if the aggregated constraint value has changed,
  0 if the aggregated constraint value has not changed,
  -EINVAL in case of wrong parameters, -ENODEV if the device has been
  removed from the system
  Callers should ensure that the target device is not RPM_SUSPENDED before
  using this function for requests of type DEV_PM_QOS_FLAGS.
guard against callers passing in null 
  dev_pm_qos_remove_request - modifies an existing qos request
  @req: handle to request list element
  Will remove pm qos request from the list of constraints and
  recompute the current target value. Call this on slow code paths.
  Returns 1 if the aggregated constraint value has changed,
  0 if the aggregated constraint value has not changed,
  -EINVAL in case of wrong parameters, -ENODEV if the device has been
  removed from the system
  Callers should ensure that the target device is not RPM_SUSPENDED before
  using this function for requests of type DEV_PM_QOS_FLAGS.
  dev_pm_qos_add_notifier - sets notification entry for changes to target value
  of per-device PM QoS constraints
  @dev: target device for the constraint
  @notifier: notifier block managed by caller.
  @type: request type.
  Will register the notifier into a notification chain that gets called
  upon changes to the target value for the device.
  If the device's constraints object doesn't exist when this routine is called,
  it will be created (or error code will be returned if that fails).
  dev_pm_qos_remove_notifier - deletes notification for changes to target value
  of per-device PM QoS constraints
  @dev: target device for the constraint
  @notifier: notifier block to be removed.
  @type: request type.
  Will remove the notifier from the notification chain that gets called
  upon changes to the target value.
 Silently return if the constraints object is not present. 
  dev_pm_qos_add_ancestor_request - Add PM QoS request for device's ancestor.
  @dev: Device whose ancestor to add the request for.
  @req: Pointer to the preallocated handle.
  @type: Type of the request.
  @value: Constraint latency value.
  dev_pm_qos_expose_latency_limit - Expose PM QoS latency limit to user space.
  @dev: Device whose PM QoS latency limit is to be exposed to user space.
  @value: Initial value of the latency limit.
  dev_pm_qos_hide_latency_limit - Hide PM QoS latency limit from user space.
  @dev: Device whose PM QoS latency limit is to be hidden from user space.
  dev_pm_qos_expose_flags - Expose PM QoS flags of a device to user space.
  @dev: Device whose PM QoS flags are to be exposed to user space.
  @val: Initial values of the flags.
  dev_pm_qos_hide_flags - Hide PM QoS flags of a device from user space.
  @dev: Device whose PM QoS flags are to be hidden from user space.
  dev_pm_qos_update_flags - Update PM QoS flags request owned by user space.
  @dev: Device to update the PM QoS flags request for.
  @mask: Flags to setclear.
  @set: Whether to set or clear the flags (true means set).
  dev_pm_qos_get_user_latency_tolerance - Get user space latency tolerance.
  @dev: Device to obtain the user space latency tolerance for.
  dev_pm_qos_update_user_latency_tolerance - Update user space latency tolerance.
  @dev: Device to update the user space latency tolerance for.
  @val: New user space latency tolerance for @dev (negative values disable).
  dev_pm_qos_expose_latency_tolerance - Expose latency tolerance to userspace
  @dev: Device whose latency tolerance to expose
  dev_pm_qos_hide_latency_tolerance - Hide latency tolerance from userspace
  @dev: Device whose latency tolerance to hide
 Remove the request from user space now 
 SPDX-License-Identifier: GPL-2.0
  driversbasepowertrace.c
  Copyright (C) 2006 Linus Torvalds
  Trace facility for suspendresume problems, when none of the
  devices may be working.
  Horrid, horrid, horrid.
  It turns out that the _only_ piece of hardware that actually
  keeps its value across a hard boot (and, more importantly, the
  POST init sequence) is literally the realtime clock.
  Never mind that an RTC chip has 114 bytes (and often a whole
  other bank of an additional 128 bytes) of nice SRAM that is
  _designed_ to keep data - the POST will clear it. So we literally
  can just use the few bytes of actual time data, which means that
  we're really limited.
  It means, for example, that we can't use the seconds at all
  (since the time between the hang and the boot might be more
  than a minute), and we'd better not depend on the low bits of
  the minutes either.
  There are the wday fields etc, but I wouldn't guarantee those
  are dependable either. And if the date isn't valid, either the
  hw or POST will do strange things.
  So we're left with:
   - year: 0-99
   - month: 0-11
   - day-of-month: 1-28
   - hour: 0-23
   - min: (0-30)2
  Giving us a total range of 0-16128000 (0xf61800), ie less
  than 24 bits of actual data we can save across reboots.
  And if your box can't boot in less than three minutes,
  you're screwed.
  Now, almost 24 bits of data is pitifully small, so we need
  to be pretty dense if we want to use it for anything nice.
  What we do is that instead of saving off nice readable info,
  we save off _hashes_ of information that we can hopefully
  regenerate after the reboot.
  In particular, this means that we might be unlucky, and hit
  a case where we have a hash collision, and we end up not
  being able to tell for certain exactly which case happened.
  But that's hopefully unlikely.
  What we do is to take the bits we can fit, and split them
  into three parts (169971009 = 16095568), and use the values
  for:
   - 0-15: user-settable
   - 0-996: file + line number
   - 0-1008: device
 June 7th, 2006
 June - counting from zero
 100 years 
 12 months 
 28 month-days 
 24 hours 
 20 3-minute intervals 
  This is just the sdbm hash function with a user-supplied
  seed and final size parameter.
  We could just take the "tracedata" index into the .tracedata
  section instead. Generating a hash of the data gives us a
  chance to work across kernel versions, and perhaps more
  importantly it also gives us validinvalid check (ie we will
  likely not give totally bogus reports - if the hash matches,
  it's not any guarantee, but it's a high _likelihood_ that
  the match is valid).
	
	  It's possible that multiple devices will match the hash and we can't
	  tell which is the culprit, so it's best to output them all.
 % DEVHASH ;
 SPDX-License-Identifier: GPL-2.0
  driversbasepowermain.c - Where the driver meets power management.
  Copyright (c) 2003 Patrick Mochel
  Copyright (c) 2003 Open Source Development Lab
  The driver model core calls device_pm_add() when a device is registered.
  This will initialize the embedded device_pm_info object in the device
  and add it to the list of power-controlled devices. sysfs entries for
  controlling device power management will also be added.
  A separate list is used for keeping track of power info, because the power
  domain dependencies may differ from the ancestral dependencies that the
  subsystem list maintains.
  The entries in the dpm_list list are in a depth first order, simply
  because children are guaranteed to be discovered after parents, and
  are inserted at the back of the list on discovery.
  Since device_pm_add() may be called with a device lock held,
  we must never try to acquire a device lock while holding
  dpm_list_mutex.
  device_pm_sleep_init - Initialize system suspend-related device fields.
  @dev: Device object being initialized.
  device_pm_lock - Lock the list of active devices used by the PM core.
  device_pm_unlock - Unlock the list of active devices used by the PM core.
  device_pm_add - Add a device to the PM core's list of active devices.
  @dev: Device to add to the list.
 Skip PM setupinitialization. 
  device_pm_remove - Remove a device from the PM core's list of active devices.
  @dev: Device to be removed from the list.
  device_pm_move_before - Move device in the PM core's list of active devices.
  @deva: Device to move in dpm_list.
  @devb: Device @deva should come before.
 Delete deva from dpm_list and reinsert before devb. 
  device_pm_move_after - Move device in the PM core's list of active devices.
  @deva: Device to move in dpm_list.
  @devb: Device @deva should come after.
 Delete deva from dpm_list and reinsert after devb. 
  device_pm_move_last - Move device to end of the PM core's list of devices.
  @dev: Device to move in dpm_list.
  dpm_wait - Wait for a PM operation to complete.
  @dev: Device to wait for.
  @async: If unset, wait only if the device's power.async_suspend flag is set.
	
	  If the supplier goes away right after we've checked the link to it,
	  we'll wait for its completion to change the state, but that's fine,
	  because the only things that will block as a result are the SRCU
	  callbacks freeing the link objects for the links in the list we're
	  walking.
	
	  If the device is resumed asynchronously and the parent's callback
	  deletes both the device and the parent itself, the parent object may
	  be freed while this function is running, so avoid that by reference
	  counting the parent once more unless the device has been deleted
	  already (in which case return right away).
	
	  If the parent's callback has deleted the device, attempting to resume
	  it would be invalid, so avoid doing that then.
	
	  The status of a device link can only be changed from "dormant" by a
	  probe, but that cannot happen during system suspendresume.  In
	  theory it can change to "dormant" at that time, but then it is
	  reasonable to wait for the target device anyway (eg. if it goes
	  away, it's better to wait for it to go away completely and then
	  continue instead of trying to continue in parallel with its
	  unregistration).
  pm_op - Return the PM operation appropriate for given PM event.
  @ops: PM operations to choose from.
  @state: PM transition of the system being carried out.
 CONFIG_SUSPEND 
 CONFIG_HIBERNATE_CALLBACKS 
  pm_late_early_op - Return the PM operation appropriate for given PM event.
  @ops: PM operations to choose from.
  @state: PM transition of the system being carried out.
  Runtime PM is disabled for @dev while this function is being executed.
 CONFIG_SUSPEND 
 CONFIG_HIBERNATE_CALLBACKS 
  pm_noirq_op - Return the PM operation appropriate for given PM event.
  @ops: PM operations to choose from.
  @state: PM transition of the system being carried out.
  The driver of @dev will not receive interrupts while this function is being
  executed.
 CONFIG_SUSPEND 
 CONFIG_HIBERNATE_CALLBACKS 
  dpm_watchdog_handler - Driver suspend  resume watchdog handler.
  @t: The timer that PM watchdog depends on.
  Called when a driver has timed out suspending or resuming.
  There's not much we can do here to recover so panic() to
  capture a crash-dump in pstore.
  dpm_watchdog_set - Enable pm watchdog for given device.
  @wd: Watchdog. Must be allocated on the stack.
  @dev: Device to handle.
 use same timeout value for both suspend and resume 
  dpm_watchdog_clear - Disable suspendresume watchdog.
  @wd: Watchdog to disable.
------------------------- Resume routines -------------------------
  dev_pm_skip_resume - System-wide device resume optimization check.
  @dev: Target device.
  Return:
  - %false if the transition under way is RESTORE.
  - Return value of dev_pm_skip_suspend() if the transition under way is THAW.
  - The logical negation of %power.must_resume otherwise (that is, when the
    transition under way is RESUME).
  device_resume_noirq - Execute a "noirq resume" callback for given device.
  @dev: Device to handle.
  @state: PM transition of the system being carried out.
  @async: If true, the device is being resumed asynchronously.
  The driver of @dev will not receive interrupts while this function is being
  executed.
	
	  If the driver callback is skipped below or by the middle layer
	  callback and device_resume_early() also skips the driver callback for
	  this device later, it needs to appear as "suspended" to PM-runtime,
	  so change its status accordingly.
	 
	  Otherwise, the device is going to be resumed, so set its PM-runtime
	  status to "active", but do that only if DPM_FLAG_SMART_SUSPEND is set
	  to avoid confusing drivers that don't use it.
	
	  Advanced the async threads upfront,
	  in case the starting of async threads is
	  delayed by non-async resuming devices.
  dpm_resume_noirq - Execute "noirq resume" callbacks for all devices.
  @state: PM transition of the system being carried out.
  Invoke the "noirq" resume callbacks for all devices in dpm_noirq_list and
  allow device drivers' interrupt handlers to be called.
  device_resume_early - Execute an "early resume" callback for given device.
  @dev: Device to handle.
  @state: PM transition of the system being carried out.
  @async: If true, the device is being resumed asynchronously.
  Runtime PM is disabled for @dev while this function is being executed.
  dpm_resume_early - Execute "early resume" callbacks for all devices.
  @state: PM transition of the system being carried out.
	
	  Advanced the async threads upfront,
	  in case the starting of async threads is
	  delayed by non-async resuming devices.
  dpm_resume_start - Execute "noirq" and "early" device callbacks.
  @state: PM transition of the system being carried out.
  device_resume - Execute "resume" callbacks for given device.
  @dev: Device to handle.
  @state: PM transition of the system being carried out.
  @async: If true, the device is being resumed asynchronously.
 Match the pm_runtime_disable() in __device_suspend(). 
	
	  This is a fib.  But we'll allow new children to be added below
	  a resumed device, even if the device hasn't been completed yet.
  dpm_resume - Execute "resume" callbacks for non-sysdev devices.
  @state: PM transition of the system being carried out.
  Execute the appropriate "resume" callback for all devices whose status
  indicates that they are suspended.
  device_complete - Complete a PM transition for given device.
  @dev: Device to handle.
  @state: PM transition of the system being carried out.
  dpm_complete - Complete a PM transition for all non-sysdev devices.
  @state: PM transition of the system being carried out.
  Execute the ->complete() callbacks for all devices whose PM status is not
  DPM_ON (this allows new devices to be registered).
 Allow device probing and trigger re-probing of deferred devices 
  dpm_resume_end - Execute "resume" callbacks and complete system transition.
  @state: PM transition of the system being carried out.
  Execute "resume" callbacks for all devices and complete the PM transition of
  the system.
------------------------- Suspend routines -------------------------
  resume_event - Return a "resume" message for given "suspend" sleep state.
  @sleep_state: PM message representing a sleep state.
  Return a PM message representing the resume event corresponding to given
  sleep state.
  __device_suspend_noirq - Execute a "noirq suspend" callback for given device.
  @dev: Device to handle.
  @state: PM transition of the system being carried out.
  @async: If true, the device is being suspended asynchronously.
  The driver of @dev will not receive interrupts while this function is being
  executed.
	
	  Skipping the resume of devices that were in use right before the
	  system suspend (as indicated by their PM-runtime usage counters)
	  would be suboptimal.  Also resume them if doing that is not allowed
	  to be skipped.
  dpm_suspend_noirq - Execute "noirq suspend" callbacks for all devices.
  @state: PM transition of the system being carried out.
  Prevent device drivers' interrupt handlers from being called and invoke
  "noirq" suspend callbacks for all non-sysdev devices.
  __device_suspend_late - Execute a "late suspend" callback for given device.
  @dev: Device to handle.
  @state: PM transition of the system being carried out.
  @async: If true, the device is being suspended asynchronously.
  Runtime PM is disabled for @dev while this function is being executed.
  dpm_suspend_late - Execute "late suspend" callbacks for all devices.
  @state: PM transition of the system being carried out.
  dpm_suspend_end - Execute "late" and "noirq" device suspend callbacks.
  @state: PM transition of the system being carried out.
  legacy_suspend - Execute a legacy (bus or class) suspend callback for device.
  @dev: Device to suspend.
  @state: PM transition of the system being carried out.
  @cb: Suspend callback to execute.
  @info: string description of caller.
  __device_suspend - Execute "suspend" callbacks for given device.
  @dev: Device to handle.
  @state: PM transition of the system being carried out.
  @async: If true, the device is being suspended asynchronously.
	
	  Wait for possible runtime PM transitions of the device in progress
	  to complete and if there's a runtime resume request pending for it,
	  resume it before proceeding with invoking the system-wide suspend
	  callbacks for it.
	 
	  If the system-wide suspend callbacks below change the configuration
	  of the device, they must disable runtime PM for it or otherwise
	  ensure that its runtime-resume callbacks will not be confused by that
	  change in case they are invoked going forward.
 Avoid direct_complete to let wakeup_path propagate. 
  dpm_suspend - Execute "suspend" callbacks for all non-sysdev devices.
  @state: PM transition of the system being carried out.
  device_prepare - Prepare a device for system power transition.
  @dev: Device to handle.
  @state: PM transition of the system being carried out.
  Execute the ->prepare() callback(s) for given device.  No new children of the
  device may be registered after this function has returned.
	
	  If a device's parent goes into runtime suspend at the wrong time,
	  it won't be possible to resume the device.  To prevent this we
	  block runtime suspend here, during the prepare phase, and allow
	  it again during the complete phase.
	
	  A positive return value from ->prepare() means "this device appears
	  to be runtime-suspended and its state is fine, so if it really is
	  runtime-suspended, you can leave it in that state provided that you
	  will do the same thing with all of its descendants".  This only
	  applies to suspend transitions, however.
  dpm_prepare - Prepare all non-sysdev devices for a system PM transition.
  @state: PM transition of the system being carried out.
  Execute the ->prepare() callback(s) for all devices.
	
	  Give a chance for the known devices to complete their probes, before
	  disable probing of devices. This sync point is important at least
	  at boot time + hibernation restore.
	
	  It is unsafe if probing of devices will happen during suspend or
	  hibernation and system behavior will be unpredictable in this case.
	  So, let's prohibit device's probing here and defer their probes
	  instead. The normal behavior will be restored in dpm_complete().
  dpm_suspend_start - Prepare devices for PM transition and suspend them.
  @state: PM transition of the system being carried out.
  Prepare all non-sysdev devices for system PM transition and execute "suspend"
  callbacks for them.
  device_pm_wait_for_dev - Wait for suspendresume of a device to complete.
  @subordinate: Device that needs to wait for @dev.
  @dev: Device to wait for.
  dpm_for_each_dev - device iterator.
  @data: data for the callback.
  @fn: function to be called for each device.
  Iterate over devices in dpm_list, and call @fn for each device,
  passing it @data.
 SPDX-License-Identifier: GPL-2.0-only
  HSI core.
  Copyright (C) 2010 Nokia Corporation. All rights reserved.
  Contact: Carlos Chinea <carlos.chinea@nokia.com>
 register hsi-char device 
  hsi_port_unregister_clients - Unregister an HSI port
  @port: The HSI port to unregister
  hsi_unregister_controller - Unregister an HSI controller
  @hsi: The HSI controller to register
  hsi_register_controller - Register an HSI controller and its ports
  @hsi: The HSI controller to register
  Returns -errno on failure, 0 on success.
 Populate HSI bus with HSI clients 
  hsi_register_client_driver - Register an HSI client to the HSI bus
  @drv: HSI client driver to register
  Returns -errno on failure, 0 on success.
  hsi_put_controller - Free an HSI controller
  @hsi: Pointer to the HSI controller to freed
  HSI controller drivers should only use this function if they need
  to free their allocated hsi_controller structures before a successful
  call to hsi_register_controller. Other use is not allowed.
  hsi_alloc_controller - Allocate an HSI controller and its ports
  @n_ports: Number of ports on the HSI controller
  @flags: Kernel allocation flags
  Return NULL on failure or a pointer to an hsi_controller on success.
  hsi_free_msg - Free an HSI message
  @msg: Pointer to the HSI message
  Client is responsible to free the buffers pointed by the scatterlists.
  hsi_alloc_msg - Allocate an HSI message
  @nents: Number of memory entries
  @flags: Kernel allocation flags
  nents can be 0. This mainly makes sense for read transfer.
  In that case, HSI drivers will call the complete callback when
  there is data to be read without consuming it.
  Return NULL on failure or a pointer to an hsi_msg on success.
  hsi_async - Submit an HSI transfer to the controller
  @cl: HSI client sending the transfer
  @msg: The HSI transfer passed to controller
  The HSI message must have the channel, ttype, complete and destructor
  fields set beforehand. If nents > 0 then the client has to initialize
  also the scatterlists to point to the buffers to write to or read from.
  HSI controllers relay on pre-allocated buffers from their clients and they
  do not allocate buffers on their own.
  Once the HSI message transfer finishes, the HSI controller calls the
  complete callback with the status and actual_len fields of the HSI message
  updated. The complete callback can be called before returning from
  hsi_async.
  Returns -errno on failure or 0 on success
  hsi_claim_port - Claim the HSI client's port
  @cl: HSI client that wants to claim its port
  @share: Flag to indicate if the client wants to share the port or not.
  Returns -errno on failure, 0 on success.
  hsi_release_port - Release the HSI client's port
  @cl: HSI client which previously claimed its port
 Allow HW driver to do some cleanup 
  hsi_register_port_event - Register a client to receive port events
  @cl: HSI client that wants to receive port events
  @handler: Event handler callback
  Clients should register a callback to be able to receive
  events from the ports. Registration should happen after
  claiming the port.
  The handler can be called in interrupt context.
  Returns -errno on error, or 0 on success.
  hsi_unregister_port_event - Stop receiving port events for a client
  @cl: HSI client that wants to stop receiving port events
  Clients should call this function before releasing their associated
  port.
  Returns -errno on error, or 0 on success.
  hsi_event - Notifies clients about port events
  @port: Port where the event occurred
  @event: The event type
  Clients should not be concerned about wake line behavior. However, due
  to a race condition in HSI HW protocol, clients need to be notified
  about wake line changes, so they can implement a workaround for it.
  Events:
  HSI_EVENT_START_RX - Incoming wake line high
  HSI_EVENT_STOP_RX - Incoming wake line down
  Returns -errno on error, or 0 on success.
  hsi_get_channel_id_by_name - acquire channel id by channel name
  @cl: HSI client, which uses the channel
  @name: name the channel is known under
  Clients can call this function to get the hsi channel ids similar to
  requesting IRQs or GPIOs by name. This function assumes the same
  channel configuration is used for RX and TX.
  Returns -errno on error or channel id on success.
 SPDX-License-Identifier: GPL-2.0-only
  HSI clients registration interface
  Copyright (C) 2010 Nokia Corporation. All rights reserved.
  Contact: Carlos Chinea <carlos.chinea@nokia.com>
  hsi_board_list is only used internally by the HSI framework.
  No one else is allowed to make use of it.
  hsi_register_board_info - Register HSI clients information
  @info: Array of HSI clients on the board
  @len: Length of the array
  HSI clients are statically declared and registered on board files.
  HSI clients will be automatically registered to the HSI bus once the
  controller and the port where the clients wishes to attach are registered
  to it.
  Return -errno on failure, 0 on success.
 SPDX-License-Identifier: GPL-2.0-only
 OMAP SSI port driver.
  Copyright (C) 2010 Nokia Corporation. All rights reserved.
  Copyright (C) 2014 Sebastian Reichel <sre@kernel.org>
  Contact: Carlos Chinea <carlos.chinea@nokia.com>
 SST 
 SSR 
 Hold clocks during the transfer 
 Sync 
 Sync 
 Hold clocks for pio writes 
 TODO: Add sg support 
  2 : SSI TX clock is always half of the SSI functional clock 
 Round down when tx_fckrate % omap_ssi->max_speed == 0 
 Set TXRX module to sleep to stop TXRX during cfg update 
 Flush posted write 
 TX 
 RX 
 Cleanup the break queue if we leave FRAME mode 
 Shadow registering for OFF mode 
 SST 
 SSR 
 stop all ssi communication 
 wait for racing frames 
 Stop all DMA transfers 
 Flush all SST buffers 
 Flush all SSR buffers 
 Flush all errors 
 Flush break 
 Clear interrupts 
 Dequeue all pending requests 
 Release write clocks 
 Resume SSI communication 
 Grab clocks 
 Release clocks 
 Release the clocks writes, also GDD ones 
 Check if we keep the error detection interrupt armed 
 Cleanup write buffers 
 Cleanup read buffers 
 Disarm and ack pending interrupts 
		
		  Clock references for write will be handled in
		  ssi_cleanup_queues
 OCP barrier 
 Stop all the pending DMA requests for that client 
 Now cleanup all the queues 
 If it is the last client of the port, do extra checks and cleanup 
		
		  Drop the clock reference for the incoming wake line
		  if it is still kept high by the other side.
 Stop any SSI TXRX without a client 
 ACK error 
 Cancel all GDD read transfers 
 Cancel all PIO read transfers 
 Disable error & all dataavailable interrupts 
 ACK error 
 Signal the error all current pending read requests 
 Now restart queued reads if any 
		
		  Wait for the last written frame to be really sent before
		  we call the complete callback
 Transfer completed at this point 
 Release clocks for write transfer 
 TODO: sleep if we retry? 
		
		  We can have a quick High-Low-High transition in the line.
		  In such a case if we have long interrupt latencies,
		  we can miss the low event or get twice a high event.
		  This workaround will avoid breaking the clock reference
		  count when such a situation ocurrs.
 FIXME: HACK ! To be removed 
 FIXME: HACK ! To be removed 
 get id of first uninitialized port in controller 
 initialize HSI port 
 update divisor 
 SST context 
 SSR context 
 OCP barrier 
 We always need to restore the mode & TX divisor 
 SPDX-License-Identifier: GPL-2.0-only
 OMAP SSI driver.
  Copyright (C) 2010 Nokia Corporation. All rights reserved.
  Copyright (C) 2014 Sebastian Reichel <sre@kernel.org>
  Contact: Carlos Chinea <carlos.chinea@nokia.com>
 For automatically allocated device IDs 
 SSI controller 
 SSI GDD (DMA) 
 CONFIG_DEBUG_FS 
  FIXME: Horrible HACK needed until we remove the useless wakeline test
  in the CMT. To be removed !!!!
 Keep clocks reference for write pio event 
 release GDD lch 
 Timeout error 
 Dequeue msg 
 Workaround for SWBREAK + CAwake down race in CMT 
 stop all ssi communication 
 wait for racing frames 
 kHz 
 resume ssi communication 
 TODO: find register, which can be used to detect context loss 
 Resetting GDD 
 Get FCK rate in kHz 
 cleanup of of_platform_populate() call 
 SPDX-License-Identifier: GPL-2.0-only
  cmt_speech.c - HSI CMT speech driver
  Copyright (C) 2008,2009,2010 Nokia Corporation. All rights reserved.
  Contact: Kai Vehmanen <kai.vehmanen@nokia.com>
  Original author: Peter Ujfalusi <peter.ujfalusi@nokia.com>
 mmap things 
 hsi channel ids 
 Number of pre-allocated commands buffers 
  During data transfers, transactions must be handled
  within 20ms (fixed value in cmtspeech HSI protocol)
 Timeout to wait for pending HSI transfers to complete 
 state exposed to application 
	 note: for security reasons, we do not trust the contents of
 size of aligned memory blocks 
	
	  Make sure control read is always pending when issuing
	  new control writes. This is needed as the controller
	  may flush our messages if e.g. the peer device reboots
	  unexpectedly (and we cannot directly resubmit a new read from
	  the message destructor; see cs_cmd_destructor()).
 expose current rx ptr in mmap area 
  Readwrite transaction is ongoing. Returns false if in
  SSI_CHANNEL_STATE_POLL state.
  No pending readwrites
		
		  For more robust overrun detection, let the rx
		  pointer run in range 0..'boundary-1'. Boundary
		  is a multiple of rx_bufs, and limited in max size
		  by RX_PTR_MAX_SHIFT to allow for fast ptr-diff
		  calculation.
  Block until pending data transfers have completed.
		
		  prepare_to_wait must be called with hi->lock held
		  so that callbacks can check for waitqueue_active()
 Prevent new transactions during buffer reconfig 
	
	  make sure that no non-zero data reads are ongoing before
	  proceeding to change the buffer layout
 hsi_release_port() needs to be called with CS_STATE_CLOSED 
	
	  hsi_release_port() should flush out all the pending
	  messages, so cs_state_idle() should be true for both
	  control and data channels.
 these are only used in release so lock not needed 
 SPDX-License-Identifier: GPL-2.0-only
  HSI character device driver, implements the character device
  interface.
  Copyright (C) 2010 Nokia Corporation. All rights reserved.
  Contact: Andras Domokos <andras.domokos@nokia.com>
 Num of channels 
  We support up to 4 controllers that can have up to 4
  ports, which should currently be more than enough.
  struct hsc_channel - hsi_char internal channel data
  @ch: channel number
  @flags: Keeps state of the channel (openclose, reading, writing)
  @free_msgs_list: List of free HSI messagesrequests
  @rx_msgs_queue: List of pending RX requests
  @tx_msgs_queue: List of pending TX requests
  @lock: Serialize access to the lists
  @cl: reference to the associated hsi_client
  @cl_data: reference to the client data that this channels belongs to
  @rx_wait: RX requests wait queue
  @tx_wait: TX requests wait queue
  struct hsc_client_data - hsi_char internal client data
  @cdev: Characther device associated to the hsi_client
  @lock: Lock to serialize openclose access
  @flags: Keeps track of port state (rx hwbreak armed)
  @usecnt: Use count for claiming the HSI port (mutex protected)
  @cl: Referece to the HSI client
  @channels: Array of channels accessible by the client
 Stores the major number dynamically allocated for hsi_char 
 Maximum buffer size that hsi_char will accept from userspace 
 Ignore false positive, due to sg pointer handling 
 Broadcast HWBREAK on all channels 
	
	  Check if we have already claimed the port associated to the HSI
	  client. If not then try to claim it, else increase its refcount
 1 hsi client -> N char devices (one for each channel) 
 SPDX-License-Identifier: GPL-2.0-only
  ssi_protocol.c
  Implementation of the SSI McSAAB improved protocol.
  Copyright (C) 2010 Nokia Corporation. All rights reserved.
  Copyright (C) 2013 Sebastian Reichel <sre@kernel.org>
  Contact: Carlos Chinea <carlos.chinea@nokia.com>
 FIXME: Revisit 
 FIXME: has to be 500 msecs 
 15 msecs 
 Number of pre-allocated commands buffers 
  SSI protocol command definitions
 Commands 
 Payloads 
 Generic Command 
 Commands for the control channel 
 Main state machine states 
 Send state machine states 
 Receive state machine states 
  struct ssi_protocol - SSI protocol (McSAAB) data
  @main_state: Main state machine
  @send_state: TX state machine
  @recv_state: RX state machine
  @flags: Flags, currently only used to follow wake line test
  @rxid: RX data id
  @txid: TX data id
  @txqueue_len: TX queue length
  @tx_wd: TX watchdog
  @rx_wd: RX watchdog
  @keep_alive: Workaround for SSI HW bug
  @lock: To serialize access to this struct
  @netdev: Phonet network device
  @txqueue: TX data queue
  @cmdqueue: Queue of free commands
  @cl: HSI client own reference
  @link: Link for ssip_list
  @tx_usecount: Refcount to keep track the slaves that use the wake line
  @channel_id_cmd: HSI channel id for command stream
  @channel_id_data: HSI channel id for data stream
 wake-up workaround 
 List of ssi protocol instances 
 CMT speech workaround 
 FIXME: To be removed 
			
			  Workaround for cmt-speech in that case
			  we relay on audio timers.
	
	  We can have two UP events in a row due to a short low
	  high transition. Therefore we need to ignore the sencond UP event.
 In soft IRQ context 
 length field is exchanged in network byte order 
 FIXME: Revisit 
 Workaroud: Ignore CMT Loader message leftover 
 FIXME: To be removed 
 Start boot handshake watchdog 
 Use tx_wd as a boot watchdog in non ACTIVE state 
 FIXME: To be removed 
 Stop boot handshake timer 
 Ignored 
 FIXME: To be removed 
 Pad to 32-bits - FIXME: Revisit
	
	  Modem sends Phonet messages over SSI with its own endianness.
	  Assume that modem has the same endianness as we do.
 length field is exchanged in network byte order 
 Needed for cmt-speech workaround 
 CMT reset event handler 
 MTU range: 6 - 65535 
 SPDX-License-Identifier: GPL-2.0-only
  nokia-modem.c
  HSI client driver for Nokia N900 modem.
  Copyright (C) 2014 Sebastian Reichel <sre@kernel.org>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2009, Microsoft Corporation.
  Authors:
    Haiyang Zhang <haiyangz@microsoft.com>
    Hank Janssen  <hjanssen@microsoft.com>
 The one and only 
  hv_init - Main initialization routine.
  This routine must be called before any other routines in here are called
  Functions for allocating and freeing memory with size and
  alignment HV_HYP_PAGE_SIZE. These functions are needed because
  the guest page size may not be the same as the Hyper-V page
  size. We depend upon kmalloc() aligning power-of-two size
  allocations to the allocation size boundary, so that the
  allocated memory appears to Hyper-V as a page of the size
  it expects.
  hv_post_message - Post a message using the hypervisor message IPC.
  This involves a hypercall.
	 Preemption must remain disabled until after the hypercall
	  so some other thread can't get scheduled onto this cpu and
	  corrupt the per-cpu post_msg_page
	
	  First, zero all per-cpu memory areas so hv_synic_free() can
	  detect what memory has been allocated and cleanup properly
	  after any failures.
		
		  Synic message and event pages are allocated by paravisor.
		  Skip these pages allocation here.
	
	  Any memory allocations that succeeded will be freed when
	  the caller cleans up by calling hv_synic_free()
  hv_synic_init - Initialize the Synthetic Interrupt Controller.
  If it is already initialized by another entity (ie x2v shim), we need to
  retrieve the initialized message and event pages.  Otherwise, we create and
  initialize the message and event pages.
 Setup the Synic's message page 
 Setup the Synic's event page 
 Setup the shared SINT. 
	
	  On architectures where Hyper-V doesn't support AEOI (e.g., ARM64),
	  it doesn't provide a recommendation flag and AEOI must be disabled.
 Enable the global synic bit 
  hv_synic_cleanup - Cleanup routine for hv_synic_init().
 Need to correctly cleanup in the case of SMP!!! 
 Disable the interrupt 
	
	  In Isolation VM, sim and sief pages are allocated by
	  paravisor. These pages also will be used by kdump
	  kernel. So just reset enable bit here and keep page
	  addresses.
 Disable the global synic bit 
  Scan the event flags page of 'this' CPU looking for any bit that is set.  If we find one
  bit set, then wait for a few milliseconds.  Repeat these steps for a maximum of 3 times.
  Return 'true', if there is still any set bit after this operation; 'false', otherwise.
  If a bit is set, that means there is a pending channel interrupt.  The expectation is
  that the normal interrupt handling mechanism will find and process the channel interrupt
  "very soon", and in the process clear the bit.
 assumes VMBus version >= VERSION_WIN8 
 Special case - VMBus channel protocol messages 
	
	  Hyper-V does not provide a way to change the connect CPU once
	  it is set; we must prevent the connect CPU from going offline
	  while the VM is running normally. But in the panic or kexec()
	  path where the vmbus is already disconnected, the CPU must be
	  allowed to shut down.
	
	  Search for channels which are bound to the CPU we're about to
	  cleanup.  In case we find one and vmbus is still connected, we
	  fail; this will effectively prevent CPU offlining.
	 
	  TODO: Re-bind the channels to different CPUs.
	
	  channel_found == false means that any channels that were previously
	  assigned to the CPU have been reassigned elsewhere with a call of
	  vmbus_send_modifychannel().  Scan the event flags page looking for
	  bits that are set and waiting with a timeout for vmbus_chan_sched()
	  to process such bits.  If bits are still set after this operation
	  and VMBus is connected, fail the CPU offlining operation.
 SPDX-License-Identifier: GPL-2.0-only
  Kerneluserspace transport abstraction for Hyper-V util driver.
  Copyright (C) 2015, Vitaly Kuznetsov <vkuznets@redhat.com>
		
		  Switching to CHARDEV mode. We switch bach to INIT when
		  device gets released.
		
		  We're switching from netlink communication to using char
		  device. Issue the reset first.
	
	  Cleanup message buffers to avoid spurious messages when the daemon
	  connects back.
	
	  Switching to NETLINK mode. Switching to CHARDEV happens when someone
	  opens the device.
		
		  We don't know when netlink messages are delivered but unlike
		  in CHARDEV mode we're not blocked and we can send next
		  messages right away.
 HVUTIL_TRANSPORT_CHARDEV 
 Previous message wasn't received 
 Use cn_id.idxcn_id.val to determine if we need to setup netlink 
	
	  In case we were in 'chardev' mode we still have an open fd so we
	  have to defer freeing the device. Netlink interface can be freed
	  now.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2010, Microsoft Corporation.
  Authors:
    Haiyang Zhang <haiyangz@microsoft.com>
    Hank Janssen  <hjanssen@microsoft.com>
  Send the "hibernate" udev event in a thread context.
  Perform the shutdown operation in a thread context.
  Perform the restart operation in a thread context.
 Ensure recvlen is big enough to read header data 
 Ensure recvlen is big enough to contain shutdown_msg_data struct 
		
		  shutdown_msg->flags can be 0(shut down), 2(reboot),
		  or 4(hibernate). It may bitwise-OR 1, which means
		  performing the request by force. Linux always tries
		  to perform the request by force.
  Set the host time in a process context.
  The last time sample, received from the host. PTP device responds to
  requests by using this data and the current partition-wide time reference
  count.
  Hard coded threshold for host timesync delay: 600 seconds
	
	  We need to let the caller know that last update from host
	  is older than the max allowable threshold. clock_gettime()
	  and PTP ioctl do not have a documented error that we could
	  return for this specific case. Use ESTALE to report this.
  Synchronize time with host after reboot, restore, etc.
  ICTIMESYNCFLAG_SYNC flag bit indicates reboot, restore events of the VM.
  After reboot the flag ICTIMESYNCFLAG_SYNC is included in the first time
  message after the timesync channel is opened. Since the hv_utils module is
  loaded after hv_vmbus, the first message is usually missed. This bit is
  considered a hard request to discipline the clock.
  ICTIMESYNCFLAG_SAMPLE bit indicates a time sample from host. This is
  typically used as a hint to the guest. The guest is under no obligation
  to discipline the clock.
	
	  Save the adjusted time sample from the host and the snapshot
	  of the current system time.
	
	  TimeSync v4 messages contain reference time (guest's Hyper-V
	  clocksource read when the time sample was generated), we can
	  improve the precision by adding the delta between now and the
	  time of generation. For older protocols we set
	  reftime == cur_reftime on call.
 Schedule work to do do_settimeofday64() 
  Time Sync Channel message handler.
	
	  Drain the ring buffer and use the last packet to update
	  host_ts
 Ensure recvlen is big enough to read header data 
 Ensure recvlen is big enough to read ictimesync_ref_data 
 Ensure recvlen is big enough to read ictimesync_data 
  Heartbeat functionality.
  Every two seconds, Hyper-V send us a heartbeat request message.
  we respond to this message, and Hyper-V knows we are alive.
 Ensure recvlen is big enough to read header data 
			
			  Ensure recvlen is big enough to read seq_num. Reserved area is not
			  included in the check as the host may not fill it up entirely
	
	  The set of services managed by the util driver are not performance
	  critical and do not need batched reading. Furthermore, some services
	  such as KVP can only handle one message from the host at a time.
	  Turn off batched reading for all util drivers before we open the
	  channel.
  When we're in util_suspend(), all the userspace processes have been frozen
  (refer to hibernate() -> freeze_processes()). The userspace is thawed only
  after the whole resume procedure, including util_resume(), finishes.
 Shutdown guid 
 Time synch guid 
 Heartbeat guid 
 KVP guid 
 VSS GUID 
 File copy GUID 
 The one and only one 
	
	  ptp_clock_register() returns NULL when CONFIG_PTP_1588_CLOCK is
	  disabled but the driver is still useful without the PTP device
	  as it still handles the ICTIMESYNCFLAG_SYNC case.
 SPDX-License-Identifier: GPL-2.0-only
  Authors:
    Branden Bonaby <brandonbonaby94@gmail.com>
 Setup delay files to store test values 
 Setup test state value for vmbus device 
 Bind hv device to a dentry for debugfs 
 Create all test dentry's and names for fuzz testing 
 Remove dentry associated with released hv device 
 Remove all dentrys associated with vmbus testing 
 Delay buffermessage reads on a vmbus channel 
 Initialize top dentry for vmbus testing 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2009, Microsoft Corporation.
  Authors:
    Haiyang Zhang <haiyangz@microsoft.com>
    Hank Janssen  <hjanssen@microsoft.com>
    K. Y. Srinivasan <kys@microsoft.com>
  When we write to the ring buffer, check if the host needs to
  be signaled. Here is the details of this protocol:
 	1. The host guarantees that while it is draining the
 	   ring buffer, it will set the interrupt_mask to
 	   indicate it does not need to be interrupted when
 	   new data is placed.
 	2. The host guarantees that it will completely drain
 	   the ring buffer before exiting the read loop. Further,
 	   once the ring buffer is empty, it will clear the
 	   interrupt_mask and re-check to see if new data has
 	   arrived.
  KYS: Oct. 30, 2016:
  It looks like Windows hosts have logic to deal with DOS attacks that
  can be triggered if it receives interrupts when it is not expecting
  the interrupt. The host expects interrupts only when the ring
  transitions from empty to non-empty (or full to non full on the guest
  to host ring).
  So, base the signaling decision solely on the ring state until the
  host logic is fixed.
 check interrupt_mask before read_index 
	
	  This is the only case we need to signal when the
	  ring transitions from being empty to non-empty.
 Get the next write location for the specified ring buffer. 
 Set the next write location for the specified ring buffer. 
 Get the size of the ring buffer. 
 Get the read and write indices as u64 of the specified ring buffer. 
  Helper routine to copy from source to ring buffer.
  Assume there is enough room. Handles wrap-around in dest case only!!
  hv_get_ringbuffer_availbytes()
  Get number of bytes available to read and to write to
  for the specified ring buffer
 Capture the readwrite indices before they changed 
 Get various debug metrics for the specified ring buffer. 
 Initialize a channel's ring buffer info mutex locks 
 Initialize the ring buffer. 
	
	  First page holds struct hv_ring_buffer, do wraparound mapping for
	  the rest.
 Zero ring buffer after setting memory host visibility. 
 Set the feature bit for enabling flow control. 
 Initialize buffer that holds copies of incoming packets 
 Cleanup the ring buffer. 
 Write to the ring buffer. 
	
	  If there is only room for the packet, assume it is full.
	  Otherwise, the next time around, we think the ring buffer
	  is empty since the read index == write index.
 Write to the ring buffer 
	
	  Allocate the request ID after the data has been copied into the
	  ring buffer.  Once this request ID is allocated, the completion
	  path could find the data and free it.
 Set previous packet start 
 Issue a full memory barrier before updating the write index 
 Now, update the write location 
 Reclaim request ID to avoid leak of IDs 
 Make sure there is something to read 
		
		  No error is set when there is even no header, drivers are
		  supposed to analyze buffer_actual_len.
 since ring is double mapped, only one copy is necessary 
 Advance ring index to next packet descriptor 
 Notify host of update 
  Determine number of bytes available in ring buffer after
  the current iterator (priv_read_index) location.
  This is similar to hv_get_bytes_to_read but with private
  read index instead.
  Get first vmbus packet without copying it out of the ring buffer
  Get first vmbus packet from ring buffer after read_index
  If ring buffer is empty, returns NULL and no other action needed.
	
	  Ensure the compiler does not use references to incoming Hyper-V values (which
	  could change at any moment) when reading local variables later in the code
	
	  If pkt_len is invalid, set it to the smaller of hv_pkt_iter_avail() and
	  rbi->pkt_buffer_size
	
	  If pkt_offset is invalid, arbitrarily set it to
	  the size of vmpacket_descriptor
 Copy the Hyper-V packet out of the ring buffer 
	
	  Hyper-V could still change len8 and offset8 after the earlier read.
	  Ensure that desc_copy has legal values for len8 and offset8 that
	  are consistent with the copy we just made
  Get next vmbus packet from ring buffer.
  Advances the current location (priv_read_index) and checks for more
  data. If the end of the ring buffer is reached, then return NULL.
 bump offset to next potential packet 
 more data? 
 How many bytes were read in this iterator cycle 
  Update host ring buffer after iterating over packets. If the host has
  stopped queuing new entries because it found the ring buffer full, and
  sufficient space is being freed up, signal the host. But be careful to
  only signal the host when necessary, both for performance reasons and
  because Hyper-V protects itself by throttling guests that signal
  inappropriately.
  Determining when to signal is tricky. There are three key data inputs
  that must be handled in this order to avoid race conditions:
  1. Update the read_index
  2. Read the pending_send_sz
  3. Read the current write_index
  The interrupt_mask is not used to determine when to signal. The
  interrupt_mask is used only on the guest->host ring buffer when
  sending requests to the host. The host does not use it on the host->
  guest ring buffer to indicate whether it should be signaled.
	
	  Make sure all reads are done before we update the read index since
	  the writer may start writing to the read area once the read index
	  is updated.
	
	  Older versions of Hyper-V (before WS2102 and Win8) do not
	  implement pending_send_sz and simply poll if the host->guest
	  ring buffer is full.  No signaling is needed or expected.
	
	  Issue a full memory barrier before making the signaling decision.
	  If reading pending_send_sz were to be reordered and happen
	  before we commit the new read_index, a race could occur.  If the
	  host were to set the pending_send_sz after we have sampled
	  pending_send_sz, and the ring buffer blocks before we commit the
	  read index, we could miss sending the interrupt. Issue a full
	  memory barrier to address this.
	
	  If the pending_send_sz is zero, then the ring buffer is not
	  blocked and there is no need to signal.  This is far by the
	  most common case, so exit quickly for best performance.
	
	  Ensure the read of write_index in hv_get_bytes_to_write()
	  happens after the read of pending_send_sz.
	
	  We want to signal the host only if we're transitioning
	  from a "not enough free space" state to a "enough free
	  space" state.  For example, it's possible that this function
	  could run and free up enough space to signal the host, and then
	  run again and free up additional space before the host has a
	  chance to clear the pending_send_sz.  The 2nd invocation would
	  be a null transition from "enough free space" to "enough free
	  space", which doesn't warrant a signal.
	 
	  Exactly filling the ring buffer is treated as "not enough
	  space". The ring buffer always must have at least one byte
	  empty so the empty and full conditions are distinguishable.
	  hv_get_bytes_to_write() doesn't fully tell the truth in
	  this regard.
	 
	  So first check if we were in the "enough free space" state
	  before we began the iteration. If so, the host was not
	  blocked, and there's no need to signal.
	
	  Similarly, if the new state is "not enough space", then
	  there's no need to signal.
 SPDX-License-Identifier: GPL-2.0-only
  An implementation of file copy service.
  Copyright (C) 2014, Microsoft, Inc.
  Author : K. Y. Srinivasan <ksrinivasan@novell.com>
  Global state maintained for transaction that is being processed.
  For a class of integration services, including the "file copy service",
  the specified protocol is a "requestresponse" protocol which means that
  there can only be single outstanding transaction from the host at any
  given point in time. We use this to simplify memory management in this
  driver - we cache and process only one message at a time.
  While the requestresponse protocol is guaranteed by the host, we further
  ensure this by serializing packet processing in this driver - we do not
  read additional packets from the VMBUs until the current packet is fully
  handled.
 hvutil_device_state 
 number of bytes received. 
 current message 
 chn we got the request 
 request ID. 
  This state maintains the version number registered by the daemon.
 Transaction is finished, reset the state here to avoid races. 
	
	  If the timer fires, the user-mode component has not responded;
	  process the pending transaction.
 Daemon doesn't expect us to reply 
 Daemon expects us to reply with our own version 
		
		  For now we will fail the registration.
		  If and when we have multiple versions to
		  deal with, we will be backward compatible.
		  We will add this code when needed.
	
	  The  strings sent from the host are encoded in
	  in utf16; convert it to utf8 strings.
	  The host assures us that the utf16 strings will not exceed
	  the max lengths specified. We will however, reserve room
	  for the string terminating character - in the utf16s_utf8s()
	  function we limit the size of the buffer where the converted
	  string is placed to W_MAX_PATH -1 to guarantee
	  that the strings can be properly terminated!
  Send a response back to the host.
	
	  Copy the global state for completing the transaction. Note that
	  only one transaction can be active at a time. This is guaranteed
	  by the file copy protocol implemented by the host. Furthermore,
	  the "transaction active" state we maintain ensures that there can
	  only be one active transaction at a time.
		
		  We have raced with util driver being unloaded;
		  silently return.
 Ensure recvlen is big enough to read header data 
 Ensure recvlen is big enough to contain hv_fcopy_hdr 
		
		  Stash away this global state for completing the
		  transaction; note transactions are serialized.
 Userspace is not registered yet 
		
		  Send the information to the user-level daemon.
 Callback when data is received from userspace 
	
	  Complete the transaction by forwarding the result
	  to the host. But first, cancel the timeout.
	
	  The daemon has exited; reset the state.
	
	  When this driver loads, the user level daemon that
	  processes the host requests may not yet be running.
	  Defer processing channel callbacks until the daemon
	  has registered.
	
	  Fake a CANCEL_FCOPY message for the user space daemon in case the
	  daemon is in the middle of copying some file. It doesn't matter if
	  there is already a message pending to be delivered to the user
	  space since we force fcopy_transaction.state to be HVUTIL_READY, so
	  the user space daemon's write() will fail with EINVAL (see
	  fcopy_on_msg()), and the daemon will reset the device by closing
	  and re-opening it.
 We don't care about the return value. 
 tasklet_enable() will be called in hv_fcopy_pre_resume(). 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2009, Microsoft Corporation.
  Authors:
    Haiyang Zhang <haiyangz@microsoft.com>
    Hank Janssen  <hjanssen@microsoft.com>
    K. Y. Srinivasan <kys@microsoft.com>
 Values parsed from ACPI DSDT 
  Boolean to control whether to report panic messages over Hyper-V.
  It can be set via procsyskernelhyperv_record_panic_msg
	
	  Hyper-V should be notified only once about a panic.  If we will be
	  doing hyperv_report_panic_msg() later with kmsg data, don't do
	  the notification here.
 Don't notify Hyper-V if the die event is other than oops 
	
	  Hyper-V should be notified only once about a panic.  If we will be
	  doing hyperv_report_panic_msg() later with kmsg data, don't do
	  the notification here.
 We need to keep extra room for a newline 
 Set up per device attributes in sysbusvmbusdevices<bus device> 
  Device-level attribute_group callback function. Returns the permission for
  each attribute, and returns 0 if an attribute is not visible.
 Hide the monitor attributes if the monitor mechanism is not used. 
 Set up the attribute for sysbusvmbushibernation 
  vmbus_uevent - add uevent for our device
  This routine is invoked when a device is added or removed on the vmbus to
  generate a uevent to udev in the userspace. The udev will then look at its
  rule and the uevent generated here to load the appropriate driver
  The alias string will be of the form vmbus:guid where guid is the string
  representation of the device guid (each byte of the guid will be
  represented with two hex characters.
 empty device table 
  Return a matching hv_vmbus_device_id pointer.
  If there is no match, return NULL.
 When driver_override is set, only bind to the matching driver 
 Look at the dynamic ids first, before the static ones 
 driver_override will always match, send a dummy id 
 vmbus_add_dynid - add a new device ID to this driver and re-probe devices 
  store_new_id - sysfs frontend to vmbus_add_dynid()
  Allow GUIDs to be added to an existing driver via sysfs.
  store_remove_id - remove a PCI device ID from this driver
  Removes a dynamic pci device ID to this driver.
  vmbus_match - Attempt to match the specified device to the specified driver
 The hv_sock driver handles all hv_sock offers. 
  vmbus_probe - Add the new vmbus's child device
  vmbus_remove - Remove a vmbus device
  vmbus_shutdown - Shutdown a vmbus device
 The device may not be attached yet 
  vmbus_suspend - Suspend a vmbus device
 The device may not be attached yet 
  vmbus_resume - Resume a vmbus device
 The device may not be attached yet 
 CONFIG_PM_SLEEP 
  vmbus_device_release - Final callback release of the vmbus child device
  Note: we must use the "noirq" ops: see the comment before vmbus_bus_pm.
  suspend_noirqresume_noirq are set to NULL to support Suspend-to-Idle: we
  shouldn't suspend the vmbus devices upon Suspend-to-Idle, otherwise there
  is no way to wake up a Generation-2 VM.
  The other 4 ops are for hibernation.
 The one and only one 
 Do not process messages if we're in DISCONNECTED state 
	
	  'enum vmbus_channel_message_type' is supposed to always be 'u32' as
	  it is being used in 'struct vmbus_channel_message_header' definition
	  which is supposed to match hypervisor ABI.
	
	  Since the message is in memory shared with the host, an erroneous or
	  malicious Hyper-V could modify the message while vmbus_on_msg_dpc()
	  or individual message handlers are executing; to prevent this, copy
	  the message into private memory.
 no msg 
		
		  The host can generate a rescind message while we
		  may still be handling the original offer. We deal with
		  this condition by relying on the synchronization provided
		  by offer_in_progress and by channel_mutex.  See also the
		  inline comments in vmbus_onoffer_rescind().
			
			  If we are handling the rescind message;
			  schedule the work on the global work queue.
			 
			  The OFFER message and the RESCIND message should
			  not be handled by the same serialized work queue,
			  because the OFFER handler may call vmbus_open(),
			  which tries to open the channel by sending an
			  OPEN_CHANNEL message to the host and waits for
			  the host's response; however, if the host has
			  rescinded the channel before it receives the
			  OPEN_CHANNEL message, the host just silently
			  ignores the OPEN_CHANNEL message; as a result,
			  the guest's OFFER handler hangs for ever, if we
			  handle the RESCIND message in the same serialized
			  work queue: the RESCIND handler can not start to
			  run before the OFFER handler finishes.
			
			  The host sends the offer message of a given channel
			  before sending the rescind message of the same
			  channel.  These messages are sent to the guest's
			  connect CPU; the guest then starts processing them
			  in the tasklet handler on this CPU:
			 
			  VMBUS_CONNECT_CPU
			 
			  [vmbus_on_msg_dpc()]
			  atomic_inc()   CHANNELMSG_OFFERCHANNEL
			  queue_work()
			  ...
			  [vmbus_on_msg_dpc()]
			  schedule_work()   CHANNELMSG_RESCIND_CHANNELOFFER
			 
			  We rely on the memory-ordering properties of the
			  queue_work() and schedule_work() primitives, which
			  guarantee that the atomic increment will be visible
			  to the CPUs which will execute the offer & rescind
			  works by the time these works will start execution.
  Fake RESCIND_CHANNEL messages to clean up hv_sock channels by force for
  hibernation, because hv_sock connections can not persist across hibernation.
	
	  Allocation size is small and the allocation should really not fail,
	  otherwise the state of the hv_sock connections ends up in limbo.
	
	  So far, these are not really used by Linux. Just set them to the
	  reasonable values conforming to the definitions of the fields.
 These values are actually used by Linux. 
 CONFIG_PM_SLEEP 
  Schedule all channels with events pending
		
		  When the host is win8 and beyond, the event page
		  can be directly checked to get the id of the channel
		  that has the interrupt pending.
 Special case - vmbus channel protocol msg 
		
		  Pairs with the kfree_rcu() in vmbus_chan_release().
		  Guarantees that the channel data structure doesn't
		  get freed while the channel pointer below is being
		  dereferenced.
 Find channel based on relid 
		
		  Make sure that the ring buffer data structure doesn't get
		  freed while we dereference the ring buffer pointer.  Test
		  for the channel's onchannel_callback being NULL within a
		  sched_lock critical section.  See also the inline comments
		  in vmbus_reset_channel_cb().
	
	  Check for events before checking for messages. This is the order
	  in which events and messages are checked in Windows guests on
	  Hyper-V, and the Windows team suggested we do the same.
 Since we are a child, we only need to check bit 0 
		
		  Our host is win8 or above. The signaling mechanism
		  has changed and we can directly look at the event page.
		  If bit n is set then we have an interrup on the channel
		  whose id is n.
 Check if there are actual msgs to be processed 
  Callback from kmsg_dump. Grab as much as possible from the end of the kmsg
  buffer and call into Hyper-V to transfer the data.
 We are only interested in panics. 
	
	  Write dump contents to the page. No need to synchronize; panic should
	  be single-threaded.
	
	  P3 to contain the physical address of the panic page & P4 to
	  contain the size of the panic data in that page. Rest of the
	  registers are no-op when the NOTIFY_MSG flag is set.
	
	  Let Hyper-V know there is crash data available along with
	  the panic message.
  sysctl option to allow the user to control whether kmsg data should be
  reported to Hyper-V on panic.
  vmbus_bus_init -Main vmbus driver initialization routine.
  Here, we
 	- initialize the vmbus driver context
 	- invoke the vmbus hv main init routine
 	- retrieve the channel offers
	
	  VMbus interrupts are best modeled as per-cpu interrupts. If
	  on an architecture with support for per-cpu IRQs (e.g. ARM64),
	  allocate a per-cpu IRQ using standard Linux kernel functionality.
	  If not on such an architecture (e.g., x86x64), then rely on
	  code in the arch-specific portion of the code tree to connect
	  the VMbus interrupt handler.
	
	  Initialize the per-cpu interrupt state and stimer state.
	  Then connect to the host.
	
	  Only register if the crash MSRs are available
		
		  Sysctl registration is not fatal, since by default
		  reporting is enabled.
		
		  Register for panic kmsg callback only if the right
		  capability is supported by the hypervisor.
	
	  Always register the panic notifier because we need to unload
	  the VMbus channel connection to prevent any VMbus
	  activity after the VM panics.
  __vmbus_child_driver_register() - Register a vmbus's driver
  @hv_driver: Pointer to driver structure you want to register
  @owner: owner module of the drv
  @mod_name: module name string
  Registers the given driver with Linux through the 'driver_register()' call
  and sets up the hyper-v vmbus handling for this driver.
  It will return the state of the 'driver_register()' call.
  vmbus_driver_unregister() - Unregister a vmbus's driver
  @hv_driver: Pointer to driver structure you want to
              un-register
  Un-register the given driver that was previous registered with a call to
  vmbus_driver_register()
  Called when last reference to channel is gone.
 Validate target_cpu for the cpumask_test_cpu() operation below. 
 No CPUs should come up or down during this. 
	
	  Synchronizes target_cpu_store() and channel closure:
	 
	  { Initially: state = CHANNEL_OPENED }
	 
	  CPU1				CPU2
	 
	  [target_cpu_store()]		[vmbus_disconnect_ring()]
	 
	  LOCK channel_mutex		LOCK channel_mutex
	  LOAD r1 = state		LOAD r2 = state
	  IF (r1 == CHANNEL_OPENED)	IF (r2 == CHANNEL_OPENED)
	    SEND MODIFYCHANNEL		  STORE state = CHANNEL_OPEN
	    [...]			  SEND CLOSECHANNEL
	  UNLOCK channel_mutex		UNLOCK channel_mutex
	 
	  Forbids: r1 == r2 == CHANNEL_OPENED (i.e., CPU1's LOCK precedes
	  		CPU2's LOCK) && CPU2's SEND precedes CPU1's SEND
	 
	  Note.  The host processes the channel messages "sequentially", in
	  the order in which they are received on a per-partition basis.
	
	  Hyper-V will ignore MODIFYCHANNEL messages for "non-open" channels;
	  avoid sending the message and fail here for such channels.
	
	  For version before VERSION_WIN10_V5_3, the following warning holds:
	 
	  Warning.  At this point, there is no guarantee that the host will
	  have successfully processed the vmbus_send_modifychannel() request.
	  See the header comment of vmbus_send_modifychannel() for more info.
	 
	  Lags in the processing of the above vmbus_send_modifychannel() can
	  result in missed interrupts if the "old" target CPU is taken offline
	  before Hyper-V starts sending interrupts to the "new" target CPU.
	  But apart from this offlining scenario, the code tolerates such
	  lags.  It will function correctly even if a channel interrupt comes
	  in on a CPU that is different from the channel target_cpu value.
 See init_vp_index(). 
 Currently set only for storvsc channels. 
  Channel-level attribute_group callback function. Returns the permission for
  each attribute, and returns 0 if an attribute is not visible.
 Hide the monitor attributes if the monitor mechanism is not used. 
  vmbus_add_channel_kobj - setup a sub-directory under devicechannels
		
		  The calling functions' error handling paths will cleanup the
		  empty channel directory.
  vmbus_remove_channel_attr_group - remove the channel's attribute group
  vmbus_device_create - Creates and registers a new child device
  on the vmbus.
 MSFT vendor ID 
  vmbus_device_register - Register the child device
	
	  Register with the LDM. This will kick off the driverdevice
	  binding...which will eventually call vmbus_match() and vmbus_probe()
  vmbus_device_unregister - Remove the specified child device
  from the vmbus.
	
	  Kick off the process of unregistering the device.
	  This will call vmbus_remove() and eventually vmbus_device_release()
  VMBUS is an acpi enumerated device. Get the information we
  need from DSDT.
	
	  "Address" descriptors are for bus windows. Ignore
	  "memory" descriptors, which are for registers on
	  devices.
	
	  The IRQ information is needed only on ARM64, which Hyper-V
	  sets up in the extended format. IRQ information is present
	  on x86x64 in the non-extended format but it is not used by
	  Linux. So don't bother checking for the non-extended format.
 ARM64 INTID for VMbus 
 Linux IRQ number 
 Unused resource type 
	
	  Ignore ranges that are below 1MB, as they're not
	  necessary or useful here.
 If this range overlaps the virtual TPM, truncate it. 
	
	  If two ranges are adjacent, merge them.
	
	  Make a claim for the frame buffer in the resource tree under the
	  first node, which will be the one below 4GB.  The length seems to
	  be underreported, particularly in a Generation 1 VM.  So start out
	  reserving a larger area and make it smaller until it succeeds.
  vmbus_allocate_mmio() - Pick a memory-mapped IO range.
  @new:		If successful, supplied a pointer to the
 			allocated MMIO space.
  @device_obj:		Identifies the caller
  @min:		Minimum guest physical address of the
 			allocation
  @max:		Maximum guest physical address
  @size:		Size of the range to be allocated
  @align:		Alignment of the range to be allocated
  @fb_overlap_ok:	Whether this allocation can be allowed
 			to overlap the video frame buffer.
  This function walks the resources granted to VMBus by the
  _CRS object in the ACPI namespace underneath the parent
  "bridge" whether that's a root PCI bus in the Generation 1
  case or a Module Device in the Generation 2 case.  It then
  attempts to allocate from the global MMIO pool in a way that
  matches the constraints supplied in these parameters and by
  that _CRS.
  Return: 0 on success, -errno on failure
	
	  If overlaps with frame buffers are allowed, then first attempt to
	  make the allocation from within the reserved region.  Because it
	  is already reserved, no shadow allocation is necessary.
  vmbus_free_mmio() - Free a memory-mapped IO range.
  @start:		Base address of region to release.
  @size:		Size of the range to be allocated
  This function releases anything requested by
  vmbus_mmio_allocate().
	
	  Some ancestor of the vmbus acpi device (Gen1 or Gen2
	  firmware) is the VMOD that has the mmio ranges. Get that.
		
		  We wait here until the completion of any channel
		  offers that are currently in progress.
	
	  Wait until all the sub-channels and hv_sock channels have been
	  cleaned up. Sub-channels should be destroyed upon suspend, otherwise
	  they would conflict with the new sub-channels that will be created
	  in the resume path. hv_sock channels should also be destroyed, but
	  a hv_sock channel of an established hv_sock connection can not be
	  really destroyed since it may still be referenced by the userspace
	  application, so we just force the hv_sock channel to be rescinded
	  by vmbus_force_channel_rescinded(), and the userspace application
	  will thoroughly destroy the channel after hibernation.
	 
	  Note: the counter nr_chan_close_on_suspend may never go above 0 if
	  the VM has no sub-channel and hv_sock channel, e.g. a 1-vCPU VM.
		
		  Remove the channel from the array of channels and invalidate
		  the channel's relid.  Upon resume, vmbus_onoffer() will fix
		  up the relid (and other fields, if necessary) and add the
		  channel back to the array.
 Reset the event for the next resume. 
	
	  We only use the 'vmbus_proto_version', which was in use before
	  hibernation, to re-negotiate with the host.
 Reset the event for the next suspend. 
 CONFIG_PM_SLEEP 
  Note: we must use the "no_irq" ops, otherwise hibernation can not work with
  PCI device assignment, because "pci_dev_pm_ops" uses the "noirq" ops: in
  the resume path, the pci "noirq" restore op runs before "non-noirq" op (see
  resume_target_kernel() -> dpm_resume_start(), and hibernation_restore() ->
  dpm_resume_end()). This means vmbus_bus_resume() and the pci-hyperv's
  resume callback must also run via the "noirq" ops.
  Set suspend_noirqresume_noirq to NULL for Suspend-to-Idle: see the comment
  earlier in this file before vmbus_pm.
 Make sure conn_state is set as hv_synic_cleanup checks for it 
	
	  In crash handler we can't schedule synic cleanup for all CPUs,
	  doing the cleanup for current CPU only. This should be sufficient
	  for kdump.
	
	  When we reach here, all the non-boot CPUs have been offlined.
	  If we're in a legacy configuration where stimer Direct Mode is
	  not enabled, the stimers on the non-boot CPUs have been unbound
	  in hv_synic_cleanup() -> hv_stimer_legacy_cleanup() ->
	  hv_stimer_cleanup() -> clockevents_unbind_device().
	 
	  hv_synic_suspend() only runs on CPU0 with interrupts disabled.
	  Here we do not call hv_stimer_legacy_cleanup() on CPU0 because:
	  1) it's unnecessary as interrupts remain disabled between
	  syscore_suspend() and syscore_resume(): see create_image() and
	  resume_target_kernel()
	  2) the stimer on CPU0 is automatically disabled later by
	  syscore_suspend() -> timekeeping_suspend() -> tick_suspend() -> ...
	  -> clockevents_shutdown() -> ... -> hv_ce_shutdown()
	  3) a warning would be triggered if we call
	  clockevents_unbind_device(), which may sleep, in an
	  interrupts-disabled context.
	
	  Note: we don't need to call hv_stimer_init(0), because the timer
	  on CPU0 is not unbound in hv_synic_suspend(), and the timer is
	  automatically re-enabled in timekeeping_resume().
 The callbacks run only on CPU0, with irqs_disabled. 
	
	  Get ACPI resources first.
	
	  If we're on an architecture with a hardcoded hypervisor
	  vector (i.e. x86x64), override the VMbus interrupt found
	  in the ACPI tables. Ensure vmbus_irq is not set since the
	  normal Linux IRQ mechanism is not used in this case.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Architecture neutral utility routines for interacting with
  Hyper-V. This file is specifically for code that must be
  built-in to the kernel image when CONFIG_HYPERV is set
  (vs. being in a module) because it is called from architecture
  specific code under arch.
  Copyright (C) 2021, Microsoft, Inc.
  Author : Michael Kelley <mikelley@microsoft.com>
  hv_root_partition and ms_hyperv are defined here with other Hyper-V
  specific globals so they are shared across all architectures and are
  built only when CONFIG_HYPERV is defined.  But on x86,
  ms_hyperv_init_platform() is built even when CONFIG_HYPERV is not
  defined, and it uses these two variables.  So mark them as __weak
  here, allowing for an overriding definition in the module containing
  ms_hyperv_init_platform().
  Hyper-V specific initialization and shutdown code that is
  common across all architectures.  Called from architecture
  specific initialization functions.
	
	  Hyper-V expects to get crash register data or kmsg when
	  crash enlightment is available and system crashes. Set
	  crash_kexec_post_notifiers to be true to make sure that
	  calling crash enlightment interface before running kdump
	  kernel.
	
	  Allocate the per-CPU state for the hypercall input arg.
	  If this allocation fails, we will not be able to setup
	  (per-CPU) hypercall input page and thus this failure is
	  fatal on Hyper-V.
 Allocate the per-CPU state for output arg for root 
  Hyper-V specific initialization and die code for
  individual CPUs that is common across all architectures.
  Called by the CPU hotplug mechanism.
 hv_cpu_init() can be called with IRQs disabled from hv_resume() 
 Bit mask of the extended capability to query: see HV_EXT_CAPABILITY_xxx 
	
	  The address of the 'hv_extended_cap' variable will be used as an
	  output parameter to the hypercall below and so it should be
	  compatible with 'virt_to_phys'. Which means, it's address should be
	  directly mapped. Use 'static' to keep it compatible; stack variables
	  can be virtually mapped, making them incompatible with
	  'virt_to_phys'.
	  Hypercall inputoutput addresses should also be 8-byte aligned.
	
	  Querying extended capabilities is an extended hypercall. Check if the
	  partition supports extended hypercall, first.
 Extended capabilities do not change at runtime. 
	
	  The query extended capabilities hypercall should not fail under
	  any normal circumstances. Avoid repeatedly making the hypercall, on
	  error.
  Default function to read the Hyper-V reference counter, independent
  of whether Hyper-V enlightened clockstimers are being used. But on
  architectures where it is used, Hyper-V enlightenment code in
  hyperv_timer.c may override this function.
 These __weak functions provide default "no-op" behavior and
  may be overridden by architecture specific versions. Architectures
  for which the default "no-op" behavior is sufficient can leave
  them unimplemented and not be cluttered with a bunch of stub
  functions in arch-specific code.
 SPDX-License-Identifier: GPL-2.0-only
  An implementation of host initiated guest snapshot.
  Copyright (C) 2013, Microsoft, Inc.
  Author : K. Y. Srinivasan <kys@microsoft.com>
  Timeout values are based on expecations from host
  Global state maintained for transaction that is being processed. For a class
  of integration services, including the "VSS service", the specified protocol
  is a "requestresponse" protocol which means that there can only be single
  outstanding transaction from the host at any given point in time. We use
  this to simplify memory management in this driver - we cache and process
  only one message at a time.
  While the requestresponse protocol is guaranteed by the host, we further
  ensure this by serializing packet processing in this driver - we do not
  read additional packets from the VMBUs until the current packet is fully
  handled.
 hvutil_device_state 
 number of bytes received. 
 chn we got the request 
 request ID. 
 current message 
  This state maintains the version number registered by the daemon.
 Transaction is finished, reset the state here to avoid races. 
  Callback when data is received from user mode.
	
	  Timeout waiting for userspace component to reply happened.
 Daemon doesn't expect us to reply 
 Daemon expects us to reply with our own version 
		
		  Don't process registration messages if we're in the middle
		  of a transaction processing.
 Transaction is finished, reset the state. 
 This is a spurious call! 
 The transaction state is wrong. 
	
	  Initiate a "freezethaw" operation in the guest.
	  We respond to the host once the operation is complete.
	 
	  We send the message to the user space daemon and the operation is
	  performed in the daemon.
 Userspace is not registered yet 
  Send a response back to the host.
	
	  Copy the global state for completing the transaction. Note that
	  only one transaction can be active at a time.
		
		  We have raced with util driver being unloaded;
		  silently return.
  This callback is invoked when we get a VSS message from the host.
  The host ensures that only one VSS transaction can be active at a time.
 Ensure recvlen is big enough to read header data 
 Ensure recvlen is big enough to contain hv_vss_msg 
		
		  Stash away this global state for completing the
		  transaction; note transactions are serialized.
	
	  When this driver loads, the user level daemon that
	  processes the host requests may not yet be running.
	  Defer processing channel callbacks until the daemon
	  has registered.
	
	  Fake a THAW message for the user space daemon in case the daemon
	  has frozen the file systems. It doesn't matter if there is already
	  a message pending to be delivered to the user space since we force
	  vss_transaction.state to be HVUTIL_READY, so the user space daemon's
	  write() will fail with EINVAL (see vss_on_msg()), and the daemon
	  will reset the device by closing and re-opening it.
 Cancel any possible pending work. 
 We don't care about the return value. 
 tasklet_enable() will be called in hv_vss_pre_resume(). 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2009, Microsoft Corporation.
  Authors:
    Haiyang Zhang <haiyangz@microsoft.com>
    Hank Janssen  <hjanssen@microsoft.com>
 IDE 
 SCSI 
 Fibre Channel 
 Synthetic NIC 
 Network Direct 
 PCIE 
 Synthetic Frame Buffer 
 Synthetic Keyboard 
 Synthetic MOUSE 
 KVP 
 Time Synch 
 Heartbeat 
 Shutdown 
 File copy 
 Backup 
 Dynamic Memory 
 Unknown GUID 
  The rescinded channel may be blocked waiting for a response from the host;
  take care of that.
  vmbus_prep_negotiate_resp() - Create default response for Negotiate message
  @icmsghdrp: Pointer to msg header structure
  @buf: Raw buffer channel data
  @buflen: Length of the raw buffer channel data.
  @fw_version: The framework versions we can support.
  @fw_vercnt: The size of @fw_version.
  @srv_version: The service versions we can support.
  @srv_vercnt: The size of @srv_version.
  @nego_fw_version: The selected framework version.
  @nego_srv_version: The selected service version.
  Note: Versions are given in decreasing order.
  Set up and fill in default negotiate response message.
  Mainly used by Hyper-V drivers.
 Check that there's enough space for icframe_vercnt, icmsg_vercnt 
 Validate negop packet 
	
	  Select the framework version number we will
	  support.
	
	  Respond with the framework and service
	  version numbers we can support.
  alloc_channel - Allocate and initialize a vmbus channel object
  free_channel - Release the resources used by the vmbus channel object
	
	  The mapping of the channel's relid is visible from the CPUs that
	  execute vmbus_chan_sched() by the time that vmbus_chan_sched() will
	  execute:
	 
	   (a) In the "normal (i.e., not resuming from hibernation)" path,
	       the full barrier in smp_store_mb() guarantees that the store
	       is propagated to all CPUs before the add_channel_work work
	       is queued.  In turn, add_channel_work is queued before the
	       channel's ring buffer is allocatedinitialized and the
	       OPENCHANNEL message for the channel is sent in vmbus_open().
	       Hyper-V won't start sending the interrupts for the channel
	       before the OPENCHANNEL message is acked.  The memory barrier
	       in vmbus_chan_sched() -> sync_test_and_clear_bit() ensures
	       that vmbus_chan_sched() must find the channel's relid in
	       recv_int_page before retrieving the channel pointer from the
	       array of channels.
	 
	   (b) In the "resuming from hibernation" path, the smp_store_mb()
	       guarantees that the store is propagated to all CPUs before
	       the VMBus connection is marked as ready for the resume event
	       (cf. check_ready_for_resume_event()).  The interrupt handler
	       of the VMBus driver and vmbus_chan_sched() can not run before
	       vmbus_bus_resume() has completed execution (cf. resume_noirq).
	
	  hv_process_channel_removal() could find INVALID_RELID only for
	  hv_sock channels.  See the inline comments in vmbus_onoffer().
	
	  Upon suspend, an in-use hv_sock channel is removed from the array of
	  channels and the relid is invalidated.  After hibernation, when the
	  user-space appplication destroys the channel, it's unnecessary and
	  unsafe to remove the channel from the array of channels.  See also
	  the inline comments before the call of vmbus_release_relid() below.
	
	  If this is a "perf" channel, updates the hv_numa_map[] masks so that
	  init_vp_index() can (re-)use the CPU.
	
	  Upon suspend, an in-use hv_sock channel is marked as "rescinded" and
	  the relid is invalidated; after hibernation, when the user-space app
	  destroys the channel, the relid is INVALID_RELID, and in this case
	  it's unnecessary and unsafe to release the old relid, since the same
	  relid can refer to a completely different channel now.
 hv_process_channel_removal() needs this 
 Note: the function can run concurrently for primarysub channels. 
	
	  This state is used to indicate a successful open
	  so that when we do close the channel normally, we
	  can cleanup properly.
 newchannel is a sub-channel. 
	
	  Start the process of binding the primary channel to the driver
	
	  Add the new device to the bus. This will kick off device-driver
	  binding which eventually invokes the device driver's AddDevice()
	  method.
	
	  We need to set the flag, otherwise
	  vmbus_onoffer_rescind() can be blocked.
 vmbus_process_offer() has mapped the channel. 
  vmbus_process_offer - Process the offer by creating a channeldevice
  associated with this offer
	
	  Synchronize vmbus_process_offer() and CPU hotplugging:
	 
	  CPU1				CPU2
	 
	  [vmbus_process_offer()]	[Hot removal of the CPU]
	 
	  CPU_READ_LOCK		CPUS_WRITE_LOCK
	  LOAD cpu_online_mask		SEARCH chn_list
	  STORE target_cpu		LOAD target_cpu
	  INSERT chn_list		STORE cpu_online_mask
	  CPUS_READ_UNLOCK		CPUS_WRITE_UNLOCK
	 
	  Forbids: CPU1's LOAD from not seing CPU2's STORE &&
	               CPU2's SEARCH from not seeing CPU1's INSERT
	 
	  Forbids: CPU2's SEARCH from seeing CPU1's INSERT &&
	               CPU2's LOAD from not seing CPU1's STORE
	
	  Serializes the modifications of the chn_list list as well as
	  the accesses to next_numa_node_id in init_vp_index().
 Remember the channels that should be cleaned up upon suspend. 
	
	  Now that we have acquired the channel_mutex,
	  we can release the potentially racing rescind thread.
		
		  Check to see if this is a valid sub-channel.
			
			  Don't call free_channel(), because newchannel->kobj
			  is not initialized yet.
		
		  Process the sub-channel.
	
	  vmbus_process_offer() mustn't call channel->sc_creation_callback()
	  directly for sub-channels, because sc_creation_callback() ->
	  vmbus_open() may never get the host's response to the
	  OPEN_CHANNEL message (the host may rescind a channel at any time,
	  e.g. in the case of hot removing a NIC), and vmbus_onoffer_rescind()
	  may not wake up the vmbus_open() as it's blocked due to a non-zero
	  vmbus_connection.offer_in_progress, and finally we have a deadlock.
	 
	  The above is also true for primary channels, if the related device
	  drivers use sync probing mode by default.
	 
	  And, usually the handling of primary channels and sub-channels can
	  depend on each other, so we should offload them to different
	  workqueues to avoid possible deadlock, e.g. in sync-probing mode,
	  NIC1's netvsc_subchan_work() can race with NIC2's netvsc_probe() ->
	  rtnl_lock(), and causes deadlock: the former gets the rtnl_lock
	  and waits for all the sub-channels to appear, but the latter
	  can't get the rtnl_lock and this blocks the handling of
	  sub-channels.
  Check if CPUs used by other channels of the same device.
  It should only be called by init_vp_index().
  We use this state to statically distribute the channel interrupt load.
  Starting with Win8, we can statically distribute the incoming
  channel interrupt load by binding a channel to VCPU.
  For pre-win8 hosts or non-performance critical channels we assign the
  VMBUS_CONNECT_CPU.
  Starting with win8, performance critical channels will be distributed
  evenly among all the available NUMA nodes.  Once the node is assigned,
  we will assign the CPU based on a simple round robin scheme.
		
		  Prior to win8, all channel interrupts are
		  delivered on VMBUS_CONNECT_CPU.
		  Also if the channel is not a performance critical
		  channel, bind it to VMBUS_CONNECT_CPU.
		  In case alloc_cpumask_var() fails, bind it to
		  VMBUS_CONNECT_CPU.
			
			  We have cycled through all the CPUs in the node;
			  reset the alloced map.
 10 milliseconds 
 100 seconds 
 Every 5 seconds 
	
	  CHANNELMSG_UNLOAD_RESPONSE is always delivered to the CPU which was
	  used for initial contact or to CPU0 depending on host version. When
	  we're crashing on a different CPU let's hope that IRQ handler on
	  the cpu which receives CHANNELMSG_UNLOAD_RESPONSE is still
	  functional and vmbus_unload_response() will complete
	  vmbus_connection.unload_event. If not, the last thing we can do is
	  read message pages for all CPUs directly.
	 
	  Wait up to 100 seconds since an Azure host must writeback any dirty
	  data in its disk cache before the VMbus UNLOAD request will
	  complete. This flushing has been empirically observed to take up
	  to 50 seconds in cases with a lot of dirty data, so allow additional
	  leeway and for inaccuracies in mdelay(). But eventually time out so
	  that the panic path can't get hung forever in case the response
	  message isn't seen.
		
		  Give a notice periodically so someone watching the
		  serial output won't think it is completely hung.
	
	  We're crashing and already got the UNLOAD_RESPONSE, cleanup all
	  maybe-pending messages on all CPUs to be able to receive new
	  messages after we reconnect.
  vmbus_unload_response - Handler for the unload response.
	
	  This is a global event; just wakeup the waiting thread.
	  Once we successfully unload, we can cleanup the monitor state.
	 
	  NB.  A malicious or compromised Hyper-V could send a spurious
	  message of type CHANNELMSG_UNLOAD_RESPONSE, and trigger a call
	  of the complete() below.  Make sure that unload_event has been
	  initialized by the time this complete() is executed.
 Pre-Win2012R2 hosts don't support reconnect 
	
	  vmbus_initiate_unload() is also called on crash and the crash can be
	  happening in an interrupt context, where scheduling is impossible.
	
	  If all the old primary channels have been fixed up, then it's safe
	  to resume.
	
	  Setup state for signalling the host.
  find_primary_channel_by_offer - Get the channel object given the new offer.
  This is only used in the resume path of hibernation.
 Ignore sub-channel offers. 
  vmbus_onoffer - Handler for channel offers from vmbus in parent partition.
		
		  We're resuming from hibernation: all the sub-channel and
		  hv_sock channels we had before the hibernation should have
		  been cleaned up, and now we must be seeing a re-offered
		  primary channel that we had before the hibernation.
		
		  { Initially: channel relid = INVALID_RELID,
		 		channels[valid_relid] = NULL }
		 
		  CPU1					CPU2
		 
		  [vmbus_onoffer()]			[vmbus_device_release()]
		 
		  LOCK channel_mutex			LOCK channel_mutex
		  STORE channel relid = valid_relid	LOAD r1 = channel relid
		  MAP_RELID channel			if (r1 != INVALID_RELID)
		  UNLOCK channel_mutex			  UNMAP_RELID channel
		 					UNLOCK channel_mutex
		 
		  Forbids: r1 == valid_relid &&
		               channels[valid_relid] == channel
		 
		  Note.  r1 can be INVALID_RELID only for an hv_sock channel.
		  None of the hv_sock channels which were present before the
		  suspend are re-offered upon the resume.  See the WARN_ON()
		  in hv_process_channel_removal().
 Fix up the relid. 
			
			  This is not an error, since the host can also change
			  the other field(s) of the offer, e.g. on WS RS5
			  (Build 17763), the offer->connection_id of the
			  Mellanox VF vmbus device can change when the host
			  reoffers the device upon resume.
 Fix up the old channel. 
 Add the channel back to the array of channels. 
 Allocate the channel object and save this offer. 
	
	  If all the sub-channels or hv_sock channels have been cleaned up,
	  then it's safe to suspend.
  vmbus_onoffer_rescind - Rescind offer handler.
  We queue a work item to process this offer synchronously
	
	  The offer msg and the corresponding rescind msg
	  from the host are guranteed to be ordered -
	  offer comes in first and then the rescind.
	  Since we process these events in work elements,
	  and with preemption, we may end up processing
	  the events out of order.  We rely on the synchronization
	  provided by offer_in_progress and by channel_mutex for
	  ordering these events:
	 
	  { Initially: offer_in_progress = 1 }
	 
	  CPU1				CPU2
	 
	  [vmbus_onoffer()]		[vmbus_onoffer_rescind()]
	 
	  LOCK channel_mutex		WAIT_ON offer_in_progress == 0
	  DECREMENT offer_in_progress	LOCK channel_mutex
	  STORE channels[]		LOAD channels[]
	  UNLOCK channel_mutex		UNLOCK channel_mutex
	 
	  Forbids: CPU2's LOAD from not seeing CPU1's STORE
		
		  We wait here until any channel offer is currently
		  being processed.
		
		  Guarantee that no other instance of vmbus_onoffer_rescind()
		  has got a reference to the channel object.  Synchronize on
		  &vmbus_connection.channel_mutex.
		
		  We failed in processing the offer message;
		  we would have cleaned up the relid in that
		  failure path.
	
	  Before setting channel->rescind in vmbus_rescind_cleanup(), we
	  should make sure the channel callback is not running any more.
	
	  Now wait for offer handling to complete.
		
		  We wait here until any channel offer is currently
		  being processed.
	
	  At this point, the rescind handling can proceed safely.
		
		  We will have to unregister this device from the
		  driver core.
		
		  Sub-channel is being rescinded. Following is the channel
		  close sequence when initiated from the driveri (refer to
		  vmbus_close() for details):
		  1. Close all sub-channels first
		  2. Then close the primary channel.
			
			  The channel is currently not open;
			  it is safe for us to cleanup the channel.
 The "channel" may have been freed. Do not access it any longer. 
 We always get a rescind msg when a connection is closed. 
  vmbus_onoffers_delivered -
  This is invoked when all offers have been delivered.
  Nothing to do here.
  vmbus_onopen_result - Open result handler.
  This is invoked when we received a response to our channel open request.
  Find the matching request, copy the response and signal the requesting
  thread.
	
	  Find the open msg, copy the result and signalunblock the wait event
  vmbus_ongpadl_created - GPADL created handler.
  This is invoked when we received a response to our gpadl create request.
  Find the matching request, copy the response and signal the requesting
  thread.
	
	  Find the establish msg, copy the result and signalunblock the wait
	  event
  vmbus_onmodifychannel_response - Modify Channel response handler.
  This is invoked when we received a response to our channel modify request.
  Find the matching request, copy the response and signal the requesting thread.
	
	  Find the modify msg, copy the response and signalunblock the wait event.
  vmbus_ongpadl_torndown - GPADL torndown handler.
  This is invoked when we received a response to our gpadl teardown request.
  Find the matching request, copy the response and signal the requesting
  thread.
	
	  Find the open msg, copy the result and signalunblock the wait event
  vmbus_onversion_response - Version response handler
  This is invoked when we received a response to our initiate contact request.
  Find the matching request, copy the response and signal the requesting
  thread.
 Channel message dispatch table 
  vmbus_onmessage - Handler for channel protocol messages.
  This is invoked in the vmbus worker thread context.
	
	  vmbus_on_msg_dpc() makes sure the hdr->msgtype here can not go
	  out of bound and the message_handler pointer can not be NULL.
  vmbus_request_offers - Send a request to get all our pending offers.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, Microsoft Corporation.
  Author:
    K. Y. Srinivasan <kys@microsoft.com>
  We begin with definitions supporting the Dynamic Memory protocol
  with the host.
  Begin protocol definitions.
  Protocol versions. The low word is the minor version, the high word the major
  version.
  History:
  Initial version 1.0
  Changed to 0.1 on 20090325
  Changes to 0.2 on 20090514
  Changes to 0.3 on 20091203
  Changed to 1.0 on 20110405
  Message Types
	
	  Version 0.3
	
	  Version 1.0.
  Structures defining the dynamic memory management
  protocol.
		
		  To support guests that may have alignment
		  limitations on hot-add, the guest can specify
		  its alignment requirements; a value of n
		  represents an alignment of 2^n in mega bytes.
		
		  The PFN number of the first page in the range.
		  40 bits is the architectural limit of a PFN
		  number for AMD64.
		
		  The number of pages in the range.
  The header for all dynamic memory messages:
  type: Type of the message.
  size: Size of the message in bytes; including the header.
  trans_id: The guest is responsible for manufacturing this ID.
  A generic message format for dynamic memory.
  Specific message formats are defined later in the file.
 enclosed message 
  Specific message types supporting the dynamic memory protocol.
  Version negotiation message. Sent from the guest to the host.
  The guest is free to try different versions until the host
  accepts the version.
  dm_version: The protocol version requested.
  is_last_attempt: If TRUE, this is the last version guest will request.
  reservedz: Reserved field, set to zero.
  Version response message; Host to Guest and indicates
  if the host has accepted the version sent by the guest.
  is_accepted: If TRUE, host has accepted the version and the guest
  should proceed to the next stage of the protocol. FALSE indicates that
  guest should re-try with a different version.
  reservedz: Reserved field, set to zero.
  Message reporting capabilities. This is sent from the guest to the
  host.
  Response to the capabilities message. This is sent from the host to the
  guest. This message notifies if the host has accepted the guest's
  capabilities. If the host has not accepted, the guest must shutdown
  the service.
  is_accepted: Indicates if the host has accepted guest's capabilities.
  reservedz: Must be 0.
  This message is used to report memory pressure from the guest.
  This message is not part of any transaction and there is no
  response to this message.
  num_avail: Available memory in pages.
  num_committed: Committed memory in pages.
  page_file_size: The accumulated size of all page files
 		   in the system in pages.
  zero_free: The nunber of zero and free pages.
  page_file_writes: The writes to the page file in pages.
  io_diff: An indicator of file cache efficiency or page file activity,
 	    calculated as File Cache Page Fault Count - Page Read Count.
 	    This value is in pages.
  Some of these metrics are Windows specific and fortunately
  the algorithm on the host side that computes the guest memory
  pressure only uses num_committed value.
  Message to ask the guest to allocate memory - balloon up message.
  This message is sent from the host to the guest. The guest may not be
  able to allocate as much memory as requested.
  num_pages: number of pages to allocate.
  Balloon response message; this message is sent from the guest
  to the host in response to the balloon message.
  reservedz: Reserved; must be set to zero.
  more_pages: If FALSE, this is the last message of the transaction.
  if TRUE there will atleast one more message from the guest.
  range_count: The number of ranges in the range array.
  range_array: An array of page ranges returned to the host.
  Un-balloon message; this message is sent from the host
  to the guest to give guest more memory.
  more_pages: If FALSE, this is the last message of the transaction.
  if TRUE there will atleast one more message from the guest.
  reservedz: Reserved; must be set to zero.
  range_count: The number of ranges in the range array.
  range_array: An array of page ranges returned to the host.
  Un-balloon response message; this message is sent from the guest
  to the host in response to an unballoon request.
  Hot add request message. Message sent from the host to the guest.
  mem_range: Memory range to hot add.
  Hot add response message.
  This message is sent by the guest to report the status of a hot add request.
  If page_count is less than the requested page count, then the host should
  assume all further hot add requests will fail, since this indicates that
  the guest has hit an upper physical memory barrier.
  Hot adds may also fail due to low resources; in this case, the guest must
  not complete this message until the hot add can succeed, and the host must
  not send a new hot add request until the response is sent.
  If VSC fails to hot add memory DYNMEM_NUMBER_OF_UNSUCCESSFUL_HOTADD_ATTEMPTS
  times it fails the request.
  page_count: number of pages that were successfully hot added.
  result: result of the operation 1: success, 0: failure.
  Types of information sent from host to the guest.
  Header for the information message.
  This message is sent from the host to the guest to pass
  some relevant information (win8 addition).
  reserved: no used.
  info_size: size of the information blob.
  info: information blob.
  End protocol definitions.
  State to manage hot adding memory into the guest.
  The range start_pfn : end_pfn specifies the range
  that the host has asked us to hot add. The range
  start_pfn : ha_end_pfn specifies the range that we have
  currently hot added. We hot add in multiples of 128M
  chunks; it is possible that we may not be able to bring
  online all the pages in the region. The range
  covered_start_pfn:covered_end_pfn defines the pages that can
  be brough online.
	
	  A list of gaps.
  Delay reporting memory pressure by
  the specified number of seconds.
  The last time we posted a pressure report to host.
  Driver specific state.
	
	  Number of pages we have currently ballooned out.
	
	  State to manage the ballooning (up) operation.
	
	  State to execute the "hot-add" operation.
	
	  This state tracks if the host has specified a hot-add
	  region.
	
	  State to synchronize hot-add.
	
	  This thread handles hot-add
	  requests from the host as well as notifying
	  the host with regards to memory pressure in
	  the guest.
	
	  Protects ha_region_list, num_pages_onlined counter and individual
	  regions from ha_region_list.
	
	  A list of hot-add regions.
	
	  We start with the highest version we can support
	  and downgrade based on the host; we save here the
	  next version to try.
	
	  The negotiated version agreed by host.
 The page is not backed. 
 Check for gaps. 
		
		  Search for HAS which covers the pfn and when we find one
		  count how many consequitive PFNs are covered.
		
		  This PFN is not in any HAS (e.g. we're offlining a region
		  which was present at boot), no need to account for it. Go
		  to the next one.
			
			  We're offlining more pages than we managed to online.
			  This is unexpected. In any case don't let
			  num_pages_onlined wrap around zero.
 Check if the particular page is backed and can be onlined and online it. 
 This frame is currently backed; online the page. 
				
				  This error indicates that the error
				  is not a transient failure. This is the
				  case where the guest's physical address map
				  precludes hot adding memory. Stop all further
				  memory hot-add.
		
		  Wait for memory to get onlined. If the kernel onlined the
		  memory when adding it, this will return directly. Otherwise,
		  it will wait for user space to online the memory. This helps
		  to avoid adding memory faster than it is getting onlined. As
		  adding succeeded, it is ok to proceed even if the memory was
		  not onlined in time.
 The page belongs to a different HAS. 
		
		  If the pfn range we are dealing with is not in the current
		  "hot add block", move on.
		
		  If the current start pfn is not where the covered_end
		  is, create a gap and update covered_end_pfn.
		
		  If the current hot add-request extends beyond
		  our current limit; extend it.
			
			  Extend the region by multiples of HA_CHUNK.
		
		  If the pfn range we are dealing with is not in the current
		  "hot add block", move on.
			
			  This is the case where we are backing pages
			  in an already hot added region. Bring
			  these pages online first.
			
			  Check if the corresponding memory block is already
			  online. It is possible to observe struct pages still
			  being uninitialized here so check section instead.
			  In case the section is online we need to bring the
			  rest of pfns (which were not backed previously)
			  online too.
			
			  We have some residual hot add range
			  that needs to be hot added; hot add
			  it now. Hot add a multiple of
			  of HA_CHUNK that fully covers the pages
			  we have.
		
		  If we managed to online any pages that were given to us,
		  we declare success.
	
	  If the host has specified a hot-add range; deal with it first.
	
	  Process the page range specified; bringing them
	  online if possible.
		
		  The host has not specified the hot-add region.
		  Based on the hot-add page range being specified,
		  compute a hot-add region that can cover the pages
		  that need to be hot-added while ensuring the alignment
		  and size requirements of Linux as it relates to hot-add.
	
	  The result field of the response structure has the
	  following semantics:
	 
	  1. If all or some pages hot-added: Guest should return success.
	 
	  2. If no pages could be hot-added:
	 
	  If the guest returns success, then the host
	  will not attempt any further hot-add operations. This
	  signifies a permanent failure.
	 
	  If the guest returns failure, then this failure will be
	  treated as a transient failure and the host may retry the
	  hot-add operation after some delay.
	 Simple continuous piecewiese linear function:
	   max MiB -> min MiB  gradient
	        0         0
	       16        16
	       32        24
	      128        72    (12)
	      512       168    (14)
	     2048       360    (18)
	     8192       744    (116)
	    32768      1512	(132)
  Post our status as it relates memory pressure to the
  host. Host expects the guests to post this status
  periodically at 1 second intervals.
  The metrics specified in this protocol are very Windows
  specific and so we cook up numbers here to convey our memory
  pressure.
	
	  The host expects the guest to report free and committed memory.
	  Furthermore, the host expects the pressure information to include
	  the ballooned out pages. For a given amount of memory that we are
	  managing we need to compute a floor below which we should not
	  balloon. Compute this and add it to the pressure report.
	  We also need to report all offline pages (num_pages_added -
	  num_pages_onlined) as committed to the host, otherwise it can try
	  asking us to balloon them out.
	
	  If our transaction ID is no longer current, just don't
	  send the status. This can happen if we were interrupted
	  after we picked our transaction ID.
	
	  If the last post time that we sampled has changed,
	  we have raced, don't post the status.
		
		  We execute this code in a thread context. Furthermore,
		  we don't want the kernel to try too hard.
		
		  If we allocatted 2M pages; split them so we
		  can free them in any order we get.
 mark all pages offline 
	
	  We will attempt 2M allocations. However, if we fail to
	  allocate 2M chunks, we will go back to PAGE_SIZE allocations.
 Refuse to balloon below the floor. 
		
		  We are pushing a lot of data through the channel;
		  deal with transient failures caused because of the
		  lack of space in the ring buffer.
			
			  Free up the memory we allocatted.
		
		  The host expects us to post information on the memory
		  pressure every second.
		
		  We are done; wakeup the
		  context waiting for version
		  negotiation.
	
	  If there are more versions to try, continue
	  with negotiations; if not
	  shutdown the service since we are not able
	  to negotiate a suitable version number
	  with the host.
	
	  Set the next version to try in case current version fails.
	  Win7 protocol ought to be the last one to try.
				
				  This is a normal hot-add request specifying
				  hot-add memory.
				
				  Host is specifying that we first hot-add
				  a region and then partially populate this
				  region.
 Hyper-V only supports reporting 2MB pages or higher 
 page reporting only reports 2MB pages or higher 
 Essentially, validating 'PAGE_REPORTING_MIN_ORDER' is big enough. 
	
	  Initiate the hand shake with the host and negotiate
	  a version that the host can support. We start with the
	  highest version number and go down if the host cannot
	  support it.
	
	  If we could not negotiate a compatible version with the host
	  fail the probe function.
	
	  Now submit our capabilities to the host.
	
	  When hibernation (i.e. virtual ACPI S4 state) is enabled, the host
	  currently still requires the bits to be set, so we have to add code
	  to fail the host's hot-add and balloon updown requests, if any.
	
	  Specify our alignment requirements as it relates
	  memory hot-add. Specify 128MB alignment.
	
	  Currently the host does not use these
	  values and we set them to what is done in the
	  Windows driver.
	
	  If the host does not like our capabilities,
	  fail the probe function.
 Dynamic Memory Class ID 
 525074DC-8985-46e2-8057-A307DC18A502 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2009, Microsoft Corporation.
  Authors:
    Haiyang Zhang <haiyangz@microsoft.com>
    Hank Janssen  <hjanssen@microsoft.com>
  Negotiated protocol version with the host.
  Table of VMBus versions listed from newest to oldest.
  Maximal VMBus protocol version guests can negotiate.  Useful to cap the
  VMBus version for testing and debugging purpose.
	
	  VMBus protocol 5.0 (VERSION_WIN10_V5) and higher require that we must
	  use VMBUS_MESSAGE_CONNECTION_ID_4 for the Initiate Contact Message,
	  and for subsequent messages, we must use the Message Connection ID
	  field in the host-returned Version Response Message. And, with
	  VERSION_WIN10_V5 and higher, we don't use msg->interrupt_page, but we
	  tell the host explicitly that we still use VMBUS_MESSAGE_SINT(2) for
	  compatibility.
	 
	  On old hosts, we should always use VMBUS_MESSAGE_CONNECTION_ID (1).
	
	  Add to list before we send the request since we may
	  receive the response before returning from this routine
 Wait for the connection response 
 Check if successful 
  vmbus_connect - Sends a connect request on the partition service connection
 Initialize the vmbus connection 
	
	  Setup the vmbus event connection for channel interrupt
	  abstraction stuff
	
	  Setup the monitor notification facility. The 1st page for
	  parent->child and the 2nd page for child->parent
		
		  Isolation VM with AMD SNP needs to access monitor page via
		  address space above shared gpa boundary.
		
		  Set memory host visibility hvcall smears memory
		  and so zero monitor pages here.
	
	  Negotiate a compatible VMBUS version number with the
	  host. We start with the highest number we can support
	  and work our way down until we negotiate a compatible
	  version.
	
	  First send the unload request to the host.
		
		  memunmap() checks input address is ioremap address or not
		  inside. It doesn't unmap any thing in the non-SNP CVM and
		  so not check CVM type here.
  relid2channel - Get the channel object given its
  child relative id (ie channel id)
  vmbus_on_event - Process a channel event notification
  For batched channels (default) optimize host to guest signaling
  by ensuring:
  1. While reading the channel, we disable interrupts from host.
  2. Ensure that we process all posted messages from the host
     before returning from this callback.
  3. Once we return, enable signaling from the host. Once this
     state is set we check to see if additional packets are
     available to read. In this case we repeat the process.
     If this tasklet has been running for a long time
     then reschedule ourselves.
		 A channel once created is persistent even when
		  there is no driver handling the device. An
		  unloading driver sets the onchannel_callback to NULL.
 The time limit (2 jiffies) has been reached 
  vmbus_post_msg - Send a msg on the vmbus's message connection
	
	  hv_post_message() can have transient failures because of
	  insufficient resources. Retry the operation a couple of
	  times before giving up.
			
			  See vmbus_negotiate_version(): VMBus protocol 5.0
			  and higher require that we must use
			  VMBUS_MESSAGE_CONNECTION_ID_4 for the Initiate
			  Contact message, but on old hosts that only
			  support VMBus protocol 4.0 or lower, here we get
			  HV_STATUS_INVALID_CONNECTION_ID and we should
			  return an error immediately without retrying.
			
			  We could get this if we send messages too
			  frequently.
  vmbus_set_event - Send an event notification to the parent
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2009, Microsoft Corporation.
  Authors:
    Haiyang Zhang <haiyangz@microsoft.com>
    Hank Janssen  <hjanssen@microsoft.com>
  hv_gpadl_size - Return the real size of a gpadl, the size that Hyper-V uses
  For BUFFER gpadl, Hyper-V uses the exact same size as the guest does.
  For RING gpadl, in each ring, the guest uses one PAGE_SIZE as the header
  (because of the alignment requirement), however, the hypervisor only
  uses the first HV_HYP_PAGE_SIZE as the header, therefore leaving a
  (PAGE_SIZE - HV_HYP_PAGE_SIZE) gap. And since there are two rings in a
  ringbuffer, the total size for a RING gpadl that Hyper-V uses is the
  total size that the guest uses minus twice of the gap size.
 The size of a ringbuffer must be page-aligned 
		
		  Two things to notice here:
		  1) We're processing two ring buffers as a unit
		  2) We're skipping any space larger than HV_HYP_PAGE_SIZE in
		  the first guest-size page of each of the two ring buffers.
		  So we effectively subtract out two guest-size pages, and add
		  back two Hyper-V size pages.
  hv_ring_gpadl_send_hvpgoffset - Calculate the send offset (in unit of
                                  HV_HYP_PAGE) in a ring gpadl based on the
                                  offset in the guest
  @offset: the offset (in bytes) where the send ringbuffer starts in the
                virtual address space of the guest
	
	  For RING gpadl, in each ring, the guest uses one PAGE_SIZE as the
	  header (because of the alignment requirement), however, the
	  hypervisor only uses the first HV_HYP_PAGE_SIZE as the header,
	  therefore leaving a (PAGE_SIZE - HV_HYP_PAGE_SIZE) gap.
	 
	  And to calculate the effective send offset in gpadl, we need to
	  substract this gap.
  hv_gpadl_hvpfn - Return the Hyper-V page PFN of the @i th Hyper-V page in
                   the gpadl
  @type: the type of the gpadl
  @kbuffer: the pointer to the gpadl in the guest
  @size: the total size (in bytes) of the gpadl
  @send_offset: the offset (in bytes) where the send ringbuffer starts in the
                virtual address space of the guest
  @i: the index
  vmbus_setevent- Trigger an event notification on the specified
  channel.
	
	  For channels marked as in "low latency" mode
	  bypass the monitor page mechanism.
 Get the child to parent monitor page 
 vmbus_free_ring - drop mapping of ring buffer 
 vmbus_alloc_ring - allocate and map pages for ring buffer 
 Allocate the ring buffer 
 Used for Hyper-V Socket: a guest client's connect() to the host 
	
	  Release channel_mutex; otherwise, vmbus_onoffer_rescind() could block on
	  the mutex and be unable to signal the completion.
	 
	  See the caller target_cpu_store() for information about the usage of the
	  mutex.
  Setchange the vCPU (@target_vp) the channel (@child_relid) will interrupt.
  CHANNELMSG_MODIFYCHANNEL messages are aynchronous.  When VMbus version 5.3
  or later is negotiated, Hyper-V always sends an ACK in response to such a
  message.  For VMbus version 5.2 and earlier, it never sends an ACK.  With-
  out an ACK, we can not know when the host will stop interrupting the "old"
  vCPU and start interrupting the "new" vCPU for the given channel.
  The CHANNELMSG_MODIFYCHANNEL message type is supported since VMBus version
  VERSION_WIN10_V4_1.
  create_gpadl_header - Creates a gpadl for the specified buffer
 do we need a gpadl body msg 
 we need a gpadl body 
 fill in the header 
 how many pfns can we fit 
 fill in the body 
				
				  Free up all the allocated messages.
			
			  Gpadl is u32 and we are using a pointer which could
			  be 64-bit
			  This is governed by the guesthost protocol and
			  so the hypervisor guarantees that this is ok.
 add to msg header 
 everything fits in a header 
  __vmbus_establish_gpadl - Establish a GPADL for a buffer or ringbuffer
  @channel: a channel
  @type: the type of the corresponding GPADL, only meaningful for the guest.
  @kbuffer: from kmalloc or vmalloc
  @size: page-size multiple
  @send_offset: the offset (in bytes) where the send ring buffer starts,
               should be 0 for BUFFER type gpadl
  @gpadl_handle: some funky thing
 At this point, we received the gpadl created msg 
  vmbus_establish_gpadl - Establish a GPADL for the specified buffer
  @channel: a channel
  @kbuffer: from kmalloc or vmalloc
  @size: page-size multiple
  @gpadl_handle: some funky thing
  request_arr_init - Allocates memory for the requestor array. Each slot
  keeps track of the next available slot in the array. Initially, each
  slot points to the next one (as in a Linked List). The last slot
  does not point to anything, so its value is U64_MAX by default.
  @size The size of the array
 Last slot (no more available slots) 
  vmbus_alloc_requestor - Initializes @rqstor's fields.
  Index 0 is the first free slot
  @size: Size of the requestor array
  vmbus_free_requestor - Frees memory allocated for @rqstor
  @rqstor: Pointer to the requestor struct
 Create and init requestor 
 Establish the gpadl for the ring buffer 
 Create and init the channel open message 
	
	  The unit of ->downstream_ringbuffer_pageoffset is HV_HYP_PAGE and
	  the unit of ->ringbuffer_send_offset (i.e. send_pages) is PAGE, so
	  here we calculate it into HV_HYP_PAGE.
  vmbus_connect_ring - Open the channel but reuse ring buffer
  vmbus_open - Open the specified channel.
  vmbus_teardown_gpadl -Teardown the specified GPADL handle
	
	  If the channel has been rescinded;
	  we will be awakened by the rescind
	  handler; set the error code to zero so we don't leak memory.
	
	  vmbus_on_event(), running in the per-channel tasklet, can race
	  with vmbus_close_internal() in the case of SMP guest, e.g., when
	  the former is accessing channel->inbound.ring_buffer, the latter
	  could be freeing the ring_buffer pages, so here we must stop it
	  first.
	 
	  vmbus_chan_sched() might call the netvsc driver callback function
	  that ends up scheduling NAPI work that accesses the ring buffer.
	  At this point, we have to ensure that any such work is completed
	  and that the channel ring buffer is no longer being accessed, cf.
	  the calls to napi_disable() in netvsc_device_remove().
 See the inline comments in vmbus_chan_sched(). 
 Re-enable tasklet for use on re-open 
	
	  In case a device driver's probe() fails (e.g.,
	  util_probe() -> vmbus_open() returns -ENOMEM) and the device is
	  rescinded later (e.g., we dynamically disable an Integrated Service
	  in Hyper-V Manager), the driver's remove() invokes vmbus_close():
	  here we should skip most of the below cleanup work.
 Send a closing message 
		
		  If we failed to post the close msg,
		  it is perhaps better to leak memory.
 Tear down the gpadl for the channel's ring buffer 
			
			  If we failed to teardown gpadl,
			  it is perhaps better to leak memory.
 disconnect ring - close all channels 
	
	  Now close the primary.
  vmbus_close - Close the specified channel
  vmbus_sendpacket() - Send the specified buffer on the given channel
  @channel: Pointer to vmbus_channel structure
  @buffer: Pointer to the buffer you want to send the data from.
  @bufferlen: Maximum size of what the buffer holds.
  @requestid: Identifier of the request
  @type: Type of packet that is being sent e.g. negotiate, time
 	  packet etc.
  @flags: 0 or VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED
  Sends data in @buffer directly to Hyper-V via the vmbus.
  This will send the data unparsed to Hyper-V.
  Mainly used by Hyper-V drivers.
 Setup the descriptor 
 VmbusPacketTypeDataInBand; 
 VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED; 
 in 8-bytes granularity 
 will be updated in hv_ringbuffer_write() 
  vmbus_sendpacket_pagebuffer - Send a range of single-page buffer
  packets using a GPADL Direct packet type. This interface allows you
  to control notifying the host. This will be useful for sending
  batched data. Also the sender can control the send flags
  explicitly.
	
	  Adjust the size down since vmbus_channel_packet_page_buffer is the
	  largest size we support
 Setup the descriptor 
 in 8-bytes granularity 
 will be updated in hv_ringbuffer_write() 
  vmbus_sendpacket_multipagebuffer - Send a multi-page buffer packet
  using a GPADL Direct packet type.
  The buffer includes the vmbus descriptor.
 Setup the descriptor 
 in 8-bytes granularity 
 will be updated in hv_ringbuffer_write() 
  __vmbus_recvpacket() - Retrieve the user packet on the specified channel
  @channel: Pointer to vmbus_channel structure
  @buffer: Pointer to the buffer you want to receive the data into.
  @bufferlen: Maximum size of what the buffer can hold.
  @buffer_actual_len: The actual size of the data after it was received.
  @requestid: Identifier of the request
  @raw: true means keep the vmpacket_descriptor header in the received data.
  Receives directly from the hyper-v vmbus and puts the data it received
  into Buffer. This will receive the data unparsed from hyper-v.
  Mainly used by Hyper-V drivers.
  vmbus_recvpacket_raw - Retrieve the raw packet on the specified channel
  vmbus_next_request_id - Returns a new request id. It is also
  the index at which the guest memory address is stored.
  Uses a spin lock to avoid race conditions.
  @channel: Pointer to the VMbus channel struct
  @rqst_add: Guest memory address to be stored in the array
 Check rqstor has been initialized 
 Requestor array is full 
 The already held spin lock provides atomicity 
	
	  Cannot return an ID of 0, which is reserved for an unsolicited
	  message from Hyper-V.
  vmbus_request_addr - Returns the memory address stored at @trans_id
  in @rqstor. Uses a spin lock to avoid race conditions.
  @channel: Pointer to the VMbus channel struct
  @trans_id: Request id sent back from Hyper-V. Becomes the requestor's
  next request id.
 Check rqstor has been initialized 
 Hyper-V can send an unsolicited message with ID of 0 
 Data corresponding to trans_id is stored at trans_id - 1 
 Invalid trans_id 
 The already held spin lock provides atomicity 
  An implementation of key value pair (KVP) functionality for Linux.
  Copyright (C) 2010, Novell, Inc.
  Author : K. Y. Srinivasan <ksrinivasan@novell.com>
  This program is free software; you can redistribute it andor modify it
  under the terms of the GNU General Public License version 2 as published
  by the Free Software Foundation.
  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
  NON INFRINGEMENT.  See the GNU General Public License for more
  details.
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  Pre win8 version numbers used in ws2008 and ws 2008 r2 (win7)
  Global state maintained for transaction that is being processed. For a class
  of integration services, including the "KVP service", the specified protocol
  is a "requestresponse" protocol which means that there can only be single
  outstanding transaction from the host at any given point in time. We use
  this to simplify memory management in this driver - we cache and process
  only one message at a time.
  While the requestresponse protocol is guaranteed by the host, we further
  ensure this by serializing packet processing in this driver - we do not
  read additional packets from the VMBUS until the current packet is fully
  handled.
 hvutil_device_state 
 number of bytes received. 
 current message 
 chn we got the request 
 request ID. 
  This state maintains the version number registered by the daemon.
  Register the kernel component with the user-level daemon.
  As part of this registration, pass the LIC version number.
  This number has no meaning, it satisfies the registration protocol.
 Transaction is finished, reset the state here to avoid races. 
	
	  If we're still negotiating with the host cancel the timeout
	  work to not poll the channel twice.
	
	  If the timer fires, the user-mode component has not responded;
	  process the pending transaction.
	
	  We have a compatible daemon; complete the handshake.
  Callback when data is received from user mode.
	
	  If we are negotiating the version information
	  with the daemon; handle that first.
 We didn't send anything to userspace so the reply is spurious 
	
	  Based on the version of the daemon, we propagate errors from the
	  daemon differently.
		
		  Null string is used to pass back error condition.
		
		  We use the message header information from
		  the user level daemon to transmit errors.
	
	  Complete the transaction by forwarding the key value
	  to the host. But first, cancel the timeout.
		
		  Transform all parameters into utf16 encoding.
		
		  Transform all parameters into utf8 encoding.
 The transaction state is wrong. 
	
	  The keyvalue strings sent from the host are encoded in
	  in utf16; convert it to utf8 strings.
	  The host assures us that the utf16 strings will not exceed
	  the max lengths specified. We will however, reserve room
	  for the string terminating character - in the utf16s_utf8s()
	  function we limit the size of the buffer where the converted
	  string is placed to HV_KVP_EXCHANGE_MAX__SIZE -1 to guarantee
	  that the strings can be properly terminated!
		
		  We only need to pass on the info of operation, adapter_id
		  and addr_family to the userland kvp daemon.
			
			  The value is a string - utf16 encoding.
			
			  The value is a 32 bit scalar.
			  We save this as a utf8 string.
			
			  The value is a 64 bit scalar.
			  We save this as a utf8 string.
		
		  The key is always a string - utf16 encoding.
  Send a response back to the host.
	
	  Copy the global state for completing the transaction. Note that
	  only one transaction can be active at a time.
		
		  We have raced with util driver being unloaded;
		  silently return.
	
	  If the error parameter is set, terminate the host's enumeration
	  on this pool.
		
		  Something failed or we have timed out;
		  terminate the current host-side iteration.
	
	  The windows host expects the keyvalue pair to be encoded
	  in utf16. Ensure that the keyvalue size reported to the host
	  will be less than or equal to the MAX size (including the
	  terminating character).
 utf16 encoding 
 utf16 encoding 
	
	  If the utf8s to utf16s conversion failed; notify host
	  of the error.
 all our values are strings 
  This callback is invoked when we get a KVP message from the host.
  The host ensures that only one KVP transaction can be active at a time.
  KVP implementation in Linux needs to forward the key to a user-mde
  component to retrieve the corresponding value. Consequently, we cannot
  respond to the host in the context of this callback. Since the host
  guarantees that at most only one transaction can be active at a time,
  we stash away the transaction state in a set of global variables.
		
		  If userspace daemon is not connected and host is asking
		  us to negotiate we need to delay to not lose messages.
		  This is important for Failover IP setting.
 Ensure recvlen is big enough to read header data 
		
		  recvlen is not checked against sizeof(struct kvp_msg) because kvp_msg contains
		  a union of structs and the msg type received is not known. Code using this
		  struct should provide validation when accessing its fields.
		
		  Stash away this global state for completing the
		  transaction; note transactions are serialized.
 Userspace is not registered yet 
		
		  Get the information from the
		  user-mode component.
		  component. This transaction will be
		  completed when we get the value from
		  the user-mode component.
		  Set a timeout to deal with
		  user-mode not responding.
	
	  When this driver loads, the user level daemon that
	  processes the host requests may not yet be running.
	  Defer processing channel callbacks until the daemon
	  has registered.
	
	  If there is a pending transtion, it's unnecessary to tell the host
	  that the transaction will fail, because that is implied when
	  util_suspend() calls vmbus_close() later.
	
	  Forece the state to READY to handle the ICMSGTYPE_NEGOTIATE message
	  later. The user space daemon may go out of order and its write()
	  may fail with EINVAL: this doesn't matter since the daemon will
	  reset the device by closing and re-opening it.
 SPDX-License-Identifier: GPL-2.0-only
  Common code for Intel Running Average Power Limit (RAPL) support.
  Copyright (c) 2019, Intel Corporation.
 bitmasks for RAPL MSRs, used by primitive access functions 
 Non HW constants 
 not from raw data 
 scale from driver unit to powercap unit 
 no translation 
 per domain data, some are optional 
 Sideband MBI registers 
 per domain data. used to describe individual knobs such that access function
  can be consolidated into one instead of many inline functions.
 guarded by CPU hotplug lock 
	 prevent CPU hotplug, make sure the RAPL domain does not go
	  away while reading the counter.
	 package zone is the last zone of a package, we can free
	  memory here since all children has been unregistered.
 per RAPL domain ops, in the order of rapl_domain_type 
 RAPL_DOMAIN_PACKAGE 
 RAPL_DOMAIN_PP0 
 RAPL_DOMAIN_PP1 
 RAPL_DOMAIN_DRAM 
 RAPL_DOMAIN_PLATFORM 
  Constraint index used by powercap can be different than power limit (PL)
  index in that some  PLs maybe missing due to non-existent MSRs. So we
  need to convert here by finding the valid PLs only (name populated).
		
		  Time window parameter is not applicable for PL4 entry
		  so assigining '0' as default value.
 As a generalization rule, PL4 would be around two times PL2. 
 called after domain detection and package level data are set 
		
		  The PL2 power domain is applicable for limits two
		  and limits three
 Enable PL4 domain if the total power limits are three 
 per domain unit takes precedence 
 in the order of enum rapl_primitives 
 name, mask, shift, msr index, unit divisor 
 non-hardware 
 Read primitive data based on its related struct rapl_primitive_info.
  if xlate flag is set, return translated data based on data units, i.e.
  time, energy, and power.
  RAPL MSRs are non-architectual and are laid out not consistently across
  domains. Here we use primitive info to allow writing consolidated access
  functions.
  For a given primitive, it is processed by MSR mask and shift. Unit conversion
  is pre-assigned based on RAPL unit MSRs read at init time.
  63-------------------------- 31--------------------------- 0
  |                           xxxxx (mask)                   |
  |                                |<- shift ----------------|
  63-------------------------- 31--------------------------- 0
 domain with 2 limits has different bit 
 non-hardware data are collected by the polling thread 
 Similar use of primitive info in the read counterpart 
  Raw RAPL data stored in MSRs are in certain scales. We need to
  convert them into standard units based on the units reported in
  the RAPL unit MSRs. This is specific to CPUs as the method to
  calculate units differ on different CPUs.
  We convert the units to below format based on CPUs.
  i.e.
  energy unit: picoJoules  : Represented in picoJoules by default
  power unit : microWatts  : Represented in milliWatts by default
  time unit  : microseconds: Represented in seconds by default
 save the state of PLN irq mask bit before disabling it 
 REVISIT:
  When package power limit is set artificially low by RAPL, LVT
  thermal interrupt for package power limit should be ignored
  since we are not really exceeding the real limit. The intention
  is to avoid excessive interrupts while we are trying to save power.
  A useful feature might be routing the package_power_limit interrupt
  to userspace via eventfd. once we have a usecase, this is simple
  to do by adding an atomic notifier.
  Restore per package power limit interrupt enable state. Called from cpu
  hotplug code on package removal.
 irq enable state not saved, nothing to restore 
	 always enable clamp such that p-state can go below OS requested
	  range. power capping priority over guranteed frequency.
 some domains have pl2 
 fraction and exp. used for time unit 
	
	  Special processing based on 2^Y(1+F4), refer
	  to Intel Software Developer's manual Vol.3B: CH 14.9.3.
	
	  Atom time unit encoding is straight forward val  time_unit,
	  where time_unit is default to 1 sec. Never 0.
 Read once for all raw primitive data for domains 
 exclude non-raw primitives 
 Update the domain data of the new package 
 first we register package domain as the parent zone 
 track parent zone in per packagesocket data 
 done, only one package domain per socket 
 now register domains as children of the socketpackage 
 number of power limits per domain varies 
	
	  Clean up previously initialized domains within the package if we
	  failed after the first domain setup.
	 make sure domain counters are available and contains non-zero
	  values, otherwise skip it.
  Check if power limits are available. Two cases when they are not available:
  1. Locked by BIOS, in this case we still provide read-only access so that
     users can see what limit is set by the BIOS.
  2. Some CPUs make some domains monitoring only which means PLx MSRs may not
     exist at all. In this case, we do not show the constraints in powercap.
  Called after domains are detected and initialized.
 check if the domain is locked by BIOS, ignore if MSR doesn't exist 
 check if power limit MSR exists, otherwise domain is monitoring only 
 Detect active and valid domains for the given CPU, caller must
  ensure the CPU belongs to the targeted package and CPU hotlug is disabled.
 use physical package id to read counters 
 called from CPU hotplug notifier, hotplug lock held 
 do parent zone last 
 caller to ensure CPU hotplug lock is held 
 called from CPU hotplug notifier, hotplug lock held 
 add the new package to the list 
 check if the package contains valid domains 
 SPDX-License-Identifier: GPL-2.0-only
  Power capping class
  Copyright (c) 2013, Intel Corporation.
 Power zone show function 
 The only meaningful input is 0 (reset), others are silently ignored 
 Power zone constraint show function 
 Power zone constraint store function 
 Power zone information callbacks 
 Power zone attributes 
 Power zone constraint attributes callbacks 
 For one time seeding of constraint device attributes 
 A list of powercap control_types 
 Mutex to protect list of powercap control_types 
 Some limit to avoid overflow 
 Create zone and attributes in sysfs 
 Store flag as the release() may free memory 
 Remove id from parent idr struct 
 Destroy idrs allocated for this zone 
 Store flag as the release() may free memory 
 Default is enabled 
 Using idr to get the unique id 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2020 Linaro Limited
  Author: Daniel Lezcano <daniel.lezcano@linaro.org>
  The powercap based Dynamic Thermal Power Management framework
  provides to the userspace a consistent API to set the power limit
  on some devices.
  DTPM defines the functions to create a tree of constraints. Each
  parent node is a virtual description of the aggregation of the
  children. It propagates the constraints set at its level to its
  children and collect the children power information. The leaves of
  the tree are the real devices which have the ability to get their
  current power consumption and set their power limit.
  dtpm_update_power - Update the power on the dtpm
  @dtpm: a pointer to a dtpm structure to update
  Function to update the power values of the dtpm node specified in
  parameter. These new values will be propagated to the tree.
  Return: zero on success, -EINVAL if the values are inconsistent
  dtpm_release_zone - Cleanup when the node is released
  @pcz: a pointer to a powercap_zone structure
  Do some housecleaning and update the weight on the tree. The
  release will be denied if the node has children. This function must
  be called by the specific release callback of the different
  backends.
  Return: 0 on success, -EBUSY if there are children
  Set the power limit on the nodes, the power limit is distributed
  given the weight of the children.
  The dtpm node lock must be held when calling this function.
	
	  A max power limitation means we remove the power limit,
	  otherwise we set a constraint and flag the dtpm node.
	
	  Only leaves of the dtpm tree has ops to getset the power
			
			  Integer division rounding will inevitably
			  lead to a different min or max value when
			  set several times. In order to restore the
			  initial value, we force the child's min or
			  max power every time if the constraint is
			  at the boundaries.
	
	  Don't allow values outside of the power range previously
	  set when initializing the power numbers.
  dtpm_init - Allocate and initialize a dtpm struct
  @dtpm: The dtpm struct pointer to be initialized
  @ops: The dtpm device specific ops, NULL for a virtual node
  dtpm_unregister - Unregister a dtpm node from the hierarchy tree
  @dtpm: a pointer to a dtpm structure corresponding to the node to be removed
  Call the underlying powercap unregister function. That will call
  the release callback of the powercap zone.
  dtpm_register - Register a dtpm node in the hierarchy tree
  @name: a string specifying the name of the node
  @dtpm: a pointer to a dtpm structure corresponding to the new node
  @parent: a pointer to a dtpm structure corresponding to the parent node
  Create a dtpm node in the tree. If no parent is specified, the node
  is the root node of the hierarchy. If the root node already exists,
  then the registration will fail. The powercap controller must be
  initialized before calling this function.
  The dtpm structure must be initialized with the power numbers
  before calling this function.
  Return: zero on success, a negative value in case of error:
   -EAGAIN: the function is called before the framework is initialized.
   -EBUSY: the root node is already inserted
   -EINVAL:  there is no root node yet and @parent is specified
             no all ops are defined
             parent have ops which are reserved for leaves
    Other negative values are reported back from the powercap framework
 SPDX-License-Identifier: GPL-2.0
  Copyright 2018 Linaro Limited
  Author: Daniel Lezcano <daniel.lezcano@linaro.org>
  The idle injection framework provides a way to force CPUs to enter idle
  states for a specified fraction of time over a specified period.
  It relies on the smpboot kthreads feature providing common code for CPU
  hotplug and thread [un]parking.
  All of the kthreads used for idle injection are created at init time.
  Next, the users of the the idle injection framework provide a cpumask via
  its register function. The kthreads will be synchronized with respect to
  this cpumask.
  The idle + run duration is specified via separate helpers and that allows
  idle injection to be started.
  The idle injection kthreads will call play_idle_precise() with the idle
  duration and max allowed latency specified as per the above.
  After all of them have been woken up, a timer is set to start the next idle
  injection cycle.
  The timer interrupt handler will wake up the idle injection kthreads for
  all of the CPUs in the cpumask provided by the user.
  Idle injection is stopped synchronously and no leftover idle injection
  kthread activity after its completion is guaranteed.
  It is up to the user of this framework to provide a lock for higher-level
  synchronization to prevent race conditions like starting idle injection
  while unregistering from the framework.
  struct idle_inject_thread - task onoff switch structure
  @tsk: task injecting the idle cycles
  @should_run: whether or not to run the task (for the smpboot kthread API)
  struct idle_inject_device - idle injection data
  @timer: idle injection period timer
  @idle_duration_us: duration of CPU idle time to inject
  @run_duration_us: duration of CPU run time to allow
  @latency_us: max allowed latency
  @cpumask: mask of CPUs affected by idle injection
  idle_inject_wakeup - Wake up idle injection threads
  @ii_dev: target idle injection device
  Every idle injection task associated with the given idle injection device
  and running on an online CPU will be woken up.
  idle_inject_timer_fn - idle injection timer function
  @timer: idle injection hrtimer
  This function is called when the idle injection timer expires.  It wakes up
  idle injection tasks associated with the timer and they, in turn, invoke
  play_idle_precise() to inject a specified amount of CPU idle time.
  Return: HRTIMER_RESTART.
  idle_inject_fn - idle injection work function
  @cpu: the CPU owning the task
  This function calls play_idle_precise() to inject a specified amount of CPU
  idle time.
	
	  Let the smpboot main loop know that the task should not run again.
  idle_inject_set_duration - idle and run duration update helper
  @run_duration_us: CPU run time to allow in microseconds
  @idle_duration_us: CPU idle time to inject in microseconds
  idle_inject_get_duration - idle and run duration retrieval helper
  @run_duration_us: memory location to store the current CPU run time
  @idle_duration_us: memory location to store the current CPU idle time
  idle_inject_set_latency - set the maximum latency allowed
  @latency_us: set the latency requirement for the idle state
  idle_inject_start - start idle injections
  @ii_dev: idle injection control device structure
  The function starts idle injection by first waking up all of the idle
  injection kthreads associated with @ii_dev to let them inject CPU idle time
  sets up a timer to start the next idle injection period.
  Return: -EINVAL if the CPU idle or CPU run time is not set or 0 on success.
  idle_inject_stop - stops idle injections
  @ii_dev: idle injection control device structure
  The function stops idle injection and waits for the threads to finish work.
  If CPU idle time is being injected when this function runs, then it will
  wait until the end of the cycle.
  When it returns, there is no more idle injection kthread activity.  The
  kthreads are scheduled out and the periodic timer is off.
	
	  Stopping idle injection requires all of the idle injection kthreads
	  associated with the given cpumask to be parked and stay that way, so
	  prevent CPUs from going online at this point.  Any CPUs going online
	  after the loop below will be covered by clearing the should_run flag
	  that will cause the smpboot main loop to schedule them out.
	
	  Iterate over all (online + offline) CPUs here in case one of them
	  goes offline with the should_run flag set so as to prevent its idle
	  injection kthread from running when the CPU goes online again after
	  the ii_dev has been freed.
  idle_inject_setup - prepare the current task for idle injection
  @cpu: not used
  Called once, this function is in charge of setting the current task's
  scheduler parameters to make it an RT task.
  idle_inject_should_run - function helper for the smpboot API
  @cpu: CPU the kthread is running on
  Return: whether or not the thread can run.
  idle_inject_register - initialize idle injection on a set of CPUs
  @cpumask: CPUs to be affected by idle injection
  This function creates an idle injection control device structure for the
  given set of CPUs and initializes the timer associated with it.  It does not
  start any injection cycles.
  Return: NULL if memory allocation fails, idle injection control device
  pointer on success.
  idle_inject_unregister - unregister idle injection control device
  @ii_dev: idle injection control device to unregister
  The function stops idle injection for the given control device,
  unregisters its kthreads and frees memory allocated when that device was
  created.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2020 Linaro Limited
  Author: Daniel Lezcano <daniel.lezcano@linaro.org>
  The DTPM CPU is based on the energy model. It hooks the CPU in the
  DTPM tree which in turns update the power number by propagating the
  power number from the CPU energy model information to the parents.
  The association between the power and the performance state, allows
  to set the power of the CPU at the OPP granularity.
  The CPU hotplug is supported and the power numbers will be updated
  if a CPU is hot plugged  unplugged.
		
		  The capacity is the same for all CPUs belonging to
		  the same perf domain, so a single call to
		  arch_scale_cpu_capacity() is enough. However, we
		  need the CPU parameter to be initialized by the
		  loop, so the call ends up in this block.
		 
		  We can initialize 'max' with a cpumask_first() call
		  before the loop but the bits computation is not
		  worth given the arch_scale_cpu_capacity() just
		  returns a value where the resulting assembly code
		  will be optimized by the compiler.
	
	  In the improbable case where all the CPUs of the perf
	  domain are offline, 'max' will be zero and will lead to an
	  illegal operation with a zero division.
	
	  The callbacks at CPU hotplug time are calling
	  dtpm_update_power() which in turns calls update_pd_power().
	 
	  The function update_pd_power() uses the online mask to
	  figure out the power consumption limits.
	 
	  At CPUHP_AP_ONLINE_DYN, the CPU is present in the CPU
	  online mask when the cpuhp_dtpm_cpu_online function is
	  called, but the CPU is still in the online mask for the
	  tear down callback. So the power can not be updated when
	  the CPU is unplugged.
	 
	  At CPUHP_AP_DTPM_CPU_DEAD, the situation is the opposite as
	  above. The CPU online mask is not up to date when the CPU
	  is plugged in.
	 
	  For this reason, we need to call the online and offline
	  callbacks at different moments when the CPU online mask is
	  consistent with the power numbers we want to update.
 SPDX-License-Identifier: GPL-2.0-only
  Intel Running Average Power Limit (RAPL) Driver via MSR interface
  Copyright (c) 2019, Intel Corporation.
 Local defines 
 private data for RAPL MSR Interface 
 Handles CPU hotplug on multi-socket systems.
  If a CPU goes online as the first CPU of the physical package
  we add the RAPL package to the system. Similarly, when the last
  CPU of the package is removed, we remove the RAPL package and its
  associated domains. Cooling devices are handled accordingly at
  per-domain level.
 List of verified CPUs. 
  Sonics Silicon Backplane
  Broadcom PCI-core driver
  Copyright 2005, Broadcom Corporation
  Copyright 2006, 2007, Michael Buesch <m@bues.ch>
  Licensed under the GNUGPL. See COPYING for details.
  Code for hostmode operation.
 Probe a 32bit value on the bus and catch bus exceptions.
  Returns nonzero on a bus exception.
  This is MIPS specific
 Assume one-hot slot wiring 
 Global lock is OK, as we won't have more than one extpci anyway. 
 Core to access the external PCI config space. Can only have one. 
 We do only have one cardbus device behind the bridge. 
 Type 0 transaction 
 Slide the window 
 Calculate the address 
 Type 1 transaction 
 Calculate the address 
 This function is called when doing a pci_enable_device().
  We must first check if the device is a device on the PCI-core bridge.
 This is not a device on the PCI-core bridge. 
 Fix up interrupt lines 
 Early PCI fixup for a device on the PCI-core bridge. 
 This is not a device on the PCI-core bridge. 
 Enable PCI bridge bus mastering and memory space 
 Enable PCI bridge BAR1 prefetch and burst 
 Make sure our latency is high enough to handle the devices behind us 
 PCI device IRQ mapping. 
 This is not a device on the PCI-core bridge. 
 Reset devices on the external PCI bus 
 Clock on 
 Assertion time demanded by the PCI standard 
 Deassert RST# 
 Assertion time demanded by the PCI standard 
 GPIO 1 resets the bridge 
 64MB IO window 
 64MB config space 
 1GB memory window 
	
	  Accessing PCI config without a proper delay after devices reset (not
	  GPIO reset) was causing reboots on WRT300N v1.0 (BCM4704).
	  Tested delay 850 us lowered reboot chance to 50-80%, 1000 us fixed it
	  completely. Flushing all writes was also tested but with no luck.
	  The same problem was reported for WRT350N v1 (BCM4705), so we just
	  sleep here unconditionally.
 Enable PCI bridge BAR0 prefetch and burst 
 Clear error conditions 
 Enable PCI interrupts 
	 Ok, ready to run, register it to the system.
	  The following needs change, if we want to port hostmode
	  to non-MIPS platform.
	 Give some time to the PCI controller to configure itself with the new
	  values. Not waiting at this point causes crashes of the machine.
	 The 200-pin BCM4712 package does not bond out PCI. Even when
	  PCI is bonded out, some boards may leave the pins floating.
 CONFIG_SSB_PCICORE_HOSTMODE 
  Workarounds.
 Control ,
 Control );
 TLP Workaround register. 
 DLLP Link Control register. 
 Timer , 0x8128);
 CDR , 0x0100);
 CDR BW , 0x1466);
 TODO: DLLP Power Management Threshold 
 TODO: ASPM 
 TODO: No PLL down 
 Miscellaneous Configuration Fixup 
  Generic and Clientmode operation code.
 Disable PCI interrupts. 
 Additional PCIe always once-executed workarounds 
 TODO: ASPM 
 TODO: Clock Request Update 
 CONFIG_SSB_PCICORE_HOSTMODE 
 Start of Transaction 
 Write Transaction 
 Turnaround 
 Trans complete )
 Enable Preamble Sequence 
 MDIO Clock Divisor 
 Start of Transaction 
 Read Transaction 
 Turnaround 
 Wait for the device to complete the transaction 
 Trans complete ) {
 Enable Preamble Sequence 
 MDIO Clock Divisor 
 Start of Transaction 
 Write Transaction 
 Turnaround 
 Wait for the device to complete the transaction 
 Trans complete )
		 This SSB device is not on a PCI host-bus. So the IRQs are
		  not routed through the PCI core.
		  So we must not enable routing through the PCI core.
 Enable interrupts for this device. 
 Calculate the "coremask" for the device. 
 Setup PCIcore operation. 
  Sonics Silicon Backplane
  PCMCIA-Hostbus related functions
  Copyright 2006 Johannes Berg <johannes@sipsolutions.net>
  Copyright 2007-2008 Michael Buesch <m@bues.ch>
  Licensed under the GNUGPL. See COPYING for details.
 Define the following to 1 to enable a printk on each coreswitch. 
 PCMCIA configuration registers 
 Hardware invariants CIS tuples 
 PCMCIA SPROM size. 
 Write to a PCMCIA configuration register. 
 Read from a PCMCIA configuration register. 
 CONFIG_SSB_BLOCKIO 
 CONFIG_SSB_BLOCKIO 
 Not "static", as it's used in main.c 
 offset is the 16bit word offset 
 Make byte offset 
 offset is the 16bit word offset 
 Make byte offset 
 Read the SPROM image. bufsize is in 16bit words. 
 Write the SPROM image. size is in 16bit words. 
TODO
 We ignore this. 
 continue with next entry 
 First fetch the MAC address. 
 Fetch the vendor specific tuples. 
 Initialize the PCMCIA hardware. This is called on Init and Resume. 
	 Switch segment to a known state and sync
 Init the COR register. 
 Some cards also need this register to get poked. 
  Sonics Silicon Backplane
  Embedded systems support code
  Copyright 2005-2008, Broadcom Corporation
  Copyright 2006-2008, Michael Buesch <m@bues.ch>
  Copyright 2012, Hauke Mehrtens <hauke@hauke-m.de>
  Licensed under the GNUGPL. See COPYING for details.
 CONFIG_SSB_DRIVER_GIGE 
 This is not a PCI device on any SSB device. 
 CONFIG_SSB_DRIVER_GIGE 
	 Check if this PCI device is a device on a SSB bus or device
 This is not a PCI device on any SSB device. 
  Broadcom 43xx PCI-SSB bridge module
  This technically is a separate PCI driver module, but
  because of its small size we include it in the SSB core
  instead of creating a standalone module.
  Copyright 2007  Michael Buesch <m@bues.ch>
  Licensed under the GNUGPL. See COPYING for details.
  Sonics Silicon Backplane SoC host related functions.
  Subsystem core
  Copyright 2005, Broadcom Corporation
  Copyright 2006, 2007, Michael Buesch <m@bues.ch>
  Licensed under the GNUGPL. See COPYING for details.
 CONFIG_SSB_BLOCKIO 
 CONFIG_SSB_BLOCKIO 
 Ops for the plain SSB bus without a host-device (no PCI or PCMCIA). 
 Fill boardinfo structure 
  Sonics Silicon Backplane
  PCI Hostdevice wrapper
  Copyright (c) 2005 Martin Langer <martin-langer@gmx.de>
  Copyright (c) 2005 Stefano Brivio <st3@riseup.net>
  Copyright (c) 2005 Danny van Dyk <kugelfang@gentoo.org>
  Copyright (c) 2005 Andreas Jaggi <andreas.jaggi@waterwave.ch>
  Copyright (c) 2005-2007 Michael Buesch <m@bues.ch>
  Licensed under the GNUGPL. See COPYING for details.
	 if there is a wakeup enabled child device on ssb bus,
 CONFIG_PM_SLEEP 
	 Disable the RETRY_TIMEOUT register (0x41) to keep
  Sonics Silicon Backplane
  Bus scanning
  Copyright (C) 2005-2007 Michael Buesch <m@bues.ch>
  Copyright (C) 2005 Martin Langer <martin-langer@gmx.de>
  Copyright (C) 2005 Stefano Brivio <st3@riseup.net>
  Copyright (C) 2005 Danny van Dyk <kugelfang@gentoo.org>
  Copyright (C) 2005 Andreas Jaggi <andreas.jaggi@waterwave.ch>
  Copyright (C) 2006 Broadcom Corporation.
  Licensed under the GNUGPL. See COPYING for details.
 Can't reach this code. 
 Only map the first core for now. 
 Can't reach this code. 
 Nothing to ioremap in the SDIO case, just fake it 
	 More than one 802.11 core is only supported by special chips.
	  There are chips with two 802.11 cores, but with dangling
	  pins on the second core. Be careful and reject them here.
 CONFIG_SSB_PCIHOST 
 Switch to first core 
		 Now that we know the number of cores,
		  remap the whole IO space for all cores.
 Fetch basic information about each coredevice 
 CONFIG_SSB_DRIVER_EXTIF 
 CONFIG_SSB_DRIVER_MIPS 
				 Ignore PCI cores on PCI-E cards.
				  Ignore PCI-E cores on PCI cards.
 CONFIG_SSB_DRIVER_PCICORE 
					 This is a dangling ethernet core on a
					  wireless device. Ignore it.
  Sonics Silicon Backplane
  Broadcom EXTIF core driver
  Copyright 2005, Broadcom Corporation
  Copyright 2006, 2007, Michael Buesch <m@bues.ch>
  Copyright 2006, 2007, Felix Fietkau <nbd@openwrt.org>
  Copyright 2007, Aurelien Jarno <aurelien@aurel32.net>
  Licensed under the GNUGPL. See COPYING for details.
 Disable GPIO interrupt initially 
 CONFIG_SSB_SERIAL 
 Initialize extif so we can get to the LEDs and external UART 
 Set timing for the flash 
 Set programmable interface timing for external uart 
 We don't have a Extif core 
  Sonics Silicon Backplane
  Broadcom ChipCommon core driver
  Copyright 2005, Broadcom Corporation
  Copyright 2006, 2007, Michael Buesch <m@bues.ch>
  Copyright 2012, Hauke Mehrtens <hauke@hauke-m.de>
  Licensed under the GNUGPL. See COPYING for details.
 Clock sources 
 PCI clock 
 Crystal slow clock oscillator 
 Low power oscillator 
 We support SLOW only on 6..9 
 PMU controls clockmode, separated function needed 
 chipcommon cores prior to rev6 don't support dynamic clock control 
 ChipCommon cores rev10+ need testing 
 For revs 6..9 only 
 Force crystal on 
 udelay(150); TODO: not available in early init 
			 For dynamic control, we have to release our xtal_pu
 Get the Slow Clock Source 
 Get maximum or minimum (depending on get_max flag) slowclock frequency. 
 Set Idle Power clock rate to 1Mhz 
bcm-v4.sipsolutions.net802.11PmuFastPwrupDelay 
 TODO: 
bcm-v4.sipsolutions.net802.11ClkctlFastPwrupDelay 
 based on 32KHz ILP clock 
 We don't have a ChipCommon 
 Get the processor clock 
 5350 uses m2 to control mips 
 Get the bus clock 
 100200 or 120240 only 
 25Mhz, 2 dividers 
 set register for external IO to control LED. 
 Waitcount-3 = 10ns 
 Waitcount-1 = 40ns 
 Waitcount-0 = 240ns 
 0x01020a0c for a 100Mhz clock 
 Set timing for the flash 
 Waitcount-3 = 10nS 
 Waitcount-1 = 10nS 
 Waitcount-0 = 120nS 
 Enable EXTIF 
 Waitcount-3 = 10ns 
 Waitcount-2 = 20ns 
 Waitcount-1 = 100ns 
 Waitcount-0 = 120ns 
 0x01020a0c for a 100Mhz clock 
 Set chip watchdog reset timer to fire in 'ticks' backplane cycles 
 instant NMI 
 PLL clock 
 BCM5354 uses constant 25MHz clock 
 Set the override bit so we don't divide it 
 Turn off UART clock before switching clocksource. 
 Set the override bit so we don't divide it 
 Re-enable the UART clock. 
 Internal backplane clock 
 Fixed internal backplane clock 
 Clock source depends on strapping if UartClkOverride is unset 
 Internal divided backplane clock 
 Assume external clock of 1.8432 MHz 
 Determine the registers of the UARTs 
 Offset changed at after rev 0 
 CONFIG_SSB_SERIAL 
  Sonics Silicon Backplane PCI-Hostbus related functions.
  Copyright (C) 2005-2006 Michael Buesch <m@bues.ch>
  Copyright (C) 2005 Martin Langer <martin-langer@gmx.de>
  Copyright (C) 2005 Stefano Brivio <st3@riseup.net>
  Copyright (C) 2005 Danny van Dyk <kugelfang@gentoo.org>
  Copyright (C) 2005 Andreas Jaggi <andreas.jaggi@waterwave.ch>
  Derived from the Broadcom 4400 device driver.
  Copyright (C) 2002 David S. Miller (davem@redhat.com)
  Fixed by Pekka Pietikainen (pp@ee.oulu.fi)
  Copyright (C) 2006 Broadcom Corporation.
  Licensed under the GNUGPL. See COPYING for details.
 Define the following to 1 to enable a printk on each coreswitch. 
 Lowlevel coreswitching 
 Enabledisable the on board crystal oscillator andor PLL. 
		 Avoid glitching the clock if GPRS is already using it.
		  We can't actually read the state of the PLLPD so we infer it
		  by the value of XTAL_PU which is readable via gpioin.
 Turn the crystal on 
 Turn the PLL on 
 Turn the crystal off 
 Turn the PLL off 
 Get the word-offset for a SSB_SPROM_XXX define. 
 Helper to extract some _offset, which is one of the SSB_SPROM_XXX defines. 
 Polynomial:   x^8 + x^7 + x^6 + x^4 + x^2 + 1   
 If unset use 2dBm 
 Convert to Q5.2 
 Q5.2 Fractional part is stored in 0xC0 
 rev 3 moved MAC 
 only rev 1-2 have et0, et1 
 Extract the antenna gain values. 
 Revs 4 5 and 8 have partially shared layout 
 Extract the antenna gain values. 
 Extract cores power info info 
 TODO - get remaining rev 4 stuff needed 
 extract the MAC address 
 Extract the antenna gain values. 
 Extract cores power info info 
 Extract FEM info 
 TODO - get remaining rev 8 stuff needed 
 preset et0 and et1 mac 
		 Workaround: The BCM44XX chip has a stupid revision
		  number stored in the SPROM.
 per specs 
 per specs 
 can be unavailable! 
		
		  get SPROM offset: SSB_SPROM_BASE1 except for
		  chipcommon rev >= 31 or chip ID is 0x4312 and
		  chipcommon status & 3 == 2
 try for a 440 byte SPROM - revision 4 and higher 
			 All CRC attempts failed.
			  Maybe there is no SPROM on the device?
			  Now we ask the arch code if there is some sprom
 CONFIG_SSB_BLOCKIO 
 CONFIG_SSB_BLOCKIO 
 Not "static", as it's used in main.c 
  Sonics Silicon Backplane
  GPIO driver
  Copyright 2011, Broadcom Corporation
  Copyright 2012, Hauke Mehrtens <hauke@hauke-m.de>
  Licensed under the GNUGPL. See COPYING for details.
  Shared
  ChipCommon
 clear pulldown 
 Set pullup 
 clear pullup 
	 There is just one SoC in one device and its GPIO addresses should be
	  deterministic to address them more easily. The other buses could get
	  a random base number.
  EXTIF
	 There is just one SoC in one device and its GPIO addresses should be
	  deterministic to address them more easily. The other buses could get
	  a random base number.
  Init
  Sonics Silicon Backplane
  Common SPROM support routines
  Copyright (C) 2005-2008 Michael Buesch <m@bues.ch>
  Copyright (C) 2005 Martin Langer <martin-langer@gmx.de>
  Copyright (C) 2005 Stefano Brivio <st3@riseup.net>
  Copyright (C) 2005 Danny van Dyk <kugelfang@gentoo.org>
  Copyright (C) 2005 Andreas Jaggi <andreas.jaggi@waterwave.ch>
  Licensed under the GNUGPL. See COPYING for details.
 Strip whitespace at the end. 
 Length must match exactly. 
 Common sprom device-attribute show-handler 
	 Use interruptible locking, as the SPROM write might
	  be holding the lock for several seconds. So allow userspace
	  to cancel operation.
 Common sprom device-attribute store-handler 
	 Use interruptible locking, as the SPROM write might
	  be holding the lock for several seconds. So allow userspace
	  to cancel operation.
  ssb_arch_register_fallback_sprom - Registers a method providing a
  fallback SPROM if no SPROM is found.
  @sprom_callback: The callback function.
  With this function the architecture implementation may register a
  callback handler which fills the SPROM data structure. The fallback is
  only used for PCI based SSB devices, where no valid SPROM can be found
  in the shadow registers.
  This function is useful for weird architectures that have a half-assed
  SSB device hardwired to their PCI bus.
  Note that it does only work with PCI attached SSB devices. PCMCIA
  devices currently don't use this fallback.
  Architectures must provide the SPROM for native SSB devices anyway, so
  the fallback also isn't used for native devices.
  This function is available for architecture code, only. So it is not
  exported.
bcm-v4.sipsolutions.net802.11IsSpromAvailable 
	 status register only exists on chipcomon rev >= 11 and we need check
	  for >= 31 only
	 this routine differs from specs as we do not access SPROM directly
	  on PCMCIA
 can be unavailable! 
  Broadcom 43xx PCMCIA-SSB bridge module
  Copyright (c) 2007 Michael Buesch <m@bues.ch>
  Licensed under the GNUGPL. See COPYING for details.
 CONFIG_PM 
 CONFIG_PM 
  These are not module initexit functions!
  The module_pcmcia_driver() helper cannot be used here.
  Sonics Silicon Backplane
  ChipCommon serial flash interface
  Licensed under the GNUGPL. See COPYING for details.
 Initialize serial flash access 
	 Prepare platform device, but don't register it yet. It's too early,
  Sonics Silicon Backplane
  SDIO-Hostbus related functions
  Copyright 2009 Albert Herranz <albert_herranz@yahoo.es>
  Based on driversssbpcmcia.c
  Copyright 2006 Johannes Berg <johannes@sipsolutions.net>
  Copyright 2007-2008 Michael Buesch <m@bues.ch>
  Licensed under the GNUGPL. See COPYING for details.
 Define the following to 1 to enable a printk on each coreswitch. 
 Hardware invariants CIS tuples 
 same as in PCMCIA 
  Function 1 miscellaneous registers.
  Definitions match srcincludesbsdio.h from the
  Android Open Source Project
  http:android.git.kernel.org?p=platformsystemwlanbroadcom.git
 SB Address window Low (b15) 
 SB Address window Mid (b23-b16) 
 SB Address window High (b24-b31) 
 valid bits in SBSDIO_FUNC1_SBADDRxxx regs 
 Valid address bits in SBADDRLOW 
 Valid address bits in SBADDRMID 
 Valid address bits in SBADDRHIGH 
 sb offset addr is <= 15 bits, 32k 
 REVISIT: this flag doesn't seem to matter 
 forces 32-bit SB access 
  Address map within the SDIO function address space (128K).
    Start   End     Description
    ------- ------- ------------------------------------------
    0x00000 0x0ffff selected backplane address window (64K)
    0x10000 0x1ffff backplane control registers (max 64K)
  The current address window is configured by writing to registers
  SBADDRLOW, SBADDRMID and SBADDRHIGH.
  In order to access the contents of a 32-bit Silicon Backplane address
  the backplane address window must be first loaded with the highest
  16 bits of the target address. Then, an access must be done to the
  SDIO function address space using the lower 15 bits of the address.
  Bit 15 of the address must be set when doing 32 bit accesses.
  10987654321098765432109876543210
  WWWWWWWWWWWWWWWWW                 SB Address Window
                  OOOOOOOOOOOOOOOO  Offset within SB Address Window
                  a                 32-bit access flag
  SSB IO via SDIO.
  NOTE: SDIO address @addr is 17 bits long (SDIO address space is 128K).
 host claimed 
 host claimed 
 for enumeration use only 
 for enumeration use only 
 host must be already claimed 
 32 bit data access 
 32 bit data access 
 CONFIG_SSB_BLOCKIO 
 32 bit data access 
 32 bit data access 
 CONFIG_SSB_BLOCKIO 
 Not "static", as it's used in main.c 
 extended function 
 fetch the MAC address. 
 vendor specific tuple 
 Not present 
 Nothing to do here. 
  Sonics Silicon Backplane
  Broadcom Gigabit Ethernet core driver
  Copyright 2008, Broadcom Corporation
  Copyright 2008, Michael Buesch <m@bues.ch>
  Licensed under the GNUGPL. See COPYING for details.
MODULE_DESCRIPTION("SSB Broadcom Gigabit Ethernet driver");
MODULE_AUTHOR("Michael Buesch");
MODULE_LICENSE("GPL");
 MODULE_DEVICE_TABLE(ssb, ssb_gige_tbl); 
 Setup BAR0. This is a 64k MMIO region. 
 Enable the memory region. 
	 Write flushing is controlled by the Flush Status Control register.
	  We want to flush every register write with a timeout and we want
	  to disable the IRQ mask while flushing to avoid concurrency.
	  Note that automatic write flushing does _not_ work from
	  an IRQ handler. The driver must flush manually by reading a register.
	 Check if we have an RGMII or GMII PHY-bus.
 The PCI device is not on this SSB GigE bridge device. 
 Fixup the PCI resources. 
 Fixup interrupt lines. 
 The PCI device is not on this SSB GigE bridge device. 
  Sonics Silicon Backplane
  Broadcom ChipCommon Power Management Unit driver
  Copyright 2009, Michael Buesch <m@bues.ch>
  Copyright 2007, Broadcom Corporation
  Licensed under the GNUGPL. See COPYING for details.
 Crystal frequency in kHz.
 Crystal frequency value for PMU control 
 Tune the PLL to the crystal speed. crystalfreq is in kHz. 
 Check if the PLL already is programmed to this frequency. 
 We're already there... 
 First turn the PLL off. 
 Set PDIV in PLL control 0. 
 Set WILD in PLL control 1. 
 Set WILD in PLL control 2. 
 Set the crystalfrequency and the divisor. 
 Crystal frequency in kHz.
 Crystal frequency value for PMU control 
 Tune the PLL to the crystal speed. crystalfreq is in kHz. 
		 We do not touch the BCM4312 PLL and assume
 Check if the PLL already is programmed to this frequency. 
 We're already there... 
 First turn the PLL off. 
 Adjust the BBPLL to 2 on all channels later. 
 Set p1div and p2div. 
 Set ndiv int and ndiv mode 
 Set ndiv frac 
 Change the drive strength, if required. 
 Tune the crystalfreq and the divisor. 
 in kHz. 0 = keep default freq. 
 The resource number 
 The updown value 
 The resource number 
 SET | ADD | REMOVE 
 The depend mask 
 Adjust ILP Request to avoid forcing EXTBB into burst mode. 
 Adjust HT-Available dependencies. 
		 We keep the default settings:
		  min_msk = 0xCBB
		  max_msk = 0x7FFFF
 Power OTP down later. 
 The PLL may turn on, if it decides so. 
 The PLL may turn on, if it decides so. 
 The PLL may turn on, if it decides so. 
 Set the resource masks. 
bcm-v4.sipsolutions.net802.11SSBPmuInit 
SPEC FIXME found via mmiotrace - dummy read?
 5354 chip uses a non programmable PLL of frequency 240MHz 
  Sonics Silicon Backplane
  Broadcom MIPS core driver
  Copyright 2005, Broadcom Corporation
  Copyright 2006, 2007, Michael Buesch <m@bues.ch>
  Licensed under the GNUGPL. See COPYING for details.
 not irq supported 
 Get the MIPS IRQ assignment for a specified device.
  If unassigned, 0 is returned.
  If disabled, 5 is returned.
  If not supported, 6 is returned.
 Clear the IRQ in the MIPScore backplane registers 
 clear the old irq 
 assign the new one 
 When there is no chipcommon on the bus there is 4MB flash 
 There is ChipCommon, so use it to read info about flash 
 We don't have a MIPS core 
 Assign IRQs to all cores on the bus, start with irq line 2, because serial usually takes 1 
			 shouldn't need a separate irq line for non-4710, most of them have a proper
 These devices get their own IRQ line if available, the rest goes on IRQ0 
  Sonics Silicon Backplane
  Subsystem core
  Copyright 2005, Broadcom Corporation
  Copyright 2006, 2007, Michael Buesch <m@bues.ch>
  Licensed under the GNUGPL. See COPYING for details.
 Temporary list of yet-to-be-attached buses 
 List if running buses 
 Software ID counter 
 buses_mutes locks the two buslists and the next_busnumber.
  Don't lock this directly, but use ssb_buses_[un]lock() below.
 There are differences in the codeflow, if the bus is
  initialized from early boot, as various needed services
  are not available early. This is a mechanism to delay
  these initializations to after early boot has finished.
  It's also used to avoid mutex locking, as that's not
  available and needed early.
 CONFIG_SSB_PCIHOST 
 CONFIG_SSB_PCMCIAHOST 
	 Reset HW state information in memory, so that HW is
	  completely reinitialized.
 ssb_devices_freeze - Freeze all devices on the bus.
  After freezing no device driver will be handling a device
  on this bus anymore. ssb_devices_thaw() must be called after
  a successful freeze to reactivate the devices.
  @bus: The bus.
  @ctx: Context structure. Pass this to ssb_devices_thaw().
 ssb_devices_thaw - Unfreeze all devices on the bus.
  This will re-attach the device drivers and re-init the devices.
  @ctx: The context structure from ssb_devices_freeze()
 CONFIG_SSB_SPROM 
 found 
 See the comment at the ssb_is_early_boot definition 
 See the comment at the ssb_is_early_boot definition 
		 We don't register SSB-system devices to the kernel,
		  as the drivers for them are built into SSB.
			 Set dev to NULL to not unregister
			  dev on error unwinding.
 Unwind the already registered devices. 
 Needs ssb_buses_lock() 
		 Can't init the PCIcore in ssb_bus_register(), as that
		  is too early in boot for embedded systems
		  (no udelay() available). So do it here in attach stage.
 Powerup the bus 
 Init SDIO-host device (if any), before the scan 
 Scan for devices (cores) 
 Init PCI-host device (if any) 
 Init PCMCIA-host device (if any) 
 Initialize basic system devices (if available) 
	 Queue it for attach.
	  See the comment at the ssb_is_early_boot definition.
 This is not early boot, so we must attach the bus now 
 CONFIG_SSB_PCIHOST 
 CONFIG_SSB_PCMCIAHOST 
 CONFIG_SSB_PCMCIAHOST 
 map the magic values 
 Calculate the speed the backplane would run at a given set of clockcontrol values 
 100200 or 120240 only 
 48Mhz base, 3 dividers 
 25Mhz, 2 dividers 
 48Mhz, 4 dividers 
 25Mhz, 4 dividers 
 48Mhz, 4 dividers 
 25Mhz, 4 dividers 
 25Mhz, 2 dividers 
 25Mhz, 4 dividers 
 48Mhz base, 3 dividers 
 25Mhz, 2 dividers 
 48Mhz, 4 dividers 
 25Mhz, 4 dividers 
 Get the current speed the backplane is running at 
 25Mhz, 2 dividers 
 The REJECT bit seems to be different for Backplane rev 2.3 
 TODO - find the proper REJECT bit 
 same here 
 this is a guess 
	 Make _really_ sure the device has finished the TMSLOW
	  register write transaction, as we risk running into
	  a machine check exception otherwise.
	  Do this by reading the register back to commit the
	  PCI write and delay an additional usec for the device
	  to react to the change.
 Clear SERR if set. This is a hw bug workaround. 
 Wait for bitmask in a register to get set or cleared.
  timeout is in units of ten-microseconds
 Some chipsets need routing known for PCIe and 64-bit DMA 
	 On buses where more than one core may be working
	  at a time, we must not powerdown stuff if there are
	  still cores that may want to run.
 This is used for both, PCI and ChipCommon core, so be careful. 
 flush 
 flush 
 This forces an update of the cached registers. 
 unsupported 
 unsupported 
 unsupported 
 unsupported 
 See the comment at the ssb_is_early_boot definition 
	 Maybe we already registered some buses at early boot.
	  Check for this and attach them
 don't fail SSB init because of this 
 don't fail SSB init because of this 
 don't fail SSB init because of this 
 ssb must be initialized after PCI but before the ssb drivers.
  That means we must use some initcall between subsys_initcall
  and device_initcall.
 SPDX-License-Identifier: GPL-2.0
  Generic serial GNSS receiver driver
  Copyright (C) 2018 Johan Hovold <johan@kernel.org>
 write is only buffered synchronously 
 FIXME: determine if interrupted? 
  FIXME: need to provide subdriver defaults or separate dt parsing from
  allocation.
 CONFIG_PM 
	
	  FIXME: serdev currently lacks support for managing the underlying
	  device's wakeup settings. A workaround would be to close the serdev
	  device here if it is open.
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0
  SiRFstar GNSS receiver driver
  Copyright (C) 2018 Johan Hovold <johan@kernel.org>
  If no data arrives for this time, we assume that the chip is off.
  REVISIT: The report cycle is configurable and can be several minutes long,
  so this will only work reliably if the report cycle is set to a reasonable
  low value. Also power saving settings (like send data only on movement)
  might things work even worse.
  Workaround might be to parse shutdown or bootup messages.
 write is only buffered synchronously 
 FIXME: determine if interrupted? 
 Wait for state change (including any shutdown messages). 
 Wait for data reception or timeout. 
 Wait for chip to boot into hibernate mode. 
 Force hibernate mode if already active. 
 clear runtime_error flag 
 SPDX-License-Identifier: GPL-2.0
  Mediatek GNSS receiver driver
  Copyright (C) 2018 Johan Hovold <johan@kernel.org>
 SPDX-License-Identifier: GPL-2.0
  GNSS receiver core
  Copyright (C) 2018 Johan Hovold <johan@kernel.org>
 FIFO size must be a power of two 
 Ignoring O_NONBLOCK, write_raw() is synchronous. 
		
		  Assumes write_raw can always accept GNSS_WRITE_BUF_SIZE
		  bytes.
		 
		  FIXME: revisit
 Set a flag which can be accessed without holding the rwsem. 
  Caller guarantees serialisation.
  Must not be called for a closed device.
 SPDX-License-Identifier: GPL-2.0
  u-blox GNSS receiver driver
  Copyright (C) 2018 Johan Hovold <johan@kernel.org>
 SPDX-License-Identifier: GPL-2.0-or-later
  rio_cm - RapidIO Channelized Messaging Driver
  Copyright 2013-2016 Integrated Device Technology, Inc.
  Copyright (c) 2015, Prodrive Technologies
  Copyright (c) 2015, RapidIO Trade Association
 Debug output filtering masks 
 driver init 
 driver exit 
 mport addremove 
 RapidIO device addremove 
 channel operations 
 waiting for events 
 message TX 
 message TX event 
 inbound data messages 
 inbound REQACKNACK messages 
 connect response TO (in sec) 
 Use full range of u16 field 
 Max number of endpoints 
 Tracking RX buffers reported to upper level 
 local channel ID 
 channel refcount 
 associated CM device object 
 remote RapidIO device 
 local destID 
 remote destID 
 remote channel ID 
 requester destID 
 requester channel ID 
  A channel_dev structure represents a CM_CDEV
  @cdev	Character device
  @dev		Associated device object
  riocm_rx_fill - fills a ring of receive buffers for given cm device
  @cm: cm_dev object
  @nent: max number of entries to fill
  Returns: none
  riocm_rx_free - frees all receive buffers associated with given cm device
  @cm: cm_dev object
  Returns: none
  riocm_req_handler - connection request handler
  @cm: cm_dev object
  @req_data: pointer to the request packet
  Returns: 0 if success, or
           -EINVAL if channel is not in correct state,
           -ENODEV if cannot find a channel with specified ID,
           -ENOMEM if unable to allocate memory to store the request
  riocm_resp_handler - response to connection request handler
  @resp_data: pointer to the response packet
  Returns: 0 if success, or
           -EINVAL if channel is not in correct state,
           -ENODEV if cannot find a channel with specified ID,
  riocm_close_handler - channel close request handler
  @req_data: pointer to the request packet
  Returns: 0 if success, or
           -ENODEV if cannot find a channel with specified ID,
             + error codes returned by riocm_ch_close.
  rio_cm_handler - function that services request (non-data) packets
  @cm: cm_dev object
  @data: pointer to the packet
  rio_rx_data_handler - received data packet handler
  @cm: cm_dev object
  @buf: data packet
  Returns: 0 if success, or
           -ENODEV if cannot find a channel with specified ID,
           -EIO if channel is not in CONNECTED state,
           -ENOMEM if channel RX queue is full (packet discarded)
 Discard data message for non-existing channel 
 Place pointer to the buffer into channel's RX queue 
 Channel is not ready to receive data, discard a packet 
 If RX ring is full, discard a packet 
  rio_ibmsg_handler - inbound message packet handler
 For now simply discard packets other than channel 
 Process a channel message 
  rio_txcq_handler - TX completion handler
  @cm: cm_dev object
  @slot: TX queue slot
  TX completion handler also ensures that pending request packets are placed
  into transmit queue as soon as a free slot becomes available. This is done
  to give higher priority to request packets during high intensity data flow.
	 ATTN: Add TX completion notification ifwhen direct buffer
	  transfer is implemented. At this moment only correct tracking
	  of tx_count is important.
	
	  If there are pending requests, insert them into transmit queue
  riocm_post_send - helper function that places packet into msg TX queue
  @cm: cm_dev object
  @rdev: target RapidIO device object (required by outbound msg interface)
  @buffer: pointer to a packet buffer to send
  @len: length of data to transfer
  @req: request priority flag
  Returns: 0 if success, or error code otherwise.
  riocm_ch_send - sends a data packet to a remote device
  @ch_id: local channel ID
  @buf: pointer to a data buffer to send (including CM header)
  @len: length of data to transfer (including CM header)
  ATTN: ASSUMES THAT THE HEADER SPACE IS RESERVED PART OF THE DATA PACKET
  Returns: 0 if success, or
           -EINVAL if one or more input parameters isare not valid,
           -ENODEV if cannot find a channel with specified ID,
           -EAGAIN if a channel is not in CONNECTED state,
 	    + error codes returned by HW send routine.
	
	  Fill buffer header section with corresponding channel data
	 ATTN: the function call below relies on the fact that underlying
	  HW-specific add_outb_message() routine copies TX data into its own
	  internal transfer buffer (true for all RIONET compatible mport
	  drivers). Must be reviewed if mport driver uses the buffer directly.
  riocm_ch_receive - fetch a data packet received for the specified channel
  @ch: local channel ID
  @buf: pointer to a packet buffer
  @timeout: timeout to wait for incoming packet (in jiffies)
  Returns: 0 and valid buffer pointer if success, or NULL pointer and one of:
           -EAGAIN if a channel is not in CONNECTED state,
           -ENOMEM if in-use tracking queue is full,
           -ETIME if wait timeout expired,
 	    -EINTR if wait was interrupted.
		 If we do not have entries to track buffers given to upper
		  layer, reject request.
 We have no entry to store pending message: drop it 
  riocm_ch_connect - sends a connect request to a remote device
  @loc_ch: local channel ID
  @cm: CM device to send connect request
  @peer: target RapidIO device
  @rem_ch: remote channel ID
  Returns: 0 if success, or
           -EINVAL if the channel is not in IDLE state,
           -EAGAIN if no connection request available immediately,
           -ETIME if ACK response timeout expired,
           -EINTR if wait for response was interrupted.
	
	  Send connect request to the remote RapidIO device
	 ATTN: the function call below relies on the fact that underlying
	  HW-specific add_outb_message() routine copies TX data into its
	  internal transfer buffer. Must be reviewed if mport driver uses
	  this buffer directly.
 Wait for connect response from the remote device 
	 ATTN: the function call below relies on the fact that underlying
	  add_outb_message() routine copies TX data into its internal transfer
	  buffer. Review if switching to direct buffer version.
  riocm_ch_accept - accept incoming connection request
  @ch_id: channel ID
  @new_ch_id: local mport device
  @timeout: wait timeout (if 0 non-blocking call, do not wait if connection
            request is not available).
  Returns: pointer to new channel struct if success, or error-valued pointer:
           -ENODEV - cannot find specified channel or mport,
           -EINVAL - the channel is not in IDLE state,
           -EAGAIN - no connection request available immediately (timeout=0),
           -ENOMEM - unable to allocate new channel,
           -ETIME - wait timeout expired,
           -EINTR - wait was interrupted.
 Don't sleep if this is a non blocking call 
 Create new channel for this connection 
 Find requester's device object 
 If peer device object not found, simply ignore the request 
 Acknowledge the connection request. 
  riocm_ch_listen - puts a channel into LISTEN state
  @ch_id: channel ID
  Returns: 0 if success, or
           -EINVAL if the specified channel does not exists or
                   is not in CHAN_BOUND state.
  riocm_ch_bind - associate a channel object and an mport device
  @ch_id: channel ID
  @mport_id: local mport device ID
  @context: pointer to the additional caller's context
  Returns: 0 if success, or
           -ENODEV if cannot find specified mport,
           -EINVAL if the specified channel does not exist or
                   is not in IDLE state.
 Find matching cm_dev object 
  riocm_ch_alloc - channel object allocation helper routine
  @ch_num: channel ID (1 ... RIOCM_MAX_CHNUM, 0 = automatic)
  Return value: pointer to newly created channel object,
                or error-valued pointer
 If requested, try to obtain the specified channel ID 
 Obtain channel ID from the dynamic allocation range 
  riocm_ch_create - creates a new channel object and allocates ID for it
  @ch_num: channel ID (1 ... RIOCM_MAX_CHNUM, 0 = automatic)
  Allocates and initializes a new channel object. If the parameter ch_num > 0
  and is within the valid range, riocm_ch_create tries to allocate the
  specified ID for the new channel. If ch_num = 0, channel ID will be assigned
  automatically from the range (chstart ... RIOCM_MAX_CHNUM).
  Module parameter 'chstart' defines start of an ID range available for dynamic
  allocation. Range below 'chstart' is reserved for pre-defined ID numbers.
  Available channel numbers are limited by 16-bit size of channel numbers used
  in the packet header.
  Return value: PTR to rio_channel structure if successful (with channel number
                updated via pointer) or error-valued pointer if error.
  riocm_ch_free - channel object release routine
  @ref: pointer to a channel's kref structure
	
	  Send CH_CLOSE notification to the remote RapidIO device
	 ATTN: the function call below relies on the fact that underlying
	  add_outb_message() routine copies TX data into its internal transfer
	  buffer. Needs to be reviewed if switched to direct buffer mode.
  riocm_ch_close - closes a channel object with specified ID (by local request)
  @ch: channel to be closed
 Timeout on wait occurred 
 Wait_for_completion was interrupted by a signal 
  riocm_cdev_open() - Open character device
  riocm_cdev_release() - Release character device
 Check if there are channels associated with this file descriptor 
  cm_ep_get_list_size() - Reports number of endpoints in the network
 Find a matching cm_dev object 
  cm_ep_get_list() - Returns list of attached endpoints
 Find a matching cm_dev object 
 report an updated number of entries 
 put back an mport ID 
  cm_mport_get_list() - Returns list of available local mport devices
 Scan all registered cm_dev objects 
 report a real number of entries 
  cm_chan_create() - Create a message exchange channel
  cm_chan_close() - Close channel
  @filp:	Pointer to file object
  @arg:	Channel to close
  cm_chan_bind() - Bind channel
  @arg:	Channel number
  cm_chan_listen() - Listen on channel
  @arg:	Channel number
  cm_chan_accept() - Accept incoming connection
  @filp:	Pointer to file object
  @arg:	Channel number
  cm_chan_connect() - Connect on channel
  @arg:	Channel information
 Find matching cm_dev object 
 Find corresponding RapidIO endpoint device object 
  cm_chan_msg_send() - Send a message through channel
  @arg:	Outbound message information
  cm_chan_msg_rcv() - Receive a message through channel
  @arg:	Inbound message information
  riocm_cdev_ioctl() - IOCTL requests handler
  riocm_add_dev - add new remote RapidIO device into channel management core
  @dev: device object associated with RapidIO device
  @sif: subsystem interface
  Adds the specified RapidIO device (if applicable) into peers list of
  the corresponding channel management device (cm_dev).
 Check if the remote device has capabilities required to support CM 
 Find a corresponding cm_dev object 
  riocm_remove_dev - remove remote RapidIO device from channel management core
  @dev: device object associated with RapidIO device
  @sif: subsystem interface
  Removes the specified RapidIO device (if applicable) from peers list of
  the corresponding channel management device (cm_dev).
 Check if the remote device has capabilities required to support CM 
 Find matching cm_dev object 
 Remove remote device from the list of peers 
	
	  Release channels associated with this peer
  riocm_cdev_add() - Create rio_cm char device
  @devno: device number assigned to device (MAJ + MIN)
  riocm_add_mport - add new local mport device into channel management core
  @dev: device object associated with mport
  @class_intf: class interface
  When a new mport device is added, CM immediately reserves inbound and
  outbound RapidIO mailboxes that will be used.
	
	  Allocate and register inbound messaging buffers to be ready
	  to receive channel and system management requests
  riocm_remove_mport - remove local mport device from channel management core
  @dev: device object associated with mport
  @class_intf: class interface
  Removes a local mport device from the list of registered devices that provide
  channel management services. Returns an error if the specified mport is not
  registered with the CM core.
 Find a matching cm_dev object 
 Release channels bound to this mport 
 Remove and free peer entries 
	
	  If there are any channels left in connected state send
	  close notification to the connection partner.
	  First build a list of channels that require a closing
	  notification because function riocm_send_close() should
	  be called outside of spinlock protected code.
  riocm_interface handles additionremoval of remote RapidIO devices
  rio_mport_interface handles additionremoval local mport devices
 Create device class needed by udev 
	
	  Register as rapidio_port class interface to get notifications about
	  mport additions and removals.
	
	  Register as RapidIO bus interface to get notifications about
	  additionremoval of remote RapidIO devices.
 SPDX-License-Identifier: GPL-2.0-or-later
  RapidIO driver support
  Copyright 2005 MontaVista Software, Inc.
  Matt Porter <mporter@kernel.crashing.org>
   rio_match_device - Tell if a RIO device has a matching RIO device id structure
   @id: the RIO device id structure to match against
   @rdev: the RIO device structure to match against
   Used from driver probe and bus matching to check whether a RIO device
   matches a device id structure provided by a RIO driver. Returns the
   matching &struct rio_device_id or %NULL if there is no match.
  rio_dev_get - Increments the reference count of the RIO device structure
  @rdev: RIO device being referenced
  Each live reference to a device should be refcounted.
  Drivers for RIO devices should normally record such references in
  their probe() methods, when they bind to a device, and release
  them by calling rio_dev_put(), in their disconnect() methods.
  rio_dev_put - Release a use of the RIO device structure
  @rdev: RIO device being disconnected
  Must be called when a user of a device is finished with it.
  When the last user of the device calls this function, the
  memory of the device is freed.
   rio_device_probe - Tell if a RIO device structure has a matching RIO device id structure
   @dev: the RIO device structure to match against
  return 0 and set rio_dev->driver when drv claims rio_dev, else error
   rio_device_remove - Remove a RIO device from the system
   @dev: the RIO device structure to match against
  Remove a RIO device from the system. If it has an associated
  driver, then run the driver remove() method.  Then update
  the reference count.
   rio_register_driver - register a new RIO driver
   @rdrv: the RIO driver structure to register
   Adds a &struct rio_driver to the list of registered drivers.
   Returns a negative value on error, otherwise 0. If no error
   occurred, the driver remains registered even if no device
   was claimed during registration.
 initialize common driver fields 
 register with core 
   rio_unregister_driver - unregister a RIO driver
   @rdrv: the RIO driver structure to unregister
   Deletes the &struct rio_driver from the list of registered RIO
   drivers, gives it a chance to clean up by calling its remove()
   function for each device it was responsible for, and marks those
   devices as driverless.
   rio_match_bus - Tell if a RIO device structure has a matching RIO driver device id structure
   @dev: the standard device structure to match against
   @drv: the standard driver structure containing the ids to match against
   Used by a driver to check whether a RIO device present in the
   system is in its list of supported devices. Returns 1 if
   there is a matching &struct rio_device_id or 0 if there is
   no match.
   rio_bus_init - Register the RapidIO bus with the device model
   Registers the RIO mport device class and RIO bus type with the Linux
   device model.
 SPDX-License-Identifier: GPL-2.0-or-later
  RapidIO sysfs attributes and support
  Copyright 2005 MontaVista Software, Inc.
  Matt Porter <mporter@kernel.crashing.org>
 Sysfs support 
 Switch-only attributes 
 Several chips lock up trying to read undefined config space 
		
		  Hide switch-specific attributes for a non-switch device.
 SPDX-License-Identifier: GPL-2.0-or-later
  RapidIO enumeration and discovery support
  Copyright 2005 MontaVista Software, Inc.
  Matt Porter <mporter@kernel.crashing.org>
  Copyright 2009 Integrated Device Technology, Inc.
  Alex Bounine <alexandre.bounine@idt.com>
  - Added Port-WriteError Management initialization and handling
  Copyright 2009 Sysgo AG
  Thomas Moll <thomas.moll@sysgo.com>
  - Added Input- Output- enable functionality, to allow full communication
 logical minimal id 
 max number of IDs in table 
  rio_destid_alloc - Allocate next available destID for given network
  @net: RIO network
  Returns next available device destination ID for the specified RIO network.
  Marks allocated ID as one in use.
  Returns RIO_INVALID_DESTID if new destID is not available.
  rio_destid_reserve - Reserve the specified destID
  @net: RIO network
  @destid: destID to reserve
  Tries to reserve the specified destID.
  Returns 0 if successful.
  rio_destid_free - free a previously allocated destID
  @net: RIO network
  @destid: destID to free
  Makes the specified destID available for use.
  rio_destid_first - return first destID in use
  @net: RIO network
  rio_destid_next - return next destID in use
  @net: RIO network
  @from: destination ID from which search shall continue
  rio_get_device_id - Get the baseextended device id for a device
  @port: RIO master port
  @destid: Destination ID of device
  @hopcount: Hopcount to device
  Reads the baseextended device id from a device. Returns the
  816-bit device ID.
  rio_set_device_id - Set the baseextended device id for a device
  @port: RIO master port
  @destid: Destination ID of device
  @hopcount: Hopcount to device
  @did: Device ID value to be written
  Writes the baseextended device id from a device.
  rio_clear_locks- Release all host locks and signal enumeration complete
  @net: RIO network to run on
  Marks the component tag CSR on each device with the enumeration
  complete flag. When complete, it then release the host locks on
  each device. Returns 0 on success or %-EINVAL on failure.
 Release host device id locks 
 Mark device as discovered and enable master 
  rio_enum_host- Set host lock and initialize host destination ID
  @port: Master port to issue transaction
  Sets the local host master port lock and destination ID register
  with the host device ID value. The host device ID value is provided
  by the platform. Returns %0 on success or %-1 on failure.
 Set master port host device id lock 
 Set master port destid and init destid ctr 
  rio_device_has_destid- Test if a device contains a destination ID register
  @port: Master port to issue transaction
  @src_ops: RIO device source operations
  @dst_ops: RIO device destination operations
  Checks the provided @src_ops and @dst_ops for the necessary transaction
  capabilities that indicate whether or not a device will implement a
  destination ID register. Returns 1 if true or 0 if false.
  rio_release_dev- Frees a RIO device struct
  @dev: LDM device associated with a RIO device struct
  Gets the RIO device struct associated a RIO device struct.
  The RIO device struct is freed.
  rio_is_switch- Tests if a RIO device has switch capabilities
  @rdev: RIO device
  Gets the RIO device Processing Element Features register
  contents and tests for switch capabilities. Returns 1 if
  the device is a switch or 0 if it is not a switch.
  The RIO device struct is freed.
  rio_setup_device- Allocates and sets up a RIO device
  @net: RIO network
  @port: Master port to send transactions
  @destid: Current destination ID
  @hopcount: Current hopcount
  @do_enum: EnumerationDiscovery mode flag
  Allocates a RIO device and configures fields based on configuration
  space contents. If device has a destination ID register, a destination
  ID is either assigned in enumeration mode or read from configuration
  space in discovery mode.  If the device has switch capabilities, then
  a switch is allocated and configured appropriately. Returns a pointer
  to a RIO device on success or NULL on failure.
 Assign component tag to device 
		 Switch device has an associated destID which
		  will be adjusted later
 If a PE has both switch and other functions, show it as a switch 
 Initialize switch route table 
Enable Input Output Port (transmitter receiver)
  rio_sport_is_active- Tests if a switch port has an active connection.
  @rdev: RapidIO device object
  @sp: Switch port number
  Reads the port error status CSR for a particular switch port to
  determine if the port has an active link.  Returns
  %RIO_PORT_N_ERR_STS_PORT_OK if the port is active or %0 if it is
  inactive.
  rio_get_host_deviceid_lock- Reads the Host Device ID Lock CSR on a device
  @port: Master port to send transaction
  @hopcount: Number of hops to the device
  Used during enumeration to read the Host Device ID Lock CSR on a
  RIO device. Returns the value of the lock register.
  rio_enum_peer- Recursively enumerate a RIO network through a master port
  @net: RIO network being enumerated
  @port: Master port to send transactions
  @hopcount: Number of hops into the network
  @prev: Previous RIO device connected to the enumerated one
  @prev_port: Port on previous RIO device
  Recursively enumerates a RIO network.  Transactions are sent via the
  master port passed in @port.
		
		  Already discovered by this host. Add it as another
		  link to the existing device.
 Attempt to acquire device lock 
 Delay a bit 
 Attempt to acquire device lock again 
 Setup new RIO device 
 Update routing tables 
				 If switch supports Error Management,
				  set PORT_LOCKOUT bit for unused port
 Direct Port-write messages to the enumeratiing host 
 Check for empty switch 
  rio_enum_complete- Tests if enumeration of a network is complete
  @port: Master port to send transaction
  Tests the PGCCSR discovered bit for non-zero value (enumeration
  complete flag). Return %1 if enumeration is complete or %0 if
  enumeration is incomplete.
  rio_disc_peer- Recursively discovers a RIO network through a master port
  @net: RIO network being discovered
  @port: Master port to send transactions
  @destid: Current destination ID in network
  @hopcount: Number of hops into the network
  @prev: previous rio_dev
  @prev_port: previous port number
  Recursively discovers a RIO network.  Transactions are sent via the
  master port passed in @port.
 Setup new RIO device 
 Associated destid is how we accessed this switch 
  rio_mport_is_active- Tests if master port link is active
  @port: Master port to test
  Reads the port error status CSR for the master port to
  determine if the port has an active link.  Returns
  %RIO_PORT_N_ERR_STS_PORT_OK if the  master port is active
  or %0 if it is inactive.
  rio_scan_alloc_net - Allocate and configure a new RIO network
  @mport: Master port associated with the RIO network
  @do_enum: EnumerationDiscovery mode flag
  @start: logical minimal start id for new net
  Allocates a new RIO network structure and initializes enumerator-specific
  part of it (if required).
  Returns a RIO network pointer on success or %NULL on failure.
  rio_update_route_tables- Updates route tables in switches
  @net: RIO network to run update on
  For each enumerated device, ensure that each switch in a system
  has correct routing entries. Add routes for devices that where
  unknown during the first enumeration pass through the switch.
 Skip if destid ends in empty switch
  rio_init_em - Initializes RIO Error Management (for switches)
  @rdev: RIO device
  For each enumerated switch, call device-specific error management
  initialization routine (if supplied by the switch driver).
  rio_enum_mport- Start enumeration through a master port
  @mport: Master port to send transactions
  @flags: Enumeration control flags
  Starts the enumeration process. If somebody has enumerated our
  master port device, then give up. If not and we have an active
  link, then start recursive peer enumeration. Returns %0 if
  enumeration succeeds or %-EBUSY if enumeration fails.
	
	  To avoid multiple start requests (repeat enumeration is not supported
	  by this method) check if enumerationdiscovery was performed for this
	  mport: if mport was added into the list of mports for a net exit
	  with error.
 If somebody else enumerated our master port device, bail. 
 If master port has an active link, allocate net and enum peers 
 reserve mport destID in new net 
 Enable Input Output Port (transmitter receiver) 
 Set component tag for host 
 A higher priority host won enumeration, bail. 
 free the last allocated destID (unused) 
  rio_build_route_tables- Generate route tables from switch route entries
  @net: RIO network to run route tables scan on
  For each switch device, generate a route table by copying existing
  route entries from the switch.
  rio_disc_mport- Start discovery through a master port
  @mport: Master port to send transactions
  @flags: discovery control flags
  Starts the discovery process. If we have an active link,
  then wait for the signal that enumeration is complete (if wait
  is allowed).
  When enumeration completion is signaled, start recursive
  peer discovery. Returns %0 if discovery succeeds or %-EBUSY
  on failure.
 If master port has an active link, allocate net and discover peers 
 Read DestID assigned by enumerator 
  rio_basic_attach:
  When this enumerationdiscovery method is loaded as a module this function
  registers its specific enumeration and discover routines for all available
  RapidIO mport devices. The "scan" command line parameter controls ability of
  the module to start RapidIO enumerationdiscovery automatically.
  Returns 0 for success or -EIO if unable to register itself.
  This enumerationdiscovery method cannot be unloaded and therefore does not
  provide a matching cleanup_module routine.
 SPDX-License-Identifier: GPL-2.0-or-later
  RapidIO interconnect services
  (RapidIO Interconnect Specification, http:www.rapidio.org)
  Copyright 2005 MontaVista Software, Inc.
  Matt Porter <mporter@kernel.crashing.org>
  Copyright 2009 - 2013 Integrated Device Technology, Inc.
  Alex Bounine <alexandre.bounine@idt.com>
  struct rio_pwrite - RIO portwrite event
  @node:    Node in list of doorbell events
  @pwcback: Doorbell event callback
  @context: Handler specific context to pass on event
  rio_local_get_device_id - Get the baseextended device id for a port
  @port: RIO master port from which to get the deviceid
  Reads the baseextended device id from the local device
  implementing the master port. Returns the 816-bit device
  id.
  rio_query_mport - Query mport device attributes
  @port: mport device to query
  @mport_attr: mport attributes data structure
  Returns attributes of specified mport through the
  pointer to attributes data structure.
  rio_alloc_net- Allocate and initialize a new RIO network data structure
  @mport: Master port associated with the RIO network
  Allocates a RIO network structure, initializes per-network
  list heads, and adds the associated master port to the
  network list of associated master ports. Returns a
  RIO network pointer on success or %NULL on failure.
  rio_local_set_device_id - Set the baseextended device id for a port
  @port: RIO master port
  @did: Device ID value to be written
  Writes the baseextended device id from a device.
  rio_add_device- Adds a RIO device to the device model
  @rdev: RIO device
  Adds the RIO device to the global device list and adds the RIO
  device to the RIO device list.  Creates the generic sysfs nodes
  for an RIO device.
  rio_del_device - removes a RIO device from the device model
  @rdev: RIO device
  @state: device state to set during removal process
  Removes the RIO device to the kernel device list and subsystem's device list.
  Clears sysfs entries for the removed device.
  rio_request_inb_mbox - request inbound mailbox service
  @mport: RIO master port from which to allocate the mailbox resource
  @dev_id: Device specific pointer to pass on event
  @mbox: Mailbox number to claim
  @entries: Number of entries in inbound mailbox queue
  @minb: Callback to execute when inbound message is received
  Requests ownership of an inbound mailbox resource and binds
  a callback function to the resource. Returns %0 on success.
 Make sure this mailbox isn't in use 
 Hook the inbound message callback 
  rio_release_inb_mbox - release inbound mailbox message service
  @mport: RIO master port from which to release the mailbox resource
  @mbox: Mailbox number to release
  Releases ownership of an inbound mailbox resource. Returns 0
  if the request has been satisfied.
  rio_request_outb_mbox - request outbound mailbox service
  @mport: RIO master port from which to allocate the mailbox resource
  @dev_id: Device specific pointer to pass on event
  @mbox: Mailbox number to claim
  @entries: Number of entries in outbound mailbox queue
  @moutb: Callback to execute when outbound message is sent
  Requests ownership of an outbound mailbox resource and binds
  a callback function to the resource. Returns 0 on success.
 Make sure this outbound mailbox isn't in use 
 Hook the inbound message callback 
  rio_release_outb_mbox - release outbound mailbox message service
  @mport: RIO master port from which to release the mailbox resource
  @mbox: Mailbox number to release
  Releases ownership of an inbound mailbox resource. Returns 0
  if the request has been satisfied.
  rio_setup_inb_dbell - bind inbound doorbell callback
  @mport: RIO master port to bind the doorbell callback
  @dev_id: Device specific pointer to pass on event
  @res: Doorbell message resource
  @dinb: Callback to execute when doorbell is received
  Adds a doorbell resourcecallback pair into a port's
  doorbell event list. Returns 0 if the request has been
  satisfied.
  rio_request_inb_dbell - request inbound doorbell message service
  @mport: RIO master port from which to allocate the doorbell resource
  @dev_id: Device specific pointer to pass on event
  @start: Doorbell info range start
  @end: Doorbell info range end
  @dinb: Callback to execute when doorbell is received
  Requests ownership of an inbound doorbell resource and binds
  a callback function to the resource. Returns 0 if the request
  has been satisfied.
 Make sure these doorbells aren't in use 
 Hook the doorbell callback 
  rio_release_inb_dbell - release inbound doorbell message service
  @mport: RIO master port from which to release the doorbell resource
  @start: Doorbell info range start
  @end: Doorbell info range end
  Releases ownership of an inbound doorbell resource and removes
  callback from the doorbell event list. Returns 0 if the request
  has been satisfied.
 If we can't find an exact match, fail 
 Release the doorbell resource 
 Free the doorbell event 
  rio_request_outb_dbell - request outbound doorbell message range
  @rdev: RIO device from which to allocate the doorbell resource
  @start: Doorbell message range start
  @end: Doorbell message range end
  Requests ownership of a doorbell message range. Returns a resource
  if the request has been satisfied or %NULL on failure.
 Make sure these doorbells aren't in use 
  rio_release_outb_dbell - release outbound doorbell message range
  @rdev: RIO device from which to release the doorbell resource
  @res: Doorbell resource to be freed
  Releases ownership of a doorbell message range. Returns 0 if the
  request has been satisfied.
  rio_add_mport_pw_handler - add port-write message handler into the list
                             of mport specific pw handlers
  @mport:   RIO master port to bind the portwrite callback
  @context: Handler specific context to pass on event
  @pwcback: Callback to execute when portwrite is received
  Returns 0 if the request has been satisfied.
  rio_del_mport_pw_handler - remove port-write message handler from the list
                             of mport specific pw handlers
  @mport:   RIO master port to bind the portwrite callback
  @context: Registered handler specific context to pass on event
  @pwcback: Registered callback function
  Returns 0 if the request has been satisfied.
  rio_request_inb_pwrite - request inbound port-write message service for
                           specific RapidIO device
  @rdev: RIO device to which register inbound port-write callback routine
  @pwcback: Callback routine to execute when port-write is received
  Binds a port-write callback function to the RapidIO device.
  Returns 0 if the request has been satisfied.
  rio_release_inb_pwrite - release inbound port-write message service
                           associated with specific RapidIO device
  @rdev: RIO device which registered for inbound port-write callback
  Removes callback from the rio_dev structure. Returns 0 if the request
  has been satisfied.
  rio_pw_enable - Enablesdisables port-write handling by a master port
  @mport: Master port associated with port-write handling
  @enable:  1=enable,  0=disable
  rio_map_inb_region -- Map inbound memory region.
  @mport: Master port.
  @local: physical address of memory region to be mapped
  @rbase: RIO base address assigned to this window
  @size: Size of the memory region
  @rflags: Flags for mapping.
  Return: 0 -- Success.
  This function will create the mapping from RIO space to local memory.
  rio_unmap_inb_region -- Unmap the inbound memory region
  @mport: Master port
  @lstart: physical address of memory region to be unmapped
  rio_map_outb_region -- Map outbound memory region.
  @mport: Master port.
  @destid: destination id window points to
  @rbase: RIO base address window translates to
  @size: Size of the memory region
  @rflags: Flags for mapping.
  @local: physical address of memory region mapped
  Return: 0 -- Success.
  This function will create the mapping from RIO space to local memory.
  rio_unmap_outb_region -- Unmap the inbound memory region
  @mport: Master port
  @destid: destination id mapping points to
  @rstart: RIO base address window translates to
  rio_mport_get_physefb - Helper function that returns register offset
                       for Physical Layer Extended Features Block.
  @port: Master port to issue transaction
  @local: Indicate a local master port or remote device access
  @destid: Destination ID of the device
  @hopcount: Number of switch hops to the device
  @rmap: pointer to location to store register map type info
  rio_get_comptag - Begin or continue searching for a RIO device by component tag
  @comp_tag: RIO component tag to match
  @from: Previous RIO device found in search, or %NULL for new search
  Iterates through the list of known RIO devices. If a RIO device is
  found with a matching @comp_tag, a pointer to its device
  structure is returned. Otherwise, %NULL is returned. A new search
  is initiated by passing %NULL to the @from argument. Otherwise, if
  @from is not %NULL, searches continue from next device on the global
  list.
  rio_set_port_lockout - Setsclears LOCKOUT bit (RIO EM 1.3) for a switch port.
  @rdev: Pointer to RIO device control structure
  @pnum: Switch port number to set LOCKOUT bit
  @lock: Operation : set (=1) or clear (=0)
  rio_enable_rx_tx_port - enable input receiver and output transmitter of
  given port
  @port: Master port associated with the RIO network
  @local: local=1 select local port otherwise a far device is reached
  @destid: Destination ID of the device to check host bit
  @hopcount: Number of hops to reach the target
  @port_num: Port (-number on switch) to enable on a far end device
  Returns 0 or 1 from on General Control Command and Status Register
  (EXT_PTR+0x3C)
	
	 enable rx input tx output port
  rio_chk_dev_route - Validate route to the specified device.
  @rdev:  RIO device failed to respond
  @nrdev: Last active device on the route to rdev
  @npnum: nrdev's port number on the route to rdev
  Follows a route to the specified RIO device to determine the last available
  device (and corresponding RIO port) on the route.
 Find switch with failed RIO link 
  rio_mport_chk_dev_access - Validate access to the specified device.
  @mport: Master port to send transactions
  @destid: Device destination ID in network
  @hopcount: Number of hops into the network
  rio_chk_dev_access - Validate access to the specified device.
  @rdev: Pointer to RIO device control structure
  rio_get_input_status - Sends a Link-RequestInput-Status control symbol and
                         returns link-response (if requested).
  @rdev: RIO devive to issue Input-status command
  @pnum: Device port number to issue the command
  @lnkresp: Response from a link partner
		 Read from link maintenance response register
 Issue Input-status command 
 Exit if the response is not expected 
  rio_clr_err_stopped - Clears port Error-stopped states.
  @rdev: Pointer to RIO device control structure
  @pnum: Switch port number to clear errors
  @err_status: port error status (if 0 reads register from device)
  TODO: Currently this routine is not compatible with recovery process
  specified for idt_gen3 RapidIO switch devices. It has to be reviewed
  to implement universal recovery process that is compatible full range
  off available devices.
  IDT gen3 switch driver now implements HW-specific error handler that
  issues soft port reset to the port to reset ERR_STOP bits and ackIDs.
		
		  Send a Link-RequestInput-Status control symbol
		
		  If required, synchronize ackIDs of near and
		  far sides.
			 Align near outstandingoutbound ackIDs with
			  far inbound.
			 Align far outstandingoutbound ackIDs with
			  near inbound.
  rio_inb_pwrite_handler - inbound port-write message handler
  @mport:  mport device associated with port-write
  @pw_msg: pointer to inbound port-write message
  Processes an inbound port-write message. Returns 0 if the request
  has been satisfied.
	 Call a device-specific handler (if it is registered for the device).
	  This may be the service for endpoints that send device-specific
	  port-write messages. End-point messages expected to be handled
	  completely by EP specific device driver.
	  For switches rc==0 signals that no standard processing required.
	
	  FIXME: The code below stays as it was before for now until we decide
	  how to do default PW handling in combination with per-mport callbacks
	 Check if device and route to it are functional:
	  Sometimes devices may send PW message(s) just before being
	  powered down (or link being lost).
		 Scan route to the device and identify failed link.
		  This will replace device and port reported in PW message.
		  PW message should not be used after this point.
 For End-point devices processing stops here 
	
	  Process the port-write notification from switch
 Schedule Insertion Service 
		 Clear error-stopped states (if reported).
		  Depending on the link partner state, two attempts
		  may be needed for successful recovery.
 if (err_status & RIO_PORT_N_ERR_STS_PORT_UNINIT) 
 Schedule Extraction Service 
 Clear EM Port N Error Detect CSR 
 Clear EM LT Layer Error Detect CSR 
 Clear remaining error bits and Port-Write Pending bit 
  rio_mport_get_efb - get pointer to next extended features block
  @port: Master port to issue transaction
  @local: Indicate a local master port or remote device access
  @destid: Destination ID of the device
  @hopcount: Number of switch hops to the device
  @from: Offset of  current Extended Feature block header (if 0 starts
  from	ExtFeaturePtr)
  rio_mport_get_feature - query for devices' extended features
  @port: Master port to issue transaction
  @local: Indicate a local master port or remote device access
  @destid: Destination ID of the device
  @hopcount: Number of switch hops to the device
  @ftr: Extended feature code
  Tell if a device supports a given RapidIO capability.
  Returns the offset of the requested extended feature
  block within the device's RIO configuration space or
  0 in case the device does not support it.
  rio_std_route_add_entry - Add switch route table entry using standard
    registers defined in RIO specification rev.1.3
  @mport: Master port to issue transaction
  @destid: Destination ID of the device
  @hopcount: Number of switch hops to the device
  @table: routing table ID (global or port-specific)
  @route_destid: destID entry in the RT
  @route_port: destination port for specified destID
  rio_std_route_get_entry - Read switch route table entry (port number)
    associated with specified destID using standard registers defined in RIO
    specification rev.1.3
  @mport: Master port to issue transaction
  @destid: Destination ID of the device
  @hopcount: Number of switch hops to the device
  @table: routing table ID (global or port-specific)
  @route_destid: destID entry in the RT
  @route_port: returned destination port for specified destID
  rio_std_route_clr_table - Clear swotch route table using standard registers
    defined in RIO specification rev.1.3.
  @mport: Master port to issue transaction
  @destid: Destination ID of the device
  @hopcount: Number of switch hops to the device
  @table: routing table ID (global or port-specific)
  rio_lock_device - Acquires host device lock for specified device
  @port: Master port to send transaction
  @destid: Destination ID for deviceswitch
  @hopcount: Hopcount to reach switch
  @wait_ms: Max wait time in msec (0 = no timeout)
  Attepts to acquire host device lock for specified device
  Returns 0 if device lock acquired or EINVAL if timeout expires.
 Attempt to acquire device lock 
 Delay a bit 
 Try to acquire device lock again 
  rio_unlock_device - Releases host device lock for specified device
  @port: Master port to send transaction
  @destid: Destination ID for deviceswitch
  @hopcount: Hopcount to reach switch
  Returns 0 if device lock released or EINVAL if fails.
 Release device lock 
  rio_route_add_entry- Add a route entry to a switch routing table
  @rdev: RIO device
  @table: Routing table ID
  @route_destid: Destination ID to be routed
  @route_port: Port number to be routed
  @lock: apply a hardware lock on switch device flag (1=lock, 0=no_lock)
  If available calls the switch specific add_entry() method to add a route
  entry into a switch routing table. Otherwise uses standard RT update method
  as defined by RapidIO specification. A specific routing table can be selected
  using the @table argument if a switch has per port routing tables or
  the standard (or global) table may be used by passing
  %RIO_GLOBAL_TABLE in @table.
  Returns %0 on success or %-EINVAL on failure.
  rio_route_get_entry- Read an entry from a switch routing table
  @rdev: RIO device
  @table: Routing table ID
  @route_destid: Destination ID to be routed
  @route_port: Pointer to read port number into
  @lock: apply a hardware lock on switch device flag (1=lock, 0=no_lock)
  If available calls the switch specific get_entry() method to fetch a route
  entry from a switch routing table. Otherwise uses standard RT read method
  as defined by RapidIO specification. A specific routing table can be selected
  using the @table argument if a switch has per port routing tables or
  the standard (or global) table may be used by passing
  %RIO_GLOBAL_TABLE in @table.
  Returns %0 on success or %-EINVAL on failure.
  rio_route_clr_table - Clear a switch routing table
  @rdev: RIO device
  @table: Routing table ID
  @lock: apply a hardware lock on switch device flag (1=lock, 0=no_lock)
  If available calls the switch specific clr_table() method to clear a switch
  routing table. Otherwise uses standard RT write method as defined by RapidIO
  specification. A specific routing table can be selected using the @table
  argument if a switch has per port routing tables or the standard (or global)
  table may be used by passing %RIO_GLOBAL_TABLE in @table.
  Returns %0 on success or %-EINVAL on failure.
 Check that DMA device belongs to the right MPORT 
  rio_request_mport_dma - request RapidIO capable DMA channel associated
    with specified local RapidIO mport device.
  @mport: RIO mport to perform DMA data transfers
  Returns pointer to allocated DMA channel or NULL if failed.
  rio_request_dma - request RapidIO capable DMA channel that supports
    specified target RapidIO device.
  @rdev: RIO device associated with DMA transfer
  Returns pointer to allocated DMA channel or NULL if failed.
  rio_release_dma - release specified DMA channel
  @dchan: DMA channel to release
  rio_dma_prep_xfer - RapidIO specific wrapper
    for device_prep_slave_sg callback defined by DMAENGINE.
  @dchan: DMA channel to configure
  @destid: target RapidIO device destination ID
  @data: RIO specific data descriptor
  @direction: DMA data transfer direction (TO or FROM the device)
  @flags: dmaengine defined flags
  Initializes RapidIO capable DMA channel for the specified data transfer.
  Uses DMA channel private extension to pass information related to remote
  target RIO device.
  Returns: pointer to DMA transaction descriptor if successful,
           error-valued pointer or NULL if failed.
  rio_dma_prep_slave_sg - RapidIO specific wrapper
    for device_prep_slave_sg callback defined by DMAENGINE.
  @rdev: RIO device control structure
  @dchan: DMA channel to configure
  @data: RIO specific data descriptor
  @direction: DMA data transfer direction (TO or FROM the device)
  @flags: dmaengine defined flags
  Initializes RapidIO capable DMA channel for the specified data transfer.
  Uses DMA channel private extension to pass information related to remote
  target RIO device.
  Returns: pointer to DMA transaction descriptor if successful,
           error-valued pointer or NULL if failed.
 CONFIG_RAPIDIO_DMA_ENGINE 
  rio_find_mport - find RIO mport by its ID
  @mport_id: number (ID) of mport device
  Given a RIO mport number, the desired mport is located
  in the global list of mports. If the mport is found, a pointer to its
  data structure is returned.  If no mport is found, %NULL is returned.
  rio_register_scan - enumerationdiscovery method registration interface
  @mport_id: mport device ID for which fabric scan routine has to be set
             (RIO_MPORT_ANY = set for all available mports)
  @scan_ops: enumerationdiscovery operations structure
  Registers enumerationdiscovery operations with RapidIO subsystem and
  attaches it to the specified mport device (or all available mports
  if RIO_MPORT_ANY is specified).
  Returns error if the mport already has an enumerator attached to it.
  In case of RIO_MPORT_ANY skips mports with valid scan routines (no error).
	
	  Check if there is another enumerator already registered for
	  the same mport ID (including RIO_MPORT_ANY). Multiple enumerators
	  for the same mport ID are not supported.
	
	  Allocate and initialize new scan registration node.
	
	  Traverse the list of registered mports to attach this new scan.
	 
	  The new scan with matching mport ID overrides any previously attached
	  scan assuming that old scan (if any) is the default one (based on the
	  enumerator registration check above).
	  If the new scan is the global one, it will be attached only to mports
	  that do not have their own individual operations already attached.
  rio_unregister_scan - removes enumerationdiscovery method from mport
  @mport_id: mport device ID for which fabric scan routine has to be
             unregistered (RIO_MPORT_ANY = apply to all mports that use
             the specified scan_ops)
  @scan_ops: enumerationdiscovery operations structure
  Removes enumeration or discovery method assigned to the specified mport
  device. If RIO_MPORT_ANY is specified, removes the specified operations from
  all mports that have them attached.
  rio_mport_scan - execute enumerationdiscovery on the specified mport
  @mport_id: number (ID) of mport device
	
	  First, run enumerations and check if we need to perform discovery
	  on any of the registered mports.
	
	  If we have mports that require discovery schedule a discovery work
	  for each of them. If the code below fails to allocate needed
	  resources, exit without error to keep results of enumeration
	  process (if any).
	  TODO: Implement restart of discovery process for all or
	  individual discovering mports.
	
	  Check if there are any registered enumerationdiscovery operations
	  that have to be attached to the added mport.
	
	  Unregister all RapidIO devices residing on this net (this will
	  invoke notification of registered subsystem interfaces as well).
 Transition mport to the SHUTDOWN state 
	
	  Unregister all RapidIO devices attached to this mport (this will
	  invoke notification of registered subsystem interfaces as well).
 SPDX-License-Identifier: GPL-2.0-or-later
  RapidIO configuration space access support
  Copyright 2005 MontaVista Software, Inc.
  Matt Porter <mporter@kernel.crashing.org>
   Wrappers for all RIO configuration access functions.  They just check
   alignment and call the low-level functions pointed to by rio_mport->ops.
  RIO_LOP_READ - Generate rio_local_read_config_ functions
  @size: Size of configuration space read (8, 16, 32 bits)
  @type: C type of value argument
  @len: Length of configuration space read (1, 2, 4 bytes)
  Generates rio_local_read_config_ functions used to access
  configuration space registers on the local device.
  RIO_LOP_WRITE - Generate rio_local_write_config_ functions
  @size: Size of configuration space write (8, 16, 32 bits)
  @type: C type of value argument
  @len: Length of configuration space write (1, 2, 4 bytes)
  Generates rio_local_write_config_ functions used to access
  configuration space registers on the local device.
  RIO_OP_READ - Generate rio_mport_read_config_ functions
  @size: Size of configuration space read (8, 16, 32 bits)
  @type: C type of value argument
  @len: Length of configuration space read (1, 2, 4 bytes)
  Generates rio_mport_read_config_ functions used to access
  configuration space registers on the local device.
  RIO_OP_WRITE - Generate rio_mport_write_config_ functions
  @size: Size of configuration space write (8, 16, 32 bits)
  @type: C type of value argument
  @len: Length of configuration space write (1, 2, 4 bytes)
  Generates rio_mport_write_config_ functions used to access
  configuration space registers on the local device.
  rio_mport_send_doorbell - Send a doorbell message
  @mport: RIO master port
  @destid: RIO device destination ID
  @data: Doorbell message data
  Send a doorbell message to a RIO device. The doorbell message
  has a 16-bit info field provided by the data argument.
 SPDX-License-Identifier: GPL-2.0-or-later
  RapidIO Tsi57x switch family support
  Copyright 2009-2010 Integrated Device Technology, Inc.
  Alexandre Bounine <alexandre.bounine@idt.com>
   - Added EM support
   - Modified switch operations initialization.
  Copyright 2005 MontaVista Software, Inc.
  Matt Porter <mporter@kernel.crashing.org>
 Global (broadcast) route registers 
 Per port route registers 
		 Use local RT of the ingress port to avoid possible
	
	  Switch domain configuration operates only at global level
 Turn off flat (LUT_512) mode 
 Set switch domain base 
	
	  Switch domain configuration operates only at global level
 Make sure that Port-Writes are enabled (for all ports) 
 Clear all pending interrupts 
 Enable all interrupts to allow ports to send a port-write 
 Skip next (odd) port if the current port is in x4 mode 
 set TVAL = ~50us 
 Remove any queued packets by lockingunlocking port 
		 Read from link maintenance response register to clear
		  valid bit
		 Send a Packet-Not-AcceptedLink-Request-Input-Status control
		  symbol to recover from IESOES
 Clear implementation specific error status bits 
 Ensure that default routing is disabled on startup 
 terminate list 
 SPDX-License-Identifier: GPL-2.0-or-later
  RapidIO Tsi568 switch support
  Copyright 2009-2010 Integrated Device Technology, Inc.
  Alexandre Bounine <alexandre.bounine@idt.com>
   - Added EM support
   - Modified switch operations initialization.
  Copyright 2005 MontaVista Software, Inc.
  Matt Porter <mporter@kernel.crashing.org>
 Global (broadcast) route registers 
 Per port route registers 
 Make sure that Port-Writes are disabled (for all ports) 
 terminate list 
 SPDX-License-Identifier: GPL-2.0-or-later
  IDT RXS Gen.3 Serial RapidIO switch family support
  Copyright 2016 Integrated Device Technology, Inc.
 Use broadcast register to update all per-port tables 
	
	  Verify that specified porttable number is valid
	
	  This switch device does not have the dedicated global routing table.
	  It is substituted by reading routing table of the ingress port of
	  maintenance read requests.
  This routine performs device-specific initialization only.
  All standard EM configuration should be performed at upper level.
 Disable assertion of interrupt signal 
 Disable port-write event notifications during initialization 
 Configure Port-Write notifications for hot-swap events 
 Clear events signaled before enabling notification 
 Enable event notifications 
 Enable port-write generation on events 
 Set Port-Write destination port 
 Enable sending port-write event notifications 
 set TVAL = ~50us 
  idtg3_em_handler - device-specific error handler
  If the link is down (PORT_UNINIT) does nothing - this is considered
  as link partner removal from the port.
  If the link is up (PORT_OK) - situation is handled as new device insertion.
  In this case ERR_STOP bits are cleared by issuing soft reset command to the
  reporting port. Inbound and outbound ackIDs are cleared by the reset as well.
  This way the port is synchronized with freshly inserted device (assuming it
  was resetpowered-up on insertion).
  TODO: This is not sufficient in a situation when a link between two devices
  was down and up again (e.g. cable disconnect). For that situation full ackID
  realignment process has to be implemented.
 Do nothing for devicelink removal 
	 When link is OK we have a device insertion.
	  Request port soft reset to clear errors if they present.
	  Inbound and outbound ackIDs will be 0 after reset.
		 Disable hierarchical routing support: Existing fabric
		  enumerationdiscovery process (see rio-scan.c) uses 8-bit
		  flat destination ID routing only.
  Gen3 switches repeat sending PW messages until a corresponding event flag
  is cleared. Use shutdown notification to disable generation of port-write
  messages if their destination node is shut down.
 Currently the enumerator node acts also as PW handler 
 Check port-write destination port 
	 Disable sending port-write event notifications if PW destID
	  matches to one of the enumerator node
 terminate list 
 SPDX-License-Identifier: GPL-2.0-or-later
  IDT CPS Gen.2 Serial RapidIO switch family support
  Copyright 2010 Integrated Device Technology, Inc.
  Alexandre Bounine <alexandre.bounine@idt.com>
	
	  Select routing table to update
	
	  Program destination port for the specified destID
	
	  Select routing table to read
	
	  Select routing table to read
	
	  Switch domain configuration operates only at global level
	
	  Switch domain configuration operates only at global level
	
	  This routine performs device-specific initialization only.
	  All standard EM configuration should be performed at upper level.
 Set Port-Write info CSR: PRIO=3 and CRF=1 
	
	  Configure LT LAYER error reporting.
 Enable standard (RIO.p8) error reporting 
	 Use Port-Writes for LT layer error reporting.
	  Enable per-port reset
	
	  Configure PORT error reporting.
 Report all RIO.p8 errors supported by device 
 Configure reporting of implementation specific errorsevents 
 Use Port-Writes for port error reporting and enable error logging 
 Overwrite error log if full 
	
	  Configure LANE error reporting.
 Disable line error reporting 
	 Use Port-Writes for lane error reporting (when enabled)
	  (do per-lane update because lanes may have different configuration)
	
	  Configure AUX error reporting.
 Disable JTAG and I2C Error capture 
 Disable JTAG and I2C Error reportinglogging 
 Disable Port-Write notification from JTAG 
 Disable Port-Write notification from I2C 
	
	  Configure CFG_BLK error reporting.
 Disable Configuration Block error capture 
 Disable Port-Writes for Configuration Block error reporting 
 set TVAL = ~50us 
 Service LogicalTransport Layer Error(s) 
 Implementation specific error reported 
 Clear implementation specific address capture CSR 
 Service Port-Level Error(s) 
 Implementation Specific port error reported 
 Get IS errors reported 
 Clear all implementation specific events 
 0 = end of log 
 Initialize sysfs entries 
 Ensure that default routing is disabled on startup 
 Create device-specific sysfs attributes 
 Remove device-specific sysfs attributes 
 terminate list 
 SPDX-License-Identifier: GPL-2.0-or-later
  IDT CPS RapidIO switches support
  Copyright 2009-2010 Integrated Device Technology, Inc.
  Alexandre Bounine <alexandre.bounine@idt.com>
	
	  Switch domain configuration operates only at global level
	
	  Switch domain configuration operates only at global level
 set TVAL = ~50us 
 Ensure that default routing is disabled on startup 
 terminate list 
 SPDX-License-Identifier: GPL-2.0-or-later
  RapidIO mport character device
  Copyright 2014-2015 Integrated Device Technology, Inc.
     Alexandre Bounine <alexandre.bounine@idt.com>
  Copyright 2014-2015 Prodrive Technologies
     Andre van Herk <andre.van.herk@prodrive-technologies.com>
     Jerry Jacobs <jerry.jacobs@prodrive-technologies.com>
  Copyright (C) 2014 Texas Instruments Incorporated
     Aurelien Jacquiot <a-jacquiot@ti.com>
 Debug output filtering masks 
 driver init 
 driver exit 
 mport addremove 
 RapidIO device addremove 
 DMA transfer messages 
 mapping messages 
 inbound window 
 event handling messages 
 outbound window messages 
 doorbell messages 
 DMA transfer timeout in msec 
  An internal DMA coherent buffer
  Internal memory mapping structure
 for mmap 
 kernel address, for dma_free_coherent 
 refcount of vmas sharing the mapping 
  mport_dev  driver-specific structure that represents mport device
  @active    mport device status flag
  @node      list node to maintain list of registered mports
  @cdev      character device
  @dev       associated device object
  @mport     associated subsystem's master port device object
  @buf_mutex lock for buffer handling
  @file_mutex - lock for open files list
  @file_list  - list of open files on given mport
  @properties properties of this mport
  @portwrites queue of inbound portwrites
  @pw_lock    lock for port write queue
  @mappings   queue for memory mappings
  @dma_chan   DMA channels associated with this device
  @dma_ref:
  @comp:
  mport_cdev_priv - data structure specific to individual file object
                    associated with an open device
  @md    master port character device object
  @async_queue - asynchronous notification queue
  @list - file objects tracking list
  @db_filters    inbound doorbell filters for this descriptor
  @pw_filters    portwrite filters for this descriptor
  @event_fifo    event fifo for this descriptor
  @event_rx_wait wait queue for this descriptor
  @fifo_lock     lock for event_fifo
  @event_mask    event mask for this descriptor
  @dmach DMA engine channel allocated for specific file object
 RIO_DOORBELL, RIO_PORTWRITE 
  rio_mport_pw_filter - structure to describe a portwrite filter
  md_node   node in mport device's list
  priv_node node in private file object's list
  priv      reference to private data
  filter    actual portwrite filter
  rio_mport_db_filter - structure to describe a doorbell filter
  @data_node reference to device node
  @priv_node node in private data
  @priv      reference to private data
  @filter    actual doorbell filter
 used by commented out portion of poll function : FIXME 
  Inboundoutbound memory mapping functions
 If not found, create new 
  rio_mport_obw_free() - unmap an OutBound Window from RapidIO address space
  @priv: driver private data
  @arg:  buffer handle returned by allocation routine
  maint_hdid_set() - Set the host Device ID
  @priv: driver private data
  @arg:	Device Id
  maint_comptag_set() - Set the host Component Tag
  @priv: driver private data
  @arg:	Component Tag
  prep_dma_xfer() - Configure and send request to DMAengine to prepare DMA
                    transfer object.
  Returns pointer to DMA transaction descriptor allocated by DMA driver on
  success or ERR_PTR (andor NULL) if failed. Caller must check returned
  non-NULL pointer using IS_ERR macro.
 Request DMA channel associated with this mport device.
  Try to request DMA channel for every new process that opened given
  mport. If a new DMA channel is not available use default channel
  which is the first DMA channel opened on mport device.
 Use default DMA channel if available 
 Register default DMA channel if we do not have one 
  DMA transfer functions
 Initialize DMA transaction request 
 Timeout on wait occurred 
		 Wait_for_completion was interrupted by a signal but DMA may
		  be in progress
 DMA transaction completion was signaled with error 
  rio_dma_transfer() - Perform RapidIO DMA data transfer tofrom
                       the remote RapidIO device
  @filp: file pointer associated with the call
  @transfer_mode: DMA transfer mode
  @sync: synchronization mode
  @dir: DMA transfer direction (DMA_MEM_TO_DEV = write OR
                                DMA_DEV_TO_MEM = read)
  @xfer: data transfer descriptor structure
	
	  If parameter loc_addr != NULL, we are transferring data fromto
	  data buffer allocated in user-space: lock in memory user-space
	  buffer pages and build an SG table for DMA transfer request
	 
	  Otherwise (loc_addr == NULL) contiguous kernel-space buffer is
	  used for DMA data transfers: build single entry SG table using
	  offset within the internal buffer specified by handle parameter.
				
				  Set nr_pages up to mean "how many pages to unpin, in
				  the error handler:
 return ASYNC cookie 
 only single transfer for now 
 Use default DMA timeout 
 Timeout on wait occurred 
		 Wait_for_completion was interrupted by a signal but DMA may
		  be still in progress
 DMA transaction completion signaled with transfer error 
 Return request back into async queue 
 CONFIG_RAPIDIO_DMA_ENGINE 
  Inboundoutbound memory mapping functions
 rio_map_inb_region() accepts u32 size 
 allow exact match only 
 not found, create new 
 Delete mapping if it was created by this request 
  rio_mport_inbound_free() - unmap from RapidIO address space and free
                     previously allocated inbound DMA coherent buffer
  @priv: driver private data
  @arg:  buffer handle returned by allocation routine
  maint_port_idx_get() - Get the port index of the mport instance
  @priv: driver private data
  @arg:  port index
  rio_release_dev - release routine for kernel RIO device object
  @dev: kernel device object associated with a RIO device structure
  Frees a RIO device struct associated a RIO device struct.
  The RIO device struct is freed.
  rio_mport_add_riodev - creates a kernel RIO device object
  Allocates a RIO device data structure and initializes required fields based
  on device's configuration space contents.
  If the device has switch capabilities, then a switch specific portion is
  allocated and configured.
 hopcount is stored as specified by a caller, regardles of EP or SW 
 If device name is specified, removal by name has priority 
  Mport cdev management
  mport_cdev_open() - Open character device (mport)
 Test for valid device 
  mport_cdev_release() - Release character device
  mport_cdev_ioctl() - IOCTLs for character device
  mport_release_mapping - free mapping resources and info structure
  @ref: a pointer to the kref within struct rio_mport_mapping
  NOTE: Shall be called while holding buf_mutex.
  Character device management
  mport_cdev_add() - Create mport_dev from rio_mport
  @mport:	RapidIO master port
	 The transfer_mode property will be returned through mport query
	  interface
 for now: only on Freescale's SoCs 
  mport_cdev_terminate_dma() - Stop all active DMA data transfers and release
                               associated DMA channels.
  mport_cdev_kill_fasync() - Send SIGIO signal to all processes with open
                             mport_cdev files.
  mport_cdev_remove() - Remove mport character device
  @dev:	Mport device to remove
	 TODO: do we need to give clients some time to close file
	  descriptors? Simple wait for XX, or kref?
	
	  Release DMA buffers allocated for the mport device.
	  Disable associated inbound Rapidio requests mapping if applicable.
  RIO rio_mport_interface driver
  mport_add_mport() - Add rio_mport from LDM device struct
  @dev:		Linux device model struct
  @class_intf:	Linux class_interface
  mport_remove_mport() - Remove rio_mport from global list
  TODO remove device from global mport_dev list
 the rio_mport_interface is used to handle local mport devices 
  Linux kernel module
  mport_init - Driver module loading
 Create device class needed by udev 
 Register to rio_mport_interface 
  mport_exit - Driver module unloading
 SPDX-License-Identifier: GPL-2.0-or-later
  DMA Engine support for Tsi721 PCIExpress-to-SRIO bridge
  Copyright (c) 2011-2014 Integrated Device Technology, Inc.
  Alexandre Bounine <alexandre.bounine@idt.com>
	
	  Allocate space for DMA descriptors
	  (add an extra element for link descriptor)
 Allocate space for descriptor status FIFO 
 Free space allocated for DMA descriptors 
 Initialize DMA descriptors ring using added link descriptor 
 Setup DMA descriptor pointers 
 Setup descriptor status FIFO 
 Clear interrupt bits 
 Request interrupt service if we are in MSI-X mode 
 Free space allocated for DMA descriptors 
 Free space allocated for status descriptors 
 CONFIG_PCI_MSI 
 Toggle DMA channel initialization 
 Check if DMA channel still running 
 Put DMA channel into init state 
 CONFIG_PCI_MSI 
 Free space allocated for DMA descriptors 
 Free space allocated for status FIFO 
 Clear pending BDMA channel interrupts 
 Enable BDMA channel interrupts 
 Disable BDMA channel interrupts 
 Clear pending BDMA channel interrupts 
 Disable BDMA channel interrupts 
  tsi721_omsg_msix - MSI-X interrupt handler for BDMA channels
  @irq: Linux interrupt number
  @ptr: Pointer to interrupt-specific data (BDMA channel structure)
  Handles BDMA channel interrupts signaled using MSI-X.
 CONFIG_PCI_MSI 
 Must be called with the spinlock held 
 Initialize DMA descriptor 
 Update DMA descriptor 
 Check and clear descriptor status FIFO entries 
 Must be called with the channel spinlock held 
	
	  Fill DMA channel's hardware buffer descriptors.
	  (NOTE: RapidIO destination address is limited to 64 bits for now)
 wrap around link descriptor 
		
		  If this sg entry forms contiguous block with previous one,
		  try to merge it into existing DMA descriptor
 Adjust byte count of the descriptor 
 Finalize descriptor using total byte count value 
 wrap around link descriptor 
	
	  If there is no data transfer in progress, fetch new descriptor from
	  the pending queue.
 Clear channel interrupts 
 Re-initialize DMA channel if possible 
 Put DMA channel into init state 
 Setup DMA descriptor pointers 
 Setup descriptor status FIFO 
 Clear interrupt bits 
 Re-Enable BDMA channel interrupts 
 Check if the descriptor is detached from any lists 
 Initialize BDMA channel 
 Allocate queue of transaction descriptors 
 make sure to stop the transfer 
 Wait until DMA channel stops 
 stop the transfer in progress 
 Wait until DMA channel stops 
 SPDX-License-Identifier: GPL-2.0-or-later
  RapidIO mport driver for Tsi721 PCIExpress-to-SRIO bridge
  Copyright 2011 Integrated Device Technology, Inc.
  Alexandre Bounine <alexandre.bounine@idt.com>
  Chul Kim <chul.kim@idt.com>
  tsi721_lcread - read from local SREP config space
  @mport: RapidIO master port info
  @index: ID of RapdiIO interface
  @offset: Offset into configuration space
  @len: Length (in bytes) of the maintenance transaction
  @data: Value to be read into
  Generates a local SREP space read. Returns %0 on
  success or %-EINVAL on failure.
 only 32-bit access is supported 
  tsi721_lcwrite - write into local SREP config space
  @mport: RapidIO master port info
  @index: ID of RapdiIO interface
  @offset: Offset into configuration space
  @len: Length (in bytes) of the maintenance transaction
  @data: Value to be written
  Generates a local write into SREP configuration space. Returns %0 on
  success or %-EINVAL on failure.
 only 32-bit access is supported 
  tsi721_maint_dma - Helper function to generate RapidIO maintenance
                     transactions using designated Tsi721 DMA channel.
  @priv: pointer to tsi721 private data
  @sys_size: RapdiIO transport system size
  @destid: Destination ID of transaction
  @hopcount: Number of hops to target device
  @offset: Offset into configuration space
  @len: Length (in bytes) of the maintenance transaction
  @data: Location to be read from or write into
  @do_wr: Operation flag (1 == MAINT_WR)
  Generates a RapidIO maintenance transaction (Read or Write).
  Returns %0 on success and %-EINVAL or %-EFAULT on failure.
 Initialize DMA descriptor 
 Start DMA operation 
 Wait until DMA transfer is finished 
		 If DMA operation aborted due to error,
		  reinitialize DMA channel
	
	  Update descriptor status FIFO RD pointer.
	  NOTE: Skipping check and clear FIFO entries because we are waiting
	  for transfer to be completed.
  tsi721_cread_dma - Generate a RapidIO maintenance read transaction
                     using Tsi721 BDMA engine.
  @mport: RapidIO master port control structure
  @index: ID of RapdiIO interface
  @destid: Destination ID of transaction
  @hopcount: Number of hops to target device
  @offset: Offset into configuration space
  @len: Length (in bytes) of the maintenance transaction
  @val: Location to be read into
  Generates a RapidIO maintenance read transaction.
  Returns %0 on success and %-EINVAL or %-EFAULT on failure.
  tsi721_cwrite_dma - Generate a RapidIO maintenance write transaction
                      using Tsi721 BDMA engine
  @mport: RapidIO master port control structure
  @index: ID of RapdiIO interface
  @destid: Destination ID of transaction
  @hopcount: Number of hops to target device
  @offset: Offset into configuration space
  @len: Length (in bytes) of the maintenance transaction
  @val: Value to be written
  Generates a RapidIO maintenance write transaction.
  Returns %0 on success and %-EINVAL or %-EFAULT on failure.
  tsi721_pw_handler - Tsi721 inbound port-write interrupt handler
  @priv:  tsi721 device private structure
  Handles inbound port-write interrupts. Copies PW message from an internal
  buffer into PW message FIFO and schedules deferred routine to process
  queued messages.
		 Queue PW message (if there is room in FIFO),
		  otherwise discard it.
 Clear pending PW interrupts 
	
	  Process port-write messages
 Pass the port-write message to RIO core for processing 
  tsi721_pw_enable - enabledisable port-write interface init
  @mport: Master port implementing the port write unit
  @enable:    1=enable; 0=disable port-write message handling
 Clear pending PW interrupts 
 Update enable bits 
  tsi721_dsend - Send a RapidIO doorbell
  @mport: RapidIO master port info
  @index: ID of RapidIO interface
  @destid: Destination ID of target device
  @data: 16-bit info field of RapidIO doorbell
  Sends a RapidIO doorbell message. Always returns %0.
  tsi721_dbell_handler - Tsi721 doorbell interrupt handler
  @priv: tsi721 device-specific data structure
  Handles inbound doorbell interrupts. Copies doorbell entry from an internal
  buffer into DB message FIFO and schedules deferred  routine to process
  queued DBs.
 Disable IDB interrupts 
	
	  Process queued inbound doorbells
 Process one doorbell 
 Re-enable IDB interrupts 
  tsi721_irqhandler - Tsi721 interrupt handler
  @irq: Linux interrupt number
  @ptr: Pointer to interrupt-specific data (tsi721_device structure)
  Handles Tsi721 interrupts signaled using MSI and INTA. Checks reported
  interrupt events and calls an event-specific handler(s).
 For MSI mode disable all device-level interrupts 
 Service SR2PC Channel interrupts 
 Service Inbound Doorbell interrupt 
 Clear interrupts 
		
		  Service channel interrupts from Messaging Engine
 Inbound Msg 
 Disable signaled OB MSG Channel interrupts 
			
			  Process Inbound Message interrupt for each MBOX
 Outbound Msg 
 Disable signaled OB MSG Channel interrupts 
			
			  Process Outbound Message interrupts for each MBOX
 Service SRIO MAC interrupts 
 For MSI mode re-enable device-level interrupts 
 Enable IDB interrupts 
 Enable SRIO MAC interrupts 
 Enable interrupts from channels in use 
  tsi721_omsg_msix - MSI-X interrupt handler for outbound messaging
  @irq: Linux interrupt number
  @ptr: Pointer to interrupt-specific data (tsi721_device structure)
  Handles outbound messaging interrupts signaled using MSI-X.
  tsi721_imsg_msix - MSI-X interrupt handler for inbound messaging
  @irq: Linux interrupt number
  @ptr: Pointer to interrupt-specific data (tsi721_device structure)
  Handles inbound messaging interrupts signaled using MSI-X.
  tsi721_srio_msix - Tsi721 MSI-X SRIO MAC interrupt handler
  @irq: Linux interrupt number
  @ptr: Pointer to interrupt-specific data (tsi721_device structure)
  Handles Tsi721 interrupts from SRIO MAC.
 Service SRIO MAC interrupts 
  tsi721_sr2pc_ch_msix - Tsi721 MSI-X SR2PC Channel interrupt handler
  @irq: Linux interrupt number
  @ptr: Pointer to interrupt-specific data (tsi721_device structure)
  Handles Tsi721 interrupts from SR2PC Channel.
  NOTE: At this moment services only one SR2PC channel associated with inbound
  doorbells.
 Service Inbound DB interrupt from SR2PC channel 
 Clear interrupts 
 Read back to ensure that interrupt was cleared 
  tsi721_request_msix - register interrupt service for MSI-X mode.
  @priv: tsi721 device-specific data structure
  Registers MSI-X interrupt service routines for interrupts that are active
  immediately after mport initialization. Messaging interrupt service routines
  should be registered during corresponding open requests.
  tsi721_enable_msix - Attempts to enable MSI-X support for Tsi721.
  @priv: pointer to tsi721 private data
  Configures MSI-X support for Tsi721. Supports only an exact number
  of requested vectors.
	
	  Initialize MSI-X entries for Messaging Engine:
	  this driver supports four RIO mailboxes (inbound and outbound)
	  NOTE: Inbound message MBOX 0...4 use IB channels 4...7. Therefore
	  offset +4 is added to IB MBOX number.
	
	  Initialize MSI-X entries for Block DMA Engine:
	  this driver supports XXX DMA channels
	  (one is reserved for SRIO maintenance transactions)
 CONFIG_RAPIDIO_DMA_ENGINE 
	
	  Copy MSI-X vector information into tsi721 private structure
 CONFIG_RAPIDIO_DMA_ENGINE 
 CONFIG_PCI_MSI 
			
			  If this window belongs to the current BAR check it
			  for overlap
 Overlap detected 
	
	  Configure Outbound Window
	
	  Program Address Translation Zones:
	   This implementation uses all 8 zones associated wit window.
  tsi721_init_pc2sr_mapping - initializes outbound (PCIe->SRIO)
  translation regions.
  @priv: pointer to tsi721 private data
  Disables SREP translation regions.
 Disable all PC2SR translation windows 
 Initialize zone lookup tables to avoid ECC errors on reads 
  tsi721_rio_map_inb_mem -- Mapping inbound memory region.
  @mport: RapidIO master port
  @lstart: Local memory space start address.
  @rstart: RapidIO space start address.
  @size: The mapping region size.
  @flags: Flags for mapping. 0 for using default flags.
  Return: 0 -- Success.
  This function will create the inbound mapping
  from rstart to lstart.
 Max IBW size supported by HW is 16GB 
 Calculate minimal acceptable window size and base address 
 Check for crossing IBW max size 16GB 
	
	  Scan for overlapping with active regions and mark the first available
	  IB window at the same time.
 Return error if address translation involved 
			
			  Direct mappings usually are larger than originally
			  requested fragments - check if this new request fits
			  into it.
 We are in - no further mapping required 
 Sanity check: available IB window must be disabled at this point 
	
	  When using direct IBW mapping and have larger than requested IBW size
	  we can have multiple local memory blocks mapped through the same IBW
	  To handle this situation we maintain list of "clients" for such IBWs.
  tsi721_rio_unmap_inb_mem -- Unmapping inbound memory region.
  @mport: RapidIO master port
  @lstart: Local memory space start address.
 Search for matching active inbound translation window 
 Address translating IBWs must to be an exact march 
  tsi721_init_sr2pc_mapping - initializes inbound (SRIO->PCIe)
  translation regions.
  @priv: pointer to tsi721 private data
  Disables inbound windows.
 Disable all SR2PC inbound windows 
  tsi721_close_sr2pc_mapping - closes all active inbound (SRIO->PCIe)
  translation regions.
  @priv: pointer to tsi721 device private data
 Disable all active SR2PC inbound windows 
  tsi721_port_write_init - Inbound port write interface init
  @priv: pointer to tsi721 private data
  Initializes inbound port write handler.
  Returns %0 on success or %-ENOMEM on failure.
 Use reliable port-write capture mode 
	 Outbound Doorbells do not require any setup.
	  Tsi721 uses dedicated PCI BAR1 to generate doorbells.
	  That BAR1 was mapped during the probe routine.
 Initialize Inbound Doorbell processing DPC and queue 
 Allocate buffer for inbound doorbells queue 
 Enable accepting all inbound doorbells 
 Free buffer allocated for inbound doorbell queue 
  tsi721_bdma_maint_init - Initialize maintenance request BDMA channel.
  @priv: pointer to tsi721 private data
  Initialize BDMA channel allocated for RapidIO maintenance readwrite
  request generation
  Returns %0 on success or %-ENOMEM on failure.
	
	  Initialize DMA channel for maintenance requests
 Allocate space for DMA descriptors 
 Allocate space for descriptor status FIFO 
 Free space allocated for DMA descriptors 
 Initialize DMA descriptors ring 
 Setup DMA descriptor pointers 
 Setup descriptor status FIFO 
 Clear interrupt bits 
 Toggle DMA channel initialization 
 Check if DMA channel still running 
 Put DMA channel into init state 
 Free space allocated for DMA descriptors 
 Free space allocated for status FIFO 
 Enable Inbound Messaging Interrupts 
 Clear pending Inbound Messaging interrupts 
 Enable Inbound Messaging interrupts 
 Finished if we are in MSI-X mode 
	
	  For MSI and INTA interrupt signalling we need to enable next levels
 Enable Device Channel Interrupt 
 Disable Inbound Messaging Interrupts 
 Clear pending Inbound Messaging interrupts 
 Disable Inbound Messaging interrupts 
 Finished if we are in MSI-X mode 
	
	  For MSI and INTA interrupt signalling we need to disable next levels
 Disable Device Channel Interrupt 
 Enable Outbound Messaging interrupts 
 Clear pending Outbound Messaging interrupts 
 Enable Outbound Messaging channel interrupts 
 Finished if we are in MSI-X mode 
	
	  For MSI and INTA interrupt signalling we need to enable next levels
 Enable Device Channel Interrupt 
 Disable Outbound Messaging interrupts 
 Clear pending Outbound Messaging interrupts 
 Disable Outbound Messaging interrupts 
 Finished if we are in MSI-X mode 
	
	  For MSI and INTA interrupt signalling we need to disable next levels
 Disable Device Channel Interrupt 
  tsi721_add_outb_message - Add message to the Tsi721 outbound message queue
  @mport: Master port with outbound message queue
  @rdev: Target of outbound message
  @mbox: Outbound mailbox
  @buffer: Message to add to outbound queue
  @len: Length of message
 Copy copy message into transfer buffer 
 Build descriptor associated with buffer 
 Request IOF_DONE interrupt generation for each N-th frame in queue 
 Go to next descriptor 
 Move through the ring link descriptor at the end 
 Set new write count value 
  tsi721_omsg_handler - Outbound Message Interrupt Handler
  @priv: pointer to tsi721 private data
  @ch:   number of OB MSG channel to service
  Services channel interrupts from outbound messaging engine.
		
		  Find last successfully processed descriptor
 Check and clear descriptor status FIFO entries 
 Inform upper layer about transfer completion 
		
		  Check if this is a Link Descriptor (LD).
		  If yes, ignore LD and use descriptor processed
		  before LD.
 Move slot index to the next message to be sent 
		
		 Outbound message operation aborted due to error,
		 reinitialize OB MSG channel
 Inform upper level to clear all pending tx slots 
 Synch tx_slot tracking 
 Clear channel interrupts 
 Re-enable channel interrupts 
  tsi721_open_outb_mbox - Initialize Tsi721 outbound mailbox
  @mport: Master port implementing Outbound Messaging Engine
  @dev_id: Device specific pointer to pass on event
  @mbox: Mailbox to open
  @entries: Number of entries in the outbound mailbox ring
	 Outbound Msg Buffer allocation based on
 Outbound message descriptor allocation 
 Outbound message descriptor status FIFO allocation 
	
	  Configure Outbound Messaging Engine
 Setup Outbound Message descriptor pointer 
 Setup Outbound Message descriptor status FIFO 
 Enable interrupts 
 Request interrupt service if we are in MSI-X mode 
 CONFIG_PCI_MSI 
 Initialize Outbound Message descriptors ring 
 Initialize Outbound Message engine 
 CONFIG_PCI_MSI 
  tsi721_close_outb_mbox - Close Tsi721 outbound mailbox
  @mport: Master port implementing the outbound message unit
  @mbox: Mailbox to close
 Disable Interrupts 
 CONFIG_PCI_MSI 
 Free OMSG Descriptor Status FIFO 
 Free OMSG descriptors 
 Free message buffers 
  tsi721_imsg_handler - Inbound Message Interrupt Handler
  @priv: pointer to tsi721 private data
  @ch: inbound message channel number to service
  Services channel interrupts from inbound messaging engine.
 Clear IB channel interrupts 
 If an IB Msg is received notify the upper layer 
 Re-enable channel interrupts 
  tsi721_open_inb_mbox - Initialize Tsi721 inbound mailbox
  @mport: Master port implementing the Inbound Messaging Engine
  @dev_id: Device specific pointer to pass on event
  @mbox: Mailbox to open
  @entries: Number of entries in the inbound mailbox ring
 Initialize IB Messaging Ring 
 Allocate buffers for incoming messages 
 Allocate memory for circular free list 
 Allocate memory for Inbound message descriptors 
 Fill free buffer pointer list 
	
	  For mapping of inbound SRIO Messages into appropriate queues we need
	  to set Inbound Device ID register in the messaging engine. We do it
	  once when first inbound mailbox is requested.
	
	  Configure Inbound Messaging channel (ch = mbox + 4)
 Setup Inbound Message free queue 
 Setup Inbound Message descriptor queue 
 Enable interrupts 
 Request interrupt service if we are in MSI-X mode 
 CONFIG_PCI_MSI 
 Initialize Inbound Message Engine 
 CONFIG_PCI_MSI 
  tsi721_close_inb_mbox - Shut down Tsi721 inbound mailbox
  @mport: Master port implementing the Inbound Messaging Engine
  @mbox: Mailbox to close
 mbox isn't initialized yet 
 Disable Inbound Messaging Engine 
 Disable Interrupts 
 CONFIG_PCI_MSI 
 Clear Inbound Buffer Queue 
 Free memory allocated for message buffers 
 Free memory allocated for free pointr list 
 Free memory allocated for RX descriptors 
  tsi721_add_inb_buffer - Add buffer to the Tsi721 inbound message queue
  @mport: Master port implementing the Inbound Messaging Engine
  @mbox: Inbound mailbox number
  @buf: Buffer to add to inbound queue
  tsi721_get_inb_message - Fetch inbound message from the Tsi721 MSG Queue
  @mport: Master port implementing the Inbound Messaging Engine
  @mbox: Inbound mailbox number
  Returns pointer to the message on success or NULL on failure.
 Return free buffer into the pointer list 
  tsi721_messages_init - Initialization of Messaging Engine
  @priv: pointer to tsi721 private data
  Configures Tsi721 messaging engine.
 Set SRIO Message RequestResponse Timeout 
 Initialize Inbound Messaging Engine Registers 
 Clear interrupt bits 
 Clear Status 
  tsi721_query_mport - Fetch inbound message from the Tsi721 MSG Queue
  @mport: Master port implementing the Inbound Messaging Engine
  @mbox: Inbound mailbox number
  Returns pointer to the message on success or NULL on failure.
  tsi721_disable_ints - disables all device interrupts
  @priv: pointer to tsi721 private data
 Disable all device level interrupts 
 Disable all Device Channel interrupts 
 Disable all Inbound Msg Channel interrupts 
 Disable all Outbound Msg Channel interrupts 
 Disable all general messaging interrupts 
 Disable all BDMA Channel interrupts 
 Disable all general BDMA interrupts 
 Disable all SRIO Channel interrupts 
 Disable all general SR2PC interrupts 
 Disable all PC2SR interrupts 
 Disable all I2C interrupts 
 Disable SRIO MAC interrupts 
  tsi721_setup_mport - Setup Tsi721 as RapidIO subsystem master port
  @priv: pointer to tsi721 private data
  Configures Tsi721 as RapidIO master port.
 small system 
 Hook up interrupt handler 
 CONFIG_PCI_MSI 
 Enable SRIO link 
	
	  Verify BAR configuration
 BAR_0 (registers) must be 512KB+ in 32-bit address space 
 BAR_1 (outbound doorbells) must be 16MB+ in 32-bit address space 
	
	  BAR_2 and BAR_4 (outbound translation) must be in 64-bit PCIe address
	  space.
	  NOTE: BAR_2 and BAR_4 are not used by this version of driver.
	  It may be a good idea to keep them disabled using HW configuration
	  to save PCI memory space.
 Configure DMA attributes. 
 Clear "no snoop" and "relaxed ordering" bits. 
 Override PCIe Maximum Read Request Size setting if requested 
 Set PCIe completion timeout to 1-10ms 
	
	  FIXUP: correct offsets of MSI-X tables in the MSI-X Capability Block
 End of FIXUP 
 terminate list 
 SPDX-License-Identifier: GPL-2.0
  Support for dynamic device trees.
  On some platforms, the device tree can be manipulated at runtime.
  The routines in this section support adding, removing and changing
  device tree nodes.
  of_node_get() - Increment refcount of a node
  @node:	Node to inc refcount, NULL is supported to simplify writing of
 		callers
  Return: The node with refcount incremented.
  of_node_put() - Decrement refcount of a node
  @node:	Node to dec refcount, NULL is supported to simplify writing of
 		callers
  of_reconfig_get_state_change()	- Returns new state of device
  @action	- action of the of notifier
  @arg		- argument of the of notifier
  Returns the new state of a device based on the notifier used.
  Return: 0 on device going from enabled to disabled, 1 on device
  going from disabled to enabled and -1 on no change.
 figure out if a device should be created or destroyed 
 -1 & 0 status either missing or okay 
 -1 & 0 status either missing or okay 
 no status property -> enabled (legacy) 
 no status property -> enabled (legacy) 
 only call notifiers if the node is attached 
  of_attach_node() - Plug a device node into the tree and global list.
  @np:		Pointer to the caller's Device Node
 race with of_find_node_by_phandle() prevented by devtree_lock 
  of_detach_node() - "Unplug" a node from the device tree.
  @np:		Pointer to the caller's Device Node
  of_node_release() - release a dynamically allocated node
  @kobj: kernel object of the node to be released
  In of_node_put() this function is passed to kref_put() as the destructor.
 We should never be releasing nodes that haven't been detached. 
 premature refcount of zero, do not free memory 
		
		  If node->properties non-empty then properties were added
		  to this node either by different overlay that has not
		  yet been removed, or by a non-overlay mechanism.
  __of_prop_dup - Copy a property dynamically.
  @prop:	Property to copy
  @allocflags:	Allocation flags (typically pass GFP_KERNEL)
  Copy a property by dynamically allocating the memory of both the
  property structure and the property name & contents. The property's
  flags have the OF_DYNAMIC bit set so that we can differentiate between
  dynamically allocated properties and not.
  Return: The newly allocated property or NULL on out of memory error.
	
	  NOTE: There is no check for zero length value.
	  In case of a boolean property, this will allocate a value
	  of zero bytes. We do this to work around the use
	  of of_get_property() calls on boolean values.
 mark the property as dynamic 
  __of_node_dup() - Duplicate or create an empty device node dynamically.
  @np:		if not NULL, contains properties to be duplicated in new node
  @full_name:	string value to be duplicated into new node's full_name field
  Create a device tree node, optionally duplicating the properties of
  another node.  The node data are dynamically allocated and all the node
  flags have the OF_DYNAMIC & OF_DETACHED bits set.
  Return: The newly allocated node or NULL on out of memory error.
 Iterate over and duplicate all properties 
 Frees the node and properties 
 empty 
 update was used but original property did not exist 
 If the property is in deadprops then it must be removed 
 If the property is in deadprops then it must be removed 
 ignore duplicate names 
  of_changeset_init - Initialize a changeset for use
  @ocs:	changeset pointer
  Initialize a changeset structure
  of_changeset_destroy - Destroy a changeset
  @ocs:	changeset pointer
  Destroys a changeset. Note that if a changeset is applied,
  its changes to the tree cannot be reverted.
  Apply the changeset entries in @ocs.
  If apply fails, an attempt is made to revert the entries that were
  successfully applied.
  If multiple revert errors occur then only the final revert error is reported.
  Returns 0 on success, a negative error value in case of an error.
  If a revert error occurs, it is returned in ret_revert.
  Returns 0 on success, a negative error value in case of an error.
  If multiple changeset entry notification errors occur then only the
  final notification error is reported.
 drop the global lock while emitting notifiers 
  Returns 0 on success, a negative error value in case of an error.
  If a changeset entry apply fails, an attempt is made to revert any
  previous entries in the changeset.  If any of the reverts fails,
  that failure is not reported.  Thus the state of the device tree
  is unknown if an apply error occurs.
  of_changeset_apply - Applies a changeset
  @ocs:	changeset pointer
  Applies a changeset to the live tree.
  Any side-effects of live tree state changes are applied here on
  success, like creationdestruction of devices and side-effects
  like creation of sysfs properties and directories.
  Return: 0 on success, a negative error value in case of an error.
  On error the partially applied effects are reverted.
  Revert the changeset entries in @ocs.
  If revert fails, an attempt is made to re-apply the entries that were
  successfully removed.
  If multiple re-apply errors occur then only the final apply error is
  reported.
  Returns 0 on success, a negative error value in case of an error.
  If an apply error occurs, it is returned in ret_apply.
  If multiple changeset entry notification errors occur then only the
  final notification error is reported.
 drop the global lock while emitting notifiers 
  of_changeset_revert - Reverts an applied changeset
  @ocs:	changeset pointer
  Reverts a changeset returning the state of the tree to what it
  was before the application.
  Any side-effects like creationdestruction of devices and
  removal of sysfs properties and directories are applied.
  Return: 0 on success, a negative error value in case of an error.
  of_changeset_action - Add an action to the tail of the changeset list
  @ocs:	changeset pointer
  @action:	action to perform
  @np:		Pointer to device node
  @prop:	Pointer to property
  On action being one of:
  + OF_RECONFIG_ATTACH_NODE
  + OF_RECONFIG_DETACH_NODE,
  + OF_RECONFIG_ADD_PROPERTY
  + OF_RECONFIG_REMOVE_PROPERTY,
  + OF_RECONFIG_UPDATE_PROPERTY
  Return: 0 on success, a negative error value in case of an error.
 get a reference to the node 
 add it to the list 
 SPDX-License-Identifier: GPL-2.0
  Self tests for device tree subsystem
 to test phys_to_dmadma_to_phys 
  Expected message may have a message level other than KERN_INFO.
  Print the expected message only if the current loglevel will allow
  the actual message to print.
  Do not use EXPECT_BEGIN() or EXPECT_END() for messages generated by
  pr_debug().
 Test if trailing '' works 
 Test if trailing '' works on aliases 
 Array of 4 properties for the purpose of testing 
 Add a new property - should pass
 Try to add an existing property - should fail 
 Try to modify an existing property - should pass 
 Try to modify non-existent property - should pass
 Remove property - should pass 
 Adding very large property - should pass 
 Baseline; check conversion with a large size limit 
 use strcmp() instead of strncmp() here to be absolutely sure strings match 
 Make sure length limits work 
 Clear the buffer, and make sure it works correctly still 
 Clean up 
 Test the values from tests-phandle.dtsi 
 Check for missing list property 
 Check for missing cells property 
 Check for bad phandle in list 
 Check for incorrectly formed argument list 
 Test the values from tests-phandle.dtsi 
 Check for missing list property 
 Check for missing cells,map,mask property 
 Check for bad phandle in list 
 Check for incorrectly formed argument list 
 of_property_count_strings() tests 
 of_property_read_string_index() tests 
 should fail 
 of_property_read_string_array() tests 
 -- An incorrectly formed string should cause a failure 
 -- parsing the correctly formed strings should still work: 
 Make sure node names are constructed correctly 
	
	  Get the dma-ranges from the device tree
 Test the values from tests-phandle.dtsi 
 Test the values from tests-phandle.dtsi 
			
			  Tests child node that is missing property
			  #address-cells.  See the comments in
			  driversofunittest-datatests-interrupts.dtsi
			  nodes intmap1 and interrupts-extended0
 Name alone is lowest priority 
 followed by type alone 
 followed by both together 
 Only match when type doesn't match 
 Test that a missing irq domain returns -EPROBE_DEFER 
 Test that a parsing failure does not return -EPROBE_DEFER 
	
	  Add a dummy resource to the test bus node after it is
	  registered to catch problems with un-inserted resources. The
	  DT code doesn't insert the resources, and it has caused the
	  kernel to oops in the past. This makes sure the same bug
	  doesn't crop up again.
 	update_node_properties - adds the properties
 	of np into dup node (present in live tree) and
 	updates parent of children of np to dup.
 	@np:	node whose properties are being added to the live tree
 	@dup:	node present in live tree to be updated
	
	  "unittest internal error: unable to add testdata property"
	 
	     If this message reports a property in node '__symbols__' then
	     the respective unittest overlay contains a label that has the
	     same name as a label in the live devicetree.  The label will
	     be in the live devicetree only if the devicetree source was
	     compiled with the '-@' option.  If you encounter this error,
	     please consider renaming __all__ of the labels in the unittest
	     overlay dts files with an odd prefix that is unlikely to be
	     used in a real devicetree.
	
	  open code for_each_property_of_node() because of_add_property()
	  sets prop->next to NULL
 	attach_node_and_children - attaches nodes
 	and its children to live tree.
 	CAUTION: misleading function name - if node @np already exists in
 	the live tree then children of @np are not attached to the live
 	tree.  This works for the current test devicetree nodes because such
 	nodes do not have child nodes.
 	@np:	Node to attach to live tree
 	unittest_data_add - Reads, copies data from
 	linked tree and attaches it to the live tree
	
	  __dtb_testcases_begin[] and __dtb_testcases_end[] are magically
	  created by cmd_dt_S_dtb in scriptsMakefile.lib
 creating copy 
	
	  This lock normally encloses of_resolve_phandles()
 attach the sub-tree to live tree 
 get the platform device instantiated at the path 
 find out if a platform device exists at that path 
 dynamic allocation 
	
	  tests: apply overlays before registering driver
	  Similar to installing a driver as a module, the
	  driver is registered after applying the overlays.
	 
	  The overlays are applied by overlay_data_apply()
	  instead of of_unittest_apply_overlay() so that they
	  will not be tracked.  Thus they will not be removed
	  by of_unittest_destroy_tracked_overlays().
	 
	  - apply overlay_gpio_01
	  - apply overlay_gpio_02a
	  - apply overlay_gpio_02b
	  - register driver
	 
	  register driver will result in
	    - probe and processing gpio hog for overlay_gpio_01
	    - probe for overlay_gpio_02a
	    - processing gpio for overlay_gpio_02b
	
	  overlay_gpio_01 contains gpio node and child gpio hog node
	  overlay_gpio_02a contains gpio node
	  overlay_gpio_02b contains child gpio hog node
	
	  messages are the result of the probes, after the
	  driver is registered
	
	  tests: apply overlays after registering driver
	 
	  Similar to a driver built-in to the kernel, the
	  driver is registered before applying the overlays.
	 
	  overlay_gpio_03 contains gpio node and child gpio hog node
	 
	  - apply overlay_gpio_03
	 
	  apply overlay will result in
	    - probe and processing gpio hog.
 overlay_gpio_03 contains gpio node and child gpio hog node 
	
	  overlay_gpio_04a contains gpio node
	 
	  - apply overlay_gpio_04a
	 
	  apply the overlay will result in
	    - probe for overlay_gpio_04a
 overlay_gpio_04a contains gpio node 
	
	  overlay_gpio_04b contains child gpio hog node
	 
	  - apply overlay_gpio_04b
	 
	  apply the overlay will result in
	    - processing gpio for overlay_gpio_04b
 overlay_gpio_04b contains child gpio hog node 
 skip tests 
 get the i2c client device instantiated at the path 
 find out if a i2c client device exists at that path 
 FIXME: it is NOT guaranteed that overlay ids are assigned in sequence 
 try until no defers 
 remove in reverse order 
 apply an overlay while checking before and after states 
 unittest device must not be in before state 
 of_unittest_apply_overlay already called unittest() 
 unittest device must be to set to after state 
 apply an overlay and then revert it while checking before, after states 
 unittest device must be in before state 
 apply the overlay 
 of_unittest_apply_overlay already called unittest() 
 unittest device must be in after state 
 unittest device must be again in before state 
 test activation of device 
 device should enable 
 test deactivation of device 
 device should disable 
 test activation of device 
 device should enable 
 test deactivation of device 
 device should disable 
 test activation of a full device node 
 device should disable 
 test overlay applyrevert sequence 
 device should disable 
 test overlay application in sequence 
 unittest device must be in before state 
 apply the overlays 
 unittest device must be in after state 
 unittest device must be again in before state 
 test overlay application in sequence 
 we don't care about device state in this test 
 apply the overlays 
 now try to remove first overlay (it should fail) 
 removing them in order should work 
 test insertion of a bus with parent devices 
 device should disable 
 test insertion of a bus with parent devices (and revert) 
 device should disable 
 link them together 
 device should enable 
 test deactivation of device 
 device should disable 
 just check for i2c mux existence 
 device should enable 
 tests in sequence 
  __dtb_ot_begin[] and __dtb_ot_end[] are created by cmd_dt_S_dtb
  in scriptsMakefile.lib
 entries found by name 
 end marker 
  Create base device tree for the overlay unittest.
  This is called from very early boot code.
  Do as much as possible the same way as done in __unflatten_device_tree
  and other early boot steps for the normal FDT so that the overlay base
  unflattened tree will have the same characteristics as the real tree
  (such as having memory allocated by the early allocator).  The goal
  is to test "the real thing" as much as possible, and test "test setup
  code" as little as possible.
  Have to stop before resolving phandles, because that uses kmalloc.
  The purpose of of_unittest_overlay_data_add is to add an
  overlay in the normal fashion.  This is a test of the whole
  picture, instead of testing individual elements.
  A secondary purpose is to be able to verify that the contents of
  procdevice-tree contains the updated structure and values from
  the overlay.  That must be verified separately in user space.
  Return 0 on unexpected error.
  The purpose of of_unittest_overlay_high_level is to add an overlay
  in the normal fashion.  This is a test of the whole picture,
  instead of individual elements.
  The first part of the function is _not_ normal overlay usage; it is
  finishing splicing the base overlay device tree into the live tree.
	
	  Could not fixup phandles in unittest_unflatten_overlay_base()
	  because kmalloc() was not yet available.
	
	  do not allow overlay_base to duplicate any node already in
	  tree, this greatly simplifies the code
	
	  remove overlay_base_root node "__local_fixups", after
	  being used by of_resolve_phandles()
 remove overlay_base_root node "__symbols__" if in live tree 
 will have to graft properties from node into live tree 
	
	  overlay 'overlay_base' is not allowed to have root
	  properties, so only need to splice nodes into main device tree.
	 
	  root node of overlay_base_root will not be freed, it is lost
	  memory.
 "name" auto-generated by unflatten 
 now do the normal overlay usage test 
 adding data for unittest 
 Double check linkage after removing testcase data 
 SPDX-License-Identifier: GPL-2.0
 true when node is initialized 
 true when node is attached (i.e. present on sysfs) 
 Without CONFIG_OF_DYNAMIC, no nodes gets freed 
 CONFIG_OF_DYNAMIC 
 always return newly allocated name, caller must free after use 
 don't be a hero. After 16 tries give up 
 Important: Don't leak passwords 
 at early boot, bail here and defer setup to of_init() 
 At early boot, bail out and defer setup to of_init() 
 Nodes without parents are new top level trees 
 only remove properties if on sysfs 
 SPDX-License-Identifier: GPL-2.0
  Functions for working with the Flattened Device Tree data format
  Copyright 2009 Benjamin Herrenschmidt, IBM Corp
  benh@kernel.crashing.org
 for COMMAND_LINE_SIZE 
  of_fdt_limit_memory - limit the number of regions in the memory node
  @limit: maximum entries
  Adjust the flattened device tree to have at most 'limit' number of
  memory entries in the memory node. This function may be called
  any time after initial_boot_param is set.
		 We accept flattened tree phandles either in
		  ePAPR-style "phandle" properties, or the
		  legacy "linux,phandle" properties.  If both
		  appear and have different values, things
		  will get weird. Don't do that.
		 And we process the "ibm,phandle" property
		  used in pSeries dynamic device tree
		  stuff
	 With version 0x10 we may not have the name property,
	  recreate it here from the unit name if absent
 In-depth first 
 Reverse the nodes in the child list 
  unflatten_dt_nodes - Alloc and populate a device_node from the flat tree
  @blob: The parent device tree blob
  @mem: Memory chunk to use for allocating device nodes and properties
  @dad: Parent struct device_node
  @nodepp: The device_node tree created by the call
  Return: The size of unflattened device tree or error code
	
	  We're unflattening device sub-tree if @dad is valid. There are
	  possibly multiple nodes in the first level of depth. We need
	  set @depth to 1 to make fdt_next_node() happy as it bails
	  immediately when negative @depth is found. Otherwise, the device
	  nodes except the first one won't be unflattened successfully.
	
	  Reverse the child list. Some drivers assumes node order matches .dts
	  node order
  __unflatten_device_tree - create tree of device_nodes from flat blob
  @blob: The blob to expand
  @dad: Parent device node
  @mynodes: The device_node tree created by the call
  @dt_alloc: An allocator that provides a virtual address to memory
  for the resulting tree
  @detached: if true set OF_DETACHED on @mynodes
  unflattens a device-tree, creating the tree of struct device_node. It also
  fills the "name" and "type" pointers of the nodes so the normal device-tree
  walking functions can be used.
  Return: NULL on failure or the memory chunk containing the unflattened
  device tree on success.
 First pass, scan for size 
 Allocate memory for the expanded device tree 
 Second pass, do actual unflattening 
  of_fdt_unflatten_tree - create tree of device_nodes from flat blob
  @blob: Flat device tree blob
  @dad: Parent device node
  @mynodes: The device tree created by the call
  unflattens the device-tree passed by the firmware, creating the
  tree of struct device_node. It also fills the "name" and "type"
  pointers of the nodes so the normal device-tree walking functions
  can be used.
  Return: NULL on failure or the memory chunk containing the unflattened
  device tree on success.
 Everything below here references initial_boot_params directly. 
		
		  If the memory is already reserved (by another region), we
		  should not allow it to be marked nomap.
  __reserved_mem_reserve_reg() - reserve all memory described in 'reg' property
  __reserved_mem_check_root() - check if #size-cells, #address-cells provided
  in reserved-memory matches the values supported by the current implementation,
  also check if ranges property has been provided
  fdt_scan_reserved_mem() - scan a single FDT node for reserved memory
  fdt_reserve_elfcorehdr() - reserves memory for elf core header
  This function reserves the memory occupied by an elf core header
  described in the device tree. This region contains all the
  information about primary kernel's core image and is used by a dump
  capture kernel to access the system memory on primary kernel.
  early_init_fdt_scan_reserved_mem() - create reserved memory regions
  This function grabs memory from early allocator for device exclusive use
  defined in device tree structures. It should be called by arch specific code
  once the early allocator (i.e. memblock) has been fully activated.
 Process header memreserve fields 
  early_init_fdt_reserve_self() - reserve the memory used by the FDT blob
 Reserve the dtb region 
  of_scan_flat_dt - scan flattened tree blob and call callback on each.
  @it: callback function
  @data: context data pointer
  This function is used to scan the flattened device-tree, it is
  used to extract the memory information at boot before we can
  unflatten the tree
  of_scan_flat_dt_subnodes - scan sub-nodes of a node call callback on each.
  @parent: parent node
  @it: callback function
  @data: context data pointer
  This function is used to scan sub-nodes of a node.
  of_get_flat_dt_subnode_by_name - get the subnode by given name
  @node: the parent node
  @uname: the name of subnode
  @return offset of the subnode, or -FDT_ERR_NOTFOUND if there is none
  of_get_flat_dt_root - find the root node in the flat blob
  of_get_flat_dt_prop - Given a node in the flat blob, return the property ptr
  This function can be used within scan_flattened_dt callback to get
  access to properties
  of_fdt_is_compatible - Return true if given node from the given blob has
  compat in its compatible list
  @blob: A device tree blob
  @node: node to test
  @compat: compatible string to compare with compatible list.
  Return: a non-zero value on match with smaller values returned for more
  specific compatible values.
  of_flat_dt_is_compatible - Return true if given node has compat in compatible list
  @node: node to test
  @compat: compatible string to compare with compatible list.
  of_flat_dt_match - Return true if node matches a list of compatible values
  of_get_flat_dt_phandle - Given a node in the flat blob, return the phandle
  of_flat_dt_match_machine - Iterate match tables to find matching machine.
  @default_match: A machine specific ptr to return in case of no match.
  @get_next_compat: callback function to return next compatible match table.
  Iterate through machine match tables to find the best match for the machine
  compatible string in the FDT.
	 ARM64 would cause a BUG to occur here when CONFIG_DEBUG_VM is
	  enabled since __va() is called too early. ARM64 does make use
	  of phys_initrd_startphys_initrd_size so we can skip this
	  conversion.
  early_init_dt_check_for_initrd - Decode initrd location from flat tree
  @node: reference to node containing initrd location ('chosen')
  early_init_dt_check_for_elfcorehdr - Decode elfcorehdr location from flat
  tree
  @node: reference to node containing elfcorehdr location ('chosen')
  early_init_dt_check_for_usable_mem_range - Decode usable memory range
  location from flat tree
  @node: reference to node containing usable memory range location ('chosen')
 Get the node specified by stdout-path 
  early_init_dt_scan_root - fetch the top level address and size cells
 break now 
  early_init_dt_scan_memory - Look for and parse memory nodes
 We are scanning "memory" nodes only 
 Retrieve command line 
	
	  CONFIG_CMDLINE is meant to be a default in case nothing else
	  managed to set the command line, unless CONFIG_CMDLINE_FORCE
	  is set in which case we override whatever was found earlier.
 No arguments from boot loader, use kernel's  cmdl
 CONFIG_CMDLINE 
 try to clear seed so it won't be found. 
 update CRC check value 
 break now 
 check device tree validity 
 Setup flat device-tree pointer 
 Initialize {size,address}-cells info 
 Retrieve various information from the chosen node 
 Setup memory, calling early_init_dt_add_memory_arch 
 Handle linux,usable-memory-range property 
  unflatten_device_tree - create tree of device_nodes from flat blob
  unflattens the device-tree passed by the firmware, creating the
  tree of struct device_node. It also fills the "name" and "type"
  pointers of the nodes so the normal device-tree walking functions
  can be used.
 Get pointer to "chosen" and "aliases" nodes for use everywhere 
  unflatten_and_copy_device_tree - copy and create tree of device_nodes from flat blob
  Copies and unflattens the device-tree passed by the firmware, creating the
  tree of struct device_node. It also fills the "name" and "type"
  pointers of the nodes so the normal device-tree walking functions
  can be used. This should only be used when the FDT memory has not been
  reserved such is the case when the FDT is built-in to the kernel init
  section. If the FDT memory is reserved already then unflatten_device_tree
  should be used instead.
 CONFIG_OF_EARLY_FLATTREE 
 SPDX-License-Identifier: GPL-2.0+
  Procedures for creating, accessing and interpreting the device tree.
  Paul Mackerras	August 1996.
  Copyright (C) 1996-2005 Paul Mackerras.
   Adapted for 64bit PowerPC by Dave Engebretsen and Peter Bergner.
     {engebret|bergner}@us.ibm.com
   Adapted for sparc and sparc64 by David S. Miller davem@davemloft.net
   Reconsolidated from archxkernelprom.c by Stephen Rothwell and
   Grant Likely.
  Used to protect the of_aliases, to hold off addition of nodes to sysfs.
  This mutex must be held whenever modifications are being made to the
  device tree. The of_{attach,detach}_node() and
  of_{add,remove,update}_property() helpers make sure this happens.
 use when traversing tree through the child, sibling,
  or parent members of struct device_node.
 No #address-cells property for the root node 
 No #size-cells property for the root node 
  Caller must hold devtree_lock.
 Create the kset, and register existing nodes 
 Symlink in proc as required by userspace ABI 
 Walk back up looking for a sibling, or the end of the structure 
 Might be null at the end of the tree 
  of_find_all_nodes - Get next node in global list
  @prev:	Previous node or NULL to start iteration
 		of_node_put() will be called on it
  Return: A node pointer with refcount incremented, use
  of_node_put() on it when done.
  Find a property with a given name for a given node
  and return the value.
  Find a property with a given name for a given node
  and return the value.
  of_get_cpu_hwid - Get the hardware ID from a CPU device node
  @cpun: CPU number(logical index) for which device node is required
  @thread: The local thread number to get the hardware ID for.
  Return: The hardware ID for the CPU node or ~0ULL if not found.
  arch_match_cpu_phys_id - Match the given logical CPU and physical id
  @cpu: logical cpu index of a corethread
  @phys_id: physical identifier of a corethread
  CPU logical to physical index mapping is architecture specific.
  However this __weak function provides a default match of physical
  id to logical cpu index. phys_id provided here is usually values read
  from the device tree which must match the hardware internal registers.
  Returns true if the physical identifier and the logical cpu index
  correspond to the same corethread, false otherwise.
  Checks if the given "prop_name" property holds the physical id of the
  corethread corresponding to the logical cpu 'cpu'. If 'thread' is not
  NULL, local thread number within the core is returned in it.
  arch_find_n_match_cpu_physical_id - See if the given device node is
  for the cpu corresponding to logical cpu 'cpu'.  Return true if so,
  else false.  If 'thread' is non-NULL, the local thread number within the
  core is returned in it.
	 Check for non-standard "ibm,ppc-interrupt-server#s" property
	  for thread ids on PowerPC. If it doesn't exist fallback to
	  standard "reg" property.
  of_get_cpu_node - Get device node associated with the given logical CPU
  @cpu: CPU number(logical index) for which device node is required
  @thread: if not NULL, local thread number within the physical core is
           returned
  The main purpose of this function is to retrieve the device node for the
  given logical CPU index. It should be used to initialize the of_node in
  cpu device. Once of_node in cpu device is populated, all the further
  references can use that instead.
  CPU logical to physical index mapping is architecture specific and is built
  before booting secondary cores. This function uses arch_match_cpu_phys_id
  which can be overridden by architecture specific implementation.
  Return: A node pointer for the logical cpu with refcount incremented, use
  of_node_put() on it when done. Returns NULL if not found.
  of_cpu_node_to_id: Get the logical CPU number for a given device_node
  @cpu_node: Pointer to the device_node for CPU.
  Return: The logical CPU number of the given CPU device_node or -ENODEV if the
  CPU is not found.
  of_get_cpu_state_node - Get CPU's idle state node at the given index
  @cpu_node: The device node for the CPU
  @index: The index in the list of the idle states
  Two generic methods can be used to describe a CPU's idle states, either via
  a flattened description through the "cpu-idle-states" binding or via the
  hierarchical layout, using the "power-domains" and the "domain-idle-states"
  bindings. This function check for both and returns the idle state node for
  the requested index.
  Return: An idle state node if found at @index. The refcount is incremented
  for it, so call of_node_put() on it when done. Returns NULL if not found.
  __of_device_is_compatible() - Check if the node matches given constraints
  @device: pointer to node
  @compat: required compatible string, NULL or "" for any match
  @type: required device_type value, NULL or "" for any match
  @name: required node name, NULL or "" for any match
  Checks if the given @compat, @type and @name strings match the
  properties of the given @device. A constraints can be skipped by
  passing NULL or an empty string as the constraint.
  Returns 0 for no match, and a positive integer on match. The return
  value is a relative score with larger values indicating better
  matches. The score is weighted for the most specific compatible value
  to get the highest score. Matching type is next, followed by matching
  name. Practically speaking, this results in the following priority
  order for matches:
  1. specific compatible && type && name
  2. specific compatible && type
  3. specific compatible && name
  4. specific compatible
  5. general compatible && type && name
  6. general compatible && type
  7. general compatible && name
  8. general compatible
  9. type && name
  10. type
  11. name
 Compatible match has highest priority 
 Matching type is better than matching name 
 Matching name is a bit better than not 
 Checks if the given "compat" string matches one of the strings in
  the device's "compatible" property
 Checks if the device is compatible with any of the entries in
   a NULL terminated array of strings. Returns the best match
   score or 0.
  of_machine_is_compatible - Test root of device tree for a given compatible value
  @compat: compatible string to look for in root node's compatible property.
  Return: A positive integer if the root node has the given value in its
  compatible property.
   __of_device_is_available - check if a device is available for use
   @device: Node to check for availability, with locks already held
   Return: True if the status property is absent or set to "okay" or "ok",
   false otherwise
   of_device_is_available - check if a device is available for use
   @device: Node to check for availability
   Return: True if the status property is absent or set to "okay" or "ok",
   false otherwise
   of_device_is_big_endian - check if a device has BE registers
   @device: Node to check for endianness
   Return: True if the device has a "big-endian" property, or if the kernel
   was compiled for BE and the device has a "native-endian" property.
   Returns false otherwise.
   Callers would nominally use ioread32beiowrite32be if
   of_device_is_big_endian() == true, or readlwritel otherwise.
  of_get_parent - Get a node's parent if any
  @node:	Node to get parent
  Return: A node pointer with refcount incremented, use
  of_node_put() on it when done.
  of_get_next_parent - Iterate to a node's parent
  @node:	Node to get parent of
  This is like of_get_parent() except that it drops the
  refcount on the passed node, making it suitable for iterating
  through a node's parents.
  Return: A node pointer with refcount incremented, use
  of_node_put() on it when done.
  of_get_next_child - Iterate a node childs
  @node:	parent node
  @prev:	previous child of the parent node, or NULL to get first
  Return: A node pointer with refcount incremented, use of_node_put() on
  it when done. Returns NULL when prev is the last child. Decrements the
  refcount of prev.
  of_get_next_available_child - Find the next available child node
  @node:	parent node
  @prev:	previous child of the parent node, or NULL to get first
  This function is like of_get_next_child(), except that it
  automatically skips any disabled nodes (i.e. status = "disabled").
  of_get_next_cpu_node - Iterate on cpu nodes
  @prev:	previous child of the cpus node, or NULL to get first
  Return: A cpu node pointer with refcount incremented, use of_node_put()
  on it when done. Returns NULL when prev is the last child. Decrements
  the refcount of prev.
  of_get_compatible_child - Find compatible child node
  @parent:	parent node
  @compatible:	compatible string
  Lookup child node whose compatible property contains the given compatible
  string.
  Return: a node pointer with refcount incremented, use of_node_put() on it
  when done; or NULL if not found.
  of_get_child_by_name - Find the child node by name for a given parent
  @node:	parent node
  @name:	child name to look for.
  This function looks for child node for given matching name
  Return: A node pointer if found, with refcount incremented, use
  of_node_put() on it when done.
  Returns NULL if node is not found.
 Increment past '' delimiter 
  of_find_node_opts_by_path - Find a node matching a full OF path
  @path: Either the full path to match, or if the path does not
        start with '', the name of a property of the aliases
        node (an alias).  In the case of an alias, the node
        matching the alias' value will be returned.
  @opts: Address of a pointer into which to store the start of
        an options string appended to the end of the path with
        a ':' separator.
  Valid paths:
    foobar	Full path
    foo	Valid alias
    foobar	Valid alias + relative path
  Return: A node pointer with refcount incremented, use
  of_node_put() on it when done.
 The path could begin with an alias 
 of_aliases must not be NULL 
 Step down the tree matching path components 
  of_find_node_by_name - Find a node by its "name" property
  @from:	The node to start searching from or NULL; the node
 		you pass will not be searched, only the next one
 		will. Typically, you pass what the previous call
 		returned. of_node_put() will be called on @from.
  @name:	The name string to match against
  Return: A node pointer with refcount incremented, use
  of_node_put() on it when done.
  of_find_node_by_type - Find a node by its "device_type" property
  @from:	The node to start searching from, or NULL to start searching
 		the entire device tree. The node you pass will not be
 		searched, only the next one will; typically, you pass
 		what the previous call returned. of_node_put() will be
 		called on from for you.
  @type:	The type string to match against
  Return: A node pointer with refcount incremented, use
  of_node_put() on it when done.
  of_find_compatible_node - Find a node based on type and one of the
                                 tokens in its "compatible" property
  @from:	The node to start searching from or NULL, the node
 		you pass will not be searched, only the next one
 		will; typically, you pass what the previous call
 		returned. of_node_put() will be called on it
  @type:	The type string to match "device_type" or NULL to ignore
  @compatible:	The string to match to one of the tokens in the device
 		"compatible" list.
  Return: A node pointer with refcount incremented, use
  of_node_put() on it when done.
  of_find_node_with_property - Find a node which has a property with
                               the given name.
  @from:	The node to start searching from or NULL, the node
 		you pass will not be searched, only the next one
 		will; typically, you pass what the previous call
 		returned. of_node_put() will be called on it
  @prop_name:	The name of the property to look for.
  Return: A node pointer with refcount incremented, use
  of_node_put() on it when done.
  of_match_node - Tell if a device_node has a matching of_match structure
  @matches:	array of of device match structures to search in
  @node:	the of device structure to match against
  Low level utility function used by device matching.
  of_find_matching_node_and_match - Find a node based on an of_device_id
 				     match table.
  @from:	The node to start searching from or NULL, the node
 		you pass will not be searched, only the next one
 		will; typically, you pass what the previous call
 		returned. of_node_put() will be called on it
  @matches:	array of of device match structures to search in
  @match:	Updated to point at the matches entry which matched
  Return: A node pointer with refcount incremented, use
  of_node_put() on it when done.
  of_modalias_node - Lookup appropriate modalias for a device node
  @node:	pointer to a device tree node
  @modalias:	Pointer to buffer that modalias value will be copied into
  @len:	Length of modalias value
  Based on the value of the compatible property, this routine will attempt
  to choose an appropriate modalias value for a particular device tree node.
  It does this by stripping the manufacturer prefix (as delimited by a ',')
  from the first entry in the compatible list property.
  Return: This routine returns 0 on success, <0 on failure.
  of_find_node_by_phandle - Find a node given a phandle
  @handle:	phandle of the node to find
  Return: A node pointer with refcount incremented, use
  of_node_put() on it when done.
	
	  one of cell_count or cells_name must be provided to determine the
	  argument length.
 If phandle is 0, then it is an empty entry with no arguments. 
		
		  Find the provider node and parse the #-cells property to
		  determine the argument length.
				
				  If both cell_count and cells_name is given,
				  fall back to cell_count in absence
				  of the cells_name property
		
		  Make sure that the arguments actually fit in the remaining
		  property data length
 Loop over the phandles until all the requested entry is found 
		
		  All of the error cases bail out of the loop, so at
		  this point, the parsing is successful. If the requested
		  index matches, then fill the out_args structure and return,
		  or return -ENOENT for an empty entry.
 Found it! return success 
	
	  Unlock node before returning result; will be one of:
	  -ENOENT : index is for empty phandle
	  -EINVAL : parsing error on data
  of_parse_phandle - Resolve a phandle property to a device_node pointer
  @np: Pointer to device node holding phandle property
  @phandle_name: Name of property holding a phandle value
  @index: For properties holding a table of phandles, this is the index into
          the table
  Return: The device_node pointer with refcount incremented.  Use
  of_node_put() on it when done.
  of_parse_phandle_with_args() - Find a node pointed by phandle in a list
  @np:		pointer to a device tree node containing a list
  @list_name:	property name that contains a list
  @cells_name:	property name that specifies phandles' arguments count
  @index:	index of a phandle to parse out
  @out_args:	optional pointer to output arguments structure (will be filled)
  This function is useful to parse lists of phandles and their arguments.
  Returns 0 on success and fills out_args, on error returns appropriate
  errno value.
  Caller is responsible to call of_node_put() on the returned out_args->np
  pointer.
  Example::
   phandle1: node1 {
 	#list-cells = <2>;
   };
   phandle2: node2 {
 	#list-cells = <1>;
   };
   node3 {
 	list = <&phandle1 1 2 &phandle2 3>;
   };
  To get a device_node of the ``node2`` node you may call this:
  of_parse_phandle_with_args(node3, "list", "#list-cells", 1, &args);
 If cells_name is NULL we assume a cell count of 0 
  of_parse_phandle_with_args_map() - Find a node pointed by phandle in a list and remap it
  @np:		pointer to a device tree node containing a list
  @list_name:	property name that contains a list
  @stem_name:	stem of property names that specify phandles' arguments count
  @index:	index of a phandle to parse out
  @out_args:	optional pointer to output arguments structure (will be filled)
  This function is useful to parse lists of phandles and their arguments.
  Returns 0 on success and fills out_args, on error returns appropriate errno
  value. The difference between this function and of_parse_phandle_with_args()
  is that this API remaps a phandle if the node the phandle points to has
  a <@stem_name>-map property.
  Caller is responsible to call of_node_put() on the returned out_args->np
  pointer.
  Example::
   phandle1: node1 {
   	#list-cells = <2>;
   };
   phandle2: node2 {
   	#list-cells = <1>;
   };
   phandle3: node3 {
   	#list-cells = <1>;
   	list-map = <0 &phandle2 3>,
   		   <1 &phandle2 2>,
   		   <2 &phandle1 5 1>;
   	list-map-mask = <0x3>;
   };
   node4 {
   	list = <&phandle1 1 2 &phandle3 0>;
   };
  To get a device_node of the ``node2`` node you may call this:
  of_parse_phandle_with_args(node4, "list", "list", 1, &args);
 Get the #<list>-cells property 
 Precalculate the match array - this simplifies match loop 
 Get the <list>-map property 
 Get the <list>-map-mask property (optional) 
 Iterate through <list>-map property 
 Compare specifiers 
 Check if not found 
 Check for malformed properties 
 Move forward by new node's #<list>-cells amount 
 Get the <list>-map-pass-thru property (optional) 
		
		  Successfully parsed a <list>-map translation; copy new
		  specifier into the out_args structure, keeping the
		  bits specified in <list>-map-pass-thru.
 Iterate again with new provider 
  of_parse_phandle_with_fixed_args() - Find a node pointed by phandle in a list
  @np:		pointer to a device tree node containing a list
  @list_name:	property name that contains a list
  @cell_count: number of argument cells following the phandle
  @index:	index of a phandle to parse out
  @out_args:	optional pointer to output arguments structure (will be filled)
  This function is useful to parse lists of phandles and their arguments.
  Returns 0 on success and fills out_args, on error returns appropriate
  errno value.
  Caller is responsible to call of_node_put() on the returned out_args->np
  pointer.
  Example::
   phandle1: node1 {
   };
   phandle2: node2 {
   };
   node3 {
   	list = <&phandle1 0 2 &phandle2 2 3>;
   };
  To get a device_node of the ``node2`` node you may call this:
  of_parse_phandle_with_fixed_args(node3, "list", 2, 1, &args);
  of_count_phandle_with_args() - Find the number of phandles references in a property
  @np:		pointer to a device tree node containing a list
  @list_name:	property name that contains a list
  @cells_name:	property name that specifies phandles' arguments count
  Return: The number of phandle + argument tuples within a property. It
  is a typical pattern to encode a list of phandle and variable
  arguments into a single property. The number of arguments is encoded
  by a property in the phandle-target node. For example, a gpios
  property would contain a list of GPIO specifies consisting of a
  phandle and 1 or more arguments. The number of arguments are
  determined by the #gpio-cells property in the node pointed to by the
  phandle.
	
	  If cells_name is NULL we assume a cell count of 0. This makes
	  counting the phandles trivial as each 32bit word in the list is a
	  phandle and no arguments are to consider. So we don't iterate through
	  the list but just use the length to determine the phandle count.
  __of_add_property - Add a property to a node without lock operations
  @np:		Caller's Device Node
  @prop:	Property to add
 duplicate ! don't insert it 
  of_add_property - Add a property to a node
  @np:		Caller's Device Node
  @prop:	Property to add
 found the node 
  of_remove_property - Remove a property from a node.
  @np:		Caller's Device Node
  @prop:	Property to remove
  Note that we don't actually remove it, since we have given out
  who-knows-how-many pointers to the data using get-property.
  Instead we just move the property to the "dead properties"
  list, so it won't be found any more.
 replace the node 
 new node 
  of_update_property - Update a property in a node, if the property does
  not exist, add it.
  Note that we don't actually remove it, since we have given out
  who-knows-how-many pointers to the data using get-property.
  Instead we just move the property to the "dead properties" list,
  and add the new property to the property list
  of_alias_scan - Scan all properties of the 'aliases' node
  @dt_alloc:	An allocator that provides a virtual address to memory
 		for storing the resulting tree
  The function scans all the properties of the 'aliases' node and populates
  the global lookup table with the properties.  It returns the
  number of alias properties found, or an error code in case of failure.
 linux,stdout-path and aliasesstdout are for legacy compatibility 
 Skip those we do not want to proceed 
		 walk the alias backwards to extract the id and work out
 Allocate an alias_prop with enough space for the stem 
  of_alias_get_id - Get alias id for the given device_node
  @np:		Pointer to the given device_node
  @stem:	Alias stem of the given device_node
  The function travels the lookup table to get the alias id for the given
  device_node and alias stem.
  Return: The alias id if found.
  of_alias_get_alias_list - Get alias list for the given device driver
  @matches:	Array of OF device match structures to search in
  @stem:	Alias stem of the given device_node
  @bitmap:	Bitmap field pointer
  @nbits:	Maximum number of alias IDs which can be recorded in bitmap
  The function travels the lookup table to record alias ids for the given
  device match structures and alias stem.
  Return:	0 or -ENOSYS when !CONFIG_OF or
 		-EOVERFLOW if alias ID is greater then allocated nbits
 Zero bitmap field to make sure that all the time it is clean 
  of_alias_get_highest_id - Get highest alias id for the given stem
  @stem:	Alias stem to be examined
  The function travels the lookup table to get the highest alias id for the
  given alias stem.  It returns the alias id if found.
  of_console_check() - Test and setup console for DT setup
  @dn: Pointer to device node
  @name: Name to use for preferred console without index. ex. "ttyS"
  @index: Index to use for preferred console.
  Check if the given device node matches the stdout-path property in the
  chosen node. If it does then register it as the preferred console.
  Return: TRUE if console successfully setup. Otherwise return FALSE.
	
	  XXX: cast `options' to char pointer to suppress complication
	  warnings: printk, UART and console drivers expect char pointer.
  of_find_next_cache_node - Find a node's subsidiary cache
  @np:	node of type "cpu" or "cache"
  Return: A node pointer with refcount incremented, use
  of_node_put() on it when done.  Caller should hold a reference
  to np.
	 OF on pmac has nodes instead of properties named "l2-cache"
	  beneath CPU nodes.
  of_find_last_cache_level - Find the level at which the last cache is
  		present for the given logical cpu
  @cpu: cpu number(logical index) for which the last cache level is needed
  Return: The the level at which the last cache is present. It is exactly
  same as  the total number of cache levels for the given logical cpu.
  of_map_id - Translate an ID through a downstream mapping.
  @np: root complex device node.
  @id: device ID to map.
  @map_name: property name of the map to use.
  @map_mask_name: optional property name of the mask to use.
  @target: optional pointer to a target device node.
  @id_out: optional pointer to receive the translated ID.
  Given a device ID, look up the appropriate implementation-defined
  platform ID andor the target device which receives transactions on that
  ID, as per the "iommu-map" and "msi-map" bindings. Either of @target or
  @id_out may be NULL if only the other is required. If @target points to
  a non-NULL device node pointer, only entries targeting that node will be
  matched; if it points to a NULL value, it will receive the device node of
  the first matching target phandle, with a reference held.
  Return: 0 on success or a standard error code on failure.
 Otherwise, no map implies no translation 
 The default is to select all bits. 
	
	  Can be overridden by "{iommu,msi}-map-mask" property.
	  If of_property_read_u32() fails, the default is used.
 Bypasses translation 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2020 Arm Limited
  Based on archarm64kernelmachine_kexec_file.c:
   Copyright (C) 2018 Linaro Limited
  And archpowerpckexecfile_load.c:
   Copyright (C) 2016  IBM Corporation
  Additional space needed for the FDT buffer so that we can add initrd,
  bootargs, kaslr-seed, rng-seed, useable-memory-range and elfcorehdr.
  fdt_find_and_del_mem_rsv - delete memory reservation with given address and size
  @fdt:	Flattened device tree for the current kernel.
  @start:	Starting address of the reserved memory.
  @size:	Size of the reserved memory.
  Return: 0 on success, or negative errno on error.
  get_addr_size_cells - Get address and size of root node
  @addr_cells: Return address of the root node
  @size_cells: Return size of the root node
  Return: 0 on success, or negative errno on error.
  do_get_kexec_buffer - Get address and size of device tree property
  @prop: Device tree property
  @len: Size of @prop
  @addr: Return address of the node
  @size: Return size of the node
  Return: 0 on success, or negative errno on error.
  ima_get_kexec_buffer - get IMA buffer from the previous kernel
  @addr:	On successful return, set to point to the buffer contents.
  @size:	On successful return, set to the buffer size.
  Return: 0 on success, negative errno on error.
  ima_free_kexec_buffer - free memory used by the IMA buffer
  remove_ima_buffer - remove the IMA buffer property and reservation from @fdt
  @fdt: Flattened Device Tree to update
  @chosen_node: Offset to the chosen node in the device tree
  The IMA measurement buffer is of no use to a subsequent kernel, so we always
  remove it from the device tree.
  setup_ima_buffer - add IMA buffer information to the fdt
  @image:		kexec image being loaded.
  @fdt:		Flattened device tree for the next kernel.
  @chosen_node:	Offset to the chosen node.
  Return: 0 on success, or negative errno on error.
 CONFIG_IMA_KEXEC 
 CONFIG_IMA_KEXEC 
  of_kexec_alloc_and_setup_fdt - Alloc and setup a new Flattened Device Tree
  @image:		kexec image being loaded.
  @initrd_load_addr:	Address where the next initrd will be loaded.
  @initrd_len:		Size of the next initrd, or 0 if there will be none.
  @cmdline:		Command line for the next kernel, or NULL if there will
 			be none.
  @extra_fdt_size:	Additional size for the new FDT buffer.
  Return: fdt on success, or NULL errno on error.
 Remove memory reservation for the current device tree. 
 Did we boot using an initrd? 
		
		  kexec reserves exact initrd size, while firmware may
		  reserve a multiple of PAGE_SIZE, so check for both.
 add initrd- 
 add linux,elfcorehdr 
		
		  Avoid elfcorehdr from being stomped on in kdump kernel by
		  setting up memory reserve map.
 add linux,usable-memory-range 
 add bootargs 
 add kaslr-seed 
 add rng-seed 
 SPDX-License-Identifier: GPL-2.0
  OF NUMA Parsing support.
  Copyright (C) 2015 - 2016 Cavium Inc.
 define default numa node to 0 
  Even though we connect cpus to numa domains later in SMP
  init, we need to know the node ids now for all cpus.
			
			  property doesn't exist if -EINVAL, continue
			  looking for more memory nodes with
			  "numa-node-id" property
 Set default distance of node B->A same as A->B 
		
		  -EINVAL indicates the property was not found, and
		   we walk up the tree trying to find a parent with a
		   "numa-node-id".  Any other type of error indicates
		   a bad device tree and we give up.
	
	  If numa=off passed on command line, or with a defective
	  device tree, the nid may not be in the set of possible
	  nodes.  Check for this case and return NUMA_NO_NODE.
 SPDX-License-Identifier: GPL-2.0
  Functions for dealing with DT resolution
  Copyright (C) 2012 Pantelis Antoniou <panto@antoniou-consulting.com>
  Copyright (C) 2012 Texas Instruments Inc.
 adjust node's phandle in node 
 copy adjusted phandle into phandle properties 
 prop_fixup contains a list of tuples of path:property_name:offset 
 compare nodes taking into account that 'name' strips out the @ part 
  Adjust the local phandle references by the given phandle delta.
  Subtree @local_fixups, which is overlay node __local_fixups__,
  mirrors the fragment node structure at the root of the overlay.
  For each property in the fragments that contains a phandle reference,
  @local_fixups has a property of the same name that contains a list
  of offsets of the phandle reference(s) within the respective property
  value(s).  The values at these offsets will be fixed up.
 skip properties added automatically 
	
	  These nested loops recurse down two subtrees in parallel, where the
	  node names in the two subtrees match.
	 
	  The roots of the subtrees are the overlay's __local_fixups__ node
	  and the overlay's root node.
  of_resolve_phandles - Relocate and resolve overlay against live tree
  @overlay:	Pointer to devicetree overlay to relocate and resolve
  Modify (relocate) values of local phandles in @overlay to a range that
  does not conflict with the live expanded devicetree.  Update references
  to the local phandles in @overlay.  Update (resolve) phandle references
  in @overlay that refer to the live expanded devicetree.
  Phandle values in the live tree are in the range of
  1 .. live_tree_max_phandle().  The range of phandle values in the overlay
  also begin with at 1.  Adjust the phandle values in the overlay to begin
  at live_tree_max_phandle() + 1.  Update references to the phandles to
  the adjusted phandle values.
  The name of each property in the "__fixups__" node in the overlay matches
  the name of a symbol (a label) in the live tree.  The values of each
  property in the "__fixups__" node is a list of the property values in the
  overlay that need to be updated to contain the phandle reference
  corresponding to that symbol in the live tree.  Update the references in
  the overlay with the phandle values in the live tree.
  @overlay must be detached.
  Resolving and applying @overlay to the live expanded devicetree must be
  protected by a mechanism to ensure that multiple overlays are processed
  in a single threaded manner so that multiple overlays will not relocate
  phandles to overlapping ranges.  The mechanism to enforce this is not
  yet implemented.
  Return: %0 on success or a negative error value on error.
 skip properties added automatically 
 SPDX-License-Identifier: GPL-2.0+
 pdt.c: OF PROM device tree support code.
  Paul Mackerras	August 1996.
  Copyright (C) 1996-2005 Paul Mackerras.
   Adapted for 64bit PowerPC by Dave Engebretsen and Peter Bergner.
     {engebret|bergner}@us.ibm.com
   Adapted for sparc by David S. Miller davem@davemloft.net
   Adapted for multiple architectures by Andres Salomon <dilinger@queued.net>
 CONFIG_SPARC 
 for generating unique names on failure 
 !CONFIG_SPARC 
 Get pointer to "chosen" and "aliases" nodes for use everywhere 
 SPDX-License-Identifier: GPL-2.0+
     Copyright (C) 2006 Benjamin Herrenschmidt, IBM Corp.
 			 <benh@kernel.crashing.org>
     and		 Arnd Bergmann, IBM Corp.
     Merged from powerpckernelof_platform.c and
     sparc{,64}kernelof_device.c by Stephen Rothwell
 CONFIG_ARM_AMBA 
 Empty terminated list 
 Empty terminated list 
  of_find_device_by_node - Find the platform_device associated with a node
  @np: Pointer to device tree node
  Takes a reference to the embedded struct device which needs to be dropped
  after use.
  Return: platform_device pointer, or NULL if not found
  The following routines scan a subtree and registers a device for
  each applicable node.
  Note: sparc doesn't use these routines because it has a different
  mechanism for creating devices from device tree nodes.
  of_device_make_bus_id - Use the device node data to assign a unique name
  @dev: pointer to device structure that is linked to a device tree node
  This routine will first try using the translated bus address to
  derive a unique name. If it cannot, then it will prepend names from
  parent nodes until a unique name can be derived.
 Construct the name, using parent nodes if necessary to ensure uniqueness 
		
		  If the address can be translated, then that is as much
		  uniqueness as we need. Make it the first component and return
 format arguments only used if dev_name() resolves to NULL 
  of_device_alloc - Allocate and initialize an of_device
  @np: device node to assign to device
  @bus_id: Name to assign to the device.  May be null to use default name.
  @parent: Parent device.
 count the io and irq resources 
 Populate the resource table 
  of_platform_device_create_pdata - Alloc, initialize and register an of_device
  @np: pointer to node to create device for
  @bus_id: name to assign device
  @platform_data: pointer to populate platform_data pointer with
  @parent: Linux device model parent device.
  Return: Pointer to created platform device, or NULL if a device was not
  registered.  Unavailable devices will not get registered.
  of_platform_device_create - Alloc, initialize and register an of_device
  @np: pointer to node to create device for
  @bus_id: name to assign device
  @parent: Linux device model parent device.
  Return: Pointer to created platform device, or NULL if a device was not
  registered.  Unavailable devices will not get registered.
 AMBA devices only support a single DMA mask 
 setup generic device info 
 Allow the HW Peripheral ID to be overridden 
 CONFIG_ARM_AMBA 
 CONFIG_ARM_AMBA 
  of_dev_lookup() - Given a device node, lookup the preferred Linux name
 Try compatible match if no phys_addr and name are specified 
  of_platform_bus_create() - Create a device for a node and its children.
  @bus: device node of the bus to instantiate
  @matches: match table for bus nodes
  @lookup: auxdata table for matching id and platform_data with device nodes
  @parent: parent for new device, or NULL for top level.
  @strict: require compatible property
  Creates a platform_device for the provided device_node, and optionally
  recursively create devices for all the child nodes.
 Make sure it has a compatible property 
 Skip nodes for which we don't want to create devices 
		
		  Don't return an error here to keep compatibility with older
		  device tree files.
  of_platform_bus_probe() - Probe the device-tree for platform buses
  @root: parent of the first level to probe or NULL for the root of the tree
  @matches: match table for bus nodes
  @parent: parent to hook devices from, NULL for toplevel
  Note that children of the provided root are not instantiated as devices
  unless the specified root itself matches the bus list and is not NULL.
 Do a self check of bus type, if there's a match, create children 
  of_platform_populate() - Populate platform_devices from device tree data
  @root: parent of the first level to probe or NULL for the root of the tree
  @matches: match table, NULL to use the default
  @lookup: auxdata table for matching id and platform_data with device nodes
  @parent: parent to hook devices from, NULL for toplevel
  Similar to of_platform_bus_probe(), this function walks the device tree
  and creates devices from nodes.  It differs in that it follows the modern
  convention of requiring all device nodes to have a 'compatible' property,
  and it is suitable for creating devices which are children of the root
  node (of_platform_bus_probe will only create children of the root which
  are selected by the @matches argument).
  New board support should be using this function instead of
  of_platform_bus_probe().
  Return: 0 on success, < 0 on failure.
	
	  Handle certain compatibles explicitly, since we don't want to create
	  platform_devices for every node in reserved-memory with a
	  "compatible",
 Populate everything else. 
 Do not touch devices not populated from the device tree 
 Recurse for any nodes that were treated as busses 
  of_platform_depopulate() - Remove devices populated from device tree
  @parent: device which children will be removed
  Complementary to of_platform_populate(), this function removes children
  of the given device (and, recurrently, their children) that have been
  created from their respective device tree nodes (and only those,
  leaving others - eg. manually created - unharmed).
  devm_of_platform_populate() - Populate platform_devices from device tree data
  @dev: device that requested to populate from device tree data
  Similar to of_platform_populate(), but will automatically call
  of_platform_depopulate() when the device is unbound from the bus.
  Return: 0 on success, < 0 on failure.
  devm_of_platform_depopulate() - Remove devices populated from device tree
  @dev: device that requested to depopulate from device tree data
  Complementary to devm_of_platform_populate(), this function removes children
  of the given device (and, recurrently, their children) that have been
  created from their respective device tree nodes (and only those,
  leaving others - eg. manually created - unharmed).
 verify that the parent is a bus 
 not for us 
 already populated? (driver using of_populate manually) 
 pdev_parent may be NULL when no bus platform device 
 of_platform_device_create tosses the error code 
 already depopulated? 
 find our device by node 
 no? not meant for us 
 unregister takes one ref away 
 and put the reference of the find 
 CONFIG_OF_DYNAMIC 
 CONFIG_OF_ADDRESS 
 SPDX-License-Identifier: GPL-2.0+
  FDT Address translation based on u-boot fdt_support.c which in turn was
  based on the kernel unflattened DT address translation code.
  (C) Copyright 2007
  Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com
  Copyright 2010-2011 Freescale Semiconductor, Inc.
 Max address size we deal with 
 Debug utility 
 Callbacks for bus specific translators 
 Default translator (generic bus) 
 Array of bus specific translators 
 Default 
 Now walk through the ranges 
 Translate it into parent bus space 
  Translate an address from the device-tree into a CPU physical address,
  this walks up the tree and applies the various bus mappings on the
  way.
  Note: We consider that crossing any level with #size-cells == 0 to mean
  that translation is impossible (that is we are not dealing with a value
  that can be mapped to a cpu physical address). This is not really specified
  that way, but this is traditionally the way IBM at least do things
 Get parent & match bus type 
 Cound address cells & copy address locally 
 Translate 
 Switch to parent bus 
 If root, we have finished 
 Get new parent bus and counts 
 Apply bus translation 
 Complete the move up one level 
  of_flat_dt_translate_address - translate DT addr into CPU phys addr
  @node: node in the flat blob
 SPDX-License-Identifier: GPL-2.0
 for bus_dma_region 
  of_match_device - Tell if a struct device matches an of_device_id list
  @matches: array of of device match structures to search in
  @dev: the of device structure to match against
  Used by a driver to check whether an platform_device present in the
  system is in its list of supported devices.
	 name and id have to be set so that the platform bus doesn't get
	
	  If this device has not binding numa node in devicetree, that is
	  of_node_to_nid returns NUMA_NO_NODE. device_add will assume that this
	  device is on the same node as the parent.
	
	  If dev->of_node doesn't exist or doesn't contain memory-region, try
	  the OF node having DMA configuration.
		
		  There might be multiple memory regions, but only one
		  restricted-dma-pool region is allowed.
	
	  Attempt to initialize a restricted-dma-pool region if one was found.
	  Note that count can hold a negative error code.
  of_dma_configure_id - Setup DMA configuration
  @dev:	Device to apply DMA configuration
  @np:		Pointer to OF node having DMA configuration
  @force_dma:  Whether device is to be set up by of_dma_configure() even if
 		DMA capability is not explicitly described by firmware.
  @id:		Optional const pointer value input id
  Try to get devices's DMA configuration from DT and update it
  accordingly.
  If platform code needs to use its own special DMA configuration, it
  can use a platform bus notifier and handle BUS_NOTIFY_ADD_DEVICE events
  to fix up DMA configuration.
		
		  For legacy reasons, we have to assume some devices need
		  DMA configuration regardless of whether "dma-ranges" is
		  correctly specified or not.
 Determine the overall bounds of all DMA regions 
 Take lower and upper limits 
		
		  Add a work around to treat the size as mask + 1 in case
		  it is defined in DT as a mask.
	
	  If @dev is expected to be DMA-capable then the bus code that created
	  it should have initialised its dma_mask pointer by this point. For
	  now, we'll continue the legacy behaviour of coercing it to the
	  coherent mask if not, but we'll no longer do so quietly.
	
	  Limit coherent and dma mask based on size and default mask
	  set by the driver.
 ...but only set bus limit and range map if we found valid dma-ranges earlier 
 Don't touch range map if it wasn't set from a valid dma-ranges 
 Name & Type 
 %p eats all alphanum characters, so %c must be used here 
  of_device_modalias - Fill buffer with newline terminated modalias string
  @dev:	Calling device
  @str:	Modalias string
  @len:	Size of @str
  of_device_uevent - Display OF related uevent information
  @dev:	Device to apply DMA configuration
  @env:	Kernel object's userspace event reference
	 Since the compatible field can contain pretty much anything
	  it's not really legal to split it out with commas. We split it
 Devicetree modalias is tricky, we add it in 2 steps 
 SPDX-License-Identifier: GPL-2.0
  Functions for working with device tree overlays
  Copyright (C) 2012 Pantelis Antoniou <panto@antoniou-consulting.com>
  Copyright (C) 2012 Texas Instruments Inc.
  struct target - info about current target node as recursing through overlay
  @np:			node where current level of overlay will be applied
  @in_livetree:	@np is a node in the live devicetree
  Used in the algorithm to create the portion of a changeset that describes
  an overlay fragment, which is a devicetree subtree.  Initially @np is a node
  in the live devicetree where the overlay subtree is targeted to be grafted
  into.  When recursing to the next level of the overlay subtree, the target
  also recurses to the next level of the live devicetree, as long as overlay
  subtree node also exists in the live devicetree.  When a node in the overlay
  subtree does not exist at the same level in the live devicetree, target->np
  points to a newly allocated node, and all subsequent targets in the subtree
  will be newly allocated nodes.
  struct fragment - info about fragment nodes in overlay expanded device tree
  @target:	target of the overlay operation
  @overlay:	pointer to the __overlay__ node
  struct overlay_changeset
  @id:			changeset identifier
  @ovcs_list:		list on which we are located
  @fdt:		base of memory allocated to hold aligned FDT that was unflattened to create @overlay_tree
  @overlay_tree:	expanded device tree that contains the fragment nodes
  @count:		count of fragment structures
  @fragments:		fragment nodes in the overlay expanded device tree
  @symbols_fragment:	last element of @fragments[] is the  __symbols__ node
  @cset:		changeset to apply fragments to live device tree
 flags are sticky - once set, do not reset 
  If a changeset apply or revert encounters an error, an attempt will
  be made to undo partial changes, but may fail.  If the undo fails
  we do not know the state of the devicetree.
  of_resolve_phandles() finds the largest phandle in the live tree.
  of_overlay_apply() may add a larger phandle to the live tree.
  Do not allow race between two overlays being applied simultaneously:
     mutex_lock(&of_overlay_phandle_mutex)
     of_resolve_phandles()
     of_overlay_apply()
     mutex_unlock(&of_overlay_phandle_mutex)
  of_overlay_notifier_register() - Register notifier for overlay operations
  @nb:		Notifier block to register
  Register for notification on overlay operations on device tree nodes. The
  reported actions definied by @of_reconfig_change. The notifier callback
  furthermore receives a pointer to the affected device tree node.
  Note that a notifier callback is not supposed to store pointers to a device
  tree node or its content beyond @OF_OVERLAY_POST_REMOVE corresponding to the
  respective node it received.
  of_overlay_notifier_unregister() - Unregister notifier for overlay operations
  @nb:		Notifier block to unregister
  The values of properties in the "__symbols__" node are paths in
  the ovcs->overlay_tree.  When duplicating the properties, the paths
  need to be adjusted to be the correct path for the live device tree.
  The paths refer to a node in the subtree of a fragment node's "__overlay__"
  node, for example "fragment@0__overlay__symbol_path_tail",
  where symbol_path_tail can be a single node or it may be a multi-node path.
  The duplicated property value will be modified by replacing the
  "fragment_name__overlay" portion of the value  with the target
  path from the fragment node.
  add_changeset_property() - add @overlay_prop to overlay changeset
  @ovcs:		overlay changeset
  @target:		where @overlay_prop will be placed
  @overlay_prop:	property to add or update, from overlay tree
  @is_symbols_prop:	1 if @overlay_prop is from node "__symbols__"
  If @overlay_prop does not already exist in live devicetree, add changeset
  entry to add @overlay_prop in @target, else add changeset entry to update
  value of @overlay_prop.
  @target may be either in the live devicetree or in a new subtree that
  is contained in the changeset.
  Some special properties are not added or updated (no error returned):
  "name", "phandle", "linux,phandle".
  Properties "#address-cells" and "#size-cells" are not updated if they
  are already in the live tree, but if present in the live tree, the values
  in the overlay must match the values in the live tree.
  Update of property in symbols node is not allowed.
  Return: 0 on success, -ENOMEM if memory allocation failure, or -EINVAL if
  invalid @overlay.
  add_changeset_node() - add @node (and children) to overlay changeset
  @ovcs:	overlay changeset
  @target:	where @node will be placed in live tree or changeset
  @node:	node from within overlay device tree fragment
  If @node does not already exist in @target, add changeset entry
  to add @node in @target.
  If @node already exists in @target, and the existing node has
  a phandle, the overlay node is not allowed to have a phandle.
  If @node has child nodes, add the children recursively via
  build_changeset_next_level().
  NOTE_1: A live devicetree created from a flattened device tree (FDT) will
        not contain the full path in node->full_name.  Thus an overlay
        created from an FDT also will not contain the full path in
        node->full_name.  However, a live devicetree created from Open
        Firmware may have the full path in node->full_name.
        add_changeset_node() follows the FDT convention and does not include
        the full path in node->full_name.  Even though it expects the overlay
        to not contain the full path, it uses kbasename() to remove the
        full path should it exist.  It also uses kbasename() in comparisons
        to nodes in the live devicetree so that it can apply an overlay to
        a live devicetree created from Open Firmware.
  NOTE_2: Multiple mods of created nodes not supported.
  Return: 0 on success, -ENOMEM if memory allocation failure, or -EINVAL if
  invalid @overlay.
 ignore obsolete "linux,phandle" 
  build_changeset_next_level() - add level of overlay changeset
  @ovcs:		overlay changeset
  @target:		where to place @overlay_node in live tree
  @overlay_node:	node from within an overlay device tree fragment
  Add the properties (if any) and nodes (if any) from @overlay_node to the
  @ovcs->cset changeset.  If an added node has child nodes, they will
  be added recursively.
  Do not allow symbols node to have any children.
  Return: 0 on success, -ENOMEM if memory allocation failure, or -EINVAL if
  invalid @overlay_node.
  Add the properties from __overlay__ node to the @ovcs->cset changeset.
  changeset_dup_entry_check() - check for duplicate entries
  @ovcs:	Overlay changeset
  Check changeset @ovcs->cset for multiple {add or delete} node entries for
  the same node or duplicate {add, delete, or update} properties entries
  for the same property.
  Return: 0 on success, or -EINVAL if duplicate changeset entry found.
  build_changeset() - populate overlay changeset in @ovcs from @ovcs->fragments
  @ovcs:	Overlay changeset
  Create changeset @ovcs->cset to contain the nodes and properties of the
  overlay device tree fragments in @ovcs->fragments[].  If an error occurs,
  any portions of the changeset that were successfully created will remain
  in @ovcs->cset.
  Return: 0 on success, -ENOMEM if memory allocation failure, or -EINVAL if
  invalid overlay in @ovcs->fragments[].
	
	  if there is a symbols fragment in ovcs->fragments[i] it is
	  the final element in the array
  Find the target node using a number of different strategies
  in order of preference:
  1) "target" property containing the phandle of the target
  2) "target-path" property containing the path of the target
  init_overlay_changeset() - initialize overlay changeset from overlay tree
  @ovcs:	Overlay changeset to build
  @fdt:	base of memory allocated to hold aligned FDT that was unflattened to create @tree
  @tree:	Contains the overlay fragments and overlay fixup nodes
  Initialize @ovcs.  Populate @ovcs->fragments with node information from
  the top level of @tree.  The relevant top level nodes are the fragment
  nodes and the __symbols__ node.  Any other top level node will be ignored.
  Return: 0 on success, -ENOMEM if memory allocation failure, -EINVAL if error
  detected in @tree, or -ENOSPC if idr_alloc() error.
	
	  Warn for some issues.  Can not return -EINVAL for these until
	  of_unittest_apply_overlay() is fixed to pass these checks.
 fragment nodes 
	
	  if there is a symbols fragment in ovcs->fragments[i] it is
	  the final element in the array
	
	  There should be no live pointers into ovcs->overlay_tree and
	  ovcs->fdt due to the policy that overlay notifiers are not allowed
	  to retain pointers into the overlay devicetree.
  internal documentation
  of_overlay_apply() - Create and apply an overlay changeset
  @fdt:	base of memory allocated to hold the aligned FDT
  @tree:	Expanded overlay device tree
  @ovcs_id:	Pointer to overlay changeset id
  Creates and applies an overlay changeset.
  If an error occurs in a pre-apply notifier, then no changes are made
  to the device tree.
  A non-zero return value will not have created the changeset if error is from:
    - parameter checks
    - building the changeset
    - overlay changeset pre-apply notifier
  If an error is returned by an overlay changeset pre-apply notifier
  then no further overlay changeset pre-apply notifier will be called.
  A non-zero return value will have created the changeset if error is from:
    - overlay changeset entry notifier
    - overlay changeset post-apply notifier
  If an error is returned by an overlay changeset post-apply notifier
  then no further overlay changeset post-apply notifier will be called.
  If more than one notifier returns an error, then the last notifier
  error to occur is returned.
  If an error occurred while applying the overlay changeset, then an
  attempt is made to revert any changes that were made to the
  device tree.  If there were any errors during the revert attempt
  then the state of the device tree can not be determined, and any
  following attempt to apply or remove an overlay changeset will be
  refused.
  Returns 0 on success, or a negative error number.  Overlay changeset
  id is returned to ovcs_id.
	
	  As of this point, fdt and tree belong to the overlay changeset.
	  overlay changeset code is responsible for freeing them.
	
	  after overlay_notify(), ovcs->overlay_tree related pointers may have
	  leaked to drivers, so can not kfree() tree, aka ovcs->overlay_tree;
	  and can not free memory containing aligned fdt.  The aligned fdt
	  is contained within the memory at ovcs->fdt, possibly at an offset
	  from ovcs->fdt.
 notify failure is not fatal, continue 
	
	  Must create permanent copy of FDT because of_fdt_unflatten_tree()
	  will create pointers to the passed in FDT in the unflattened tree.
		
		  new_fdt and overlay_root now belong to the overlay
		  changeset.
		  overlay changeset code is responsible for freeing them.
  Find @np in @tree.
  Returns 1 if @np is @tree or is contained in @tree, else 0
  Is @remove_ce_node a child of, a parent of, or the same as any
  node in an overlay changeset more topmost than @remove_ovcs?
  Returns 1 if found, else 0
  We can safely remove the overlay only if it's the top-most one.
  Newly applied overlays are inserted at the tail of the overlay list,
  so a top most overlay is the one that is closest to the tail.
  The topmost check is done by exploiting this property. For each
  affected device node in the log list we check if this overlay is
  the one closest to the tail. If another overlay has affected this
  device node and is closest to the tail, then removal is not permited.
  of_overlay_remove() - Revert and free an overlay changeset
  @ovcs_id:	Pointer to overlay changeset id
  Removes an overlay if it is permissible.  @ovcs_id was previously returned
  by of_overlay_fdt_apply().
  If an error occurred while attempting to revert the overlay changeset,
  then an attempt is made to re-apply any changeset entry that was
  reverted.  If an error occurs on re-apply then the state of the device
  tree can not be determined, and any following attempt to apply or remove
  an overlay changeset will be refused.
  A non-zero return value will not revert the changeset if error is from:
    - parameter checks
    - overlay changeset pre-remove notifier
    - overlay changeset entry revert
  If an error is returned by an overlay changeset pre-remove notifier
  then no further overlay changeset pre-remove notifier will be called.
  If more than one notifier returns an error, then the last notifier
  error to occur is returned.
  A non-zero return value will revert the changeset if error is from:
    - overlay changeset entry notifier
    - overlay changeset post-remove notifier
  If an error is returned by an overlay changeset post-remove notifier
  then no further overlay changeset post-remove notifier will be called.
  Return: 0 on success, or a negative error number.  @ovcs_id is set to
  zero after reverting the changeset, even if a subsequent error occurs.
 notify failure is not fatal, continue 
  of_overlay_remove_all() - Reverts and frees all overlay changesets
  Removes all overlays from the system in the correct order.
  Return: 0 on success, or a negative error number
 the tail of list is guaranteed to be safe to remove 
 SPDX-License-Identifier: GPL-2.0
 for bus_dma_region 
 Max address size we deal with 
 Debug utility 
 Callbacks for bus specific translators 
  Default translator (generic bus)
 32 bits 
 64 bits 
  PCI bus specific translator
	
 	  "pciex" is PCI Express
	  "vci" is for the chaos bridge on 1st-gen PCI powermacs
	  "ht" is hypertransport
	 
	  If none of the device_type match, and that the node name is
	  "pcie", accept the device as PCI (with a warning).
 Check address type match 
 Read address values, skipping high cell 
 CONFIG_PCI 
  of_pci_range_to_resource - Create a resource from an of_pci_range
  @range:	the PCI range that describes the resource
  @np:		device node where the range belongs to
  @res:	pointer to a valid resource that will be updated to
               reflect the values contained in the range.
  Returns EINVAL if the range cannot be converted to resource.
  Note that if the range is an IO range, the resource will be converted
  using pci_address_to_pio() which can fail if it is called too early or
  if the range cannot be matched to any host bridge IO space (our case here).
  To guard against that we try to register the IO range first.
  If that fails we know that pci_address_to_pio() will do too.
  ISA bus specific translator
 Check address type match 
 Read address values, skipping high cell 
  Array of bus specific translators
 PCI 
 CONFIG_PCI 
 ISA 
 Default 
 To save cycles, we cache the result for global "Mac" setting 
 PA-SEMI sdc DT bug 
 Make quirk cached 
	
	  Normally, an absence of a "ranges" property means we are
	  crossing a non-translatable boundary, and thus the addresses
	  below the current cannot be converted to CPU physical ones.
	  Unfortunately, while this is very clear in the spec, it's not
	  what Apple understood, and they do have things like uni-n or
	  ht nodes with no "ranges" property and a lot of perfectly
	  useable mapped devices below them. Thus we treat the absence of
	  "ranges" as equivalent to an empty "ranges" property which means
	  a 1:1 translation at that level. It's up to the caller not to try
	  to translate addresses that aren't supposed to be translated in
	  the first place. --BenH.
	 
	  As far as we know, this damage only exists on Apple machines, so
	  This code is only enabled on powerpc. --gcl
	 
	  This quirk also applies for 'dma-ranges' which frequently exist in
	  child nodes without 'dma-ranges' in the parent nodes. --RobH
 Now walk through the ranges 
 Translate it into parent bus space 
  Translate an address from the device-tree into a CPU physical address,
  this walks up the tree and applies the various bus mappings on the
  way.
  Note: We consider that crossing any level with #size-cells == 0 to mean
  that translation is impossible (that is we are not dealing with a value
  that can be mapped to a cpu physical address). This is not really specified
  that way, but this is traditionally the way IBM at least do things
  Whenever the translation fails, the host pointer will be set to the
  device that had registered logical PIO mapping, and the return code is
  relative to that node.
 Increase refcount at current level 
 Get parent & match bus type 
 Count address cells & copy address locally 
 Translate 
 Switch to parent bus 
 If root, we have finished 
		
		  For indirectIO device which has no ranges property, get
		  the address from reg directly.
 Get new parent bus and counts 
 Apply bus translation 
 Complete the move up one level 
 Get parent & match bus type 
 Get "reg" or "assigned-addresses" property 
 PCI bus matches on BAR number instead of index 
 A extra cell for resource flags 
 Now consume following elements while they are contiguous 
 host-specific port access 
 memory-mapped IO range 
 Get optional "reg-names" property to add a name to a resource 
  of_address_to_resource - Translate device tree address and return as resource
  @dev:	Caller's Device Node
  @index:	Index into the array
  @r:		Pointer to resource array
  Note that if your address is a PIO address, the conversion will fail if
  the physical address can't be internally converted to an IO token with
  pci_address_to_pio(), that is because it's either called too early or it
  can't be matched to any host bridge IO space
  of_iomap - Maps the memory mapped IO for a given device_node
  @np:		the device whose io range will be mapped
  @index:	index of the io range
  Returns a pointer to the mapped memory
  of_io_request_and_map - Requests a resource and maps the memory mapped IO
 			   for a given device_node
  @device:	the device whose io range will be mapped
  @index:	index of the io range
  @name:	name "override" for the memory region request or NULL
  Returns a pointer to the requested and mapped memory or an ERR_PTR() encoded
  error code on failure. Usage example:
 	base = of_io_request_and_map(node, 0, "foo");
 	if (IS_ERR(base))
 		return PTR_ERR(base);
  of_dma_get_range - Get DMA range info and put it into a map array
  @np:		device node to get DMA range info
  @map:	dma range structure to return
  Look in bottom up direction for the first "dma-ranges" property
  and parse it.  Put the information into a DMA offset map array.
  dma-ranges format:
 	DMA addr (dma_addr)	: naddr cells
 	CPU addr (phys_addr_t)	: pna cells
 	size			: nsize cells
  It returns -ENODEV if "dma-ranges" property was not found for this
  device in the DT.
 Ignore empty ranges, they imply no translation required 
 Once we find 'dma-ranges', then a missing one is an error 
	
	  Record all info in the generic DMA ranges array for struct device.
 CONFIG_HAS_DMA 
  of_dma_get_max_cpu_address - Gets highest CPU address suitable for DMA
  @np: The node to start searching from or NULL to start from the root
  Gets the highest CPU physical address that is addressable by all DMA masters
  in the sub-tree pointed by np, or the whole tree if NULL is passed. If no
  DMA constrained device is found, it returns PHYS_ADDR_MAX.
  of_dma_is_coherent - Check if device is coherent
  @np:	device node
  It returns true if "dma-coherent" property was found
  for this device in the DT, or if DMA is coherent by
  default for OF devices on the current platform.
  of_mmio_is_nonposted - Check if device uses non-posted MMIO
  @np:	device node
  Returns true if the "nonposted-mmio" property was found for
  the device's bus.
  This is currently only enabled on builds that support Apple ARM devices, as
  an optimization.
 SPDX-License-Identifier: GPL-2.0+
  Device tree based initialization code for reserved memory.
  Copyright (c) 2013, 2015 The Linux Foundation. All Rights Reserved.
  Copyright (c) 2013,2014 Samsung Electronics Co., Ltd.
 		http:www.samsung.com
  Author: Marek Szyprowski <m.szyprowski@samsung.com>
  Author: Josh Cartwright <joshc@codeaurora.org>
  fdt_reserved_mem_save_node() - save fdt node for second pass initialization
  __reserved_mem_alloc_size() - allocate reserved memory described by
 	'size', 'alignment'  and 'alloc-ranges' properties.
 Need adjust the alignment to satisfy the CMA requirement 
  __reserved_mem_init_node() - call region specific reserved memory init code
	
	  Put the dynamic allocations (address == 0, size == 0) before static
	  allocations at address 0x0 so that overlap detection works
	  correctly.
  fdt_init_reserved_mem() - allocate and init all saved reserved memory regions
 check for overlapping reserved regions 
  of_reserved_mem_device_init_by_idx() - assign reserved memory region to
 					  given device
  @dev:	Pointer to the device to configure
  @np:		Pointer to the device_node with 'reserved-memory' property
  @idx:	Index of selected region
  This function assigns respective DMA-mapping operations based on reserved
  memory region specified by 'memory-region' property in @np node to the @dev
  device. When driver needs to use more than one reserved memory region, it
  should allocate child devices and initialize regions by name for each of
  child device.
  Returns error code or zero on success.
  of_reserved_mem_device_init_by_name() - assign named reserved memory region
 					   to given device
  @dev: pointer to the device to configure
  @np: pointer to the device node with 'memory-region' property
  @name: name of the selected memory region
  Returns: 0 on success or a negative error-code on failure.
  of_reserved_mem_device_release() - release reserved memory device structures
  @dev:	Pointer to the device to deconfigure
  This function releases structures allocated for memory region handling for
  the given device.
  of_reserved_mem_lookup() - acquire reserved_mem from a device node
  @np:		node pointer of the desired reserved-memory region
  This function allows drivers to acquire a reference to the reserved_mem
  struct based on a device node handle.
  Returns a reserved_mem reference, or NULL on error.
 SPDX-License-Identifier: GPL-2.0+
   Derived from archi386kernelirq.c
     Copyright (C) 1992 Linus Torvalds
   Adapted from archi386 by Gary Thomas
     Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)
   Updated and modified by Cort Dougan <cort@fsmlabs.com>
     Copyright (C) 1996-2001 Cort Dougan
   Adapted for Power Macintosh by Paul Mackerras
     Copyright (C) 1996 Paul Mackerras (paulus@cs.anu.edu.au)
  This file contains the code used to make IRQ descriptions in the
  device tree to actual irq numbers on an interrupt controller
  driver.
  irq_of_parse_and_map - Parse and map an interrupt into linux virq space
  @dev: Device node of the device whose interrupt is to be mapped
  @index: Index of the interrupt to map
  This function is a wrapper that chains of_irq_parse_one() and
  irq_create_of_mapping() to make things easier to callers
  of_irq_find_parent - Given a device node, find its interrupt parent node
  @child: pointer to device node
  Return: A pointer to the interrupt parent node, or NULL if the interrupt
  parent could not be determined.
  of_irq_parse_raw - Low level interrupt tree parsing
  @addr:	address specifier (start of "reg" property of the device) in be32 format
  @out_irq:	structure of_phandle_args updated by this function
  This function is a low-level interrupt tree walking function. It
  can be used to do a partial walk with synthetized reg and interrupts
  properties, for example when resolving PCI interrupts when no device
  node exist for the parent. It takes an interrupt specifier structure as
  input, walks the tree looking for any interrupt-map properties, translates
  the specifier for each map, and then returns the translated map.
  Return: 0 on success and a negative number on error
	 First get the #interrupt-cells property of the current cursor
	  that tells us how to interpret the passed-in intspec. If there
	  is none, we are nice and just walk up the tree
	 Look for this #address-cells. We have to implement the old linux
	  trick of looking for the parent here as some device-trees rely on it
 Range check so that the temporary buffer doesn't overflow 
 Precalculate the match array - this simplifies match loop 
 Now start the actual "proper" walk of the interrupt tree 
		
		  Now check if cursor is an interrupt-controller and
		  if it is then we are done, unless there is an
		  interrupt-map which takes precedence.
		
		  interrupt-map parsing does not work without a reg
		  property when #address-cells != 0
 No interrupt map, check for an interrupt parent 
 Look for a mask 
 Parse interrupt-map 
 Compare specifiers 
 Get the interrupt parent 
 Check if not found 
			 Get #interrupt-cells and #address-cells of new
			  parent
 Check for malformed properties 
				
				  The PASEMI Nemo is a known offender, so
				  let's only warn for anyone else.
		
		  Successfully parsed an interrrupt-map translation; copy new
		  interrupt specifier into the out_irq structure
 Iterate again with new parent 
 No interrupt-map found 
  of_irq_parse_one - Resolve an interrupt for a device
  @device: the device whose interrupt is to be resolved
  @index: index of the interrupt to resolve
  @out_irq: structure of_phandle_args filled by this function
  This function resolves an interrupt for a node by walking the interrupt tree,
  finding which interrupt controller node it is attached to, and returning the
  interrupt specifier that can be used to retrieve a Linux IRQ number.
 OldWorld mac stuff is "special", handle out of line 
 Get the reg property (if any) 
 Try the new-style interrupts-extended first 
 Look for the interrupt parent. 
 Get size of interrupt specifier 
 Copy intspec into irq structure 
 Check if there are any interrupt-map translations to process 
  of_irq_to_resource - Decode a node's IRQ and return it as a resource
  @dev: pointer to device tree node
  @index: zero-based index of the irq
  @r: pointer to resource structure to return result into.
	 Only dereference the resource if both the
		
		  Get optional "interrupt-names" property to add a name
		  to the resource.
  of_irq_get - Decode a node's IRQ and return it as a Linux IRQ number
  @dev: pointer to device tree node
  @index: zero-based index of the IRQ
  Return: Linux IRQ number on success, or 0 on the IRQ mapping failure, or
  -EPROBE_DEFER if the IRQ domain is not yet created, or error code in case
  of any other failure.
  of_irq_get_byname - Decode a node's IRQ and return it as a Linux IRQ number
  @dev: pointer to device tree node
  @name: IRQ name
  Return: Linux IRQ number on success, or 0 on the IRQ mapping failure, or
  -EPROBE_DEFER if the IRQ domain is not yet created, or error code in case
  of any other failure.
  of_irq_count - Count the number of IRQs a node uses
  @dev: pointer to device tree node
  of_irq_to_resource_table - Fill in resource table with node's IRQ info
  @dev: pointer to device tree node
  @res: array of resources to fill in
  @nr_irqs: the number of IRQs (and upper bound for num of @res elements)
  Return: The size of the filled in table (up to @nr_irqs).
  of_irq_init - Scan and init matching interrupt controllers in DT
  @matches: 0 terminated array of nodes to match and init function to call
  This function scans the device tree for matching interrupt controller nodes,
  and calls their initialization functions in order with parents first.
		
		  Here, we allocate and populate an of_intc_desc with the node
		  pointer, interrupt-parent device_node etc.
	
	  The root irq controller is the one without an interrupt-parent.
	  That one goes first, followed by the controllers that reference it,
	  followed by the ones that reference the 2nd level controllers, etc.
		
		  Process all controllers with the current 'parent'.
		  First pass will be looking for NULL as the parent.
		  The assumption is that NULL parent means a root controller.
			
			  This one is now set up; add it to the parent list so
			  its children can get processed in a subsequent pass.
 Get the next pending parent that might have children 
	
	  Walk up the device parent links looking for one with a
	  "msi-map" property.
  of_msi_map_id - Map a MSI ID for a device.
  @dev: device for which the mapping is to be done.
  @msi_np: device node of the expected msi controller.
  @id_in: unmapped MSI ID for the device.
  Walk up the device hierarchy looking for devices with a "msi-map"
  property.  If found, apply the mapping to @id_in.
  Return: The mapped MSI ID.
  of_msi_map_get_device_domain - Use msi-map to find the relevant MSI domain
  @dev: device for which the mapping is to be done.
  @id: Device ID.
  @bus_token: Bus token
  Walk up the device hierarchy looking for devices with a "msi-map"
  property.
  Returns: the MSI domain for this device (or NULL on failure)
  of_msi_get_domain - Use msi-parent to find the relevant MSI domain
  @dev: device for which the domain is requested
  @np: device node for @dev
  @token: bus type for this domain
  Parse the msi-parent property (both the simple and the complex
  versions), and returns the corresponding MSI domain.
  Returns: the MSI domain for this device (or NULL on failure).
 Check for a single msi-parent property 
 Check for the complex msi-parent version 
  of_msi_configure - Set the msi_domain field of a device
  @dev: device structure to associate with an MSI irq domain
  @np: device node for that device
 SPDX-License-Identifier: GPL-2.0+
  driversofproperty.c - Procedures for accessing and interpreting
 			   Devicetree properties and graphs.
  Initially created by copying procedures from driversofbase.c. This
  file contains the OF property as well as the OF graph interface
  functions.
  Paul Mackerras	August 1996.
  Copyright (C) 1996-2005 Paul Mackerras.
   Adapted for 64bit PowerPC by Dave Engebretsen and Peter Bergner.
     {engebret|bergner}@us.ibm.com
   Adapted for sparc and sparc64 by David S. Miller davem@davemloft.net
   Reconsolidated from archxkernelprom.c by Stephen Rothwell and
   Grant Likely.
  of_graph_is_present() - check graph's presence
  @node: pointer to device_node containing graph port
  Return: True if @node has a port or ports (with a port) sub-node,
  false otherwise.
  of_property_count_elems_of_size - Count the number of elements in a property
  @np:		device node from which the property value is to be read.
  @propname:	name of the property to be searched.
  @elem_size:	size of the individual element
  Search for a property in a device node and count the number of elements of
  size elem_size in it.
  Return: The number of elements on sucess, -EINVAL if the property does not
  exist or its length does not match a multiple of elem_size and -ENODATA if
  the property does not have a value.
  of_find_property_value_of_size
  @np:		device node from which the property value is to be read.
  @propname:	name of the property to be searched.
  @min:	minimum allowed length of property value
  @max:	maximum allowed length of property value (0 means unlimited)
  @len:	if !=NULL, actual length is written to here
  Search for a property in a device node and valid the requested size.
  Return: The property value on success, -EINVAL if the property does not
  exist, -ENODATA if property does not have a value, and -EOVERFLOW if the
  property data is too small or too large.
  of_property_read_u32_index - Find and read a u32 from a multi-value property.
  @np:		device node from which the property value is to be read.
  @propname:	name of the property to be searched.
  @index:	index of the u32 in the list of values
  @out_value:	pointer to return value, modified only if no error.
  Search for a property in a device node and read nth 32-bit value from
  it.
  Return: 0 on success, -EINVAL if the property does not exist,
  -ENODATA if property does not have a value, and -EOVERFLOW if the
  property data isn't large enough.
  The out_value is modified only if a valid u32 value can be decoded.
  of_property_read_u64_index - Find and read a u64 from a multi-value property.
  @np:		device node from which the property value is to be read.
  @propname:	name of the property to be searched.
  @index:	index of the u64 in the list of values
  @out_value:	pointer to return value, modified only if no error.
  Search for a property in a device node and read nth 64-bit value from
  it.
  Return: 0 on success, -EINVAL if the property does not exist,
  -ENODATA if property does not have a value, and -EOVERFLOW if the
  property data isn't large enough.
  The out_value is modified only if a valid u64 value can be decoded.
  of_property_read_variable_u8_array - Find and read an array of u8 from a
  property, with bounds on the minimum and maximum array size.
  @np:		device node from which the property value is to be read.
  @propname:	name of the property to be searched.
  @out_values:	pointer to found values.
  @sz_min:	minimum number of array elements to read
  @sz_max:	maximum number of array elements to read, if zero there is no
 		upper limit on the number of elements in the dts entry but only
 		sz_min will be read.
  Search for a property in a device node and read 8-bit value(s) from
  it.
  dts entry of array should be like:
   ``property = bits 8 <0x50 0x60 0x70>;``
  Return: The number of elements read on success, -EINVAL if the property
  does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
  if the property data is smaller than sz_min or longer than sz_max.
  The out_values is modified only if a valid u8 value can be decoded.
  of_property_read_variable_u16_array - Find and read an array of u16 from a
  property, with bounds on the minimum and maximum array size.
  @np:		device node from which the property value is to be read.
  @propname:	name of the property to be searched.
  @out_values:	pointer to found values.
  @sz_min:	minimum number of array elements to read
  @sz_max:	maximum number of array elements to read, if zero there is no
 		upper limit on the number of elements in the dts entry but only
 		sz_min will be read.
  Search for a property in a device node and read 16-bit value(s) from
  it.
  dts entry of array should be like:
   ``property = bits 16 <0x5000 0x6000 0x7000>;``
  Return: The number of elements read on success, -EINVAL if the property
  does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
  if the property data is smaller than sz_min or longer than sz_max.
  The out_values is modified only if a valid u16 value can be decoded.
  of_property_read_variable_u32_array - Find and read an array of 32 bit
  integers from a property, with bounds on the minimum and maximum array size.
  @np:		device node from which the property value is to be read.
  @propname:	name of the property to be searched.
  @out_values:	pointer to return found values.
  @sz_min:	minimum number of array elements to read
  @sz_max:	maximum number of array elements to read, if zero there is no
 		upper limit on the number of elements in the dts entry but only
 		sz_min will be read.
  Search for a property in a device node and read 32-bit value(s) from
  it.
  Return: The number of elements read on success, -EINVAL if the property
  does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
  if the property data is smaller than sz_min or longer than sz_max.
  The out_values is modified only if a valid u32 value can be decoded.
  of_property_read_u64 - Find and read a 64 bit integer from a property
  @np:		device node from which the property value is to be read.
  @propname:	name of the property to be searched.
  @out_value:	pointer to return value, modified only if return value is 0.
  Search for a property in a device node and read a 64-bit value from
  it.
  Return: 0 on success, -EINVAL if the property does not exist,
  -ENODATA if property does not have a value, and -EOVERFLOW if the
  property data isn't large enough.
  The out_value is modified only if a valid u64 value can be decoded.
  of_property_read_variable_u64_array - Find and read an array of 64 bit
  integers from a property, with bounds on the minimum and maximum array size.
  @np:		device node from which the property value is to be read.
  @propname:	name of the property to be searched.
  @out_values:	pointer to found values.
  @sz_min:	minimum number of array elements to read
  @sz_max:	maximum number of array elements to read, if zero there is no
 		upper limit on the number of elements in the dts entry but only
 		sz_min will be read.
  Search for a property in a device node and read 64-bit value(s) from
  it.
  Return: The number of elements read on success, -EINVAL if the property
  does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
  if the property data is smaller than sz_min or longer than sz_max.
  The out_values is modified only if a valid u64 value can be decoded.
  of_property_read_string - Find and read a string from a property
  @np:		device node from which the property value is to be read.
  @propname:	name of the property to be searched.
  @out_string:	pointer to null terminated return string, modified only if
 		return value is 0.
  Search for a property in a device tree node and retrieve a null
  terminated string value (pointer to data, not a copy).
  Return: 0 on success, -EINVAL if the property does not exist, -ENODATA if
  property does not have a value, and -EILSEQ if the string is not
  null-terminated within the length of the property data.
  The out_string pointer is modified only if a valid string can be decoded.
  of_property_match_string() - Find string in a list and return index
  @np: pointer to node containing string list property
  @propname: string list property name
  @string: pointer to string to search for in string list
  This function searches a string list property and returns the index
  of a specific string value.
 Found it; return index 
  of_property_read_string_helper() - Utility helper for parsing string properties
  @np:		device node from which the property value is to be read.
  @propname:	name of the property to be searched.
  @out_strs:	output array of string pointers.
  @sz:		number of array elements to read.
  @skip:	Number of strings to skip over at beginning of list.
  Don't call this function directly. It is a utility helper for the
  of_property_read_string() family of functions.
  of_graph_parse_endpoint() - parse common endpoint node properties
  @node: pointer to endpoint device_node
  @endpoint: pointer to the OF endpoint data structure
  The caller should hold a reference to @node.
	
	  It doesn't matter whether the two calls below succeed.
	  If they don't then the default value 0 is used.
  of_graph_get_port_by_id() - get the port matching a given id
  @parent: pointer to the parent device node
  @id: id of the port
  Return: A 'port' node pointer with refcount incremented. The caller
  has to use of_node_put() on it when done.
  of_graph_get_next_endpoint() - get next endpoint node
  @parent: pointer to the parent device node
  @prev: previous endpoint node, or NULL to get first
  Return: An 'endpoint' node pointer with refcount incremented. Refcount
  of the passed @prev node is decremented.
	
	  Start by locating the port node. If no previous endpoint is specified
	  search for the first port node, otherwise get the previous endpoint
	  parent port node.
		
		  Now that we have a port node, get the next endpoint by
		  getting the next child. If the previous endpoint is NULL this
		  will return the first child.
 No more endpoints under this port, try the next one. 
  of_graph_get_endpoint_by_regs() - get endpoint node of specific identifiers
  @parent: pointer to the parent device node
  @port_reg: identifier (value of reg property) of the parent port node
  @reg: identifier (value of reg property) of the endpoint node
  Return: An 'endpoint' node pointer which is identified by reg and at the same
  is the child of a port node identified by port_reg. reg and port_reg are
  ignored when they are -1. Use of_node_put() on the pointer when done.
  of_graph_get_remote_endpoint() - get remote endpoint node
  @node: pointer to a local endpoint device_node
  Return: Remote endpoint node associated with remote endpoint node linked
 	   to @node. Use of_node_put() on it when done.
 Get remote endpoint node. 
  of_graph_get_port_parent() - get port's parent node
  @node: pointer to a local endpoint device_node
  Return: device node associated with endpoint node linked
 	   to @node. Use of_node_put() on it when done.
	
	  Preserve usecount for passed in node as of_get_next_parent()
	  will do of_node_put() on it.
 Walk 3 levels up only if there is 'ports' node. 
  of_graph_get_remote_port_parent() - get remote port's parent node
  @node: pointer to a local endpoint device_node
  Return: Remote device node associated with remote endpoint node linked
 	   to @node. Use of_node_put() on it when done.
 Get remote endpoint node. 
  of_graph_get_remote_port() - get remote port node
  @node: pointer to a local endpoint device_node
  Return: Remote port node associated with remote endpoint node linked
  to @node. Use of_node_put() on it when done.
 Get remote endpoint node. 
  of_graph_get_remote_node() - get remote parent device_node for given portendpoint
  @node: pointer to parent device_node containing graph portendpoint
  @port: identifier (value of reg property) of the parent port node
  @endpoint: identifier (value of reg property) of the endpoint node
  Return: Remote device node associated with remote endpoint node linked
  to @node. Use of_node_put() on it when done.
 Root needs no prefix here (its name is ""). 
 Get the parent of the port 
 Is this the "ports" node? If not, it's the port parent. 
  of_link_to_phandle - Add fwnode link to supplier from supplier phandle
  @con_np: consumer device tree node
  @sup_np: supplier device tree node
  Given a phandle to a supplier device tree node (@sup_np), this function
  finds the device that owns the supplier device tree node and creates a
  device link from @dev consumer device to the supplier device. This function
  doesn't create device links for invalid scenarios such as trying to create a
  link with a parent device as the consumer of its child device. In such
  cases, it returns an error.
  Returns:
  - 0 if fwnode link successfully created to supplier
  - -EINVAL if the supplier link is invalid and should not be created
  - -ENODEV if struct device will never be create for supplier
	
	  Find the device node that contains the supplier phandle.  It may be
	  @sup_np or it may be an ancestor of @sup_np.
	
	  Don't allow linking a device node as a consumer of one of its
	  descendant nodes. By definition, a child node can't be a functional
	  dependency for the parent node.
	
	  Don't create links to "early devices" that won't have struct devices
	  created for them.
  parse_prop_cells - Property parsing function for suppliers
  @np:		Pointer to device tree node containing a list
  @prop_name:	Name of property to be parsed. Expected to hold phandle values
  @index:	For properties holding a list of phandles, this is the index
 		into the list.
  @list_name:	Property name that is known to contain list of phandle(s) to
 		supplier(s)
  @cells_name:	property name that specifies phandles' arguments count
  This is a helper function to parse properties that have a known fixed name
  and are a list of phandles and phandle arguments.
  Returns:
  - phandle node pointer with refcount incremented. Caller must of_node_put()
    on it when done.
  - NULL if no phandle found at index
  parse_suffix_prop_cells - Suffix property parsing function for suppliers
  @np:		Pointer to device tree node containing a list
  @prop_name:	Name of property to be parsed. Expected to hold phandle values
  @index:	For properties holding a list of phandles, this is the index
 		into the list.
  @suffix:	Property suffix that is known to contain list of phandle(s) to
 		supplier(s)
  @cells_name:	property name that specifies phandles' arguments count
  This is a helper function to parse properties that have a known fixed suffix
  and are a list of phandles and phandle arguments.
  Returns:
  - phandle node pointer with refcount incremented. Caller must of_node_put()
    on it when done.
  - NULL if no phandle found at index
  struct supplier_bindings - Property parsing functions for suppliers
  @parse_prop: function name
 	parse_prop() finds the node corresponding to a supplier phandle
  @parse_prop.np: Pointer to device node holding supplier phandle property
  @parse_prop.prop_name: Name of property holding a phandle value
  @parse_prop.index: For properties holding a list of phandles, this is the
 		      index into the list
  @optional: Describes whether a supplier is mandatory or not
  @node_not_dev: The consumer node containing the property is never a device.
  Returns:
  parse_prop() return values are
  - phandle node pointer with refcount incremented. Caller must of_node_put()
    on it when done.
  - NULL if no phandle found at index
	
	  Ignore node with gpio-hog property since its gpios are all provided
	  by its parent.
  of_link_property - Create device links to suppliers listed in a property
  @con_np: The consumer device tree node which contains the property
  @prop_name: Name of property to be parsed
  This function checks if the property @prop_name that is present in the
  @con_np device tree node is one of the known common device tree bindings
  that list phandles to suppliers. If @prop_name isn't one, this function
  doesn't do anything.
  If @prop_name is one, this function attempts to create fwnode links from the
  consumer device tree node @con_np to all the suppliers device tree nodes
  listed in @prop_name.
  Any failed attempt to create a fwnode link will NOT result in an immediate
  return.  of_link_property() must create links to all the available supplier
  device tree nodes even when attempts to create a link to one or more
  suppliers fail.
 Do not stop at first failed link, link all available suppliers. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2020 Western Digital Corporation or its affiliates.
 sentinel  },
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018, Intel Corporation
  Copied from reset-sunxi.c
  These are the reset controller we need to initialize early on in
  our system, before we can even think of using a regular device
  driver for it.
  The controllers that we can register through the regular device
  model are handled by the simple reset driver directly.
 sentinel  },
  The early driver is problematic, because it doesn't register
  itself as a driver. This causes certain device links to prevent
  consumer devices from probing. The hacky solution is to register
  an empty driver, whose only job is to attach itself to the reset
  manager and call probe.
 sentinel  },
  Texas Instrument's System Control Interface (TI-SCI) reset driver
  Copyright (C) 2015-2017 Texas Instruments Incorporated - https:www.ti.com
 	Andrew F. Davis <afd@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  struct ti_sci_reset_control - reset control structure
  @dev_id: SoC-specific device identifier
  @reset_mask: reset mask to use for toggling reset
  @lock: synchronize reset_mask read-modify-writes
  struct ti_sci_reset_data - reset controller information structure
  @rcdev: reset controller entity
  @dev: reset controller device pointer
  @sci: TI SCI handle used for communication with system controller
  @idr: idr structure for mapping ids to reset control structures
  ti_sci_reset_set() - program a device's reset
  @rcdev: reset controller entity
  @id: ID of the reset to toggle
  @assert: boolean flag to indicate assert or deassert
  This is a common internal function used to assert or deassert a device's
  reset using the TI SCI protocol. The device's reset is asserted if the
  @assert argument is true, or deasserted if @assert argument is false.
  The mechanism itself is a read-modify-write procedure, the current device
  reset register is read using a TI SCI device operation, the new value is
  set or un-set using the reset's mask, and the new reset value written by
  using another TI SCI device operation.
  Return: 0 for successful request, else a corresponding error value
  ti_sci_reset_assert() - assert device reset
  @rcdev: reset controller entity
  @id: ID of the reset to be asserted
  This function implements the reset driver op to assert a device's reset
  using the TI SCI protocol. This invokes the function ti_sci_reset_set()
  with the corresponding parameters as passed in, but with the @assert
  argument set to true for asserting the reset.
  Return: 0 for successful request, else a corresponding error value
  ti_sci_reset_deassert() - deassert device reset
  @rcdev: reset controller entity
  @id: ID of the reset to be deasserted
  This function implements the reset driver op to deassert a device's reset
  using the TI SCI protocol. This invokes the function ti_sci_reset_set()
  with the corresponding parameters as passed in, but with the @assert
  argument set to false for deasserting the reset.
  Return: 0 for successful request, else a corresponding error value
  ti_sci_reset_status() - check device reset status
  @rcdev: reset controller entity
  @id: ID of reset to be checked
  This function implements the reset driver op to return the status of a
  device's reset using the TI SCI protocol. The reset register value is read
  by invoking the TI SCI device operation .get_device_resets(), and the
  status of the specific reset is extracted and returned using this reset's
  reset mask.
  Return: 0 if reset is deasserted, or a non-zero value if reset is asserted
  ti_sci_reset_of_xlate() - translate a set of OF arguments to a reset ID
  @rcdev: reset controller entity
  @reset_spec: OF reset argument specifier
  This function performs the translation of the reset argument specifier
  values defined in a reset consumer device node. The function allocates a
  reset control structure for that device reset, and will be used by the
  driver for performing any reset functions on that reset. An idr structure
  is allocated and used to map to the reset control structure. This idr
  is used by the driver to do reset lookups.
  Return: 0 for successful request, else a corresponding error value
 sentinel  },
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018 The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0-only
  Oxford Semiconductor Reset Controller driver
  Copyright (C) 2016 Neil Armstrong <narmstrong@baylibre.com>
  Copyright (C) 2014 Ma Haijun <mahaijuns@gmail.com>
  Copyright (C) 2009 Oxford Semiconductor Ltd
 Regmap offsets 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
  Pistachio SoC Reset Controller driver
  Copyright (C) 2015 Imagination Technologies Ltd.
  Author: Damien Horsley <Damien.Horsley@imgtec.com>
 sentinel  },
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2019 Intel Corporation.
  Lei Chuanhua <Chuanhua.lei@intel.com>
  Reset status register offset relative to
  the reset control register(X) is X + 4
  RCU is system core entity which is in Always On Domain whose clocks
  or resource initialization happens in system core initialization.
  Also, it is required for most of the platform or architecture
  specific devices to perform reset operation as part of initialization.
  So perform RCU as post core initialization.
 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
  Amlogic Meson Reset Controller driver
  Copyright (c) 2016 BayLibre, SAS.
  Author: Neil Armstrong <narmstrong@baylibre.com>
 sentinel  },
 SPDX-License-Identifier: GPL-2.0
  Raspberry Pi 4 firmware reset driver
  Copyright (C) 2020 Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
		
		  The Raspberry Pi 4 gets its USB functionality from VL805, a
		  PCIe chip that implements xHCI. After a PCI reset, VL805's
		  firmware may either be loaded directly from an EEPROM or, if
		  not present, by the SoC's co-processor, VideoCore. rpi's
		  VideoCore OS contains both the non public firmware load
		  logic and the VL805 firmware blob. This triggers the
		  aforementioned process.
		 
		  The pci device address is expected is expected by the
		  firmware encoded like this:
		 
		 	PCI_BUS << 20 | PCI_SLOT << 15 | PCI_FUNC << 12
		 
		  But since rpi's PCIe is hardwired, we know the address in
		  advance.
 Wait for vl805 to startup 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  Renesas RZG2L USBPHY control driver
  Copyright (C) 2021 Renesas Electronics Corporation
 Sentinel  }
 put pll and phy into reset state 
  Copyright (C) 2014 Marvell Technology Group Ltd.
  Marvell Berlin reset driver
  Antoine Tenart <antoine.tenart@free-electrons.com>
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 let the reset be effective 
 SPDX-License-Identifier: GPL-2.0
 reset-uniphier-glue.c - Glue layer reset driver for UniPhier
 Copyright 2018 Socionext Inc.
 Author: Kunihiko Hayashi <hayashi.kunihiko@socionext.com>
 Sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
   Copyright (C) 2010 John Crispin <blogic@phrozen.org>
   Copyright (C) 2013-2015 Lantiq Beteiligungs-GmbH & Co.KG
   Copyright (C) 2016 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
   Copyright (C) 2017 Hauke Mehrtens <hauke@hauke-m.de>
 SPDX-License-Identifier: GPL-2.0
  Broadcom STB generic reset controller for SW_INIT style reset controller
  Author: Florian Fainelli <f.fainelli@gmail.com>
  Copyright (C) 2018 Broadcom
 A full bank contains extra registers that we are not utilizing but still
  qualify as a single bank.
	 Maximum reset delay after de-asserting a line and seeing block
	  operation is typically 14us for the worst case, build some slack
	  here.
 Use defaults: 1 cell and simple xlate function 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
   Copyright Intel Corporation (C) 2017. All Rights Reserved
  Reset driver for Altera Arria10 MAX5 System Resource Chip
  Adapted from reset-socfpga.c
 SPDX-License-Identifier: GPL-2.0-only
  Reset driver for NXP LPC18xx43xx Reset Generation Unit (RGU).
  Copyright (C) 2015 Joachim Eastwood <manabian@gmail.com>
 LPC18xx RGU registers 
 Internal reset outputs 
  The LPC18xx RGU has mostly self-deasserting resets except for the
  two reset lines going to the internal Cortex-M0 cores.
  To prevent the M0 core resets from accidentally getting deasserted
  status register must be check and bits in control register set to
  preserve the state.
 Only M0 cores require explicit reset deassert 
  Copyright (C) 2017 Synopsys.
  Synopsys HSDK Development platform reset driver.
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 APB_RST  
 AXI_RST  
 ETH_RST  
 USB_RST  
 SDIO_RST 
 HDMI_RST 
 GFX_RST  
 DMAC_RST 
 EBI_RST  
 wait till reset bit is back to 0 
 SPDX-License-Identifier: GPL-2.0-or-later
  BCM6345 Reset Controller Driver
  Copyright (C) 2020 lvaro Fernndez Rojas <noltari@gmail.com>
	
	  Ensure component is taken out reset state by sleeping also after
	  deasserting the reset. Otherwise, the component may not be ready
	  for operation.
 sentinel  },
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018-2020 Broadcom 
 This is needed if #reset-cells == 0. 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015, National Instruments Corp.
  Xilinx Zynq Reset controller driver
  Author: Moritz Fischer <moritz.fischer@ettus.com>
 sentinel  },
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2018 Xilinx, Inc.
 sentinel  },
 SPDX-License-Identifier: GPL-2.0+
 Microchip Sparx5 Switch Reset driver
  Copyright (c) 2020 Microchip Technology Inc. and its subsidiaries.
  The Sparx5 Chip Register Model can be browsed at this location:
  https:github.commicrochip-ungsparx-5_reginfo
 Make sure the core is PROTECTED from reset 
 Start soft reset 
 Wait for soft reset done 
 SPDX-License-Identifier: GPL-2.0
  ARM System Control and Management Interface (ARM SCMI) reset driver
  Copyright (C) 2019-2021 ARM Ltd.
  struct scmi_reset_data - reset controller information structure
  @rcdev: reset controller entity
  @ph: ARM SCMI protocol handle used for communication with system controller
  scmi_reset_assert() - assert device reset
  @rcdev: reset controller entity
  @id: ID of the reset to be asserted
  This function implements the reset driver op to assert a device's reset
  using the ARM SCMI protocol.
  Return: 0 for successful request, else a corresponding error value
  scmi_reset_deassert() - deassert device reset
  @rcdev: reset controller entity
  @id: ID of the reset to be deasserted
  This function implements the reset driver op to deassert a device's reset
  using the ARM SCMI protocol.
  Return: 0 for successful request, else a corresponding error value
  scmi_reset_reset() - reset the device
  @rcdev: reset controller entity
  @id: ID of the reset signal to be reset(assert + deassert)
  This function implements the reset driver op to trigger a device's
  reset signal using the ARM SCMI protocol.
  Return: 0 for successful request, else a corresponding error value
 SPDX-License-Identifier: (GPL-2.0 OR MIT)
 Copyright (c) 2018 BayLibre, SAS.
 Author: Jerome Brunet <jbrunet@baylibre.com>
 Disable all access 
	
	  Enable general :
	  In the initial state, all memory interfaces are disabled
	  and the general bit is on
 Register reset controller 
 SPDX-License-Identifier: GPL-2.0-or-later
  Reset Controller framework
  Copyright 2013 Philipp Zabel, Pengutronix
  struct reset_control - a reset control
  @rcdev: a pointer to the reset controller device
          this reset control belongs to
  @list: list entry for the rcdev's reset controller list
  @id: ID of the reset controller in the reset
       controller device
  @refcnt: Number of gets of this reset_control
  @acquired: Only one reset_control may be acquired for a given rcdev and id.
  @shared: Is this a shared (1), or an exclusive (0) reset_control?
  @array: Is this an array of reset controls (1)?
  @deassert_count: Number of times this reset line has been deasserted
  @triggered_count: Number of times this reset line has been reset. Currently
                    only used for shared resets, which means that the value
                    will be either 0 or 1.
  struct reset_control_array - an array of reset controls
  @base: reset control for compatibility with reset control API functions
  @num_rstcs: number of reset controls
  @rstc: array of reset controls
  of_reset_simple_xlate - translate reset_spec to the reset line number
  @rcdev: a pointer to the reset controller device
  @reset_spec: reset line specifier as found in the device tree
  This static translation function is used by default if of_xlate in
  :c:type:`reset_controller_dev` is not set. It is useful for all reset
  controllers with 1:1 mapping, where reset lines can be indexed by number
  without gaps.
  reset_controller_register - register a reset controller device
  @rcdev: a pointer to the initialized reset controller device
  reset_controller_unregister - unregister a reset controller device
  @rcdev: a pointer to the reset controller device
  devm_reset_controller_register - resource managed reset_controller_register()
  @dev: device that is registering this reset controller
  @rcdev: a pointer to the initialized reset controller device
  Managed reset_controller_register(). For reset controllers registered by
  this function, reset_controller_unregister() is automatically called on
  driver detach. See reset_controller_register() for more information.
  reset_controller_add_lookup - register a set of lookup entries
  @lookup: array of reset lookup entries
  @num_entries: number of entries in the lookup array
  reset_control_reset - reset the controlled device
  @rstc: reset controller
  On a shared reset line the actual reset pulse is only triggered once for the
  lifetime of the reset_control instance: for all but the first caller this is
  a no-op.
  Consumers must not use reset_control_(de)assert on shared reset lines when
  reset_control_reset has been used.
  If rstc is NULL it is an optional reset and the function will just
  return 0.
  reset_control_bulk_reset - reset the controlled devices in order
  @num_rstcs: number of entries in rstcs array
  @rstcs: array of struct reset_control_bulk_data with reset controls set
  Issue a reset on all provided reset controls, in order.
  See also: reset_control_reset()
  reset_control_rearm - allow shared reset line to be re-triggered"
  @rstc: reset controller
  On a shared reset line the actual reset pulse is only triggered once for the
  lifetime of the reset_control instance, except if this call is used.
  Calls to this function must be balanced with calls to reset_control_reset,
  a warning is thrown in case triggered_count ever dips below 0.
  Consumers must not use reset_control_(de)assert on shared reset lines when
  reset_control_reset or reset_control_rearm have been used.
  If rstc is NULL the function will just return 0.
  reset_control_assert - asserts the reset line
  @rstc: reset controller
  Calling this on an exclusive reset controller guarantees that the reset
  will be asserted. When called on a shared reset controller the line may
  still be deasserted, as long as other users keep it so.
  For shared reset controls a driver cannot expect the hw's registers and
  internal state to be reset, but must be prepared for this to happen.
  Consumers must not use reset_control_reset on shared reset lines when
  reset_control_(de)assert has been used.
  If rstc is NULL it is an optional reset and the function will just
  return 0.
		
		  Shared reset controls allow the reset line to be in any state
		  after this call, so doing nothing is a valid option.
		
		  If the reset controller does not implement .assert(), there
		  is no way to guarantee that the reset line is asserted after
		  this call.
  reset_control_bulk_assert - asserts the reset lines in order
  @num_rstcs: number of entries in rstcs array
  @rstcs: array of struct reset_control_bulk_data with reset controls set
  Assert the reset lines for all provided reset controls, in order.
  If an assertion fails, already asserted resets are deasserted again.
  See also: reset_control_assert()
  reset_control_deassert - deasserts the reset line
  @rstc: reset controller
  After calling this function, the reset is guaranteed to be deasserted.
  Consumers must not use reset_control_reset on shared reset lines when
  reset_control_(de)assert has been used.
  If rstc is NULL it is an optional reset and the function will just
  return 0.
	
	  If the reset controller does not implement .deassert(), we assume
	  that it handles self-deasserting reset lines via .reset(). In that
	  case, the reset lines are deasserted by default. If that is not the
	  case, the reset controller driver should implement .deassert() and
	  return -ENOTSUPP.
  reset_control_bulk_deassert - deasserts the reset lines in reverse order
  @num_rstcs: number of entries in rstcs array
  @rstcs: array of struct reset_control_bulk_data with reset controls set
  Deassert the reset lines for all provided reset controls, in reverse order.
  If a deassertion fails, already deasserted resets are asserted again.
  See also: reset_control_deassert()
  reset_control_status - returns a negative errno if not supported, a
  positive value if the reset line is asserted, or zero if the reset
  line is not asserted or if the desc is NULL (optional reset).
  @rstc: reset controller
  reset_control_acquire() - acquires a reset control for exclusive use
  @rstc: reset control
  This is used to explicitly acquire a reset control for exclusive use. Note
  that exclusive resets are requested as acquired by default. In order for a
  second consumer to be able to control the reset, the first consumer has to
  release it first. Typically the easiest way to achieve this is to call the
  reset_control_get_exclusive_released() to obtain an instance of the reset
  control. Such reset controls are not acquired by default.
  Consumers implementing shared access to an exclusive reset need to follow
  a specific protocol in order to work together. Before consumers can change
  a reset they must acquire exclusive access using reset_control_acquire().
  After they are done operating the reset, they must release exclusive access
  with a call to reset_control_release(). Consumers are not granted exclusive
  access to the reset as long as another consumer hasn't released a reset.
  See also: reset_control_release()
  reset_control_bulk_acquire - acquires reset controls for exclusive use
  @num_rstcs: number of entries in rstcs array
  @rstcs: array of struct reset_control_bulk_data with reset controls set
  This is used to explicitly acquire reset controls requested with
  reset_control_bulk_get_exclusive_release() for temporary exclusive use.
  See also: reset_control_acquire(), reset_control_bulk_release()
  reset_control_release() - releases exclusive access to a reset control
  @rstc: reset control
  Releases exclusive access right to a reset control previously obtained by a
  call to reset_control_acquire(). Until a consumer calls this function, no
  other consumers will be granted exclusive access.
  See also: reset_control_acquire()
  reset_control_bulk_release() - releases exclusive access to reset controls
  @num_rstcs: number of entries in rstcs array
  @rstcs: array of struct reset_control_bulk_data with reset controls set
  Releases exclusive access right to reset controls previously obtained by a
  call to reset_control_bulk_acquire().
  See also: reset_control_release(), reset_control_bulk_acquire()
			
			  Allow creating a secondary exclusive reset_control
			  that is initially not acquired for an already
			  controlled reset line.
 reset_list_mutex also protects the rcdev's reset_control list 
 Reset provider may not be ready yet. 
  reset_control_put - free the reset controller
  @rstc: reset controller
  reset_control_bulk_put - free the reset controllers
  @num_rstcs: number of entries in rstcs array
  @rstcs: array of struct reset_control_bulk_data with reset controls set
  __device_reset - find reset controller associated with the device
                   and perform reset
  @dev: device to be reset by the controller
  @optional: whether it is optional to reset the device
  Convenience wrapper for __reset_control_get() and reset_control_reset().
  This is useful for the common case of devices with single, dedicated reset
  lines.
  APIs to manage an array of reset controls.
  of_reset_control_get_count - Count number of resets available with a device
  @node: device node that contains 'resets'.
  Returns positive reset count on success, or error number on failure and
  on count being zero.
  of_reset_control_array_get - Get a list of reset controls using
 				device node.
  @np: device node for the device that requests the reset controls array
  @shared: whether reset controls are shared or not
  @optional: whether it is optional to get the reset controls
  @acquired: only one reset control may be acquired for a given controller
             and ID
  Returns pointer to allocated reset_control on success or error on failure
  devm_reset_control_array_get - Resource managed reset control array get
  @dev: device that requests the list of reset controls
  @shared: whether reset controls are shared or not
  @optional: whether it is optional to get the reset controls
  The reset control array APIs are intended for a list of resets
  that just have to be asserted or deasserted, without any
  requirements on the order.
  Returns pointer to allocated reset_control on success or error on failure
  reset_control_get_count - Count number of resets available with a device
  @dev: device for which to return the number of resets
  Returns positive reset count on success, or error number on failure and
  on count being zero.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Nuvoton Technology corporation.
 NPCM7xx GCR registers 
 NPCM7xx Reset registers 
   The following procedure should be observed in USB PHY, USB device and
   USB host initialization at BMC boot
 checking which USB device is enabled 
 assert reset USB PHY and USB devices 
 clear USB PHY RS bit 
 deassert reset USB PHY 
 set USB PHY RS bit 
 deassert reset USB devices
  Copyright (C) 2017 Synopsys.
  Synopsys AXS10x reset driver.
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  TI SYSCON regmap reset driver
  Copyright (C) 2015-2016 Texas Instruments Incorporated - https:www.ti.com
 	Andrew F. Davis <afd@ti.com>
 	Suman Anna <afd@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  struct ti_syscon_reset_control - reset control structure
  @assert_offset: reset assert control register offset from syscon base
  @assert_bit: reset assert bit in the reset assert control register
  @deassert_offset: reset deassert control register offset from syscon base
  @deassert_bit: reset deassert bit in the reset deassert control register
  @status_offset: reset status register offset from syscon base
  @status_bit: reset status bit in the reset status register
  @flags: reset flag indicating how the (de)assert and status are handled
  struct ti_syscon_reset_data - reset controller information structure
  @rcdev: reset controller entity
  @regmap: regmap handle containing the memory-mapped reset registers
  @controls: array of reset controls
  @nr_controls: number of controls in control array
  ti_syscon_reset_assert() - assert device reset
  @rcdev: reset controller entity
  @id: ID of the reset to be asserted
  This function implements the reset driver op to assert a device's reset.
  This asserts the reset in a manner prescribed by the reset flags.
  Return: 0 for successful request, else a corresponding error value
 assert not supported for this reset 
  ti_syscon_reset_deassert() - deassert device reset
  @rcdev: reset controller entity
  @id: ID of reset to be deasserted
  This function implements the reset driver op to deassert a device's reset.
  This deasserts the reset in a manner prescribed by the reset flags.
  Return: 0 for successful request, else a corresponding error value
 deassert not supported for this reset 
  ti_syscon_reset_status() - check device reset status
  @rcdev: reset controller entity
  @id: ID of the reset for which the status is being requested
  This function implements the reset driver op to return the status of a
  device's reset.
  Return: 0 if reset is deasserted, true if reset is asserted, else a
  corresponding error value
 status not supported for this reset 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018 The Linux Foundation. All rights reserved.
 Wait 6 32kHz sleep cycles for reset 
 Wait 6 32kHz sleep cycles for reset 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Socionext Inc.
    Author: Masahiro Yamada <yamada.masahiro@socionext.com>
 System reset data 
 NAND 
 STDMAC (Ether, HSC, MIO) 
 NAND 
 Ether 
 STDMAC (HSC, MIO, RLE) 
 GIO (Ether, SATA, USB3) 
 USB30 
 USB31 
 SATA0 
 SATA1 
 SATA-PHY 
 AIO 
 NAND 
 STDMAC (HSC) 
 GIO (PCIe, USB3) 
 USB30 
 USB31 
 PCIe 
 AIO 
 NAND 
 Ether 
 STDMAC (HSC, RLE) 
 USB30 
 USB31 
 USB30-PHY0 
 USB30-PHY1 
 USB30-PHY2 
 USB31-PHY0 
 USB31-PHY1 
 SATA 
 SATA-PHY (active high) 
 AIO 
 NAND 
 eMMC 
 Ether 
 STDMAC (HSC, MIO) 
 HSC 
 AIO 
 EVEA 
 EXIV 
 NAND 
 eMMC 
 Ether 
 STDMAC (HSC) 
 HSC 
 USB30 
 USB30-PHY0 
 USB30-PHY1 
 USB30-PHY2 
 USB30-PHY3 
 PCIe 
 AIO 
 EVEA 
 EXIV 
 NAND 
 eMMC 
 Ether0 
 Ether1 
 STDMAC 
 USB30 link 
 USB31 link 
 USB30-PHY0 
 USB30-PHY1 
 USB30-PHY2 
 USB31-PHY0 
 USB31-PHY1 
 PCIe 
 SATA0 
 SATA1 
 SATA-PHY 
 AIO 
 EXIV 
 eMMC 
 Ether 
 USB30 link 
 USB30-PHY0 
 USB30-PHY1 
 USB30-PHY2 
 PCIe 
 VOC 
 HDMI-Tx 
 Media IO reset data 
 Peripheral reset data 
 Analog signal amplifiers reset data 
 EVEA 
 core implementaton 
 parent should be syscon node 
 System reset 
 Media IO reset, SD reset 
 Peripheral reset 
 Analog signal amplifiers reset 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
  Allwinner SoCs Reset Controller driver
  Copyright 2013 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
  These are the reset controller we need to initialize early on in
  our system, before we can even think of using a regular device
  driver for it.
  The controllers that we can register through the regular device
  model are handled by the simple reset driver directly.
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-or-later
  Simple Reset Controller Driver
  Copyright (C) 2017 Pengutronix, Philipp Zabel <kernel@pengutronix.de>
  Based on Allwinner SoCs Reset Controller driver
  Copyright 2013 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
  struct reset_simple_devdata - simple reset controller properties
  @reg_offset: offset between base address and first reset register.
  @nr_resets: number of resets. If not set, default to resource size in bits.
  @active_low: if true, bits are cleared to assert the reset. Otherwise, bits
               are set to assert the reset.
  @status_active_low: if true, bits read back as cleared while the reset is
                      asserted. Otherwise, bits read back as set while the
                      reset is asserted.
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017, Impinj, Inc.
  i.MX7 System Reset Controller (SRC) driver
  Author: Andrey Smirnov <andrew.smirnov@gmail.com>
		
		  wait for more than 10us to release phy g_rst and
		  btnrst
		
		  wait for more than 10us to release phy g_rst and
		  btnrst
		
		  wait for more than 10us to release phy g_rst and
		  btnrst
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-or-later
  AR71xx Reset Controller Driver
  Author: Alban Bedel
  Copyright (C) 2015 Alban Bedel <albeu@free.fr>
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2016-2017 Linaro Ltd.
  Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
 fall back to the deprecated compatible 
 SPDX-License-Identifier: GPL-2.0-only
  Hisilicon Hi6220 reset controller driver
  Copyright (c) 2016 Linaro Limited.
  Copyright (c) 2015-2016 HiSilicon Limited.
  Author: Feng Chen <puck.chen@hisilicon.com>
	
	  It was suggested to disable isolation before enabling
	  the clocks and deasserting reset, to avoid glitches.
	  But this order is preserved to keep it matching the
	  vendor code.
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2013 STMicroelectronics Limited
  Author: Stephen Gallimore <stephen.gallimore@st.com>
  Inspired by mach-imxsrc.c
  struct syscfg_reset_channel - Reset channel regmap configuration
  @reset: regmap field for the channel's reset bit.
  @ack: regmap field for the channel's ack bit (optional).
  struct syscfg_reset_controller - A reset controller which groups together
  a set of related reset bits, which may be located in different system
  configuration registers.
  @rst: base reset controller structure.
  @active_low: are the resets in this controller active low, i.e. clearing
               the reset bit puts the hardware into reset.
  @channels: An array of reset channels for this controller.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2014 STMicroelectronics (R&D) Limited
  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>
 STiH407 Peripheral powerdown definitions. 
 Powerdown requests control 0 
 Powerdown requests control 1 (High Speed Links) 
 Ethernet powerdownstatusreset 
 Reset Generator control 01 
 Softreset IRB & SBC UART 
 PicoPHY resetcontrol 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2016 NVIDIA Corporation
 SPDX-License-Identifier: GPL-2.0-only
  VFIO: IOMMU DMA mapping support for TCE on POWER
  Copyright (C) 2013 IBM Corp.  All rights reserved.
      Author: Alexey Kardashevskiy <aik@ozlabs.ru>
  Derived from original vfio_iommu_type1.c:
  Copyright (C) 2012 Red Hat, Inc.  All rights reserved.
      Author: Alex Williamson <alex.williamson@redhat.com>
  VFIO IOMMU fd for SPAPR_TCE IOMMU implementation
  This code handles mapping and unmapping of user data buffers
  into DMA'ble space using the IOMMU
  A container needs to remember which preregistered region  it has
  referenced to do proper cleanup at the userspace process exit.
  The container descriptor supports only a single group per container.
  Required by the API as the container is not supplied with the IOMMU group
  at the moment of initialization.
	
	  Check that the TCE table granularity is not bigger than the size of
	  a page we just found. Otherwise the hardware can get access to
	  a bigger memory chunk that it should.
	
	  When userspace pages are mapped into the IOMMU, they are effectively
	  locked memory, so, theoretically, we need to update the accounting
	  of locked pages on each map and unmap.  For powerpc, the map unmap
	  paths can be very hot, though, and the accounting would kill
	  performance, especially since it would be difficult to impossible
	  to handle the accounting in real mode only.
	 
	  To address that, rather than precisely accounting every page, we
	  instead account for a worst case on locked memory when the iommu is
	  enabled and disabled.  The worst case upper bound on locked memory
	  is the size of the whole iommu window, which is usually relatively
	  small (compared to total memory sizes) on POWER hardware.
	 
	  Also we don't have a nice way to fail on H_PUT_TCE due to ulimits,
	  that would effectively kill the guest at random points, much better
	  enforcing the limit based on the max that the guest can map.
	 
	  Unfortunately at the moment it counts whole tables, no matter how
	  much memory the guest has. I.e. for 4GB guest and 4 IOMMU groups
	  each with 2GB DMA window, 8GB will be counted here. The reason for
	  this is that we cannot tell here the amount of RAM used by the guest
	  as this information is only available from KVM and VFIO is
	  KVM agnostic.
	 
	  So we do not allow enabling a container without a group attached
	  as there is no way to know how much we should increment
	  the locked_vm counter.
	
	  If VFIO created a table, it was not disposed
	  by tce_iommu_detach_group() so do it now.
			
			  For multilevel tables, we can take a shortcut here
			  and skip some TCEs as we know that the userspace
			  addresses cache is a mirror of the real TCE table
			  and if it is missing some indirect levels, then
			  the hardware table does not have them allocated
			  either and therefore does not require updating.
 align to level_size which is power of two 
 Preserve offset within IOMMU page 
 The registered region is being unregistered 
 dirtmp cannot be DMA_NONE here 
 Get the first group for ops::create_table 
 Create TCE table 
	
	  Program the table to every group.
	  Groups have been tested for compatibility at the attach time.
 Return start address assigned by platform in create_table() 
 Detach groups from IOMMUs 
		
		  SPAPR TCE IOMMU exposes the default DMA window to
		  the guest via dma32_window_startsize of
		  VFIO_IOMMU_SPAPR_TCE_GET_INFO. Some platforms allow
		  the userspace to remove this window, some do not so
		  here we check for the platform capability.
 Free table 
	
	  Sanity check to prevent one userspace from manipulating
	  another userspace mm.
 iova is checked by the IOMMU API 
 No flag is supported now 
 No flag is supported now 
 No flag is supported now 
 Set all windows to the new group 
	 pr_debug("tce_vfio: Attaching group #%u to iommu %p\n",
 Check if new group has the same iommu_ops (i.e. compatible) 
 SPDX-License-Identifier: GPL-2.0-only
  VFIO generic eventfd code for IRQFD support.
  Derived from driversvfiopcivfio_pci_intrs.c
  Copyright (C) 2012 Red Hat, Inc.  All rights reserved.
      Author: Alex Williamson <alex.williamson@redhat.com>
 An event has been signaled, call function 
		
		  The eventfd is closing, if the virqfd has not yet been
		  queued for release, as determined by testing whether the
		  virqfd pointer to it is still valid, queue it now.  As
		  with kvm irqfds, we know we won't race against the virqfd
		  going away because we hold the lock to get here.
	
	  virqfds can be released by closing the eventfd or directly
	  through ioctl.  These are both done through a workqueue, so
	  we update the pointer to the virqfd under lock to avoid
	  pushing multiple jobs to release the same virqfd.
	
	  Install our own custom wake-up handling so we are notified via
	  a callback whenever someone signals the underlying eventfd.
	
	  Check if there was an event already pending on the eventfd
	  before we registered and trigger it as if we didn't miss it.
	
	  Do not drop the file until the irqfd is fully initialized,
	  otherwise we might race against the EPOLLHUP.
	
	  Block until we know all outstanding shutdown jobs have completed.
	  Even if we don't queue the job, flush the wq to be sure it's
	  been released.
 SPDX-License-Identifier: GPL-2.0-only
  VFIO: IOMMU DMA mapping support for Type1 IOMMU
  Copyright (C) 2012 Red Hat, Inc.  All rights reserved.
      Author: Alex Williamson <alex.williamson@redhat.com>
  Derived from original vfio:
  Copyright 2010 Cisco Systems, Inc.  All rights reserved.
  Author: Tom Lyon, pugs@cisco.com
  We arbitrarily define a Type1 IOMMU as one matching the below code.
  It could be called the x86 IOMMU as it's designed for AMD-Vi & Intel
  VT-d, but that makes it harder to re-use as theoretically anyone
  implementing a similar IOMMU could make use of this.  We expect the
  IOMMU to support the IOMMU API and have few to no restrictions around
  the IOVA range that can be mapped.  The Type1 IOMMU is currently
  optimized for relatively static mappings of a userspace process with
  userspace pages pinned into memory.  We also assume devices and IOMMU
  domains are PCI based as the IOMMU API is still centered around a
  devicebus interface rather than a group interface.
 IOMMU_CACHE 
 Fine-grained super pages 
 Device address 
 Process virtual addr 
 Map size (bytes) 
 IOMMU_READWRITE 
 capable(CAP_IPC_LOCK) 
 Ex-user pinned pfn list 
 for pin_user_pages_remote 
 if pages alloc fails 
 length of pages array 
 of batch currently 
 of next entry in pages 
  Guest RAM pinning working set or DMA target
 Device address 
 Host pfn 
  Input argument of number of bits to bitmap_set() is unsigned integer, which
  further casts to signed integer for unaligned multi-bit operation,
  __bitmap_set().
  Then maximum bitmap size supported is 2^31 bits divided by 2^3 bitsbyte,
  that is 2^28 (256 MB) which maps to 2^31  2^12 = 2^43 (8TB) on 4K page
  system.
  This code handles mapping and unmapping of user data buffers
  into DMA'ble space using the IOMMU
	
	  Allocate extra 64 bits that are used to calculate shift required for
	  bitmap_shift_left() to manipulate and club unaligned number of pages
	  in adjacent vfio_dma ranges.
  Helper Functions for host iova-pfn list
 process exited 
  Some mappings aren't backed by a struct page, for example an mmap'd
  MMIO range for our own or another device.  These use a different
  pfn conversion and shouldn't be tracked as locked pages.
  For compound pages, any driver that sets the reserved bit in head
  page needs to set the reserved bit in all subpages to be safe.
  Returns the positive number of pfns successfully obtained or a negative
  error code.
  Find dma struct and wait for its vaddr to be valid.  iommu lock is dropped
  if the task waits, but is re-locked on return.  Return result in dma_p.
  Return 0 on success with no waiting, WAITED on success if waited, and -errno
  on error.
  Wait for all vaddr in the dma_list to become valid.  iommu lock is dropped
  if the task waits, but is re-locked on return.  Return 0 on success with no
  waiting, WAITED on success if waited, and -errno on error.
  Attempt to pin pages.  We really don't want to track all the pfns and
  the iommu can only map chunks of consecutive pfns anyway, so get the
  first page and all consecutive pages with the same locking.
 This code path is only user initiated 
 Leftover pages in batch from an earlier call. 
 Empty batch, so refill it. 
		
		  pfn is preset for the first iteration of this inner loop and
		  updated at the end to handle a VM_PFNMAP pfn.  In that case,
		  batch->pages isn't valid (there's no struct page), so allow
		  batch->pages to be touched only when there's more than one
		  pfn to check, which guarantees the pfns are from a
		  !VM_PFNMAP vma.
			
			  Reserved pages aren't counted against the user,
			  externally pinned pages are already counted against
			  the user.
 May be a VM_PFNMAP pfn, which the batch can't remember. 
 Supported for v2 version only 
	
	  Wait for all necessary vaddr's to be valid so they can be used in
	  the main loop without dropping the lock, to avoid racing vs unmap.
 Fail if notifier list is empty 
	
	  If iommu capable domain exist in the container then all pages are
	  already pinned and accounted. Accounting should be done if there is no
	  iommu capable domain in the container.
			
			  Bitmap populated with the smallest supported page
			  size
 Supported for v2 version only 
  Generally, VFIO needs to unpin remote pages after each IOTLB flush.
  Therefore, when using IOTLB flush sync interface, VFIO need to keep track
  of these regions (currently using a list).
  This value specifies maximum number of regions for each IOTLB flush sync.
	
	  Sync if the number of fast-unmap regions hits the limit
	  or in case of errors.
	
	  We use the IOMMU to track the physical addresses, otherwise we'd
	  need a much more complicated tracking system.  Unfortunately that
	  means we need to use one of the iommu domains to figure out the
	  pfns to unpin.  The rest need to be unmapped in advance so we have
	  no iommu translations remaining when the pages are unpinned.
		
		  To optimize for fewer iommu_unmap() calls, each of which
		  may require hardware cache flushing, try to find the
		  largest contiguous physical memory chunk to unmap.
		
		  First, try to use fast unmapunpin. In case of failure,
		  switch to slow unmapunpin path.
	
	  In case the IOMMU supports page sizes smaller than PAGE_SIZE
	  we pretend PAGE_SIZE is supported and hide sub-PAGE_SIZE sizes.
	  That way the user will be able to mapunmap buffers whose size
	  start address is aligned with PAGE_SIZE. Pinning code uses that
	  granularity while iommu driver can use the sub-PAGE_SIZE size
	  to map the buffer.
	
	  mark all pages dirty if any IOMMU capable device is not able
	  to report dirty pages and all pages are pinned and mapped.
	
	  GET_BITMAP request must fully cover vfio_dma mappings.  Multiple
	  vfio_dma mappings may be clubbed by specifying large ranges, but
	  there must not be any previous mappings bisected by the range.
	  An error will be returned if these conditions are not met.
		
		  Re-populate bitmap to include all pinned pages which are
		  considered as dirty but exclude pages which are unpinned and
		  pages which are marked dirty by vfio_dma_rw()
 When dirty tracking is enabled, allow only min supported pgsize 
	
	  vfio-iommu-type1 (v1) - User mappings were coalesced together to
	  avoid tracking individual mappings.  This means that the granularity
	  of the original mapping was lost and the user was allowed to attempt
	  to unmap any range.  Depending on the contiguousness of physical
	  memory and page sizes supported by the IOMMU, arbitrary unmaps may
	  or may not have worked.  We only guaranteed unmap granularity
	  matching the original mapping; even though it was untracked here,
	  the original mappings are reflected in IOMMU mappings.  This
	  resulted in a couple unusual behaviors.  First, if a range is not
	  able to be unmapped, ex. a set of 4k pages that was mapped as a
	  2M hugepage into the IOMMU, the unmap ioctl returns success but with
	  a zero sized unmap.  Also, if an unmap request overlaps the first
	  address of a hugepage, the IOMMU will unmap the entire hugepage.
	  This also returns success and the returned unmap size reflects the
	  actual size unmapped.
	 
	  We attempt to maintain compatibility with this "v1" interface, but
	  we take control out of the hands of the IOMMU.  Therefore, an unmap
	  request offset from the beginning of the original mapping will
	  return success with zero sized unmap.  And an unmap request covering
	  the first iova of mapping will unmap the entire range.
	 
	  The v2 version of this interface intends to be more deterministic.
	  Unmap requests must fully cover previous mappings.  Multiple
	  mappings may still be unmaped by specifying large ranges, but there
	  must not be any previous mappings bisected by the range.  An error
	  will be returned if these conditions are not met.  The v2 interface
	  will only return success and a size of zero if there were no
	  mappings within the range.
		
		  Task with same address space who mapped this iova range is
		  allowed to unmap the iova range.
			
			  Notify anyone (mdev vendor drivers) to invalidate and
			  unmap iovas within the range we're about to unmap.
			  Vendor drivers MUST unpin pages in response to an
			  invalidation.
 Report how much was unmapped 
 Pin a contiguous chunk of memory 
 Map it! 
  Check dma map request is within a valid iova range
	
	  Check for list_empty() as well since a container with
	  a single mdev device will have an empty list.
 Verify that none of our __u64 fields overflow 
 READWRITE from device perspective 
 Don't allow IOVA or virtual address wrap 
	
	  We need to be able to both add to a task's locked memory and test
	  against the locked memory limit and we need to be able to do both
	  outside of this call path as pinning can be asynchronous via the
	  external interfaces for mdev devices.  RLIMIT_MEMLOCK requires a
	  task_struct and VM locked pages requires an mm_struct, however
	  holding an indefinite mm reference is not recommended, therefore we
	  only hold a reference to a task.  We could hold a reference to
	  current, however QEMU uses this call path through vCPU threads,
	  which can be killed resulting in a NULL mm and failure in the unmap
	  path when called via a different thread.  Avoid this problem by
	  using the group_leader as threads within the same group require
	  both CLONE_THREAD and CLONE_VM and will therefore use the same
	  mm_struct.
	 
	  Previously we also used the task for testing CAP_IPC_LOCK at the
	  time of pinning and accounting, however has_capability() makes use
	  of real_cred, a copy-on-write field, so we can't guarantee that it
	  matches group_leader, or in fact that it might not change by the
	  time it's evaluated.  If a process were to call MAP_DMA with
	  CAP_IPC_LOCK but later drop it, it doesn't make sense that they
	  possibly see different results for an iommu_mapped vfio_dma vs
	  externally mapped.  Therefore track CAP_IPC_LOCK in vfio_dma at the
	  time of calling MAP_DMA.
 Insert zero-sized and grow as we map chunks of it 
 Don't pin and map if container doesn't contain IOMMU capable domain
 Arbitrarily pick the first domain in the list for lookups 
 mapped wo a domain?! 
 All dmas are now mapped, defer to second tree walk for unwind 
  We change our unmap behavior slightly depending on whether the IOMMU
  supports fine-grained superpages.  IOMMUs like AMD-Vi will use a superpage
  for practically any contiguous power-of-two mapping we give it.  This means
  we don't need to look for contiguous chunks ourselves to make unmapping
  more efficient.  On IOMMUs with coarse-grained super pages, like Intel VT-d
  with discrete 2M1G512G1T superpages, identifying contiguous chunks
  significantly boosts non-hugetlbfs mappings and doesn't seem to hurt when
  hugetlbfs is in use.
		
		  The presence of any 'real' MSI regions should take
		  precedence over the software-managed one if the
		  IOMMU driver happens to advertise both types.
  This is a helper function to insert an address range to iova list.
  The list is initially created with a single entry corresponding to
  the IOMMU domain geometry to which the device group is attached.
  The list aperture gets modified when a new domain is added to the
  container if the new aperture doesn't conflict with the current one
  or with any existing dma mappings. The list is also modified to
  exclude any reserved regions associated with the device group.
  Check the new iommu aperture conflicts with existing aper or with any
  existing dma mappings.
 Disjoint sets, return conflict 
 Check for any existing dma mappings below the new start 
 Check for any existing dma mappings beyond the new end 
  Resize iommu iova aperture window. This is called only if the new
  aperture has no conflict with existing aperture and dma mappings.
 Adjust iova list start 
 Delete nodes before new start 
 Adjust iova list end 
 Delete nodes after new end 
  Check reserved region conflicts with existing dma mappings
 Check for conflict with existing dma mappings 
  Check iova region overlap with  reserved regions and
  exclude them from the iommu iova range
 No overlap 
			
			  Insert a new node if current node overlaps with the
			  reserve region to exclude that from valid iova range.
			  Note that, new node is inserted before the current
			  node and finally the current node is deleted keeping
			  the list updated and sorted.
 Check for duplicates 
		
		  An emulated IOMMU group cannot dirty memory directly, it can
		  only use interfaces that provide dirty tracking.
		  The iommu scope can only be promoted with the addition of a
		  dirty tracking group.
 Determine bus_type in order to allocate a domain 
 Get aperture info 
	
	  We don't want to work on the original iova list as the list
	  gets modified and in case of failure we have to retain the
	  original list. Get a copy here.
	
	  Try to match an existing compatible domain.  We don't want to
	  preclude an IOMMU driver supporting multiple bus_types and being
	  able to include different bus_types in the same IOMMU domain, so
	  we test whether the domains use the same iommu_ops rather than
	  testing if they're on the same bus_type.
 replay mappings on new domains 
 Delete the old one and insert new iova list 
	
	  An iommu backed group can dirty memory directly and therefore
	  demotes the iommu scope until it declares itself dirty tracking
	  capable via the page pinning interface.
  Called when a domain is removed in detach. It is possible that
  the removed domain decided the iova aperture window. Modify the
  iova aperture with the smallest window among existing domains.
 Modify aperture limits. The new aper is either same or bigger 
  Called when a group is detached. The reserved regions for that
  group can be part of valid iova now. But since reserved regions
  may be duplicated among groups, populate the iova valid regions
  list again.
 purge the iova list and create new one 
 Exclude current reserved regions from iova ranges 
	
	  Get a copy of iova list. This will be used to update
	  and to replace the current one later. Please note that
	  we will leave the original list as it is if update fails.
		
		  Group ownership provides privilege, if the group list is
		  empty, the domain goes away. If it's the last domain with
		  iommu and external domain doesn't exist, then all the
		  mappings go away too. If it's the last domain with iommu and
		  external domain exist, update accounting
	
	  Removal of a group without dirty tracking may allow the iommu scope
	  to be promoted.
		
		  Return 0 as a container with a single mdev device
		  will have an empty list
 support minimum pgsize 
 For backward compatibility, cannot require this 
 output, no-recopy necessary 
 only one flag should be set at a time 
 allow only smallest supported pgsize 
 clear known events 
 refuse to register if still events remaining 
			
			  Bitmap populated with the smallest supported page
			  size
 SPDX-License-Identifier: GPL-2.0-only
  VFIO core
  Copyright (C) 2012 Red Hat, Inc.  All rights reserved.
      Author: Alex Williamson <alex.williamson@redhat.com>
  Derived from original vfio:
  Copyright 2010 Cisco Systems, Inc.  All rights reserved.
  Author: Tom Lyon, pugs@cisco.com
 locks group_list 
	
	  Atomically acquire a singleton object in the xarray for this set_id
  Only noiommu containers can use vfio-noiommu and noiommu containers can only
  use vfio-noiommu.
 CONFIG_VFIO_NOIOMMU 
  IOMMU driver registration
 Check for duplicates 
  Container objects - containers are created when devvfiovfio is
  opened, but their lifecycle extends until the last user is done, so
  it's freed via kref.  Must support containergroupdevice being
  closed in any order.
  Group objects - create, release, get, put, search
 put in vfio_group_release() 
 Did we race creating this group? 
	
	  These data structures all have paired operations that can only be
	  undone when the caller holds a live reference on the group. Since all
	  pairs must be undone these WARN_ON's indicate some caller did not
	  properly hold the group reference.
  Device objects - create, release, get, put, search
 Device reference always implies a group reference 
  Some drivers, like pci-stub, are only used to prevent other drivers from
  claiming a device and are therefore perfectly legitimate for a user owned
  group.  The pci-stub driver has no dependencies on DMA or the IOVA mapping
  of the device, but it does prevent the user from having direct access to
  the device, which is useful in some circumstances.
  We also assume that we can include PCI interconnect devices, ie. bridges.
  IOMMU grouping on PCI necessitates that if we lack isolation on a bridge
  then all of the downstream devices will be part of the same IOMMU group as
  the bridge.  Thus, if placing the bridge into the user owned IOVA space
  breaks anything, it only does so for user owned devices downstream.  Note
  that error notification via MSI can be affected for platforms that handle
  MSI within the same IOVA space as DMA.
  A vfio group is viable for use by userspace if all devices are in
  one of the following states:
   - driver-less
   - bound to a vfio driver
   - bound to an otherwise allowed driver
   - a PCI interconnect device
  We use two methods to determine whether a device is bound to a vfio
  driver.  The first is to test whether the device exists in the vfio
  group.  The second is to test if the device exists on the group
  unbound_list, indicating it's in the middle of transitioning from
  a vfio driver to driver-less.
  Async device support
 Do we already know about it?  We shouldn't 
 Nothing to do for idle groups 
 TODO Prevent device auto probing 
 We don't care what happens when the group isn't in use 
		
		  Nothing to do here.  If the device is in use, then the
		  vfio sub-driver should block the remove callback until
		  it is unused.  If the device is unused or attached to a
		  stub driver, then it should be released and we don't
		  care that it will be going away.
		
		  XXX An unbound device in a live group is ok, but we'd
		  really like to avoid the above BUG_ON by preventing other
		  drivers from binding to it.  Once that occurs, we have to
		  stop the system to maintain isolation.  At a minimum, we'd
		  want a toggle to disable driver auto probe for this device.
  VFIO driver API
		
		  With noiommu enabled, create an IOMMU group for devices that
		  don't already have one and don't have an iommu_ops on their
		  bus.  Taint the kernel because we're about to give a DMA
		  capable device to a user without IOMMU protection.
 The vfio_group holds a reference to the iommu_group 
	
	  If the driver doesn't specify a set then the device is added to a
	  singleton set just for itself.
 Our reference on group is moved to the device 
 Refcounting can't start until the driver calls register 
  Register a virtual device without IOMMU backing.  The user of this
  device must not be able to directly trigger unmediated DMA.
  Get a reference to the vfio_device for a device.  Even if the
  caller thinks they own the device, they could be racing with a
  release call path, so we can't trust drvdata for the shortcut.
  Go the long way around, from the iommu_group to the vfio_group
  to the vfio_device.
  Decrement the device reference count and wait for the device to be
	
	  When the device is removed from the group, the group suddenly
	  becomes non-viable; the device has a driver (until the unbind
	  completes), but it's not present in the group.  This is bad news
	  for any external users that need to re-acquire a group reference
	  in order to match and release their existing reference.  To
	  solve this, we track such devices on the unbound_list to bridge
	  the gap until they're fully unbound.
	
	  In order to support multiple devices per group, devices can be
	  plucked from the group while other devices in the group are still
	  in use.  The container persists with this group and those remaining
	  devices still attached.  If the user creates an isolation violation
	  by binding this device to another driver while the group is still in
	  use, that's their fault.  However, in the case of removing the last,
	  or potentially the only, device in the group there can be no other
	  in-use devices in the group.  The user has done their due diligence
	  and we should lay no claims to those devices.  In order to do that,
	  we need to make sure the group is detached from the container.
	  Without this stall, we're potentially racing with a user process
	  that may attempt to immediately bind this device to another driver.
 Matches the get in vfio_register_group_dev() 
  VFIO base fd, devvfiovfio
 No base extensions yet 
		
		  If no driver is set, poll all registered drivers for
		  extensions and return the first positive result.  If
		  a driver is already set, further queries will be passed
		  only to that driver.
 hold write lock on container->group_lock 
	
	  The container is designed to be an unprivileged interface while
	  the group can be assigned to specific users.  Therefore, only by
	  adding a group to a container does the user get the privilege of
	  enabling the iommu, which may allocate finite resources.  There
	  is no unset_iommu, but by removing all the groups from a container,
	  the container is deprivileged and returns to an unset state.
		
		  The arg magic for SET_IOMMU is the same as CHECK_EXTENSION,
		  so test which iommu driver reported support for this
		  extension and call open on them.  We also pass them the
		  magic, allowing a single driver to support multiple
		  interfaces if they'd like.
 passthrough all unrecognized ioctls 
  VFIO Group fd, devvfio$GROUP
 Detaching the last group deprivileges a container, remove iommu 
  VFIO_GROUP_UNSET_CONTAINER should fail if there are other users or
  if there was no container to unset.  Since the ioctl is called on
  the group, we know that still exists, therefore the only valid
  transition here is 1->0.
  When removing container users, anything that removes the last user
  implicitly removes the group from the container.  That is, if the
  group file descriptor is closed, as well as any device file descriptors,
  the group is free.
 Sanity check, is this really our fd? 
 fget ensures we don't race vfio_release 
 Real groups and fake groups cannot mix 
 Get a reference on the container and mark a user within the group 
	
	  We can't use anon_inode_getfd() because we need to modify
	  the f_mode flags directly to allow more than just ioctls
	
	  TODO: add an anon_inode interface to do this.
	  Appears to be missing by lack of need rather than
	  explicitly prevented.  Now there's need.
 users can be zero if this races with vfio_group_put() 
 Do we need multiple instances of the group open?  Seems not. 
 Is something still in use from a previous open? 
 Warn if previous user didn't cleanup and re-init to drop them 
  VFIO Device fd
  External user API, exported by symbols to be linked dynamically.
  The protocol includes:
   1. do normal VFIO init operation:
 	- opening a new container;
 	- attaching group(s) to it;
 	- setting an IOMMU driver for a container.
  When IOMMU is set for a container, all groups in it are
  considered ready to use by an external user.
  2. User space passes a group fd to an external user.
  The external user calls vfio_group_get_external_user()
  to verify that:
 	- the group is initialized;
 	- IOMMU is set for it.
  If both checks passed, vfio_group_get_external_user()
  increments the container user counter to prevent
  the VFIO group from disposal before KVM exits.
  3. The external user calls vfio_external_user_iommu_id()
  to know an IOMMU ID.
  4. When the external KVM finishes, it calls
  vfio_group_put_external_user() to release the VFIO group.
  This call decrements the container user counter.
	
	  Since the caller holds the fget on the file group->users must be >= 1
  External user API, exported by symbols to be linked dynamically.
  The external user passes in a device pointer
  to verify that:
 	- A VFIO group is assiciated with the device;
 	- IOMMU is set for the group.
  If both checks passed, vfio_group_get_external_user_from_dev()
  increments the container user counter to prevent the VFIO group
  from disposal before external user exits and returns the pointer
  to the VFIO group.
  When the external user finishes using the VFIO group, it calls
  vfio_group_put_external_user() to release the VFIO group and
  decrement the container user counter.
  @dev [in]	: device
  Return error PTR or pointer to VFIO group.
  Sub-module support
  Helper for managing a buffer of info chain capabilities, allocate or
  reallocate a buffer with additional @size, filling in @id and @version
  of the capability.  A pointer to the new capability is returned.
  NB. The chain is based at the head of the buffer, so new entries are
  added to the tail, vfio_info_cap_shift() should be called to fixup the
  next offsets prior to copying to the user buffer.
 Eventually copied to user buffer, zero 
 Add to the end of the capability chain 
 nothing 
  Pin a set of guest PFNs and return their associated host PFNs for local
  domain only.
  @dev [in]     : device
  @user_pfn [in]: array of userguest PFNs to be pinned.
  @npage [in]   : count of elements in user_pfn array.  This count should not
 		   be greater VFIO_PIN_PAGES_MAX_ENTRIES.
  @prot [in]    : protection flags
  @phys_pfn[out]: array of host PFNs
  Return error or number of pages pinned.
  Unpin set of host PFNs for local domain only.
  @dev [in]     : device
  @user_pfn [in]: array of userguest PFNs to be unpinned. Number of userguest
 		   PFNs should not be greater than VFIO_PIN_PAGES_MAX_ENTRIES.
  @npage [in]   : count of elements in user_pfn array.  This count should not
                  be greater than VFIO_PIN_PAGES_MAX_ENTRIES.
  Return error or number of pages unpinned.
  Pin a set of guest IOVA PFNs and return their associated host PFNs for a
  VFIO group.
  The caller needs to call vfio_group_get_external_user() or
  vfio_group_get_external_user_from_dev() prior to calling this interface,
  so as to prevent the VFIO group from disposal in the middle of the call.
  But it can keep the reference to the VFIO group for several calls into
  this interface.
  After finishing using of the VFIO group, the caller needs to release the
  VFIO group by calling vfio_group_put_external_user().
  @group [in]		: VFIO group
  @user_iova_pfn [in]	: array of userguest IOVA PFNs to be pinned.
  @npage [in]		: count of elements in user_iova_pfn array.
 			  This count should not be greater
 			  VFIO_PIN_PAGES_MAX_ENTRIES.
  @prot [in]		: protection flags
  @phys_pfn [out]	: array of host PFNs
  Return error or number of pages pinned.
  Unpin a set of guest IOVA PFNs for a VFIO group.
  The caller needs to call vfio_group_get_external_user() or
  vfio_group_get_external_user_from_dev() prior to calling this interface,
  so as to prevent the VFIO group from disposal in the middle of the call.
  But it can keep the reference to the VFIO group for several calls into
  this interface.
  After finishing using of the VFIO group, the caller needs to release the
  VFIO group by calling vfio_group_put_external_user().
  @group [in]		: vfio group
  @user_iova_pfn [in]	: array of userguest IOVA PFNs to be unpinned.
  @npage [in]		: count of elements in user_iova_pfn array.
 			  This count should not be greater than
 			  VFIO_PIN_PAGES_MAX_ENTRIES.
  Return error or number of pages unpinned.
  This interface allows the CPUs to perform some sort of virtual DMA on
  behalf of the device.
  CPUs readwrite frominto a range of IOVAs pointing to user space memory
  intofrom a kernel buffer.
  As the readwrite of user space memory is conducted via the CPUs and is
  not a real device DMA, it is not necessary to pin the user space memory.
  The caller needs to call vfio_group_get_external_user() or
  vfio_group_get_external_user_from_dev() prior to calling this interface,
  so as to prevent the VFIO group from disposal in the middle of the call.
  But it can keep the reference to the VFIO group for several calls into
  this interface.
  After finishing using of the VFIO group, the caller needs to release the
  VFIO group by calling vfio_group_put_external_user().
  @group [in]		: VFIO group
  @user_iova [in]	: base IOVA of a user space buffer
  @data [in]		: pointer to kernel buffer
  @len [in]		: kernel buffer length
  @write		: indicate read or write
  Return error code on failure or 0 on success.
 clear known events 
 refuse to continue if still events remaining 
	
	  The attaching of kvm and vfio_group might already happen, so
	  here we replay once upon registration.
  Moduleclass support
 devvfio$GROUP 
 SPDX-License-Identifier: GPL-2.0-only
  EEH functionality support for VFIO devices. The feature is only
  available on sPAPR compatible platforms.
  Copyright Gavin Shan, IBM Corporation 2014.
 We might build address mapping here for "fast" path later 
 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
  Copyright 2013-2016 Freescale Semiconductor Inc.
  Copyright 2016-2017,2019-2020 NXP
		
		  Only regions addressed with PAGE granularity may be
		  MMAPed securely.
 reset the device before cleaning up the interrupts 
 map offset to the physical address  
 Write at command parameter into portal 
 Write command header in the end 
	 Wait for response before returning to user-space
	  This can be optimized in future to even prepare response
	  before returning to user-space and avoid read ioctl.
 Non-dprc devices share mc_io from parent 
 open DPRC, allocate a MC portal 
 non dprc devices do not scan for other devices 
 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
  Copyright 2013-2016 Freescale Semiconductor Inc.
  Copyright 2019 NXP
 Device does not support any interrupt 
 interrupts were already allocated for this device 
 Allocate IRQs 
 Disable only 
 Free All IRQs for the given MC object 
	
	  Device does not support any interrupt or the interrupts
	  were not configured
 SPDX-License-Identifier: GPL-2.0-only
  MDEV driver
  Copyright (c) 2016, NVIDIA CORPORATION. All rights reserved.
      Author: Neo Jia <cjia@nvidia.com>
              Kirti Wankhede <kwankhede@nvidia.com>
	
	  No drivers automatically match. Drivers are only bound by explicit
	  device_driver_attach()
  mdev_register_driver - register a new MDEV driver
  @drv: the driver to register
  Returns a negative value on error, otherwise 0.
 initialize common driver fields 
 register with core 
  mdev_unregister_driver - unregister MDEV driver
  @drv: the driver to unregister
 SPDX-License-Identifier: GPL-2.0-only
  File attributes for Mediated devices
  Copyright (c) 2016, NVIDIA CORPORATION. All rights reserved.
      Author: Neo Jia <cjia@nvidia.com>
              Kirti Wankhede <kwankhede@nvidia.com>
 Static functions 
 Pairs with the get in add_mdev_supported_type() 
 Pairs with the put in mdev_type_release() 
 mdev sysfs functions 
 SPDX-License-Identifier: GPL-2.0-only
  VFIO based driver for Mediated device
  Copyright (c) 2016, NVIDIA CORPORATION. All rights reserved.
      Author: Neo Jia <cjia@nvidia.com>
              Kirti Wankhede <kwankhede@nvidia.com>
 SPDX-License-Identifier: GPL-2.0-only
  Mediated device Core Driver
  Copyright (c) 2016, NVIDIA CORPORATION. All rights reserved.
      Author: Neo Jia <cjia@nvidia.com>
              Kirti Wankhede <kwankhede@nvidia.com>
  Return the index in supported_type_groups that this mdev_device was created
  from.
  Used in mdev_type_attribute sysfs functions to return the index in the
  supported_type_groups that the sysfs is called from.
  Used in mdev_type_attribute sysfs functions to return the parent struct
  device
 Should be called holding parent_list_lock 
 Caller must hold parent unreg_sem read or write lock 
 Balances with device_initialize() 
  mdev_register_device : Register a device
  @dev: device structure representing parent device.
  @ops: Parent device operation structure to be registered.
  Add device to list of registered parent devices.
  Returns a negative value on error, otherwise 0.
 check for mandatory ops 
 Check for duplicate 
  mdev_unregister_device : Unregister a parent device
  @dev: device structure representing parent device.
  Remove device from list of registered parent devices. Give a chance to free
  existing mediated devices for given device.
 We still have the caller's reference to use for the uevent 
 Pairs with the get in mdev_device_create() 
 Check for duplicate 
 Pairs with the put in mdev_device_release() 
 Check if parent unregistration has started 
 Check if parent unregistration has started 
 SPDX-License-Identifier: GPL-2.0-only
  VFIO platform devices interrupt handling
  Copyright (C) 2013 - Virtual Open Systems
  Author: Antonios Motakis <a.motakis@virtualopensystems.com>
 automask maskable interrupts 
 Disable only 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2013 - Virtual Open Systems
  Author: Antonios Motakis <a.motakis@virtualopensystems.com>
 probing devices from the linux platform bus 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2013 - Virtual Open Systems
  Author: Antonios Motakis <a.motakis@virtualopensystems.com>
			
			  Only regions addressed with PAGE granularity may be
			  MMAPed securely.
 map offset to the physical address  
 not implemented 
 not implemented 
 not implemented 
  There can be two kernel build combinations. One build where
  ACPI is not selected in Kconfig and another one with the ACPI Kconfig.
  In the first case, vfio_platform_acpi_probe will return since
  acpi_disabled is 1. DT user will not see any kind of messages from
  ACPI.
  In the second case, both DT and ACPI is compiled in but the system is
  booting with any of these combinations.
  If the firmware is DT type, then acpi_disabled is 1. The ACPI probe routine
  terminates immediately without any messages.
  If the firmware is ACPI type, then acpi_disabled is 0. All other checks are
  valid checks. We cannot claim that this system is DT.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2013 - Virtual Open Systems
  Author: Antonios Motakis <a.motakis@virtualopensystems.com>
 probing devices from the AMBA bus 
 zero is an unset IRQ for AMBA devices 
 SPDX-License-Identifier: GPL-2.0-only
  VFIO platform driver specialized for Calxeda xgmac reset
  reset code is inherited from calxeda xgmac native driver
  Copyright 2010-2011 Calxeda, Inc.
  Copyright (c) 2015 Linaro Ltd.
               www.linaro.org
 XGMAC Register definitions 
 MAC Configuration 
 DMA Control and Status Registers 
 Ctrl (Operational Mode) 
 Interrupt Enable 
 DMA Control register defines 
 StartStop Transmission 
 StartStop Receive 
 Common MAC defines 
 Transmitter Enable 
 Receiver Enable 
 disable IRQ 
 Disable the MAC core 
 SPDX-License-Identifier: GPL-2.0-only
  VFIO platform driver specialized for AMD xgbe reset
  reset code is inherited from AMD xgbe native driver
  Copyright (c) 2015 Linaro Ltd.
               www.linaro.org
 reset the PHY through MDIO
 disable auto-negotiation 
 disable AN IRQ 
 clear AN IRQ 
 MAC software reset 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2017 Broadcom
  This driver provides reset support for Broadcom FlexRM ring manager
  to VFIO platform.
 FlexRM configuration 
 Per-Ring register offsets 
 Register RING_CONTROL fields 
 Register RING_FLUSH_DONE fields 
 Disableinactivate ring 
 Set ring flush state 
 timeout of 1s 
 Clear ring flush state 
 timeout of 1s 
 Map FlexRM ring registers if not mapped 
 Discover and shutdown each FlexRM ring 
 SPDX-License-Identifier: GPL-2.0-only
  VFIO PCI IO Port & MMIO access
  Copyright (C) 2012 Red Hat, Inc.  All rights reserved.
      Author: Alex Williamson <alex.williamson@redhat.com>
  Derived from original vfio:
  Copyright 2010 Cisco Systems, Inc.  All rights reserved.
  Author: Tom Lyon, pugs@cisco.com
  Read or write from an __iomem region (MMIO or IO port) with an excluded
  range which is inaccessible.  The excluded range drops writes and fills
  reads with -1.  This is intended for handling MSI-X vector tables and
  leftover space for ROM BARs.
 Fill reads with -1, drop writes 
		
		  The ROM can fill less space than the BAR, so we start the
		  excluded range at the end of the actual ROM.  This makes
		  filling large ROM BARs much faster.
	
	  VGA MMIO is a legacy, non-BAR resource that hopefully allows
	  probing, so we don't currently worry about access in relation
	  to the memory enable bit in the command register.
 Lock contended, use thread 
 Only support ioeventfds into BARs 
 Disallow ioeventfds working around MSI-X table writes 
 SPDX-License-Identifier: GPL-2.0-only
  VFIO PCI config space virtualization
  Copyright (C) 2012 Red Hat, Inc.  All rights reserved.
      Author: Alex Williamson <alex.williamson@redhat.com>
  Derived from original vfio:
  Copyright 2010 Cisco Systems, Inc.  All rights reserved.
  Author: Tom Lyon, pugs@cisco.com
  This code handles reading and writing of PCI configuration registers.
  This is hairy because we want to allow a lot of flexibility to the
  user driver, but cannot trust it with all of the config fields.
  Tables determine which fields can be read and written, as well as
  which fields are 'virtualized' - special actions and translations to
  make it appear to the user that he has control, when in fact things
  must be negotiated with the underlying OS.
 Fake capability ID for standard config space 
  Lengths of PCI Config Capabilities
    0: Removed from the user visible capability list
    FF: Variable length
 pci config header 
 bridge - don't care 
 10, 14, 20, or 24 
 cpci - not yet 
 8 or 24 
 hypertransport 
 variable 
 debug - don't care 
 cpci - not yet 
 hotswap - not yet 
 bridge - don't care 
 AGP8x - not yet 
 secure device not yet 
 20 or 44 
  Lengths of PCIePCI-X Extended Config Capabilities
    0: Removed or masked from the user visible capability list
    FF: Variable length
 root only - don't care 
 root only - don't care 
 root only - don't care 
 same as CAP_ID_VC 
 root only - don't care 
 obsolete 
 not yet 
 not yet 
 not yet 
 not yet 
 not yet 
  ReadWrite Permission Bits - one bit for each bit in capability
  Any field can be read if it exists, but what is read depends on
  whether the field is 'virtualized', or just pass through to the
  hardware.  Any virtualized field is also virtualized for writes.
  Writes are only permitted if they have a 1 bit here.
 readwrite virtual data, not hw 
 writeable bits 
 Any non-virtualized bits? 
 drop, no writable bits 
 Virtualized and writable bits go to vconfig 
 Non-virtualzed and writable bits go to hardware 
 Allow direct read from hardware, except for capability next pointer 
 Extended cap header mangling 
 Std cap mangling 
 Raw access skips any kind of virtualization 
 Virt access uses only virtualization 
 Default capability regions to read-only, no-virtualization 
  Default unassigned regions to raw read-write access.  Some devices
  require this to function as they hide registers between the gaps in
  config space (be2net).  Like MMIO and IO port registers, we have
  to trust the hardware isolation.
	
	  Round up all permission bits to the next dword, this lets us
	  ignore whether a readwrite exceeds the defined capability
	  structure.  We can do this because:
	   - Standard config space is already dword aligned
	   - Capabilities are all dword aligned (bits 0:1 of next reserved)
	   - Express capabilities defined as dword aligned
	
	  Zero state is
	  - All Readable, None Writeable, None Virtualized
  Helper functions for filling in permission tables
 Handle endian-ness - pci and tables are little-endian 
 Handle endian-ness - pci and tables are little-endian 
 Caller should hold memory_lock semaphore 
	
	  SR-IOV VF memory enable is handled by the MSE bit in the
	  PF SR-IOV capability, there's therefore no need to trigger
	  faults based on the virtual value.
  Restore the real BARs after we detect a FLR or backdoor reset.
  (backdoor = some device specific technique that we didn't catch)
  Pretend we're hardware and tweak the values of the virtual PCI BARs
  to reflect the hardware capabilities.  This implements BAR sizing.
 Unmapped by host = unimplemented to user 
	
	  NB. REGION_INFO will have reported zero size if we weren't able
	  to read the ROM, but we still return the actual BAR size here if
	  it exists (or the shadow ROM space).
 pos == offset for basic config 
 Mask in virtual memory enable 
 Test whether BARs match the value we think they should contain 
		
		  If the user is writing memio enable (new_memio) and we
		  think it's already enabled (virt_memio), but the hardware
		  shows it disabled (phys_memio, then the device has
		  undergone some kind of backdoor reset and needs to be
		  restored before we allow it to enable the bars.
		  SR-IOV devices will trigger this - for mem enable let's
		  catch this now and for io enable it will be caught later
	
	  Save current memoryio enable bits in vconfig to allow for
	  the test above next time.
 Emulate INTx disable 
 Permissions for the Basic PCI Header 
 Virtualized for SR-IOV functions, which just have FFFF 
	
	  Virtualize INTx disable, we use it internally for interrupt
	  control and can emulate it for non-PCI 2.3 devices.
 Virtualize capability list, we might want to skipdisable 
 No harm to write 
 Virtualize all bars, can't touch the real ones 
 Allow us to adjust capability chain 
 Sometimes used by sw, just virtualize 
 Virtualize interrupt pin to allow hiding INTx 
 Permissions for the Power Management capability 
	
	  We always virtualize the next field so we can remove
	  capabilities from the chain if we want to.
	
	  Power management is defined per function, so we can let
	  the user change power state, but we trap and initiate the
	  change ourselves, so the state bits are read-only.
	
	  Write through to emulation.  If the write includes the upper byte
	  of PCI_VPD_ADDR, then the PCI_VPD_ADDR_F bit is written and we
	  have work to do.
	
	  Toggle PCI_VPD_ADDR_F in the emulated PCI_VPD_ADDR register to
	  signal completion.  If an error occurs above, we assume that not
	  toggling this bit will induce a driver timeout.
 Permissions for Vital Product Data capability 
	
	  We always virtualize the next field so we can remove
	  capabilities from the chain if we want to.
	
	  Both the address and data registers are virtualized to
	  enable access through the pci_vpd_readwrite functions
 Permissions for PCI-X capability 
 Alloc 24, but only 8 are used in v0 
	
	  The FLR bit is virtualized, if set and the device supports PCIe
	  FLR, issue a reset_function.  Regardless, clear the bit, the spec
	  requires it to be always read as zero.  NB, reset_function might
	  not use a PCIe FLR, we don't have that level of granularity.
	
	  MPS is virtualized to the user, writes do not change the physical
	  register since determining a proper MPS value requires a system wide
	  device view.  The MRRS is largely independent of MPS, but since the
	  user does not have that system-wide view, they might set a safe, but
	  inefficiently low value.  Here we allow writes through to hardware,
	  but we set the floor to the physical device MPS setting, so that
	  we can at least use full TLPs, as defined by the MPS value.
	 
	  NB, if any devices actually depend on an artificially low MRRS
	  setting, this will need to be revisited, perhaps with a quirk
	  though pcie_set_readrq().
 Permissions for PCI Express capability 
 Alloc largest of possible sizes 
	
	  Allow writes to device control fields, except devctl_phantom,
	  which could confuse IOMMU, MPS, which can break communication
	  with other physical devices, and the ARI bit in devctl2, which
	  is set at probe time.  FLR and MRRS get virtualized via our
	  writefn.
	
	  The FLR bit is virtualized, if set and the device supports AF
	  FLR, issue a reset_function.  Regardless, clear the bit, the spec
	  requires it to be always read as zero.  NB, reset_function might
	  not use an AF FLR, we don't have that level of granularity.
 Permissions for Advanced Function capability 
 Permissions for Advanced Error Reporting extended capability 
	
	  Virtualize the first dword of all express capabilities
	  because it includes the next pointer.  This lets us later
	  remove capabilities from the chain if we need to.
 Writable bits mask 
 Undefined 
 Data Link Protocol 
 Surprise Down 
 Poisoned TLP 
 Flow Control Protocol 
 Completion Timeout 
 Completer Abort 
 Unexpected Completion 
 Receiver Overflow 
 Malformed TLP 
 ECRC Error Status 
 Unsupported Request 
 ACS Violation 
 internal error 
 MC blocked TLP 
 Atomic egress blocked 
 TLP prefix blocked 
 Receiver Error Status 
 Bad TLP Status 
 Bad DLLP Status 
 REPLAY_NUM Rollover 
 Replay Timer Timeout 
 Advisory Non-Fatal 
 Corrected Internal 
 Header Log Overflow 
 ECRC Generation Enable 
 ECRC Check Enable 
 Permissions for Power Budgeting extended capability 
 Writing the data selector is OK, the info is still read-only 
  Initialize the shared permission tables
 Basic config space 
 Capabilities 
 Extended capabilities 
 XXX Can we have to abutting capabilities of the same type? 
 Update max available queue size from msi_qmax 
 Fixup and write configured queue size and enable to hardware 
 MSI is enabled via ioctl 
 Check queue size 
 Write back to virt and to hardware 
  MSI determination is per-device, so this routine gets used beyond
  initialization time. Don't add __init
	
	  The upper byte of the control register is reserved,
	  just setup the lower byte.
 Determine MSI CAP field length; initialize msi_perms on 1st call per vdev 
 Minimum size 
 Determine extended capability length for VC (2 & 9) and MFVC 
 extended vc count 
	
	  Port arbitration tables are root & switch only;
	  function arbitration tables are function 0 only.
	  In either case, we'll never let user write them so
	  we don't care how big they are
 Test for extended capabilities 
 length follows next field 
 Test for extended capabilities 
 length based on version and type 
 "All Devices" only, no link 
 No link 
	
	  We try to read physical config space in the largest chunks
	  we can, assuming that all of the fields support dword access.
	  pci_save_state() makes this same assumption and seems to do ok.
 Any capabilities? 
 Done 
 Mark the previous position in case we want to skip a capability 
 We can bound our loop, capabilities are dword aligned 
		
		  ID 0 is a NULL capability, conflicting with our fake
		  PCI_CAP_ID_BASIC.  As it has no content, consider it
		  hidden for now.
 Variable length 
 Sanity check, do we overlap other capabilities? 
 If we didn't fill any capabilities, clear the status flag 
 If not the first in the chain, we can skip over it 
			
			  Otherwise, fill in a placeholder, the direct
			  readfn will virtualize this automatically
		
		  Even though ecap is 2 bytes, we're currently a long way
		  from exceeding 1 byte capabilities.  If we ever make it
		  up to 0xFE we'll need to up this to a two-byte, byte map.
		
		  If we're just using this capability to anchor the list,
		  hide the real ID.  Only count real ecaps.  XXX PCI spec
		  indicates to use cap id = 0, version = 0, next = 0 if
		  ecaps are absent, hope users check all the way to next.
  Nag about hardware bugs, hopefully to have vendors fix them, but at least
  to collect a list of dependencies for the VF INTx pin quirk below.
  For each device we allocate a pci_config_map that indicates the
  capability occupying each dword and thus the struct perm_bits we
  use for read and write.  We also allocate a virtualized config
  space which tracks reads and writes to bits that we emulate for
  the user.  Initial values filled from device.
  Using shared struct perm_bits between all vfio-pci devices saves
  us from allocating cfg_size buffers for virt and write for every
  device.  We could remove vconfig and allocate individual buffers
  for each area requiring emulated bits, but the array of pointers
  would be comparable in size (at least for standard config space).
	
	  Config space, caps and ecaps are all dword aligned, so we could
	  use one byte per dword to record the type.  However, there are
	  no requiremenst on the length of a capability, so the gap between
	  capabilities needs byte granularity.
	
	  XXX can we just pci_load_saved_statepci_restore_state?
	  may need to rebuild vconfig after that
 For restore after reset 
		
		  Per SR-IOV spec rev 1.1, 3.4.1.18 the interrupt pin register
		  does not apply to VFs and VFs must implement this register
		  as read-only with value zero.  Userspace is not readily able
		  to identify whether a device is a VF and thus that the pin
		  definition on the device is bogus should it violate this
		  requirement.  We already virtualize the pin register for
		  other purposes, so we simply need to replace the bogus value
		  and consider VFs when we determine INTx IRQ count.
 Gratuitous for good VFs 
		
		  VFs and devices that set pdev->no_command_memory do not
		  implement the memory enable bit of the COMMAND register
		  therefore we'll not have it set in our initial copy of
		  config space after pci_enable_device().  For consistency
		  with PFs, set the virtual enable bit here.
  Find the remaining number of bytes in a dword that match the given
  position.  Stop at either the end of the capability or the dword boundary.
 nop ;
	
	  Chop accesses into aligned chunks containing no more than a
	  single capability.  Caller increments to the next chunk.
 SPDX-License-Identifier: GPL-2.0-only
  VFIO PCI Intel Graphics support
  Copyright (C) 2016 Red Hat, Inc.  All rights reserved.
 	Author: Alex Williamson <alex.williamson@redhat.com>
  Register a device specific region through which to provide read-only
  access to the Intel IGD opregion.  The register defining the opregion
  address is also virtualized to prevent user modification.
  igd_opregion_shift_copy() - Copy OpRegion to user buffer and shift position.
  @dst: User buffer ptr to copy to.
  @off: Offset to user buffer ptr. Increased by bytes on return.
  @src: Source buffer to copy from.
  @pos: Increased by bytes on return.
  @remaining: Decreased by bytes on return.
  @bytes: Bytes to copy and adjust off, pos and remaining.
  Copy OpRegion to offset from specific source ptr and shift the offset.
  Return: 0 on success, -EFAULT otherwise.
 Copy until OpRegion version 
 Copy patched (if necessary) OpRegion version 
 Patch to 2.1 if OpRegion 2.0 has extended VBT 
 Copy until RVDA 
 Copy modified (if necessary) RVDA 
 Copy the rest of OpRegion 
 Copy extended VBT if exists 
 In KB 
	
	  OpRegion and VBT:
	  When VBT data doesn't exceed 6KB, it's stored in Mailbox #4.
	  When VBT data exceeds 6KB size, Mailbox #4 is no longer large enough
	  to hold the VBT data, the Extended VBT region is introduced since
	  OpRegion 2.0 to hold the VBT data. Since OpRegion 2.0, RVDARVDS are
	  introduced to define the extended VBT data location and size.
	  OpRegion 2.0: RVDA defines the absolute physical address of the
	    extended VBT data, RVDS defines the VBT data size.
	  OpRegion 2.1 and above: RVDA defines the relative address of the
	    extended VBT data to OpRegion base, RVDS defines the VBT data size.
	 
	  Due to the RVDA definition diff in OpRegion VBT (also the only diff
	  between 2.0 and 2.1), exposing OpRegion and VBT as a contiguous range
	  for OpRegion 2.0 and above makes it possible to support the
	  non-contiguous VBT through a single vfio region. From rw ops view,
	  only contiguous VBT after OpRegion with version 2.1+ is exposed,
	  regardless the host OpRegion is 2.0 or non-contiguous 2.1+. The rw
	  ops will on-the-fly shift the actural offset into VBT so that data at
	  correct position can be returned to the requester.
 The extended VBT is valid only when RVDARVDS are non-zero 
			
			  Extended VBT location by RVDA:
			  Absolute physical addr for 2.0.
			  Relative addr to OpRegion header for 2.1+.
 Fill vconfig with the hw value and virtualize register 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2021, NVIDIA CORPORATION & AFFILIATES. All rights reserved
  Copyright (C) 2012 Red Hat, Inc.  All rights reserved.
      Author: Alex Williamson <alex.williamson@redhat.com>
  Derived from original vfio:
  Copyright 2010 Cisco Systems, Inc.  All rights reserved.
  Author: Tom Lyon, pugs@cisco.com
 match all by default 
 no ids passed actually 
 add ids specified in the module parameter 
 Register and scan for devices 
 SPDX-License-Identifier: GPL-2.0-only
  VFIO ZPCI devices support
  Copyright (C) IBM Corp. 2020.  All rights reserved.
 	Author(s): Pierre Morel <pmorel@linux.ibm.com>
                  Matthew Rosato <mjrosato@linux.ibm.com>
  Add the Base PCI Function information to the device info region.
  Add the Base PCI Function Group information to the device info region.
  Add the device utility string to the device info region.
  Add the function path string to the device info region.
  Add all supported capabilities to the VFIO_DEVICE_GET_INFO capability chain.
 SPDX-License-Identifier: GPL-2.0-only
  VFIO PCI interrupt handling
  Copyright (C) 2012 Red Hat, Inc.  All rights reserved.
      Author: Alex Williamson <alex.williamson@redhat.com>
  Derived from original vfio:
  Copyright 2010 Cisco Systems, Inc.  All rights reserved.
  Author: Tom Lyon, pugs@cisco.com
  INTx
	
	  Masking can come from interrupt, ioctl, or config space
	  via INTx disable.  The latter means this can get called
	  even when not using intx delivery.  In this case, just
	  try to have the physical bit follow the virtual bit.
		
		  Can't use check_and_mask here because we always want to
		  mask, not just when something is pending.
  If this is triggered by an eventfd, we can't call eventfd_signal
  or else we'll deadlock on the eventfd wait queue.  Return >0 when
  a signal is necessary, which can then be handled via a work queue
  or directly depending on the caller.
	
	  Unmasking comes from ioctl or config, so again, have the
	  physical bit follow the virtual even when not using INTx.
		
		  A pending interrupt here would immediately trigger,
		  but we can avoid that overhead by just re-sending
		  the interrupt to the user.
 may be shared 
	
	  If the virtual interrupt is masked, restore it.  Devices
	  supporting DisINTx can be masked at the hardware level
	  here, non-PCI-2.3 devices will have to wait until the
	  interrupt is enabled.
 Disable only 
	
	  INTx disable will stick across the new irq setup,
	  disable_irq won't.
  MSIMSI-X
 return the number of supported vectors if we can't get all: 
		
		  Compute the virtual hardware field for max msi vectors -
		  it is the log base 2 of the number of vectors.
	
	  The MSIx vector table resides in device memory which may be cleared
	  via backdoor resets. We don't allow direct access to the vector
	  table so even if a userspace driver attempts to saverestore around
	  such a reset it would be unsuccessful. To avoid this, restore the
	  cached value of the message prior to enabling.
	
	  Both disable paths above use pci_intx_for_msi() to clear DisINTx
	  via their shutdown paths.  Restore for NoINTx devices.
  IOCTL support
 XXX implement me 
 DATA_NONEDATA_BOOL enables loopback testing 
 XXX Need masking support exported 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2012 Red Hat, Inc.  All rights reserved.
      Author: Alex Williamson <alex.williamson@redhat.com>
  Derived from original vfio:
  Copyright 2010 Cisco Systems, Inc.  All rights reserved.
  Author: Tom Lyon, pugs@cisco.com
  Our VGA arbiter participation is limited since we don't know anything
  about the device itself.  However, if the device is the only VGA device
  downstream of a bridge and VFIO VGA support is disabled, then we can
  safely return legacy VGA IO and memory as not decoded since the user
  has no way to get to it and routing can be disabled externally at the
  bridge.
		
		  The PCI core shouldn't set up a resource with a
		  type but zero size. But there may be bugs that
		  cause us to do that.
			
			  Add a dummy resource to reserve the remainder
			  of the exclusive page in case that hot-add
			  device's bar is assigned into it.
		
		  Here we don't handle the case when the BAR is not page
		  aligned because we can't expect the BAR will be
		  assigned into the same location in a page in guest
		  when we passthrough the BAR. And it's hard to access
		  this BAR in userspace because we have no way to get
		  the BAR's location in a page.
  INTx masking requires the ability to disable INTx signaling via PCI_COMMAND
  _and_ the ability detect when the device is asserting INTx via PCI_STATUS.
  If a device implements the former but not the latter we would typically
  expect broken_intx_masking be set and require an exclusive interrupt.
  However since we do have control of the device's ability to assert INTx,
  we can instead pretend that the device does not implement INTx, virtualizing
  the pin register to report zero and maintaining DisINTx set on the host.
 All i40e (XL710X710XXV710) 10202540GbE NICs 
 X550 
  pci_set_power_state() wrapper handling devices which perform a soft reset on
  D3->D0 transition.  Save state prior to D012->D3, stash it on the vdev,
  restore when returned to D0.  Saved separately from pci_saved_state for use
  by PM capability emulation and separately from pci_dev internal saved state
  to avoid it being overwritten and consumed around other resets.
 D3 might be unsupported via quirk, skip unless in D3 
 Don't allow our initial saved state to include busmaster 
 If reset fails because of the device lock, fail this path entirely 
 For needs_reset 
 Stop the device from further DMA 
 Device closed, don't need mutex here 
 don't krealloc a freed pointer 
	
	  If we have saved state, restore it.  If we can reset the device,
	  even better.  Resetting with current state seems better than
	  nothing, but saving and restoring current state without reset
	  is just busy work.
	
	  Disable INTx and MSI, presumably to avoid spurious interrupts
	  during reset.  Stolen from pci_reset_function()
	
	  Try to get the locks ourselves to prevent a deadlock. The
	  success of this is dependent on being able to lock the device,
	  which is not always possible.
	  We can not use the "try" reset interface here, which will
	  overwrite the previously restored configuration information.
 Something changed, try again 
 Cannot reset non-isolated devices 
 For backward compatibility, cannot require this 
 Report the BAR size, not the ROM size 
 Shadow ROMs appear as PCI option ROMs 
			
			  Is it really there?  Enable memory decode for
			  implicit access in pci_map_rom().
 Can we do a slot or bus reset or neither? 
 How many devices are affected? 
 Should always be at least one 
		
		  If there's enough space, fill it now, otherwise return
		  -ENOSPC and the number of devices affected.
		
		  If a device was removed between counting and filling,
		  we may come up short of fill.max.  If a device was
		  added, we'll have a return of -EAGAIN above.
 Can we do a slot or bus reset or neither? 
		
		  We can't let userspace give us an arbitrarily large
		  buffer to copy, so verify how many we think there
		  could be.  Note groups can have multiple devices so
		  one group per device is the max.
 Somewhere between 1 and count is OK 
		
		  For each group_fd, get the group through the vfio external
		  user interface and store the group and iommu ID.  This
		  ensures the group is held across the reset.
 release reference to groups on error 
 Check unknown flags 
 GET & SET are mutually exclusive except with PROBE 
			
			  We do not support GET of the VF Token UUID as this
			  could expose the token of the previous device user.
 Don't SET unless told to do so 
 Return 1 on zap and vma_lock acquired, 0 on contention (only with @try) 
	
	  Lock ordering:
	  vma_lock is nested under mmap_lock for vm_ops callback paths.
	  The memory_lock semaphore is used by both code paths calling
	  into this function to zap vmas and the vm_ops.fault callback
	  to protect the memory enable state of the device.
	 
	  When zapping vmas we need to maintain the mmap_lock => vma_lock
	  ordering, which requires using vma_lock to walk vma_list to
	  acquire an mm, then dropping vma_lock to get the mmap_lock and
	  reacquiring vma_lock.  This logic is derived from similar
	  requirements in uverbs_user_mmap_disassociate().
	 
	  mmap_lock must always be the top-level lock when it is taken.
	  Therefore we can only hold the memory_lock write lock when
	  vma_list is empty, as we'd need to take mmap_lock to clear
	  entries.  vma_list can only be guaranteed empty when holding
	  vma_lock, thus memory_lock is nested under vma_lock.
	 
	  This enables the vm_ops.fault callback to acquire vma_lock,
	  followed by memory_lock read lock, while already holding
	  mmap_lock without risk of deadlock.
 Caller holds vma_lock 
  Zap mmaps on open so that we can fault them in on access and therefore
  our vma_list only tracks mappings accessed since last zap.
	
	  We populate the whole vma on fault, so we need to test whether
	  the vma has already been mapped, such as for concurrent faults
	  to the same vma.  io_remap_pfn_range() will trigger a BUG_ON if
	  we ask it to fill the same range again.
	
	  Even though we don't make use of the barmap for the mmap,
	  we need to request the region and the barmap tracks that.
	
	  See remap_pfn_range(), called from vfio_pci_fault() but we can't
	  change vm_flags within the fault handler.  Set them now.
	
	  There's always some degree of trust or collaboration between SR-IOV
	  PF and VFs, even if just that the PF hosts the SR-IOV capability and
	  can disrupt VFs with a reset, but often the PF has more explicit
	  access to deny service to the VF or access data passed through the
	  VF.  We therefore require an opt-in via a shared VF token (UUID) to
	  represent this trust.  This both prevents that a VF driver might
	  assume the PF driver is a trusted, in-kernel driver, and also that
	  a PF driver might be replaced with a rogue driver, unknown to in-use
	  VF drivers.
	 
	  Therefore when presented with a VF, if the PF is a vfio device and
	  it is bound to the vfio-pci driver, the user needs to provide a VF
	  token to access the device, in the form of appending a vf_token to
	  the device name, for example:
	 
	  "0000:04:10.0 vf_token=bd8d9d2b-5a5f-4f5a-a211-f591514ba1f3"
	 
	  When presented with a PF which has VFs in use, the user must also
	  provide the current VF token to prove collaboration with existing
	  VF users.  If VFs are not in use, the VF token provided for the PF
	  device will act to set the VF token.
	 
	  If the VF token is provided but unused, an error is generated.
 No VF token provided or required 
 PF is not vfio-pci, no VF token 
 No match 
 No match: non-whitespace after name 
 Unknownduplicate option 
 Match 
	
	  Prevent binding to PFs with VFs enabled, the VFs might be in use
	  by the host or other users.  We cannot capture the VFs if they
	  already exist, nor can we track VF users.  Disabling SR-IOV here
	  would initiate removing the VFs, which would unbind the driver,
	  which is prone to blocking if that VF is also in use by vfio-pci.
	  Just reject these PFs and let the user sort it out.
		
		  If there is no slot reset support for this device, the whole
		  bus needs to be grouped together to support bus-wide resets.
		
		  pci-core sets the device power state to an unknown value at
		  bootup and after being removed from a driver.  The only
		  transition it allows from this unknown state is to D0, which
		  typically happens when a driver calls pci_enable_device().
		  We're not ready to enable the device yet, but we do want to
		  be able to get to D3.  Therefore first do a D0 transition
		  before going to D3.
  vfio-core considers a group to be viable and will create a vfio_device even
  if some devices are bound to drivers like pci-stub or pcieport. Here we
  require all PCI devices to be inside our dev_set since that ensures they stay
  put and that every driver controlling the device can co-ordinate with the
  device reset.
  Returns the pci_dev to pass to pci_reset_bus() if every PCI device to be
  reset is inside the dev_set, and pci_reset_bus() can succeed. NULL otherwise.
	
	  By definition all PCI devices in the dev_set share the same PCI
	  reset, so any pci_dev will have the same outcomes for
	  pci_probe_reset_() and pci_reset_bus().
 pci_reset_bus() is supported 
  We need to get memory_lock for each device, but devices can share mmap_lock,
  therefore we need to zap and hold the vma_lock for each device, and only then
  get each memory_lock.
		
		  Test whether all the affected devices are contained by the
		  set of groups provided by the user.
		
		  Locking multiple devices is prone to deadlock, runaway and
		  unwind if we hit contention.
 No VFIO device in the set can have an open device FD 
  If a bus or slot reset is available for the provided dev_set and:
   - All of the devices affected by that bus or slot reset are unused
   - At least one of the affected devices is marked dirty via
     needs_reset (such as by lack of FLR support)
  Then attempt to perform that bus or slot reset.
  Returns true if the dev_set was reset.
 Allocate shared config space permission data used by all devices 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2016 Linaro Ltd.
  Author: Linus Walleij <linus.walleij@linaro.org>
 STMPE 24xx PWM instructions 
 Only available on 2403 
 Make sure we are disabled 
 Connect the PWM to the pin 
 On STMPE2401 and 2403 pins 21,22,23 are used 
 STMPE24XX 
 Should not happen as npwm is 3 
 off all the time 
 LOAD 0xff 
 on all the time 
 LOAD 0x00 
		
		  Counter goes from 0x00 to 0xff repeatedly at 32768 Hz,
		  (means a period of 30517 ns) then this is compared to the
		  counter from the ramp, if this is >= PWM counter the output
		  is high. With LOAD we can define how much of the cycle it
		  is on.
		 
		  Prescale = 0 -> 2 kHz -> T = 1f = 488281.25 ns
 Scale to 0..0xff 
 Run the old program 
 STMPE2403 can simply set the right PWM value 
 STMPE2401 need a complex program 
 Count up 
 Count down 
 Step to desired value, smoothly 
 Loop eternally to 0x00 
	
	  We can write programs of up to 64 16-bit words into this channel.
 If we were enabled, re-enable this PWM 
 Sleep for 200ms so we're sure it will take effect 
 SPDX-License-Identifier: GPL-2.0-or-later
  PWM Controller Driver for HiSilicon BVT SoCs
  Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
		
		  Some implementations require the PWM to be enabled twice
		  each time the duty cycle is refreshed.
 SPDX-License-Identifier: GPL-2.0-only
  Intel Low Power Subsystem PWM controller driver
  Copyright (C) 2014, Intel Corporation
  Author: Mika Westerberg <mika.westerberg@linux.intel.com>
  Author: Chew Kean Ho <kean.ho.chew@intel.com>
  Author: Chang Rebecca Swee Fun <rebecca.swee.fun.chang@intel.com>
  Author: Chew Chiau Ee <chiau.ee.chew@intel.com>
  Author: Alan Cox <alan@linux.intel.com>
 Size of each PWM register space if multiple 
	
	  PWM Configuration register has SW_UPDATE bit that is set when a new
	  configuration is written to the register. The bit is automatically
	  cleared at the start of the next output cycle by the IP block.
	 
	  If one writes a new configuration to the register while it still has
	  the bit enabled, PWM may freeze. That is, while one can still write
	  to the register, it won't have an effect. Thus, we try to sleep long
	  enough that the bit gets cleared and make sure the bit is not
	  enabled while we update the configuration.
	
	  The equation is:
	  base_unit = round(base_unit_range  freq  c)
 base_unit must not be 0 and we also want to avoid overflowing it 
 SPDX-License-Identifier: GPL-2.0-only
  Driver for Allwinner sun4i Pulse Width Modulation Controller
  Copyright (C) 2014 Alexandre Belloni <alexandre.belloni@free-electrons.com>
  Limitations:
  - When outputing the source clock directly, the PWM logic will be bypassed
    and the currently running period is not guaranteed to be completed
 Actually 1 but tested separately 
	
	  PWM chapter in H6 manual has a diagram which explains that if bypass
	  bit is set, no other setting has any meaning. Even more, experiment
	  proved that also enable bit is ignored in this case.
 Skip calculation of other parameters if we bypass them 
 First, test without any prescaler when available 
		
		  When not using any prescaler, the clock period in nanoseconds
		  is not an integer so round it half up instead of
		  truncating to get less surprising values.
 Go up from the first divider 
 We can skip other parameter 
 Prescaler changed, the clock has to be gated 
 We need a full period to elapse before disabling the channel. 
 sentinel 
	
	  All hardware variants need a source clock that is divided and
	  then feeds the counter that defines the output wave form. In the
	  device tree this clock is either unnamed or called "mod".
	  Some variants (e.g. H6) need another clock to access the
	  hardware registers; this is called "bus".
	  So we request "mod" first (and ignore the corner case that a
	  parent provides a "mod" clock while the right one would be the
	  unnamed one of the PWM device) and if this is not found we fall
	  back to the first clock of the PWM.
 Deassert reset 
	
	  We're keeping the bus clock on for the sake of simplicity.
	  Actually it only needs to be on for hardware register accesses.
 SPDX-License-Identifier: GPL-2.0-or-later
  Broadcom BCM7038 PWM driver
  Author: Florian Fainelli
  Copyright (C) 2015 Broadcom Corporation
 Number of bits for the CWORD value 
  Maximum control word value allowed when variable-frequency PWM is used as a
  clock for the constant-frequency PMW.
  Fv is derived from the variable frequency output. The variable frequency
  output is configured using this formula:
  W = cword, if cword < 2 ^ 15 else 16-bit 2's complement of cword
  Fv = W x 2 ^ -16 x 27Mhz (reference clock)
  The period is: (period + 1)  Fv and "on" time is on  (period + 1)
  The PWM core framework specifies that the "duty_ns" parameter is in fact the
  "on" time, so this translates directly into our HW programming here.
	
	  If asking for a duty_ns equal to period_ns, we need to substract
	  the period value by 1 to make it shorter than the "on" time and
	  produce a flat 100% duty cycle signal, and max out the "on" time
		
		  Calculate the base rate from base frequency and current
		  cword
		
		  We can be called with separate duty and period updates,
		  so do not reject dc == 0 right away
 We converged on a calculation 
		
		  The cword needs to be a power of 2 for the variable
		  frequency generator to output a 50% duty cycle variable
		  frequency which is used as input clock to the fixed
		  frequency generator.
		
		  Desired periods are too large, we do not have a divider
		  for them
	
	  Configure the defined "cword" value to have the variable frequency
	  generator output a base frequency for the constant frequency
	  generator to derive from.
 Select constant frequency signal output 
 Configure on and period value 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2007 Ben Dooks
  Copyright (c) 2008 Simtec Electronics
      Ben Dooks <ben@simtec.co.uk>, <ben-linux@fluff.org>
  Copyright (c) 2013 Tomasz Figa <tomasz.figa@gmail.com>
  Copyright (c) 2017 Samsung Electronics Co., Ltd.
  PWM driver for Samsung SoCs
 For struct samsung_timer_variant and samsung_pwm_lock. 
  Each channel occupies 4 bits in TCON register, but there is a gap of 4
  bits (one channel) after channel 0, so channels have different numbering
  when accessing TCON register. See to_tcon_channel() function.
  In addition, the location of autoreload bit for channel 4 (TCON channel 5)
  in its set of bits is 2 as opposed to 3 for other channels.
  struct samsung_pwm_channel - private data of PWM channel
  @period_ns:	current period in nanoseconds programmed to the hardware
  @duty_ns:	current duty time in nanoseconds programmed to the hardware
  @tin_ns:	time of one timer tick in nanoseconds with current timer rate
  struct samsung_pwm_chip - private data of PWM chip
  @chip:		generic PWM chip
  @variant:		local copy of hardware variant data
  @inverter_mask:	inverter status for all channels - one bit per channel
  @disabled_mask:	disabled status for all channels - one bit per channel
  @base:		base address of mapped PWM registers
  @base_clk:		base clock used to drive the timers
  @tclk0:		external clock 0 (can be ERR_PTR if not present)
  @tclk1:		external clock 1 (can be ERR_PTR if not present)
  PWM block is shared between pwm-samsung and samsung_pwm_timer drivers
  and some registers need access synchronization. If both drivers are
  compiled in, the spinlock is defined in the clocksource driver,
  otherwise following definition is used.
  Currently we do not need any more complex synchronization method
  because all the supported SoCs contain only one instance of the PWM
  IP. Should this change, both drivers will need to be modified to
  properly synchronize accesses to particular instances.
 TCON register has a gap of 4 bits (1 channel) after channel 0 
	
	  Compare minimum PWM frequency that can be achieved with possible
	  divider settings and choose the lowest divisor that can generate
	  frequencies lower than requested.
 Only for s3c24xx 
		
		  Other variants have enough counter bits to generate any
		  requested rate, so no need to check higher divisors.
	
	  In case the PWM is at 100% duty cycle, force a manual
	  update to prevent the signal from staying high.
	
	  We currently avoid using 64bit arithmetic by using the
	  fact that anything faster than 1Hz is easily representable
	  by 32bits.
 We need tick count for calculation, not last tick. 
 Check to see if we are changing the clock rate of the PWM. 
 Period is too short. 
 Note that counters count down. 
 0% duty is not available 
 Decrement to get tick numbers, instead of tick counts. 
 -1UL will give 100% duty. 
 Update PWM registers. 
	
	  In case the PWM is currently at 100% duty cycle, force a manual
	  update to prevent the signal staying high if the PWM is disabled
	  shortly afer this update (before it autoreloaded the new values).
 Inverted means normal in the hardware. 
 Following clocks are optional. 
 needed to make PWM disable work on Odroid-XU3 
  Copyright (C) 2016 Broadcom
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 must be a 400 ns delay between clearing and setting enable bit 
 must be a 400 ns delay between clearing and setting enable bit 
	
	  Find period count, duty count and prescale to suit duty_cycle and
	  period. This is done according to formulas described below:
	 
	  period_ns = 10^9  (PRESCALE + 1)  PC  PWM_CLK_RATE
	  duty_ns = 10^9  (PRESCALE + 1)  DC  PWM_CLK_RATE
	 
	  PC = (PWM_CLK_RATE  period_ns)  (10^9  (PRESCALE + 1))
	  DC = (PWM_CLK_RATE  duty_ns)  (10^9  (PRESCALE + 1))
 Otherwise, increase prescale and recalculate counts 
 Set prescale 
 set period and duty cycle 
 set polarity 
 Set full drive and normal polarity for all channels 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) STMicroelectronics 2016
  Author: Gerald Baeza <gerald.baeza@st.com>
  Inspired by timer-stm32.c from Maxime Coquelin
              pwm-atmel.c from Bo Shen
 protect pwm configenable 
 DMA'able buffer 
  Capture using PWM input mode:
                               ___          ___
  TI[1, 2, 3 or 4]: ........._|   |________|
                              ^0  ^1       ^2
                               .   .        .
                               .   .        XXXXX
                               .   .   XXXXX     |
                               .  XXXXX     .    |
                             XXXXX .        .    |
  COUNTER:        ______XXXXX  .   .        .    |_XXX
                  start^       .   .        .        ^stop
                       .       .   .        .
                       v       v   .        v
                                   v
  CCR1CCR3:       tx..........t0...........t2
  CCR2CCR4:       tx..............t1.........
  DMA burst transfer:          |            |
                               v            v
  DMA buffer:                  { t0, tx }   { t2, t1 }
  DMA done:                                 ^
  0: IC13 snapchot on rising edge: counter value -> CCR1CCR3
     + DMA transfer CCR[13] & CCR[24] values (t0, tx: doesn't care)
  1: IC24 snapchot on falling edge: counter value -> CCR2CCR4
  2: IC13 snapchot on rising edge: counter value -> CCR1CCR3
     + DMA transfer CCR[13] & CCR[24] values (t2, t1)
  DMA done, compute:
  - Period     = t2 - t0
  - Duty cycle = t1 - t0
 Ensure registers have been updated, enable counter and capture 
 Use cc1 or cc3 DMA resp for PWM input channels 1 & 2 or 3 & 4 
	
	  Timer DMA burst mode. Request 2 registers, 2 bursts, to get both
	  CCR1 & CCR2 (or CCR3 & CCR4) on each capture event.
	  We'll get two capture snapchots: { CCR1, CCR2 }, { CCR1, CCR2 }
	  or { CCR3, CCR4 }, { CCR3, CCR4 }
 Period: t2 - t0 (take care of counter overflow) 
 Duty cycle capture requires at least two capture units 
		
		  Race beetween PWM input and DMA: it may happen
		  falling edge triggers new capture on TI24 before DMA
		  had a chance to read CCR24. It means capture[1]
		  contains period + duty_cycle. So, subtract period.
 prescaler: fit timeout window provided by upper layer 
 Map TI1 or TI2 PWM input to IC1 & IC2 (or TI34 to IC3 & IC4) 
 Capture period on IC13 rising edge, duty cycle on IC24 falling. 
	
	  Got a capture. Try to improve accuracy at high rates:
	  - decrease counter clock prescaler, scale up to max rate.
	  - use input prescaler, capture once every 2 4 or 8 edges.
 arbitrary margin 
 bellow resolution, use max scale 
 2nd measure with new scale 
 Compute intermediate period not to exceed timeout at low rates 
 input prescaler: also keep arbitrary margin 
 Last chance to improve period accuracy, using input prescaler 
		
		  We may fall here using input prescaler, when input
		  capture starts on high side (before falling edge).
		  Example with icpsc to capture on each 4 events:
		 
		        start   1st capture                     2nd capture
		          v     v                               v
		          ___   _____   _____   _____   _____   ____
		  TI1..4     |__|    |__|    |__|    |__|    |__|
		             v  v    .  .    .  .    .       v  v
		  icpsc13:  .  0    .  1    .  2    .  3    .  0
		  icpsc24:  0       1       2       3       0
		             v  v                            v  v
		  CCR13  ......t0..............................t2
		  CCR24  ..t1..............................t1'...
		                .                            .  .
		  Capture0:     .<----------------------------->.
		  Capture1:     .<-------------------------->.  .
		                .                            .  .
		  Period:       .<------>                    .  .
		  Low side:                                  .<>.
		 
		  Result:
		  - Period = Capture0  icpsc
		  - Duty = Period - Low side = Period - (Capture0 - Capture1)
 Period and prescaler values depends on clock rate 
	
	  All channels share the same prescaler and counter so when two
	  channels are active at the same time we can't change them
 Calculate the duty cycles 
 Configure output mode 
 Enable channel 
 Make sure that registers are updated 
 Enable controller 
 Disable channel 
 When all channels are disabled, we can disable the controller 
 protect common prescaler for all active channels 
	
	  Because "st,breakinput" parameter is optional do not make probe
	  failed if it doesn't exist.
	
	  If complementary bit doesn't exist writing 1 will have no
	  effect so we can detect it.
	
	  If channels enable bits don't exist writing 1 will have no
	  effect so we can detect and count them.
 Look for active channels 
 restore breakinput registers that may have been lost in low power 
 end node  },
