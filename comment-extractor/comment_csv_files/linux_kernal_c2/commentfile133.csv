 SPDX-License-Identifier: GPL-2.0
  STM32 Low-Power Timer PWM driver
  Copyright (C) STMicroelectronics 2017
  Author: Gerald Baeza <gerald.baeza@st.com>
  Inspired by Gerald Baeza's pwm-stm32 driver
 STM32 Low-Power Timer is preceded by a configurable power-of-2 prescaler 
 Disable LP timer 
 disable clock to PWM counter 
 Calculate the period and prescaler value 
 Clock is too slow to achieve requested period. 
 Calculate the duty cycle 
 enable clock to drive PWM counter 
 Must disable LP timer to modify CFGR 
 Must (re)enable LP timer to modify CMP & ARR 
 ensure CMP & ARR registers are properly written 
 Start LP timer in continuous mode 
 Keep PWM counter clock refcount in sync with PWM initial state 
 SPDX-License-Identifier: GPL-2.0-or-later
  PWM device driver for ST SoCs
  Copyright (C) 2013-2016 STMicroelectronics (R&D) Limited
  Author: Ajit Pal Singh <ajitpal.singh@st.com>
          Lee Jones <lee.jones@linaro.org>
 Device's Duty Cycle register 
 Capture value 
 Edge to capture on 
 ControlConfig register 
 Interrupt EnableDisable register 
 Interrupt Status register 
 Regfield IDs 
 Bits in PWM_CTRL
 Keep last 
  Each capture input can be programmed to detect rising-edge, falling-edge,
  either edge or neither egde.
 To sync between enabledisable calls 
  Calculate the prescaler value corresponding to the period.
	
	  prescale = ((period_ns  clk_rate)  (10^9  (max_pwm_cnt + 1)) - 1
  For STiH4xx PWM IP, the PWM period is fixed to 256 local clock cycles. The
  only way to change the period (apart from changing the PWM input clock) is
  to change the PWM clock prescaler.
  The prescaler is of 8 bits, so 256 prescaler values and hence 256 possible
  period values are supported (for a particular clock rate). The requested
  period will be applied only if it matches one of these 256 values.
	
	  Allow configuration changes if one of the following conditions
	  satisfy.
	  1. No devices have been configured.
	  2. Only one device has been configured and the new request is for
	     the same device.
	  3. Only one device has been configured and the new request is for
	     a new device and period of the new device is same as the current
	     configured period.
	  4. More than one devices are configured and period of the new
	     requestis the same as the current period.
 Enable clock before writing to PWM registers. 
		
		  When PWMVal == 0, PWM pulse = 1 local clock cycle.
		  When PWMVal == max_pwm_count,
		  PWM pulse = (max_pwm_count + 1) local cycles,
		  that is continuous pulse: signal never goes low.
	
	  Since we have a common enable for all PWM devices, do not enable if
	  already enabled.
 Prepare capture measurement 
 Enable capture 
		
		  Getting here could mean:
		   - input signal is constant of less than 1 Hz
		   - there is no input signal at all
		 
		  In such case the frequency is rounded down to 0
 We have everying we need 
 Disable capture 
		
		  Capture input:
		     _______                   _______
		    |       |                 |       |
		  __|       |_________________|       |________
		    ^0      ^1                ^2
		 
		  Capture start by the first available rising edge. When a
		  capture event occurs, capture value (CPT_VALx) is stored,
		  index incremented, capture edge changed.
		 
		  After the capture, if the index > 1, we have collected the
		  necessary data so we signal the thread waiting for it and
		  disable the capture by setting capture edge to none
 Just ACK everything 
	
	  Setup PWM data with default values: some values could be replaced
	  with specific ones provided from Device Tree.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  Intel Keem Bay PWM driver
  Copyright (C) 2020 Intel Corporation
  Authors: Lai Poey Seng <poey.seng.lai@intel.com>
           Vineetha G. Jaya Kumaran <vineetha.g.jaya.kumaran@intel.com>
  Limitations:
  - Upon disabling a channel, the currently running
    period will not be completed. However, upon
    reconfiguration of the duty cycleperiod, the
    currently running period will be completed first.
 Mask 
 PWM Register offset 
  With gcc 10, CONFIG_CC_OPTIMIZE_FOR_SIZE and only "inline" instead of
  "__always_inline" this fails to compile because the compiler doesn't notice
  for all valid masks (e.g. KMB_PWM_LEADIN_MASK) that they are ok.
 Read channel enabled status 
 Read period and duty cycle 
	
	  Configure the pwm repeat count as infinite at (15:0) and leadin
	  low time as 0 at (30:16), which is in terms of clock cycles.
	
	  The upper 16 bits and lower 16 bits of the KMB_PWM_HIGHLOW_OFFSET
	  register contain the high time and low time of waveform accordingly.
	  All the values are in terms of clock cycles.
 SPDX-License-Identifier: GPL-2.0-or-later
  EHRPWM PWM driver
  Copyright (C) 2012 Texas Instruments, Inc. - https:www.ti.com
 EHRPWM registers and bits definitions 
 Time base module registers 
 compare module registers 
 Action qualifier module registers 
 EHRPWM channels 
  set_prescale_div -	Set up the prescaler divider function
  @rqst_prescaler:	prescaler value min
  @prescale_div:	prescaler value set
  @tb_clk_div:		Time Base Control prescaler bits
			
			  calculations for prescaler value :
			  prescale_div = HSPCLKDIVIDER  CLKDIVIDER.
			  HSPCLKDIVIDER =  2  hspclkdiv
			  CLKDIVIDER = (1),		if clkdiv == 0 OR
			 		(2  clkdiv),	if clkdiv != 0
			 
			  Configure prescale_div value such that period
			  register value is less than 65535.
	
	  Configure PWM output to HIGHLOW level on counter
	  reaches compare register value and LOWHIGH level
	  on counter value reaches period register value and
	  zero value on counter
  period_ns = 10^9  (ps_divval  period_cycles)  PWM_CLK_RATE
  duty_ns   = 10^9  (ps_divval  duty_cycles)  PWM_CLK_RATE
	
	  Period values should be same for multiple PWM channels as IP uses
	  same period register for multiple channels.
			
			  Allow channel to reconfigure period if no other
			  channels being configured.
 Configure clock prescaler to support Low frequency PWM wave 
 Update clock prescaler values 
 Update period & duty cycle with presacler division 
 Configure shadow loading on Period register 
 Configure ehrpwm counter for up-count mode 
 Channel 1 configured with compare B register 
 Channel 0 configured with compare A register 
 Configuration of polarity in hardware delayed, do at enable 
 Leave clock enabled on enabling PWM 
 Disabling Action Qualifier on PWM output 
 Changes to shadow mode 
 Channels polarity can be configured from action qualifier module 
 Enable TBCLK 
 Action Qualifier puts PWM output low forcefully 
 Update shadow register first before modifying active register 
	
	  Changes to immediate action on Action Qualifier. This puts
	  Action Qualifier control on PWM output from next TBCLK
 Disabling TBCLK on PWM disable 
 Disable clock on PWM disable 
 set period value to zero on free 
 Acquire tbclk for Time Base EHRPWM submodule 
 Disable explicitly if PWM is running 
 Enable explicitly if PWM was running 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (C) 2010, Lars-Peter Clausen <lars@metafoo.de>
   JZ4740 platform PWM support
  Limitations:
  - The .apply callback doesn't complete the currently running period before
    reconfiguring the hardware.
 Enable all TCU channels for PWM use by default except channels 01 
 Enable PWM output 
 Start counter 
	
	  Set duty > period. This trick allows the TCU channels in TCU2 mode to
	  properly return to their init level.
	
	  Disable PWM output.
	  In TCU2 mode (channel 12 on JZ4750+), this must be done before the
	  counter is stopped, while in TCU1 mode the order does not matter.
 Stop counter 
	
	  Limit the clock to a maximum rate that still gives us a period value
	  which fits in 16 bits.
	
	  !\ IMPORTANT NOTE:
	  -------------------
	  This code relies on the fact that clk_round_rate() will always round
	  down, which is not a valid assumption given by the clk API, but only
	  happens to be true with the clk drivers used for Ingenic SoCs.
	 
	  Right now, there is no alternative as the clk API does not have a
	  round-down function (and won't have one for a while), but if it ever
	  comes to light, a round-down function should be used instead.
 Calculate period value 
 Calculate duty value 
 Reset counter to 0 
 Set duty 
 Set period 
 Set abrupt shutdown 
	
	  Set polarity.
	 
	  The PWM starts in inactive state until the internal timer reaches the
	  duty value, then becomes active until the timer reaches the period
	  value. In theory, we should then use (period - duty) as the real duty
	  value, as a high duty value would otherwise result in the PWM pin
	  being inactive most of the time.
	 
	  Here, we don't do that, and instead invert the polarity of the PWM
	  when it is active. This trick makes the PWM start with its active
	  state instead of its inactive state.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2017-2018 SiFive
  For SiFive's PWM IP block documentation please refer Chapter 14 of
  Reference Manual : https:static.dev.sifive.comFU540-C000-v1.0.pdf
  Limitations:
  - When changing both duty cycle and period, we cannot prevent in
    software that the output might produce a period with mixed
    settings (new period length and old duty cycle).
  - The hardware cannot generate a 100% duty cycle.
  - The hardware generates only inverted output.
 Register offsets 
 PWMCFG fields 
 PWM_SIFIVE_SIZE_PWMCMP is used to calculate offset for pwmcmpX registers 
 lock to protect user_count 
	
	  The PWM unit is used with pwmzerocmp=0, so the only way to modify the
	  period length is using pwmscale which provides the number of bits the
	  counter is shifted before being feed to the comparators. A period
	  lasts (1 << (PWM_SIFIVE_CMPWIDTH + pwmscale)) clock ticks.
	  (1 << (PWM_SIFIVE_CMPWIDTH + scale))  10^9rate = period
 As scale <= 15 the shift operation cannot overflow. 
	
	  The problem of output producing mixed setting as mentioned at top,
	  occurs here. To minimize the window for this problem, we are
	  calculating the register values first and then writing them
	  consecutively
 The hardware cannot generate a 100% duty cycle 
 Watch for changes to underlying clock frequency 
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2012 Freescale Semiconductor, Inc.
	
	  If the PWM channel is disabled, make sure to turn on the
	  clock before calling clk_get_rate() and writing to the
	  registers. Otherwise, just keep it enabled.
	
	  The data sheet the says registers must be written to in
	  this order (ACTIVEn, then PERIODn). Also, the new settings
	  only take effect at the beginning of a new period, avoiding
	  glitches.
			
			  The clock was enabled above. Just enable
			  the channel in the control register.
 FIXME: Only do this if the PWM isn't already running 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  Intel Low Power Subsystem PWM controller driver
  Copyright (C) 2014, Intel Corporation
  Derived from the original pwm-lpss.c
 BayTrail 
 Braswell 
 Broxton 
	
	  On Cherry Trail devices the GFX0._PS0 AML checks if the controller
	  is on and if it is not on it turns it on and restores what it
	  believes is the correct state to the PWM controller.
	  Because of this we must disallow direct-complete, which keeps the
	  controller (runtime)suspended on resume, to avoid 2 issues:
	  1. The controller getting turned on without the linux-pm code
	     knowing about this. On devices where the controller is unused
	     this causes it to stay on during the next suspend causing high
	     battery drain (because S0i3 is not reached)
	  2. The state restoring code unexpectedly messing with the controller
	 
	  Leaving the controller runtime-suspended (skipping runtime-resume +
	  normal-suspend) during suspend is fine.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 Spreadtrum Communications Inc.
  The list of clocks required by PWM channels, and each channel has 2 clocks:
  enable clock and pwm clock.
	
	  The clocks to PWM channel has to be enabled first before
	  reading to the registers.
	
	  The hardware provides a counter that is feed by the source clock.
	  The period length is (PRESCALE + 1)  MOD counter steps.
	  The duty cycle length is (PRESCALE + 1)  DUTY counter steps.
	  Thus the period_ns and duty_ns calculation formula should be:
	  period_ns = NSEC_PER_SEC  (prescale + 1)  mod  clk_rate
	  duty_ns = NSEC_PER_SEC  (prescale + 1)  duty  clk_rate
 Disable PWM clocks if the PWM channel is not in enable state. 
	
	  The hardware provides a counter that is feed by the source clock.
	  The period length is (PRESCALE + 1)  MOD counter steps.
	  The duty cycle length is (PRESCALE + 1)  DUTY counter steps.
	 
	  To keep the maths simple we're always using MOD = SPRD_PWM_MOD_MAX.
	  The value for PRESCALE is selected such that the resulting period
	  gets the maximal length not bigger than the requested one with the
	  given settings (MOD = SPRD_PWM_MOD_MAX and input clock).
	
	  Note: Writing DUTY triggers the hardware to actually apply the
	  values written to MOD and DUTY to the output, so must keep writing
	  DUTY last.
	 
	  The hardware can ensures that current running period is completed
	  before changing a new configuration to avoid mixed settings.
			
			  The clocks to PWM channel has to be enabled first
			  before writing to the registers.
		
		  Note: After setting SPRD_PWM_ENABLE to zero, the controller
		  will not wait for current period to be completed, instead it
		  will stop the PWM channel immediately.
 SPDX-License-Identifier: GPL-2.0
  Expose a PWM controlled by the ChromeOS EC to the host processor.
  Copyright (C) 2016 Google, Inc.
  struct cros_ec_pwm_device - Driver data for EC PWM
  @dev: Device node
  @ec: Pointer to EC device
  @chip: PWM controller chip
  struct cros_ec_pwm - per-PWM driver data
  @duty_cycle: cached duty cycle
 The EC won't let us change the period 
	
	  EC doesn't separate the concept of duty cycle and enabled, but
	  kernel does. Translate.
	
	  Note that "disabled" and "duty cycle == 0" are treated the same. If
	  the cached duty cycle is not zero, used the cached duty cycle. This
	  ensures that the configured duty cycle is kept across a disable and
	  enable operation and avoids potentially confusing consumers.
	 
	  For the case of the initial hardware readout, channel->duty_cycle
	  will be 0 and the actual duty cycle read from the EC is used.
 The EC won't let us change the period 
  Determine the number of supported PWMs. The EC does not return the number
  of PWMs it supports directly, so we have to read the pwm duty cycle for
  subsequent channels until we get an error.
 The index field is only 8 bits 
		
		  We look for SUCCESS, INVALID_COMMAND, or INVALID_PARAM
		  responses; everything else is treated as an error.
		  The EC error codes map to -EOPNOTSUPP and -EINVAL,
		  so check for those.
 invalid command 
 invalid parameter 
 PWM chip 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2012 Alexandre Pereira da Silva <aletes.xgr@gmail.com>
 The highest acceptable divisor is 256, which is represented by 0 
 Compute 256 x #dutyperiod value and care for corner cases 
 If PWM is disabled, configure the output to the default value 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015 Neil Armstrong <narmstrong@baylibre.com>
  Copyright (c) 2014 Joachim Eastwood <manabian@gmail.com>
  Copyright (c) 2012 NeilBrown <neilb@suse.de>
  Heavily based on earlier code which is:
  Copyright (c) 2010 Grant Erickson <marathon96@gmail.com>
  Also based on pwm-samsung.c
  Description:
    This file is the core OMAP support for the generic, Linux
    PWM driver  controller, using the OMAP's dual-mode timers
    with a timer counter that goes up. When it overflows it gets
    reloaded with the load value and the pwm output goes up.
    When counter matches with match register, the output goes down.
    Reference Manual: https:www.ti.comlitugspruh73qspruh73q.pdf
  Limitations:
  - When PWM is stopped, timer counter gets stopped immediately. This
    doesn't allow the current PWM period to complete and stops abruptly.
  - When PWM is running and changing both duty cycle and period,
    we cannot prevent in software that the output might produce
    a period with mixed settings. Especially when periodduty_cyle
    is updated while the pwm pin is high, current pwm periodduty_cycle
    can get updated as below based on the current timer counter:
    	- period for current cycle =  current_period + new period
    	- duty_cycle for current period = current period + new duty_cycle.
  - PWM OMAP DM timer cannot change the polarity when pwm is active. When
    user requests a change in polarity when in active state:
 	- PWM is stopped abruptly(without completing the current cycle)
 	- Polarity is changed
 	- A fresh cycle is started.
  struct pwm_omap_dmtimer_chip - Structure representing a pwm chip
 				  corresponding to omap dmtimer.
  @chip:		PWM chip structure representing PWM controller
  @mutex:		Mutex to protect pwm apply state
  @dm_timer:		Pointer to omap dm timer.
  @pdata:		Pointer to omap dm timer ops.
  @dm_timer_pdev:	Pointer to omap dm timer platform device
 Mutex to protect pwm apply state 
  pwm_omap_dmtimer_get_clock_cycles() - Get clock cycles in a time frame
  @clk_rate:	pwm timer clock rate
  @ns:		time frame in nano seconds.
  Return number of clock cycles in a given period(ins ns).
  pwm_omap_dmtimer_start() - Start the pwm omap dm timer in pwm mode
  @omap:	Pointer to pwm omap dm timer chip
	
	  According to OMAP 4 TRM section 22.2.4.10 the counter should be
	  started at 0xFFFFFFFE when overflow and match is used to ensure
	  that the PWM line is toggled on the first event.
	 
	  Note that omap_dm_timer_enabledisable is for register access and
	  not the timer counter itself.
  pwm_omap_dmtimer_is_enabled() -  Detect if the pwm is enabled.
  @omap:	Pointer to pwm omap dm timer chip
  Return true if pwm is enabled else false.
  pwm_omap_dmtimer_polarity() -  Detect the polarity of pwm.
  @omap:	Pointer to pwm omap dm timer chip
  Return the polarity of pwm.
  pwm_omap_dmtimer_config() - Update the configuration of pwm omap dm timer
  @chip:	Pointer to PWM controller
  @pwm:	Pointer to PWM channel
  @duty_ns:	New duty cycle in nano seconds
  @period_ns:	New period in nano seconds
  Return 0 if successfully changed the periodduty_cycle else appropriate
  error.
	
	  Calculate the appropriate load and match values based on the
	  specified period and duty cycle. The load value determines the
	  period time and the match value determines the duty time.
	 
	  The period lasts for (DM_TIMER_MAX-load_value+1) clock cycles.
	  Similarly, the active time lasts (match_value-load_value+1) cycles.
	  The non-active time is the remainder: (DM_TIMER_MAX-match_value)
	  clock cycles.
	 
	  NOTE: It is required that: load_value <= match_value < DM_TIMER_MAX
	 
	  References:
	    OMAP44306070 TRM sections 22.2.4.10 and 22.2.4.11
	    AM335x Sitara TRM sections 20.1.3.5 and 20.1.3.6
  pwm_omap_dmtimer_set_polarity() - Changes the polarity of the pwm dm timer.
  @chip:	Pointer to PWM controller
  @pwm:	Pointer to PWM channel
  @polarity:	New pwm polarity to be set
 Disable the PWM before changing the polarity. 
  pwm_omap_dmtimer_apply() - Changes the state of the pwm omap dm timer.
  @chip:	Pointer to PWM controller
  @pwm:	Pointer to PWM channel
  @state:	New state to apply
  Return 0 if successfully changed the state else appropriate error.
	
	  Ensure that the timer is stopped before we allow PWM core to call
	  pwm_enable.
 setup dmtimer clock source 
	
	  omap is allocated using devm_kzalloc,
	  so no free necessary here
 SPDX-License-Identifier: GPL-2.0-only
  sl28cpld PWM driver
  Copyright (c) 2020 Michael Walle <michael@walle.cc>
  There is no public datasheet available for this PWM core. But it is easy
  enough to be briefly explained. It consists of one 8-bit counter. The PWM
  supports four distinct frequencies by selecting when to reset the counter.
  With the prescaler setting you can select which bit of the counter is used
  to reset it. This implies that the higher the frequency the less remaining
  bits are available for the actual counter.
  Let cnt[7:0] be the counter, clocked at 32kHz:
  +-----------+--------+--------------+-----------+---------------+
  | prescaler |  reset | counter bits | frequency | period length |
  +-----------+--------+--------------+-----------+---------------+
  |         0 | cnt[7] |     cnt[6:0] |    250 Hz |    4000000 ns |
  |         1 | cnt[6] |     cnt[5:0] |    500 Hz |    2000000 ns |
  |         2 | cnt[5] |     cnt[4:0] |     1 kHz |    1000000 ns |
  |         3 | cnt[4] |     cnt[3:0] |     2 kHz |     500000 ns |
  +-----------+--------+--------------+-----------+---------------+
  Limitations:
  - The hardware cannot generate a 100% duty cycle if the prescaler is 0.
  - The hardware cannot atomically set the prescaler and the counter value,
    which might lead to glitches and inconsistent states if a write fails.
  - The counter is not reset if you switch the prescaler which leads
    to glitches, too.
  - The duty cycle will switch immediately and not after a complete cycle.
  - Depending on the actual implementation, disabling the PWM might have
    side effects. For example, if the output pin is shared with a GPIO pin
    it will automatically switch back to GPIO mode.
  PWM timer block registers.
 32 kHz 
  We calculate the duty cycle like this:
    duty_cycle_ns = pwm_cycle_reg  max_period_ns  max_duty_cycle
  With
    max_period_ns = 1 << (7 - prescaler)  SL28CPLD_PWM_CLK  NSEC_PER_SEC
    max_duty_cycle = 1 << (7 - prescaler)
  this then simplifies to:
    duty_cycle_ns = pwm_cycle_reg  SL28CPLD_PWM_CLK  NSEC_PER_SEC
                  = NSEC_PER_SEC  SL28CPLD_PWM_CLK  pwm_cycle_reg
  NSEC_PER_SEC is a multiple of SL28CPLD_PWM_CLK, therefore we're not losing
  precision by doing the divison first.
	
	  Sanitize values for the PWM core. Depending on the prescaler it
	  might happen that we calculate a duty_cycle greater than the actual
	  period. This might happen if someone (e.g. the bootloader) sets an
	  invalid combination of values. The behavior of the hardware is
	  undefined in this case. But we need to report sane values back to
	  the PWM core.
 Polarity inversion is not supported 
	
	  Calculate the prescaler. Pick the biggest period that isn't
	  bigger than the requested period.
	
	  Work around the hardware limitation. See also above. Trap 100% duty
	  cycle if the prescaler is 0. Set prescaler to 1 instead. We don't
	  care about the frequency because its "all-one" in either case.
	 
	  We don't need to check the actual prescaler setting, because only
	  if the prescaler is 0 we can have this particular value.
	
	  To avoid glitches when we switch the prescaler, we have to make sure
	  we have a valid duty cycle for the new mode.
	 
	  Take the current prescaler (or the current period length) into
	  account to decide whether we have to write the duty cycle or the new
	  prescaler first. If the period length is decreasing we have to
	  write the duty cycle first.
 Initialize the pwm_chip structure 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2014 Free Electrons
  Copyright (C) 2014 Atmel
  Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
 Errata: cannot use slow clk on some IP revisions 
 Errata: cannot divide by 1 on some IP revisions 
		
		  The PWM duty cycle is configurable from 0256 to 255256 of
		  the period cycle. Hence we can't set a duty cycle occupying
		  the whole period cycle if we're asked to.
		  Set it to 255 if pwmcval is greater than 256.
 Keep the periph clock enabled if the PWM is still running. 
 Re-enable the periph clock it was stopped during suspend. 
 9n12 has same errata as 9x5 HLCDC PWM 
 sentinel  },
 sentinel  },
 SPDX-License-Identifier: GPL-2.0
  Copyright 2021 Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
  For more information on Raspberry Pi's PoE hat see:
  https:www.raspberrypi.orgproductspoe-hat
  Limitations:
   - No disable bit, so a disabled PWM is simulated by duty_cycle 0
   - Only normal polarity
   - Fixed 12.5 kHz period
  The current period is completed when HW is reconfigured.
 12.5 kHz 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020 Intel Corporation.
  Limitations:
  - The hardware supports fixed period & configures only 2-wire mode.
  - Supports normal polarity. Does not support changing polarity.
  - When PWM is disabled, output of PWM will become 0(inactive). It doesn't
    keep track of running period.
  - When duty cycle is changed, PWM output may be a mix of previous setting
    and new setting for the first period. From second period, the output is
    based on new setting.
  - It is a dedicated PWM fan controller. There are no other consumers for
    this PWM controller.
 The hardware only supports normal polarity and fixed period. 
 fixed period 
 SPDX-License-Identifier: GPL-2.0-only
  Driver for Atmel Pulse Width Modulation Controller
  Copyright (C) 2013 Atmel Corporation
 		 Bo Shen <voice.shen@atmel.com>
  Links to reference manuals for the supported PWM chips can be found in
  Documentationarmmicrochip.rst.
  Limitations:
  - Periods start with the inactive level.
  - Hardware has to be stopped in general to update settings.
  Software bugspossible improvements:
  - When atmel_pwm_apply() is called with state->enabled=false a change in
    state->polarity isn't honored.
  - Instead of sleeping to wait for a completed period, the interrupt
    functionality could be used.
 The following is global registers for PWM controller 
 Bit field in SR 
 The following register is PWM channel related registers 
 Bit field in CMR 
 The following registers for PWM v1 
 The following registers for PWM v2 
	
	  The hardware supports a mechanism to update a channel's duty cycle at
	  the end of the currently running period. When such an update is
	  pending we delay disabling the PWM until the new configuration is
	  active because otherwise pmw_config(duty_cycle=0); pwm_disable();
	  might not result in an inactive output.
	  This bitmask tracks for which channels an update is pending in
	  hardware.
 Protects .update_pending 
	
	  Each channel that has its bit in ISR set started a new period since
	  ISR was cleared and so there is no more update pending.  Note that
	  reading ISR clears it, so this needs to handle all channels to not
	  loose information.
	
	  Clear pending flags in hardware because otherwise there might still
	  be a stale flag in ISR.
 Calculate the period cycles and prescale value 
	
	  The register for the period length is cfg.period_bits bits wide.
	  So for each bit the number of clock cycles is wider divide the input
	  clock frequency by two using pres and shift cprd accordingly.
	
	  Wait for the PWM channel disable operation to be effective before
	  stopping the clock.
 It is necessary to preserve CPOL, inside CMR 
 Wait for an updated duty_cycle queued in hardware 
 16 bits to keep period and duty. 
 16 bits to keep period and duty. 
 32 bits to keep period and duty. 
 sentinel 
 SPDX-License-Identifier: GPL-2.0-or-later
  driverspwmpwm-tegra.c
  Tegra pulse-width-modulation controller driver
  Copyright (c) 2010-2020, NVIDIA Corporation.
  Based on archarmplat-mxcpwm.c by Sascha Hauer <s.hauer@pengutronix.de>
  Overview of Tegra Pulse Width Modulator Register:
  1. 13-bit: Frequency division (SCALE)
  2. 8-bit : Pulse division (DUTY)
  3. 1-bit : Enable bit
  The PWM clock frequency is divided by 256 before subdividing it based
  on the programmable frequency division value to generate the required
  frequency for PWM output. The maximum output frequency that can be
  achieved is (max rate of source clock)  256.
  e.g. if source clock rate is 408 MHz, maximum output frequency can be:
  408 MHz256 = 1.6 MHz.
  This 1.6 MHz frequency can further be divided using SCALE value in PWM.
  PWM pulse width: 8 bits are usable [23:16] for varying pulse width.
  To achieve 100% duty cycle, program Bit [24] of this register to
  1’b1. In which case the other bits [23:16] are set to don't care.
  Limitations:
  -	When PWM is disabled, the output is driven to inactive.
  -	It does not allow the current PWM period to complete and
 	stops abruptly.
  -	If the register is reconfigured while PWM is running,
 	it does not complete the currently running period.
  -	If the user input duty is beyond acceptible limits,
 	-EINVAL is returned.
 Maximum IP frequency for given SoCs 
	
	  Convert from duty_ns  period_ns to a fixed number of duty ticks
	  per (1 << PWM_DUTY_WIDTH) cycles and make sure to round to the
	  nearest integer during division.
	
	   min period = max clock limit >> PWM_DUTY_WIDTH
	
	  Compute the prescaler value for which (1 << PWM_DUTY_WIDTH)
	  cycles at the PWM clock rate will take period_ns nanoseconds.
	 
	  num_channels: If single instance of PWM controller has multiple
	  channels (e.g. Tegra210 or older) then it is not possible to
	  configure separate clock rates to each of the channels, in such
	  case the value stored during probe will be referred.
	 
	  If every PWM controller instance has one channel respectively, i.e.
	  nums_channels == 1 then only the clock rate can be modified
	  dynamically (e.g. Tegra186 or Tegra194).
		
		  Rate is multiplied with 2^PWM_DUTY_WIDTH so that it matches
		  with the maximum possible rate that the controller can
		  provide. Any further lower value can be derived by setting
		  PFM bits[0:12].
		 
		  required_clk_rate is a reference rate for source clock and
		  it is derived based on user requested period. By setting the
		  source clock rate as required_clk_rate, PWM controller will
		  be able to configure the requested period.
 Store the new rate for further references 
 Consider precision in PWM_SCALE_WIDTH rate calculation 
	
	  Since the actual PWM divider is the register's frequency divider
	  field plus 1, we need to decrement to get the correct value to
	  write to the register.
	
	  Make sure that the rate will fit in the register's frequency
	  divider field.
	
	  If the PWM channel is disabled, make sure to turn on the clock
	  before writing the register. Otherwise, keep it enabled.
	
	  If the PWM is not enabled, turn the clock off again to save power.
 Set maximum frequency of the IP 
	
	  The requested and configured frequency may differ due to
	  clock register resolutions. Get the configured frequency
	  so that PWM period can be calculated more accurately.
 Set minimum limit of PWM period for the IP 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2018-2019 NXP.
  Limitations:
  - The TPM counter and period counter are shared between
    multiple channels, so all channels should use same period
    settings.
  - Changes to polarity cannot be latched at the time of the
    next period start.
  - Changing period and duty cycle together isn't atomic,
    with the wrong timing it might happen that a period is
    produced with old duty cycle but new period settings.
  The reference manual describes this field as two separate bits. The
  semantic of the two bits isn't orthogonal though, so they are treated
  together as a 2-bit field here.
  This function determines for a given pwm_state state that a consumer
  might request the pwm_state real_state that eventually is implemented
  by the hardware and the necessary register values (in p) to achieve
  this.
 calculate real period HW can support 
	
	  if eventually the PWM output is inactive, either
	  duty cycle is 0 or status is disabled, need to
	  make sure the output pin is inactive.
 get period 
 get duty cycle 
 get polarity 
		
		  Assume reserved values (2b00 and 2b11) to yield
		  normal polarity.
 get channel status 
 this function is supposed to be called with mutex hold 
		
		  TPM counter is shared by multiple channels, so
		  prescale and period can NOT be modified when
		  there are multiple channels in use with different
		  period settings.
 set TPM counter prescale 
		
		  set period count:
		  if the PWM is disabled (CMOD[1:0] = 2b00), then MOD register
		  is updated when MOD register is written.
		 
		  if the PWM is enabled (CMOD[1:0] ≠ 2b00), the period length
		  is latched into hardware when the next period starts.
 polarity is NOT allowed to be changed if PWM is active 
		
		  set channel value:
		  if the PWM is disabled (CMOD[1:0] = 2b00), then CnV register
		  is updated when CnV register is written.
		 
		  if the PWM is enabled (CMOD[1:0] ≠ 2b00), the duty length
		  is latched into hardware when the next period starts.
 make sure MOD & CnV registers are updated 
	
	  polarity settings will enableddisable output status
	  immediately, so if the channel is disabled, need to
	  make sure MSAMSBELS are set to 0 which means channel
	  disabled.
		
		  set polarity (for edge-aligned PWM modes)
		 
		  ELS[1:0] = 2b10 yields normal polarity behaviour,
		  ELS[1:0] = 2b01 yields inversed polarity.
		  The other values are reserved.
 control the counter status 
 get number of channels 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  Driver for TWL40306030 Generic Pulse Width Modulator
  Copyright (C) 2012 Texas Instruments
  Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
  This driver handles the PWMs of TWL4030 and TWL6030.
  The TRM names for the PWMs on TWL4030 are: PWM0, PWM1
  TWL6030 also have two PWMs named in the TRM as PWM1, PWM2
 Registers, bits and macro for TWL4030 
 GPBR1 register bits 
 PMBR1 register bits 
 Register, bits and macro for TWL6030 
	
	  To configure the duty period:
	  On-cycle is set to 1 (the minimum allowed value)
	  The off time of 0 is not configurable, so the mapping is:
	  0 -> off cycle = 2,
	  1 -> off cycle = 2,
	  2 -> off cycle = 3,
	  126 - > off cycle 127,
	  127 - > off cycle 1
	  When on cycle == off cycle the PWM will be always on
 Save the current MUX configuration for the PWM 
 Select PWM functionality 
 Restore the MUX configuration for the PWM 
 SPDX-License-Identifier: GPL-2.0
  DesignWare PWM Controller driver
  Copyright (C) 2018-2020 Intel Corporation
  Author: Felipe Balbi (Intel)
  Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
  Author: Raymond Tan <raymond.tan@intel.com>
  Limitations:
  - The hardware cannot generate a 0 % or 100 % duty cycle. Both high and low
    periods are one or more input clock periods long.
 Timer Control Register 
	
	  Calculate width of low and high period in terms of input clock
	  periods and check are the result within HW limits between 1 and
	  2^32 periods.
	
	  Specification says timer usage flow is to disable timer, then
	  program it followed by enable. It also says Load Count is loaded
	  into timer after it is enabled - either after a disable or
	  a reset. Based on measurements it happens also without disable
	  whenever Load Count is updated. But follow the specification.
	
	  Write Load Count and Load Count 2 registers. Former defines the
	  width of low period and latter the width of high period in terms
	  multiple of input clock periods:
	  Width = ((Count + 1)  input clock period).
	
	  Set user-defined mode, timer reloads from Load Count registers
	  when it counts down to 0.
	  Set PWM mode, it makes output to toggle and width of low and high
	  periods are set by Load Count registers.
	
	  Enable timer. Output starts from low period.
 Elkhart Lake 
 Terminating Entry 
 SPDX-License-Identifier: GPL-2.0-only
  PWM driver for Rockchip SoCs
  Copyright (C) 2014 Beniamino Galvani <b.galvani@gmail.com>
  Copyright (C) 2014 ROCKCHIP, Inc.
	
	  Since period and duty cycle registers have a width of 32
	  bits, every possible input period can be obtained using the
	  default prescaler value for all practical clock rate values.
	
	  Lock the period and duty of previous configuration, then
	  change the duty and period, that would not be effective.
	
	  Unlock and set polarity at the same time,
	  the configuration of duty, period and polarity
	  would be effective together at next period.
 sentinel  }
 Keep the PWM clk enabled if the PWM appears to be up and running. 
 SPDX-License-Identifier: GPL-2.0-only
  Driver for TWL40306030 Pulse Width Modulator used as LED driver
  Copyright (C) 2012 Texas Instruments
  Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
  This driver is a complete rewrite of the former pwm-twl6030.c authorded by:
  Hemanth V <hemanthv@ti.com>
  This driver handles the PWM driven LED terminals of TWL4030 and TWL6030.
  To generate the signal on TWL4030:
   - LEDA uses PWMA
   - LEDB uses PWMB
  TWL6030 has one LED pin with dedicated LEDPWM
 Registers, bits and macro for TWL4030 
 Register, bits and macro for TWL6030 
	
	  To configure the duty period:
	  On-cycle is set to 1 (the minimum allowed value)
	  The off time of 0 is not configurable, so the mapping is:
	  0 -> off cycle = 2,
	  1 -> off cycle = 2,
	  2 -> off cycle = 3,
	  126 - > off cycle 127,
	  127 - > off cycle 1
	  When on cycle == off cycle the PWM will be always on
  Copyright (C) 2014 Broadcom Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  The Kona PWM has some unusual characteristics.  Here are the main points.
  1) There is no disable bit and the hardware docs advise programming a zero
     duty to achieve output equivalent to that of a normal disable operation.
  2) Changes to prescale, duty, period, and polarity do not take effect until
     a subsequent rising edge of the trigger bit.
  3) If the smooth bit and trigger bit are both low, the output is a constant
     high signal.  Otherwise, the earlier waveform continues to be output.
  4) If the smooth bit is set on the rising edge of the trigger bit, output
     will transition to the new settings on a period boundary (which could be
     seconds away).  If the smooth bit is clear, new settings will be applied
     as soon as possible (the hardware always has a 400ns delay).
  5) When the external clock that feeds the PWM is disabled, output is pegged
     high or low depending on its state at that exact instant.
  Clear trigger bit but set smooth bit to maintain old output.
	
	  There must be a min 400ns delay between clearing trigger and setting
	  it. Failing to do this may result in no PWM signal.
 Set trigger bit and clear smooth bit to apply new settings 
 Trigger bit must be held high for at least 400 ns. 
	
	  Find period count, duty count and prescale to suit duty_ns and
	  period_ns. This is done according to formulas described below:
	 
	  period_ns = 10^9  (PRESCALE + 1)  PC  PWM_CLK_RATE
	  duty_ns = 10^9  (PRESCALE + 1)  DC  PWM_CLK_RATE
	 
	  PC = (PWM_CLK_RATE  period_ns)  (10^9  (PRESCALE + 1))
	  DC = (PWM_CLK_RATE  duty_ns)  (10^9  (PRESCALE + 1))
 If duty_ns or period_ns are not achievable then return 
 If pc and dc are in bounds, the calculation is done 
 Otherwise, increase prescale and recalculate pc and dc 
	
	  Don't apply settings if disabled. The period and duty cycle are
	  always calculated above to ensure the new values are
	  validated immediately instead of on enable.
 Simulate a disable by configuring for zero duty 
 Set prescale to 0 for this channel 
 Set pushpull for all channels 
 SPDX-License-Identifier: GPL-2.0-only
  Imagination Technologies Pulse Width Modulator driver
  Copyright (c) 2014-2015, Imagination Technologies
  Based on driverspwmpwm-tegra.c, Copyright (c) 2010, NVIDIA Corporation
 PWM registers 
 ms 
  PWM period is specified with a timebase register,
  in number of step periods. The PWM duty cycle is also
  specified in step periods, in the [0, $timebase] range.
  In other words, the timebase imposes the duty cycle
  resolution. Therefore, let's constraint the timebase to
  a minimum value to allow a sane range of duty cycle values.
  Imposing a minimum timebase, will impose a maximum PWM frequency.
  The value chosen is completely arbitrary.
 The maximum input clock divider is 512 
 CONFIG_PM 
 SPDX-License-Identifier: GPL-2.0-or-later
  PWM framework driver for Cirrus Logic EP93xx
  Copyright (c) 2009        Matthieu Crapet <mcrapet@gmail.com>
  Copyright (c) 2009, 2013  H Hartley Sweeten <hsweeten@visionengravers.com>
  EP930102 have only one channel:
    platform device ep93xx-pwm.1 - PWMOUT1 (EGPIO14)
  EP9307 has only one channel:
    platform device ep93xx-pwm.0 - PWMOUT
  EP931215 have two channels:
    platform device ep93xx-pwm.0 - PWMOUT
    platform device ep93xx-pwm.1 - PWMOUT1 (EGPIO14)
 for ep93xx_pwm_{acquire,release}_gpio() 
		
		  The clock needs to be enabled to access the PWM registers.
		  Polarity can only be changed when the PWM is disabled.
	
	  The clock needs to be enabled to access the PWM registers.
	  Configuration can be changed at any time.
 Order is important if PWM is running 
 SPDX-License-Identifier: GPL-2.0-only
  Toshiba Visconti pulse-width-modulation controller driver
  Copyright (c) 2020 - 2021 TOSHIBA CORPORATION
  Copyright (c) 2020 - 2021 Toshiba Electronic Devices & Storage Corporation
  Authors: Nobuhiro Iwamatsu <nobuhiro1.iwamatsu@toshiba.co.jp>
  Limitations:
  - The fixed input clock is running at 1 MHz and is divided by either 1,
    2, 4 or 8.
  - When the settings of the PWM are modified, the new values are shadowed
    in hardware until the PIPGM_PCSR register is written and the currently
    running period is completed. This way the hardware switches atomically
    from the old setting to the new.
  - Disabling the hardware completes the currently running period and keeps
    the output at low level at all times.
	
	  The biggest period the hardware can provide is
	 	(0xffff << 3)  1000 ns
	  This value fits easily in an u32, so simplify the maths by
	  capping the values to 32 bit integers.
	
	  The input clock runs fixed at 1 MHz, so we have only
	  microsecond resolution and so can divide by
	  NSEC_PER_SEC  CLKFREQ = 1000 without losing precision.
	
	  PWMC controls a divider that divides the input clk by a power of two
	  between 1 and 8. As a smaller divider yields higher precision, pick
	  the smallest possible one. As period is at most 0xffff << 3, pwmc0 is
	  in the intended range [0..3].
 SPDX-License-Identifier: GPL-2.0-only
  driverspwmpwm-vt8500.c
  Copyright (C) 2012 Tony Prisk <linux@prisktech.co.nz>
  Copyright (C) 2010 Alexey Charkov <alchark@gmail.com>
  SoC architecture allocates register space for 4 PWMs but only
  2 are currently implemented.
 Sentinel  }
 SPDX-License-Identifier: GPL-2.0
  R-Car PWM Timer driver
  Copyright (C) 2015 Renesas Electronics Corporation
  Limitations:
  - The hardware cannot generate a 0% duty cycle.
 0.01 nanoseconds 
 Avoid prohibited setting 
 Don't enable the PWM device if CYC0 or PH0 is 0 
 This HWdriver only supports normal polarity 
 The SYNC should be set to 0 even if rcar_pwm_set_counter failed 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2014 Bart Tanghe <bart.tanghe@thomasmore.be>
 set timer in PWM mode 
	
	  period_cycles must be a 32 bit value, so period  rate  NSEC_PER_SEC
	  must be <= U32_MAX. As U32_MAX  NSEC_PER_SEC < U64_MAX the
	  multiplication period  rate doesn't overflow.
	  To calculate the maximal possible period that guarantees the
	  above inequality:
	 
	      round(period  rate  NSEC_PER_SEC) <= U32_MAX
	  <=> period  rate  NSEC_PER_SEC < U32_MAX + 0.5
	  <=> period  rate < (U32_MAX + 0.5)  NSEC_PER_SEC
	  <=> period < ((U32_MAX + 0.5)  NSEC_PER_SEC)  rate
	  <=> period < ((U32_MAX  NSEC_PER_SEC + NSEC_PER_SEC2)  rate
	  <=> period <= ceil((U32_MAX  NSEC_PER_SEC + NSEC_PER_SEC2)  rate) - 1
 set period 
 don't accept a period that is too small 
 set duty cycle 
 set polarity 
 enabledisable 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  MediaTek display pulse-width-modulation controller driver.
  Copyright (c) 2015 MediaTek Inc.
  Author: YH Huang <yh.huang@mediatek.com>
	
	  Find period, high_width and clk_div to suit duty_ns and period_ns.
	  Calculate proper div value to keep period value in the bound.
	 
	  period_ns = 10^9  (clk_div + 1)  (period + 1)  PWM_CLK_RATE
	  duty_ns = 10^9  (clk_div + 1)  high_width  PWM_CLK_RATE
	 
	  period = (PWM_CLK_RATE  period_ns)  (10^9  (clk_div + 1)) - 1
	  high_width = (PWM_CLK_RATE  duty_ns)  (10^9  (clk_div + 1))
		
		  For MT2701, disable double buffer before writing register
		  and select manual mode and use PWM_PERIODPWM_HIGH_WIDTH.
	
	  period has 12 bits, clk_div 11 and NSEC_PER_SEC has 30,
	  so period  (clk_div + 1)  NSEC_PER_SEC doesn't overflow.
 SPDX-License-Identifier: GPL-2.0-only
  driverspwmpwm-pxa.c
  simple driver for PWM (Pulse Width Modulator) controller
  2008-02-13	initial version
 		eric miao <eric.miao@marvell.com>
   PWM    has_secondary_pwm? 
 PWM registers and bits definitions 
  period_ns = 10^9  (PRESCALE + 1)  (PV + 1)  PWM_CLK_RATE
  duty_ns   = 10^9  (PRESCALE + 1)  DC  PWM_CLK_RATE
	 NOTE: the clock to PWM has to be enabled first
	  before writing to the registers
  Device tree users must create one device instance for each PWM channel.
  Hence we dispense with the HAS_SECONDARY_PWM and "tell" the original driver
  code that this is a single channel pxa25x-pwm.  Currently all devices are
  supported identically.
 SPDX-License-Identifier: GPL-2.0-only
  NXP LPC18xx State Configurable Timer - Pulse Width Modulator driver
  Copyright (c) 2015 Ariel D'Alessandro <ariel@vanguardiasur.com>
  Notes
  =====
  NXP LPC18xx provides a State Configurable Timer (SCT) which can be configured
  as a Pulse Width Modulator.
  SCT supports 16 outputs, 16 events and 16 registers. Each event will be
  triggered when its related register matches the SCT counter value, and it
  will set or clear a selected output.
  One of the events is preselected to generate the period, thus the maximum
  number of simultaneous channels is limited to 15. Notice that period is
  global to all the channels, thus PWM driver will refuse setting different
  values to it, unless there's only one channel requested.
 LPC18xx SCT registers 
 LPC18xx SCT unified counter 
 LPC18xx SCT events 
 SCT conflict resolution 
	
	  Simultaneous set and clear may happen on an output, that is the case
	  when duty_ns == period_ns. LPC18xx SCT allows to set a conflict
	  resolution action to be taken in such a case.
	
	  The PWM supports only a single period for all PWM channels.
	  Once the period is set, it can only be changed if no more than one
	  channel is requested at that moment.
 SCT counter must be in unify (32 bit) mode 
	
	  Everytime the timer counter reaches the period value, the related
	  event will be triggered and the counter reset to 0.
 SPDX-License-Identifier: GPL-2.0
  simple driver for PWM (Pulse Width Modulator) controller
  Derived from pxa PWM driver by eric miao <eric.miao@marvell.com>
 PWM Control Register 
 PWM Sample Register 
 PWM Period Register 
	
	  The PWM subsystem allows for exact frequencies. However,
	  I cannot connect a scope on my device to the PWM line and
	  thus cannot provide the program the PWM controller
	  exactly. Instead, I'm relying on the fact that the
	  Bootloader (u-boot or WinCE+haret) has programmed the PWM
	  function group already. So I'll just modify the PWM sample
	  register to follow the ratio of duty_ns vs. period_ns
	  accordingly.
	 
	  This is good enough for programming the brightness of
	  the LCD backlight.
	 
	  The real implementation would divide PERCLK[0] first by
	  both the prescaler (1 .. 128) and then by CLKSEL
	  (2 .. 16).
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  simple driver for PWM (Pulse Width Modulator) controller
  Derived from pxa PWM driver by eric miao <eric.miao@marvell.com>
  Limitations:
  - When disabled the output is driven to 0 independent of the configured
    polarity.
 PWM Control Register 
 PWM Status Register 
 PWM Sample Register 
 PWM Period Register 
 PWMPR register value of 0xffff has the same effect as 0xfffe 
	
	  The driver cannot read the current duty cycle from the hardware if
	  the hardware is disabled. Cache the last programmed duty cycle
	  value to return in that case.
 PWMOUT (Hz) = PWMCLK  (PWMPR + 2) 
	
	  PWMSAR can be read only if PWM is enabled. If the PWM is disabled,
	  use the cached value.
	
	  according to imx pwm RM, the real period value should be PERIOD
	  value in PWMPR plus 2.
	
	  Wait for a free FIFO slot if the PWM is already enabled, and flush
	  the FIFO if the PWM was disabled and is about to be enabled.
	
	  Store the duty cycle for future reference in cases where the
	  MX3_PWMSAR register can't be read (i.e. when the PWM is disabled).
 sentinel  }
 keep clks on if pwm is running 
 SPDX-License-Identifier: GPL-2.0-or-later
  A simple sysfs interface for the generic PWM framework
  Copyright (C) 2013 H Hartley Sweeten <hsweeten@visionengravers.com>
  Based on previous work by Lars Poeschel <poeschel@lemonage.de>
 for device_find_child() 
 takes export->lock on success 
 for device_find_child() 
 release lock taken in pwm_class_get_state 
			
			  roll back the PWM devices that were disabled by
			  this suspend function.
	
	  If device_create() fails the pwm_chip is still usable by
	  the kernel it's just not exported.
  Marvell Berlin PWM driver
  Copyright (C) 2015 Marvell Technology Group Ltd.
  Author: Antoine Tenart <antoine.tenart@free-electrons.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  The prescaler claims to support 8 different moduli, configured using the
  low three bits of PWM_CONTROL. (Sequentially, they are 1, 4, 8, 16, 64,
  256, 1024, and 4096.)  However, the moduli from 4 to 1024 appear to be
  implemented by internally shifting TCNT left without adding additional
  bits. So, the max TCNT that actually works for a modulus of 4 is 0x3fff;
  for 8, 0x1fff; and so on. This means that those moduli are entirely
  useless, as we could just do the shift ourselves. The 4096 modulus is
  implemented with a real prescaler, so we do use that, but we treat it
  as a flag instead of pretending the modulus is actually configurable.
 Prescaled by 4096
 SPDX-License-Identifier: GPL-2.0-or-later
  Generic pwmlib implementation
  Copyright (C) 2011 Sascha Hauer <s.hauer@pengutronix.de>
  Copyright (C) 2011-2012 Avionic Design GmbH
 flags in the third cell are optional 
  pwm_set_chip_data() - set private chip data for a PWM
  @pwm: PWM device
  @data: pointer to chip-specific data
  Returns: 0 on success or a negative error code on failure.
  pwm_get_chip_data() - get private chip data for a PWM
  @pwm: PWM device
  Returns: A pointer to the chip-private data for the PWM device.
 driver supports legacy, non-atomic operation 
  pwmchip_add() - register a new PWM chip
  @chip: the PWM chip to add
  Register a new PWM chip.
  Returns: 0 on success or a negative error code on failure.
  pwmchip_remove() - remove a PWM chip
  @chip: the PWM chip to remove
  Removes a PWM chip. This function may return busy if the PWM chip provides
  a PWM device that is still requested.
  Returns: 0 on success or a negative error code on failure.
  pwm_request() - request a PWM device
  @pwm: global PWM device index
  @label: PWM device label
  This function is deprecated, use pwm_get() instead.
  Returns: A pointer to a PWM device or an ERR_PTR()-encoded error code on
  failure.
  pwm_request_from_chip() - request a PWM device relative to a PWM chip
  @chip: PWM chip
  @index: per-chip index of the PWM to request
  @label: a literal description string of this PWM
  Returns: A pointer to the PWM device at the given index of the given PWM
  chip. A negative error code is returned if the index is not valid for the
  specified PWM chip or if the PWM device cannot be requested.
  pwm_free() - free a PWM device
  @pwm: PWM device
  This function is deprecated, use pwm_put() instead.
 No reasonable diagnosis possible without .get_state() 
	
	  state was just applied. Read out the hardware state and do some
	  checks.
	
	  The lowlevel driver either ignored .polarity (which is a bug) or as
	  best effort inverted .polarity and fixed .duty_cycle respectively.
	  Undo this inversion and fixup for further tests.
 reapply the state that the driver reported being configured. 
 reapplication of the current state should give an exact match 
  pwm_apply_state() - atomically apply a new state to a PWM device
  @pwm: PWM device
  @state: new state to apply
	
	  Some lowlevel driver's implementations of .apply() make use of
	  mutexes, also with some drivers only returning when the new
	  configuration is active calling pwm_apply_state() from atomic context
	  is a bad idea. So make it explicit that calling this function might
	  sleep.
		
		  only do this after pwm->state was applied as some
		  implementations of .get_state depend on this
		
		  FIXME: restore the initial state in case of error.
			
			  Changing the polarity of a running PWM is
			  only allowed when the PWM driver implements
			  ->apply().
  pwm_capture() - capture and report a PWM signal
  @pwm: PWM device
  @result: structure to fill with capture result
  @timeout: time to wait, in milliseconds, before giving up on capture
  Returns: 0 on success or a negative error code on failure.
  pwm_adjust_config() - adjust the current PWM config to the PWM arguments
  @pwm: PWM device
  This function will adjust the PWM config to the PWM arguments provided
  by the DT or PWM lookup table. This is particularly useful to adapt
  the bootloader config to the Linux one.
	
	  If the current period is zero it means that either the PWM driver
	  does not support initial state retrieval or the PWM has not yet
	  been configured.
	 
	  In either case, we setup the new period and polarity, and assign a
	  duty cycle of 0.
	
	  Adjust the PWM duty cycleperiod based on the period value provided
	  in PWM args.
	
	  If the polarity changed, we should also change the duty cycle.
		
		  No device for the PWM consumer has been provided. It may
		  impact the PM sequence ordering: the PWM supplier may get
		  suspended before the consumer.
  of_pwm_get() - request a PWM via the PWM framework
  @dev: device for PWM consumer
  @np: device node to get the PWM from
  @con_id: consumer name
  Returns the PWM device parsed from the phandle and index specified in the
  "pwms" property of a device tree node or a negative error-code on failure.
  Values parsed from the device tree are stored in the returned PWM device
  object.
  If con_id is NULL, the first PWM device listed in the "pwms" property will
  be requested. Otherwise the "pwm-names" property is used to do a reverse
  lookup of the PWM index. This also means that the "pwm-names" property
  becomes mandatory for devices that look up the PWM device via the con_id
  parameter.
  Returns: A pointer to the requested PWM device or an ERR_PTR()-encoded
  error code on failure.
 of_xlate ended up calling pwm_request_from_chip() 
	
	  If a consumer name was not given, try to look it up from the
	  "pwm-names" property if it exists. Otherwise use the name of
	  the user device node.
  acpi_pwm_get() - request a PWM via parsing "pwms" property in ACPI
  @fwnode: firmware node to get the "pwms" property from
  Returns the PWM device parsed from the fwnode and index specified in the
  "pwms" property or a negative error-code on failure.
  Values parsed from the device tree are stored in the returned PWM device
  object.
  This is analogous to of_pwm_get() except con_id is not yet supported.
  ACPI entries must look like
  Package () {"pwms", Package ()
      { <PWM device reference>, <PWM index>, <PWM period> [, <PWM flags>]}}
  Returns: A pointer to the requested PWM device or an ERR_PTR()-encoded
  error code on failure.
  pwm_add_table() - register PWM device consumers
  @table: array of consumers to register
  @num: number of consumers in table
  pwm_remove_table() - unregister PWM device consumers
  @table: array of consumers to unregister
  @num: number of consumers in table
  pwm_get() - look up and request a PWM device
  @dev: device for PWM consumer
  @con_id: consumer name
  Lookup is first attempted using DT. If the device was not instantiated from
  a device tree, a PWM chip and a relative index is looked up via a table
  supplied by board setup code (see pwm_add_table()).
  Once a PWM chip has been found the specified PWM device will be requested
  and is ready to be used.
  Returns: A pointer to the requested PWM device or an ERR_PTR()-encoded
  error code on failure.
 look up via DT first 
 then lookup via ACPI 
	
	  We look up the provider in the static table typically provided by
	  board setup code. We first try to lookup the consumer device by
	  name. If the consumer device was passed in as NULL or if no match
	  was found, we try to find the consumer by directly looking it up
	  by name.
	 
	  If a match is found, the provider PWM chip is looked up by name
	  and a PWM device is requested using the PWM device per-chip index.
	 
	  The lookup algorithm was shamelessly taken from the clock
	  framework:
	 
	  We do slightly fuzzy matching here:
	   An entry with a NULL ID is assumed to be a wildcard.
	   If an entry has a device ID, it must match
	   If an entry has a connection ID, it must match
	  Then we take the most specific entry - with the following order
	  of precedence: dev+con > dev only > con only.
	
	  If the lookup entry specifies a module, load the module and retry
	  the PWM chip lookup. This can be used to work around driver load
	  ordering issues if driver's can't be made to properly support the
	  deferred probe mechanism.
  pwm_put() - release a PWM device
  @pwm: PWM device
  devm_pwm_get() - resource managed pwm_get()
  @dev: device for PWM consumer
  @con_id: consumer name
  This function performs like pwm_get() but the acquired PWM device will
  automatically be released on driver detach.
  Returns: A pointer to the requested PWM device or an ERR_PTR()-encoded
  error code on failure.
  devm_of_pwm_get() - resource managed of_pwm_get()
  @dev: device for PWM consumer
  @np: device node to get the PWM from
  @con_id: consumer name
  This function performs like of_pwm_get() but the acquired PWM device will
  automatically be released on driver detach.
  Returns: A pointer to the requested PWM device or an ERR_PTR()-encoded
  error code on failure.
  devm_fwnode_pwm_get() - request a resource managed PWM from firmware node
  @dev: device for PWM consumer
  @fwnode: firmware node to get the PWM from
  @con_id: consumer name
  Returns the PWM device parsed from the firmware node. See of_pwm_get() and
  acpi_pwm_get() for a detailed description.
  Returns: A pointer to the requested PWM device or an ERR_PTR()-encoded
  error code on failure.
 CONFIG_DEBUG_FS 
 SPDX-License-Identifier: GPL-2.0+
  Cirrus Logic CLPS711X PWM driver
  Author: Alexander Shiyan <shc_work@mail.ru>
 PWM0 - bits 4..7, PWM1 - bits 8..11 
 Duty cycle 0..15 max 
 Store constant period value 
 SPDX-License-Identifier: GPL-2.0-or-later
  ECAP PWM driver
  Copyright (C) 2012 Texas Instruments, Inc. - https:www.ti.com
 ECAP registers and bits definitions 
  period_ns = 10^9  period_cycles  PWM_CLK_RATE
  duty_ns   = 10^9  duty_cycles  PWM_CLK_RATE
 Configure APWM mode & disable sync option 
 Update active registers if not running 
		
		  Update shadow registers to configure period and
		  compare values. This helps current PWM period to
		  complete on reconfiguring
 Disable APWM mode to put APWM output Low 
 Duty cycle defines LOW period of PWM 
 Duty cycle defines HIGH period of PWM 
 Leave clock enabled on enabling PWM 
	
	  Enable 'Free run Time stamp counter mode' to start counter
	  and  'APWM mode' to enable APWM output
	
	  Disable 'Free run Time stamp counter mode' to stop counter
	  and 'APWM mode' to put APWM output to low
 Disable clock on PWM disable 
 Disable explicitly if PWM is running 
 Enable explicitly if PWM was running 
 SPDX-License-Identifier: GPL-2.0-only
  Intel Low Power Subsystem PWM controller PCI driver
  Copyright (C) 2014, Intel Corporation
  Derived from the original pwm-lpss.c
 BayTrail 
 Braswell 
 Broxton 
 Tangier 
	
	  The PCI core will handle transition to D3 automatically. We only
	  need to provide runtime PM hooks for that to happen.
 SPDX-License-Identifier: GPL-2.0-only
  Driver for PCA9685 16-channel 12-bit PWM LED controller
  Copyright (C) 2013 Steffen Trumtrar <s.trumtrar@pengutronix.de>
  Copyright (C) 2015 Clemens Gruber <clemens.gruber@pqgruber.com>
  based on the pwm-twl-led.c driver
  Because the PCA9685 has only one prescaler per chip, only the first channel
  that is enabled is allowed to change the prescale register.
  PWM channels requested afterwards must use a period that results in the same
  prescale setting as the one set by the first requested channel.
  GPIOs do not count as enabled PWMs as they are not using the prescaler.
 => max. frequency of 1526 Hz 
 => min. frequency of 24 Hz 
 Internal oscillator with 25 MHz 
 This function is supposed to be called with the lock mutex held 
 No PWM enabled: Change allowed 
 More than one PWM enabled: Change not allowed 
	
	  Only one PWM enabled: Change allowed if the PWM about to
	  be changed is the one that is already enabled
 Helper function to set the duty cycle ratio to duty4096 (e.g. duty=2048 -> 50%) 
 Set the full OFF bit, which has the highest precedence 
 Set the full ON bit and clear the full OFF bit 
		
		  If usage_power is set, the pca9685 driver will phase shift
		  the individual channels relative to their channel number.
		  This improves EMI because the enabled channels no longer
		  turn on at the same time, while still maintaining the
		  configured duty cycle  power output.
 Set ON time (clears full ON bit) 
 Set OFF time (clears full OFF bit) 
 HW does not support reading state of "all LEDs" channel 
 Full OFF bit is set 
 Full ON bit is set 
 Read ON register to calculate duty cycle of staggered output 
 Reset val to 0 in case reading LED_N_ON_L failed 
		
		  "All LEDs" channel:
		  pretend already in use if any of the PWMs are requested
		
		  Regular channel:
		  pretend already in use if the "all LEDs" channel is requested
 Always out 
  The PCA9685 has a bit for turning the PWM output full off or on. Some
  boards like Intel Galileo actually uses these as normal GPIOs so we
  expose a GPIO chip here which can exclusively take over the underlying
  PWM channel.
 Wait 500us for the oscillator to be back up 
		
		  Putting the chip briefly into SLEEP mode
		  at this point won't interfere with the
		  pm_runtime framework, because the pm_runtime
		  state is guaranteed active here.
 Put chip into sleep mode 
 Change the chip-wide output frequency 
 Wake the chip up 
 Calculate (chip-wide) period from prescale value 
	
	  PCA9685_OSC_CLOCK_MHZ is 25, i.e. an integer divider of 1000.
	  The following calculation is therefore only a multiplication
	  and we are not losing precision.
 The (per-channel) polarity is fixed 
		
		  The "all LEDs" channel does not support HW readout
		  Return 0 and disabled for backwards compatibility
 PWMs - except the "all LEDs" channel - default to enabled 
 Disable all LED ALLCALL and SUBx addresses to avoid bus collisions 
 Reset OFFON registers to POR default 
 Add an extra channel for ALL_LED 
		
		  Although the chip comes out of power-up in the sleep state,
		  we force it to sleep in case it was woken up before
 Wake the chip up if runtime PM is disabled 
 Put chip in sleep state if runtime PM is disabled 
 sentinel  },
 sentinel  },
 sentinel  }
 SPDX-License-Identifier: GPL-2.0+
  Azoteq IQS620A PWM Generator
  Copyright (C) 2019 Jeff LaBundy <jeff@labundy.com>
  Limitations:
  - The period is fixed to 1 ms and is generated continuously despite changes
    to the duty cycle or enabledisable state.
  - Changes to the duty cycle or enabledisable state take effect immediately
    and may result in a glitch during the period in which the change is made.
  - The device cannot generate a 0% duty cycle. For duty cycles below 1  256
    ms, the output is disabled and relies upon an external pull-down resistor
    to hold the GPIO3LTX pin low.
	
	  The duty cycle generated by the device is calculated as follows:
	 
	  duty_cycle = (IQS620_PWM_DUTY_CYCLE + 1)  256  1 ms
	 
	  ...where IQS620_PWM_DUTY_CYCLE is a register value between 0 and 255
	  (inclusive). Therefore the lowest duty cycle the device can generate
	  while the output is enabled is 1  256 ms.
	 
	  For lower duty cycles (e.g. 0), the PWM output is simply disabled to
	  allow an external pull-down resistor to hold the GPIO3LTX pin low.
	
	  Since the device cannot generate a 0% duty cycle, requests to do so
	  cause subsequent calls to iqs620_pwm_get_state to report the output
	  as disabled. This is not ideal, but is the best compromise based on
	  the capabilities of the device.
	
	  The parent MFD driver already prints an error message in the event
	  of a device reset, so nothing else is printed here unless there is
	  an additional failure.
 SPDX-License-Identifier: GPL-2.0-only
  TINational Semiconductor LP3943 PWM driver
  Copyright 2013 Texas Instruments
  Author: Milo Kim <milo.kim@ti.com>
 Return an error if the pin is already assigned 
	
	  How to configure the LP3943 PWMs
	 
	  1) Period = 6250 ~ 1600000
	  2) Prescale = period  6250 -1
	  3) Duty = input duty
	 
	  Prescale and duty are register values
	
	  Each PWM generator is set to control any of outputs of LP3943.
	  To enabledisable the PWM, these output pins should be configured.
	
	  LP3943 outputs are open-drain, so the pin should be configured
	  when the PWM is disabled.
	
	  Read the output map configuration from the device tree.
	  Each of the two PWM generators can drive zero or more outputs.
  ST Microelectronics SPEAr Pulse Width Modulator driver
  Copyright (C) 2012 ST Microelectronics
  Shiraz Hashim <shiraz.linux.kernel@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 PWM registers and bits definitions 
 Control Register 
 Duty Cycle Register 
 Period Register 
 Following only available on 13xx SoCs 
 Master Control Register 
  struct spear_pwm_chip - struct representing pwm chip
  @mmio_base: base address of pwm chip
  @clk: pointer to clk structure of pwm chip
  @chip: linux pwm chip representation
	
	  Find pv, dc and prescale to suit duty_ns and period_ns. This is done
	  according to formulas described below:
	 
	  period_ns = 10^9  (PRESCALE + 1)  PV  PWM_CLK_RATE
	  duty_ns = 10^9  (PRESCALE + 1)  DC  PWM_CLK_RATE
	 
	  PV = (PWM_CLK_RATE  period_ns)  (10^9  (PRESCALE + 1))
	  DC = (PWM_CLK_RATE  duty_ns)  (10^9  (PRESCALE + 1))
 if duty_ns and period_ns are not achievable then return 
		
		  if pv and dc have crossed their upper limit, then increase
		  prescale and recalculate pv and dc.
	
	  NOTE: the clock to PWM has to be enabled first before writing to the
	  registers.
		
		  Following enables PWM chip, channels would still be
		  enabled individually through their control register
 clk was prepared in probe, hence unprepare it here 
 SPDX-License-Identifier: GPL-2.0-or-later
   Freescale FlexTimer Module (FTM) PWM Driver
   Copyright 2012-2013 Freescale Semiconductor, Inc.
 This value is valid iff a pwm is running 
	
	  The Freescale FTM controller supports only a single period for
	  all PWM channels, therefore verify if the newly computed period
	  is different than the current period being used. In such case
	  we allow to change the period only if no other pwm is running.
	
	  oldstate to newstate : action
	 
	  disabled to disabled : ignore
	  enabled to disabled : disable
	  enabled to enabled : update settings
	  disabled to enabled : update settings + enable
 check if need to enable 
	
	  ipg_clk is the interface clock for the IP. If not provided, use the
	  ftm_sys clock as the default.
 restore all registers from cache 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) Overkiz SAS 2012
  Author: Boris BREZILLON <b.brezillon@overkiz.com>
 PWM polarity 
 PWM clock divider 
 PWM duty expressed in clk cycles 
 PWM period expressed in clk cycles 
	
	  Get init config from Timer Counter registers if
	  Timer Counter is already configured as a PWM generator.
	
	  If duty is 0 the timer will be stopped and we have to
	  configure the output correctly on software trigger:
	   - set output to high if PWM_POLARITY_INVERSED
	   - set output to low if PWM_POLARITY_NORMAL
	 
	  This is why we're reverting polarity in this case.
 flush old setting and set the new one 
	
	  Use software trigger to apply the new setting.
	  If both PWM devices in this group are disabled we stop the clock.
	
	  If duty is 0 the timer will be stopped and we have to
	  configure the output correctly on software trigger:
	   - set output to high if PWM_POLARITY_INVERSED
	   - set output to low if PWM_POLARITY_NORMAL
	 
	  This is why we're reverting polarity in this case.
 flush old setting and set the new one 
 Set CMR flags according to given polarity 
	
	  If duty is 0 or equal to period there's no need to register
	  a specific action on RARB and RC compare.
	  The output will be configured on software trigger and keep
	  this config till next config call.
 Use software trigger to apply the new setting 
	
	  Find best clk divisor:
	  the smallest divisor which can fulfill the period_ns requirements.
	  If there is a gclk, the first divisor is actuallly the gclk selector
	
	  If none of the divisor are small enough to represent period_ns
	  take slow clock (32KHz).
 If period is too big return ERANGE error 
	
	  PWM devices provided by the TCB driver are grouped by 2.
	  PWM devices in a given group must be configured with the
	  same period_ns.
	 
	  We're checking the period value of the second PWM device
	  in this group before applying the new config.
 This function only sets a flag in driver data 
 sentinel  }
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  R-Mobile TPU PWM driver
  Copyright (C) 2012 Renesas Solutions Corp.
 Timer start register (shared) 
 Timer control register 
 Timer mode register 
 Timer IO control register 
 Timer interrupt enable register 
 Timer status register 
 Timer counter 
 Timer general register A 
 Timer general register B 
 Timer general register C 
 Timer general register D 
 Pin is driven inactive 
 Pin is driven by PWM 
 Pin is driven active 
 Whether the timer is running 
 Channel number in the TPU 
 Wake up device and enable clock. 
	
	  Make sure the channel is stopped, as we need to reconfigure it
	  completely. First drive the pin to the inactive state to avoid
	  glitches.
	
	  - Clear TCNT on TGRB match
	  - Count on rising edge
	  - Set prescaler
	  - Output 0 until TGRA, output 1 until TGRB (active low polarity)
	  - Output 1 until TGRA, output 0 until TGRB (active high polarity
	  - PWM mode
 Start the channel. 
 Disable channel. 
 Stop clock and mark device as idle. 
 -----------------------------------------------------------------------------
  PWM API
	
	  Pick a prescaler to avoid overflowing the counter.
	  TODO: Pick the highest acceptable prescaler.
 If the channel is disabled we're done. 
		
		  If only the duty cycle changed and the timer is already
		  running, there's no need to reconfigure it completely, Just
		  modify the duty cycle.
 Otherwise perform a full reconfiguration. 
		
		  To avoid running the timer when not strictly required, handle
		  0% and 100% duty cycles as fixed levels and stop the timer.
	
	  To avoid running the timer when not strictly required, handle 0% and
	  100% duty cycles as fixed levels and stop the timer.
 The timer must be running to modify the pin output configuration. 
 -----------------------------------------------------------------------------
  Probe and remove
 Map memory, get clock and pin control. 
 Initialize and register the device. 
 SPDX-License-Identifier: GPL-2.0-or-later
  The Netronix embedded controller is a microcontroller found in some
  e-book readers designed by the original design manufacturer Netronix, Inc.
  It contains RTC, battery monitoring, system power management, and PWM
  functionality.
  This driver implements PWM output.
  Copyright 2020 Jonathan Neuschäfer <j.neuschaefer@gmx.net>
  Limitations:
  - The get_state callback is not implemented, because the current state of
    the PWM output can't be read back from the hardware.
  - The hardware can only generate normal polarity output.
  - The period and duty cycle can't be changed together in one atomic action.
  The time base used in the EC is 8MHz, or 125ns. Period and duty cycle are
  measured in this unit.
  The maximum input value (in nanoseconds) is determined by the time base and
  the range of the hardware registers that hold the converted value.
  It fits into 32 bits, so we can do our calculations in 32 bits as well.
	
	  Changes to the period and duty cycle take effect as soon as the
	  corresponding low byte is written, so the hardware may be configured
	  to an inconsistent state after the period is written and before the
	  duty cycle is fully written. If, in such a case, the old duty cycle
	  is longer than the new period, the EC may output 100% for a moment.
	 
	  To minimize the time between the changes to period and duty cycle
	  taking effect, the writes are interleaved.
	
	  Writing a duty cycle of zero puts the device into a state where
	  writing a higher duty cycle doesn't result in the brightness that it
	  usually results in. This can be fixed by cycling the ENABLE register.
	 
	  As a workaround, write ENABLE=0 when the duty cycle is zero.
	  The case that something has previously set the duty cycle to zero
	  but ENABLE=1, is not handled.
 Disable the auto-off timer 
	
	  No .get_state callback, because the current state cannot be read
	  back from the hardware.
 SPDX-License-Identifier: GPL-2.0
  MediaTek Pulse Width Modulator driver
  Copyright (C) 2015 John Crispin <blogic@openwrt.org>
  Copyright (C) 2017 Zhi Mao <zhi.mao@mediatek.com>
 PWM registers and bits definitions 
  struct pwm_mediatek_chip - struct representing PWM chip
  @chip: linux PWM chip representation
  @regs: base address of PWM chip
  @clk_top: the top clock generator
  @clk_main: the clock used by PWM core
  @clk_pwms: the clock used by each PWM channel
  @clk_freq: the fix clock frequency of legacy MIPS SoC
  @soc: pointer to chip's platform data
 Make sure we use the bus clock and not the 26MHz clock 
 Using resolution in picosecond gets accuracy higher 
		
		  PWM[4,5] has distinct offset for PWMDWIDTH and PWMTHRES
		  from the other PWMs on MT7623.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2015 Intel Corporation. All rights reserved.
  Author: Shobhit Kumar <shobhit.kumar@intel.com>
 DIVIDECLK = BASECLK 
 DIVIDECLK = BASECLK100 
 DIVIDECLK = BASECLK128 
 6 MHz 
 183 Hz 
  struct crystalcove_pwm - Crystal Cove PWM controller
  @chip: the abstract pwm_chip structure.
  @regmap: the regmap from the parent device.
 clk_div 1 - 128, maps to register values 0-127 
 changing the clk divisor, clear PWM_OUTPUT_ENABLE first 
 get the PMIC regmap 
 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
  PWM controller driver for Amlogic Meson SoCs.
  This PWM is only a set of Gates, Dividers and Counters:
  PWM output is achieved by calculating a clock that permits calculating
  two periods (low and high). The counter then has to be set to switch after
  N cycles for the first half period.
  The hardware has no "polarity" setting. This driver reverses the period
  cycles (the low length is inverted with the high length) for
  PWM_POLARITY_INVERSED. This means that .get_state cannot read the polarity
  from the hardware.
  Setting the duty cycle will disable and re-enable the PWM output.
  Disabling the PWM stops the output immediately (without waiting for the
  current period to complete first).
  The public S912 (GXM) datasheet contains some documentation for this PWM
  controller starting on page 543:
  https:dl.khadas.comHardwareVIM2DatasheetS912_Datasheet_V0.220170314publicversion-Wesion.pdf
  An updated version of this IP block is found in S922X (G12B) SoCs. The
  datasheet contains the description for this IP block revision starting at
  page 1084:
  https:dn.odroid.comS922XODROID-N2DatasheetS922X_Public_Datasheet_V0.2.pdf
  Copyright (c) 2016 BayLibre, SAS.
  Author: Neil Armstrong <narmstrong@baylibre.com>
  Copyright (C) 2014 Amlogic, Inc.
	
	  Protects register (write) access to the REG_MISC_AB register
	  that is shared between the two PWMs.
 Then check is we can have the duty with the same pre_div 
			
			  This IP block revision doesn't have an "always high"
			  setting which we can use for "inverted disabled".
			  Instead we achieve this using the same settings
			  that we use a pre_div of 0 (to get the shortest
			  possible duration for one "count") and
			  "period == duty_cycle". This results in a signal
			  which is LOW for one "count", while being HIGH for
			  the rest of the (so the signal is HIGH for slightly
			  less than 100% of the period, but this is the best
			  we can achieve).
 to_meson_pwm() can only be used after .get_state() is called 
  Only the 2 first inputs of the GXBB AO PWMs are valid
  The last 2 are grounded
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) ST-Ericsson SA 2010
  Author: Arun R Murthy <arun.murthy@stericsson.com>
  PWM Out generators
  Bank: 0x10
	
	  get the first 8 bits that are be written to
	  AB8500_PWM_OUT_CTRL1_REG[0:7]
	
	  get bits [9:10] that are to be written to
	  AB8500_PWM_OUT_CTRL2_REG[0:1]
	
	  Nothing to be done in probe, this is required to get the
	  device which is required for ab8500 read and write
 SPDX-License-Identifier: GPL-2.0
  Tracepoint definitions for vfio_ccw
  Copyright IBM Corp. 2019
  Author(s): Eric Farman <farman@linux.ibm.com>
 SPDX-License-Identifier: GPL-2.0
     Copyright IBM Corp. 2007, 2012
     Author(s): Peter Oberparleiter <peter.oberparleiter@de.ibm.com>
 Clear ids starting from @schid up to end of subchannel set. 
 SPDX-License-Identifier: GPL-2.0
   Functions for assembling fcx enabled IO control blocks.
     Copyright IBM Corp. 2008
     Author(s): Peter Oberparleiter <peter.oberparleiter@de.ibm.com>
  tcw_get_intrg - return pointer to associated interrogate tcw
  @tcw: pointer to the original tcw
  Return a pointer to the interrogate tcw associated with the specified tcw
  or %NULL if there is no associated interrogate tcw.
  tcw_get_data - return pointer to inputoutput data associated with tcw
  @tcw: pointer to the tcw
  Return the input or output data address specified in the tcw depending
  on whether the r-bit or the w-bit is set. If neither bit is set, return
  %NULL.
  tcw_get_tccb - return pointer to tccb associated with tcw
  @tcw: pointer to the tcw
  Return pointer to the tccb associated with this tcw.
  tcw_get_tsb - return pointer to tsb associated with tcw
  @tcw: pointer to the tcw
  Return pointer to the tsb associated with this tcw.
  tcw_init - initialize tcw data structure
  @tcw: pointer to the tcw to be initialized
  @r: initial value of the r-bit
  @w: initial value of the w-bit
  Initialize all fields of the specified tcw data structure with zero and
  fill in the format, flags, r and w fields.
		 TODO: find out if padding applies to total of data
		  transferred or data transferred by this tidaw. Assumption:
  tcw_finalize - finalize tcw length fields and tidaw list
  @tcw: pointer to the tcw
  @num_tidaws: the number of tidaws used to address inputoutput data or zero
  if no tida is used
  Calculate the input-output-count and tccbl field in the tcw, add a
  tcat the tccb and terminate the data tidaw list if used.
  Note: in case input- or output-tida is used, the tidaw-list must be stored
  in contiguous storage (no ttic). The tcal field in the tccb must be
  up-to-date.
 Terminate tidaw list. 
 Add tcat to tccb. 
 Calculate tcw inputoutput count and tcat transport count. 
 Calculate tccbl. 
  tcw_set_intrg - set the interrogate tcw address of a tcw
  @tcw: the tcw address
  @intrg_tcw: the address of the interrogate tcw
  Set the address of the interrogate tcw in the specified tcw.
  tcw_set_data - set data address and tida flag of a tcw
  @tcw: the tcw address
  @data: the data address
  @use_tidal: zero of the data address specifies a contiguous block of data,
  non-zero if it specifies a list if tidaws.
  Set the inputoutput data address of a tcw (depending on the value of the
  r-flag and w-flag). If @use_tidal is non-zero, the corresponding tida flag
  is set as well.
  tcw_set_tccb - set tccb address of a tcw
  @tcw: the tcw address
  @tccb: the tccb address
  Set the address of the tccb in the specified tcw.
  tcw_set_tsb - set tsb address of a tcw
  @tcw: the tcw address
  @tsb: the tsb address
  Set the address of the tsb in the specified tcw.
  tccb_init - initialize tccb
  @tccb: the tccb address
  @size: the maximum size of the tccb
  @sac: the service-action-code to be user
  Initialize the header of the specified tccb by resetting all values to zero
  and filling in defaults for format, sac and initial tcal fields.
  tsb_init - initialize tsb
  @tsb: the tsb address
  Initialize the specified tsb by resetting all values to zero.
  tccb_add_dcw - add a dcw to the tccb
  @tccb: the tccb address
  @tccb_size: the maximum tccb size
  @cmd: the dcw command
  @flags: flags for the dcw
  @cd: pointer to control data for this dcw or NULL if none is required
  @cd_count: number of control data bytes for this dcw
  @count: number of data bytes for this dcw
  Add a new dcw to the specified tccb by writing the dcw information specified
  by @cmd, @flags, @cd, @cd_count and @count to the tca of the tccb. Return
  a pointer to the newly added dcw on success or -%ENOSPC if the new dcw
  would exceed the available space as defined by @tccb_size.
  Note: the tcal field of the tccb header will be updates to reflect added
  content.
 Check for space. 
 Add dcw to tca. 
  tcw_add_tidaw - add a tidaw to a tcw
  @tcw: the tcw address
  @num_tidaws: the current number of tidaws
  @flags: flags for the new tidaw
  @addr: address value for the new tidaw
  @count: count value for the new tidaw
  Add a new tidaw to the inputoutput data tidaw-list of the specified tcw
  (depending on the value of the r-flag and w-flag) and return a pointer to
  the new tidaw.
  Note: the tidaw-list is assumed to be contiguous with no ttics. The caller
  must ensure that there is enough space for the new tidaw. The last-tidaw
  flag for the last tidaw in the list will be set by tcw_finalize.
 Add tidaw to tidaw-list. 
 SPDX-License-Identifier: GPL-2.0
  finite state machine for device handling
     Copyright IBM Corp. 2002, 2008
     Author(s): Cornelia Huck (cornelia.huck@de.ibm.com)
 		 Martin Schwidefsky (schwidefsky@de.ibm.com)
  Timeout function. It just triggers a DEV_EVENT_TIMEOUT.
  Set timeout
  The machine won't give us any notification by machine check if a chpid has
  been varied online on the SE so we have to find out by magic (i. e. driving
  the channel subsystem to device selection and updating our path masks).
  Stop device recognition.
	
	  Now that we tried recognition, we have performed device selection
	  through ssch() and the path information is up to date.
 Check since device may again have become not operational. 
 Force reprobe on all chpids. 
 device was recognized before 
  Function called from device_id.c after sense id has completed.
 Sense id stopped by timeout. 
   ccw_device_notify() - inform the device's driver about an event
   @cdev: device for which an event occurred
   @event: event that occurred
   Returns:
     -%EINVAL if the device is offline or has no driver.
     -%EOPNOTSUPP if the device's driver has no notifier registered.
     %NOTIFY_OK if the driver wants to keep the device.
     %NOTIFY_BAD if the driver doesn't want to keep the device.
 Reenable channel measurements, if needed. 
 Save indication for new paths. 
 Driver doesn't want device back. 
  Finished with onlineoffline processing.
 Reset device status. 
  Start device recognition.
	
	  We used to start here with a sense pgid to find out whether a device
	  is locked by someone else. Unfortunately, the sense pgid command
	  code has other meanings on devices predating the path grouping
	  algorithm, so we start with sense id and box the device after an
	  timeout (or if sense pgid during path verification detects the device
	  is locked, as may happen on newer devices).
  Handle events for states that use the ccw request infrastructure.
 Update schib - pom may have changed. 
 Update lpm with verified path mask. 
 Repeat path verification? 
 Deliver fake irb to device driver, if needed. 
 Reset oper notify indication after verify error. 
 Reset oper notify indication after verify error. 
 Reset oper notify indication after verify error. 
  Get device online.
 Couldn't enable the subchannel for io. Sick device. 
 Start initial path verification. 
  Shutdown device.
 Allow ccw_device_offline while disconnected. 
 Are we doing path grouping? 
 No, set state offline immediately. 
 Start Set Path Group commands. 
  Handle not operational event in non-special state.
  Handle path verification event in offline state.
  Handle path verification event.
	
	  Since we might not just be coming from an interrupt from the
	  subchannel we have to update the schib.
		
		  No final status yet or final status not yet delivered
		  to the device driver. Can't do path verification now,
		  delay until final status was delivered.
 Device is idle, we can do the path verification. 
  Handle path verification event in boxed state.
  Pass interrupt to device driver.
	
	  we allow for the device action handler if .
	   - we received ending status
	   - the action handler requested to see all interrupts
	   - we received an intermediate status
	   - fast notification was requested (primary status)
	   - unsolicited interrupts
  Got an interrupt for a normal io (state online).
 Check for unsolicited interrupt. 
 Unit check but no sense data. Need basic sense. 
 Accumulate status and find out if a basic sense is needed. 
 Call the handler. 
 Start delayed path verification. 
  Got an timeout in online state.
  Got an interrupt for a basic sense.
 Check for unsolicited interrupt. 
 Basic sense hasn't started. Try again. 
	
	  Check if a halt or clear has been issued in the meanwhile. If yes,
	  only deliver the haltclear interrupt to the device driver as if it
	  had killed the original request.
 Add basic sense info to irb. 
 Another basic sense is needed. 
 In case sensing interfered with setting the device online 
 Call the handler. 
 Start delayed path verification. 
 Start delayed path verification. 
 OK, io is dead now. Call interrupt handler. 
 Start delayed path verification. 
 Start delayed path verification. 
 Start verification after current task finished. 
 Couldn't enable the subchannel for io. Sick device. 
 Update some values. 
	
	  The pim, pam, pom values may not be accurate, but they are the best
	  we have before performing device selection :
	
	  Use the initial configuration since we can't be shure that the old
	  paths are valid.
 We should also udate ssd info, but this has to wait. 
 Check if this is another device which appeared on the same sch. 
	
	  An interrupt in a disabled state means a previous disable was not
	  successful - should not happen, but we try to disable again.
  No operation action. This is used e.g. to ignore a timeout event in
  state offline.
  device statemachine
 states to wait for io completion before doing something 
FIXME
 special states for devices gone not operational 
 SPDX-License-Identifier: GPL-2.0
  Functions for registration of IO interruption subclasses on s390.
  Copyright IBM Corp. 2008
  Authors: Sebastian Ott <sebott@linux.vnet.ibm.com>
  isc_register - register an IO interruption subclass.
  @isc: IO interruption subclass to register
  The number of users for @isc is increased. If this is the first user to
  register @isc, the corresponding IO interruption subclass mask is enabled.
  Context:
    This function must not be called in interrupt context.
  isc_unregister - unregister an IO interruption subclass.
  @isc: IO interruption subclass to unregister
  The number of users for @isc is decreased. If this is the last user to
  unregister @isc, the corresponding IO interruption subclass mask is
  disabled.
  Note: This function must not be called if isc_register() hasn't been called
  before by the driver for @isc.
  Context:
    This function must not be called in interrupt context.
 check for misuse 
 SPDX-License-Identifier: GPL-2.0
  Async IO region for vfio_ccw
  Copyright Red Hat, Inc. 2019
  Author(s): Cornelia Huck <cohuck@redhat.com>
 SPDX-License-Identifier: GPL-2.0
     Copyright IBM Corp. 1999, 2010
     Author(s): Cornelia Huck (cornelia.huck@de.ibm.com)
 		 Arnd Bergmann (arndb@de.ibm.com)
 		 Peter Oberparleiter <peter.oberparleiter@de.ibm.com>
 Map for pending configure tasks. 
 Map for channel-path status. 
 Time after which channel-path status may be outdated. 
 Wait queue for configure completion events. 
 Set vary state for given chpid. 
 On success return 0 if channel-path is varied offline, 1 if it is varied
  chp_get_sch_opm - return opm for subchannel
  @sch: subchannel
  Calculate and return the operational path mask (opm) based on the chpids
  used by the subchannel and the status of the associated channel-paths.
  chp_is_registered - check if a channel-path is registered
  @chpid: channel-path ID
  Return non-zero if a channel-path with the given chpid is registered,
  zero otherwise.
  Function: s390_vary_chpid
  Varies the specified chpid online or offline
  Channel measurement related functions
 Only allow single reads. 
  Files for the channel path entries.
 Wait until previous actions have settled. 
 channel measurements not available 
 channel measurements not available 
  chp_update_desc - update channel-path description
  @chp: channel-path
  Update the channel-path description of the specified channel-path
  including channel measurement related information.
  Return zero on success, non-zero otherwise.
	
	  Fetching the following data is optional. Not all machines or
	  hypervisors implement the required chsc commands.
  chp_new - register a new channel-path
  @chpid: channel-path ID
  Create and register data structure representing new channel-path. Return
  zero on success, non-zero otherwise.
 fill in status, etc. 
 Obtain channel path description and fill it in. 
 make it known to the system 
  chp_get_chp_desc - return newly allocated channel-path description
  @chpid: channel-path ID
  On success return a newly allocated copy of the channel-path description
  data associated with the given channel-path ID. Return %NULL on error.
  chp_process_crw - process channel-path status change
  @crw0: channel report-word to handler
  @crw1: second channel-report word (always NULL)
  @overflow: crw overflow indication
  Handle channel-report-words indicating that the status of a channel-path
  has changed.
	
	  Check for solicited machine checks. These are
	  created by reset channel path and need not be
	  handled here.
 Path has come. 
 Path has gone. 
 Force chp_info refresh on next call to info_validate(). 
 Ensure that chp_info is up-to-date. 
 Data is too old, update. 
  chp_info_get_status - retrieve configure status of a channel-path
  @chpid: channel-path ID
  On success, return 0 for standby, 1 for configured, 2 for reserved,
  3 for not recognized. Return negative error code on error.
 Return configure task for chpid. 
 Set configure task for chpid. 
 Fetch the first configure task. Set chpid accordingly. 
 Perform one configuredeconfigure request. Reschedule work function until
 Get updated information after last change. 
  chp_cfg_schedule - schedule chpid configuration request
  @chpid: channel-path ID
  @configure: Non-zero for configure, zero for deconfigure
  Schedule a channel-path configurationdeconfiguration request.
  chp_cfg_cancel_deconfigure - cancel chpid deconfiguration request
  @chpid: channel-path ID
  Cancel an active channel-path deconfiguration request if it has not yet
  been performed.
 Register available channel-paths. 
 SPDX-License-Identifier: GPL-2.0
    Channel report handling code
     Copyright IBM Corp. 2000, 2009
     Author(s): Ingo Adlung <adlung@de.ibm.com>,
 		 Martin Schwidefsky <schwidefsky@de.ibm.com>,
 		 Cornelia Huck <cornelia.huck@de.ibm.com>,
 		 Heiko Carstens <heiko.carstens@de.ibm.com>,
  crw_register_handler() - register a channel report word handler
  @rsc: reporting source code to handle
  @handler: handler to be registered
  Returns %0 on success and a negative error value otherwise.
  crw_unregister_handler() - unregister a channel report word handler
  @rsc: reporting source code to handle
  Retrieve CRWs and call function to handle event.
 Check for overflows. 
 chain is always 0 or 1 here. 
  Machine checks for the channel subsystem must be enabled
  after the channel subsystem is initialized
 enable channel report MCH 
 SPDX-License-Identifier: GPL-2.0
  Finite state machine for vfio-ccw device handling
  Copyright IBM Corp. 2017
  Copyright Red Hat, Inc. 2019
  Author(s): Dong Jia Shi <bjsdjshi@linux.vnet.ibm.com>
             Cornelia Huck <cohuck@redhat.com>
 Issue "Start Subchannel" 
		
		  Initialize device status information
 Status pending 
 Busy 
 Devicepath not operational 
 Issue "Halt Subchannel" 
		
		  Initialize device status information
 Status pending 
 Busy 
 Device not operational 
 Issue "Clear Subchannel" 
		
		  Initialize device status information
 TODO: check what else we might need to clear 
 Device not operational 
	
	  TODO:
	  Probably we should send the machine check to the guest.
  No operation action.
	
	  An interrupt in a disabled state means a previous disable was not
	  successful - should not happen, but we try to disable again.
  Deal with the ccw command request from the userspace.
 Don't try to build a cp if transport mode is specified. 
 Start channel program and wait for IO interrupt. 
 halt is handled via the async cmd region 
 clear is handled via the async cmd region 
  Deal with an async request from userspace.
 should not happen? 
  Got an interrupt for a normal io (state busy).
  Device statemachine
 SPDX-License-Identifier: GPL-2.0
   Copyright IBM Corp. 2008, 2009
   Author: Jan Glauber (jang@linux.vnet.ibm.com)
 allocate trace view for the interface 
 SPDX-License-Identifier: GPL-2.0
  Channel path related status regions for vfio_ccw
  Copyright IBM Corp. 2020
  Author(s): Farhan Ali <alifm@linux.ibm.com>
             Eric Farman <farman@linux.ibm.com>
 Notify the guest if more CRWs are on our queue 
 SPDX-License-Identifier: GPL-2.0
  driver for channel subsystem
  Copyright IBM Corp. 2002, 2010
  Author(s): Arnd Bergmann (arndb@de.ibm.com)
 	      Cornelia Huck (cornelia.huck@de.ibm.com)
 Skip idset allocation in case of known-only loop. 
 fall back to brute force scanning in case of oom 
 Process registered subchannels. 
 Process unregistered subchannels. 
	
	  The physical addresses for some of the dma structures that can
	  belong to a subchannel need to fit 31 bit width (e.g. ccw).
	
	  But we don't have such restrictions imposed on the stuff that
	  is handled by the streaming API.
  css_sch_device_unregister - unregister a subchannel
  @sch: subchannel to be unregistered
 We need to keep extra room for a newline 
 Initialize the subchannel structure 
	
	  We don't want to generate uevents for IO subchannels that don't
	  have a working ccw device behind them since they will be
	  unregistered before they can be used anyway, so we delay the add
	  uevent until after device recognition was successful.
	  Note that we suppress the uevent for all subchannel types;
	  the subchannel driver can decide itself when it wants to inform
	  userspace of its existence.
 make it known to the system 
		
		  No driver matched. Generate the uevent now so that
		  a fitting driver module may be loaded based on the
		  modalias.
  css_sch_is_valid() - check if a subchannel is valid
  @schib: subchannel information block for the subchannel
 Will be done on the slow path. 
	
	  The first subchannel that is not-operational (ccode==3)
	  indicates that there aren't any more devices available.
	  If stsch gets an exception, it means the current subchannel set
	  is not valid.
  css_sched_sch_todo - schedule a subchannel operation
  @sch: subchannel
  @todo: todo
  Schedule the operation identified by @todo to be performed on the slow path
  workqueue. Do nothing if another operation with higher priority is already
  scheduled. Needs to be called with subchannel lock held.
 Get workqueue ref. 
 Already queued, release workqueue ref. 
 Find out todo. 
 Perform todo. 
 Release workqueue ref. 
		
		  The loop might take long time for platforms with lots of
		  known devices. Allow scheduling here.
 These should abort looping 
		 Allow scheduling here since the containing loop might
 Find unregistered subchannels. 
 Fallback. 
 Apply to slow_subchannel_set. 
 Schedule reprobing of all unregistered subchannels. 
 Schedule with a delay to allow merging of subsequent calls. 
  Called from the machine check handler for subchannel report words.
	
	  Since we are always presented with IPI in the CRW, we have to
	  use stsch() to find out if the subchannel in question has come
	  or gone.
	
	  We currently allocate notifier bits with this (using
	  css->device as the device argument with the DMA API)
	  and are fine with 64 bit addresses.
 Currently cio supports only a single css 
 this is quite ugly but no better idea 
 No need to free up the resources: compiled in 
  Allocate dma memory from the css global pool. Intended for memory not
  specific to any single device within the css. The allocated memory
  is not guaranteed to be 31-bit addressable.
  Caution: Not suitable for early stuff like console.
  Now that the driver core is running, we can setup our channel subsystem.
  The struct subchannel's are created during probing.
 Try to enable MSS. 
 Success. 
 Setup css structure. 
 Enable default isc for IO subchannels. 
 Register subchannels which are already in use. 
 Start initial subchannel evaluation. 
 Wait for the evaluation of subchannels to finish. 
 Wait for the subchannel type specific initialization to finish 
  Wait for the initialization of devices to finish, to make sure we are
  done with our setup if the search for the root device starts.
 Handle pending CRW's. 
CONFIG_PROC_FS
 When driver_override is set, only bind to the matching driver 
  css_driver_register - register a css driver
  @cdrv: css driver to register
  This is mainly a wrapper around driver_register that sets name
  and bus_type in the embedded struct device_driver correctly.
  css_driver_unregister - unregister a css driver
  @cdrv: css driver to unregister
  This is a wrapper around driver_unregister.
 SPDX-License-Identifier: GPL-2.0+
  Linux on zSeries Channel Measurement Facility support
  Copyright IBM Corp. 2000, 2006
  Authors: Arnd Bergmann <arndb@de.ibm.com>
 	    Cornelia Huck <cornelia.huck@de.ibm.com>
  original idea from Natarajan Krishnaswami <nkrishna@us.ibm.com>
 get_tod_clock() 
  parameter to enable cmf during boot, possible uses are:
   "s390cmf" -- enable cmf and allocate 2 MB of ram so measuring can be
                used on any subchannel
   "s390cmf=<num>" -- enable cmf and allocate enough memory to measure
                      <num> subchannel, where <num> is an integer
                      between 1 and 65535, default is 1024
 indices for READCMB 
 basic and exended format: 
 extended format only: 
  enum cmb_format - types of supported measurement block formats
  @CMF_BASIC:      traditional channel measurement blocks supported
 		    by all machines that we run on
  @CMF_EXTENDED:   improved format that was introduced with the z990
 		    machine
  @CMF_AUTODETECT: default: use extended format when running on a machine
 		    supporting extended format, otherwise fall back to
 		    basic format
  format - actual format for all measurement blocks
  The format module parameter can be set to a value of 0 (zero)
  or 1, indicating basic or extended format as described for
  enum cmb_format.
  struct cmb_operations - functions to use depending on cmb_format
  Most of these functions operate on a struct ccw_device. There is only
  one instance of struct cmb_operations because the format of the measurement
  data is guaranteed to be the same for every ccw_device.
  @alloc:	allocate memory for a channel measurement block,
 		either with the help of a special pool or with kmalloc
  @free:	free memory allocated with @alloc
  @set:	enable or disable measurement
  @read:	read a measurement entry at an index
  @readall:	read a measurement block in a common format
  @reset:	clear the data in the associated measurement block and
 		reset its time stamp
 private: 
 Pointer to block updated by hardware 
 Last changed block copied from hardware block 
 Size of hw_block and last_block 
 when last_block was updated 
  Our user interface is designed in terms of nanoseconds,
  while the hardware measures total times in its own
  unit.
  Users are usually interested in average times,
  not accumulated time.
  This also helps us with atomicity problems
  when reading sinlge values.
 no samples yet, avoid division by 0 
 value comes in units of 128 µsec 
  Activate or deactivate the channel monitor. When area is NULL,
  the monitor is deactivated. The channel monitor needs to
  be active in order to measure subchannels, which also need
  to be enabled.
 activate channel measurement 
 address can be either a block address or a block index 
		
		  The task was to disable measurement block updates but
		  the subchannel is already gone. Report success.
 if the device is not online, don't even try again 
 Don't copy if a start function is in progress. 
		
		  Need to reset hw block as well to make the hardware start
		  from 0 again.
  struct cmb_area - container for global cmb data
  @mem:	pointer to CMBs (only in basic measurement mode)
  @list:	contains a linked list of all subchannels
  @num_channels: number of channels to be measured
  @lock:	protect concurrent access to @mem and @list
  old style CMB handling 
  Basic channel measurement blocks are allocated in one contiguous
  block of memory, which can not be moved as long as any channel
  is active. Therefore, a maximum number of subchannels needs to
  be defined somewhere. This is a module parameter, defaulting to
  a reasonable value of 1024, or 32 kb of memory.
  Current kernels don't allow kmalloc with more than 128kb, so the
  maximum is 4096.
  struct cmb - basic channel measurement block
  @ssch_rsch_count: number of ssch and rsch
  @sample_count: number of samples
  @device_connect_time: time of device connect
  @function_pending_time: time of function pending
  @device_disconnect_time: time of device disconnect
  @control_unit_queuing_time: time of control unit queuing
  @device_active_only_time: time of device active only
  @reserved: unused in basic measurement mode
  The measurement block as used by the hardware. The fields are described
  further in zArchitecture Principles of Operation, chapter 17.
  The cmb area made up from these blocks must be a contiguous array and may
  not be reallocated or freed.
  Only one cmb area can be present in the system.
  Insert a single device into the cmb_area list.
  Called with cmb_area.lock held from alloc_cmb.
	
	  Find first unused cmb in cmb_area.mem.
	  This is a little tricky: cmb_area.list
	  remains sorted by ->cmb->hw_data pointers.
 insert new cmb 
 Allocate private cmb_data. 
 there is no user yet, so we need a new area 
 ok, another thread was faster 
 no luck 
 everything ok 
 do the actual allocation 
 calculate utilization in 0.1 percent units 
 we only know values before device_busy_time 
 copy data to new structure 
 time fields are converted to nanoseconds while copying 
  extended cmb handling 
  struct cmbe - extended channel measurement block
  @ssch_rsch_count: number of ssch and rsch
  @sample_count: number of samples
  @device_connect_time: time of device connect
  @function_pending_time: time of function pending
  @device_disconnect_time: time of device disconnect
  @control_unit_queuing_time: time of control unit queuing
  @device_active_only_time: time of device active only
  @device_busy_time: time of device busy
  @initial_command_response_time: initial command response time
  @reserved: unused
  The measurement block as used by the hardware. May be in any 64 bit physical
  location.
  The fields are described further in zArchitecture Principles of Operation,
  third edition, chapter 17.
 activate global measurement if this is the first channel 
 deactivate global measurement if this is the last channel 
 we only know values before device_busy_time 
 copy data to new structure 
 time fields are converted to nanoseconds while copying 
  enable_cmf() - switch on the channel measurement for a specific device
   @cdev:	The ccw device to be enabled
   Enable channel measurements for @cdev. If this is called on a device
   for which channel measurement is already enabled a reset of the
   measurement data is triggered.
   Returns: %0 for success or a negative error value.
   Context:
     non-atomic
  __disable_cmf() - switch off the channel measurement for a specific device
   @cdev:	The ccw device to be disabled
   Returns: %0 for success or a negative error value.
   Context:
     non-atomic, device_lock() held.
  disable_cmf() - switch off the channel measurement for a specific device
   @cdev:	The ccw device to be disabled
   Returns: %0 for success or a negative error value.
   Context:
     non-atomic
  cmf_read() - read one value from the current channel measurement block
  @cdev:	the channel to be read
  @index:	the index of the value to be read
  Returns: The value read or %0 if the value cannot be read.
   Context:
     any
  cmf_readall() - read the current channel measurement block
  @cdev:	the channel to be read
  @data:	a pointer to a data block that will be filled
  Returns: %0 on success, a negative error value otherwise.
   Context:
     any
 Reenable cmf when a disconnected device becomes available again. 
  cmf_reactivate() - reactivate measurement block updates
  Use this during resume from hibernate.
	
	  If the user did not give a parameter, see if we are running on a
	  machine supporting extended measurement blocks, otherwise fall back
	  to basic mode.
 SPDX-License-Identifier: GPL-2.0
  Channel subsystem IO instructions.
 SPDX-License-Identifier: GPL-2.0
   CCW device SENSE ID IO handling.
     Copyright IBM Corp. 2002, 2009
     Author(s): Cornelia Huck <cornelia.huck@de.ibm.com>
 		 Martin Schwidefsky <schwidefsky@de.ibm.com>
 		 Peter Oberparleiter <peter.oberparleiter@de.ibm.com>
  diag210_to_senseid - convert diag 0x210 data to sense id information
  @senseid: sense id
  @diag: diag 0x210 data
  Return 0 on success, non-zero otherwise.
 Special case for osa devices. 
  diag210_get_dev_info - retrieve device information via diag 0x210
  @cdev: ccw device
  Returns zero on success, non-zero otherwise.
  Initialize SENSE ID data.
  Check for complete SENSE ID data.
 Check for incomplete SENSE ID data. 
 Check for incompatible SENSE ID data. 
 Check for extended-identification information. 
  Process SENSE ID request result.
 Try diag 0x210 fallback on zVM. 
  ccw_device_sense_id_start - perform SENSE ID
  @cdev: ccw device
  Execute a SENSE ID channel program on @cdev to update its sense id
  information. When finished, call ccw_device_sense_id_done with a
  return code specifying the result.
 Data setup. 
 Channel program setup. 
 Request setup. 
 SPDX-License-Identifier: GPL-2.0
   bus driver for ccwgroup
   Copyright IBM Corp. 2002, 2012
   Author(s): Arnd Bergmann (arndb@de.ibm.com)
 	       Cornelia Huck (cornelia.huck@de.ibm.com)
 In Linux 2.4, we had a channel device layer called "chandev"
  that did all sorts of obscure stuff for networking devices.
  This is another driver that serves as a replacement for just
  one of its functions, namely the translation of single subchannels
  to devices that use multiple subchannels.
  ccwgroup_set_online() - enable a ccwgroup device
  @gdev: target ccwgroup device
  This function attempts to put the ccwgroup device into the online state.
  Returns:
   %0 on success and a negative error value on failure.
  ccwgroup_set_offline() - disable a ccwgroup device
  @gdev: target ccwgroup device
  @call_gdrv: Call the registered gdrv set_offline function
  This function attempts to put the ccwgroup device into the offline state.
  Returns:
   %0 on success and a negative error value on failure.
  Provide an 'ungroup' attribute so the user can remove group devices no
  longer needed or accidentially created. Saves memory :)
 Prevent concurrent onlineoffline processing and ungrouping. 
 Release onoff "lock" when ungrouping failed. 
 Last entry. Strip trailing newline, if applicable. 
  ccwgroup_create_dev() - create and register a ccw group device
  @parent: parent device for the new device
  @gdrv: driver for the new group device
  @num_devices: number of slave devices
  @buf: buffer containing comma separated bus ids of slave devices
  Create and register a new ccw group device as a child of @parent. Slave
  devices are obtained from the list of bus ids given in @buf.
  Returns:
   %0 on success and an error code on failure.
  Context:
   non-atomic
		
		  All devices have to be of the same type in
		  order to be grouped.
 Don't allow a device to belong to more than one group. 
 Check for sufficient number of bus ids. 
 Check for trailing stuff. 
 Check if the devices are bound to the required ccw driver. 
 driver stuff 
  ccwgroup_driver_register() - register a ccw group driver
  @cdriver: driver to be registered
  This function is mainly a wrapper around driver_register().
 register our new driver with the core 
  ccwgroup_driver_unregister() - deregister a ccw group driver
  @cdriver: driver to be deregistered
  This function is mainly a wrapper around driver_unregister().
  ccwgroup_probe_ccwdev() - probe function for slave devices
  @cdev: ccw device to be probed
  This is a dummy probe function for ccw devices that are slave devices in
  a ccw group device.
  Returns:
   always %0
  ccwgroup_remove_ccwdev() - remove function for slave devices
  @cdev: ccw device to be removed
  This is a remove function for ccw devices that are slave devices in a ccw
  group device. It sets the ccw device offline and also deregisters the
  embedding ccw group device.
 Ignore offlining errors, device is gone anyway. 
 If one of its devices is gone, the whole group is done for. 
 Get ccwgroup device reference for local processing. 
 Unregister group device. 
 Release ccwgroup device reference for local processing. 
 SPDX-License-Identifier: GPL-2.0
  Recognize and maintain s390 storage class memory.
  Copyright IBM Corp. 2012
  Author(s): Sebastian Ott <sebott@linux.vnet.ibm.com>
  scm_driver_register() - register a scm driver
  @scmdrv: driver to be registered
  scm_driver_unregister() - deregister a scm driver
  @scmdrv: driver to be deregistered
  Check for state-changes, notify the driver and userspace.
 Release reference from scm_find(). 
 Release reference from device_initialize(). 
 SPDX-License-Identifier: GPL-2.0
    CIO inject interface
     Copyright IBM Corp. 2021
     Author(s): Vineeth Vijayan <vneethv@linux.ibm.com>
  crw_inject : Initiate the artificial CRW inject
  @crw: The data which needs to be injected as new CRW.
  The CRW handler is called, which will use the provided artificial
  data instead of the CRW from the underlying hardware.
  Return: 0 on success
  stcrw_get_injected: Copy the artificial CRW data to CRW struct.
  @crw: The target CRW pointer.
  Retrieve an injected CRW data. Return 0 on success, 1 if no
  injected-CRW is available. The function reproduces the return
  code of the actual STCRW function.
 The debugfs write handler for crw_inject nodes operation 
 Debugfs write handler for inject_enable node
 enable_inject node enables the static branching 
 SPDX-License-Identifier: GPL-2.0
    S390 common IO routines -- blacklisting of specific devices
     Copyright IBM Corp. 1999, 2013
     Author(s): Ingo Adlung (adlung@de.ibm.com)
 		 Cornelia Huck (cornelia.huck@de.ibm.com)
 		 Arnd Bergmann (arndb@de.ibm.com)
  "Blacklisting" of certain devices:
  Device numbers given in the commandline as cio_ignore=... won't be known
  to Linux.
  These can be single devices or ranges of devices
 65536 bits for each set to indicate if a devno is blacklisted or not 
  Function: blacklist_range
  (Un-)blacklist the devices from-to
 old style 
 new style 
 Checking if devices are blacklisted 
  Function: is_blacklisted
  Returns 1 if the given devicenumber can be found in the blacklist,
  otherwise 0.
  Used by validate_subchannel()
  Function: blacklist_parse_proc_parameters
  parse the stuff which is piped to proccio_ignore
		
		  Evaluate the subchannels without an online device. This way,
		  no path-verification will be triggered on those subchannels
		  and it avoids unnecessary delays.
 Iterator struct for all devices. 
 Not blacklisted, nothing to output. 
 First device in range. 
 Singular device. 
 Last device in range. 
 maybe better use the stack? 
 CONFIG_PROC_FS 
 SPDX-License-Identifier: GPL-2.0
  Driver for s390 chsc subchannels
  Copyright IBM Corp. 2008, 2011
  Author(s): Cornelia Huck <cornelia.huck@de.ibm.com>
 Copy irb to provided request and set done. 
 end of list  },
  chsc_async() - try to start a chsc request asynchronously
  @chsc_area: request to be started
  @request: request structure to associate
  Tries to start a chsc request on one of the existing chsc subchannels.
  Returns:
   %0 if the request was performed synchronously
   %-EINPROGRESS if the request was successfully started
   %-EBUSY if all chsc subchannels are busy
   %-ENODEV if no chsc subchannels are available
  Context:
   interrupts disabled, chsc_lock held
 It makes no sense to try. 
 copy area back to user 
 unknown ioctl number 
 SPDX-License-Identifier: GPL-1.0+
  Copyright IBM Corp. 2002, 2009
  Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com)
 	      Cornelia Huck (cornelia.huck@de.ibm.com)
  ccw_device_set_options_mask() - set some options and unset the rest
  @cdev: device for which the options are to be set
  @flags: options to be set
  All flags specified in @flags are set, all flags not specified in @flags
  are cleared.
  Returns:
    %0 on success, -%EINVAL on an invalid flag combination.
	 The flag usage is mutal exclusive ...
  ccw_device_set_options() - set some options
  @cdev: device for which the options are to be set
  @flags: options to be set
  All flags specified in @flags are set, the remainder is left untouched.
  Returns:
    %0 on success, -%EINVAL if an invalid flag combination would ensue.
	 The flag usage is mutal exclusive ...
  ccw_device_clear_options() - clear some options
  @cdev: device for which the options are to be cleared
  @flags: options to be cleared
  All flags specified in @flags are cleared, the remainder is left untouched.
  ccw_device_is_pathgroup() - determine if paths to this device are grouped
  @cdev: ccw device
  Return non-zero if there is a path group, zero otherwise.
  ccw_device_is_multipath() - determine if device is operating in multipath mode
  @cdev: ccw device
  Return non-zero if device is operating in multipath mode, zero otherwise.
  ccw_device_clear() - terminate IO request processing
  @cdev: target ccw device
  @intparm: interruption parameter to be returned upon conclusion of csch
  ccw_device_clear() calls csch on @cdev's subchannel.
  Returns:
   %0 on success,
   -%ENODEV on device not operational,
   -%EINVAL on invalid device state.
  Context:
   Interrupts disabled, ccw device lock held
  ccw_device_start_timeout_key() - start a s390 channel program with timeout and key
  @cdev: target ccw device
  @cpa: logical start address of channel program
  @intparm: user specific interruption parameter; will be presented back to
 	     @cdev's interrupt handler. Allows a device driver to associate
 	     the interrupt with a particular IO request.
  @lpm: defines the channel path to be used for a specific IO request. A
 	 value of 0 will make cio use the opm.
  @key: storage key to be used for the IO
  @flags: additional flags; defines the action to be performed for IO
 	   processing.
  @expires: timeout value in jiffies
  Start a S390 channel program. When the interrupt arrives, the
  IRQ handler is called, either immediately, delayed (dev-end missing,
  or sense required) or never (no IRQ handler registered).
  This function notifies the device driver if the channel program has not
  completed during the time specified by @expires. If a timeout occurs, the
  channel program is terminated via xsch, hsch or csch, and the device's
  interrupt handler will be called with an irb containing ERR_PTR(-%ETIMEDOUT).
  The interruption handler will echo back the @intparm specified here, unless
  another interruption parameter is specified by a subsequent invocation of
  ccw_device_halt() or ccw_device_clear().
  Returns:
   %0, if the operation was successful;
   -%EBUSY, if the device is busy, or status pending;
   -%EACCES, if no path specified in @lpm is operational;
   -%ENODEV, if the device is not operational.
  Context:
   Interrupts disabled, ccw device lock held
 Remember to fake irb when finished. 
 There's already a fake IO around. 
 Adjust requested path mask to exclude unusable paths. 
  ccw_device_start_key() - start a s390 channel program with key
  @cdev: target ccw device
  @cpa: logical start address of channel program
  @intparm: user specific interruption parameter; will be presented back to
 	     @cdev's interrupt handler. Allows a device driver to associate
 	     the interrupt with a particular IO request.
  @lpm: defines the channel path to be used for a specific IO request. A
 	 value of 0 will make cio use the opm.
  @key: storage key to be used for the IO
  @flags: additional flags; defines the action to be performed for IO
 	   processing.
  Start a S390 channel program. When the interrupt arrives, the
  IRQ handler is called, either immediately, delayed (dev-end missing,
  or sense required) or never (no IRQ handler registered).
  The interruption handler will echo back the @intparm specified here, unless
  another interruption parameter is specified by a subsequent invocation of
  ccw_device_halt() or ccw_device_clear().
  Returns:
   %0, if the operation was successful;
   -%EBUSY, if the device is busy, or status pending;
   -%EACCES, if no path specified in @lpm is operational;
   -%ENODEV, if the device is not operational.
  Context:
   Interrupts disabled, ccw device lock held
  ccw_device_start() - start a s390 channel program
  @cdev: target ccw device
  @cpa: logical start address of channel program
  @intparm: user specific interruption parameter; will be presented back to
 	     @cdev's interrupt handler. Allows a device driver to associate
 	     the interrupt with a particular IO request.
  @lpm: defines the channel path to be used for a specific IO request. A
 	 value of 0 will make cio use the opm.
  @flags: additional flags; defines the action to be performed for IO
 	   processing.
  Start a S390 channel program. When the interrupt arrives, the
  IRQ handler is called, either immediately, delayed (dev-end missing,
  or sense required) or never (no IRQ handler registered).
  The interruption handler will echo back the @intparm specified here, unless
  another interruption parameter is specified by a subsequent invocation of
  ccw_device_halt() or ccw_device_clear().
  Returns:
   %0, if the operation was successful;
   -%EBUSY, if the device is busy, or status pending;
   -%EACCES, if no path specified in @lpm is operational;
   -%ENODEV, if the device is not operational.
  Context:
   Interrupts disabled, ccw device lock held
  ccw_device_start_timeout() - start a s390 channel program with timeout
  @cdev: target ccw device
  @cpa: logical start address of channel program
  @intparm: user specific interruption parameter; will be presented back to
 	     @cdev's interrupt handler. Allows a device driver to associate
 	     the interrupt with a particular IO request.
  @lpm: defines the channel path to be used for a specific IO request. A
 	 value of 0 will make cio use the opm.
  @flags: additional flags; defines the action to be performed for IO
 	   processing.
  @expires: timeout value in jiffies
  Start a S390 channel program. When the interrupt arrives, the
  IRQ handler is called, either immediately, delayed (dev-end missing,
  or sense required) or never (no IRQ handler registered).
  This function notifies the device driver if the channel program has not
  completed during the time specified by @expires. If a timeout occurs, the
  channel program is terminated via xsch, hsch or csch, and the device's
  interrupt handler will be called with an irb containing ERR_PTR(-%ETIMEDOUT).
  The interruption handler will echo back the @intparm specified here, unless
  another interruption parameter is specified by a subsequent invocation of
  ccw_device_halt() or ccw_device_clear().
  Returns:
   %0, if the operation was successful;
   -%EBUSY, if the device is busy, or status pending;
   -%EACCES, if no path specified in @lpm is operational;
   -%ENODEV, if the device is not operational.
  Context:
   Interrupts disabled, ccw device lock held
  ccw_device_halt() - halt IO request processing
  @cdev: target ccw device
  @intparm: interruption parameter to be returned upon conclusion of hsch
  ccw_device_halt() calls hsch on @cdev's subchannel.
  The interruption handler will echo back the @intparm specified here, unless
  another interruption parameter is specified by a subsequent invocation of
  ccw_device_clear().
  Returns:
   %0 on success,
   -%ENODEV on device not operational,
   -%EINVAL on invalid device state,
   -%EBUSY on device busy or interrupt pending.
  Context:
   Interrupts disabled, ccw device lock held
  ccw_device_resume() - resume channel program execution
  @cdev: target ccw device
  ccw_device_resume() calls rsch on @cdev's subchannel.
  Returns:
   %0 on success,
   -%ENODEV on device not operational,
   -%EINVAL on invalid device state,
   -%EBUSY on device busy or interrupt pending.
  Context:
   Interrupts disabled, ccw device lock held
  ccw_device_get_ciw() - Search for CIW command in extended sense data.
  @cdev: ccw device to inspect
  @ct: command type to look for
  During SenseID, command information words (CIWs) describing special
  commands available to the device may have been stored in the extended
  sense data. This function searches for CIWs of a specified command
  type in the extended sense data.
  Returns:
   %NULL if no extended sense data has been stored or if no CIW of the
   specified command type could be found,
   else a pointer to the CIW of the specified command type.
  ccw_device_get_path_mask() - get currently available paths
  @cdev: ccw device to be queried
  Returns:
   %0 if no subchannel for the device is available,
   else the mask of currently available paths for the ccw device's subchannel.
  ccw_device_get_chp_desc() - return newly allocated channel-path descriptor
  @cdev: device to obtain the descriptor for
  @chp_idx: index of the channel path
  On success return a newly allocated copy of the channel-path description
  data associated with the given channel path. Return %NULL on error.
  ccw_device_get_util_str() - return newly allocated utility strings
  @cdev: device to obtain the utility strings for
  @chp_idx: index of the channel path
  On success return a newly allocated copy of the utility strings
  associated with the given channel path. Return %NULL on error.
  ccw_device_get_id() - obtain a ccw device id
  @cdev: device to obtain the id for
  @dev_id: where to fill in the values
  ccw_device_tm_start_timeout_key() - perform start function
  @cdev: ccw device on which to perform the start function
  @tcw: transport-command word to be started
  @intparm: user defined parameter to be passed to the interrupt handler
  @lpm: mask of paths to use
  @key: storage key to use for storage access
  @expires: time span in jiffies after which to abort request
  Start the tcw on the given ccw device. Return zero on success, non-zero
  otherwise.
 Remember to fake irb when finished. 
 There's already a fake IO around. 
 Adjust requested path mask to exclude unusable paths. 
  ccw_device_tm_start_key() - perform start function
  @cdev: ccw device on which to perform the start function
  @tcw: transport-command word to be started
  @intparm: user defined parameter to be passed to the interrupt handler
  @lpm: mask of paths to use
  @key: storage key to use for storage access
  Start the tcw on the given ccw device. Return zero on success, non-zero
  otherwise.
  ccw_device_tm_start() - perform start function
  @cdev: ccw device on which to perform the start function
  @tcw: transport-command word to be started
  @intparm: user defined parameter to be passed to the interrupt handler
  @lpm: mask of paths to use
  Start the tcw on the given ccw device. Return zero on success, non-zero
  otherwise.
  ccw_device_tm_start_timeout() - perform start function
  @cdev: ccw device on which to perform the start function
  @tcw: transport-command word to be started
  @intparm: user defined parameter to be passed to the interrupt handler
  @lpm: mask of paths to use
  @expires: time span in jiffies after which to abort request
  Start the tcw on the given ccw device. Return zero on success, non-zero
  otherwise.
  ccw_device_get_mdc() - accumulate max data count
  @cdev: ccw device for which the max data count is accumulated
  @mask: mask of paths to use
  Return the number of 64K-bytes blocks all paths at least support
  for a transport command. Return value 0 indicates failure.
 Adjust requested path mask to excluded varied off paths. 
  ccw_device_tm_intrg() - perform interrogate function
  @cdev: ccw device on which to perform the interrogate function
  Perform an interrogate function on the given ccw device. Return zero on
  success, non-zero otherwise.
  ccw_device_get_schid() - obtain a subchannel id
  @cdev: device to obtain the id for
  @schid: where to fill in the values
  ccw_device_pnso() - Perform Network-Subchannel Operation
  @cdev:		device on which PNSO is performed
  @pnso_area:		request and response block for the operation
  @oc:			Operation Code
  @resume_token:	resume token for multiblock response
  @cnc:		Boolean change-notification control
  pnso_area must be allocated by the caller with get_zeroed_page(GFP_KERNEL)
  Returns 0 on success.
  ccw_device_get_cssid() - obtain Channel Subsystem ID
  @cdev: device to obtain the CSSID for
  @cssid: The resulting Channel Subsystem ID
  ccw_device_get_iid() - obtain MIF-image ID
  @cdev: device to obtain the MIF-image ID for
  @iid: The resulting MIF-image ID
  ccw_device_get_chpid() - obtain Channel Path ID
  @cdev: device to obtain the Channel Path ID for
  @chp_idx: Index of the channel path
  @chpid: The resulting Channel Path ID
  ccw_device_get_chid() - obtain Channel ID associated with specified CHPID
  @cdev: device to obtain the Channel ID for
  @chp_idx: Index of the channel path
  @chid: The resulting Channel ID
  Allocate zeroed dma coherent 31 bit addressable memory using
  the subchannels dma pool. Maximal size of allocation supported
  is PAGE_SIZE.
 SPDX-License-Identifier: GPL-2.0
  Physical device callbacks for vfio_ccw
  Copyright IBM Corp. 2017
  Copyright Red Hat, Inc. 2019
  Author(s): Dong Jia Shi <bjsdjshi@linux.vnet.ibm.com>
             Xiao Feng Ren <renxiaof@linux.vnet.ibm.com>
             Cornelia Huck <cohuck@redhat.com>
	
	  TODO:
	  In the cureent stage, some things like "no IO running" and "no
	  interrupt pending" are clear, but we are not sure what other state
	  we need to care about.
	  There are still a lot more instructions need to be handled. We
	  should come back here later.
	
	  Vendor drivers MUST unpin pages in response to an
	  invalidation.
 The state will be NOT_OPER on error. 
 The state will be NOT_OPER on error. 
 all other regions are handled via capability chain 
 Request removal of the device
 SPDX-License-Identifier: GPL-2.0
    S390 common IO routines -- channel subsystem call
     Copyright IBM Corp. 1999,2012
     Author(s): Ingo Adlung (adlung@de.ibm.com)
 		 Cornelia Huck (cornelia.huck@de.ibm.com)
 		 Arnd Bergmann (arndb@de.ibm.com)
 VF flag for Full Link Address 
 4 in RS field indicates CHPID 
  chsc_error_from_response() - convert a chsc response to an error
  @response: chsc response code
  Returns an appropriate Linux error code for @response.
 "Wrong Channel Parm" for the op 0x003d 
 "Channel busy" for the op 0x003d 
 "HW limit exceeded" for the op 0x003d 
 first subchannel 
 last subchannel 
 subchannel type 
 unit address 
 device number 
 subchannel 
 chpids 0-7 
 full link addresses 0-7 
 Check response. 
 Copy data 
  chsc_ssqd() - store subchannel QDIO data (SSQD)
  @schid: id of the subchannel on which SSQD is performed
  @ssqd: request and response block for SSQD
  Returns 0 on success.
  chsc_sadc() - set adapter device controls (SADC)
  @schid: id of the subchannel on which SADC is performed
  @scssc: request and response block for SADC
  @summary_indicator_addr: summary indicator address
  @subchannel_indicator_addr: subchannel indicator address
  @isc: Interruption Subclass for this subchannel
  Returns 0 on success.
 enable the time delay disablement facility 
 Wait until previous actions have settled. 
 Wait until previous actions have settled. 
	
	  IO resources may have become accessible.
	  Scan through all subchannels that may be concerned and
	  do a validation on those.
	  The more information we have (info), the less scanning
	  will we have to do.
 validity flags 
 reporting source 
 content code 
 full link address 
 reporting source id 
 ccdf has to be big enough for a link-incident record 
 content-code dependent field 
 p and v bit 
 content code 
 content-code dependent field 
 notification type mask 
  Link Incident Record as defined in SA22-7202, "ESCON IO Interface"
 PARAMS=xx,xxxxxx 
 NODEID=ttttttmdl,mmm.ppssssssssssss,xxxx 
 Copy EBCIDC text, convert to ASCII and optionally add delimiter. 
 Format node ID and parameters for output in LIR log message. 
 PARAMS=xx,xxxxxx 
 NODEID=ttttttmdl,mmm.ppssssssssssss,xxxx 
 Ignore NULL Link Incident Records. 
	 Inform user that a link requires maintenance actions because it has
	  become degraded or not operational. Note that this log message is
 allocate a new channel path structure, if needed 
 Ignore the event on unknowninvalid chp 
 which kind of information was stored? 
 link incident
 io resource accessibility 
 ap config changed 
 channel-path-availability information 
 channel-path-configuration notification 
 scm change notification 
 scm available notification 
 FCES event notification 
 other stuff 
 Check if we might have lost some information. 
 Fallback for old firmware. 
  Handle channel subsystem related CRWs.
  Use store event information to find out what's going on.
  Note: Access to sei_page is serialized through machine check handler
  thread, so no need for locking.
 Wait until previous actions have settled. 
  chsc_chp_vary - propagate channel-path vary operation to subchannels
  @chpid: channl-path ID
  @on: non-zero for vary online, zero for vary offline
	
	  Redo PathVerification on the devices the chpid connects to
 Try to update the channel path description. 
 No cmg-dependent data. 
  chsc_scm_info() - store SCM information (SSI)
  @scm_area: request and response block for SSI
  @token: continuation token
  Returns 0 on success.
  chsc_pnso() - Perform Network-Subchannel Operation
  @schid:		id of the subchannel on which PNSO is performed
  @pnso_area:		request and response block for the operation
  @oc:			Operation Code
  @resume_token:	resume token for multiblock response
  @cnc:		Boolean change-notification control
  pnso_area must be allocated by the caller with get_zeroed_page(GFP_KERNEL)
  Returns 0 on success.
 network-subchannel operation 
 operation data area begin 
 SCUD request block length 
 SCUD Command Code 
  chsc_scud() - Store control-unit description.
  @cu:		number of the control-unit
  @esm:	8 1-byte endpoint security mode values
  @esm_valid:	validity mask for @esm
  Interface to retrieve information about the endpoint security
  modes for up to 8 paths of a control unit.
  Returns 0 on success.
 SPDX-License-Identifier: GPL-2.0
    S390 common IO routines -- low level io calls
     Copyright IBM Corp. 1999, 2008
     Author(s): Ingo Adlung (adlung@de.ibm.com)
 		 Cornelia Huck (cornelia.huck@de.ibm.com)
 		 Arnd Bergmann (arndb@de.ibm.com)
 		 Martin Schwidefsky (schwidefsky@de.ibm.com)
  Function: cio_debug_init
  Initializes three debug logs for common IO:
  - cio_msg logs generic cio messages
  - cio_trace logs the calling of different functions
  - cio_crw logs machine check related cio messages
 subchannel structure 
 logical channel prog addr 
 logical path mask 
 storage key 
 sch is always under 2G. 
	
	  for 64 bit we always support 64 bit IDAWs with 4k page size only
 issue "Start Subchannel" 
 process condition code 
		
		  initialize device status information
 status pending 
 busy 
 devicepath not operational 
  resume suspended IO operation
		
		  useless to wait for request completion
		   as device is no longer operational !
  halt IO operation
	
	  Issue "Halt subchannel" and process condition code
 status pending 
 busy 
 device not operational 
  Clear IO operation
	
	  Issue "Clear subchannel" and process condition code
 device not operational 
  Function: cio_cancel
  Issues a "Cancel Subchannel" on the specified subchannel
  Note: We don't need any fancy intparms and flags here
 	 since xsch is executed synchronously.
  Only for common IO internal use as for now.
 success 
 Update information in scsw. 
 status pending 
 not applicable 
 not oper 
  cio_cancel_halt_clear - Cancel running IO by performing cancel, halt
  and clear ordinally if subchannel is valid.
  @sch: subchannel on which to perform the cancel_halt_clear operation
  @iretry: the number of the times remained to retry the next operation
  This should be called repeatedly since haltclear are asynchronous
  operations. We do one try with cio_cancel, three tries with cio_halt,
  255 tries with cio_clear. The caller should initialize @iretry with
  the value 255 for its first call to this, and keep using the same
  @iretry in the subsequent calls until it gets a non -EBUSY return.
  Returns 0 if device now idle, -ENODEV for device not operational,
  -EBUSY if an interrupt is expected (either from haltclear or from a
  status pending), and -EIO if out of retries.
 Not operational -> done. 
 Stage 1: cancel io. 
		
		  Cancel io unsuccessful or not applicable (transport mode).
		  Continue with asynchronous instructions.
 3 halt retries. 
 Stage 2: halt io. 
 Halt io unsuccessful. 
 255 clear retries. 
 Stage 3: clear io. 
 Function was unsuccessful 
  cio_commit_config - apply configuration to the subchannel
 copy desired changes to local schib 
 -EIO if msch gets a program check. 
 successful 
 commit changes from local schib 
 status pending 
 busy 
 allow for recovery 
 not operational 
  cio_update_schib - Perform stsch and update schib if subchannel is valid.
  @sch: subchannel on which to perform stsch
  Return zero on success, -ENODEV otherwise.
  cio_enable_subchannel - enable a subchannel.
  @sch: subchannel to be enabled
  @intparm: interruption parameter to set
		
		  Got a program check in msch. Try without
		  the concurrent sense bit the next time.
  cio_disable_subchannel - disable a subchannel.
  @sch: subchannel to disable
  do_cio_interrupt() handles all normal IO device IRQ's
 Clear pending interrupt condition. 
 Store interrupt response block to lowcore. 
 Keep subchannel information word up to date. 
 Call interrupt handler if there is one. 
  Use cio_tsch to update the subchannel status and call the interrupt handler
  if status had been pending. Called with the subchannel's lock held.
 Store interrupt response block to lowcore. 
 Not status pending or not operational. 
 Call interrupt handler with updated status. 
 found 
 VM provided us with the irq number of the console. 
 At least the console device number is known. 
 CONFIG_CCW_CONSOLE 
  cio_tm_start_key - perform start function
  @sch: subchannel on which to perform the start function
  @tcw: transport-command word to be started
  @lpm: mask of paths to use
  @key: storage key to use for storage access
  Start the tcw on the given subchannel. Return zero on success, non-zero
  otherwise.
  cio_tm_intrg - perform interrogate function
  @sch: subchannel on which to perform the interrogate function
  If the specified subchannel is running in transport-mode, perform the
  interrogate function. Return zero on success, non-zero otherwie.
 SPDX-License-Identifier: GPL-2.0
  qdio queue initialization
  Copyright IBM Corp. 2008
  Author(s): Jan Glauber <jang@linux.vnet.ibm.com>
  qdio_free_buffers() - free qdio buffers
  @buf: array of pointers to qdio buffers
  @count: number of qdio buffers to free
  qdio_alloc_buffers() - allocate qdio buffers
  @buf: array of pointers to qdio buffers
  @count: number of qdio buffers to allocate
  qdio_reset_buffers() - reset qdio buffers
  @buf: array of pointers to qdio buffers
  @count: number of qdio buffers that will be zeroed
 queue must be cleared for qdio_establish 
 fill in sbal 
 fill in slib 
 fill in sl 
  If there is a qdio_irq we use the chsc_page and store the information
  in the qdio_irq, otherwise we copy it to the specified structure.
 all flags set, worst case 
 size in words 
 fill input and output descriptors 
 qdr, qib, sls, slsbs, slibs, sbales are filled now 
 set our IRQ handler 
 get qdio commands 
 restore IRQ handler 
 Check for OSAFCP thin interrupts (bit 67). 
 Check for QEBSM support in general (bit 58). 
 SPDX-License-Identifier: GPL-2.0
   CCW device PGID and path verification IO handling.
     Copyright IBM Corp. 2002, 2009
     Author(s): Cornelia Huck <cornelia.huck@de.ibm.com>
 		 Martin Schwidefsky <schwidefsky@de.ibm.com>
 		 Peter Oberparleiter <peter.oberparleiter@de.ibm.com>
  Process path verification data and report result.
 Ensure consistent multipathing state at device and channel. 
  Create channel program to perform a NOOP.
  Perform NOOP on a single path.
  Adjust NOOP IO status.
 Only subchannel status might indicate a path error. 
  Process NOOP request result for a single path.
 Continue on the next path. 
  Create channel program to perform SET PGID on a single path.
 We don't know the path groups' state. Abort. 
	
	  Path groups have been reset. Restart path verification but
	  leave paths in path_noirq_mask out.
  Reset pathgroups and restart path verification, leave unusable paths out.
 Initialize request data. 
  Perform establishresign SET PGID on a single path.
 Use next available path that is not already in correct state. 
 Channel program setup. 
 At least one SPID could be partially done. 
  Process SET PGID request result for a single path.
 Try without multipathing. 
 Try without pathgrouping. 
 Initialize request data. 
  Determine pathgroup state from PGID data.
 Set bits for paths which are already in the target state. 
  Process SENSE PGID data and report result.
 Anything left to do? 
 Perform path-grouping. 
 Path-grouping not supported. 
  Create channel program to perform a SENSE PGID on a single path.
 Channel program setup. 
  Perform SENSE PGID on a single path.
  Process SENSE PGID request result for single path.
 Continue on the next path. 
  Perform path verification.
 Initialize PGID data. 
 Initialize request data. 
  ccw_device_verify_start - perform path verification
  @cdev: ccw device
  Perform an IO on each available channel path to @cdev to determine which
  paths are operational. The resulting path mask is stored in sch->vpm.
  If device options specify pathgrouping, establish a pathgroup for the
  operational paths. When finished, call ccw_device_verify_done with a
  return code specifying the result.
	
	  Initialize pathgroup and multipath state with target values.
	  They may change in the course of path verification.
  Process disband SET PGID request result.
 Ensure consistent multipathing state at device and channel. 
  ccw_device_disband_start - disband pathgroup
  @cdev: ccw device
  Execute a SET PGID channel program on @cdev to disband a previously
  established pathgroup. When finished, call ccw_device_disband_done with
  a return code specifying the result.
 Request setup. 
  ccw_device_stlck_start - perform unconditional release
  @cdev: ccw device
  @data: data pointer to be passed to ccw_device_stlck_done
  @buf1: data pointer used in channel program
  @buf2: data pointer used in channel program
  Execute a channel program on @cdev to release an existing PGID reservation.
 Request setup. 
  Perform unconditional reserve + release.
 Check if steal lock operation is valid for this device. 
 Perform operation. 
 Wait for operation to finish. 
 Got a signal. 
 Check results. 
 SPDX-License-Identifier: GPL-2.0
  Copyright IBM Corp. 2000, 2009
  Author(s): Utz Bacher <utz.bacher@de.ibm.com>
 	      Cornelia Huck <cornelia.huck@de.ibm.com>
 	      Jan Glauber <jang@linux.vnet.ibm.com>
  Restriction: only 63 iqdio subchannels would have its own indicator,
  after that, subsequent subchannels share one indicator
 device state change indicators 
 u32 because of compare-and-swap performance 
 use count, 0 or 1 for non-shared indicators 
 list of thin interrupt input queues 
 returns addr for the device state change indicator 
 use the shared indicator 
  tiqdio_thinint_handler - thin interrupt handler for qdio
  @airq: pointer to adapter interrupt descriptor
  @floating: flag to recognize floating vs. directed interrupts (unused)
 protect tiq_list entries, only changed in activate or shutdown 
 only process queues from changed sets 
 reset adapter interrupt indicators 
 SPDX-License-Identifier: GPL-1.0+
   bus driver for ccw devices
     Copyright IBM Corp. 2002, 2008
     Author(s): Arnd Bergmann (arndb@de.ibm.com)
 		 Cornelia Huck (cornelia.huck@de.ibm.com)
 		 Martin Schwidefsky (schwidefsky@de.ibm.com)
 HZ 
 bus type handling 
 The Linux driver model distinguishes between a bus type and
  the bus itself. Of course we only have one channel
  subsystem driver and one channel system per machine, but
 Store modalias string delimited by prefixsuffix string into buffer with
  specified size. Return length of resulting string (excluding trailing '\0')
 Set up environment variables for ccw device uevent. Return 0 on success,
 CU_TYPE= 
 CU_MODEL= 
 The next two can be zero, that's ok for us 
 DEV_TYPE= 
 DEV_MODEL= 
 MODALIAS=  
 end of list  },
 device handling 
 Undo device_add(). 
 Release reference from device_initialize(). 
  ccw_device_set_offline() - disable a ccw device for IO
  @cdev: target ccw device
  This function calls the driver's set_offline() function for @cdev, if
  given, and then disables @cdev.
  Returns:
    %0 on success and a negative error value on failure.
  Context:
   enabled, ccw device lock not held
 Wait until a final state or DISCONNECTED is reached 
 Inform the user if set offline failed. 
 Give up reference from ccw_device_set_online(). 
 Give up reference from ccw_device_set_online(). 
  ccw_device_set_online() - enable a ccw device for IO
  @cdev: target ccw device
  This function first enables @cdev and then calls the driver's set_online()
  function for @cdev, if given. If set_online() returns an error, @cdev is
  disabled again.
  Returns:
    %0 on success and a negative error value on failure.
  Context:
   enabled, ccw device lock not held
 Hold on to an extra reference while device is online. 
 Give up online reference since onlining failed. 
 Check if online processing was successful 
 Inform the user that set online failed. 
 Give up online reference since onlining failed. 
 Wait until a final state or DISCONNECTED is reached 
 Give up online reference since onlining failed. 
 Give up online reference since onlining failed. 
 Do device recognition, if needed. 
 recognition failed 
 Prevent conflict between multiple on-offline processing requests. 
 Prevent conflict between internal IOs and on-offline processing. 
 Prevent conflict between pending work and on-offline processing.
 All other states considered fine. 
  get_ccwdev_by_dev_id() - obtain device from a ccw device id
  @dev_id: id of the device to be searched
  This function searches all devices attached to the ccw bus for a device
  matching @dev_id.
  Returns:
   If a device is found its reference count is increased and returned;
   else %NULL is returned.
 Release reference of parent subchannel. 
 Do first half of device_register. 
 Release reference from device_initialize(). 
 Need to allocate a new ccw device. 
 OK, we did everything we could... 
 Start recognition for the new ccw device. 
  Register recognized device.
	
	  Check if subchannel is still registered. It may have become
	  unregistered if a machine check hit us after finishing
	  device recognition but before the register work could be
	  queued.
	
	  io_subchannel_register() will also be called after device
	  recognition has been done for a boxed device (which will already
	  be registered). We need to reprobe since we may now have sense id
	  information.
 We can't do much here. 
	
	  Now we know this subchannel will stay, we can throw
	  our delayed uevent.
 make it known to the system 
 Release initial device reference. 
  subchannel recognition done. Called from the state machine.
 Device did not respond in time. 
 Remove device found not operational. 
		
		  We can't register the device in interrupt context so
		  we schedule a work item.
 Increase counter of devices currently in recognition. 
 Start async. device sensing. 
 Obtain child reference for new parent. 
 Release child reference for new parent. 
 Try to reenable the old subchannel. 
 Release child reference for new parent. 
 Clean up old subchannel. 
 Release child reference for old parent. 
 Initialize new subchannel. 
  Note: We always return 0 so that we bind to the device even on error.
  This is needed so that our remove function is called on unregister.
		
		  The console subchannel already has an associated ccw_device.
		  Throw the delayed uevent for the subchannel, register
		  the ccw_device and exit.
 should always be the case for the console 
 Release online reference. 
 Allocate IO subchannel private data. 
 Check for IO on path. 
 Trigger path verification. 
 Forward Endpoint Security event 
	
	  We can't do our recovery in softirq context and it's not
	  performance critical, so we schedule it.
 Abort loop in case of pending signal. 
  ccw_purge_blacklisted - purge unused, blacklisted devices
  Unregister all ccw devices that are offline and on the blacklist.
 Not operational. 
 Operational. 
  io_subchannel_sch_event - process subchannel event
  @sch: subchannel
  @process: non-zero if function is called in process context
  An unspecified event occurred for this subchannel. Adjust data according
  to the current operational state of the subchannel and device. Return
  zero when the event has been handled sufficiently or -EAGAIN when this
  function should be called again in process context.
 Perform immediate actions while holding the lock. 
 Trigger device recognition. 
 Trigger path verification. 
			
			  Note: delayed work triggered by this event
			  and repeated calls to sch_event are synchronized
			  by the above check for work_pending(cdev).
 All other actions require process context. 
 Handle attached ccw device. 
 Move ccw device to orphanage. 
 Unregister ccw device. 
 Handle subchannel. 
 Release reference from get_ccwdev_by_dev_id() 
 Release reference from get_ccwdev_by_dev_id() 
	 Note: we interpret class 0 in this context as an uninitialized
 Now wait for the async. recognition to come to an end. 
 Hold on to an extra reference while device is online. 
 Give up online reference since onlining failed. 
  ccw_device_wait_idle() - busy wait for device to become idle
  @cdev: ccw device
  Poll until activity control is zero, that is, no function or data
  transfer is pendingactive.
  Called with device lock being held.
  get_ccwdev_by_busid() - obtain device from a bus id
  @cdrv: driver the device is owned by
  @bus_id: bus id of the device to be searched
  This function searches all devices owned by @cdrv for a device with a bus
  id matching @bus_id.
  Returns:
   If a match is found, its reference count of the found device is increased
   and it is returned; else %NULL is returned.
 device driver handling 
 This is the implementation of the ccw_driver class. The probe, remove
  and release methods are initially very similar to the device_driver
  implementations, with the difference that they have ccw_device
  arguments.
  A ccw driver also contains the information that is needed for
  device matching.
 to let the driver call _set_online 
 Give up reference obtained in ccw_device_set_online(). 
  ccw_driver_register() - register a ccw driver
  @cdriver: driver to be registered
  This function is mainly a wrapper around driver_register().
  Returns:
    %0 on success and a negative error value on failure.
  ccw_driver_unregister() - deregister a ccw driver
  @cdriver: driver to be deregistered
  This function is mainly a wrapper around driver_unregister().
 Find out todo. 
 Perform todo. 
 Release workqueue ref. 
  ccw_device_sched_todo - schedule ccw device operation
  @cdev: ccw device
  @todo: todo
  Schedule the operation identified by @todo to be performed on the slow path
  workqueue. Do nothing if another operation with higher priority is already
  scheduled. Needs to be called with ccwdev lock held.
 Get workqueue ref. 
 Already queued, release workqueue ref. 
  ccw_device_siosl() - initiate logging
  @cdev: ccw device
  This function is used to invoke model-dependent logging within the channel
  subsystem.
 SPDX-License-Identifier: GPL-2.0
     Copyright IBM Corp. 2002
     Author(s): Cornelia Huck (cornelia.huck@de.ibm.com)
 		 Martin Schwidefsky (schwidefsky@de.ibm.com)
  Status accumulation and basic sense functions.
  Check for any kind of channel or interface control check but don't
  issue the message for the console device
  Some paths became not operational (pno bit in scsw is set).
  Copy valid bits from the extended control word to device irb.
	
	  Copy extended control bit if it is valid... yes there
	  are condition that have to be met for the extended control
	  bit to have meaning. Sick.
 Check if extended control word is valid. 
 Copy concurrent sense  model dependent information. 
  Check if extended status word is valid.
  Copy valid bits from the extended status word to device irb.
 Copy last path used mask. 
 Copy subchannel logout information if esw is of format 0. 
 Copy extended status flags. 
		
		  Copy fields that have a meaning for channel data check
		  channel control check and interface control check.
 Copy ancillary report bit. 
 Copy field-validity-flags. 
 Copy storage access code. 
 Copy termination code. 
 Copy sequence code. 
 Copy device status check. 
 Copy secondary error. 
 Copy io-error alert. 
 Copy channel path timeout bit. 
 Copy failing storage address validity flag. 
 ... and copy the failing storage address. 
 ... and copy the failing storage address format. 
 Copy secondary ccw address validity bit. 
 ... and copy the secondary ccw address. 
 FIXME: DCTI for format 2? 
 Copy authorization bit. 
 Copy path verification required flag. 
 Copy concurrent sense bit. 
  Accumulate status from irb to devstat.
	
	  Check if the status pending bit is set in stctl.
	  If not, the remaining bit have no meaning and we must ignore them.
	  The esw is not meaningful as well...
 Check for channel checks and interface control checks. 
 Check for path not operational. 
 No irb accumulation for transport mode irbs. 
	
	  Don't accumulate unsolicited interrupts.
	
	  If the clear function had been performed, all formerly pending
	  status at the subchannel has been cleared and we must not pass
	  intermediate accumulated status to the device driver.
 Copy bits which are valid only for the start function. 
 Copy key. 
 Copy suspend control bit. 
 Accumulate deferred condition code. 
 Copy ccw format bit. 
 Copy prefetch bit. 
 Copy initial-status-interruption-control. 
 Copy address limit checking control. 
 Copy suppress suspend bit. 
 Take care of the extended control bit and extended control word. 
 Accumulate function control. 
 Copy activity control. 
 Accumulate status control. 
	
	  Copy ccw address if it is valid. This is a bit simplified
	  but should be close enough for all practical purposes.
 Accumulate device status, but not the device busy flag. 
 dstat is not always valid. 
 Accumulate subchannel status. 
 Copy residual count if it is valid. 
 Take care of bits in the extended status word. 
	
	  Check whether we must issue a SENSE CCW ourselves if there is no
	  concurrent sense facility installed for the subchannel.
	  No sense is required if no delayed sense is pending
	  and we did not get a unit check without sense information.
	 
	  Note: We should check for ioinfo[irq]->flags.consns but VM
	 	 violates the ESA390 architecture and doesn't present an
	 	 operand exception for virtual devices without concurrent
	 	 sense facility availablesupported when enabling the
	 	 concurrent sense facility.
  Do a basic sense.
 A sense is required, can we do it now ? 
		
		  we received an Unit Check but we have no final
		   status yet, therefore we must delay the SENSE
		   processing. We must not report this intermediate
		   status to the device interrupt handler.
	
	  We have ending status but no sense information. Do a basic sense.
  Add information from basic sense to devstat.
	
	  Check if the status pending bit is set in stctl.
	  If not, the remaining bit have no meaning and we must ignore them.
	  The esw is not meaningful as well...
 Check for channel checks and interface control checks. 
 Check for path not operational. 
 Check if path verification is required. 
  This function accumulates the status into the private devstat and
  starts a basic sense if one is needed.
 Check for basic sense. 
 SPDX-License-Identifier: GPL-2.0
    S390 common IO debugfs interface
     Copyright IBM Corp. 2021
     Author(s): Vineeth Vijayan <vneethv@linux.ibm.com>
 Create the debugfs directory for CIO under the arch_debugfs_dir
  i.e syskerneldebugs390cio
 SPDX-License-Identifier: GPL-2.0
     Support for adapter interruptions
     Copyright IBM Corp. 1999, 2007
     Author(s): Ingo Adlung <adlung@de.ibm.com>
 		 Cornelia Huck <cornelia.huck@de.ibm.com>
 		 Arnd Bergmann <arndb@de.ibm.com>
 		 Peter Oberparleiter <peter.oberparleiter@de.ibm.com>
  register_adapter_interrupt() - register adapter interrupt handler
  @airq: pointer to adapter interrupt descriptor
  Returns 0 on success, or -EINVAL.
  unregister_adapter_interrupt - unregister adapter interrupt handler
  @airq: pointer to adapter interrupt descriptor
  airq_iv_create - create an interrupt vector
  @bits: number of bits in the interrupt vector
  @flags: allocation flags
  Returns a pointer to an interrupt vector structure
  airq_iv_release - release an interrupt vector
  @iv: pointer to interrupt vector structure
  airq_iv_alloc - allocate irq bits from an interrupt vector
  @iv: pointer to an interrupt vector structure
  @num: number of consecutive irq bits to allocate
  Returns the bit number of the first irq in the allocated block of irqs,
  or -1UL if no bit is available or the AIRQ_IV_ALLOC flag has not been
  specified
 Found a suitable block of irqs 
  airq_iv_free - free irq bits of an interrupt vector
  @iv: pointer to interrupt vector structure
  @bit: number of the first irq bit to free
  @num: number of consecutive irq bits to free
 Clear (possibly left over) interrupt bit 
 Make the bit positions available again 
 Find new end of bit-field 
  airq_iv_scan - scan interrupt vector for non-zero bits
  @iv: pointer to interrupt vector structure
  @start: bit number to start the search
  @end: bit number to end the search
  Returns the bit number of the next non-zero interrupt bit, or
  -1UL if the scan completed without finding any more any non-zero bits.
 Find non-zero bit starting from 'ivs->next'. 
 SPDX-License-Identifier: GPL-2.0
   Handling of internal CCW device requests.
     Copyright IBM Corp. 2009, 2011
     Author(s): Peter Oberparleiter <peter.oberparleiter@de.ibm.com>
  lpm_adjust - adjust path mask
  @lpm: path mask to adjust
  @mask: mask of available paths
  Shift @lpm right until @lpm and @mask have at least one bit in common or
  until @lpm is zero. Return the resulting lpm.
  Adjust path mask to use next path and reset retry count. Return resulting
  path mask.
  Clean up device state and report to callback.
  (Re-)Start the operation until retries and paths are exhausted.
 Retries exhausted, try next path. 
 Perform start function. 
 IO started successfully. 
 Permanent device error. 
 Permant path error. 
 Temporary improper status. 
  ccw_request_start - perform IO request
  @cdev: ccw device
  Perform the IO request specified by cdev->req.
 Try all paths twice to counter link flapping. 
  ccw_request_cancel - cancel running IO request
  @cdev: ccw device
  Cancel the IO request specified by cdev->req. Return non-zero if request
  has already finished, zero otherwise.
  Return the status of the internal IO started on the specified ccw device.
  Perform BASIC SENSE if required.
 Perform BASIC SENSE if needed. 
 Check for haltclear interrupt. 
 Check for path error. 
 Handle BASIC SENSE data. 
 Check for command reject. 
 Ask the driver what to do 
 Assume that unexpected SENSE data implies an error. 
 Check for channel errors. 
 Check for device errors. 
 Check for final state. 
 Check for other improper status. 
  Log ccw request status.
  ccw_request_handler - interrupt handler for IO request procedure.
  @cdev: ccw device
  Handle interrupt during IO request procedure.
 Check status of IO request. 
 Check if request was cancelled on purpose. 
 Check back with request initiator. 
 Try next path and restart IO. 
 Restart. 
  ccw_request_timeout - timeout handler for IO request procedure
  @cdev: ccw device
  Handle timeout during IO request procedure.
 set the final return code for this request 
  ccw_request_notoper - notoper handler for IO request procedure
  @cdev: ccw device
  Handle notoper during IO request procedure.
 SPDX-License-Identifier: GPL-2.0
  channel program interfaces
  Copyright IBM Corp. 2017
  Author(s): Dong Jia Shi <bjsdjshi@linux.vnet.ibm.com>
             Xiao Feng Ren <renxiaof@linux.vnet.ibm.com>
 Starting guest physical IO address. 
 Array that stores PFNs of the pages need to pin. 
 Array that receives PFNs of the pages pinned. 
 Number of pages pinned from @pa_iova. 
 Guest physical address of the current chain. 
 Count of the valid ccws in chain. 
 Pinned PAGEs for the original data. 
  pfn_array_alloc() - alloc memory for PFNs
  @pa: pfn_array on which to perform the operation
  @iova: target guest physical address
  @len: number of bytes that should be pinned from @iova
  Attempt to allocate memory for PFNs.
  Usage of pfn_array:
  We expect (pa_nr == 0) and (pa_iova_pfn == NULL), any field in
  this structure will be filled in by this function.
  Returns:
          0 if PFNs are allocated
    -EINVAL if pa->pa_nr is not initially zero, or pa->pa_iova_pfn is not NULL
    -ENOMEM if alloc failed
  pfn_array_pin() - Pin user pages in memory
  @pa: pfn_array on which to perform the operation
  @mdev: the mediated device to perform pin operations
  Returns number of pages pinned upon success.
  If the pin request partially succeeds, or fails completely,
  all pages are left unpinned and a negative error value is returned.
 Unpin the pages before releasing the memory. 
 Only unpin if any pages were pinned to begin with 
 Create the list of IDAL words for a pfn_array. 
	
	  Idal words (execept the first one) rely on the memory being 4k
	  aligned. If a user virtual address is 4K aligned, then it's
	  corresponding kernel physical address will also be 4K aligned. Thus
	  there will be no problem here to simply use the phys to create an
	  idaw.
 Adjust the first IDAW, since it may not start on a page boundary 
  Within the domain (@mdev), copy @n bytes from a guest physical
  address (@iova) to a host physical address (@to).
  Helpers to operate ccwchain.
  ccw_does_data_transfer()
  Determine whether a CCW will move any data, such that the guest pages
  would need to be pinned before performing the IO.
  Returns 1 if yes, 0 if no.
 If the count field is zero, then no data will be transferred 
 If the command is a NOP, then no data will be transferred 
 If the skip flag is off, then data will be transferred 
	
	  If the skip flag is on, it is only meaningful if the command
	  code is a read, read backward, sense, or sense ID.  In those
	  cases, no data will be transferred.
 The skip flag is on, but it is ignored for this command code. 
  is_cpa_within_range()
  @cpa: channel program address being questioned
  @head: address of the beginning of a CCW chain
  @len: number of CCWs within the chain
  Determine whether the address of a CCW (whether a new chain,
  or the target of a TIC) falls within a range (including the end points).
  Returns 1 if yes, 0 if no.
 Make ccw address aligned to 8. 
 Free resource for a ccw that allocated memory for its cda. 
  ccwchain_calc_length - calculate the length of the ccw chain.
  @iova: guest physical address of the target ccw chain
  @cp: channel_program on which to perform the operation
  This is the chain length not considering any TICs.
  You need to do a new round for each TIC target.
  The program is also validated for absence of not yet supported
  indirect data addressing scenarios.
  Returns: the length of the ccw chain or -errno.
		
		  As we don't want to fail direct addressing even if the
		  orb specified one of the unsupported formats, we defer
		  checking for IDAWs in unsupported formats to here.
		
		  We want to keep counting if the current CCW has the
		  command-chaining flag enabled, or if it is a TIC CCW
		  that loops back into the current chain.  The latter
		  is used for device orientation, where the CCW PRIOR to
		  the TIC can either jump to the TIC or a CCW immediately
		  after the TIC, depending on the results of its operation.
 Copy 2K (the most we support today) of possible CCWs 
 Convert any Format-0 CCWs to Format-1 
 Count the CCWs in the current chain 
 Need alloc a new chain for this one. 
 Copy the actual CCWs into the new chain 
 Loop for tics on this new chain. 
 Loop for TICs. 
 May transfer to an existing chain. 
 Build a ccwchain for the next segment 
 Calculate size of IDAL 
 Read first IDAW to see if it's 4K-aligned or not. 
 All subsequent IDAws will be 4K-aligned. 
 Allocate an IDAL from host storage 
	
	  Allocate an array of pfn's for pages to pintranslate.
	  The number of pages is actually the count of the idaws
	  required for the data transfer, since we only only support
	  4K IDAWs today.
 Copy guest IDAL into host IDAL 
		
		  Copy guest IDAWs into pfn_array, in case the memory they
		  occupy is not contiguous.
		
		  No action is required here; the iova addresses in pfn_array
		  were initialized sequentially in pfn_array_alloc() beginning
		  with the contents of ccw->cda.
 Populate the IDAL with pinnedtranslated addresses from pfn 
  Fetch one ccw.
  To reduce memory copy, we'll pin the cda page in memory,
  and to get rid of the cda 2G limitiaion of ccw1, we'll translate
  direct ccws to idal ccws.
  cp_init() - allocate ccwchains for a channel program.
  @cp: channel_program on which to perform the operation
  @mdev: the mediated device to perform pinunpin operations
  @orb: control block for the channel program from the guest
  This creates one or more ccwchain(s), and copies the raw data of
  the target channel program from @orb->cmd.iova to the new ccwchain(s).
  Limitations:
  1. Supports idal(c64) ccw chaining.
  2. Supports 4k idaw.
  Returns:
    %0 on success and a negative error value on failure.
 custom ratelimit used to avoid flood during guest IPL 
 this is an error in the caller 
	
	  We only support prefetching the channel program. We assume all channel
	  programs executed by supported guests likewise support prefetching.
	  Executing a channel program that does not specify prefetching will
	  typically not cause an error, but a warning is issued to help identify
	  the problem if something does break.
 Build a ccwchain for the first CCW segment 
		 It is safe to force: if it was not set but idals used
		  ccwchain_calc_length would have returned an error.
  cp_free() - free resources for channel program.
  @cp: channel_program on which to perform the operation
  This unpins the memory pages and frees the memory space occupied by
  @cp, which must have been returned by a previous call to cp_init().
  Otherwise, undefined behavior occurs.
  cp_prefetch() - translate a guest physical address channel program to
                  a real-device runnable channel program.
  @cp: channel_program on which to perform the operation
  This function translates the guest-physical-address channel program
  and stores the result to ccwchain list. @cp must have been
  initialized by a previous call with cp_init(). Otherwise, undefined
  behavior occurs.
  For each chain composing the channel program:
  - On entry ch_len holds the count of CCWs to be translated.
  - On exit ch_len is adjusted to the count of successfully translated CCWs.
  This allows cp_free to find in ch_len the count of CCWs to free in a chain.
  The S390 CCW Translation APIS (prefixed by 'cp_') are introduced
  as helpers to do ccw chain translation inside the kernel. Basically
  they accept a channel program issued by a virtual machine, and
  translate the channel program to a real-device runnable channel
  program.
  These APIs will copy the ccws into kernel-space buffers, and update
  the guest phsical addresses with their corresponding host physical
  addresses.  Then channel IO device drivers could issue the
  translated channel program to real devices to perform an IO
  operation.
  These interfaces are designed to support translation only for
  channel programs, which are generated and formatted by a
  guest. Thus this will make it possible for things like VFIO to
  leverage the interfaces to passthrough a channel IO mediated
  device in QEMU.
  We support direct ccw chaining by translating them to idal ccws.
  Returns:
    %0 on success and a negative error value on failure.
 this is an error in the caller 
 Only cleanup the chain elements that were actually translated. 
  cp_get_orb() - get the orb of the channel program
  @cp: channel_program on which to perform the operation
  @intparm: new intparm for the returned orb
  @lpm: candidate value of the logical-path mask for the returned orb
  This function returns the address of the updated orb of the channel
  program. Channel IO device drivers could use this orb to issue a
  ssch.
 this is an error in the caller 
  cp_update_scsw() - update scsw for a channel program.
  @cp: channel_program on which to perform the operation
  @scsw: IO results of the channel program and also the target to be
         updated
  @scsw contains the IO results of the channel program that pointed
  to by @cp. However what @scsw->cpa stores is a host physical
  address, which is meaningless for the guest, which is waiting for
  the IO results.
  This function updates @scsw->cpa to its coressponding guest physical
  address.
	
	  LATER:
	  For now, only update the cmd.cpa part. We may need to deal with
	  other portions of the schib as well, even if we don't return them
	  in the ioctl directly. Path status changes etc.
		
		  On successful execution, cpa points just beyond the end
		  of the chain.
			
			  (cpa - ccw_head) is the offset value of the host
			  physical ccw to its chain head.
			  Adding this value to the guest physical ccw chain
			  head gets us the guest cpa.
  cp_iova_pinned() - check if an iova is pinned for a ccw chain.
  @cp: channel_program on which to perform the operation
  @iova: the iova to check
  If the @iova is currently pinned for the ccw chain, return true;
  else return false.
 SPDX-License-Identifier: GPL-2.0
  Tracepoint definitions for s390_cio
  Copyright IBM Corp. 2015
  Author(s): Peter Oberparleiter <oberpar@linux.vnet.ibm.com>
 SPDX-License-Identifier: GPL-2.0
  VFIO based Physical Subchannel device driver
  Copyright IBM Corp. 2017
  Copyright Red Hat, Inc. 2019
  Author(s): Dong Jia Shi <bjsdjshi@linux.vnet.ibm.com>
             Xiao Feng Ren <renxiaof@linux.vnet.ibm.com>
             Cornelia Huck <cohuck@redhat.com>
  Helpers
		
		  Flush all IO and wait for
		  cancelhaltclear completion.
	
	  Reset to IDLE only if processing of a channel program
	  has finished. Do not overwrite a possible processing
	  state if the final interrupt was for HSCH or CSCH.
  Css driver callbacks
  vfio_ccw_sch_event - process subchannel event
  @sch: subchannel
  @process: non-zero if function is called in process context
  An unspecified event occurred for this subchannel. Adjust data according
  to the current operational state of the subchannel. Return zero when the
  event has been handled sufficiently or -EAGAIN when this function should
  be called again in process context.
	
	  If unable to allocate a CRW, just drop the event and
	  carry on.  The guest will either see a later one or
	  learn when it issues its own store subchannel.
	
	  Build the CRW based on the inputs given to us.
 Path logically turned off 
 Path is gone 
 Path logically turned on 
 Path became available 
 end of list  },
 SPDX-License-Identifier: GPL-2.0
  Linux for s390 qdio support, buffer handling, qdio API and module support.
  Copyright IBM Corp. 2000, 2008
  Author(s): Utz Bacher <utz.bacher@de.ibm.com>
 	      Jan Glauber <jang@linux.vnet.ibm.com>
  2.6 cio integration by Cornelia Huck <cornelia.huck@de.ibm.com>
  do_siga_output - perform SIGA-wwt function
  @schid: subchannel id or in case of QEBSM the subchannel token
  @mask: which output queues to process
  @bb: busy bit indicator, set only if SIGA-wwt could not access a buffer
  @fc: function code to perform
  @aob: asynchronous operation block
  Returns condition code.
  Note: For IQDC unicast queues only the highest priority queue is processed.
  qdio_do_eqbs - extract buffer states for QEBSM
  @q: queue to manipulate
  @state: state of the extracted buffers
  @start: buffer number to start at
  @count: count of buffers to examine
  @auto_ack: automatically acknowledge buffers
  Returns the number of successfully extracted equal buffer states.
  Stops processing if a state is different from the last buffers state.
 all done, or next buffer state different 
 not all buffers processed 
 no buffer processed 
  qdio_do_sqbs - set buffer states for QEBSM
  @q: queue to manipulate
  @state: new state of the buffers
  @start: first buffer number to change
  @count: how many buffers to change
  Returns the number of successfully changed buffers.
  Does retrying until the specified count of buffer states is set or an
  error occurs.
 all done, or active buffer adapter-owned 
 not all buffers processed 
  Returns number of examined buffers and their common state in state.
  Requested number of buffers-to-examine must be > 0.
 get initial state: 
 Bail out early if there is no work on the queue: 
 stop if next state differs from initial state: 
 wrap-around safe setting of slsb states, returns number of changed buffers 
 Ensure that all preceding changes to the SBALs are visible: 
 Make our SLSB changes visible: 
 set slsb states to initial state 
 hipersocket busy condition 
 show the card that we are not polling anymore 
 special handling for no target buffer empty 
 ACK the newest SBAL: 
 We should never see this state, throw a WARN: 
 more work coming 
 the adapter got it 
 the adapter has not fetched the output yet 
 We should never see this state, throw a WARN: 
 PCI interrupt handler 
	
	  In case of zVM LGR (Live Guest Migration) QDIO recovery will happen.
	  Therefore we call the LGR detection function here.
 qdio interrupt handler 
  qdio_get_ssqd_desc - get qdio subchannel description
  @cdev: ccw device to get description for
  @data: where to store the ssqd
  Returns 0 or an error code. The results of the chsc are stored in the
  specified structure.
 default behaviour is halt 
  qdio_shutdown - shut down a qdio subchannel
  @cdev: associated ccw device
  @how: use halt or clear to shutdown
	
	  Subchannel was already shot down. We cannot prevent being called
	  twice since cio may trigger a shutdown asynchronously.
	
	  Indicate that the device is going down.
  qdio_free - free data structures for a qdio subchannel
  @cdev: associated ccw device
  qdio_allocate - allocate qdio queues and associated data
  @cdev: associated ccw device
  @no_input_qs: allocate this number of Input Queues
  @no_output_qs: allocate this number of Output Queues
 irq_ptr must be in GFP_DMA since it contains ccw1.cda 
	
	  Allocate a page for the chsc calls in qdio_establish.
	  Must be pre-allocated since a zfcp recovery will call
	  qdio_establish. In case of low memory and swap on a zfcp disk
	  we may not be able to allocate memory otherwise.
 qdr is used in ccw1.cda which is u32 
  qdio_establish - establish queues on a qdio subchannel
  @cdev: associated ccw device
  @init_data: initialization data
 establish q 
 qebsm is now setup if available, initialize buffer states 
  qdio_activate - activate queues on a qdio subchannel
  @cdev: associated cdev
 wait for subchannel to become active 
  handle_inbound - reset processed input buffers
  @q: queue containing the buffers
  @bufnr: first buffer to process
  @count: how many buffers are emptied
 If any processed SBALs are returned to HW, adjust our tracking: 
  handle_outbound - process filled outbound buffers
  @q: queue containing the buffers
  @bufnr: first buffer to process
  @count: how many buffers are filled
  @aob: asynchronous operation block
 The previous buffer is not processed yet, tack on. 
  do_QDIO - process input or output buffers
  @cdev: associated ccw_device for the qdio subchannel
  @callflags: input or output and special flags from the program
  @q_nr: queue number
  @bufnr: buffer number
  @count: how many buffers to process
  @aob: asynchronous operation block (outbound only)
  qdio_start_irq - enable interrupt processing for the device
  @cdev: associated ccw_device for the qdio subchannel
  Return codes
    0 - success
    1 - irqs not started since new data is available
	
	  We need to check again to not lose initiative after
	  resetting the ACK state.
 for the next time 
  qdio_stop_irq - disable interrupt processing for the device
  @cdev: associated ccw_device for the qdio subchannel
  Return codes
    0 - interrupts were already disabled
    1 - interrupts successfully disabled
 SPDX-License-Identifier: GPL-2.0
   Functions for incremental construction of fcx enabled IO control blocks.
     Copyright IBM Corp. 2008
     Author(s): Peter Oberparleiter <peter.oberparleiter@de.ibm.com>
  struct itcw - incremental tcw helper data type
  This structure serves as a handle for the incremental construction of a
  tcw and associated tccb, tsb, data tidaw-list plus an optional interrogate
  tcw and associated data. The data structures are contained inside a single
  contiguous buffer provided by the user.
  The itcw construction functions take care of overall data integrity:
  - reset unused fields to zero
  - fill in required pointers
  - ensure required alignment for data structures
  - prevent data structures to cross 4k-byte boundary where required
  - calculate tccb-related length fields
  - optionally provide ready-made interrogate tcw and associated structures
  Restrictions apply to the itcws created with these construction functions:
  - tida only supported for data address, not for tccb
  - only contiguous tidaw-lists (no ttic)
  - total number of bytes required per itcw may not exceed 4k bytes
  - either read or write operation (may not work with r=0 and w=0)
  Example:
  struct itcw itcw;
  void buffer;
  size_t size;
  size = itcw_calc_size(1, 2, 0);
  buffer = kmalloc(size, GFP_KERNEL | GFP_DMA);
  if (!buffer)
 	return -ENOMEM;
  itcw = itcw_init(buffer, size, ITCW_OP_READ, 1, 2, 0);
  if (IS_ERR(itcw))
 	return PTR_ER(itcw);
  itcw_add_dcw(itcw, 0x2, 0, NULL, 0, 72);
  itcw_add_tidaw(itcw, 0, 0x30000, 20);
  itcw_add_tidaw(itcw, 0, 0x40000, 52);
  itcw_finalize(itcw);
  itcw_get_tcw - return pointer to tcw associated with the itcw
  @itcw: address of the itcw
  Return pointer to the tcw associated with the itcw.
  itcw_calc_size - return the size of an itcw with the given parameters
  @intrg: if non-zero, add an interrogate tcw
  @max_tidaws: maximum number of tidaws to be used for data addressing or zero
  if no tida is to be used.
  @intrg_max_tidaws: maximum number of tidaws to be used for data addressing
  by the interrogate tcw, if specified
  Calculate and return the number of bytes required to hold an itcw with the
  given parameters and assuming tccbs with maximum size.
  Note that the resulting size also contains bytes needed for alignment
  padding as well as padding to ensure that data structures don't cross a
  4k-boundary where required.
 Main data. 
 TCW  sizeof(struct tcw) + 
 TSB  sizeof(struct tsb) +
 TIDAL  max_tidaws  sizeof(struct tidaw);
 Interrogate data. 
 TCW  sizeof(struct tcw) + 
 TSB  sizeof(struct tsb) +
 TIDAL  intrg_max_tidaws  sizeof(struct tidaw);
 Maximum required alignment padding. 
 Initial TCW  63 + 
	 TIDAW lists may not cross a 4k boundary. To cross a
	  boundary we need to add a TTIC TIDAW. We need to reserve
	  one additional TIDAW for a TTIC that we may need to add due
	  to the placement of the data chunk in memory, and a further
	  TIDAW for each page boundary that the TIDAW list may cross
	  due to it's own size.
  itcw_init - initialize incremental tcw data structure
  @buffer: address of buffer to use for data structures
  @size: number of bytes in buffer
  @op: %ITCW_OP_READ for a read operation tcw, %ITCW_OP_WRITE for a write
  operation tcw
  @intrg: if non-zero, add and initialize an interrogate tcw
  @max_tidaws: maximum number of tidaws to be used for data addressing or zero
  if no tida is to be used.
  @intrg_max_tidaws: maximum number of tidaws to be used for data addressing
  by the interrogate tcw, if specified
  Prepare the specified buffer to be used as an incremental tcw, i.e. a
  helper data structure that can be used to construct a valid tcw by
  successive calls to other helper functions. Note: the buffer needs to be
  located below the 2G address limit. The resulting tcw has the following
  restrictions:
   - no tccb tidal
   - inputoutput tidal is contiguous (no ttic)
   - total data should not exceed 4k
   - tcw specifies either read or write operation
  On success, return pointer to the resulting incremental tcw data structure,
  ERR_PTR otherwise.
 Check for 2G limit. 
 ITCW. 
 allow for TTIC tidaws that may be needed to cross a page boundary 
 Main TCW. 
 Interrogate TCW. 
 Data TIDAL. 
 Interrogate data TIDAL. 
 TSB. 
 Interrogate TSB. 
 TCCB. 
 Interrogate TCCB. 
  itcw_add_dcw - add a dcw to the itcw
  @itcw: address of the itcw
  @cmd: the dcw command
  @flags: flags for the dcw
  @cd: address of control data for this dcw or NULL if none is required
  @cd_count: number of control data bytes for this dcw
  @count: number of data bytes for this dcw
  Add a new dcw to the specified itcw by writing the dcw information specified
  by @cmd, @flags, @cd, @cd_count and @count to the tca of the tccb. Return
  a pointer to the newly added dcw on success or -%ENOSPC if the new dcw
  would exceed the available space.
  Note: the tcal field of the tccb header will be updated to reflect added
  content.
  itcw_add_tidaw - add a tidaw to the itcw
  @itcw: address of the itcw
  @flags: flags for the new tidaw
  @addr: address value for the new tidaw
  @count: count value for the new tidaw
  Add a new tidaw to the inputoutput data tidaw-list of the specified itcw
  (depending on the value of the r-flag and w-flag). Return a pointer to
  the new tidaw on success or -%ENOSPC if the new tidaw would exceed the
  available space.
  Note: TTIC tidaws are automatically added when needed, so explicitly calling
  this interface with the TTIC flag is not supported. The last-tidaw flag
  for the last tidaw in the list will be set by itcw_finalize.
	
	  Is the tidaw, which follows the one we are about to fill, on the next
	  page? Then we have to insert a TTIC tidaw first, that points to the
	  tidaw on the new page.
  itcw_set_data - set data address and tida flag of the itcw
  @itcw: address of the itcw
  @addr: the data address
  @use_tidal: zero of the data address specifies a contiguous block of data,
  non-zero if it specifies a list if tidaws.
  Set the inputoutput data address of the itcw (depending on the value of the
  r-flag and w-flag). If @use_tidal is non-zero, the corresponding tida flag
  is set as well.
  itcw_finalize - calculate length and count fields of the itcw
  @itcw: address of the itcw
  Calculate tcw input-output-count and tccbl fields and add a tcat the tccb.
  In case input- or output-tida is used, the tidaw-list must be stored in
  continuous storage (no ttic). The tcal field in the tccb must be
  up-to-date.
 SPDX-License-Identifier: GPL-2.0
  Driver for s390 eadm subchannels
  Copyright IBM Corp. 2012
  Author(s): Sebastian Ott <sebott@linux.vnet.ibm.com>
 status pending 
 busy 
 not operational 
 Handle start subchannel failure. 
  eadm_subchannel_sch_event - process subchannel event
  @sch: subchannel
  @process: non-zero if function is called in process context
  An unspecified event occurred for this subchannel. Adjust data according
  to the current operational state of the subchannel. Return zero when the
  event has been handled sufficiently or -EAGAIN when this function should
  be called again in process context.
 end of list  },
 SPDX-License-Identifier: GPL-2.0
     SCLP control program identification sysfs interface
     Copyright IBM Corp. 2001, 2007
     Author(s): Martin Peschke <mpeschke@de.ibm.com>
 		 Michael Ernst <mernst@de.ibm.com>
 setup SCCB for Control-Program Identification 
 set system type 
 set system name 
 set system level 
 set sysplex name 
 prepare request data structure presented to SCLP driver 
 Add request to sclp queue 
 SPDX-License-Identifier: GPL-2.0
     HMC Drive DVD Module
     Copyright IBM Corp. 2013
     Author(s): Ralf Hoppe (rhoppe@de.ibm.com)
  module parameter 'cachesize'
  hmcdrv_mod_init() - module init function
 perform wo cache 
  hmcdrv_mod_exit() - module exit function
 SPDX-License-Identifier: GPL-2.0
  driver: reading from and writing to system console on S390 via SCLP
  Copyright IBM Corp. 1999, 2009
  Author(s): Martin Peschke <mpeschke@de.ibm.com>
 	      Martin Schwidefsky <schwidefsky@de.ibm.com>
  The room for the SCCB (only for writing) is not equal to a pages size
  (as it is specified as the maximum size in the SCLP documentation)
  because of the additional data structure described above.
 Event type structure for write message and write priority message 
  Setup a sclp write buffer. Gets a page as input (4K) and returns
  a pointer to a struct sclp_buffer structure that is located at the
  end of the input page. This reduces the buffer space by a few
  bytes but simplifies things.
	
	  We keep the struct sclp_buffer structure at the end
	  of the sccb page.
 initialize sccb 
  Return a pointer to the original page that has been used to create
  the buffer.
  Initialize a new message the end of the provided buffer with
  enough room for max_len characters. Return 0 on success.
 max size of new message including message text  
 check if current buffer sccb can contain the mto 
 ebcdic "MDB " 
 message text object 
 end text 
 set pointer to first byte after struct mto. 
  Finalize message initialized by sclp_initialize_mto(),
  updating the sizes of MTO, enclosing MDB, event buffer and SCCB.
	
	  update values of sizes
	  (SCCB, Event(Message) Buffer, Message Data Block)
	
	  count number of buffered messages (= number of Message Text
	  Objects) and number of buffered characters
	  for the SCCB currently used for buffering and at all
  processing of a message including escape characters,
  returns number of characters written to the output sccb
  ("processed" means that is not guaranteed that the character have already
   been sent to the SCLP but that it will be done at least next time the SCLP
   is not busy)
	
	  parse msg for escape sequences (\t,\v ...) and put formated
	  msg into an mto (created by sclp_initialize_mto).
	 
	  We have to do this work ourselfs because there is no support for
	  these characters on the native machine and only partial support
	  under VM (Why does VM interpret \n but the native machine doesn't ?)
	 
	  Depending on io-control setting the message is always written
	  immediately or we wait for a final new line maybe coming with the
	  next message. Besides we avoid a buffer overrun by writing its
	  content.
	 
	  RESTRICTIONS:
	 
	  \r and \b work within one line because we are not able to modify
	  previous output that have already been accepted by the SCLP.
	 
	  \t combined with following \r is not correctly represented because
	  \t is expanded to some spaces but \r does not know about a
	  previous \t and decreases the current position by one column.
	  This is in order to a slim and quick implementation.
 new line, line feed (ASCII)	
 check if new mto needs to be created 
 bell, one for several times	
 set SCLP sound alarm bit in General Object 
 horizontal tabulator	 
 check if new mto needs to be created 
 "go to (next htab-boundary + 1, same line)" 
 ok, add a blank 
 form feed  
 vertical tabulator  
 "go to (actual column, actual line + 1)" 
 = new line, leading spaces 
 one an empty line this is the same as \n 
 backspace  
 "go to (actual column - 1, actual line)" 
 decrement counter indicating position, 
 do not remove last character 
 end of string  
 transfer current line to SCCB 
 skip the rest of the message including the 0 byte 
 no escape character	
 do not output unprintable characters 
 check if new mto needs to be created 
 check if current mto is full 
 return number of processed characters 
  Return the number of free bytes in the sccb
  Return number of characters in buffer
  called by sclp_console_init andor sclp_tty_init
  second half of Write Event Data-function that has to be done after
  interruption indicating completion of Service Call.
 check SCLP response code and choose suitable action	
 Normal completion, buffer processed, message(s) sent 
 Contained SCLP equipment check 
 remove processed buffers and requeue rest 
 not all buffers were processed 
 SCLP equipment check 
 Target resource in improper state 
 retry request 
  Setup the request structure in the struct sclp_buffer to do SCLP Write
  Event Data and pass the request to the core SCLP loop. Return zero on
  success, non-zero otherwise.
 add current line if there is one 
 Are there messages in the output buffer ? 
 SPDX-License-Identifier: GPL-2.0
  SCLP Store Data support and sysfs interface
  Copyright IBM Corp. 2017
  struct sclp_sd_data - Result of a Store Data request
  @esize_bytes: Resulting esize in bytes
  @dsize_bytes: Resulting dsize in bytes
  @data: Pointer to data - must be released using vfree()
  struct sclp_sd_listener - Listener for asynchronous Store Data response
  @list: For enqueueing this struct
  @id: Event ID of response to listen for
  @completion: Can be used to wait for response
  @evbuf: Contains the resulting Store Data response after completion
  struct sclp_sd_file - Sysfs representation of a Store Data entity
  @kobj: Kobject
  @data_attr: Attribute for accessing data contents
  @data_mutex: Mutex to serialize access and updates to @data
  @data: Data associated with this entity
  @di: DI value associated with this entity
  sclp_sd_listener_add() - Add listener for Store Data responses
  @listener: Listener to add
  sclp_sd_listener_remove() - Remove listener for Store Data responses
  @listener: Listener to remove
  sclp_sd_listener_init() - Initialize a Store Data response listener
  @listener: Response listener to initialize
  @id: Event ID to listen for
  Initialize a listener for asynchronous Store Data responses. This listener
  can afterwards be used to wait for a specific response and to retrieve
  the associated response data.
  sclp_sd_receiver() - Receiver for Store Data events
  @evbuf_hdr: Header of received events
  Process Store Data events and complete listeners with matching event IDs.
  sclp_sd_sync() - Perform Store Data request synchronously
  @page: Address of work page - must be below 2GB
  @eq: Input EQ value
  @di: Input DI value
  @sat: Input SAT value
  @sa: Input SA value used to specify the address of the target buffer
  @dsize_ptr: Optional pointer to input and output DSIZE value
  @esize_ptr: Optional pointer to output ESIZE value
  Perform Store Data request with specified parameters and wait for completion.
  Return %0 on success and store resulting DSIZE and ESIZE values in
  @dsize_ptr and @esize_ptr (if provided). Return non-zero on error.
 Prepare SCCB 
 Perform command 
 Evaluate response 
 Provide some information about what went wrong 
  sclp_sd_store_data() - Obtain data for specified Store Data entity
  @result: Resulting data
  @di: DI value associated with this entity
  Perform a series of Store Data requests to obtain the size and contents of
  the specified Store Data entity.
  Return:
    %0:       Success - result is stored in @result. @result->data must be
 	       released using vfree() after use.
    %-ENOENT: No data available for this entity
    %<0:      Other error
 Get size 
 Allocate memory 
 Get translation table for buffer 
 Get data 
 Cancel running request if interrupted 
  sclp_sd_data_reset() - Reset Store Data result buffer
  @data: Data buffer to reset
  Reset @data to initial state and release associated memory.
  sclp_sd_file_release() - Release function for sclp_sd_file object
  @kobj: Kobject embedded in sclp_sd_file object
  sclp_sd_file_update() - Update contents of sclp_sd_file object
  @sd_file: Object to update
  Obtain the current version of data associated with the Store Data entity
  @sd_file.
  On success, return %0 and generate a KOBJ_CHANGE event to indicate that the
  data may have changed. Return non-zero otherwise.
  sclp_sd_file_update_async() - Wrapper for asynchronous update call
  @data: Object to update
  @cookie: Unused
  reload_store() - Store function for "reload" sysfs attribute
  @kobj: Kobject of sclp_sd_file object
  @attr: Reload attribute
  @buf: Data written to sysfs attribute
  @count: Count of bytes written
  Initiate a reload of the data associated with an sclp_sd_file object.
  data_read() - Read function for "data" sysfs attribute
  @file: Open file pointer
  @kobj: Kobject of sclp_sd_file object
  @attr: Data attribute
  @buffer: Target buffer
  @off: Requested file offset
  @size: Requested number of bytes
  Store the requested portion of the Store Data entity contents into the
  specified buffer. Return the number of bytes stored on success, or %0
  on EOF.
  sclp_sd_file_create() - Add a sysfs file representing a Store Data entity
  @name: Name of file
  @di: DI value associated with this entity
  Create a sysfs directory with the given @name located under
    sysfirmwaresclp_sd
  The files in this directory can be used to access the contents of the Store
  Data entity associated with @DI.
  Return pointer to resulting sclp_sd_file object on success, %NULL otherwise.
  The object must be freed by calling kobject_put() on the embedded kobject
  pointer after use.
 Create kobject located under sysfirmwaresclp_sd 
	
	  For completeness only - users interested in entity data should listen
	  for KOBJ_CHANGE instead.
 Don't let a slow Store Data request delay further initialization 
  sclp_sd_init() - Initialize sclp_sd support and register sysfs files
 Create kset named "sclp_sd" located under sysfirmware 
 SPDX-License-Identifier: GPL-2.0
     SEHMC Drive (Read) Cache Functions
     Copyright IBM Corp. 2013
     Author(s): Ralf Hoppe (rhoppe@de.ibm.com)
 aging timeout in seconds 
  struct hmcdrv_cache_entry - file cache (only used on readdir)
  @id: FTP command ID
  @content: kernel-space buffer, 4k aligned
  @len: size of @content cache (0 if caching disabled)
  @ofs: start of content within file (-1 if no cached content)
  @fname: file name
  @fsize: file size
  @timeout: cache timeout in jiffies
  Notice that the first three members (id, fname, fsize) are cached on all
  readdir requests. But content is cached only under some preconditions.
  Uncached content is signalled by a negative value of @ofs.
 cache allocated page order 
  hmcdrv_cache_get() - looks for file datacontent in read cache
  @ftp: pointer to FTP command specification
  Return: number of bytes read from cache or a negative number if nothing
  in content cache (for the filecmd specified in @ftp)
 position in cache (signed) 
 EOF ? 
 has content? 
	 there seems to be cached content - calculate the maximum number
	  of bytes that can be returned (regarding file size and offset)
	 check if the requested chunk falls into our cache (which starts
	  at offset 'hmcdrv_cache_file.ofs' in the file of interest)
  hmcdrv_cache_do() - do a HMC drive CDDVD transfer with cache update
  @ftp: pointer to FTP command specification
  @func: FTP transfer function to be used
  Return: number of bytes readwritten or a (negative) error code
	 only cache content if the readdir cache really exists
	  (hmcdrv_cache_file.len > 0), is large enough to handle the
	  request (hmcdrv_cache_file.len >= ftp->len) and there is a need
	  to do so (ftp->len > 0)
		 because the cache is not located at ftp->buf, we have to
		  assemble a new HMC drive FTP cmd specification (pointing
		  to our cache, and using the increased size)
 make a copy 
 and update 
 buffer data 
 now do 
 invalidate content 
		 cache some file info (FTP command, file name and file
		  size) unconditionally
  hmcdrv_cache_cmd() - perform a cached HMC drive CDDVD transfer
  @ftp: pointer to FTP command specification
  @func: FTP transfer function to be used
  Attention: Notice that this function is not reentrant - so the caller
  must ensure exclusive execution.
  Return: number of bytes readwritten or a (negative) error code
 read cache 
 got it from cache ? 
 yes 
 simply do original command 
	 invalidate the (read) cache in case there was a write operation
	  or an error on readdir
  hmcdrv_cache_startup() - startup of HMC drive cache
  @cachesize: cache size
  Return: 0 on success, else a (negative) error code
 perform caching ? 
  hmcdrv_cache_shutdown() - shutdown of HMC drive cache
 no cache 
 SPDX-License-Identifier: GPL-2.0
  Copyright IBM Corp. 2004
  Tape class device support
  Author: Stefan Bader <shbader@de.ibm.com>
  Based on simple class device code by Greg K-H
  Register a tape device and return a pointer to the cdev structure.
  device
 	The pointer to the struct device of the physical (base) device.
  drivername
 	The pointer to the drivers name for it's character devices.
  dev
 	The intended majorminor number. The major number may be 0 to
 	get a dynamic major number.
  fops
 	The pointer to the drivers file operations for the tape device.
  devname
 	The pointer to the name of the character device.
 SPDX-License-Identifier: GPL-2.0
  core function to access sclp interface
  Copyright IBM Corp. 1999, 2009
  Author(s): Martin Peschke <mpeschke@de.ibm.com>
 	      Martin Schwidefsky <schwidefsky@de.ibm.com>
 Debug trace area intended for all entries in abbreviated form. 
 Error trace area intended for full entries relating to failed requests. 
 Lock to protect internal data consistency. 
 Mask of events that we can send to the sclp interface. 
 Mask of events that we can receive from the sclp interface. 
 List of registered event listeners and senders. 
 List of queued requests. 
 Data for read and and init requests. 
 Number of console pages to allocate, used by sclp_con.c and sclp_vt220.c 
 Flag to indicate if buffer pages are dropped on buffer full condition 
 Number of times the console dropped buffer pages 
 The currently active SCLP command word. 
 Minimize trace area usage by not tracing trailing zeroes. 
 Full SCCB tracing if debug level is set to max. 
 Minimal tracing for console writes. 
 Timer for request retries. 
 Timer for queued requests. 
 Internal state: is a request active at the sclp? 
 Internal state: is a read request pending? 
 Internal state: is the driver currently serving requests? 
 Internal state: is an init mask request pending? 
 Maximum retry counts 
 Timeout intervals in seconds.
 Add request to head of queue 
 Set up request retry timer. Called while sclp_lock is locked. 
 Request timeout handler. Restart the request queue. If force_restart,
 TMO: A timeout occurred (a=force_restart) 
			 Break running state and queue NOP read event request
  Returns the expire value in jiffies of the next pending request timeout,
  if any. Needs to be called with sclp_lock.
  Returns expired request, if any, and removes it from the list.
 Don't need list_for_each_safe because we break out after list_del 
  Timeout handler for queued requests. Removes request from list and
  invokes callback. This timer can be set per request in situations where
  waiting too long would be harmful to the system, e.g. during SE reboot.
 RQTM: Request timed out (a=sccb, b=summary) 
 SRV1: Service call about to be issued (a=command, b=sccb address) 
 SRV2: Service call was issued (a=rc, b=SRVC sequence number) 
 Try to start a request. Return zero if the request was successfully
  started or if it will be started at a later time. Return non-zero otherwise.
 Successfully started request 
 Try again later 
 Request failed 
 Try to start queued requests. 
 Request failed 
			 Cannot abort already submitted request - could still
 Post-processing for aborted request 
 RQAB: Request aborted (a=sccb, b=summary) 
 Queue a new request. Return zero on success, non-zero otherwise. 
 RQAD: Request was added (a=sccb, b=caller) 
 Start if request is first in list 
 Dispatch events found in request buffer to registered listeners. Return 0
 Check for malformed hardware response 
 Search for event handler 
 EVNT: Event callback (b=receiver) 
 Read event data request callback. 
 Prepare read event data request. Called while sclp_lock is locked. 
 Search request list for request with matching sccb. Return request if found,
 Check SCCB response. 
 Check event-processed flag on outgoing events. 
 Handler for external interruption. Perform request post-processing.
  Prepare read event data request if necessary. Start processing of next
 INT: Interrupt received (a=intparm, b=cmd) 
 Request post-processing 
 RQOK: Request success (a=sccb, b=summary) 
 UNEX: Unexpected SCCB completion (a=sccb address) 
 Convert interval in jiffies to TOD ticks. 
 Wait until a currently running request finished. Note: while this function
 SYN1: Synchronous wait start (a=runstate, b=sync count) 
	 We'll be disabling timer interrupts, so we need a custom timeout
 Get timeout TOD value 
 Prevent bottom half from executing once we force interrupts open 
 Enable service-signal interruption, disable timer interrupts 
 Loop until driver state indicates finished request 
 Check for expired request timer 
 SYN2: Synchronous wait end (a=runstate, b=sync_count) 
 Dispatch changes in send and receive mask to registered listeners. 
 STCG: State-change callback (b=callback) 
 variable length 
	
	  u8		sclp_receive_mask[mask_length];
	  u8		sclp_send_mask[mask_length];
	  u32		read_data_function_mask;
 State change event callback. Inform listeners of changes. 
 Calculate receive and send mask of currently registered listeners.
 Register event listener. Return 0 on success, non-zero otherwise. 
 REG: Event listener registered (b=caller) 
 Check event mask for collisions 
 Trigger initial state change callback 
 Unregister event listener. 
 UREG: Event listener unregistered (b=caller) 
 Remove event buffers which are marked processed. Return the number of
 Prepare init mask request. Called while sclp_lock is locked. 
 Start init mask request. If calculate is non-zero, calculate the mask as
  requested by registered listeners. Use zero mask otherwise. Return 0 on
 Check if interface is in appropriate state 
 Determine mask 
 Prepare request 
 Try again later 
 Successful request 
 Deactivate SCLP interface. On success, new requests will be rejected,
  events will no longer be dispatched. Return 0 on success, non-zero
 Deactivate can only be called when active 
 Reactivate SCLP interface after sclp_deactivate. On success, new
  requests will be accepted, events will be dispatched again. Return 0 on
 Reactivate can only be called when inactive 
 Handler for external interruption used during initialization. Modify
 Is this the interrupt we are waiting for? 
 Initial init mask request timed out. Modify request state to failed. 
 Perform a check of the SCLP interface. Return zero if the interface is
  available and there are no pending requests from a previous instance.
 Prepare init mask command 
		 Enable service-signal interruption - needs to happen
 Wait for signal from interrupt or timeout 
		 Disable service-signal interruption - needs to happen
 Reboot event handler. Reset send and receive mask to prevent pending SCLP
 Initialize SCLP driver. Return zero if driver is operational, non-zero
 Check for previous or running initialization 
 Set up variables 
 Check interface 
 Register reboot handler 
 Register interrupt handler 
	 Enable service-signal external interruption - needs to happen with
 SPDX-License-Identifier: GPL-2.0
     character device frontend for tape device driver
   S390 and zSeries version
     Copyright IBM Corp. 2001, 2006
     Author(s): Carsten Otte <cotte@de.ibm.com>
 		 Michael Holzheu <holzheu@de.ibm.com>
 		 Tuan Ngo-Anh <ngoanh@de.ibm.com>
 		 Martin Schwidefsky <schwidefsky@de.ibm.com>
 get dynamic major 
  file operation structure for tape character frontend
  This function is called for every new tapedevice
 The current idal buffer is not correct. Allocate a new one. 
  Tape device read function
	
	  If the tape isn't terminated yet, do it now. And since we then
	  are at the end of the tape there wouldn't be anything to read
	  anyways. So we return immediately.
 Find out block size to use 
 Let the discipline build the ccw chain. 
 Execute it. 
 Copy data from idal buffer to user space. 
  Tape device write function
 Find out block size and number of blocks 
 Let the discipline build the ccw chain. 
 Copy data from user space to idal buffer. 
		
		  Ok, the device has no more space. It has NOT written
		  the block.
	
	  After doing a write we always need two tapemarks to correctly
	  terminate the tape (one to terminate the file, the second to
	  flag the end of recorded data.
	  Since process_eov positions the tape in front of the written
	  tapemark it doesn't hurt to write two marks again.
  Character frontend tape device open function.
  Character frontend tape device release function.
	
	  If this is the rewinding tape minor then rewind. In that case we
	  write all required tapemarks. Otherwise only one to terminate the
	  file.
  Tape device io controls.
		
		  Operations that change tape position should write final
		  tapemarks.
 MTIOCPOS: query the tape position. 
 MTIOCGET: query the tape drive status. 
 device->devstat.rescnt ;
 FIXME: mt_gstat, mt_erreg, mt_fileno 
 Try the discipline ioctl function. 
 CONFIG_COMPAT 
  Initialize character device frontend.
  cleanup
 SPDX-License-Identifier: GPL-2.0
   Unified handling of special chars.
     Copyright IBM Corp. 2001
     Author(s): Fritz Elfert <felfert@millenux.com> <elfert@de.ibm.com>
  ctrlchar_handle - check for special chars at start of input
  @buf: console input buffer
  @len: length of valid data in buffer
  @tty: the tty struct for this console
  Return: CTRLCHAR_NONE, if nothing matched,
          CTRLCHAR_SYSRQ, if sysrq was encountered
          otherwise char to be inserted logically or'ed
          with CTRLCHAR_CTRL
 hat is 0xb1 in codepage 037 (US etc.) and thus 
 converted to 0x5e in ascii ('^') 
 racy 
 SPDX-License-Identifier: GPL-2.0
     SCLP OCF communication parameters sysfs interface
     Copyright IBM Corp. 2011
     Author(s): Martin Schwidefsky <schwidefsky@de.ibm.com>
 in EBCDIC 
 Handler for OCF event. Look for the CPC image name. 
 Find the 0x9f00 block. 
 Find the 0x9f22 block inside the 0x9f00 block. 
 Find the 0x81 block inside the 0x9f22 block. 
 Find the 0x01 block inside the 0x81 block. 
 Find the 0x02 block inside the 0x81 block. 
 Copy network name and cpc name. 
 SPDX-License-Identifier: GPL-2.0
     DIAGNOSE X'2C4' instruction based HMC FTP services, useable on zVM
     Copyright IBM Corp. 2013
     Author(s): Ralf Hoppe (rhoppe@de.ibm.com)
 DIAGNOSE X'2C4' return codes in Ry 
 HMC FTP started successfully 
 HMC FTP service currently busy 
 HMC FTP service IO error 
 and an artificial extension 
 HMC FTP service privilege error 
 FTP service status codes (after INTR at guest real location 133) 
 request completed successfully 
 program check condition 
 paging IO error 
 timeout 
 base of error codes from SCLP 
 failed 
 not allowed 
 runs 
 not runs 
  struct diag_ftp_ldfpl - load file FTP parameter list (LDFPL)
  @bufaddr: real buffer address (at 4k boundary)
  @buflen: length of buffer
  @offset: dirfile offset
  @intparm: interruption parameter (unused)
  @transferred: bytes transferred
  @fsize: file size, filled on GET
  @failaddr: failing address
  @spare: padding
  @fident: file name - ASCII
  diag_ftp_handler() - FTP services IRQ handler
  @extirq: external interrupt (sub-) code
  @param32: 32-bit interruption parameter from &struct diag_ftp_ldfpl
  @param64: unused (for 64-bit interrupt parameters)
 not a FTP services sub-code 
  diag_ftp_2c4() - DIAGNOSE X'2C4' service call
  @fpl: pointer to prepared LDFPL
  @cmd: FTP command to be executed
  Performs a DIAGNOSE X'2C4' call with (inputoutput) FTP parameter list
  @fpl and FTP function code @cmd. In case of an error the function does
  nothing and returns an (negative) error code.
  Notes:
  1. This function only initiates a transfer, so the caller must wait
     for completion (asynchronous execution).
  2. The FTP parameter list @fpl must be aligned to a double-word boundary.
  3. fpl->bufaddr must be a real address, 4k aligned
  diag_ftp_cmd() - executes a DIAG X'2C4' FTP command, targeting a HMC
  @ftp: pointer to FTP command specification
  @fsize: return of file size (or NULL if undesirable)
  Attention: Notice that this function is not reentrant - so the caller
  must ensure locking.
  Return: number of bytes readwritten or a (negative) error code
	
	  There is no way to cancel the running diag X'2C4', the code
	  needs to wait unconditionally until the transfer is complete.
 success 
 no such file or media 
  diag_ftp_startup() - startup of FTP services, when running on zVM
  Return: 0 on success, else an (negative) error code
  diag_ftp_shutdown() - shutdown of FTP services, when running on zVM
 SPDX-License-Identifier: GPL-2.0
     HMC Drive FTP Services
     Copyright IBM Corp. 2013
     Author(s): Ralf Hoppe (rhoppe@de.ibm.com)
  struct hmcdrv_ftp_ops - HMC drive FTP operations
  @startup: startup function
  @shutdown: shutdown function
  @transfer: FTP transfer function
 current operations 
 mutex for hmcdrv_ftp_funcs 
 startshutdown reference counter 
  hmcdrv_ftp_cmd_getid() - determine FTP command ID from a command string
  @cmd: FTP command string (NOT zero-terminated)
  @len: length of FTP command string in @cmd
 HMC FTP command descriptor 
 command string 
 associated command as enum 
	 Description of all HMC drive FTP commands
	 
	  Notes:
	  1. Array size should be a prime number.
	  2. Do not change the order of commands in table (because the
	     index is determined by CRC % ARRAY_SIZE).
	  3. Original command 'nlist' was renamed, else the CRC would
	     collide with 'append' (see point 2).
 [0] get (CRC = 0x68eb) 
 [1] dir (CRC = 0x6a9e) 
 [2] delete (CRC = 0x53ae) 
 [3] nls (CRC = 0xf87c) 
 [4] put (CRC = 0xac56) 
 [5] append (CRC = 0xf56e) 
 [6] unused 
 error indiactor 
  hmcdrv_ftp_parse() - HMC drive FTP command parser
  @cmd: FTP command string "<cmd> <filename>"
  @ftp: Pointer to FTP command specification buffer (output)
  Return: 0 on success, else a (negative) error code
 1st argument (FTP command) 
 2nd  last argument (rest of line) 
 switch 
 while 
  hmcdrv_ftp_do() - perform a HMC drive FTP, with data from kernel-space
  @ftp: pointer to FTP command specification
  Return: number of bytes readwritten or a negative error code
  hmcdrv_ftp_probe() - probe for the HMC drive FTP service
  Return: 0 if service is available, else an (negative) error code
 no such filemedia or currently busy, 
 but service seems to be available 
 leave 'rc' as it is for [0, -EPERM, -E...] 
 clear length (success) 
 switch 
  hmcdrv_ftp_cmd() - Perform a HMC drive FTP, with data from user-space
  @cmd: FTP command string "<cmd> <filename>"
  @offset: file position to readwrite
  @buf: user-space buffer for readwritten directoryfile
  @len: size of @buf (readdir) or number of bytes to write
  This function must not be called before hmcdrv_ftp_startup() was called.
  Return: number of bytes readwritten or a negative error code
  hmcdrv_ftp_startup() - startup of HMC drive FTP functionality for a
  dedicated (owner) instance
  Return: 0 on success, else an (negative) error code
 block transfers while start-up 
  hmcdrv_ftp_shutdown() - shutdown of HMC drive FTP functionality for a
  dedicated (owner) instance
 SPDX-License-Identifier: GPL-2.0
  Character device driver for writing zVM MONITOR service records.
  Copyright IBM Corp. 2006, 2009
  Author(s): Melissa Howland <Melissa.Howland@us.ibm.com>
  helper functions
 monhdr->mon_function is checked in monwrite_new_hdr 
  file operations
  module initexit
	
	  misc_register() has to be the last action in module_init(), because
	  file operations will be available right after this.
 SPDX-License-Identifier: GPL-2.0
     tape device discipline for 3590 tapes.
     Copyright IBM Corp. 2001, 2009
     Author(s): Stefan Bader <shbader@de.ibm.com>
 		 Michael Holzheu <holzheu@de.ibm.com>
 		 Martin Schwidefsky <schwidefsky@de.ibm.com>
 size of buffers for dynamic generated messages 
  Pointer to debug area.
  Error Recovery functions:
  - Read Opposite:		 implemented
  - Read Device (buffered) log: BRA
  - Read Library log:		 BRA
  - Swap Devices:		 BRA
  - Long Busy:			 implemented
  - Special Intercept:		 BRA
  - Read Alternate:		 implemented
  Query KEKLs
  IOCTL: Query KEKLs
  Set KEKLs
  IOCTL: Set KEKLs
  Enable encryption
  Disable encryption
  IOCTL: Set encryption status
  IOCTL: Query enryption status
  3590 IOCTL Overload
 no additional ioctls 
  SENSE Medium: Get Sense data about medium state
  MTTELL: Tell block. Return the number of block relative to current file.
  MTSEEK: seek to the specified block.
  Read Opposite Error Recovery Function:
  Used, when Read Forward does not work
	
	  We have allocated 4 ccws in tape_std_read, so we can now
	  transform the request to a read backward, followed by a
	  forward space block.
  Read Attention Msg
  This should be done after an interrupt with attention bit (0x80)
  in device state.
  After a "read attention message" request there are two possible
  results:
  1. A unit check is presented, when attention sense is present (e.g. when
  a medium has been unloaded). The attention sense comes then
  together with the unit check. The recovery action is either "retry"
  (in case there is an attention message pending) or "permanent error".
  2. The attention msg is written to the "read subsystem data" buffer.
  In this case we probably should print it to the console.
 read att msg 
  These functions are used to schedule follow-up actions from within an
  interrupt context (like unsolicited interrupts).
  Note: the work handler is called by the system work queue. The tape
  commands started by the handler need to be asynchrounous, otherwise
  a deadlock can occur e.g. in case of a deferred cc=1 (see __tape_do_irq).
  The done handler is called at devicechannel end and wakes up the sleeping
  process
 RBI seems to succeed even without medium loaded. 
 Same to NOP. 
  This function is called, when error recovery was successful
  This function is called, when error recovery was not successful
  Error Recovery do retry
  Handle unsolicited interrupts
 Probably result of halt ssch 
 Device Ready 
 check medium state 
  Basic Recovery routine
   RDL: Read Device (buffered) log
	
	  We just do the basic error recovery at the moment (retry).
	  Perhaps in the future, we read the log and dump it somewhere...
   SWAP: Swap Devices
	
	  This error recovery should swap the tapes
	  if the original has a problem. The operation
	  should proceed with the new tape... this
	  should probably be done in user space!
   LBY: Long Busy
   SPI: Special Intercept
   RDA: Read Alternate
	
	  The issued Read Backward or Read Previous command is not
	  supported by the device
	  The recovery action should be to issue another command:
	  Read Revious: if Read Backward is not supported
	  Read Backward: if Read Previous is not supported
  Error Recovery read opposite
		
		  We did read forward, but the data could not be read.
		  We will read backward and then skip forward again.
 We tried to read forward and backward, but hat no success 
  Print an MIM (Media Information  Message) (message code f0)
 Exception Message 
 Service Message 
  Print an IO Subsystem Service Information Message (message code f1)
 Exception Message 
 Service Message 
  Print an Device Subsystem Service Information Message (message code f2)
 Exception Message 
 Service Message 
  Print standard ERA Message
 Standard Media Information Message 
 Standard IO Subsystem Service Information Message 
 Standard Device Service Information Message 
 Standard Library Service Information Message 
 key not defined on EKM 
 No connection to EKM 
   3590 error Recovery routine:
   If possible, it tries to recover from the error. If this is not possible,
   inform the user about the problem.
	
	  First check all RC-QRCs where we want to do something special
	    - "break":     basic error recovery is done
	    - "goto out:": just print error message if available
		
		  print additional msg since default msg
		  "device intervention" is not very meaningfull
 Device Long Busy 
 XXX: Also use long busy handling here? 
 Swap 
 Read Opposite 
  3590 interrupt handler:
 Write at end of volume 
  Setup device function
 Try to find out if medium is loaded 
  Cleanup device function
  List of 3590 magnetic tape commands.
  Tape discipline structure for 3590.
 end of list  }
  Setup discipline structure.
 Register driver for 3590 tapes. 
 SPDX-License-Identifier: GPL-2.0
     tape device driver for S390 and zSeries tapes.
   S390 and zSeries version
     Copyright IBM Corp. 2001
     Author(s): Carsten Otte <cotte@de.ibm.com>
 		 Michael Holzheu <holzheu@de.ibm.com>
 		 Tuan Ngo-Anh <ngoanh@de.ibm.com>
  PROCFS Functions
 our proc tapedevices entry 
  Show function for proctapedevices
  Initialize procfs stuff on startup
  Cleanup all stuff registered to the procfs
 SPDX-License-Identifier: GPL-2.0
      signal quiesce handler
   Copyright IBM Corp. 1999, 2004
   Author(s): Martin Schwidefsky <schwidefsky@de.ibm.com>
              Peter Oberparleiter <peter.oberparleiter@de.ibm.com>
 Shutdown handler. Signal completion of shutdown by loading special PSW. 
 Handler for quiesce event. Start shutdown procedure. 
 Initialize quiesce driver. 
 SPDX-License-Identifier: GPL-2.0
  Copyright IBM Corp. 2007,2012
  Author(s): Heiko Carstens <heiko.carstens@de.ibm.com>,
 	      Peter Oberparleiter <peter.oberparleiter@de.ibm.com>
 Perform sclp request. 
 Check response. 
  CPU configuration related functions.
	
	  This is not going to cross a page boundary since we force
	  kmalloc to have a minimum alignment of 8 bytes on s390.
		
		  We do not allow to set memory blocks offline that contain
		  standby memory. This is done to simplify the "memory online"
		  case.
 No standby memory in kdump mode 
 CONFIG_MEMORY_HOTPLUG 
  Channel path configuration related functions.
 Prepare sccb. 
  sclp_chp_configure - perform configure channel-path sclp command
  @chpid: channel-path ID
  Perform configure channel-path command sclp command for specified chpid.
  Return 0 after command successfully finished, non-zero otherwise.
  sclp_chp_deconfigure - perform deconfigure channel-path sclp command
  @chpid: channel-path ID
  Perform deconfigure channel-path command sclp command for specified chpid
  and wait for completion. On success return 0. Return non-zero otherwise.
  sclp_chp_read_info - perform read channel-path information sclp command
  @info: resulting channel-path information data
  Perform read channel-path information sclp command and wait for completion.
  On success, store channel-path information in @info and return 0. Return
  non-zero otherwise.
 Prepare sccb. 
 SPDX-License-Identifier: GPL-1.0+
  zcore module to export memory content and register sets for creating system
  dumps on SCSINVMe disks (zfcpnvme dump).
  For more information please refer to Documentations390zfcpdump.rst
  Copyright IBM Corp. 2003, 2008
  Author(s): Michael Holzheu
  Copy memory from HSA to user memory (not reentrant):
  @dest:  User buffer where memory should be copied to
  @src:   Start address within HSA where data should be copied
  @count: Size of buffer, which should be copied
  Copy memory from HSA to kernel memory (not reentrant):
  @dest:  Kernel or user buffer where memory should be copied to
  @src:   Start address within HSA where data should be copied
  @count: Size of buffer, which should be copied
 get info for boot cpu from lowcore, stored in the HSA 
 vx registers are saved in smp.c 
  Release the HSA
  Provide IPL parameter information block from either HSA or memory
  for future reipl
 we need to be notified before reipl and kdump 
 we need to be notified before reipl and kdump 
 SPDX-License-Identifier: GPL-2.0
  SCLP line mode console driver
  Copyright IBM Corp. 1999, 2009
  Author(s): Martin Peschke <mpeschke@de.ibm.com>
 	      Martin Schwidefsky <schwidefsky@de.ibm.com>
 TTYAUX_MAJOR 
 Lock to guard over changes to global variables 
 List of free pages that can be used for console output buffering 
 List of full struct sclp_buffer structures ready for output 
 Pointer to current console buffer 
 Timer for delayed output of console messages 
 Flag that output queue is currently running 
 Output format for console messages 
 Remove buffer from outqueue 
 Check if there is a pending buffer on the out queue. 
  Finalize and emit first pending buffer.
  Wait until out queue is empty
  When this routine is called from the timer then we flush the
  temporary write buffer without further waiting on a final new line.
  Drop oldest console buffer if sclp_con_drop is set
 The first element is in IO 
  Writes the given message to S390 system console
	
	  process escape characters, write message into buffer,
	  send buffer to SCLP
 make sure we have a console output buffer 
 try to write the string to the current output buffer 
		
		  Not all characters could be written to the current
		  output buffer. Emit the buffer, create a new buffer
		  and then output the rest of the string.
 Setup timer to output current console buffer after 110 second 
  Make sure that all buffers will be flushed to the SCLP.
  used to register the SCLP console to the kernel and to
  give printk necessary information
 ttyS0 
  called by console_init() in driverschartty_io.c at boot-time.
 SCLP consoles are handled together 
 Allocate pages for output buffering 
 enable printk-access to this driver 
 SPDX-License-Identifier: GPL-2.0
     IBM3270 Driver - tty functions.
   Author(s):
     Original 3270 Code for 2.4 written by Richard Hitt (UTS Global)
     Rewritten for 2.5 by Martin Schwidefsky <schwidefsky@de.ibm.com>
 	-- Copyright IBM Corp. 2003
  The main tty view data structure.
  FIXME:
  1) describe line orientation & lines list concept against screen
  2) describe conversion of screen to lines
  3) describe line format.
 Array of pages used for freemem. 
 List of free memory for strings. 
 Output stuff. 
 List of lines. 
 List of lines to update. 
 Write control character. 
 # lines in list. 
 # lines up in history. 
 Update indication bits. 
 Lower right of display. 
 Single write request. 
 Output delay timer. 
 Current tty screen. 
 Current output position. 
 Blinkreverseunderscore 
 Foreground color 
 New model & size 
 Input stuff. 
 Output string for input area. 
 Input string for read request. 
 Single read request. 
 Single keyboard reset request. 
 Visibleinvisible input. 
 tty throttleunthrottle. 
 Tasklet to issue read request. 
 Tasklet to hang up the tty. 
 key_maps stuff. 
 Escape sequence parsing. 
 Command recalling. 
 List of recallable lines. 
 Point in rcl_lines list. 
 Numbermax number of rcl_lines. 
 Character array for put_charflush_chars. 
 tty3270->update_flags. See tty3270_update for details. 
 Use EWRITEA instead of WRITE. 
 Update lines in tty3270->update. 
 Update input line. 
 Update status line. 
 Recreate screen. 
  Setup timeout for a device. On timeout trigger an update.
  The input line are the two last lines of the screen.
 Clear to end of input line. 
 empty input string 
 Copy blueprint to status line 
 Set output offsets. 
 Allocate input string for reading. 
  The status line is the last line of the screen. It shows the string
  "Running""Holding" in the lower right corner of the screen.
 Copy blueprint to status line 
 Set address to start of status string (= last 9 characters). 
  Set output offsets to 3270 datastream fragment of a tty string.
  (TO_SBA offset at the start and TO_RA offset at the end of the string)
  Rebuild update list to print all lines.
	 
	  Throw away update list and create a new one,
	  containing all lines that will fit on the screen.
  Alloc string for size bytes. If there is not enough room in
  freemem, free strings until there is room.
  Add an empty line to the list.
  Create a blank screen and remove all lines from the history.
  Write request completion callback.
 Write wasn't successful. Refresh all. 
  Update 3270 display.
 Use erase write alternate to erase display. 
	
	  Update status line.
	
	  Write input line.
 Write strings in the update list to the screen. 
			
			  Skip TO_SBA at the start of the string if the
			  last output position matches the start address
			  of this line.
  Command recalling.
  Deactivate tty view.
  Scroll forward in history.
  Scroll backward in history.
  Pass input line to tty.
	
	  Two AID keys are special: For 0x7d (enter) the input line
	  has to be emitted to the tty and for 0x6d the screen
	  needs to be redrawn.
 Enter: write input to tty. 
 Clear input area. 
 Display has been cleared. Redraw. 
 Start keyboard reset command. 
 Emit keycode for AID byte. 
  Read request completion callback.
 Schedule tasklet to pass input to tty. 
  Issue a read request. Call with device lock.
 Read already scheduled. 
 Issue the read modified request. 
  Hang up the tty
  Switch to the tty view.
 Handle ATTN. Schedule tasklet to read aid. 
 Normal end. Copy residual count. 
 Interrupt without an outstanding request -> update all 
  Allocate tty3270 structure.
  Free tty3270 structure.
  Allocate tty3270 screen.
  Free tty3270 screen.
  Resize tty3270 screen
 Switch to new output size 
 Informat tty layer about new size 
  Unlink tty3270 data structure from tty.
  Free tty3270 data structure
  Delayed freeing of tty3270 views.
  This routine is called whenever a 3270 tty is opened first time.
 Check if the tty3270 is already there. 
 Allocate tty3270 structure on first open. 
 Create blank line for every line in the tty output area. 
  This routine is called whenever a 3270 tty is opened.
  This routine is called when the 3270 tty is closed. We wait
  for the remaining request to be completed. Then we clean up.
  We always have room.
  Insert character into the screen at the current position with the
  current color and highlight. This function does NOT do cursor movement.
  Convert a tty3270_line to a 3270 data fragment usable for output.
 Determine how long the fragment will be. 
 Prefix (TO_SBA). 
 TO_SA to switch highlight. 
 TO_SA to switch color. 
 TO_SA to reset hightlight. 
 TO_SA to reset color. 
 Postfix (TO_RA). 
 Find the line in the list. 
	
	  Check if the line needs to get reallocated.
 Reallocate string. 
 Write 3270 data fragment. 
 Line is currently visible on screen. 
 Add line to update list. 
  Do carriage return.
  Do line feed.
 Last line just filled up. Add new, blank line. 
  Insert characters at current position.
  Delete characters at current position.
  Erase characters at current position.
  Erase line, 3 different cases:
   Esc [ 0 K	Erase from current position to end of line inclusive
   Esc [ 1 K	Erase from beginning of line to current position inclusive
   Esc [ 2 K	Erase entire line (without moving cursor)
  Erase display, 3 different cases:
   Esc [ 0 J	Erase from current position to bottom of screen inclusive
   Esc [ 1 J	Erase from top of screen to current position inclusive
   Esc [ 2 J	Erase entire screen (without moving the cursor)
  Set attributes found in an escape sequence.
   Esc [ <attr> ; <attr> ; ... m
 Reset 
 Highlight. 
 Start underlining. 
 Start blink. 
 Start reverse. 
 End underlining 
 End blink. 
 End reverse. 
 Foreground color. 
 Black 
 Red 
 Green 
 Yellow 
 Blue 
 Magenta 
 Cyan 
 White 
 Black 
  Process escape sequences. Known sequences:
   Esc 7			Save Cursor Position
   Esc 8			Restore Cursor Position
   Esc [ Pn ; Pn ; .. m	Set attributes
   Esc [ Pn ; Pn H		Cursor Position
   Esc [ Pn ; Pn f		Cursor Position
   Esc [ Pn A			Cursor Up
   Esc [ Pn B			Cursor Down
   Esc [ Pn C			Cursor Forward
   Esc [ Pn D			Cursor Backward
   Esc [ Pn G			Cursor Horizontal Absolute
   Esc [ Pn X			Erase Characters
   Esc [ Ps J			Erase in Display
   Esc [ Ps K			Erase in Line
   FIXME: add all the new ones.
   Pn is a numeric parameter, a string of zero or more decimal digits.
   Ps is a selective parameter.
 Starting new escape sequence. 
 Respond ID. 
 Save cursor position. 
 Restore cursor position. 
 Reset terminal. 
 Status report. 
 Cursor report. 
 Set cursor position. 
 Set y position. 
 Cursor up. 
 Cursor down. 
 Cursor forward. 
 Cursor backward. 
 Set x position. 
 Erase Characters. 
 Erase display. 
 Erase line. 
 Delete characters. 
 Insert characters. 
 Save cursor position. 
 Restore cursor position. 
  String write routine for 3270 ttys
 Continue escape sequence. 
 '\a' -- Alarm 
 Backspace. 
 '\t' -- Tabulate 
 '\n' -- New Line 
 '\f' -- Form Feed 
 '\r' -- Carriage Return 
 SuSE "exit alternate mode" 
 Start escape sequence. 
 Insert normal character. 
 Convert current line to 3270 data fragment. 
 Setup timer to update display after 110 second 
  String write routine for 3270 ttys
  Put single characters to the ttys character buffer
  Flush all characters from the ttys characeter buffer put there
  by tty3270_put_char.
  Check for visibleinvisible input switches
  Disable reading from a 3270 tty
  Enable reading from a 3270 tty
  Hang up the tty device.
  3270 tty registration code called from tty_init().
  Most kernel services (incl. kmalloc) are available at this poimt.
	
	  Initialize the tty_driver structure
	  Entries in tty3270_driver that are NOT initialized:
	  proc_entry, set_termios, flush_buffer, set_ldisc, write_proc
 SPDX-License-Identifier: GPL-2.0
  s390 crypto adapter related sclp functions.
  Copyright IBM Corp. 2020
 SPDX-License-Identifier: GPL-2.0
  Copyright IBM Corp. 2004, 2010
  Interface implementation for communication with the zVM control program
  Author(s): Christian Borntraeger <borntraeger@de.ibm.com>
  zVMs CP offers the possibility to issue commands via the diagnose code 8
  this driver implements a character device that issues these commands and
  returns the answer of CP.
  The idea of this driver is based on cpint from Neale Ferguson and #CP in CMS
	
	  For anything below order 3 allocations rely on the buddy
	  allocator. If such low-order allocations can't be handled
	  anymore the system won't work anyway.
 reset the file pointer after a command 
  These ioctls are available, as the semantics of the diagnose 8 call
  does not fit very well into a Linux call. Diagnose X'08' is described in
  CP Programming Services SC24-6084-00
  VMCP_GETCODE: gives the CP return code back to user space
  VMCP_SETBUF: sets the response buffer for the next write call. diagnose 8
  expects adjacent pages in real storage and to make matters worse, we
  dont know the size of the response. Therefore we default to PAGESIZE and
  let userspace to change the response size, if userspace expects a bigger
  response
 SPDX-License-Identifier: GPL-2.0
     Copyright IBM Corp. 2015
     Author(s): Martin Schwidefsky <schwidefsky@de.ibm.com>
  Used to keep track of the size of the event masks. Qemu until version 2.11
  only supports 4 and needs a workaround.
 Output multi-line text using SCLP Message interface. 
 Output multi-line text using SCLP VT220 interface. 
  Output one or more lines of text on the SCLP console (VT220 and 
  or line-mode).
  We can't pass sclp_info_sccb to sclp_early_cmd() here directly,
  because it might not fulfil the requiremets for a SCLP communication buffer:
    - lie below 2G in memory
    - be page-aligned
  Therefore, we use the buffer sclp_early_sccb (which fulfils all those
  requirements) temporarily for communication and copy a received response
  back into the buffer sclp_info_sccb upon successful completion.
 SPDX-License-Identifier: GPL-2.0
  IBM3270 Driver - console view.
  Author(s):
    Original 3270 Code for 2.4 written by Richard Hitt (UTS Global)
    Rewritten for 2.5 by Martin Schwidefsky <schwidefsky@de.ibm.com>
      Copyright IBM Corp. 2003, 2009
  Main 3270 console view data structure.
 list of free memory for strings. 
 Output stuff. 
 list of lines. 
 list of lines to update. 
 line number for next update. 
 # lines in list. 
 # lines up in history. 
 Update indication bits. 
 current output line. 
 last line of display. 
 single write request. 
 Input stuff. 
 input string for read request. 
 single read request. 
 single keyboard reset request. 
 tasklet to issue read request. 
 con3270->update_flags. See con3270_update for details. 
 Use EWRITEA instead of WRITE. 
 Update lines in tty3270->update. 
 Update status line. 
 Recreate screen. 
  Setup timeout for a device. On timeout trigger an update.
  The status line is the last line of the screen. It shows the string
  "console view" in the lower left corner and "Running""More...""Holding"
  in the lower right corner of the screen.
 Copy blueprint to status line 
 Set TO_RA addresses. 
 Convert strings to ebcdic. 
  Set output offsets to 3270 datastream fragment of a console string.
		 This indicates a bug, but printing a warning would
  Rebuild update list to print all lines.
	 
	  Throw away update list and create a new one,
	  containing all lines that will fit on the screen.
  Alloc string for size bytes. Free strings from history if necessary.
  Write completion callback.
  Update console display.
 Use erase write alternate to initialize display. 
	
	  Update status line.
 Write strings in the update list to the screen. 
  Read tasklet.
 Check aid byte. 
 enter: jump to bottom. 
 PF3: deactivate the console view. 
 clear: start from scratch. 
 PF7: do a page up in the console log. 
 PF8: do a page down in the console log. 
 Start keyboard reset command. 
  Read request completion callback.
 Schedule tasklet to pass input to tty. 
  Issue a read request. Called only from interrupt function.
 Read already scheduled. 
 Issue the read modified request. 
  Switch to the console view.
 Handle ATTN. Schedule tasklet to read aid. 
 Normal end. Copy residual count. 
 Interrupt without an outstanding request -> update all 
 Console view to a 3270 device. 
 Already added. 
 Copy cline. 
 Replace cline with allocated line s and reset cline. 
  Write a string to the 3270 console
 Setup timer to output current console buffer after 110 second 
  Wait for end of write request.
  panic() calls con3270_flush through a panic_notifier
  before the system enters a disabled, endless loop.
   The console structure for the 3270 console
  3270 console initialization code called from console_init().
 Check if 3270 is to be the console 
 Set the console mode for VM 
 SPDX-License-Identifier: GPL-2.0
  SCLP "store data in absolute storage"
  Copyright IBM Corp. 2003, 2013
  Author(s): Michael Holzheu
  Called by SCLP base when read event data has been completed (async mode only)
  Called by SCLP base when sdias event has been accepted
 not initiated, wait some time and retry 
 initiated, wait for completion of service call 
 if not accepted, retry 
		
		  for the sync interface the response is in the initial sccb
 otherwise we wait for completion 
  Get number of blocks (4K) available in the HSA
  Copy from HSA to absolute storage (not reentrant):
  @dest     : Address of buffer where data should be copied
  @start_blk: Start Block (beginning with 1)
  @nr_blks  : Number of 4K blocks to copy
  Return Value: 0 : Requested 'number' of blocks of data copied
 		 <0: ERROR - negative event status
 SPDX-License-Identifier: GPL-2.0
  Linux driver for System z and s390 unit record devices
  (zVM virtual punch, reader, printer)
  Copyright IBM Corp. 2001, 2009
  Authors: Malcolm Beattie <beattiem@uk.ibm.com>
 	    Michael Holzheu <holzheu@de.ibm.com>
 	    Frank Munzert <munzert@de.ibm.com>
  Driver overview
  Unit record device support is implemented as a character device driver.
  We can fit at least 16 bits into a device minor number and use the
  simple method of mapping a character device number with minor abcd
  to the unit record device with devno abcd.
  IO to virtual unit record devices is handled as follows:
  Reads: Diagnose code 0x14 (input spool file manipulation)
  is used to read spool data page-wise.
  Writes: The CCW used is WRITE_CCW_CMD (0x01). The device's record length
  is available by reading sysfs attr reclen. Each write() to the device
  must specify an integral multiple (maximal 511) of reclen.
 We put the device's record length (for writes) in the driver_info field 
 end of list  }
  Allocation, freeing, getting and putting of urdev structures
  Each ur device (urd) contains a reference to its corresponding ccw device
  (cdev) using the urd->cdev pointer. Each ccw device has a reference to the
  ur device using dev_get_drvdata(&cdev->dev) pointer.
  urd references:
  - ur_probe gets a urd reference, ur_remove drops the reference
    dev_get_drvdata(&cdev->dev)
  - ur_open gets a urd reference, ur_release drops the reference
    (urf->urd)
  cdev references:
  - urdev_alloc get a cdev reference (urd->cdev)
  - urdev_free drops the cdev reference (urd->cdev)
  Setting and clearing of dev_get_drvdata(&cdev->dev) is protected by the ccwdev lock
  Low-level functions to do IO to a ur device.
      alloc_chan_prog
      free_chan_prog
      do_ur_io
      ur_int_handler
  alloc_chan_prog allocates and builds the channel program
  free_chan_prog frees memory of the channel program
  do_ur_io issues the channel program to the device and blocks waiting
  on a completion event it publishes at urd->io_done. The function
  serialises itself on the device's mutex so that only one IO
  is issued at a time (and that IO is synchronous).
  ur_int_handler catches the "IO done" interrupt, writes the
  subchannel status word into the scsw member of the urdev structure
  and complete()s the io_done to wake the waiting do_ur_io.
  The caller of do_ur_io is responsible for kfree()ing the channel program
  address pointer that alloc_chan_prog returned.
  alloc_chan_prog
  The channel program we use is write commands chained together
  with a final NOP CCW command-chained on (which ensures that CE and DE
  are presented together in a single interrupt instead of as separate
  interrupts unless an incorrect length indication kicks in first). The
  data length in each CCW is reclen.
	
	  We chain a NOP onto the writes to force CE+DE together.
	  That means we allocate room for CCWs to cover countreclen
	  records plus a NOP.
 The following NOP CCW forces CE+DE to be presented together 
  ur interrupt handler, called from the ccw_device layer
 On special conditions irb is an error pointer 
  reclen sysfs attribute - The record length to be used for write CCWs
  diagnose code 0x210 - retrieve device information
  cc=0  normal completion, we have a real device
  cc=1  CP paging error
  cc=2  The virtual device exists, but is not associated with a real device
  cc=3  Invalid device address, or the virtual device does not exist
 virtual device class 
  Allocation and freeing of urfile structures
  The fops implementation of the character device driver
 count must be a multiple of reclen 
  diagnose code 0x14 subcode 0x0028 - position spool file to designated
 				       record
  cc=0  normal completion
  cc=2  no file active on the virtual reader or device not ready
  cc=3  record specified is beyond EOF
 position beyond end of file 
  diagnose code 0x14 subcode 0x0000 - read next spool file buffer
  cc=0  normal completion
  cc=1  EOF reached
  cc=2  no file active on the virtual reader, and no file eligible
  cc=3  file already active on the virtual reader or specified virtual
 	 reader does not exist or is not a reader
  diagnose code 0x14 subcode 0x0fff - retrieve next file descriptor
  cc=0  normal completion
  cc=1  no files on reader queue or no subsequent file
  cc=2  spid specified is invalid
 check for empty reader device (beginning of chain) 
 if file is in hold status, we do not read it 
 open file on virtual reader	
 EOF does not hurt 
 check if the file on top of the queue is open now 
 no check needed here 
	
	  We treat the minor number as the devno of the ur device
	  to find in the driver tree.
 seek allowed only for reader 
 only multiples of 4K allowed 
  ccw_device infrastructure:
      ur_probe creates the struct urdev (with refcount = 1), the device
      attributes, sets up the interrupt handler and validates the virtual
      unit record device.
      ur_remove removes the device attributes and drops the reference to
      struct urdev.
      ur_probe, ur_remove, ur_set_online and ur_set_offline are serialized
      by the vmur_mutex lock.
      urd->char_device is used as indication that the online function has
      been completed successfully.
 validate virtual unit record device 
 ur_remove already deleted our urd 
 Another ur_set_online was faster 
 ur_remove already deleted our urd 
 Another ur_set_offline was faster 
 There is still a user of urd (e.g. ur_open) 
  Module initialisation and cleanup
 SPDX-License-Identifier: GPL-2.0
     standard tape device functions for ibm tapes.
   S390 and zSeries version
     Copyright IBM Corp. 2001, 2002
     Author(s): Carsten Otte <cotte@de.ibm.com>
 		 Michael Holzheu <holzheu@de.ibm.com>
 		 Tuan Ngo-Anh <ngoanh@de.ibm.com>
 		 Martin Schwidefsky <schwidefsky@de.ibm.com>
 		 Stefan Bader <shbader@de.ibm.com>
  tape_std_assign
	
	  The assign command sometimes blocks if the device is assigned
	  to another host (actually this shouldn't happen but it does).
	  So we set up a timeout for this call.
  tape_std_unassign
  TAPE390_DISPLAY: Show a string on the tape display.
  Read block id.
 setup ccws 
 execute it 
 Get result from read buffer. 
  MTLOAD: Loads the tape.
  The default implementation just wait until the tape medium state changes
  to MS_LOADED.
  MTSETBLK: Set block size.
		
		  Just set block_size to 0. tapechar_readtapechar_write
		  will realloc the idal buffer if a bigger one than the
		  current is needed.
 We already have a idal buffer of that size. 
 Allocate a new idal buffer. 
  MTRESET: Set block size to 0.
  MTFSF: Forward space over 'count' file marks. The tape is positioned
  at the EOT (End of Tape) side of the file mark.
 setup ccws 
 execute it 
  MTFSR: Forward space over 'count' tape blocks (blocksize is set
  via MTSETBLK.
 setup ccws 
 execute it 
  MTBSR: Backward space over 'count' tape blocks.
  (blocksize is set via MTSETBLK.
 setup ccws 
 execute it 
  MTWEOF: Write 'count' file marks at the current position.
 setup ccws 
 execute it 
  MTBSFM: Backward space over 'count' file marks.
  The tape is positioned at the BOT (Begin Of Tape) side of the
  last skipped file mark.
 setup ccws 
 execute it 
  MTBSF: Backward space over 'count' file marks. The tape is positioned at
  the EOT (End of Tape) side of the last skipped file mark.
 setup ccws 
 execute it 
  MTFSFM: Forward space over 'count' file marks.
  The tape is positioned at the BOT (Begin Of Tape) side
  of the last skipped file mark.
 setup ccws 
 execute it 
  MTREW: Rewind the tape.
 setup ccws 
 execute it 
  MTOFFL: Rewind the tape and put the drive off-line.
  Implement 'rewind unload'
 setup ccws 
 execute it 
  MTNOP: 'No operation'.
 setup ccws 
 execute it 
  MTEOM: positions at the end of the portion of the tape already used
  for recordind data. MTEOM positions after the last file mark, ready for
  appending another file.
	
	  Seek from the beginning of tape (rewind).
	
	  The logical end of volume is given by two sewuential tapemarks.
	  Look for this by skipping to the next file (over one tapemark)
	  and then test for another one (fsr returns 1 if a tapemark was
	  encountered).
  MTRETEN: Retension the tape, i.e. forward space to end of tape and rewind.
 setup ccws 
 execute it, MTRETEN rc gets ignored 
  MTERASE: erases the tape.
 setup ccws 
 execute it 
  MTUNLOAD: Rewind the tape and unload it.
  MTCOMPRESSION: used to enable compression.
  Sets the IDRC onoff.
 setup ccws 
 execute it 
  Read Block
	
	  We have to alloc 4 ccws in order to be able to transform request
	  into a read backward request in error case.
  Read Block backward transformation function.
	
	  We have allocated 4 ccws in tape_std_read, so we can now
	  transform the request to a read backward, followed by a
	  forward space block.
  Write Block
  This routine is called by frontend after an ENOSP on write
	
	  End of volume: We have to backspace the last written record, then
	  we TRY to write a tapemark and then backspace over the written TM
 SPDX-License-Identifier: GPL-2.0
     tape device discipline for 34803490 tapes.
     Copyright IBM Corp. 2001, 2009
     Author(s): Carsten Otte <cotte@de.ibm.com>
 		 Tuan Ngo-Anh <ngoanh@de.ibm.com>
 		 Martin Schwidefsky <schwidefsky@de.ibm.com>
  Pointer to debug area.
  A list of block ID's is used to faster seek blocks.
  Medium sense for 34xx tapes. There is no 'real' medium sense call.
  So we just do a normal sense.
		
		  This isn't quite correct. But since INTERVENTION_REQUIRED
		  means that the drive is 'neither ready nor on-line' it is
		  only slightly inaccurate to say there is no tape loaded if
		  the drive isn't online...
  These functions are currently used only to schedule a medium_sense for
  later execution. This is because we get an interrupt whenever a medium
  is inserted but cannot call tape_do_io from an interrupt context.
  Maybe that's useful for other actions we want to start from the
  interrupt handler.
  Note: the work handler is called by the system work queue. The tape
  commands started by the handler need to be asynchrounous, otherwise
  a deadlock can occur e.g. in case of a deferred cc=1 (see __tape_do_irq).
  Done Handler is called when dev stat = DEVICE-END (successful operation)
  This function is called, when no request is outstanding and we get an
  interrupt
 READY 
 A medium was inserted in the drive. 
  Read Opposite Error Recovery Function:
  Used, when Read Forward does not work
		
		  We did read forward, but the data could not be read
		  correctly. We transform the request to a read backward
		  and try again.
	
	  We tried to read forward and backward, but hat no
	  success -> failed.
  Handle data overrun between cu and drive. The channel speed might
  be too slow.
  Handle record sequence error.
		
		  cu detected incorrect block-id sequence on tape.
	
	  Record sequence error bit is set, but erpa does not
	  show record sequence error.
  This function analyses the tape's sense-data in case of a unit-check.
  If possible, it tries to recover from the error. Else the user is
  informed about the problem.
 medium is write protected 
	
	  Special cases for various tape-states when reaching
	  end of recorded area
	 
	  FIXME: Maybe a special case of the special case:
	         sense[0] == SENSE_EQUIPMENT_CHECK &&
	         sense[1] == SENSE_DRIVE_ONLINE    &&
	         sense[3] == 0x47 (Volume Fenced)
	 
	         This was caused by continued FSF or FSR after an
	         'End Of Data'.
		
		  sense[0] == SENSE_DATA_CHECK   &&
		  sense[1] == SENSE_DRIVE_ONLINE
		  sense[3] == 0x36 (End Of Data)
		 
		  Further seeks might return a 'Volume Fenced'.
 Trying to seek beyond end of recorded area 
		
		  sense[0] == SENSE_DATA_CHECK   &&
		  sense[1] == SENSE_DRIVE_ONLINE &&
		  sense[3] == 0x36 (End Of Data)
 Block could not be located. 
 Read beyond end of recorded area -> 0 bytes read 
		
		  sense[0] == SENSE_EQUIPMENT_CHECK &&
		  sense[1] == SENSE_DRIVE_ONLINE    &&
		  sense[3] == 0x38 (Physical End Of Volume)
 Writing at physical end of volume 
 Sensing special bits 
		
		  hardware failure, damaged tape or improper
		  operating conditions
 a read data check occurred 
 data check is not permanent, may be
 recovered. We always use async-mode with
 cu-recovery, so this should never happen.
 data check is permanent, CU recovery has failed 
 a write data check occurred
 data check is not permanent, may be
 recovered. We always use async-mode with
 cu-recovery, so this should never happen.
 data check is permanent, cu-recovery has failed
 Data Check (read opposite) occurred. 
 ID-Mark at tape start couldn't be written 
 Tape void. Tried to read beyond end of device. 
 Record sequence error. 
			 all data checks for 3480 should result in one of
			  the above erpa-codes. For 3490, other data-check
 Sensing erpa codes 
 Unit check with erpa code 0. Report and ignore. 
		
		  Data streaming not operational. CU will switch to
		  interlock mode. Reissue the command.
		
		  Path equipment check. Might be drive adapter error, buffer
		  error on the lower interface, internal path not usable,
		  or error during cartridge load.
		
		  Load display check. Load display was command was issued,
		  but the drive is displaying a drive check message. Can
		  be threated as "device end".
		
		  Command reject. May indicate illegal channel program or
		  buffer overunderrun. Since all channel programs are
		  issued by this driver and ought be correct, we assume a
		  overunderrun situation and retry the channel program.
		
		  Function incompatible. Either the tape is idrc compressed
		  but the hardware isn't capable to do idrc, or a perform
		  subsystem func is issued and the CU is not on-line.
		
		  Unsolicited environmental data. An internal counter
		  overflows, we can ignore this and reissue the cmd.
		
		  Environmental data present. Indicates either unload
		  completed ok or read buffered log command completed ok.
 Rewind unload completed ok. 
 tape_34xx doesn't use read buffered log commands. 
		
		  Permanent equipment check. CU has tried recovery, but
		  did not succeed.
 Data security erase failure. 
 Data security erase failure, but no such command issued. 
		
		  Not capable. This indicates either that the drive fails
		  reading the format id mark or that that format specified
		  is not supported by the drive.
 The medium is write protected. 
 Tension loss. We cannot recover this, it's an IO error.
		
		  Load Failure. The cartridge was not inserted correctly or
		  the tape is not threaded correctly.
		
		  Unload failure. The drive cannot maintain tape tension
		  and control tape movement during an unload operation.
		
		  Drive equipment check. One of the following:
		  - cu cannot recover from a drive detected error
		  - a check code message is shown on drive display
		  - the cartridge loader does not respond correctly
		  - a failure occurs during an index, load, or unload cycle
 End of data. 
 This erpa is reserved for 3480 
		
		  Tape length error. The tape is shorter than reported in
		  the beginning-of-tape data.
		
		  Physical end of tape. A readwrite operation reached
		  the physical end of tape.
 Backward at Beginning of tape. 
 Drive switched to not ready. 
 Manual rewind or unload. This causes an IO error. 
		
		  Degraded mode. A condition that can cause degraded
		  performance is detected.
 Drive not ready. 
 Some commands commands are successful even in this case 
 Locate Block unsuccessful. 
 No locate block was issued. 
 The drive is assigned to a different channel path. 
		
		  Drive not on-line. Drive may be switched offline,
		  the power supply may be switched off or
		  the drive address may not be set correctly.
 Volume fenced. CU reports volume integrity is lost. 
 Log sense data and retry request. 
 Bus out check. A parity check error on the bus was found. 
 Control unit erp failed. 
		
		  CU and drive incompatible. The drive requests micro-program
		  patches, which are not available on the CU.
		
		  Recovered Check-One failure. Cu develops a hardware error,
		  but is able to recover.
			
			  Resetting event received. Since the driver does
			  not support resetting event recovery (which has to
			  be handled by the IO Layer), retry our command.
 This erpa is reserved for 3480. 
			
			  Maximum block size exceeded. This indicates, that
			  the block to be written is larger than allowed for
			  buffered mode.
 This erpa is reserved for 3480. 
		
		  Read buffered log (Overflow). CU is running in extended
		  buffered log mode, and a counter overflows. This should
		  never happen, since we're never running in extended
		  buffered log mode.
		
		  Read buffered log (EOV). EOF processing occurs while the
		  CU is in extended buffered log mode. This should never
		  happen, since we're never running in extended buffered
		  log mode.
 End of Volume complete. Rewind unload completed ok. 
 Global command intercept. 
 Channel interface recovery (temporary). 
 Channel interface recovery (permanent). 
 Channel protocol error. 
		
		  3480: Attention intercept.
		  3490: Global status intercept.
		
		  Tape length incompatible. The tape inserted is too long,
		  which could cause damage to the tape or the drive.
 Format 3480 XF incompatible 
 The tape will get overwritten. 
 Format 3480-2 XF incompatible 
 Tape length violation. 
 Compaction algorithm incompatible. 
 The following erpas should have been covered earlier. 
 Read data check. 
 Write data check. 
 Data check (read opposite). 
 Write id mark check. 
 Tape void. 
 Overrun error. 
 Record sequence error. 
 All other erpas are reserved for future use. 
  34803490 interrupt handler
 Write at end of volume 
		
		  A unit exception occurs on skipping over a tapemark block.
  ioctl_overload
  Build up the search block ID list. The block ID consists of a logical
  block number and a hardware specific part. The hardware specific part
  helps the tape drive to speed up searching for a specific block.
	
	  immediately return if there is no list at all or the block to add
	  is located in segment 1 of wrap 0 because this position is used
	  if no hardware position data is supplied.
	
	  Search the position where to insert the new entry. Hardware
	  acceleration uses only the segment and wrap number. So we
	  need only one entry for a specific wrapsegment combination.
	  If there is a block with a lower number but the same hard-
	  ware position data we just update the block number in the
	  existing entry.
 Sort in according to logical block number. 
 List empty or new block bigger than last entry. 
  Delete all entries from the search block ID list that belong to tape blocks
  equal or higher than the given number.
  Merge hardware position data into a block id.
  MTTELL: Tell block. Return the number of block relative to current file.
  MTSEEK: seek to the specified block.
 setup ccws 
 execute it 
  List of 34803490 magnetic tape commands.
  Tape discipline structure for 3480 and 3490.
 end of list  },
 Register driver for 34803490 tapes. 
 SPDX-License-Identifier: GPL-2.0
  Character device driver for reading zVM MONITOR service records.
  Copyright IBM Corp. 2004, 2009
  Author: Gerald Schaefer <gerald.schaefer@de.ibm.com>
 Version code, must be 0x01 for shared mode 
 what to collect 
 DCSS name in EBCDIC, 8 bytes padded with blanks 
                              helper functions                               
  Create the 8 bytes EBCDIC DCSS segment name from
  an ASCII name, incl. padding
                                IUCV handler                                 
                                file operations                              
	
	  only one user allowed
	
	  Connect to MONITOR service
	
	  Wait for connection confirmation
	
	  Close IUCV connection and unregister
 read monitor control element (12 bytes) first 
 read records 
                               module initexit                              
	
	  Register with IUCV and connect to MONITOR service
	
	  misc_register() has to be the last action in module_init(), because
	  file operations will be available right after this.
 SPDX-License-Identifier: GPL-2.0
  SCLP VT220 terminal driver.
  Copyright IBM Corp. 2003, 2009
  Author(s): Peter Oberparleiter <Peter.Oberparleiter@de.ibm.com>
 console=ttysclp0 
 Representation of a single write request 
 VT220 SCCB 
 Structures and data needed to register tty driver 
 Lock to protect internal data from concurrent access 
 List of empty pages to be used as write request buffers 
 List of pending requests 
 Flag that output queue is currently running 
 Timer used for delaying write requests to merge subsequent messages into
 Pointer to current request buffer which has been partially filled but not
 Number of characters in current request buffer 
 Counter controlling core driver initialization. 
 Flag indicating that sclp_vt220_current_request should really
  have been already queued but wasn't because the SCLP was processing
 Registration structure for SCLP output event buffers 
 Registration structure for SCLP input event buffers 
  Put provided request buffer back into queue and check emit pending
  buffers if necessary.
 Put buffer back to list of empty buffers 
 Move request from outqueue to empty queue 
 Check if there is a pending buffer on the out queue. 
  Callback through which the result of a write request is reported by the
  SCLP.
 Check SCLP response code and choose suitable action	
 Target resource in improper state 
 Contained SCLP equipment check 
 Remove processed buffers and requeue rest 
 Not all buffers were processed 
 SCLP equipment check 
  Emit vt220 request buffer to SCLP. Return zero on success, non-zero
  otherwise.
  Queue and emit current request.
 Only emit buffers with content 
  Helper function to initialize a page with the sclp request structure.
 Place request structure at end of page 
 SCCB goes at start of page 
  Add msg to buffer associated with request. Return the number of characters
  added.
 Perform Linefeed conversion (0x0a -> 0x0a 0x0d)
 Retrieve character 
 Perform conversion 
  Emit buffer after having waited long enough for more data to arrive.
  Drop oldest console buffer if sclp_con_drop is set
 The first element is in IO 
  Internal implementation of the write function. Write COUNT bytes of data
  from memory at BUF
  to the SCLP interface. In case that the data does not fit into the current
  write buffer, emit the current one and allocate a new one. If there are no
  more empty buffers available, wait until one gets emptied. If DO_SCHEDULE
  is non-zero, the buffer will be scheduled for emitting after a timeout -
  otherwise the user has to explicitly call the flush function.
  A non-zero CONVERTLF parameter indicates that 0x0a characters in the message
  buffer should be converted to 0x0a 0x0d. After completion, return the number
  of bytes written.
 Create an sclp output buffer if none exists yet 
 Try to write the string to the current request buffer 
		
		  Not all characters could be written to the current
		  output buffer. Emit the buffer, create a new buffer
		  and then output the rest of the string.
 Setup timer to output current console buffer after some time 
  This routine is called by the kernel to write a series of
  characters to the tty device.  The characters may come from
  user space or kernel space.  This routine will return the
  number of characters actually accepted for writing.
 Handle magic sys request 
 CTRL-O 
			
			  If pressed again, reset sysrq_pressed
			  and flip CTRL-O character
  Called by the SCLP to report incoming event buffers.
 Send input to line discipline 
  This routine is called when a particular tty device is opened.
  This routine is called when a particular tty device is closed.
  This routine is called by the kernel to write a single
  character to the tty device.  If the kernel uses this routine,
  it must call the flush_chars() routine (if defined) when it is
  done stuffing characters into the driver.
  This routine is called by the kernel after it has written a
  series of characters to the tty device using put_char().  
  This routine returns the numbers of characters the tty driver
  will accept for queuing to be written.  This number is subject
  to change as output buffers get emptied, or if the output flow
  control is acted.
  Return number of buffered chars.
  Pass on all buffers to the hardware. Return only when there are no more
  buffers pending.
 Release allocated pages. 
 Release memory and unregister from sclp core. Controlled by init counting -
 Allocate buffer pages and register with sclp core. Controlled by init
 Allocate pages for output buffering 
  Register driver with SCLP and Linux and initialize internal tty structures.
	 Note: we're not testing for CONSOLE_IS_SCLP here to preserve
 Structure needed to register with printk 
 Attach linux console 
 CONFIG_SCLP_VT220_CONSOLE 
 SPDX-License-Identifier: GPL-2.0
 Do not edit this file! It was automatically generated by   
    loadkeys --mktable defkeymap.map > defkeymap.c          
  Philosophy: most people do not define more strings, but they who do
  often want quite a lot of string space. So, we statically allocate
  the default and allocate dynamically in chunks of 512 bytes.
 space left 
 SPDX-License-Identifier: GPL-2.0
     SCLP Event Type (ET) 7 - Diagnostic Test FTP Services, useable on LPAR
     Copyright IBM Corp. 2013
     Author(s): Ralf Hoppe (rhoppe@de.ibm.com)
  sclp_ftp_txcb() - Diagnostic Test FTP services SCLP command callback
  @req: sclp request
  @data: pointer to struct completion
  sclp_ftp_rxcb() - Diagnostic Test FTP services receiver event callback
  @evbuf: pointer to Diagnostic Test (ET7) event buffer
	
	  Check for Diagnostic Test FTP Service
	
	  Because the event buffer is located in a page which is owned
	  by the SCLP core, all data of interest must be copied. The
	  error indication is in 'sclp_ftp_ldflg'
  sclp_ftp_et7() - start a Diagnostic Test FTP Service SCLP request
  @ftp: pointer to FTP descriptor
  Return: 0 on success, else a (negative) error code
 clear processed-buffer 
 Wait for end of ftp sclp command. 
	
	  Check if sclp accepted the request. The data transfer runs
	  asynchronously and the completion is indicated with an
	  sclp ET7 event.
 processed-buffer 
  sclp_ftp_cmd() - executes a HMC related SCLP Diagnose (ET7) FTP command
  @ftp: pointer to FTP command specification
  @fsize: return of file size (or NULL if undesirable)
  Attention: Notice that this function is not reentrant - so the caller
  must ensure locking.
  Return: number of bytes readwritten or a (negative) error code
 Start ftp sclp command. 
	
	  There is no way to cancel the sclp ET7 request, the code
	  needs to wait unconditionally until the transfer is complete.
  ET7 event listener
 want tx events 
 want rx events 
 async callback (rx) 
  sclp_ftp_startup() - startup of FTP services, when running on LPAR
 get SYSIB 2.2.2 
 DEBUG 
  sclp_ftp_shutdown() - shutdown of FTP services, when running on LPAR
 SPDX-License-Identifier: GPL-2.0
     ebcdic keycode functions for s390 console drivers
   S390 version
     Copyright IBM Corp. 2003
     Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
  Handler Tables.
 maximum values each key_handler can handle 
 dead_grave 
 dead_acute 
 dead_circumflex 
 dead_tilda 
 dead_diaeresis 
 dead_cedilla 
 dead_macron 
 dead_breve 
 dead_abovedot 
 dead_abovering 
 dead_doubleacute 
 dead_caron 
 dead_ogonek 
 dead_iota 
 dead_voiced_sound 
 dead_semivoiced_sound 
 dead_belowdot 
 dead_hook 
 dead_horn 
 dead_stroke 
 dead_abovecomma 
 dead_abovereversedcomma 
 dead_doublegrave 
 dead_invertedbreve 
 dead_belowcomma 
 dead_currency 
 dead_greek 
  Allocfree of kbd_data structures.
  Generate ascii -> ebcdic translation table from kbd_data.
  Generate ebcdic -> ascii translation table from kbd_data.
  We have a combining character DIACR here, followed by the character CH.
  If the combination occurs in the table, return the corresponding value.
  Otherwise, if CH is a space or equals DIACR, return DIACR.
  Otherwise, conclude that DIACR was not combining after all,
  queue it and return CH.
  Handle dead key.
  Normal character handler.
  Special key handlers
  Function key handler.
  Put utf8 character to tty flip buffer.
  UTF-8 is defined for words of up to 31 bits,
  but we need only 16 bits here
  0 
 110 10 
 1110 10 10 
  Process keycode.
 Handle the SysRq Hack 
 Incomplete sysrq sequence. 
  Ioctl stuff.
 disallocate map 
 nothing to do 
		
		  Attention Key.
 Get u_kbs->kb_func. 
	
	  To have permissions to do most of the vt ioctls, we either have
	  to be the owner of the tty, or have CAP_SYS_TTY_CONFIG.
 FIXME this test is pretty racy 
 SPDX-License-Identifier: GPL-2.0
  PCI IO adapter configuration related functions.
  Copyright IBM Corp. 2016
 adapter type 
 adapter identifier 
 SPDX-License-Identifier: GPL-2.0
  IBM3270 Driver - fullscreen driver.
  Author(s):
    Original 3270 Code for 2.4 written by Richard Hitt (UTS Global)
    Rewritten for 2.52.6 by Martin Schwidefsky <schwidefsky@de.ibm.com>
      Copyright IBM Corp. 2003, 2009
 Pid of controlling program. 
 ccw command to use for reads. 
 ccw command to use for writes. 
 Got attention. 
 Fullscreen view is active. 
 single init request. 
 Init & attention wait queue. 
 full-screen-deactivate buffer 
 size of data returned by RDBUF 
	
	  The fullscreen view is in working order if the view
	  has been activated AND the initial request is finished.
 Fullscreen view isn't ready yet. 
 Started successfully. Now wait for completion. 
  Switch to the fullscreen view.
 If an old init command is still running just return. 
 No saved buffer. Just clear the screen. 
 Restore fullscreen buffer saved by fs3270_deactivate. 
  Shutdown fullscreen view.
 Correct idal buffer element 0 address. 
	
	  If the rdbuf command failed or the idal buffer is
	  to small for the amount of data returned by the
	  rdbuf command, then we have no choice but to send
	  a SIGHUP to the application.
 If an old init command is still running just return. 
 Prepare read-buffer request. 
	
	  Hackish: skip first 5 bytes of the idal buffer to make
	  room for the TW_KRTO_SBA<address><address>TO_IC sequence
	  in the activation command.
 Start IO to read in the 3270 buffer. 
 Handle ATTN. Set indication and wake waiters for attention. 
 Normal end. Copy residual count. 
  Process reads from fullscreen 3270.
  Process writes to fullscreen 3270.
  process ioctl commands for the tube driver
  Allocate fs3270 structure.
  Free fs3270 structure.
  Unlink fs3270 data structure from filp.
 View to a 3270 device. Can be console, tty or fullscreen. 
  This routine is called whenever a 3270 fullscreen device is opened.
 Check for minor 0 multiplexer. 
 Check if some other program is already using fullscreen mode. 
 Allocate fullscreen view structure. 
 Allocate idal-buffer. 
  This routine is called when the 3270 tty is closed. We wait
  for the remaining request to be completed. Then we clean up.
 owner 
 read 
 write 
 ioctl 
 ioctl 
 open 
 release 
  3270 fullscreen driver initialization.
 SPDX-License-Identifier: GPL-2.0
  3215 line mode terminal driver.
  Copyright IBM Corp. 1999, 2009
  Author(s): Martin Schwidefsky <schwidefsky@de.ibm.com>
  Updated:
   Aug-2000: Added tab support
 	      Dan Morrison, IBM Corporation <dmorriso@cse.buffalo.edu>
 ASYNC_ flags 
 output buffer size 
 input buffer size 
 minimum free space for wakeup 
 min. length for immediate output 
 max. bytes to write with one ssch 
 max. lines to write with one ssch 
 time for delayed output 
 3215 console device is not be freed 
 set if a request is being worked on 
 set if reading is disabled 
 set if writing is disabled 
 set if the output delay timer is on 
 set to flush buffer (no delay) 
 tab stop size 
  Request types for a 3215 device
  Request structure for a 3215 device
 type of the request 
 start index & len in output buffer 
 indication to wait for more data 
 residual count for read request 
 space for the channel program 
 pointer to main structure 
 pointer to next request 
 device for tty driver 
 pointer to irq lock 
 state flags 
 pointer to output buffer 
 pointer to input buffer 
 first free byte in output buffer 
 number of bytes in output buffer 
 number of bytes in write requests 
 pointer to queued read requests 
 pointer to queued write requests 
 wait queue for flushing 
 timer for delayed output 
 position on the line (for tabs) 
 copy_from_user buffer 
 array of 3215 devices structures 
 spinlock to protect the raw3215 array 
 list of free request structures 
 spinlock to protect free list 
  Get a request structure from the free list
  Put a request structure back to the free list
 don't free a free request 
  Set up a read request that reads up to 160 byte from the 3215 device.
  If there is a queued read request it is used, but that shouldn't happen
  because a 3215 terminal won't accept a new read before the old one is
  completed.
 there can only be ONE read request at a time 
 no queued read request, use new req structure 
 read inquiry 
 ignore incorrect length 
  Set up a write request with the information from the main structure.
  A ccw chain is created that writes as much as possible from the output
  buffer to the 3215 device. If a queued write exists it is replaced by
  the new, probably lengthened request.
 check if there is a queued write request 
 no queued write request, use new req structure 
	
	  now we have to count newlines. We can at max accept
	  RAW3215_MAX_NEWLINE newlines in a single ssch due to
	  a restriction in VM
 set the indication if we should try to enlarge this request 
 use command chaining 
 write, auto carrier return 
 ignore incorrect length ind.  
	
	  Add a NOP to the channel program. 3215 devices are purely
	  emulated and its much better to avoid the channel end
	  interrupt in this case.
 use command chaining 
 NOP 
  Start a read or a write request
 dequeue request 
 do_IO failed, put request back to queue 
 dequeue request 
 do_IO failed, put request back to queue 
  Function to start a delayed output after RAW3215_TIMEOUT seconds
  Function to conditionally start an IO. A read is started immediately,
  a write is only started immediately if the flush flag is on or the
  amount of data is bigger than RAW3215_MIN_WRITE. If a write is not
  done immediately a timer is started with a delay of RAW3215_TIMEOUT.
 execute write requests bigger than minimum size 
  Try to start the next IO and wake up processes waiting on the tty.
  Interrupt routine, called from common io layer
 we got a unit exception 
 we can ignore it 
 Attention interrupt, someone hit the enter key 
 Channel end interrupt. 
 That shouldn't happen ... 
 store residual count, then wait for device end 
 Device end interrupt. 
 That shouldn't happen ... 
 add the auto \n 
 check for empty wait 
 Strange interrupt, I'll do my best to clean up 
  Wait until length bytes are available int the output buffer.
  Has to be called with the s390irq lock held. Can be called
  disabled.
 there might be a request pending 
 Enough room freed up ? 
 there might be another cpu waiting for the lock 
  String write routine for 3215 devices
 copy string to output buffer and convert it to EBCDIC 
 start or queue request 
  Put character routine for 3215 devices
 start or queue request 
  Flush routine, it simply sets the flush flag and tries to start
  pending IO.
  Fire up a 3215 device.
  Shutdown a 3215 device.
 Wait for outstanding requests, then free irq 
 Console is special. 
 end of list  },
  Write a string to the 3215 console
 console 3215 is the first one 
  panic() calls con3215_flush through a panic_notifier
  before the system enters a disabled, endless loop.
 console 3215 is the first one 
   The console structure for the 3215 console
  3215 console initialization code called from console_init().
 Check if 3215 is to be the console 
 Set the console mode for VM 
 allocate 3215 request structures 
 Request the console irq 
  tty3215_open
  This routine is called whenever a 3215 tty is opened.
	
	  Start up 3215 device
  tty3215_close()
  This routine is called when the 3215 tty is closed. We wait
  for the remaining request to be completed. Then we clean up.
 Shutdown the terminal 
  Returns the amount of free space in the output buffer.
 Subtract TAB_STOP_SIZE to allow for a tab, 8 <<< 64K 
  String write routine for 3215 ttys
  Put character routine for 3215 ttys
  Returns the number of characters in the output buffer
  Disable reading from a 3215 tty
  Enable reading from a 3215 tty
  Disable writing to a 3215 tty
  Enable writing to a 3215 tty
  3215 tty registration code called from tty_init().
  Most kernel services (incl. kmalloc) are available at this poimt.
	
	  Initialize the tty_driver structure
	  Entries in tty3215_driver that are NOT initialized:
	  proc_entry, set_termios, flush_buffer, set_ldisc, write_proc
 SPDX-License-Identifier: GPL-2.0
     HMC Drive CDDVD Device
     Copyright IBM Corp. 2013
     Author(s): Ralf Hoppe (rhoppe@de.ibm.com)
     This file provides a Linux "misc" character device for access to an
     assigned HMC drive CDDVD-ROM. It works as follows: First create the
     device by calling hmcdrv_dev_init(). After open() a lseek(fd, 0,
     SEEK_END) indicates that a new FTP command follows (not needed on the
     first command after open). Then write() the FTP command ASCII string
     to it, e.g. "dir " or "nls <directory>" or "get <filename>". At the
     end read() the response.
 If the following macro is defined, then the HMC device creates it's own
  separated device class (and dynamically assigns a major number). If not
  defined then the HMC device is assigned to the "misc" class devices.
#define HMCDRV_DEV_CLASS "hmcftp"
 delay between -EBUSY trials in ms 
 number of retries on -EBUSY 
 character device structure 
 mode of device node (unused, zero) 
 "misc" device structure 
  device operations
 HMC device struct (static) 
 device class pointer 
 device number (majorminor) 
  hmcdrv_dev_name() - provides a naming hint for a device node in dev
  @dev: device for which the namingmode hint is
  @mode: file mode for device node created in dev
  See: devtmpfs.c, function devtmpfs_create_node()
  Return: recommended device file name in dev
 kernel device name 
	 on device destroy (rmmod) the mode pointer may be NULL
 HMCDRV_DEV_CLASS 
  open()
	 check for non-blocking access, which is really unsupported
	 Because it makes no sense to open this device read-only (then a
	  FTP command cannot be emitted), we respond with an error.
	 prevent unloading this module as long as anyone holds the
	  device file open - so increment the reference count here
 no command yet 
  release()
  lseek()
 relative to current file position 
 new position stored in 'pos' 
 absolute (relative to beginning of file) 
 SEEK_SET 
		 We use SEEK_END as a special indicator for a SEEK_SET
		  (set absolute position), combined with a FTP command
		  clear.
 SEEK_END 
 SEEK_DATA, SEEK_HOLE: unsupported 
  transfer (helper function)
  read()
 no FTP cmd defined ? 
  write()
 first expect a cmd write 
  hmcdrv_dev_init() - creates a HMC drive CDDVD device
  This function creates a HMC drive CDDVD kernel device and an associated
  device under dev, using a dynamically allocated major number.
  Return: 0 on success, else an error code.
	 At this point the character device exists in the kernel (see
	  procdevices), but not under dev nor sysdevicesvirtual. So
	  we have to create an associated class (see sysclass).
	 Finally a device node in dev has to be established (as 'mkdev'
	  does from the command line). Notice that assignment of a device
	  node namemode function is optional (only for mode != 0600).
 "unset" 
 !HMCDRV_DEV_CLASS 
 finally produces 0600 
 HMCDRV_DEV_CLASS 
  hmcdrv_dev_exit() - destroys a HMC drive CDDVD device
 !HMCDRV_DEV_CLASS 
 HMCDRV_DEV_CLASS 
 SPDX-License-Identifier: GPL-2.0
 	character device driver for reading zVM system service records
 	Copyright IBM Corp. 2004, 2009
 	character device driver for reading zVM system service records,
 	Version 1.0
 	Author(s): Xenia Tkatschow <xenia@us.ibm.com>
 		   Stefan Weinhuber <wein@de.ibm.com>
  The size of the buffer for iucv data transfer is one page,
  but in addition to the data we read from iucv we also
  place an integer and some characters into that buffer,
  so the maximum size for record data is a little less then
  one page.
  The elements that are concurrently accessed by bottom halves are
  connection_established, iucv_path_severed, local_interrupt_buffer
  and receive_ready. The first three can be protected by
  priv_lock.  receive_ready is atomic, so it can be incremented and
  decremented without holding a lock.
  The variable dev_in_use needs to be protected by the lock, since
  it's a flag used by open to make sure that the device is opened only
  by one user at the same time.
 1: already opened, 0: not opened
  File operation structure for vmlogrdr devices
  pointer to system service private structure
  minor number 0 --> logrec
  minor number 1 --> account
  minor number 2 --> symptom
 just in case we're sleeping waiting for a record 
	
	  This function is the bottom half so it should be quick.
	  Copy the external interrupt data into our local eib and increment
	  the usage count
 now the parsing
	
	  expect comma separated list of classes here, if one of them
	  is A or B return 1 otherwise 0
	
	  The recording commands needs to be called with option QID
	  for guests that have previlege classes A or B.
	  Purging has to be done as separate step, because recording
	  can't be switched on as long as records are on the queue.
	  Doing both at the same time doesn't work.
	 The recording command will usually answer with 'Command complete'
	  on success, but when the specific service was never connected
	  before then there might be an additional informational message
	  'HCPCRC8072I Recording entry not found' before the
	  'Command complete'. So I use strstr rather then the strncmp.
	
	  If we turn recording off, we have to purge any remaining records
	  afterwards, as a large number of queued records may impact zVM
	  performance.
	
	  only allow for blocking reads to be open
 Besure this device hasn't already been opened 
 set the file options 
 start recording for this service
 create connection to the system service 
	 We've issued the connect and now we must wait for a
	  ConnectionComplete or ConnectinSevered Interrupt
	  before we can continue to process.
 kfree(NULL) is ok. 
	 we need to keep track of two data sizes here:
	  The number of bytes we need to receive from iucv and
	  the total number of bytes we actually write into the buffer.
 receive second half of a record 
			 receive a new record:
			  We need to return the total length of the record
                          + size of FENCE in the first 4 bytes of the buffer.
		
		  If the record is bigger than our buffer, we receive only
		  a part of it. We can get the rest later.
		 An rc of 5 indicates that the record was bigger than
		  the buffer, which is OK for us. A 9 indicates that the
		  record was purged befor we could receive it.
			 the whole record has been captured,
 copy only up to end of record 
 if all data has been transferred, set buffer free 
	  The recording command needs to be called with option QID
	  for guests that have previlege classes A or B.
	  Other guests will not recognize the command and we have to
	  issue the same command without the QID parameter.
 Register with iucv driver 
		
		  The release function could be called after the
		  module has been unloaded. It's _only_ task is to
		  free the struct. Therefore, we specify kfree()
		  directly here. (Probably a little bit obfuscating
		  but legitime ...).
 cleanup: cdev is not fully registered, no cdev_del here!
 SPDX-License-Identifier: GPL-2.0
     SCLP line mode terminal driver.
   S390 version
     Copyright IBM Corp. 1999
     Author(s): Martin Peschke <mpeschke@de.ibm.com>
 		 Martin Schwidefsky <schwidefsky@de.ibm.com>
  size of a buffer that collects single characters coming in
  via sclp_tty_put_char()
  There is exactly one SCLP terminal, so we can keep things simple
  and allocate all variables statically.
 Lock to guard over changes to global variables. 
 List of free pages that can be used for console output buffering. 
 List of full struct sclp_buffer structures ready for output. 
 Counter how many buffers are emitted. 
 Pointer to current console buffer. 
 Timer for delayed output of console messages. 
 to separate upper and lower case (% in EBCDIC) 
 This routine is called whenever we try to open a SCLP terminal. 
 This routine is called when the SCLP terminal is closed. 
  This routine returns the numbers of characters the tty driver
  will accept for queuing to be written.  This number is subject
  to change as output buffers get emptied, or if the output flow
  control is acted. This is not an exact number because not every
  character needs the same space in the sccb. The worst case is
  a string of newlines. Every newline creates a new message which
  needs 82 bytes.
 Remove buffer from outqueue 
 Check if there is a pending buffer on the out queue. 
  When this routine is called from the timer then we flush the
  temporary write buffer.
  Write a string to the sclp tty.
 Create a sclp output buffer if none exists yet 
 try to write the string to the current output buffer 
		
		  Not all characters could be written to the current
		  output buffer. Emit the buffer, create a new buffer
		  and then output the rest of the string.
 Setup timer to output current console buffer after 110 second 
  This routine is called by the kernel to write a series of characters to the
  tty device. The characters may come from user space or kernel space. This
  routine will return the number of characters actually accepted for writing.
  This routine is called by the kernel to write a single character to the tty
  device. If the kernel uses this routine, it must call the flush_chars()
  routine (if defined) when it is done stuffing characters into the driver.
  Characters provided to sclp_tty_put_char() are buffered by the SCLP driver.
  If the given character is a '\n' the contents of the SCLP write buffer
  - including previous characters from sclp_tty_put_char() and strings from
  sclp_write() without final '\n' - will be written.
  This routine is called by the kernel after it has written a series of
  characters to the tty device using put_char().
  This routine returns the number of characters in the write buffer of the
  SCLP driver. The provided number includes all characters that are stored
  in the SCCB (will be written next time the SCLP is not busy) as well as
  characters in the write buffer (will not be written as long as there is a
  final line feed missing).
  removes all content from buffers of low level driver
  push input to tty
	
	  If this tty driver is currently closed
	  then throw the received input away.
 send (normal) input to line discipline 
 add the auto \n 
  get a EBCDIC string in upperlower case,
  find out characters in lowerupper case separated by a special character,
  modifiy original string,
  returns length of resulting string
 initially changing case is off 
 compare with special character 
 followed by another special character? 
				
				  ... then put a single copy of the special
				  character to the output string
				
				  ... special character follower by a normal
				  character toggles the case change behaviour
 skip special character 
 not the special character 
 but case switching is on 
 switch to uppercase 
 switch to lowercase 
 no case switching, copy the character 
 return length of reformatted string. 
 convert EBCDIC to ASCII (modify original input in SCCB) 
 transfer input to high level driver 
 zVM multiplexes the line mode output on the 32xx screen 
 Allocate pages for output buffering 
 case input lines to lowercase 
 SPDX-License-Identifier: GPL-2.0
  SCLP early driver
  Copyright IBM Corp. 2013
 Save IPL information 
  This function will be called after sclp_early_facilities_detect(), which gets
  called from early.c code. The sclp_early_facilities_detect() function retrieves
  and saves the IPL information.
	
	  Turn off SCLP event notifications.  Also save remote masks in the
	  sccb.  These are sufficient to detect sclp console capabilities.
 SPDX-License-Identifier: GPL-2.0
  IBM3270 Driver - core functions.
  Author(s):
    Original 3270 Code for 2.4 written by Richard Hitt (UTS Global)
    Rewritten for 2.5 by Martin Schwidefsky <schwidefsky@de.ibm.com>
      Copyright IBM Corp. 2003, 2009
 The main 3270 data structure. 
 Request queue. 
 List of available views. 
 Active view. 
 Device timer. 
 ascii -> ebcdic table 
 raw3270->state 
 Initial state 
 Reset command is pending 
 Wait for attention interrupt 
 Read partition is pending 
 Device is usable by views 
 raw3270->flags 
 14-bit buffer addresses 
 Device busy, leave it alone 
 Device is the console. 
 Semaphore to protect global data of raw3270 (devices, views, etc). 
 List of 3270 devices. 
  Flag to indicate if the driver has been registered. Some operations
  like waiting for the end of io need to be done differently as long
  as the kernel is still starting up (console support).
 Module parameters 
  Wait queue for device initdelete, view delete.
  Encode array for 12 bit 3270 addresses.
  Allocate a new 3270 ccw request
 Allocate request structure 
 alloc output buffer. 
	
	  Setup ccw.
  Free 3270 ccw request
  Reset request to initial state.
  Set command code to ccw of a request.
  Add data fragment to output buffer.
  Set addresslength pair to ccw of a request.
  Set idal buffer to ccw of a request.
  Add the request to the request queue, try to start it if the
  3270 device is idle. Return without waiting for end of io.
 No other requests are on the queue. Start this one. 
  3270 interrupt routine, called from the ccw_device layer
 Handle CE-DE-UE and subsequent UDE 
 Handle disconnected devices 
 Call interrupt handler of the view 
 Device busy, do not start IO 
 The request completed, remove from queue and do callback. 
 Do put_device for get_device in raw3270_start. 
	
	  Try to start each request on request queue until one is
	  started successful.
 Start failed. Remove request and do callback. 
 Do put_device for get_device in raw3270_start. 
  To determine the size of the 3270 device we need to do:
  1) send a 'read partition' data stream to the device
  2) wait for the attn interrupt that precedes the query reply
  3) do a read modified to get the query reply
  To make things worse we have to cope with intervention
  required (3270 device switched to 'stand-by') and command
  rejects (old devices that can't do 'read partition').
 Query Reply structure for Usable Area 
 Usable Area Query Reply Base 
 Length of this structured field 
 0x81 if Query Reply 
 0x81 if Usable Area 
 Width of usable area 
 Heigth of usavle area 
 0x00:in; 0x01:mm 
 Character buffer size, bytes 
 Alternate Usable Area Self-Defining Parameter 
 Length of this Self-Defining Parm 
 0x02 if Alternate Usable Area 
 0x01 is Id for the A U A 
 Width of AUAi 
 Height of AUAi 
 0x00:in, 0x01:mm 
 Use default model 2 if the size could not be detected 
 Got a Query Reply 
 Paranoia check. 
 Couldn't detect size. Use default model 2. 
 Copy rowscolumns of default Usable Area 
 Check for 14 bit addressing 
 Check for Alternate Usable Area 
 Try to find a model. 
 Notify views about new size 
 Setup processing done, now activate a view 
 Use 'read modified' to get the result of a read partition. 
 Store 'read partition' data stream to init_data 
  Device reset
 Reset command failed. 
 Check if reset is already pending 
 Store reset data stream to init_datainit_reset 
 Cancel all queued requests 
 Start from scratch 
 Queue read modified after attention interrupt 
  Setup new 3270 device.
 Copy ebcdic -> ascii translation table. 
 correct brackets and circumflex 
 Set defaults. 
	
	  Add device to list and find the smallest unused minor
	  number for it. Note: there is no device with minor 0,
	  see special case for fs3270.c:fs3270_open().
 Keep the list sorted. 
 No free minor number? Then give up. 
 Tentative definition - see below for actual definition. 
  Setup 3270 device configured as console.
  Create a 3270 device structure.
 Get reference to ccw_device structure. 
  Activate a view.
 Didn't work. Try to reactivate the old view. 
 Didn't work as well. Try any other view. 
  Deactivate current view.
 Move deactivated view to end of list. 
 Try to activate another view. 
  Add view to device with minor "minor".
  Find specific view of device with minor "minor".
  Remove view from device and free view structure via call to view->fn->free.
 Try to activate another view. 
 Wait for reference counter to drop to zero. 
  Remove a 3270 device structure.
 Remove from device chain. 
 Disconnect from ccw_device. 
 Put ccw_device structure. 
 Now free raw3270 structure. 
  Additional attributes for a 3270 device
  Notifier for device additionremoval
  Set 3270 device online.
  Remove 3270 device structure.
	
	  _remove is the opposite of _probe; it's probe that
	  should set up rp.  raw3270_remove gets entered for
	  devices even if they haven't been varied online.
	  Thus, rp may validly be NULL here.
 Deactivate current view and remove all views. 
 Reset 3270 device. 
 And finally remove it. 
  Set 3270 device offline.
 end of list  },
 Create attributes for early (= console) device. 
 SPDX-License-Identifier: GPL-2.0
     Copyright IBM Corp. 2007
     Author(s): Heiko Carstens <heiko.carstens@de.ibm.com>
 Setup SCCB for Control-Program Identification 
 SPDX-License-Identifier: GPL-2.0
  IOCTL interface for SCLP
  Copyright IBM Corp. 2012
  Author: Michael Holzheu <holzheu@linux.vnet.ibm.com>
  Supported command words
  Check if command word is supported
  Start SCLP request
  SCLP SCCB ioctl function
 unknown ioctl number 
  File operations
  Misc device definition
 SPDX-License-Identifier: GPL-2.0
     basic function of the tape device driver
   S390 and zSeries version
     Copyright IBM Corp. 2001, 2009
     Author(s): Carsten Otte <cotte@de.ibm.com>
 		 Michael Holzheu <holzheu@de.ibm.com>
 		 Tuan Ngo-Anh <ngoanh@de.ibm.com>
 		 Martin Schwidefsky <schwidefsky@de.ibm.com>
 		 Stefan Bader <shbader@de.ibm.com>
 for kernel parameters
 for requesting modules
 for locks
 for variable types
 seconds 
  One list to contain all tape devices of all disciplines, so
  we can assign the devices to minor numbers of the same major
  The list is protected by the rwlock
  Pointer to debug area.
  Printable strings for tape enumerations.
  Some channel attached tape specific attributes.
  FIXME: In the future the first_minor and blocksize attribute should be
         replaced by a link to the cdev tree.
  Tape state functions
  Stop running ccw. Has to be called with the device lock held.
 Check if interrupt has already been processed 
  Add device into the sorted list, giving it the first
  available minor number.
 remove device from the list 
  Set a device online.
  This function is called by the common IO layer to move a device from the
  detected but offline into the online state.
  If we return an error (RC < 0) the device remains in the offline state. This
  can happen if the device is assigned somewhere else, for example.
 Let the discipline have a go at the device. 
  Set device offline.
  Called by the common IO layer if the drive should set offline on user
  request. We may prevent this by returning an error.
  Manual offline is only allowed while the drive is not in use.
  Allocate memory for a new device structure.
  Get a reference to an existing device structure. This will automatically
  increment the reference count.
  Decrease the reference counter of a devices structure. If the
  reference counter reaches zero free the device structure.
  The function returns a NULL pointer to be used by the caller
  for clearing reference pointers.
  Find tape device by a device index.
  Driverfs tape probe function.
 Decrease ref_count for removed request. 
  Driverfs tape remove function.
  This function is called whenever the common IO layer detects the device
  gone. This can happen at any time and we cannot refuse.
			
			  Nothing to do.
			
			  Need only to release the device.
			
			  There may be requests on the queue. We will not get
			  an interrupt for a request that was running. So we
			  just post them all as IO errors.
  Allocate a new tape ccw request
 allocate channel program 
 alloc small kernel buffer 
  Free tape ccw request
 The common IO subsystem is currently busy. Retry later. 
 Start failed. Remove request and indicate failure. 
	
	  Try to start each request on request queue until one is
	  started successful.
		
		  Avoid race condition if bottom-half was triggered more than
		  once.
		
		  Request has already been stopped. We have to wait until
		  the request is removed from the queue in the interrupt
		  handling.
		
		  We wanted to cancel the request but the common IO layer
		  was busy at that time. This can only happen if this
		  function is called by delayed_next_request.
		  Otherwise we start the next request on the queue.
 Set ending status. 
 Remove from request queue. 
 Do callback. 
 Remove from request queue. 
 Do callback. 
 Start next request. 
  Write sense data to dbf
  IO helper function. Adds the request to the request queue
  and starts it if the tape is idle. Has to be called with
  the device lock held.
 Increase use count of device for the added request. 
 No other requests are on the queue. Start this one. 
  Add the request to the request queue, try to start it if the
  tape is idle. Return without waiting for end of io.
 Add request to request queue and try to start it. 
  tape_do_io__tape_wake_up
  Add the request to the request queue, try to start it if the
  tape is idle and wait uninterruptible for its completion.
 Setup callback 
 Add request to request queue and try to start it. 
 Request added to the queue. Wait for its completion. 
 Get rc from request 
  tape_do_io_interruptible__tape_wake_up_interruptible
  Add the request to the request queue, try to start it if the
  tape is idle and wait uninterruptible for its completion.
 Setup callback 
 Request added to the queue. Wait for its completion. 
 Request finished normally. 
 Interrupted by a signal. We have to stop the current request. 
 Wait for the interrupt that acknowledges the halt. 
  Stop running ccw.
  Tape interrupt routine, called from the ccw_device layer
 On special conditions irb is an error pointer 
 FIXME: What to do with the request? 
	
	  If the condition code is not zero and the start function bit is
	  still set, this is an deferred error and the last start IO did
	  not succeed. At this point the condition that caused the deferred
	  error might still apply. So we just schedule the request to be
	  started later.
 May be an unsolicited irq 
 Not Ready to Ready after long busy ? 
 Set the 'ONLINE' flag depending on sense byte 1 
		
		  Any request that does not come back with channel end
		  and device end is unusual. Log the sense data.
 Upon normal completion the device _is_ online 
	
	  Request that were canceled still come back with an interrupt.
	  To detect these request the state will be set to TAPE_REQUEST_DONE.
	
	  rc < 0 : request finished unsuccessfully.
	  rc == TAPE_IO_SUCCESS: request finished successfully.
	  rc == TAPE_IO_PENDING: request is still running. Ignore rc.
	  rc == TAPE_IO_RETRY: request finished but needs another go.
	  rc == TAPE_IO_STOP: request needs to get terminated.
 Upon normal completion the device _is_ online 
  Tape device open function used by tape_char frontend.
  Tape device release function used by tape_char frontend.
  Execute a magnetic tape command a number of times.
 We assume that the backends can handle count up to 500. 
  Tape init function.
  Tape exit function.
 Get rid of the frontends 
 SPDX-License-Identifier: GPL-2.0
  ccw based virtio transport
  Copyright IBM Corp. 2012, 2014
     Author(s): Cornelia Huck <cornelia.huck@de.ibm.com>
  virtio related functions
 same as PCI config space size, should be enough for all drivers 
 Transport revision 
 Serializes IO requests 
 the highest virtio-ccw revision we support 
 inherit from subchannel 
 Walk through indicators field, summary indicator active. 
 Walk through indicators field, summary indicator not active. 
 Not enough vacancies. 
 payload is the address of the indicators 
 Deregister indicators from host. 
 Remove from our list. 
 Release from host. 
	
	  -ENODEV isn't considered an error: The device is gone anyway.
	  This may happen on device detach.
 Allocate queue. 
 For now, we fail if we can't get the requested size. 
 it may have been reduced 
 Register it with the host. 
 Save it to our list. 
 Try to get an indicator. 
			
			  The host does not support adapter interrupts
			  for virtio-ccw, stop trying.
	
	  We need a data area under 2G to communicate. Our payload is
	  the address of the indicators.
 no error, just fall back to legacy interrupts 
 Register queue indicators with host. 
 Register indicators2 with host for config changes 
 Zero status bits. 
 Send a reset ccw on device. 
 Read the feature bits from the host. 
 Read second half of the feature bits from the host. 
	
	  Currently nothing to do here.
 Give virtio_ring a chance to accept features. 
 Give virtio_ccw a chance to accept features. 
 Write the first half of the feature bits to the host. 
 Write the second half of the feature bits to the host. 
 Read the config area from the host. 
 Make sure we don't overwrite fields. 
 Write the config area to the host. 
  If the channel program failed (should only happen if the device
  was hotunplugged, and then we clean up via the machine check
  handler anyway), vcdev->dma_area->status was not overwritten and we just
  return the old status, which is fine.
 Write the status to the host. 
 Write failed? We assume status is unchanged. 
  ccw bus driver related functions
 don't know what to do... 
 Don't poke around indicators, something's wrong. 
 Check if it's a notification from the host. 
 OK 
 Command reject? 
 Map everything else to -EIO. 
 The bit clear must happen before the vring kick. 
  We usually want to autoonline all devices, but give the admin
  a way to exempt devices from this.
 Set transport revision 
 none of our supported revisions carry payload 
				
				  The host device does not support setting
				  the revision: let's operate it in legacy
				  mode.
 at least try 
	
	  Make sure vcdev is set
	  i.e. set_offlineremove callback not already running
 parse no_auto string before we do anything further 
 SPDX-License-Identifier: GPL-2.0
  Copyright IBM Corp. 2018
 Prio-queueing needs all TX queues: 
		 Reject downgrade while running. It could push displaced
		  ucast flows onto txq0, which is reserved for mcast.
 Helper function to fill 'advertising' and 'supported' which are the same. 
 Autoneg and full-duplex are supported and advertised unconditionally.     
 Always advertise and support all speeds up to specified, and only one     
 specified port type.							     
 Check if we can obtain more accurate information.	 
 SPDX-License-Identifier: GPL-2.0
     Copyright IBM Corp. 2007
     Author(s): Frank Pavlic <fpavlic@de.ibm.com>,
 		 Thomas Spatzier <tspat@de.ibm.com>,
 		 Frank Blaschka <frank.blaschka@de.ibm.com>
 default for qeth_get_ipa_msg(): 
 SPDX-License-Identifier: GPL-2.0+
  IUCV network driver
  Copyright IBM Corp. 2001, 2009
  Author(s):
 	Original netiucv driver:
 		Fritz Elfert (elfert@de.ibm.com, felfert@millenux.com)
 	Sysfs integration and all bugs therein:
 		Cornelia Huck (cornelia.huck@de.ibm.com)
 	PM functions:
 		Ursula Braun (ursula.braun@de.ibm.com)
  Documentation used:
   the source of the original IUCV driver by:
     Stefan Hegewald <hegewald@de.ibm.com>
     Hartmut Penner <hpenner@de.ibm.com>
     Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com)
     Martin Schwidefsky (schwidefsky@de.ibm.com)
     Alan Altmark (Alan_Altmark@us.ibm.com)  Sept. 2000
  Debug Facility stuff
  some more debug stuff
 for debugging 
  Per connection profiling data
  Representation of one iucv connection
  Linked list of all connection structs.
  Representation of event-data for the
  connection state machine.
  Private part of the network device structure
  Link level header for a packet.
  Compatibility macros for busy handling
  of network devices.
  Convert an iucv userId to its printable
  form (strip whitespace at end).
  @param An iucv userId
  @returns The printable string (static data!!)
  States of the interface statemachine.
	
	  MUST be always the last element!!
  Events of the interface statemachine.
	
	  MUST be always the last element!!
  Events of the connection statemachine
	
	  Events, representing callbacks from
	  lowlevel iucv layer)
	
	  Events, representing errors return codes from
	  calls to lowlevel iucv layer
	
	  Event, representing timer expiry.
	
	  Events, representing commands from upper levels.
	
	  MUST be always the last element!!
  States of the connection statemachine.
	
	  Connection not assigned to any device,
	  initial state, invalid
	
	  Userid assigned but not operating
	
	  Connection registered,
	  no connection request sent yet,
	  no connection request received
	
	  Connection registered and connection request sent,
	  no acknowledge and no connection request received yet.
	
	  Connection up and running idle
	
	  Data sent, awaiting CONN_EVENT_TXDONE
	
	  Error during registration.
	
	  Error during registration.
	
	  MUST be always the last element!!
  Debug Facility Stuff
  Callback-wrappers, called from lowlevel iucv layer.
 Found a matching connection for this path. 
  NOP action for statemachines
  Actions of the connection statemachine
  netiucv_unpack_skb
  @conn: The connection where this skb has been received.
  @pskb: The received skb.
  Unpack a just received skb and hand it over to upper layers.
  Helper function for conn_action_rx.
		
		  Since receiving is always initiated from a tasklet (in iucv.c),
		  we must use netif_rx_ni() instead of netif_rx()
	
	  We must set the state before calling iucv_connect because the
	  callback handler could be called at any point after the connection
	  request is sent
  Actions for interface - statemachine.
  dev_action_start
  @fi: An instance of an interface statemachine.
  @event: The event, just happened.
  @arg: Generic pointer, casted from struct net_device  upon call.
  Startup connection by sending CONN_EVENT_START to it.
  Shutdown connection by sending CONN_EVENT_STOP to it.
  @param fi    An instance of an interface statemachine.
  @param event The event, just happened.
  @param arg   Generic pointer, casted from struct net_device  upon call.
  Called from connection statemachine
  when a connection is up and running.
  @param fi    An instance of an interface statemachine.
  @param event The event, just happened.
  @param arg   Generic pointer, casted from struct net_device  upon call.
  Called from connection statemachine
  when a connection has been shutdown.
  @param fi    An instance of an interface statemachine.
  @param event The event, just happened.
  @param arg   Generic pointer, casted from struct net_device  upon call.
  Transmit a packet.
  This is a helper function for netiucv_tx().
  @param conn Connection to be used for sending.
  @param skb Pointer to struct sk_buff of packet to send.
             The linklevel header has already been set up
             by netiucv_tx().
  @return 0 on success, -ERRNO on failure. (Never fails.)
		
		  Copy the skb to a new allocated skb in lowmem only if the
		  data is located above 2G in memory or tailroom is < 2.
		
		  skb now is below 2G and has enough room. Add headers.
				
				  Remove our headers. They get added
				  again on retransmit.
  Interface API for upper network layers
  Open an interface.
  Called from generic network layer when ifconfig up is run.
  @param dev Pointer to interface struct.
  @return 0 on success, -ERRNO on failure. (Never fails.)
  Close an interface.
  Called from generic network layer when ifconfig down is run.
  @param dev Pointer to interface struct.
  @return 0 on success, -ERRNO on failure. (Never fails.)
  Start transmission of a packet.
  Called from generic network device layer.
  @param skb Pointer to buffer containing the packet.
  @param dev Pointer to interface struct.
  @return 0 if packet consumed, !0 if packet rejected.
          Note: If we return !0, then the packet is free'd by
                the generic network layer.
	
	  Some sanity checks ...
	
	  If connection is not running, try to restart it
	  and throw away packet.
  netiucv_stats
  @dev: Pointer to interface struct.
  Returns interface statistics of a device.
  Returns pointer to stats struct of this interface.
  attributes in sysfs
 trailing lf, grr 
 username changed while the interface is active. 
		
		  The release function could be called after the
		  module has been unloaded. It's _only_ task is to
		  free the struct. Therefore, we specify kfree()
		  directly here. (Probably a little bit obfuscating
		  but legitime ...).
  Allocate and initialize a new connection structure.
  Add it to the list of netiucv connections;
  Release a connection structure and remove it from the
  list of netiucv connections.
  Release everything of a net device.
 privptr gets freed by free_netdev() 
  Initialize a net device. (Called from kernel in alloc_netdev())
  Allocate and initialize everything of a net device.
 sysfs magic 
 trailing lf, grr 
 SPDX-License-Identifier: GPL-2.0
  ISM driver for s390.
  Copyright IBM Corp. 2018
 hardware is V2 capable 
 SPDX-License-Identifier: GPL-2.0+
  IUCV special message driver
  Copyright IBM Corp. 2003, 2009
  Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com)
 Path pending from MSG. 
 Remove trailing whitespace from the sender name. 
 SPDX-License-Identifier: GPL-2.0
  A generic FSM based on fsm used in isdn4linux
 FIXME: this function is never used, why 
 SPDX-License-Identifier: GPL-2.0
  Copyright IBM Corp. 2001, 2007
  Authors:	Fritz Elfert (felfert@millenux.com)
  		Peter Tiedemann (ptiedem@de.ibm.com)
 	MPC additions :
 		Belinda Thompson (belindat@us.ibm.com)
 		Andy Richter (richtera@us.ibm.com)
	
	 additional MPC events
	
	 additional MPC states
  ----- static ctcm actions for channel statemachine -----
  ----- static ctcmpc actions for ctcmpc channel statemachine -----
 shared :
static void ctcm_chx_setmode(fsm_instance fi, int event, void arg);
static void ctcm_chx_start(fsm_instance fi, int event, void arg);
static void ctcm_chx_haltio(fsm_instance fi, int event, void arg);
static void ctcm_chx_stopped(fsm_instance fi, int event, void arg);
static void ctcm_chx_stop(fsm_instance fi, int event, void arg);
static void ctcm_chx_fail(fsm_instance fi, int event, void arg);
static void ctcm_chx_setuperr(fsm_instance fi, int event, void arg);
static void ctcm_chx_restart(fsm_instance fi, int event, void arg);
static void ctcm_chx_rxiniterr(fsm_instance fi, int event, void arg);
static void ctcm_chx_rxinitfail(fsm_instance fi, int event, void arg);
static void ctcm_chx_rxdisc(fsm_instance fi, int event, void arg);
static void ctcm_chx_txiniterr(fsm_instance fi, int event, void arg);
static void ctcm_chx_txretry(fsm_instance fi, int event, void arg);
static void ctcm_chx_iofatal(fsm_instance fi, int event, void arg);
  Check return code of a preceding ccw_device call, halt_IO etc...
  ch	:	The channel, the error belongs to.
  Returns the error code (!= 0) to inspect.
  NOP action for statemachines
  Actions for channel - statemachines.
  Normal data has been send. Free the corresponding
  skb (it's in io_queue), reset dev->tbusy and
  revert to idle state.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
  Initial data is sent.
  Notify device statemachine that we are up and
  running.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
  Got normal data, check for sanity, queue it up, allocate new buffer
  trigger bottom half, and initiate next read.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
	
	  VM TCP seems to have a bug sending 2 trailing bytes of garbage.
  Initialize connection by sending a __u16 of value 0.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
 reset unit check report control 
 OS390 resp. zOS 
	
	  Don't setup a timer for receiving the initial RX frame
	  if in compatibility mode, since VM TCP delays the initial
	  frame until it has some data to send.
 Transfer only length 
	
	  If in compatibility mode since we don't setup a timer, we
	  also signal RX channel up immediately. This enables us
	  to send packets early which in turn usually triggers some
	  reply from VM TCP which brings up the RX channel to it's
	  final state.
  Got initial data, check it. If OK,
  notify device statemachine that we are up and
  running.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
  Set channel into extended mode.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
 only for timer not yet locked 
			 Such conditional locking is undeterministic in
 see above comments 
  Setup channel.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
 jointed CE + DE 
  Shutdown a channel.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
 only for STOP not yet locked 
			 Such conditional locking is undeterministic in
 see remark above about conditional locking 
  Cleanup helper for chx_fail and chx_stopped
  cleanup channels queue and notify interface statemachine.
  fi		An instance of a channel statemachine.
  state	The next state (depending on caller).
  ch		The channel to operate on.
  A channel has successfully been halted.
  Cleanup it's queue and notify interface statemachine.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
  A stop command from device statemachine arrived and we are in
  not operational mode. Set state to stopped.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
  A machine check for no path, not operational status or gone device has
  happened.
  Cleanup queue and notify interface statemachine.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
  Handle error during setup of channel.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
	
	  Special case: Got UC_RCRESET on setmode.
	  This means that remote side isn't setup. In this case
	  simply retry after some 10 secs...
  Restart a channel after an error.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
 only for timer not yet locked 
			 Such conditional locking is a known problem for
			  sparse because its undeterministic in static view.
  Handle error during RX initial handshake (exchange of
  0-length block header)
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
 TODO : check if MPC deletes timer somewhere 
  Notify device statemachine if we gave up initialization
  of RX channel.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
  Handle RX Unit check remote reset (remote disconnected)
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
	
	  Notify device statemachine
  Handle error during TX channel initialization.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
  Handle TX timeout by retrying operation.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
		 call restart if not MPC or if MPC and mpcg fsm is ready.
 for TIMER not yet locked 
			 Such conditional locking is a known problem for
			  sparse because its undeterministic in static view.
  Handle fatal errors during an IO command.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
  The ctcm statemachine for a channel.
  MPC actions for mpc channel statemachine
  handling of MPC protocol requires extra
  statemachine and actions which are prefixed ctcmpc_ .
  The ctc_ch_states and ctc_ch_state_names,
  ctc_ch_events and ctc_ch_event_names share the ctcm definitions
  which are expanded by some elements.
  Actions for mpc channel statemachine.
  Normal data has been send. Free the corresponding
  skb (it's in io_queue), reset dev->tbusy and
  revert to idle state.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
 p_header points to the last one we handled 
Say it's the last one
 Normal data 
  Got normal data, check for sanity, queue it up, allocate new buffer
  trigger bottom half, and initiate next read.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
 avoids compiler warning 
 must have valid th header or game over 
 see remark about conditional locking 
  Initialize connection by sending a __u16 of value 0.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
  Got initial data, check it. If OK,
  notify device statemachine that we are up and
  running.
  fi		An instance of a channel statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from channel  upon call.
 avoids compiler warning 
 XID processing complete 
 see remark about conditional locking 
  ctcmpc channel FSM action
  called from several points in ctcmpc_ch_fsm
  ctcmpc only
 ok..start yside xid exchanges 
 attn rcvd before xid0 processed via bh 
		 attn rcvd before xid0 processed on ch
  ctcmpc channel FSM action
  called from one point in ctcmpc_ch_fsm
  ctcmpc only
 vtam wants to be primary.start yside xid exchanges
 only receive one attn-busy at a time so must not  
 change state each time			     
 process began via call to establish_conn	 
 so must report failure instead of reverting	 
 back to ready-for-xid passive state		 
 this attnbusy is NOT the result of xside xid  
 collisions so yside must have been triggered  
 by an ATTN that was not intended to start XID 
 processing. Revert back to ready-for-xid and  
 wait for ATTN interrupt to signal xid start	 
		 XID2 was received before ATTN Busy for second
		   channel.Send yside xid for second channel.
 multiple attn-busy indicates too out-of-sync      
 and they are certainly not being received as part 
 of valid mpc group negotiations..		     
  ctcmpc channel FSM action
  called from several points in ctcmpc_ch_fsm
  ctcmpc only
  ctcmpc channel FSM action
  called from several points in ctcmpc_ch_fsm
  ctcmpc only
 give the previous IO time to complete 
 send out the sweep 
  The ctcmpc statemachine for a channel.
  Actions for interface - statemachine.
  Startup channels by sending CTC_EVENT_START to each channel.
  fi		An instance of an interface statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from struct net_device  upon call.
  Shutdown channels by sending CTC_EVENT_STOP to each channel.
  fi		An instance of an interface statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from struct net_device  upon call.
 going back into start sequence too quickly can	  
 result in the other side becoming unreachable   due	  
 to sense reported when IO is aborted			  
  Called from channel statemachine
  when a channel is up and running.
  fi		An instance of an interface statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from struct net_device  upon call.
  Called from device statemachine
  when a channel has been shutdown.
  fi		An instance of an interface statemachine.
  event	The event, just happened.
  arg		Generic pointer, casted from struct net_device  upon call.
 --- This is the END my friend --- 
 SPDX-License-Identifier: GPL-2.0
     Copyright IBM Corp. 2007
     Author(s): Utz Bacher <utz.bacher@de.ibm.com>,
 		 Frank Pavlic <fpavlic@de.ibm.com>,
 		 Thomas Spatzier <tspat@de.ibm.com>,
 		 Frank Blaschka <frank.blaschka@de.ibm.com>
	 check if 1920 devices are supported ,
	  if though we have to permit priority queueing
 fixed layer, can't switch 
 start with a new, pristine netdevice: 
 parse input into isolation mode 
 SPDX-License-Identifier: GPL-2.0
     Copyright IBM Corp. 2007
     Author(s): Utz Bacher <utz.bacher@de.ibm.com>,
 		 Frank Pavlic <fpavlic@de.ibm.com>,
 		 Thomas Spatzier <tspat@de.ibm.com>,
 		 Frank Blaschka <frank.blaschka@de.ibm.com>
 delete old ip address 
 delete ip address only 
 Append %mask to the entry: 
 Enough room to format %entry\n into null terminated page? 
 Expected input pattern: %addr%mask 
 Terminate the %addr sub-string, and parse it: 
 Enough room to format %addr\n into null terminated page? 
 SPDX-License-Identifier: GPL-2.0
 	Copyright IBM Corp. 2001, 2007
 	Authors:	Peter Tiedemann (ptiedem@de.ibm.com)
  Debug Facility Stuff
 register the areas 
 register a view 
 set a passing level 
 SPDX-License-Identifier: GPL-2.0
     Copyright IBM Corp. 2007, 2009
     Author(s): Utz Bacher <utz.bacher@de.ibm.com>,
 		 Frank Pavlic <fpavlic@de.ibm.com>,
 		 Thomas Spatzier <tspat@de.ibm.com>,
 		 Frank Blaschka <frank.blaschka@de.ibm.com>
 define dbf - Name, Pages, Areas, Maxlen, Level, View, Handle 
                   N  P  A    M  L  V                      H  
 max length to be returned: 14 
 Defer until queue is allocated: 
 Remove entries from the pool: 
 Allocate additional entries: 
 keep the cmd alive after completion: 
 handle unsolicited event: 
 Set offline, then probably fail to set online: 
 stay online for subsequent STARTLAN 
 match against pending cmd requests 
 take the object outside the lock 
 Bail out when the requestor has already left: 
 while we hold the ccwdev lock, this stays valid: 
 IO was terminated, free its resources. 
 sanity check: 
 Empty buffer? 
 is PCI flag set on buffer? 
 clear outbound buffers to free skbs 
 CHPP field bit 6 == 1 -> single queue 
 inbound 
 IP address takeover 
 Determine whether the device requires a specific layer discipline 
 MPC cmds are issued strictly in sequence. 
  qeth_send_control_data() -	send control command to the card
  @card:			qeth_card structure pointer
  @iob:			qeth_cmd_buffer pointer
  @reply_cb:			callback function pointer
   cb_card:			pointer to the qeth_card structure
   cb_reply:			pointer to the qeth_reply structure
   cb_cmd:			pointer to the original iob for non-IPA
 				commands, or to the qeth_ipa_cmd structure
 				for the IPA commands.
  @reply_param:		private pointer passed to the callback
  Callback function gets called one or more times, with cb_cmd
  pointing to the response returned by the hardware. Callback
  function must return
    > 0 if more reply blocks are expected,
      0 if the last or only reply block is received, and
    < 0 on error.
  Callback function can get the value of the reply_param pointer from the
  field 'param' of the structure qeth_reply.
 This pairs with iob->callback, and keeps the iob alive after IO: 
 Wait until the callback for a late reply has completed: 
 Zap any callback that's still pending: 
 scan for RCD command in extended SenseID data 
 negative reply: 
 IQD needs accurate max MTU to set up its RX buffers: 
 tolerate quirky HW: 
 move any device with default MTU to new max MTU: 
 adjust RX buffer size to new max MTU: 
 default MTUs for first setup: 
 allow for LLC + SNAP 
 inbound buffer pool 
 outbound 
 completion 
 inbound buffer pool 
 free outbound qdio_qs 
 Prio-queueing implicitly uses the default priorities: 
		 VM will use a non-zero first character
		  to indicate a HiperSockets like reporting
		  of the level OSA sets the first character to zero
 no free buffer in pool so take first one and swap pages 
	
	  since the buffer is accessed only from the input_tasklet
	  there shouldn't be a need to synchronize; also, since we use
	  the QETH_IN_BUF_REQUEUE_THRESHOLD we should never run  out off
	  buffers
 inbound queue 
give only as many buffers to hardware as we have buffer pool entries
 completion 
 outbound queue 
 override with IPA-specific values: 
 hdr->seqno is set by qeth_send_control_data() 
  qeth_send_ipa_cmd() - send an IPA command
  See qeth_send_control_data() for explanation of the arguments.
 only requeue at a certain threshold to avoid SIGAs 
			 we are in memory shortage so we switch back to
 kick-start the NAPI softirq: 
  qeth_prep_flush_pack_buffer - Prepares flushing of a packing buffer.
  @queue: queue to check for packing buffer
  Returns number of buffers that were prepared for flush.
 it's a packing buffer 
  Switched to packing state if the number of used buffers on a queue
  reaches a certain limit.
 switch non-PACKING -> PACKING 
  Switches from packing to non-packing mode. If there is a packing
  buffer on the queue this buffer will be prepared to be flushed.
  In that case 1 is returned to inform the caller. If no buffer
  has to be flushed, zero is returned.
 switch PACKING -> non-PACKING 
				 it's likely that we'll go to packing
				
				  there's no outstanding PCI any more, so we
				  have to request a PCI to be sure the the PCI
				  will wake at some time in the future then we
				  can flush packed buffers that might still be
				  hanging around, which can happen if no
				  further send was requested by the stack
 ignore temporary SIGA errors without busy condition 
 Fake the TX completion interrupt: 
 Old behaviour carried over from the qdio layer: 
		 this must not happen under normal circumstances. if it
	
	  check if weed have to switch to non-packing mode or if
	  we have to get a pci flag out on the queue
  Note: Function assumes that we have 4 outbound queues.
  qeth_get_elements_for_frags() -	find number of SBALEs for skb frags.
  @skb:				SKB address
  Returns the number of pages, and thus QDIO buffer elements, needed to cover
  fragmented part of the SKB. Returns zero for linear SKB.
  qeth_count_elements() -	Counts the number of QDIO buffer elements needed
 				to transmit an skb.
  @skb:			the skb to operate on.
  @data_offset:		skip this part of the skb's linear data
  Returns the number of pages, and thus QDIO buffer elements, needed to map the
  skb's data (both its linear part and paged fragments).
  qeth_add_hw_header() - add a HW header to an skb.
  @queue: TX queue that the skb will be placed on.
  @skb: skb that the HW header should be added to.
  @hdr: double pointer to a qeth_hdr. When returning with >= 0,
 	 it contains a valid pointer to a qeth_hdr.
  @hdr_len: length of the HW header.
  @proto_len: length of protocol headers that need to be in same page as the
 	       HW header.
  @elements: returns the required number of buffer elements for this skb.
  Returns the pushed length. If the header can't be pushed on
  (eg. because it would cross a page boundary), it is allocated from
  the cache instead and 0 is returned.
  The number of needed buffer elements is returned in @elements.
  Error to create the hdr is indicated by returning with < 0.
 Push HW header into same page as first protocol header. 
 ... but TSO always needs a separate element for headers: 
 Push HW header into preceding page, flush with skb->data. 
 Use header cache, copy protocol headers up. 
 Compress skb to fit into one IO buffer: 
 Drop it, no easy way of shrinking it further. 
 Linearization changed the layout, re-evaluate: 
 Add the header: 
 Fall back to cache element with known-good alignment: 
 Copy protocol headers behind HW header: 
 All packets must have the same target: 
  qeth_fill_buffer() - map skb into an output buffer
  @buf:	buffer to transport the skb
  @skb:	skb to map into the buffer
  @hdr:	qeth_hdr for this skb. Either at skb->data, or allocated
 		from qeth_core_header_cache.
  @offset:	when mapping the skb, start at skb->data + offset
  @hd_len:	if > 0, build a dedicated header element of this size
 build dedicated element for HW Header 
 HW header is allocated from cache: 
 HW header was pushed and is contiguous with linear part: 
 map linear part into buffer element(s) 
 skb needs additional elements 
 map page frags into buffer element(s) 
	 Just a sanity check, the wakestop logic should ensure that we always
	  get a free buffer.
 Sanity-check again: 
		 If a TX completion happens right _here_ and misses to wake
		  the txq, then our re-check below will catch the race.
	 Just a sanity check, the wakestop logic should ensure that we always
	  get a free buffer.
 check if we need to switch packing state of this queue 
 does packet fit in current buffer? 
 ... no -> set state PRIMED 
 We stepped forward, so sanity-check again: 
		 If a TX completion happens right _here_ and misses to wake
		  the txq, then our re-check below will catch the race.
 HW header needs its own buffer element. 
 TODO: drop skb_orphan() once TX completion is fast enough 
 benign error while disabling ISOLATION_MODE_FWD 
 Basic mode control register 
 Basic mode status register 
 PHYS ID 1 
 PHYS ID 2 
 Advertisement control reg 
 Link partner ability reg 
 Expansion register 
 disconnect counter 
 false carrier counter 
 N-way auto-neg test register 
 rx error counter 
 silicon revision 
 reserved 1 
 loopback, rx, bypass error 
 physical address 
 reserved 2 
 TPI status for 10mbps 
 network interface config 
 check if there is enough room in userspace 
copy entries to user buffer
 Sanitize user input, to avoid overflows in iob size calculation: 
 Multi-part reply is unexpected, don't bother: 
 Expect the reply to start with phys_if data: 
 Get more accurate data via QUERY OAT: 
  qeth_vm_request_mac() - Request a hypervisor-managed MAC address
  @card: pointer to a qeth_card
  Returns
 	0, if a MAC address has been set for the card's netdevice
 	a return code, for various error conditions
 no need for locking  error handling at this early stage: 
 let user_space know that device is online 
 cancel any stalled cmd that might block the rtnl: 
 let user_space know that device is offline 
 Lock-free, other users will block until we are done. 
 copy VLAN tag from hdr into skb 
 never happens 
 qeth_hdr must not cross element boundaries 
 Can't determine packet length, drop the whole buffer. 
 QETH_CQ_ENABLED only: 
 -ENOMEM, no point in falling back further. 
 Shouldn't happen. Don't optimize, fall back to linear skb. 
 Extract data from current element: 
 Step forward to next element: 
 This packet was skipped, go get another one: 
 Fetch completed RX buffers: 
 Process one completed RX buffer: 
 Step forward to next buffer: 
 Process any substantial refill backlog: 
 Exhausted the RX budget. Keep IRQ disabled, we get called again. 
 QAOB hasn't completed yet: 
 Prepare the queue slot for immediate re-use: 
 Skip clearing the buffer: 
 QAOB already completed: 
 Give the CPU a breather: 
 Ensure we see TX completion for pending work: 
		 xmit may have observed the full-condition, but not yet
		  stopped the txq. In which case the code below won't trigger.
		  So before returning, xmit will re-check the txq's fill level
		  and wake it up if needed.
 register the areas 
 register a view 
 set a passing level 
 for synchronized module loading 
 initialized when device first goes online: 
 It's so early that we don't need the discipline_mutex yet. 
 some L3 HW requires combined L3+L4 csum offload: 
 enable TSO capability 
 noone Offload Assist available, so the rc is trivial 
 enable: success if any Assist is active 
 disable: failure if any Assist is still active 
  qeth_enable_hw_features() - (Re-)Enable HW functions for device features
  @dev:	a net_device
	 force-off any feature that might need an IPA sequence.
	  netdev_update_features() will restart them.
 toggle VLAN filter, so that VIDs are re-programmed: 
 everything changed successfully? 
 something went wrong. save changed features and return error 
 Traffic with local next-hop is not eligible for some offloads: 
	 GSO segmentation builds skbs with
	 	a (small) linear part for the headers, and
	 	page frags for the data.
	  Compared to a linear skb, the header-only part consumes an
	  additional buffer element. This reduces buffer utilization, and
	  hurts throughput. So compress small segments into one element.
 match skb_segment(): 
 linearize only if resulting skb allocations are order-0: 
	 IQD requires mcast traffic to be placed on a dedicated queue, and
	  qeth_iqd_select_queue() deals with this.
	  For unicast traffic, we defer the queue selection to the stack.
	  By installing a trivial prio map that spans over only the unicast
	  queues, we can encourage the stack to spread the ucast traffic evenly
	  without selecting the mcast queue.
 One traffic class, spanning over all active ucast queues: 
 Map all priorities to this traffic class: 
 Per netif_setup_tc(), adjust the mapping first: 
 kick-start the NAPI softirq: 
 Quiesce the NAPI instances: 
 Stop .ndo_start_xmit, might still access queue->napi. 
 Queues may get re-allocated, so remove the NAPIs. 
 SPDX-License-Identifier: GPL-2.0
     Copyright IBM Corp. 2013
     Author(s): Eugene Crosser <eugene.crosser@ru.ibm.com>
 Forbid direct manipulation 
 sbp_lock ensures ordering vs notifications-stopped events 
 VNIC CHARS support 
 convert sysfs attr name to VNIC characteristic 
 get current timeout setting 
 change timeout setting 
 get current setting of characteristic 
 change setting of characteristic 
 SPDX-License-Identifier: GPL-2.0
  Copyright IBM Corp. 2001, 2009
  Author(s):
 	Original CTC driver(s):
 		Fritz Elfert (felfert@millenux.com)
 		Dieter Wellerdiek (wel@de.ibm.com)
 		Martin Schwidefsky (schwidefsky@de.ibm.com)
 		Denis Joseph Barrow (barrow_dj@yahoo.com)
 		Jochen Roehrig (roehrig@de.ibm.com)
 		Cornelia Huck <cornelia.huck@de.ibm.com>
 	MPC additions:
 		Belinda Thompson (belindat@us.ibm.com)
 		Andy Richter (richtera@us.ibm.com)
 	Revived by:
 		Peter Tiedemann (ptiedem@de.ibm.com)
 Some common global variables 
  The root device for ctcm group devices
  Linked list of all detected channels.
  Unpack a just received skb and hand it over to
  upper layers.
   ch		The channel where this skb has been received.
   pskb	The received skb.
				
				  Check packet type only if we stick strictly
				  to S390's protocol of OS390. This only
				  supports IP. Otherwise allow any packet
				  type.
		
		  reset logflags
  Release a specific channel in the channel list.
   ch		Pointer to channel struct to be released.
  Remove a specific channel in the channel list.
   ch		Pointer to channel struct to be released.
  Get a specific channel from the channel list.
   type	Type of channel we are interested in.
   id		Id of channel we are interested in.
   direction	Direction we want to use this channel for.
  returns Pointer to a channel or NULL if no matching channel available.
  Check sense of a unit check.
   ch		The channel, the sense code belongs to.
   sense	The sense code to inspect.
 data-streaming timeout 
 Data-transfer parity error 
  Interface API for upper network layers
  Open an interface.
  Called from generic network layer when ifconfig up is run.
   dev		Pointer to interface struct.
  returns 0 on success, -ERRNO on failure. (Never fails.)
  Close an interface.
  Called from generic network layer when ifconfig down is run.
   dev		Pointer to interface struct.
  returns 0 on success, -ERRNO on failure. (Never fails.)
  Transmit a packet.
  This is a helper function for ctcm_tx().
   ch		Channel to be used for sending.
   skb		Pointer to struct sk_buff of packet to send.
             The linklevel header has already been set up
             by ctcm_tx().
  returns 0 on success, -ERRNO on failure. (Never fails.)
	 we need to acquire the lock for testing the state
	  otherwise we can have an IRQ changing the state to
	  TXIDLE after the test but before acquiring the lock.
	
	  Protect skb against beeing free'd by upper
	  layers.
	
	  IDAL support in CTCM is broken, so we have to
	  care about skb's above 2G ourselves.
		
		  idal allocation failed, try via copying to
		  trans_skb. trans_skb usually has a pre-allocated
		  idal.
			
			  Remove our header. It gets added
			  again on retransmit.
		
		  Remove our header. It gets added
		  again on retransmit.
 int rc = 0; 
 sweep processing is not complete until response and request 
 has completed for all read channels in group		       
 rc = -ENOMEM; 
 0x0f 
  MPC mode version of transmit_skb
 avoids compiler warning 
	
	  Protect skb against beeing free'd by upper
	  layers.
	
	  IDAL support in CTCM is broken, so we have to
	  care about skb's above 2G ourselves.
 put the TH on the packet 
 Normal data 
		
		  idal allocation failed, try via copying to trans_skb.
		  trans_skb usually has a pre-allocated idal.
			
			  Remove our header.
			  It gets added again on retransmit.
 Chose at random. 
  Start transmission of a packet.
  Called from generic network device layer.
   skb		Pointer to buffer containing the packet.
   dev		Pointer to interface struct.
  returns 0 if packet consumed, !0 if packet rejected.
          Note: If we return !0, then the packet is free'd by
                the generic network layer.
 first merge version - leaving both functions separated 
	
	  If channels are not running, try to restart them
	  and throw away packet.
 unmerged MPC variant of ctcm_tx 
	
	  Some sanity checks ...
	
	  If channels are not running,
	  notify anybody about a link failure and throw
	  away packet.
 handle freeing of skb here 
  Sets MTU of an interface.
   dev		Pointer to interface struct.
   new_mtu	The new MTU to use for this interface.
  returns 0 on success, -EINVAL if MTU is out of valid range.
          (valid range is 576 .. 65527). If VM is on the
          remote side, maximum MTU is 32760, however this is
          not checked here.
  Returns interface statistics of a device.
   dev		Pointer to interface struct.
  returns Pointer to stats struct of this interface.
	
	  Note: kfree(priv); is done in "opposite" function of
	  allocator function probe_device which is remove_device.
  Initialize everything of the net device except the name and the
  channel structs.
  MPC Group Initializations  
  Main IRQ handler.
   cdev	The ccw_device the interrupt is for.
   intparm	interruption parameter.
   irb		interruption response block.
 Check for unsolicited interrupts. 
 Try to extract channel from driver data. 
 Explain: inconsistent internal structures 
 Explain: inconsistent internal structures 
 Copy interruption response block. 
 Issue error message and return on subchannel error code 
 Check the reason-code of a unit check 
 print it only once 
  Add ctcm specific attributes.
  Add ctcm private data.
   cgdev	pointer to ccwgroup_device just added
  returns 0 on success, !0 on failure.
  Add a new channel to the list of channels.
  Keeps the channel list sorted.
   cdev	The ccw_device to be added.
   type	The type class of the new channel.
   priv	Points to the private data of the ccwgroup_device.
  returns 0 on success, !0 on error.
	
	  "static" ccws are used in the following way:
	 
	  ccw[0..2] (Channel program for generic IO):
	            0: prepare
	            1: read or write (depending on direction) with fixed
	               buffer (idal allocated once when buffer is allocated)
	            2: nop
	  ccw[3..5] (Channel program for direct write of packets)
	            3: prepare
	            4: write (idal allocated on every write).
	            5: nop
	  ccw[6..7] (Channel program for initial channel setup):
	            6: set extended mode
	            7: nop
	 
	  ch->ccw[0..5] are initialized in ch_action_start because
	  the channel's direction is yet unknown here.
	 
	  ccws used for xid2 negotiations
	   ch-ccw[8-14] need to be used for the XID exchange either
	     X side XID2 Processing
	        8:  write control
	        9:  write th
	 	     10: write XID
	 	     11: read th from secondary
	 	     12: read XID   from secondary
	 	     13: read 4 byte ID
	 	     14: nop
	     Y side XID Processing
	 	     8:  sense
	        9:  read th
	 	     10: read XID
	 	     11: write th
	 	     12: write XID
	 	     13: write 4 byte ID
	 	     14: nop
	 
	   ccws used for double noop due to VM timing issues
	   which result in unrecoverable Busy on channel
	        15: nop
	        16: nop
 note that all channel pointers are 0 or valid 
  Return type of a detected device.
  Setup an interface.
   cgdev	Device to be setup.
  returns 0 on success, !0 on failure.
 sysfs magic 
  Shutdown an interface.
   cgdev	Device to be shut down.
  returns 0 on success, !0 on failure.
 Close the device 
  Module related routines
  Prepare to be unloaded. Free IRQ's and release all resources.
  This is called just before this module is unloaded. It is
  not called, if the usage count is !0, so we don't need to check
  for that.
  Print Banner.
  Initialize module.
  This is called just after the module is loaded.
  returns 0 on success, !0 on error.
 SPDX-License-Identifier: GPL-2.0+
   Linux for S390 Lan Channel Station Network Driver
   Copyright IBM Corp. 1999, 2009
   Author(s): Original Code written by
 			DJ Barrow <djbarrow@de.ibm.com,barrow_dj@yahoo.com>
 	       Rewritten by
 			Frank Pavlic <fpavlic@de.ibm.com> and
 			Martin Schwidefsky <schwidefsky@de.ibm.com>
  initialization string for output
   the root device for lcs group devices
  Some prototypes.
 CONFIG_IP_MULTICAST 
  Debug Facility Stuff
   LCS Debug Facility functions
  Allocate io buffers.
 alloc memory fo iobuffer 
 Not all io buffers could be allocated. 
  Free io buffers.
  Cleanup channel.
 Kill write channel tasklets. 
 Free channel buffers. 
  LCS free memory for card and channels.
  LCS alloc memory for card and channels
 Allocate io buffers for the read channel. 
 Allocate io buffers for the write channel. 
  Setup read channel.
 Setup read ccws. 
		
		  Note: we have allocated the buffer with GFP_DMA, so
		  we do not need to do set_normalized_cda.
 Last ccw is a tic (transfer in channel). 
 Setg initial state of the read channel. 
 Initialize read channel tasklet. 
 Initialize waitqueue. 
  Setup write channel.
 Setup write ccws. 
		
		  Note: we have allocated the buffer with GFP_DMA, so
		  we do not need to do set_normalized_cda.
 Last ccw is a tic (transfer in channel). 
 Set initial state of the write channel. 
 Initialize write channel tasklet. 
 Initialize waitqueue. 
  Initialize channels,card and state machines.
 Set cards initial state. 
 Free multicast list. 
  Cleanup channels,card and state machines.
 Cleanup channels. 
  Start channel.
  Stop channel.
 Asynchronous halt initialted. Wait for its completion. 
  start read and write channel
 start read channel 
 start write channel 
  stop read and write channel
  Get empty buffer.
  Resume channel program if the channel is suspended.
  Make a buffer ready for processing.
 Check if we may clear the suspend bit of this buffer. 
 Check if we have to set the PCI bit. 
 Suspend bit of the previous buffer is not set. 
 Suspend bit of the next buffer is set. 
 Set length. 
 Check relevant PCIsuspend bits. 
  Mark the buffer as processed. Take care of the suspend bit
  of the previous buffer. This function is called from
  interrupt context, so the lock must not be taken.
 Set the suspend bit and clear the PCI bit of this buffer. 
 Check the suspend bit of the previous buffer. 
		
		  Previous buffer is in state ready. It might have
		  happened in lcs_ready_buffer that the suspend bit
		  has not been cleared to avoid an endless loop.
		  Do it now.
 Clear PCI bit of next buffer. 
  Put a processed buffer back to state empty.
  Get buffer for a lan command.
 Get buffer and wait if none is available. 
  Notifier function for lancmd replies. Called from read irq.
  Emit buffer of a lan command.
  LCS startup command
  LCS shutdown command
  LCS lanstat command
 Setup lanstat command. 
  send stoplan command
  send startlan command
  send setipm command (Multicast)
  send delipm command (Multicast)
  check if multicast is supported by LCS
 Send query ipassist. 
  set or del multicast address on LCS card
			 del from ipm_list so no one else can tamper with
				 store ipm in failed list -> will be added
				  to ipm_list again, so a retry will be done
 re-insert into ipm_list 
 re-insert all entries from the failed_list into ipm_list 
  get mac address for the relevant Multicast address
  function called by net device to handle multicast address relevant things
 Address already in list. 
 CONFIG_IP_MULTICAST 
  function called by net device to
  handle multicast address relevant things
 CONFIG_IP_MULTICAST 
  IRQ Handler for LCS channels
 Check for channel and device errors presented 
 How far in the ccw chain have we processed? 
 Bloody io subsystem tells us lies about cpa... 
 Mark channel as stopped. 
 CCW execution stopped on a suspend bit. 
 The channel has been stopped by halt_IO. 
 Do the rest in the tasklet. 
  Tasklet for IRQ handler
 Check for processed buffers. 
 Do the callback thing. 
 Something happened on the channel. Wake up waiters. 
  Finish current tx buffer and make it ready for transmit.
  Callback for finished tx buffers.
 Put buffer back to pool. 
		
		  Last running tx buffer has finished. Submit partially
		  filled current buffer.
  Packet transmit function called by network stack
 skb too big for current tx buffer. 
 Get new tx buffer 
 If this is the first tx buffer emit it immediately. 
  send startlan and lanstat command to make LCS device ready
 autodetecting lan type 
  LCS detect function
  setup channels and make them IO ready
 startreset card 
  LCS Stop card
  Kernel Thread helper functions for LGW initiated commands
  Process control frames.
  Unpack network packet.
 The card isn't up. Ignore the packet. 
  LCS main routine to get packets and lancmd replies from the buffers
 Offset invalid. 
 What kind of frame is it? 
 Control frame. 
 Normal network packet. 
 Unknown frame type. 
 FIXME: error message ?
 Proceed to next frame. 
 The buffer is now empty. Make it ready again. 
  get network statistics for ifconfig and other user programs
  stop lcs device
  This function will be called by user doing ifconfig xxx down
  start lcs device and make it runnable
  This function will be called by user doing ifconfig xxx up
 initialize statistics 
  show function for portno called by cat or similar things
  store the value which is piped to file portno
 TODO: sanity checks 
 TODO: sanity checks 
  lcs_probe_device is called on establishing a new ccwgroup_device.
  lcs_new_device will be called by setting the group device online.
 Print out supported assists: IPv6 
 Print out supported assist: Multicast 
  lcs_shutdown_device, called when setting the group device offline.
  drive lcs recovery after startup and startlan initiated by Lan Gateway
  lcs_remove_device, free buffers and card
  LCS ccwgroup driver registration
   LCS ModuleKernel initialization function
   LCS module cleanup function
 SPDX-License-Identifier: GPL-2.0
 	Copyright IBM Corp. 2004, 2007
 	Authors:	Belinda Thompson (belindat@us.ibm.com)
 			Andy Richter (richtera@us.ibm.com)
 			Peter Tiedemann (ptiedem@de.ibm.com)
	This module exports functions to be used by CCS:
	EXPORT_SYMBOL(ctc_mpc_alloc_channel);
	EXPORT_SYMBOL(ctc_mpc_establish_connectivity);
	EXPORT_SYMBOL(ctc_mpc_dealloc_ch);
	EXPORT_SYMBOL(ctc_mpc_flow_control);
 instead of <asmio.h> ok ? 
 instead of <asmbitops.h> ok ? 
 instead of <asmuaccess.h> ok ? 
  Definition of one MPC group
  Compatibility macros for busy handling
  of network devices.
  MPC Group state machine actions (static prototypes)
-------------------------------------------------------------------
 Dump buffer format						     
								     
 endfor 
	 end of ctcmpc_dumpit  
  Dump header and first 16 bytes of an sk_buff for debugging purposes.
  skb		The sk_buff to dump.
  offset	Offset relative to skb-data, where to start the dump.
  ctc_mpc_alloc_channel
 	(exported interface)
  Device Initialization :
 	ACTPATH  driven IO operations
 Group is in the process of terminating 
 MPC Group will transition to state		  
 MPCG_STATE_XID2INITW iff the minimum number	  
 of 1 read and 1 write channel have successfully
 activated					  
fsm_newstate(grp->fsm, MPCG_STATE_XID2INITW);
 XID exchanges completed after PORT was activated 
 Link station already active			    
 Maybe timing issue...retry callback		    
 there are problems...bail out	    
 there may be a state mismatch so restart 
  ctc_mpc_establish_connectivity
 	(exported interface)
 XID exchanges completed after PORT was activated 
 Link station already active			    
 Maybe timing issue...retry callback		    
 there are problems...bail out	 
 MPC Group is not ready to start XID - min num of 
 1 read and 1 write channel have not been acquired
 alloc channel was called but no XID exchange    
 has occurred. initiate xside XID exchange	   
 make sure yside XID0 processing has not started 
 already in active XID negotiations 
  ctc_mpc_dealloc_ch
 	(exported interface)
  ctc_mpc_flow_control
 	(exported interface)
 ensure any data that has accumulated 
 on the io_queue will now be sen t	
 possible race condition			
  helper function of ctcmpc_unpack_skb
  helper function of mpc_rcvd_sweep_req
  which is a helper of ctcmpc_unpack_skb
  helper function of ctcmpc_unpack_skb
   MPC Group Station FSM definitions
  The MPC Group Station FSM
    22 events
  MPC Group Station FSM action
  CTCM_PROTO_MPC only
  helper of ctcm_init_netdevice
  CTCM_PROTO_MPC only
 Put up a read on the channel 
 Put the write channel in idle state 
  Increment the MPC Group Active Channel Counts
  helper of dev_action (called from channel fsm)
  Unpack a just received skb and hand it over to
  upper layers.
  special MPC version of unpack_skb.
  ch		The channel where this skb has been received.
  pskb		The received skb.
 nothing for us 	goto done;
			 This is NOT the next segment		
			  we are not the correct race winner	
			  go away and let someone else win	
			  BUT..this only applies if xid negot	
			  is done				
 should never happen		    
 pskb len must be hosed...bail out 
 "data may be lost", 
 point to next PDU 
  it's a sweep?   
 mpcginfo only used for non-data transfers 
  tasklet helper for mpc's skb unpacking.
  ch		The channel to work on.
  Allow flow control back pressure to occur here.
  Throttling back channel can result in excessive
  channel inactivity and system deact of channel
 caller has requested driver to throttle back 
 assume data loss has occurred if 
 missing seq_num for extended     
 period of time		    
   MPC Group Initializations
  base xid for all channels in group  
  The MPC Group Station FSM
  MPC Group Station FSM actions
  CTCM_PROTO_MPC only
  NOP action for statemachines
  invoked when the device transitions to dev_stopped
  MPC will stop each individual channel if a single XID failure
  occurs, or will intitiate all channels be stopped if a GROUP
  level failure occurs.
 dealloc_channel has been called 
min of all received 
 DO NOT issue DEV_EVENT_STOP directly out of this code 
 This can result in INOP of VTAM PU due to halting of  
 outstanding IO which causes a sense to be returned	 
 Only about 3 senses are allowed and then IOSVTAM will
 become unreachable without manual intervention	 
  Handle mpc group  action timeout.
  MPC Group Station FSM action
  CTCM_PROTO_MPC only
  fi		An instance of an mpc_group fsm.
  event	The event, just happened.
  arg		Generic pointer, casted from net_device  upon call.
 Unless there is outstanding IO on the  
 channel just return and wait for ATTN  
 interrupt to begin XID negotiations	  
  MPC Group Station FSM action
  CTCM_PROTO_MPC only
  MPC Group Station - not part of FSM
  CTCM_PROTO_MPC only
  called from add_channel in ctcm_main.c
  helper function of mpc FSM
  CTCM_PROTO_MPC only
  mpc_action_rcvd_xid7
 XID REJECTED: xid == NULL 
the received direction should be the opposite of ours  
 XID REJECTED: rw channel pairing mismatch 
 convert two 32 bit numbers into 1 64 bit for id compare 
 lower id assume the xside role 
 XID REJECTED: xid flag byte4 mismatch 
 XID REJECTED - xid NOGOOD 
 XID REJECTED - Adjacent Station ID Mismatch 
 XID REJECTED - Sender Address Mismatch 
  MPC Group Station FSM action
  CTCM_PROTO_MPC only
	unsigned long saveflags = 0;	 avoids compiler warning with
	
	  skb data-buffer referencing:
	 result of the previous 3 statements is NOT always
	  already set after ctcm_checkalloc_buffer
	  because of possible reuse of the trans_skb
 check is main purpose here: 
 check is main purpose here: 
 cleanup back to startpoint 
 non-checking rewrite of above skb data-buffer referencing: 
	
	memset(ch->trans_skb->data, 0, 16);
	ch->rcvd_xid_th =  (struct th_header )ch->trans_skb_data;
	ch->rcvd_xid = (struct xid2 )(ch->trans_skb_data + TH_HEADER_LENGTH);
	ch->rcvd_xid_id = ch->trans_skb_data + TH_HEADER_LENGTH + XID2_LENGTH;
 mpc_action_xside_xid 
 side == YSIDE : mpc_action_yside_xid 
			  Such conditional locking is a known problem for
			   sparse because its static undeterministic.
 see remark above about conditional locking 
  MPC Group Station FSM action
  CTCM_PROTO_MPC only
  MPC Group Station FSM action
  CTCM_PROTO_MPC only
  MPC Group Station FSM action
  CTCM_PROTO_MPC only
  MPC Group Station FSM action
  CTCM_PROTO_MPC only
 xid7 phase 1 
 xid7 phase 2 
  MPC Group Station FSM action
  CTCM_PROTO_MPC only
 must change state before validating xid to 
 properly handle interim interrupts received
  MPC Group Station FSM action
  CTCM_PROTO_MPC only
  mpc_action helper of an MPC Group Station FSM action
  CTCM_PROTO_MPC only
	
	  establish conn callback function is
	  preferred method to report failure
		 receipt of CC03 resets anticipated sequence number on
 --- This is the END my friend --- 
 SPDX-License-Identifier: GPL-2.0
     Copyright IBM Corp. 2007, 2009
     Author(s): Utz Bacher <utz.bacher@de.ibm.com>,
 		 Frank Pavlic <fpavlic@de.ibm.com>,
 		 Thomas Spatzier <tspat@de.ibm.com>,
 		 Frank Blaschka <frank.blaschka@de.ibm.com>
 set byte byte 3 to casting flags 
	 VSWITCH relies on the VLAN
	  information to be present in
 flush all VLANs: 
 fall back to alternative mechanism: 
	 Fall back once more, but some devices don't support a custom MAC
	  address:
 don't register the same address twice 
 add the new address, switch over, drop the old 
 New MAC address is added to the hash table and marked to be written on card
  only if there is not in the hash table storage already
 for next call to set_rx_mode(): 
 	qeth_l2_pnso() - perform network subchannel operation
 	@card: qeth_card structure pointer
 	@oc: Operation Code
 	@cnc: Boolean Change-Notification Control
 	@cb: Callback function will be executed for each element
 		of the address list
 	@priv: Pointer to pass to the callback function.
 	Collects network information in a network address list and calls the
 	callback function for every entry in the list. If "change-notification-
 	control" is set, further changes in the address list will be reported
 	via the IPA command.
 on the first iteration, naihdr.resume_token will be zero 
 Inform the caller that they need to scrap 
 the data that was already reported via cb 
 list stored 
 resume token is non-zero => list incomplete 
 	qeth_l2_dev2br_fdb_notify() - update fdb of master bridge
 	@card:	qeth_card structure pointer
 	@code:	event bitmask: high order bit 0x80 set to
 				1 - removal of an object
 				0 - addition of an object
 			       Object type(s):
 				0x01 - VLAN, 0x02 - MAC, 0x03 - VLAN and MAC
 	@token: "network token" structure identifying 'physical' location
 		of the target
 	@addr_lnid: structure with MAC address and VLAN ID of the target
 Ignore VLAN only changes 
 Ignore mcast entries 
 Ignore my own addresses 
 don't report VLAN IDs 
 	qeth_l2_dev2br_an_set() -
 	Enable or disable 'dev to bridge network address notification'
 	@card: qeth_card structure pointer
 	@enable: Enable or disable 'dev to bridge network address notification'
 	Returns negative errno-compatible error indication or 0 on success.
 	On enable, emits a series of address notifications for all
 	currently registered hosts.
			 address notification enabled, but inconsistent
			  addresses reported -> disable address notification
 	qeth_l2_br2dev_worker() - update local MACs
 	@work: bridge to device FDB update
 	Update local MACs of a learning_sync bridgeport so it can receive
 	messages for a destination port.
 	In case of an isolated learning_sync port, also update its isolated
 	siblings.
 Verify preconditions are still valid: 
 Update lsyncdev and its isolated sibling(s): 
 Take a reference on the sw port devices and the bridge 
 Called under rtnl_lock 
 Called under rtnl_lock 
 Called under rtnl_lock 
 Do not even show qeth devs that cannot do bridge_setlink 
 	qeth_l2_bridge_setlink() - set bridgeport attributes
 	@dev: netdevice
 	@nlh: netlink message header
 	@flags: bridge flags (here: BRIDGE_FLAGS_SELF)
 	@extack: extended ACK report struct
 	Called under rtnl_lock
 do not change anything if BridgePort is enabled 
 OSA 3S and earlier has no RXTX support 
 Set BridgePort features 
 VNIC Characteristics features 
 Conditional to avoid spurious error messages 
 Let the callback function refresh the stored role value. 
 	qeth_l2_detect_dev2br_support() -
 	Detect whether this card supports 'dev to bridge fdb network address
 	change notification' and thus can support the learning_sync bridgeport
 	attribute
 	@card: qeth_card structure pointer
 dev2br requires valid cssid,iid,chid 
 Recoverable error, retry once 
 SETBRIDGEPORT support, async notifications 
  qeth_bridge_emit_host_event() - bridgeport address change notification
  @card:  qeth_card structure pointer, for udev events.
  @evtype:  "normal" registerunregister, or abort, or reset. For abort
 	      and reset token and addr_lnid are unused and may be NULL.
  @code:  event bitmask: high order bit 0x80 value 1 means removal of an
 			  object, 0 - addition of an object.
 			  0x01 - VLAN, 0x02 - MAC, 0x03 - VLAN and MAC.
  @token: "network token" structure identifying physical address of the port.
  @addr_lnid: pointer to structure with MAC address and VLAN ID.
  This function is called when registrations and deregistrations are
  reported by the hardware, and also when notifications are enabled -
  for all currently registered addresses.
 Information for the local port: 
 Potential re-config in progress, try again later: 
		 Card fdb and bridge fdb are out of sync, card has stopped
		  notifications (no need to drain_workqueue). Purge all
		  'extern_learn' entries from the parent bridge and restart
		  the notifications.
			 TODO: if we want to retry after -EAGAIN, be
			  aware there could be stale entries in the
			  workqueue now, that need to be drained.
			  For now we give up:
 To remove fdb entries reported by an_set: 
 Potential re-config in progress, try again later: 
 SETBRIDGEPORT support; sending commands 
 maybe not the best code here? 
  qeth_bridgeport_query_support() - store bitmask of supported subfunctions.
  @card:			     qeth_card structure pointer.
  Sets bitmask of supported setbridgeport subfunctions in the qeth_card
  strucutre: card->options.sbp.supported_funcs.
 first entry contains the state of the local port 
  qeth_bridgeport_query_ports() - query local bridgeport status.
  @card:			   qeth_card structure pointer.
  @role:   Role of the port: 0-none, 1-primary, 2-secondary.
  @state:  State of the port: 0-inactive, 1-standby, 2-active.
  Returns negative errno-compatible error indication or 0 on success.
  'role' and 'state' are not updated in case of hardware operation failure.
  qeth_bridgeport_setrole() - Assign primary role to the port.
  @card:		       qeth_card structure pointer.
  @role:		       Role to assign.
  Returns negative errno-compatible error indication or 0 on success.
  qeth_bridgeport_an_set() - Enable or disable bridgeport address notification
  @card:		      qeth_card structure pointer.
  @enable:		      0 - disable, non-zero - enable notifications
  Returns negative errno-compatible error indication or 0 on success.
  On enable, emits a series of address notifications udev events for all
  currently registered hosts.
 VNIC Characteristics support 
 handle VNICC IPA command return codes; convert to error codes 
 generic VNICC request call back 
 return results to caller 
 VNICC query VNIC characteristics request 
 VNICC query sub commands request 
 VNICC enabledisable characteristic request 
 VNICC getset timeout for characteristic request 
 recover user timeout setting 
 set current VNICC flag state; called from sysfs store function 
 check if characteristic and enabledisable are supported 
 set enabledisable command and store wanted characteristic 
 do we need to do anything? 
 if card is not ready, simply stop here 
 successful online VNICC change; handle special cases 
 get current VNICC flag state; called from sysfs show function 
 check if characteristic is supported 
 if card is ready, query current VNICC state 
 set VNICC timeout; called from sysfs store function. Currently, only learning
  supports timeout
 check if characteristic and set_timeout are supported 
 do we need to do anything? 
 if card is not ready, simply store the value internally and return 
 send timeout value to card; if successful, store value internally 
 get current VNICC timeout; called from sysfs show function. Currently, only
  learning supports timeout
 check if characteristic and get_timeout are supported 
 if card is ready, get timeout. Otherwise, just return stored value 
 check if VNICC is currently enabled 
	 default values are only OK if rx_bcast was not enabled by user
	  or the card is offline.
 	qeth_bridgeport_allowed - are any qeth_bridgeport functions allowed?
 	@card: qeth_card structure pointer
 	qeth_bridgeport functionality is mutually exclusive with usage of the
 	VNIC Characteristics and dev2br address notifications
 recover user characteristic setting 
 (re-)initialize VNICC 
 reset rx_bcast 
 initial query and storage of VNIC characteristics 
 fail quietly if user didn't change the default config 
 get supported commands for each supported characteristic 
 enforce assumed default values and recover settings, if changed  
 Change chars, if necessary  
 configure default values of VNIC characteristics 
 characteristics values 
 supported commands 
 settings wanted by users 
 for the rx_bcast characteristic, init VNICC after setmac 
 softsetup 
 Returns zero if the command is successfully "consumed" 
 SPDX-License-Identifier: GPL-2.0
  Deliver zVM CP special messages (SMSG) as uevents.
  The driver registers for zVM CP special messages with the
  "APP" prefix. Incoming messages are delivered to user space
  as uevents.
  Copyright IBM Corp. 2010
  Author(s): Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
 prefix used for SMSG registration 
 SMSG related uevent environment variables 
 zVM user ID which is permitted to send SMSGs
  If the value is undefined or empty (""), special messages are
 SMSG device representation 
 list element for queuing received messages for delivery 
 queue for outgoing uevents 
 setting up environment pointers into buf 
 setting up environment: sender, prefix name, and message text 
	 check if the originating zVM user ID matches
 get start of message text (skip prefix and leading blanks) 
 allocate event list element and its environment 
 queue event and schedule work function 
 convert sender to uppercase characters 
 register with the smsgiucv device driver 
 unregister callback 
 cancel pending work and flush any queued event work 
 SPDX-License-Identifier: GPL-2.0
     Copyright IBM Corp. 2007, 2009
     Author(s): Utz Bacher <utz.bacher@de.ibm.com>,
 		 Frank Pavlic <fpavlic@de.ibm.com>,
 		 Thomas Spatzier <tspat@de.ibm.com>,
 		 Frank Blaschka <frank.blaschka@de.ibm.com>
 invert? 
  IP address takeover related functions
  qeth_l3_update_ipato() - Update 'takeover' property, for all NORMAL IPs.
  Caller must hold ip_lock.
 go on
 go on
 go on
 go on
 go on
 go on
 for mcast, by-IP match means full match 
 for mcast, by-IP match means full match 
 Guestlan trace 
 HiperSockets trace 
 for next call to set_rx_mode(): 
	
	  currently GuestLAN only supports the ARP assist function
	  IPA_CMD_ASS_ARP_QUERY_INFO, but not IPA_CMD_ASS_ARP_SET_NO_ENTRIES;
	  thus we say EOPNOTSUPP for this ARP function
 check if all replies received ... 
	 keep STRIP_ENTRIES flag so the user program can distinguish
IPA_QUERY_ARP_ADDR_INFO
 get size of userspace buffer and mask_bits -> 6 bytes 
 fails in case of GuestLAN QDIO mode 
	
	  currently GuestLAN only supports the ARP assist function
	  IPA_CMD_ASS_ARP_QUERY_INFO, but not IPA_CMD_ASS_ARP_ADD_ENTRY;
	  thus we say EOPNOTSUPP for this ARP function
	
	  currently GuestLAN only supports the ARP assist function
	  IPA_CMD_ASS_ARP_QUERY_INFO, but not IPA_CMD_ASS_ARP_FLUSH_CACHE;
	  thus we say EOPNOTSUPP for this ARP function
 no neighbour (eg AF_PACKET), fall back to target's IP address ... 
 OSA only: ... and MAC address 
 some HW requires combined L3+L4 csum offload: 
 NETIF_F_HW_VLAN_CTAG_TX 
 OSA only: 
 this is safe, IPv6 traffic takes a different path 
 re-use the L2 header area for the HW header: 
  we need NOARP for IPv4 but we want neighbor solicitation for IPv6. Setting
  NOARP on the netdevice is no option because it also turns off neighbor
  solicitation. For IPv4 we install a neighbor_setup function. We don't want
  arp resolution but we want the hard header (packet socket will work
  e.g. tcpdump)
IPv6 address autoconfiguration stuff
 allow for de-acceleration of NETIF_F_HW_VLAN_CTAG_TX: 
 softsetup 
 Returns zero if the command is successfully "consumed" 
 SPDX-License-Identifier: GPL-2.0
  Copyright IBM Corp. 2007, 2007
  Authors:	Peter Tiedemann (ptiedem@de.ibm.com)
  sysfs attributes
 just to overwrite the default 
 Reset statistics 
 SPDX-License-Identifier: GPL-2.0
  zfcp device driver
  Module interface and handling of zfcp data structures.
  Copyright IBM Corp. 2002, 2020
  Driver authors:
             Martin Peschke (originator of the driver)
             Raimund Schroeder
             Aron Zeh
             Wolfgang Taphorn
             Stefan Bader
             Heiko Carstens (kernel 2.6 port of the driver)
             Andreas Herrmann
             Maxim Shchetynin
             Volker Sameske
             Ralph Wuerthner
             Michael Loehr
             Swen Schillig
             Christof Schmitt
             Martin Petermann
             Sven Schuetz
             Steffen Maier
 	      Benjamin Block
 duplicate devstr and keep the original for sysfs presentation
  zfcp_get_port_by_wwpn - find port in port list of adapter by wwpn
  @adapter: pointer to adapter to search for port
  @wwpn: wwpn to search for
  Returns: pointer to zfcp_port or NULL
  zfcp_status_read_refill - refill the long running status_read_requests
  @adapter: ptr to struct zfcp_adapter for which the buffers should be refilled
  Return:
   0 on success meaning at least one status read is pending
   1 if posting failed and not a single status read buffer is pending,
      also triggers adapter reopen recovery
 undo add -1 
  zfcp_adapter_enqueue - enqueue a new adapter to the list
  @ccw_device: pointer to the struct cc_device
  Returns:	struct zfcp_adapter
  Enqueues an adapter at the end of the adapter list in the driver data.
  All adapter internal structures are set up.
  Proc-fs entries are also created.
 report size limit per scatter-gather segment 
 TODO: make this more fine-granular 
 final put to release 
 final put to release 
  zfcp_adapter_release - remove the adapter from the resource list
  @ref: pointer to struct kref
  locks:	adapter list write lock is assumed to be held by caller
  zfcp_port_enqueue - enqueue port to port list of adapter
  @adapter: adapter where remote port is added
  @wwpn: WWPN of the remote port to be enqueued
  @status: initial status for the port
  @d_id: destination id of the remote port to be enqueued
  Returns: pointer to enqueued port on success, ERR_PTR on error
  All port internal structures are set up and the sysfs entry is generated.
  d_id is used to enqueue ports with a well known address like the Directory
  Service for nameserver lookup.
 SPDX-License-Identifier: GPL-2.0
  zfcp device driver
  Implementation of FSF commands.
  Copyright IBM Corp. 2002, 2020
 timeout for FSF requests sent during scsi_eh: abort or FCP TMF 
 timeout for: exchange configport data outside ERP, or openclose WKA port 
 association between FSF command and FSF QTCB type 
  zfcp_fsf_req_free - free memory used by fsf request
  @req: pointer to struct zfcp_fsf_req
 if there is no shost yet, we have nothing to zero-out 
 All ports should be marked as ready to run again 
 all non-return stats set FSFREQ_ERROR
 go through reopen to flush pending requests 
 All ports should be marked as ready to run again 
  zfcp_fsf_req_complete - process completion of a FSF request
  @req: The FSF request that has been completed.
  When a request has been completed either from the FCP adapter,
  or it has been dismissed due to a queue shutdown, this function
  is called to process the completion status and trigger further
  events related to the FSF request.
  Caller must ensure that the request has been removed from
  adapter->req_list, to protect against concurrent modification
  by zfcp_erp_strategy_check_fsfreq().
  zfcp_fsf_req_dismiss_all - dismiss all fsf requests
  @adapter: pointer to struct zfcp_adapter
  Never ever call this without shutting down the adapter first.
  Otherwise the adapter would continue using and corrupting s390 storage.
  Included BUG_ON() call to ensure this is done.
  ERP is supposed to be the only user of this function.
 adjust pointers for missing command code 
 no error return above here, otherwise must fix call chains 
 do not evaluate invalid fields 
		
		  usually we wait with an update till the cache is too old,
		  but because we have the data available, update it anyway
		 avoids adapter shutdown to be able to recognize
  Mapping of FC Endpoint Security flag masks to mnemonics
  NOTE: Update macro ZFCP_FSF_MAX_FC_SECURITY_MNEMONIC_LENGTH when making any
        changes.
 maximum strlen(zfcp_fsf_fc_security_mnemonics[...].name) + 1 
  zfcp_fsf_scnprint_fc_security() - translate FC Endpoint Security flags into
                                    mnemonics and place in a buffer
  @buf        : the buffer to place the translated FC Endpoint Security flag(s)
                into
  @size       : the size of the buffer, including the trailing null space
  @fc_security: one or more FC Endpoint Security flags, or zero
  @fmt        : specifies whether a list or a single item is to be put into the
                buffer
  The Fibre Channel (FC) Endpoint Security flags are translated into mnemonics.
  If the FC Endpoint Security flags are zero "none" is placed into the buffer.
  With ZFCP_FSF_PRINT_FMT_LIST the mnemonics are placed as a list separated by
  a comma followed by a space into the buffer. If one or more FC Endpoint
  Security flags cannot be translated into a mnemonic, as they are undefined
  in zfcp_fsf_fc_security_mnemonics, their bitwise ORed value in hexadecimal
  representation is placed into the buffer.
  With ZFCP_FSF_PRINT_FMT_SINGLEITEM only one single mnemonic is placed into
  the buffer. If the FC Endpoint Security flag cannot be translated, as it is
  undefined in zfcp_fsf_fc_security_mnemonics, its value in hexadecimal
  representation is placed into the buffer. If more than one FC Endpoint
  Security flag was specified, their value in hexadecimal representation is
  placed into the buffer. The macro ZFCP_FSF_MAX_FC_SECURITY_MNEMONIC_LENGTH
  can be used to define a buffer that is large enough to hold one mnemonic.
  Return: The number of characters written into buf not including the trailing
          '\0'. If size is == 0 the function returns 0.
 no change, no trace 
		
		  usually we wait with an update till the cache is too old,
		  but because we have the data available, update it anyway
 lookup request again, list might have changed 
	
	  NOTE: DO NOT TOUCH ASYNC req PAST THIS POINT.
	 	 ONLY TOUCH SYNC req AGAIN ON req->completion.
	 
	  The request might complete and be freed concurrently at any point
	  now. This is not protected by the QDIO-lock (req_q_lock). So any
	  uncontrolled access after this might result in an use-after-free bug.
	  Only if the request doesn't have ZFCP_STATUS_FSFREQ_CLEANUP set, and
	  when it is completed via req->completion, is it safe to use req
	  again.
 Don't increase for unsolicited status 
  zfcp_fsf_status_read - send status read request
  @qdio: pointer to struct zfcp_qdio
  Returns: 0 on success, ERROR otherwise
 NOTE: DO NOT TOUCH req PAST THIS POINT! 
  zfcp_fsf_abort_fcp_cmnd - abort running SCSI command
  @scmnd: The SCSI command to abort
  Returns: pointer to struct zfcp_fsf_req
 NOTE: DO NOT TOUCH req, UNTIL IT COMPLETES! 
 use single, unchained SBAL if it can hold the request 
 common settings for ctgs and els requests 
 max value accepted by hardware 
  zfcp_fsf_send_ct - initiate a Generic Service request (FC-GS)
  @wka_port: pointer to zfcp WKA port to send CTGS to
  @ct: pointer to struct zfcp_send_ct with data for request
  @pool: if non-null this mempool is used to allocate struct zfcp_fsf_req
  @timeout: timeout that hardware should use, and a later software timeout
 NOTE: DO NOT TOUCH req PAST THIS POINT! 
 should never occur, avoided in zfcp_fsf_send_els 
  zfcp_fsf_send_els - initiate an ELS command (FC-FS)
  @adapter: pointer to zfcp adapter
  @d_id: N_Port_ID to send ELS to
  @els: pointer to struct zfcp_send_els with data for the command
  @timeout: timeout that hardware should use, and a later software timeout
 NOTE: DO NOT TOUCH req PAST THIS POINT! 
 NOTE: DO NOT TOUCH req PAST THIS POINT! 
  zfcp_fsf_exchange_config_data_sync() - Request information about FCP channel.
  @qdio: pointer to the QDIO-Queue to use for sending the command.
  @data: pointer to the QTCB-Bottom for storing the result of the command,
 	  might be %NULL.
  Returns:
   0		- Exchange Config Data was successful, @data is complete
   -EIO	- Exchange Config Data was not successful, @data is invalid
   -EAGAIN	- @data contains incomplete data
   -ENOMEM	- Some memory allocation failed along the way
 NOTE: ONLY TOUCH SYNC req AGAIN ON req->completion. 
  zfcp_fsf_exchange_port_data - request information about local port
  @erp_action: ERP action for the adapter for which port data is requested
  Returns: 0 on success, error otherwise
 NOTE: DO NOT TOUCH req PAST THIS POINT! 
  zfcp_fsf_exchange_port_data_sync() - Request information about local port.
  @qdio: pointer to the QDIO-Queue to use for sending the command.
  @data: pointer to the QTCB-Bottom for storing the result of the command,
 	  might be %NULL.
  Returns:
   0		- Exchange Port Data was successful, @data is complete
   -EIO	- Exchange Port Data was not successful, @data is invalid
   -EAGAIN	- @data contains incomplete data
   -ENOMEM	- Some memory allocation failed along the way
   -EOPNOTSUPP	- This operation is not supported
 NOTE: ONLY TOUCH SYNC req AGAIN ON req->completion. 
 no change, no log nor trace 
 no change in string representation, no log 
 activation 
 deactivation 
 change 
	
	  Open Port command error codes
	
	  Send FCP command error codes
	
	  Unknown error codes
 no zfcp_fc_test_link() with failed open port 
 check whether D_ID has changed during open 
		
		  FIXME: This check is not airtight, as the FCP channel does
		  not monitor closures of target port connections caused on
		  the remote side. Thus, they might miss out on invalidating
		  locally cached WWPNs (and other N_Port parameters) of gone
		  target ports. So, our heroic attempt to make things safe
		  could be undermined by 'open port' response data tagged with
		  obsolete WWPNs. Another reason to monitor potential
		  connection closures ourself at least (by interpreting
		  incoming ELS' and unsolicited status). It just crosses my
		  mind that one should be able to cross-check by means of
		  another GID_PN straight after a port has been opened.
		  Alternately, an ADISCPDISC ELS should suffice, as well.
  zfcp_fsf_open_port - create and send open port request
  @erp_action: pointer to struct zfcp_erp_action
  Returns: 0 on success, error otherwise
 NOTE: DO NOT TOUCH req PAST THIS POINT! 
  zfcp_fsf_close_port - create and send close port request
  @erp_action: pointer to struct zfcp_erp_action
  Returns: 0 on success, error otherwise
 NOTE: DO NOT TOUCH req PAST THIS POINT! 
  zfcp_fsf_open_wka_port - create and send open wka-port request
  @wka_port: pointer to struct zfcp_fc_wka_port
  Returns: 0 on success, error otherwise
 NOTE: DO NOT TOUCH req PAST THIS POINT! 
  zfcp_fsf_close_wka_port - create and send close wka port request
  @wka_port: WKA port to open
  Returns: 0 on success, error otherwise
 NOTE: DO NOT TOUCH req PAST THIS POINT! 
		 can't use generic zfcp_erp_modify_port_status because
		 can't use generic zfcp_erp_modify_port_status because
		  ZFCP_STATUS_COMMON_OPEN must not be reset for the port
  zfcp_fsf_close_physical_port - close physical port
  @erp_action: pointer to struct zfcp_erp_action
  Returns: 0 on success
 NOTE: DO NOT TOUCH req PAST THIS POINT! 
  zfcp_fsf_open_lun - open LUN
  @erp_action: pointer to struct zfcp_erp_action
  Returns: 0 on success, error otherwise
 NOTE: DO NOT TOUCH req PAST THIS POINT! 
  zfcp_fsf_close_lun - close LUN
  @erp_action: pointer to erp_action triggering the "close LUN"
  Returns: 0 on success, error otherwise
 NOTE: DO NOT TOUCH req PAST THIS POINT! 
  zfcp_fsf_fcp_handler_common() - FCP response handler common to IO and TMF.
  @req: Pointer to FSF request.
  @sdev: Pointer to SCSI device as request context.
	
	  We must hold this lock until scsi_done has been called.
	  Otherwise we may call scsi_done after abort regarding this
	  command has completed.
	  Note: scsi_done must not block!
  zfcp_fsf_fcp_cmnd - initiate an FCP command (for a SCSI command)
  @scsi_cmnd: scsi command to be sent
 NOTE: DO NOT TOUCH req PAST THIS POINT! 
  zfcp_fsf_fcp_task_mgmt() - Send SCSI task management command (TMF).
  @sdev: Pointer to SCSI device to send the task management command to.
  @tm_flags: Unsigned byte for task management flags.
  Return: On success pointer to struct zfcp_fsf_req, %NULL otherwise.
 NOTE: DO NOT TOUCH req, UNTIL IT COMPLETES! 
  zfcp_fsf_reqid_check - validate req_id contained in SBAL returned by QDIO
  @qdio: pointer to struct zfcp_qdio
  @sbal_idx: response queue index of SBAL to be processed
			
			  Unknown request means that we have potentially memory
			  corruption and must stop the machine immediately.
 SPDX-License-Identifier: GPL-2.0
  zfcp device driver
  Tracking of manually configured LUNs and helper functions to
  register the LUNs with the SCSI midlayer.
  Copyright IBM Corp. 2010
  zfcp_unit_scsi_scan - Register LUN with SCSI midlayer
  @unit: The zfcp LUNunit to register
  When the SCSI midlayer is not allowed to automatically scan and
  attach SCSI devices, zfcp has to register the single devices with
  the SCSI midlayer.
  zfcp_unit_queue_scsi_scan - Register configured units on port
  @port: The zfcp_port where to register units
  After opening a port, all units configured on this port have to be
  registered with the SCSI midlayer. This function should be called
  after calling fc_remote_port_add, so that the fc_rport is already
  ONLINE and the call to scsi_scan_target runs the same way as the
  call in the FC transport class.
  zfcp_unit_find - Find and return zfcp_unit with specified FCP LUN
  @port: zfcp_port where to look for the unit
  @fcp_lun: 64 Bit FCP LUN used to identify the zfcp_unit
  If zfcp_unit is found, a reference is acquired that has to be
  released later.
  Returns: Pointer to the zfcp_unit, or NULL if there is no zfcp_unit
           with the specified FCP LUN.
  zfcp_unit_release - Drop reference to zfcp_port and free memory of zfcp_unit.
  @dev: pointer to device in zfcp_unit
  zfcp_unit_add - add unit to unit list of a port.
  @port: pointer to port where unit is added
  @fcp_lun: FCP LUN of unit to be added
  Returns: 0 success
  Sets up some unit internal structures and creates sysfs entry.
 port is already gone 
 under zfcp_sysfs_port_units_mutex ! 
	
	  lock order: shost->scan_mutex before zfcp_sysfs_port_units_mutex
	  due to      zfcp_unit_scsi_scan() => zfcp_scsi_slave_alloc()
  zfcp_unit_sdev - Return SCSI device for zfcp_unit
  @unit: The zfcp_unit where to get the SCSI device for
  Returns: scsi_device pointer on success, NULL if there is no SCSI
           device for this zfcp_unit
  On success, the caller also holds a reference to the SCSI device
  that must be released with scsi_device_put.
  zfcp_unit_sdev_status - Return zfcp LUN status for SCSI device
  @unit: The unit to lookup the SCSI device for
  Returns the zfcp LUN status field of the SCSI device if the SCSI device
  for the zfcp_unit exists, 0 otherwise.
  zfcp_unit_remove - Remove entry from list of configured units
  @port: The port where to remove the unit from the configuration
  @fcp_lun: The 64 bit LUN of the unit to remove
  Returns: -EINVAL if a unit with the specified LUN does not exist,
           0 on success.
 undo _zfcp_unit_find() 
 SPDX-License-Identifier: GPL-2.0
  zfcp device driver
  sysfs attributes.
  Copyright IBM Corp. 2008, 2020
	
	  If `scsi_host` is missing, we can't schedule `scan_work`, as it
	  makes use of the corresponding fc_host object. But this state is
	  only possible if xconfigxport data has never completed yet,
	  and we couldn't successfully scan for ports anyway.
	
	  Users wish is our command: immediately schedule and flush a
	  worker to conduct a synchronous port scan, that is, neither
	  a random delay nor a rate limit is applied here.
 zfcp_unit(s) under port 
 alive scsi_device under port of interest 
 port is about to be removed, so no more unit_add or slave_alloc 
 undo zfcp_get_port_by_wwpn() 
 undo zfcp_get_port_by_wwpn() 
 ceil(log(2^64 - 1)  log(10)) = 20 
	
	  Adapter status COMMON_OPEN implies xconf data and xport data
	  was done. Adapter FC Endpoint Security capability remains
	  unchanged in case of COMMON_ERP_FAILED (e.g. due to local link
	  down).
 nport_serv_param doesn't contain the ELS_Command code 
 SPDX-License-Identifier: GPL-2.0
  zfcp device driver
  Fibre Channel related functions for the zfcp device driver.
  Copyright IBM Corp. 2008, 2017
 delay only needed within waiting period 
 paranoia: never ever delay scans longer than specified 
  zfcp_fc_post_event - post event to userspace via fc_transport
  @work: work struct with enqueued events
  zfcp_fc_enqueue_event - safely enqueue FC HBA API event from irq context
  @adapter: The adapter where to enqueue the event
  @event_code: The event code (as defined in fc_host_event_code in
 		scsi_transport_fc.h)
  @event_data: The event data (e.g. n_port page in case of els)
 wait 10 milliseconds, other reqs might pop in 
 see FC-FS 
 handle failed ports 
 skip head and start with 1st element 
  zfcp_fc_incoming_els - handle incoming ELS
  @fsf_req: request which contains incoming ELS
 looks like a valid d_id 
 setup parameters for send generic command 
  zfcp_fc_ns_gid_pn - initiate GID_PN nameserver request
  @port: port where GID_PN request is needed
  return: -ENOMEM on error, 0 otherwise
 < WORKER_DESC_LEN=24 
 could not issue gid_pn for some reason 
  zfcp_fc_trigger_did_lookup - trigger the d_id lookup using a GID_PN request
  @port: The zfcp_port to lookup the d_id for.
  zfcp_fc_plogi_evaluate - evaluate PLOGI playload
  @port: zfcp_port structure
  @plogi: plogi payload
  Evaluate PLOGI playload and copy important fields into zfcp_port structure
 request rejected or timed out 
 port is good, unblock rport without going through erp 
	 acc. to FC-FS, hard_nport_id in ADISC should not be set for ports
 < WORKER_DESC_LEN=24 
 only issue one test command at one time per port 
 send of ADISC was not possible 
  zfcp_fc_test_link - lightweight link test procedure
  @port: port to be tested
  Test status of a link to a remote port using the ELS command ADISC.
  If there is a problem with the remote port, error recovery steps
  will be triggered.
  zfcp_fc_sg_free_table - free memory used by scatterlists
  @sg: pointer to scatterlist
  @count: number of scatterlist which are to be free'ed
  the scatterlist are expected to reference pages always
  zfcp_fc_sg_setup_table - init scatterlist and allocate, assign buffers
  @sg: pointer to struct scatterlist
  @count: number of scatterlists which should be assigned with buffers
  of size page
  Returns: 0 on success, -ENOMEM otherwise
 might be a temporary condition 
 first entry is the header 
 don't attach ports with a well known address 
 skip the adapter's port and known remote ports 
  zfcp_fc_scan_ports - scan remote ports and attach new ports
  @work: reference to scheduled work
  zfcp_fc_sym_name_update - Retrieve and update the symbolic port name
  @work: ns_up_work of the adapter where to update the symbolic port name
  Retrieve the current symbolic port name that may have been set by
  the hardware using the GSPN request and update the fc_host
  symbolic_name sysfs attribute. When running in NPIV mode (and hence
  the port name is unique for this system), update the symbolic port
  name to add Linux specific information and update the FC nameserver
  using the RSPN request.
 hardware tracks timeout, reset bsg timeout to not interfere 
 SPDX-License-Identifier: GPL-2.0
  zfcp device driver
  Registration and callback for the s390 common IO layer.
  Copyright IBM Corp. 2002, 2010
  zfcp_ccw_activate - activate adapter and wait for it to finish
  @cdev: pointer to belonging ccw device
  @clear: Status flags to clear.
  @tag: s390dbf trace record tag
	
	  We want to scan ports here, with some random backoff and without
	  rate limit. Recovery has already scheduled a port scan for us,
	  but with both random delay and rate limit. Nevertheless we get
	  what we want here by flushing the scheduled work after sleeping
	  an equivalent random time.
	  Let the port scan random delay elapse first. If recovery finishes
	  up to that point in time, that would be perfect for both recovery
	  and port scan. If not, i.e. recovery takes ages, there was no
	  point in waiting a random delay on top of the time consumed by
	  recovery.
  zfcp_ccw_probe - probe function of zfcp driver
  @cdev: pointer to belonging ccw device
  This function gets called by the common io layer for each FCP
  device found on the current system. This is only a stub to make cio
  work: To only allocate adapter resources for devices actually used,
  the allocation is deferred to the first call to ccw_set_online.
  zfcp_ccw_remove - remove function of zfcp driver
  @cdev: pointer to belonging ccw device
  This function gets called by the common io layer and removes an adapter
  from the system. Task of this function is to get rid of all units and
  ports that belong to this adapter. And in addition all resources of this
  adapter will be freed too.
 put from zfcp_ccw_adapter_by_cdev 
  zfcp_ccw_set_online - set_online function of zfcp driver
  @cdev: pointer to belonging ccw device
  This function gets called by the common io layer and sets an
  adapter into state online.  The first call will allocate all
  adapter resources that will be retained until the device is removed
  via zfcp_ccw_remove.
  Setting an fcp device online means that it will be registered with
  the SCSI stack, that the QDIO queues will be set up and that the
  adapter will be opened.
 initialize request counter 
	
	  We want to scan ports here, always, with some random delay and
	  without rate limit - basically what zfcp_ccw_activate() has
	  achieved for us. Not quite! That port scan depended on
	  !no_auto_port_rescan. So let's cover the no_auto_port_rescan
	  case here to make sure a port scan is done unconditionally.
	  Since zfcp_ccw_activate() has waited the desired random time,
	  we can immediately schedule and flush a port scan for the
	  remaining cases.
  zfcp_ccw_set_offline - set_offline function of zfcp driver
  @cdev: pointer to belonging ccw device
  This function gets called by the common io layer and sets an adapter
  into state offline.
  zfcp_ccw_notify - ccw notify function
  @cdev: pointer to belonging ccw device
  @event: indicates if adapter was detached or attached
  This function gets called by the common io layer if an adapter has gone
  or reappeared.
  zfcp_ccw_shutdown - handle shutdown from cio
  @cdev: device for adapter to shutdown.
 SPDX-License-Identifier: GPL-2.0
  zfcp device driver
  Setup and helper functions to access QDIO.
  Copyright IBM Corp. 2002, 2020
 this needs to be called prior to updating the queue fill level 
 cleanup all SBALs being program-owned now 
 incl. signaling SBAL 
	
	  go through all SBALs from input queue currently
	  returned by QDIO layer
 go through all SBALEs of SBAL 
	
	  put SBALs back to response queue
 Check the Response Queue: 
 More work pending: 
 set last entry flag in current SBALE of current SBAL 
 don't exceed last allowed SBAL 
 set chaining flag in first SBALE of current SBAL 
 calculate index of next SBAL 
 keep this requests number of SBALs up-to-date 
 start at first SBALE of new SBAL 
 set storage-block type for new SBAL 
  zfcp_qdio_sbals_from_sg - fill SBALs from scatter-gather list
  @qdio: pointer to struct zfcp_qdio
  @q_req: pointer to struct zfcp_qdio_req
  @sg: scatter-gather list
  Returns: zero or -EINVAL on error
 set storage-block type for this request 
  zfcp_qdio_sbal_get - get free sbal in request queue, wait if necessary
  @qdio: pointer to struct zfcp_qdio
  The req_q_lock must be held by the caller of this function, and
  this function may only be called from process context; it will
  sleep when waiting for a free sbal.
  Returns: 0 on success, -EIO if there is no free sbal after waiting.
 assume hanging outbound queue, try queue recovery 
  zfcp_qdio_send - send req to QDIO
  @qdio: pointer to struct zfcp_qdio
  @q_req: pointer to struct zfcp_qdio_req
  Returns: 0 on success, error otherwise
	
	  This should actually be a spin_lock_bh(stat_lock), to protect against
	  Request Queue completion processing in tasklet context.
	  But we can't do so (and are safe), as we always get called with IRQs
	  disabled by spin_lock_irq[save](req_q_lock).
 Failed to submit the IO, roll back our modifications. 
 account for transferred buffers 
  zfcp_qdio_allocate - allocate queue memory and initialize QDIO data
  @qdio: pointer to struct zfcp_qdio
  Returns: -ENOMEM on memory allocation error or return value from
           qdio_allocate
  zfcp_qdio_close - close qdio queues for an adapter
  @qdio: pointer to structure zfcp_qdio
 clear QDIOUP flag, thus do_QDIO is not called during qdio_shutdown 
 cleanup used outbound sbals 
  zfcp_qdio_open - prepare and initialize response queue
  @qdio: pointer to struct zfcp_qdio
  Returns: 0 on success, otherwise -EIO
 set index of first available SBALS  number of available SBALS 
 Enable processing for Request Queue completions: 
 Enable processing for QDIO interrupts: 
 This results in a qdio_start_irq(): 
  zfcp_qdio_siosl - Trigger logging in FCP channel
  @adapter: The zfcp_adapter where to trigger logging
  Call the cio siosl function to trigger hardware logging.  This
  wrapper function sets a flag to ensure hardware logging is only
  triggered once before going through qdio shutdown.
  The triggers are always run from qdio tasklet context, so no
  additional synchronization is necessary.
 SPDX-License-Identifier: GPL-2.0
  zfcp device driver
  Error Recovery Procedures (ERP).
  Copyright IBM Corp. 2002, 2020
  Eyecatcher pseudo flag to bitwise or-combine with enum zfcp_erp_act_type.
  Used to indicate that an ERP action could not be set up despite a detected
  need for some recovery.
  Eyecatcher pseudo flag to bitwise or-combine with enum zfcp_erp_act_type.
  Used to indicate that ERP not needed because the object has
  ZFCP_STATUS_COMMON_ERP_FAILED.
 ensure propagation of failed status to new devices 
 ensure propagation of failed status to new devices 
 shutdown requested for closed adapter 
 marker for trace 
 marker for trace 
 marker for trace 
 don't waste stack  struct zfcp_port tmpport;
	 Stand-in zfcp port with fields just good enough for
	  zfcp_dbf_rec_trig() and zfcp_dbf_set_common().
	  Under lock because tmpport is static.
 unknown 
  zfcp_erp_adapter_reopen - Reopen adapter.
  @adapter: Adapter to reopen.
  @clear: Status flags to clear.
  @dbftag: Tag for debug trace event.
  zfcp_erp_adapter_shutdown - Shutdown adapter.
  @adapter: Adapter to shut down.
  @clear: Status flags to clear.
  @dbftag: Tag for debug trace event.
  zfcp_erp_port_shutdown - Shutdown port
  @port: Port to shut down.
  @clear: Status flags to clear.
  @dbftag: Tag for debug trace event.
  zfcp_erp_port_forced_reopen - Forced close of port and open again
  @port: Port to force close and to reopen.
  @clear: Status flags to clear.
  @dbftag: Tag for debug trace event.
  zfcp_erp_port_reopen - trigger remote port recovery
  @port: port to recover
  @clear: flags in port status to be cleared
  @dbftag: Tag for debug trace event.
  zfcp_erp_lun_reopen - initiate reopen of a LUN
  @sdev: SCSI device  LUN to be reopened
  @clear: specifies flags in LUN status to be cleared
  @dbftag: Tag for debug trace event.
  Return: 0 on success, < 0 on error
  zfcp_erp_lun_shutdown - Shutdown LUN
  @sdev: SCSI device  LUN to shut down.
  @clear: Status flags to clear.
  @dbftag: Tag for debug trace event.
  zfcp_erp_lun_shutdown_wait - Shutdown LUN and wait for erp completion
  @sdev: SCSI device  LUN to shut down.
  @dbftag: Tag for debug trace event.
  Do not acquire a reference for the LUN when creating the ERP
  action. It is safe, because this function waits for the ERP to
  complete first. This allows to shutdown the LUN, even when the SCSI
  device is in the state SDEV_DEL when scsi_device_get will fail.
			 lock-free concurrent access with
			  zfcp_erp_timeout_handler()
  zfcp_erp_notify - Trigger ERP action.
  @erp_action: ERP action to continue.
  @set_mask: ERP action status flags to set.
  zfcp_erp_timeout_handler - Trigger ERP action from timed out ERP request
  @t: timer list entry embedded in zfcp FSF request
 lock-free concurrent access with zfcp_erp_strategy_check_fsfreq() 
 NOP 
 error or port already attached 
	
	  We allocated the shost for the first time. Before it was NULL,
	  and so we deferred all updates in the xconf- and xport-data
	  handlers. We need to make up for that now, and make all the updates
	  that would have been done before.
	 
	  We can be sure that xconf- and xport-data succeeded, because
	  otherwise this function is not called. But they might have been
	  incomplete.
	
	  There is a remote possibility that the 'Exchange Port Data' request
	  reports a different connectivity status than 'Exchange Config Data'.
	  But any change to the connectivity status of the local optic that
	  happens after the initial xconf request is expected to be reported
	  to us, as soon as we post Status Read Buffers to the FCP channel
	  firmware after this function. So any resulting inconsistency will
	  only be momentary.
 close queues to ensure that buffers are not accessed by adapter 
 all ports and LUNs are closed 
 NOP 
 D_ID might have changed during open 
 no early return otherwise, continue after switch case 
 NOP 
 NOP 
 already closed 
 NOP 
 NOP 
 NOP 
 NOP 
 take it online 
 take it offline 
  zfcp_erp_try_rport_unblock - unblock rport if no morenew recovery
  @port: zfcp_port whose fc_rport we should try to unblock
		 new ERP of severity >= port triggered elsewhere meanwhile or
		  local link down (adapter erp_failed but not clear unblock)
 LUN under port of interest 
 unblock rport despite failed LUNs 
 LUN recovery not given up yet [maybe follow-up pending] 
			 LUN blocked:
			  not yet unblocked [LUN recovery pending]
			  or meanwhile blocked [new LUN recovery triggered]
	 now port has no child or all children have completed recovery,
	  and no ERP of severity >= port was meanwhile triggered elsewhere
		 This switch case might also happen after a forced reopen
		  was successfully done and thus overwritten with a new
		  non-forced reopen at `ersfs_2'. In this case, we must not
		  do the clean-up of the non-forced version.
 no lock to allow for blocking operations 
 NOP 
 there is more to come after dismission, no notify 
  zfcp_erp_thread_setup - Start ERP thread for adapter
  @adapter: Adapter to start the ERP thread for
  Return: 0 on success, or error code from kthread_run().
  zfcp_erp_thread_kill - Stop ERP thread.
  @adapter: Adapter where the ERP thread should be stopped.
  The caller of this routine ensures that the specified adapter has
  been shut down and that this operation has been completed. Thus,
  there are no pending erp_actions which would need to be handled
  here.
  zfcp_erp_wait - wait for completion of error recovery on an adapter
  @adapter: adapter for which to wait for completion of its error recovery
  zfcp_erp_set_adapter_status - set adapter status bits
  @adapter: adapter to change the status
  @mask: status bits to change
  Changes in common status bits are propagated to attached ports and LUNs.
	
	  if `scsi_host` is missing, xconfigxport data has never completed
	  yet, so we can't access it, but there are also no SDEVs yet
  zfcp_erp_clear_adapter_status - clear adapter status bits
  @adapter: adapter to change the status
  @mask: status bits to change
  Changes in common status bits are propagated to attached ports and LUNs.
	
	  if `scsi_host` is missing, xconfigxport data has never completed
	  yet, so we can't access it, but there are also no SDEVs yet
  zfcp_erp_set_port_status - set port status bits
  @port: port to change the status
  @mask: status bits to change
  Changes in common status bits are propagated to attached LUNs.
  zfcp_erp_clear_port_status - clear port status bits
  @port: adapter to change the status
  @mask: status bits to change
  Changes in common status bits are propagated to attached LUNs.
  zfcp_erp_set_lun_status - set lun status bits
  @sdev: SCSI device  lun to set the status bits
  @mask: status bits to change
  zfcp_erp_clear_lun_status - clear lun status bits
  @sdev: SCSi device  lun to clear the status bits
  @mask: status bits to change
  zfcp_erp_adapter_reset_sync() - Really reopen adapter and wait.
  @adapter: Pointer to zfcp_adapter to reopen.
  @dbftag: Trace tag string of length %ZFCP_DBF_TAG_LEN.
 SPDX-License-Identifier: GPL-2.0
  zfcp device driver
  Functions to handle diagnostics.
  Copyright IBM Corp. 2018
  zfcp_diag_adapter_setup() - Setup storage for adapter diagnostics.
  @adapter: the adapter to setup diagnostics for.
  Creates the data-structures to store the diagnostics for an adapter. This
  overwrites whatever was stored before at &zfcp_adapter->diagnostics!
  Return:
   0	     - Everyting is OK
   -ENOMEM - Could not allocate allparts of the data-structures;
 	       &zfcp_adapter->diagnostics remains unchanged
 default value: 5 s 
 setup header for port_data 
 set the timestamp so that the first test on age will always fail 
 setup header for config_data 
 set the timestamp so that the first test on age will always fail 
  zfcp_diag_adapter_free() - Frees all adapter diagnostics allocations.
  @adapter: the adapter whose diagnostic structures should be freed.
  Frees all data-structures in the given adapter that store diagnostics
  information. Can savely be called with partially setup diagnostics.
  zfcp_diag_update_xdata() - Update a diagnostics buffer.
  @hdr: the meta data to update.
  @data: data to use for the update.
  @incomplete: flag stating whether the data in @data is incomplete.
 make sure we never go into the past with an update 
  zfcp_diag_update_port_data_buffer() - Implementation of
 					 &typedef zfcp_diag_update_buffer_func
 					 to collect and update Port Data.
  @adapter: Adapter to collect Port Data from.
  This call is SYNCHRONOUS ! It blocks till the respective command has
  finished completely, or has failed in some way.
  Return:
   0		- Successfully retrieved new Diagnostics and Updated the buffer;
 		  this also includes cases where data was retrieved, but
 		  incomplete; you'll have to check the flag ``incomplete``
 		  of &struct zfcp_diag_header.
   see zfcp_fsf_exchange_port_data_sync() for possible error-codes (
    excluding -EAGAIN)
 signaling incomplete via struct zfcp_diag_header 
 buffer-data was updated in zfcp_fsf_exchange_port_data_handler() 
  zfcp_diag_update_config_data_buffer() - Implementation of
 					   &typedef zfcp_diag_update_buffer_func
 					   to collect and update Config Data.
  @adapter: Adapter to collect Config Data from.
  This call is SYNCHRONOUS ! It blocks till the respective command has
  finished completely, or has failed in some way.
  Return:
   0		- Successfully retrieved new Diagnostics and Updated the buffer;
 		  this also includes cases where data was retrieved, but
 		  incomplete; you'll have to check the flag ``incomplete``
 		  of &struct zfcp_diag_header.
   see zfcp_fsf_exchange_config_data_sync() for possible error-codes (
    excluding -EAGAIN)
 signaling incomplete via struct zfcp_diag_header 
 buffer-data was updated in zfcp_fsf_exchange_config_data_handler() 
 unlocked, because update function sleeps 
		
		  every thread waiting here went via an interruptible wait,
		  so its fine to only wake those
	
	  Should not happen (data is from the future).. if it does, still
	  signal that it needs refresh
  zfcp_diag_update_buffer_limited() - Collect diagnostics and update a
 				       diagnostics buffer rate limited.
  @adapter: Adapter to collect the diagnostics from.
  @hdr: buffer-header for which to update with the collected diagnostics.
  @buffer_update: Specific implementation for collecting and updating.
  This function will cause an update of the given @hdr by calling the also
  given @buffer_update function. If called by multiple sources at the same
  time, it will synchornize the update by only allowing one source to call
  @buffer_update and the others to wait for that source to complete instead
  (the wait is interruptible).
  Additionally this version is rate-limited and will only exit if either the
  buffer is fresh enough (within the limit) - it will do nothing if the buffer
  is fresh enough to begin with -, or if the sourcethread that started this
  update is the one that made the update (to prevent endless loops).
  Return:
   0		- If the update was successfully published andor the buffer is
 		  fresh enough
   -EINTR	- If the thread went into the wait-state and was interrupted
   whatever @buffer_update returns
 SPDX-License-Identifier: GPL-2.0
  zfcp device driver
  Debug traces for zfcp.
  Copyright IBM Corp. 2002, 2020
  zfcp_dbf_hba_fsf_res - trace event for fsf responses
  @tag: tag indicating which kind of FSF response has been received
  @level: trace level to be used for event
  @req: request for which a response was received
  zfcp_dbf_hba_fsf_fces - trace event for fsf responses related to
 			   FC Endpoint Security (FCES)
  @tag: tag indicating which kind of FC Endpoint Security event has occurred
  @req: request for which a response was received
  @wwpn: remote port or ZFCP_DBF_INVALID_WWPN
  @fc_security_old: old FC Endpoint Security of FCP device or connection
  @fc_security_new: new FC Endpoint Security of FCP device or connection
  zfcp_dbf_hba_fsf_uss - trace event for an unsolicited status buffer
  @tag: tag indicating which kind of unsolicited status has been received
  @req: request providing the unsolicited status
 status read buffer payload length 
  zfcp_dbf_hba_bit_err - trace event for bit error conditions
  @tag: tag indicating which kind of bit error unsolicited status was received
  @req: request which caused the bit_error condition
  zfcp_dbf_hba_def_err - trace event for deferred error messages
  @adapter: pointer to struct zfcp_adapter
  @req_id: request id which caused the deferred error message
  @scount: number of sbals incl. the signaling sbal
  @pl: array of all involved sbals
  zfcp_dbf_rec_trig - trace event related to triggered recovery
  @tag: identifier for event
  @adapter: adapter on which the erp_action should run
  @port: remote port involved in the erp_action
  @sdev: scsi device involved in the erp_action
  @want: wanted erp_action
  @need: required erp_action
  The adapter->erp_lock has to be held.
  zfcp_dbf_rec_trig_lock - trace event related to triggered recovery with lock
  @tag: identifier for event
  @adapter: adapter on which the erp_action should run
  @port: remote port involved in the erp_action
  @sdev: scsi device involved in the erp_action
  @want: wanted erp_action
  @need: required erp_action
  The adapter->erp_lock must not be held.
  zfcp_dbf_rec_run_lvl - trace event related to running recovery
  @level: trace level to be used for event
  @tag: identifier for event
  @erp: erp_action running
  zfcp_dbf_rec_run - trace event related to running recovery
  @tag: identifier for event
  @erp: erp_action running
  zfcp_dbf_rec_run_wka - trace wka port event with info like running recovery
  @tag: identifier for event
  @wka_port: well known address port
  @req_id: request ID to correlate with potential HBA trace record
 full length even if we cap pay below 
 part of 1st sg entry 
 skip pay record if full content in rec->payload 
	 if (len > rec_len):
	  dump data up to cap_len ignoring small duplicate in rec->payload
 cap_len <= pay_sum < cap_len+ZFCP_DBF_PAY_MAX_REC 
  zfcp_dbf_san_req - trace event for issued SAN request
  @tag: identifier for event
  @fsf: request containing issued CT or ELS data
  @d_id: N_Port_ID where SAN request is sent to
  d_id: destination ID
 reqh->ct_mr_size can vary so do not match but read below 
 not GPN_FT response so do not cap 
 cap all but accept CT responses to at least the CT header 
		+ 1  zfcp_fc_scan_ports: bytes correct, entries off-by-one
	 the basic CT_IU preamble is the same size as one entry in the GPN_FT
	  response, allowing us to skip special handling for it - just skip it
 cap after last entry 
  zfcp_dbf_san_res - trace event for received SAN request
  @tag: identifier for event
  @fsf: request containing received CT or ELS data
  zfcp_dbf_san_in_els - trace event for incoming ELS
  @tag: identifier for event
  @fsf: request containing received ELS data
  zfcp_dbf_scsi_common() - Common trace event helper for scsi.
  @tag: Identifier for event.
  @level: trace level of event.
  @sdev: Pointer to SCSI device as context for this event.
  @sc: Pointer to SCSI command, or NULL with task management function (TMF).
  @fsf: Pointer to FSF request, or NULL.
 mandatory parts of FCP_RSP IU in this SCSI record 
		 complete FCP_RSP IU in associated PAYload record
		  but only if there are optional parts
				 at least one full PAY record
				  but not beyond hardware response field
  zfcp_dbf_scsi_eh() - Trace event for special cases of scsi_eh callbacks.
  @tag: Identifier for event.
  @adapter: Pointer to zfcp adapter as context for this event.
  @scsi_id: SCSI IDtarget to indicate scope of task management function (TMF).
  @ret: Return value of calling function.
  This SCSI trace variant does not depend on any of:
  scsi_cmnd, zfcp_fsf_req, scsi_device.
 re-use field, int is 4 bytes and fits 
  zfcp_dbf_adapter_register - registers debug feature for an adapter
  @adapter: pointer to adapter for which debug features should be registered
  return: -ENOMEM on error, 0 otherwise
 debug feature area which records recovery activity 
 debug feature area which records HBA (FSF and QDIO) conditions 
 debug feature area which records payload info 
 debug feature area which records SAN command failures and recovery 
 debug feature area which records SCSI command failures and recovery 
  zfcp_dbf_adapter_unregister - unregisters debug feature for an adapter
  @adapter: pointer to adapter for which debug features should be unregistered
 SPDX-License-Identifier: GPL-2.0
  zfcp device driver
  Interface to Linux SCSI midlayer.
  Copyright IBM Corp. 2002, 2020
 if previous slave_alloc returned early, there is nothing to do 
 reset the status for this request 
		 only LUN access denied, but port is good
		 This could be
		  call to rport_delete pending: mimic retry from
		  	fc_remote_port_chkready until rport is BLOCKED
 port is already gone 
 undo zfcp_get_port_by_wwpn() 
 avoid race condition between late normal completion and abort 
 completion could be in progress 
 don't access old fsf_req after releasing the abort_lock 
 already aborted - prevent side-effects - or not a SCSI command 
 (tmf_scope == FCP_TMF_TGT_RESET || tmf_scope == FCP_TMF_LUN_RESET) 
	
	  abort_lock secures against other processings - in the abort-function
	  and normal cmnd-handler - of (struct zfcp_fsf_req )->data
  zfcp_scsi_task_mgmt_function() - Send a task management function (sync).
  @sdev: Pointer to SCSI device to send the task management command to.
  @tm_flags: Task management flags,
 	      here we only handle %FCP_TMF_TGT_RESET or %FCP_TMF_LUN_RESET.
 release reference from above shost_for_each_device 
  zfcp_scsi_sysfs_host_reset() - Support scsi_host sysfs attribute host_reset.
  @shost: Pointer to Scsi_Host to perform action on.
  @reset_type: We support %SCSI_ADAPTER_RESET but not %SCSI_FIRMWARE_RESET.
  Return: 0 on %SCSI_ADAPTER_RESET, -%EOPNOTSUPP otherwise.
  This is similar to zfcp_sysfs_adapter_failed_store().
 GCD, adjusted later 
 GCD, adjusted later 
 report size limit per scatter-gather segment 
  zfcp_scsi_adapter_register() - Allocate and register SCSI and FC host with
 				  SCSI midlayer
  @adapter: The zfcp adapter to register with the SCSI midlayer
  Allocates the SCSI host object for the given adapter, sets basic properties
  (such as the transport template, QDIO limits, ...), and registers it with
  the midlayer.
  During registration with the midlayer the corresponding FC host object for
  the referenced transport class is also implicitely allocated.
  Upon success adapter->scsi_host is set, and upon failure it remains NULL. If
  adapter->scsi_host is already set, nothing is done.
  Return:
   0	     - Allocation and registration was successful
   -EEXIST - SCSI and FC host did already exist, nothing was done, nothing
 	       was changed
   -EIO    - Allocation or registration failed
 register adapter as SCSI host with mid layer of SCSI stack 
 tell the SCSI stack some characteristics of this adapter 
 in struct fcp_cmnd 
 make all basic properties known at registration time 
  zfcp_scsi_adapter_unregister - Unregister SCSI and FC host from SCSI midlayer
  @adapter: The zfcp adapter to unregister.
 freed in adapter_release 
		adapter->stats_reset_data = data;  finally freed in
  zfcp_scsi_terminate_rport_io - Terminate all IO on a rport
  @rport: The FC rport where to teminate IO
  Abort all pending SCSI commands for a port by closing the
  port. Using a reopen avoids a conflict with a shutdown
  overwriting a reopen. The "forced" ensures that a disappeared port
  is not opened again as valid due to the cached plogi data in
  non-NPIV mode.
 zfcp_scsi_rport_register ,
 zfcp_scsi_rport_register );
 < WORKER_DESC_LEN=24 
  zfcp_scsi_set_prot - Configure DIFDIX support in scsi_host
  @adapter: The adapter where to configure DIFDIX for the SCSI host
  zfcp_scsi_dif_sense_error - Report DIFDIX error as driver sense error
  @scmd: The SCSI command to report the error for
  @ascq: The ASCQ to put in the sense buffer
  See the error handling in sd_done for the sense codes used here.
  Set DID_SOFT_ERROR to retry the request, if possible.
 adjust pointers for missing command code 
 do not evaluate invalid fields 
	 no functions registered for following dynamic attributes but
 SPDX-License-Identifier: GPL-2.0
  Author(s)......: Holger Smolinski <Holger.Smolinski@de.ibm.com>
 		    Horst Hummel <Horst.Hummel@de.ibm.com>
 		    Carsten Otte <Cotte@de.ibm.com>
 		    Martin Schwidefsky <schwidefsky@de.ibm.com>
  Bugreports.to..: <Linux390@de.ibm.com>
  Copyright IBM Corp. 1999, 2002
  proc interface for the dasd driver.
 This is ugly... 
 Print device number. 
 Print discipline string. 
 Print kdev. 
 Print device name. 
 Print devices features. 
 Print device status information. 
 CONFIG_DASD_PROFILE 
 prevent counter 'overflow' on output 
 check for valid verbs 
 'set xxx' was given 
 switch on statistics profiling 
 switch off statistics profiling 
 reset the statistics 
 CONFIG_DASD_PROFILE 
  Create dasd proc-fs entries.
  In case creation failed, cleanup and return -ENOENT.
 SPDX-License-Identifier: GPL-2.0
  Author(s)......: Holger Smolinski <Holger.Smolinski@de.ibm.com>
 		    Horst Hummel <Horst.Hummel@de.ibm.com>
 		    Carsten Otte <Cotte@de.ibm.com>
 		    Martin Schwidefsky <schwidefsky@de.ibm.com>
  Bugreports.to..: <Linux390@de.ibm.com>
  Copyright IBM Corp. 1999, 2001
  io controls for the dasd driver.
 This is ugly... 
  Enable device.
  used by dasdfmt after BIODASDDISABLE to retrigger blocksize detection
  Disable device.
  Used by dasdfmt. Disable IO operations but allow ioctls.
	
	  Man this is sick. We don't do a real disable but only downgrade
	  the device to DASD_STATE_BASIC. The reason is that dasdfmt uses
	  BIODASDDISABLE to disable accesses to the device via the block
	  device layer but it still wants to do io on the device by
	  using the BIODASDFMT ioctl. Therefore the correct state for the
	  device is DASD_STATE_BASIC that allows to do basic io.
	
	  Set i_size to zero, since read, write, etc. check against this
	  value.
  Quiesce device.
  Resume device.
  Abort all failfast IO on a device.
  Allow IO on a device
  performs formatting of _device_ according to _fdata_
  Note: The discipline's format_function is assumed to deliver formatting
  commands to format multiple units of the device. In terms of the ECKD
  devices this means CCWs are generated to format multiple tracks.
	 Since dasdfmt keeps the device open after it was disabled,
	  there still exists an inode for this device.
	  We must update i_blkbits, otherwise we might get errors when
	  enabling the device later.
  Format device.
  Check device format
  Release allocated space
  Reset device profile information
  Return device profile information
  Return dasd information. Used for BIODASDINFO and BIODASDINFO2.
	
	  The open_count is increased for every opener, that includes
	  the blkdev_get in dasd_scan_partitions.
	  This must be hidden from user-space.
	
	  check if device is really formatted
	  LDL  CDL was returned by 'fill_info'
  Set read only
 do not manipulate hardware state for partitions 
 if the discipline has an ioctl method try it. 
  dasd_biodasdinfo() - fill out the dasd information structure
  @disk: [in] pointer to gendisk structure that references a DASD
  @info: [out] pointer to the dasd_information2_t structure
  Provide access to DASD specific information.
  The gendisk structure is checked if it belongs to the DASD driver by
  comparing the gendisk->fops pointer.
  If it does not belong to the DASD driver -EINVAL is returned.
  Otherwise the provided dasd_information2_t structure is filled out.
  Returns:
    %0 on success and a negative error value on failure.
 export that symbol_get in partition detection is possible 
 SPDX-License-Identifier: GPL-2.0
  Author(s)......: Holger Smolinski <Holger.Smolinski@de.ibm.com>
  Bugreports.to..: <Linux390@de.ibm.com>
  Copyright IBM Corp. 1999, 2009
 HDIO_GETGEO			    
 PRINTK_HEADER 
 end of list  },
 Read Device Characteristics 
 FBA supports discard, set the according feature bit 
 bits to shift 512 to get a block 
 first of all check for state change pending interrupt 
  Builds a CCW with no data payload
  Builds a CCW that writes only zeroes.
  Helper function to count the amount of necessary CCWs within a given range
  with 4k alignment and command chaining in mind.
  This function builds a CCW request for block layer discard requests.
  Each page in the zVM hypervisor that represents certain records of an FBA
  device will be padded with zeros. This is a special behaviour of the WRITE
  command which is triggered when no data payload is added to the CCW.
  Note: Due to issues in some zVM versions, we can't fully utilise this
  special behaviour. We have to keep a 4k (or 8 block) alignment in mind to
  work around those issues and write actual zeroes to the unaligned parts in
  the request. This workaround might be removed in the future.
 Current position within the extent 
 define extent + nr_ccws  locate record + nr_ccws  single CCW 
 First part is not aligned. Calculate range to write zeroes. 
 We can do proper discard when we've got at least blocks_per_page blocks. 
 is last record at page boundary? 
 We might still have some bits left which need to be zeroed. 
 default 5 minutes 
 Calculate record id of first and last block. 
 Check struct bio and count the number of blocks for the request. 
 Fba can only do full blocks. 
 Paranoia. 
 1x define extent + 1x locate record + number of blocks 
 1x define extent + 1x locate record 
	
	  Find out number of additional locate record ccws if the device
	  can't do data chaining.
 Allocate the ccw request. 
 First ccw is define extent. 
 Build locate_record + readwrite ccws. 
 Locate record for all blocks for smart devices. 
 Locate record for stupid devices. 
 default 5 minutes 
 Skip over define extent & locate record. 
 Skip locate record. 
 dump the Channel Program 
 print first CCWs (maximum 8) 
 print failing CCW area 
 print last CCWs 
  Initialize block layer request queue.
 With page sized segments each segment can be translated into one idawtidaw 
 Calculate max_discard_sectors and make it PAGE aligned 
 SPDX-License-Identifier: GPL-2.0
  PAV alias management for the DASD ECKD discipline
  Copyright IBM Corp. 2007
  Author(s): Stefan Weinhuber <wein@de.ibm.com>
 PRINTK_HEADER 
  General concept of alias management:
  - PAV and DASD alias management is specific to the eckd discipline.
  - A device is connected to an lcu as long as the device exists.
    dasd_alias_make_device_known_to_lcu will be called wenn the
    device is checked by the eckd discipline and
    dasd_alias_disconnect_device_from_lcu will be called
    before the device is deleted.
  - The dasd_alias_add_device  dasd_alias_remove_device
    functions mark the point when a device is 'ready for service'.
  - A summary unit check is a rare occasion, but it is mandatory to
    support it. It requires some complex recovery actions before the
    devices can be used again (see dasd_alias_handle_summary_unit_check).
  - dasd_alias_get_start_dev will find an alias device that can be used
    instead of the base device and does some (very simple) load balancing.
    This is the function that gets called for each IO, so when improving
    something, this function should get faster or better, the rest has just
    to be correct.
 for hyper pav there is only one group 
 for base pav we have to find the group that matches the base 
  This is the function that will allocate all the server and lcu data,
  so this function must be called first for a new device.
  If the return value is 1, the lcu was already known before, if it
  is 0, this is a new lcu.
  Negative return code indicates that something went wrong (e.g. -ENOMEM)
 someone was faster 
 someone was faster 
  This function removes a device from the scope of alias management.
  The complicated part is to make sure that it is not in use by
  any of the workers. If necessary cancel the work.
 nothing to do if already disconnected 
 make sure that the workers don't use this device 
  This function assumes that the unit address configuration stored
  in the lcu is up to date and will update the device uid before
  adding it to a pav group.
 if we have no PAV anyway, we don't need to bother with PAV groups 
	
	  intrc values ENODEV, ENOLINK and EPERM
	  will be optained from sleep_on to indicate that no
	  IO operation can be started
 command reject, Format 0 MSG 4 - invalid parameter 
 PSF 	+ 1 
 Prepare for Read Subsystem Data 
 Read unit address configuration 
 all other bytes of prssdp must be zero 
 Read Subsystem Data - feature codes 
 need to unset flag here to detect race with summary unit check 
 suborder not supported or device unusable for IO 
 IO failed but should be retried 
	
	  there is another update needed skip the remaining handling
	  the data might already be outdated
	  but especially do not add the device to an LCU with pending
	  update
	
	  Need to check flags again, as there could have been another
	  prepare_update or a new device a new device while we were still
	  processing the data
 already scheduled or running 
	
	  if we haven't found a proper device yet, give up for now, the next
	  device that will be set active will trigger an lcu update
	
	  Check if device and lcu type differ. If so, the uac data may be
	  outdated and needs to be updated.
 nothing to do if already removed 
		
		  PAV enabled but prefix not, very unlikely
		  seems to be a lost pathgroup
		  use base device to do IO
  Summary unit check handling depends on the way alias devices
  are handled so it is done here rather then in dasd_eckd.c
 set retry counter to enable basic ERP 
 active and inactive list can contain alias as well as base devices 
	
	  Problem here ist that dasd_flush_device_queue may wait
	  for termination of a request to complete. We can't keep
	  the lcu lock during that time, so we must assume that
	  the lists may have changed.
	  Idea: first gather all active alias devices in a separate list,
	  then flush the first element of this list unlocked, and afterwards
	  check if it is still on the list before moving it to the
	  active_devices list.
		
		  only move device around if it wasn't moved away while we
		  were waiting for the flush
 1. flush alias devices 
 2. reset summary unit check 
 3. read new alias configuration 
	 If this device is about to be removed just return and wait for
	  the next interrupt on a different device
 already scheduled or running 
 prepare for lcu_update 
 SPDX-License-Identifier: GPL-2.0
  Device driver for s390 storage class memory.
  Copyright IBM Corp. 2012
  Author(s): Sebastian Ott <sebott@linux.vnet.ibm.com>
 SPDX-License-Identifier: GPL-2.0
  Author(s)......: Holger Smolinski <Holger.Smolinski@de.ibm.com>
 		    Horst Hummel <Horst.Hummel@de.ibm.com>
 		    Carsten Otte <Cotte@de.ibm.com>
 		    Martin Schwidefsky <schwidefsky@de.ibm.com>
  Bugreports.to..: <Linux390@de.ibm.com>
  Copyright IBM Corp. 1999, 2009
  EMC Symmetrix ioctl Copyright EMC Corporation, 2008
  Author.........: Nigel Hislop <hislop_nigel@emc.com>
 HDIO_GETGEO			    
 PRINTK_HEADER 
  raw track access always map to 64k in memory
  so it maps to 16 blocks of 4k per track
 64k are 128 x 512 byte sectors  
 The ccw bus type uses this table to find devices that it sends to
 end of list  },
 see below 
 emergency request for reserverelease 
 definitions for the path verification worker 
 initial attempt at a probe function. this can be simplified once
 set ECKD specific ccw-device options 
 head and record addresses of count_area read in analysis ccw 
  calculate failing track from sense data depending if
  it is an EAV device or not
 enhanced addressing 
	
	  Ignore return code if XRC is not supported or
	  sync clock is switched off
 switch on System Time Stamp - needed for XRC Support 
 switch on 'Time Stamp Valid'   
 switch on 'Extended Parameter' 
 ECKD 
 Regular Data Format Mode 
 check for sequential prestage - enhance cylinder range 
	 note: meaning of count depends on the operation
	 	 for record based IO it's the number of records, but for
	 	 track based IO it's the number of tracks
 not tlf, as one might think 
 prefix data 
 private uid is kept up to date, conf_data may be outdated 
	
	  For some commands the System Time Stamp is set in the define extent
	  data when XRC is supported. The validity of the time stamp must be
	  reflected in the prefix data as well.
 'Time Stamp Valid'   
  Returns 1 if the block is one of the special blocks that needs
  to get readwritten with the KD variant of the command.
  That is DASD_ECKD_READ_KD_MT instead of DASD_ECKD_READ_MT and
  DASD_ECKD_WRITE_KD_MT instead of DASD_ECKD_WRITE_MT.
  Luckily the KD variants differ only by one bit (0x08) from the
  normal variant. So don't wonder about code like:
  if (dasd_eckd_cdl_special(blk_per_trk, recid))
          ccw->cmd_code |= 0x8;
  Returns the record size for the special blocks of the cdl format.
  Only returns something useful if dasd_eckd_cdl_special is true
  for the recid.
 create unique id from private structure. 
  Generate device unique id that specifies the physical device.
  compare device UID with data of a given dasd_eckd_private structure
  return 0 for match
	
	  buffer has to start with EBCDIC "V1.0" to show
	  support for virtual device SNEQ
  Wakeup helper for read_conf
  if the cqr is not done and needs some error recovery
  the buffer has to be re-initialized with the EBCDIC "V1.0"
  to show support for virtual device SNEQ
	
	  sanity check: scan for RCD command in extended SenseID data
	  some devices do not support RCD
	
	  sanity check: scan for RCD command in extended SenseID data
	  some devices do not support RCD
 RCD ,
 use rcd_buf as data ara 
	
	  on success we update the user input parms
	
	  path handling and read_conf allocate data
	  free it before replacing the pointer
	  also replace the old private->conf_data pointer
	  with the new one if this points to the same data
 get configuration data per operational path 
 -EOPNOTSUPP is ok 
 no further analysis possible 
 no error 
 save first valid configuration data 
 initially clear previously stored conf_data 
			
			  build device UID that other path data
			  can be compared to it
 is transport mode supported? 
 -EOPNOTSUPP is ok 
 first valid path is enough 
		
		  save conf_data for comparison after
		  rebuild_device_uid may have changed
		  the original data
		
		  compare path UID with device UID only if at least
		  one valid path is left
		  in other case the device UID may have changed and
		  the first working path UID will be used as device UID
			
			  the comparison was not successful
			  rebuild the device UID with at least one
			  known path in case a zVM hyperswap command
			  has changed the device
			 
			  after this compare again
			 
			  if either the rebuild or the recompare fails
			  the path can not be used
			
			  path is operational but path config data could not
			  be stored due to low mem condition
			  add it to the error path mask and schedule a path
			  verification later that this could be added again
		
		  There is a small chance that a path is lost again between
		  above path verification and the following modification of
		  the device opm mask. We could avoid that race here by using
		  yet another path mask, but we rather deal with this unlikely
		  situation in dasd_start_IO.
 delay path verification until device was resumed 
 check if path verification already running and delay if so 
 PSF 	+ 1 
 Prepare for Read Subsystem Data 
 Read Feature Codes 
 all other bytes of prssdp must be zero 
 Read Subsystem Data - feature codes 
 Read Volume Information - Volume Storage Query 
 This command cannot be executed on an alias device 
 PSF + RSSD ,
 Prepare for Read Subsystem Data 
 Volume Storage Query 
 Read Subsystem Data - Volume Storage Query 
 The command might not be supported. Suppress the error output 
  This value represents the total amount of available space. As more space is
  allocated by ESE volumes, this value will decrease.
  The data for this value is therefore updated on any call.
  The value of space allocated by an ESE volume may have changed and is
  therefore updated on any call.
 Read Extent Pool Information - Logical Configuration Query 
 This command cannot be executed on an alias device 
 PSF + RSSD ,
 Prepare for Read Subsystem Data 
 Logical Configuration Query 
 The command might not be supported. Suppress the error output 
  Depending on the device type, the extent size is specified either as
  cylinders per extent (CKD) or size per extent (FBA)
  A 1GB size corresponds to 1113cyl, and 16MB to 21cyl.
  Extent Pool out of space
  Build CP for Perform Subsystem Function - SSC.
 PSF  ,
  Perform Subsystem Function.
  It is necessary to trigger CIO for channel revalidation since this
  call might change behaviour of DASD devices.
	
	  set flags e.g. turn on failfast, to prevent blocking
	  the calling function should handle failed requests
 trigger CIO to reprobe devices 
  Valide storage server of current device.
	 may be requested feature is not available on server,
  worker to do a validate server in case of a lost pathgroup
 schedule worker again if failed 
 exit if device not online or in offline processing 
 queue call to do_validate_server to the kernel event daemon. 
  Check device characteristics.
  If the device is accessible using ECKD discipline, the device is enabled.
 setup work queue for validate server
 setup work queue for summary unit check 
 Invalidate status of initial analysis. 
 Set default cache operations. 
 Read Configuration Data 
 set some default values 
 do not accept useless values 
 register lcu with alias handling, enable PAV 
 device may report different configuration data after LCU setup 
 Read Feature Codes 
 Read Volume Information 
 Read Extent Pool Information 
 Read Device Characteristics 
 find the valid cylinder size 
 Define extent for the first 2 tracks. 
 Locate record for the first 4 records on track 0. 
 Locate record for the first record on track 1. 
 Read count ccw. 
 Set flags to suppress output for expected errors 
 differentiate between 'no record found' and any other error 
  This is the callback function for the init_analysis cqr. It saves
  the status of the initial analysis ccw before it frees it and kicks
  the device to continue the startup sequence. This will call
  dasd_eckd_do_analysis again (if the devices has not been marked
  for deletion in the meantime).
	 first try without ERP, so we can later handle unformatted
	  devices as special case
 try again, this time with full ERP 
 Check Track 0 for Compatible Disk Layout 
 we found notthing violating our disk layout 
 bits to shift 512 to get a block 
  Build the TCW request for the format check
	
	  we're adding 'count' amount of tidaw to the itcw.
	  calculate the corresponding itcw_size
 Set flags to suppress output for expected errors 
  Build the CCW request for the format check
 Set flags to suppress output for expected errors 
	
	  fdata->intensity is a bit string that tells us what to do:
	    Bit 0: write record zero
	    Bit 1: write home address, currently not supported
	    Bit 2: invalidate tracks
	    Bit 3: use OS390 compatible disk layout (cdl)
	    Bit 4: do not allow storage subsystem to modify record zero
	  Only some bit combinations do make sense.
 Normal format 
 Normal format, use cdl. 
 Write record zero and format track. 
 Write record zero and format track, use cdl. 
 Invalidate track. 
 Invalidate track, use cdl. 
 Normal format. 
 grant subsystem permission to format R0 
 grant subsystem permission to format R0 
 Write record zero + format track. 
 Invalidate track. 
 calculate cylinder and head for the current track 
 write record zero 
 erase track 
 write remaining records 
				
				  Check for special tracks 0-1
				  when formatting CDL
  Wrapper function to build a CCW request depending on input data
  Sanity checks on format_data
  This function will process format_data originally coming from an IOCTL
 Command Mode  Format Check 
 Transport Mode  Format Check 
 Normal Formatting 
					
					  not enough memory available, start
					  requests retry after first requests
					  were finished
				
				  Only get sense data if called by format
				  check
			
			  In case fewer than the expected records are on the
			  track, we will most likely get a 'No Record Found'
			  error (in command mode) or a 'File Protected' error
			  (in transport mode). Those particular cases shouldn't
			  pass the -EIO to the IOCTL, therefore reset the rc
			  and continue.
  Callback function to free ESE format requests.
 test if track is already in formatting by another thread 
	
	  We're building the request with PAV disabled as we're reusing
	  the former startdev.
  When data is read from an unformatted area of an ESE volume, this function
  returns zeroed data and thereby mimics a read of zero data.
  The first unformatted track is the one that got the NRF error, the address is
  encoded in the sense data.
  All tracks before have returned valid data and should not be touched.
  All tracks after the unformatted track might be formatted or not. This is
  currently not known, remember the processed data and return the remainder of
  the request to the blocklayer in __dasd_cleanup_cqr().
 sanity check if the current track from sense data is valid 
	
	  if not the first track got the NRF error we have to skip over valid
	  blocks
 we have no information beyond the current track 
  Helper function to count consecutive records of a single track.
	
	  There are 3 conditions where we stop counting:
	  - if data reoccurs (same head and record may reoccur), which may
	    happen due to the way DASD_ECKD_CCW_READ_COUNT works
	  - when the head changes, because we're iterating over several tracks
	    then (DASD_ECKD_CCW_READ_COUNT_MT)
	  - when we've reached the end of sensible data in the buffer (the
	    record will be 0 then)
  Evaluate a given range of tracks. Data like number of records, blocksize,
  record ids, and key length are compared with expected data.
  If a mismatch occurs, the corresponding error bit is set, as well as
  additional information, depending on the error.
 Calculate the correct next starting position in the buffer 
 Calculate the expected geo values for the current track 
 Count and check number of records 
			
			  Set special values when checking CDL formatted
			  devices.
 Check blocksize 
 Check if key length is 0 
 Check if record_id is correct 
	
	  In case of no errors, we need to decrease by one
	  to get the correct positions.
  Check the format of a range of tracks of a DASD.
 Get maximum and expected amount of records per track 
	
	  A certain FICON feature subset is needed to operate in transport
	  mode. Additionally, the support for transport mode is implicitly
	  checked by comparing the buffer size with fcx_max_data. As long as
	  the buffer size is smaller we can operate in transport mode and
	  process multiple tracks. If not, only one track at once is being
	  processed using command mode.
		
		  If our first attempt with transport mode enabled comes back
		  with an incorrect length error, we're going to retry the
		  check with command mode.
 first of all check for state change pending interrupt 
		
		  for alias only, not in offline processing
		  and only if not suspended
 schedule worker to reload device 
 summary unit check 
 service information message SIM 
	 loss of device reservation is handled via base devices only
	  as alias devices may be used with several bases
  Helper function to count the amount of involved extents within a given range
  with extent alignment in mind.
 Count first partial extent 
 Count full extents 
 Count last partial extent 
  Release allocated space for a given range or an entire volume.
 CKD volume 
 Release specified extents or entire volume 
	
	  This bit guarantees initialisation of tracks within an extent that is
	  not fully specified, but is only supported with a certain feature
	  subset.
 Make sure device limits are not exceeded 
 Check struct bio and count the number of blocks for the request. 
 Eckd can only do full blocks. 
 Paranoia. 
 use the prefix command if available 
 1x prefix + number of blocks 
 1x prefix + cidawssizeof(long) 
 1x define extent + 1x locate record + number of blocks 
 1x define extent + 1x locate record + cidawssizeof(long) 
 Find out the number of additional locate record ccws for cdl. 
 Allocate the ccw request. 
 First ccw is define extent or prefix. 
			 Clock not in sync and XRC is enabled.
			  Try again later.
			 Clock not in sync and XRC is enabled.
			  Try again later.
 Build locate_record+readwriteccws. 
 Only standard blocks so there is just one locate record. 
 Locate record for cdl special block ? 
 Locate record for standard blocks ? 
 Readwrite ccw. 
 default 5 minutes 
 Set flags to suppress output for expected errors 
	 Track based IO needs IDAWs for each page, and not just for
	  64 bit addresses. We need additional idals for pages
	  that get filled from two tracks, so we use the number
	  of records as upper limit.
 1x prefix + one readwrite ccw per track 
 Allocate the ccw request. 
 transfer length factor: how many bytes to read from the last track 
 format , first_offs + 1,
		 Clock not in sync and XRC is enabled.
		  Try again later.
	
	  The translation of request into ccw programs must meet the
	  following conditions:
	  - all idaws but the first and the last must address full pages
	    (or 2K blocks on 31-bit)
	  - the scope of a ccw and it's idal ends with the track boundaries
 first idaw for a ccw may start anywhere 
			 If we start a new idaw, we must make sure that it
			  starts on an IDA_BLOCK_SIZE boundary.
			  If we continue an idaw, we must make sure that the
			  current segment begins where the so far accumulated
			  idaw ends
			 collected memory area ends on an IDA_BLOCK border,
			  -> create an idaw
			  idal_create_words will handle cases where idaw_len
			  is larger then IDA_BLOCK_SIZE
 We also need to end the idaw at track end 
 default 5 minutes 
 Set flags to suppress output for expected errors 
 setup prefix data 
 PFX with LRE 
 private uid is kept up to date, conf_data may be outdated 
		
		  If XRC is supported the System Time Stamp is set. The
		  validity of the time stamp must be reflected in the prefix
		  data as well.
 'Time Stamp Valid' 
 ECKD 
 check for sequential prestage - enhance cylinder range 
 records per track is valid 
	 trackbased IO needs address all memory via TIDAWs,
	  not just for 64 bit addresses. This allows us to map
	  each segment directly to one tidaw.
	  In the case of write requests, additional tidaws may
	  be needed when a segment crosses a track boundary.
 Allocate the ccw request. 
 transfer length factor: how many bytes to read from the last track 
		 Clock not in sync and XRC is enabled.
		  Try again later.
	
	  A tidaw can address 4k of memory, but must not cross page boundaries
	  We can let the block layer handle this by setting
	  blk_queue_segment_boundary to page boundaries and
	  blk_max_segment_size to page size when setting up the request queue.
	  For write requests, a TIDAW must not cross track boundaries, because
	  we have to set the CBC flag on the last tidaw for each track.
 We need to end the tidaw at track end 
 default 5 minutes 
 Set flags to suppress output for expected errors 
 Calculate number of blocksrecords per track. 
 Calculate record id of first and last block. 
 tpm write request add CBC data on each track boundary 
 is read track data and write track data in command mode supported? 
 do nothing, just fall through to the cmd mode single case 
	
	  raw track access needs to be mutiple of 64k and on 64k boundary
	  For read requests we can fix an incorrect alignment by padding
	  the request with dummy pages.
	
	  Raw track based IO needs IDAWs for each page,
	  and not just for 64 bit addresses.
	
	  struct PFX_eckd_data and struct LRE_eckd_data can have up to 2 bytes
	  of extended parameter. This is needed for write full track.
 Allocate the ccw request. 
 maximum 3390 track size 
 64k map to one track 
 maximum 3390 track size 
 64k map to one track 
 Skip over define extent & locate record. 
 Skip locate record. 
  Modify ccwtcw in cqr so it can be started on a base device.
  Note that this is not enough to restart the cqr!
  Either reset cqr->startdev as well (summary unit check handling)
  or restart via separate cqr (as in ERP handling).
  SECTION: ioctl functions for eckd devices.
  Release device ioctl.
  Buils a channel programm to releases a prior reserved
  (see dasd_eckd_reserve) device.
 set retry counter to enable basic ERP 
  Reserve device ioctl.
  Options are set to 'synchronous wait for interrupt' and
  'timeout the request'. This leads to a terminate IO if
  the interrupt is outstanding for a certain time.
 set retry counter to enable basic ERP 
  Steal lock ioctl - unconditional reserve device.
  Buils a channel programm to break a device's reservation.
  (unconditional reserve)
 set retry counter to enable basic ERP 
  SNID - Sense Path Group ID
  This ioctl may be used in situations where IO is stalled due to
  a reserve, so if the normal dasd_smalloc_request fails, we use the
  preallocated dasd_reserve_req.
 verify that IO processing didn't modify the path mask 
  Read performance statistics
 PSF   + 1 
 Prepare for Read Subsystem Data 
 Performance Statistics 
 Perf Statistics for the Subsystem 
 Read Subsystem Data - Performance Statistics 
  Get attributes (cache operations)
  Returnes the cache attributes used in Define Extend (DE).
  Set attributes (cache operations)
  Stores the attributes for cache operation to be used in Define Extend (DE).
  Issue syscall IO to EMC Symmetrix array.
  CCWs are PSF and RSSD
 Copy parms from caller 
 Make sure pointers are sane even on 31 bit. 
 at least 2 bytes are accessed and should be allocated 
 alloc IO data area 
 get syscall header from user space 
 setup CCWs for PSF + RSSD 
 Build the ccws 
 PSF ccw 
 RSSD ccw  
  Dump the range of CCWs into 'page' buffer
  and return number of printed chars.
 get pointer to data (consider IDALs) 
 dump data (max 32 bytes) 
  Print sense data and related channel program.
  Parts are printed because printk buffer is only 1024 bytes.
 dump the sense data 
 24 Byte Sense Data 
 32 Byte Sense Data 
 req == NULL for unsolicited interrupts 
 dump the Channel Program (max 140 Bytes per line) 
 Count CCW and print first CCWs (maximum 1024 % 140 = 7) 
 print failing CCW area (maximum 4) 
 scsw->cda is either valid or zero  
 failing CCW 
 there is a gap - print header 
 print last CCWs (maximum 2) 
 there is a gap - print header 
  Print sense data from a tcw.
 dump the sense data 
 tsa_iostat 
 ts_ddpc 
 tsa_intrg 
 24 Byte Sense Data 
 32 Byte Sense Data 
		
		  In some cases the 'File Protected' or 'Incorrect Length'
		  error might be expected and log messages shouldn't be written
		  then. Check if the according suppress bit is set.
		
		  In some cases the 'Command Reject' or 'No Record Found'
		  error might be expected and log messages shouldn't be
		  written then. Check if the according suppress bit is set.
	
	  remove device from alias handling to prevent new requests
	  from being scheduled on the wrong alias device
 Read Configuration Data 
	
	  update unit address configuration and
	  add device to alias management
 PSF 	+ 1 
	 dasd_sleep_on_immediatly does not do complex error
	  recovery so clear erp flag and set retry counter to
 Prepare for Read Subsystem Data 
 Message Buffer 
 all other bytes of prssdp must be zero 
 Read Subsystem Data - message buffer 
		
		  on zVM we might not be able to do IO on the requested path
		  but instead we get the required information on any path
		  so retry with open path mask
 not available for HYPER PAV alias devices 
 may not be supported by the storage server 
 PSF 	+ 1 
 Prepare for Read Subsystem Data 
 query host access 
 LSS and Volume that will be queried 
 all other bytes of prssdp must be zero 
 Read Subsystem Data - query host access 
 the command might not be supported, suppress error message 
  return number of grouped devices
  write host access information to a sequential file
 PGID 
 FLAGS 
 SYSPLEX NAME 
 SUPPORTED CYLINDER 
 TIMESTAMP 
  Perform Subsystem Function - CUIR response
 PSF  ,
  return configuration data that is referenced by record selector
  if a record selector is specified or per default return the
  conf_data pointer for the path specified by lpum
  This function determines the scope of a reconfiguration request by
  analysing the path and device selection data provided in the CUIR request.
  Returns a path mask containing CUIR affected paths for the give device.
  If the CUIR request does not contain the required information return the
  path mask of the path the attention message for the CUIR request was reveived
  on.
	 if CUIR request does not specify the scope use the path
 get reference conf data 
 reference ned is determined by ned_map field 
 transfer 24 bit neq_map to mask 
 initialise data per path 
 compare reference ned and per path ned 
		 compare reference gneq and per_path gneq under
		   24 bit mask where mask bit 0 equals byte 7 of
		 device and path match the reference values
 get position of bit in mask 
 get channel path descriptor from this position 
 nothing to do if path is not in use 
		 no path would be left if the CUIR action is taken
 remove device from operational path mask 
  walk through all devices and build a path mask to quiesce them
  return an error if the last path to a device would be removed
  if only part of the devices are quiesced and an error
  occurs no onlining necessary, the storage server will
  notify the already set offline devices again
 active devices 
 inactive devices 
 devices in PAV groups 
 notify user about all paths affected by CUIR action 
	
	  the path may have been added through a generic path event before
	  only trigger path verification if the path is not already in use
 devices in PAV groups 
 notify user about all paths affected by CUIR action 
 quiesce 
 resume 
 to make sure there is no attention left schedule work again 
 devices in PAV groups 
 In any case, update related data 
 to make sure there is no attention left schedule work again 
 sanity check for no HPF, the error makes no sense 
	
	  prevent that any new IO ist started on the device and schedule a
	  requeue of existing requests
  Initialize block layer request queue.
		
		  the max_blocks value for raw_track access is 256
		  it is higher than the native ECKD value because we
		  only need one ccw per track
		  so the max_hw_sectors are
		  2048 x 512B = 1024kB = 16 tracks
 With page sized segments each segment can be translated into one idawtidaw 
 SPDX-License-Identifier: GPL-2.0
  dcssblk.c -- the S390 block driver for dcss memory
  Authors: Carsten Otte, Stefan Weinhuber, Gerald Schaefer
  release function for segment device.
  get a minor number. needs to be called with
  down_write(&dcssblk_devices_sem) and the
  device needs to be enqueued before the semaphore is
  freed.
 test if minor available
 got unused minor
  get the struct dcssblk_dev_info from dcssblk_devices
  for the given name.
  down_read(&dcssblk_devices_sem) must be held.
  get the struct segment_info from seg_list
  for the given name.
  down_read(&dcssblk_devices_sem) must be held.
  get the highest address of the multi-segment block.
  get the lowest address of the multi-segment block.
  Check continuity of segments.
 sort segments 
 check continuity 
 EN and EW are allowed in a block device 
  Load a segment
 already loaded? 
 get a struct segment_info 
 load the segment 
  device attribute for switching sharednonshared (exclusive)
  operation (show + store)
 reload segments in shared mode 
 reload segments in exclusive mode 
  device attribute for save operation on current copy
  of the segment. If the segment is busy, saving will
  become pending until it gets released, which can be
  undone by storing a non-true value to this entry.
  (show + store)
 device is idle => we save immediately
 device is busy => we save it when it becomes
 idle in dcssblk_release
 device is busy & the user wants to undo his save
 request
  device attribute for showing all segments in a device
  device attribute for adding devices
	
	  parse input
		
		  get a struct dcssblk_dev_info
 no trailing colon at the end of the input 
 size in sectors
	
	 get minor, add to list
	
	  register the device
  device attribute for removing devices
	
	  parse input
 unload all related segments 
 Request is not page-aligned. 
 verify data transfer direction 
 cannot write to these segments 
 More paranoia.
  The initexit functions.
 SPDX-License-Identifier: GPL-2.0
  Block driver for s390 storage class memory.
  Copyright IBM Corp. 2012
  Author(s): Sebastian Ott <sebott@linux.vnet.ibm.com>
 We don't use all msbs - place aidaws at the end of the aob page. 
 For -EIO the response block is valid. 
 scma..scmz + scmaa..scmzz 
 8  512 = blk_size 
 512 byte sectors 
 SPDX-License-Identifier: GPL-2.0
  Author(s)......: Holger Smolinski <Holger.Smolinski@de.ibm.com>
  Based on.......: linuxdriverss390blockmdisk.c
  ...............: by Hartmunt Penner <hpenner@de.ibm.com>
  Bugreports.to..: <Linux390@de.ibm.com>
  Copyright IBM Corp. 1999, 2000
 The maximum number of blocks per request (max_blocks) is dependent on the
  amount of storage that is available in the static IO buffer for each
  device. Currently each device gets 2 pages. We want to fit two requests
  into the available memory so that we can immediately start the next if one
 EBCDIC CMS1 
 Perform DIAG250 call with block IO parameter list iob (input and output)
  and function code cmd.
  In case of an exception return 3. Otherwise return result of bitwise OR of
 Initialize block IO to DIAG device using the specified blocksize and
  block offset. On success, return zero and set end_block to contain the
  number of blocks on the device minus the specified offset. Return non-zero
 Remove block IO environment for device. Return zero on success, non-zero
 Error recovery for failed DIAG requests - try to reestablish the DIAG
 Start a given request at the device. Return zero on success, non-zero
 Synchronous IO finished successfully 
		 Indicate to calling function that only a dasd_schedule_bh()
 Asynchronous IO was started 
 Error condition 
 Terminate given request at the device. 
 Handle external interruption. 
 no intparm: unsolicited interrupt 
 get irq lock to modify request queue 
 Check for a pending clear operation 
 Start first request on queue if possible -> fast_io. 
 Check whether device can be controlled by DIAG discipline. Return zero on
 Read Device Characteristics 
 Figure out position of label block 
 terminate all outstanding operations 
 figure out blocksize of device 
 try all sizes - needed for ECKD devices 
 do synchronous io 
 check for label block 
 get formatted blocksize from label block 
 bits to shift 512 to get a block 
 Fill in virtual disk geometry for device. Return zero on success, non-zero
 Create DASD request from block device request. Return pointer to new
 Calculate record id of first and last block. 
 Check struct bio and count the number of blocks for the request. 
 Fba can only do full blocks. 
 Paranoia. 
 Build the request 
 Release DASD request. Return non-zero if request was successful, zero
 Fill in IOCTL data for device. 
  Initialize block layer request queue.
 With page sized segments each segment can be translated into one idawtidaw 
 SPDX-License-Identifier: GPL-2.0
  Author(s)......: Holger Smolinski <Holger.Smolinski@de.ibm.com>
 		    Horst Hummel <Horst.Hummel@de.ibm.com>
 		    Carsten Otte <Cotte@de.ibm.com>
 		    Martin Schwidefsky <schwidefsky@de.ibm.com>
  Bugreports.to..: <Linux390@de.ibm.com>
  Copyright IBM Corp. 1999,2001
  Device mapping and dasd= parameter parsing functions. All devmap
  functions may not be called from interrupt context. In particular
  dasd_get_device is a no-no from interrupt context.
 This is ugly... 
  dasd_devmap_t is used to store the features and the relation
  between device number and device index. To find a dasd_devmap_t
  that corresponds to a device number of a device index each
  dasd_devmap_t is added to two linked lists, one to search by
  the device number and one to search by the device index. As
  soon as big minor numbers are available the device index list
  can be removed since the device number will then be identical
  to the device index.
  Parameter parsing functions for dasd= parameter. The syntax is:
    <devno>		: (0x)?[0-9a-fA-F]+
    <busid>		: [0-0a-f]\.[0-9a-f]\.(0x)?[0-9a-fA-F]+
    <feature>		: ro
    <feature_list>	: \(<feature>(:<feature>)\)
    <devno-range>	: <devno>(-<devno>)?<feature_list>?
    <busid-range>	: <busid>(-<busid>)?<feature_list>?
    <devices>		: <devno-range>|<busid-range>
    <dasd_module>	: dasd_diag_mod|dasd_eckd_mod|dasd_fba_mod
    <dasd>		: autodetect|probeonly|<devices>(,<devices>)
 is true, when probeonly mode is active 
 is true, when autodetection is active 
 is true, when PAV is disabled 
 disable High Performance Ficon 
  char dasd[] is intended to hold the ranges supplied by the dasd= statement
  it is named 'dasd' to directly be filled by insmod with the comma separated
  strings when running as a module.
  Single spinlock to protect devmap and servermap structures and lists.
  Hash lists for devmap structures.
 #ifndef MODULE 
  Read a device busiddevno from a string.
 Interpret ipldev busid 
 Old style 0xXXXX or XXXX 
 New style x.y.z busid 
  Read colon separated list of dasd features.
  Try to match the first element on the comma separated parse string
  with one of the known keywords. If a keyword is found, take the approprate
  action and return a pointer to the residual string. If the first element
  could not be matched to any keyword then return an error code.
  Split a string of a device range into its pieces and return the from, to, and
  feature parts separately.
  e.g.:
  0.0.1234-0.0.5678(ro:erplog) -> from: 0.0.1234 to: 0.0.5678 features: ro:erplog
  0.0.8765(raw) -> from: 0.0.8765 to: null features: raw
  0x4321 -> from: 0x4321 to: null features: null
 Do we have a range or a single device? 
  Try to interprete the range string as a device number or a range of devices.
  If the interpretation is successful, create the matching dasd_devmap entries.
  If interpretation fails or in case of an error, return an error code.
 each device in dasd= parameter should be set initially online 
  Parse parameters stored in dasd[]
  The 'dasd=...' parameter allows to specify a comma separated list of
  keywords and device ranges. The parameters in that list will be stored as
  separate elementes in dasd[].
  Add a devmap for the device specified by busid. It is possible that
  the devmap already exists (dasd= parameter). The order of the devices
  added through this function will define the kdevs for the individual
  devices.
 This bus_id is new. 
  Find devmap for device with given bus_id.
  Check if busid has been added to the list of dasd ranges.
  Forget all about the device numbers added so far.
  This may only be called at module unload or system shutdown.
  Find the device struct by its device index.
 Found the devmap for the device. 
  Return devmap for cdev. If no devmap exists yet, create one and
  connect it to the cdev.
  Create a dasd device structure for cdev.
 Someone else was faster. 
  Wait queue for dasd_delete_device waits.
  Remove a dasd device structure. The passed referenced
  is destroyed.
 First remove device pointer from devmap. 
 Disconnect dasd_device structure from ccw_device structure. 
	
	  Drop ref_count by 3, one for the devmap reference, one for
	  the cdev reference and one for the passed reference.
 Wait for reference counter to drop to zero. 
 Disconnect dasd_device structure from ccw_device structure. 
 Put ccw_device structure. 
 Now the device structure can be freed. 
  Reference counter dropped to zero. Wake up waiter
  in dasd_delete_device.
  Return dasd_device structure associated with cdev.
  This function needs to be called with the ccw device
  lock held. It can be used from interrupt context.
  Return dasd_device structure associated with cdev.
  SECTION: files in sysfs
  failfast controls the behaviour, if no path is available
  readonly controls the readonly status of a dasd
 Increase open_count to avoid losing the block device 
  erplog controls the logging of ERP related data
  (e.g. failing channel programs).
  use_diag controls whether the driver should use diag rather than ssch
  to talk to the device
 Changing diag discipline flag is only allowed in offline state. 
  use_raw controls whether the driver should give access to raw eckd data or
  operate in standard mode
 Changing diag discipline flag is only allowed in offline state. 
 Already doing offline processing 
 vendor  3 + 1 + 
 SSID    4 + 1 + 
 vduit  32 + 1)
 should not happen, treat like base device 
  extended error-reporting
  expiration time for default requests
  threshold value for IFCCCCC errors
  configure if path is disabled after IFCCCCC error threshold is
  exceeded
  interval for IFCCCCC checks
  meaning time with no IFCCCCC error before the error counter
  gets reset
  Return value of the specified feature.
  Set  reset given feature.
  Flag indicates whether to set (!=0) or the reset (=0) the feature.
  As we keep kobjects for the lifetime of a device, this function must not be
  called anywhere but in the context of offlining a device.
 Initialize devmap structures. 
 SPDX-License-Identifier: GPL-2.0
  Author(s)......: Holger Smolinski <Holger.Smolinski@de.ibm.com>
 		    Horst Hummel <Horst.Hummel@de.ibm.com>
 		    Carsten Otte <Cotte@de.ibm.com>
 		    Martin Schwidefsky <schwidefsky@de.ibm.com>
  Bugreports.to..: <Linux390@de.ibm.com>
  Copyright IBM Corp. 1999, 2009
 This is ugly... 
  SECTION: Constant definitions to be used within this file
  SECTION: exported variables of dasd.c
  SECTION: prototypes for static functions of dasd.c
  SECTION: Operations on the device structure.
  Allocate memory for a new device structure.
 Get two pages for normal block device operations. 
 Get one page for error recovery. 
 Get two pages for ese format. 
  Free memory of a device structure.
  Allocate memory for a new device structure.
 open_count = 0 means device online but not in use 
  Free memory of a device structure.
  Make a new device known to the system.
	
	  As long as the device is not in state DASD_STATE_NEW we want to
	  keep the reference count > 0.
  Let the system forget about a device.
 Disable extended error reporting for this device. 
 Give up reference we took in dasd_state_new_to_known. 
  Request the irq line for the device.
 Allocate and register gendisk structure. 
 register 'device' debug area, used for all DBF_DEV_XXX calls 
  Release the irq line for the device. Terminate any running io.
  Do the initial analysis. The do_analysis function may return
  -EAGAIN in which case the device keeps the state DASD_STATE_BASIC
  until the discipline decides to continue the startup sequence
  by calling the function dasd_change_state. The eckd disciplines
  uses this to start a ccw that detects the format. The completion
  interrupt for this detection ccw uses the kernel event daemon to
  trigger the call to dasd_change_state. All this is done in the
  discipline code, see dasd_eckd.c.
  After the analysis ccw is done (do_analysis returned 0) the block
  device is setup.
  In case the analysis returns an error, the device setup is stopped
  (a fake disk was already added to allow formatting).
 make disk known with correct capacity 
  Remove device from block device layer. Destroy dirty buffers.
  Forget format information. Check if the target level is basic
  and if it is create fake disk for formatting.
  Back to basic.
  Make the device online and schedule the bottom half to start
  the requeueing of requests from the linux request queue to the
  ccw queue.
  Stop the requeueing of requests again.
  Device startup state changes.
  Device shutdown state changes.
  This is the main startupshutdown routine.
 Already where we want to go today... 
 let user-space know that the device status changed 
  Kick starter for devices that did not complete the startupshutdown
  procedure or were sleeping because of a pending state.
  dasd_kick_device will schedule a call do do_kick_device to the kernel
  event daemon.
 queue call to dasd_kick_device to the kernel event daemon. 
  dasd_reload_device will schedule a call do do_reload_device to the kernel
  event daemon.
 queue call to dasd_reload_device to the kernel event daemon. 
  Set the target state for a device and starts the state change.
 If we are in probeonly mode stop at DASD_STATE_READY. 
  Enable devices with device numbers in [from..to].
 No discipline for device found. 
 Now wait for the devices to come up. 
  SECTION: device operation (interrupt handler, start io, term io ...)
  Add profiling information for cqr before execution.
 count the length of the chanq for statistics 
	
	  We count the request for the start device, even though it may run on
	  some other device due to error recovery. This way we make sure that
	  we count each request only once.
 request is not yet queued on the start device 
  Add profiling information for cqr after execution.
 in case of an overflow, reset the whole profile 
 got the string, now strip linefeed. 
 CONFIG_DASD_PROFILE 
  Check discipline magic in cqr.
  Terminate the current io and set the request to clear_pending.
  Timer keeps device runnig.
  ccw_device_clear can fail if the io subsystem
  is in a bad mood.
 Check the cqr 
 termination successful 
			
			  device not valid so no IO could be running
			  handle CQR as termination successful
 no retries for invalid devices 
 fake rc to success 
 internal error 10 - unknown rc
  Start the io. This start_IO can fail if the channel is really busy.
  In that case set up a timer to start the request later.
 Check the cqr 
 internal error 14 - start_IO run out of retries 
		 -EACCES indicates that the request used only a subset of the
		  available paths and all these paths are gone. If the lpm of
		  this request was only a subset of the opm (e.g. the ppm) then
		  we just do a retry with all available paths.
		  If we already use the full opm, something is amiss, and we
		  need a full path verification.
 internal error 11 - unknown rc 
  Timeout function for dasd devices. This is used for different purposes
   1) missing interrupt handler for normal operation
   2) delayed start of request where start_IO failed with -EBUSY
   3) timeout for missing state change interrupts
  The head of the ccw queue will have status DASD_CQR_IN_IO for 1),
  DASD_CQR_QUEUED for 2) and 3).
 re-activate request queue 
  Setup timeout for a device in jiffies.
  Clear timeout for a device.
 Schedule request to be retried. 
 First of all start sense subsystem status request. 
  Interrupt handler for "normal" ssch-io based dasd devices.
 check for conditions that should be handled immediately 
 ignore unsolicited interrupts for DIAG discipline 
		
		  In some cases 'File Protected' or 'No Record Found' errors
		  might be expected and debug log messages for the
		  corresponding interrupts shouldn't be written then.
		  Check if either of the according suppress bits is set.
			
			  Extent pool probably out-of-space.
			  Stop device and check exhaust level.
 check for for attention message 
			
			  If we can't format now, let the request go
			  one extra round. Maybe we can format later.
 Check for clear pending 
 check status - the request might have been killed by dyn detach 
 request was completed successfully 
 Start first request on queue if possible -> fast_io. 
 error 
		 check for HPF error
		  call discipline function to requeue all requests
		  and disable HPF accordingly
		
		  If we don't want complex ERP for this request, then just
		  reset this and retry it in the fastpath
  If we have an error on a dasd_block layer request then we cancel
  and return all further requests from the same dasd_block as well.
	
	  only requeue request that came from the dasd_block layer
  Remove those ccw requests from the queue that need to be returned
  to the upper layer.
 Process request with final status. 
 Skip any non-final request. 
 Rechain finished requests to final queue 
 internal error 12 - wrong cqr status
  the cqrs from the final queue are returned to the upper layer
  by setting a dasd_block state and calling the callback function
  Take a look at the first request on the ccw queue and check
  if it reached its expire time. If so, terminate the IO.
			
			  IO in safe offline processing should not
			  run out of retries
 Hmpf, try again in 5 sec 
  return 1 when device is not eligible for IO
		
		  dasd is being set offline
		  but it is no safe offline where we have to allow IO
 stopped and CQR will not change that. 
			 CQR is not able to change device to
 CQR required to get device operational. 
  Take a look at the first request on the ccw queue and check
  if it needs to be started.
 if device is not usable return request to upper layer 
 Hmpf, try again in 12 sec 
  Go through all request on the dasd_device request queue,
  terminate them on the cdev if necessary, and return them to the
  submitting layer via callback.
  Note:
  Make sure that all 'submitting layers' still exist when
  this function is called!. In other words, when 'device' is a base
  device then all block layer requests must have been removed before
  via dasd_flush_block_queue.
 Check status and move request to flush_queue 
 unable to terminate requeust 
 stop flush processing 
 no need to modify the others 
	
	  After this point all requests must be in state CLEAR_PENDING,
	  CLEARED, SUCCESS or ERROR. Now wait for CLEAR_PENDING to become
	  one of the others.
	
	  Now set each request back to TERMINATED, DONE or NEED_ERP
	  and call the callback function of flushed requests
  Acquire the device lock and process queues for the device.
 Check expire time of first request on the ccw queue. 
 find final requests on ccw queue 
 Now call the callback function of requests with final status 
 Now check if the head of the ccw queue needs to be started. 
  Schedules a call to dasd_tasklet over the device tasklet.
 Protect against rescheduling. 
  Queue a request to the head of the device ccw_queue.
  Start the IO if possible.
 let the bh start the request to keep them in order 
  Queue a request to the tail of the device ccw_queue.
  Start the IO if possible.
 let the bh start the request to keep them in order 
  Wakeup helper for the 'sleep_on' functions.
  checks if error recovery is necessary, returns 1 if yes, 0 otherwise.
 erp is not done yet 
 could be failed 
 Non-temporary stop condition will trigger fail fast 
		
		  Don't try to start requests if device is in
		  offline processing, it might wait forever
		
		  Don't try to start requests if device is stopped
		  except path verification requests
 wait (non-interruptible) for final status 
could be failed
Non-temporary stop condition will trigger fail fast
Don't try to start requests if device is stopped
		
		  In some cases the 'File Protected' or 'Incorrect Length'
		  error might be expected and error recovery would be
		  unnecessary in these cases.	Check if the according suppress
		  bit is set.
		
		  for alias devices simplify error recovery and
		  return to upper layer
		  do not skip ERP requests
 normal recovery for basedev IO 
 handle erp first 
  Queue a request to the tail of the device ccw_queue and wait for
  it's completion.
  Start requests from a ccw_queue and wait for their completion.
  Start requests from a ccw_queue and wait interruptible for their completion.
  Queue a request to the tail of the device ccw_queue and wait
  interruptible for it's completion.
  Whoa nelly now it gets really hairy. For some functions (e.g. steal lock
  for eckd devices) the currently running request has to be terminated
  and be put back to status queued, before the special request is added
  to the head of the queue. Then the special request is waited on normally.
		
		  CQR terminated because a more important request is pending.
		  Undo decreasing of retry counter because this is
		  not an error case.
	
	  add new request as second
	  first the terminated cqr needs to be finished
 let the bh start the request to keep them in order 
 kick tasklets 
  Cancels a request that was started with dasd_sleep_on_req.
  This is useful to timeout requests. The request will be
  terminated if it is currently in io.
  Returns 0 if request termination was successful
 	   negative error code if termination failed
  Cancellation of a request is an asynchronous operation! The calling
  function has to wait until the request is properly returned via callback.
 request was not started - just set to cleared 
 request in IO - terminate IO and release again 
 already finished or clear pending - do nothing 
  SECTION: Operations of the dasd_block layer.
  Timeout function for dasd_block. This is used when the block layer
  is waiting for something that may not come reliably, (e.g. a state
  change interrupt)
 re-activate request queue 
  Setup timeout for a dasd_block in jiffies.
  Clear timeout for a dasd_block.
  Process finished error recovery ccw.
	
	  We need to take care for ETIMEDOUT errors here since the
	  complete callback does not get called in this case.
	  Take care of all errors here and avoid additional code to
	  transfer the error value to the complete callback.
		
		  Partial completed requests can happen with ESE devices.
		  During read we might have gotten a NRF error and have to
		  complete a request partially.
  Process ccw request queue.
 Process request with final status. 
  Process requests that may be recovered 
 log sense for fatal error 
 First of all call extended error reporting. 
 restart request  
 Process finished ERP request. 
 Rechain finished requests to final queue 
	 We allways begin with the first requests on the queue, as some
	  of previously started requests have to be enqueued on a
	  dasd_device again for error recovery.
 Non-temporary stop condition will trigger fail fast 
 Don't try to start requests if device is stopped 
 just a fail safe check, should not happen 
 make sure that the requests we submit find their way back 
  Central dasd_block layer routine. Takes requests from the generic
  block layer request queue, creates ccw requests, enqueues them on
  a dasd_device and processes ccw requests that have been returned.
 Finish off requests on ccw queue 
 Now call the callback function of requests with final status 
 Now check if the head of the ccw queue needs to be started. 
  Requeue a request back to the block request queue
  only works for block requests
	
	  If the request is an ERP request there is nothing to requeue.
	  This will be done with the remaining original request.
  Go through all request on the dasd_block request queue, cancel them
  on the respective dasd_device, and return them to the generic
  block layer.
 if this request currently owned by a dasd_device cancel it 
		 Rechain request (including erp chain) so it won't be
		  touched by the dasd_block_tasklet anymore.
		  Replace the callback so we notice when the request
		  is returned from the dasd_device layer.
 moved more than one request - need to restart 
 Now call the callback function of flushed requests 
 Process finished ERP request. 
			 restart list_for_xx loop since dasd_process_erp
 call the callback function 
  Schedules a call to dasd_tasklet over the device tasklet.
 Protect against rescheduling. 
 life cycle of block is bound to it's base device 
  SECTION: external block device operations
  (request queue handling, open, release, etc.)
  Dasd request queue function. Called from ll_rw_blk.c
	
	  if device is stopped do not fetch new requests
	  except failfast is active which will let requests fail
	  immediately in __dasd_block_start_head()
	
	   Note: callback is set to dasd_return_cqr_cb in
	  __dasd_block_start_head to cover erp requests as well
  Block timeout callback, called from the block layer
  Return values:
  BLK_EH_RESET_TIMER if the request should be left running
  BLK_EH_DONE if the request is handled or terminated
 		      by the driver.
 searchcqr is an ERP request for cqr 
				
				  Shouldn't happen; most recent ERP
				  request is at the front of queue
  Allocate and initialize request queue and default IO scheduler.
  Deactivate and free request queue.
  Return disk geometry.
  end of block device operations
  SECTION: common functions for ccw_driver use
  Is the device read-only?
  Note that this function does not report the setting of the
  readonly device attribute, but how it is configured in zVM.
  Initial attempt at a probe function. this can be simplified once
  the other detection code is gone.
	
	  Automatically online either all dasd devices (dasd_autodetect)
	  or all devices specified with dasd= parameters during
	  initial probe.
 Forget the discipline information. 
  This will one day be called from a global not_oper handler.
  It is also used by driver_unregister during module unload.
 Already doing offline processing 
	
	  This device is removed unconditionally. Set offline
	  flag to prevent dasd_open from opening it while it is
	  no quite down yet.
 dasd_delete_device destroys the device reference. 
	
	  life cycle of block is bound to device, so delete it after
	  device was safely removed
  Activate a device. This is called from dasd_{eckd,fba}_probe() when either
  the device is detected for the first time and is supposed to be used
  or the user has started activation through sysfs.
 first online clears initial online feature flag 
 Try to load the required module. 
		 Module init could have failed, so check again here after
 check_device will allocate block device if necessary 
	
	  We must make sure that this device is currently not in use.
	  The open_count is increased for every opener, that includes
	  the blkdev_get in dasd_scan_partitions. We are only interested
	  in the other openers.
	
	  Test if the offline processing is already running and exit if so.
	  If a safe offline is being processed this could only be a normal
	  offline that should be able to overtake the safe offline and
	  cancel any IO we do not want to wait for any longer
	
	  if safe_offline is called set safe_offline_running flag and
	  clear safe_offline so that a call to normal offline
	  can overrun safe_offline processing
 need to unlock here to wait for outstanding IO 
		
		  If we want to set the device safe offline all IO operations
		  should be finished before continuing the offline process
		  so sync bdev first and then wait for our queues to become
		  empty
		
		  check if a normal offline process overtook the offline
		  processing in this case simply do nothing beside returning
		  that we got interrupted
		  otherwise mark safe offline as not running any longer and
		  continue with normal offline
 dasd_delete_device destroys the device reference. 
	
	  life cycle of block is bound to device, so delete it after
	  device was safely removed
 interrupted by signal 
 First of all call extended error reporting. 
 Device is active. We want to keep it. 
				
				  we can not establish a pathgroup on an
				  unavailable path, so trigger a path
				  verification first
		
		  device has no operational paths but at least one path is
		  disabled due to HPF errors
		  disable HPF at all and use the path(s) again
		
		  device has no operational paths but at least one path is
		  disabled due to IFCC errors
		  trigger path verification on paths with IFCC errors
  clear active requests and requeue them to block layer if possible
 Check status and move request to flush_queue 
 unable to terminate requeust 
		
		  requeue requests to blocklayer will only work
		  for block device requests
 remove requests from device and block queue 
 remove the request from the block queue 
 free the finished erp request 
		
		  _dasd_requeue_request already checked for a valid
		  blockdevice, no need to check again
		  all erp requests (cqr->refers) have a cqr->block
		  pointer copy from the original cqr
	
	  if requests remain then they are internal request
	  and go back to the device queue
 move freeze_queue to start of the ccw_queue 
 queue call to dasd_reload_device to the kernel event daemon. 
 RDC , rdc_buffer_size, device,
 internal error 13 - Allocating the RDC request failed
    In command mode and transport mode we need to look for sense
    data in different places. The sense data itself is allways
    an array of 32 bytes, so we can unify the sense data access
    for both modes.
 tsa_iostat 
 tsa_ddpc 
 currently we don't use interrogate data 
 register 'common' DASD debug area, used for all DBF_XXX calls 
 SPDX-License-Identifier: GPL-2.0
   Character device driver for extended error reporting.
   Copyright IBM Corp. 2005
   extended error reporting for DASD ECKD devices
   Author(s): Stefan Weinhuber <wein@de.ibm.com>
 PRINTK_HEADER 
  SECTION: the internal buffer
  The internal buffer is meant to store obaque blobs of data, so it does
  not know of higher level concepts like triggers.
  It consists of a number of pages that are used as a ringbuffer. Each data
  blob is stored in a simple record that consists of an integer, which
  contains the size of the following data, and the data bytes themselfes.
  To allow for multiple independent readers we create one internal buffer
  each time the device is opened and destroy the buffer when the file is
  closed again. The number of pages used for this buffer is determined by
  the module parmeter eer_pages.
  One record can be written to a buffer by using the functions
  - dasd_eer_start_record (one time per record to write the size to the
                           buffer and reserve the space for the data)
  - dasd_eer_write_buffer (one or more times per record to write the data)
  The data can be written in several steps but you will have to compute
  the total size up front for the invocation of dasd_eer_start_record.
  If the ringbuffer is full, dasd_eer_start_record will remove the required
  number of old records.
  A record is typically read in two steps, first read the integer that
  specifies the size of the following data, then read the data.
  Both can be done by
  - dasd_eer_read_buffer
  For all mentioned functions you need to get the bufferlock first and keep
  it until a complete record is written or read.
  All information necessary to keep track of an internal buffer is kept in
  a struct eerbuffer. The buffer specific to a file pointer is strored in
  the private_data field of that file. To be able to write data to all
  existing buffers, each buffer is also added to the bufferlist.
  If the user does not want to read a complete record in one go, we have to
  keep track of the rest of the record. residual stores the number of bytes
  that are still to deliver. If the rest of the record is invalidated between
  two reads then residual will be set to -1 so that the next read will fail.
  All entries in the eerbuffer structure are protected with the bufferlock.
  To avoid races between writing to a buffer on the one side and creating
  and destroying buffers on the other side, the bufferlock must also be used
  to protect the bufferlist.
  How many free bytes are available on the buffer.
  Needs to be called with bufferlock held.
  How many bytes of buffer space are used.
  Needs to be called with bufferlock held.
  The dasd_eer_write_buffer function just copies count bytes of data
  to the buffer. Make sure to call dasd_eer_start_record first, to
  make sure that enough free space is available.
  Needs to be called with bufferlock held.
 wrap around 
  Needs to be called with bufferlock held.
 wrap around 
  Whenever you want to write a blob of data to the internal buffer you
  have to start by using this function first. It will write the number
  of bytes that will be written to the buffer. If necessary it will remove
  old records to make room for the new one.
  Needs to be called with bufferlock held.
  Release pages that are not used anymore.
  Allocate a new set of memory pages.
  SECTION: The extended error reporting functionality
  When a DASD device driver wants to report an error, it calls the
  function dasd_eer_write and gives the respective trigger ID as
  parameter. Currently there are four kinds of triggers:
  DASD_EER_FATALERROR:  all kinds of unrecoverable IO problems
  DASD_EER_PPRCSUSPEND: PPRC was suspended
  DASD_EER_NOPATH:      There is no path to the device left.
  DASD_EER_STATECHANGE: The state of the device has changed.
  For the first three triggers all required information can be supplied by
  the caller. For these triggers a record is written by the function
  dasd_eer_write_standard_trigger.
  The DASD_EER_STATECHANGE trigger is special since a sense subsystem
  status ccw need to be executed to gather the necessary sense data first.
  The dasd_eer_snss function will queue the SNSS request and the request
  callback will then call dasd_eer_write with the DASD_EER_STATCHANGE
  trigger.
  To avoid memory allocations at runtime, the necessary memory is allocated
  when the extended error reporting is enabled for a device (by
  dasd_eer_probe). There is one sense subsystem status request for each
  eer enabled DASD device. The presence of the cqr in device->eer_cqr
  indicates that eer is enable for the device. The use of the snss request
  is protected by the DASD_FLAG_EER_IN_USE bit. When this flag indicates
  that the cqr is currently in use, dasd_eer_snss cannot start a second
  request but sets the DASD_FLAG_EER_SNSS flag instead. The callback of
  the SNSS request will check the bit and call dasd_eer_snss again.
  The following function can be used for those triggers that have
  all necessary data available when the function is called.
  If the parameter cqr is not NULL, the chain of requests will be searched
  for valid sense data, and all valid sense data sets will be added to
  the triggers data.
 go through cqr chain and count the valid sense data sets 
 "EOR" 
  This function writes a DASD_EER_STATECHANGE trigger.
 "EOR" 
  This function is called for all triggers. It calls the appropriate
  function that writes the actual trigger records.
 unknown trigger, so we write it without any sense data 
  Start a sense subsystem status request.
  Needs to be called with the device held.
 Device not eer enabled. 
 Sense subsystem status request in use. 
 cdev is already locked, can't use dasd_add_request_head 
  Callback function for use with sense subsystem status request.
 Another SNSS has been requested in the meantime. 
		
		  Extended error recovery has been switched off while
		  the SNSS request was running. It could even have
		  been switched off and on again in which case there
		  is a new ccw in device->eer_cqr. Free the "old"
		  snss request now.
  Enable error reporting on a given device.
 SNSS ,
  Disable error reporting on a given device.
  SECTION: the device operations
  On the one side we need a lock to access our internal buffer, on the
  other side a copy_to_user can sleep. So we need to copy the data we have
  to transfer in a readbuffer, which is protected by the readbuffer_mutex.
 the remainder of this record 
 has been deleted             
 OK we still have a second half of a record to deliver 
 no data available 
 SPDX-License-Identifier: GPL-2.0
  Author(s)......: Holger Smolinski <Holger.Smolinski@de.ibm.com>
 		    Horst Hummel <Horst.Hummel@de.ibm.com>
 		    Carsten Otte <Cotte@de.ibm.com>
 		    Martin Schwidefsky <schwidefsky@de.ibm.com>
  Bugreports.to..: <Linux390@de.ibm.com>
  Copyright IBM Corp. 1999, 2001
 This is ugly... 
 Sanity checks 
  dasd_default_erp_action just retries the current cqr
 just retry - there is nothing to save ... I got no sense data.... 
 end dasd_default_erp_action 
  DESCRIPTION
    Frees all ERPs of the current ERP Chain and set the status
    of the original CQR either to DASD_CQR_DONE if ERP was successful
    or to DASD_CQR_FAILED if ERP was NOT successful.
    NOTE: This function is only called if no discipline postaction
 	   is available
  PARAMETER
    erp		current erp_head
  RETURN VALUES
    cqr		pointer to the original CQR
 free all ERPs - but NOT the original cqr 
 remove the request from the block queue 
 free the finished erp request 
 set corresponding status to original cqr 
 end default_erp_postaction 
 dump sense data 
 dump sense data to s390 debugfeature
 SPDX-License-Identifier: GPL-2.0
  Author(s)......: Horst  Hummel    <Horst.Hummel@de.ibm.com>
 		    Holger Smolinski <Holger.Smolinski@de.ibm.com>
  Bugreports.to..: <Linux390@de.ibm.com>
  Copyright IBM Corp. 2000, 2001
 e.g Inhibit Write, Enable Write,... 
 Subcommand modifier 
 reserved 
  SECTION ERP HANDLING
  24 and 32 byte sense ERP functions
  DASD_3990_ERP_CLEANUP
  DESCRIPTION
    Removes the already build but not necessary ERP request and sets
    the status of the original cqr  erp to the given (final) status
   PARAMETER
    erp		request to be blocked
    final_status	either DASD_CQR_DONE or DASD_CQR_FAILED
  RETURN VALUES
    cqr		original cqr
 end dasd_3990_erp_cleanup 
  DASD_3990_ERP_BLOCK_QUEUE
  DESCRIPTION
    Block the given device request queue to prevent from further
    processing until the started timer has expired or an related
    interrupt was received.
  DASD_3990_ERP_INT_REQ
  DESCRIPTION
    Handles 'Intervention Required' error.
    This means either device offline or not installed.
  PARAMETER
    erp		current erp
  RETURN VALUES
    erp		modified erp
 first time set initial retry counter and erp_function 
 and retry once without blocking queue		 
 (this enables easier enqueing of the cqr)		 
 issue a message and wait for 'device ready' interrupt 
 end dasd_3990_erp_int_req 
  DASD_3990_ERP_ALTERNATE_PATH
  DESCRIPTION
    Repeat the operation on a different channel path.
    If all alternate paths have been tried, the request is posted with a
    permanent error.
   PARAMETER
    erp		pointer to the current ERP
  RETURN VALUES
    erp		modified pointer to the ERP
 try alternate valid path 
 reset status to submit the request again... 
 post request with permanent error 
 end dasd_3990_erp_alternate_path 
  DASD_3990_ERP_DCTL
  DESCRIPTION
    Setup cqr to do the Diagnostic Control (DCTL) command with an
    Inhibit Write subcommand (0x20) and the given modifier.
   PARAMETER
    erp		pointer to the current (failed) ERP
    modifier		subcommand modifier
  RETURN VALUES
    dctl_cqr		pointer to NEW dctl_cqr
 Inhibit Write 
 end dasd_3990_erp_DCTL 
  DASD_3990_ERP_ACTION_1
  DESCRIPTION
    Setup ERP to do the ERP action 1 (see Reference manual).
    Repeat the operation on a different channel path.
    As deviation from the recommended recovery action, we reset the path mask
    after we have tried each path and go through all paths a second time.
    This will cover situations where only one path at a time is actually down,
    but all paths fail and recover just with the same sequence and timing as
    we try to use them (flapping links).
    If all alternate paths have been tried twice, the request is posted with
    a permanent error.
   PARAMETER
    erp		pointer to the current ERP
  RETURN VALUES
    erp		pointer to the ERP
 end dasd_3990_erp_action_1(b) 
  DASD_3990_ERP_ACTION_4
  DESCRIPTION
    Setup ERP to do the ERP action 4 (see Reference manual).
    Set the current request to PENDING to block the CQR queue for that device
    until the state change interrupt appears.
    Use a timer (20 seconds) to retry the cqr if the interrupt is still
    missing.
   PARAMETER
    sense		sense data of the actual error
    erp		pointer to the current ERP
  RETURN VALUES
    erp		pointer to the ERP
 first time set initial retry counter and erp_function    
 and retry once without waiting for state change pending  
 interrupt (this enables easier enqueing of the cqr)	    
 state change pending 
 busy 
 no state change pending - retry 
 end dasd_3990_erp_action_4 
  24 byte sense ERP functions (only)
  DASD_3990_ERP_ACTION_5
  DESCRIPTION
    Setup ERP to do the ERP action 5 (see Reference manual).
    NOTE: Further handling is done in xxx_further_erp after the retries.
   PARAMETER
    erp		pointer to the current ERP
  RETURN VALUES
    erp		pointer to the ERP
 first of all retry 
 end dasd_3990_erp_action_5 
  DASD_3990_HANDLE_ENV_DATA
  DESCRIPTION
    Handles 24 byte 'Environmental data present'.
    Does a analysis of the sense data (message Format)
    and prints the error messages.
  PARAMETER
    sense		current sense data
  RETURN VALUES
    void
 Format 0 - Program or System Checks 
 check message to operator bit 
 No Message 
 No Message 
 Format 1 - Device Equipment Checks 
 No Message 
 Format 2 - 3990 Equipment Checks 
 Format 3 - 3990 Control Checks 
 Format 4 - Data Checks 
 Format 5 - Data Check with displacement information 
 Format 6 - Usage StatisticsOverrun Errors 
 Format 7 - Device Connection Control Checks 
 Format 8 - Additional Device Equipment Checks 
 No Message 
 Format 9 - Device Read, Write, and Seek Checks 
 No Message 
 Format F - Cache Storage Checks 
 call extended error reporting (EER) 
	default:	 unknown message format - should not happen
 end switch message format 
 end dasd_3990_handle_env_data 
  DASD_3990_ERP_COM_REJ
  DESCRIPTION
    Handles 24 byte 'Command Reject' error.
  PARAMETER
    erp		current erp_head
    sense		current sense data
  RETURN VALUES
    erp		'new' erp_head - pointer to new ERP
 env data present (ACTION 10 - retry should work) 
		 fatal error -  set status to FAILED
 end dasd_3990_erp_com_rej 
  DASD_3990_ERP_BUS_OUT
  DESCRIPTION
    Handles 24 byte 'Bus Out Parity Check' error.
  PARAMETER
    erp		current erp_head
  RETURN VALUES
    erp		new erp_head - pointer to new ERP
 first time set initial retry counter and erp_function 
 and retry once without blocking queue		 
 (this enables easier enqueing of the cqr)		 
 issue a message and wait for 'device ready' interrupt 
 end dasd_3990_erp_bus_out 
  DASD_3990_ERP_EQUIP_CHECK
  DESCRIPTION
    Handles 24 byte 'Equipment Check' error.
  PARAMETER
    erp		current erp_head
  RETURN VALUES
    erp		new erp_head - pointer to new ERP
		 vary path offline
 all other equipment checks - Action 5 
 rest is done when retries == 0 
 end dasd_3990_erp_equip_check 
  DASD_3990_ERP_DATA_CHECK
  DESCRIPTION
    Handles 24 byte 'Data Check' error.
  PARAMETER
    erp		current erp_head
  RETURN VALUES
    erp		new erp_head - pointer to new ERP
 correctable data check 
 issue message that the data has been corrected 
 not possible to handle this situation in Linux 
 all other data checks 
 end dasd_3990_erp_data_check 
  DASD_3990_ERP_OVERRUN
  DESCRIPTION
    Handles 24 byte 'Overrun' error.
  PARAMETER
    erp		current erp_head
  RETURN VALUES
    erp		new erp_head - pointer to new ERP
 end dasd_3990_erp_overrun 
  DASD_3990_ERP_INV_FORMAT
  DESCRIPTION
    Handles 24 byte 'Invalid Track Format' error.
  PARAMETER
    erp		current erp_head
  RETURN VALUES
    erp		new erp_head - pointer to new ERP
 internal error 06 - The track format is not valid
 end dasd_3990_erp_inv_format 
  DASD_3990_ERP_EOC
  DESCRIPTION
    Handles 24 byte 'End-of-Cylinder' error.
  PARAMETER
    erp		already added default erp
  RETURN VALUES
    erp		pointer to original (failed) cqr.
 implement action 7 - BUG 
 end dasd_3990_erp_EOC 
  DASD_3990_ERP_ENV_DATA
  DESCRIPTION
    Handles 24 byte 'Environmental-Data Present' error.
  PARAMETER
    erp		current erp_head
  RETURN VALUES
    erp		new erp_head - pointer to new ERP
 don't retry on disabled interface 
 end dasd_3990_erp_env_data 
  DASD_3990_ERP_NO_REC
  DESCRIPTION
    Handles 24 byte 'No Record Found' error.
  PARAMETER
    erp		already added default ERP
  RETURN VALUES
    erp		new erp_head - pointer to new ERP
	
	  In some cases the 'No Record Found' error might be expected and
	  log messages shouldn't be written then.
	  Check if the according suppress bit is set.
 end dasd_3990_erp_no_rec 
  DASD_3990_ERP_FILE_PROT
  DESCRIPTION
    Handles 24 byte 'File Protected' error.
    Note: Seek related recovery is not implemented because
 	   wee don't use the seek command yet.
  PARAMETER
    erp		current erp_head
  RETURN VALUES
    erp		new erp_head - pointer to new ERP
	
	  In some cases the 'File Protected' error might be expected and
	  log messages shouldn't be written then.
	  Check if the according suppress bit is set.
 end dasd_3990_erp_file_prot 
  DASD_3990_ERP_INSPECT_ALIAS
  DESCRIPTION
    Checks if the original request was started on an alias device.
    If yes, it modifies the original and the erp request so that
    the erp request can be started on a base device.
  PARAMETER
    erp		pointer to the currently created default ERP
  RETURN VALUES
    erp		pointer to the modified ERP, or NULL
		
		  dynamic pav may have changed base alias mapping
			
			  remove device from alias handling to prevent new
			  requests from being scheduled on the
			  wrong alias device
 schedule worker to reload device 
  DASD_3990_ERP_INSPECT_24
  DESCRIPTION
    Does a detailed inspection of the 24 byte sense data
    and sets up a related error recovery action.
  PARAMETER
    sense		sense data of the actual error
    erp		pointer to the currently created default ERP
  RETURN VALUES
    erp		pointer to the (addtitional) ERP
 Check sense for ....	   
 'Command Reject'	   
 'Intervention Required' 
 'Bus Out Parity Check'  
 'Equipment Check'	   
 'Data Check'		   
 'Overrun'		   
 'Invalid Track Format'  
 'End-of-Cylinder'	   
 'Environmental Data'	   
 'No Record Found'	   
 'File Protected'	   
 other (unknown) error - do default ERP 
 END dasd_3990_erp_inspect_24 
  32 byte sense ERP functions (only)
  DASD_3990_ERPACTION_10_32
  DESCRIPTION
    Handles 32 byte 'Action 10' of Single Program Action Codes.
    Just retry and if retry doesn't work, return with error.
  PARAMETER
    erp		current erp_head
    sense		current sense data
  RETURN VALUES
    erp		modified erp_head
 end dasd_3990_erp_action_10_32 
  DASD_3990_ERP_ACTION_1B_32
  DESCRIPTION
    Handles 32 byte 'Action 1B' of Single Program Action Codes.
    A write operation could not be finished because of an unexpected
    condition.
    The already created 'default erp' is used to get the link to
    the erp chain, but it can not be used for this recovery
    action because it contains no DELO data space.
  PARAMETER
    default_erp	already added default erp.
    sense		current sense data
  RETURN VALUES
    erp		new erp or
 			default_erp in case of imprecise ending or error
 LO_eckd_data_t 
 determine the original cqr 
 for imprecise ending just do default erp 
 determine the address of the CCW to be restarted 
 Imprecise ending is not set -> addr from IRB-SCSW 
 Build new ERP request including DELO 
 DELO + TIC 
 internal error 01 - Unable to allocate ERP 
 use original DE 
 create LO 
 should not 
 operation code is WRITE DATA -> data area orientation 
 operation code is FORMAT WRITE -> index orientation 
 operation 
 auxiliary 
 count 
 seek_addr.cyl 
 seek_addr.cyl 2nd byte 
 seek_addr.head 2nd byte 
 create DE ccw 
 create LO ccw 
 TIC to the failed ccw 
 fill erp related fields 
 remove the default erp 
 end dasd_3990_erp_action_1B_32 
  DASD_3990_UPDATE_1B
  DESCRIPTION
    Handles the update to the 32 byte 'Action 1B' of Single Program
    Action Codes in case the first action was not successful.
    The already created 'previous_erp' is the currently not successful
    ERP.
  PARAMETER
    previous_erp	already created previous erp.
    sense		current sense data
  RETURN VALUES
    erp		modified erp
 struct LO_eckd_data 
 determine the original cqr 
 for imprecise ending just do default erp 
 determine the address of the CCW to be restarted 
 Imprecise ending is not set -> addr from IRB-SCSW 
		 internal error 02 -
 update the LO with the new returned sense data  
 should not happen 
 operation code is WRITE DATA -> data area orientation 
 operation code is FORMAT WRITE -> index orientation 
 operation 
 auxiliary 
 count 
 seek_addr.cyl 
 seek_addr.cyl 2nd byte 
 seek_addr.head 2nd byte 
 TIC to the failed ccw 
 addr of DE ccw 
 addr of LE ccw 
 addr of TIC ccw 
 end dasd_3990_update_1B 
  DASD_3990_ERP_COMPOUND_RETRY
  DESCRIPTION
    Handles the compound ERP action retry code.
    NOTE: At least one retry is done even if zero is specified
 	   by the sense data. This makes enqueueing of the request
 	   easier.
  PARAMETER
    sense		sense data of the actual error
    erp		pointer to the currently created ERP
  RETURN VALUES
    erp		modified ERP pointer
 no not retry 
 retry 2 times 
 retry 10 times 
 retry 256 times 
 end dasd_3990_erp_compound_retry 
  DASD_3990_ERP_COMPOUND_PATH
  DESCRIPTION
    Handles the compound ERP action for retry on alternate
    channel path.
  PARAMETER
    sense		sense data of the actual error
    erp		pointer to the currently created ERP
  RETURN VALUES
    erp		modified ERP pointer
			 reset the lpm and the status to be able to
 end dasd_3990_erp_compound_path 
  DASD_3990_ERP_COMPOUND_CODE
  DESCRIPTION
    Handles the compound ERP action for retry code.
  PARAMETER
    sense		sense data of the actual error
    erp		pointer to the currently created ERP
  RETURN VALUES
    erp		NEW ERP pointer
			 issue a Diagnostic Control command with an
 wait for 5 seconds and retry again 
 should not happen - continue 
 end dasd_3990_erp_compound_code 
  DASD_3990_ERP_COMPOUND_CONFIG
  DESCRIPTION
    Handles the compound ERP action for configuration
    dependent error.
    Note: duplex handling is not implemented (yet).
  PARAMETER
    sense		sense data of the actual error
    erp		pointer to the currently created ERP
  RETURN VALUES
    erp		modified ERP pointer
		 set to suspended duplex state then restart
		   internal error 05 - Set device to suspended duplex state
 end dasd_3990_erp_compound_config 
  DASD_3990_ERP_COMPOUND
  DESCRIPTION
    Does the further compound program action if
    compound retry was not successful.
  PARAMETER
    sense		sense data of the actual error
    erp		pointer to the current (failed) ERP
  RETURN VALUES
    erp		(additional) ERP pointer
 if no compound action ERP specified, the request failed 
 end dasd_3990_erp_compound 
 DASD_3990_ERP_HANDLE_SIM
 DESCRIPTION
   inspects the SIM SENSE data and starts an appropriate action
  PARAMETER
    sense	   sense data of the actual error
  RETURN VALUES
    none
 print message according to log or message to operator mode 
 print SIM SRC from RefCode 
 print SIM SRC Refcode 
  DASD_3990_ERP_INSPECT_32
  DESCRIPTION
    Does a detailed inspection of the 32 byte sense data
    and sets up a related error recovery action.
  PARAMETER
    sense		sense data of the actual error
    erp		pointer to the currently created default ERP
  RETURN VALUES
    erp_filled		pointer to the ERP
 check for SIM sense data 
 compound program action codes (byte25 bit 0 == '1') 
 single program action codes (byte25 bit 0 == '0') 
 success - use default ERP for retries 
 fatal error 
 intervention required 
 intervention required during dual copy 
		case 0x0F:   length mismatch during update write command
 logging required for other channel program 
		case 0x15:	 next track outside defined extend
				   internal error 07 - The next track is not
 unexpected condition during write 
 invalid data 
 not possible to handle this situation in Linux 
 state-change pending 
 busy 
 all others errors - default erp  
 end dasd_3990_erp_inspect_32 
 no remaining path, cannot disable 
	
	  check if the last error is longer ago than the timeout,
	  if so reset error state
 threshold exceeded disable path if possible 
  main ERP control functions (24 and 32 byte sense)
  DASD_3990_ERP_CONTROL_CHECK
  DESCRIPTION
    Does a generic inspection if a control check occurred and sets up
    the related error recovery procedure
  PARAMETER
    erp		pointer to the currently created default ERP
  RETURN VALUES
    erp_filled		pointer to the erp
  DASD_3990_ERP_INSPECT
  DESCRIPTION
    Does a detailed inspection for sense data by calling either
    the 24-byte or the 32-byte inspection routine.
  PARAMETER
    erp		pointer to the currently created default ERP
  RETURN VALUES
    erp_new		contens was possibly modified
 if this problem occurred on an alias retry on base 
	 sense data are located in the refers record of the
	  already set up new ERP !
	  check if concurrent sens is available
 distinguish between 24 and 32 byte sense data 
 inspect the 24 byte sense data 
 inspect the 32 byte sense data 
 end distinguish between 24 and 32 byte sense data 
  DASD_3990_ERP_ADD_ERP
  DESCRIPTION
    This function adds an additional request block (ERP) to the head of
    the given cqr (or erp).
    For a command mode cqr the erp is initialized as an default erp
    (retry TIC).
    For transport mode we make a copy of the original TCW (points to
    the original TCCB, TIDALs, etc.) but give it a fresh
    TSB so the original sense data will not be changed.
  PARAMETER
    cqr		head of the current ERP-chain (or single cqr if
 			first error)
  RETURN VALUES
    erp		pointer to new ERP-chain head
 TCW needs to be 64 byte aligned, so leave enough room 
 allocate additional request block 
 make a shallow copy of the original tcw but set new tsb 
 PSF cannot be chained from NOOPTIC 
 initialize request with default TIC to current ERPCQR 
  DASD_3990_ERP_ADDITIONAL_ERP
  DESCRIPTION
    An additional ERP is needed to handle the current error.
    Add ERP to the head of the ERP-chain containing the ERP processing
    determined based on the sense data.
  PARAMETER
    cqr		head of the current ERP-chain (or single cqr if
 			first error)
  RETURN VALUES
    erp		pointer to new ERP-chain head
 add erp and initialize with default TIC 
 inspect sense, determine specific ERP if possible 
 end dasd_3990_erp_additional_erp 
  DASD_3990_ERP_ERROR_MATCH
  DESCRIPTION
    Check if the device status of the given cqr is the same.
    This means that the failed CCW and the relevant sense data
    must match.
    I don't distinguish between 24 and 32 byte sense because in case of
    24 byte sense byte 25 and 27 is set as well.
  PARAMETER
    cqr1		first cqr, which will be compared with the
    cqr2		second cqr.
  RETURN VALUES
    match		'boolean' for match found
 			returns 1 if match found, otherwise 0.
 one request has sense data, the other not -> no match, return 0 
 no sense data in both cases -> check cstat for IFCC 
 match with ifcc
 check sense data; byte 0-2,25,27 
 sense doesn't match 
 match 
 end dasd_3990_erp_error_match 
  DASD_3990_ERP_IN_ERP
  DESCRIPTION
    check if the current error already happened before.
    quick exit if current cqr is not an ERP (cqr->refers=NULL)
  PARAMETER
    cqr		failed cqr (either original cqr or already an erp)
  RETURN VALUES
    erp		erp-pointer to the already defined error
 			recovery procedure OR
 			NULL if a 'new' error occurred.
 save erp chain head 
 save erp chain head 
 'boolean' for matching error found 
 return if not in erp 
 check the erpcqr chain for current error 
 save possible matching erp  
 check next erpcqr in queue 
 no match was found 
 return address of matching erp 
 END dasd_3990_erp_in_erp 
  DASD_3990_ERP_FURTHER_ERP (24 & 32 byte sense)
  DESCRIPTION
    No retry is left for the current ERP. Check what has to be done
    with the ERP.
      - do further defined ERP action or
      - wait for interrupt or
      - exit with permanent error
  PARAMETER
    erp		ERP which is in progress with no retry left
  RETURN VALUES
    erp		modifiedadditional ERP
 check for 24 byte sense ERP 
 retries have not been successful 
 prepare erp for retry on different channel path 
			 issue a Diagnostic Control command with an
 controller 
 channel path 
 storage director 
 check for 32 byte sense ERP 
		
		  No retry left and no additional special handling
		  necessary
 end dasd_3990_erp_further_erp 
  DASD_3990_ERP_HANDLE_MATCH_ERP
  DESCRIPTION
    An error occurred again and an ERP has been detected which is already
    used to handle this error (e.g. retries).
    All prior ERP's are asumed to be successful and therefore removed
    from queue.
    If retry counter of matching erp is already 0, it is checked if further
    action is needed (besides retry) or if the ERP has failed.
  PARAMETER
    erp_head		first ERP in ERP-chain
    erp		ERP that handles the actual error.
 			(matching erp)
  RETURN VALUES
    erp		modifiedadditional ERP
 finished req 
 req to be freed 
 loop over successful ERPs and remove them from chanq 
 end of chain reached 
 remove the request from the device queue 
 free the finished erp request 
 end while 
 check for special retries 
 simple retry	  
 handle the request again... 
 no retry left - check for further necessary action	 
 if no further actions, handle rest as permanent error 
 end dasd_3990_erp_handle_match_erp 
  DASD_3990_ERP_ACTION
  DESCRIPTION
    control routine for 3990 erp actions.
    Has to be called with the queue lock (namely the s390_irq_lock) acquired.
  PARAMETER
    cqr		failed cqr (either original cqr or already an erp)
  RETURN VALUES
    erp		erp-pointer to the head of the ERP action chain.
 			This means:
 			 - either a ptr to an additional ERP cqr or
 			 - the original given cqr (which's status might
 			   be modified)
 print current erp_chain 
 double-check if current erpcqr was successful 
 check if error happened before 
 no matching erp found - set up erp 
 matching erp found - set all leading erp's to DONE 
	
	  For path verification work we need to stick with the path that was
	  originally chosen so that the per path configuration data is
	  assigned correctly.
 print current erp_chain 
 enqueue ERP request if it's a new one 
 add erp request before the cqr 
 end dasd_3990_erp_action 
 SPDX-License-Identifier: GPL-2.0
  Author(s)......: Holger Smolinski <Holger.Smolinski@de.ibm.com>
 		    Horst Hummel <Horst.Hummel@de.ibm.com>
 		    Carsten Otte <Cotte@de.ibm.com>
 		    Martin Schwidefsky <schwidefsky@de.ibm.com>
  Bugreports.to..: <Linux390@de.ibm.com>
  Copyright IBM Corp. 1999, 2001
  gendisk related functions for the dasd driver.
 This is ugly... 
  Allocate and register gendisk structure for device.
 Make sure the minor for this device exists. 
 Initialize gendisk structure. 
	
	  Set device name.
	    dasda - dasdz : 26 devices
	    dasdaa - dasdzz : 676 devices, added up = 702
	    dasdaaa - dasdzzz : 17576 devices, added up = 18278
	    dasdaaaa - dasdzzzz : 456976 devices, added up = 475252
  Unregister and free gendisk structure for device.
  Trigger a partition detection.
	
	  Since the matching blkdev_put call to the blkdev_get in
	  this function is not called before dasd_destroy_partitions
	  the offline open_count limit needs to be increased from
	  0 to 1. This is done by setting device->bdev (see
	  dasd_generic_set_offline). As long as the partition
	  detection is running no offline should be allowed. That
	  is why the assignment to device->bdev is done AFTER
	  the BLKRRPART ioctl.
  Remove all inodes in the system for a device, delete the
  partitions and make device unusable by setting its size to zero.
	
	  Get the bdev pointer from the device structure and clear
	  device->bdev to lower the offline open_count limit again.
 Matching blkdev_put to the blkdev_get in dasd_scan_partitions. 
 Register to static dasd major 94 
 SPDX-License-Identifier: GPL-2.0+
  Copyright IBM Corp. 2006, 2021
  Author(s): Cornelia Huck <cornelia.huck@de.ibm.com>
 	      Martin Schwidefsky <schwidefsky@de.ibm.com>
 	      Ralph Wuerthner <rwuerthn@de.ibm.com>
 	      Felix Beck <felix.beck@de.ibm.com>
 	      Holger Dengler <hd@linux.vnet.ibm.com>
 	      Harald Freudenberger <freude@linux.ibm.com>
  Adjunct processor bus.
  Module parameters; note though this file itself isn't modular.
 Adjunct Processor Domain Index 
 Hashtable of all queue devices on the AP bus 
 lock used for the ap_queues hashtable 
 Default permissions (ioctl, card and domain masking) 
 # of bus scans since init 
 # of bindings complete since init 
 completion for initial APQN bindings complete 
  AP bus related debug feature things.
  Workqueue timer for bus rescan.
  Tasklet & timer for AP request polling and interrupts
  In LPAR poll with 4kHz frequency. Poll every 250000 nanoseconds.
  If zVM change to 1500000 nanoseconds to adjust to zVM polling.
 Maximum domain id, if not given via qci 
 Maximum adapter id, if not given via qci 
 Adapter interrupt definitions 
  ap_airq_ptr() - Get the address of the adapter interrupt indicator
  Returns the address of the local-summary-indicator of the adapter
  interrupt handler for AP, or NULL if adapter interrupts are not
  available.
  ap_interrupts_available(): Test if AP interrupts are available.
  Returns 1 if AP interrupts are available.
  ap_qci_available(): Test if AP configuration
  information can be queried via QCI subfunction.
  Returns 1 if subfunction PQAP(QCI) is available.
  ap_apft_available(): Test if AP facilities test (APFT)
  facility is available.
  Returns 1 if APFT is is available.
  ap_qact_available(): Test if the PQAP(QACT) subfunction is available.
  Returns 1 if the QACT subfunction is available.
  ap_fetch_qci_info(): Fetch cryptographic config info
  Returns the ap configuration info fetched via PQAP(QCI).
  On success 0 is returned, on failure a negative errno
  is returned, e.g. if the PQAP(QCI) instruction is not
  available, the return value will be -EOPNOTSUPP.
  ap_init_qci_info(): Allocate and query qci config info.
  Does also update the static variables ap_max_domain_id
  and ap_max_adapter_id if this info is available.
  ap_test_config(): helper function to extract the nrth bit
 		     within the unsigned int array field.
  ap_test_config_card_id(): Test, whether an AP card ID is configured.
  Returns 0 if the card is not configured
 	   1 if the card is configured or
 	     if the configuration information is not available
  ap_test_config_usage_domain(): Test, whether an AP usage domain
  is configured.
  Returns 0 if the usage domain is not configured
 	   1 if the usage domain is configured or
 	     if the configuration information is not available
  ap_test_config_ctrl_domain(): Test, whether an AP control domain
  is configured.
  @domain AP control domain ID
  Returns 1 if the control domain is configured
 	   0 in all other cases
  ap_queue_info(): Check and get AP queue info.
  Returns true if TAPQ succeeded and the info is filled or
  false otherwise.
 facility bits 
 ap type 
 apxl ml 
 queue depth 
 make sure we don't run into a specifiation exception 
 call TAPQ on this APQN 
		
		  According to the architecture in all these cases the
		  info should be filled. All bits 0 is not possible as
		  there is at least one of the mode bits set.
			 For CEX2 and CEX3 the available functions
			  are not reflected by the facilities bits.
			  Instead it is coded into the type. So here
			  modify the function bits based on the type.
		
		  A response code which indicates, there is no info available.
  ap_request_timeout(): Handling of request timeouts
  @t: timer making this callback
  Handles request timeouts.
  ap_poll_timeout(): AP receive polling for finished AP requests.
  @unused: Unused pointer.
  Schedules the AP tasklet using a high resolution timer.
  ap_interrupt_handler() - Schedule ap_tasklet on interrupt
  @airq: pointer to adapter interrupt descriptor
  @floating: ignored
  ap_tasklet_fn(): Tasklet to poll all AP devices.
  @dummy: Unused variable
  Poll all AP devices on the bus.
	 Reset the indicator if interrupts are used. Thus new interrupts can
	  be received. Doing it in the beginning of the tasklet is therefor
	  important that no requests on any AP get lost.
  ap_poll_thread(): Thread that polls for finished requests.
  @data: Unused pointer
  AP bus poll thread. The purpose of this thread is to poll for
  finished requests in a loop if there is a "free" cpu - that is
  a cpu that doesn't have anything better to do. The polling stops
  as soon as there is another task or if all messages have been
  delivered.
  ap_bus_match()
  @dev: Pointer to device
  @drv: Pointer to device_driver
  AP bus driver registrationunregistration.
	
	  Compare device type of the device with the list of
	  supported types of the device_driver.
  ap_uevent(): Uevent function for AP devices.
  @dev: Pointer to device
  @env: Pointer to kobj_uevent_env
  It sets up a single environment variable DEV_TYPE which contains the
  hardware device type.
 Uevents from ap bus core don't need extensions to the env 
 Set up DEV_TYPE environment variable. 
 Add MODALIAS= 
 Add MODE=<accel|cca|ep11> 
 Add MODE=<accel|cca|ep11> 
  calc # of bound APQNs
  After initial ap bus scan do check if all existing APQNs are
  bound to device drivers.
  Interface to wait for the AP bus to have done one initial ap bus
  scan and all detected APQNs have been bound to device drivers.
  If these both conditions are not fulfilled, this function blocks
  on a condition with wait_for_completion_interruptible_timeout().
  If these both conditions are fulfilled (before the timeout hits)
  the return value is 0. If the timeout (in jiffies) hits instead
  -ETIME is returned. On failures negative return values are
  returned to the caller.
		
		  If the apqn is marked as reservedused by ap bus and
		  default drivers, only probe with drivers with the default
		  flag set. If it is not marked, only probe with drivers
		  with the default flag not set.
 Add queuecard to list of active queuescards 
 prepare ap queue device removal 
 driver's chance to clean up gracefully 
 now do the ap queue device remove 
 Remove queuecard from list of active queuescards 
 processing a asynchronous bus rescan 
 A config change has happened, force an ap bus rescan.
  hex2bitmap() - parse hex mask string and set bitmap.
  Valid strings are "0x012345678" with at least one valid hex number.
  Rest of the bitmap to the right is padded with 0. No spaces allowed
  within the string, the leading 0x may be omitted.
  Returns the bitmask with exactly the bits set as given by the hex
  string (both in big endian order).
 bits needs to be a multiple of 8 
  modify_bitmap() - parse bitmask argument and modify an existing
  bit mask accordingly. A concatenation (done with ',') of these
  terms is recognized:
    +<bitnr>[-<bitnr>] or -<bitnr>[-<bitnr>]
  <bitnr> may be any valid number (hex, decimal or octal) in the range
  0...bits-1; the leading + or - is required. Here are some examples:
    +0-15,+32,-128,-0xFF
    -0-255,+1-16,+0x128
    +1,+2,+3,+4,-5,-7-10
  Returns the new bitmap after all changes have been applied. Every
  positive value in the string will set a bit and every negative value
  in the string will clear a bit. As a bit may be touched more than once,
  the last 'operation' wins:
  +0-255,-128 = first bits 0-255 will be set, then bit 128 will be
  cleared again. All other bits are unmodified.
 bits needs to be a multiple of 8 
 bits needs to be a multiple of 8 
  AP bus attributes.
 QCI not supported 
 QCI not supported 
 QCI not supported 
 120 seconds = maximum poll interval 
  ap_select_domain(): Select an AP domain if possible and we haven't
  already done so before.
	
	  Choose the default domain. Either the one specified with
	  the "domain=" parameter or the first domain with at least
	  one valid APQN.
 Domain has already been selected. 
  This function checks the type and returns either 0 for not
  supported or the highest compatible type value (which may
  include the input type value).
 < CEX2A is not supported 
 up to CEX7 known and fully supported 
	
	  unknown new type > CEX7, check for compatibility
	  to the highest known and supported type which is
	  currently CEX7 with the help of the QACT function.
  Helper function to be used with bus_find_dev
  matches for the card device with the given id
  Helper function to be used with bus_find_dev
  matches for the queue device with a given qid
  Helper function to be used with bus_find_dev
  matches any queue device with given queue id
  Helper function for ap_scan_bus().
  Remove card device and associated queue devices.
  Helper function for ap_scan_bus().
  Does the scan bus job for all the domains within
  a valid adapter given by an ap_card ptr.
	
	  Go through the configuration for the domains and compare them
	  to the existing queue devices. Also take care of the config
	  and error state for the queue devices.
 domain is valid, get info from this APQN 
 if no queue device exists, create a new one 
 register queue device 
 get it and thus adjust reference counter 
 Check config state on the already existing queue device 
 config off this queue device 
 'receive' pending messages with -EAGAIN 
 config on this queue device 
 handle other error states 
 'receive' pending messages with -EAGAIN 
 re-init (with reset) the queue device 
  Helper function for ap_scan_bus().
  Does the scan bus job for the given adapter id.
 Is there currently a card device for this adapter ? 
 Adapter not in configuration ? 
	
	  Adapter ap is valid in the current configuration. So do some checks:
	  If no card device exists, build one. If a card device exists, check
	  for type and functions changed. For all this we need to find a valid
	  APQN first.
 Could not find a valid APQN for this adapter 
 No apdater type info available, an unusable adapter 
 Check APQN against existing card device for changes 
 Build a new card device 
 maybe enlarge ap_max_msg_size to support this card 
 Register the new card device with AP bus 
 get it and thus adjust reference counter 
 Verify the domains and the queue devices for this card 
 release the card device 
  ap_scan_bus(): Scan the AP bus for new devices
  Runs periodically, workqueue timer (ap_config_time)
  @unused: Unused pointer.
 loop over all possible adapters 
 check if there is at least one queue available with default domain 
 all resources useable if no kernel parameter string given 
 apm kernel parameter string 
 aqm kernel parameter string 
  ap_module_init(): The module initialization code.
  Initializes the module.
 init ap_queue hashtable 
 set up the AP permissions (ioctls, ap and aq masks) 
 Get AP configuration data if available 
 check default domain setting 
 enable interrupts if available 
 Create sysbusap. 
 Create sysdevicesap. 
 Setup the AP bus rescan timer. 
	
	  Setup the high resultion poll timer.
	  If we are running under zVM adjust polling to zVM polling rate.
 Start the low priority AP bus poll thread. 
 SPDX-License-Identifier: GPL-2.0+
  Adjunct processor matrix VFIO device driver callbacks.
  Copyright IBM Corp. 2018
  Author(s): Tony Krowiak <akrowiak@linux.ibm.com>
 	      Halil Pasic <pasic@linux.ibm.com>
 	      Pierre Morel <pmorel@linux.ibm.com>
  vfio_ap_get_queue - retrieve a queue with a specific APQN from a list
  @matrix_mdev: the associated mediated matrix
  @apqn: The queue APQN
  Retrieve a queue with a specific APQN from the list of the
  devices of the vfio_ap_drv.
  Verify that the APID and the APQI are set in the matrix.
  Return: the pointer to the associated vfio_ap_queue
  vfio_ap_wait_for_irqclear - clears the IR bit or gives up after 5 tries
  @apqn: The AP Queue number
  Checks the IRQ bit for the status of this APQN using ap_tapq.
  Returns if the ap_tapq function succeeded and the bit is clear.
  Returns if ap_tapq function failed with invalid, deconfigured or
  checkstopped AP.
  Otherwise retries up to 5 times after waiting 20ms.
  vfio_ap_free_aqic_resources - free vfio_ap_queue resources
  @q: The vfio_ap_queue
  Unregisters the ISC in the GIB when the saved ISC not invalid.
  Unpins the guest's page holding the NIB when it exists.
  Resets the saved_pfn and saved_isc to invalid values.
  vfio_ap_irq_disable - disables and clears an ap_queue interrupt
  @q: The vfio_ap_queue
  Uses ap_aqic to disable the interruption and in case of success, reset
  in progress or IRQ disable command already proceeded: calls
  vfio_ap_wait_for_irqclear() to check for the IRQ bit to be clear
  and calls vfio_ap_free_aqic_resources() to free the resources associated
  with the AP interrupt handling.
  In the case the AP is busy, or a reset is in progress,
  retries after 20ms, up to 5 times.
  Returns if ap_aqic function failed with invalid, deconfigured or
  checkstopped AP.
  Return: &struct ap_queue_status
 All cases in default means AP not operational 
  vfio_ap_irq_enable - Enable Interruption for a APQN
  @q:	 the vfio_ap_queue holding AQIC parameters
  @isc: the guest ISC to register with the GIB interface
  @nib: the notification indicator byte to pin.
  Pin the NIB saved in q
  Register the guest ISC to GIB interface and retrieve the
  host ISC to issue the host side PQAPAQIC
  Response.status may be set to AP_RESPONSE_INVALID_ADDRESS in case the
  vfio_pin_pages failed.
  Otherwise return the ap_queue_status returned by the ap_aqic(),
  all retry handling will be done by the guest.
  Return: &struct ap_queue_status
 See if we did clear older IRQ configuration 
 We could not modify IRQ setings: clear new configuration 
  handle_pqap - PQAP instruction callback
  @vcpu: The vcpu on which we received the PQAP instruction
  Get the general register contents to initialize internal variables.
  REG[0]: APQN
  REG[1]: IR and ISC
  REG[2]: NIB
  Response.status may be set to following Response Code:
  - AP_RESPONSE_Q_NOT_AVAIL: if the queue is not available
  - AP_RESPONSE_DECONFIGURED: if the queue is not configured
  - AP_RESPONSE_NORMAL (0) : in case of successs
    Check vfio_ap_setirq() and vfio_ap_clrirq() for other possible RC.
  We take the matrix_dev lock to ensure serialization on queues and
  mediated device access.
  Return: 0 if we could handle the request inside KVM.
  Otherwise, returns -EOPNOTSUPP to let QEMU handle the fault.
 If we do not use the AIV facility just go to userland 
 If the there is no guest using the mdev, there is nothing to do 
 If IR bit(16) is set we enable the interrupt 
  vfio_ap_has_queue - determines if the AP queue containing the target in @data
  @dev: an AP queue device
  @data: a struct vfio_ap_queue_reserved reference
  Flags whether the AP queue device (@dev) has a queue ID containing the APQN,
  apid or apqi specified in @data:
  - If @data contains both an apid and apqi value, then @data will be flagged
    as reserved if the APID and APQI fields for the AP queue device matches
  - If @data contains only an apid value, @data will be flagged as
    reserved if the APID field in the AP queue device matches
  - If @data contains only an apqi value, @data will be flagged as
    reserved if the APQI field in the AP queue device matches
  Return: 0 to indicate the input to function succeeded. Returns -EINVAL if
  @data does not contain either an apid or apqi.
  vfio_ap_verify_queue_reserved - verifies that the AP queue containing
  @apid or @aqpi is reserved
  @apid: an AP adapter ID
  @apqi: an AP queue index
  Verifies that the AP queue with @apid@apqi is reserved by the VFIO AP device
  driver according to the following rules:
  - If both @apid and @apqi are not NULL, then there must be an AP queue
    device bound to the vfio_ap driver with the APQN identified by @apid and
    @apqi
  - If only @apid is not NULL, then there must be an AP queue device bound
    to the vfio_ap driver with an APQN containing @apid
  - If only @apqi is not NULL, then there must be an AP queue device bound
    to the vfio_ap driver with an APQN containing @apqi
  Return: 0 if the AP queue is reserved; otherwise, returns -EADDRNOTAVAIL.
  vfio_ap_mdev_verify_no_sharing - verifies that the AP matrix is not configured
  @matrix_mdev: the mediated matrix device
  Verifies that the APQNs derived from the cross product of the AP adapter IDs
  and AP queue indexes comprising the AP matrix are not configured for another
  mediated device. AP queue sharing is not allowed.
  Return: 0 if the APQNs are not shared; otherwise returns -EADDRINUSE.
		
		  We work on full longs, as we can only exclude the leftover
		  bits in non-inverse order. The leftover is all zeros.
  assign_adapter_store - parses the APID from @buf and sets the
  corresponding bit in the mediated matrix device's APM
  @dev:	the matrix device
  @attr:	the mediated matrix device's assign_adapter attribute
  @buf:	a buffer containing the AP adapter number (APID) to
 		be assigned
  @count:	the number of bytes in @buf
  Return: the number of bytes processed if the APID is valid; otherwise,
  returns one of the following errors:
 	1. -EINVAL
 	   The APID is not a valid number
 	2. -ENODEV
 	   The APID exceeds the maximum value configured for the system
 	3. -EADDRNOTAVAIL
 	   An APQN derived from the cross product of the APID being assigned
 	   and the APQIs previously assigned is not bound to the vfio_ap device
 	   driver; or, if no APQIs have yet been assigned, the APID is not
 	   contained in an APQN bound to the vfio_ap device driver.
 	4. -EADDRINUSE
 	   An APQN derived from the cross product of the APID being assigned
 	   and the APQIs previously assigned is being used by another mediated
 	   matrix device
 If the KVM guest is running, disallow assignment of adapter 
	
	  Set the bit in the AP mask (APM) corresponding to the AP adapter
	  number (APID). The bits in the mask, from most significant to least
	  significant bit, correspond to APIDs 0-255.
  unassign_adapter_store - parses the APID from @buf and clears the
  corresponding bit in the mediated matrix device's APM
  @dev:	the matrix device
  @attr:	the mediated matrix device's unassign_adapter attribute
  @buf:	a buffer containing the adapter number (APID) to be unassigned
  @count:	the number of bytes in @buf
  Return: the number of bytes processed if the APID is valid; otherwise,
  returns one of the following errors:
 	-EINVAL if the APID is not a number
 	-ENODEV if the APID it exceeds the maximum value configured for the
 		system
 If the KVM guest is running, disallow unassignment of adapter 
  assign_domain_store - parses the APQI from @buf and sets the
  corresponding bit in the mediated matrix device's AQM
  @dev:	the matrix device
  @attr:	the mediated matrix device's assign_domain attribute
  @buf:	a buffer containing the AP queue index (APQI) of the domain to
 		be assigned
  @count:	the number of bytes in @buf
  Return: the number of bytes processed if the APQI is valid; otherwise returns
  one of the following errors:
 	1. -EINVAL
 	   The APQI is not a valid number
 	2. -ENODEV
 	   The APQI exceeds the maximum value configured for the system
 	3. -EADDRNOTAVAIL
 	   An APQN derived from the cross product of the APQI being assigned
 	   and the APIDs previously assigned is not bound to the vfio_ap device
 	   driver; or, if no APIDs have yet been assigned, the APQI is not
 	   contained in an APQN bound to the vfio_ap device driver.
 	4. -EADDRINUSE
 	   An APQN derived from the cross product of the APQI being assigned
 	   and the APIDs previously assigned is being used by another mediated
 	   matrix device
 If the KVM guest is running, disallow assignment of domain 
  unassign_domain_store - parses the APQI from @buf and clears the
  corresponding bit in the mediated matrix device's AQM
  @dev:	the matrix device
  @attr:	the mediated matrix device's unassign_domain attribute
  @buf:	a buffer containing the AP queue index (APQI) of the domain to
 		be unassigned
  @count:	the number of bytes in @buf
  Return: the number of bytes processed if the APQI is valid; otherwise,
  returns one of the following errors:
 	-EINVAL if the APQI is not a number
 	-ENODEV if the APQI exceeds the maximum value configured for the system
 If the KVM guest is running, disallow unassignment of domain 
  assign_control_domain_store - parses the domain ID from @buf and sets
  the corresponding bit in the mediated matrix device's ADM
  @dev:	the matrix device
  @attr:	the mediated matrix device's assign_control_domain attribute
  @buf:	a buffer containing the domain ID to be assigned
  @count:	the number of bytes in @buf
  Return: the number of bytes processed if the domain ID is valid; otherwise,
  returns one of the following errors:
 	-EINVAL if the ID is not a number
 	-ENODEV if the ID exceeds the maximum value configured for the system
 If the KVM guest is running, disallow assignment of control domain 
	 Set the bit in the ADM (bitmask) corresponding to the AP control
	  domain number (id). The bits in the mask, from most significant to
	  least significant, correspond to IDs 0 up to the one less than the
	  number of control domains that can be assigned.
  unassign_control_domain_store - parses the domain ID from @buf and
  clears the corresponding bit in the mediated matrix device's ADM
  @dev:	the matrix device
  @attr:	the mediated matrix device's unassign_control_domain attribute
  @buf:	a buffer containing the domain ID to be unassigned
  @count:	the number of bytes in @buf
  Return: the number of bytes processed if the domain ID is valid; otherwise,
  returns one of the following errors:
 	-EINVAL if the ID is not a number
 	-ENODEV if the ID exceeds the maximum value configured for the system
 If a KVM guest is running, disallow unassignment of control domain 
  vfio_ap_mdev_set_kvm - sets all data for @matrix_mdev that are needed
  to manage AP resources for the guest whose state is represented by @kvm
  @matrix_mdev: a mediated matrix device
  @kvm: reference to KVM instance
  Note: The matrix_dev->lock must be taken prior to calling
  this function; however, the lock will be temporarily released while the
  guest's AP configuration is set to avoid a potential lockdep splat.
  The kvm->lock is taken to set the guest's AP configuration which, under
  certain circumstances, will result in a circular lock dependency if this is
  done under the @matrix_mdev->lock.
  Return: 0 if no other mediated matrix device has a reference to @kvm;
  otherwise, returns an -EPERM.
  vfio_ap_mdev_iommu_notifier - IOMMU notifier callback
  @nb: The notifier block
  @action: Action to be taken
  @data: data associated with the request
  For an UNMAP request, unpin the guest IOVA (the NIB guest address we
  pinned before). Other requests are ignored.
  Return: for an UNMAP request, NOFITY_OK; otherwise NOTIFY_DONE.
  vfio_ap_mdev_unset_kvm - performs clean-up of resources no longer needed
  by @matrix_mdev.
  @matrix_mdev: a matrix mediated device
  @kvm: the pointer to the kvm structure being unset.
  Note: The matrix_dev->lock must be taken prior to calling
  this function; however, the lock will be temporarily released while the
  guest's AP configuration is cleared to avoid a potential lockdep splat.
  The kvm->lock is taken to clear the guest's AP configuration which, under
  certain circumstances, will result in a circular lock dependency if this is
  done under the @matrix_mdev->lock.
 things are really broken, give up 
 wait for the reset to take effect 
			
			  Regardless whether a queue turns out to be busy, or
			  is not operational, we need to continue resetting
			  the remaining queues.
 SPDX-License-Identifier: GPL-2.0
  Copyright IBM Corp. 2016
  Author(s): Martin Schwidefsky <schwidefsky@de.ibm.com>
  Adjunct processor bus, card related code.
  AP card related attributes.
 SPDX-License-Identifier: GPL-2.0+
   Copyright IBM Corp. 2001, 2012
   Author(s): Robert Burroughs
 	       Eric Rossman (edrossma@us.ibm.com)
 	       Cornelia Huck <cornelia.huck@de.ibm.com>
   Hotplug & misc device support: Jochen Roehrig (roehrig@de.ibm.com)
   Major cleanup & driver split: Martin Schwidefsky <schwidefsky@de.ibm.com>
 				  Ralph Wuerthner <rwuerthn@de.ibm.com>
   MSGTYPE restruct:		  Holger Dengler <hd@linux.vnet.ibm.com>
  Device attributes common for all crypto card devices.
	
	  As we are in atomic context here, directly sending uevents
	  does not work. So collect the zqueues in a dynamic array
	  and process them after zcrypt_list_lock release. As we getput
	  the zqueue objects, we make sure they exist after lock release.
  zcrypt_card_register() - Register a crypto card device.
  @zc: Pointer to a crypto card device
  Register a crypto card device. Returns 0 if successful.
  zcrypt_card_unregister(): Unregister a crypto card device.
  @zc: Pointer to crypto card device
  Unregister a crypto card device.
 SPDX-License-Identifier: GPL-2.0+
   Copyright IBM Corp. 2019
   Author(s): Harald Freudenberger <freude@linux.ibm.com>
   Collection of EP11 misc functions used by zcrypt and pkey
 default iv used here 
 ep11 card info cache 
  Simple check if the key blob is a valid EP11 AES key blob with header.
  Simple check if the key blob is a valid EP11 ECC key blob with header.
  Simple check if the key blob is a valid EP11 AES key blob with
  the header in the session field (old style EP11 AES key).
  Allocate and prepare ep11 cprb plus additional payload.
  Some helper functions related to ASN1 encoding.
  Limited to length info <= 2 byte.
 EP11 payload > 127 bytes starts with this struct 
 prep ep11 payload head helper function 
 prep urb helper function 
 Check ep11 reply payload, return 0 or suggested errno value. 
 start tag 
 payload length format 
 len should cover at least 3 fields with 32 bit value each 
 function tag, length and value 
 dom tag, length and value 
 return value tag, length and value 
  Helper function which does an ep11 query with given query type.
 request cprb and payload 
 get xcp info 
 reply cprb and payload 
 urb and target 
  Provide information about an EP11 card.
 module info query ,
  Provide information about a domain within an EP11 card.
 domain info query ,
 left imprint mode ) {
 cur wk valid ) {
 new wk present 
 new wk committed ) {
  Default EP11 AES key generate attributes, used when no keygenflags given:
  XCP_BLOB_ENCRYPT | XCP_BLOB_DECRYPT | XCP_BLOB_PROTKEY_EXTRACTABLE
 request cprb and payload 
 GenerateKey 
 CKM_AES_KEY_GEN 
 CKA_VALUE_LEN 
 reply cprb and payload 
 urb and target 
 copy key blob and set header values 
		
		  maybe followed by iv data
		  followed by key tag + key blob
		  followed by plaintext tag + plaintext
 data follows 
 the simple asn1 coding used has length limits 
 request cprb and payload 
 mech is mech + mech params (iv here) 
 CKM_AES_CBC_PAD 
 key and input data 
 reply cprb and payload, assume out data size <= in data size + 32 
 urb and target 
		
		  maybe followed by iv data
		  followed by kek tag + kek blob
		  followed by empty mac tag
		  followed by empty pin tag
		  followed by encryted key tag + bytes
 request cprb and payload 
 UnwrapKey 
 CKA_KEY_TYPE 
 CKK_AES 
 CKA_VALUE_LEN 
 mech is mech + mech params (iv here) 
 CKM_AES_CBC_PAD 
 kek 
 empty mac key tag 
 empty pin tag 
 encrypted key value tag and bytes 
 reply cprb and payload 
 urb and target 
 copy key blob and set header values 
		
		  followed by iv data
		  followed by key tag + key blob
		  followed by dummy kek param
		  followed by dummy mac param
 maybe the session field holds a header with key info 
 request cprb and payload 
 CPACF_WRAP needs special bit 
 CKM_IBM_CPACF_WRAP 
 WrapKey 
 mech is mech + mech params (iv here) 
 CKM_IBM_CPACF_WRAP 
 key blob 
 maybe the key argument needs the head data cleaned out 
 empty kek tag 
 empty mac tag 
 reply cprb and payload 
 urb and target 
 copy the data from the cprb to the data buffer 
 allocate memory for the temp kek 
 Step 1: generate AES 256 bit random kek key 
 ENDECRYPT, WRAPUNWRAP 
 Step 2: encrypt clear key value with the kek key 
 Step 3: import the encrypted key value as a new key 
 key with or without header ? 
 EP11 AES or ECC key with header 
 EP11 AES key (old style) 
 raw EP11 key blob 
 alloc temp working buffer 
 ep11 secure key -> protected key + info 
 check struct version and pkey type 
 check protected key type field 
 AES 
 AES 128 protected key 
 AES 192 protected key 
 AES 256 protected key 
 EC-P 
 EC-ED 
 EC-BP 
 TDES 
 copy the tanslated protected key 
 fetch status of all crypto cards 
 allocate 1k space for up to 256 apqns 
 walk through all the crypto apqnss 
 check online state 
 check for ep11 functions 
 check cardnr 
 check domain 
 check min hardware type 
 check min api version if given 
 check wkvp if given 
 apqn passed all filtering criterons, add to the array 
 nothing found ? 
 no re-allocation, simple return the _apqns array 
 SPDX-License-Identifier: GPL-2.0+
   Copyright IBM Corp. 2001, 2018
   Author(s): Robert Burroughs
 	       Eric Rossman (edrossma@us.ibm.com)
   Hotplug & misc device support: Jochen Roehrig (roehrig@de.ibm.com)
   Major cleanup & driver split: Martin Schwidefsky <schwidefsky@de.ibm.com>
 				  Ralph Wuerthner <rwuerthn@de.ibm.com>
   MSGTYPE restruct:		  Holger Dengler <hd@linux.vnet.ibm.com>
  128 bits	
 2048 bits	
  128 bits	
 4096 bits	
 end of list  },
 end of list  },
  CCA card additional device attributes
   CCA queue additional device attributes
  Large random number detection function. Its sends a message to a CEX2CCEX3C
  card to find out if large random numbers are supported.
  @ap_dev: pointer to the AP device.
  Returns 1 if large random numbers are supported, 0 if not and < 0 on error.
 Wait for the test message to complete. 
 Got no answer. 
  Probe function for CEX2CCEX3C card devices. It always accepts the
  AP device since the bus_match already checked the hardware type.
  @ap_dev: pointer to the AP card device.
	
	  Normalized speed ratings per crypto adapter
	  MEX_1k, MEX_2k, MEX_4k, CRT_1k, CRT_2k, CRT_4k, RNG, SECKEY
  This is called to remove the CEX2CCEX3C card driver information
  if an AP card device is removed.
  Probe function for CEX2CCEX3C queue devices. It always accepts the
  AP device since the bus_match already checked the hardware type.
  @ap_dev: pointer to the AP card device.
  This is called to remove the CEX2CCEX3C queue driver information
  if an AP queue device is removed.
 SPDX-License-Identifier: GPL-2.0+
   Copyright IBM Corp. 2001, 2012
   Author(s): Robert Burroughs
 	       Eric Rossman (edrossma@us.ibm.com)
   Hotplug & misc device support: Jochen Roehrig (roehrig@de.ibm.com)
   Major cleanup & driver split: Martin Schwidefsky <schwidefsky@de.ibm.com>
 				  Ralph Wuerthner <rwuerthn@de.ibm.com>
   MSGTYPE restruct:		  Holger Dengler <hd@linux.vnet.ibm.com>
    8 bits	
 2048 bits	
 4096 bits	
 sizeof(struct type50_crb2_msg)    
 max outputdatalength + type80_hdr 
#define CEX3A_MAX_RESPONSE_SIZE	0x210	 512 bit modulus
					  (max outputdatalength) +
 end of list  },
 end of list  },
  Probe function for CEX2A card devices. It always accepts the AP device
  since the bus_match already checked the card type.
  @ap_dev: pointer to the AP device.
	
	  Normalized speed ratings per crypto adapter
	  MEX_1k, MEX_2k, MEX_4k, CRT_1k, CRT_2k, CRT_4k, RNG, SECKEY
  This is called to remove the CEX2A card driver information
  if an AP card device is removed.
  Probe function for CEX2A queue devices. It always accepts the AP device
  since the bus_match already checked the queue type.
  @ap_dev: pointer to the AP device.
  This is called to remove the CEX2A queue driver information
  if an AP queue device is removed.
 SPDX-License-Identifier: GPL-2.0
  Copyright IBM Corp. 2016
  Author(s): Martin Schwidefsky <schwidefsky@de.ibm.com>
  Adjunct processor bus, queue related code.
  ap_queue_enable_irq(): Enable interrupt support on this AP queue.
  @aq: The AP queue
  @ind: the notification indicator byte
  Enables interruption on AP queue via ap_aqic(). Based on the return
  value it waits a while and tests the AP queue if interrupts
  have been switched on using ap_test_queue().
  __ap_send(): Send message to adjunct processor queue.
  @qid: The AP queue number
  @psmid: The program supplied message identifier
  @msg: The message text
  @length: The message length
  @special: Special Bit
  Returns AP queue status structure.
  Condition code 1 on NQAP can't happen because the L bit is 1.
  Condition code 2 on NQAP also means the send is incomplete,
  because a segment boundary was reached. The NQAP is repeated.
 Device is gone. 
 State machine definitions and helpers 
  ap_sm_recv(): Receive pending reply messages from an AP queue but do
 	not change the state of the device.
  @aq: pointer to the AP queue
  Returns AP_SM_WAIT_NONE, AP_SM_WAIT_AGAIN, or AP_SM_WAIT_INTERRUPT
	
	  DQAP loop until response code and resgr0 indicate that
	  the msg is totally received. As we use the very same buffer
	  the msg is overwritten with each invocation. That's intended
	  and the receiver of the msg is informed with a msg rc code
	  of EMSGSIZE in such a case.
 The card shouldn't forget requests but who knows. 
  ap_sm_read(): Receive pending reply messages from an AP queue.
  @aq: pointer to the AP queue
  Returns AP_SM_WAIT_NONE, AP_SM_WAIT_AGAIN, or AP_SM_WAIT_INTERRUPT
  ap_sm_write(): Send messages from the request queue to an AP queue.
  @aq: pointer to the AP queue
  Returns AP_SM_WAIT_NONE, AP_SM_WAIT_AGAIN, or AP_SM_WAIT_INTERRUPT
 Start the next request on the queue. 
  ap_sm_read_write(): Send and receive messages tofrom an AP queue.
  @aq: pointer to the AP queue
  Returns AP_SM_WAIT_NONE, AP_SM_WAIT_AGAIN, or AP_SM_WAIT_INTERRUPT
  ap_sm_reset(): Reset an AP queue.
  @aq: The AP queue
  Submit the Reset command to an AP queue.
  ap_sm_reset_wait(): Test queue for completion of the reset operation
  @aq: pointer to the AP queue
  Returns AP_POLL_IMMEDIATELY, AP_POLL_AFTER_TIMEROUT or 0.
 Try to read a completed message and get the status 
 Get the status with TAPQ 
  ap_sm_setirq_wait(): Test queue for completion of the irq enablement
  @aq: pointer to the AP queue
  Returns AP_POLL_IMMEDIATELY, AP_POLL_AFTER_TIMEROUT or 0.
 Try to read a completed message and get the status 
 Get the status with TAPQ 
 Irqs are now enabled 
  AP state machine jump table
  AP queue related attributes.
 queue device state 
 state machine state 
  ap_queue_message(): Queue a request to an AP device.
  @aq: The AP device to queue the message to
  @ap_msg: The message that is to be added
 msg needs to have a valid receive-callback 
 only allow to queue new messages if device state is ok 
 Sendreceive as many request from the queue as possible. 
  ap_cancel_message(): Cancel a crypto request.
  @aq: The AP device that has the message queued
  @ap_msg: The message that is to be removed
  Cancel a crypto request. This is done by removing the request
  from the device pending or request queue. Note that the
  request stays on the AP queue. When it finishes the message
  reply will be discarded because the psmid can't be found.
  __ap_flush_queue(): Flush requests.
  @aq: Pointer to the AP queue
  Flush all requests from the requestpending queue of an AP device.
 flush queue 
 move queue device state to SHUTDOWN in progress 
	
	  all messages have been flushed and the device state
	  is SHUTDOWN. Now reset with zero which also clears
	  the irq registration and move the device state
	  to the initial value AP_DEV_STATE_UNINITIATED.
 SPDX-License-Identifier: GPL-2.0
   pkey device driver
   Copyright IBM Corp. 2017,2019
   Author(s): Harald Freudenberger
 key buffer size used for internal processing 
 protected key buffer size used internal 
 max 64 apqns within a apqn list 
  debug feature data and functions
 5 arguments per dbf entry (including the format string ptr) 
 inside view of a protected key token (only type 0x00 version 0x01) 
 0x00 for PAES specific key tokens 
 should be 0x01 for protected AES key token 
 key type, one of the PKEY_KEYTYPE values 
 bytes actually stored in protkey[] 
 the protected key blob 
 inside view of a clear key token (type 0x00 version 0x02) 
 0x00 for PAES specific key tokens 
 0x02 for clear AES key token 
 key type, one of the PKEY_KEYTYPE values 
 bytes actually stored in clearkey[] 
 clear key value 
  Create a protected key from a clear key value.
 mask of available pckmo subfunctions 
 Did we already check for PCKMO ? 
 no, so check now 
 check for the pckmo subfunction we need now 
 prepare param block 
 call the pckmo instruction 
 copy created protected key 
  Find card and transform secure key into protected key.
	
	  The cca_xxx2protkey call may fail when a card has been
	  addressed where the master key was changed after last fetch
	  of the mkvp into the cache. Try 3 times: First witout verify
	  then with verify and last round with verify and old master
	  key verification pattern match not ignored.
  Construct EP11 key with given clear key value.
 build a list of apqns suitable for ep11 keys with cpacf support 
 go through the list of apqns and try to bild an ep11 key 
  Find card and transform EP11 secure key into protected key.
 build a list of apqns suitable for this key 
 go through the list of apqns and try to derive an pkey 
  Verify key and give back some info about the key.
 check the secure key for valid AES secure key 
 try to find a card which can handle this key 
 key mkvp matches to old master key mkvp 
  Generate a random protected key
 generate a dummy random clear key 
 convert it to a dummy protected key 
 replace the key part of the protected key with random bytes 
  Verify if a protected key is still valid
  Transform a non-CCA key token into a protected key
 alloc temp key buffer space 
 try direct way with the PCKMO instruction 
 PCKMO failed, so try the CCA secure key way 
 if the CCA way also failed, let's try via EP11 
 now we should really have an protected key 
 check ep11 key for exportable as protected key 
 check ep11 key with header for exportable as protected key 
  Transform a CCA internal key token into a protected key
  Transform a key blob (of any type) into a protected key
 check for at least one apqn given 
 check key type and size 
 simple try all apqns from the list 
 TOKVER_CCA_VLSC 
 check for at least one apqn given 
 check key type and size 
 simple try all apqns from the list 
 TOKVER_CCA_VLSC 
 check for at least one apqn given 
 simple try all apqns from the list 
 EP11 AES secure key blob 
 unknown cca internal token type 
 unknown cca internal 2 token type 
 check for at least one apqn given 
 EP11 AES key blob with header 
 EP11 ECC key blob with header 
 EP11 AES key blob with header in session field 
 CCA AES data key 
 CCA AES cipher key 
 CCA ECC (private) key 
 simple try all apqns from the list 
  File io functions
 unknownunsupported ioctl cmd 
  Sysfs and file io operations
  Sysfs attribute read function for all protected key binary attributes.
  The implementation can not deal with partial reads, because a new random
  protected key blob is generated with each read. In case of partial reads
  (i.e. off != 0 or count < key blob size) -EINVAL is returned.
  Sysfs attribute read function for all secure key ccadata binary attributes.
  The implementation can not deal with partial reads, because a new random
  protected key blob is generated with each read. In case of partial reads
  (i.e. off != 0 or count < key blob size) -EINVAL is returned.
  Sysfs attribute read function for all secure key ccacipher binary attributes.
  The implementation can not deal with partial reads, because a new random
  secure key blob is generated with each read. In case of partial reads
  (i.e. off != 0 or count < key blob size) -EINVAL is returned.
 build a list of apqns able to generate an cipher key 
 simple try all apqns from the list 
  Sysfs attribute read function for all ep11 aes key binary attributes.
  The implementation can not deal with partial reads, because a new random
  secure key blob is generated with each read. In case of partial reads
  (i.e. off != 0 or count < key blob size) -EINVAL is returned.
  This function and the sysfs attributes using it provide EP11 key blobs
  padded to the upper limit of MAXEP11AESKEYBLOBSIZE which is currently
  320 bytes.
 build a list of apqns able to generate an cipher key 
 simple try all apqns from the list 
  Module init
	
	  The pckmo instruction should be available - even if we don't
	  actually invoke it. This instruction comes with MSA 3 which
	  is also the minimum level for the kmc instructions which
	  are able to work with protected keys.
 check for kmc instructions available 
  Module exit
 SPDX-License-Identifier: GPL-2.0+
   Copyright IBM Corp. 2001, 2012
   Author(s): Robert Burroughs
 	       Eric Rossman (edrossma@us.ibm.com)
   Hotplug & misc device support: Jochen Roehrig (roehrig@de.ibm.com)
   Major cleanup & driver split: Martin Schwidefsky <schwidefsky@de.ibm.com>
 				  Ralph Wuerthner <rwuerthn@de.ibm.com>
   MSGTYPE restruct:		  Holger Dengler <hd@linux.vnet.ibm.com>
 >= CEX3A: 4096 bits 
 CEX2A: max outputdatalength + type80_hdr 
 >= CEX3A: 512 bit modulus, (max outputdatalength) + type80_hdr 
  The type 50 message family is associated with a CEXxA cards.
  The four members of the family are described below.
  Note that all unsigned char arrays are right-justified and left-padded
  with zeroes.
  Note that all reserved fields must be zeroes.
 0x50 
 Mod-Exp, with a small modulus 
 0x0001 
 Mod-Exp, with a large modulus 
 0x0002 
 Mod-Exp, with a larger modulus 
 0x0003 
 CRT, with a small modulus 
 0x0011 
 CRT, with a large modulus 
 0x0012 
 CRT, with a larger modulus 
 0x0013 
  The type 80 response family is associated with a CEXxA cards.
  Note that all unsigned char arrays are right-justified and left-padded
  with zeroes.
  Note that all reserved fields must be zeroes.
 0x80 
 0x00 
 1024 bit 
 2048 bit 
 4096 bit 
 1024 bit 
 2048 bit 
 4096 bit 
  Convert a ICAMEX message to a type50 MEX message.
  @zq: crypto queue pointer
  @ap_msg: crypto request pointer
  @mex: pointer to user input data
  Returns 0 on success or -EFAULT.
  Convert a ICACRT message to a type50 CRT message.
  @zq: crypto queue pointer
  @ap_msg: crypto request pointer
  @crt: pointer to user input data
  Returns 0 on success or -EFAULT.
	
	  CEX2A and CEX3A wo FW update can handle requests up to
	  256 byte modulus (2k keys).
	  CEX3A with FW update and newer CEXxA cards are able to handle
	  512 byte modulus (4k keys).
 up to 1024 bit key size 
 up to 2048 bit key size 
 up to 4096 bit key size 
	
	  correct the offset of p, bp and mult_inv according zcrypt.h
	  block size right aligned (skip the first byte)
  Copy results from a type 80 reply message back to user space.
  @zq: crypto device pointer
  @reply: reply AP message.
  @data: pointer to user output data
  @length: size of user output data
  Returns 0 on success or -EFAULT.
 The result is too short, the CEXxA card may not do that.. 
 Response type byte is the second byte in the response. 
 Unknown response type, this should NEVER EVER happen 
  This function is called from the AP bus code after a crypto request
  "msg" has finished with the reply message "reply".
  It is called from tasklet context.
  @aq: pointer to the AP device
  @msg: pointer to the AP message
  @reply: pointer to the AP reply message
 Copy the reply message to the request message buffer. 
 ap_msg->rc indicates the error 
  The request distributor calls this function if it picked the CEXxA
  device to handle a modexpo request.
  @zq: pointer to zcrypt_queue structure that identifies the
 	CEXxA device to the request distributor
  @mex: pointer to the modexpo request buffer
 Signal pending. 
  The request distributor calls this function if it picked the CEXxA
  device to handle a modexpo_crt request.
  @zq: pointer to zcrypt_queue structure that identifies the
 	CEXxA device to the request distributor
  @crt: pointer to the modexpoc_crt request buffer
 Signal pending. 
  The crypto operations for message type 50.
 SPDX-License-Identifier: GPL-2.0+
   Copyright IBM Corp. 2001, 2012
   Author(s): Robert Burroughs
 	       Eric Rossman (edrossma@us.ibm.com)
   Hotplug & misc device support: Jochen Roehrig (roehrig@de.ibm.com)
   Major cleanup & driver split: Martin Schwidefsky <schwidefsky@de.ibm.com>
 				  Ralph Wuerthner <rwuerthn@de.ibm.com>
   MSGTYPE restruct:		  Holger Dengler <hd@linux.vnet.ibm.com>
 max size type86 v2 reply	    
  CPRB
 	  Note that all shorts, ints and longs are little-endian.
 	  All pointer fields are 32-bits long, and mean nothing
 	  A request CPRB is followed by a request_parameter_block.
 	  The request (or reply) parameter block is organized thus:
 	    function code
 	    VUD block
 	    key block
 CPRB length			 
 CPRB version id.		 
 Alignment pad byte.		 
 SRPI return code LELONG	 
 SRPI verb type		 
 flags			 
 function id			 
				 
 reserved			 
 request parameter buffer	 
 length 16-bit little endian	 
	unsigned char req_parmp[4];	 request parameter buffer	 
					  pointer (means nothing: the	 
					  parameter buffer follows	 
 request data buffer		 
 length	  ULELONG	 
 request data buffer		 
 pointer			 
 reply  parameter buffer	 
 length 16-bit little endian	 
 Alignment pad bytes. ULESHORT 
	unsigned char rpl_parmp[4];	 reply parameter buffer	 
					  pointer (means nothing: the	 
					  parameter buffer follows	 
 reply data buffer len ULELONG 
 reply data buffer		 
 pointer			 
 server reason code	ULESHORT 
 server return code	ULESHORT 
 replied parameter len ULESHORT
 Mac Data Length	ULESHORT 
 replied data length	ULELONG	 
 PC identifier		 
 resource origin		 
 Mac Value			 
 Logon Identifier		 
 cdx				 
 reserved for requestor	 
 server name length  ULESHORT	 
 server name			 
  The following is used to initialize the CPRBX passed to the CEXxCCEXxP
  card in a type6 message. The 3 fields that must be filled in at execution
  time are  req_parml, rpl_parml and usage_domain.
  Everything about this interface is asciibig-endian, since the
  device does not have 'Intel inside'.
  The CPRBX is followed immediately by the parm block.
  The parm block contains:
  - function code ('PD' 0x5044 or 'PK' 0x504B)
  - rule block (one of:)
    + 0x000A 'PKCS-1.2' (MCL2 'PD')
    + 0x000A 'ZERO-PAD' (MCL2 'PK')
    + 0x000A 'ZERO-PAD' (MCL3 'PD' or CEX2C 'PD')
    + 0x000A 'MRP     ' (MCL3 'PK' or CEX2C 'PK')
  - VUD block
  Convert a ICAMEX message to a type6 MEX message.
  @zq: crypto device pointer
  @ap_msg: pointer to AP message
  @mex: pointer to user input data
  Returns 0 on success or negative errno value.
	
	  The inputdatalength was a selection criteria in the dispatching
	  function zcrypt_rsa_modexpo(). However, make sure the following
	  copy_from_user() never exceeds the allocated buffer space.
 VUD.ciphertext 
 Set up key which is located after the variable length text. 
 message header, cprbx and f&r 
  Convert a ICACRT message to a type6 CRT message.
  @zq: crypto device pointer
  @ap_msg: pointer to AP message
  @crt: pointer to user input data
  Returns 0 on success or negative errno value.
	
	  The inputdatalength was a selection criteria in the dispatching
	  function zcrypt_rsa_crt(). However, make sure the following
	  copy_from_user() never exceeds the allocated buffer space.
 VUD.ciphertext 
 Set up key which is located after the variable length text. 
 total size of msg 
 message header, cprbx and f&r 
  Convert a XCRB message to a type6 CPRB message.
  @zq: crypto device pointer
  @ap_msg: pointer to AP message
  @xcRB: pointer to user input data
  Returns 0 on success or -EFAULT, -EINVAL.
 overflow after alignment
 length checks 
	
	  Overflow check
	  sum must be greater (or equal) than the largest operand
 overflow after alignment
	
	  Overflow check
	  sum must be greater (or equal) than the largest operand
 prepare type6 header 
 prepare CPRB 
 copy data block 
 {'X'} 
 {'C'} 
 fixed value 0x30 
 payload length format 
 fixed value 0x4 
 fixed value 0x4 
 function ID	   
 fixed value 0x4 
 fixed value 0x4 
 domain id	   
 overflow after alignment
 length checks 
 overflow after alignment
 prepare type6 header 
 Import CPRB data from the ioctl input parameter 
ext.len.fmt 2 or 3
 length format #1 
 enable special processing based on the cprbs flags special bit 
  Copy results from a type 86 ICA reply message back to user space.
  @zq: crypto device pointer
  @reply: reply AP message.
  @data: pointer to user output data
  @length: size of user output data
  Returns 0 on success or -EINVAL, -EFAULT, -EAGAIN in case of an error.
 4 byte function coderules block ? 
	
	  For all encipher requests, the length of the ciphertext (reply_len)
	  will always equal the modulus length. For MEX decipher requests
	  the output needs to get padded. Minimum pad size is 10.
	 
	  Currently, the cases where padding will be added is for:
	  - PCIXCC_MCL2 using a CRT form token (since PKD didn't support
	    ZERO-PAD and CRT is only supported for PKD requests)
	  - PCICC, always
 'restore' padding left in the CEXXC card. 
 Copy the crypto response to user space. 
  Copy results from a type 86 XCRB reply message back to user space.
  @zq: crypto device pointer
  @reply: reply AP message.
  @xcRB: pointer to XCRB
  Returns 0 on success or -EINVAL, -EFAULT, -EAGAIN in case of an error.
 Copy CPRB to user 
 Copy data buffer to user 
  Copy results from a type 86 EP11 XCRB reply message back to user space.
  @zq: crypto device pointer
  @reply: reply AP message.
  @xcRB: pointer to EP11 user request block
  Returns 0 on success or -EINVAL, -EFAULT, -EAGAIN in case of an error.
 Copy response CPRB to user 
 wrong cprb version is an unknown response 
 Unknown response type, this should NEVER EVER happen 
 HDD_InvalidParm 
 wrong cprb version is an unknown response 
 Unknown response type, this should NEVER EVER happen 
 HDD_InvalidParm 
 wrong cprb version is an unknown resp 
 Unknown response type, this should NEVER EVER happen 
 wrong cprb version is an unknown response 
 Unknown response type, this should NEVER EVER happen 
  This function is called from the AP bus code after a crypto request
  "msg" has finished with the reply message "reply".
  It is called from tasklet context.
  @aq: pointer to the AP queue
  @msg: pointer to the AP message
  @reply: pointer to the AP reply message
 Copy the reply message to the request message buffer. 
 ap_msg->rc indicates the error 
  This function is called from the AP bus code after a crypto request
  "msg" has finished with the reply message "reply".
  It is called from tasklet context.
  @aq: pointer to the AP queue
  @msg: pointer to the AP message
  @reply: pointer to the AP reply message
 Copy the reply message to the request message buffer. 
 ap_msg->rc indicates the error 
  The request distributor calls this function if it picked the CEXxC
  device to handle a modexpo request.
  @zq: pointer to zcrypt_queue structure that identifies the
 	CEXxC device to the request distributor
  @mex: pointer to the modexpo request buffer
 Signal pending. 
  The request distributor calls this function if it picked the CEXxC
  device to handle a modexpo_crt request.
  @zq: pointer to zcrypt_queue structure that identifies the
 	CEXxC device to the request distributor
  @crt: pointer to the modexpoc_crt request buffer
 Signal pending. 
  Fetch function code from cprb.
  Extracting the fc requires to copy the cprb from userspace.
  So this function allocates memory and needs an ap_msg prepared
  by the caller with ap_init_message(). Also the caller has to
  make sure ap_release_message() is always called even on failure.
  The request distributor calls this function if it picked the CEXxC
  device to handle a send_cprb request.
  @zq: pointer to zcrypt_queue structure that identifies the
 	CEXxC device to the request distributor
  @xcRB: pointer to the send_cprb request buffer
 Signal pending. 
  Fetch function code from ep11 cprb.
  Extracting the fc requires to copy the ep11 cprb from userspace.
  So this function allocates memory and needs an ap_msg prepared
  by the caller with ap_init_message(). Also the caller has to
  make sure ap_release_message() is always called even on failure.
  The request distributor calls this function if it picked the CEX4P
  device to handle a send_ep11_cprb request.
  @zq: pointer to zcrypt_queue structure that identifies the
 	  CEX4P device to the request distributor
  @xcRB: pointer to the ep11 user request block
 fixed value 0x30 
 payload length format 
 fixed value 0x4 
 fixed value 0x4 
 function ID	   
 fixed value 0x4 
 fixed value 0x4 
 domain id	   
	
	  The target domain field within the cprb bodypayload block will be
	  replaced by the usage domain for non-management commands only.
	  Therefore we check the first bit of the 'flags' parameter for
	  management command indication.
	    0 - non management command
	    1 - management command
ext.len.fmt 2 or 3
 length format #1 
 Signal pending. 
  The request distributor calls this function if it picked the CEXxC
  device to generate random data.
  @zq: pointer to zcrypt_queue structure that identifies the
 	CEXxC device to the request distributor
  @buffer: pointer to a memory page to return random data
 Signal pending. 
  The crypto operations for a CEXxC card.
 SPDX-License-Identifier: GPL-2.0+
   Copyright IBM Corp. 2001, 2018
   Author(s): Robert Burroughs
 	       Eric Rossman (edrossma@us.ibm.com)
 	       Cornelia Huck <cornelia.huck@de.ibm.com>
   Hotplug & misc device support: Jochen Roehrig (roehrig@de.ibm.com)
   Major cleanup & driver split: Martin Schwidefsky <schwidefsky@de.ibm.com>
 				  Ralph Wuerthner <rwuerthn@de.ibm.com>
   MSGTYPE restruct:		  Holger Dengler <hd@linux.vnet.ibm.com>
   Multiple device nodes: Harald Freudenberger <freude@linux.ibm.com>
  Module description.
  zcrypt tracepoint functions
 Zcrypt related debug feature stuff. 
  Process a rescan of the transport layer.
  Returns 1, if the rescan has been processed, otherwise 0.
  Multi device nodes extension functions.
  Find zcdn device by name.
  Returns reference to the zcdn device which needs to be released
  with put_device() after use.
  Find zcdn device by devt value.
  Returns reference to the zcdn device which needs to be released
  with put_device() after use.
 check if device node with this name already exists 
 find an unused minor number 
 alloc and prepare a new zcdn device 
 try to find this zcdn device 
	
	  The zcdn device is not hard destroyed. It is subject to
	  reference counting and thus just needs to be unregistered.
  zcrypt_read (): Not supported beyond zcrypt 1.3.1.
  This function is not supported beyond zcrypt 1.3.1.
  zcrypt_write(): Not allowed.
  Write is is not allowed
  zcrypt_open(): Count number of users.
  Device open function to count number of users.
 find returns a reference, no get_device() needed 
  zcrypt_release(): Count number of users.
  Device close function to count number of users.
 2 puts here: one for find, one for open 
  zcrypt ioctls.
	
	  As long as outputdatalength is big enough, we can set the
	  outputdatalength equal to the inputdatalength, since that is the
	  number of bytes we will copy in any case
 Check for useable accelarator or CCA card 
 Check for size limits 
 check if device node has admission for this card 
 get weight index of the card device	
 penalty if this msg was previously sent via this card 
 check if device is useable and eligible 
 check if device node has admission for this queue 
 penalty if the msg was previously sent at this qid 
	
	  As long as outputdatalength is big enough, we can set the
	  outputdatalength equal to the inputdatalength, since that is the
	  number of bytes we will copy in any case
 Check for useable accelarator or CCA card 
 Check for size limits 
 check if device node has admission for this card 
 get weight index of the card device	
 penalty if this msg was previously sent via this card 
 check if device is useable and eligible 
 check if device node has admission for this queue 
 penalty if the msg was previously sent at this qid 
	
	  If a valid target domain is set and this domain is NOT a usage
	  domain but a control only domain, use the default domain as target.
 Check for useable CCA card 
 Check for user selected CCA card 
 check if request size exceeds card max msg size 
 check if device node has admission for this card 
 get weight index of the card device	
 penalty if this msg was previously sent via this card 
 check for device useable and eligible 
 check if device node has admission for this queue 
 penalty if the msg was previously sent at this qid 
 in case of auto select, provide the correct domain 
 empty list indicates autoselect (all available targets) 
 Check for useable EP11 card 
 Check for user selected EP11 card 
 check if request size exceeds card max msg size 
 check if device node has admission for this card 
 get weight index of the card device	
 penalty if this msg was previously sent via this card 
 check if device is useable and eligible 
 check if device node has admission for this queue 
 penalty if the msg was previously sent at this qid 
 Check for useable CCA card 
 get weight index of the card device	
 check if device is useable and eligible 
 on failure: retry once again after a requested rescan 
 on failure: retry once again after a requested rescan 
 'FI' ) {
 on failure: retry once again after a requested rescan 
 on failure: retry once again after a requested rescan 
	
	  Deprecated ioctls
 the old ioctl supports only 64 adapters 
 the old ioctl supports only 64 adapters 
 the old ioctl supports only 64 adapters 
 the old ioctl supports only 64 adapters 
 unknown ioctl number 
  ioctl32 conversion routines
 on failure: retry once again after a requested rescan 
 on failure: retry once again after a requested rescan 
 on failure: retry once again after a requested rescan 
  Misc device file operations.
  Misc device.
	
	  We don't need locking here because the RNG API guarantees serialized
	  read method calls.
 on failure: retry once again after a requested rescan 
  Wait until the zcrypt api is operational.
  The AP bus scan and the binding of ap devices to device drivers is
  an asynchronous job. This function waits until these initial jobs
  are done and so the zcrypt api should be ready to serve crypto
  requests - if there are resources available. The function uses an
  internal timeout of 60s. The very first caller will either wait for
  ap bus bindings complete or the timeout happens. This state will be
  remembered for further callers which will only be blocked until a
  decision is made (timeout or bindings complete).
  On timeout -ETIME is returned, on success the return value is 0.
 initial state, invoke wait for the ap bus complete 
 ap bus bindings are complete 
 interrupted, go back to caller 
 timeout 
 other failure 
 a previous caller already found ap bus bindings complete 
 a previous caller had timeout or other failure 
 create a new class 'zcrypt' 
 alloc device minor range 
 need some class specific sysfs attributes 
  zcrypt_api_init(): Module initialization.
  The module initialization code.
 Register the request sprayer. 
  zcrypt_api_exit(): Module termination.
  The module termination code.
 SPDX-License-Identifier: GPL-2.0+
  VFIO based AP device driver
  Copyright IBM Corp. 2018
  Author(s): Tony Krowiak <akrowiak@linux.ibm.com>
 	      Pierre Morel <pmorel@linux.ibm.com>
 Only type 10 adapters (CEX4 and later) are supported
  by the AP matrix device driver
 end of sibling  },
  vfio_ap_queue_dev_probe: Allocate a vfio_ap_queue structure and associate it
 			    with the device as driver_data.
  @apdev: the AP device being probed
  Return: returns 0 if the probe succeeded; otherwise, returns -ENOMEM if
 	   storage could not be allocated for a vfio_ap_queue object.
  vfio_ap_queue_dev_remove: Free the associated vfio_ap_queue structure.
  @apdev: the AP device being removed
  Takes the matrix lock to avoid actions on this device while doing the remove.
 Fill in config info via PQAP(QCI), if available 
 If there are no AP instructions, there is nothing to pass through. 
 SPDX-License-Identifier: GPL-2.0+
   Copyright IBM Corp. 2001, 2012
   Author(s): Robert Burroughs
 	       Eric Rossman (edrossma@us.ibm.com)
 	       Cornelia Huck <cornelia.huck@de.ibm.com>
   Hotplug & misc device support: Jochen Roehrig (roehrig@de.ibm.com)
   Major cleanup & driver split: Martin Schwidefsky <schwidefsky@de.ibm.com>
 				  Ralph Wuerthner <rwuerthn@de.ibm.com>
   MSGTYPE restruct:		  Holger Dengler <hd@linux.vnet.ibm.com>
  Device attributes common for all crypto queue devices.
  zcrypt_queue_register() - Register a crypto queue device.
  @zq: Pointer to a crypto queue device
  Register a crypto queue device. Returns 0 if successful.
 New devices are online by default. 
  zcrypt_queue_unregister(): Unregister a crypto queue device.
  @zq: Pointer to crypto queue device
  Unregister a crypto queue device.
 SPDX-License-Identifier: GPL-2.0
   Copyright IBM Corp. 2012, 2019
   Author(s): Holger Dengler <hd@linux.vnet.ibm.com>
    8 bits	
 2048 bits	
 4096 bits	
  256 bits	
 4096 bits	
 Waiting time for requests to be processed.
  Currently there are some types of request which are not deterministic.
  But the maximum time limit managed by the stomper code is set to 60sec.
  Hence we have to wait at least that time period.
 end of list  },
 end of list  },
  CCA card additional device attributes
   CCA queue additional device attributes
  EP11 card additional device attributes
  EP11 queue additional device attributes
  Probe function for CEX4CEX5CEX6CEX7 card device. It always
  accepts the AP device since the bus_match already checked
  the hardware type.
  @ap_dev: pointer to the AP device.
	
	  Normalized speed ratings per crypto adapter
	  MEX_1k, MEX_2k, MEX_4k, CRT_1k, CRT_2k, CRT_4k, RNG, SECKEY
			 wrong user space type, just for compatibility
			  with the ZCRYPT_STATUS_MASK ioctl.
			 wrong user space type, must be CEX4
			  just keep it for cca compatibility
			 wrong user space type, must be CEX5
			  just keep it for cca compatibility
			 wrong user space type, must be CEX6
			  just keep it for cca compatibility
			 wrong user space type, must be CEX7
			  just keep it for cca compatibility
			 wrong user space type, just for compatibility
			  with the ZCRYPT_STATUS_MASK ioctl.
  This is called to remove the CEX4CEX5CEX6CEX7 card driver
  information if an AP card device is removed.
  Probe function for CEX4CEX5CEX6CEX7 queue device. It always
  accepts the AP device since the bus_match already checked
  the hardware type.
  @ap_dev: pointer to the AP device.
  This is called to remove the CEX4CEX5CEX6CEX7 queue driver
  information if an AP queue device is removed.
 SPDX-License-Identifier: GPL-2.0+
   Copyright IBM Corp. 2019
   Author(s): Harald Freudenberger <freude@linux.ibm.com>
 	       Ingo Franzki <ifranzki@linux.ibm.com>
   Collection of CCA misc functions used by zcrypt and pkey
 Size of parameter block used for all cca requestsreplies 
 Size of vardata block used for some of the cca requestsreplies 
 a list with cca_info_list_entry entries 
  Simple check if the token is a valid CCA secure AES data key
  token. If keybitsize is given, the bitsize of the key is
  also checked. Returns 0 on success or errno value on failure.
  Simple check if the token is a valid CCA secure AES cipher key
  token. If keybitsize is given, the bitsize of the key is
  also checked. If checkcpacfexport is enabled, the key is also
  checked for the export flag to allow CPACF export.
  Returns 0 on success or errno value on failure.
  Simple check if the token is a valid CCA secure ECC private
  key token. Returns 0 on success or errno value on failure.
  Allocate consecutive memory for request CPRB, request param
  block, reply CPRB and reply param block and fill in values
  for the common fields. Returns 0 on success or errno value
  on failure.
	
	  allocate consecutive memory for request CPRB, request param
	  block, reply CPRB and reply param block
 fill request cprb struct 
  Free the cprb memory allocated with the function above.
  If the scrub value is not zero, the memory is filled
  with zeros before freeing (useful if there was some
  clear key material in there).
  Helper function to prepare the xcrb struct
 'CA' 
  Generate (random) CCA AES DATA secure key.
 ... some more data ... 
 get already prepared memory for 2 cprbs with param block each 
 fill request cprb struct 
 fill request cprb param block with KG request 
 older ioctls used this 
 older ioctls used this 
 older ioctls used this 
 fill xcrb struct 
 forward xcrb with request CPRB and reply CPRB to zcrypt dd 
 check response returncode and reasoncode 
 process response cprb param block 
 check length of the returned secure key token 
 check secure key token 
 copy the generated secure key token 
  Generate an CCA AES DATA secure key with given key value.
 ... some more data ... 
 get already prepared memory for 2 cprbs with param block each 
 fill request cprb struct 
 fill request cprb param block with CM request 
 older ioctls used this 
 older ioctls used this 
 older ioctls used this 
 fill xcrb struct 
 forward xcrb with request CPRB and reply CPRB to zcrypt dd 
 check response returncode and reasoncode 
 process response cprb param block 
 check length of the returned secure key token 
 check secure key token 
 copy the generated secure key token 
  Derive proteced key from an CCA AES DATA secure key.
 cca secure key token 
 version of this struct 
 the key (len bytes) 
 verification pattern 
 get already prepared memory for 2 cprbs with param block each 
 fill request cprb struct 
 fill request cprb param block with USK request 
 fill xcrb struct 
 forward xcrb with request CPRB and reply CPRB to zcrypt dd 
 check response returncode and reasoncode 
 process response cprb param block 
 check the returned keyblock 
 copy the tanslated protected key 
 AES 128 protected key 
 AES 192 protected key 
 AES 256 protected key 
  AES cipher key skeleton created with CSNBKTB2 with these flags:
  INTERNAL, NO-KEY, AES, CIPHER, ANY-MODE, NOEX-SYM, NOEXAASY,
  NOEXUASY, XPRTCPAC, NOEX-RAW, NOEX-DES, NOEX-AES, NOEX-RSA
  used by cca_gencipherkey() and cca_clr2cipherkey().
  Generate (random) CCA AES CIPHER secure key.
 120-136 bytes 
 get already prepared memory for 2 cprbs with param block each 
 fill request cprb struct 
 prepare request param block with GK request 
 prepare vud block 
 prepare kb block 
 patch the skeleton key token export flags inside the kb block 
 prepare xcrb struct 
 forward xcrb with request CPRB and reply CPRB to zcrypt dd 
 check response returncode and reasoncode 
 process response cprb param block 
 do some plausibility checks on the key block 
 and some checks on the generated key 
 copy the generated vlsc key token 
  Helper function, does a the CSNBKPI2 CPRB.
 0x0064 
 0x0063 
 clear key value bytes 
 0x0030 
 key skeleton 
 0x0030 
 key token 
 get already prepared memory for 2 cprbs with param block each 
 fill request cprb struct 
 prepare request param block with IP request 
 prepare vud block 
 prepare key block 
 prepare xcrb struct 
 forward xcrb with request CPRB and reply CPRB to zcrypt dd 
 check response returncode and reasoncode 
 process response cprb param block 
 do some plausibility checks on the key block 
 do not check the key here, it may be incomplete 
 copy the vlsc key token back 
  Build CCA AES CIPHER secure key with a given clear key value.
 fill exorbuf with random data 
 allocate space for the key token to build 
 prepare the token with the key skeleton 
 patch the skeleton key token export flags 
	
	  Do the key import with the clear key value in 4 steps:
	  14 FIRST import with only random data
	  24 EXOR the clear key
	  34 EXOR the very same random data again
	  44 COMPLETE the secure cipher key import
 copy the generated key token 
  Derive proteced key from CCA AES cipher secure key.
 64 or more
 version of this struct 
 the key (keylen bytes) 
 verification pattern 
 get already prepared memory for 2 cprbs with param block each 
 fill request cprb struct 
 fill request cprb param block with AU request 
 vud, tk blob 
 kb, cca token 
 now fill length of param block into cprb 
 fill xcrb struct 
 forward xcrb with request CPRB and reply CPRB to zcrypt dd 
 check response returncode and reasoncode 
 process response cprb param block 
 check the returned keyblock 
 copy the translated protected key 
 AES 128 protected key 
 AES 192 protected key 
 AES 256 protected key 
  Derive protected key from CCA ECC secure private key.
 version of this struct 
 the key (keylen bytes) 
 verification pattern 
 get already prepared memory for 2 cprbs with param block each 
 fill request cprb struct 
 fill request cprb param block with AU request 
 vud, tk blob 
 kb, cca token 
 now fill length of param block into cprb 
 fill xcrb struct 
 forward xcrb with request CPRB and reply CPRB to zcrypt dd 
 check response returncode and reasoncode 
 process response cprb param block 
 check the returned keyblock 
 copy the translated protected key 
  query cryptographic facility from CCA adapter
 get already prepared memory for 2 cprbs with param block each 
 fill request cprb struct 
 fill request cprb param block with FQ request 
 fill xcrb struct 
 forward xcrb with request CPRB and reply CPRB to zcrypt dd 
 check response returncode and reasoncode 
 process response cprb param block 
 check and possibly copy reply rule array 
 check and possible copy reply var array 
  Fetch cca_info values via query_crypto_facility from adapter.
 get first info from zcrypt device driver about this apqn 
 prep page for rule array and var array use 
 QF for this carddomain 
  Fetch cca information about a CCA queue.
  Search for a matching crypto card based on the
  Master Key Verification Pattern given.
 mkvp must not be zero, minhwtype needs to be >= 0 
 fetch status of all crypto cards 
 walk through all crypto cards 
 enabled CCA card, check current mkvp from cache 
 verify: refresh card info 
 Card is offline andor not a CCA card. 
 del mkvp entry from cache if it exists 
 nothing found, so this time without cache 
 fresh fetch mkvp from adapter 
 old mkvp matched, use this card then 
  Search for a matching crypto card based on the Master Key
  Verification Pattern provided inside a secure key token.
 fetch status of all crypto cards 
 allocate 1k space for up to 256 apqns 
 walk through all the crypto apqnss 
 check online state 
 check for cca functions 
 check cardnr 
 check domain 
 get cca info on this apqn 
 current master key needs to be valid 
 check min hardware type 
 check mkvps 
 apqn passed all filtering criterons, add to the array 
 nothing found ? 
 no re-allocation, simple return the _apqns array 
 SPDX-License-Identifier: GPL-2.0-only
 uctrl.c: TS102 Microcontroller interface on Tadpole Sparcbook 3
  Copyright 1999 Derrick J Brashear (shadow@dementia.org)
  Copyright 2008 David S. Miller (davem@davemloft.net)
 Bits for uctrl_intr register 
 transmit FIFO empty int req 
 transmit FIFO not full int req 
 receive FIFO not empty int req 
 receive FIFO overflow int req 
 transmit FIFO empty mask 
 transmit FIFO not full mask 
 receive FIFO not empty mask 
 receive FIFO overflow mask 
 Bits for uctrl_stat register 
 transmit FIFO empty status 
 transmit FIFO not full status 
 receive FIFO not empty status 
 receive FIFO overflow status 
 Everything required for one transaction with the uctrl 
 0x07 
 0x0b 
 0x0c 
 0x10 
 0x11, 0x1b 
 0x18 
 0x19 
 0x20 
 0x21 
 0x23 
 0x24 
 0x28 
 0x29 
 0x2F 
 Wait for space to write, then write to it 
 Wait for something to read, read it, then clear the bit 
 Get the ack 
 SPDX-License-Identifier: GPL-2.0-only
 envctrl.c: Temperature and Fan monitoring on Machines providing it.
  Copyright (C) 1998  Eddie C. Dost  (ecd@skynet.be)
  Copyright (C) 2000  Vinh Truong    (vinh.truong@eng.sun.com)
  VT - The implementation is to support Sun Microelectronics (SME) platform
       environment monitoring.  SME platforms use pcf8584 as the i2c bus 
       controller to access pcf8591 (8-bit AD and DA converter) and 
       pcf8571 (256 x 8-bit static low-voltage RAM with I2C-bus interface).
       At board level, it follows SME Firmware I2C Specification. Reference:
  	http:www-eu2.semiconductors.compipPCF8584P
  	http:www-eu2.semiconductors.compipPCF8574AP
  	http:www-eu2.semiconductors.compipPCF8591P
  EB - Added support for CP1500 Global Address and PSVoltage monitoring.
  		Eric Brower <ebrower@usa.net>
  DB - Audit every copy_to_user in envctrl_read.
               Daniele Bellucci <bellucda@tiscali.it>
  CLK Mode Register.
 value to generate I2c_bus START condition 
 value to generate I2c_bus STOP condition 
 Monitor type of i2c child device.
  Firmware definitions.
 global address monitor 
 fan status monitor 
 voltage monitor    
 temperature monitor
 Monitor type of i2c child device.
  Driver definitions.
 cpu temperature monitor 
 voltage monitor         
 fan status monitor      
 ethernet temperature 
 monitor                     
 voltage status monitor  
 motherboard temperature 
 scsi temperature 
 global address 
 Child device type.
  Driver definitions.
 pcf8591 
 pcf8571 
 Data read from child device may need to decode
  through a data table and a scale.
  Translation type as defined by firmware.
 table[data] 
 table[data]scale 
 Driver miscellaneous definitions. 
 Mask values for combined GlobalAddressPowerStatus node 
 Node 0x70 ignored on CompactPCI CP14001500 platforms 
  (see envctrl_init_i2c_child)
 Each child device can be monitored by up to PCF8584_MAX_CHANNELS.
  Property of a port or channel as defined by the firmware.
 Each child device may have one or more tables of bytes to help decode
  data. Table property as defined by the firmware.
 offset from the beginning of the table 
 i2c child 
 Either ADC or GPIO. 
 Channel info.  
 Number of monitor channels. 
 Byte mask for fan status channels. 
 Byte mask for voltage status channels. 
 Properties of all monitor channels. 
 Number of monitor tables. 
 Pointer to table(s). 
 Channel description. 
 Forward declarations. 
 Function Description: Test the PIN bit (Pending Interrupt Not) 
  			 to test when serial transmission is completed .
  Return : None.
 Function Description: Test busy bit.
  Return : None.
 Busy bit 0 means busy. 
 Function Description: Send the address for a read access.
  Return : 0 if not acknowledged, otherwise acknowledged.
 Load address. 
 Wait for PIN. 
 CSR 0 means acknowledged. 
 Function Description: Send the address for write mode.  
  Return : None.
 Generate Start condition. 
 Function Description: Read 1 byte of data from addr 
 			 set by envctrl_i2c_read_addr() 
  Return : Data from address set by envctrl_i2c_read_addr().
 Send neg ack. 
 Function Description: Instruct the device which port to read data from.  
  Return : None.
 Function Description: Generate Stop condition after last byte is sent.
  Return : None.
 Function Description: Read adc device.
  Return : Data at address and port.
 Send address. 
 Setup port to read. 
 Read port. 
 Do a single byte read and send stop. 
 Function Description: Read gpio device.
  Return : Data at address.
 Do a single byte read and send stop. 
 Function Description: Decode data read from an adc device using firmware
                        table.
  Return: Number of read bytes. Data is stored in bufdata in ascii format.
 No decode necessary. 
 Decode this way: data = table[data]. 
 Decode this way: data = table[data]scale 
 Function Description: Read cpu-related data such as cpu temperature, voltage.
  Return: Number of read bytes. Data is stored in bufdata in ascii format.
 Find the right monitor type and channel. 
 Read data from address and port. 
 Find decoding table. 
 Function Description: Read noncpu-related data such as motherboard 
                        temperature.
  Return: Number of read bytes. Data is stored in bufdata in ascii format.
 Read data from address and port. 
 Find decoding table. 
 Function Description: Read fan status.
  Return : Always 1 byte. Status stored in bufdata.
 All bits are on. All fans are functioning. 
 No bits are on. No fans are functioning. 
		 Go through all channels, mark 'on' the matched bits.
		  Notice that fan_mask may have discontiguous bits but
		  return mask are always contiguous. For example if we
		  monitor 4 fans at channels 0,1,2,4, the return mask
		  should be 00010000 if only fan at channel 4 is working.
 Function Description: Read global addressing line.
  Return : Always 1 byte. Status stored in bufdata.
	 Translatation table is not necessary, as global
	  addr is the integer value of the GA# bits.
	 
	  NOTE: MSB is documented as zero, but I see it as '1' always....
	 
	  -----------------------------------------------
	  | 0 | FAL | DEG | GA4 | GA3 | GA2 | GA1 | GA0 |
	  -----------------------------------------------
	  GA0 - GA4	integer value of Global Address (backplane slot#)
	  DEG			0 = cPCI Power supply output is starting to degrade
	  				1 = cPCI Power supply output is OK
	  FAL			0 = cPCI Power supply has failed
	  				1 = cPCI Power supply output is OK
 Function Description: Read standard voltage and power supply status.
  Return : Always 1 byte. Status stored in bufdata.
 Two channels are used to monitor voltage and power supply. 
 All bits are on. Voltage and power supply are okay. 
 All bits are off. Voltage and power supply are bad 
 Either voltage or power supply has problem. 
 Break out when there is a mismatch. 
		 Make a wish that hardware will always use the
		  first channel for voltage and the second for
		  power supply.
 Function Description: Read a byte from devenvctrl. Mapped to user read().
  Return: Number of read bytes. 0 for error.
	 Get the type of read as decided in ioctl() call.
	  Find the appropriate i2c child.
	  Get the data and put back to the user buffer.
 Reset cpu to the default cpu0. 
 Reset cpu to the default cpu0. 
 If voltage monitor not present, check for CPCI equivalent 
 Function Description: Command what to read.  Mapped to user ioctl().
  Return: Gives 0 for implemented commands, -EINVAL otherwise.
		 Check to see if application passes in any cpu number,
		  the default is cpu0.
 Save the command for use when reading. 
 Function Description: open device. Mapped to user open().
  Return: Always 0.
 Function Description: Open device. Mapped to user close().
  Return: Always 0.
 Function Description: Set monitor type based on firmware description.
  Return: None.
	 Firmware only has temperature type.  It does not distinguish
	  different kinds of temperatures.  We use channel description
	  to disinguish them.
 Function Description: Initialize monitor channel with channel desc,
                        decoding tables, monitor type, optional properties.
  Return: None.
 Firmware describe channels into a stream separated by a '\0'. 
 Get optional properties. 
 Function Description: Initialize child device monitoring fan status.
  Return: None.
 Go through all channels and set up the mask. 
	 We only need to know if this child has fan status monitored.
	  We don't care which channels since we have the mask already.
 Function Description: Initialize child device for global addressing line.
  Return: None.
	 VoltagePowerSupply monitoring is piggybacked 
	  with Global Address on CompactPCI.  See comments
	  within envctrl_i2c_globaladdr for bit assignments.
	 
	  The mask is created here by assigning mask bits to each
	  bit position that represents PCF8584_VOLTAGE_TYPE data.
	  Channel numbers are not consecutive within the globaladdr
	  node (why?), so we use the actual counter value as chnls_mask
	  index instead of the chnl_array[x].chnl_no value.
	 
	  NOTE: This loop could be replaced with a constant representing
	  a mask of bits 5&6 (ENVCTRL_GLOBALADDR_PSTAT_MASK).
	 We only need to know if this child has global addressing 
	  line monitored.  We don't care which channels since we know 
	  the mask already (ENVCTRL_GLOBALADDR_ADDR_MASK).
 Initialize child device monitoring voltage status. 
 Go through all channels and set up the mask. 
	 We only need to know if this child has voltage status monitored.
	  We don't care which channels since we have the mask already.
 Function Description: Initialize i2c child device.
  Return: None.
 Get device address. 
 Get tables property.  Read firmware temperature tables. 
	 SPARCengine ASM Reference Manual (ref. SMI doc 805-7581-04)
	  sections 2.5, 3.5, 4.5 state node 0x70 for CP14001500 is
	  "For Factory Use Only."
	 
	  We ignore the node on these platforms by assigning the
	  'NULL' monitor type.
 Get the monitor channels. 
 Function Description: Search the child device list for a device.
  Return : The i2c child if found. NULL otherwise.
 TODO env_mon_interval 
 Set device address. 
 Set system clock and SCL frequencies.  
 Enable serial interface. 
 Register the device as a minor miscellaneous device. 
	 Note above traversal routine post-incremented 'i' to accommodate 
	  a next child device, so we decrement before reverse-traversal of
	  child devices.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2017, Oracle andor its affiliates. All rights reserved.
  Oracle Data Analytics Accelerator (DAX)
  DAX is a coprocessor which resides on the SPARC M7 (DAX1) and M8
  (DAX2) processor chips, and has direct access to the CPU's L3
  caches as well as physical memory. It can perform several
  operations on data streams with various input and output formats.
  The driver provides a transport mechanism only and has limited
  knowledge of the various opcodes and data formats. A user space
  library provides high level services and translates these into low
  level commands which are then passed into the driver and
  subsequently the hypervisor and the coprocessor.  The library is
  the recommended way for applications to use the coprocessor, and
  the driver interface is not intended for general use.
  See Documentationsparcoradaxoracle-dax.rst for more details.
 stream types 
 completion status 
 completion err 
 no error 
 buffer overflow 
 CCB decode error 
 page overflow 
 command was killed 
 Timeout 
 ADI error 
 data format error 
 Other error, do not retry 
 Other error, retry 
 QP partial symbol warning 
 CCB address types 
 secondary context 
 real address 
 virtual address 
 dax_header_t opcode 
 OR with translate, scan opcodes 
 31:28 CCB Version 
 27:24 Sync Flags 
 Pipeline 
 Longccb. Set for scan with lu2, lu3, lu4. 
 Conditional 
 Serial 
 23:16 Opcode 
 15:0 Address Type. 
 15:13 reserved 
 12:11 Huffman Table Address Type 
 10:8 Destination Address Type 
 7:5 Secondary Source Address Type 
 4:2 Primary Source Address Type 
 1:0 Completion Address Type 
 31:28 Primary Input Format 
 27:23 Primary Input Element Size(less1) 
 22:20 Primary Input Starting Offset 
 19    Secondary Input Encoding 
	 (must be 0 for Select) 
 18:16 Secondary Input Starting Offset 
 15:14 Secondary Input Element Size 
	 (must be 0 for Select) 
 13:12 Output Format 
 11:10 Output Element Size 
 9:0 Opcode specific info 
 63:62 Flow Control Type 
 61:60 Pipeline Target 
 59:40 Output Buffer Size 
	 (cachelines less 1) 
 39:32 Reserved, Set to 0 
 31:27 Output Allocation 
 26	 Reserved 
 25:24 Input Length Format 
 23:0  Input ElementByteBit Count 
	 (less 1) 
 CCB Header 
 Control Word 
 Completion Address 
 Primary Input Address 
 Data Access Control 
 Secondary Input Address 
 depends on opcode 
 Output Address 
 Table Address or bitmap 
 user may mwait on this address 
 user visible error notification 
 reserved 
 for QP partial symbol warning 
 output in bytes 
 reserved 
 run time in OCND2 cycles 
 nothing reported in version 1.0 
 number input elements 
 reserved 
 command return value 
 reserved 
 per thread CCB context 
 cached RA of ccb_buf  
 cached RA of ca_buf   
 array of locked pages 
 thread that owns ctx  
 requesting thread     
 driver public entry points 
 submit a zero length ccb array to query coprocessor queue size 
 map completion area 
 completion area is mapped read-only for user 
 Unlock user pages. Called during dequeue or device close 
		
		  For each address in the CCB whose type is virtual,
		  lock the page and change the type to virtual alternate
		  context. On error, return the offending address in
		  err_va.
 skip over 2nd 64 bytes of long CCB 
 CCB EXEC 
 immediate command 
 allocate CCB completion area buffer 
  Validates user CCB content.  Also sets completion address and address types
  for all addresses contained in CCB.
	
	  The user is not allowed to specify real address types in
	  the CCB header.  This must be enforced by the kernel before
	  submitting the CCBs to HV.  The only allowed values for all
	  address fields are VA or IMM
 set completion (real) address and address type 
 skip over 2nd 64 bytes of long CCB 
 for given index and length, verify ca_buf range exists 
	
	  Copy CCBs into kernel buffer to prevent modification by the
	  user in between validation and submission.
 check to see if ca_buf[idx] .. ca_buf[idx + nccbs] are available 
		
		  Hcall succeeded with no errors but the accepted
		  length may be less than the requested length.  The
		  only way the driver can resubmit the remainder is
		  to wait for completion of the submitted CCBs since
		  there is no way to guarantee the ordering semantics
		  required by the client applications.  Therefore we
		  let the user library deal with resubmissions.
		
		  This is a transient HV API error. The user library
		  can retry.
		
		  HV was unable to translate a VA. The VA it could
		  not translate is returned in the status_data param.
		
		  This is the result of an invalid user CCB as HV is
		  validating some of the user CCB fields.  Pass this
		  error back to the user. There is no supporting info
		  to isolate the invalid field.
		
		  HV found a VA that did not have the appropriate
		  permissions (such as the w bit). The VA in question
		  is returned in status_data param.
		
		  The requested CCB operation could not be performed
		  at this time. Return the specific unavailable code
		  in the status_data field.
 unlock pages associated with the unaccepted CCBs 
 mark unaccepted CCBs as not completed 
 no read needed to complete protocol 
 SPDX-License-Identifier: GPL-2.0
 bbc_envctrl.c: UltraSPARC-III environment control driver.
  Copyright (C) 2001, 2008 David S. Miller (davem@davemloft.net)
 WARNING: Making changes to this driver is very dangerous.
           If you misprogram the sensor chips they can
           cut the power on you instantly.
 Two temperature sensors exist in the SunBLADE-1000 enclosure.
  Both are implemented using max1617 i2c devices.  Each max1617
  monitors 2 temperatures, one for one of the cpu dies and the other
  for the ambient temperature.
  The max1617 is capable of being programmed with power-off
  temperature values, one low limit and one high limit.  These
  can be controlled independently for the cpu or ambient temperature.
  If a limit is violated, the power is simply shut off.  The frequency
  with which the max1617 does temperature sampling can be controlled
  as well.
  Three fans exist inside the machine, all three are controlled with
  an i2c digital to analog converter.  There is a fan directed at the
  two processor slots, another for the rest of the enclosure, and the
  third is for the power supply.  The first two fans may be speed
  controlled by changing the voltage fed to them.  The third fan may
  only be completely off or on.  The third fan is meant to only be
  disabledenabled when enteringexiting the lowest power-saving
  mode of the machine.
  An environmental control kernel thread periodically monitors all
  temperature sensors.  Based upon the samples it will adjust the
  fan speeds to try and keep the system within a certain temperature
  range (the goal being to make the fans as quiet as possible without
  allowing the system to get too hot).
  If the temperature begins to risefall outside of the acceptable
  operating range, a periodic warning will be sent to the kernel log.
  The fans will be put on full blast to attempt to deal with this
  situation.  After exceeding the acceptable operating range by a
  certain threshold, the kernel thread will shut down the system.
  Here, the thread is attempting to shut the machine down cleanly
  before the hardware based power-off event is triggered.
 These settings are in Celsius.  We use these defaults only
  if we cannot interrogate the cpu-fru SEEPROM.
	 Put temperatures into range so we don't mis-program
	  the hardware.
 Now check the shutdown limits. 
		 We do not try to avoid 'too cold' events.  Basically we
		  only try to deal with over-heating and fan noise reduction.
 Now check the shutdown limits. 
		 We do not try to avoid 'too cold' events.  Basically we
		  only try to deal with over-heating and fan noise reduction.
	 Basically, prioritize what the temperature sensors
	  recommend we do, and perform that action on all the
	  fans.
	 Since we will not be monitoring things anymore, put
	  the fans on full blast.
	 Tell it to convert once every 5 seconds, clear all cfg
	  bits.
 Program the hard temperature limits into the chip. 
	 The i2c device controlling the fans is write-only.
	  So the only way to keep track of the current power
	  level fed to the fans is via software.  Choose half
	  power for cpusystem and 'on' fo the powersupply fan
	  and set it now.
 SPDX-License-Identifier: GPL-2.0-only
 display7seg.c - Driver implementation for the 7-segment display
                  present on Sun Microsystems CP1400 and CP1500
  Copyright (c) 2000 Eric Brower (ebrower@usa.net)
 request_region 
 put_get_user			
 Solaris compatibility mode	
 Solaris compatibility flag -
  The Solaris implementation omits support for several
  documented driver features (ref Sun doc 806-0180-03).  
  By default, this module supports the documented driver 
  abilities, rather than the Solaris implementation:
  	1) Device ALWAYS reverts to OBP-specified FLIPPED mode
  	   upon closure of device or module unload.
  	2) Device ioctls D7SIOCRDD7SIOCWR honor toggling of
  	   FLIP bit
  If you wish the device to operate as under Solaris,
  omitting above features, set this parameter to non-zero.
  Register block address- see header for details
  -----------------------------------------
  | DP | ALARM | FLIP | 4 | 3 | 2 | 1 | 0 |
  -----------------------------------------
  DP 		- Toggles decimal point onoff 
  ALARM	- Toggles "Alarm" LED greenred
  FLIP		- Inverts display for upside-down mounted board
  bits 0-4	- 7-segment display contents
	 Reset flipped state to OBP default only if
	  no other users have the device open and we
	  are not operating in solaris-compat mode
		 assign device register values we mask-out D7S_FLIP
		  if in sol_compat mode
		 retrieve device register values
		  NOTE: Solaris implementation returns D7S_FLIP bit
		  as toggled by user, even though it does not honor it.
		  This driver will not misinform you about the state
		  of your hardware while in sol_compat mode
 toggle device mode-- flip display orientation 
	 OBP option "d7s-flipped?" is honored as default for the
	  device, and reset default when detached
 Honor OBP d7s-flipped? unless operating in solaris-compat mode 
 SPDX-License-Identifier: GPL-2.0-only
 bbc_i2c.c: I2C low-level driver for BBC device on UltraSPARC-III
             platforms.
  Copyright (C) 2001, 2008 David S. Miller (davem@davemloft.net)
 Convert this driver to use i2c bus layer someday... 
 1 if not initialized 
 The BBC devices have two I2C controllers.  The first I2C controller
  connects mainly to configuration proms (NVRAM, cpu configuration,
  dimm types, etc.).  Whereas the second I2C controller connects to
  environmental control devices such as fans and temperature sensors.
  The second controller also connects to the smartcard reader, if present.
 READ 
	 Set PIN back to one so the device sends the first
	  byte.
	 PIN going from set to clear is the only event which
	  makes the i2c assert an interrupt.
 SPDX-License-Identifier: GPL-2.0-or-later
  LinuxSPARC PROM Configuration Driver
  Copyright (C) 1996 Thomas K. Dyas (tdyas@noc.rutgers.edu)
  Copyright (C) 1996 Eddie C. Dost  (ecd@skynet.be)
  This character device driver allows user programs to access the
  PROM device tree. It is compatible with the SunOS devopenprom
  driver and the NetBSD devopenprom driver. The SunOS eeprom
  utility works without any modifications.
  The driver uses a minor number under the misc device major. The
  file readwrite mode determines the type of access to the PROM.
  Interrupts are disabled whenever the driver calls into the PROM for
  sanity's sake.
 Private data kept by the driver for each descriptor. 
 Current node for SunOS ioctls. 
 Last valid node used by BSD ioctls. 
 ID of the PROM node containing all of the EEPROM options. 
  Copy an openpromio structure into kernel space from user space.
  This routine does error checking to make sure that all memory
  accesses are within bounds. A pointer to the allocated openpromio
  structure will be placed in "opp_p". Return value is the length
  of the user supplied buffer.
	 If the bufsize is too large, just limit it.
	  Fix from Jason Rappleye.
  Copy an openpromio structure in kernel space back to user space.
 Sibling of node zero is the root node.  
 	SunOS and Solaris devopenprom ioctl calls.
 Copy in a whole string from userspace into kernelspace. 
 	NetBSD devopenprom ioctl calls.
 	Handoff control to the correct ioctl handler.
	
	  SunOSSolaris only, the NetBSD one's have embedded pointers in
	  the arg which we'd need to clean up...
 SPDX-License-Identifier: GPL-2.0-only
 flash.c: Allow mmap access to the OBP Flash, for OBP updates.
  Copyright (C) 1997  Eddie C. Dost  (ecd@skynet.be)
 Physical read address 
 Physical write address 
 Size of read area 
 Size of write area 
 In use? 
	 no write to the Flash, use mmap
	  and play flash dependent tricks.
 SPDX-License-Identifier: GPL-2.0-only
  (C) Copyright 2009 Intel Corporation
  Author: Jacob Pan (jacob.jun.pan@intel.com)
  Shared with ARM platforms, Jamie Iles, Picochip 2011
  Support for the Synopsys DesignWare APB Timers.
 1: periodic, 0:free running. 
  dw_apb_clockevent_pause() - stop the clock_event_device from running
  @dw_ced:	The APB clock to stop generating events.
 clear pending intr 
	
	  set free running mode, this mode will let timer reload max
	  timeout which will give time (3min on 25MHz clock) to rearm
	  the next event, therefore emulate the one-shot mode.
 write again to set free running mode 
	
	  DW APB p. 46, load counter with all 1s before starting free
	  running mode.
	
	  DW APB p. 46, have to disable timer before load counter,
	  may cause sync problem.
 Disable timer 
 write new count 
  dw_apb_clockevent_init() - use an APB timer as a clock_event_device
  @cpu:	The CPU the events will be targeted at or -1 if CPU affiliation
 		isn't required.
  @name:	The name used for the timer and the IRQ for it.
  @rating:	The rating to give the timer.
  @base:	IO base for the timer registers.
  @irq:	The interrupt number to use for the timer.
  @freq:	The frequency that the timer counts at.
  This creates a clock_event_device for using with the generic clock layer
  but does not start and register it.  This should be done with
  dw_apb_clockevent_register() as the next step.  If this is the first time
  it has been called for a timer then the IRQ will be requested, if not it
  just be enabled to allow CPU hotplug to avoid repeatedly requesting and
  releasing the IRQ.
  dw_apb_clockevent_resume() - resume a clock that has been paused.
  @dw_ced:	The APB clock to resume.
  dw_apb_clockevent_stop() - stop the clock_event_device and release the IRQ.
  @dw_ced:	The APB clock to stop generating the events.
  dw_apb_clockevent_register() - register the clock with the generic layer
  @dw_ced:	The APB clock to register as a clock_event_device.
  dw_apb_clocksource_start() - start the clocksource counting.
  @dw_cs:	The clocksource to start.
  This is used to start the clocksource before registration and can be used
  to enable calibration of timers.
	
	  start count down from 0xffff_ffff. this is done by toggling the
	  enable bit then load initial load count to ~0.
 enable, mask interrupt 
 read it once to get cached counter value initialized 
  dw_apb_clocksource_init() - use an APB timer as a clocksource.
  @rating:	The rating to give the clocksource.
  @name:	The name for the clocksource.
  @base:	The IO base for the timer registers.
  @freq:	The frequency that the timer counts at.
  This creates a clocksource using an APB timer but does not yet register it
  with the clocksource system.  This should be done with
  dw_apb_clocksource_register() as the next step.
  dw_apb_clocksource_register() - register the APB clocksource.
  @dw_cs:	The clocksource to register.
  dw_apb_clocksource_read() - read the current value of a clocksource.
  @dw_cs:	The clocksource to read.
  J-Core SoC PITclocksource driver
  Copyright (C) 2015-2016 Smart Energy Instruments, Inc.
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
	
	  The J-Core PIT is not hard-wired to a particular IRQ, but
	  integrated with the interrupt controller such that the IRQ it
	  generates is programmable, as follows:
	 
	  The bit layout of the PIT enable register is:
	 
	 	.....e..ppppiiiiiiii............
	 
	  where the .'s indicate unrelatedunused bits, e is enable,
	  p is priority, and i is hard irq number.
	 
	  For the PIT included in AIC1 (obsolete but still in use),
	  any hard irq (trap number) can be programmed via the 8
	  iiiiiiii bits, and a priority (0-15) is programmable
	  separately in the pppp bits.
	 
	  For the PIT included in AIC2 (current), the programming
	  interface is equivalent modulo interrupt mapping. This is
	  why a different compatible tag was not used. However only
	  traps 64-127 (the ones actually intended to be used for
	  interrupts, rather than syscallsexceptionsetc.) can be
	  programmed (the high 2 bits of i are ignored) and the
	  priority pppp is <<2'd and or'd onto the irq number. This
	  choice seems to have been made on the hardware engineering
	  side under an assumption that preserving old AIC1 priority
	  mappings was important. Future models will likely ignore
	  the pppp field.
 SPDX-License-Identifier: GPL-2.0-or-later
  Clocksource using the Low Power Timer found in the Low Power Controller (LPC)
  Copyright (C) 2015 STMicroelectronics – All Rights Reserved
  Author(s): Francesco Virlinzi <francesco.virlinzi@st.com>
 	      Ajit Pal Singh <ajitpal.singh@st.com>
 Low Power Timer 
 LPC can either run as a Clocksource or in RTC or WDT mode 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2010 Google, Inc.
  Author:
 	Colin Cross <ccross@google.com>
	
	  Tegra's timer uses n+1 scheme for the counter, i.e. timer will
	  fire after one tick if 0 is loaded.
	 
	  The minimum and maximum numbers of oneshot ticks are defined
	  by clockevents_config_and_register(1, 0x1fffffff + 1) invocation
	  below in the code. Hence the cycles (ticks) can't be outside of
	  a range supportable by hardware.
	
	  Tegra's timer uses n+1 scheme for the counter, i.e. timer will
	  fire after one tick if 0 is loaded and thus minimum number of
	  ticks is 1. In result both of the clocksource's tick limits are
	  higher than a minimum and maximum that hardware register can
	  take by 1, this is then taken into account by set_next_event
	  callback.
 min 
 max 29 bits + 1 
  tegra_rtc_read - Reads the Tegra RTC registers
  Care must be taken that this function is not called while the
  tegra_rtc driver could be executing to avoid race conditions
  on the RTC shadow register
	
	  TIMER1-9 are fixed to 1MHz, TIMER10-13 are running off the
	  parent clock.
	
	  Configure microsecond timers to have 1MHz clock
	  Config register is 0xqqww, where qq is "dividend", ww is "divisor"
	  Uses n+1 scheme
 (11+1)(0+1) 
 (63+1)(4+1) 
 (12+1)(0+1) 
 (83+1)(4+1) 
 (95+1)(4+1) 
 (25+1)(0+1) 
 (191+1)(4+1) 
 (47+1)(0+1) 
	
	  Arch-timer can't survive across power cycle of CPU core and
	  after CPUPORESET signal due to a system design shortcoming,
	  hence tegra-timer is more preferable on Tegra210.
	
	  Tegra20 and Tegra30 have Cortex A9 CPU that has a TWD timer,
	  that timer runs off the CPU clock and hence is subjected to
	  a jitter caused by DVFS clock rate changes. Tegra-timer is
	  more preferable for older Tegra's, while later SoC generations
	  have arch-timer as a main per-CPU timer and it is not affected
	  by DVFS changes.
 SPDX-License-Identifier: GPL-2.0-only
  driversclocksourcearm_global_timer.c
  Copyright (C) 2013 STMicroelectronics (R&D) Limited.
  Author: Stuart Menefy <stuart.menefy@st.com>
  Author: Srinivas Kandagatla <srinivas.kandagatla@st.com>
 this bit is NOT banked 
 banked 
 banked 
 banked 
  We are expecting to be clocked by the ARM peripheral clock.
  Note: it is assumed we are using a prescaler value of zero, so this is
  the units for all operations.
  To get the value from the Global Timer Counter register proceed as follows:
  1. Read the upper 32-bit timer counter register
  2. Read the lower 32-bit timer counter register
  3. Read the upper 32-bit timer counter register again. If the value is
   different to the 32-bit upper value read previously, go back to step 2.
   Otherwise the 64-bit timer counter value is correct.
  To ensure that updates to comparator value register do not set the
  Interrupt Status Register proceed as follows:
  1. Clear the Comp Enable bit in the Timer Control Register.
  2. Write the lower 32-bit Comparator Value Register.
  3. Write the upper 32-bit Comparator Value Register.
  4. Set the Comp Enable bit and, if necessary, the IRQ enable bit.
	
	  ERRATA 740657( Global Timer can send 2 interrupts for
	  the same event in single-shot mode)
	  Workaround:
	 	Either disable single-shot mode.
	 	Or
	 	Modify the Interrupt Handler to avoid the
	 	offending sequence. This is achieved by clearing
	 	the Global Timer flag _after_ having incremented
	 	the Comparator register	value to a higher value.
 re-enable timer on resume 
 set prescaler and enable timer on all the cores 
 prescaler within legal range? 
		
		  store timer clock ctrl register so we can restore it in case
		  of an abort.
 scale down: adjust divider in post-change notification 
 scale up: adjust divider now - before frequency change 
 scale up: pre-change notification did the adjustment 
 scale down: adjust divider now - after frequency change 
 we have to undo the adjustment in case we scale up 
 restore original register value 
	
	  In A9 r2p0 the comparators for each processor with the global timer
	  fire when the timer value is greater than or equal to. In previous
	  revisions the comparators fired when the timer value was equal to.
 Register and immediately configure the timer on the boot CPU 
 Only tested on r2p2 and r3p0  
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) Maxime Coquelin 2015
  Author:  Maxime Coquelin <mcoquelin.stm32@gmail.com>
  Inspired by time-efm32.c from Uwe Kleine-Koenig
  stm32_timer_of_bits_set - set accessor helper
  @to: a timer_of structure pointer
  @bits: the number of bits (16 or 32)
  Accessor helper to set the number of bits in the timer-of private
  structure.
  stm32_timer_of_bits_get - get accessor helper
  @to: a timer_of structure pointer
  Accessor helper to get the number of bits in the timer-of private
  structure.
  Returns an integer corresponding to the number of bits.
  stm32_timer_start - Start the counter without event
  @to: a timer_of structure pointer
  Start the timer in order to have the counter reset and start
  incrementing but disable interrupt event when there is a counter
  overflow. By default, the counter direction is used as upcounter.
  stm32_timer_width - Sort out the timer width (3216)
  @to: a pointer to a timer-of structure
  Write the 32-bit max value and readreturn the result. If the timer
  is 32 bits wide, the result will be UINT_MAX, otherwise it will
  be truncated by the 16-bit register to USHRT_MAX.
  stm32_timer_set_prescaler - Compute and set the prescaler register
  @to: a pointer to a timer-of structure
  Depending on the timer width, compute the prescaler to always
  target a 10MHz timer rate for 16 bits. 32-bit timers are
  considered precise and long enough to not use the prescaler.
		
		  The prescaler register is an u16, the variable
		  can't be greater than TIM_PSC_MAX, let's cap it in
		  this case.
 Adjust rate and period given the prescaler value 
	
	  This driver allows to register several timers and relies on
	  the generic time framework to select the right one.
	  However, nothing allows to do the same for the
	  sched_clock. We are not interested in a sched_clock for the
	  16-bit timers but only for the 32-bit one, so if no 32-bit
	  timer is registered yet, we select this 32-bit timer as a
	  sched_clock.
		
		  Start immediately the counter as we will be using
		  it right after.
 SPDX-License-Identifier: GPL-2.0-or-later
  linuxarcharmmach-at91at91rm9200_time.c
   Copyright (C) 2003 SAN People
   Copyright (C) 2003 ATMEL
  The ST_CRTR is updated asynchronously to the master clock ... but
  the updates as seen by the CPU don't seem to be strictly monotonic.
  Waiting until we read the same value twice avoids glitching.
  IRQ handler for the timer.
	
	  irqs should be disabled here, but as the irq is shared they are only
	  guaranteed to be off if the timer irq is registered first.
 simulate "oneshot" timer with alarm 
 periodic mode should handle delayed ticks 
 this irq is shared ... 
 Disable and flush pending timer interrupts 
	
	  ALM for oneshot irqs, set by next_event()
	  before 32 seconds have passed.
 PIT for periodic irqs; fixed rate of 1HZ 
	 The alarm IRQ uses absolute time (now+delta), not the relative
	  time (delta) in our calling convention.  Like all clockevents
	  using such "match" hardware, we have a race to defend against.
	 
	  Our defense here is to have set up the clockevent device so the
	  delta is at least two.  That way we never end up writing RTAR
	  with the value then held in CRTR ... which would mean the match
	  wouldn't trigger until 32 seconds later, after CRTR wraps.
 Cancel any pending alarm; flush any pending IRQ 
 Schedule alarm by writing RTAR. 
  ST (system timer) module supports both clockevents and clocksource.
 Disable all timer interrupts, and clear any pending ones 
 Get the interrupts property 
 Make IRQs happen for the system timer 
	 The 32KiHz "Slow Clock" (tick every 30517.58 nanoseconds) is used
	  directly for the clocksource and all clockevents, after adjusting
	  its prescaler from the 1 Hz default.
 Setup timer clockevent, with minimum of two ticks (important!!) 
 register clocksource 
 SPDX-License-Identifier: GPL-2.0
  Amlogic Meson6 SoCs timer handling.
  Copyright (C) 2014 Carlo Caione <carlo@caione.org>
  Based on code from Amlogic, Inc
 Set 1us for timer E 
 Timer A base 1us 
 Stop the timer A 
 Also use MESON_ISA_TIMERE for delays 
 SPDX-License-Identifier: GPL-2.0
  JZ47xx SoCs TCU Operating System Timer driver
  Copyright (C) 2016 Maarten ter Huurne <maarten@treewalker.org>
  Copyright (C) 2020 Paul Cercueil <paul@crapouillou.net>
  The TCU_REG_OST_CNT{L,R} from <linuxmfdingenic-tcu.h> are only for the
  regmap; these are for use with the __iomem pointer.
 Read using __iomem pointer instead of regmap to avoid locking 
 Read using __iomem pointer instead of regmap to avoid locking 
 Clear counter highlow registers 
 Don't reset counter at compare value. 
 Enable OST TCU channel 
 _noirq: We want the OST clock to be gated last  ungated first 
 SPDX-License-Identifier: GPL-2.0
  SuperH Timer Support - MTU2
   Copyright (C) 2009 Magnus Damm
 Protect the shared registers 
 shared register 
 channel register 
 channel register 
 channel register 
 channel register 
 channel register 
 channel register 
 channel register 
 Values 4 to 7 are channel-dependent 
 start stop register shared by multiple timer channels 
 enable clock 
 make sure channel is disabled 
	
	  "Periodic Counter Operation"
	  Clear on TGRA compare match, divide clock by 64.
 enable channel 
 disable channel 
 stop clock 
 acknowledge interrupt 
 notify clockevent layer 
 Skip channels with no declared interrupt. 
 Get hold of clock. 
 Map the memory resource. 
 Allocate and setup the channels. 
 cannot unregister clockevent 
 SPDX-License-Identifier: GPL-2.0-or-later
  Freescale FlexTimer Module (FTM) timer driver.
  Copyright 2014 Freescale Semiconductor, Inc.
 select and enable counter clock source 
 disable counter clock source 
	
	  The CNT register contains the FTM counter value.
	  Reset clears the CNT register. Writing any value to COUNT
	  updates the counter with its initial value, CNTIN.
	
	  The CNNIN and MOD are all double buffer registers, writing
	  to the MOD register latches the value into a buffer. The MOD
	  register is updated with the value of its write buffer with
	  the following scenario:
	  a, the counter source clock is disabled.
 Force the value of CNTIN to be loaded into the FTM counter 
	
	  The counter increments until the value of MOD is reached,
	  at which point the counter is reloaded with the value of CNTIN.
	  The TOF (the overflow flag) bit is set when the FTM counter
	  changes from MOD to CNTIN. So we should using the delta - 1.
	 The counter register is only using the lower 16 bits, and
	  if the 'freq' value is to big here, then the periodic_cyc
	  may exceed 0xFFFF.
 SPDX-License-Identifier: GPL-2.0-only
   linuxdriversclocksourcearm_arch_timer.c
   Copyright (C) 2011 ARM Ltd.
   All Rights Reserved
  The minimum amount of time a generic counter is guaranteed to not roll over
  (40 years)
 CONFIG_GENERIC_GETTIMEOFDAY 
  Makes an educated guess at a valid counter width based on the Generic Timer
  specification. Of note:
    1) the system counter is at least 56 bits wide
    2) a roll-over time of not less than 40 years
  See 'ARM DDI 0487G.a D11.1.2 ("The system counter")' for more details.
 guarantee the returned width is within the valid range 
  Architected system timer support.
			
			  Not guaranteed to be atomic, so the timer
			  must be disabled at this point.
 Same restriction as above 
  Default to cp15 based access because arm64 uses this function for
  sched_clock() before DT is probed and the cp15 method is guaranteed
  to exist on arm64. arm doesn't use this before DT is probed so even
  if we don't have the cp15 accessors we won't have a problem.
  The number of retries is an arbitrary value well beyond the highest number
  of iterations the loop has been observed to take.
  Verify whether the value of the second read is larger than the first by
  less than 32 is the only way to confirm the value is correct, so clear the
  lower 5 bits to check whether the difference is greater than 32 or not.
  Theoretically the erratum should not occur more than twice in succession
  when reading the system counter, but it is possible that some interrupts
  may lead to more than twice read errors, triggering the warning, so setting
  the number of retries far beyond the number of iterations the loop has been
  observed to take.
	
	  Note that trailing spaces are required to properly match
	  the OEM table information.
 Sentinel indicating the end of the OEM array  },
  The low bits of the counter registers are indeterminate while bit 10 or
  greater is rolling over. Since the counter value can jump both backward
  (7ff -> 000 -> 800) and forward (7ff -> fff -> 800), ignore register values
  with all ones or all zeros in the low bits. Bound the loop by the maximum
  number of CPU cycles in 3 consecutive 24 MHz counter periods.
 Iterate over the ACPI OEM info array, looking for a match 
	
	  Don't use the vdso fastpath if errata require using the
	  out-of-line counter accessor. We may change our mind pretty
	  late in the game (with a per-CPU erratum, for example), so
	  change both the default value and the vdso itself.
 CONFIG_ARM_ARCH_TIMER_OOL_WORKAROUND 
		
		  XGene-1 implements CVAL in terms of TVAL, meaning
		  that the maximum timer range is 32bit. Shame on them.
 Set the divider and enable virtual event stream 
	
	  As the event stream can at most be generated at half the frequency
	  of the counter, use half the frequency when computing the divider.
	
	  Find the closest power of two to the divisor. If the adjacent bit
	  of lsb (last set bit, starts from 0) is set, then we use (lsb + 1).
 enable event stream 
 Disable user access to the timers and both counters 
 Also disable virtual event stream 
	
	  Enable user access to the virtual counter if it doesn't
	  need to be workaround. The vdso may have been already
	  disabled though.
 Arch timer frequency < 1MHz can cause trouble 
  For historical reasons, when probing with DT we use whichever (non-zero)
  rate was probed first, and don't verify that others match. If the first node
  probed has a clock-frequency property, this overrides the HW register.
 Who has more than one independent system counter? 
 Check the timer frequency. 
	
	  We might get called from a preemptible context. This is fine
	  because availability of the event stream should be always the same
	  for a preemptible context and context where we might resume a task.
 Register the CP15 based counter if we have one 
 Register and immediately configure the timer on the boot CPU 
 We have two timers, and both device-tree nodes are probed. 
	
	  Only one type of timer is probed,
	  check if we have another type of timer node in device-tree.
  arch_timer_select_ppi() - Select suitable PPI for the current system.
  If HYP mode is available, we know that the physical timer
  has been configured to be accessible from PL1. Use it, so
  that a guest can use the virtual timer instead.
  On ARMv8.1 with VH extensions, the kernel runs in HYP. VHE
  accesses to CNTP__EL1 registers are silently redirected to
  their CNTHP__EL2 counterparts, and use a different PPI
  number.
  If no interrupt provided for virtual timer, we'll have to
  stick to the physical timer. It'd better be accessible...
  For arm64 we never use the secure interrupt.
  Return: a suitable PPI type for the current system.
 Check for globally applicable workarounds 
	
	  If we cannot rely on firmware initializing the timer registers then
	  we should use the physical timers instead.
 On some systems, the counter stops ticking when in suspend. 
	
	  Try to find a virtual capable frame. Otherwise fall back to a
	  physical capable frame.
 Try enabling everything, and see what sticks 
	
	  While unlikely, it's theoretically possible that none of the frames
	  in a timer expose the combination of feature we want.
 implies !frame 
			
			  Only complain about missing suitable frames if we
			  haven't already found one in a previous iteration.
 Initialize per-processor generic timer and memory-mapped timer(if present) 
	
	  When probing via ACPI, we have no mechanism to override the sysreg
	  CNTFRQ value. This must be correct.
 Always-on capability 
 Check for globally applicable workarounds 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018 Hangzhou C-SKY Microsystems co.,ltd.
  clock event for percpu
  clock source
	
	  Csky_mptimer is designed for C-SKY SMP multi-processors and
	  every core has it's own private irq and regs for clkevt and
	  clksrc.
	 
	  The regs is accessed by cpu instruction: mfcrmtcr instead of
	  mmio map style. So we needn't mmio-address in dts, but we still
	  need to give clk and irq number.
	 
	  We use private irq for the mptimer and irq number is the same
	  for every core. So we use request_percpu_irq() in timer_of_init.
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2005-2017 Andes Technology Corporation
   Andestech ATCPIT100 Timer Device Driver Implementation
  Rick Chen, Andes Technology Corporation <rick@andestech.com>
  Definition of register offsets
 ID and Revision Register 
 Configuration Register 
 Interrupt Enable Register 
 Interrupt Status Register 
 Channel Enable Register 
 Channel 0 , 1 Control Register 
 Channel clock source , bit 3 , 0:External clock , 1:APB clock 
 Channel mode , bit 0~2 
 Channel 0 , 1 Reload Register 
 Channel 0 , 1 Counter Register 
	
	  FIXME: we currently only support clocking using PCLK
	  and using EXTCLK is not supported in the driver.
 clear channel 0 timer0 interrupt 
 Enable channel 0 timer0 interrupt 
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2017-2019 NXP
	
	  clear the enable bit(EN =0) will clear
	  the status bit(ISTAT = 0), then the interrupt
	  signal will be negated(acknowledged).
 system counter clock is divided by 3 internally 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018 Socionext Inc.
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018 Hangzhou C-SKY Microsystems co.,ltd.
 reset and stop counter 
 enable with irq and start 
 use reset to pause timer 
 config next timeout value 
	
	  The timer driver is for nationalchip gx6605s SOC and there are two
	  same timer in gx6605s. We use one for clkevt and another for clksrc.
	 
	  The timer is mmio map to access, so we need give mmio address in dts.
	 
	  It provides a 32bit countup timer and interrupt will be caused by
	  count-overflow.
	  So we need set-next-event by ULONG_MAX - delta in TIMER_INI reg.
	 
	  The counter at 0x0  offset is clock event.
	  The counter at 0x40 offset is clock source.
	  They are the same in hardware, just different used by driver.
 SPDX-License-Identifier: GPL-2.0
  Faraday Technology FTTMR010 timer driver
  Copyright (C) 2017 Linus Walleij <linus.walleij@linaro.org>
  Based on a rewrite of archarmmach-geminitimer.c:
  Copyright (C) 2001-2006 Storlink, Corp.
  Copyright (C) 2008-2009 Paulius Zaleckas <paulius.zaleckas@teltonika.lt>
  Register definitions common for all the timer variants.
  Control register set to clear for ast2600 only.
  Control register (TMC30) bit fields for fttmr010geminimoxart timers.
  Control register (TMC30) bit fields for aspeed ast2400ast2500 timers.
  The aspeed timers move bits around in the control register and lacks
  bits for setting the timer to count upwards.
  Interrupt statusmask register definitions for fttmr010geminimoxart
  timers.
  The registers don't exist and they are not needed on aspeed timers
  because:
    - aspeed timer overflow interrupt is controlled by bits in Control
      Register (TMC30).
    - aspeed timers always generate interrupt when either one of the
      Match registers equals to Status register.
  A local singleton used by sched_clock and delay timer reads, which are
  fast and stateless
 Stop 
		
		  ASPEED Timer Controller will load TIMER1_LOAD register
		  into TIMER1_COUNT register when the timer is re-enabled.
 Setup the match register forward in time 
 Start 
 Stop 
 Stop 
 Stop 
 Setup counter start from 0 or ~0 
 Enable interrupt 
 Stop 
 Setup timer to fire at 1HZ intervals. 
 Enable interrupt on overflow 
 Start the timer 
  IRQ handler for the timer
	
	  These implementations require a clock reference.
	  FIXME: we currently only support clocking using PCLK
	  and using EXTCLK is not supported in the driver.
 IRQ for timer 1 
	
	  The Aspeed timers move bits around in the control register.
		
		  Reset the interrupt mask and status
	
	  Enable timer 1 count up, timer 2 count up, except on Aspeed,
	  where everything just counts down.
	
	  Setup free-running clocksource timer (interrupts
	  disabled.)
	
	  Setup clockevent timer (interrupt-driven) on timer 1.
 Reasonably fast and accurate clock event 
 Also use this timer for delays 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2012 Altera Corporation
  Copyright (c) 2011 Picochip Ltd., Jamie Iles
  Modified from mach-picoxcelltime.c
	
	  Reset the timer if the reset control is available, wiping
	  out the state the firmware may have left it
	
	  Not all implementations use a peripheral clock, so don't panic
	  if it's not present
	
	  Fallback to use the clocksource as sched_clock if no separate
	  timer is found. sched_io_base then points to the current_value
	  register of the clocksource timer.
 Sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008 STMicroelectronics
  Copyright (C) 2010 Alessandro Rubini
  Copyright (C) 2010 Linus Walleij for ST-Ericsson
  The MTU device hosts four different counters, with 4 set of
  registers. These are register names.
 Interrupt mask setclear 
 Raw interrupt status 
 Masked interrupt status 
 Interrupt clear register 
 per-timer registers take 0..3 as argument 
 Load value 
 Current value 
 Control reg 
 At next overflow 
 bits for the control register 
 if 0 = free-running 
 if 0 = wraps reloading from BGLR
 Other registers are usual ambaprimecell registers, currently not used 
 write-once 
  Override the global weak sched_clock symbol with this
  local implementation which uses the clocksource to get some
  better resolution when scheduling the kernel.
 Clockevent device: use one-shot mode 
 Load highest value, enable device, enable interrupts 
 Timer: configure load and background-load, and fire it up 
 Generate an interrupt to start the clockevent again 
 disable timer 
 load some high default value 
 Disable 
 ClockSource: configure load and background-load, and fire it up 
  IRQ Handler for timer 1 of the MTU block.
 Interrupt clear reg 
	
	  Tick rate is 2.4MHz for Nomadik and 2.4Mhz, 100MHz or 133 MHz
	  for ux500, and in one specific Ux500 case 32768 Hz.
	 
	  Use a divide-by-16 counter if the tick rate is more than 32MHz.
	  At 32 MHz, the timer (with 32 bit counter) can be programmed
	  to wake-up at a max 127s a head in time. Dividing a 2.4 MHz timer
	  with 16 gives too low timer resolution.
 Cycles for periodic mode 
 Timer 0 is the free running clocksource 
 Timer 1 is used for events, register irq and clockevents 
  Copyright (C) 2012 Broadcom Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  We use the peripheral timers for system tick, the cpu global timer for
  profile tick
	
	  clear and disable interrupts
	  We are using comparematch register 0 for our system interrupts
 Clear compare (0) interrupt 
 disable compare 
	
	  Read 64-bit free running counter
	  1. Read hi-word
	  2. Read low-word
	  3. Read hi-word again
	  4.1
	       if new hi-word is not equal to previously read hi-word, then
	       start from #1
	  4.2
	       if new hi-word is equal to previously read hi-word then stop.
	
	  timer (0) is disabled by the timer interrupt already
	  so, here we reload the next event value and re-enable
	  the timer.
	 
	  This way, we are potentially losing the time between
	  timer-interrupt->set_next_event. CPU local timers, when
	  they come in should get rid of skew.
 Load the "next" event tick value 
 Enable compare 
 Setup IRQ numbers 
 Setup IO addresses 
  bcm,kona-timer is deprecated by brcm,kona-timer
  being kept here for driver compatibility
 SPDX-License-Identifier: GPL-2.0-or-later
   archarmmach-vt8500timer.c
   Copyright (C) 2012 Tony Prisk <linux@prisktech.co.nz>
   Copyright (C) 2010 Alexey Charkov <alchark@gmail.com>
  This file is copied and modified from the original timer.c provided by
  Alexey Charkov. Minor changes have been made for Device Tree Support.
 interrupt enable 
 access status 
 not ready for read 
 not ready for write 
 not ready for write 
 SPDX-License-Identifier: GPL-2.0-only
  TI DaVinci clocksource driver
  Copyright (C) 2019 Texas Instruments
  Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
  (with tiny parts adopted from code by Kevin Hilman <khilman@baylibre.com>)
  This must be globally accessible by davinci_timer_read_sched_clock(), so
  let's keep it here.
	
	  This function is only ever called if we're using both timer
	  halves. In this case TIM34 runs in periodic mode and we must
	  not modify it.
 Same as above. 
  Standard use-case: we're using tim12 for clockevent and tim34 for
  clocksource. The default is making the former run in oneshot mode
  and the latter in periodic mode.
  Special use-case on da830: the DSP may use tim34. We're using tim12 for
  both clocksource and clockevent. We set tim12 to periodic and don't touch
  tim34.
 Set clock to internal mode and disable it. 
	
	  Reset both 32-bit timers, set no prescaler for timer 34, set the
	  timer to dual 32-bit unchained mode, unreset both 32-bit timers.
 Init both counters to zero. 
 SPDX-License-Identifier: GPL-2.0-only
   linuxdriversclocksourcezevio-timer.c
   Copyright (C) 2013 Daniel Tang <tangrs@tangrs.id.au>
 There are 6 match registers but we only use one. 
 Disable timer interrupts 
 Stop timer 
 Enable timer interrupts 
 Start with timer interrupts disabled 
 Interrupt to occur when timer value matches 0 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2017 Spreadtrum Communications Inc.
 SPDX-License-Identifier: GPL-2.0
  i8253 PIT clocksource
  Protects access to IO ports
  0040-0043 : timer0, i8253  i8254
  0061-0061 : NMI Control Register which contains two speaker control bits.
  Handle PIT quirk in pit_shutdown() where zeroing the counter register
  restarts the PIT, negating the shutdown. On platforms with the quirk,
  platform specific code can set this to false.
  Since the PIT overflows every tick, its not very useful
  to just read by itself. So use jiffies to emulate a free
  running counter:
	
	  Although our caller may have the read side of jiffies_lock,
	  this is now a seqlock, and we are cheating in this routine
	  by having side effects on state that we cannot undo if
	  there is a collision on the seqlock and our caller has to
	  retry.  (Namely, old_jifs and old_count.)  So we must treat
	  jiffies as volatile despite the lock.  We read jiffies
	  before latching the timer count to guarantee that although
	  the jiffies value might be older than the count (that is,
	  the counter may underflow between the last point where
	  jiffies was incremented and the point where we latch the
	  count), it cannot be newer.
 latch the count ASAP 
 read the latched count 
 VIA686a test code... reset the latch if count > max + 1 
	
	  It's possible for count to appear to go the wrong way for a
	  couple of reasons:
	 
	   1. The timer counter underflows, but we haven't handled the
	      resulting interrupt and incremented jiffies yet.
	   2. Hardware problem with the timer, not giving us continuous time,
	      the counter does small "jumps" upwards on some Pentium systems,
	      (see c't 9510 page 335 for Neptun bug.)
	 
	  Previous attempts to handle these cases intelligently were
	  buggy, so we just do the simple thing now.
 binary, mode 2, LSBMSB, ch 0 
 LSB 
 MSB 
  Program the next event in oneshot mode
  Delta is given in PIT ticks
 LSB 
 MSB 
  On UP the PIT can serve all of the possible timer functions. On SMP systems
  it can be solely used for the global tick.
  Initialize the conversion factor and the minmax deltas of the clock event
  structure and register the clock event source with the framework.
	
	  Start pit with the boot cpu mask. x86 might make it global
	  when it is used as broadcast device later.
 SPDX-License-Identifier: GPL-2.0-only
  archarmmach-pxatime.c
  PXA clocksource, clockevents, and OST interrupt handlers.
  Copyright (c) 2007 by Bill Gatliff <bgat@billgatliff.com>.
  Derived from Nicolas Pitre's PXA timer handler Copyright (c) 2001
  by MontaVista Software, Inc.  (Nico, your code rocks!)
 OS Timer 0 Match Register 
 OS Timer 1 Match Register 
 OS Timer 2 Match Register 
 OS Timer 3 Match Register 
 OS Timer Counter Register 
 OS Timer Status Register 
 OS Timer Watchdog Enable Register 
 OS Timer Interrupt Enable Register 
 Match status channel 3 
 Match status channel 2 
 Match status channel 1 
 Match status channel 0 
 Interrupt enable channel 0 
  This is PXA's sched_clock implementation. This has a resolution
  of at least 308 ns and a maximum value of 208 days.
  The return value is guaranteed to be monotonic in that range as
  long as there is always less than 582 seconds between successive
  calls to sched_clock() which should always be the case in practice.
 Disarm the comparematch, signal the event. 
 initializing, released, or preparing for suspend 
	
	  Ensure that we have at least MIN_OSCR_DELTA between match
	  register 0 and the OSCR, to guarantee that we will receive
	  the one-shot timer interrupt.  We adjust OSMR0 in preference
	  to OSCR to guarantee that OSCR is monotonically incrementing.
 timer registers are shared with watchdog timer 
 we are only interested in OS-timer0 irq 
  Legacy timer init for non device-tree boards.
 SPDX-License-Identifier: GPL-2.0+
  linuxarcharmplat-omapdmtimer.c
  OMAP Dual-Mode Timers
  Copyright (C) 2010 Texas Instruments Incorporated - https:www.ti.com
  Tarun Kanti DebBarma <tarun.kanti@ti.com>
  Thara Gopinath <thara@ti.com>
  dmtimer adaptation to platform_driver.
  Copyright (C) 2005 Nokia Corporation
  OMAP2 support by Juha Yrjola
  API improvements and OMAP2 clock framework support by Timo Teras
  Copyright (C) 2009 Texas Instruments
  Added OMAP4 support - Santosh Shilimkar <santosh.shilimkar@ti.com>
  omap_dm_timer_read_reg - read timer registers in posted and non-posted mode
  @timer:      timer pointer over which read operation to perform
  @reg:        lowest byte holds the register offset
  The posted mode bit is encoded in reg. Note that in posted mode write
  pending bit must be checked. Otherwise a read of a non completed write
  will produce an error.
  omap_dm_timer_write_reg - write timer registers in posted and non-posted mode
  @timer:      timer pointer over which write operation is to perform
  @reg:        lowest byte holds the register offset
  @value:      data to write into the register
  The posted mode bit is encoded in reg. Note that in posted mode the write
  pending bit must be checked. Otherwise a write on a register which has a
  pending write will be lost.
 No need to restore context 
 Configure timer for smart-idle mode 
	
	  FIXME: Used for OMAP1 devices only because they do not currently
	  use the clock framework to set the parent clock. To be removed
	  once OMAP1 migrated to using clock framework for dmtimers
 Check if the clock has configurable parents 
	
	  FIXME: OMAP1 devices do not use the clock framework for dmtimers so
	  do not call clk_get() for these devices.
 REQUEST_ANY 
				
				  If timer is not NULL, we have already found
				  one timer. But it was not an exact match
				  because it had more capabilities than what
				  was required. Therefore, unreserve the last
				  timer found and see if this one is a better
				  match.
 Exit loop early if we find an exact match 
 REQUEST_ANY 
 Requesting timer by ID is not supported when device tree is used 
  omap_dm_timer_request_by_cap - Request a timer by capability
  @cap:	Bit mask of capabilities to match
  Find a timer based upon capabilities bit mask. Callers of this function
  should use the definitions found in the platdmtimer.h file under the
  comment "timer capabilities used in hwmod database". Returns pointer to
  timer handle on success and a NULL pointer on failure.
  omap_dm_timer_request_by_node - Request a timer by device-tree node
  @np:		Pointer to device-tree timer node
  Request a timer based upon a device node pointer. Returns pointer to
  timer handle on success and a NULL pointer on failure.
  omap_dm_timer_modify_idlect_mask - Check if any running timers use ARMXOR
  @inputmask: current value of idlect mask
 If ARMXOR cannot be idled this function call is unnecessary 
 If any active timer is using ARMXOR return modified mask 
  omap_dm_timer_set_int_disable - disable timer interrupts
  @timer:	pointer to timer handle
  @mask:	bit mask of interrupts to be disabled
  Disables the specified timer interrupts for a timer.
 Save the context 
  omap_dm_timer_probe - probe function called for every registered device
  @pdev:	pointer to current timer platform device
  Called by driver framework at the end of device registration for all
  timer devices.
 add the timer element to the list 
  omap_dm_timer_remove - cleanup a registered timer device
  @pdev:	pointer to current timer platform device
  Called by driver framework whenever a timer device is unregistered.
  In addition to freeing platform resources it also deletes the timer
  entry from the local list.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2012-2013 Freescale Semiconductor, Inc.
  Each pit takes 0x10 Bytes register space
 set the max load value and start the clock source counter 
	
	  set a new value to PITLDVAL register will not restart the timer,
	  to abort the current cycle and start a timer period with the new
	  value, the timer must be disabled and enabled again.
	  and the PITLAVAL should be set to delta minus one according to pit
	  hardware requirement.
	
	  pit hardware doesn't support oneshot, it will generate an interrupt
	  and reload the counter value from PITLDVAL when PITCVAL reach zero,
	  and start the counter again. So software need to disable the timer
	  to stop the counter loop in ONESHOT mode.
	
	  The value for the LDVAL register trigger is calculated as:
	  LDVAL trigger = (period  clock period) - 1
	  The pit is a 32-bit down count timer, when the counter value
	  reaches 0, it will generate an interrupt, thus the minimal
	  LDVAL trigger value is 1. And then the min_delta is
	  minimal LDVAL trigger value + 1, and the max_delta is full 32-bit.
	
	  PIT0 and PIT1 can be chained to build a 64-bit timer,
	  so choose PIT2 as clocksource, PIT3 as clockevent device,
	  and leave PIT0 and PIT1 unused for anyone else who needs them.
 enable the pit module 
 SPDX-License-Identifier: GPL-2.0-only
   linuxdriversclocksourcedummy_timer.c
   Copyright (C) 2013 ARM Ltd.
   All Rights Reserved
 SPDX-License-Identifier: GPL-2.0+
 For type1, set SYSC_OMAP2_CLOCKACTIVITY for fck off on idle, l4 clock on 
  Subset of the timer registers we use. Note that the register offsets
  depend on the timer revision detected.
 Assumes v1 ip if bits [31:16] are zero 
 Note we must use io_base instead of func_base for type2 OCP regs 
 Sentinel  },
  Check if the SoC als has a usable working 32 KiHz counter. The 32 KiHz
  counter is handled by timer-ti-32k, but we need to detect it as it
  affects the preferred dmtimer system timer configuration. There is
  typically no use for a dmtimer clocksource if the 32 KiHz counter is
  present, except on am437x as described below.
 Sentinel  },
  Checks that system timers are configured to not reset and idle during
  the generic timer-ti-dm device driver probe. And that the system timer
  source clocks are properly configured. Also, let's not hog any DSP and
  PWM capable timers unnecessarily as system timers.
 Secure gptimer12 is always clocked with a fixed source 
  Finds the first available usable always-on timer, and assigns it to either
  clockevent or clocksource depending if the counter_32k is available on the
  SoC or not.
  Some omap3 boards with unreliable oscillator must not use the counter_32k
  or dmtimer1 with 32 KiHz source. Additionally, the boards with unreliable
  oscillator should really set counter_32k as disabled, and delete dmtimer1
  ti,always-on property, but let's not count on it. For these quirky cases,
  we prefer using the always-on secure dmtimer12 with the internal 32 KiHz
  clock as the clocksource, and any available dmtimer as clockevent.
  For am437x, we are using am335x style dmtimer clocksource. It is unclear
  if this quirk handling is really needed, but let's change it separately
  based on testing as it might cause side effects.
 Quirk unreliable 32 KiHz oscillator with incomplete dts 
 Quirk am437x using am335x style dmtimer clocksource 
 Quirky omap3 boards must use dmtimer12 
 Usually no need for dmtimer clocksource if we have counter32 
 Finds the first usable dmtimer, used for the don't care case 
 Selects the best clocksource and clockevent to use 
 Interface clocks are only available on some SoCs variants 
	
	  Enable optional assigned-clock-parents configured at the timer
	  node level. For regular device drivers, this is done automatically
	  by bus related code such as platform_drv_probe().
 For ti-sysc, we have timer clocks at the parent module level 
 Clockevent 
 Flush posted write 
  Wait for functional clock period x 3.5 
 Looks like we need to first set the load value separately 
	
	  We mostly use cpuidle_coupled with ARM local timers for runtime,
	  so there's probably no use for CLOCK_EVT_FEAT_DYNIRQ here.
	
	  For clock-event timers we never read the timer counter and
	  so we are not impacted by errata i103 and i767. Therefore,
	  we can safely ignore this errata for clock-event timers.
 Timer internal resync latency 
 Dmtimer as percpu timer. See dra7 ARM architected timer wrap erratum i940 
 See TRM for timer internal resynch latency 
 dra7 dmtimer3 
 dra7 dmtimer4 
 Clocksource 
 Unlike for clockevent, legacy code sets suspend only for am4 
  To detect between a clocksource and clockevent, we assume the device tree
  has no interrupts configured for a clocksource timer.
 One time init for the preferred timer configuration 
 SPDX-License-Identifier: GPL-2.0-only
  at91sam926x_time.c - Periodic Interval Timer (PIT) for at91sam926x
  Copyright (C) 2005-2006 M. Amine SAYA, ATMEL Rousset, France
  Revision	 2005 M. Nicolas Diremdjian, ATMEL Rousset, France
  Converted to ClockSourceClockEvents by David Brownell.
 Mode Register 
 Timer Interrupt Enable 
 Timer Enabled 
 Periodic Interval Value 
 Status Register 
 Timer Status 
 Periodic Interval Value Register 
 Periodic Interval Image Register 
 Interval Counter 
 Inverval Value 
  Clocksource:  just a monotonic counter of MCK16 cycles.
  We don't care whether or not PIT irqs are enabled.
 disable irq, leaving the clocksource active 
  Clockevent device:  interrupts every 1HZ (== pit_cycles  MCK16)
 update clocksource counter 
 Disable timer 
 Disable timer and irqs 
 Clear any pending interrupts, wait for PIT to stop counting 
 Start PIT but don't enable IRQ 
  IRQ handler for the timer.
 The PIT interrupt may be disabled, and is shared 
 Get number of ticks performed before irq, and ack it 
  Set up both clocksource and clockevent support.
 Get the interrupts property 
	
	  Use our actual MCK to figure out how many MCK16 ticks per
	  1HZ period (instead of a compile-time constant LATCH).
 Initialize and enable the timer 
	
	  Register clocksource.  The high order bits of PIV are unused,
	  so this isn't a 32-bit counter unless we get clockevent irqs.
 PICNT  + ilog2(data->cycle) 
 Set up irq handler 
 Set up and register clockevents 
 SPDX-License-Identifier: GPL-2.0
   H8S TPU Driver
   Copyright 2015 Yoshinori Sato <ysato@users.sourcefoge.jp>
 Make sure the timer value is stable. Stolen from acpi_pm.c 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2014-2018 Nuvoton Technologies tomer.maimon@nuvoton.com
  All rights reserved.
  Copyright 2017 Google, Inc.
 Timers registers 
 Timer 0 Control and Status Register 
 Timer 0 Initial Count Register 
 Timer 1 Control and Status Register 
 Timer 1 Initial Count Register 
 Timer 1 Data Register 
 Timer Interrupt Status Register 
 Timers control 
 Timers operating mode 
 Clock input is divided by PRESCALE + 1 before it is fed 
 to the counter 
 SPDX-License-Identifier: GPL-2.0-only
  timer-ti-32k.c - OMAP2 32k Timer Support
  Copyright (C) 2009 Nokia Corporation
  Update to use new clocksourceclockevent layers
  Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
  Copyright (C) 2007 MontaVista Software, Inc.
  Original driver:
  Copyright (C) 2005 Nokia Corporation
  Author: Paul Mundt <paul.mundt@nokia.com>
          Juha Yrjölä <juha.yrjola@nokia.com>
  OMAP Dual-mode timer framework support by Timo Teras
  Some parts based off of TI's 24xx code:
  Copyright (C) 2004-2009 Texas Instruments, Inc.
  Roughly modelled after the OMAP1 MPU timer code.
  Added OMAP4 support - Santosh Shilimkar <santosh.shilimkar@ti.com>
  Copyright (C) 2015 Texas Instruments Incorporated - https:www.ti.com
  32KHz clocksource ... always available, on pretty most chips except
  OMAP 730 and 1510.  Other timers could be used as clocksources, with
  higher resolution in free-running counter modes (e.g. 12 MHz xtal),
  but systems won't necessarily want to spend resources that way.
 Only some SoCs have a separate interface clock 
	
	  Force idle module as wkup domain is active with MPU.
	  No need to tag the module disabled for ti-sysc probe.
	
	  32k sync Counter IP register offsets vary between the highlander
	  version and the legacy ones.
	 
	  The 'SCHEME' bits(30-31) of the revision register is used to identify
	  the version.
 SPDX-License-Identifier: GPL-2.0
  64-bit Periodic Interval Timer driver
  Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries
  Author: Claudiu Beznea <claudiu.beznea@microchip.com>
 Control Register 
 Mode Register 
 LSB Period Register 
 MSB Period Register 
 Interrupt Enable Register 
 Interrupt Status Register 
 Timer LSB Register 
 Timer MSB Register 
 5 MHz 
 32 KHz 
  struct mchp_pit64b_timer - PIT64B timer data structure
  @base: base address of PIT64B hardware block
  @pclk: PIT64B's peripheral clock
  @gclk: PIT64B's generic clock
  @mode: precomputed value for mode register
  mchp_pit64b_clkevt - PIT64B clockevent data structure
  @timer: PIT64B timer
  @clkevt: clockevent
  mchp_pit64b_clksrc - PIT64B clocksource data structure
  @timer: PIT64B timer
  @clksrc: clocksource
 Base address for clocksource timer. 
 Default cycles for clockevent timer. 
	
	  When using a 64 bit period TLSB must be read first, followed by the
	  read of TMSB. This sequence generates an atomic read of the 64 bit
	  timer value whatever the lapse of time between the accesses.
 Need to clear the interrupt. 
 Use the biggest prescaler if we didn't match one. 
  mchp_pit64b_init_mode - prepare PIT64B mode register value to be used at
 			   runtime; this includes prescaler and SGCLK bit
  PIT64B timer may be fed by gclk or pclk. When gclk is used its rate has to
  be at least 3 times lower that pclk's rate. pclk rate is fixed, gclk rate
  could be changed via clock APIs. The chosen clock (pclk or gclk) could be
  divided by the internal PIT64B's divider.
  This function, first tries to use GCLK by requesting the desired rate from
  PMC and then using the internal PIT64B prescaler, if any, to reach the
  requested rate. If PCLKGCLK < 3 (condition requested by PIT64B hardware)
  then the function falls back on using PCLK as clock source for PIT64B timer
  choosing the highest prescaler in case it doesn't locate one to match the
  requested frequency.
  Below is presented the PIT64B block in relation with PMC:
                                 PIT64B
   PMC             +------------------------------------+
  +----+           |   +-----+                          |
  |    |-->gclk -->|-->|     |    +---------+  +-----+  |
  |    |           |   | MUX |--->| Divider |->|timer|  |
  |    |-->pclk -->|-->|     |    +---------+  +-----+  |
  +----+           |   +-----+                          |
                   |      ^                             |
                   |     sel                            |
                   +------------------------------------+
  Where:
 	- gclk rate <= pclk rate3
 	- gclk rate could be requested from PMC
 	- pclk rate is fixed (cannot be requested from PMC)
 Try using GCLK. 
 Check if requested rate could be obtained using PCLK. 
 Use PCLK. 
 Use GCLK. 
 Stop timer. 
 Parse DT node. 
 Initialize mode (prescaler + SGCK bit). To be used at runtime. 
 1st request, register clockevent. 
 2nd request, register clocksource. 
 The rest, don't care. 
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  Copyright (C) 2012 MIPS Technologies, Inc.  All rights reserved.
 Set clocksource mask. 
 Calculate a somewhat reasonable rating value. 
 And finally start the counter 
	
	  It's safe to use the MIPS GIC timer as a sched clock source only if
	  its ticks are stable, which is true on either the platforms with
	  stable CPU frequency or on the platforms with CM3 and CPU frequency
	  change performed by the CPC core clocks divider.
 SPDX-License-Identifier: GPL-2.0+
  RDA8810PL SoC timer driver
  Copyright RDA Microelectronics Company Limited
  Copyright (c) 2017 Andreas Färber
  Copyright (c) 2018 Manivannan Sadhasivam
  RDA8810PL has two independent timers: OSTIMER (56 bit) and HWTIMER (64 bit).
  Each timer provides optional interrupt support. In this driver, OSTIMER is
  used for clockevents and HWTIMER is used for clocksource.
 Enable ostimer interrupt first 
 Write low 32 bits first, high 24 bits are with ctrl 
 Disable ostimer interrupt first 
 clear timer int 
 Always read low 32 bits first 
 SPDX-License-Identifier: GPL-2.0-or-later
  IntegratorAP timer driver
  Copyright (C) 2000-2003 Deep Blue Solutions Ltd
  Copyright (c) 2014, Linaro Limited
  IRQ handler for the timer
 clear the interrupt 
 Disable timer 
 Leave the timer disabled, .set_next_event will enable it 
 Disable timer 
 Enable the timer and start the periodic tick 
 Calculate and program a divisor 
	
	  The pointer is used as an identifier not as a pointer, we
	  can drop the refcount on the of__node immediately after
	  getting it.
 The primary timer lacks IRQ, use as clocksource 
 The secondary timer will drive the clock event 
  Marvell Armada 370XP SoC timer handling.
  Copyright (C) 2012 Marvell
  Lior Amsalem <alior@marvell.com>
  Gregory CLEMENT <gregory.clement@free-electrons.com>
  Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  This file is licensed under the terms of the GNU General Public
  License version 2.  This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  Timer 0 is used as free-running clocksource, while timer 1 is
  used as clock_event_device.
  ---
  Clocksource driver for Armada 370 and Armada XP SoC.
  This driver implements one compatible string for each SoC, given
  each has its own characteristics:
     Armada 370 has no 25 MHz fixed timer.
     Armada XP cannot work properly without such 25 MHz fixed timer as
      doing otherwise leads to using a clocksource whose frequency varies
      when doing cpufreq frequency changes.
  See Documentationdevicetreebindingstimermarvell,armada-370-xp-timer.txt
  Timer block registers.
 Global timers are connected to the coherency fabric clock, and the
  SoC-specific data.
  Number of timer ticks per jiffy.
  Clockevent handling.
	
	  Clear clockevent timer interrupt.
	
	  Setup new clockevent timer value.
	
	  Enable the timer.
	
	  Disable timer.
	
	  ACK pending timer interrupt.
	
	  Setup timer to fire at 1HZ intervals.
	
	  Enable timer.
	
	  ACK timer interrupt and call event handler.
  Setup the local clock events for a CPU.
	
	  We use timer 0 as clocksource, and private(local) timer 0
	  for clockevents
	
	  Setup free-running clocksource timer (interrupts
	  disabled).
	
	  Set scale and timer for sched_clock.
	
	  Setup clockevent timer (interrupt-driven).
 Immediately configure the timer on the boot CPU 
		
		  This fallback is required in order to retain proper
		  devicetree backwards compatibility.
 Must have at least a clock 
 SPDX-License-Identifier: GPL-2.0-or-later
  Mediatek SoCs General-Purpose Timer handling.
  Copyright (C) 2014 Matthias Brugger
  Matthias Brugger <matthias.bgg@gmail.com>
 gpt 
 system timer 
  SYST_CON_EN: Clock enable. Shall be set to
    - Start timer countdown.
    - Allow timeout ticks being updated.
    - Allow changing interrupt status,like clear irq pending.
  SYST_CON_IRQ_EN: Set to enable interrupt.
  SYST_CON_IRQ_CLR: Set to clear interrupt.
 Clear and disable interrupt 
 Enable clock to allow timeout tick update later 
	
	  Write new timeout ticks. Timer shall start countdown
	  after timeout ticks are updated.
 Enable interrupt 
 Clear any irq 
 Disable timer 
 Acknowledge interrupt 
 Clear 2 bit timer operation mode field 
 Acknowledge timer0 irq 
 Disable all interrupts 
 Acknowledge all spurious pending interrupts 
 Disable all interrupts 
	
	  This is called with interrupts disabled,
	  so we need to ack any interrupt that is pending
	  or for example ATF will prevent a suspend from completing.
 Configure clock source 
 Configure clock event 
 SPDX-License-Identifier: GPL-2.0
  Ingenic SoCs TCU IRQ driver
  Copyright (C) 2019 Paul Cercueil <paul@crapouillou.net>
  Copyright (C) 2020 周琰杰 (Zhou Yanjie) <zhouyanjie@wanyeetech.com>
 Reset channel 
 Reset counter 
 Enable channel 
 sentinel  }
	
	  Enable all TCU channels for PWM use by default except channels 01,
	  and channel 2 if target CPU is JZ4780X2000 and SMP is selected.
 Verify that we have at least num_possible_cpus() + 1 free channels 
 Setup clock events on each CPU core 
 Register the sched_clock at the end as there's no way to undo it 
 _noirq: We want the TCU clocks to be gated last  ungated first 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2007 Google, Inc.
  Copyright (c) 2009-2012,2014, The Linux Foundation. All rights reserved.
 Stop the timer tick 
 Install and invoke hotplug callbacks 
 We use GPT0 for the clockevent 
 We use CPU0's DGT for the clocksource 
 SPDX-License-Identifier: GPL-2.0-only
  This file contains driver for the Cadence Triple Timer Counter Rev 06
   Copyright (C) 2011-2013 Xilinx
  based on archmipskerneltime.c timer driver
  This driver configures the 2 1632-bit count-up timers as follows:
  T1: Timer 1, clocksource for generic timekeeping
  T2: Timer 2, clockevent source for hrtimers
  T3: Timer 3, <unused>
  The input frequency to the timer module for emulation is 2.5MHz which is
  common to all the timer channels (T1, T2, and T3). With a pre-scaler of 32,
  the timers are clocked at 78.125KHz (12.8 us resolution).
  The input frequency to the timer module in silicon is configurable and
  obtained from device tree. The pre-scaler of 32 is used.
  Timer Register Offset Definitions of Timer 1, Increment base address by 4
  and use same offsets for Timer 2
 Clock Control Reg, RW 
 Counter Control Reg, RW 
 Counter Value Reg, RO 
 Interval Count Reg, RW 
 Interrupt Status Reg, RO 
 Interrupt Enable Reg, RW 
 clock source 
  Setup the timers to use pre-scaling, using a fixed value for now that will
  work across most input frequency, but it may need to be more dynamic
 2 ^ PRESCALE_EXPONENT = PRESCALE 
 The exponent must match this 
  struct ttc_timer - This definition defines local timer structure
  @base_addr:	Base address of timer
  @freq:	Timer input clock frequency
  @clk:	Associated clock source
  @clk_rate_change_nb	Notifier block for clock rate changes
  ttc_set_interval - Set the timer interval value
  @timer:	Pointer to the timer instance
  @cycles:	Timer interval ticks
 Disable the counter, set the counter value  and re-enable counter 
	
	  Reset the counter (0x10) so that it starts from 0, one-shot
	  mode makes this needed for timing to be right.
  ttc_clock_event_interrupt - Clock event timer interrupt handler
  @irq:	IRQ number of the Timer
  @dev_id:	void pointer to the ttc_timer instance
  returns: Always IRQ_HANDLED - success
 Acknowledge the interrupt and call event handler 
  __ttc_clocksource_read - Reads the timer counter register
  returns: Current timer counter register value
  ttc_set_next_event - Sets the time interval for next event
  @cycles:	Timer interval ticks
  @evt:	Address of clock event instance
  returns: Always 0 - success
  ttc_set_{shutdown|oneshot|periodic} - Sets the state of timer
  @evt:	Address of clock event instance
		
		  store timer clock ctrl register so we can restore it in case
		  of an abort.
 prescaler within legal range? 
 scale down: adjust divider in post-change notification 
 scale up: adjust divider now - before frequency change 
 scale up: pre-change notification did the adjustment 
 scale down: adjust divider now - after frequency change 
 we have to undo the adjustment in case we scale up 
 restore original register value 
	
	  Setup the clock source counter to be an incrementing counter
	  with no interrupt and it rolls over at 0xFFFF. Pre-scale
	  it by 32 also. Let it start running now.
 update cached frequency 
	
	  Setup the clock event timer to be an interval timer which
	  is prescaled by 32 using the interval interrupt. Leave it
	  disabled for now.
	
	  Get the 1st Triple Timer Counter (TTC) block from the device tree
	  and use it. Note that the event timer uses the interrupt and it's the
	  2nd TTC hence the irq_of_parse_and_map(,1)
 SPDX-License-Identifier: GPL-2.0-only
  Generic MMIO clocksource support
  clocksource_mmio_init - Initialize a simple mmio based clocksource
  @base:	Virtual address of the clock readout register
  @name:	Name of the clocksource
  @hz:		Frequency of the clocksource in Hz
  @rating:	Rating of the clocksource
  @bits:	Number of valid bits
  @read:	One of clocksource_mmio_read() above
  Conexant Digicolor timer driver
  Author: Baruch Siach <baruch@tkos.co.il>
  Copyright (C) 2014 Paradox Innovation Ltd.
  Based on:
 	Allwinner SoCs hstimer driver
  Copyright (C) 2013 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
  This file is licensed under the terms of the GNU General Public
  License version 2.  This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  Conexant Digicolor SoCs have 8 configurable timers, named from "Timer A" to
  "Timer H". Timer A is the only one with watchdog support, so it is dedicated
  to the watchdog driver. This driver uses Timer B for sched_clock(), and
  Timer C for clockevents.
 one of TIMER_ 
	
	  timer registers are shared with the watchdog timer;
	  don't map exclusively
 SPDX-License-Identifier: GPL-2.0-only
  linuxdriversclocksourceacpi_pm.c
  This file contains the ACPI PM based clocksource.
  This code was largely moved from the i386 timer_pm.c file
  which was (C) Dominik Brodowski <linux@brodo.de> 2003
  and contained the following comments:
  Driver to use the Power Management Timer (PMTMR) available in some
  southbridges as primary timing source for the Linux kernel.
  Based on parts of linuxdriversacpihardwarehwtimer.c, timer_pit.c,
  timer_hpet.c, and on Arjan van de Ven's implementation for 2.4.
  The IO port the PMTMR resides at.
  The location is detected during setup_arch(),
  in archi386kernelacpiboot.c
 mask the output to 24 bits 
	
	  It has been reported that because of various broken
	  chipsets (ICH4, PIIX4 and PIIX4E) where the ACPI PM clock
	  source is not latched, you must read it multiple
	  times to ensure a safe value is read:
  PIIX4 Errata:
  The power management timer may return improper results when read.
  Although the timer value settles properly after incrementing,
  while incrementing there is a 3 ns window every 69.8 ns where the
  timer value is indeterminate (a 4.2% chance that the data will be
  incorrect when read). As a result, the ACPI free running count up
  timer specification is violated due to erroneous reads.
 the bug has been fixed in PIIX4M 
  Some boards have the PMTMR running way too fast. We check
  the PMTMR rate against PIT channel 2 to catch these cases.
 Check that the PMTMR delta is within 5% of what we expect 
 Number of monotonicity checks to perform during initialization 
 Number of reads we try to get two different values 
 "verify" this timing source: 
 We use fs_initcall because we want the PCI fixups to have run
  but we still need to load before device_initcall
  Allow an override of the IOPort. Stupid BIOSes do not tell us about
  the PMTimer, but we might know where it is.
 SPDX-License-Identifier: GPL-2.0
  Clocksource driver for the synthetic counter and timers
  provided by the Hyper-V hypervisor to guest VMs, as described
  in the Hyper-V Top Level Functional Spec (TLFS). This driver
  is instruction set architecture independent.
  Copyright (C) 2019, Microsoft, Inc.
  Author:  Michael Kelley <mikelley@microsoft.com>
  If false, we're using the old mechanism for stimer0 interrupts
  where it sends a VMbus message when it expires. The old
  mechanism is used when running on older versions of Hyper-V
  that don't support Direct Mode. While Hyper-V provides
  four stimer's per CPU, Linux uses only stimer0.
  Because Direct Mode does not require processing a VMbus
  message, stimer interrupts can be enabled earlier in the
  process of booting a CPU, and consistent with when timer
  interrupts are enabled for other clocksource drivers.
  However, for legacy versions of Hyper-V when Direct Mode
  is not enabled, setting up stimer interrupts must be
  delayed until VMbus is initialized and can process the
  interrupt message.
  Common code for stimer0 interrupts coming via Direct Mode or
  as a VMbus message.
  stimer0 interrupt handler for architectures that support
  per-cpu interrupts, which also implies Direct Mode.
		
		  When it expires, the timer will directly interrupt
		  on the specified hardware vectorIRQ.
		
		  When it expires, the timer will generate a VMbus message,
		  to be handled by the normal VMbus interrupt handler.
  hv_stimer_init - Per-cpu initialization of the clockevent
  hv_stimer_cleanup - Per-cpu cleanup of the clockevent
	
	  In the legacy case where Direct Mode is not enabled
	  (which can only be on x8664), stimer cleanup happens
	  relatively early in the CPU offlining process. We
	  must unbind the stimer-based clockevent device so
	  that the LAPIC timer can take over until clockevents
	  are no longer needed in the offlining process. Note
	  that clockevents_unbind_device() eventually calls
	  hv_ce_shutdown().
	 
	  The unbind should not be done when Direct Mode is
	  enabled because we may be on an architecture where
	  there are no other clockevent devices to fallback to.
  These placeholders are overridden by arch specific code on
  architectures that need special setup of the stimer0 IRQ because
  they don't support per-cpu IRQs (such as x86x64).
 Called only on architectures with per-cpu IRQs (i.e., not x86x64) 
 hv_stimer_alloc - Global initialization of the clockevent and stimer0 
	
	  Synthetic timers are always available except on old versions of
	  Hyper-V on x86.  In that case, return as error as Linux will use a
	  clockevent based on emulated LAPIC timer hardware.
	
	  If Direct Mode isn't enabled, the remainder of the initialization
	  is done later by hv_stimer_legacy_init()
	
	  Since we are in Direct Mode, stimer initialization
	  can be done now with a CPUHP value in the same range
	  as other clockevent devices.
  hv_stimer_legacy_init -- Called from the VMbus driver to handle
  the case when Direct Mode is not enabled, and the stimer
  must be initialized late in the CPU onlining process.
	
	  This function gets called by each vCPU, so setting the
	  global stimer_message_sint value each time is conceptually
	  not ideal, but the value passed in is always the same and
	  it avoids introducing yet another interface into this
	  clocksource driver just to set the sint in the legacy case.
  hv_stimer_legacy_cleanup -- Called from the VMbus driver to
  handle the case when Direct Mode is not enabled, and the
  stimer must be cleaned up early in the CPU offlining
  process.
  Do a global cleanup of clockevents for the cases of kexec and
  vmbus exit
	
	  hv_stime_legacy_cleanup() will stop the stimer if Direct
	  Mode is not enabled, and fallback to the LAPIC timer.
  Code and definitions for the Hyper-V clocksources.  Two
  clocksources are defined: one that reads the Hyper-V defined MSR, and
  the other that uses the TSC reference page feature as defined in the
  TLFS.  The MSR version is for compatibility with old versions of
  Hyper-V and 32-bit x86.  The TSC reference page version is preferred.
 Disable the TSC page 
 Re-enable the TSC page 
	
	  Read the partition counter to get the current tick count. This count
	  is set to 0 when the partition is created and is incremented in
	  100 nanosecond units.
  Reference to pv_ops must be inline so objtool
  detection of noinstr violations can work correctly.
	
	  We're on an architecture with generic sched clock (not x86x64).
	  The Hyper-V sched clock read function returns nanoseconds, not
	  the normal 100ns units of the Hyper-V synthetic clock.
 We're on x86x64 and using PV ops 
 !CONFIG_GENERIC_SCHED_CLOCK && !CONFIG_PARAVIRT 
 CONFIG_GENERIC_SCHED_CLOCK 
	
	  If Hyper-V offers TSC_INVARIANT, then the virtualized TSC correctly
	  handles frequency and offset changes due to live migration,
	  pauseresume, and other VM management operations.  So lower the
	  Hyper-V Reference TSC rating, causing the generic TSC to be used.
	  TSC_INVARIANT is not offered on ARM64, so the Hyper-V Reference
	  TSC will be preferred over the virtualized ARM64 arch counter.
	  While the Hyper-V MSR clocksource won't be used since the
	  Reference TSC clocksource is present, change its rating as
	  well for consistency.
	
	  The Hyper-V TLFS specifies to preserve the value of reserved
	  bits in registers. So read the existing value, preserve the
	  low order 12 bits, and add in the guest physical address
	  (which already has at least the low 12 bits set to zero since
	  it is page aligned). Also set the "enable" bit, which is bit 0.
	
	  Try to set up the TSC page clocksource. If it succeeds, we're
	  done. Otherwise, set up the MSR clocksource.  At least one of
	  these will always be available except on very old versions of
	  Hyper-V on x86.  In that case we won't have a Hyper-V
	  clocksource, but Linux will still run with a clocksource based
	  on the emulated PIT or LAPIC timer.
 SPDX-License-Identifier: GPL-2.0-or-later
   Cirrus Logic CLPS711X clocksource driver
   Copyright (C) 2014 Alexander Shiyan <shc_work@mail.ru>
 Set Timer prescaler 
 SPDX-License-Identifier: GPL-2.0
  Ingenic XBurst SoCs SYSOST clocks driver
  Copyright (c) 2020 周琰杰 (Zhou Yanjie) <zhouyanjie@wanyeetech.com>
 OST register offsets 
 bits within the OSTCCR register 
 bits within the OSTCR register 
 bits within the OSTFR register 
 bits within the OSTMR register 
 bits within the OSTESR register 
 bits within the OSTECR register 
 16 divider 
 Reset clock divider 
 Clear counter CNT registers 
 Enable OST channel 
 sentinel  }
 Register the sched_clock at the end as there's no way to undo it 
 SPDX-License-Identifier: GPL-2.0-only
  Clock event driver for the CS5535CS5536
  Copyright (C) 2006, Advanced Micro Devices, Inc.
  Copyright (C) 2007  Andres Salomon <dilinger@debian.org>
  Copyright (C) 2009  Andres Salomon <dilinger@collabora.co.uk>
  The MFGPTs are documented in AMD Geode CS5536 Companion Device Data Book.
  We are using the 32.768kHz input clock - it's the only one that has the
  ranges we find desirable.  The following table lists the suitable
  divisors and the associated Hz, minimum interval and the maximum interval:
   Divisor   Hz      Min Delta (s)  Max Delta (s)
    1        32768   .00048828125      2.000
    2        16384   .0009765625       4.000
    4         8192   .001953125        8.000
    8         4096   .00390625        16.000
    16        2048   .0078125         32.000
    32        1024   .015625          64.000
    64         512   .03125          128.000
   128         256   .0625           256.000
   256         128   .125            512.000
 Selected from the table above 
 divisor = 2^(scale) 
  The MFGPT timers on the CS5536 provide us with suitable timers to use
  as clock event sources - not as good as a HPET or APIC, but certainly
  better than the PIT.  This isn't a general purpose MFGPT driver, but
  a simplified one designed specifically to act as a clock event source.
  For full details about the MFGPT, please consult the CS5536 data sheet.
 avoid races by clearing CMP1 and CMP2 unconditionally 
 See if the interrupt was for us 
 Turn off the clock (and clear the event) 
 Clear the counter 
 Restart the clock in periodic mode 
 Set up the IRQ on the MFGPT side 
 And register it with the kernel 
 Set the clock scale and enable the event mode for CMP2 
 Set up the clock event 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2014 Oleksij Rempel <linux@rempel-privat.de>
  this device provide 4 offsets for each register:
  0x0 - plain read write mode
  0x4 - set mode, OR logic.
  0x8 - clr mode, XOR logic.
  0xc - togle mode.
 RW. Interrupt 
 RW. Timer controller 
 BM_C_RST
  Timer Counter and the Prescale Counter are synchronously reset on the
  next positive edge of PCLK. The counters remain reset until TCR[1] is
 BM_C_EN
  1 - Timer Counter and Prescale Counter are enabled for counting
 RW. Direction? 
 00 - count up
  01 - count down
 RO. Timer counter 0 
 HW_TC. Timer counter owerflow (0xffff.ffff to 0x0000.0000) do not generate
 RW. prescaler 
 RO. Prescaler counter 
 RW. Match control 
 enable interrupt on match 
 enable TC reset on match 
 enable stop TC on match 
 RW. Match reg 
 Counter control 
 Timer mode. Every rising PCLK edge. 
 configure match count for TC0 
 enable TC0 
 stop timer0 
 enable reset and stop on match 
 disable reset and stop on match 
 configure match count for TC0 
 enable TC0 
  ---------------------------------------------------------------------------
  Timer initialization
  ---------------------------------------------------------------------------
 set all timers for count-up 
 disable divider 
 make sure all timers use every rising PCLK edge. 
 enable interrupt for TC0 and clean setting for all other lines 
	 Seems like we can't use counter without match register even if
 enable TC1 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2000-2001 Deep Blue Solutions
  Copyright (C) 2002 Shane Nay (shane@minirl.com)
  Copyright (C) 2006-2007 Pavel Pisa (ppisa@pikron.com)
  Copyright (C) 2008 Juergen Beisert (kernel@pengutronix.de)
  Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
  There are 2 versions of the timrot on Freescale MXS-based SoCs.
  The v1 on MX23 only gets 16 bits counter, while v2 on MX28
  extends the counter to 32 bits.
  The implementation uses two timers, one for clock_event and
  another for clocksource. MX28 uses timrot 0 and 1, while MX23
  uses 0 and 2.
  There are 4 registers for each timrotv2 instance, and 2 registers
  for each timrotv1. So address step 0x40 in macros below strides
  one instance of timrotv2 while two instances of timrotv1.
  As the result, HW_TIMROT_XXXn(1) defines the address of timrot1
  on MX28 while timrot2 on MX23.
 common between v1 and v2 
 v1 only 
 v2 only 
 timrot decrements the count 
 timrot decrements the count 
 Disable interrupt in timer module 
 Set event time into the furthest future 
 Clear pending interrupt 
	
	  Initialize timers to a known state
 get timrot version 
 one for clock_event 
 another for clocksource 
 set clocksource timer fixed count to the maximum 
 init and register the timer to the framework 
 Make irqs happen 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2012 Regents of the University of California
  Copyright (C) 2017 SiFive
  All RISC-V systems have a timer attached to every hart.  These timers can
  either be read from the "time" and "timeh" CSRs, and can use the SBI to
  setup events, or directly accessed using MMIO registers.
  It is guaranteed that all the timers across all the harts are synchronized
  within one tick of each other, so while this could technically go
  backwards when hopping between CPUs, practically it won't happen.
 called directly from the low-level interrupt handler 
  Pistachio clocksource based on general-purpose timers
  Copyright (C) 2015 Imagination Technologies
  This file is subject to the terms and conditions of the GNU General Public
  License. See the file "COPYING" in the main directory of this archive
  for more details.
 Top level reg 
 Timer specific registers 
 Timer specific configuration Values 
	
	  The counter value is only refreshed after the overflow value is read.
	  And they must be read in strict order, hence raw spin lock added.
 Disable GPT local before loading reload value 
 Disable GPT local 
 Desirable clock source for pistachio platform 
 Switch to using the fast counter clock 
 Disable irq's for clocksource usage 
 Enable timer block 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2016-17 Synopsys, Inc. (www.synopsys.com)
  Copyright (C) 2004, 2007-2010, 2011-2012 Synopsys, Inc. (www.synopsys.com)
 ARC700 has two 32bit independent prog Timers: TIMER0 and TIMER1, Each can be
  programmed to go from @count to @limit and optionally interrupt.
  We've designated TIMER0 for clockevents and TIMER1 for clocksource
  ARCv2 based HS38 cores have RTC (in-core) and GFRC (inside ARConnectMCIP)
  which are suitable for UP and SMP based clocksources respectively
 Clock Source Device 
	
	  From a programming model pov, there seems to be just one instance of
	  MCIP_CMDMCIP_READBACK however micro-architecturally there's
	  an instance PER ARC CORE (not per cluster), and there are dedicated
	  hardware decode logic (per core) inside ARConnect to handle
	  simultaneous readwrite accesses from cores via those two registers.
	  So several concurrent commands to ARConnect are OK if they are
	  trying to access two different sub-components (like GFRC,
	  inter-core interrupt, etc...). HW also supports simultaneously
	  accessing GFRC by multiple cores.
	  That's why it is safe to disable hard interrupts on the local CPU
	  before access to GFRC instead of taking global MCIP spinlock
	  defined in archarckernelmcip.c
	
	  hardware has an internal state machine which tracks readout of
	  lowhigh and updates the CTRL.status if
	   - interruptexception taken between the two reads
	   - high increments after low has been read
 Local to CPU hence not usable in SMP 
  32bit TIMER1 to keep counting monotonically and wraparound
 Local to CPU hence not usable in SMP 
 Clock Event Device 
  Arm the timer to interrupt after @cycles
  The distinction for oneshotperiodic is done in arc_event_timer_ack() below
 start from 0 
	
	  At X Hz, 1 sec = 1000ms -> X cycles;
	 		      10ms -> X  100 cycles
	
	  Note that generic IRQ core could have passed @evt for @dev_id if
	  irq_set_chip_and_handler() asked for handle_percpu_devid_irq()
	
	  1. ACK the interrupt
	     - For ARC700, any write to CTRL reg ACKs it, so just rewrite
	       Count when [N]ot [H]alted bit.
	     - For HS3x, it is a bit subtle. On taken count-down interrupt,
	       IP bit [3] is set, which needs to be cleared for ACK'ing.
	       The write below can only update the other two bits, hence
	       explicitly clears IP bit
	  2. Re-arm interrupt if periodic by writing to IE bit [0]
  clockevent setup for boot CPU
 Needs apriori irq_set_percpu_devid() done in intc map function 
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2012 Simon Arlott
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2016 Freescale Semiconductor, Inc.
 Copyright 2017 NXP
 channel disable 
 channel enabled in sw compare mode 
	
	  NOTE: We observed in a very small probability, the bus fabric
	  contention between GPU and A7 may results a few cycles delay
	  of writing CNT registers which may cause the min_delta event got
	  missed, so we need add a ETIME check here in case it happened.
 enable clk before accessing registers 
 use rating 200 for 32-bit counter and 150 for 16-bit counter 
	
	  Initialize tpm module to a known state
	  1) Counter disabled
	  2) TPM counter operates in up counting mode
	  3) Timer Overflow Interrupt disabled
	  4) Channel0 disabled
	  5) DMA transfers disabled
 make sure counter is disabled 
 TOF is W1C 
 CHF is W1C 
	
	  increase per cnt,
	  div 8 for 32-bit counter and div 128 for 16-bit counter
 set MOD register to maximum for free running mode 
 SPDX-License-Identifier: GPL-2.0
  We're configured to use a specific TC block, one that's not hooked
  up to external hardware, to provide a time solution:
    - Two channels combine to create a free-running 32 bit counter
      with a base rate of 5+ MHz, packaged as a clocksource (with
      resolution better than 200 nsec).
    - Some chips support 32 bit counter. A single channel is used for
      this 32 bit free-running counter. the second channel is not used.
    - The third channel may be used to provide a clockevent source, used in
    either periodic or oneshot mode. For 16-bit counter its runs at 32 KiHZ,
    and can handle delays of up to two seconds. For 32-bit counters, it runs at
    the same rate as the clocksource
  REVISIT behavior during system suspend states... we should disable
  all clocks and save the power.  Easily done for clockevent devices,
  but clocksources won't necessarily get the needed notifications.
  For deeper system sleep states, this will be mandatory...
 Restore registers for the channel, RA and RB are not used  
 Disable all the interrupts 
 Reenable interrupts that were enabled before suspending 
 Start the clock if it was used 
 Dual channel, chain channels 
 Finally, trigger all the channels
 count up to RC, then irq and stop 
 set_next_event() configures and starts the timer 
	 By not making the gentime core emulate periodic mode on top
	  of oneshot, we get lower overhead and improved accuracy.
 count up to RC, then irq and restart 
 Enable clock and interrupts on RC compare 
 go go gadget! 
 go go gadget! 
 Should be lower than at91rm9200's system timer 
 try to enable t2 clk to avoid future errors in mode change 
 !CONFIG_GENERIC_CLOCKEVENTS 
 NOTHING 
 channel 0:  waveform mode, input mclk8, clock TIOA0 on overflow 
 likely divide-by-8 
 free-run 
 TIOA0 rises at 0 
 (duty cycle 50%) 
 no irqs 
 channel 1:  waveform mode, input TIOA0 
 input: TIOA0 
 free-run 
 no irqs 
 chain channel 0 to channel 1
 then reset all the timers 
 channel 0:  waveform mode, input mclk8 
 likely divide-by-8 
 free-run 
 no irqs 
 then reset all the timers 
 sentinel  }
 Protect against multiple calls 
 How fast will we be counting?  Pick something over 5 MHz.  
 use appropriate function to read 32 bit counter 
 setup only channel 0 
		 we have three clocks no matter what the
		  underlying platform supports.
 setup both channel 0 & 1 
 and away we go! 
 channel 2:  periodic and oneshot timer support 
 SPDX-License-Identifier: GPL-2.0
  SuperH Timer Support - CMT
   Copyright (C) 2008 Magnus Damm
  The CMT comes in 5 different identified flavours, depending not only on the
  SoC but also on the particular instance. The following table lists the main
  characteristics of those flavours.
 			16B	32B	32B-F	48B	R-Car Gen2
  -----------------------------------------------------------------------------
  Channels		2	14	1	6	28
  Control Width	16	16	16	16	32
  Counter Width	16	32	32	3248	3248
  Shared StartStop	Y	Y	Y	Y	N
  The r8a73a4  R-Car Gen2 version has a per-channel startstop register
  located in the channel registers block. All other versions have a shared
  startstop register located in the global space.
  Channels are indexed from 0 to N-1 in the documentation. The channel index
  infers the startstop bit position in the control register and the channel
  registers block address. Some CMT instances have a subset of channels
  available, in which case the index in the documentation doesn't match the
  "real" index as implemented in hardware. This is for instance the case with
  CMT0 on r8a7740, which is a 32-bit variant with a single channel numbered 0
  in the documentation but using startstop bit 5 and having its registers
  block at 0x60.
  Similarly CMT0 on r8a73a4, r8a7790 and r8a7791, while implementing 32-bit
  channels only, is a 48-bit gen2 CMT with the 48-bit channels unavailable.
 16 or 32 bit version of hardware block 
 callbacks for CMSTR and CMCSR access 
 callbacks for CMCNT and CMCOR access 
 Index in the documentation 
 Real hardware index 
 Protect the shared startstop register 
 channel register 
 channel register 
 channel register 
 CLK Enable Register (R-Car Gen2) 
 Make sure the timer value is stable. Stolen from acpi_pm.c 
 start stop register shared by multiple timer channels 
 enable clock 
 make sure channel is disabled 
 configure channel, periodic mode and maximum timeout 
	
	  According to the sh73a0 user's manual, as CMCNT can be operated
	  only by the RCLK (Pseudo 32 kHz), there's one restriction on
	  modifying CMCNT register; two RCLK cycles are necessary before
	  this register is either read or any modification of the value
	  it holds is reflected in the LSI's actual operation.
	 
	  While at it, we're supposed to clear out the CMCNT as of this
	  moment, so make sure it's processed properly here.  This will
	  take RCLKx2 at maximum.
 enable channel 
 stop clock 
 disable channel 
 disable interrupts in CMT block 
 stop clock 
 private flags 
 force reprogram 
		 we're competing with the interrupt handler.
		   -> let the interrupt handler reprogram the timer.
		   -> interrupt number two handles the event.
		 reprogram the timer hardware,
		  but don't save the new match value yet.
			 we are changing to a greater match value,
			  so this wrap must be caused by the counter
			  matching the old value.
			  -> first interrupt reprograms the timer.
			  -> interrupt number two handles the event.
			 we are changing to a smaller match value,
			  so the wrap must be caused by the counter
			  matching the new value.
			  -> save programmed match value.
			  -> let isr handle the event.
 be safe: verify hardware settings 
			 timer value is below match value, all good.
			  this makes sure we won't miss any match events.
			  -> save programmed match value.
			  -> let isr handle the event.
		 the counter has reached a value greater
		  than our new match value. and since the
		  has_wrapped flag isn't set we must have
		  programmed a too close event.
		  -> increase delay and retry.
 clear flags 
	 update clock source counter to begin with if enabled
	  the wrap flag should be cleared by the timer specific
	  isr before we end up here.
 setup timeout if no clockevent 
 adjust the timeout to maximum if only clocksource left 
 deal with old setting first 
 TODO: calculate good shift from rate and counter bit width 
 Skip unused channels. 
	
	  Compute the address of the channel control register block. For the
	  timers with a per-channel startstop register, compute its address
	  as well.
 Enable the clock supply to the channel 
 deprecated, preserved for backward compatibility 
 deprecated, preserved for backward compatibility 
 Get hold of clock. 
 Determine clock rate. 
 Map the memory resource(s). 
 Allocate and setup the channels. 
	
	  Use the first channel as a clock event device and the second channel
	  as a clock source. If only one channel is available use it for both.
 cannot unregister clockevent and clocksource 
  Marvell Orion SoC timer handling.
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2.  This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  Timer 0 is used as free-running clocksource, while timer 1 is
  used as clock_event_device.
  Free-running clocksource handling.
  Clockevent handling.
 setup and enable one-shot timer 
 disable timer 
 setup and enable periodic timer at 1HZ intervals 
 timer registers are shared with watchdog timer 
 we are only interested in timer1 irq 
 setup timer0 as free-running clocksource 
 setup timer1 as clockevent timer 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) ST-Ericsson SA 2011
  Author: Mattias Wallin <mattias.wallin@stericsson.com> for ST-Ericsson
  Author: Sundar Iyer for ST-Ericsson
  sched_clock implementation is based on:
  plat-nomadiktimer.c Linus Walleij <linus.walleij@stericsson.com>
  DBx500-PRCMU Timer
  The PRCMU has 5 timers which are available in a always-on
  power domain.  We use the Timer 4 for our always-on clock
  source on DB8500.
 Negate because the timer is a decrementing counter 
	
	  The A9 sub system expects the timer to be configured as
	  a continuous looping timer.
	  The PRCMU should configure it but if it for some reason
	  don't we do it here.
 SPDX-License-Identifier: GPL-2.0-only
  driversclocksourcetimer-oxnas-rps.c
  Copyright (C) 2009 Oxford Semiconductor Ltd
  Copyright (C) 2013 Ma Haijun <mahaijuns@gmail.com>
  Copyright (C) 2016 Neil Armstrong <narmstrong@baylibre.com>
 TIMER1 used as tick
  TIMER2 used as clocksource
 Registers definitions 
 Clockevent & Clocksource data 
 Start with prescaler 1 
 Clocksource 
 use prescale 16 
 Disable timers 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017, Linaro Ltd.  All rights reserved.
  Author: Daniel Lezcano <daniel.lezcano@linaro.org>
  timer_of_irq_exit - Release the interrupt
  @of_irq: an of_timer_irq structure pointer
  Free the irq resource
  timer_of_irq_init - Request the interrupt
  @np: a device tree node pointer
  @of_irq: an of_timer_irq structure pointer
  Get the interrupt number from the DT from its definition and
  request it. The interrupt is gotten by falling back the following way:
  - Get interrupt number by name
  - Get interrupt number by index
  When the interrupt is per CPU, 'request_percpu_irq()' is called,
  otherwise 'request_irq()' is used.
  Returns 0 on success, < 0 otherwise
  timer_of_clk_exit - Release the clock resources
  @of_clk: a of_timer_clk structure pointer
  Disables and releases the refcount on the clk
  timer_of_clk_init - Initialize the clock resources
  @np: a device tree node pointer
  @of_clk: a of_timer_clk structure pointer
  Get the clock by name or by index, enable it and get the rate
  Returns 0 on success, < 0 otherwise
  timer_of_cleanup - release timer_of resources
  @to: timer_of structure
  Release the resources that has been used in timer_of_init().
  This function should be called in init error cases
  Allwinner SoCs hstimer driver.
  Copyright (C) 2013 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
  This file is licensed under the terms of the GNU General Public
  License version 2.  This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  When we disable a timer, we need to wait at least for 2 cycles of
  the timer source clock. We will use for that the clocksource timer
  that is already setup and runs at the same frequency than the other
  timers, and we never will be disabled.
 Enable timer0 interrupt 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2006 Jim Cromie
  This is a clocksource driver for the Geode SCx200's 1 or 27 MHz
  high-resolution timer.  The Geode SC-1100 (at least) has a buggy
  time stamp counter (TSC), which loses time unless 'idle=poll' is
  given as a boot-arg. In its absence, the Generic Timekeeping code
  will detect and de-rate the bad TSC, allowing this timer to take
  over timekeeping duties.
  Based on work by John Stultz, and Ted Phelps (in a 2.6.12-rc6 patch)
 load time only 
 load time only 
 HiRes Timer configuration register address 
 and config settings 
 timer interrupt enable 
 1|0 counts at 27|1 MHz 
 1 turns off input clock (power-down) 
 The base timer frequency,  27 if selected 
 Read the timer value 
 mult, shift are set based on mhz27 flag 
 Make sure scx200 has initialized the configuration block 
 Reserve the timer's ISA io-region for ourselves 
 write timer config 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2011 Samsung Electronics Co., Ltd.
 		http:www.samsung.com
  samsung - Common hr-timer support (s3c and s5p)
  Clocksource driver
  Each channel occupies 4 bits in TCON register, but there is a gap of 4
  bits (one channel) after channel 0, so channels have different numbering
  when accessing TCON register.
  In addition, the location of autoreload bit for channel 4 (TCON channel 5)
  in its set of bits is 2 as opposed to 3 for other channels.
	
	  This check is needed to account for internal rounding
	  errors inside clockevents core, which might result in
	  passing cycles = 0, which in turn would not generate any
	  timer interrupt and hang the system.
	 
	  Another solution would be to set up the clockevent device
	  with min_delta = 2, but this would unnecessarily increase
	  the minimum sleep period.
  Override the global weak sched_clock symbol with this
  local implementation which uses the clocksource to get some
  better resolution when scheduling the kernel. We accept that
  this wraps around for now, since it is just a relative time
  stamp. (Inspired by U300 implementation.)
  PWM master driver
 SPDX-License-Identifier: GPL-2.0
   H8300 16bit Timer driver
   Copyright 2015 Yoshinori Sato <ysato@users.sourcefoge.jp>
 Make sure the timer value is stable. Stolen from acpi_pm.c 
 SPDX-License-Identifier: GPL-2.0-or-later
   linuxdriversclocksourcetimer-sp.c
   Copyright (C) 1999 - 2003 ARM Limited
   Copyright (C) 2000 Deep Blue Solutions Ltd
 Hisilicon 64-bit timer(a variant of ARM SP804) 
 It's impossible to reach here 
  IRQ handler for the timer
 clear the interrupt 
 Ensure timers are disabled 
 Get the 2nd clock if the timer has 3 timer clocks 
 Ensure timer is disabled 
  Allwinner A1X SoCs timer handling.
  Copyright (C) 2012 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
  Based on code from
  Allwinner Technology Co., Ltd. <www.allwinnertech.com>
  Benn Huang <benn@allwinnertech.com>
  This file is licensed under the terms of the GNU General Public
  License version 2.  This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  When we disable a timer, we need to wait at least for 2 cycles of
  the timer source clock. We will use for that the clocksource timer
  that is already setup and runs at the same frequency than the other
  timers, and we never will be disabled.
	
	  sched_clock_register does not have priorities, and on sun6i and
	  later there is a better sched_clock registered by arm_arch_timer.c
 Make sure timer is stopped before playing with interrupts 
 clear timer0 interrupt 
 Enable timer0 interrupt 
 SPDX-License-Identifier: GPL-2.0
  SuperH Timer Support - TMU
   Copyright (C) 2009 Magnus Damm
 Protect the shared startstop register 
 shared register 
 channel register 
 channel register 
 channel register 
 start stop register shared by multiple timer channels 
 enable clock 
 make sure channel is disabled 
 maximum timeout 
 configure channel to parent clock  4, irq off 
 enable channel 
 disable channel 
 disable interrupts in TMU block 
 stop clock 
 stop timer 
 acknowledge interrupt 
 enable interrupt 
 reload delta value in case of periodic timer 
 start timer 
 disable or acknowledge interrupt 
 notify clockevent layer 
 deal with old setting first 
 program new delta value 
 Skip unused channels. 
 Get hold of clock. 
 Determine clock rate. 
 Map the memory resource. 
 Allocate and setup the channels. 
	
	  Use the first channel as a clock event device and the second channel
	  as a clock source.
 cannot unregister clockevent and clocksource 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) STMicroelectronics 2019 - All Rights Reserved
  Authors: Benjamin Gaignard <benjamin.gaignard@st.com> for STMicroelectronics.
 	    Pascal Paillet <p.paillet@st.com> for STMicroelectronics.
 clear pending flags 
 disable LPTIMER to be able to write into IER register
 enable ARR interrupt 
 enable LPTIMER to be able to write into ARR register 
 set next event counter 
 start counter 
 Adjust rate and period given the prescaler value 
 cannot unregister clockevent 
  Clocksource driver for NXP LPC32xx18xx43xx timer
  Copyright (C) 2015 Joachim Eastwood <manabian@gmail.com>
  Based on:
  time-efm32 Copyright (C) 2013 Pengutronix
  mach-lpc32xxtimer.c Copyright (C) 2009 - 2010 NXP Semiconductors
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 Needed for the sched clock 
	
	  Place timer in reset and program the delta in the match
	  channel 0 (MR0). When the timer counter matches the value
	  in MR0 register the match will trigger an interrupt.
	  After setup the timer is released from reset and enabled.
 Disable the timer 
	
	  When using oneshot, we must also disable the timer
	  to wait for the first call to set_next_event().
 Enable interrupt, reset on match and stop on match (MCR). 
 Enable interrupt and reset on match. 
	
	  Place timer in reset and program the delta in the match
	  channel 0 (MR0).
 Clear match on channel 0 
	
	  Disable and reset timer then set it to free running timer
	  mode (CTCR) with no prescaler (PR) or match operations (MCR).
	  After setup the timer is released from reset and enabled.
	
	  Disable timer and clear any pending interrupt (IR) on match
	  channel 0 (MR0). Clear the prescaler as it's not used.
  This function asserts that we have exactly one clocksource and one
  clock_event_device in the end.
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2000-2001 Deep Blue Solutions
  Copyright (C) 2002 Shane Nay (shane@minirl.com)
  Copyright (C) 2006-2007 Pavel Pisa (ppisa@pikron.com)
  Copyright (C) 2008 Juergen Beisert (kernel@pengutronix.de)
  There are 4 versions of the timer hardware on Freescale MXC hardware.
   - MX1MXL
   - MX21, MX27.
   - MX25, MX31, MX35, MX37, MX51, MX6Q(rev1.0)
   - MX6DL, MX6SX, MX6Q(rev1.1+)
 defines common for all i.MX 
 Enable module 
 MX1, MX21, MX27 
 MX21, MX27 
 MX31, MX35, MX25, MX5, MX6 
 Wait enable mode 
 clock event 
 Disable interrupt in GPT module 
 Set event time into far-far future 
 Clear pending interrupt 
 DEBUG 
 Disable interrupt in GPT module 
 Set event time into far-far future 
 Clear pending interrupt 
 DEBUG 
	
	  Do not put overhead of interrupt enabledisable into
	  mxc_set_next_event(), the core has about 4 minutes
	  to call mxc_set_next_event() or shutdown clock after
	  mode switching
  IRQ handler for the timer
 24  8 = 3 MHz 
	
	  Initialise to a known state (all timers off, and timing reset)
 see datasheet note 
 init and register the timer to the framework 
 Support one instance only 
 Try osc_per first, and fall back to per otherwise 
	
	  We were using the same compatible string for i.MX6QD and i.MX6DLS
	  GPT device, while they actually have different programming model.
	  This is a workaround to keep the existing i.MX6DLS DTBs continue
	  working with the new kernel.
 SPDX-License-Identifier: GPL-2.0
   linuxarchh8300kernelcputimertimer8.c
   Yoshinori Sato <ysato@users.sourcefoge.jp>
   8bit Timer driver
 SPDX-License-Identifier: GPL-2.0-only
 linuxarcharmmach-exynos4mct.c
  Copyright (c) 2011 Samsung Electronics Co., Ltd.
 		http:www.samsung.com
  Exynos4 MCT(Multi-Core Timer) support
 Use values higher than ARM arch timer. See 6282edb72bed. 
 L_TCON write status 
 L_ICNTB write status 
 L_TCNTB write status 
 G_TCON write status 
 G_COMP0_L write status 
 G_COMP0_U write status 
 G_COMP0_ADD_INCR w status 
 G_CNT_L write status 
 G_CNT_U write status 
 Wait maximum 1 ms until written values are applied 
 Clocksource handling 
  exynos4_read_count_64 - Read all 64-bits of the global counter
  This will read all 64-bits of the global counter taking care to make sure
  that the upper and lower half match.  Note that reading the MCT can be quite
  slow (hundreds of nanoseconds) so you should use the 32-bit (lower half
  only) version when possible.
  Returns the number of cycles in the global counter.
  exynos4_read_count_32 - Read the lower 32-bits of the global counter
  This will read just the lower 32-bits of the global counter.  This is marked
  as notrace so it can be used by the scheduler clock.
  Returns the number of cycles in the global counter (lower 32 bits).
 Clock event handling 
 MCT_L_UPDATE_ICNTB 
 update interrupt count buffer 
 enable MCT tick interrupt 
 Clear the MCT tick interrupt 
	
	  This is for supporting oneshot mode.
	  Mct would generate interrupt periodically
	  without explicit stopping.
 Install hotplug callbacks which configure the timer on this CPU 
 This driver uses only one global timer interrupt 
	
	  Find out the number of local irqs specified. The local
	  timer irqs are specified after the four global timer
	  irqs are specified.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020 Western Digital Corporation or its affiliates.
  Most of the M-mode (i.e. NoMMU) RISC-V systems usually have a
  CLINT MMIO timer device.
 CLINT manages IPI and Timer for RISC-V M-mode  
 CONFIG_64BIT 
 CONFIG_64BIT 
	
	  Ensure that CLINT device interrupts are either RV_IRQ_TIMER or
	  RV_IRQ_SOFT. If it's anything else then we ignore the device.
 Find parent irq domain and map timer irq 
 If CLINT timer irq not found then fail 
	
	  Yes, that's an odd naming scheme.  time_val is public, but hopefully
	  will die in favor of something cleaner.
 SPDX-License-Identifier: GPL-2.0-only
  Keystone broadcast clock-event
  Copyright 2013 Texas Instruments, Inc.
  Author: Ivan Khoronzhuk <ivan.khoronzhuk@ti.com>
 Timer register offsets 
 Timer register bitfields 
  struct keystone_timer: holds timer's data
  @base: timer memory base address
  @hz_period: cycles per HZ period
  @event_dev: event device based on timer
  keystone_timer_barrier: write memory barrier
  use explicit barrier to avoid using readlwritel non relaxed function
  variants, because in our case non relaxed variants hide the true places
  where barrier is needed.
  keystone_timer_config: configures timer to work in oneshotperiodic modes.
  @ mask: mask of the mode to configure
  @ period: cycles number to configure for
 set enable mode 
 disable timer 
 here we have to be sure the timer has been disabled 
 reset counter to zero, set new period 
	
	  enable timer
	  here we have to be sure that CNTLO, CNTHI, PRDLO, PRDHI registers
	  have been written.
 disable timer 
 disable, use internal clock source 
 here we have to be sure the timer has been disabled 
 reset timer as 64-bit, no pre-scaler, plus features are disabled 
 unreset timer 
 init counter to zero 
 enable timer interrupts 
 setup clockevent 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2014 ARM Limited
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2015 ARM Limited
  Author: Vladimir Murzin <vladimir.murzin@arm.com>
 Ensure timer is disabled 
 clk_{disable, unprepare, put}() can handle NULL as a parameter 
 Ensure timer is disabled 
 ... and set it up as free-running clocksource 
 clk_{disable, unprepare, put}() can handle NULL as a parameter 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2015 Numascale AS. All rights reserved.
 Setup IPI vector to local core and relative timing mode 
 Reset timer 
 Setup per-cpu clockevents 
 SPDX-License-Identifier: GPL-2.0-only
  Rockchip timer support
  Copyright (C) Daniel Lezcano <daniel.lezcano@linaro.org>
 Leave rk_clkevt not NULL to prevent future init 
 Leave rk_clksrc not NULL to prevent future init 
 SPDX-License-Identifier: GPL-2.0-or-later
  Actions Semi Owl timer
  Copyright 2012 Actions Semi Inc.
  Author: Actions Semi, Inc.
  Copyright (c) 2017 SUSE Linux GmbH
  Author: Andreas Färber
 PD bit is cleared when set 
 SPDX-License-Identifier: GPL-2.0-only
  Emma Mobile Timer Support - STI
   Copyright (C) 2012 Magnus Damm
 enable clock 
 reset the counter 
 mask and clear pending interrupts 
 enable updates of counter registers 
 mask interrupts 
 stop clock 
	 the STI hardware buffers the 48-bit count, but to
	  break it out into two 32-bit access the registers
	  must be accessed in a certain order.
	  Always read STI_COUNT_H before STI_COUNT_L.
 mask compare A interrupt 
 update compare A value 
 clear compare A interrupt source 
 unmask compare A interrupt 
 map memory, let base point to the STI instance 
 get hold of clock 
 cannot unregister clockevent and clocksource 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) Maxime Coquelin 2015
  Author:  Maxime Coquelin <mcoquelin.stm32@gmail.com>
 SPDX-License-Identifier: GPL-2.0
  Renesas Timer Support - OSTM
  Copyright (C) 2017 Renesas Electronics America, Inc.
  Copyright (C) 2017 Chris Brandt
  The OSTM contains independent channels.
  The first OSTM channel probed will be set up as a free running
  clocksource. Additionally we will use this clocksource for the system
  schedule timer sched_clock().
  The second (or more) channel probed will be set up as an interrupt
  driven clock event.
 For sched_clock() 
 OSTM REGISTERS 
 RW,32 
 R,32 
 R,8 
 W,8 
 W,8 
 RW,8 
		
		  Read back the register simply to confirm the write operation
		  has completed since IO writes can sometimes get queued by
		  the bus architecture.
 notify clockevent layer 
		
		  clock sources don't use interrupts, clock events do
	
	  First probed device will be used as system clocksource. Any
	  additional devices will be used as clock events.
 SPDX-License-Identifier: GPL-2.0
  IXP4 timer driver
  Copyright (C) 2019 Linus Walleij <linus.walleij@linaro.org>
  Based on archarmmach-ixp4xxcommon.c
  Copyright 2002 (C) Intel Corporation
  Copyright 2003-2004 (C) MontaVista, Software, Inc.
  Copyright (C) Deepak Saxena <dsaxena@plexity.net>
 Goes away with OF conversion 
  Constants to make it easy to access Timer ControlStatus registers
 Continuous Timestamp 
 Timer 1 Timestamp 
 Timer 1 Reload 
 Timer 2 Timestamp 
 Timer 2 Reload 
 Timer Status 
  Timer register values and bit definitions
 Low order bits of reload value ignored 
 Remaining registers are for the watchdog and defined in the watchdog driver 
  A local singleton used by sched_clock and delay timer reads, which are
  fast and stateless
 Clear Pending Interrupt 
 Keep enableoneshot bits 
  IXP4xx timer tick
  We use OS timer1 on the CPU for the timer tick and the timestamp
  counter as a source of real clock ticks to account for missed jiffies.
	
	  The timer register doesn't allow to specify the two least
	  significant bits of the timeout value and assumes them being zero.
	  So make sure the latch is the best value with the two least
	  significant bits unset.
 Resetdisable counter 
 Clear any pending interrupt on timer 1 
 Reset time-stamp counter 
 Also use this timer for delays 
  This probe gets called after the timer is already up and running. The main
  function on this platform is to spawn the watchdog device as a child.
 Pass the base address as platform data and nothing else 
 sentinel  },
  ixp4xx_timer_setup() - Timer setup function to be called from boardfiles
  @timerbase: physical base of timer block
  @timer_irq: Linux IRQ number for the timer
  @timer_freq: Fixed frequency of the timer
 TODO: get some fixed clocks into the device tree 
 SPDX-License-Identifier: GPL-2.0-only
  EFI support for Xen.
  Copyright (C) 1999 VA Linux Systems
  Copyright (C) 1999 Walt Drummond <drummond@valinux.com>
  Copyright (C) 1999-2002 Hewlett-Packard Co.
 	David Mosberger-Tang <davidm@hpl.hp.com>
 	Stephane Eranian <eranian@hpl.hp.com>
  Copyright (C) 2005-2008 Intel Co.
 	Fenghua Yu <fenghua.yu@intel.com>
 	Bibo Mao <bibo.mao@intel.com>
 	Chandramouli Narayanan <mouli@linux.intel.com>
 	Huang Ying <ying.huang@intel.com>
  Copyright (C) 2011 Novell Co.
 	Jan Beulich <JBeulich@suse.com>
  Copyright (C) 2011-2012 Oracle Co.
 	Liang Tang <liang.tang@oracle.com>
  Copyright (c) 2014 Oracle Co., Daniel Kiper
  Set XEN EFI runtime services function pointers. Other fields of struct efi,
  e.g. efi.systab, will be set like normal EFI.
 SPDX-License-Identifier: GPL-2.0-only
  features.c
  Xen feature flags.
  Copyright (c) 2006, Ian Campbell, XenSource Inc.
  Linux kernel expects at least Xen 4.0.
  Assume some features to be available for that reason (depending on guest
  mode, of course).
 SPDX-License-Identifier: GPL-2.0
  Xen stolen ticks accounting.
 runstate info updated by Xen 
 return an consistent snapshot of 64-bit timecounter value 
		
		  Read high then low, and then make sure high is
		  still the same; this will only loop if low wraps
		  and carries into high.
		  XXX some clean way to make this endian-proof?
 Hypervisor might update data. 
 Hypervisor might update data. 
 backup runstate time before suspend 
 backup runstate time after resume 
 do not accumulate runstate time for checkpointing 
  Runstate accounting
 return true when a vcpu could run but has no real cpu to run on 
 SPDX-License-Identifier: GPL-2.0 OR MIT
  Xen frontendbackend page directory based shared buffer
  helper module.
  Copyright (C) 2018 EPAM Systems Inc.
  Author: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
  FIXME: usage of grant reference 0 as invalid grant reference:
  grant reference 0 is valid, but never exposed to a PV driver,
  because of the fact it is already in usereserved by the PV console.
  This structure represents the structure of a shared page
  that contains grant references to the pages of the shared
  buffer. This structure is common to many Xen para-virtualized
  protocols at includexeninterfaceio
 Variable length 
  Shared buffer ops which are differently implemented
  depending on the allocation mode, e.g. if the buffer
  is allocated by the corresponding backend or frontend.
  Some of the operations.
	
	  Calculate number of grefs required to handle this buffer,
	  e.g. if grefs are required for page directory only or the buffer
	  pages as well.
 Fill page directory according to para-virtual display protocol. 
 Claim grant references for the pages of the buffer. 
 Map grant references of the buffer. 
 Unmap grant references of the buffer. 
  Get granted reference to the very first page of the
  page directory. Usually this is passed to the backend,
  so it can findfill the grant references to the buffer's
  pages.
  \param buf shared buffer which page directory is of interest.
  \return granted reference to the very first page of the
  page directory.
  Map granted references of the shared buffer.
  Depending on the shared buffer mode of allocation
  (be_alloc flag) this can either do nothing (for buffers
  shared by the frontend itself) or map the provided granted
  references onto the backing storage (buf->pages).
  \param buf shared buffer which grants to be maped.
  \return zero on success or a negative number on failure.
 No need to map own grant references. 
  Unmap granted references of the shared buffer.
  Depending on the shared buffer mode of allocation
  (be_alloc flag) this can either do nothing (for buffers
  shared by the frontend itself) or unmap the provided granted
  references.
  \param buf shared buffer which grants to be unmaped.
  \return zero on success or a negative number on failure.
 No need to unmap own grant references. 
  Free all the resources of the shared buffer.
  \param buf shared buffer which resources to be freed.
  Number of grefs a page can hold with respect to the
  struct xen_page_directory header.
  Get the number of pages the page directory consumes itself.
  \param buf shared buffer.
  Calculate the number of grant references needed to share the buffer
  and its pages when backend allocates the buffer.
  \param buf shared buffer.
 Only for pages the page directory consumes itself. 
  Calculate the number of grant references needed to share the buffer
  and its pages when frontend allocates the buffer.
  \param buf shared buffer.
	
	  Number of pages the page directory consumes itself
	  plus grefs for the buffer pages.
  Unmap the buffer previously mapped with grant references
  provided by the backend.
  \param buf shared buffer.
  \return zero on success or a negative number on failure.
  Map the buffer with grant references provided by the backend.
  \param buf shared buffer.
  \return zero on success or a negative number on failure.
	
	  Read page directory to get grefs from the backend: for external
	  buffer we only allocate buf->grefs for the page directory,
	  so buf->num_grefs has number of pages in the page directory itself.
 Save handles even if error, so we can unmap. 
  Fill page directory with grant references to the pages of the
  page directory itself.
  The grant references to the buffer pages are provided by the
  backend in this case.
  \param buf shared buffer.
 Fill only grefs for the page directory itself. 
 Last page must say there is no more pages. 
  Fill page directory with grant references to the pages of the
  page directory and the buffer we share with the backend.
  \param buf shared buffer.
	
	  While copying, skip grefs at start, they are for pages
	  granted for the page directory itself.
  Grant references to the frontend's buffer pages.
  These will be shared with the backend, so it can
  access the buffer's data.
  \param buf shared buffer.
  \return zero on success or a negative number on failure.
  Grant all the references needed to share the buffer.
  Grant references to the page directory pages and, if
  needed, also to the pages of the shared buffer data.
  \param buf shared buffer.
  \return zero on success or a negative number on failure.
  Allocate all required structures to mange shared buffer.
  \param buf shared buffer.
  \return zero on success or a negative number on failure.
  For backend allocated buffers we don't need grant_refs_for_buffer
  as those grant references are allocated at backend side.
  For locally granted references we do not need to mapunmap
  the references.
  Allocate a new instance of a shared buffer.
  \param cfg configuration to be used while allocating a new shared buffer.
  \return zero on success or a negative number on failure.
 SPDX-License-Identifier: GPL-2.0
  Xen dma-buf functionality for gntdev.
  DMA buffer implementation is based on driversgpudrmdrm_prime.c.
  Copyright (c) 2018 Oleksandr Andrushchenko, EPAM Systems Inc.
  Note on usage of grant reference 0 as invalid grant reference:
  grant reference 0 is valid, but never exposed to a driver,
  because of the fact it is already in usereserved by the PV console.
 Exported buffers are reference counted. 
 Granted references of the imported buffer. 
 Scatter-gather table of the imported buffer. 
 dma-buf attachment of the imported buffer. 
 Number of pages this buffer has. 
 Pages of this buffer. 
 List of exported DMA buffers. 
 List of wait objects. 
 List of imported DMA buffers. 
 This is the lock which protects dma_buf_xxx lists. 
	
	  We reference this file while exporting dma-bufs, so
	  the grant device context is not destroyed while there are
	  external users alive.
 DMA buffer export support. 
 Implementation of wait for exported DMA buffer to be released. 
 Put our reference and wait for gntdev_dmabuf's release to fire. 
	
	  Try to find the DMA buffer: if not found means that
	  either the buffer has already been released or file descriptor
	  provided is wrong.
	
	  gntdev_dmabuf still exists and is reference count locked by us now,
	  so prepare to wait: allocate wait object and add it to the wait list,
	  so we can find it on release.
 DMA buffer export support. 
 Return the cached mapping when possible. 
	
	  Two mappings with different directions for the same attachment are
	  not allowed.
 Not implemented. The unmap is done at dmabuf_exp_ops_detach(). 
 already removed , map);
 Shut up unnecessary gcc warning for i386 
 DMA buffer import support. 
 Check that we have zero offset. 
 Check number of pages that imported buffer has. 
 Now convert sgt to array of pages and check for page validity. 
		
		  Check if page is valid: this can happen if we are given
		  a page from VRAM or other resources which are not backed
		  by a struct page.
  Find the hyper dma-buf by its file descriptor and remove
  it from the buffer's list.
 DMA buffer IOCTL support. 
 SPDX-License-Identifier: GPL-2.0-or-later
  (c) 2017 Stefano Stabellini <stefano@aporeto.com>
 Only one frontback connection supported. 
 first increment refcount, then proceed 
 first complete other operations, then decrement refcount 
		
		  Socket status, needs to be 64-bit aligned due to the
		  test_and_ functions which have this requirement on arm64.
		
		  Internal state-machine flags.
		  Only one accept operation can be inflight for a socket.
		  Only one poll operation can be inflight for a given socket.
		  flags needs to be 64-bit aligned due to the test_and_
		  functions which have this requirement on arm64.
			
			  clear INFLIGHT, then set RET. It pairs with
			  the checks at the beginning of
			  pvcalls_front_poll_passive.
			
			  First copy the rest of the data, then req_id. It is
			  paired with the barrier when accessing bedata->rsp.
	
	  PVCalls only supports domain AF_INET,
	  type SOCK_STREAM and protocol 0 sockets for now.
	 
	  Check socket type here, AF_INET and protocol checks are done
	  by the caller.
	
	  sock->sk->sk_send_head is not used for ip sockets: reuse the
	  field to store a pointer to the struct sock_mapping
	  corresponding to the socket. This way, we can easily get the
	  struct sock_mapping from the struct socket.
 read req_id, then the content 
 read req_id, then the content 
 read indexes before continuing 
 write to ring before updating pointer 
 get pointers before reading from the ring 
 read data from the ring before increasing the index 
 read req_id, then the content 
 read req_id, then the content 
	
	  Backend only supports 1 inflight accept request, will return
	  errors for the others
 We could check if we have received a response before returning. 
 read req_id, then the content 
	
	  First check RET, then INFLIGHT. No barriers necessary to
	  ensure execution ordering because of the conditional
	  instructions creating control dependencies.
		
		  Set in_error and wake up inflight_conn_req to force
		  recvmsg waiters to exit.
		
		  We need to make sure that sendmsgrecvmsg on this socket have
		  not started before we've cleared sk_send_head here. The
		  easiest way to guarantee this is to see that no pvcalls
		  (other than us) is in progress on this socket.
 No need to lock, refcount is 0 
 See XENBUS_FUNCTIONS_CALLS in pvcalls.h 
 Missed the backend's CLOSING state 
 SPDX-License-Identifier: GPL-2.0
  Xen memory reservation utilities.
  Copyright (c) 2003, B Dragovic
  Copyright (c) 2003-2004, M Williamson, K Fraser
  Copyright (c) 2005 Dan M. Smith, IBM Corporation
  Copyright (c) 2010 Daniel Kiper
  Copyright (c) 2018 Oleksandr Andrushchenko, EPAM Systems Inc.
  Use one extent per PAGE_SIZE to avoid to break down the page into
  multiple frame.
		
		  We don't support PV MMU when Linux and Xen is using
		  different page granularity.
		
		  We don't support PV MMU when Linux and Xen are using
		  different page granularity.
 CONFIG_XEN_HAVE_PVMMU 
 @frames is an array of PFNs 
 XENMEM_populate_physmap requires a PFN based on Xen granularity. 
 @frames is an array of GFNs 
 XENMEM_decrease_reservation requires a GFN 
  Xen SCSI backend driver
  Copyright (c) 2008, FUJITSU Limited
  Based on the blkback driver code.
  Adaption to kernel taget core infrastructure taken from vhostscsi.c
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2
  as published by the Free Software Foundation; or, when distributed
  separately from the Linux kernel or incorporated into other
  software packages, subject to the following license:
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this source file (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, andor sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
 SG_ALL 
 host    
 channel 
 target  
 LUN     
 translate from 
 translate to   
 theoretical maximum of grants for one request 
  VSCSI_GRANT_BATCH is the maximum number of grants to be processed in one
  call to mapunmap grants. Don't choose it too large, as there are arrays
  with VSCSI_GRANT_BATCH elements allocated on the stack.
 real length of SG list 
 SG pages and potentially SG list 
 Pointer to TCM session for I_T Nexus 
 SCSI protocol the tport is providing 
 Binary World Wide unique Port Name for pvscsi Target port 
 ASCII formatted WWPN for pvscsi Target port 
 Returned by scsiback_make_tport() 
 scsiback port target portal group tag for TCM 
 track number of TPG PortLun Links wrt explicit I_T Nexus shutdown 
 xen-pvscsi references to tpg_nexus, protected by tv_tpg_mutex 
 list for scsiback_list 
 Used to protect access for tpg_nexus 
 Pointer to the TCM pvscsi I_T Nexus for this TPG endpoint 
 Pointer back to scsiback_tport 
 Returned by scsiback_make_tpg() 
 alias used in xenstore 
 list of info structures related to this target portal group 
 Global spinlock to protect scsiback TPG list 
	
	  Drop the extra KREF_ACK reference taken by target_submit_cmd_map_sgls()
	  ahead of scsiback_check_stop_free() ->  transport_generic_free_cmd()
	  final se_cmd->cmd_kref put.
 free of (sgl) in fast_flush_area() 
  Perform virtual to physical translation
 request range check from frontend 
 guest system is accessing ring, too 
 Yield point for this unbounded loop. 
 In case of a ring error we keep the event channel masked. 
  Check for a translation entry being present
  Add a new translation entry
 Check double assignment to identical virtual ID 
 Create a new translation entry and add to the list 
  Delete the translation entry specified
 Find out the translation entry specified 
 read status 
 physical SCSI device 
 virtual SCSI device 
 modify vscsi-devsdev-xstate 
 When it is necessary, processing is added here. 
 if not online 
  Release the translation entry specfied
	
	  Determine the emulated Protocol Identifier and Target Port Name
	  based on the incoming configfs directory name.
 Skip over "fc." 
 Go ahead and process the write immediately 
	
	  Release the SCSI I_T Nexus to the emulated xen-pvscsi Target Port
	
	  Shutdown the active I_T nexus if 'NULL' is passed.
	
	  Otherwise make sure the passed virtual Initiator port WWN matches
	  the fabric protocol_id set in scsiback_make_tport(), and call
	  scsiback_make_nexus().
 Skip over "fc." 
	
	  Clear any trailing newline for the NAA WWN
	
	  Release the virtual I_T Nexus for this xen-pvscsi TPG
	
	  Deregister the se_tpg from TCM.
	
	  Setup callers for generic logic in target_core_fabric_configfs.c
  gntdev.c
  Device for accessing (in user-space) pages that have been granted by other
  domains.
  Copyright (c) 2006-2007, D G Murray.
            (c) 2009 Gerd Hoffmann <kraxel@redhat.com>
            (c) 2018 Oleksandr Andrushchenko, EPAM Systems Inc.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ------------------------------------------------------------------ 
	
	  Check if this mapping is requested to be backed
	  by a DMA buffer.
 Remember the device, so we can free DMA memory. 
 ------------------------------------------------------------------ 
 Note: it could already be mapped 
		
		  Setup the map_ops corresponding to the pte entries pointing
		  to the kernel linear addresses of the struct pages.
		  These ptes are completely different from the user ptes dealt
		  with find_grant_ptes.
		  Note that GNTMAP_device_map isn't needed here: The
		  dev_bus_addr output field gets consumed only from ->map_ops,
		  and by not requesting it when mapping we also avoid needing
		  to mirror dev_bus_addr into ->unmap_ops (and holding an extra
		  reference to the page in the hypervisor).
 No need for kmap, pages are in lowmem 
	 It is possible the requested range will have a "hole" where we
	  already unmapped some of the grants. Only unmap valid ranges.
 ------------------------------------------------------------------ 
 ------------------------------------------------------------------ 
	
	  If the VMA is split or otherwise changed the notifier is not
	  updated, but we don't want to process VA's outside the modified
	  VMA. FIXME: It would be much more understandable to just prevent
	  modifying the VMA in the first place.
 ------------------------------------------------------------------ 
 already removed , map);
 This is not a dma-buf. );
	 We need to grab a reference to the event channel we are going to use
	  to send the notify before releasing the reference we may already have
	  (if someone has called this ioctl twice). This is required so that
	  it is possible to change the clear_byte part of the notification
	  without disturbing the event channel part, which may now be the last
	  reference to that event channel.
 Drop the reference to the event channel we did not save in the map 
	
	  For each completed op, update the status if the op failed
	  and all previous ops for the segment were successful.
	
	  Disallow local -> local copies since there is only space in
	  batch->pages for one page per-op and this would be a very
	  expensive memcpy().
 Can't cross page if sourcedest is a grant ref. 
		
		  gntdev takes the address of the PTE in find_grant_ptes() and
		  passes it to the hypervisor in gntdev_map_grant_pages(). The
		  purpose of the notifier is to prevent the hypervisor pointer
		  to the PTE from going stale.
		 
		  Since this vma's mappings can't be touched without the
		  mmap_lock, and we are holding it now, there is no need for
		  the notifier_range locking pattern.
 ------------------------------------------------------------------ 
 ------------------------------------------------------------------ 
  grant_table.c
  Granting foreign access to our memory reservation.
  Copyright (c) 2005-2006, Christopher Clark
  Copyright (c) 2004-2005, K A Fraser
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2
  as published by the Free Software Foundation; or, when distributed
  separately from the Linux kernel or incorporated into other
  software packages, subject to the following license:
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this source file (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, andor sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
 External tools reserve first few grant table entries. 
This is a structure of function pointers for grant table
	
	  Version of the grant interface.
	
	  Grant refs per grant frame.
	
	  Mapping a list of frames for storing grant entries. Frames parameter
	  is used to store grant table address when grant table being setup,
	  nr_gframes is the number of frames to map grant table. Returning
	  GNTST_okay means success and negative value means failure.
	
	  Release a list of frames which are mapped in map_frames for grant
	  entry status.
	
	  Introducing a valid entry into the grant table, granting the frame of
	  this grant entry to domain for accessing or transfering. Ref
	  parameter is reference of this introduced grant entry, domid is id of
	  granted domain, frame is the page frame to be granted, and flags is
	  status of the grant entry to be updated.
	
	  Stop granting a grant entry to domain for accessing. Ref parameter is
	  reference of a grant entry whose grant access will be stopped,
	  readonly is not in use in this function. If the grant entry is
	  currently mapped for reading or writing, just return failure(==0)
	  directly and don't tear down the grant access. Otherwise, stop grant
	  access for this entry and return success(==1).
	
	  Stop granting a grant entry to domain for transfer. Ref parameter is
	  reference of a grant entry whose grant transfer will be stopped. If
	  tranfer has not started, just reclaim the grant entry and return
	  failure(==0). Otherwise, wait for the transfer to complete and then
	  return the frame.
	
	  Query the status of a grant entry. Ref parameter is reference of
	  queried grant entry, return value is the status of queried entry.
	  Detailed status(writingreading) can be gotten from the return value
	  by bit operations.
 This reflects status of grant entries, so act as a global value. 
 This can be used as an l-value 
  Following applies to gnttab_update_entry_v1 and gnttab_update_entry_v2.
  Introducing a valid entry into the grant table:
   1. Write ent->domid.
   2. Write ent->frame:
       GTF_permit_access:   Frame to which access is permitted.
       GTF_accept_transfer: Pseudo-phys frame slot being filled by new
                            frame, or zero if none.
   3. Write memory barrier (WMB).
   4. Write ent->flags, inc. valid type.
 Hypervisor concurrent accesses. 
  Public grant-issuing interface functions
 Concurrent access by hypervisor. 
		
		  The read of grstatus needs to have acquire semantics.
		   On x86, reads already have that, and we just need to
		  protect against compiler reorderings.
		  On other architectures we may need a full barrier.
	
	  If a transfer is not even yet started, try to reclaim the grant
	  reference and return failure (== 0).
 If a transfer is in progress then wait until it is completed. 
 Read the frame number after reading completion status. 
	
	  If a transfer is not even yet started, try to reclaim the grant
	  reference and return failure (== 0).
 If a transfer is in progress then wait until it is completed. 
 Read the frame number after reading completion status. 
 Check if the callback is already on the list 
 Legacy max supported number of frames 
 First time, initialize it properly. 
  gnttab_alloc_pages - alloc pages suitable for grant mapping into
  @nr_pages: number of pages to alloc
  @pages: returns the pages
  gnttab_free_pages - free pages allocated by gnttab_alloc_pages()
  @nr_pages; number of pages to free
  @pages: the pages
  gnttab_dma_alloc_pages - alloc DMAable pages suitable for grant mapping into
  @args: arguments to the function
  gnttab_dma_free_pages - free DMAable pages
  @args: arguments to the function
 Handling of paged out grant targets (GNTST_eagain) 
 Retry eagain maps 
 Test status in next loop iteration. 
	 No need for kzalloc as it is initialized in following hypercall
	  GNTTABOP_get_status_frames.
		
		  Loop backwards, so that the first hypercall has the largest
		  index, ensuring that the table will grow only once.
	 No need for kzalloc as it is initialized in following hypercall
	  GNTTABOP_setup_table.
 Information not available, use V1. 
 Boot parameter overrides automatic selection. 
	 Determine the maximum number of frames required for the
	  grant reference free list on the current hypervisor.
 Delay grant-table initialization in the PV on HVM case 
 Starts after core_initcall so that xen_pvh_gnttab_setup can be called
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: GPL-2.0-only
  privcmd.c
  Interface to privileged domain-0 commands.
  Copyright (c) 2002-2004, K A Fraser, B Dragovic
 Disallow arbitrary hypercalls if restricted 
  Given an array of items in userspace, return a list of pages
  containing the data.  If copying fails, either because of memory
  allocation failure or a problem reading user memory, return an
  error code; its up to the caller to dispose of any partial list.
 quiet, gcc 
  Call function "fn" on each element of the array fragmented
  over a list of pages.
 hush, gcc 
  Similar to traverse_pages, but use each page as a "block" of
  data to be processed as one unit.
 Do not allow range to wrap the address space. 
 Range chunks must be contiguous in va space. 
 We only support privcmd_ioctl_mmap_batch for non-auto-translated. 
 If restriction is in place, check the domid matches 
	 A tristate:
	       0 for no errors
	       1 if at least one error has happened (and no
	           -ENOENT errors have happened)
	       -ENOENT if at least 1 -ENOENT has happened.
 User-space gfn array to store errors in the second pass for V1. 
 User-space int array to store errors in the second pass for V2. 
 auto translated dom0 note: if domU being created is PV, then gfn is
  mfn(addr on bus). If it's auto xlated, then gfn is pfn (input to HAP).
 Adjust the global_error? 
 Record that at least one error has happened. 
			
			  V1 encodes the error codes in the 32bit top
			  nibble of the gfn (with its known
			  limitations vis-a-vis 64 bit callers).
 st->version == 2 
 Allocate pfns that are then mapped with gfns from foreign domid. Update
  the vma with the page info to use later.
  Returns: 0 if success, otherwise -errno
 Returns per-frame error in m.arr. 
 Returns per-frame error code in m.err. 
 If restriction is in place, check the domid matches 
 Zero error array now to only copy back actual errors. 
	
	  Caller must either:
	 
	  Map the whole VMA range, which will also allocate all the
	  pages required for the auto_translated_physmap case.
	 
	  Or
	 
	  Map unmapped holes left from a previous map attempt (e.g.,
	  because those foreign frames were previously paged out).
 mmap_batch_fn guarantees ret == 0 
 Write back errors in second pass. 
	 If we have not had any EFAULT-like global errors then set the global
 If restriction is in place, check the domid matches 
 Set restriction to the specified domain, or check it matches 
 If restriction is in place, check the domid matches 
 Both fields must be set or unset 
 Query the size of the resource. 
 DOMID_INVALID implies no restriction 
	 DONTCOPY is essential for Xen because copy_page_range doesn't know
  For MMAPBATCH. This allows asserting the singleshot mapping
  on a per pfnpte basis. Mapping calls that fail with ENOENT
  can be then retried until success.
 SPDX-License-Identifier: GPL-2.0
 check if @page can be merged with 'vec1' 
	
	  XXX: Add support for merging bio_vec when using different page
	  size in Xen and Linux.
  mcelog.c
  Driver for receiving and transferring machine check error infomation
  Copyright (c) 2012 Intel Corporation
  Author: Liu, Jinsong <jinsong.liu@intel.com>
  Author: Jiang, Yunhong <yunhong.jiang@intel.com>
  Author: Ke, Liping <liping.ke@intel.com>
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2
  as published by the Free Software Foundation; or, when distributed
  separately from the Linux kernel or incorporated into other
  software packages, subject to the following license:
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this source file (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, andor sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
 #times opened 
 already open exclusive? 
 Only supports full reads right now 
  Caller should hold the mcelog_lock
	
	  When the buffer fills up discard new entries.
	  Assume that the earlier errors are the more
	  interesting ones:
log this record
 virq handler for machine check error info
 urgent mc_info 
 nonurgent mc_info 
 wake processes polling devmcelog 
 Fetch physical CPU Numbers 
 Fetch each CPU Physical Info for later reference
 Only DOM0 is responsible for MCE logging 
 register character device devmcelog for xen mcelog 
 SPDX-License-Identifier: GPL-2.0-or-later
  (c) 2017 Stefano Stabellini <stefano@aporeto.com>
  Per-frontend data structure. It contains pointers to the command
  ring, its event channel, a list of active sockets and a tree of
  passive sockets.
 read the indexes first, then deal with the data 
 shouldn't happen 
 write the data, then modify the indexes 
 update the indexes, then notify the other end 
 read the indexes before dealing with the data 
 write the data, then update the indexes 
 update the indexes, then notify the other end 
 leave the actual socket allocation for later 
 first read the order, then map the data ring 
	
	  __pvcalls_back_accept can race against pvcalls_back_accept.
	  We only need to check the value of "cmd" on read. It could be
	  done atomically, but to simplify the code on the write side, we
	  use a spinlock.
	
	  Limitation of the current implementation: only support one
	  concurrent accept or poll call on one socket.
 Tell the caller we don't need to send back a notification yet 
	
	  Limitation of the current implementation: only support one
	  concurrent accept or poll call on one socket.
 Tell the caller we don't need to send back a notification yet 
  evtchn.c
  Driver for receiving and demuxing event-channel signals.
  Copyright (c) 2004-2005, K A Fraser
  Multi-process extensions Copyright (c) 2004, Steven Smith
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2
  as published by the Free Software Foundation; or, when distributed
  separately from the Linux kernel or incorporated into other
  software packages, subject to the following license:
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this source file (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, andor sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
 serialize bindunbind operations 
 Notification ring, accessed via devxenevtchn. 
 protect against concurrent readers 
 product against concurrent interrupts 
 Processes wait on this queue when ring is empty. 
 Add new node and rebalance tree. 
 Ensure ring contents visible 
 Whole number of ports. 
 Byte lengths of two chunks. Chunk split (if any) is at ring wrap. 
 Truncate chunks according to caller's maximum byte count. 
 Ensure that we see the port before we copy it. 
 Whole number of ports. 
	
	  Ensure the ring is large enough to capture all possible
	  events. i.e., one free slot for each bound event.
	
	  Access to the ring contents is serialized by either the
	  prod or cons lock so take both when resizing.
	
	  Copy the old ring contents to the new ring.
	 
	  To take care of wrapping, a full ring, and the new index
	  pointing into the second half, simply copy the old contents
	  twice.
	 
	  +---------+    +------------------+
	  |34567  12| -> |34567  1234567  12|
	  +-----p-c-+    +-------c------p---+
	
	  Ports are never reused, so every caller should pass in a
	  unique port.
	 
	  (Locking not necessary because we haven't registered the
	  interrupt handler yet, and our caller has already
	  serialized bind operations.)
 start enabled 
 bind failed, should close the port now 
 Prevent bind from racing with unbind 
 Initialise the ring to empty. Clear errors. 
 Create 'devxenevtchn'. 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2009, Intel Corporation.
  Author: Weidong Han <weidong.han@intel.com>
	
	  Reserve MCFG areas in Xen on first invocation due to this being
	  potentially called from inside of acpi_init immediately after
	  MCFG table has been finally parsed.
			
			  This device was not listed in the ACPI name space at
			  all. Try to get acpi handle of parent pci bus.
 CONFIG_ACPI 
 Check whether they are in the right area. 
  pcpu.c
  Management physical cpu in dom0, get pcpu info and provide sys interface
  Copyright (c) 2012 Intel Corporation
  Author: Liu, Jinsong <jinsong.liu@intel.com>
  Author: Jiang, Yunhong <yunhong.jiang@intel.com>
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2
  as published by the Free Software Foundation; or, when distributed
  separately from the Linux kernel or incorporated into other
  software packages, subject to the following license:
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this source file (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, andor sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
  @cpu_id: Xen physical cpu logic number
  @flags: Xen physical cpu status flag
  - XEN_PCPU_FLAGS_ONLINE: cpu is online
  - XEN_PCPU_FLAGS_INVALID: cpu is not present
	
	  Xen never offline cpu0 due to several restrictions
	  and assumptions. This basically doesn't add a sys control
	  to user, one cannot attempt to offline BSP.
 the pcpu is onlined 
 The pcpu is offlined 
 pcpu remove would be implicitly done 
 Need hold on xen_pcpu_lock before pcpu list manipulations 
  Caller should hold the xen_pcpu_lock
	
	  Only those at cpu present map has its sys interface.
  Sync dom0's pcpu information with xen hypervisor's
	
	  Boot cpu always have cpu_id 0 in xen
 SPDX-License-Identifier: GPL-2.0-only
   copyright (c) 2006 IBM Corporation
   Authored by: Mike D. Day <ncmike@us.ibm.com>
 ARM only. 
 xen version attributes 
 UUID 
 xen compilation attributes 
 xen properties info 
 SPDX-License-Identifier: GPL-2.0-only
   Copyright 2010
   by Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
  This code provides a IOMMU for Xen PV guests with PCI passthrough.
  PV guests under Xen are running in an non-contiguous memory architecture.
  When PCI pass-through is utilized, this necessitates an IOMMU for
  translating bus (DMA) to virtual and vice-versa and also providing a
  mechanism to have contiguous pages for device drivers operations (say DMA
  operations).
  Specifically, under Xen the Linux idea of pages is an illusion. It
  assumes that pages start at zero and go up to the available memory. To
  help with that, the Linux Xen MMU provides a lookup mechanism to
  translate the page frame numbers (PFN) to machine frame numbers (MFN)
  and vice-versa. The MFN are the "real" frame numbers. Furthermore
  memory is not contiguous. Xen hypervisor stitches memory for guests
  from different pools, which means there is no guarantee that PFN==MFN
  and PFN+1==MFN+1. Lastly with Xen 4.0, pages (in debug mode) are
  allocated in descending order (high to low), meaning the guest might
  never get any MFN's under the 4GB mark.
  Quick lookup value of the bus address of the IOTLB.
	 If the address is outside our domain, it CAN
	  have the same virtual address as another address
	  in our domain. Therefore _only_ check address within our domain.
	
	  Get IO TLB memory from any location.
	
	  And replace that memory with pages under 4GB.
 Min is 2MB 
	
	  Get IO TLB memory from any location.
	
	  And replace that memory with pages under 4GB.
 Min is 2MB 
 CONFIG_X86 
	
	 Ignore region specifiers - the kernel's ideas of
	 pseudo-phys memory layout has nothing to do with the
	 machine physical layout.  We can't allocate highmem
	 because we can't return a pointer to it.
 Convert the size to actually allocated. 
	 On ARM this function returns an ioremap'ped virtual address for
	  which virt_to_phys doesn't return the corresponding physical
	  address. In fact on ARM virt_to_phys only works for kernel direct
	  mapped RAM memory. Also see comment below.
	 At this point dma_handle is the dma address, next we are
	  going to set it to the machine address.
	  Do not use virt_to_phys(ret) because on ARM it doesn't correspond
	 do not use virt_to_phys because on ARM it doesn't return you the
 Convert the size to actually allocated. 
  Map a single buffer of the indicated size for DMA in streaming mode.  The
  physical address to use is returned.
  Once the device is given the dma address, the device owns this memory until
  either xen_swiotlb_unmap_page or xen_swiotlb_dma_sync_single is performed.
	
	  If the address happens to be in the device's DMA window,
	  we can safely return the device addr and not worry about bounce
	  buffering it.
	
	  Oh well, have to allocate and map a bounce buffer.
	
	  Ensure that the address returned is DMA'ble
  Unmap a single streaming mode DMA translation.  The dma_addr and size must
  match what was provided for in a previous xen_swiotlb_map_page call.  All
  other usages are undefined.
  After this call, reads by the cpu to the buffer are guaranteed to see
  whatever the device wrote there.
 NOTE: We use dev_addr here, not paddr! 
  Unmap a set of streaming mode DMA translations.  Again, cpu read rules
  concerning calls here are the same as for swiotlb_unmap_page() above.
  Return whether the given device DMA address mask can be supported
  properly.  For example, if your device can only drive the low 24-bits
  during bus mastering, then you would pass 0x00ffffff as the mask to
  this function.
  Xen balloon driver - enables returningclaiming memory tofrom Xen.
  Copyright (c) 2003, B Dragovic
  Copyright (c) 2003-2004, M Williamson, K Fraser
  Copyright (c) 2005 Dan M. Smith, IBM Corporation
  Copyright (c) 2010 Daniel Kiper
  Memory hotplug support was written by Daniel Kiper. Work on
  it was sponsored by Google under Google Summer of Code 2010
  program. Jeremy Fitzhardinge from Citrix was the mentor for
  this project.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2
  as published by the Free Software Foundation; or, when distributed
  separately from the Linux kernel or incorporated into other
  software packages, subject to the following license:
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this source file (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, andor sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
  Use one extent per PAGE_SIZE to avoid to break down the page into
  multiple frame.
  balloon_thread() state:
  BP_DONE: done or nothing to do,
  BP_WAIT: wait to be rescheduled,
  BP_EAGAIN: error, go to sleep,
  BP_ECANCELED: error, balloon operation canceled.
 Main waiting point for xen-balloon thread. 
 We increasedecrease in batches which fit in a page 
 List of ballooned pages, threaded through the mem_map array. 
 When ballooning out (allocating memory to return to Xen) we don't really
 balloon_append: add the given page to the balloon. 
 Lowmem is re-populated first, so highmem pages go at list tail. 
 balloon_retrieve: rescue a page from the balloon, if it is not empty. 
	
	  No need to reset region to identity mapped since we now
	  know that no IO can be in this region
	
	  Already hotplugged enough pages?  Wait for them to be
	  onlined.
	
	  We don't support PV MMU when Linux and Xen is using
	  different page granularity.
          add_memory() will build page tables for the new memory so
          the p2m must contain invalid entries so the correct
          non-present PTEs will be written.
          If a failure occurs, the original (identity) p2m entries
          are not restored since this region is now known not to
          conflict with any devices.
	
	  add_memory_resource() will call online_pages() which in its turn
	  will call xen_online_page() callback causing deadlock if we don't
	  release balloon_mutex here. Unlocking here is safe because the
	  callers drop the mutex before trying again.
 add_memory_resource() requires the device_hotplug lock 
 CONFIG_XEN_BALLOON_MEMORY_HOTPLUG 
 Relinquish the page back to the allocator. 
	
	  Ensure that ballooned highmem pages don't have kmaps.
	 
	  Do this before changing the p2m as kmap_flush_unused()
	  reads PTEs to obtain pages (and hence needs the original
	  p2m entry).
	
	  Setup the frame, update direct mapping, invalidate P2M,
	  and add to balloon.
  Stop waiting if either state is BP_DONE and ballooning action is
  needed, or if the credit has changed while state is not BP_DONE.
  As this is a kthread it is guaranteed to run as a single instance only.
  We may of course race updates of the target counts (which are protected
  by the balloon lock), or with changes to the Xen hard limit, but we will
  recover from these in time.
 Resets the Xen limit, sets new target, and kicks off processing. 
 No need for lock. Not read-modify-write updates. 
  xen_alloc_unpopulated_pages - get pages that have been ballooned out
  @nr_pages: Number of pages to get
  @pages: pages returned
  @return 0 on success, error otherwise
			
			  We don't support PV MMU when Linux and Xen is using
			  different page granularity.
	
	  NB: free_xenballooned_pages will only subtract pgno pages, but since
	  target_unpopulated is incremented with nr_pages at the start we need
	  to remove the remaining ones also, or accounting will be screwed.
  xen_free_unpopulated_pages - return pages retrieved with get_ballooned_pages
  @nr_pages: Number of pages
  @pages: pages to return
 The balloon may be too large now. Shrink it if needed. 
	
	  If the amount of usable memory has been limited (e.g., with
	  the 'mem' command line parameter), don't add pages beyond
	  this limit.
		 totalram_pages and totalhigh_pages do not
		   include the boot-time balloon extension, so
		
		  Initialize the balloon with pages from the extra memory
		  regions (see archx86xensetup.c).
 Init the xen-balloon driver. 
 PV guests don't need to wait. 
  MMU operations common to all auto-translated physmap guests.
  Copyright (C) 2015 Citrix Systems R&D Ltd.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2
  as published by the Free Software Foundation; or, when distributed
  separately from the Linux kernel or incorporated into other
  software packages, subject to the following license:
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this source file (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, andor sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
 Break down the pages in 4KB chunk and call fn for each gfn 
 foreign domain's gfn 
 Number of foreign gfn left to map 
 Hypercall parameters 
 Iterator 
 info->err_ptr expect to have one error status per Xen PFN 
	
	  Note: The hypercall will return 0 in most of the case if even if
	  all the fgmfn are not mapped. We still have to update the pte
	  as the userspace may decide to continue.
	 Kept here for the purpose of making sure code doesn't break
  xen_xlate_map_ballooned_pages - map a new set of ballooned pages
  @gfns: returns the array of corresponding GFNs
  @virt: returns the virtual address of the mapped region
  @nr_grant_frames: number of GFNs
  @return 0 on success, error otherwise
  This allocates a set of ballooned pages and maps them into the
  kernel's address space.
 Used by the privcmd module, but has to be built-in on ARM 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2012 by Oracle Inc
  Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
  This code borrows ideas from
  https:lore.kernel.orglkml1322673664-14642-6-git-send-email-konrad.wilk@oracle.com
  so many thanks go to Kevin Tian <kevin.tian@intel.com>
  and Yu Ke <ke.yu@intel.com>.
  Note: Do not convert the acpi_id below to cpumask_var_t or use cpumask_bit
  - as those shrink to nr_cpu_bits (which is dependent on possible_cpu), which
  can be less than what we want to put in. Instead use the 'nr_acpi_bits'
  which is dynamically computed based on the MADT or x2APIC table.
 Mutex to protect the acpi_ids_done - for CPU hotplug use. 
 Which ACPI ID we have processed from 'struct acpi_processor'. 
 Which ACPI ID exist in the SSDTDSDT processor definitions. 
 And if there is an _CST definition (or a PBLK) for the ACPI IDs 
 Which ACPI P-State dependencies for a enumerated processor 
 NATIVE_CSTATE_BEYOND_HALT 
 VENDOR_INTEL 
		 EINVAL means the ACPI ID is incorrect - meaning the ACPI
		  table is referencing a non-existing CPU - which can happen
 Fortunatly for us, they are both the same size 
	 This information is enumerated only if acpi_processor_preregister_performance
	  has been called.
	 'acpi_processor_preregister_performance' does not parse if the
	  num_processors <= 1, but Xen still requires it. Do it manually here.
	 It would be nice if you could just do 'memcpy(pct, dst_pct') but
	  sadly the Xen structure did not have the proper padding so the
	  descriptor field takes two (dst_pct) bytes instead of one (pct).
		 EINVAL means the ACPI ID is incorrect - meaning the ACPI
		  table is referencing a non-existing CPU - which can happen
 The max_present is the same irregardless of the xen_cpuid 
 Slack for CPU hotplug support. 
  The read_acpi_id and check_acpi_ids are there to support the Xen
  oddity of virtual CPUs != physical CPUs in the initial domain.
  The user can supply 'xen_max_vcpus=X' on the Xen hypervisor line
  which will band the amount of CPUs the initial domain can see.
  In general that is OK, except it plays havoc with any of the
  for_each_[present|online]_cpu macros which are banded to the virtual
  CPU amount.
	 There are more ACPI Processor objects than in x2APIC or MADT.
 OK, There is a ACPI Processor object 
 It has P-state dependencies 
 .. and it has a C-state 
 OK, done this once .. skip to uploading 
	 All online CPUs have been processed at this stage. Now verify
	  whether in fact "online CPUs" == physical CPUs.
 Mask out C-states if there are no _CST or PBLK 
 num_entries is non-zero if we evaluated _PSD 
 acpi_perf_data is a pointer to percpu data. 
 Freeing a NULL pointer is OK, and alloc_percpu zeroes. 
 APIC ID );
	
	  xen_upload_processor_pm_data() calls non-atomic code.
	  However, the context for xen_acpi_processor_resume is syscore
	  with only the boot CPU online and in an atomic context.
	 
	  So defer the upload for some point safer.
 Do initialization in ACPI core. It is OK to fail here. 
 Freeing a NULL pointer is OK: alloc_percpu zeroes. 
 We want to be loaded before the CPU freq scaling drivers are loaded.
 SPDX-License-Identifier: GPL-2.0
          memremap will build page tables for the new memory so
          the p2m must contain invalid entries so the correct
          non-present PTEs will be written.
          If a failure occurs, the original (identity) p2m entries
          are not restored since this region is now known not to
          conflict with any devices.
  xen_alloc_unpopulated_pages - alloc unpopulated pages
  @nr_pages: Number of pages
  @pages: pages returned
  @return 0 on success, error otherwise
  xen_free_unpopulated_pages - return unpopulated pages
  @nr_pages: Number of pages
  @pages: pages to return
	
	  Initialize with pages from the extra memory regions (see
	  archx86xensetup.c).
 SPDX-License-Identifier: GPL-2.0
  gntalloc.c
  Device for creating grant references (in user-space) that may be shared
  with other domains.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  This driver exists to allow userspace programs in Linux to allocate kernel
  memory that will later be shared with another domain.  Without this device,
  Linux userspace programs cannot create grant references.
  How this stuff works:
    X -> granting a page to Y
    Y -> mapping the grant from X
    1. X uses the gntalloc device to allocate a page of kernel memory, P.
    2. X creates an entry in the grant table that says domid(Y) can access P.
       This is done without a hypercall unless the grant table needs expansion.
    3. X gives the grant reference identifier, GREF, to Y.
    4. Y maps the page, either directly into kernel memory for use in a backend
       driver, or via a the gntdev device to map into the address space of an
       application running in Y. This is the first point at which Xen does any
       tracking of the page.
    5. A program in X mmap()s a segment of the gntalloc device that corresponds
       to the shared page, and can now communicate with Y over the shared page.
  NOTE TO USERSPACE LIBRARIES:
    The grant allocation and mmap()ing are, naturally, two separate operations.
    You set up the sharing by calling the create ioctl() and then the mmap().
    Teardown requires munmap() and either close() or ioctl().
  WARNING: Since Xen does not allow a guest to forcibly end the use of a grant
  reference, this device can be used to consume kernel memory by leaving grant
  references mapped by another domain when an application exits. Therefore,
  there is a global limit on the number of pages that can be allocated. When
  all references to the page are unmapped, it will be freed during the next
  grant operation.
 Bits 0-11: Offset of the byte to clear 
 Bits 12-13: Unmap notification flags 
 Port (event channel) to notify 
 Metadata on a grant reference. 
 list entry gref_list 
 list entry file->list, if open 
 The shared page 
 File offset for mmap() 
 Use count - when zero, waiting on Xen 
 The grant reference number 
 Unmap notification 
 Grant foreign access to the page. 
 Add to gref lists. 
	 It's possible for the target domain to map the just-allocated grant
	  references by blindly guessing their IDs; if this is done, then
	  __del_gref will leave them in the queue_gref list. They need to be
	  added to the global list so that we can free them when they are no
	  longer referenced.
 finds contiguous grant references in a file, returns the first 
  -------------------------------------
   File operations.
  -------------------------------------
	 Clean up pages that were at zero (local) users but were still mapped
	  by remote domains. Since those pages count towards the limit that we
	  are about to enforce, removing them here is a good idea.
	 Once we finish add_grefs, it is unsafe to touch the new reference,
	  since it is possible for a concurrent ioctl to remove it (by guessing
	  its index). If the userspace application doesn't provide valid memory
	  to write the IDs to, then it will need to close the file in order to
	  release - which it will do by segfaulting when it tries to access the
	  IDs to close them.
		 Remove from the file list only, and decrease reference count.
		  The later call to do_cleanup() will remove from gref_list and
		  free the memory if the pages aren't mapped anywhere.
	 We need to grab a reference to the event channel we are going to use
	  to send the notify before releasing the reference we may already have
	  (if someone has called this ioctl twice). This is required so that
	  it is possible to change the clear_byte part of the notification
	  without disturbing the event channel part, which may now be the last
	  reference to that event channel.
  -------------------------------------
  Module creationdestruction.
  -------------------------------------
  Xen balloon driver - enables returningclaiming memory tofrom Xen.
  Copyright (c) 2003, B Dragovic
  Copyright (c) 2003-2004, M Williamson, K Fraser
  Copyright (c) 2005 Dan M. Smith, IBM Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2
  as published by the Free Software Foundation; or, when distributed
  separately from the Linux kernel or incorporated into other
  software packages, subject to the following license:
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this source file (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, andor sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
 React to a change in the target key 
 The balloon driver will take care of adding memory now. 
 This is ok (for domain0 at least) - so just return 
	 The given memorytarget value is in KiB, so it needs converting to
	  pages. PAGE_SHIFT converts bytes to pages, hence PAGE_SHIFT - 10.
  acpi.c
  acpi file for domain 0 kernel
  Copyright (c) 2011 Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
  Copyright (c) 2011 Yu Ke ke.yu@intel.com
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2
  as published by the Free Software Foundation; or, when distributed
  separately from the Linux kernel or incorporated into other
  software packages, subject to the following license:
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this source file (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, andor sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
 SPDX-License-Identifier: GPL-2.0 OR MIT
  privcmd-buf.c
  Mmap of hypercall buffers.
  Copyright (c) 2018 Juergen Gross
 SPDX-License-Identifier: GPL-2.0-only
  Handle extern requests for shutdown, reboot and sysrq
	 Code 3 is SHUTDOWN_CRASH, which we don't use because the domain can only
	   report a crash, not be instructed to crash!
	   HALT is the same as POWEROFF, as far as we're concerned.  The tools use
 Ignore multiple shutdown requests. 
 Resume console as early as possible. 
 CONFIG_HIBERNATE_CALLBACKS 
 Don't do it when we are haltingrebooting. 
 ? 
 Ignore read errors and empty reads. 
 Only acknowledge commands which we are prepared to handle. 
		
		  The Xenstore watch fires directly after registering it and
		  after a suspendresume cycle. So ENOENT is no error but
		  might happen in those cases. ERANGE is observed when we get
		  an empty value (''), this happens when we acknowledge the
		  request by writing '\0' below.
 SPDX-License-Identifier: GPL-2.0-only
  platform-pci.c
  Xen platform PCI device driver
  Authors: ssmith@xensource.com and stefano.stabellini@eu.citrix.com
  Copyright (c) 2005, Intel Corporation.
  Copyright (c) 2007, XenSource Inc.
  Copyright (c) 2010, Citrix
 ISA IRQ 
 We don't know the GSI. Specify the PCI INTx line instead. 
 PCI INTx identifier 
		
		  It doesn't strictly have to run on CPU0 but it sure
		  as hell better process the event channel ports delivered
		  to CPU0.
 SPDX-License-Identifier: GPL-2.0-only
  xen-acpi-pad.c - Xen pad interface
  Copyright (c) 2012, Intel Corporation.
     Author: Liu, Jinsong <jinsong.liu@intel.com>
  Query firmware how many CPUs should be idle
  return -1 on failure
 rev 1 
 Only DOM0 is responsible for Xen acpi pad 
 Only Xen4.2 or later support Xen acpi pad 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015, Linaro Limited, Shannon Zhao
			
			  The regions are always mapped 1:1 to DOM0 and this is
			  fine because the memory map for DOM0 is the same as
			  the host (except for the RAM).
  Client-facing interface for the Xenbus driver.  In other words, the
  interface between the Xenbus and the device-specific code, be it the
  frontend or the backend of that driver.
  Copyright (C) 2005 XenSource Ltd
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2
  as published by the Free Software Foundation; or, when distributed
  separately from the Linux kernel or incorporated into other
  software packages, subject to the following license:
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this source file (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, andor sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
 Why do we need two arrays? See comment of __xenbus_map_ring 
  xenbus_watch_path - register a watch
  @dev: xenbus device
  @path: path to watch
  @watch: watch to register
  @callback: callback to register
  Register a @watch on the given path, using the given xenbus_watch structure
  for storage, and the given @callback function as the callback.  Return 0 on
  success, or -errno on error.  On success, the given @path will be saved as
  @watch->node, and remains the caller's to free.  On error, @watch->node will
  be NULL, the device will switch to %XenbusStateClosing, and the error will
  be saved in the store.
  xenbus_watch_pathfmt - register a watch on a sprintf-formatted path
  @dev: xenbus device
  @watch: watch to register
  @callback: callback to register
  @pathfmt: format of path to watch
  Register a watch on the given @path, using the given xenbus_watch
  structure for storage, and the given @callback function as the callback.
  Return 0 on success, or -errno on error.  On success, the watched path
  (@path@path2) will be saved as @watch->node, and becomes the caller's to
  kfree().  On error, watch->node will be NULL, so the caller has nothing to
  free, the device will switch to %XenbusStateClosing, and the error will be
  saved in the store.
	 We check whether the state is currently set to the given value, and
	   if not, then the state is set.  We don't want to unconditionally
	   write the given state, because we don't want to fire watches
	   unnecessarily.  Furthermore, if the node has gone, we don't write
	   to it, as the device will be tearing down, and we don't want to
	   resurrect that directory.
	   Note that, because of this cached value of our state, this
	   function will not take a caller's Xenstore transaction
	   (something it was trying to in the past) because dev->state
	   would not get reset if the transaction was aborted.
  xenbus_switch_state
  @dev: xenbus device
  @state: new state
  Advertise in the store a change of the given driver to the given new_state.
  Return 0 on success, or -errno on error.  On error, the device will switch
  to XenbusStateClosing, and the error will be saved in the store.
  xenbus_dev_error
  @dev: xenbus device
  @err: error to report
  @fmt: error message format
  Report the given negative errno into the store, along with the given
  formatted message.
  xenbus_dev_fatal
  @dev: xenbus device
  @err: error to report
  @fmt: error message format
  Equivalent to xenbus_dev_error(dev, err, fmt, args), followed by
  xenbus_switch_state(dev, XenbusStateClosing) to schedule an orderly
  closedown of this driver and its peer.
  Equivalent to xenbus_dev_fatal(dev, err, fmt, args), but helps
  avoiding recursion within xenbus_switch_state.
  xenbus_grant_ring
  @dev: xenbus device
  @vaddr: starting virtual address of the ring
  @nr_pages: number of pages to be granted
  @grefs: grant reference array to be filled in
  Grant access to the given @vaddr to the peer of the given device.
  Then fill in @grefs with grant references.  Return 0 on success, or
  -errno on error.  On error, the device will switch to
  XenbusStateClosing, and the error will be saved in the store.
  Allocate an event channel for the given xenbus_device, assigning the newly
  created local port to port.  Return 0 on success, or -errno on error.  On
  error, the device will switch to XenbusStateClosing, and the error will be
  saved in the store.
  Free an existing event channel. Returns 0 on success or -errno on error.
  xenbus_map_ring_valloc
  @dev: xenbus device
  @gnt_refs: grant reference array
  @nr_grefs: number of grant references
  @vaddr: pointer to address to be filled out by mapping
  Map @nr_grefs pages of memory into this domain from another
  domain's grant table.  xenbus_map_ring_valloc allocates @nr_grefs
  pages of virtual address space, maps the pages to that address, and
  sets vaddr to that address.  Returns 0 on success, and -errno on
  error. If an error is returned, device will switch to
  XenbusStateClosing and the error message will be saved in XenStore.
 N.B. sizeof(phys_addr_t) doesn't always equal to sizeof(unsigned
  long), e.g. 32-on-64.  Caller is responsible for preparing the
  xenbus_unmap_ring
  @dev: xenbus device
  @handles: grant handle array
  @nr_handles: number of handles in the array
  @vaddrs: addresses to unmap
  Unmap memory in this domain that was imported from another domain.
  Returns 0 on success and returns GNTST_ on error
  (see xenincludeinterfacegrant_table.h).
  xenbus_unmap_ring_vfree
  @dev: xenbus device
  @vaddr: addr to unmap
  Based on Rusty Russell's skeleton driver's unmap_page.
  Unmap a page of memory in this domain that was imported from another domain.
  Use xenbus_unmap_ring_vfree if you mapped in your memory with
  xenbus_map_ring_valloc (it will free the virtual address space).
  Returns 0 on success and returns GNTST_ on error
  (see xenincludeinterfacegrant_table.h).
  xenbus_read_driver_state
  @path: path for driver
  Return the state of the driver rooted at the given store path, or
  XenbusStateUnknown if no state can be read.
  Talks to Xen Store to figure out what devices we have (backend half).
  Copyright (C) 2005 Rusty Russell, IBM Corporation
  Copyright (C) 2005 Mike Wray, Hewlett-Packard
  Copyright (C) 2005, 2006 XenSource Ltd
  Copyright (C) 2007 Solarflare Communications, Inc.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2
  as published by the Free Software Foundation; or, when distributed
  separately from the Linux kernel or incorporated into other
  software packages, subject to the following license:
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this source file (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, andor sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
 backend<type><fe-uuid><id> => <type>-<fe-domid>-<id> 
 stuff we want to pass to sbinhotplug 
 backend<typename><frontend-uuid><name> 
 backend<typename><frontend-domid> 
 backendtype<frontend><id> 
 Enumerate devices in xenstore and watch for changes. 
  Returns 0 always because we are using shrinker to only detect memory
  pressure.
 Register ourselves with the kernel bus subsystem 
  Driver giving user-space access to the kernel's xenbus connection
  to xenstore.
  Copyright (c) 2005, Christian Limpach
  Copyright (c) 2005, Rusty Russell, IBM Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2
  as published by the Free Software Foundation; or, when distributed
  separately from the Linux kernel or incorporated into other
  software packages, subject to the following license:
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this source file (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, andor sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
  Changes:
  2008-10-07  Alex Zeffertt    Replaced procxenxenbus with xenfs filesystem
                               and procxen compatibility mount point.
                               Turned xenfs into a loadable module.
  An element of a list of outstanding transactions, for which we're
  still waiting a reply.
  A buffer of data on the queue.
	
	  msgbuffer_mutex is held while partial requests are built up
	  and complete requests are acted on.  It therefore protects
	  the "transactions" and "watches" lists, and the partial
	  request length and buffer.
	 
	  reply_mutex protects the reply being built up to return to
	  usermode.  It nests inside msgbuffer_mutex but may be held
	  alone during a watch callback.
 In-progress transactions 
 Active watches. 
 Partial request. 
 Response queue. 
 Read out any raw xenbus messages queued up. 
 Clear out buffer if it has been consumed 
  Add a buffer to the queue.  Caller must hold the appropriate lock
  if the queue is not local.  (Commonly the caller will build up
  multiple queued buffers on a temporary local list, and then add it
  to the appropriate list under lock once all the buffers have een
  successfully allocated.)
  Free all the read_buffer s on a list.
  Caller must have sole reference to list.
 success: pass reply list onto watcher 
	
	  No need for locking here because there are no other users,
	  by definition.
	
	  We might be called in xenbus_thread().
	  Use workqueue to avoid deadlock.
 Success.  Synthesize a reply to say all is OK. 
	
	  We're expecting usermode to be writing properly formed
	  xenbus messages.  If they write an incomplete message we
	  buffer it up.  Once it is complete, we act on it.
	
	  Make sure concurrent writers can't stomp all over each
	  other's messages and make a mess of our partial message
	  buffer.  We don't make any attemppt to stop multiple
	  writers from making a mess of each other's incomplete
	  messages; we're just trying to guarantee our own internal
	  consistency and make sure that single writes are handled
	  atomically.
 Get this out of the way early to avoid confusion 
 Can't write a xenbus message larger we can buffer 
 On error, dump existing buffer 
 Deal with a partial copy. 
 Return if we haven't got a full message yet 
 not even the header yet 
	 If we're expecting a message that's larger than we can
 incomplete data portion 
	
	  OK, now we have a complete message.  Do something with it.
 (Un)Ask for some path to be watched for changes 
 Send out a transaction 
 Buffered message consumed 
 SPDX-License-Identifier: GPL-2.0-only
 device<type><id> => <type>-<id> 
 device<typename><name> 
 ignore console0 
	
	  If xenstored is running in this domain, we cannot access the backend
	  state at the moment, so we need to defer xenbus_dev_resume
 devicetype<id> 
 We watch for devices appearing and vanishing. 
	
	  A device with no driver will never connect. We care only about
	  devices which should currently be in the process of connecting.
 Is this search limited to a particular driver? 
		 With older QEMU, for PVonHVM guests the guest config files
		  could contain: vfb = [ 'vnc=1, vnclisten=0.0.0.0']
		  which is nonsensical as there is no PV FB (there can be
 ignore PV[KBB+FB] );
 Is this operation limited to a particular driver? 
 Information only: is this too noisy? 
 We only wait for device setup after most initcalls have run. 
  On a 5-minute timeout, wait for all devices currently configured.  We need
  to do this to guarantee that the filesystems and  or network devices
  needed for boot are available, before we can allow the boot to proceed.
  This needs to be on a late_initcall, to happen after the frontend device
  drivers have been initialised, but before the root fs is mounted.
  A possible improvement here would be to have the tools add a per-device
  flag to the store entry, indicating whether it is needed at boot time.
  This would allow people who knew what they were doing to accelerate their
  boot slightly, but of course needs tools or manual intervention to set up
  those flags correctly.
 Skips PVKB and PVFB check.
 If this driver is loaded as a module wait for devices to attach. 
  Reset frontend if it is in Connected or Closed state.
  Wait for backend to catch up.
  State Connected happens during kdump, Closed after kexec.
 fall through to forward backend to state XenbusStateInitialising 
 reset devices in Connected or Closed state 
 Enumerate devices in xenstore and watch for changes. 
 Register ourselves with the kernel bus subsystem 
  Talks to Xen Store to figure out what devices we have.
  Copyright (C) 2005 Rusty Russell, IBM Corporation
  Copyright (C) 2005 Mike Wray, Hewlett-Packard
  Copyright (C) 2005, 2006 XenSource Ltd
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2
  as published by the Free Software Foundation; or, when distributed
  separately from the Linux kernel or incorporated into other
  software packages, subject to the following license:
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this source file (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, andor sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
 If something in array of ids matches this device, return it. 
	 Protect us against watches firing on old details when the otherend
	
	  Ignore xenbus transitions during shutdown. This prevents us doing
	  work that can fail e.g., when the rootfs is gone.
	
	  If the toolstack has forced the device state to closing then set
	  the state to closed now to allow it to be cleaned up.
	  Similarly, if the driver does not support re-bind, set the
	  closed.
 Match the info->nodename path, or any subdirectory of that path. 
 If the node name is longer, ensure it really is a subdirectory. 
		 Device is not new, so ignore it.  This can happen if a
 Copy the strings into the extra space. 
 Register with generic device framework. 
 backend<type>... or device<type>... 
 Do nothing 
 A flag to determine if xenstored is 'ready' (i.e. has started) 
	
	  In the HVM case, xenbus_init() deferred its call to
	  xs_init() in case callbacks were not operational yet.
	  So do it now.
 Notify others that xenstore is up 
  Returns true when XenStore init must be deferred in order to
  allow the PCI platform device to be initialised, before we
  can actually have event channel interrupts working.
	
	  We actually just want to wait for any trigger of xb_waitq,
	  and run xenbus_probe() the moment it occurs.
	
	  Probe XenBus here in the XS_PV case, and also XS_HVM unless we
	  need to wait for the platform PCI device to come up.
	
	  For XS_LOCAL, spawn a thread which will wait for xenstored
	  or a xenstore-stubdom to be started, then probe. It will be
	  triggered when communication starts happening, by waiting
	  on xb_waitq.
	
	  If xenbus_probe_initcall() deferred the xenbus_probe()
	  due to the callback not functioning yet, we can do it now.
 Set up event channel for xenstored which is run as a local process
  (this is normally used only in dom0)
 Allocate Xenstore page 
 Next allocate a local port which xenstored can bind to 
	
	  HVM domains may not have a functional callback yet. In that
	  case let xs_init() be called from xenbus_probe(), which will
	  get invoked at an appropriate time.
	
	  Create xenfs mountpoint in proc for compatibility with
	  utilities that expect to find "xenbus" under "procxen".
 SPDX-License-Identifier: GPL-2.0
	 If xenstored_ready is nonzero, that means we have already talked to
	  xenstore and set up watches. These watches will be restored by
	  xs_resume, but that requires communication over the port established
	  below that is not visible to anyone until the ioctl returns.
	 
	  This can be resolved by splitting the ioctl into two parts
	  (postponing the resume until xenstored is active) but this is
	  unnecessarily complex for the intended use where xenstored is only
	  started once - so return -EEXIST if it's already running.
 writable );
  xenbus_comms.c
  Low level code to talks to Xen Store: ringbuffer and event channel.
  Copyright (C) 2005 Rusty Russell, IBM Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2
  as published by the Free Software Foundation; or, when distributed
  separately from the Linux kernel or incorporated into other
  software packages, subject to the following license:
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this source file (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, andor sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
 A list of replies. Currently only one will ever be outstanding. 
 A list of write requests. 
 Protect xenbus reader thread against saverestore. 
  xb_write - low level write
  @data: buffer to send
  @len: length of buffer
  Returns number of bytes written or -err.
 Read indexes, then verify. 
 Must write data after reading the consumer index. 
 Other side must not see new producer until data is there. 
 Implies mb(): other side will see the updated producer. 
 Read indexes, then verify. 
 Must read data after reading the producer index. 
 Other side must not see free space until we've copied out 
 Implies mb(): other side will see the updated consumer. 
		
		  We must disallow saverestore while reading a message.
		  A partial read across sr leaves us out of sync with
		  xenstored.
		  xs_response_mutex is locked as long as we are processing one
		  message. state.in_msg will be true as long as we are holding
		  the lock here.
 We raced with saverestore: pending data 'gone'. 
 write body, then update state 
 write err, then update state 
  xb_init_comms - Set up interrupt handler off store event channel.
 breaks kdump 
 Already have an irq; assume we're resuming 
  xenbus_xs.c
  This is the kernel equivalent of the "xs" library.  We don't need everything
  and we use xenbus_comms for communication.
  Copyright (C) 2005 Rusty Russell, IBM Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2
  as published by the Free Software Foundation; or, when distributed
  separately from the Linux kernel or incorporated into other
  software packages, subject to the following license:
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this source file (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, andor sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
  Framework to protect suspendresume handling against normal Xenstore
  message handling:
  During suspendresume there must be no open transaction and no pending
  Xenstore request.
  New watch events happening in this time can be ignored by firing all watches
  after resume.
 Lock protecting enterexit critical region. 
 Number of users in critical region (protected by xs_state_lock). 
 Suspend handler waiting or already active (protected by xs_state_lock)? 
 Unique Xenstore request id (protected by xs_state_lock). 
 Wait queue for all callers waiting for critical region to become usable. 
 Wait queue for suspend handling waiting for critical region being empty. 
 List of registered watches, and a lock to protect it. 
 List of pending watch callback events, and a lock to protect it. 
 Protect watch (de)register against saverestore. 
  Details of the xenwatch callback kernel thread. The thread waits on the
  watch_events_waitq for work to do (queued on watch_events list). When it
  wakes up it acquires the xenwatch_mutex before reading the list and
  carrying out work.
		 FIXME: Could check that the remote domain is alive,
 read req->state before all other fields 
 Make sure to reread req->state each time. 
			
			  If we are in the process of being shut-down there is
			  no point of trying to contact XenBus - it is either
			  killed (xenstored application) or the other domain
			  has been killed or is unreachable.
 Save the caller req_id and restore it later in the reply 
 Send message to xs, get kmalloc'ed reply.  ERR_PTR() on error. 
 Simplified version of xs_talkv: single message. 
 Many commands only need an ack, don't care what it says. 
 Return the path to dir with name appended. Buffer must be kfree()'ed. 
 Count the strings. 
 Transfer to one big alloc for easy freeing. 
 Check if a path exists. Return 1 if it does. 
 Get the value of a single file.
  Returns a kmalloced value: call free() on it after use.
  len indicates length in bytes.
 Write the value of a single file.
  Returns -err on failure.
 Create a new directory. 
 Destroy a file or directory (directories must be empty). 
 Start a transaction: changes by others will not be seen during this
  transaction, and changes will not be visible to others until end.
 End a transaction.
  If abandon is true, transaction is discarded instead of committed.
 Single read and scanf: returns -errno or num scanned. 
 Distinctive errno. 
 Read an (optional) unsigned value. 
 Single printf and write: returns -errno or 0. 
 Takes tuples of names, scanf-style args, and void , NULL terminated. 
  Certain older XenBus toolstack cannot handle reading values that are
  not populated. Some Xen 3.4 installation are incapable of doing this
  so if we are running on anything older than 4 do not attempt to read
  controlplatform-feature-xs_reset_watches.
 Register callback to watch this node. 
 Pointer in ascii is the token. 
	 Make sure there are no callbacks running currently (unless
 Cancel pending watch events. 
 No need for watches_lock: the xs_watch_rwsem is sufficient. 
  Wake up all threads waiting for a xenstore reply. In case of shutdown all
  pending replies will be marked as "aborted" in order to let the waiters
  return in spite of xenstore possibly no longer being able to reply. This
  will avoid blocking shutdown by a thread waiting for xenstore but being
  necessary for shutdown processing to proceed.
 Initialize the shared memory rings to talk to xenstored 
 shutdown watches for kexec boot 
 SPDX-License-Identifier: GPL-2.0-only
   xenfs.c - a filesystem for passing info between the a domain and
   the hypervisor.
  2008-10-07  Alex Zeffertt    Replaced procxenxenbus with xenfs filesystem
                               and procxen compatibility mount point.
                               Turned xenfs into a loadable module.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Hypervisor may have different name length 
 Grab next output page from the hypervisor 
	
	  If hypervisor's symbol didn't fit into the buffer then allocate
	  a larger buffer and try again.
 Rewind 
 End of symbols 
 SPDX-License-Identifier: GPL-2.0
  PCI Backend - Handle special overlays for broken devices.
  Author: Ryan Wilson <hap9@epoch.ncsc.mil>
  Author: Chris Bookholt <hap10@epoch.ncsc.mil>
 SPDX-License-Identifier: GPL-2.0
  PCI Backend - Provides restricted access to the real PCI bus topology
                to the frontend
    Author: Ryan Wilson <hap9@epoch.ncsc.mil>
 Access to dev_list must be protected by lock 
 Publish this device. 
		 Only publish this device as a root if none of its
		  parent bridges are exported
 SPDX-License-Identifier: GPL-2.0
  PCI Backend Xenbus Setup - handles setup with frontend and xend
    Author: Ryan Wilson <hap9@epoch.ncsc.mil>
 Ensure the guest can't trigger our handler before removing devices 
	 If the driver domain started an op, make sure we complete it
	 N.B. This calls pcistub_put_pci_dev which does the FLR on all
 Make sure we only do this setup once 
 Wait for frontend to state that it has published the configuration 
 If configuration didn't get read correctly, wait longer 
 Note: The PV protocol uses %02x, don't change it 
	 TODO: It'd be nice to export a bridge and have all of its children
	  get exported with it. This may be best done in xend (which will
	  have to calculate resource usage anyway) but we probably want to
	  put something in here to ensure that if a bridge gets given to a
	  driver domain, that all devices under that bridge are not given
	  to other driver domains (as he who controls the bridge can disable
	  it and stop the other devices from working).
	 N.B. This ends up calling pcistub_put_pci_dev which ends up
 use the lock. );
 Verify that we haven't already published this pci root 
 Publish pci roots. 
			 TODO: If at some point we implement support for pci
			  root hot-remove on pcifront side, we'll need to
			  remove unnecessary xenstore nodes of pci roots here.
 Make sure we only reconfigure once. 
		 pcifront switched its state from reconfiguring to connected.
		  Then switch to connected state.
 if not online 
 Get configuration from xend (if available now) 
	 It's possible we could get the call to setup twice, so make sure
	  we're not already connected.
 Switch substate of this device. 
 see if pcifront is already configured (if not, we'll wait) 
		
		  We typically move to Initialised when the first device was
		  added. Hence subsequent devices getting added may need
		  reconfiguring.
 wait for xend to configure us 
 watch the backend node for backend configuration information 
	 We need to force a call to our callback here in case
	  xend already configured us!
 SPDX-License-Identifier: GPL-2.0
  PCI Backend - Provides a Virtual PCI bus (with real devices)
                to the frontend
    Author: Ryan Wilson <hap9@epoch.ncsc.mil>
 Access to dev_list must be protected by lock 
	
	  Keep multi-function devices together on the virtual PCI bus, except
	  that we want to keep virtual functions at func 0 on their own. They
	  aren't multi-function devices and hence their presence at func 0
	  may cause guests to not scan the other functions.
 Assign to a new slot on the virtual PCI bus 
 Publish this device. 
 The Virtual PCI bus has only one root 
 SPDX-License-Identifier: GPL-2.0
  PCI Backend - Handles the virtual fields found on the capability lists
                in the configuration space.
  Author: Ryan Wilson <hap9@epoch.ncsc.mil>
 If the device has the capability found above, add these fields 
 encompass PCI_CAP_LIST_ID & PCI_CAP_LIST_NEXT 
 Disallow writes to the vital product data 
 PM_OK_BITS specifies the bits that the driver domain is allowed to change.
 Let pci core handle the power management change 
 Ensure PMEs are disabled 
 bit for enabling MSIMSI-X 
 interrupt type for exclusiveness check 
 don't allow enabling together with other interrupt types 
 SPDX-License-Identifier: GPL-2.0
  PCI Backend - Functions for creating a virtual configuration space for
                exported PCI Devices.
                It's dangerous to allow PCI Driver Domains to change their
                device's resources (memory, io ports, interrupts). We need to
                restrict changes to certain PCI Configuration registers:
                BARs, INTERRUPT_PIN, most registers in the header...
  Author: Ryan Wilson <hap9@epoch.ncsc.mil>
 This is where xen_pcibk_read_config_byte, xen_pcibk_read_config_word,
 Validate request (no un-aligned requests) 
	 if read fails for any reason, return 0
 Get the real value first, then modify as appropriate 
			 handled is set true here, but not every byte
			  may have been written! Properly detecting if
			  every byte is handled is unnecessary as the
			  flag is used to detect devices that need
			  special helpers to work correctly.
		 By default, anything not specificially handled above is
		  read-only. The permissive flag changes this behavior so
		  that anything not specifically handled above is writable.
		  This means that some fields may still be read-only because
		  they have entries in the config_field list that intercept
	
	  Do not trust dev->msi(x)_enabled here, as enabling could be done
	  bypassing the pci_msi functions, by the qemu.
 silently ignore duplicate fields 
 This sets up the device's virtual configuration space to keep track of
  certain registers (like the base address registers (BARs) so that we can
  keep the client from manipulating them directly.
 SPDX-License-Identifier: GPL-2.0
  PCI Backend Operations - respond to PCI requests from Frontend
    Author: Ryan Wilson <hap9@epoch.ncsc.mil>
 Ensure a device is has the fake IRQ handler "turned onoff" and is
  ready to be exported. This MUST be run after xen_pcibk_reset_device
  which does the actual PCI device enabledisable.
 We don't deal with bridges 
 Asked to disable, but ISR isn't runnig 
	 Squirrel away the IRQs in the dev_data. We need this
	  bc when device transitions to MSI, the dev->irq is
	  overwritten with the MSI vector.
	
	  SR-IOV devices in all use MSI-X and have no legacy
	  interrupts, so inhibit creating a fake IRQ handler for them.
		
		  The MSI or MSI-X should not have an IRQ handler. Otherwise
		  if the guest terminates we BUG_ON in free_msi_irqs.
 Ensure a device is "turned off" and ready to be exported.
  (Also see xen_pcibk_config_reset to ensure virtual configuration space is
  ready to be re-exported)
 reset device );
 Disable devices (but not bridges) 
		 The guest could have been abruptly killed without
	 The value the guest needs is actually the IDT vector, not the
	
	  PCI_COMMAND_MEMORY must be enabled, otherwise we may not be able
	  to access the BARs where the MSI-X entries reside.
	  But VF devices are unique in which the PF needs to be checked.
	
	  SR-IOV devices (which don't have any legacy IRQ) have
	  an undefined IRQ value of zero.
 Now the same evtchn is used for both pcifront conf_read_write request
 as well as pcie aer front end ack. We use a new work_queue to schedule
 xen_pcibk conf_read_write service for avoiding confict with aer_core
 do_recovery job which also use the system default work_queue
	 Check that frontend is requesting an operation and that we are not
	_XEN_PCIB_active should have been cleared by pcifront. And also make
 EOI if there was nothing to do. 
 Performing the configuration space readswrites must not be done in atomic
  context because some of the pci_ functions can sleep (mostly due to ACPI
  use of semaphores). This function is intended to be called from a work
 Transition detected 
 no reset );
 Tell the driver domain that we're done. 
 Mark that we're done. 
 after clearing PCIF_active 
 before final check for work 
 IRQs might come in before pdev->evtchn_irq is written. 
 SPDX-License-Identifier: GPL-2.0
  PCI Backend - Handles the virtual fields in the configuration space headers.
  Author: Ryan Wilson <hap9@epoch.ncsc.mil>
 Bits guests are allowed to control in permissive mode. 
 Do not allow enabling INTx together with MSI or MSI-X. 
 Only allow the guest to control certain bits. 
	 A write to obtain the length must happen as a 32-bit write.
	  This does not (yet) support writing individual bytes
 Allow restoration of bar value. 
 Do we need to support enablingdisabling the rom address here? 
 For the BARs, only allow writes which write ~0 or
  the correct resource information
  (Needed for when the driver probes the resource usage)
	 A write to obtain the length must happen as a 32-bit write.
	  This does not (yet) support writing individual bytes
 Allow restoration of bar value. 
			
			  Use ">> 16 >> 16" instead of direct ">> 32" shift
			  to avoid warnings on 32-bit architectures.
 Any side effects of letting driver domain control cache line? 
  PCI Stub Driver - Grabs devices in backend to be exported later
  Ryan Wilson <hap9@epoch.ncsc.mil>
  Chris Bookholt <hap10@epoch.ncsc.mil>
Add sem for sync AER handling and xen_pcibk removereconfigue ops,
 We want to avoid in middle of AER ops, xen_pcibk devices is being removed
 non-NULL if struct pci_dev is in use 
 Access to pcistub_devices & seized_devices lists and the initialize_devices
  flag must be locked with pcistub_devices_lock
 wait for device_initcall before initializing our devices
  (see pcistub_init_devices_late)
 Don't call this directly as it's called by pcistub_device_put 
	 Call the reset function which does not take lock as this
	  is called from "unbind" which takes a device_lock mutex.
 Disable the device 
 Clean-up the device 
  Called when:
   - XenBus state has been reconfigure (pci unplug). See xen_pcibk_remove_device
   - XenBus state has been disconnected (guest shutdown). See xen_pcibk_xenbus_remove
   - 'echo BDF > unbind' on pciback module with no guest attached. See pcistub_remove
   - 'echo BDF > unbind' with a guest still using it. See pcistub_remove
   As such we have to be careful.
   To make this easier, the caller has to hold the device lock.
	hold this lock for avoiding breaking link between
	 pcistub and xen_pcibk when AER is in processing
	 Cleanup our device
	  (so it's ready for the next domain)
		
		  The usual sequence is pci_save_state & pci_restore_state
		  but the guest might have messed the configuration space up.
		  Use the initial version (when device was bound to us).
 This disables the device. 
 And cleanup up our emulated fields. 
	 Match the specified device by domain, bus, slot, func and also if
	  any of the device's parent bridges match.
 Sometimes topmost bridge links to itself. 
	 The PCI backend is not intended to be a module (or to work with
	  removable PCI devices (yet). If it were, xen_pcibk_config_free()
	  would need to be called somewhere to free the memory allocated
	  here and then to call kfree(pci_get_drvdata(psdev->dev)).
	
	  Setup name for fake IRQ handler. It will only be enabled
	  once the device is turned on by the guest.
	 HACK: Force device (& ACPI) to determine what IRQ it's on - we
	  must do this here because pcibios_enable_device may specify
	  the pci device's true irq (and possibly its other resources)
	  if they differ from what's in the configuration space.
	  This makes the assumption that the device's resources won't
	  change after this point (otherwise this code may break!)
 We need the device active to save the state. 
	 Now disable the device (this also ensures some private device
	  data is setup before we export)
  Because some initialization still happens on
  devices during fs_initcall, we need to defer
  full initialization of our devices until
  device_initcall.
 don't want irqs disabled when calling pcistub_init_device 
 Called when 'bind'. This means we must _NOT_ call pci_reset_function or
 Didn't find the device 
 Called when 'unbind'. This means we must _NOT_ call pci_reset_function or
			 N.B. This ends up calling pcistub_put_pci_dev which ends up
 caller holds the lock. );
 the final put for releasing from the list 
PV AER handlers will set this flag
 For each aer recovery step error_detected, mmio_enabled, etc, front_end and
  backend need to have cooperation. In xen_pcibk, those steps will do similar
  jobs: send service request and waiting for front_end response.
with PV AER drivers
useful for error_detected callback
pcifront_end BDF
	local flag to mark there's aer request, xen_pcibk callback will use
	 this flag to judge whether we need to check pci-front give aer
	 service ack signal
	It is possible that a pcifront conf_read_write ops request invokes
	 the callback which cause the spurious execution of wake_up.
	 Yet it is harmless and better than a spinlock here
 Enable IRQ to signal "request done". 
 Enable IRQ for pcifront request if not already active. 
 xen_pcibk_slot_reset: it will send the slot_reset request to  pcifront in case
 of the device driver could provide this service, and then wait for pcifront
 ack.
 @dev: pointer to PCI devices
 return value is used by aer_core do_recovery policy
xen_pcibk_mmio_enabled: it will send the mmio_enabled request to  pcifront
 in case of the device driver could provide this service, and then wait
 for pcifront ack
 @dev: pointer to PCI devices
 return value is used by aer_core do_recovery policy
xen_pcibk_error_detected: it will send the error_detected request to  pcifront
 in case of the device driver could provide this service, and then wait
 for pcifront ack.
 @dev: pointer to PCI devices
 @error: the current PCI connection state
 return value is used by aer_core do_recovery policy
Guest owns the device yet no aer handler regiested, kill guest
xen_pcibk_error_resume: it will send the error_resume request to  pcifront
 in case of the device driver could provide this service, and then wait
 for pcifront ack.
 @dev: pointer to PCI devices
add xen_pcibk AER handling
  Note: There is no MODULE_DEVICE_TABLE entry here because this isn't
  for a normal device. I don't want it to be loaded automatically.
	 The name should be xen_pciback, but until the tools are updated
 try again without domain 
 try again without domain 
 pci_domains_supported is not being exported  \
			 Don't break; here because it's possible the same
			  slot could be in the list more than once
 the driver data for a device should never be null at this point 
 Let user know that what they're doing could be unsafe 
 the driver data for a device should never be null at this point 
	 If we're the first PCI Device Driver to register, we're the
	  first one to get offered PCI devices as they become
	  available (and thus we can be the first to grab them)
  fs_initcall happens before device_initcall
  so xen_pcibk should get called first (bc we
  want to suck up any device before other drivers
  get a chance by being the first pci device
  driver to register)
  Xen event channels (FIFO-based ABI)
  Copyright (C) 2013 Citrix Systems R&D ltd.
  This source code is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation; either version 2 of the
  License, or (at your option) any later version.
  Or, when distributed separately from the Linux kernel or
  incorporated into other software packages, subject to the following
  license:
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this source file (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, andor sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
  sync_set_bit() and friends must be unsigned long aligned.
 Reset the control block and the local HEADs. 
 Might already have a page if we've resumed. 
 Mask all events in this page before adding it. 
 no-op 
  Clear MASKED if not PENDING, spinning if BUSY is set.
  Return true if mask was cleared.
	
	  Reached the tail last time?  Read the new HEAD from the
	  control block.
 Ensure word is up-to-date before reading head. 
	
	  If the link is non-zero, there are more events in the
	  queue, otherwise the queue is empty.
	 
	  If the queue is empty, clear this priority from our local
	  copy of the ready word.
		
		  If this CPU is offline, take the opportunity to
		  free the control block while it is not being
		  used.
	
	  The event array starts out as empty again and is extended
	  as normal when events are bound.  The existing pages will
	  be reused.
 SPDX-License-Identifier: GPL-2.0
  Xen event channels (2-level ABI)
  Jeremy Fitzhardinge <jeremy@xensource.com>, XenSource Inc, 2007
  Note sizeof(xen_ulong_t) can be more than sizeof(unsigned long). Be
  careful to only use bitops which allow for this (e.g
  test_bitfind_first_bit and friends but not __ffs) and to pass
  BITS_PER_EVTCHN_WORD as the bitmask length.
  Make a bitmask (i.e. unsigned long ) of a xen_ulong_t
  array. Primarily to avoid long lines (hence the terse name).
 Find the first set bit in a evtchn mask 
 All writes before unmask must be visible. 
		
		  Need to clear the mask before checking pending to
		  avoid a race with an event becoming pending.
		 
		  EVTCHNOP_unmask will only trigger an upcall if the
		  mask bit was set, so if a hypercall is needed
		  remask the event.
	 Slow path (hypercall) if this is a non-local port or if this is
	  an hvm domain and an event is pending (hvm domains don't have
		
		  The following is basically the equivalent of
		  'hw_resend_irq'. Just like a real IO-APIC we 'lose
		  the interrupt edge' if the channel is masked.
  Mask out the i least significant bits of w
  Search the CPU's pending events bitmasks.  For each one found, map
  the event number to an irq, and feed it into do_IRQ() for handling.
  Xen uses a two-level bitmap to speed searching.  The first level is
  a bitset of words which contain pending event bits.  The second
  level is a bitset of pending events themselves.
 Timer interrupt has highest priority. 
	
	  Master flag must be cleared before clearing
	  selector flag. xchg_xen_ulong must contain an
	  appropriate barrier.
		
		  If we masked out all events, wrap to beginning.
 usually scan entire word from start 
		
		  We scan the starting word in two parts.
		 
		  1st time: start in the middle, scanning the
		  upper bits.
		 
		  2nd time: scan the whole word (not just the
		  parts skipped in the first pass) -- if an
		  event in the previously scanned bits is
		  pending again it would just be scanned on
		  the next loop anyway.
 If we masked out all events, move on. 
 Process port. 
 Next caller starts at last processed + 1 
 Scan start_l1i twice; all others once. 
 SPDX-License-Identifier: GPL-2.0-only
  Xen event channels
  Xen models interrupts with abstract event channels.  Because each
  domain gets 1024 event channels, but NR_IRQ is not that large, we
  must dynamically map irqs<->event channels.  The event channels
  interface with the rest of the kernel by defining a xen interrupt
  chip.  When an event is received, it is mapped to an irq and sent
  through the normal interrupt processing path.
  There are four kinds of events which can be mapped to an event
  channel:
  1. Inter-domain notifications.  This includes all the virtual
     device events, since they're driven by front-ends in another domain
     (typically dom0).
  2. VIRQs, typically used for timers.  These are per-cpu events.
  3. IPIs.
  4. PIRQs - Hardware interrupts.
  Jeremy Fitzhardinge <jeremy@xensource.com>, XenSource Inc, 2007
 Interrupt types. 
  Packed IRQ information:
  type - enum xen_irq_type
  event channel - irq->event channel mapping
  cpu - cpu this event channel is bound to
  index - type-specific information:
     PIRQ - vector, with MSB being "needs EIO", or physical IRQ of the HVM
            guest, or GSI (real passthrough IRQ) of the device.
     VIRQ - virq number
     IPI - IPI vector
     EVTCHN -
 type: IRQT_ 
 Why is event channel masked 
 Is event just being handled? 
 event channel 
 cpu bound 
 EOI must happen on this cpu-1 
 If eoi_cpu valid: irq_epoch of event 
 Time in jiffies when to EOI. 
  This lock protects updates to the following mapping and reference-count
  arrays. The lock does not need to be acquired to read the mapping tables.
  Lock protecting event handling loop against removing event channels.
  Adding of event channels is no issue as the associated IRQ becomes active
  only after everything is setup (before request_[threaded_]irq() the handler
  can't be entered for an event, as the event channel will be unmasked only
  then).
  Lock hierarchy:
  irq_mapping_update_lock
    evtchn_rwlock
      IRQ-desc lock
        percpu eoi_list_lock
          irq_info->lock
 IRQ <-> VIRQ mapping. 
 IRQ <-> IPI mapping 
 Event channel distribution data 
 Xen will never allocate port zero for any purpose. 
 Unallocated irq entries return -1 anyway 
		
		  We've prepared an empty row for the mapping. If a different
		  thread was faster inserting it, we can drop ours.
 Get info for IRQ 
 Per CPU channel accounting 
 Constructors for packed IRQ information. 
  Accessors for packed IRQ information.
  notify_remote_via_irq - send event to remote end of event channel via irq
  @irq: irq of event channel to send event to
  Unlike notify_remote_via_evtchn(), this is safe to use across
  saverestore. Notifications on a broken connection are silently
  dropped.
 is_active hasn't been reset yet, do it now. 
	
	  Interrupt affinity setting can be immediate. No point
	  in delaying it until an interrupt is handled.
	
	  A PV guest has no concept of a GSI (since it has no ACPI
	  nor access toknowledge of the physical APICs). Therefore
	  all IRQs are dynamically allocated from the entire IRQ
	  space.
 Legacy IRQ descriptors are already allocated by the arch. 
 Legacy IRQ descriptors are managed by the arch. 
 Not called for lateeoi events. 
 NB. We are happy to share unless we are probing. 
  Do not make any assumptions regarding the relationship between the
  IRQ number returned here and the Xen pirq argument.
  Note: We don't assign an event channel until the irq actually started
  up.  Return an existing irq if we've already got one for the gsi.
  Shareable implies level triggered, not shareable implies edge
  triggered here.
	 Only the privileged domain can do this. For non-priv, the pcifront
	  driver provides a PCI bus that does the call to do exactly
	 We try to use the handler with the appropriate semantic for the
	  type of interrupt: if the interrupt is an edge triggered
	  interrupt we use handle_edge_irq.
	 
	  On the other hand if the interrupt is level triggered we use
	  handle_fasteoi_irq like the native code does for this kind of
	  interrupts.
	 
	  Depending on the Xen version, pirq_needs_eoi might return true
	  not only for level triggered interrupts but for edge triggered
	  interrupts too. In any case Xen always honors the eoi mechanism,
	  not injecting any more pirqs of the same kind if the first one
	  hasn't received an eoi yet. Therefore using the fasteoi handler
	  is the right choice either way.
	
	  If trying to remove a vector in a MSI group different
	  than the first one skip the PIRQ unmap unless this vector
	  is the first one in the group.
		 If another domain quits without making the pci_disable_msix
		  call, the Xen hypervisor takes care of freeing the PIRQs
		  (free_domain_pirqs).
		
		  New interdomain events are initially bound to vCPU0 This
		  is required to setup the event channel in the first
		  place and also important for UP guests because the
		  affinity setting is not invoked on them so nothing would
		  bind the channel.
		
		  Force the affinity mask to the target CPU so proc shows
		  the correct target.
  xen_evtchn_nr_channels - number of usable event channel ports
  This may be less than the maximum supported by the current
  hypervisor ABI. Use xen_evtchn_max_channels() for the maximum
  supported.
		
		  Force the affinity mask for percpu interrupts so proc
		  shows the correct target.
  xen_set_irq_priority() - set an event channel priority.
  @irq:irq bound to an event channel.
  @priority: priority between XEN_IRQ_PRIORITY_MAX and XEN_IRQ_PRIORITY_MIN.
	
	  Check for timeout every 256 events.
	  We are setting the timeout value only after the first 256
	  events in order to not hurt the common case of few loop
	  iterations. The 256 is basically an arbitrary value.
	 
	  In case we are hitting the timeout we need to defer all further
	  EOIs in order to ensure to leave the event handling loop rather
	  sooner than later.
 Hypervisor can set upcall pending. 
	
	  Increment irq_epoch only now to defer EOIs only for
	  xen_irq_lateeoi() invocations occurring from inside the loop
	  above.
 Rebind a new event channel to an existing irq. 
	 Make sure the irq is masked, since the new event channel
 After resume the irq<->evtchn mappings are all cleared out 
	 Expect irq to have been bound before,
 Unmask the event channel. 
 Rebind an evtchn so that it gets delivered to a specific cpu 
 Send future instances of this interrupt to other vcpu. 
	
	  Mask the event while changing the VCPU binding to prevent
	  it being delivered on an unexpected VCPU.
	
	  If this fails, it usually just indicates that we're dealing with a
	  virq or IPI channel, which don't actually need to be rebound. Ignore
	  it, but don't do the xenlinux-level rebind in that case.
  Find the CPU within @dest mask which has the least number of channels
  assigned. This is not precise as the per cpu counts can be modified
  concurrently.
	
	  Catch the unlikely case that dest contains no online CPUs. Can't
	  recurse.
		
		  Don't call event_handler_exit().
		  Need to keep is_active non-zero in order to ignore re-raised
		  events after cpu affinity changes while a lateeoi is pending.
		 saverestore of PT devices doesn't work, so at this point the
 Get a new binding from Xen. 
 Record the new mapping. 
 The affinity mask is still valid 
 Get a new binding from Xen. 
 Record the new mapping. 
 The affinity mask is still valid 
 Clear an irq's pending state, in preparation for polling on it 
 Poll waiting for an irq to become pending with timeout.  In the usual case,
 Poll waiting for an irq to become pending.  In the usual case, the
 no timeout );
 Check whether the IRQ line is shared with other guests. 
 New event-channel space is not 'live' yet. 
 No IRQ <-> event-channel mappings. 
 Zap event-channel binding 
 Adjust accounting 
 The chip name needs to contain "xen-dyn" for irqbalance to work. 
 Vector callbacks are better than PCI interrupts to receive event
  channel notifications because we can receive vector callbacks on any
 No event channels are 'live' right now. 
		 pci_xen_hvm_init must be called after native_init_IRQ so that
 SPDX-License-Identifier: GPL-2.0-only
   linuxarcharmcommonamba.c
   Copyright (C) 2003 Deep Blue Solutions Ltd, All Rights Reserved.
 called on periphid match and class 0x9 coresight device. 
 no table data or zero mask - return match on periphid 
 test against read devtype and masked devarch value 
 We need to keep extra room for a newline 
 When driver_override is set, only bind to the matching driver 
  These are the device model conversion veneers; they convert the
  device model structures to our more specific structures.
 Undo the runtime PM settings in amba_probe() 
  Hooks to provide runtime PM of the pclk (bus clock).  It is safe to
  enabledisable the bus clock at runtime PM suspendresume as this
  does not result in loss of context.
 Failure is probably fatal to the system, but... 
 CONFIG_PM 
  Primecells are part of the Advanced Microcontroller Bus Architecture,
  so we call the bus "amba".
  DMA configuration for platform and AMBA bus is same. So here we reuse
  platform's DMA config routine.
 	amba_driver_register - register an AMBA device driver
 	@drv: amba device driver structure
 	Register an AMBA device driver with the Linux device model
 	core.  If devices pre-exist, the drivers probe function will
 	be called.
 	amba_driver_unregister - remove an AMBA device driver
 	@drv: AMBA device driver structure to remove
 	Unregister an AMBA device driver from the Linux device
 	model.  The device model will call the drivers remove function
 	for each device the device driver is currently handling.
 Decode the IRQs and address ranges 
 Hard-coded primecell ID instead of plug-n-play 
	
	  Dynamically calculate the size of the resource
	  and use this for iomap
		
		  Find reset control(s) of the amba bus and de-assert them.
		
		  Read pid and cid based on size of resource
		  they are located at end of region
 set the base to the start of the last 4k block 
  Registration of AMBA device require reading its pid and cid registers.
  To do this, the device must be turned on (if it is a part of power domain)
  and have clocks enabled. However in some cases those resources might not be
  yet available. Returning EPROBE_DEFER is not a solution in such case,
  because callers don't handle this special error code. Instead such devices
  are added to the special list and their registration is retried from
  periodic worker, until all resources are available and registration succeeds.
 	amba_device_add - add a previously allocated AMBA device structure
 	@dev: AMBA device allocated by amba_device_alloc
 	@parent: resource parent for this devices resources
 	Claim the resource, and read the device cell ID if not already
 	initialized.  Register the AMBA device with the Linux device
 	manager.
 	amba_device_alloc - allocate an AMBA device
 	@name: sysfs name of the AMBA device
 	@base: base of AMBA device
 	@size: size of AMBA device
 	Allocate and initialize an AMBA device structure.  Returns %NULL
 	on failure.
 	amba_device_register - register an AMBA device
 	@dev: AMBA device to register
 	@parent: parent memory resource
 	Setup the AMBA device, reading the cell ID if present.
 	Claim the resource, and register the AMBA device with
 	the Linux device manager.
 	amba_device_put - put an AMBA device
 	@dev: AMBA device to put
 	amba_device_unregister - unregister an AMBA device
 	@dev: AMBA device to remove
 	Remove the specified AMBA device from the Linux device
 	manager.  All files associated with this object will be
 	destroyed, and device drivers notified that the device has
 	been removed.  The AMBA device's resources including
 	the amba_device structure will be freed once all
 	references to it have been dropped.
 	amba_find_device - locate an AMBA device given a bus id
 	@busid: bus id for device (or NULL)
 	@parent: parent device (or NULL)
 	@id: peripheral ID (or 0)
 	@mask: peripheral ID mask (or 0)
 	Return the AMBA device corresponding to the supplied parameters.
 	If no device matches, returns NULL.
 	NOTE: When a valid device is found, its refcount is
 	incremented, and must be decremented before the returned
 	reference.
 	amba_request_regions - request all mem regions associated with device
 	@dev: amba_device structure for device
 	@name: name, or NULL to use driver name
 	amba_release_regions - release mem regions associated with device
 	@dev: amba_device structure for device
 	Release regions claimed by a successful call to amba_request_regions.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
  Copyright (C) 2011 Google, Inc.
  Author:
 	Jay Cheng <jacheng@nvidia.com>
 	James Wylder <james.wylder@motorola.com>
 	Benoit Goby <benoit@android.com>
 	Colin Cross <ccross@android.com>
 	Hiroshi DOYU <hdoyu@nvidia.com>
  INCORRECT_BASE_ADDR_LOW_BYTE: Legacy kernel DT files for Tegra SoCs
  prior to Tegra124 generally use a physical base address ending in
  0x4 for the AHB IP block.  According to the TRM, the low byte
  should be 0x0.  During device probing, this macro is used to detect
  whether the passed-in physical address is incorrect, and if so, to
  correct it.
 Correct the IP block base address if necessary 
 SPDX-License-Identifier: GPL-2.0-or-later
  sun6i_hwspinlock.c - hardware spinlock driver for sun6i compatible Allwinner SoCs
  Copyright (C) 2020 Wilken Gottwalt <wilken.gottwalt@posteo.net>
 there is only one hwspinlock device per SoC 
	
	  bit 28 and 29 represents the hwspinlock setup
	 
	  every datasheet (A64, A80, A83T, H3, H5, H6 ...) says the default value is 0x1 and 0x1
	  to 0x4 represent 32, 64, 128 and 256 locks
	  but later datasheets (H5, H6) say 00, 01, 10, 11 represent 32, 64, 128 and 256 locks,
	  but that would mean H5 and H6 have 64 locks, while their datasheets talk about 32 locks
	  all the time, not a single mentioning of 64 locks
	  the 0x4 value is also not representable by 2 bits alone, so some datasheets are not
	  correct
	  one thing have all in common, default value of the sysstatus register is 0x10000000,
	  which results in bit 28 being set
	  this is the reason 0x1 is considered being 32 locks and bit 30 is taken into account
	  verified on H2+ (datasheet 0x1 = 32 locks) and H5 (datasheet 01 = 64 locks)
 failure of debugfs is considered non-fatal 
 SPDX-License-Identifier: GPL-2.0
  Hardware spinlock framework
  Copyright (C) 2010 Texas Instruments Incorporated - http:www.ti.com
  Contact: Ohad Ben-Cohen <ohad@wizery.com>
 retry delay used in atomic context 
 radix tree tags 
 tags an hwspinlock as unused 
  A radix tree is used to maintain the available hwspinlock instances.
  The tree associates hwspinlock pointers with their integer key id,
  and provides easy-to-use API which makes the hwspinlock core code simple
  and easy to read.
  Radix trees are quick on lookups, and reasonably efficient in terms of
  storage, especially with high density usages such as this framework
  requires (a continuous range of integer keys, beginning with zero, is
  used as the ID's of the hwspinlock instances).
  The radix tree API supports tagging items in the tree, which this
  framework uses to mark unused hwspinlock instances (see the
  HWSPINLOCK_UNUSED tag above). As a result, the process of querying the
  tree, looking for an unused hwspinlock instance, is now reduced to a
  single radix tree API call.
  Synchronization of access to the tree is achieved using this mutex,
  as the radix-tree API requires that users provide all synchronisation.
  A mutex is needed because we're using non-atomic radix tree allocations.
  __hwspin_trylock() - attempt to lock a specific hwspinlock
  @hwlock: an hwspinlock which we want to trylock
  @mode: controls whether local interrupts are disabled or not
  @flags: a pointer where the caller's interrupt state will be saved at (if
          requested)
  This function attempts to lock an hwspinlock, and will immediately
  fail if the hwspinlock is already taken.
  Caution: If the mode is HWLOCK_RAW, that means user must protect the routine
  of getting hardware lock with mutex or spinlock. Since in some scenarios,
  user need some time-consuming or sleepable operations under the hardware
  lock, they need one sleepable lock (like mutex) to protect the operations.
  If the mode is neither HWLOCK_IN_ATOMIC nor HWLOCK_RAW, upon a successful
  return from this function, preemption (and possibly interrupts) is disabled,
  so the caller must not sleep, and is advised to release the hwspinlock as
  soon as possible. This is required in order to minimize remote cores polling
  on the hardware interconnect.
  The user decides whether local interrupts are disabled or not, and if yes,
  whether he wants their previous state to be saved. It is up to the user
  to choose the appropriate @mode of operation, exactly the same way users
  should decide between spin_trylock, spin_trylock_irq and
  spin_trylock_irqsave.
  Returns 0 if we successfully locked the hwspinlock or -EBUSY if
  the hwspinlock was already taken.
  This function will never sleep.
	
	  This spin_lock{_irq, _irqsave} serves three purposes:
	 
	  1. Disable preemption, in order to minimize the period of time
	     in which the hwspinlock is taken. This is important in order
	     to minimize the possible polling on the hardware interconnect
	     by a remote user of this lock.
	  2. Make the hwspinlock SMP-safe (so we can take it from
	     additional contexts on the local host).
	  3. Ensure that in_atomicmight_sleep checks catch potential
	     problems with hwspinlock usage (e.g. scheduler checks like
	     'scheduling while atomic' etc.)
 is lock already taken by another context on the local cpu ? 
 try to take the hwspinlock device 
 if hwlock is already taken, undo spin_trylock_ and exit 
 Nothing to do 
	
	  We can be sure the other core's memory operations
	  are observable to us only _after_ we successfully take
	  the hwspinlock, and we must make sure that subsequent memory
	  operations (both reads and writes) will not be reordered before
	  we actually took the hwspinlock.
	 
	  Note: the implicit memory barrier of the spinlock above is too
	  early, so we need this additional explicit memory barrier.
  __hwspin_lock_timeout() - lock an hwspinlock with timeout limit
  @hwlock: the hwspinlock to be locked
  @timeout: timeout value in msecs
  @mode: mode which controls whether local interrupts are disabled or not
  @flags: a pointer to where the caller's interrupt state will be saved at (if
          requested)
  This function locks the given @hwlock. If the @hwlock
  is already taken, the function will busy loop waiting for it to
  be released, but give up after @timeout msecs have elapsed.
  Caution: If the mode is HWLOCK_RAW, that means user must protect the routine
  of getting hardware lock with mutex or spinlock. Since in some scenarios,
  user need some time-consuming or sleepable operations under the hardware
  lock, they need one sleepable lock (like mutex) to protect the operations.
  If the mode is HWLOCK_IN_ATOMIC (called from an atomic context) the timeout
  is handled with busy-waiting delays, hence shall not exceed few msecs.
  If the mode is neither HWLOCK_IN_ATOMIC nor HWLOCK_RAW, upon a successful
  return from this function, preemption (and possibly interrupts) is disabled,
  so the caller must not sleep, and is advised to release the hwspinlock as
  soon as possible. This is required in order to minimize remote cores polling
  on the hardware interconnect.
  The user decides whether local interrupts are disabled or not, and if yes,
  whether he wants their previous state to be saved. It is up to the user
  to choose the appropriate @mode of operation, exactly the same way users
  should decide between spin_lock, spin_lock_irq and spin_lock_irqsave.
  Returns 0 when the @hwlock was successfully taken, and an appropriate
  error code otherwise (most notably -ETIMEDOUT if the @hwlock is still
  busy after @timeout msecs). The function will never sleep.
 Try to take the hwspinlock 
		
		  The lock is already taken, let's check if the user wants
		  us to try again
		
		  Allow platform-specific relax handlers to prevent
		  hogging the interconnect (no sleeping, though)
  __hwspin_unlock() - unlock a specific hwspinlock
  @hwlock: a previously-acquired hwspinlock which we want to unlock
  @mode: controls whether local interrupts needs to be restored or not
  @flags: previous caller's interrupt state to restore (if requested)
  This function will unlock a specific hwspinlock, enable preemption and
  (possibly) enable interrupts or restore their previous state.
  @hwlock must be already locked before calling this function: it is a bug
  to call unlock on a @hwlock that is already unlocked.
  The user decides whether local interrupts should be enabled or not, and
  if yes, whether he wants their previous state to be restored. It is up
  to the user to choose the appropriate @mode of operation, exactly the
  same way users decide between spin_unlock, spin_unlock_irq and
  spin_unlock_irqrestore.
  The function will never sleep.
	
	  We must make sure that memory operations (both reads and writes),
	  done before unlocking the hwspinlock, will not be reordered
	  after the lock is released.
	 
	  That's the purpose of this explicit memory barrier.
	 
	  Note: the memory barrier induced by the spin_unlock below is too
	  late; the other core is going to access memory soon after it will
	  take the hwspinlock, and by then we want to be sure our memory
	  operations are already observable.
 Undo the spin_trylock{_irq, _irqsave} called while locking 
 Nothing to do 
  of_hwspin_lock_simple_xlate - translate hwlock_spec to return a lock id
  @bank: the hwspinlock device bank
  @hwlock_spec: hwlock specifier as found in the device tree
  This is a simple translation function, suitable for hwspinlock platform
  drivers that only has a lock specifier length of 1.
  Returns a relative index of the lock within a specified bank on success,
  or -EINVAL on invalid specifier cell count.
  of_hwspin_lock_get_id() - get lock id for an OF phandle-based specific lock
  @np: device node from which to request the specific hwlock
  @index: index of the hwlock in the list of values
  This function provides a means for DT users of the hwspinlock module to
  get the global lock id of a specific hwspinlock using the phandle of the
  hwspinlock device, so that it can be requested using the normal
  hwspin_lock_request_specific() API.
  Returns the global lock id number on success, -EPROBE_DEFER if the hwspinlock
  device is not yet registered, -EINVAL on invalid args specifier value or an
  appropriate error as returned from the OF parsing of the DT client node.
 Find the hwspinlock device: we need its base_id 
  of_hwspin_lock_get_id_byname() - get lock id for an specified hwlock name
  @np: device node from which to request the specific hwlock
  @name: hwlock name
  This function provides a means for DT users of the hwspinlock module to
  get the global lock id of a specific hwspinlock using the specified name of
  the hwspinlock device, so that it can be requested using the normal
  hwspin_lock_request_specific() API.
  Returns the global lock id number on success, -EPROBE_DEFER if the hwspinlock
  device is not yet registered, -EINVAL on invalid args specifier value or an
  appropriate error as returned from the OF parsing of the DT client node.
 mark this hwspinlock as available 
 self-sanity check which should never fail 
 make sure the hwspinlock is not in use (tag is set) 
  hwspin_lock_register() - register a new hw spinlock device
  @bank: the hwspinlock device, which usually provides numerous hw locks
  @dev: the backing device
  @ops: hwspinlock handlers for this device
  @base_id: id of the first hardware spinlock in this bank
  @num_locks: number of hwspinlocks provided by this device
  This function should be called from the underlying platform-specific
  implementation, to register a new hwspinlock device instance.
  Should be called from a process context (might sleep)
  Returns 0 on success, or an appropriate error code on failure
  hwspin_lock_unregister() - unregister an hw spinlock device
  @bank: the hwspinlock device, which usually provides numerous hw locks
  This function should be called from the underlying platform-specific
  implementation, to unregister an existing (and unused) hwspinlock.
  Should be called from a process context (might sleep)
  Returns 0 on success, or an appropriate error code on failure
 self-sanity check that should never fail 
  devm_hwspin_lock_unregister() - unregister an hw spinlock device for
 				   a managed device
  @dev: the backing device
  @bank: the hwspinlock device, which usually provides numerous hw locks
  This function should be called from the underlying platform-specific
  implementation, to unregister an existing (and unused) hwspinlock.
  Should be called from a process context (might sleep)
  Returns 0 on success, or an appropriate error code on failure
  devm_hwspin_lock_register() - register a new hw spinlock device for
 				 a managed device
  @dev: the backing device
  @bank: the hwspinlock device, which usually provides numerous hw locks
  @ops: hwspinlock handlers for this device
  @base_id: id of the first hardware spinlock in this bank
  @num_locks: number of hwspinlocks provided by this device
  This function should be called from the underlying platform-specific
  implementation, to register a new hwspinlock device instance.
  Should be called from a process context (might sleep)
  Returns 0 on success, or an appropriate error code on failure
  __hwspin_lock_request() - tag an hwspinlock as used and power it up
  This is an internal function that prepares an hwspinlock instance
  before it is given to the user. The function assumes that
  hwspinlock_tree_lock is taken.
  Returns 0 or positive to indicate success, and a negative value to
  indicate an error (with the appropriate error code)
 prevent underlying implementation from being removed 
 notify PM core that power is now needed 
 mark hwspinlock as used, should not fail 
 self-sanity check that should never fail 
  hwspin_lock_get_id() - retrieve id number of a given hwspinlock
  @hwlock: a valid hwspinlock instance
  Returns the id number of a given @hwlock, or -EINVAL if @hwlock is invalid.
  hwspin_lock_request() - request an hwspinlock
  This function should be called by users of the hwspinlock device,
  in order to dynamically assign them an unused hwspinlock.
  Usually the user of this lock will then have to communicate the lock's id
  to the remote core before it can be used for synchronization (to get the
  id of a given hwlock, use hwspin_lock_get_id()).
  Should be called from a process context (might sleep)
  Returns the address of the assigned hwspinlock, or NULL on error
 look for an unused lock 
 sanity check that should never fail 
 mark as used and power up 
  hwspin_lock_request_specific() - request for a specific hwspinlock
  @id: index of the specific hwspinlock that is requested
  This function should be called by users of the hwspinlock module,
  in order to assign them a specific hwspinlock.
  Usually early board code will be calling this function in order to
  reserve specific hwspinlock ids for predefined purposes.
  Should be called from a process context (might sleep)
  Returns the address of the assigned hwspinlock, or NULL on error
 make sure this hwspinlock exists 
 sanity check (this shouldn't happen) 
 make sure this hwspinlock is unused 
 mark as used and power up 
  hwspin_lock_free() - free a specific hwspinlock
  @hwlock: the specific hwspinlock to free
  This function mark @hwlock as free again.
  Should only be called with an @hwlock that was retrieved from
  an earlier call to hwspin_lock_request{_specific}.
  Should be called from a process context (might sleep)
  Returns 0 on success, or an appropriate error code on failure
 make sure the hwspinlock is used 
 notify the underlying device that power is not needed 
 mark this hwspinlock as available 
 sanity check (this shouldn't happen) 
  devm_hwspin_lock_free() - free a specific hwspinlock for a managed device
  @dev: the device to free the specific hwspinlock
  @hwlock: the specific hwspinlock to free
  This function mark @hwlock as free again.
  Should only be called with an @hwlock that was retrieved from
  an earlier call to hwspin_lock_request{_specific}.
  Should be called from a process context (might sleep)
  Returns 0 on success, or an appropriate error code on failure
  devm_hwspin_lock_request() - request an hwspinlock for a managed device
  @dev: the device to request an hwspinlock
  This function should be called by users of the hwspinlock device,
  in order to dynamically assign them an unused hwspinlock.
  Usually the user of this lock will then have to communicate the lock's id
  to the remote core before it can be used for synchronization (to get the
  id of a given hwlock, use hwspin_lock_get_id()).
  Should be called from a process context (might sleep)
  Returns the address of the assigned hwspinlock, or NULL on error
  devm_hwspin_lock_request_specific() - request for a specific hwspinlock for
 					 a managed device
  @dev: the device to request the specific hwspinlock
  @id: index of the specific hwspinlock that is requested
  This function should be called by users of the hwspinlock module,
  in order to assign them a specific hwspinlock.
  Usually early board code will be calling this function in order to
  reserve specific hwspinlock ids for predefined purposes.
  Should be called from a process context (might sleep)
  Returns the address of the assigned hwspinlock, or NULL on error
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) STMicroelectronics SA 2018
  Author: Benjamin Gaignard <benjamin.gaignard@st.com> for STMicroelectronics.
 board init code might need to reserve hwspinlocks for predefined purposes 
 SPDX-License-Identifier: GPL-2.0
  u8500 HWSEM driver
  Copyright (C) 2010-2011 ST-Ericsson
  Implements u8500 semaphore handling for protocol 1, no interrupts.
  Author: Mathieu Poirier <mathieu.poirier@linaro.org>
  Heavily borrowed from the work of :
    Simon Que <sque@ti.com>
    Hari Kanigeri <h-kanigeri2@ti.com>
    Ohad Ben-Cohen <ohad@wizery.com>
  Implementation of STE's HSem protocol 1 without interrutps.
  The only masterID we allow is '0x01' to force people to use
  HSems for synchronisation between processors rather than processes
  on the ARM core.
 a total of 32 semaphore 
 free 
  CPU ID for master running u8500 kernel.
  Hswpinlocks should only be used to synchonise operations
  between the Cortex A9 core and the other CPUs.  Hence
  forcing the masterID to a preset value.
	 get only first 4 bit and compare to masterID.
	  if equal, we have the semaphore, otherwise
	  someone else has it.
 release the lock by writing 0 to it 
  u8500: what value is recommended here ?
 make sure protocol 1 is selected 
 clear all interrupts 
 clear all interrupts 
 board init code might need to reserve hwspinlocks for predefined purposes 
 SPDX-License-Identifier: GPL-2.0
  Spreadtrum hardware spinlock driver
  Copyright (C) 2017 Spreadtrum  - http:www.spreadtrum.com
 hwspinlock registers definition 
 unlocked value 
 bits definition of RECCTRL reg 
 hwspinlock number 
 try to lock the hardware spinlock 
 get the hardware spinlock masteruser id 
 unlock the hardware spinlock 
 The specs recommended below number as the retry delay time 
 set the hwspinlock to record user id to identify subsystems 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  OMAP hardware spinlock driver
  Copyright (C) 2010-2021 Texas Instruments Incorporated - https:www.ti.com
  Contact: Simon Que <sque@ti.com>
           Hari Kanigeri <h-kanigeri2@ti.com>
           Ohad Ben-Cohen <ohad@wizery.com>
           Suman Anna <s-anna@ti.com>
 Spinlock register offsets 
 Possible values of SPINLOCK_LOCK_REG 
 free 
 locked 
 attempt to acquire the lock by reading its value 
 release the lock by writing 0 to it 
  relax the OMAP interconnect while spinning on it.
  The specs recommended that the retry delay time will be
  just over half of the time that a requester would be
  expected to hold the lock.
  The number below is taken from an hardware specs example,
  obviously it is somewhat arbitrary.
 Only a single hwspinlock block device is supported 
	
	  make sure the module is enabled and clocked before reading
	  the module SYSSTATUS register
 Determine number of locks 
	
	  runtime PM will make sure the clock of this module is
	  enabled again iff at least one lock is requested
 one of the four lsb's must be set, and nothing else 
 actual number of locks in this device 
 end  },
 board init code might need to reserve hwspinlocks for predefined purposes 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2013, The Linux Foundation. All rights reserved.
  Copyright (c) 2015, Sony Mobile Communications AB
 All modern platform has offset 0 and stride of 4k 
 board init code might need to reserve hwspinlocks for predefined purposes 
 SPDX-License-Identifier: GPL-2.0
  usb.c - Hardware dependent module for USB
  Copyright (C) 2013-2015 Microchip Technology Germany II GmbH & Co. KG
 VID: SMSC 
 PID: USB Bridge 
 PID: USB OS81118 
 PID: USB OS81119 
 PID: USB OS81210 
 DRCI Addresses 
  struct most_dci_obj - Direct Communication Interface
  @kobj:position in sysfs
  @usb_device: pointer to the usb device
  @reg_addr: register address for arbitrary DCI access
  struct most_dev - holds all usb interface specific stuff
  @usb_device: pointer to usb device
  @iface: hardware interface
  @cap: channel capabilities
  @conf: channel configuration
  @dci: direct communication interface of hardware
  @ep_address: endpoint address table
  @description: device description
  @suffix: suffix for channel name
  @channel_lock: synchronize channel access
  @padding_active: indicates channel uses padding
  @is_channel_healthy: health status table of each channel
  @busy_urbs: list of anchored items
  @io_mutex: synchronize IO with disconnect
  @link_stat_timer: timer for link status reports
  @poll_work_obj: work for polling link status
 sync channel access 
  drci_rd_reg - read a DCI register
  @dev: usb device
  @reg: register address
  @buf: buffer to store data
  This is reads data from INIC's direct register communication interface
  drci_wr_reg - write a DCI register
  @dev: usb device
  @reg: register address
  @data: data to write
  This is writes data to INIC's direct register communication interface
  get_stream_frame_size - calculate frame size of current configuration
  @dev: device structure
  @cfg: channel configuration
  hdm_poison_channel - mark buffers of this channel as invalid
  @iface: pointer to the interface
  @channel: channel ID
  This unlinks all URBs submitted to the HCD,
  calls the associated completion function of the core and removes
  them from the list.
  Returns 0 on success or error code otherwise.
 temp. lock 
  hdm_add_padding - add padding bytes
  @mdev: most device
  @channel: channel ID
  @mbo: buffer object
  This inserts the INIC hardware specific padding bytes into a streaming
  channel's buffer
  hdm_remove_padding - remove padding bytes
  @mdev: most device
  @channel: channel ID
  @mbo: buffer object
  This takes the INIC hardware specific padding bytes off a streaming
  channel's buffer.
  hdm_write_completion - completion function for submitted Tx URBs
  @urb: the URB that has been completed
  This checks the status of the completed URB. In case the URB has been
  unlinked before, it is immediately freed. On any other error the MBO
  transfer flag is set. On success it frees allocated resources and calls
  the completion function.
  Context: interrupt!
  hdm_read_completion - completion function for submitted Rx URBs
  @urb: the URB that has been completed
  This checks the status of the completed URB. In case the URB has been
  unlinked before it is immediately freed. On any other error the MBO transfer
  flag is set. On success it frees allocated resources, removes
  padding bytes -if necessary- and calls the completion function.
  Context: interrupt!
  hdm_enqueue - receive a buffer to be used for data transfer
  @iface: interface to enqueue to
  @channel: ID of the channel
  @mbo: pointer to the buffer object
  This allocates a new URB and fills it according to the channel
  that is being used for transmission of data. Before the URB is
  submitted it is stored in the private anchor list.
  Returns 0 on success. On any error the URB is freed and a error code
  is returned.
  Context: Could in _some_ cases be interrupt!
  hdm_configure_channel - receive channel configuration from core
  @iface: interface
  @channel: channel ID
  @conf: structure that holds the configuration information
  The attached network interface controller (NIC) supports a padding mode
  to avoid short packets on USB, hence increasing the performance due to a
  lower interrupt load. This mode is default for synchronous data and can
  be switched on for isochronous data. In case padding is active the
  driver needs to know the frame size of the payload in order to calculate
  the number of bytes it needs to pad when transmitting or to cut off when
  receiving data.
		
		  Since the NIC's padding mode is not going to be
		  used, we can skip the frame size calculations and
		  move directly on to exit.
 calculate extra length to comply w HW padding 
  hdm_request_netinfo - request network information
  @iface: pointer to interface
  @channel: channel ID
  This is used as trigger to set up the link status timer that
  polls for the NI state of the INIC every 2 seconds.
  link_stat_timer_handler - schedule work obtaining mac address and link status
  @data: pointer to USB device instance
  The handler runs in interrupt context. That's why we need to defer the
  tasks to a work queue.
  wq_netinfo - work queue function to deliver latest networking information
  @wq_obj: object that holds data for our deferred work to do
  This retrieves the network interface status of the USB INIC
  wq_clear_halt - work queue function
  @wq_obj: work_struct object to execute
  This sends a clear_halt to the given USB pipe.
	 If the functional Stall condition has been set on an
	  asynchronous rx channel, we need to clear the tx channel
	  too, since the hardware runs its clean-up sequence on both
	  channels, as they are physically one on the network.
	 
	  The USB interface that exposes the asynchronous channels
	  contains always two endpoints, and two only.
  hdm_usb_fops - file operation table for USB driver
  usb_device_id - ID table for HCD device probing
 Terminating entry 
  hdm_probe - probe function of USB device driver
  @interface: Interface of the attached USB device
  @id: Pointer to the USB ID table.
  This allocates and initializes the device instance, adds the new
  entry to the internal list, scans the USB descriptors and registers
  the interface with the core.
  Additionally, the DCI objects are created and the hardware is sync'd.
  Return 0 on success. In case of an error a negative number is returned.
  hdm_disconnect - disconnect function of USB device driver
  @interface: Interface of the attached USB device
  This deregisters the interface with the core, removes the kernel timer
  and frees resources.
  Context: hub kernel thread
 SPDX-License-Identifier: GPL-2.0
  configfs.c - Implementation of configfs interface to the driver stack
  Copyright (C) 2013-2015 Microchip Technology Germany II GmbH & Co. KG
 SPDX-License-Identifier: GPL-2.0
  sound.c - Sound component for Mostcore
  Copyright (C) 2015 Microchip Technology Germany II GmbH & Co. KG
  struct channel - private structure to keep channel specific data
  @substream: stores the substream structure
  @iface: interface for which the channel belongs to
  @cfg: channel configuration
  @card: registered sound card
  @list: list for private use
  @id: channel index
  @period_pos: current period position (ring buffer)
  @buffer_pos: current buffer position (ring buffer)
  @is_stream_running: identifies whether a stream is running or not
  @opened: set when the stream is opened
  @playback_task: playback thread
  @playback_waitq: waitq used by playback thread
  get_channel - get pointer to channel
  @iface: interface structure
  @channel_id: channel ID
  This traverses the channel list and returns the channel matching the
  ID and interface.
  Returns pointer to channel on success or NULL otherwise.
  copy_data - implements data copying function
  @channel: channel
  @mbo: MBO from core
  Copy data fromto ring buffer tofrom MBO and update the buffer position
 wrap around at end of ring buffer 
  playback_thread - function implements the playback thread
  @data: private data
  Thread which does the playback functionality in a loop. It waits for a free
  MBO from mostcore for a particular channel and copy the data from ring buffer
  to MBO. Submit the MBO back to mostcore, after copying the data.
  Returns 0 on success or error code otherwise.
  pcm_open - implements open callback function for PCM middle layer
  @substream: pointer to ALSA PCM substream
  This is called when a PCM substream is opened. At least, the function should
  initialize the runtime->hw record.
  Returns 0 on success or error code otherwise.
  pcm_close - implements close callback function for PCM middle layer
  @substream: sub-stream pointer
  Obviously, this is called when a PCM substream is closed. Any private
  instance for a PCM substream allocated in the open callback will be
  released here.
  Returns 0 on success or error code otherwise.
  pcm_prepare - implements prepare callback function for PCM middle layer
  @substream: substream pointer
  This callback is called when the PCM is "prepared". Format rate, sample rate,
  etc., can be set here. This callback can be called many times at each setup.
  Returns 0 on success or error code otherwise.
  pcm_trigger - implements trigger callback function for PCM middle layer
  @substream: substream pointer
  @cmd: action to perform
  This is called when the PCM is started, stopped or paused. The action will be
  specified in the second argument, SNDRV_PCM_TRIGGER_XXX
  Returns 0 on success or error code otherwise.
  pcm_pointer - implements pointer callback function for PCM middle layer
  @substream: substream pointer
  This callback is called when the PCM middle layer inquires the current
  hardware position on the buffer. The position must be returned in frames,
  ranging from 0 to buffer_size-1.
  Initialization of struct snd_pcm_ops
  audio_probe_channel - probe function of the driver module
  @iface: pointer to interface instance
  @channel_id: channel indexID
  @cfg: pointer to actual channel configuration
  @arg_list: string that provides the name of the device to be created in dev
 	      plus the desired audio resolution
  Creates sound card, pcm device, sets pcm ops and registers sound card.
  Returns 0 on success or error code otherwise.
  audio_disconnect_channel - function to disconnect a channel
  @iface: pointer to interface instance
  @channel_id: channel index
  This frees allocated memory and removes the sound card from ALSA
  Returns 0 on success or error code otherwise.
  audio_rx_completion - completion handler for rx channels
  @mbo: pointer to buffer object that has completed
  This searches for the channel this MBO belongs to and copy the data from MBO
  to ring buffer
  Returns 0 on success or error code otherwise.
  audio_tx_completion - completion handler for tx channels
  @iface: pointer to interface instance
  @channel_id: channel indexID
  This searches the channel that belongs to this combination of interface
  pointer and channel ID and wakes a process sitting in the wait queue of
  this channel.
  Returns 0 on success or error code otherwise.
  Initialization of the struct most_component
 SPDX-License-Identifier: GPL-2.0
  cdev.c - Character device component for Mostcore
  Copyright (C) 2013-2015 Microchip Technology Germany II GmbH & Co. KG
 synchronization lock to unlink channels 
  comp_open - implements the syscall to open the device
  @inode: inode pointer
  @filp: file pointer
  This stores the channel pointer in the private data field of
  the file structure and activates the channel within the core.
  comp_close - implements the syscall to close the device
  @inode: inode pointer
  @filp: file pointer
  This stops the channel within the core.
  comp_write - implements the syscall to write to the device
  @filp: file pointer
  @buf: pointer to user buffer
  @count: number of bytes to write
  @offset: offset from where to start writing
  comp_read - implements the syscall to read from the device
  @filp: file pointer
  @buf: pointer to user buffer
  @count: number of bytes to read
  @offset: offset from where to start reading
 make sure we don't submit to gone devices 
  Initialization of struct file_operations
  comp_disconnect_channel - disconnect a channel
  @iface: pointer to interface instance
  @channel_id: channel index
  This frees allocated memory and removes the cdev that represents this
  channel in user space.
  comp_rx_completion - completion handler for rx channels
  @mbo: pointer to buffer object that has completed
  This searches for the channel linked to this MBO and stores it in the local
  fifo buffer.
  comp_tx_completion - completion handler for tx channels
  @iface: pointer to interface instance
  @channel_id: channel indexID
  This wakes sleeping processes in the wait-queue.
  comp_probe - probe function of the driver module
  @iface: pointer to interface instance
  @channel_id: channel indexID
  @cfg: pointer to actual channel configuration
  @name: name of the device to be created
  This allocates achannel object and creates the device node in dev
  Returns 0 on success or error code otherwise.
 SPDX-License-Identifier: GPL-2.0
  core.c - Implementation of core module of MOST Linux driver stack
  Copyright (C) 2013-2020 Microchip Technology Germany II GmbH & Co. KG
 channel activation synchronization 
 nq thread synchronization 
 fifo access synchronization 
  list_pop_mbo - retrieves the first MBO of the list and removes it
  @ptr: the list head to grab the MBO from.
  most_free_mbo_coherent - free an MBO and its coherent buffer
  @mbo: most buffer
  flush_channel_fifos - clear the channel fifos
  @c: pointer to channel object
  flush_trash_fifo - clear the trash fifo
  @c: pointer to channel object
  get_channel - get pointer to channel
  @mdev: name of the device interface
  @mdev_ch: name of channel
  arm_mbo - recycle MBO for further usage
  @mbo: most buffer
  This puts an MBO back to the list to have it ready for up coming
  tx transactions.
  In case the MBO belongs to a channel that recently has been
  poisoned, the MBO is scheduled to be trashed.
  Calls the completion handler of an attached component.
  arm_mbo_chain - helper function that arms an MBO chain for the HDM
  @c: pointer to interface channel
  @dir: direction of the channel
  @compl: pointer to completion function
  This allocates buffer objects including the containing DMA coherent
  buffer and puts them in the fifo.
  Buffers of Rx channels are put in the kthread fifo, hence immediately
  submitted to the HDM.
  Returns the number of allocated and enqueued MBOs.
  most_submit_mbo - submits an MBO to fifo
  @mbo: most buffer
  most_write_completion - write completion handler
  @mbo: most buffer
  This recycles the MBO for further usage. In case the channel has been
  poisoned, the MBO is scheduled to be trashed.
  most_get_mbo - get pointer to an MBO of pool
  @iface: pointer to interface instance
  @id: channel ID
  @comp: driver component
  This attempts to get a free buffer out of the channel fifo.
  Returns a pointer to MBO on success or NULL otherwise.
  most_put_mbo - return buffer to pool
  @mbo: most buffer
  most_read_completion - read completion handler
  @mbo: most buffer
  This function is called by the HDM when data has been received from the
  hardware and copied to the buffer of the MBO.
  In case the channel has been poisoned it puts the buffer in the trash queue.
  Otherwise, it passes the buffer to an component for further processing.
  most_start_channel - prepares a channel for communication
  @iface: pointer to interface instance
  @id: channel ID
  @comp: driver component
  This prepares the channel for usage. Cross-checks whether the
  channel's been properly configured.
  Returns 0 on success or error code otherwise.
 already started by another component 
  most_stop_channel - stops a running channel
  @iface: pointer to interface instance
  @id: channel ID
  @comp: driver component
  most_register_component - registers a driver component with the core
  @comp: driver component
  most_deregister_component - deregisters a driver component with the core
  @comp: driver component
  most_register_interface - registers an interface with core
  @iface: device interface
  Allocates and initializes a new interface instance and all of its channels.
  Returns a pointer to kobject or an error pointer.
  most_deregister_interface - deregisters an interface with core
  @iface: device interface
  Before removing an interface instance from the list, all running
  channels are stopped and poisoned.
  most_stop_enqueue - prevents core from enqueueing MBOs
  @iface: pointer to interface
  @id: channel id
  This is called by an HDM that _cannot_ attend to its duties and
  is imminent to get run over by the core. The core is not going to
  enqueue any further packets unless the flagging HDM calls
  most_resume enqueue().
  most_resume_enqueue - allow core to enqueue MBOs again
  @iface: pointer to interface
  @id: channel id
  This clears the enqueue halt flag and enqueues all MBOs currently
  sitting in the wait fifo.
 SPDX-License-Identifier: GPL-2.0-or-later
  Linux I2C core ACPI support code
  Copyright (C) 2014 Intel Corp, Author: Lan Tianyu <tianyu.lan@intel.com>
  i2c_acpi_get_i2c_resource - Gets I2cSerialBus resource if type matches
  @ares:	ACPI resource
  @i2c:	Pointer to I2cSerialBus resource will be returned here
  Checks if the given ACPI resource is of type I2cSerialBus.
  In this case, returns a pointer to it to the caller.
  Returns true if resource type is of I2cSerialBus, otherwise false.
  i2c_acpi_client_count - Count the number of I2cSerialBus resources
  @adev:	ACPI device
  Returns the number of I2cSerialBus resources in the ACPI-device's
  resource-list; or a negative error code.
	
	  ACPI video acpi_devices, which are handled by the acpi-video driver
	  sometimes contain a SERIAL_TYPE_I2C ACPI resource, ignore these.
 Look up for I2cSerialBus resource 
 No need to add resource to the list 
  i2c_acpi_get_irq - get device IRQ number from ACPI
  @client: Pointer to the I2C client device
  Find the IRQ number used by a specific client device.
  Return: The IRQ number or an error code.
 The adapter must match the one in I2cSerialBus() connector 
 The adapter must be present 
  i2c_acpi_register_devices - enumerate I2C slave devices behind adapter
  @adap: pointer to adapter
  Enumerate all I2C slave devices behind this adapter by walking the ACPI
  namespace. When a device is found it will be added to the Linux device
  model and bound to the corresponding ACPI handle.
	
	  These Silead touchscreen controllers only work at 400KHz, for
	  some reason they do not work at 100KHz. On some devices the ACPI
	  tables list another device at their bus as only being capable
	  of 100KHz, testing has shown that these other devices work fine
	  at 400KHz (as can be expected of any recent i2c hw) so we force
	  the speed of the bus to 400 KHz if a Silead device is present.
  i2c_acpi_find_bus_speed - find I2C bus speed from ACPI
  @dev: The device owning the bus
  Find the I2C bus speed by walking the ACPI namespace for all I2C slaves
  devices connected to this bus and use the speed of slowest device.
  Returns the speed in Hz or zero
  i2c_acpi_new_device - Create i2c-client for the Nth I2cSerialBus resource
  @dev:     Device owning the ACPI resources to get the client from
  @index:   Index of ACPI resource to get
  @info:    describes the I2C device; note this is modified (addr gets set)
  Context: can sleep
  By default the i2c subsys creates an i2c-client for the first I2cSerialBus
  resource of an acpi_device, but some acpi_devices have multiple I2cSerialBus
  resources, in that case this function can be used to create an i2c-client
  for other I2cSerialBus resources in the Current Resource Settings table.
  Also see i2c_new_client_device, which this function calls to create the
  i2c-client.
  Returns a pointer to the new i2c-client, or error pointer in case of failure.
  Specifically, -EPROBE_DEFER is returned if the adapter is not found.
 Getting a NACK is unfortunately normal with some DSTDs 
 2 transfers must have completed successfully 
 1 transfer must have completed successfully 
 CONFIG_ACPI_I2C_OPREGION 
 SPDX-License-Identifier: GPL-2.0-only
  I2C slave mode EEPROM simulator
  Copyright (C) 2014 by Wolfram Sang, Sang Engineering <wsa@sang-engineering.com>
  Copyright (C) 2014 by Renesas Electronics Corporation
  Because most slave IP cores can only detect one I2C slave address anyhow,
  this driver does not support simulating EEPROM types which take more than
  one address.
  FIXME: What to do if only 8 bits of a 16 bit address are sent?
  The ST-M24C64 sends only 0xff then. Needs verification with other
  EEPROMs, though. We currently use the 8 bit as a valid address.
 The previous byte made it to the bus, get next one 
		
		  Do not increment buffer_idx here, because we don't know if
		  this byte will be actually used. Read Linux I2C slave docs
		  for details.
 An empty eeprom typically has all bits set to 1 
 SPDX-License-Identifier: GPL-2.0-or-later
  i2c-boardinfo.c - collect pre-declarations of I2C devices
 These symbols are exported ONLY FOR the i2c core.
  No other users will be supported.
  i2c_register_board_info - statically declare I2C devices
  @busnum: identifies the bus to which these devices belong
  @info: vector of i2c device descriptors
  @len: how many descriptors in the vector; may be zero to reserve
 	the specified bus number.
  Systems using the Linux I2C driver stack can declare tables of board info
  while they initialize.  This should be done in board-specific init code
  near arch_initcall() time, or equivalent, before any I2C adapter driver is
  registered.  For example, mainboard init code could define several devices,
  as could the init code for each daughtercard in a board stack.
  The I2C devices will be created later, after the adapter for the relevant
  bus has been registered.  After that moment, standard driver model tools
  are used to bind "new style" I2C drivers to the devices.  The bus number
  for any device declared using this routine is not available for dynamic
  allocation.
  The board info passed can safely be __initdata, but be careful of embedded
  pointers (for platform_data, functions, etc) since that won't be copied.
 dynamic bus numbers will be assigned after the last static one 
 SPDX-License-Identifier: GPL-2.0-or-later
  Linux I2C core
  Copyright (C) 1995-99 Simon G. Vogl
    With some changes from Kyösti Mälkki <kmalkki@cc.hut.fi>
    Mux support by Rodolfo Giometti <giometti@enneenne.com> and
    Michael Lawnick <michael.lawnick.ext@nsn.com>
  Copyright (C) 2013-2017 Wolfram Sang <wsa@kernel.org>
  core_lock protects i2c_adapter_idr, and guarantees that device detection,
  deletion of detected devices are serialized
 Attempt an OF style match 
 Then ACPI style match 
 Finally an I2C match 
 i2c bus recovery routines 
  We are generating clock pulses. ndelay() determines durating of clk pulses.
  We will generate clock with rate 100 KHz and so duration of both clock levels
  is: delay in ns = (10^6  100)  2
	
	  If we can set SDA, we will always create a STOP to ensure additional
	  pulses will do no harm. This is achieved by letting SDA follow SCL
	  half a cycle later. Check the 'incomplete_write_byte' fault injector
	  for details. Note that we must honour tsu:sto, 4us, but lets use 5us
	  here for simplicity.
	
	  By this time SCL is high, as we need to give 9 falling-rising edges
 SCL shouldn't be low here 
 Creating STOP again, see above 
 Honour minimum tsu:sto 
 Honour minimum tf and thd:dat 
 If we can't check bus status, assume recovery worked 
	
	  we can't change states without pinctrl, so remove the states if
	  populated
 for pinctrl state changes, we need all the information 
	
	  don't touch the recovery information if the driver is not using
	  generic SCL recovery
	
	  pins might be taken as GPIO, so we should inform pinctrl about
	  this and move the state to GPIO
	
	  if there is incomplete or no recovery information, see if generic
	  GPIO recovery is available
 SDA GPIOD line is optional, so we care about DEFER only 
		
		  We have SCL. Pull SCL low and wait a bit so that SDA glitches
		  have no effect.
 Wait a bit in case of a SDA glitch, and then release SCL. 
 change the state of the pins back to their default state 
 FIXME: add proper flag instead of '0' once available 
 Generic SCL recovery 
 Keep adapter active when Host Notify is required 
	
	  An I2C ID table is not mandatory, if and only if, a suitable OF
	  or ACPI ID table is supplied for the probing device.
	
	  When there are no more users of probe(),
	  rename probe_new to probe.
	
	  Note that we are not closing the devres group opened above so
	  even resources that were attached to the device after probe is
	  run are released when i2c_device_remove() is executed. This is
	  needed as some drivers would allocate additional resources,
	  for example when updating firmware.
 modalias helps coldplug:  modprobe $(cat ...modalias) 
  i2c_verify_client - return parameter as i2c_client, or NULL
  @dev: device, probably from some driver model iterator
  When traversing the driver model tree, perhaps using driver model
  iterators like @device_for_each_child(), you can't assume very much
  about the nodes you find.  Use this function to avoid oopses caused
  by wrongly treating some non-I2C device as an i2c_client.
 Return a unique address which takes the flags of the client into account 
 For some client flags, add an arbitrary offset to avoid collisions 
 This is a permissive address validity check, I2C address map constraints
 10-bit address, all values are valid 
 7-bit address, reject the general call address 
 And this is a strict address validity check, used when probing. If a
  device uses a reserved address, then it shouldn't be probed. 7-bit
  addressing is assumed, 10-bit address devices are rare and should be
	
	  Reserved addresses per I2C specification:
	   0x00       General call address  START byte
	   0x01       CBUS address
	   0x02       Reserved for different bus format
	   0x03       Reserved for future purposes
	   0x04-0x07  Hs-mode master code
	   0x78-0x7b  10-bit slave addressing
	   0x7c-0x7f  Reserved for future purposes
 walk up mux tree 
 recurse down mux tree 
  i2c_adapter_lock_bus - Get exclusive access to an I2C bus segment
  @adapter: Target I2C bus segment
  @flags: I2C_LOCK_ROOT_ADAPTER locks the root i2c adapter, I2C_LOCK_SEGMENT
 	locks only this branch in the adapter tree
  i2c_adapter_trylock_bus - Try to get exclusive access to an I2C bus segment
  @adapter: Target I2C bus segment
  @flags: I2C_LOCK_ROOT_ADAPTER trylocks the root i2c adapter, I2C_LOCK_SEGMENT
 	trylocks only this branch in the adapter tree
  i2c_adapter_unlock_bus - Release exclusive access to an I2C bus segment
  @adapter: Target I2C bus segment
  @flags: I2C_LOCK_ROOT_ADAPTER unlocks the root i2c adapter, I2C_LOCK_SEGMENT
 	unlocks only this branch in the adapter tree
  i2c_new_client_device - instantiate an i2c device
  @adap: the adapter managing the device
  @info: describes one I2C device; bus_num is ignored
  Context: can sleep
  Create an i2c device. Binding is handled through driver model
  probe()remove() methods.  A driver may be bound to this device when we
  return from this function, or any later moment (e.g. maybe hotplugging will
  load the driver module).  This call is not appropriate for use by mainboard
  initialization logic, which usually runs during an arch_initcall() long
  before any i2c_adapter could exist.
  This returns the new i2c client, which may be saved for later use with
  i2c_unregister_device(); or an ERR_PTR to describe the error.
 Check for address business 
  i2c_unregister_device - reverse effect of i2c_new__device()
  @client: value returned from i2c_new__device()
  Context: can sleep
  i2c_new_dummy_device - return a new i2c device bound to a dummy driver
  @adapter: the adapter managing the device
  @address: seven bit address to be used
  Context: can sleep
  This returns an I2C client bound to the "dummy" driver, intended for use
  with devices that consume multiple addresses.  Examples of such chips
  include various EEPROMS (like 24c04 and 24c08 models).
  These dummy devices have two main uses.  First, most I2C and SMBus calls
  except i2c_transfer() need a client handle; the dummy will be that handle.
  And second, this prevents the specified address from being bound to a
  different driver.
  This returns the new i2c client, which should be saved for later use with
  i2c_unregister_device(); or an ERR_PTR to describe the error.
  devm_i2c_new_dummy_device - return a new i2c device bound to a dummy driver
  @dev: device the managed resource is bound to
  @adapter: the adapter managing the device
  @address: seven bit address to be used
  Context: can sleep
  This is the device-managed version of @i2c_new_dummy_device. It returns the
  new i2c client or an ERR_PTR in case of an error.
  i2c_new_ancillary_device - Helper to get the instantiated secondary address
  and create the associated device
  @client: Handle to the primary client
  @name: Handle to specify which secondary address to get
  @default_addr: Used as a fallback if no secondary address was specified
  Context: can sleep
  I2C clients can be composed of multiple I2C slaves bound together in a single
  component. The I2C client driver then binds to the master I2C slave and needs
  to create I2C dummy clients to communicate with all the other slaves.
  This function creates and returns an I2C dummy client whose I2C address is
  retrieved from the platform firmware based on the given slave name. If no
  address is specified by the firmware default_addr is used.
  On DT-based platforms the address is retrieved from the "reg" property entry
  cell whose "reg-names" value matches the slave name.
  This returns the new i2c client, which should be saved for later use with
  i2c_unregister_device(); or an ERR_PTR to describe the error.
 ------------------------------------------------------------------------- 
 I2C bus adapters -- one roots each I2C or SMBUS segment 
  Let users instantiate I2C devices through sysfs. This can be used when
  platform initialization code doesn't contain the proper data for
  whatever reason. Also useful for drivers that do device detection and
  detection fails, either because the device uses an unexpected address,
  or this is a compatible device with different ID register values.
  Parameter checking may look overzealous, but we really don't want
  the user to provide incorrect parameters.
 Parse remaining parameters, reject extra parameters 
 Keep track of the added device 
  And of course let the users delete the devices they instantiated, if
  they got it wrong. This interface can only be used to delete devices
  instantiated by i2c_sysfs_new_device above. This guarantees that we
  don't delete devices to which some kernel code still has references.
  Parameter checking may look overzealous, but we really don't want
  the user to delete the wrong device.
 Parse parameters, reject extra parameters 
 Make sure the device was added through sysfs 
  i2c_verify_adapter - return parameter as i2c_adapter or NULL
  @dev: device, probably from some driver model iterator
  When traversing the driver model tree, perhaps using driver model
  iterators like @device_for_each_child(), you can't assume very much
  about the nodes you find.  Use this function to avoid oopses caused
  by wrongly treating some non-I2C device as an i2c_adapter.
 Detect supported devices on that bus, and instantiate them 
  i2c_handle_smbus_host_notify - Forward a Host Notify event to the correct
  I2C client.
  @adap: the adapter
  @addr: the I2C address of the notifying device
  Context: can't sleep
  Helper function to be called from an I2C bus driver's interrupt
  handler. It will schedule the Host Notify IRQ.
 Can't register until after driver model init 
 Sanity checks 
 Set default timeout to 1 second if not already set 
 register soft irqs for Host Notify 
 create pre-declared device nodes 
 Notify drivers 
  __i2c_add_numbered_adapter - i2c_add_numbered_adapter where nr is never -1
  @adap: the adapter to register (with adap->nr initialized)
  Context: can sleep
  See i2c_add_numbered_adapter() for details.
  i2c_add_adapter - declare i2c adapter, use dynamic bus number
  @adapter: the adapter to add
  Context: can sleep
  This routine is used to declare an I2C adapter when its bus number
  doesn't matter or when its bus number is specified by an dt alias.
  Examples of bases when the bus number doesn't matter: I2C adapters
  dynamically added by USB links or PCI plugin cards.
  When this returns zero, a new bus number was allocated and stored
  in adap->nr, and the specified adapter became available for clients.
  Otherwise, a negative errno value is returned.
  i2c_add_numbered_adapter - declare i2c adapter, use static bus number
  @adap: the adapter to register (with adap->nr initialized)
  Context: can sleep
  This routine is used to declare an I2C adapter when its bus number
  matters.  For example, use it for I2C adapters from system-on-chip CPUs,
  or otherwise built in to the system's mainboard, and where i2c_board_info
  is used to properly configure I2C devices.
  If the requested bus number is set to -1, then this function will behave
  identically to i2c_add_adapter, and will dynamically assign a bus number.
  If no devices have pre-been declared for this bus, then be sure to
  register the adapter before any dynamically allocated ones.  Otherwise
  the required bus ID may not be available.
  When this returns zero, the specified adapter became available for
  clients using the bus number provided in adap->nr.  Also, the table
  of I2C devices pre-declared using i2c_register_board_info() is scanned,
  and the appropriate driver model device nodes are created.  Otherwise, a
  negative errno value is returned.
 -1 means dynamically assign bus id 
	 Remove the devices we created ourselves as the result of hardware
  i2c_del_adapter - unregister I2C adapter
  @adap: the adapter being unregistered
  Context: can sleep
  This unregisters an I2C adapter which was previously registered
  by @i2c_add_adapter or @i2c_add_numbered_adapter.
 First make sure that this adapter was ever added 
 Tell drivers about this removal 
 Remove devices instantiated from sysfs 
	 Detach any active clients. This can't fail, thus we do not
	  check the returned value. This is a two-pass process, because
	  we can't remove the dummy devices during the first pass: they
	  could have been instantiated by real devices wishing to clean
 device name is gone after device_unregister 
	 wait until all references to the device are gone
	 
	  FIXME: This is old code and should ideally be replaced by an
	  alternative which results in decoupling the lifetime of the struct
	  device from the i2c_adapter, like spi or netdev do. Any solution
	  should be thoroughly tested with DEBUG_KOBJECT_RELEASE enabled!
 free bus id 
	 Clear the device structure in case this adapter is ever going to be
  devm_i2c_add_adapter - device-managed variant of i2c_add_adapter()
  @dev: managing device for adding this I2C adapter
  @adapter: the adapter to add
  Context: can sleep
  Add adapter with dynamic bus number, same with i2c_add_adapter()
  but the adapter will be auto deleted on driver detach.
  i2c_parse_fw_timings - get I2C related timing parameters from firmware
  @dev: The device to scan for I2C timing properties
  @t: the i2c_timings struct to be filled with values
  @use_defaults: bool to use sane defaults derived from the I2C specification
 		  when properties are not found, otherwise don't update
  Scan the device for the generic I2C properties describing timing parameters
  for the signal and fill the given struct with the results. If a property was
  not found and use_defaults was true, then maximum timings are assumed which
  are derived from the I2C specification. If use_defaults is not used, the
  results will be as before, so drivers can apply their own defaults before
  calling this helper. The latter is mainly intended for avoiding regressions
  of existing drivers which want to switch to this function. New drivers
  almost always should use the defaults.
 ------------------------------------------------------------------------- 
  An i2c_driver is used with one or more i2c_client (device) nodes to access
  i2c slave chips, on a bus instance associated with some i2c_adapter.
 Can't register until after driver model init 
 add the driver to the list of i2c drivers in the driver core 
	 When registration returns, the driver core
	  will have called probe() for all matching-but-unbound devices.
 Walk the adapters that are already present 
  i2c_del_driver - unregister I2C driver
  @driver: the driver being unregistered
  Context: can sleep
 ------------------------------------------------------------------------- 
 We must initialize early, because some subsystems register i2c drivers
  in subsys_initcall() code, but are linked (and initialized) before i2c.
 ----------------------------------------------------
  the functional interface to the i2c busses.
  ----------------------------------------------------
 Check if val is exceeding the quirk IFF quirk is non 0 
 special checks for combined messages 
  __i2c_transfer - unlocked flavor of i2c_transfer
  @adap: Handle to I2C bus
  @msgs: One or more messages to execute before STOP is issued to
 	terminate the operation; each message begins with a START.
  @num: Number of messages to be executed.
  Returns negative errno, else the number of messages executed.
  Adapter lock must be held when calling this function. No debug logging
  takes place. adap->algo->master_xfer existence isn't checked.
	
	  i2c_trace_msg_key gets enabled when tracepoint i2c_transfer gets
	  enabled.  This is an efficient way of keeping the for-loop from
	  being executed when not needed.
 Retry automatically on arbitration loss 
  i2c_transfer - execute a single or combined I2C message
  @adap: Handle to I2C bus
  @msgs: One or more messages to execute before STOP is issued to
 	terminate the operation; each message begins with a START.
  @num: Number of messages to be executed.
  Returns negative errno, else the number of messages executed.
  Note that there is no requirement that each message be sent to
  the same slave address, although that is the most common model.
	 REVISIT the fault reporting model here is weak:
	 
	   - When we get an error after receiving N bytes from a slave,
	     there is no way to report "N".
	 
	   - When we get a NAK after transmitting N bytes to a slave,
	     there is no way to report "N" ... or to let the master
	     continue executing the rest of this combined message, if
	     that's the appropriate response.
	 
	   - When for example "num" is two and we successfully complete
	     the first message but get an error part way through the
	     second, it's unclear whether that should be reported as
	     one (discarding status on the second message) or errno
	     (discarding status on the first one).
  i2c_transfer_buffer_flags - issue a single I2C message transferring data
 			       tofrom a buffer
  @client: Handle to slave device
  @buf: Where the data is stored
  @count: How many bytes to transfer, must be less than 64k since msg.len is u16
  @flags: The flags to be used for the message, e.g. I2C_M_RD for reads
  Returns negative errno, or else the number of bytes transferred.
	
	  If everything went ok (i.e. 1 msg transferred), return #bytes
	  transferred, else error code.
  i2c_get_device_id - get manufacturer, part id and die revision of a device
  @client: The device to query
  @id: The queried information
  Returns negative errno on error, zero on success.
 ----------------------------------------------------
  the i2c address scanning function
  Will not work for 10-bit addresses!
  ----------------------------------------------------
  Legacy default probe function, mostly relevant for SMBus. The default
  probe method is a quick write, but it is known to corrupt the 24RF08
  EEPROMs due to a state machine bug, and could also irreversibly
  write-protect some EEPROMs, so for address ranges 0x30-0x37 and 0x50-0x5f,
  we use a short byte read instead. Also, some bus drivers don't implement
  quick write, so we fallback to a byte read in that case too.
  On x86, there is another special case for FSC hardware monitoring chips,
  which want regular byte reads (address 0x73.) Fortunately, these are the
  only known chips using this I2C address on PC hardware.
  Returns 1 if probe succeeded, 0 if not.
 Make sure the address is valid 
 Skip if already in use (7 bit, no need to encode flags) 
 Make sure there is something at this address 
 Finally call the custom detection function 
		 -ENODEV is returned if the detection fails. We catch it
 Consistency check 
 Detection succeeded, instantiate the device 
 Warn that the adapter lost class based instantiation 
 Stop here if the classes do not match 
 Set up a temporary client to help detect callback 
 Check address validity 
 Check address availability (7 bit, no need to encode flags) 
 Test address responsiveness 
  i2c_get_dma_safe_msg_buf() - get a DMA safe buffer for the given i2c_msg
  @msg: the message to be checked
  @threshold: the minimum number of bytes for which using DMA makes sense.
 	       Should at least be 1.
  Return: NULL if a DMA safe buffer was not obtained. Use msg->buf with PIO.
 	   Or a valid pointer to be used with DMA. After use, release it by
 	   calling i2c_put_dma_safe_msg_buf().
  This function must only be called from process context!
 also skip 0-length msgs for bogus thresholds of 0 
  i2c_put_dma_safe_msg_buf - release DMA safe buffer and sync with i2c_msg
  @buf: the buffer obtained from i2c_get_dma_safe_msg_buf(). May be NULL.
  @msg: the message which the buffer corresponds to
  @xferred: bool saying if the message was transferred
 SPDX-License-Identifier: GPL-2.0-or-later
    i2c-stub.c - I2CSMBus chip emulator
    Copyright (c) 2004 Mark M. Hoffman <mhoffman@lightlink.com>
    Copyright (C) 2007-2014 Jean Delvare <jdelvare@suse.de>
  Support for I2C_FUNC_SMBUS_BLOCK_DATA is disabled by default and must
  be enabled explicitly by setting the I2C_FUNC_SMBUS_BLOCK_DATA bits
  in the 'functionality' module parameter.
 Some chips have banked register ranges 
	u16 words[256];		 Byte operations use the LSB as per SMBus
 For chips with banks, extra registers are allocated dynamically 
 Currently selected bank 
 Room for bank_mask  bank_size registers 
 Return negative errno on error. 
 Search for the right chip 
 Set the bank as needed 
		
		  We ignore banks here, because banked chips don't use I2C
		  block transfers
 Avoid overrun 
		
		  We ignore banks here, because chips typically don't use both
		  banks and SMBus block transfers
 Largest write sets read block length 
 update for byte and word commands 
 switch (size) 
 We assume that all bits in the mask are contiguous 
 Allocate memory for all chips at once 
 Allocate extra memory for banked register ranges 
 SPDX-License-Identifier: GPL-2.0-or-later
    i2c-dev.c - i2c-bus driver, char device interface
    Copyright (C) 1995-97 Simon G. Vogl
    Copyright (C) 1998-99 Frodo Looijaard <frodol@dds.nl>
    Copyright (C) 2003 Greg Kroah-Hartman <greg@kroah.com>
 Note that this is a complete rewrite of Simon Vogl's i2c-dev module.
   But I have used so much of his original code and ideas that it seems
 The I2C_RDWR ioctl code is written by Kolja Waschk <waschk@telos.de> 
  An i2c_dev represents an i2c_adapter ... an I2C or SMBus master, not a
  slave (i2c_client) with which messages will be exchanged.  It's coupled
  with a character special file which is accessed by user mode drivers.
  The list of i2c_dev structures is parallel to the i2c_adapter lists
  maintained by the driver model, and is updated using bus notifications.
 ------------------------------------------------------------------------- 
  After opening an instance of this character special file, a file
  descriptor starts out associated only with an i2c_adapter (and bus).
  Using the I2C_RDWR ioctl(), you can then immediately issue i2c_msg
  traffic to any devices on the bus used by that adapter.  That's because
  the i2c_msg vectors embed all the addressing information they need, and
  are submitted directly to an i2c_adapter.  However, SMBus-only adapters
  don't support that interface.
  To use read()write() system calls on that file descriptor, or to use
  SMBus interfaces (and work with SMBus-only hosts!), you must first issue
  an I2C_SLAVE (or I2C_SLAVE_FORCE) ioctl.  That configures an anonymous
  (never registered) i2c_client so it holds the addressing information
  needed by those system calls and by this SMBus interface.
 walk up mux tree 
 recurse down mux tree 
 This address checking function differs from the one in i2c-core
   in that it considers an address with a registered device, but no
 Limit the size of the message to a sane amount 
 memdup_user allocates with GFP_KERNEL, so DMA is ok 
		
		  If the message length is received from the slave (similar
		  to SMBus block read), we must ensure that the buffer will
		  be large enough to cope with a message length of
		  I2C_SMBUS_BLOCK_MAX as this is the maximum underlying bus
		  drivers allow. The first byte in the buffer must be
		  pre-filled with the number of extra bytes, which must be
		  at least one to hold the message length, but can be
		  greater (for example to account for a checksum byte at
		  the end of the message.)
	 Note that I2C_SMBUS_READ and I2C_SMBUS_WRITE are 0 and 1,
 Note that command values are always valid! 
 These are special: we do not use data 
 size == smbus block, i2c block, or block proc. call 
		 Convert old I2C block commands to the new
 REVISIT: address could become busy later 
		
		  Setting the PEC flag here won't affect kernel drivers,
		  which will be using the i2c_client node registered with
		  the driver model core.  Likewise, when that client has
		  the PEC flag already set, the i2c-dev driver won't see
		  (or use) this setting.
		
		  Put an arbitrary limit on the number of messages that can
		  be sent at once
		 For historical reasons, user-space sets the timeout
		  value in units of 10 ms.
		 NOTE:  returning a fault code here could cause trouble
		  in buggy userspace code.  Some old kernel bugs returned
		  zero in this case, and userspace code might accidentally
		  have depended on that bug.
 union i2c_smbus_data data 
 struct i2c_msg __user msgs 
	 This creates an anonymous i2c_client, which may later be
	  pointed to some address using I2C_SLAVE or I2C_SLAVE_FORCE.
	 
	  This client is  NEVER REGISTERED  with the driver model
	  or I2C core code!!  It just holds private copies of addressing
	  information and maybe a PEC flag.
 ------------------------------------------------------------------------- 
 attach_adapter must have failed 
 ------------------------------------------------------------------------- 
  module loadunload record keeping
 Keep track of adapters which will be added or removed later 
 Bind to already existing adapters right away 
 SPDX-License-Identifier: GPL-2.0-only
  I2C slave mode testunit
  Copyright (C) 2020 by Wolfram Sang, Sang Engineering <wsa@sang-engineering.com>
  Copyright (C) 2020 by Renesas Electronics Corporation
 FIXME: is system_long_wq the best choice? 
 save 0 for ABORT, RESET or similar 
 convert '0 msgs transferred' to errno 
 TU_REG_CMD always written at this point 
  Multiplexed I2C bus driver.
  Copyright (c) 2008-2009 Rodolfo Giometti <giometti@linux.it>
  Copyright (c) 2008-2009 Eurotech S.p.A. <info@eurotech.it>
  Copyright (c) 2009-2010 NSN GmbH & Co KG <michael.lawnick.ext@nsn.com>
  Simplifies access to complex multiplexed I2C bus topologies, by presenting
  each multiplexed bus segment as an additional I2C adapter.
  Supports multi-level mux'ing (mux behind a mux).
  Based on:
 	i2c-virt.c from Kumar Gala <galak@kernel.crashing.org>
 	i2c-virtual.c from Ken Harrenstien, Copyright (c) 2004 Google, Inc.
 	i2c-virtual.c from Brian Kuschak <bkuschak@yahoo.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 multiplexer per channel data 
 Switch to the right mux port and perform the transfer. 
 Switch to the right mux port and perform the transfer. 
 Select the right mux port and perform the transfer. 
 Select the right mux port and perform the transfer. 
 Return the parent's functionality 
 Return all parent classes, merged 
 mux_lock not locked, failure 
 we only want mux_lock, success 
 parent locked too, success 
 parent not locked, failure 
 mux_lock not locked, failure 
 parent locked too, success 
 parent not locked, failure 
	
	  Walk up the device tree to find an i2c adapter, indicating
	  that this is an i2c client device. Check all ancestors to
	  handle mfd devices etc.
 Continue up the tree to find the root i2c adapter 
 Set up private adapter data 
	 Need to do algo dynamically because we don't know ahead
	  of time what sort of physical adapter we'll be dealing with.
 Now fill out new adapter structure 
 Sanity check on class 
	
	  Try to populate the mux adapter's of_node, expands to
	  nothing if !CONFIG_OF.
 A "reg" property indicates an old-style DT entry 
	
	  Associate the mux channel with an ACPI node.
 SPDX-License-Identifier: GPL-2.0-or-later
  Linux I2C core OF support code
  Copyright (C) 2008 Jochen Friedrich <jochen@scram.de>
  based on a previous patch from Jon Smirl <jonsmirl@gmail.com>
  Copyright (C) 2013, 2018 Wolfram Sang <wsa@kernel.org>
 Only register child devices if the adapter has a node pointer set 
 must call put_device() when done with returned i2c_client device 
 must call put_device() when done with returned i2c_adapter device 
 must call i2c_put_adapter() when done with returned i2c_adapter device 
		
		  Adding devices through the i2c sysfs interface provides us
		  a string to match which may be compatible with the device
		  tree compatible strings, however with no actual of_node the
		  of_match_device() will not match
 not for us 
 already depopulated? 
 find our device by node 
 no? not meant for us 
 unregister takes one ref away 
 and put the reference of the find 
 CONFIG_OF_DYNAMIC 
 SPDX-License-Identifier: GPL-2.0-or-later
  i2c-smbus.c - SMBus extensions to the I2C protocol
  Copyright (C) 2008 David Brownell
  Copyright (C) 2010-2019 Jean Delvare <jdelvare@suse.de>
 Alert response address 
 If this is the alerting device, notify its driver 
	
	  Drivers should either disable alerts, or provide at least
	  a minimal handler.  Lock so the driver won't change.
 Stop iterating after we find the device 
  The alert IRQ handler needs to hand work off to a task which can issue
  SMBus calls, because those sleeping calls can't be made in IRQ context.
		
		  Devices with pending alerts reply in address order, low
		  to high, because of slave transmit arbitration.  After
		  responding, an SMBus device stops asserting SMBALERT#.
		 
		  Note that SMBus 2.0 reserves 10-bit addresses for future
		  use.  We neither handle them, nor try to use PEC here.
 Notify driver for the device which issued the alert 
 Setup SMBALERT# infrastructure 
 IRQ and memory resources are managed so they are freed automatically 
 LIST END  }
  i2c_handle_smbus_alert - Handle an SMBus alert
  @ara: the ARA client on the relevant adapter
  Context: can't sleep
  Helper function to be called from an I2C bus driver's interrupt
  handler. It will schedule the alert work, in turn calling the
  corresponding I2C device driver's alert function.
  It is assumed that ara is a valid i2c client previously returned by
  i2c_new_smbus_alert_device().
		 We only retrieve the first byte received (addr)
		  since there is currently no support to retrieve the data
		  parameter from the client.
  i2c_new_slave_host_notify_device - get a client for SMBus host-notify support
  @adapter: the target adapter
  Context: can sleep
  Setup handling of the SMBus host-notify protocol on a given I2C bus segment.
  Handling is done by creating a device and its callback and handling data
  received via the SMBus host-notify address (0x8)
  This returns the client, which should be ultimately freed using
  i2c_free_slave_host_notify_device(); or an ERRPTR to indicate an error.
  i2c_free_slave_host_notify_device - free the client for SMBus host-notify
  support
  @client: the client to free
  Context: can sleep
  Free the i2c_client allocated via i2c_new_slave_host_notify_device
  SPD is not part of SMBus but we include it here for convenience as the
  target systems are the same.
  Restrictions to automatic SPD instantiation:
   - Only works if all filled slots have the same memory type
   - Only works for DDR2, DDR3 and DDR4 for now
   - Only works on systems with 1 to 4 memory slots
 Skip empty slots 
 Skip undefined memory type 
 Invalid, Other, Unknown 
 First filled slot 
 Check that all filled slots have the same type 
 No useful DMI data, bail out 
 DDR2 
 DDR3 
 LPDDR2 
 LPDDR3 
 DDR4 
 LPDDR4 
	
	  We don't know in which slots the memory modules are. We could
	  try to guess from the slot names, but that would be rather complex
	  and unreliable, so better probe all possible addresses until we
	  have found all memory modules.
 SPDX-License-Identifier: GPL-2.0-or-later
  Linux I2C core SMBus and SMBus emulation code
  This file contains the SMBus functions which are always included in the I2C
  core because they can be emulated via I2C. SMBus specific extensions
  (e.g. smbalert) are handled in a separate i2c-smbus module.
  All SMBus-related things are written by Frodo Looijaard <frodol@dds.nl>
  SMBus 2.0 support by Mark Studebaker <mdsxyz123@yahoo.com> and
  Jean Delvare <jdelvare@suse.de>
 The SMBus parts 
  i2c_smbus_pec - Incremental CRC8 over the given input data array
  @crc: previous return crc8 value
  @p: pointer to data buffer.
  @count: number of bytes in data buffer.
  Incremental CRC8 over count bytes in the array pointed to by p
 Assume a 7-bit address, which is reasonable for SMBus 
 The address will be sent first 
 The data buffer follows 
 Used for write only transactions 
 Return <0 on CRC error
   If there was a write before this read (most cases) we need to take the
   partial CRC from the write part into account.
   Note that this function does modify the message (we need to decrease the
  i2c_smbus_read_byte - SMBus "receive byte" protocol
  @client: Handle to slave device
  This executes the SMBus "receive byte" protocol, returning negative errno
  else the byte received from the device.
  i2c_smbus_write_byte - SMBus "send byte" protocol
  @client: Handle to slave device
  @value: Byte to be sent
  This executes the SMBus "send byte" protocol, returning negative errno
  else zero on success.
  i2c_smbus_read_byte_data - SMBus "read byte" protocol
  @client: Handle to slave device
  @command: Byte interpreted by slave
  This executes the SMBus "read byte" protocol, returning negative errno
  else a data byte received from the device.
  i2c_smbus_write_byte_data - SMBus "write byte" protocol
  @client: Handle to slave device
  @command: Byte interpreted by slave
  @value: Byte being written
  This executes the SMBus "write byte" protocol, returning negative errno
  else zero on success.
  i2c_smbus_read_word_data - SMBus "read word" protocol
  @client: Handle to slave device
  @command: Byte interpreted by slave
  This executes the SMBus "read word" protocol, returning negative errno
  else a 16-bit unsigned "word" received from the device.
  i2c_smbus_write_word_data - SMBus "write word" protocol
  @client: Handle to slave device
  @command: Byte interpreted by slave
  @value: 16-bit "word" being written
  This executes the SMBus "write word" protocol, returning negative errno
  else zero on success.
  i2c_smbus_read_block_data - SMBus "block read" protocol
  @client: Handle to slave device
  @command: Byte interpreted by slave
  @values: Byte array into which data will be read; big enough to hold
 	the data returned by the slave.  SMBus allows at most 32 bytes.
  This executes the SMBus "block read" protocol, returning negative errno
  else the number of data bytes in the slave's response.
  Note that using this function requires that the client's adapter support
  the I2C_FUNC_SMBUS_READ_BLOCK_DATA functionality.  Not all adapter drivers
  support this; its emulation through I2C messaging relies on a specific
  mechanism (I2C_M_RECV_LEN) which may not be implemented.
  i2c_smbus_write_block_data - SMBus "block write" protocol
  @client: Handle to slave device
  @command: Byte interpreted by slave
  @length: Size of data block; SMBus allows at most 32 bytes
  @values: Byte array which will be written.
  This executes the SMBus "block write" protocol, returning negative errno
  else zero on success.
 Returns the number of read bytes 
  Simulate a SMBus command using the I2C protocol.
  No checking of parameters is done!
	
	  So we need to generate a series of msgs. In the case of writing, we
	  need to use only one message; when reading, we need two. We
	  initialize most things with sane defaults, to keep the code below
	  somewhat simpler.
 Special case: The readwrite field is used as data 
 Special case: only a read! 
 Special case 
			msg[1].len = 1;  block length will be added by
 Another special case 
		msg[1].len = 1;  block length will be added by
 Compute PEC if first message is a write 
 Write only 
 Write followed by read 
 Ask for PEC if last message is a read 
 Check PEC if last message is a read 
  i2c_smbus_xfer - execute SMBus protocol operations
  @adapter: Handle to I2C bus
  @addr: Address of SMBus slave on that bus
  @flags: I2C_CLIENT_ flags (usually zero or I2C_CLIENT_PEC)
  @read_write: I2C_SMBUS_READ or I2C_SMBUS_WRITE
  @command: Byte interpreted by slave, for protocols which use such bytes
  @protocol: SMBus protocol operation to execute, such as I2C_SMBUS_PROC_CALL
  @data: Data to be read or written
  This executes an SMBus protocol operation, and returns a negative
  errno code else zero on success.
	 If enabled, the following two tracepoints are conditional on
	  read_write and protocol.
 fallback to I2C emulation 
 Retry automatically on arbitration loss 
		
		  Fall back to i2c_smbus_xfer_emulated if the adapter doesn't
		  implement native support for the SMBus operation.
 If enabled, the reply tracepoint is conditional on read_write. 
  i2c_smbus_read_i2c_block_data_or_emulated - read block or emulate
  @client: Handle to slave device
  @command: Byte interpreted by slave
  @length: Size of data block; SMBus allows at most I2C_SMBUS_BLOCK_MAX bytes
  @values: Byte array into which data will be read; big enough to hold
 	the data returned by the slave.  SMBus allows at most
 	I2C_SMBUS_BLOCK_MAX bytes.
  This executes the SMBus "block read" protocol if supported by the adapter.
  If block read is not supported, it emulates it using either word or byte
  read protocols depending on availability.
  The addresses of the I2C slave device that are accessed with this function
  must be mapped to a linear region, so that a block read will have the same
  effect as a byte read. Before using this function you must double-check
  if the I2C slave does support exchanging a block transfer with a byte
  transfer.
  i2c_new_smbus_alert_device - get ara client for SMBus alert support
  @adapter: the target adapter
  @setup: setup data for the SMBus alert handler
  Context: can sleep
  Setup handling of the SMBus alert protocol on a given I2C bus segment.
  Handling can be done either through our IRQ handler, or by the
  adapter (from its handler, periodic polling, or whatever).
  This returns the ara client, which should be saved for later use with
  i2c_handle_smbus_alert() and ultimately i2c_unregister_device(); or an
  ERRPTR to indicate an error.
 SPDX-License-Identifier: GPL-2.0-or-later
  Linux I2C core slave support code
  Copyright (C) 2014 by Wolfram Sang <wsa@sang-engineering.com>
 Enforce stricter address checking 
  i2c_detect_slave_mode - detect operation mode
  @dev: The device owning the bus
  This checks the device nodes for an I2C slave by checking the address
  used in the reg property. If the address match the I2C_OWN_SLAVE_ADDRESS
  flag this means the device is configured to act as a I2C slave and it will
  be listening at that address.
  Returns true if an I2C own slave address is detected, otherwise returns
  false.
 SPDX-License-Identifier: GPL-2.0-only
  Driver for the TAOS evaluation modules
  These devices include an I2C master which can be controlled over the
  serial port.
  Copyright (C) 2007 Jean Delvare <jdelvare@suse.de>
 last used address 
 position inside the buffer 
 TAOS TSL2550 EVM 
 Instantiate i2c devices based on the adapter name 
	 Encode our transaction. "@" is for the device address, "$" for the
	 The device remembers the last used address, no need to send it
 Send the transaction to the TAOS EVM 
 Start the transaction and read the answer 
 Interpret the returned string 
			
			  Voluntarily dropping error code of kstrtou8 since all
			  error code that it could return are invalid according
			  to Documentationi2cfault-codes.rst.
 Extract the adapter name from the buffer received after reset.
 Reset the TAOS evaluation module to identify it 
 Turn echo off for better performance 
 SPDX-License-Identifier: GPL-2.0-or-later
  Synopsys DesignWare I2C adapter driver (master only).
  Based on the TI DAVINCI I2C adapter driver.
  Copyright (C) 2006 Texas Instruments.
  Copyright (C) 2007 MontaVista Software Inc.
  Copyright (C) 2009 Provigent Ltd.
  Copyright (C) 2011, 2015, 2016 Intel Corporation.
 Merrifield HCNTLCNTSDA hold time 
 BayTrail HCNTLCNTSDA hold time 
 Haswell HCNTLCNTSDA hold time 
 NAVI-AMD HCNTLCNTSDA hold time 
   TODO find a better way how to deduplicate instantiation
   of USB PD slave device from nVidia GPU driver.
	
	  On Intel Merrifield the user visible i2c buses are enumerated
	  [1..7]. So, we add 1 to shift the default range. Besides that the
	  first PCI slot provides 4 functions, that's why we have to add 0 to
	  the first slot and 4 to the next one.
 work with hotplug and coldplug 
 Medfield 
 Merrifield 
 Baytrail 
 Haswell 
 Braswell  Cherrytrail 
 Elkhart Lake (PSE I2C) 
 SPDX-License-Identifier: GPL-2.0-or-later
  IBM OPAL I2C driver
  Copyright (C) 2014 IBM
	 We only support fairly simple combinations here of one
	  or two messages
  For two messages, we basically support simple smbus transactions of a
  write-then-anything.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2011 LAPIS Semiconductor Co., Ltd.
 I2C Interrupt Event Set Status 
 I2C Interrupt Event Clear Status 
 Maximum Clock speed in MHz 
 flag for Buffer mode enable 
 EEPROM SW RST enable flag 
 I2C slave address register 
 I2C control register 
 I2C status register 
 I2C data register 
 I2C bus monitor register 
 I2C bus transfer rate setup counter 
 I2C mode register 
 I2C buffer mode slave address register 
 I2C buffer mode subaddress register 
 I2C buffer mode format register 
 I2C buffer mode control register 
 I2C buffer mode interrupt mask register 
 I2C buffer mode status register 
 I2C buffer mode level register 
 EEPROM software reset mode format register 
 EEPROM software reset mode ctrl register 
 EEPROM software reset mode 
 EEPROM software reset mode status register 
 I2C timer register 
 I2C reset register 
 I2C noise filter register 
Set the number of I2C instance max
Intel EG20T PCH :		1ch
LAPIS Semiconductor ML7213 IOH :	2ch
LAPIS Semiconductor ML7831 IOH :	1ch
  struct i2c_algo_pch_data - for I2C driver functionalities
  @pch_adapter:		stores the reference to i2c_adapter structure
  @p_adapter_info:		stores the reference to adapter_info structure
  @pch_base_address:		specifies the remapped base address
  @pch_buff_mode_en:		specifies if buffer mode is enabled
  @pch_event_flag:		specifies occurrence of interrupt events
  @pch_i2c_xfer_in_progress:	specifies whether the transfer is completed
  struct adapter_info - This structure holds the adapter information for the
 			 PCH i2c controller
  @pch_data:		stores a list of i2c_algo_pch_data
  @pch_i2c_suspended:	specifies whether the system is suspended or not
 			perhaps with more lines and words.
  @ch_num:		specifies the number of i2c instance
  pch_data has as many elements as maximum I2C channels
 I2C bus speed in Kbps 
 specifies I2C clock speed in KHz 
 Definition for ML7213 by LAPIS Semiconductor 
  pch_i2c_init() - hardware initialization of I2C module
  @adap:	Pointer to struct i2c_algo_pch_data.
 reset I2C controller 
 Initialize I2C registers 
 Set transfer speed in I2CBC 
 Enable interrupts in normal mode 
  pch_i2c_wait_for_bus_idle() - check the status of bus.
  @adap:	Pointer to struct i2c_algo_pch_data.
  @timeout:	waiting time counter (ms).
 Retry after some usecs 
 Wait a bit more without consuming CPU 
  pch_i2c_start() - Generate I2C start condition in normal mode.
  @adap:	Pointer to struct i2c_algo_pch_data.
  Generate I2C start condition in normal mode by setting I2CCTL.I2CMSTA to 1.
  pch_i2c_stop() - generate stop condition in normal mode.
  @adap:	Pointer to struct i2c_algo_pch_data.
 clear the start bit 
  pch_i2c_repstart() - generate repeated start condition in normal mode
  @adap:	Pointer to struct i2c_algo_pch_data.
  pch_i2c_writebytes() - write data to I2C bus in normal mode
  @i2c_adap:	Pointer to the struct i2c_adapter.
  @msgs:	Pointer to the i2c message structure.
  @last:	specifies whether last message or not.
 		In the case of compound mode it will be 1 for last message,
 		otherwise 0.
  @first:	specifies whether first message or not.
 		1 for first message otherwise 0.
 enable master tx 
 set 7 bit slave address and RW bit as 0 
 write buffer value to I2C data register 
 check if this is the last message 
  pch_i2c_sendack() - send ACK
  @adap:	Pointer to struct i2c_algo_pch_data.
  pch_i2c_sendnack() - send NACK
  @adap:	Pointer to struct i2c_algo_pch_data.
  pch_i2c_restart() - Generate I2C restart condition in normal mode.
  @adap:	Pointer to struct i2c_algo_pch_data.
  Generate I2C restart condition in normal mode by setting I2CCTL.I2CRSTA.
  pch_i2c_readbytes() - read data  from I2C bus in normal mode.
  @i2c_adap:	Pointer to the struct i2c_adapter.
  @msgs:	Pointer to i2c_msg structure.
  @last:	specifies whether last message or not.
  @first:	specifies whether first message or not.
 enable master reception 
 7 address bits + RW bit 
 check if it is the first message 
 Dummy read needs 
 Dummy read 
 end for 
 Read final - 1 
 Read Final 
  pch_i2c_cb() - Interrupt handler Call back function
  @adap:	Pointer to struct i2c_algo_pch_data.
 clear the applicable bits 
  pch_i2c_handler() - interrupt handler for the PCH I2C controller
  @irq:	irq number.
  @pData:	cookie passed back to the handler function.
  pch_i2c_xfer() - Reading adnd writing data through I2C bus
  @i2c_adap:	Pointer to the struct i2c_adapter.
  @msgs:	Pointer to i2c_msg structure.
  @num:	number of messages.
 transfer not completed 
 transfer completed 
  pch_i2c_func() - return the functionality of the I2C driver
  @adap:	Pointer to struct i2c_algo_pch_data.
  pch_i2c_disbl_int() - Disable PCH I2C interrupts
  @adap:	Pointer to struct i2c_algo_pch_data.
 Set the number of I2C channel instance 
 base_addr + offset; 
 Wait until all channel transfers are completed 
 Disable the i2c interrupts 
 SPDX-License-Identifier: GPL-2.0
  This is a combined i2c adapter and algorithm driver for the
  MPC107Tsi107 PowerPC northbridge and processors that include
  the same I2C unit (8240, 8245, 85xx).
  Copyright (C) 2003-2004 Humboldt Solutions Ltd, adrian@humboldt.co.uk
  Copyright (C) 2021 Allied Telesis Labs
 including dfsrr 
 Sometimes 9th clock pulse isn't generated, and slave doesn't release
  the bus, because it wants to send ACK.
  Following sequence of enablingdisabling and sending startstop generates
  the 9 pulses, so it's all OK.
  Workaround for Erratum A004447. From the P2040CE Rev Q
  1.  Set up the frequency divider and sampling rate.
  2.  I2CCR - a0h
  3.  Poll for I2CSR[MBB] to get set.
  4.  If I2CSR[MAL] is set (an indication that SDA is stuck low), then go to
      step 5. If MAL is not set, then go to step 13.
  5.  I2CCR - 00h
  6.  I2CCR - 22h
  7.  I2CCR - a2h
  8.  Poll for I2CSR[MBB] to get set.
  9.  Issue read to I2CDR.
  10. Poll for I2CSR[MIF] to be set.
  11. I2CCR - 82h
  12. Workaround complete. Skip the next steps.
  13. Issue read to I2CDR.
  14. Poll for I2CSR[MIF] to be set.
  15. I2CCR - 80h
 see below - default fdr = 0x3f -> div = 2048 
 Determine divider value 
	
	  We want to choose an FDRDFSR that generates an I2C bus speed that
	  is equal to or lower than the requested speed.
 Old MPC5200 rev A CPUs do not support the high bits 
 backward compatibility 
 !(CONFIG_PPC_MPC52xx || CONFIG_PPC_MPC512x) 
 CONFIG_PPC_MPC52xx || CONFIG_PPC_MPC512x 
 Enable I2C interrupts for mpc5121 
 Interrupt enable bits for i2c-012: bit 242628 
 The clock setup for the 52xx works also fine for the 512x 
 CONFIG_PPC_MPC512x 
 CONFIG_PPC_MPC512x 
			
			  Map and check POR Device Status Register 2
			  (PORDEVSR2) at 0xE0014. Note than while MPC8533
			  and MPC8544 indicate SEC frequency ratio
			  configuration as bit 26 in PORDEVSR2, other MPC8xxx
			  parts may store it differently or may not have it
			  at all.
 sec-cfg 
	
	  According to the AN2919 all MPC824x have prescaler 1, while MPC83xx
	  may have prescaler 1, 2, or 3, depending on the power-on
	  configuration.
 mpc85xx 
 the above 85xx SoCs have prescaler 1 
 the above 85xx SoCs have prescaler 3 or 2 
 all the other 85xx have prescaler 2 
 see below - default fdr = 0x1031 -> div = 16  3072 
	
	  We want to choose an FDRDFSR that generates an I2C bus speed that
	  is equal to or lower than the requested speed.
 backward compatibility 
 !CONFIG_FSL_SOC 
 CONFIG_FSL_SOC 
 Dummy read 
 Generate Tx ACK on next to last byte 
 Do not generate stop on last byte 
			
			  For block reads, generate Tx ACK here if data length
			  is 1 byte (total length is 2 bytes).
			
			  We don't get another interrupt on read so
			  finish the transfer now
 Wait up to 100us for transfer to properly complete 
 Wait until STOP is seen, allow up to 1 s 
 for debug and error output 
	
	  enable clock for the I2C peripheral (non fatal),
	  keep a reference upon successful allocation
 Backwards compatibility 
 Backward compatibility 
 Structure for a device driver 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2015 Masahiro Yamada <yamada.masahiro@socionext.com>
 control register 
 master mode 
 start condition 
 stop condition 
 do not return ACK 
 TX FIFO 
 send command (slave addr) 
 read transaction 
 RX FIFO 
 slave address 
 clock cycle control 
 clock low period control 
 restartstop setup time control 
 data setup time control 
 interrupt status 
 interrupt enable 
 interrupt clear 
 TX FIFO empty 
 RX FIFO full 
 send complete (STOP) 
 receive complete (STOP) 
 sent specified bytes 
 received specified bytes 
 no ACK 
 arbitration lost 
 status register 
 device busy 
 stop condition detected 
 bus busy 
 RX FIFO full 
 RX FIFO not empty 
 TX FIFO not full 
 TX FIFO empty 
 reset control 
 clear TX FIFO 
 clear RX FIFO 
 forcible bus reset 
 bus monitor 
 output for SDA line 
 readback of SDA line 
 output for SCL line 
 readback of SCL line 
 noise filter control 
 TX byte count setting 
 RX byte count setting 
 TX byte count monitor 
 RX byte count monitor 
 bus reset 
 normal operation 
 release SCL 
 IRQ synchronization 
	
	  TX-FIFO stores slave address in it for the first access.
	  Decrement the counter.
			
			  work around a hardware bug:
			  The receive-completed interrupt is never set even if
			  STOP condition is detected after the address phase
			  of read transaction fails to get ACK.
			  To avoid time-out error, we issue STOP here,
			  but do not wait for its completion.
			  It should be checked after exiting this handler.
		
		  If the number of bytes to read is multiple of the FIFO size
		  (msg->len == 8, 16, 24, ...), the INT_RF bit is set a little
		  earlier than INT_RB. We wait for INT_RB to confirm the
		  completion of the current message.
	
	  This controller makes a pause while any bit of the IRQ status is
	  asserted. Clear the asserted bit to kick the controller just before
	  exiting the handler.
 do not use TX byte counter 
 set slave address 
	
	  First chunk of data. For a repeated START condition, do not write
	  data to the TX fifo here to avoid the timing issue.
		
		  If possible, use RX byte counter.
		  It can automatically handle NACK for the last byte.
		
		  The byte counter can not count over 256.  In this case,
		  do not use it at all.  Drain data when FIFO gets full,
		  but treat the last portion as a special case.
 set slave address with RD bit 
 reset TXRX FIFO 
	
	  For a repeated START condition, writing a slave address to the FIFO
	  kicks the controller. So, the UNIPHIER_FI2C_CR register should be
	  written only for a non-repeated START condition.
			
			  If bus busy continues too long, it is probably
			  in a wrong state.  Try bus recovery.
 Emit STOP if it is the last message or I2C_M_STOP is set. 
	
	   Standard-mode: tLOW + tHIGH = 10 us
	   Fast-mode:     tLOW + tHIGH = 2.5 us
	
	   Standard-mode: tLOW = 4.7 us, tHIGH = 4.0 us, tBUF = 4.7 us
	   Fast-mode:     tLOW = 1.3 us, tHIGH = 0.6 us, tBUF = 1.3 us
	  "tLowtHIGH = 54" meets both.
	
	   Standard-mode: tHD;STA = 4.0 us, tSU;STA = 4.7 us, tSU;STO = 4.0 us
	   Fast-mode:     tHD;STA = 0.6 us, tSU;STA = 0.6 us, tSU;STO = 0.6 us
	
	   Standard-mode: tSU;DAT = 250 ns
	   Fast-mode:     tSU;DAT = 100 ns
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
    Copyright (c) 1999-2002 Merlin Hughes <merlin@merlin.org>
    Shamelessly ripped from i2c-piix4.c:
    Copyright (c) 1998, 1999  Frodo Looijaard <frodol@dds.nl> and
    Philip Edelbrock <phil@netroedge.com>
    2002-04-08: Added nForce support. (Csaba Halasz)
    2002-10-03: Fixed nForce PnP IO port. (Michael Steil)
    2002-12-28: Rewritten into something that resembles a Linux driver (hch)
    2003-11-29: Added back AMD8111 removed by the previous rewrite.
                (Philip Pokorny)
   Supports AMD756, AMD766, AMD768, AMD8111 and nVidia nForce
   Note: we assume there can only be one device, with one SMBus interface.
 AMD756 SMBus address offsets 
 PCI Address Constants 
 address of IO space 
 mh 
 general configuration 
 mh 
 silicon revision code 
 Other settings 
 AMD756 constants 
  SMBUS event = IO 28-29 bit 11
     see E0 for the status bits and enabled in E2
 Make sure the SMBus host is ready to start transmitting 
 If the SMBus is still busy, we give up 
 start the transaction by setting the start bit 
 We will always wait for a fraction of a second! 
 If the SMBus is still busy, we give up 
 Return negative errno on error. 
 TODO: endian???? 
 i = inw_p(SMBHSTCNT); Reset SMBBLKDAT 
 How about enabling interrupts... 
 TODO: endian???? 
 i = inw_p(SMBHSTCNT); Reset SMBBLKDAT 
 amd 
 Determine the address of the SMBus areas 
 Technically it is a dword but... 
 set up the sysfs linkage to our parent device 
 SPDX-License-Identifier: GPL-2.0-or-later
  Synopsys DesignWare I2C adapter driver.
  Based on the TI DAVINCI I2C adapter driver.
  Copyright (C) 2006 Texas Instruments.
  Copyright (C) 2007 MontaVista Software Inc.
  Copyright (C) 2009 Provigent Ltd.
	
	  Note these methods shouldn't ever fail because the system controller
	  registers are memory mapped. We check the return value just in case.
 terminate list 
 Optional interface clock 
 The code below assumes runtime PM to be disabled. 
	
	  If the ACPI companion device object is present for this device, it
	  may be accessed during suspend and resume of other devices via I2C
	  operation regions, so tell the PM core and middle layers to avoid
	  skipping system suspendresume callbacks for it in that case.
	
	  The device can only be in runtime suspend at this point if it has not
	  been resumed throughout the ending system suspendresume cycle, so if
	  the platform firmware might mess up with it, request the runtime PM
	  framework to resume it.
 Work with hotplug and coldplug 
 SPDX-License-Identifier: GPL-2.0-only
   i2c_adap_pxa.c
   I2C adapter for the PXA I2C bus access.
   Copyright (C) 2002 Intrinsyc Software Inc.
   Copyright (C) 2004-2005 Deep Blue Solutions Ltd.
   History:
     Apr 2002: Initial version [CS]
     Jun 2002: Properly separated algoadap [FB]
     Jan 2003: Fixed several bugs concerning interrupt handling [Kai-Uwe Bloem]
     Jan 2003: added limited signal handling [Kai-Uwe Bloem]
     Sep 2004: Major rework to ensure efficient bus handling [RMK]
     Dec 2004: Added support for PXA27x and slave device probing [Liam Girdwood]
     Feb 2005: Rework slave mode handling [RMK]
 I2C register field definitions 
 start bit 
 stop bit 
 send ACK(0) or NAK(1) 
 transfer byte bit 
 master abort 
 master clock enable 
 unit enable 
 general call disable 
 enable tx interrupts 
 enable rx interrupts 
 enable bus error ints 
 slave STOP detected int enable 
 enable arbitration interrupt 
 slave address detected int enable 
 unit reset 
 fast mode 
 High Speed mode 
 fast mode for armada-3700 
 high speed mode for armada-3700 
 enable GPIO mode for SCL in HS 
 readwrite mode 
 acknak status 
 unit busy 
 bus busy 
 slave stop detected 
 arbitration loss detected 
 tx buffer empty 
 rx buffer full 
 general call address detected 
 slave address detected 
 bus error no ACKNAK 
 need a longer timeout if we're dealing with the fact we may well be
  looking at a multi-master environment
 an error has occurred retry transmit 
 ICR initialize bit values
  15 FM     0 (100 kHz operation)
  14 UR     0 (No unit reset)
  13 SADIE  0 (Disables the unit from interrupting on slave addresses
               matching its slave address)
  12 ALDIE  0 (Disables the unit from interrupt when it loses arbitration
               in master mode)
  11 SSDIE  0 (Disables interrupts from a slave stop detected, in slave mode)
  10 BEIE   1 (Enable interrupts from detected bus errors, no ACK sent)
   9 IRFIE  1 (Enable interrupts from full buffer received)
   8 ITEIE  1 (Enables the I2C unit to interrupt when transmit buffer empty)
   7 GCD    1 (Disables i2c unit response to general call messages as a slave)
   6 IUE    0 (Disable unit until we change settings)
   5 SCLE   1 (Enables the i2c clock output for master mode (drives SCL)
   4 MA     0 (Only send stop with the ICR stop bit)
   3 TB     0 (We are not transmitting a byte initially)
   2 ACKNAK 0 (Send an ACK after the unit receives a byte)
   1 STOP   0 (Do not send a STOP)
   0 START  0 (Do not send a START)
 I2C status register init values
  10 BED    1 (Clear bus error detected)
   9 SAD    1 (Clear slave address detected)
   7 IRF    1 (Clear IDBR Receive Full)
   6 ITE    1 (Clear IDBR Transmit Empty)
   5 ALD    1 (Clear Arbitration Loss Detected)
   4 SSD    1 (Clear Slave Stop Detected)
 status register init 
 I2C register layout definitions 
 no isar register 
  I2C Slave mode address
 ifdef DEBUG 
 ifdef DEBUG  else 
		 wait for unit and bus being not busy, and we also do a
		  quick check of the i2c lines themselves to ensure they've
		  gone high...
 wait for stop 
  clear the hold on the bus, and take of anything else
  that has been configured
 simple delay 
 we need to wait for the stop condition to end 
 if we where in stop, then clear... 
 reset according to 9.8 
 set control register values 
 enable unit 
 abort any transfer currently under way 
  PXA I2C Slave mode
 what should we do here? 
 allow next byte 
	
	  slave could interrupt in the middle of us generating a
	  start condition... if this happens, we'd better back off
	  and stop holding the poor thing up
	
	  If we have a master-mode message waiting,
	  kick it off now that the slave has completed.
 what should we do here? 
	
	  slave could interrupt in the middle of us generating a
	  start condition... if this happens, we'd better back off
	  and stop holding the poor thing up
  PXA I2C Master mode
	
	  Step 1: target slave address into IDBR
	
	  Step 2: initiate the write.
 Clear the START, STOP, ACK, TB and MA flags 
  PXA I2C send master code
  1. Load master code to IDBR and send it.
     Note for HS mode, set ICR [GPIOEN].
  2. Wait until win arbitration.
  i2c_pxa_master_complete - complete the message and wake up.
	
	  If ISR_ALD is set, we lost arbitration.
		
		  Do we need to do anything here?  The PXA docs
		  are vague about what happens.
		
		  We ignore this error.  We seem to see spurious ALDs
		  for seemingly no reason.  If we handle them as I think
		  they should, we end up causing an I2C error, which
		  is painful for some systems.
 ignore 
		
		  I2C bus error - either the device NAK'd us, or
		  something more serious happened.  If we were NAK'd
		  on the initial address phase, we can retry.
		
		  Read mode.  We have just sent the address byte, and
		  now we must initiate the transfer.
		
		  Write mode.  Write the next data byte.
		
		  If this is the last byte of the last message or last byte
		  of any message with I2C_M_STOP (e.g. SCCB), send a STOP.
		
		  Next segment of the message.
		
		  If we aren't doing a repeated start and address,
		  go back and try to send the next byte.  Note that
		  we do not support switching the RW direction here.
		
		  Write the next address.
		
		  And trigger a repeated start, and send the byte.
	
	  Read the byte.
		
		  If this is the last byte of the last
		  message, send a STOP.
	
	  Always clear all pending IRQs.
  We are protected by the adapter bus mutex.
	
	  Wait for the bus to become free.
	
	  Set master mode.
	
	  The rest of the processing occurs in the interrupt handler.
	
	  We place the return code in i2c->msg_idx.
 Non-interrupt mode support 
 make timeout the same as for interrupt based functions 
	
	  Wait for the bus to become free.
	
	  Set master mode.
 5 seconds 
	
	  We place the return code in i2c->msg_idx.
	 If the I2C controller is disabled we need to reset it
	  (probably due to a suspendresume destroying state). We do
	  this here as we can then avoid worrying about resuming the
 For device tree we always use the dynamic or alias-assigned ID 
	
	  Program the GPIOs to reflect the current I2C bus state while
	  we transition to recovery; this avoids glitching the bus.
	
	  The bus should now be free. Clear up the I2C controller before
	  handing control of the bus back to avoid the bus changing state.
	
	  When slave mode is enabled, we are not the only master on the bus.
	  Bus recovery can only be performed when we are the master, which
	  we can't be certain of. Therefore, when slave mode is enabled, do
	  not configure bus recovery.
 Default adapter num to device id; i2c_pxa_probe_dt can override. 
 SPDX-License-Identifier: GPL-2.0-only
  Driver for RobotFuzz OSIF
  Copyright (c) 2013 Andrew Lunn <andrew@lunn.ch>
  Copyright (c) 2007 Barry Carter <Barry.Carter@robotfuzz.com>
  Based on the i2c-tiny-usb by
  Copyright (C) 2006 Til Harbaum (Till@Harbaum.org)
 read status 
	
	  Set bus frequency. The frequency is:
	  120,000,000  ( 16 + 2  div  4^prescale).
 SPDX-License-Identifier: GPL-2.0-only
  Bitbanging I2C bus driver using the GPIO API
  Copyright (C) 2007 Atmel Corporation
 these must be protected by bus lock 
  Toggle SDA by changing the output value of the pin. This is only
  valid for pins configured as open drain (i.e. setting the value
  high effectively turns off the output driver.)
  Toggle SCL by changing the output value of the pin. This is used
  for pins that are configured as open drain and for output-only
  pins. The latter case will break the i2c protocol, but it will
  often work in practice.
 START condition 
 Send pattern, request ACK, don't send STOP 
 ADDR (7 bit) + RD (1 bit) + Client ACK, keep SDA hi (1 bit) 
 ADDR (7 bit) + WR (1 bit) + Client ACK (1 bit) 
 0x00 (8 bit) + Client ACK, keep SDA hi (1 bit) 
	
	  Interrupt on falling SCL. This ensures that the master under test has
	  really started the transfer. Interrupt on falling SDA did only
	  exercise 'bus busy' detection on some HW but not 'arbitration lost'.
	  Note that the interrupt latency may cause the first bits to be
	  transmitted correctly.
	
	  Interrupt on falling SCL. This ensures that the master under test has
	  really started the transfer.
	
	  If there will be a debugfs-dir per i2c adapter somewhen, put the
	  'fault-injector' dir there. Until then, we have a global dir with
	  all adapters as subdirs.
 CONFIG_I2C_GPIO_FAULT_INJECTOR
 FIXME: hack in the old code, is this really necessary? 
 This happens if the GPIO driver is not yet probed, let's defer 
		
		  If all platform data settings are zero it is OK
		  to not provide any platform data from the board.
	
	  First get the GPIO pins; if it fails, we'll defer the probe.
	  If the SCLSDA lines are marked "open drain" by platform data or
	  device tree then this means that something outside of our control is
	  marking these lines to be handled as open drain, and we should just
	  handle them as we handle any other output. Else we enforce open
	  drain as this is required for an I2C bus.
 10 kHz 
 100 kHz 
 100 ms 
	
	  FIXME: using global GPIO numbers is not helpful. Ifwhen we
	  get accessors to get the actual name of the GPIO line,
	  from the descriptor, then provide that instead.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
   i2c_pca_platform.c
   Platform driver for the PCA9564 I2C controller.
   Copyright (C) 2008 Pengutronix
 if 0, use polling 
 ReadWrite functions for different register alignments 
 Do polling 
 If irq is 0, we do polling. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2011 NXP Semiconductors
  Code portions referenced from the i2x-pxa and i2c-pnx drivers
  Make SMBus byte and word transactions work on LPC178x7x
  Copyright (c) 2012
  Alexander Potashev, Emcraft Systems, aspotashev@emcraft.com
  Anton Protopopov, Emcraft Systems, antonp@emcraft.com
  Copyright (C) 2015 Joachim Eastwood <manabian@gmail.com>
 LPC24xx register offsets and bits 
 I2C SCL clock has different duty cycle depending on mode 
  26 possible I2C status codes, but codes applicable only
  to master are listed here and used in this driver
 Will force clear all statuses 
	
	  If the transfer needs to abort for some reason, we'll try to
	  force a stop condition to clear any pending bus conditions
 Wait for status change 
 Bus was not idle, try to reset adapter 
	
	  I2C in the LPC2xxx series is basically a state machine.
	  Just run through the steps based on the current status.
 Start bit was just sent out, send out addr and dir 
		
		  Address or data was sent out with an ACK. If there is more
		  data to send, send it now
 Last message, send stop 
 Receive first byte from slave 
 Last byte, return NACK 
 Not last byte, return ACK 
		
		  The I2C shows NACK status on reads, so we need to accept
		  the NACK as an ACK here. This should be ok, as the real
		  BACK would of been caught on the address write.
 Data was received 
 If transfer is done, send STOP 
 Message is done 
		
		  One pre-last data input, send NACK to tell the slave that
		  this is going to be the last data byte to be transferred.
 One byte left to receive - NACK 
 More than one byte left to receive - ACK 
 NACK processing is done 
 Arbitration lost 
 Release the I2C bus 
 Unexpected statuses 
 Exit on failure or all bytes transferred 
	
	  If `msg_status` is zero, then `lpc2k_process_msg()`
	  is responsible for clearing the SI flag.
 A new transfer is kicked off by initiating a start condition 
		
		  A multi-message I2C transfer continues where the
		  previous I2C transfer left off and uses the
		  current condition of the I2C adapter.
 Start transmit of data 
 Start or repeated start 
 Wait for transfer completion 
 Check for bus idle condition 
 Something is holding the bus, try to clear it 
 Process a single message at a time 
 Save message pointer and current message data index 
 Only emulated SMBus for now 
 Place controller is a known state 
 Setup I2C dividers to generate clock with proper duty cycle 
 SPDX-License-Identifier: GPL-2.0
   Mellanox BlueField I2C bus driver
   Copyright (C) 2020 Mellanox Technologies, Ltd.
 Defines what functionality is present. 
 Shared resources info in BlueField platforms. 
  Note that the following SMBus, CAUSE, GPIO and PLL register addresses
  refer to their respective offsets relative to the corresponding
  memory-mapped region whose addresses are specified in either the DT or
  the ACPI tables or above.
  SMBus Master core clock frequency. Timing configurations are
  strongly dependent on the core clock frequency of the SMBus
  Master. Default value is set to 400MHz.
 Reference clock for Bluefield - 156 MHz. 
 Constant used to determine the PLL frequency. 
 PLL registers. 
 OR cause register. 
 Arbiter Cause Register. 
  Cause Status flags. Note that those bits might be considered
  as interrupt enabled bits.
 Transaction ended with STOP. 
 Master arbitration lost. 
 Unexpected start detected. 
 Unexpected stop detected. 
 Wait for transfer continuation. 
 Failed to generate STOP. 
 Failed to generate START. 
 Clock toggle completed. 
 Transfer timeout occurred. 
 Master busy bit reset. 
  Slave cause status flags. Note that those bits might be considered
  as interrupt enabled bits.
 Write transaction received successfully. 
 Read transaction received, waiting for response. 
 Slave busy bit reset. 
 Cause coalesce registers. 
 Functional enable register. 
 Force OE enable register. 
  Note that Smbus GWs are on GPIOs 30:25. Two pins are used to control
  SDASCL lines:
   SMBUS GW0 -> bits[26:25]
   SMBUS GW1 -> bits[28:27]
   SMBUS GW2 -> bits[30:29]
 Note that gw_id can be 0,1 or 2. 
 SMBus timing parameters. 
  Defines SMBus operating frequency and core clock frequency.
  According to ADB files, default values are compliant to 100KHz SMBus
  @ 400MHz core clock. The driver should be able to calculate core
  frequency based on PLL parameters.
 Core PLL TYU configuration. 
 Core PLL YU configuration. 
 Core PLL frequency. 
 SMBus Master GW. 
 Number of bytes received and sent. 
 Packet error check (PEC) value. 
 Status bits (ACKNACKFW Timeout). 
 SMbus Master Finite State Machine. 
  When enabled, the master will issue a stop condition in case of
  timeout while waiting for FW response.
 SMBus master GW control bits offset in MLXBF_I2C_SMBUS_MASTER_GW[31:3]. 
 Lock bit. 
 Busy bit. 
 Control start. 
 Control write phase. 
 Control read phase. 
 Control stop. 
 Slave address shift. 
 Control write bytes shift. 
 Send PEC byte shift. 
 Parse expected bytes shift. 
 Control read bytes shift. 
 SMBus master GW Data descriptor. 
 Size in bytes. 
 Maximum bytes to readwrite per SMBus transaction. 
 All bytes were transmitted. 
 NACK received. 
 Slave's byte count >128 bytes. 
 Timeout occurred. 
 SMBus slave GW. 
 Number of bytes received and sent fromto master. 
 Packet error check (PEC) value. 
 SMBus slave Finite State Machine (FSM). 
  Should be set when all raised causes handled, and cleared by HW on
  every new cause.
 SMBus slave GW control bits offset in MLXBF_I2C_SMBUS_SLAVE_GW[31:19]. 
 Busy bit. 
 Control write enable. 
 Number of bytes to write. 
 Send PEC byte shift. 
 SMBus slave GW Data descriptor. 
 Size in bytes. 
 SMbus slave configuration registers. 
  Timeout is given in microsends. Note also that timeout handling is not
  exact.
 300ms 
 Encapsulates timing parameters. 
 Clock high period. 
 Clock low period. 
 Data rise time. 
 Data fall time. 
 Clock rise time. 
 Clock fall time. 
 Hold time after (REPEATED) START. 
 Data hold time. 
 REPEATED START condition setup time. 
 STOP condition setup time. 
 Data setup time. 
 Padding. 
 Bus free time between STOP and START. 
 Thigh max. 
 Detect clock low timeout. 
 Buffer length in bytes. 
 Mutex to protect mlxbf_i2c_resource. 
 List of chip resources that are being accessed by the driver. 
 Helper macro to define an I2C resource parameters. 
 Mellanox BlueField chip type. 
 Mellanox BlueField-1 chip. 
 Mallanox BlueField-2 chip. 
 Chip shared resources that are being used by the I2C controller. 
 Callback to calculate the core PLL frequency. 
 Core frequency in Hz. 
 Physical bus identifier. 
 Polling frequency in microseconds. 
  Function to poll a set of bits at a specific address; it checks whether
  the bits are equal to zero when eq_zero is set to 'true', and not equal
  to zero when eq_zero is set to 'false'.
  Note that the timeout is given in microseconds.
  SW must make sure that the SMBus Master GW is idle before starting
  a transaction. Accordingly, this function polls the Master FSM stop
  bit; it returns false when the bit is asserted, true if not.
	
	  When transaction ended with STOP, all bytes were transmitted,
	  and no NACK received, then the transaction ended successfully.
	  On the other hand, when the GW is configured with the stop bit
	  de-asserted then the SMBus expects the following GW configuration
	  for transfer continuation.
  Poll SMBus master status and return transaction status,
  i.e. whether succeeded or failed. I2C and SMBus fault codes
  are returned as negative numbers from most calls, with zero
  or some positive number indicating a non-fault return.
	
	  GW busy bit is raised by the driver and cleared by the HW
	  when the transaction is completed. The busy bit is a good
	  indicator of transaction status. So poll the busy bit, and
	  then read the cause and master status bits to determine if
	  errors occurred during the transaction.
 Read cause status bits. 
	
	  Parse both Cause and Master GW bits, then return transaction status.
	
	  In case of timeout on GW busy, the ISR will clear busy bit but
	  transaction ended bits cause will not be set so the transaction
	  fails. Then, we must check Master GW status bits.
	
	  Copy data bytes from 4-byte aligned source buffer.
	  Data copied to the Master GW Data Descriptor MUST be shifted
	  left so the data starts at the MSB of the descriptor registers
	  as required by the underlying hardware. Enable byte swapping
	  when writing data bytes to the 32  32-bit HW Data registers
	  a.k.a Master GW Data Descriptor.
	
	  Data bytes in the Master GW Data Descriptor are shifted left
	  so the data starts at the MSB of the descriptor registers as
	  set by the underlying hardware. Enable byte swapping while
	  reading data bytes from the 32  32-bit HW Data registers
	  a.k.a Master GW Data Descriptor.
 Set Master GW control word. 
 Clear status bits. 
 Set the cause data. 
 Zero PEC byte. 
 Zero byte count. 
 GW activation. 
	
	  Poll master status and check status bits. An ACK is sent when
	  completing writing data to the bus (Master 'byte_count_done' bit
	  is set to 1).
 First of all, check whether the HW is idle. 
 Set first byte. 
		
		  Note that read and write operations might be handled by a
		  single command. If the MLXBF_I2C_F_SMBUS_OPERATION is set
		  then write command byte and set the optional SMBus specific
		  bits such as block_en and pec_en. These bits MUST be
		  submitted by the first operation only.
		
		  We assume that read operations are performed only once per
		  SMBus transaction. TBD protect this statement so it won't
		  be executed twice? or return an error if we try to read more
		  than once?
 Subtract 1 as required by HW. 
 Set Master GW data descriptor. 
 Add one byte of the slave address. 
	
	  Note that data_len cannot be 0. Indeed, the slave address byte
	  must be written to the data registers.
 Write slave address to Master GW data descriptor. 
 Get Master GW data descriptor. 
 Get data from Master GW data descriptor. 
		
		  After a read operation the SMBus FSM ps (present state)
		  needs to be 'manually' reset. This should be removed in
		  next tag integration.
 I2C SMBus protocols. 
	
	  As specified in the standard, the max number of bytes to readwrite
	  per block operation is 32 bytes. In Golan code, the controller can
	  read up to 128 bytes and write up to 127 bytes.
	
	  Skip the first data byte, which corresponds to the number of bytes
	  to readwrite.
 Set the number of byte to read. This will be used by userspace. 
 Set the number of bytes to read. This will be used by userspace. 
 including PEC byte. 
 Initialization functions. 
	
	  Compute ticks as follow:
	 
	            Ticks
	  Time = --------- x 10^9    =>    Ticks = Time x Frequency x 10^-9
	          Frequency
	
	  The number of ticks is rounded down and if minimum is equal to 1
	  then add one tick.
  Note that the mlxbf_i2c_timings->timeout value is not related to the
  bus frequency, it is impacted by the time it takes the driver to
  complete data transmission before transaction abort.
 Default settings is 100 KHz. 
	
	  The GPIO region in TYU space is shared among I2C busses.
	  This function MUST be serialized to avoid racing when
	  claiming the memory region andor setting up the GPIO.
 Check whether the memory map exist. 
 Release the GPIO resource. 
	
	  The COREPLL region in TYU space is shared among I2C busses.
	  This function MUST be serialized to avoid racing when
	  claiming the memory region.
 Check whether the memory map exist. 
 Release the CorePLL resource. 
 This configuration is only needed for BlueField 1. 
	
	  The GPIO region in TYU space is shared among I2C busses.
	  This function MUST be serialized to avoid racing when
	  claiming the memory region andor setting up the GPIO.
	
	  TYU - Configuration for GPIO pins. Those pins must be asserted in
	  MLXBF_I2C_GPIO_0_FUNC_EN_0, i.e. GPIO 0 is controlled by HW, and must
	  be reset in MLXBF_I2C_GPIO_0_FORCE_OE_EN, i.e. GPIO_OE will be driven
	  instead of HW_OE.
	  For now, we do not reset the GPIO state when the driver is removed.
	  First, it is not necessary to disable the bus since we are using
	  the same busses. Then, some busses might be shared among Linux and
	  platform firmware; disabling the bus might compromise the system
	  functionality.
 Get Core PLL configuration bits. 
	
	  Compute PLL output frequency as follow:
	 
	                                        CORE_F + 1
	  PLL_OUT_FREQ = PLL_IN_FREQ  ----------------------------
	                               (CORE_R + 1)  (CORE_OD + 1)
	 
	  Where PLL_OUT_FREQ and PLL_IN_FREQ refer to CoreFrequency
	  and PadFrequency, respectively.
 Get Core PLL configuration bits 
	
	  Compute PLL output frequency as follow:
	 
	                                      CORE_F  16384
	  PLL_OUT_FREQ = PLL_IN_FREQ  ----------------------------
	                               (CORE_R + 1)  (CORE_OD + 1)
	 
	  Where PLL_OUT_FREQ and PLL_IN_FREQ refer to CoreFrequency
	  and PadFrequency, respectively.
	
	  First, check whether the TYU core Clock frequency is set.
	  The TYU core frequency is the same for all I2C busses; when
	  the first device gets probed the frequency is determined and
	  stored into a globally visible variable. So, first of all,
	  check whether the frequency is already set. Here, we assume
	  that the frequency is expected to be greater than 0.
	
	  Read the slave registers. There are 4  32-bit slave registers.
	  Each slave register can hold up to 4  8-bit slave configuration
	  (7-bit address, 1 status bit (1 if enabled, 0 if not)).
		
		  Each register holds 4 slave addresses. So, we have to keep
		  the byte order consistent with the value read in order to
		  update the register correctly, if needed.
			
			  Mark the first available slave address slot, i.e. its
			  enabled bit should be unset. This slot might be used
			  later on to register our slave.
			
			  Parse slave address bytes and check whether the
			  slave address already exists and it's enabled,
			  i.e. most significant bit is set.
 Parse next byte. 
 Exit the loop if the slave address is found. 
 No room for a new slave address. 
 Set the slave address. 
 Enable the slave address and update the register. 
	
	  Read the slave registers. There are 4  32-bit slave registers.
	  Each slave register can hold up to 4  8-bit slave configuration
	  (7-bit address, 1 status bit (1 if enabled, 0 if not)).
 Check whether the address slots are empty. 
		
		  Each register holds 4 slave addresses. So, we have to keep
		  the byte order consistent with the value read in order to
		  update the register correctly, if needed.
			
			  Parse slave address bytes and check whether the
			  slave address already exists.
 Parse next byte. 
 Exit the loop if the slave address is found. 
 Slave is not registered, nothing to do. 
 Cleanup the slave address slot. 
	
	  Unlike BlueField-1 platform, the coalesce registers is a dedicated
	  resource in the next generations of BlueField.
		
		  The Cause Coalesce group in TYU space is shared among
		  I2C busses. This function MUST be serialized to avoid
		  racing when claiming the memory region.
 Check whether the memory map exist. 
 Reset FSM. 
	
	  Enable slave cause interrupt bits. Drive
	  MLXBF_I2C_CAUSE_READ_WAIT_FW_RESPONSE and
	  MLXBF_I2C_CAUSE_WRITE_SUCCESS, these are enabled when an external
	  masters issue a Read and Write, respectively. But, clear all
	  interrupts first.
 Finally, set the 'ready' bit to start handling transactions. 
 Initialize the cause coalesce resource. 
 Check the source of the interrupt, i.e. whether a Read or Write. 
 Clear cause bits. 
 Send byte to 'external' smbus master. 
	
	  Read bytes received from the external master. These bytes should
	  be located in the first data descriptor register of the slave GW.
	  These bytes are the slave address byte and the internal register
	  address, if supplied.
 Parse the received bytes. 
 Check whether it's our slave address. 
	
	  I2C read transactions may start by a WRITE followed by a READ.
	  Indeed, most slave devices would expect the internal address
	  following the slave address byte. So, write that byte first,
	  and then, send the requested data bytes to the master.
	
	  Now, send data to the master; currently, the driver supports
	  READ_BYTE, READ_WORD and BLOCK READ protocols. Note that the
	  hardware can send up to 128 bytes per transfer. That is the
	  size of its data registers.
 Send a stop condition to the backend. 
 Handle the actual transfer. 
 Set the number of bytes to write to master. 
 Write data to Slave GW data descriptor. 
 Disable PEC since it is not supported. 
 Prepare control word. 
	
	  Wait until the transfer is completed; the driver will wait
	  until the GW is idle, a cause will rise on fall of GW busy.
 Release the Slave GW. 
 Receive bytes from 'external' smbus master. 
 Read data from Slave GW data descriptor. 
 Check whether its our slave address. 
	
	  Notify the slave backend; another I2C master wants to write data
	  to us. This event is sent once the slave address and the write bit
	  is detected.
 Send the received data to the slave backend. 
 Send a stop condition to the backend. 
 Release the Slave GW. 
	
	  Read TYU interrupt register and determine the source of the
	  interrupt. Based on the source of the interrupt one of the
	  following actions are performed:
	   - Receive data and send response to master.
	   - Send data and release slave GW.
	 
	  Handle readwrite transaction only. CRmaster and Iarp requests
	  are ignored for now.
 Nothing to do here, interrupt was not from this device. 
	
	  The MLXBF_I2C_SMBUS_SLAVE_RS_MASTER_BYTES includes the number of
	  bytes fromto master. These are defined by 8-bits each. If the lower
	  8 bits are set, then the master expect to read N bytes from the
	  slave, if the higher 8 bits are sent then the slave expect N bytes
	  from the master.
	
	  For now, the slave supports 128 bytes transfer. Discard remaining
	  data bytes if the master wrote more than
	  MLXBF_I2C_SLAVE_DATA_DESC_SIZE, i.e, the actual size of the slave
	  data descriptor.
	 
	  Note that we will never expect to transfer more than 128 bytes; as
	  specified in the SMBus standard, block transactions cannot exceed
	  32 bytes.
 Return negative errno on error. 
	
	  Do not support ten bit chip address and do not use Packet Error
	  Checking (PEC).
 Unregister slave, i.e. disable the slave address in hardware. 
 CONFIG_ACPI 
 Read Core PLL frequency. 
 Set to default value. 
	
	  Initialize master.
	  Note that a physical bus might be shared among Linux and firmware
	  (e.g., ATF). Thus, the bus should be initialized and ready and
	  bus initialization would be unnecessary. This requires additional
	  knowledge about physical busses. But, since an extra initialization
	  does not really hurt, then keep the code as is.
	
	  Release shared resources. This should be done when releasing
	  the I2C controller.
 CONFIG_ACPI  
 SPDX-License-Identifier: GPL-2.0
  BCM2835 master mode driver
 bits 4 and 5 both clear 
 Fake bit for SW error reporting 
	
	  Per the datasheet, the register is always interpreted as an even
	  number, by rounding down. In other words, the LSB is ignored. So,
	  if the LSB is set, increment the divider to avoid any issue.
	
	  Number of core clocks to wait after falling edge before
	  outputting the next data bit.  Note that both FEDL and REDL
	  can't be greater than CDIV2.
	
	  Number of core clocks to wait after rising edge before
	  sampling the next incoming data bit.
  Repeated Start Condition (Sr)
  The BCM2835 ARM Peripherals datasheet mentions a way to trigger a Sr when it
  talks about reading from a slave with 10 bit address. This is achieved by
  issuing a write, poll the I2CS.TA flag and wait for it to be set, and then
  issue a read.
  A comment in https:github.comraspberrypilinuxissues254 shows how the
  firmware actually does it using polling and says that it's a workaround for
  a problem in the state machine.
  It turns out that it is possible to use the TXW interrupt to know when the
  transfer is active, provided the FIFO has not been prefilled.
  Note about I2C_C_CLEAR on error:
  The I2C_C_CLEAR on errors will take some time to resolve -- if you were in
  non-idle state and I2C_C_READ, it sets an abort_rx flag and runs through
  the state machine to send a NACK and a STOP. Since we're setting CLEAR
  without I2CEN, that NACK will be hanging around queued up for next time
  we start the engine.
  The BCM2835 was reported to have problems with clock stretching:
  https:www.advamation.comknowhowraspberrypirpi-i2c-bug.html
  https:www.raspberrypi.orgforumsviewtopic.php?p=146272
 SPDX-License-Identifier: GPL-2.0-only
  i2c-xiic.c
  Copyright (c) 2002-2007 Xilinx Inc.
  Copyright (c) 2009-2010 Intel Corporation
  This code was implemented by Mocean Laboratories AB when porting linux
  to the automotive development board Russellville. The copyright holder
  as seen in the header is Intel corporation.
  Mocean Laboratories forked off the GNULinux platform work into a
  separate company called Pelagicore AB, which committed the code to the
  kernel.
 Supports:
  Xilinx IIC
  struct xiic_i2c - Internal representation of the XIIC I2C bus
  @dev: Pointer to device structure
  @base: Memory base of the HW registers
  @completion:	Completion for callers
  @adap: Kernel adapter representation
  @tx_msg: Messages from above to be sent
  @lock: Mutual exclusion
  @tx_pos: Current pos in TX message
  @nmsgs: Number of messages in tx_msg
  @rx_msg: Current RX message
  @rx_pos: Position within current RX message
  @endianness: biglittle-endian byte order
  @clk: Pointer to AXI4-lite input clock
  @state: See STATE_
  @singlemaster: Indicates bus is single master
  Register offsets in bytes from RegisterBase. Three is added to the
  base offset to access LSB (IBM style) of the word
 Control Register   
 Status Register    
 Data Tx Register   
 Data Rx Register   
 Address Register   
 Tx FIFO Occupancy  
 Rx FIFO Occupancy  
 10 Bit Address reg 
 Rx FIFO Depth reg  
 Output Register    
 Control Register masks 
 Device enable = 1      
 Transmit FIFO reset=1  
 Master starts Txing=1  
 Dir of tx. Txing=1     
 Tx Ack. NO ack = 1     
 Repeated start = 1     
 Gen Call enabled = 1   
 Status Register masks 
 1=a mstr issued a GC   
 1=when addr as slave   
 1 = bus is busy        
 1=Dir: mstr <-- slave  
 1 = Tx FIFO full       
 1 = Rx FIFO full       
 1 = Rx FIFO empty      
 1 = Tx FIFO empty      
 Interrupt Status Register masks    Interrupt occurs when...       
 1 = arbitration lost   
 1=Tx errormsg complete 
 1 = Tx FIFOreg empty  
 1=Rx FIFOreg=OCY level 
 1 = Bus not busy       
 1 = when addr as slave 
 1 = not addr as slave  
 1 = TX FIFO half empty 
 The following constants specify the depth of the FIFOs 
 Rx fifo capacity               
 Tx fifo capacity               
 The following constants specify groups of interrupts that are typically
  enabled or disables at the same time
  Tx Fifo upper bit masks.
 1 = Set dynamic start 
 1 = Set dynamic stop 
  The following constants define the register offsets for the Interrupt
  registers. There are some holes in the memory map for reserved addresses
  to allow other registers to be added and still match the memory map of the
  interrupt controller registers
 Device Global Interrupt Enable Register 
 Interrupt Status Register 
 Interrupt Enable Register 
 Reset Register 
 ms 
 timeout waiting for the controller to respond 
 timeout waiting for the controller finish transfers 
  The following constant is used for the device global interrupt enable
  register, to enable all interrupts for the device, this is the only bit
  in the register
  For the register read and write functions, a little-endian and big-endian
  version are necessary. Endianness is detected during the probe function.
  Only the least significant byte [doublet] of the register are ever
  accessed. This requires an offset of 3 [2] from the base address for
  big-endian systems.
 Set receive Fifo depth to maximum (zero based). 
 Reset Tx Fifo. 
 Enable IIC Device, remove Tx Fifo reset & disable general call. 
 make sure RX fifo is empty 
 Enable interrupts 
 Disable IIC Device. 
 return the actual space left in the FIFO 
 last message in transfer -> STOP 
	 Get the interrupt Status from the IPIF. There is no clearing of
	  interrupts in the IPIF. Interrupts must be cleared at the source.
	  To find which interrupts are pending; AND interrupts pending with
	  interrupts masked.
 Service requesting interrupt 
		 bus arbritration lost, or...
		  Transmit error _OR_ RX completed
		  if this happens when RX_FULL is not set
		  this is probably a TX error
		 dynamic mode seem to suffer from problems if we just flushes
		  fifos and the next message is a TX with len 0 (only addr)
		  reset the IP instead of just flush fifos
 Receive registerFIFO is full 
 this is the last part of the message 
 also clear TX error if there (RX complete) 
			 send next message if this wasn't the last,
			  otherwise the transfer will be finialise when
			  receiving the bus not busy interrupt
 IIC bus has transitioned to not busy 
 The bus is not busy, disable BusNotBusy interrupt 
 Transmit registerFIFO is empty or ½ empty 
 current message sent and there is space in the fifo 
			 current frame is sent and is last,
			  make sure to disable tx half
	 In single master mode bus can only be busy, when in use by this
	  driver. If the register indicates bus being busy for some reason we
	  should ignore it, since bus will never be released and i2c will be
	  stuck forever.
	 for instance if previous transfer was terminated due to TX error
	  it might be that the bus is on it's way to become available
	  give it at most 3 ms to wake
 Clear and enable Rx full interrupt. 
	 we want to get all but last byte, because the TX_ERROR IRQ is used
	  to inidicate error ACK on the address, and negative ack on the last
	  received byte, so to not mix them receive all but last.
	  In the case where there is only one byte to receive
	  we can check if ERROR and RX full is set at the same time
 write the address 
 very last, enable bus not busy as well 
 the message is tx:ed 
 write the address 
 no data and last message -> add STOP 
 Clear any pending Tx empty, Tx Error and then enable them. 
 we dont date putting several reads in the FIFO 
 Timeout 
 Completion error 
 hook up driver to tree 
	
	  Detect endianness
	  Try to reset the TX FIFO. Then check the EMPTY flag. If it is not
	  set, assume that the endianness was wrong and swap.
 Reset is cleared in xiic_reinit 
 add i2c adapter to i2c tree 
 add in known devices to the bus 
 remove adapter & data 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2021 The Asahi Linux Contributors
  PA Semi PWRficient SMBus host driver for Apple SoCs
 SPDX-License-Identifier: GPL-2.0-or-later
    i2c Support for the Apple `Hydra' Mac IO
    Copyright (c) 1999-2004 Geert Uytterhoeven <geert@linux-m68k.org>
    Based on i2c Support for Via Technologies 82C586B South Bridge
    Copyright (c) 1998, 1999 Kyösti Mälkki <kmalkki@cc.hut.fi>
 CachePD lines 
 ------------------------------------------------------------------------ 
 clear SCLK_OE and SDAT_OE 
 clear SCLK_OE and SDAT_OE 
 SPDX-License-Identifier: GPL-2.0-or-later
  Ingenic JZ4780 I2C bus driver
  Copyright (C) 2006 - 2009 Ingenic Semiconductor Inc.
  Copyright (C) 2015 Imagination Technologies
  Copyright (C) 2019 周琰杰 (Zhou Yanjie) <zhouyanjie@wanyeetech.com>
 ingenic_i2c_config: SoC specific config data. 
 lock to protect rbuf and wbuf between xfer_rdwr and irq handler 
 beginning of lock scope 
 end of lock scope 
 HIGH period count of the SCL clock 
 LOW period count of the SCL clock 
 period count of the SCL clock 
	
	  1 JZ4780_I2C cycle equals to cnt_period PCLK(i2c_clk)
	  standard mode, min LOW and HIGH period are 4700 ns and 4000 ns
	  fast mode, min LOW and HIGH period are 1300 ns and 600 ns
	
	  NOTE: JZ4780_I2C_CTRL_REST can't set when i2c enabled, because
	  normal read are 2 messages, we cannot disable i2c controller
	  between these two messages, this means that we must always set
	  JZ4780_I2C_CTRL_REST when init JZ4780_I2C_CTRL
	 
	
	  a i2c device must internally provide a hold time at least 300ns
	  tHD:DAT
	 	Standard Mode: min=300ns, max=3450ns
	 	Fast Mode: min=0ns, max=900ns
	  tSU:DAT
	 	Standard Mode: min=250ns, max=infinite
	 	Fast Mode: min=100(250ns is recommended), max=infinite
	 
	  1i2c_clk = 10^6  dev_clk_khz
	  on FPGA, dev_clk_khz = 12000, so 1i2c_clk = 100012 = 83ns
	  on Pisces(1008M), dev_clk_khz=126000, so 1i2c_clk = 1000  126 = 8ns
	 
	  The actual hold time is (SDAHD + 1)  (i2c_clk period).
	 
	  Length of setup time calculated using (SDASU - 1)  (ic_clk_period)
	 
 standard mode 
i2c hold time enable 
 disable hold time 
 can send stop now if need 
 disable all interrupts first 
 then clear all interrupts 
 then disable the controller 
	
	  When reading, always drain RX FIFO before we send more Read
	  Commands to avoid fifo overrun
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
    Copyright (c) 1998, 1999  Frodo Looijaard <frodol@dds.nl> and
    Philip Edelbrock <phil@netroedge.com>
 Note: we assume there can only be one SIS5595 with one SMBus interface 
   Note: all have mfr. ID 0x1039.
   SUPPORTED		PCI ID		
	5595		0008
   Note: these chips contain a 0008 device which is incompatible with the
         5595. We recognize these by the presence of the listed
         "blacklist" PCI ID and refuse to load.
   NOT SUPPORTED	PCI ID		BLACKLIST PCI ID	
	 540		0008		0540
	 550		0008		0550
	5513		0008		5511
	5581		0008		5597
	5582		0008		5597
	5597		0008		5597
	5598		0008		55975598
	 630		0008		0630
	 645		0008		0645
	 646		0008		0646
	 648		0008		0648
	 650		0008		0650
	 651		0008		0651
	 730		0008		0730
	 735		0008		0735
	 745		0008		0745
	 746		0008		0746
 TO DO: 
  Add Block Transfers (ugly, but supported by the adapter)
  Add adapter resets
	PCI_DEVICE_ID_SI_5511,	 5513 chip has the 0008 device but that ID
				   shows up in other chips so we use the 5511
 terminates the list 
 Length of ISA address segment 
 SIS5595 SMBus registers 
 PCI Address Constants 
 Other settings 
 SIS5595 constants 
 insmod parameters 
 If force_addr is set to anything different from 0, we forcibly enable
 Look for imposters 
 Determine the address of the SMBus areas 
	 NB: We grab just the two SMBus registers here, but this may still
 doesn't work for some chips! 
 doesn't work for some chips? 
 Everything is happy 
 Make sure the SMBus host is ready to start transmitting 
 start the transaction by setting bit 4 
 We will always wait for a fraction of a second! 
 If the SMBus is still busy, we give up 
 Clock stops and slave is stuck in mid-transmission 
 Return negative errno on error. 
 set up the sysfs linkage to our parent device 
	 Always return failure here.  This is to allow other drivers to bind
	  to this pci device.  We don't really want to have control over the
	  pci device, we only wanted to read as few register values from it.
 SPDX-License-Identifier: GPL-2.0
  Nvidia GPU I2C controller Driver
  Copyright (C) 2018 NVIDIA Corporation. All rights reserved.
  Author: Ajay Gupta <ajayg@nvidia.com>
 I2C definitions 
 enable I2C 
 enable 100KHZ mode 
	
	  The controller supports maximum 4 byte read due to known
	  limitation of sending STOP after every read.
 program client address before starting read 
 gpu_i2c_read has implicit start 
  This driver is for Nvidia GPU cards with USB Type-C interface.
  We want to identify the cards using vendor ID and class code only
  to avoid dependency of adding product id for any new card which
  requires this driver.
  Currently there is no class code defined for UCSI device over PCI
  so using UNKNOWN class for now and it will be updated when UCSI
  over PCI gets a class code.
  There is no other NVIDIA cards with UNKNOWN class code. Even if the
  driver gets loaded for an undesired card then eventually i2c_read()
  (initiated from UCSI i2c_client) will timeout or UCSI commands will
  timeout.
 Use FW built for NVIDIA (nv) only 
	
	  Runtime resume ccgx client so that it can see for any
	  connector change event. Old ccg firmware has known
	  issue of not triggering interrupt when a device is
	  connected to runtime resume the controller.
 SPDX-License-Identifier: GPL-2.0-only
  i2c-stm32.c
  Copyright (C) M'boumba Cedric Madianga 2017
  Author: M'boumba Cedric Madianga <cedric.madianga@gmail.com>
 Functions for DMA support 
 Request and configure I2C TX dma channel 
 Request and configure I2C RX dma channel 
 SPDX-License-Identifier: GPL-2.0-only
  Driver for the Diolan DLN-2 USB-I2C adapter
  Copyright (c) 2014 Intel Corporation
  Derived from:
   i2c-diolan-u2c.c
   Copyright (c) 2010-2011 Ericsson AB
 I2C commands 
	
	  Buffer to hold the packet for read or write transfers. One is enough
	  since we can't have multiple transfers in parallel on the i2c bus.
 setup i2c adapter description 
 initialize the i2c interface 
 and finally attach to i2c layer 
 SPDX-License-Identifier: GPL-2.0-or-later
   Wondermedia I2C Master Mode Driver
   Copyright (C) 2012 Tony Prisk <linux@prisktech.co.nz>
   Derived from GPLv2+ licensed source:
   - Copyright (C) 2008 WonderMedia Technologies, Inc.
 REG_CR Bit fields 
 REG_TCR Bit fields 
 REG_ISR Bit fields 
 REG_IMR Bit fields 
 REG_CSR Bit fields 
 REG_TR 
 REG_MCR 
		
		  We still need to run through the while (..) once, so
		  start at -1 and break out early from the loop
 save the status and write-clear it 
 read clear 
 Disable interrupts, clock and delete adapter 
 Sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
   Copyright Intel Corporation (C) 2017.
  Based on the i2c-axxia.c driver.
 Transfer Command register 
 send START before byte 
 send STOP after byte 
 Direction of transfer 
 RX data FIFO register 
 Control register 
 RX FIFO Threshold 
 TFER CMD FIFO Threshold 
 Bus Speed (1=Fast) 
 Enable Core (1=Enable) 
 Interrupt Status Enable register 
 Enable RX OVERFLOW IRQ 
 Enable ARB LOST IRQ 
 Enable NACK DET IRQ 
 Enable RX Ready IRQ 
 Enable TX Ready IRQ 
 Interrupt Status register 
 RX OVERFLOW IRQ 
 ARB LOST IRQ 
 NACK DET IRQ 
 RX Ready IRQ 
 TX Ready IRQ 
 Status register 
 Core Status (0=idle) 
 Transfer FIFO LVL register 
 Receive FIFO LVL register 
 SCL low count register 
 SCL high count register 
 SDA hold count register 
 IRQ Threshold at 1 element 
 100ms 
  struct altr_i2c_dev - I2C device context
  @base: pointer to register struct
  @msg: pointer to current message
  @msg_len: number of bytes transferred in msg
  @msg_err: error code for completed message
  @msg_complete: xfer completion object
  @dev: device reference
  @adapter: core i2c abstraction
  @i2c_clk: clock reference for i2c input clock
  @bus_clk_rate: current i2c bus clock rate
  @buf: ptr to msg buffer for easier use.
  @fifo_size: size of the FIFO passed in.
  @isr_mask: cached copy of local ISR enables.
  @isr_status: cached copy of local ISR status.
  @isr_mutex: mutex for IRQ thread.
 Standard mode SCL 5050 
 Fast mode SCL 3366 
 Reset controller 
 SCL High Time 
 SCL Low Time 
 SDA Hold Time, 300ns 
 Mask all master interrupt bits 
  altr_i2c_transfer - On the last byte to be transmitted, send
  a Stop bit on the last byte.
 On the last byte to be transmitted, send STOP 
  altr_i2c_empty_rx_fifo - Fetch data from RX FIFO until end of
  transfer. Send a Stop bit on the last byte.
  altr_i2c_fill_tx_fifo - Fill TX FIFO from current message buffer.
 Read IRQ status but only interested in Enabled IRQs. 
 handle Lost Arbitration 
 handle RX FIFO Overflow 
 RX FIFO needs service? 
 TX FIFO needs service? 
 Wait for the Core to finish 
 Make sure RX FIFO is empty 
 write the first byte to start the RX 
 default clock rate 
 Match table for of_platform binding 
 SPDX-License-Identifier: GPL-2.0-or-later
 ------------------------------------------------------------------------ 
  i2c-parport.c I2C bus over parallel port                                 
  ------------------------------------------------------------------------ 
   Copyright (C) 2003-2011 Jean Delvare <jdelvare@suse.de>
   Based on older i2c-philips-par.c driver
   Copyright (C) 1995-2000 Simon G. Vogl
   With some changes from:
   Frodo Looijaard <frodol@dds.nl>
   Kyösti Mälkki <kmalkki@cc.hut.fi>
 type 0: Philips adapter 
 type 1: home brew teletext adapter 
 type 2: Velleman K8000 adapter 
 type 3: ELV adapter 
 type 4: ADM1032 evaluation board 
 type 5: ADM1025, ADM1030 and ADM1031 evaluation boards 
 type 6: Barco LPT->DVI (K5800236) adapter 
 type 7: One For All JP1 parallel port adapter 
 type 8: VCT-jig 
 ----- Device list ------------------------------------------------------ 
 ----- Low-level parallel port access ----------------------------------- 
 ----- Unified line operation functions --------------------------------- 
 Touch only the bit(s) needed 
 ----- I2C algorithm call-back functions and structures ----------------- 
 Encapsulate the functions above in the correct structure.
   Note that this is only a template, from which the real structures are
   copied. The attaching code will set getscl to NULL for adapters that
   cannot read SCL back, and will also make the data field point to
 ~50 kbps 
 ----- I2c and parallel port call-back functions and structures --------- 
 Fill the rest of the structure 
 Slow down if we can't sense SCL 
 ~10 kbps 
 Reset hardware to a sane state (SCL and SDA high) 
 Other init if needed (power on...) 
 Give powered devices some time to settle 
 Setup SMBus alert if supported 
 Add the new adapter to the list 
 Walk the list 
 Un-init if needed (power off...) 
 SPDX-License-Identifier: GPL-2.0-only
   ARM IOCIOMD i2c driver.
   Copyright (C) 2000 Russell King
   On Acorn machines, the following i2c devices are on the bus:
 	- PCF8583 real time clock & static RAM
  We must preserve all non-i2c output bits in IOC_CONTROL.
  Note also that we need to preserve the value of SCL and
  SDA outputs as well (which may be different from the
  values read back from IOC_CONTROL).
 SPDX-License-Identifier: GPL-2.0-or-later
  TI OMAP I2C master mode driver
  Copyright (C) 2003 MontaVista Software, Inc.
  Copyright (C) 2005 Nokia Corporation
  Copyright (C) 2004 - 2007 Texas Instruments.
  Originally written by MontaVista Software, Inc.
  Additional contributions by:
 	Tony Lindgren <tony@atomide.com>
 	Imre Deak <imre.deak@nokia.com>
 	Juha Yrjölä <juha.yrjola@solidboot.com>
 	Syed Khasim <x0khasim@ti.com>
 	Nishant Menon <nm@ti.com>
 I2C controller revisions 
 I2C controller revisions present on specific hardware 
 timeout waiting for the controller to respond 
 timeout for pm runtime autosuspend 
 ms 
 timeout for making decision on bus free status 
 For OMAP3 I2C_IV has changed to I2C_WE (wakeup enable) 
 only on OMAP4430 
 I2C Interrupt Enable Register (OMAP_I2C_IE): 
 TX Buffer drain int enable 
 RX Buffer drain int enable 
 TX data ready int enable 
 RX data ready int enable 
 Access ready int enable 
 No ack interrupt enable 
 Arbitration lost int ena 
 I2C Status Register (OMAP_I2C_STAT): 
 TX Buffer draining 
 RX Buffer draining 
 Bus busy 
 Receive overrun 
 Transmit underflow 
 Address as slave 
 Bus Free 
 Transmit data ready 
 Receive data ready 
 Register access ready 
 No ack interrupt enable 
 Arbitration lost int ena 
 I2C WE wakeup enable register 
 TX drain wakup 
 RX drain wakeup 
 Address as slave wakeup
 Bus free wakeup 
 Start condition wakeup 
 General call wakeup 
 TXRX data ready wakeup 
 Reg access ready wakeup 
 No acknowledgment wakeup 
 Arbitration lost wakeup 
 I2C Buffer Configuration Register (OMAP_I2C_BUF): 
 RX DMA channel enable 
 RX FIFO Clear 
 TX DMA channel enable 
 TX FIFO Clear 
 I2C Configuration Register (OMAP_I2C_CON): 
 I2C module enable 
 Big endian mode 
 High Speed support 
 Start byte mode (master) 
 Masterslave mode 
 TXRX mode (master only) 
 Expand address 
 Repeat mode (master only) 
 Stop cond (master only) 
 Start condition (master) 
 I2C SCL time value when Master 
 I2C System Test Register (OMAP_I2C_SYSTEST): 
 System test enable 
 Free running mode 
 Test mode select 
 Test mode select 
 Functional mode 
 SCL line input value 
 SCL line output value 
 SDA line input value 
 SDA line output value 
 SDASCL IO mode 
 SCL line sense in 
 SCL line drive out 
 SDA line sense in 
 SDA line drive out 
 OCP_SYSSTATUS bit definitions 
 OCP_SYSCONFIG bit definitions 
 Errata definitions 
 virtual 
 bit shift for I2C register addresses 
 maximum mpu wkup latency 
 Speed of bus in kHz 
	u8			fifo_size;	 use as flag and value
						  fifo_size==0 implies no fifo
						  if set, should be trsh+1
 bad hw fixes 
	unsigned		bb_valid:1;	 true when BB-bit reflects
						  the I2C bus state
 true when we're in receiver mode 
 Saved interrupt register 
 Setup clock prescaler to obtain approx 12MHz I2C module clock: 
 SCL low and high time values 
 Take the I2C module out of reset: 
	
	  NOTE: right after setting CON_EN, STAT_BB could be 0 while the
	  bus is busy. It will be changed to 1 on the next IP FCLK clock.
	  udelay(1) will be enough to fix that.
	
	  Don't write to this register if the IE state is 0 as it can
	  cause deadlock.
 Disable I2C controller before soft reset 
		 For some reason we need to set the EN bit before the
 SYSC register is cleared by the reset; rewrite it 
 Schedule I2C-bus monitoring on the next transfer 
		
		  Enabling all wakup sources to stop I2C freezing on
		  WFI instruction.
		  REVISIT: Some wkup sources might not be needed.
		
		  The I2C functional clock is the armxor_ck, so there's
		  no need to get "armxor_ck" separately.  Now, if OMAP2420
		  always returns 12MHz for the functional clock, we can
		  do this bit unconditionally.
		 TRM for 5912 says the I2C clock must be prescaled to be
		  between 7 - 12 MHz. The XOR input clock is typically
		  12, 13 or 19.2 MHz. So we should have code that produces:
		 
		  XOR MHz	Divider		Prescaler
		  12		1		0
		  13		2		1
		  19.2		2		1
		
		  HSI2C controller internal clk rate should be 19.2 Mhz for
		  HS and for all modes on 2430. On 34xx we can use lower rate
		  to get longer filter period for better noise suppression.
		  The filter is iclk (fclk for HS) period.
 Compute prescaler divisor 
 If configured for High Speed 
 For first phase of HS mode 
 For second phase of HS mode 
 Fast mode 
 Standard mode 
 Program desired operating rate 
 Not implemented 
  Try bus recovery, but only if SDA is actually low.
 bus seems to already be fine 
 recovery would not fix SCL 
  Waiting on Bus Busy
  Wait while BB-bit doesn't reflect the I2C bus state
  In a multimaster environment, after IP software reset, BB-bit value doesn't
  correspond to the current bus state. It may happen what BB-bit will be 0,
  while the bus is busy due to another I2C master activity.
  Here are BB-bit values after reset:
      SDA   SCL   BB   NOTES
        0     0    0   1, 2
        1     0    0   1, 2
        0     1    1
        1     1    0   3
  Later, if IP detect SDA=0 and SCL=1 (ACK) or SDA 1->0 while SCL=1 (START)
  combinations on the bus, it set BB-bit to 1.
  If IP detect SDA 0->1 while SCL=1 (STOP) combination on the bus,
  it set BB-bit to 0 and BF to 1.
  BB and BF bits correctly tracks the bus state while IP is suspended
  BB bit became valid on the next FCLK clock after CON_EN bit set
  NOTES:
  1. Any transfer started when BB=0 and bus is busy wouldn't be
     completed by IP and results in controller timeout.
  2. Any transfer started when BB=0 and SCL=0 results in IP
     starting to drive SDA low. In that case IP corrupt data
     on the bus.
  3. Any transfer started in the middle of another master's transfer
     results in unpredictable results and data corruption
		
		  We will see BB or BF event in a case IP had detected any
		  activity on the I2C bus. Now IP correctly tracks the bus
		  state. BB-bit value is valid.
		
		  Otherwise, we must look signals on the bus to make
		  the right decision.
			
			  SDA and SCL lines was high for 10 ms without bus
			  activity detected. The bus is free. Consider
			  BB-bit value is valid.
			
			  SDA or SCL were low for the entire timeout without
			  any activity detected. Most likely, a slave is
			  locking up the bus with no master driving the clock.
	
	  Set up notification threshold based on message size. We're doing
	  this to try and avoid draining feature as much as possible. Whenever
	  we have big messages to transfer (bigger than our total fifo size)
	  then we might use draining feature to transfer the remaining bytes.
 Clear RX Threshold 
 Clear TX Threshold 
 Enable hardware fixes 
 calculate wakeup latency constraint for MPU 
  Low level master readwrite transaction.
 REVISIT: Could the STB bit of I2C_CON be used with probing? 
 make sure writes to omap->buf_len are ordered 
 Clear the FIFO Buffers 
 High speed configuration 
	
	  NOTE: STAT_BB bit could became 1 here if another master occupy
	  the bus. IP successfully complete transfer when the bus will be
	  free again (BB reset to 0).
	
	  Don't write stt and stp together on some hardware.
 Let the user know if i2c is in a bad state 
	
	  REVISIT: We should abort the transfer on signals, but the bus goes
	  into arbitration and we're currently unable to recover from it.
 We have an error 
  Prepare controller for a transaction and call omap_i2c_xfer_msg
  to do the work during IRQ processing.
	
	  I2C Errata(Errata Nos. OMAP2: 1.67, OMAP3: 1.8)
	  Not applicable for OMAP4.
	  Under certain rare conditions, RDR could be set again
	  when the bus is busy, then ignore the interrupt and
	  clear the interrupt.
 Step 1: If RDR is set, clear it 
 Step 2: 
 Step 3: 
 rev1 devices are apparently only on some 15xx 
 None 
 Arbitration lost 
 No acknowledgement 
 Register access ready 
 Receive data ready 
 Transmit data ready 
  OMAP3430 Errata i462: When an XRDYXDR is hit, wait for XUDF before writing
  data to DATA_REG. Otherwise some data bytes can be lost while transferring
  them from the memory to the I2C interface.
		
		  Data reg in 2430, omap3 and
		  omap4 is 8 bit wide
		
		  Data reg in 2430, omap3 and
		  omap4 is 8 bit wide
 If we're in receiver mode, ignore XDRXRDY 
 my work here is done 
		
		  ProDB0017052: Clear ARDY bit twice
 enable test mode 
 select SDASCL IO mode 
 set SCL to high-impedance state (reset value is 0) 
 set SDA to high-impedance state (reset value is 0) 
 restore reset values 
 convert DT freq value in Hz into kHz for speed 
	
	  Read the Rev hi bit-[15:14] ie scheme this is 1 indicates ver2.
	  On omap132 Offset 4 is IE Reg the bit [15:14] is 0 at reset.
	  Also since the omap_i2c_read_reg uses reg_map_ip_ a
	  readw_relaxed is done.
 Set up the fifo size - Get total size 
		
		  Set up notification threshold as half the total available
		  size. This is to ensure that we can handle the status on int
		  call back latencies.
 Enable hardware fixes 
 calculate wakeup latency constraint for MPU 
 reset ASAP, clearing any IRQs 
 i2c device drivers may be active on return from add_adapter() 
 Read clears 
 Flush posted write 
 I2C may be needed to bring up other drivers 
 SPDX-License-Identifier: GPL-2.0-or-later
  Synopsys DesignWare I2C adapter driver (master only).
  Based on the TI DAVINCI I2C adapter driver.
  Copyright (C) 2006 Texas Instruments.
  Copyright (C) 2007 MontaVista Software Inc.
  Copyright (C) 2009 Provigent Ltd.
 Configure TxRx FIFO threshold levels 
 Configure the I2C master 
 Set standard and fast speed dividers for highlow periods 
 ns 
 ns 
 Calculate SCL timing parameters for standard mode if not set 
 tHD;STA = tHIGH = 4.0 us 
 0: DW default, 1: Ideal 
 No offset 
 tLOW = 4.7 us 
 No offset 
	
	  Set SCL timing parameters for fast mode or fast mode plus. Only
	  difference is the timing parameter values since the registers are
	  the same.
		
		  Check are Fast Mode Plus parameters available. Calculate
		  SCL timing parameters for Fast Mode Plus if not set.
 tHIGH = 260 ns 
 DW default 
 No offset 
 tLOW = 500 ns 
 No offset 
	
	  Calculate SCL timing parameters for fast mode if not set. They are
	  needed also in high speed mode.
 tHD;STA = tHIGH = 0.6 us 
 0: DW default, 1: Ideal 
 No offset 
 tLOW = 1.3 us 
 No offset 
 Check is high speed possible and fall back to fast mode if not 
 tHIGH = 160 ns 
 DW default 
 No offset 
 tLOW = 320 ns 
 No offset 
  i2c_dw_init_master() - Initialize the designware I2C master hardware
  @dev: device private data
  This functions configures and enables the I2C master.
  This function is called during I2C init function, and in case of timeout at
  run time.
 Disable the adapter 
 Write standard speed timing parameters 
 Write fast modefast mode plus timing parameters 
 Write high speed timing parameters if supported 
 Write SDA hold time if supported 
 Disable the adapter 
 If the slave address is ten bit address, enable 10BITADDR 
		
		  If I2C_DYNAMIC_TAR_UPDATE is set, the 10-bit addressing
		  mode has to be enabled via bit 12 of IC_TAR register.
		  We set it always as I2C_DYNAMIC_TAR_UPDATE can't be
		  detected from registers.
	
	  Set the slave (target) address and enable 10-bit addressing mode
	  if applicable.
 Enforce disabled interrupts (due to HW issues) 
 Enable the adapter 
 Dummy read to avoid the register getting stuck on Bay Trail 
 Clear and enable interrupts 
  Initiate and continue master readwrite transaction with polling
  based transfer routine afterward write messages into the Tx buffer.
	
	  In order to enable the interrupt for UCSI i.e. AMD NAVI GPU card,
	  it is mandatory to set the right value in specific register
	  (offset:0x474) as per the hardware IP specification.
 Initiate messages readwrite transaction 
		
		  Initiate the i2c readwrite transaction of buffer length,
		  and poll for bus busy status. For the last message transfer,
		  update the command with stopbit enable.
 Due to hardware bug, need to write the same command twice. 
					
					  Need to check the stop bit. However, it cannot be
					  detected from the registers so we check it always
					  when readwrite the last byte.
  Initiate (and continue) low level master readwrite transaction.
  This function is only called from i2c_dw_isr, and pumping i2c_msg
  messages into the tx buffer.  Even if the size of i2c_msg data is
  longer than the size of the tx buffer, it handles everything.
		
		  If target address has changed, we need to
		  reprogram the target address in the I2C
		  adapter when we are done with this transfer.
 new i2c_msg 
			 If both IC_EMPTYFIFO_HOLD_MASTER_EN and
			  IC_RESTART_EN are set, we must manually
			  set restart bit between messages.
			
			  If IC_EMPTYFIFO_HOLD_MASTER_EN is set we must
			  manually set the stop bit. However, it cannot be
			  detected from the registers so we set it always
			  when writingreading the last byte.
			
			  i2c-core always sets the buffer length of
			  I2C_FUNC_SMBUS_BLOCK_DATA to 1. The length will
			  be adjusted when receiving the first byte.
			  Thus we can't stop the transaction here.
 Avoid rx buffer overrun 
		
		  Because we don't know the buffer length in the
		  I2C_FUNC_SMBUS_BLOCK_DATA case, we can't stop
		  the transaction here.
 more bytes to be written 
	
	  If i2c_msg index search is completed, we don't need TX_EMPTY
	  interrupt any more.
	
	  Adjust the buffer length and mask the flag
	  after receiving the first byte.
 Ensure length byte is a valid value 
  Prepare controller for a transaction and call i2c_dw_xfer_msg.
	
	  Initiate I2C message transfer when AMD NAVI GPU card is enabled,
	  As it is polling based transfer mechanism, which does not support
	  interrupt based functionalities of existing DesignWare driver.
 Start the transfers 
 Wait for tx to complete 
 i2c_dw_init implicitly disables the adapter 
	
	  We must disable the adapter before returning and signaling the end
	  of the current transfer. Otherwise the hardware might continue
	  generating interrupts which in turn causes a race condition with
	  the following transfer.  Needs some more investigation if the
	  additional interrupts are a hardware bug or this driver doesn't
	  handle them correctly yet.
 No error 
 We have an error 
	
	  The IC_INTR_STAT register just indicates "enabled" interrupts.
	  The unmasked raw version of interrupt status bits is available
	  in the IC_RAW_INTR_STAT register.
	 
	  That is,
	    stat = readl(IC_INTR_STAT);
	  equals to,
	    stat = readl(IC_RAW_INTR_STAT) & readl(IC_INTR_MASK);
	 
	  The raw version might be useful for debugging purposes.
	
	  Do not use the IC_CLR_INTR register to clear interrupts, or
	  you'll miss some interrupts, triggered during the period from
	  readl(IC_INTR_STAT) to readl(IC_CLR_INTR).
	 
	  Instead, use the separately-prepared IC_CLR_ registers.
		
		  The IC_TX_ABRT_SOURCE register is cleared whenever
		  the IC_CLR_TX_ABRT is read.  Preserve it beforehand.
  Interrupt service routine. This gets called whenever an I2C master interrupt
  occurs.
		
		  Anytime TX_ABRT is set, the contents of the txrx
		  buffers are flushed. Make sure to skip them.
	
	  No need to modify or disable the interrupt mask here.
	  i2c_dw_xfer_msg() will take care of it according to
	  the current transmit status.
 Workaround to trigger pending interrupt 
	
	  Increment PM usage count during adapter registration in order to
	  avoid possible spurious runtime suspend when adapter device is
	  registered to the device core and immediate resume in case bus has
	  registered I2C slaves that do I2C transfers in their probe.
  I2C bus driver for the SH7760 I2C Interfaces.
  (c) 2005-2008 MSC Vertriebsges.m.b.H, Manuel Lauss <mlau@msc-ge.com>
  licensed under the terms outlined in the file COPYING.
 register offsets 
 slave ctrl		
 master ctrl		
 slave status		
 master status	
 slave irq enable	
 master irq enable	
 clock dividers	
 slave address	
 master address	
 data port		
 fifo control		
 fifo status		
 fifo irq enable	
 rx fifo count	
 tx fifo count	
 non-fifo mode switch	
 override SCL pin	
 override SDA pin	
 override pins	
 master if enable	
 force stop bit	
 en startbit gen.	
 nack received	
 arbitration lost	
 sent a stop		
 slave addr xfer done	
 nack irq en		
 arblos irq en	
 stop irq en		
 address sent irq en	
 reset rx fifo	
 reset tx fifo	
 last byte sent	
 rx fifo trigger	
 tx fifo empty	
 tx fifo empty irq en	
 rx fifo trig irq en	
 tx fifo trig irq en	
 message processing 
 arbitration lost 
		 NACK handling is very screwed up.  After receiving a
		  NAK IRQ one has to wait a bit  before writing to any
		  registers, or the ctl will lock up. After that delay
		  do a normal i2c stop. Then wait at least 1 ms before
		  attempting another transfer or ctl will stop working
 wait or risk ctl hang 
 In some cases the MST bit is also set. 
 i2c-stop was sent 
 i2c slave addr was sent; set to "normal" operation 
 manual says: wait >= 0.5 SCL times 
 next int should be MST 
				 keep the RDF bit: ctrl holds SCL low
				  until the setup for the next i2c_msg
				  clears this bit.
				 keep the TEND bit: ctl holds SCL low
				  until the setup for the next i2c_msg
				  clears this bit.
 clear status flags and ctrl resumes work 
 prepare and start a master receive operation 
 set the slave addr reg; otherwise rcv wont work! 
 adjust rx fifo trigger 
 trigger at fifo full 
 trigger before all received 
 prepare and start a master send operation 
 set the slave addr reg; otherwise xmit wont work! 
 adjust tx fifo trigger 
 trig: 2 bytes left in TX fifo 
 trig: 8 bytes left in TX fifo 
 wait a bit or i2c module stops working 
	 reset slave module registers too: master mode enables slave
	  module for receive ops (ack, data). Without this reset,
	  eternal bus activity might be reported after NACK  ARBLOST.
 calculate CCR register setting for a desired scl clock.  SCL clock is
  derived from I2C module clock  (iclk)  which in turn is derived from
  peripheral module clock (mclk, usually around 33MHz):
  iclk = mclk(CDF + 1).  iclk must be < 20MHz.
  scl = iclk(SCGD8 + 20).
 fail if more than 25% off of requested SCL 
 create a CCR register value 
 SPDX-License-Identifier: GPL-2.0-only
  Driver for I2C adapter in Rockchip RK3xxx SoC
  Max Schwarz <max.schwarz@online.de>
  based on the patches by Rockchip Inc.
 Register Map 
 control register 
 clock divisor register 
 slave address for REGISTER_TX 
 slave register address for REGISTER_TX 
 number of bytes to be transmitted 
 number of bytes to be received 
 interrupt enable 
 interrupt pending 
 finished count 
 Data buffer offsets 
 REG_CON bits 
 transmit data 
 select register and restart 
 receive data 
	REG_CON_MOD_REGISTER_RX,  broken: transmits read addr AND writes
 1: send NACK after last received byte 
 1: stop if NACK is received 
 REG_MRXADDR bits 
 [x8+7:x8] of MRX[R]ADDR valid 
 REG_IENREG_IPD bits 
 a byte was transmitted 
 a byte was received 
 master data transmit finished 
 master data receive finished 
 START condition generated 
 STOP condition generated 
 NACK received 
 Constants 
 ms 
 Hz 
  struct i2c_spec_values:
  @min_hold_start_ns: min hold time (repeated) START condition
  @min_low_ns: min LOW period of the SCL clock
  @min_high_ns: min HIGH period of the SCL cloc
  @min_setup_start_ns: min set-up time for a repeated START conditio
  @max_data_hold_ns: max data hold time
  @min_data_setup_ns: min data set-up time
  @min_setup_stop_ns: min set-up time for STOP condition
  @min_hold_buffer_ns: min bus free time between a STOP and
  START condition
  struct rk3x_i2c_calced_timings:
  @div_low: Divider output for low
  @div_high: Divider output for high
  @tuning: Used to adjust setuphold data time,
  setuphold start time and setup stop time for
  v1's calc_timings, the tuning should all be 0
  for old hardware anyone using v0's calc_timings.
  struct rk3x_i2c_soc_data:
  @grf_offset: offset inside the grf regmap for setting the i2c type
  @calc_timings: Callback function for i2c timing information calculated
  struct rk3x_i2c - private data of the controller
  @adap: corresponding I2C adapter
  @dev: device for this controller
  @soc_data: related soc data struct
  @regs: virtual memory area
  @clk: function clk for rk3399 or function & Bus clks for others
  @pclk: Bus clk for rk3399
  @clk_rate_nb: i2c clk rate change notify
  @t: I2C known timing information
  @lock: spinlock for the i2c bus
  @wait: the waitqueue to wait for i2c transfer
  @busy: the condition for the event to wait for
  @msg: current i2c message
  @addr: addr of i2c slave device
  @mode: mode of i2c transfer
  @is_last_msg: flag determines whether it is the last msg in this transfer
  @state: state of i2c transfer
  @processed: byte length which has been send or received
  @error: error code for i2c transfer
 Hardware resources 
 Settings 
 Synchronization & notification 
 Current message 
 I2C state machine 
 Reset all interrupt pending bits 
  Generate a START condition, which triggers a REG_INT_START interrupt.
 enable adapter with correct mode, send START condition 
 if we want to react to NACK, set ACTACK bit 
  Generate a STOP condition, which triggers a REG_INT_STOP interrupt.
  @error: Error code to return in rk3x_i2c_xfer
 Enable stop interrupt 
 Signal rk3x_i2c_xfer to start the next message. 
		
		  The HW is actually not capable of REPEATED START. But we can
		  get the intended effect by resetting its internal state
		  and issuing an ordinary START.
 signal that we are finished with the current msg 
  Setup a read according to i2c->msg
	
	  The hw can read up to 32 bytes at a time. If we need more than one
	  chunk, send an ACK after the last byte of the current chunk.
 make sure we are in plain RX mode if we read a second chunk 
  Fill the transmit buffer with data from i2c->msg
 IRQ handlers for individual states 
 ack interrupt 
 disable start bit 
 enable appropriate interrupts and transition 
 in any other case, we are going to be reading. 
 ack interrupt 
 are we finished? 
 we only care for MBRF here. 
 ack interrupt 
 Can only handle a maximum of 32 bytes at a time 
 read the data from receive buffer 
 are we finished? 
 ack interrupt 
 disable STOP bit 
 signal rk3x_i2c_xfer that we are finished 
 Clean interrupt bits we don't care about 
		
		  We got a NACK in the last operation. Depending on whether
		  IGNORE_NAK is set, we have to stop the operation and report
		  an error.
 is there anything left to handle? 
  Get timing values of I2C specification
  @speed: Desired SCL frequency
  Returns: Matched i2c spec values.
  Calculate divider values for desired SCL frequency
  @clk_rate: I2C input clock rate
  @t: Known I2C timing information
  @t_calc: Caculated rk3x private timings that would be written into regs
  Returns: 0 on success, -EINVAL if the goal SCL rate is too slow. In that case
  a best-effort divider value is returned in divs. If the target rate is
  too high, we silently use the highest possible rate.
 Only support standard-mode and fast-mode 
 prevent scl_rate_khz from becoming 0 
	
	  min_low_ns:  The minimum number of ns we need to hold low to
	 		meet I2C specification, should include fall time.
	  min_high_ns: The minimum number of ns we need to hold high to
	 		meet I2C specification, should include rise time.
	  max_low_ns:  The maximum number of ns we can hold low to meet
	 		I2C specification.
	 
	  Note: max_low_ns should be (maximum data hold time  2 - buffer)
	 	 This is because the i2c host on Rockchip holds the data line
	 	 for half the low time.
	
	  Timings for repeated start:
	  - controller appears to drop SDA at .875x (78) programmed clk high.
	  - controller appears to keep SCL high for 2x programmed clk high.
	 
	  We need to account for those rules in picking our "high" time so
	  we meet tSU;STA and tHD;STA times.
 Adjust to avoid overflow 
	
	  We need the total div to be >= this number
	  so we don't clock too fast.
 These are the min dividers needed for min hold times. 
	
	  This is the maximum divider so we don't go over the maximum.
	  We don't round up here (we round down) since this is a maximum.
		
		  Time needed to meet hold requirements is important.
		  Just use that.
		
		  We've got to distribute some time among the low and high
		  so we don't run too fast.
		
		  We'll try to split things up perfectly evenly,
		  biasing slightly towards having a higher div
		  for low (spend more time low).
 Don't allow it to go over the maximum 
		
		  Handle when the ideal low div is going to take up
		  more than we have.
 Give low the "ideal" and give high whatever extra is left 
	
	  Adjust to the fact that the hardware has an implicit "+1".
	  NOTE: Above calculations always produce div_low > 0 and div_high > 0.
 Give the tuning value 0, that would not update con register 
 Maximum divider supported by hw is 0xffff 
  Calculate timing values for desired SCL frequency
  @clk_rate: I2C input clock rate
  @t: Known I2C timing information
  @t_calc: Caculated rk3x private timings that would be written into regs
  Returns: 0 on success, -EINVAL if the goal SCL rate is too slow. In that case
  a best-effort divider value is returned in divs. If the target rate is
  too high, we silently use the highest possible rate.
  The following formulas are v1's method to calculate timings.
  l = divl + 1;
  h = divh + 1;
  s = sda_update_config + 1;
  u = start_setup_config + 1;
  p = stop_setup_config + 1;
  T = Tclk_i2c;
  tHigh = 8  h  T;
  tLow = 8  l  T;
  tHD;sda = (l  s + 1)  T;
  tSU;sda = [(8 - s)  l + 1]  T;
  tI2C = 8  (l + h)  T;
  tSU;sta = (8h  u + 1)  T;
  tHD;sta = [8h  (u + 1) - 1]  T;
  tSU;sto = (8h  p + 1)  T;
 Support standard-mode, fast-mode and fast-mode plus 
 prevent scl_rate_khz from becoming 0 
	
	  min_low_ns: The minimum number of ns we need to hold low to
	 	       meet I2C specification, should include fall time.
	  min_high_ns: The minimum number of ns we need to hold high to
	 	        meet I2C specification, should include rise time.
 calculate min-divh and min-divl 
	
	  Final divh and divl must be greater than 0, otherwise the
	  hardware would not output the i2c clk.
 These are the min dividers needed for min hold times. 
	
	  This is the maximum divider so we don't go over the maximum.
	  We don't round up here (we round down) since this is a maximum.
		
		  Time needed to meet hold requirements is important.
		  Just use that.
		
		  We've got to distribute some time among the low and high
		  so we don't run too fast.
		  We'll try to split things up by the scale of min_low_div and
		  min_high_div, biasing slightly towards having a higher div
		  for low (spend more time low).
	
	  calculate sda data hold count by the rules, data_upd_st:3
	  is a appropriate value to reduce calculated times.
 calculate setup start config 
 calculate setup stop config 
 Maximum divider supported by hw is 0xffff 
  rk3x_i2c_clk_notifier_cb - Clock rate change callback
  @nb:		Pointer to notifier block
  @event:	Notification reason
  @data:	Pointer to notification data object
  The callback checks whether a valid bus frequency can be generated after the
  change. If so, the change is acknowledged, otherwise the change is aborted.
  New dividers are written to the HW in the pre- or post change notification
  depending on the scaling direction.
  Code adapted from i2c-cadence.c.
  Return:	NOTIFY_STOP if the rate change should be aborted, NOTIFY_OK
 		to acknowledge the change, NOTIFY_DONE if the notification is
 		considered irrelevant.
		
		  Try the calculation (but don't store the result) ahead of
		  time to see if we need to block the clock change.  Timings
		  shouldn't actually take effect until rk3x_i2c_adapt_div().
 scale up 
 scale down 
 scale up 
  Setup I2C registers for an I2C operation specified by msgs, num.
  Must be called with i2c->lock held.
  @msgs: I2C msgs to process
  @num: Number of msgs
  returns: Number of I2C msgs processed or negative in case of error
	
	  The I2C adapter can issue a small (len < 4) write packet before
	  reading. This speeds up SMBus-style register reads.
	  The MRXADDRMRXRADDR hold the slave address and the slave register
	  address in this case.
 Fill MRXRADDR with the register address(es) 
 msgs[0] is handled by hw. 
		
		  We'll have to do it the boring way and process the msgs
		  one-by-one.
 set read bit 
			
			  We have to transmit the slave addr first. Use
			  MOD_REGISTER_TX for that purpose.
	
	  Process msgs. We can handle more than one message at once (see
	  rk3x_i2c_setup()).
 Force a STOP condition without interrupt 
 use common interface to get I2C timing properties 
 Try to set the I2C adapter number from dt 
	
	  Switch to new interface if the SoC also offers the old one.
	  The control bit is located in the GRF register space.
 27+i: write mask, 11+i: value 
 IRQ setup 
 Only one clock to use for bus clock and peripheral clock 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2014 Linaro Ltd.
  Copyright (c) 2014 HiSilicon Limited.
  Now only support 7 bit address.
 Register Map 
 I2C_CTRL_REG 
 I2C_COM_REG 
 I2C_ICR_REG 
 I2C_SR_REG 
 IRQ synchronization 
 close all i2c interrupt 
 restore original interrupt
 wait for 100 milli seconds for the bus to be idle 
 the last byte don't need send ACK 
 if i2c master receive data will send ACK 
 handle error 
 bus error 
 ack error 
	
	  If this is the last message to be transfered (stop == 1)
	  Then check if the bus can be brought back to idle.
 use 100k as default value 
 SPDX-License-Identifier: GPL-2.0
  Renesas Solutions Highlander FPGA I2CSMBus support.
  Supported devices: R0P7780LC0011RL, R0P7785LC0011RL
  Copyright (C) 2008  Paul Mundt
  Copyright (C) 2008  Renesas Solutions Corp.
  Copyright (C) 2008  Atom Create Engineering Co., Ltd.
		
		  Don't bother checking ACKE here, this and the reset
		  are handled in highlander_i2c_wait_xfer_done() when
		  waiting for the ACK.
 busy looping, the IRQ of champions 
	
	  The R0P7780LC0011RL FPGA needs a significant delay between
	  data read cycles, otherwise the transceiver gets confused and
	  garbage is returned when the read is subsequently aborted.
	 
	  It is not sufficient to wait for BBSY.
	 
	  While this generally only applies to the older SH7780-based
	  Highlanders, the same issue can be observed on SH7785 ones,
	  albeit less frequently. SH7780-based Highlanders may need
	  this to be as high as 1000 ms.
	
	  Set up the buffer and transfer size
	
	  Encode the mode setting
 default 
 Ensure we're in a sane state 
 Set slave address 
 initial read jiffies 
	
	  Reset the adapter
  Copyright 2011, Netlogic Microsystems Inc.
  Copyright 2004, Matt Porter <mporter@kernel.crashing.org>
  This file is licensed under the terms of the GNU General Public
  License version 2.  This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 XLR I2C REGISTERS 
 Sigma Designs additional registers 
 XLR I2C REGISTERS FLAGS 
 Register Values 
 No Data 
 Read 
 Write 
 timeout per byte in msec 
  On XLRXLS, we need to use __raw_ IO to read the I2C registers
  because they are in the big-endian MMIO area on the SoC.
  The readlwritel implementation on XLRXLS byteswaps, because
  those are for its little-endian PCI space (see archmipsKconfig).
 optional feature support 
 value of STATUS[0] when busy 
 extra CFG bits to set 
 retry can only happen on the first byte 
 reset timeout on successful xmit 
 should not happen 
 reset timeout on successful read 
 Emulate SMBUS over I2C 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2006-2007 PA Semi, Inc
  SMBus host driver for PA Semi PWRficient
	
	  The original PASemi PCI controllers don't have a register for
	  their HW revision.
 SPDX-License-Identifier: GPL-2.0
  Driver for STMicroelectronics STM32 I2C controller
  This I2C controller is described in the STM32F429439 Soc reference manual.
  Please see below a link to the documentation:
  http:www.st.comresourceenreference_manualDM00031020.pdf
  Copyright (C) M'boumba Cedric Madianga 2016
  Copyright (C) STMicroelectronics 2017
  Author: M'boumba Cedric Madianga <cedric.madianga@gmail.com>
  This driver is based on i2c-st.c
 STM32F4 I2C offset registers 
 STM32F4 I2C control 1
 STM32F4 I2C control 2 
 STM32F4 I2C Status 1 
 STM32F4 I2C Status 2 
 STM32F4 I2C Control Clock 
 STM32F4 I2C Trise 
  struct stm32f4_i2c_msg - client specific data
  @addr: 8-bit slave addr, including rw bit
  @count: number of bytes to be transferred
  @buf: data buffer
  @result: result of the transfer
  @stop: last I2C msg to be sent, i.e. STOP to be generated
  struct stm32f4_i2c_dev - private data of the controller
  @adap: I2C adapter for this controller
  @dev: device for this controller
  @base: virtual memory area
  @complete: completion of I2C message
  @clk: hw i2c clock
  @speed: I2C clock frequency of the controller. Standard or Fast are supported
  @parent_rate: I2C clock parent rate in MHz
  @msg: I2C transfer information
		
		  To reach 100 kHz, the parent clk frequency should be between
		  a minimum value of 2 MHz and a maximum value of 46 MHz due
		  to hardware limitation
		
		  To be as close as possible to 400 kHz, the parent clk
		  frequency should be between a minimum value of 6 MHz and a
		  maximum value of 46 MHz due to hardware limitation
	
	  These bits must be programmed with the maximum SCL rise time given in
	  the I2C bus specification, incremented by 1.
	 
	  In standard mode, the maximum allowed SCL rise time is 1000 ns.
	  If, in the I2C_CR2 register, the value of FREQ[5:0] bits is equal to
	  0x08 so period = 125 ns therefore the TRISE[5:0] bits must be
	  programmed with 0x9. (1000 ns  125 ns + 1)
	  So, for I2C standard mode TRISE = FREQ[5:0] + 1
	 
	  In fast mode, the maximum allowed SCL rise time is 300 ns.
	  If, in the I2C_CR2 register, the value of FREQ[5:0] bits is equal to
	  0x08 so period = 125 ns therefore the TRISE[5:0] bits must be
	  programmed with 0x3. (300 ns  125 ns + 1)
	  So, for I2C fast mode TRISE = FREQ[5:0]  300  1000 + 1
	 
	  Function stm32f4_i2c_set_periph_clk_freq made sure that parent rate
	  is not higher than 46 MHz . As a result trise is at most 4 bits wide
	  and so fits into the TRISE bits [5:0].
		
		  In standard mode:
		  t_scl_high = t_scl_low = CCR  I2C parent clk period
		  So to reach 100 kHz, we have:
		  CCR = I2C parent rate  (100 kHz  2)
		 
		  For example with parent rate = 2 MHz:
		  CCR = 2000000  (100000  2) = 10
		  t_scl_high = t_scl_low = 10  (1  2000000) = 5000 ns
		  t_scl_high + t_scl_low = 10000 ns so 100 kHz is reached
		 
		  Function stm32f4_i2c_set_periph_clk_freq made sure that
		  parent rate is not higher than 46 MHz . As a result val
		  is at most 8 bits wide and so fits into the CCR bits [11:0].
		
		  In fast mode, we compute CCR with duty = 0 as with low
		  frequencies we are not able to reach 400 kHz.
		  In that case:
		  t_scl_high = CCR  I2C parent clk period
		  t_scl_low = 2  CCR  I2C parent clk period
		  So, CCR = I2C parent rate  (400 kHz  3)
		 
		  For example with parent rate = 6 MHz:
		  CCR = 6000000  (400000  3) = 5
		  t_scl_high = 5  (1  6000000) = 833 ns > 600 ns
		  t_scl_low = 2  5  (1  6000000) = 1667 ns > 1300 ns
		  t_scl_high + t_scl_low = 2500 ns so 400 kHz is reached
		 
		  Function stm32f4_i2c_set_periph_clk_freq made sure that
		  parent rate is not higher than 46 MHz . As a result val
		  is at most 6 bits wide and so fits into the CCR bits [11:0].
 Select Fast mode 
  stm32f4_i2c_hw_config() - Prepare I2C block
  @i2c_dev: Controller's private data
 Enable I2C 
  stm32f4_i2c_write_byte() - Write a byte in the data register
  @i2c_dev: Controller's private data
  @byte: Data to write in the register
  stm32f4_i2c_write_msg() - Fill the data register in write mode
  @i2c_dev: Controller's private data
  This function fills the data register with I2C transfer buffer
  stm32f4_i2c_handle_write() - Handle FIFO empty interrupt in case of write
  @i2c_dev: Controller's private data
			
			  Disable buffer interrupts for RX not empty and TX
			  empty events
  stm32f4_i2c_handle_read() - Handle FIFO empty interrupt in case of read
  @i2c_dev: Controller's private data
  This function is called when a new data is received in data register
	
	  For 2-byte reception, 3-byte reception and for Data N-2, N-1 and N
	  for N-byte reception with N > 3, we do not have to read the data
	  register when RX not empty event occurs as we have to wait for byte
	  transferred finished event before reading data.
	  So, here we just disable buffer interrupt in order to avoid another
	  system preemption due to RX not empty event.
	
	  For N byte reception with N > 3 we directly read data register
	  until N-2 data.
  stm32f4_i2c_handle_rx_done() - Handle byte transfer finished interrupt
  in case of read
  @i2c_dev: Controller's private data
  This function is called when a new data is received in the shift register
  but data register has not been read yet.
		
		  In order to correctly send the Stop or Repeated Start
		  condition on the I2C bus, the STOPSTART bit has to be set
		  before reading the last two bytes (data N-1 and N).
		  After that, we could read the last two bytes, disable
		  remaining interrupts and notify the end of xfer to the
		  client
		
		  In order to correctly generate the NACK pulse after the last
		  received data byte, we have to enable NACK before reading N-2
		  data
  stm32f4_i2c_handle_rx_addr() - Handle address matched interrupt in case of
  master receiver
  @i2c_dev: Controller's private data
 Clear ADDR flag 
		
		  Single byte reception:
		  Enable NACK and reset POS (Acknowledge position).
		  Then, clear ADDR flag and set STOP or RepSTART.
		  In that way, the NACK and STOP or RepStart pulses will be
		  sent as soon as the byte will be received in shift register
		
		  2-byte reception:
		  Enable NACK, set POS (NACK position) and clear ADDR flag.
		  In that way, NACK will be sent for the next byte which will
		  be received in the shift register instead of the current
		  one.
		
		  N-byte reception:
		  Enable ACK, reset POS (ACK position) and clear ADDR flag.
		  In that way, ACK will be sent as soon as the current byte
		  will be received in the shift register
  stm32f4_i2c_isr_event() - Interrupt routine for I2C bus event
  @irq: interrupt number
  @data: Controller's private data
 Update possible_status if buffer interrupt is enabled 
 Start condition generated 
 I2C Address sent 
		
		  Enable buffer interrupts for RX not empty and TX empty
		  events
 TX empty 
 RX not empty 
	
	  The BTF (Byte Transfer finished) event occurs when:
	  - in reception : a new byte is received in the shift register
	  but the previous byte has not been read yet from data register
	  - in transmission: a new byte should be sent but the data register
	  has not been written yet
  stm32f4_i2c_isr_error() - Interrupt routine for I2C bus error
  @irq: interrupt number
  @data: Controller's private data
 Arbitration lost 
	
	  Acknowledge failure:
	  In master transmitter mode a Stop must be generated by software
 Bus error 
  stm32f4_i2c_xfer_msg() - Transfer a single I2C message
  @i2c_dev: Controller's private data
  @msg: I2C message to transfer
  @is_first: first message of the sequence
  @is_last: last message of the sequence
 Enable events and errors interrupts 
 START generation 
  stm32f4_i2c_xfer() - Transfer combined I2C message
  @i2c_adap: Adapter pointer to the controller
  @msgs: Pointer to data to be written.
  @num: Number of messages to be executed
 SPDX-License-Identifier: GPL-2.0
  Nuvoton NPCM7xx I2C Controller driver
  Copyright (C) 2020 Nuvoton Technologies tali.perry@nuvoton.com
  External I2C Interface driver xfer indication values, which indicate status
  of the bus.
  Operation type values (used to define the operation currently running)
  module is interrupt driven, on each interrupt the current operation is
  checked to see if the module is currently reading or writing.
 I2C Bank (module had 2 banks of registers) 
 Internal I2C states values (for the I2C module state machine). 
 Module supports setting multiple own slave addresses 
 init register and default value required to enable module 
 Common regs 
BANK0 regs
  npcm_i2caddr array:
  The module supports having multiple own slave addresses.
  Since the addr regs are sprinkled all over the address space,
  use this array to get the address or each register.
 SCL Low Time 
 FIFO Control 
 SCL High Time 
 BANK 1 regs 
 Both FIFOs Control and Status 
 Tx-FIFO Control 
 Bus T.O. 
 PEC Data 
 Tx-FIFO Status 
 Rx-FIFO Status 
 Rx-FIFO Control 
 NPCM_I2CST reg fields 
 NPCM_I2CCST reg fields 
 NPCM_I2CCTL1 reg fields 
 RW1S fields (inside a RW reg): 
 npcm_i2caddr reg fields 
 NPCM_I2CCTL2 reg fields 
 NPCM_I2CCTL3 reg fields 
 NPCM_I2CCST2 reg fields 
 NPCM_I2CCST3 reg fields 
 NPCM_I2CCTL4 reg fields 
 NPCM_I2CCTL5 reg fields 
 NPCM_I2CFIF_CTS reg fields 
 NPCM_I2CTXF_CTL reg fields 
 NPCM_I2CT_OUT reg fields 
 NPCM_I2CTXF_STS reg fields 
 NPCM_I2CRXF_STS reg fields 
 NPCM_I2CFIF_CTL reg fields 
 NPCM_I2CRXF_CTL reg fields 
 I2C_VER reg fields 
 stallstuck timeout in us 
 SCLFRQ field position 
 supported clk settings. values in Hz. 
 Status of one I2C module 
 IRQ synchronization 
 PEC bit mask per slave address 
 in Hz 
 debugfs device directory 
 quick protocol (just address) 
 select bank 0 for I2C addresses 
 Slave addresses removal 
 Disable module 
 enable\disable end of busy (EOB) interrupts 
 Clear EO_BUSY pending bit: 
 check if TX FIFO is not empty 
 check if TX FIFO status bit is set: 
 check if RX FIFO is not empty: 
 check if rx fifo full status is set: 
	
	  override HW issue: I2C may fail to supply stop condition in Master
	  Write operation.
	  Need to delay at least 5 us from the last int, before issueing a stop
 function called from interrupt, can't sleep 
 enable interrupt on slave match: 
 select bank 0 for address 3 to 10 
 Set and enable the address 
	
	  Save I2CCTL1 relevant bits. It is being cleared when the module
	   is disabled.
 Restore NPCM_I2CCTL1 Status 
 Clear BB (BUS BUSY) bit 
 Clear EOB bit 
 Clear all fifo bits: 
	
	  check that transaction was not timed-out, and msgs still
	  holds a valid value.
 Master tx finished and all transmit bytes were sent 
 MASTER transmit got a NACK before tx all bytes 
 Bus error 
 I2C wake up 
	
	  Fill the FIFO, while the FIFO is not full and there are more bytes
	  to write
  npcm_i2c_set_fifo:
  configure the FIFO before using it. If nread is -1 RX FIFO will not be
  configured. same for nwrite
 configure RX FIFO 
 set LAST bit. if LAST is set next FIFO packet is nacked 
		
		  if we are about to read the first byte in blk rd mode,
		  don't NACK it. If slave returns zero size HW can't NACK
		  it immidiattly, it will read extra byte and then NACK.
 set fifo to read one byte, no last: 
 set fifo size: 
 configure TX FIFO 
 data to send is more then FIFO size. 
 Clear NEGACK, STASTR and BER bits 
 Only current master is allowed to issue a stop condition 
 select bank 0 for address 3 to 10 
 Set the enable bit 
	
	  Fill the FIFO, while the FIFO is not full and there are more bytes
	  to write
 1st byte is length in block protocol: 
 fill a cyclic buffer 
	
	  once we send bytes up, need to reset the counter of the wr buf
	  got data from master (new offset in device), ignore wr fifo:
 get the next buffer 
  npcm_i2c_slave_wr_buf_sync:
  currently slave IF only supports single byte operations.
  in order to utilyze the npcm HW FIFO, the driver will ask for 16 bytes
  at a time, pack them in buffer, and then transmit them all together
  to the FIFO and onward to the bus.
  NACK on read will be once reached to bus->adap->quirks->max_read_len.
  sending a NACK wherever the backend requests for it is not supported.
  the next two functions allow reading to local buffer before writing it all
  to the HW FIFO.
 fifo already full: 
 update the wr fifo index back to the untransmitted bytes: 
		
		  Slave got an address match with direction bit 1 so it should
		  transmit data. Write till the master will NACK
		
		  Slave got an address match with direction bit 0 so it should
		  receive data.
		  this module does not support saying no to bytes.
		  it will always ACK.
 Slave: A NACK has occurred 
 clear the FIFO 
 In slave write, NACK is OK, otherwise it is a problem 
		
		  Slave has to wait for STOP to decide this is the end
		  of the transaction. tx is not yet considered as done
 Slave mode: a Bus Error (BER) has been identified 
		
		  Check whether bus arbitration or Start or Stop during data
		  xfer bus arbitration problem should not result in recovery
 wait for bus busy before clear fifo 
		
		  in BER case we might get 2 interrupts: one for slave one for
		  master ( for a channel which is master\slave switching)
 A Slave Stop Condition has been identified 
 if the buffer is empty nothing will be sent 
 Slave done transmitting or receiving 
		
		  Note, just because we got here, it doesn't mean we through
		  away the wr buffer.
		  we keep it until the next received offset.
 restart condition occurred and Rx-FIFO was not empty 
 A Slave Address Match has been identified 
 Address match automatically implies slave mode 
 Check which type of address match 
				
				  the i2c module can response to 10 own SA.
				  check which one was addressed by the master.
				  repond to the first one.
			
			   Slave match can happen in two options:
			   1. Start, SA, read (slave read without further ado)
			   2. Start, SA, read, data, restart, SA, read,  ...
			      (slave read in fragmented mode)
			   3. Start, SA, write, data, restart, SA, read, ..
			      (regular write-read mode)
 slave tx after slave rx wo STOP 
 Slave SDA status is set - tx or rx 
 SDAST 
 CONFIG_I2C_SLAVE 
	
	  In order not to change the RX_TRH during transaction (we found that
	  this might be problematic if it takes too much time to read the FIFO)
	  we read the data in the following way. If the number of bytes to
	  read == FIFO Size + C (where C < FIFO Size)then first read C bytes
	  and in the next int we read rest of the data.
 last bytes are about to be read - end of tx 
 Stop should be set before reading last byte. 
 clear the TX fifo status bit 
 Master write operation - last byte handling 
			
			  No more bytes to send (to add to the FIFO),
			  however the FIFO is not empty yet. It is
			  still in the middle of tx. Currently there's nothing
			  to do except for waiting to the end of the tx
			  We will get an int when the FIFO will get empty.
 all bytes have been written, in wr only operation 
 Clear SDA Status bit (by writing dummy byte) 
 last write-byte written on previous int - restart 
 Generate repeated start upon next write to SDA 
			
			  Receiving one byte only - stall after successful
			  completion of send address byte. If we NACK here, and
			  slave doesn't ACK the address, we might
			  unintentionally NACK the next multi-byte read.
 Next int will occur on read 
 send the slave address in read direction 
 write next byte not last byte and not slave address 
 added bytes to the packet: 
	
	  Perform master read, distinguishing between last byte and the rest of
	  the bytes. The last byte should be read when the clock is stopped
 first byte handling: 
 first byte in block protocol is the size: 
 clear RX FIFO interrupt status: 
 A NACK has occurred 
		
		  if there are still untransmitted bytes in TX FIFO
		  reduce them from wr_ind
 clear the FIFO 
 In master write operation, got unexpected NACK 
 Only current master is allowed to issue Stop Condition 
 stopping in the middle 
		
		  The bus is released from stall only after the SW clears
		  NEGACK bit. Then a Stop condition is sent.
	
	  In Master mode, NACK should be cleared only after STOP.
	  In such case, the bus is released from stall only after the
	  software clears NACK bit. Then a Stop condition is sent.
 Master mode: a Bus Error has been identified 
 Clear BB (BUS BUSY) bit 
 EOB: a master End Of Busy (meaning STOP completed) 
 Address sent and requested stall occurred (Master mode) 
		
		  Receiving one byte only - set NACK after ensuring
		  slave ACKed the address byte.
 Reset stall-after-address-byte 
 Clear stall only after setting STOP 
 SDA status is set - TX or RX, master 
			
			  Need to stall after successful
			  completion of sending address byte
		
		  Receiving one byte only - stall after successful completion
		  of sending address byte If we NACK here, and slave doesn't
		  ACK the address, we might unintentionally NACK the next
		  multi-byte read
 Initiate I2C master tx 
 select bank 1 for FIFO regs 
 clear FIFO and relevant status bits. 
 re-enable 
		
		  Configure the FIFO threshold:
		  according to the needed # of bytes to read.
		  Note: due to HW limitation can't config the rx fifo before it
		  got and ACK on the restart. LAST bit will not be reset unless
		  RX completed. It will stay set on the next tx.
 SDA interrupt, after start\restart 
 A NACK has occurred 
 Master mode: a Bus Error has been identified 
 EOB: a master End Of Busy (meaning STOP completed) 
 Address sent and requested stall occurred (Master mode) 
 SDA status is set - TX or RX, master 
 recovery using TGCLK functionality of the module 
 Allow 3 bytes (27 toggles) to be read from the slave: 
 select bank 1 for FIFO regs 
 clear FIFO and relevant status bits. 
 Repeat the following sequence until SDA is released 
 Issue a single SCL toggle 
 If SDA line is inactive (high), stop 
 If SDA line is released: send start-addr-stop, to re-sync. 
 Send an address byte in write direction: 
 Wait until START condition is sent 
 If START condition was sent 
 recovery using bit banging functionality of the module 
	
	  npcm i2c HW allows direct reading of SCL and SDA.
	  However, it does not support setting SCL and SDA directly.
	  The recovery function can togle SCL when SDA is low (but not set)
	  Getter functions used internally, and can be used externaly.
 SCLFRQ minmax field values 
  npcm_i2c_init_clk: init HW timing parameters.
  NPCM7XX i2c module timing parameters are depenent on module core clk (APB)
  and bus frequency.
  100kHz bus requires tSCL = 4  SCLFRQ  tCLK. LT and HT are simetric.
  400kHz bus requires assymetric HT and LT. A different equation is recomended
  by the HW designer, given core clock range (equations in comments below).
 100KHz and below: 
 400KHz: 
 400KHZ cannot be supported for core clock < 7.5MHz 
 Master or Slave with frequency > 25MHz 
 1MHz: 
 1MHZ cannot be supported for core clock < 24 MHz 
 Core clk > 40 MHz 
			
			  Set HLDT:
			  SDA hold time:  (HLDT-7)  T(CLK) >= 120
			  HLDT = 120T(CLK) + 7 = 120  FREQ(CLK) + 7
 Frequency larger than 1 MHz is not supported 
 write sclfrq value. bits [6:0] are in I2CCTL2 reg 
 bits [8:7] are in I2CCTL3 reg 
 Select Bank 0 to access NPCM_I2CCTL4NPCM_I2CCTL5 
		
		  Set SCL LowHigh Time:
		  k1 = 2  SCLLT7-0 -> Low Time  = k1  2
		  k2 = 2  SCLLT7-0 -> High Time = k2  2
 Return to Bank 1, and stay there by default: 
 Check whether module already enabled or frequency is out of bounds 
 Configure FIFO mode : 
 Configure I2C module clock frequency 
 Enable module (before configuring CTL1) 
 Initialize the internal data structures 
 for tx PEC is appended to buffer from i2c IF. PEC flag is ignored 
 clear FIFO and relevant status bits. 
 read 
 write 
	
	  Adaptive TimeOut: estimated time in usec + 100% margin:
	  2: double the timeout for clock stretching case
	  9: bits per transaction (including the acknack)
		
		  we must clear slave address immediately when the bus is not
		  busy, so we spinlock it, but we don't keep the lock for the
		  entire while since it is too long.
 if there was BER, check if need to recover the bus: 
	
	  After any type of error, check if LAST bit is still set,
	  due to a HW issue.
	  It cannot be cleared without resetting the module.
 reenable slave if it was enabled 
 i2c debugfs directory: used to keep health monitor of i2c devices 
 core clk must be acquired to calculate module timing settings 
 SPDX-License-Identifier: GPL-2.0+
  Freescale MXS I2C bus driver
  Copyright (C) 2012-2013 Marek Vasut <marex@denx.de>
  Copyright (C) 2011-2012 Wolfram Sang, Pengutronix e.K.
  based on a (non-working) driver which was:
  Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  struct mxs_i2c_dev - per device, private MXS-I2C data
  @dev: driver model device node
  @dev_type: distinguish i.MX23i.MX28 features
  @regs: IO registers pointer
  @cmd_complete: completion object for transaction wait
  @cmd_err: error code for last transaction
  @adapter: i2c subsystem adapter node
 DMA support components 
	
	  Configure timing for the I2C block. The I2C TIMING2 register has to
	  be programmed with this particular magic number. The rest is derived
	  from the XTAL speed and requested I2C speed.
	 
	  For details, see i.MX233 [25.4.2 - 25.4.4] and i.MX28 [27.5.2 - 27.5.4].
		
		  SELECT command.
 Queue the PIO register write transfer. 
 Queue the DMA data transfer. 
		
		  READ command.
 Queue the PIO register write transfer. 
 Queue the DMA data transfer. 
		
		  WRITE command.
 Queue the PIO register write transfer. 
 Queue the DMA data transfer. 
	
	  The last descriptor must have this callback,
	  to finish the DMA transaction.
 Start the transfer. 
 Read failpath. 
 Write failpath. 
 readback makes sure the write is latched into hardware 
  Start WRITE transaction on the I2C bus. By studying i.MX23 datasheet,
  CTRL0::PIO_MODE bit description clarifies the order in which the registers
  must be written during PIO mode operation. First, the CTRL0 register has
  to be programmed with all the necessary bits but the RUN bit. Then the
  payload has to be written into the DATA register. Finally, the transmission
  is executed by setting the RUN bit in CTRL0.
 Mute IRQs coming from this block. 
	
	  MX23 idea:
	  - Enable CTRL0::PIO_MODE (1 << 24)
	  - Enable CTRL1::ACK_MODE (1 << 27)
	 
	  WARNING! The MX23 is broken in some way, even if it claims
	  to support PIO, when we try to transfer any amount of data
	  that is not aligned to 4 bytes, the DMA engine will have
	  bits in DEBUG1::DMA_BYTES_ENABLES still set even after the
	  transfer. This in turn will mess up the next transfer as
	  the block it emit one byte write onto the bus terminated
	  with a NAK+STOP. A possible workaround is to reset the IP
	  block after every PIO transmission, which might just work.
	 
	  NOTE: The CTRL0::PIO_MODE description is important, since
	  it outlines how the PIO mode is really supposed to work.
		
		  PIO READ transfer:
		 
		  This transfer MUST be limited to 4 bytes maximum. It is not
		  possible to transfer more than four bytes via PIO, since we
		  can not in any way make sure we can read the data from the
		  DATA register fast enough. Besides, the RX FIFO is only four
		  bytes deep, thus we can only really read up to four bytes at
		  time. Finally, there is no bit indicating us that new data
		  arrived at the FIFO and can thus be fetched from the DATA
		  register.
 SELECT command. 
 READ command. 
		
		  PIO WRITE transfer:
		 
		  The code below implements clock stretching to circumvent
		  the possibility of kernel not being able to supply data
		  fast enough. It is possible to transfer arbitrary amount
		  of data using PIO write.
		
		  The LSB of data buffer is the first byte blasted across
		  the bus. Higher order bytes follow. Thus the following
		  filling schematic.
 Start the transfer with START condition. 
 If the transfer is long, use clock stretching. 
 This is the last transfer of the message. 
 Add optional STOP flag. 
 Remove RETAIN_CLOCK bit. 
 Four bytes are ready in the "data" variable. 
 Nothing interesting happened, continue stuffing. 
			
			  Compute the size of the transfer and shift the
			  data accordingly.
			 
			  i = (4k + 0) .... xlen = 2
			  i = (4k + 1) .... xlen = 3
			  i = (4k + 2) .... xlen = 4
			  i = (4k + 3) .... xlen = 1
 The START condition is sent only once. 
 Wait for the end of the transfer. 
 Check NAK here. 
 make sure we capture any occurred error into cmd_err 
 Clear any dangling IRQs and re-enable interrupts. 
 Clear the PIO_MODE on i.MX23 
  Low level master readwrite transaction.
	
	  The MX28 I2C IP block can only do PIO READ for transfer of to up
	  4 bytes of length. The write transfer is not limited as it can use
	  clock stretching to avoid FIFO underruns.
 No need to reset the block if NAK was received. 
		
		  If the transfer fails with a NAK from the slave the
		  controller halts until it gets told to return to idle state.
	
	  WARNING!
	  The i.MX23 is strange. After each and every operation, it's I2C IP
	  block must be reset, otherwise the IP block will misbehave. This can
	  be observed on the bus by the block sending out one single byte onto
	  the bus. In case such an error happens, bit 27 will be set in the
	  DEBUG0 register. This bit is not documented in the i.MX23 datasheet
	  and is marked as "TBD" instead. To reset this bit to a correct state,
	  reset the whole block. Since the block reset does not take long, do
	  reset the block after every transfer to play safe.
 MXS_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ is only for slaves 
 The I2C block clock runs at 24MHz 
		
		  limit the divider, so that min(low_count, high_count)
		  is >= 1
		
		  limit the divider, so that max(low_count, high_count)
		  cannot exceed 1023
	
	  The I2C spec specifies the following timing data:
	                           standard mode  fast mode Bitfield name
	  tLOW (SCL LOW period)     4700 ns        1300 ns
	  tHIGH (SCL HIGH period)   4000 ns         600 ns
	  tSU;DAT (data setup time)  250 ns         100 ns
	  tHD;STA (START hold time) 4000 ns         600 ns
	  tBUF (bus free time)      4700 ns        1300 ns
	 
	  The hardware (of the i.MX28 at least) seems to add 2 additional
	  clock cycles to the low_count and 7 cycles to the high_count.
	  This is compensated for by subtracting the respective constants
	  from the values written to the timing registers.
 fast mode 
 normal mode 
 sentinel  }
 Setup the DMA 
 Do reset to enforce correct startup after pinmuxing 
 SPDX-License-Identifier: GPL-2.0-only
  I2C adapter for the IMG Serial Control Bus (SCB) IP block.
  Copyright (C) 2009, 2010, 2012, 2014 Imagination Technologies Ltd.
  There are three ways that this I2C controller can be driven:
  - Raw control of the SDA and SCK signals.
    This corresponds to MODE_RAW, which takes control of the signals
    directly for a certain number of clock cycles (the INT_TIMING
    interrupt can be used for timing).
  - Atomic commands. A low level I2C symbol (such as generate
    startstopacknack bit, generate byte, receive byte, and receive
    ACK) is given to the hardware, with detection of completion by bits
    in the LINESTAT register.
    This mode of operation is used by MODE_ATOMIC, which uses an I2C
    state machine in the interrupt handler to composereact to I2C
    transactions using atomic mode commands, and also by MODE_SEQUENCE,
    which emits a simple fixed sequence of atomic mode commands.
    Due to software control, the use of atomic commands usually results
    in suboptimal use of the bus, with gaps between the I2C symbols while
    the driver decides what to do next.
  - Automatic mode. A bus address, and whether to readwrite is
    specified, and the hardware takes care of the I2C state machine,
    using a FIFO to sendreceive bytes of data to an I2C slave. The
    driver just has to keep the FIFO drained or filled in response to the
    appropriate FIFO interrupts.
    This corresponds to MODE_AUTOMATIC, which manages the FIFOs and deals
    with control of repeated start bits between I2C messages.
    Use of automatic mode and the FIFO can make much more efficient use
    of the bus compared to individual atomic commands, with potentially
    no wasted time between I2C symbols or I2C messages.
  In most cases MODE_AUTOMATIC is used, however if any of the messages in
  a transaction are zero byte writes (e.g. used by i2cdetect for probing
  the bus), MODE_ATOMIC must be used since automatic mode is normally
  started by the writing of data into the FIFO.
  The other modes are used in specific circumstances where MODE_ATOMIC and
  MODE_AUTOMATIC aren't appropriate. MODE_RAW is used to implement a bus
  recovery routine. MODE_SEQUENCE is used to reset the bus and make sure
  it is in a sane state.
  Notice that the driver implements a timer-based timeout mechanism.
  The reason for this mechanism is to reduce the number of interrupts
  received in automatic mode.
  The driver would get a slave event and transaction done interrupts for
  each atomic mode command that gets completed. However, these events are
  not needed in automatic mode, becase those atomic mode commands are
  managed automatically by the hardware.
  In practice, normal I2C transactions will be complete well before you
  get the timer interrupt, as the timer is re-scheduled during FIFO
  maintenance and disabled after the transaction is complete.
  In this way normal automatic mode operation isn't impacted by
  unnecessary interrupts, but the exceptional abort condition can still be
  detected (with a slight delay).
 Register offsets 
 SCB_CONTROL_REG bits 
 SCB_CLK_SET_REG bits 
 SCB_INT__REG bits 
 Level interrupts need clearing after handling instead of before 
 Don't allow any interrupts while the clock may be off 
 Interrupt masks for the different driver modes 
 SCB_STATUS_REG fields 
 SCB_OVERRIDE_REG fields 
 OVERRIDE_CMD values 
 Fixed timing values 
 Transaction timeout 
  Worst incs are 1 (innacurate) and 16256 (irregular).
  So a sensible inc is the logarithmic mean: 64 (2^6), which is
  in the middle of the valid range (0-127).
 Setup the clock enable filtering for 25 ns 
  Bits to return from interrupt handler functions for different modes.
  This delays completion until we've finished with the registers, so that the
  function waiting for completion can safely disable the clock to save power.
 contains +ve errno 
 ms 
 Timing parameters for i2c modes (in ns) 
 The timings array must be ordered from slower to faster 
 Standard mode 
 Fast mode 
 Reset dance 
 Just issue a stop (after an abort condition) 
 We're interested in different interrupts depending on the mode 
 Atomic command names 
	
	  The scb core clock is used to get the input frequency, and to disable
	  it after every set of transactions to save some power.
 state 
 lock before doing anything with the state 
 After the last transaction, wait for a stop bit 
 depends on mode 
 line status over command 
	
	  To avoid slave event interrupts in automatic mode, use a timer to
	  poll the abort condition if we don't get an interrupt for too long.
 atomic mode state 
 Sequence: either reset or stop. See img_i2c_sequence. 
 raw mode 
  The code to read from the master read fifo, and write to the master
  write fifo, checks a bit in an SCB register before every byte to
  ensure that the fifo is not full (write fifo) or empty (read fifo).
  Due to clock domain crossing inside the SCB block the updated value
  of this bit is only visible after 2 cycles.
  The scb_wr_rd_fence() function does 2 dummy writes (to the read-only
  revision register), and it's called after reading from or writing to the
  fifos to ensure that subsequent reads of the fifo status bits do not read
  stale values.
 Send a single atomic mode command to the hardware 
 work around lack of data setup time when generating data 
 hold the data line down for a moment 
 Start a transaction in atomic mode 
  Enable or release transaction halt for control of repeated starts.
  In version 3.3 of the IP when transaction halt is set, an interrupt
  will be generated after each byte of a transfer instead of after
  every transfer but before the stop bit.
  Due to this behaviour we have to be careful that every time we
  release the transaction halt we have to re-enable it straight away
  so that we only process a single byte, not doing so will result in
  all remaining bytes been processed and a stop bit being issued,
  which will prevent us having a repeated start.
 Drain data from the FIFO into the buffer (automatic mode) 
 Fill the FIFO with data from the buffer (automatic mode) 
 Disable fifo emptying interrupt if nothing more to write 
 Start a read transaction in automatic mode 
 Start a write transaction in automatic mode 
 img_i2c_write_fifo() may modify int_enable 
  Indicate that the transaction is complete. This is called from the
  ISR to wake up the waiting thread, after which the ISR must not
  access any more SCB registers.
 Stay in raw mode for this, so we don't just loop infinitely 
 wait if no continue bits are set 
 follow the sequence of commands in i2c->seq 
 stop on a nil 
 when generating data, the next byte is the data 
 Initiate the magic dance 
 img_i2c_reset_seq isn't empty so the following won't fail 
 Initiate a stop bit sequence 
 img_i2c_stop_seq isn't empty so the following won't fail 
 i2c->at_cur_cmd may have completed 
 don't actually stop unless we're the last transaction 
  Timer function to check if something has gone wrong in automatic mode (so we
  don't have to handle so many interrupts just to catch an exception).
 check for an abort condition 
 enable slave event interrupt mask to trigger irq 
 empty the read fifo 
 use atomic mode and try to force a stop bit 
 Enable transaction halt on start bit 
 we're no longer interested in the slave event 
 Drain remaining data in FIFO and complete transaction 
		
		  Release and then enable transaction halt, to
		  allow only a single byte to proceed.
 We handle transaction completion AFTER accessing registers 
 Read interrupt status register. 
 Clear detected interrupts. 
	
	  Read line status and clear it until it actually is clear.  We have
	  to be careful not to lose any line status bits that get latched.
 Keep track of line status bits received 
	
	  Certain interrupts indicate that sclk low timeout is not
	  a problem. If any of these are set, just continue.
 Clear detected level interrupts. 
		
		  Only wait for stop on last message.
		  Also we may already have detected the stop bit.
 now we've finished using regs, handle transaction completion 
 Enable interrupts (int_enable may be altered by changing mode) 
 Force a bus reset sequence and wait for it to complete 
		
		  0 byte reads are not possible because the slave could try
		  and pull the data line low, preventing a stop bit.
		
		  0 byte writes are possible and used for probing, but we
		  cannot do them in automatic mode, so use atomic mode
		  instead.
		 
		  Also, the I2C_M_IGNORE_NAK mode can only be implemented
		  in atomic mode.
		
		  Make a copy of the message struct. We mustn't modify the
		  original or we'll confuse drivers and i2c-dev.
		
		  After the last message we must have waited for a stop bit.
		  Not waiting can cause problems when the clock is disabled
		  before the stop bit is sent, and the linux I2C interface
		  requires separate transfers not to joined with repeated
		  start.
		
		  Clear line status and all interrupts before starting a
		  transfer, as we may have unserviced interrupts from
		  previous transfers that might be handled in the context
		  of the new transfer.
			
			  Enable transaction halt if not the last message in
			  the queue so that we can control repeated starts.
			
			  Release and then enable transaction halt, to
			  allow only a single byte to proceed.
			  This doesn't have an effect on the initial transfer
			  but will allow the following transfers to start
			  processing if the previous transfer was marked as
			  complete while the i2c block was halted.
 Fencing enabled by default. 
 Determine what mode we're in from the bitrate 
 Find the prescale that would give us that inc (approx delay = 0) 
 Setup the clock increment value 
	
	  The clock generation logic allows to filter glitches on the bus.
	  This filter is able to remove bus glitches shorter than 50ns.
	  If the clock enable rate is greater than 20 MHz, no filtering
	  is required, so we need to disable it.
	  If it's between the 20-40 MHz range, there's no need to divide
	  the clock to get a filter.
 Calculate filter clock 
 Scale up if needed 
 Obtain the clock period of the fx16 clock in ns 
 Calculate the bitrate in terms of internal clock pulses 
	
	  Setup clock duty cycle, start with 50% and adjust TCKH and TCKL
	  values from there if they don't meet minimum timing requirements
 Adjust TCKH and TCKL values 
 Setup TSDH value 
 This value is used later 
 Setup TPL value 
 Setup TPH value 
 Setup TSDL value to TPL + TSDH + 2 
 Setup TP2S value 
 Take module out of soft reset and enable clocks 
 Disable all interrupts 
 Clear all interrupts 
 Clear the scb_line_status events 
 Enable interrupts 
 Perform a synchronous sequence to reset the bus 
 Set up the exception check timer 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-or-later
  i2c support for Silicon Labs' CP2615 Digital Audio Bridge
  (c) 2021, Bence Csókás <bence98@sch.bme.hu>
 CP2615 IO Protocol implementation 
 Possible values for struct cp2615_i2c_transfer_result.status 
 Writing to the internal EEPROM failed, because it is locked 
 read_len or write_len out of range 
 I2C slave did not ACK in time 
 I2C bus busy 
 I2C bus error (ie. device NAK'd the request) 
 Translates status codes to Linux errno's 
 Unknown error code 
 Driver code 
 Checks if the IOP is functional by querying the part's ID 
  This chip has some limitations: one is that the USB endpoint
  can only receive 64 bytestransfer, that leaves 54 bytes for
  the I2C transfer. On top of that, EITHER read_len OR write_len
  may be zero, but not both. If both are non-zero, the adapter
  issues a write followed by a read. And the chip does not
  support repeated START between the write and read phases.
  Copyright (C) 2014 Broadcom Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  It takes ~18us to reading 10bytes of data, hence to keep tasklet
  running for less time, max slave read per tasklet is set to 10 bytes.
 lock for indirect access through IDM 
 bytes that have been transferred 
 bytes that have been read 
 tasklet to process slave rx data 
  Can be expanded in the future if more interrupt status bits are utilized
 put controller in reset 
 wait 100 usec per spec 
 bring controller out of reset 
 flush TXRX FIFOs 
 Maximum slave stretch time 
 Configure the slave address 
 clear all pending slave interrupts 
 Enable interrupt register to indicate a valid byte in receive fifo 
 Enable interrupt register to indicate Slave Rx FIFO Full 
 Enable interrupt register to indicate a Master read transaction 
 Enable interrupt register for the Slave BUSY command 
 status is valid only when START_BUSY is cleared after it was set 
 re-initialize i2c for recovery 
 Start of SMBUS Master write 
 Middle of SMBUS Master write 
 End of SMBUS Master write 
 clear pending IS_S_RX_EVENT_SHIFT interrupt 
		
		  In case of single byte master-read request,
		  IS_S_TX_UNDERRUN_SHIFT event is generated before
		  IS_S_START_BUSY_SHIFT event. Hence start slave data send
		  from first IS_S_TX_UNDERRUN_SHIFT event.
		 
		  This means don't send any data from slave when
		  IS_S_RD_EVENT_SHIFT event is generated else it will increment
		  eeprom or other backend slave driver read pointer twice.
 clear IS_S_RD_EVENT_SHIFT interrupt 
 clear slave interrupt 
 enable slave interrupts 
	
	  Slave events in case of master-write, master-write-read and,
	  master-read
	 
	  Master-write     : only IS_S_RX_EVENT_SHIFT event
	  Master-write-read: both IS_S_RX_EVENT_SHIFT and IS_S_RD_EVENT_SHIFT
	                     events
	  Master-read      : both IS_S_RX_EVENT_SHIFT and IS_S_RD_EVENT_SHIFT
	                     events or only IS_S_RD_EVENT_SHIFT
	 
	  iproc has a slave rx fifo size of 64 bytes. Rx fifo full interrupt
	  (IS_S_RX_FIFO_FULL_SHIFT) will be generated when RX fifo becomes
	  full. This can happen if Master issues write requests of more than
	  64 bytes.
 disable slave interrupts 
 Master-write-read request 
 Master-write request only 
 schedule tasklet to read data later 
		
		  clear only IS_S_RX_EVENT_SHIFT and
		  IS_S_RX_FIFO_FULL_SHIFT interrupt.
 Start of SMBUS for Master Read 
 Master read other than start 
 start transfer 
 clear interrupt 
 Stop received from master in case of master read transaction 
		
		  Disable interrupt for TX FIFO becomes empty and
		  less than PKT_LENGTH bytes were output on the SMBUS
 End of SMBUS for Master Read 
 flush TX FIFOs 
 clear interrupt 
 check slave transmit status only if slave is transmitting 
 Read valid data from RX FIFO 
 rx fifo empty 
 can only fill up to the FIFO size 
 start from where we left over 
 mark the last byte 
				
				  Since this is the last byte, we should now
				  disable TX FIFO underrun interrupt
 load data into TX FIFO 
 update number of transferred bytes 
 finished reading all data, disable rx thld event 
 set bytes left as threshold 
	
	  bytes_left >= iproc_i2c->thld_bytes,
	  hence no need to change the THRESHOLD SET.
	  It will remain as iproc_i2c->thld_bytes itself
 TX FIFO is empty and we have more data to send 
 RX FIFO threshold is reached and data needs to be read out 
 transfer is done 
 process only slave interrupt which are enabled 
 process all master based events 
 put controller in reset 
 wait 100 usec per spec 
 bring controller out of reset 
 flush TXRX FIFOs and set RX FIFO threshold to zero 
 disable all interrupts 
 clear all pending interrupts 
 re-initialize i2c for recovery 
 disable all interrupts 
 read it back to flush the write 
 make sure the interrupt handler isn't running 
 polling mode 
 flush both TXRX FIFOs 
 flush both TXRX FIFOs 
  If 'process_call' is true, then this is a multi-msg transfer that requires
  a repeated start between the messages.
  More specifically, it must be a write (reg) followed by a read (data).
  The i2c quirks are set to enforce this rule.
 check if bus is busy 
 format and load slave address into the TX FIFO 
	
	  For a write transaction, load data into the TX FIFO. Only allow
	  loading up to TX FIFO size - 1 bytes of data since the first byte
	  has been used up by the slave address
 mark the last byte 
 Process the read message if this is process call 
 point to second msg 
		
		  The last byte to be sent out should be a slave
		  address with read operation
 mark it the last byte out 
 mark as incomplete before starting the transaction 
	
	  Enable the "start busy" interrupt, which will be triggered after the
	  transaction is done, i.e., the internal start_busy bit, transitions
	  from 1 to 0.
	
	  If TX data size is larger than the TX FIFO, need to enable TX
	  underrun interrupt, which will be triggerred when the TX FIFO is
	  empty. When that happens we can then pump more data into the FIFO
	
	  Now we can activate the transfer. For a read operation, specify the
	  number of bytes to read
 SMBUS QUICK Command (ReadWrite) 
 set threshold value 
 enable the RX threshold interrupt 
 Repeated start, use process call 
 no slave support 
		
		  Make sure there's no pending interrupt when we remove the
		  adapter
		
		  Make sure there's no pending interrupt when we go into
		  suspend
 now disable the controller 
	
	  Power domain could have been shut off completely in system deep
	  sleep, so re-initialize the block here
 configure to the desired bus speed 
 CONFIG_PM_SLEEP 
 disable all slave interrupts 
 Erase the slave address programmed 
 flush TXRX FIFOs 
 clear all pending slave interrupts 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
  Intel CHT Whiskey Cove PMIC I2C Master driver
  Copyright (C) 2017 Hans de Goede <hdegoede@redhat.com>
  Based on various non upstream patches to support the CHT Whiskey Cove PMIC:
  Copyright (C) 2011 - 2014 Intel Corporation. All rights reserved.
 Read IRQs 
 Reads must be acked after reading the received data. 
	
	  Immediately ack IRQs, so that if new IRQs arrives while we're
	  handling the previous ones our irq will re-trigger when we're done.
	
	  Do NOT use handle_nested_irq here, the client irq handler will
	  likely want to do i2c transfers and the i2c controller uses this
	  interrupt handler as well, so running the client irq handler from
	  this thread will cause things to lock up.
		
		  generic_handle_irq expects local IRQs to be disabled
		  as normally it is called from interrupt context.
 This i2c adapter only supports SMBUS byte transfers 
		
		  The CHT GPIO controller serializes all IRQs, sometimes
		  causing significant delays, check status manually.
  We are an i2c-adapter which itself is part of an i2c-client. This means that
  transfers done through us take adapter->bus_lock twice, once for our parent
  i2c-adapter and once to take our own bus_lock. Lockdep does not like this
  nested locking, to make lockdep happy in the case of busses with muxes, the
  i2c-core's i2c_adapter_lock_bus function calls:
  rt_mutex_lock_nested(&adapter->bus_lock, i2c_adapter_depth(adapter));
  But i2c_adapter_depth only works when the direct parent of the adapter is
  another adapter, as it is only meant for muxes. In our case there is an
  i2c-client and MFD instantiated platform_device in the parent->child chain
  between the 2 devices.
  So we override the default i2c_lock_operations and pass a hardcoded
  depth of 1 to rt_mutex_lock_nested, to make lockdep happy.
  Note that if there were to be a mux attached to our adapter, this would
  break things again since the i2c-mux code expects the root-adapter to have
  a locking depth of 0. But we always have only 1 client directly attached
  in the form of the Charger IC paired with the CHT Whiskey Cove PMIC.
 irqchip for the client connected to the extchgr i2c adapter 
 Must match fusb302 dev_name in intel_cht_int33fe.c 
 The name is used in intel_cht_int33fe.c do not change. 
 Clear and activate i2c-adapter interrupts, disable client IRQ 
 Alloc and register client IRQ 
	
	  Normally the Whiskey Cove PMIC is paired with a TI bq24292i charger,
	  connected to this i2c bus, and a max17047 fuel-gauge and a fusb302
	  USB Type-C controller connected to another i2c bus. In this setup
	  the max17047 and fusb302 devices are enumerated through an INT33FE
	  ACPI device. If this device is present register an i2c-client for
	  the TI bq24292i charger.
 SPDX-License-Identifier: GPL-2.0
  I2C driver for stand-alone PCF8584 style adapters on Zorro cards
  Original ICY documentation can be found on Aminet:
  https:aminet.netpackagedocshardicy
  There has been a modern community re-print of this design in 2019:
  https:www.a1k.orgforumindex.php?threads70106
  The card is basically a Philips PCF8584 connected straight to the
  beginning of the AutoConfig'd address space (register S1 on base+2),
  with INT on INT2 on the Zorro bus.
  Copyright (c) 2019 Max Staudt <max@enpas.org>
  This started as a fork of i2c-elektor.c and has evolved since.
  Thanks go to its authors for providing a base to grow on.
  IRQ support is currently not implemented.
  As it turns out, i2c-algo-pcf is really written with i2c-elektor's
  edge-triggered ISA interrupts in mind, while the Amiga's Zorro bus has
  level-triggered interrupts. This means that once an interrupt occurs, we
  have to tell the PCF8584 to shut up immediately, or it will keep the
  interrupt line busy and cause an IRQ storm.
  However, because of the PCF8584's host-side protocol, there is no good
  way to just quieten it without side effects. Rather, we have to perform
  the next readwrite operation straight away, which will reset the INT
  pin. This entails re-designing the core of i2c-algo-pcf in the future.
  For now, we never request an IRQ from the PCF8584, and poll it instead.
  Functions called by i2c-algo-pcf
  Main i2c-icy part
  Additional sensors exposed once this property is applied:
  in1 will be the voltage of the 5V rail, divided by 2.
  in2 will be the voltage of the 12V rail, divided by 4.
  temp3 will be measured using a PCB loop next the chip.
 i2c->adapter.algo assigned by i2c_pcf_add_bus() 
 Driver private data 
	
	  The 2019 a1k.org PCBs have an LTC2990 at 0x4c, so start
	  it automatically once ltc2990 is modprobed.
	 
	  in0 is the voltage of the internal 5V power supply.
	  temp1 is the temperature inside the chip.
	 
	  See property_entry above for in1, in2, temp3.
 SPDX-License-Identifier: GPL-2.0-or-later
  i2c-au1550.c: SMBus (i2c) adapter for Alchemy PSC interface
  Copyright (C) 2004 Embedded Edge, LLC <dan@embeddededge.com>
  2.6 port by Matt Porter <mporter@kernel.crashing.org>
  The documentation describes this as an SMBus controller, but it doesn't
  understand any of the SMBus protocol in hardware.  It's really an I2C
  controller that could emulate most of the SMBus in software.
  This is just a skeleton adapter to use with the Au1550 PSC
  algorithm.  It was developed for the Pb1550, but will work with
  any Au1550 board that has a similar PSC configuration.
 Wait for Tx Buffer Empty 
 Wait for Master Done. 
 Reset the FIFOs, clear events. 
 Write out the i2c chip address and specify operation 
 zero-byte xfers stop immediately 
 Put byte into fifo, start up master. 
	 A read is performed by stuffing the transmit fifo with
	  zero bytes for timing, waiting for bytes to appear in the
	  receive fifo, then reading the bytes.
 The last byte has to indicate transfer done. 
 The last byte has to indicate transfer done. 
	 Return the number of messages processed, or the error code.
	 Divide by 8 to get a 6.25 MHz clock.  The later protocol
	  timings are based on this clock.
	 Set the protocol timer values.  See Table 71 in the
	  Au1550 Data Book for standard timing values.
  registering functions to load algorithms at runtime
  Prior to calling us, the 50MHz clock frequency and routing
  must have been set up for the PSC indicated by the adapter.
 Now, set up the PSC for SMBus PIO mode. 
 SPDX-License-Identifier: GPL-2.0-or-later
 linuxdriversi2cbussesi2c-s3c2410.c
  Copyright (C) 2004,2005,2009 Simtec Electronics
 	Ben Dooks <ben@simtec.co.uk>
  S3C2410 I2C Controller
 see s3c2410x user guide, v1.1, section 9 (p447) for more info 
 Treat S3C2410 as baseline hardware, anything else is supported via quirks 
 Max time to wait for bus to become idle after a xfer (in us) 
 Exynos5 Sysreg offset 
 i2c controller state 
  Get controller type either from device tree or platform device variant.
  Complete the message and wake up the caller, using the given return code,
  or zero to mean ok.
 irq enabledisable functions 
  put the start of a message onto the bus
 todo - check for whether ack wanted or not 
	
	  delay here to ensure the data byte has gotten onto the bus
	  before the transaction is started
	
	  The datasheet says that the STOP sequence should be:
	   1) I2CSTAT.5 = 0	- Clear BUSY (or 'generate STOP')
	   2) I2CCON.4 = 0	- Clear IRQPEND
	   3) Wait until the stop condition takes effect.
	   4) I2CSTAT.4 = 0	- Clear TXRXEN
	 
	  Where, step "4" is only for buses with the "HDMIPHY" quirk.
	 
	  However, after much experimentation, it appears that:
	  a) normal buses automatically clear BUSY and transition from
	     Master->Slave when they complete generating a STOP condition.
	     Therefore, step (3) can be done in doxfer() by polling I2CCON.4
	     after starting the STOP generation here.
	  b) HDMIPHY bus does neither, so there is no way to do step 3.
	     There is no indication when this bus has finished generating
	     STOP.
	 
	  In fact, we have found that as soon as the IRQPEND bit is cleared in
	  step 2, the HDMIPHY bus generates the STOP condition, and then
	  immediately starts transferring another data byte, even though the
	  bus is supposedly stopped.  This is presumably because the bus is
	  still in "Master" mode, and its BUSY bit is still set.
	 
	  To avoid these extra post-STOP transactions on HDMI phy devices, we
	  just disable Serial Output on the bus (I2CSTAT.4 = 0) directly,
	  instead of first generating a proper STOP condition.  This should
	  float SDA & SCK terminating the transfer.  Subsequent transfers
	   start with a proper START condition, and proceed normally.
	 
	  The HDMIPHY bus is an internal bus that always has exactly two
	  devices, the host as Master and the HDMIPHY device as the slave.
	  Skipping the STOP condition has been tested on this bus and works.
 Stop driving the I2C pins 
 stop the transfer 
  helper functions to determine the current state in the set of
  messages we are sending
  returns TRUE if the current message is the last in the set
  returns TRUE if we this is the last byte in the current message
	
	  msg->len is always 1 for the first byte of smbus block read.
	  Actual length will be read from slave. More bytes will be
	  read according to the length then.
  returns TRUE if we reached the end of the current message
  process an interrupt and work out what to do
		
		  last thing we did was send a start condition on the
		  bus, or started a new i2c message
 ack was not received... 
		
		  Terminate the transfer if there is nothing to do
		  as this is used by the i2c probe to find devices.
		
		  fall through to the write state, as we will need to
		  send a byte as well
		
		  we are writing data to the device... check for the
		  end of the message, and if so, work out what to do
			
			  delay after writing the byte to allow the
			  data setup time on the bus, as writing the
			  data to the register causes the first bit
			  to appear on SDA, and SCL will change as
			  soon as the interrupt is acknowledged
 we need to go to the next i2c message 
 check to see if we need to do another message 
					
					  cannot do this, the controller
					  forces us to send a new START
					  when we change direction
 send the new start 
 send stop 
		
		  we have a byte of data in the data register, do
		  something with it, and then work out whether we are
		  going to do any more readwrite
 Add actual length to read for smbus block read 
 last byte of buffer 
			
			  ok, we've read the entire buffer, see if there
			  is anything else we need to do
 last message, send stop and complete 
 go to the next transfer 
 acknowlegde the IRQ and get back on with the work 
  top level IRQ servicing routine
 deal with arbitration loss 
	
	  pretty much this leaves us with the fact that we've
	  transmitted or received whatever byte we last sent
  Disable the bus so that we won't get any interrupts from now on, or try
  to drive any lines. This is the default state when we don't have
  anything to sendreceive.
  If there is an event on the bus, or we have a pre-existing event at
  kernel boot time, we may not notice the event and the I2C controller
  will lock the bus with the I2C clock line low indefinitely.
 Stop driving the I2C pins 
 We don't expect any interrupts now, and don't want send acks 
  get the i2c bus for a master transaction
  wait for the i2c bus to become idle.
 ensure the stop has been through the bus 
	
	  Most of the time, the bus is already idle within a few usec of the
	  end of a transaction.  However, really slow i2c devices can stretch
	  the clock, delaying STOP generation.
	 
	  On slower SoCs this typically happens within a very small number of
	  instructions so busy wait briefly to avoid scheduling overhead.
	
	  If we do get an appreciable delay as a compromise between idle
	  detection latency for the normal, fast case, and system load in the
	  slow device case, use an exponential back off in the polling loop,
	  up to 110th of the total timeout, then continue to poll at a
	  constant rate up to the timeout.
  this starts an i2c transfer
	
	  Having these next two as dev_err() makes life very
	  noisy when doing an i2cdetect
 For QUIRK_HDMIPHY, bus is already disabled 
  first port of call from the i2c bus code when an message needs
  transferring across the i2c bus.
 declare our i2c functionality 
 i2c bus registration info 
  return the divisor settings for a given frequency
  work out a divisor for the user requested frequency setting,
  either by the requested frequency, or scanning the acceptable
  range of frequencies until something is found
 clkin now in KHz 
 Target frequency now in KHz 
	 if we're post-change and the input clock has slowed down
	  or at pre-change and the clock is about to speed up, then
	  adjust our clock rate. <0 is slow, >0 speedup.
  initialise the controller, set the IO lines and frequency
 get the plafrom data 
 write slave address 
 we need to work out the divisors for the clock... 
 todo - check that the i2c lines aren't being dragged anywhere 
  Parse the device tree node and retreive the platform data.
 i2c bus number is dynamically assigned 
	
	  Exynos5's legacy i2c controller and new high speed i2c
	  controller have muxed interrupt sources. By default the
	  interrupts for 4-channel HS-I2C controller are enabled.
	  If nodes for first four channels of legacy i2c controller
	  are available then re-configure the interrupts via the
	  system register.
 find the clock and enable it 
 map the registers 
 setup info block for the i2c core 
 inititalise the i2c gpio lines 
 initialise the i2c controller 
	
	  find the IRQ for this unit (note, this relies on the init call to
	  ensure no current IRQs pending
	
	  Note, previous versions of the driver used i2c_add_adapter()
	  to add the bus at any number. We now pass the bus number via
	  the platform data, so if unset it will now default to always
	  being bus 0.
 SPDX-License-Identifier: GPL-2.0+
 	Copyright (C) 2002 Motorola GSG-China
  Author:
 	Darius Augulis, Teltonika Inc.
  Desc.:
 	Implementation of I2C AdapterAlgorithm Driver
 	for I2C Bus integrated in Freescale i.MXMXC processors
 	Derived from Motorola GSG China I2C example driver
 	Copyright (C) 2005 Torsten Koschorrek <koschorrek at synertronixx.de
 	Copyright (C) 2005 Matthias Blaschke <blaschke at synertronixx.de
 	Copyright (C) 2007 RightHand Technologies, Inc.
 	Copyright (C) 2008 Darius Augulis <darius.augulis at teltonika.lt>
 	Copyright 2013 Freescale Semiconductor, Inc.
 	Copyright 2020 NXP
 This will be the driver name the kernel reports 
  Enable DMA if transfer byte size is bigger than this threshold.
  As the hardware request, it must bigger than 4 bytes.\
  I have set '16' here, maybe it's not the best but I think it's
  the appropriate.
 IMX I2C registers:
  the I2C register offset is different between SoCs,
  to provid support for all these chips, split the
  register offset into a fixed base address and a
  variable shift value, then the full register offset
  will be calculated by
  reg_off = ( reg_base_addr << reg_shift)
 i2c slave address 
 i2c frequency divider 
 i2c control 
 i2c status 
 i2c transfer data 
  All of the layerscape series SoCs support IBIC register.
 i2c bus interrupt config 
 Bits of IMX I2C registers 
 Bus idle interrupt enable 
 register bits different operating codes definition:
  1) I2SR: Interrupt flags clear operation differ between SoCs:
  - write zero to clear(w0c) INT flag on i.MX,
  - but write one to clear(w1c) INT flag on Vybrid.
  2) I2CR: I2C module enable operation also differ between SoCs:
  - set I2CR_IEN bit enable the module on i.MX,
  - but clear I2CR_IEN bit enable the module on Vybrid.
 ms 
  sorted list of clock divider, register value pairs
  taken from table 26-5, p.26-9, Freescale i.MX
  Integrated Portable System Processor Reference Manual
  Document Number: MC9328MXLRM, Rev. 5.1, 062007
  Duplicated divider values removed from list
 Vybrid VF610 clock divider, register value pairs 
 IMX_I2C_IFDR 
 sentinel 
 sentinel  }
	
	  i2sr_clr_opcode is the value to clear all interrupts. Here we want to
	  clear only <bits>, so we write ~i2sr_clr_opcode with just <bits>
	  toggled. This is required because i.MX needs W0C and Vybrid uses W1C.
 Set up i2c controller register and i2c status register to default value. 
 Functions for DMA support 
 check for arbitration lost 
		
		  The formula for the poll timeout is documented in the RM
		  Rev.5 on page 1878:
		      T_min = 10F_scl
		  Set the value hard as it is done for the non-atomic use-case.
		  Use 10 kHz for the calculation since this is the minimum
		  allowed SMBus frequency. Also add an offset of 100us since it
		  turned out that the I2SR_IIF bit isn't set correctly within
		  the minimum timeout in polling mode.
 check for arbitration lost 
 No ACK 
 Divider value calculation 
 Store divider value 
	
	  There dummy delay is calculated.
	  It should be about one I2C clock period long.
	  This delay is used in I2C bus disable function
	  to fix chip hardware bug.
 Enable I2C controller 
 Wait controller to be stable 
 Start I2C transaction 
 Disable interrupt 
 Stop I2C transaction 
		
		  This delay caused by an i.MXL hardware bug.
		  If no (or too short) delay, no "STOP" bit will be generated.
 Disable I2C controller 
  Enable bus idle interrupts
  Note: IBIC register will be cleared after disabled i2c module.
  All of layerscape series SoCs support IBIC register.
 Arbitration lost 
 Addressed as a slave 
 Master wants to read from us
 Slave transmit 
 Send data 
 Master wants to write to us 
 Slave receive 
 Dummy read 
 Receive mode 
 No STOP signal detected 
 STOP signal is detected 
 Transmit mode received ACK 
 Transmit mode received NAK 
 Set slave addr. 
 Enable module 
 Enable interrupt from i2c module 
 Resume 
 Reset slave address. 
 Suspend 
 save status register 
	
	  Write slave address.
	  The first byte must be transmitted by the CPU.
 Waiting for transfer complete. 
 The last data byte must be transferred by the CPU. 
 The last two data bytes must be transferred by the CPU. 
 waiting for transfer complete. 
 read n-1 byte data 
 read n byte data 
		
		  It must generate STOP before read I2DR to prevent
		  controller from generating another clock cycle
		
		  For i2c master receiver repeat restart operation like:
		  read -> repeat MSTA -> readwrite
		  The controller must set MTX before read the last byte in
		  the first read operation, otherwise the first read cost
		  one extra clock cycle.
 write slave address 
 write data 
 write slave address 
 setup bus to read data 
	
	  Reset the I2CR_TXAK flag initially for SMBus block read since the
	  length is unknown
 dummy read 
 read data 
		
		  First byte is the length of remaining packet
		  in the SMBus block data read. Add it to
		  msgs->len.
				
				  It must generate STOP before read I2DR to prevent
				  controller from generating another clock cycle
				
				  For i2c master receiver repeat restart operation like:
				  read -> repeat MSTA -> readwrite
				  The controller must set MTX before read the last byte in
				  the first read operation, otherwise the first read cost
				  one extra clock cycle.
 Start I2C transfer 
		
		  Bus recovery uses gpiod_get_value_cansleep() which is not
		  allowed within atomic context.
 readwrite data 
 writeread data 
 Stop I2C transfer 
 After data is transferred, switch to slave mode(as a receiver) 
  We switch SCL and SDA to their GPIO function and do some bitbanging
  for bus recovery. These alternative pinmux settings can be
  described in the device tree by a separate pinctrl state "gpio". If
  this is missing this is not a big problem, the only implication is
  that we can't do bus recovery.
 Setup i2c_imx driver structure 
 Get I2C clock 
 Init queue 
 Set up adapter data 
 Set up platform driver data 
 Request IRQ 
 Set up clock divider 
 Init optional bus recovery function 
 Give it another chance if pinctrl used is not ready yet 
 Add I2C adapter 
 Init DMA config if supported 
 Return OK 
 remove adapter 
 setup chip registers to defaults 
 SPDX-License-Identifier: GPL-2.0-or-later
    Copyright (c) 2001,2002 Christer Weinigel <wingel@nano-system.com>
    National Semiconductor SCx200 ACCESS.bus support
    Also supports the AMD CS5535 and AMD CS5536
    Based on i2c-keywest.c which is:
        Copyright (c) 2001 Benjamin Herrenschmidt <benh@kernel.crashing.org>
        Copyright (c) 2000 Philip Edelbrock <phil@stimpy.netroedge.com>
 Physical interface 
 State machine data 
 Register Definitions 
 SDA Status 
 Negative Acknowledge 
 Stall After Start 
 Reset the status register 
 Do a pointer write first 
 Set ACK if _next_ byte will be the last one 
 Reset the status register to avoid the hang 
	 Disable the ACCESS.bus device and Configure the SCL
 Polling mode 
 Disable slave address 
 Enable the ACCESS.bus device 
 Free STALL after START 
 Send a STOP 
 Clear BER, NEGACK and STASTR bits 
 Clear BB bit 
 For now, we only handle combined mode (smbus) 
	 Disable the ACCESS.bus device and Configure the SCL
 If there's no dev, we're tracking (ISA) ifaces manually 
 XXX: should we care about failures? 
 First scan for ISA-based devices 
 XXX: should we care about errors? 
 If at least one bus was created, init must succeed 
 No ISA devices; register the platform driver for PCI-based devices 
  This file is provided under a dual BSDGPLv2 license.  When using or
  redistributing this file, you may do so under either license.
  Copyright(c) 2012 Intel Corporation. All rights reserved.
  GPL LICENSE SUMMARY
  This program is free software; you can redistribute it andor modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.
  BSD LICENSE
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
     Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation andor other materials provided with the
      distribution.
     Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   Supports the SMBus Message Transport (SMT) in the Intel Atom Processor
   S12xx Product Family.
   Features supported by this driver:
   Hardware PEC                     yes
   Block buffer                     yes
   Block process call transaction   yes
   Slave mode                       no
 PCI Address Constants 
 PCI DIDs for the Intel SMBus Message Transport (SMT) Devices 
 number of descriptor entries 
 number of SMBus retries to attempt 
 Hardware Descriptor Constants - Control Field 
 CommandWrite Length 
 Perform Block Transaction 
 Set fairness flag upon successful arbit. 
 Packet Error Code 
 I2C Enable 
 Interrupt 
 Stop On Error 
 Hardware Descriptor Constants - Status Field 
 Success 
 Data Low Time Out 
 NAK Received 
 CRC Error 
 Clock Low Time Out 
 Collisions 
 Large Packet Received 
 Macros 
 iSMT General Register address offsets (SMBBAR + <addr>) 
 General Control 
 SMT Interrupt Cause Location 
 Error Interrupt Mask 
 Error AER Mask 
 Error Status 
 Error Information 
 iSMT Master Registers 
 Master Descriptor Base Address 
 Master Control 
 Master Status 
 Master Descriptor Size 
 Retry Policy 
 iSMT Miscellaneous Registers 
 SMBus PHY Global Timing 
 General Control Register (GCTRL) bit definitions 
 Target Reset 
 Kill 
 Soft Reset 
 Master Control Register (MCTRL) bit definitions 
 StartStop 
 Master Error Interrupt Enable 
 Firmware Master Head Ptr (FMHP) 
 Master Status Register (MSTS) bit definitions 
 HW Master Tail Pointer (HMTP) 
 Master Interrupt Status (MIS) 
 Master Error Int Status (MEIS) 
 In Progress 
 Master Descriptor Size (MDS) bit definitions 
 Master Descriptor Size mask (MDS) 
 SMBus PHY Global Timing Register (SPGT) bit definitions 
 SMBus Speed mask 
 80 kHz 
 100 kHz 
 400 kHz 
 1 MHz 
 MSI Control Register (MSICTL) bit definitions 
 MSI Enable 
 iSMT Hardware Descriptor 
 target address & rw bit 
 write length in bytes or a command 
 read length 
 control bits 
 status bits 
 collision retry and retry count 
 received bytes 
 transmitted bytes 
 lower 32 bit of the data pointer 
 upper 32 bit of the data pointer 
 PCI BAR 
 descriptor virt base addr 
 descriptor HW base addr 
 ring buffer head pointer 
 interrupt completion 
 temp RW data buffer 
 Bus speed control bits for slow debuggers - refer to the docs for usage 
  __ismt_desc_dump() - dump the contents of a specific descriptor
  @dev: the iSMT device
  @desc: the iSMT hardware descriptor
  ismt_desc_dump() - dump the contents of a descriptor for debug purposes
  @priv: iSMT private data
  ismt_gen_reg_dump() - dump the iSMT General Registers
  @priv: iSMT private data
  ismt_mstr_reg_dump() - dump the iSMT Master Registers
  @priv: iSMT private data
  ismt_submit_desc() - add a descriptor to the ring
  @priv: iSMT private data
 Set the FMHP (Firmware Master Head Pointer)
 Set the start bit 
  ismt_process_desc() - handle the completion of the descriptor
  @desc: the iSMT hardware descriptor
  @data: data buffer from the upper layer
  @priv: ismt_priv struct holding our dma buffer
  @size: SMBus transaction type
  @read_write: flag to indicate if this is a read or write
  ismt_access() - process an SMBus command
  @adap: the i2c host adapter
  @addr: address of the i2cSMBus target
  @flags: command options
  @read_write: read from or write to device
  @command: the i2cSMBus command to issue
  @size: SMBus transaction type
  @data: readwrite data buffer
 address of the data buffer 
 Initialize the DMA buffer 
 Initialize the descriptor 
 Initialize common control bits 
			
			  Send Byte
			  The command field contains the write data
 Receive Byte 
			
			  Write Byte
			  Command plus 1 data byte
 Read Byte 
 Write Word 
 Read Word 
 Block Write 
 Block Read 
 Make sure the length is valid 
 i2c Block Write 
 i2c Block Read 
			
			  Per the "Table 15-15. I2C Commands",
			  in the External Design Specification (EDS),
			  (Document Number: 508084, Revision: 2.0),
			  the _rw bit must be 0
 map the data buffer 
 Add the descriptor 
 Now we wait for interrupt completion, 1s 
 unmap the data buffer 
 do any post processing of the descriptor here 
 Update the ring pointer 
  ismt_func() - report which i2c commands are supported by this adapter
  @adap: the i2c host adapter
  ismt_handle_isr() - interrupt handler bottom half
  @priv: iSMT private data
  ismt_do_interrupt() - IRQ interrupt handler
  @vec: interrupt vector
  @data: iSMT private data
	
	  check to see it's our interrupt, return IRQ_NONE if not ours
	  since we are sharing interrupt
  ismt_do_msi_interrupt() - MSI interrupt handler
  @vec: interrupt vector
  @data: iSMT private data
  ismt_hw_init() - initialize the iSMT hardware
  @priv: iSMT private data
 initialize the Master Descriptor Base Address (MDBA) 
 initialize the Master Control Register (MCTRL) 
 initialize the Master Status Register (MSTS) 
 initialize the Master Descriptor Size (MDS) 
	
	  Set the SMBus speed (could use this for slow HW debuggers)
  ismt_dev_init() - initialize the iSMT data structures
  @priv: iSMT private data
 allocate memory for the descriptor 
  ismt_int_init() - initialize interrupts
  @priv: iSMT private data
 Try using MSI interrupts 
 Try using legacy interrupts 
  ismt_probe() - probe for iSMT devices
  @pdev: PCI-Express device
  @id: PCI-Express device ID
 enable bus mastering 
 Determine the address of the SMBus area 
  ismt_remove() - release driver resources
  @pdev: PCI-Express device
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2005 Simtec Electronics
 	Ben Dooks <ben@simtec.co.uk>
  Simtec Generic I2C Controller
 i2c bit-bus functions 
 device registration 
 setup the private data 
 device driver 
 SPDX-License-Identifier: GPL-2.0+
  FSI-attached I2C master algorithm
  Copyright 2018 IBM Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version
  2 of the License, or (at your option) any later version.
 i2c registers 
 cmd register 
 mode register 
 watermark register 
 interrupt register 
 status register 
 extended status register 
 port busy register 
 wait for command complete or data request 
 wait after reset; choose time from legacy driver 
 choose timeout length from legacy driver; it's well tested 
 since we use polling, disable interrupts 
 reset engine when port is changed 
 fsi is limited to max 4 byte aligned ops 
 no more buffer but data in fifo, need to clear it 
 force bus reset, ignore errors 
 reset errors 
 wait for command complete 
 failed to get command complete; reset engine again 
 re-init engine again 
 reset engine 
 re-init engine 
 set port; default after reset is 0 
 reset busy register; hw workaround 
 if sda is low, peform full bus reset 
 skip final stop command for these errors 
 write stop command 
 wait until we see command complete in the master 
 cmd complete and all data xfrd 
 need to xfr more data, but maybe don't need wait 
 SPDX-License-Identifier: GPL-2.0-or-later
  driversi2cbussesi2c-ibm_iic.c
  Support for the IIC peripheral on IBM PPC 4xx
  Copyright (c) 2003, 2004 Zultys Technologies.
  Eugene Surovegin <eugene.surovegin@zultys.com> or <ebs@ebshome.net>
  Copyright (c) 2008 PIKA Technologies
  Sean MacLennan <smaclennan@pikatech.com>
  Based on original work by
  	Ian DaSilva  <idasilva@mvista.com>
       Armin Kuster <akuster@mvista.com>
  	Matt Porter  <mporter@mvista.com>
       Copyright 2000-2003 MontaVista Software Inc.
  Original driver version was highly leveraged from i2c-elektor.c
    	Copyright 1995-97 Simon G. Vogl
                 1998-99 Hans Berglund
    	With some changes from Kyösti Mälkki <kmalkki@cc.hut.fi>
 	and even Frodo Looijaard <frodol@dds.nl>
 Bus timings (in ns) for bit-banging 
 Standard mode (100 KHz) 
 Fast mode (400 KHz) 
 Enabledisable interrupt generation 
  Initialize IIC interface.
 Clear master address 
 Clear slave address 
 Clear status & extended status 
 Set clock divider 
 Clear transfer count 
 Clear extended control and status 
 Clear control register 
 Enable interrupts if possible 
 Set mode control 
  Reset IIC interface
 Place chip in the reset state 
 Check if bus is free 
 Try to set bus free state 
 Wait until we regain bus control 
 Toggle SCL line 
 be nice 
 Remove reset 
 Reinitialize interface 
  Do 0-length transaction using bit-banging through IIC_DIRECTCNTL register.
 Wait for SCL andor SDA to be high 
 Only 7-bit addresses are supported 
 Reset IIC interface 
 Wait for bus to become free 
 START 
 Send address 
 ACK 
 STOP 
 Remove reset 
 Reinitialize interface 
  IIC interrupt handler
 Acknowledge IRQ and wakeup iic_wait_for_tc 
  Get master transfer result and clear errors if any.
  Returns the number of actually transferred bytes or error (<0)
 Clear errors and possible pending IRQs 
 Flush master data buffer 
		 Is bus free?
		  If error happened during combined xfer
		  IIC interface is usually stuck in some strange
		  state, the only way out - soft reset.
  Try to abort active transfer.
	
	  Wait for the abort command to complete.
	  It's not worth to be optimized, just poll (timeout >= 1 tick)
 Just to clear errors 
  Wait for master transfer to complete.
  It puts current process to sleep until we get interrupt or timeout expires.
  Returns the number of transferred bytes or error (<0)
 Interrupt mode 
 Polling mode 
  Low level master transfer routine
 Start transfer 
 Wait for completion 
 If it's not a last part of xfer, abort it 
  Set target slave address for master transfer
  Generic master transfer entrypoint.
  Returns the number of processed messages or error (<0)
	 Check the sanity of the passed messages.
	  Uhh, generic i2c layer is more suitable place for such code...
				 Special case for I2C_SMBUS_QUICK emulation.
				  IBM IIC doesn't support 0-length transactions
				  so we have to emulate them using bit-banging.
 Check bus state 
		 Usually it means something serious has happened.
		  We cannot have unfinished previous transfer
		  so it doesn't make any sense to try to stop it.
		  Probably we were not able to recover from the
		  previous error.
		  The only reasonable thing I can think of here
		  is soft reset.  --ebs
 Flush master data buffer (just in case) 
 Load slave address 
 Do real transfer 
  Calculates IICx_CLCKDIV value for a specific OPB clock frequency
	 Compatibility kludge, should go away after all cards
	  are fixed to fill correct value for opbfreq.
	  Previous driver version used hardcoded divider value 4,
	  it corresponds to OPB frequency from the range (40, 50] MHz
 Convert to MHz 
	 Disable interrupts until we finish initialization, assumes
	   level-sensitive IRQ setup...
 Fallback to the polling mode 
  Register single IIC interface
 Board specific settings 
 Initialize IIC interface 
 Register it with i2c layer 
  Cleanup initialized IIC interface
 SPDX-License-Identifier: GPL-2.0+
  This is i.MX low power i2c controller driver.
  Copyright 2016 Freescale Semiconductor, Inc.
 i2c RXTX FIFO size 
 i2c contrl register 
 i2c status register 
 i2c interrupt enable 
 i2c master configuration 
 i2c master configuration 
 i2c master configuration 
 i2c master configuration 
 i2c master clk configuration 
 i2c master clk configuration 
 i2c master FIFO control 
 i2c master FIFO status 
 i2c master TX data register 
 i2c master RX data register 
 i2c command 
 ms 
 100+Kbps 
 400+Kbps 
 1.0+Mbps 
 3.4+Mbps 
 5.0+Mbps 
 check for arbitration lost, clear if set 
 CLKLO = I2C_CLK_RATIO  CLKHI, SETHOLD = CLKHI, DATAVD = CLKHI2 
 set MCFGR1: PINCFG, PRESCALE, IGNACK 
 set MCFGR2: FILTSDA, FILTSCL 
 set MCCR: DATAVD, SETHOLD, CLKHI, CLKLO 
	
	  First byte is the length of remaining packet in the SMBus block
	  data read. Add it to msgs->len.
 not finished, still waiting for rx data 
 multiple receive commands 
 quick smbus 
 SPDX-License-Identifier: GPL-2.0-or-later
    i2c Support for Apple SMU Controller
    Copyright (c) 2005 Benjamin Herrenschmidt, IBM Corp.
                       <benh@kernel.crashing.org>
  SMBUS-type transfer entrypoint
	 Note that these are broken vs. the expected smbus API where
	  on reads, the length is actually returned from the function,
	  but I think the current API makes no sense and I don't want
	  any driver that I haven't verified for correctness to go
	  anywhere near a pmac i2c bus anyway ...
  Generic i2c master transfer entrypoint. This driver only support single
  messages (for "lame i2c" transfers). Anything else should use the smbus
  entry point
 For now, we only handle smbus 
 First check for valid "reg" 
 Then check old-style "i2c-address" 
 Now handle some devices with missing "reg" properties 
 Check for the onyx audio codec 
	
	  Note: we do _NOT_ want the standard i2c drivers to match with any of
	  our powermac stuff unless they have been specifically modified to
	  handle it on a case by case basis. For example, for thermal control,
	  things like lm75 etc... shall match with their corresponding
	  windfarm drivers, _NOT_ the generic ones, so we force a prefix of
	  'MAC', onto the modalias to make that happen
 First try proper modalias 
 Now look for known workarounds 
 Apple uses address 0x34 for TAS3001 and 0x35 for TAS3004 
	
	  In some cases we end up with the via-pmu node itself, in this
	  case we skip this function completely as the device-tree will
	  not contain anything useful.
 Get address & channel 
 Multibus setup, check channel 
		
		  Keep track of some device existence to handle
		  workarounds later.
 Make up a modalias 
 Fill out the rest of the info structure 
			 We do not dispose of the interrupt mapping on
			  purpose. It's not necessary (interrupt cannot be
			  re-used) and somebody else might have grabbed it
			  via direct DT lookup so let's not bother
 Additional workarounds 
	 Ok, now we need to make up a name for the interface that will
	  match what we used to do in the past, that is basically the
	  controller's parent device node for keywest. PMU didn't have a
	  naming convention and SMU has a different one
		 This is not what we used to do but I'm fixing drivers at
		  the same time as this change
 Clear of_node to skip automatic registration of i2c child nodes 
 Use custom child registration due to Apple device-tree funkyness 
 SPDX-License-Identifier: GPL-2.0
  Driver for STMicroelectronics STM32F7 I2C controller
  This I2C controller is described in the STM32F75xxx and STM32F74xxx Soc
  reference manual.
  Please see below a link to the documentation:
  http:www.st.comresourceenreference_manualdm00124865.pdf
  Copyright (C) M'boumba Cedric Madianga 2017
  Copyright (C) STMicroelectronics 2017
  Author: M'boumba Cedric Madianga <cedric.madianga@gmail.com>
  This driver is based on i2c-stm32f4.c
 STM32F7 I2C registers 
 STM32F7 I2C control 1 
 STM32F7 I2C control 2 
 STM32F7 I2C Own Address 1 
 STM32F7 I2C Own Address 2 
 STM32F7 I2C Interrupt Status 
 STM32F7 I2C Interrupt Clear 
 STM32F7 I2C Timing 
 ns 
 ns 
 ns 
 ns 
  struct stm32f7_i2c_regs - i2c f7 registers backup
  @cr1: Control register 1
  @cr2: Control register 2
  @oar1: Own address 1 register
  @oar2: Own address 2 register
  @tmgr: Timing register
  struct stm32f7_i2c_spec - private i2c specification timing
  @rate: I2C bus speed (Hz)
  @fall_max: Max fall time of both SDA and SCL signals (ns)
  @rise_max: Max rise time of both SDA and SCL signals (ns)
  @hddat_min: Min data hold time (ns)
  @vddat_max: Max data valid time (ns)
  @sudat_min: Min data setup time (ns)
  @l_min: Min low period of the SCL clock (ns)
  @h_min: Min high period of the SCL clock (ns)
  struct stm32f7_i2c_setup - private I2C timing setup parameters
  @speed_freq: I2C speed frequency  (Hz)
  @clock_src: I2C clock source frequency (Hz)
  @rise_time: Rise time (ns)
  @fall_time: Fall time (ns)
  @fmp_clr_offset: Fast Mode Plus clear register offset from set register
  struct stm32f7_i2c_timings - private I2C output parameters
  @node: List entry
  @presc: Prescaler value
  @scldel: Data setup time
  @sdadel: Data hold time
  @sclh: SCL high period (master mode)
  @scll: SCL low period (master mode)
  struct stm32f7_i2c_msg - client specific data
  @addr: 8-bit or 10-bit slave addr, including rw bit
  @count: number of bytes to be transferred
  @buf: data buffer
  @result: result of the transfer
  @stop: last I2C msg to be sent, i.e. STOP to be generated
  @smbus: boolean to know if the I2C IP is used in SMBus mode
  @size: type of SMBus protocol
  @read_write: direction of SMBus protocol
  SMBus block read and SMBus block write - block read process call protocols
  @smbus_buf: buffer to be used for SMBus protocol transfer. It will
  contain a maximum of 32 bytes of data + byte command + byte count + PEC
  This buffer has to be 32-bit aligned to be compliant with memory address
  register in DMA mode.
  struct stm32f7_i2c_alert - SMBus alert specific data
  @setup: platform data for the smbus_alert i2c client
  @ara: I2C slave device used to respond to the SMBus Alert with Alert
  Response Address
  struct stm32f7_i2c_dev - private data of the controller
  @adap: I2C adapter for this controller
  @dev: device for this controller
  @base: virtual memory area
  @complete: completion of I2C message
  @clk: hw i2c clock
  @bus_rate: I2C clock frequency of the controller
  @msg: Pointer to data to be written
  @msg_num: number of I2C messages to be executed
  @msg_id: message identifiant
  @f7_msg: customized i2c msg for driver usage
  @setup: I2C timing input setup
  @timing: I2C computed timings
  @slave: list of slave devices registered on the I2C bus
  @slave_running: slave device currently used
  @backup_regs: backup of i2c controller registers (for suspendresume)
  @slave_dir: transfer direction for the current slave device
  @master_mode: boolean to know in which mode the I2C is running (master or
  slave)
  @dma: dma data
  @use_dma: boolean to know if dma is used in the current transfer
  @regmap: holds SYSCFG phandle for Fast Mode Plus bits
  @fmp_sreg: register address for setting Fast Mode Plus bits
  @fmp_creg: register address for clearing Fast Mode Plus bits
  @fmp_mask: mask for Fast Mode Plus bits in set register
  @wakeup_src: boolean to know if the device is a wakeup source
  @smbus_mode: states that the controller is configured in SMBus mode
  @host_notify_client: SMBus host-notify client
  @analog_filter: boolean to indicate enabling of the analog filter
  @dnf_dt: value of digital filter requested via dt
  @dnf: value of digital filter to apply
  @alert: SMBus alert specific data
  All these values are coming from I2C Specification, Version 6.0, 4th of
  April 2014.
  Table10. Characteristics of the SDA and SCL bus lines for Standard, Fast,
  and Fast-mode Plus I2C-bus devices
  Analog and Digital Filters 
 Compute possible values for PRESC, SCLDEL and SDADEL 
	
	  Among Prescaler possibilities discovered above figures out SCL Low
	  and High Period. Provided:
	  - SCL Low Period has to be higher than SCL Clock Low Period
	    defined by I2C Specification. I2C Clock has to be lower than
	    (SCL Low Period - AnalogDigital filters)  4.
	  - SCL High Period has to be lower than SCL Clock High Period
	    defined by I2C Specification
	  - I2C Clock has to be lower than SCL High Period
 Release list and memory 
 Timing settings 
 Configure the Analog Filter 
 Program the Digital Filter 
 Flush RX buffer has no data is expected 
	
	  For I2C_SMBUS_BLOCK_DATA && I2C_SMBUS_BLOCK_PROC_CALL, the first
	  data received inform us how many data will follow.
	
	  Update NBYTES with the value read to continue the transfer
 Set transfer direction 
 Set slave address 
 Set nb bytes to transfer and reload if needed 
 Enable NACK, STOP, error and transfer complete interrupts 
 Clear DMA req and TXRX interrupt 
 Configure DMA or enable RXTX interrupt 
 Configure StartRepeated Start 
 Write configurations registers 
 Set transfer direction 
 Set slave address 
 Rely on emulated i2c transfer (through master_xfer) 
 Configure PEC 
 Set number of bytes to be transferred 
 Enable NACK, STOP, error and transfer complete interrupts 
 Clear DMA req and TXRX interrupt 
 Configure DMA or enable RXTX interrupt 
 Set Start bit 
 Write configurations registers 
 Set transfer direction 
 Add one byte for PEC if needed 
 Set number of bytes to be transferred 
	
	  Configure RXTX interrupt:
	
	  Configure DMA or enable RXTX interrupt:
	  For I2C_SMBUS_BLOCK_DATA and I2C_SMBUS_BLOCK_PROC_CALL we don't use
	  dma as we don't know in advance how many data will be received
 Configure Repeated Start 
 Write configurations registers 
		
		  For 10-bit addr, addcode = 11110XY with
		  X = Bit 9 of slave address
		  Y = Bit 8 of slave address
 Notify i2c slave that new read transfer is starting 
		
		  Disable slave TX config in case of I2C combined message
		  (I2C Write followed by I2C Read)
 Enable TX empty, STOP, NACK interrupts 
 Write 1st data byte 
 Notify i2c slave that new write transfer is starting 
 Set reload mode to be able to ACKNACK each received byte 
		
		  Set STOP, NACK, RX empty and transfer complete interrupts.
		  Set Slave Byte Control to be able to ACKNACK each data
		  byte received
 Start I2C slave processing 
 Clear ADDR flag 
	
	  slave[STM32F7_SLAVE_HOSTNOTIFY] support only SMBus Host address (0x8)
	  slave[STM32F7_SLAVE_7_10_BITS_ADDR] supports 7-bit and 10-bit slave address
	  slave[STM32F7_SLAVE_7_BITS_ADDR] supports 7-bit slave address only
 Slave transmitter mode 
 Write data byte 
 Transfer Complete Reload for Slave receiver mode 
		
		  Read data byte then set NBYTES to receive next byte or NACK
		  the current received byte
 NACK received 
 STOP received 
 Disable interrupts 
			
			  Flush TX buffer in order to not used the byte in
			  TXDR for the next transfer
 Clear STOP flag 
 Notify i2c slave that a STOP flag has been detected 
 Address match received 
 Check if the interrupt if for a slave device 
 Tx empty 
 RX not empty 
 NACK received 
 STOP detection flag 
 Disable interrupts 
 Clear STOP flag 
 Transfer complete 
	
	  Wait for dma transfer completion before sending next message or
	  notity the end of xfer to the client
 Bus error 
 Arbitration loss 
 Disable interrupts 
 Disable dma 
 Check PEC 
 Slave SMBus Host 
 Configure Own Address 1 
 Configure Own Address 2 
 Enable ACK 
 Enable Address match interrupt, error interrupt and enable I2C  
 Optional 
 Optional 
 Enable SMBus Host address 
 Disable SMBus Host address 
 Enable SMBus Alert 
 Disable SMBus Alert 
 Setup Fast mode plus if necessary 
 Init DMA config if supported 
 DMA support is optional, only report other errors 
		
		  enforce that wakeup is disabled and that the device
		  is marked as non wakeup capable
  (C) Copyright 2009-2010
  Nokia Siemens Networks, michael.lawnick.ext@nsn.com
  Portions Copyright (C) 2010 - 2016 Cavium, Inc.
  This file contains the shared part of the driver for the i2c adapter in
  Cavium Networks' OCTEON processors and ThunderX SOCs.
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 interrupt service routine 
  octeon_i2c_wait - wait for the IFLG to be set
  @i2c: The struct octeon_i2c
  Returns 0 on success, otherwise a negative errno.
	
	  Some chip revisions don't assert the irq in the interrupt
	  controller. So we must poll for the IFLG change.
 clear STTS events, listen for neither 
  Cleanup low-level state & enable high-level controller.
 clear IFLG event 
 spin until any startstop has finished 
  octeon_i2c_hlc_wait - wait for an HLC operation to complete
  @i2c: The struct octeon_i2c
  Returns 0 on success, otherwise -ETIMEDOUT.
	
	  Some cn38xx boards don't assert the irq in the interrupt
	  controller. So we must poll for the valid bit change.
	
	  This is ugly... in HLC mode the status is not in the status register
	  but in the lower 8 bits of SW_TWSI.
 Everything is fine 
 ACK allowed on pre-terminal bytes only 
 NAK allowed on terminal byte only 
 Arbitration lost 
 Being addressed as slave, should back off & listen 
 Core busy as slave 
 recover failed, try hardware re-init 
  octeon_i2c_start - send START to the bus
  @i2c: The struct octeon_i2c
  Returns 0 on success, otherwise a negative errno.
 START successful, bail out 
 START failed, try to recover 
 send STOP to the bus 
  octeon_i2c_read - receive data from the bus via low-level controller
  @i2c: The struct octeon_i2c
  @target: Target address
  @data: Pointer to the location to store the data
  @rlength: Length of the data
  @recv_len: flag for length byte
  The address is sent over the bus, then the data is read.
  Returns 0 on success, otherwise a negative errno.
 address OK ? 
		
		  For the last byte to receive TWSI_CTL_AAK must not be set.
		 
		  A special case is I2C_M_RECV_LEN where we don't know the
		  additional length yet. If recv_len is set we assume we're
		  not reading the final byte and therefore need to set
		  TWSI_CTL_AAK.
 clear iflg to allow next event 
  octeon_i2c_write - send data to the bus via low-level controller
  @i2c: The struct octeon_i2c
  @target: Target address
  @data: Pointer to the data to be sent
  @length: Length of the data
  The address is sent over the bus, then the data.
  Returns 0 on success, otherwise a negative errno.
 high-level-controller pure read of up to 8 bytes 
 SIZE 
 A 
 high-level-controller pure write of up to 8 bytes 
 SIZE 
 A 
 high-level-controller composite write+read, msg0=addr, msg1=data 
 SIZE 
 A 
 high-level-controller composite write+write, m[0]len<=2, m[1]len<=8 
 SIZE 
 A 
  octeon_i2c_xfer - The driver's master_xfer function
  @adap: Pointer to the i2c_adapter structure
  @msgs: Pointer to the messages to be processed
  @num: Length of the MSGS array
  Returns the number of messages processed, or a negative errno on failure.
 zero-length messages are not supported 
 calculate and set clock divisors 
		
		  An mdiv value of less than 2 seems to not work well
		  with ds1337 RTCs, so we constrain it to larger values.
			
			  For given ndiv and mdiv values check the
			  two closest thp values.
 reset controller 
 toggle twice to force both teardowns 
 wait for software reset to settle 
	
	  Bring control register to a good state regardless
	  of HLC state.
	
	  Generate STOP to finish the unfinished transaction.
	  Can't generate STOP via the TWSI CTL register
	  since it could bring the TWSI controller into an inoperable state.
 SPDX-License-Identifier: GPL-2.0
  Synopsys DesignWare I2C adapter driver (slave only).
  Based on the Synopsys DesignWare I2C adapter driver (master).
  Copyright (C) 2016 Synopsys Inc.
 Configure TxRx FIFO threshold levels. 
 Configure the I2C slave. 
  i2c_dw_init_slave() - Initialize the designware i2c slave hardware
  @dev: device private data
  This function configures and enables the I2C in slave mode.
  This function is called during I2C init function, and in case of timeout at
  run time.
 Disable the adapter. 
 Write SDA hold time if supported 
	
	  Set slave address in the IC_SAR register,
	  the address to which the DW_apb_i2c responds.
	
	  The IC_INTR_STAT register just indicates "enabled" interrupts.
	  The unmasked raw version of interrupt status bits is available
	  in the IC_RAW_INTR_STAT register.
	 
	  That is,
	    stat = readl(IC_INTR_STAT);
	  equals to,
	    stat = readl(IC_RAW_INTR_STAT) & readl(IC_INTR_MASK);
	 
	  The raw version might be useful for debugging purposes.
	
	  Do not use the IC_CLR_INTR register to clear interrupts, or
	  you'll miss some interrupts, triggered during the period from
	  readl(IC_INTR_STAT) to readl(IC_CLR_INTR).
	 
	  Instead, use the separately-prepared IC_CLR_ registers.
  Interrupt service routine. This gets called whenever an I2C slave interrupt
  occurs.
  Copyright (C) 2013 Broadcom Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 Hardware register offsets and field defintions 
 Locally used constants 
 bytes 
 bytes 
 Mastercodes are 0000_1xxxb 
 msecs 
 Operations that can be commanded to the controller 
 Internal divider settings for standard mode, fast mode and fast mode plus 
 Number of cycles for setup time 
 Number of cycles for hold time 
 Prescale divider 
 Timing coefficient 
 Disable clock divider 
 Post-prescale divider 
 Internal divider settings for high-speed mode 
	uint8_t hs_hold;	 Number of clock cycles SCL stays low until
	uint8_t hs_high_phase;	 Number of clock cycles SCL stays high
	uint8_t hs_setup;	 Number of clock cycles SCL stays low
 Prescale divider 
 Timing coefficient 
 Disable clock divider 
 Post-prescale divider 
 Must flush the TX FIFO when NAK detected 
 Wait for ISR_CMDBUSY_MASK to go low before writing to CS, DAT, or RCD 
 Send command to I2C bus 
 Make sure the hardware is ready 
 Unmask the session done interrupt 
 Mark as incomplete before sending the command 
 Send the command 
 Wait for transaction to finish or timeout 
 Mask all interrupts 
 Clear command 
 Read a single RX FIFO worth of data from the i2c bus 
 Mark as incomplete before starting the RX FIFO 
 Unmask the read complete interrupt 
 Start the RX FIFO 
 Wait for FIFO read to complete 
 Mask all interrupts 
 Read data from FIFO 
 Read any amount of data using the RX FIFO from the i2c bus 
 NAK last byte of transfer 
 Write a single byte of data to the i2c bus 
 Make sure the hardware is ready 
 Clear pending session done interrupt 
 Unmask the session done interrupt 
 Mark as incomplete before sending the data 
 Send one byte of data 
 Wait for byte to be written 
 Mask all interrupts 
 Write a single TX FIFO worth of data to the i2c bus 
 Mark as incomplete before sending data to the TX FIFO 
 Unmask the fifo empty and nak interrupt 
 Disable IRQ to load a FIFO worth of data without interruption 
 Write data into FIFO 
 Enable IRQ now that data has been loaded 
 Wait for FIFO to empty 
 Mask all interrupts 
 Check if there was a NAK 
 Check if a timeout occured 
 Write any amount of data using TX FIFO to the i2c bus 
 Send i2c address 
 First byte is 11110XX0 where XX is upper 2 bits 
 Second byte is the remaining 8 bits 
 For read, send restart command 
 Then re-send the first byte with the read bit set 
 Send mastercode at standard speed 
 Configure external clock to higher frequency 
 Reconfigure internal dividers 
 Send a restart command 
 Reconfigure internal dividers 
 Configure external clock to lower frequency 
 Master transfer function 
 Enable pad output 
 Enable internal clocks 
 Send start command 
 Switch to high speed if applicable 
 Loop through all messages 
 Send restart for subsequent messages 
 Send slave address 
 Perform data transfer 
 Send a STOP command 
 Return from high speed if applicable 
 Disable pad output 
 Stop internal clock 
 Send mastercode at 100k 
 Allocate memory for private data structure 
 Map hardware registers 
 Get and enable external clock 
 Parse bus speed 
 Enable internal clocks 
 Configure internal dividers 
 Disable timeout 
 Enable autosense 
 Enable TX FIFO 
 Mask all interrupts 
 Clear all pending interrupts 
 Get the interrupt number 
 register the ISR handler 
 Enable the controller but leave it idle 
 Disable pad output 
 Disable internal clock 
 Disable external clock 
 Add the i2c adapter 
 SPDX-License-Identifier: GPL-2.0-or-later
  Freescale CPM1CPM2 I2C interface.
  Copyright (c) 1999 Dan Malek (dmalek@jlc.net).
  moved into proper i2c interface;
  Brad Parker (brad@heeltoe.com)
  Parts from dbox2_i2c.c (cvs.tuxbox.org)
  (C) 2000-2001 Felix Domke (tmbinc@gmx.net), Gillem (htoa@gmx.net)
  (C) 2007 Montavista Software, Inc.
  Vitaly Bordug <vitb@kernel.crashing.org>
  Converted to of_platform_device. Renamed to i2c-cpm.c.
  (C) 2007,2008 Jochen Friedrich <jochen@scram.de>
 Try to define this if you have an older CPU (earlier than rev D4) 
 However, better use a GPIO based bitbang driver in this case :   
 Big endian mode 
 Big endian mode, memory snoop 
 I2C parameter RAM. 
 Rx Buffer descriptor base address 
 Tx Buffer descriptor base address 
 Rx function code 
 Tx function code 
 Max receive buffer length 
 Internal 
 Internal 
 Rx Buffer descriptor pointer 
 Internal 
 Internal 
 Internal 
 Internal 
 Tx Buffer descriptor pointer 
 Internal 
 Internal 
 Reserved 
 Relocation pointer 
 Reserved 
 The following elements are only for CPM2 
 Reserved 
 Internal 
 I2C Registers 
 CPM1=1, CPM2=2 
 Clear interrupt. 
 Set up the I2C parameters in the parameter ram. 
 Disable all interrupts 
 Align read buffer 
 Device address byte wrw flag 
		
		  To read, we need an empty buffer of the proper length.
		  All that is used is the first byte for address, the remainder
		  is just used for timing (and doesn't really have to exist).
 Align read buffer 
 Reset to use first buffer 
	
	  If there was a collision in the last i2c transaction,
	  Set I2COM_MASTER as it was cleared during collision.
 Start transfer now 
 Enable RXTXError interupts 
 Clear interrupt status 
 Chip bug, set enable here 
 Enable 
 Begin transmission 
 Check for outstanding messages 
	
	  Chip errata, clear enable. This is not needed on rev D4 CPUs.
	  Disabling I2C too early may cause too short stop condition
	
	  Chip errata, clear enable. This is not needed on rev D4 CPUs.
 -----exported algorithm data: -------------------------------------	
 CPM_MAX_READ is also limiting writes according to the code! 
 Install interrupt handler. 
 I2C parameter RAM 
 Check for and use a microcode relocation patch. 
		
		  Maybe should use cpm_muram_alloc instead of hardcoding
		  this in micropatch.c
 I2C controlstatus registers 
 use 60kHz i2c clock by default 
	
	  Allocate space for CPM_MAXBD transmit and receive buffer
	  descriptors in the DP ram.
 Allocate TX and RX buffers 
 Initialize TxRx parameters. 
	
	  Select an invalid address. Just make sure we don't use loopback mode
	
	  PDIV is set to 00 in i2mod, so brgclk32 is used as input to the
	  i2c baud rate generator. This is divided by 2 x (DIV + 3) to get
	  the actual i2c bus frequency.
 Master mode 
 Disable interrupts. 
 Shut down I2C. 
 Disable interrupts 
 Free all memory 
 register new adapter to i2c module... 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2004 Steven J. Hill
  Copyright (C) 2001,2002,2003 Broadcom Corporation
  Copyright (C) 1995-2000 Simon G. Vogl
 private data 
 which bus 
 CSR base 
 ----- global defines ----------------------------------------------- 
 Clear error bit by writing a 1 
 -----exported algorithm data: -------------------------------------	
  registering functions to load algorithms at runtime
 Register new adapter to i2c module... 
 Set the requested frequency. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2015 Masahiro Yamada <yamada.masahiro@socionext.com>
 TX register 
 enable interrupt 
 start condition 
 stop condition 
 do not return ACK 
 read transaction 
 RX register 
 1 = master, 0 = slave 
 1 = transmit, 0 = receive 
 stop condition detected 
 no ACK 
 arbitration lost 
 bus not busy 
 slave address 
 clock frequency control 
 bus reset 
 normal operation 
 release SCL 
 hold time control 
 bus status monitor 
 readback of SDA line 
 readback of SCL line 
 noise filter control 
 setup time control 
	
	  This hardware uses edge triggered interrupt.  Do not touch the
	  hardware registers in this handler to make sure to catch the next
	  interrupt edge.  Just send a complete signal and return.
 could not acquire bus. bail out without STOP 
 This error is fatal.  Needs recovery. 
 Failed to issue STOP.  The bus needs recovery. 
			
			  If bus busy continues too long, it is probably
			  in a wrong state.  Try bus recovery.
 Emit STOP if it is the last message or I2C_M_STOP is set. 
	
	  Bit30-16: clock cycles of tLOW.
	   Standard-mode: tLOW = 4.7 us, tHIGH = 4.0 us
	   Fast-mode:     tLOW = 1.3 us, tHIGH = 0.6 us
	  "tLowtHIGH = 54" meets both.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
   Aspeed 24XX25XX I2C Controller.
   Copyright (C) 2012-2017 ASPEED Technology Inc.
   Copyright 2017 IBM Corporation
   Copyright 2017 Google, Inc.
 I2C Register 
 Global Register Definition 
 0x00 : I2C Interrupt Status Register  
 0x08 : I2C Interrupt Target Assignment  
 Device Register Definition 
 0x00 : I2CD Function Control Register  
 0x04 : I2CD Clock and AC Timing Control Register #1 
 0x08 : I2CD Clock and AC Timing Control Register #2 
 0x0c : I2CD Interrupt Control Register &
  0x10 : I2CD Interrupt Status Register
  These share bit definitions, so use the same values for the enable &
  status bits.
 0x14 : I2CD CommandStatus Register   
 Command Bit 
 0x18 : I2CD Slave Device Address Register   
 Synchronizes IO mem access to base. 
 Transaction state. 
 Protected only by i2c_lock_bus 
 Multi-master 
 CONFIG_I2C_SLAVE 
 Bus is idle: no recovery needed. 
 Recovery failed. 
 Bus error. 
 Writes 1 to 8 SCL clock cycles until SDA is released. 
 Recovery failed. 
 Slave was requested, restart state machine. 
 Slave is not currently active, irq was for someone else. 
 Slave was sent something. 
 Handle address frame. 
 Slave was asked to stop. 
 Slave was just started. Waiting for the next event. ;
 CONFIG_I2C_SLAVE 
 precondition: bus.lock has been acquired. 
	
	  If it's requested in the middle of a slave session, set the master
	  state to 'pending' then HW will continue handling this master
	  command when the bus comes back to the idle state.
 CONFIG_I2C_SLAVE 
 Need to let the hardware know to NACK after RX. 
 precondition: bus.lock has been acquired. 
 precondition: bus.lock has been acquired. 
	
	  We encountered an interrupt that reports an error: the hardware
	  should clear the command queue effectively taking us back to the
	  INACTIVE state.
 Master is not currently active, irq was for someone else. 
 We are in an invalid state; reset bus to a known state. 
	
	  START is a special case because we still have to handle a subsequent
	  TX or RX immediately after we handle it, so we handle it here and
	  then update the state and handle the new state below.
		
		  If a peer master starts a xfer immediately after it queues a
		  master command, clear the queued master command and change
		  its state to 'pending'. To simplify handling of pending
		  cases, it uses SW solution instead of HW command queue
		  handling.
 CONFIG_I2C_SLAVE 
 SMBUS_QUICK 
 RX may not have completed yet (only address cycle) 
 Do not STOP as we have already tried. 
 Do not STOP as we should be inactive. 
 Ack all interrupts except for Rx done 
	
	  In most cases, interrupt bits will be set one by one, although
	  multiple interrupt bits could be set at the same time. It's also
	  possible that master interrupt bits could be set along with slave
	  interrupt bits. Each case needs to be handled using corresponding
	  handlers depending on the current state.
	
	  Start a pending master command at here if a slave operation is
	  completed.
 CONFIG_I2C_SLAVE 
 Ack Rx done 
 If bus is busy in a single master environment, attempt recovery. 
		
		  If timed out and bus is still busy in a multi master
		  environment, attempt recovery at here.
		
		  If timed out and the state is still pending, drop the pending
		  master command.
 precondition: bus.lock has been acquired. 
	
	  Set slave addr.  Reserved bits can all safely be written with zeros
	  on all of ast2[456]00, so zero everything else to ensure we only
	  enable a single slave address (ast2500 has two, ast2600 has three,
	  the enable bits for which are also in this register) so that we don't
	  end up with additional phantom devices responding on the bus.
 Turn on slave mode. 
 Turn off slave mode. 
 CONFIG_I2C_SLAVE 
 CONFIG_I2C_SLAVE 
	
	  SCL_high and SCL_low represent a value 1 greater than what is stored
	  since a zero divider is meaningless. Thus, the max value each can
	  store is every bit set + 1. Since SCL_high and SCL_low are added
	  together (see below), the max value of both is the max value of one
	  them times two.
	
	  The actual clock frequency of SCL is:
	 	SCL_freq = APB_freq  (base_freq  (SCL_high + SCL_low))
	 		 = APB_freq  divisor
	  where base_freq is a programmable clock divider; its value is
	 	base_freq = 1 << base_clk_divisor
	  SCL_high is the number of base_freq clock cycles that SCL stays high
	  and SCL_low is the number of base_freq clock cycles that SCL stays
	  low for a period of SCL.
	  The actual register has a minimum SCL_high and SCL_low minimum of 1;
	  thus, they start counting at zero. So
	 	SCL_high = clk_high + 1
	 	SCL_low	 = clk_low + 1
	  Thus,
	 	SCL_freq = APB_freq 
	 		((1 << base_clk_divisor)  (clk_high + 1 + clk_low + 1))
	  The documentation recommends clk_high >= clk_high_max  2 and
	  clk_low >= clk_low_max  2 - 1 when possible; this last constraint
	  gives us the following solution:
	
	  clk_high and clk_low are each 3 bits wide, so each can hold a max
	  value of 8 giving a clk_high_low_max of 16.
	
	  clk_high and clk_low are each 4 bits wide, so each can hold a max
	  value of 16 giving a clk_high_low_max of 32.
 precondition: bus.lock has been acquired. 
 precondition: bus.lock has been acquired. 
 Disable everything. 
 Enable Master Mode 
 If slave has already been registered, re-enable it. 
 CONFIG_I2C_SLAVE 
 Set interrupt generation of I2C controller 
 Disable and ack all interrupts. 
 We just need the clock rate, we don't actually use the clk object. 
 Initialize the I2C adapter 
 Clean up any left over interrupt state. 
	
	  bus.lock does not need to be held because the interrupt handler has
	  not been enabled yet.
 Disable everything. 
 SPDX-License-Identifier: GPL-2.0-or-later
    Copyright (c) 2002,2003 Alexander Malysh <amalysh@web.de>
   Status: beta
   Supports:
	SIS 630
	SIS 730
	SIS 964
   Notable differences between chips:
	+------------------------+--------------------+-------------------+
	|                        |     SIS630730     |      SIS964       |
	+------------------------+--------------------+-------------------+
	| Clock                  | 14kHz56kHz        | 55.56kHz27.78kHz |
	| SMBus registers offset | 0x80               | 0xE0              |
	| SMB_CNT                | Bit 1 = Slave Busy | Bit 1 = Bus probe |
	|         (not used yet) | Bit 3 is reserved  | Bit 3 = Last byte |
	| SMB_PCOUNT		 | Offset + 0x06      | Offset + 0x14     |
	| SMB_COUNT              | 4:0 bits           | 5:0 bits          |
	+------------------------+--------------------+-------------------+
	(Other differences don't affect the functions provided by the driver)
   Note: we assume there can only be one device, with one SMBus interface.
 SIS964 id is defined here as we are the only file using it 
 SIS630730964 SMBus registers 
 status 
 control 
 host control 
 address 
 command 
 byte count 
 ~0x8F data byte field 
 SMB_STS register 
 Byte Done Status  Block Array 
 Collision 
 Device error 
 SMB_CNT register 
 Host Master Timeout Enable 
 Host master clock selection 
 Bus ProbeSlave busy 
 Host Busy 
 SMBHOST_CNT register 
 Kill 
 Start 
 register count for request_region
  As we don't use SMB_PCOUNT, 20 is ok for SiS630 and SiS964
 PCI address constants 
 acpi base address register  
 bios control register 
 Other settings 
 SIS630 constants 
 insmod parameters 
 SMBus base adress 
 supported chips 
 terminates the list 
 Make sure the SMBus host is ready to start transmitting. 
 kill smbus transaction 
 save old clock, so we can prevent machine for hung 
	 disable timeout interrupt,
 clear all sticky bits 
 start the transaction by setting bit 4 and size 
 We will always wait for a fraction of a second! 
 check if block transmitted 
 If the SMBus is still busy, we give up 
 clear all status "sticky" bits 
	
	  restore old Host Master Clock if high_clock is set
	  and oldclock was not 56KHz
 set data 
 first transaction 
					
					   If this is not first transaction,
					   we must clear sticky bit.
					   clear SMBARY_STS
 read request 
 if this first transaction then read byte count 
 just to be sure 
 clear SMBARY_STS 
 Return negative errno on error. 
 acpi base address 
 check for supported SiS devices 
 found 
	
	   Enable ACPI first , so we can accsess reg 74-75
	   in acpi io space and read acpi base addr
 if ACPI already enabled , do nothing 
 Determine the ACPI base address 
 Everything is happy, let's grab the memory and set things up. 
 set up the sysfs linkage to our parent device 
 SPDX-License-Identifier: GPL-2.0-or-later
  Virtio I2C Bus Driver
  The Virtio I2C Specification:
  https:raw.githubusercontent.comoasis-tcsvirtio-specmastervirtio-i2c.tex
  Copyright (c) 2021 Intel Corporation. All rights reserved.
  struct virtio_i2c - virtio I2C data
  @vdev: virtio device for this controller
  @completion: completion of virtio I2C message
  @adap: I2C adapter for this controller
  @vq: the virtio virtqueue for communication
  struct virtio_i2c_req - the virtio I2C request structure
  @out_hdr: the OUT header of the virtio I2C message
  @buf: the buffer into which data is read, or from which it's written
  @in_hdr: the IN header of the virtio I2C message
		
		  Only 7-bit mode supported for this moment. For the address
		  format, Please check the Virtio I2C Specification.
 Detach the ith request from the vq 
		
		  Condition req == &reqs[i] should always meet since we have
		  total num requests in the vq. reqs[i] can never be NULL here.
	
	  For the case where count < num, i.e. we weren't able to queue all the
	  msgs, ideally we should abort right away and return early, but some
	  of the messages are already sent to the remote I2C controller and the
	  virtqueue will be left in undefined state in that case. We kick the
	  remote here to clear the virtqueue, so we can try another set of
	  messages later on.
	
	  Setup ACPI node for controlled devices which will be probed through
	  ACPI.
 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
  AMD MP2 platform driver
  Setup the I2C adapters enumerated in the ACPI namespace.
  MP2 controllers have 2 separate busses, up to 2 I2C adapters may be listed.
  Authors: Nehal Bakulchandra Shah <Nehal-bakulchandra.shah@amd.com>
           Elie Morisse <syniurge@gmail.com>
  struct amd_i2c_dev - MP2 busi2c adapter context
  @common: shared context with the MP2 PCI driver
  @pdev: platform driver node
  @adap: i2c adapter
  @cmd_complete: xfer completion object
 the adapter might have been deleted while waiting for the bus lock 
 round down to the lowest standard speed 
	 The ACPI namespace doesn't contain information about which MP2 PCI
	  device an AMDI0011 ACPI device is related to, so assume that there's
	  only one MP2 PCI device per system.
 The MP2 PCI device should get probed later 
 Register the adapter 
 Setup i2c adapter description 
 Enable the bus 
 Attach to the i2c layer 
 SPDX-License-Identifier: GPL-2.0-only
  This driver implements I2C master functionality using the LSI API2C
  controller.
  NOTE: The controller has a limitation in that it can only do transfers of
  maximum 255 bytes at a time. If a larger transfer is attempted, error code
  (-EINVAL) is returned.
 RX FIFO serivce 
 TX FIFO service 
 Manual mode done 
 Automatic mode done 
 Stop complete 
 Invalid parameter 
 Timeout 
 Arbitration lost 
 NAK on data phase 
 NAK on address phase 
 ACK to General Call Address from own master (loopback) 
 ACK to General Call Address from external masters 
 ACK to addr_1 enabled 
 10-bit addressing for addr_1 enabled 
 ACK to addr_2 enabled 
 10-bit addressing for addr_2 enabled 
 Generate ACK for writes to addr_1 
 Generate ACK for writes to addr_2 
 ACK data phase transfers to General Call Address 
 Data Valid for addr_1 
 Data Valid for addr_2 
 (N)ACK Sent 
 Timeout NACK 
 First byte after start condition received 
 Repeated Start Condition 
 Stop Condition 
 FIFO service 
 Write transfer complete 
 Slave read from addr 1 
 Repeated start from addr 1 
 Read request not following start condition 
 Read canceled 
 Slave Read timed out 
 Data written after timed out 
  axxia_i2c_dev - I2C device context
  @base: pointer to register struct
  @msg: pointer to current message
  @msg_r: pointer to current read message (sequence transfer)
  @msg_xfrd: number of bytes transferred in tx_fifo
  @msg_xfrd_r: number of bytes transferred in rx_fifo
  @msg_err: error code for completed message
  @msg_complete: xfer completion object
  @dev: device reference
  @adapter: core i2c abstraction
  @i2c_clk: clock reference for i2c input clock
  @bus_clk_rate: current i2c bus clock rate
  @last: a flag indicating is this is last message in transfer
  ns_to_clk - Convert time (ns) to clock cycles for the given clock frequency.
 Reset controller 
 Enable Master Mode 
 Standard mode SCL 5050, tSU:DAT = 250 ns 
 Fast mode SCL 3366, tSU:DAT = 100 ns 
 SCL High Time 
 SCL Low Time 
 SDA Setup Time 
 SDA Hold Time, 300ns 
 Filter <50ns spikes 
 Configure Time-Out Registers 
 Find prescaler value that makes tmo_clk fit in 15-bits counter. 
 Prescale divider (log2) 
 Timeout in divided clocks 
 Mask all master interrupt bits 
 Interrupt enable 
  axxia_i2c_empty_rx_fifo - Fetch data from RX FIFO and update SMBus block
  transfer length if this is the first byte of such a transfer.
			
			  Check length byte for SMBus block read
  axxia_i2c_fill_tx_fifo - Fill TX FIFO from current message buffer.
  @return: Number of bytes left to transfer.
 dummy read 
 dummy read 
 Read interrupt status bits 
 RX FIFO needs service? 
 TX FIFO needs service? 
 Transfer error 
 Stop completed 
 Transfer done 
 Transfer timeout 
 Clear interrupt 
		 10-bit address
		    addr_1: 5'b11110 | addr[9:8] | (RnW)
		    addr_2: addr[7:0]
 Set the RnW bit of the address 
		 7-bit address
		    addr_1: addr[6:0] | (RnW)
		    addr_2: dont care
 The NAK interrupt will be sent _before_ issuing STOP command
  so the controller might still be busy processing it. No
  interrupt will be sent at the end so we have to poll for it
 I2C read transfer 
 I2C write transfer 
 Disable wait timer temporarly 
 Check if timeout error happened 
 This function checks if the msgs[] array contains messages compatible with
  Sequence mode of operation. This mode assumes there will be exactly one
  write of non-zero length followed by exactly one read of non-zero length,
  both targeted at the same client device.
 Preserve SDA Control 
 Enable slave mode as well 
 Set slave address 
 Enable interrupts 
 Disable slave mode 
 default clock rate 
 Match table for of_platform binding 
  Copyright (C) 2017 Spreadtrum Communications Inc.
  SPDX-License-Identifier: (GPL-2.0+ OR MIT)
 I2C_CTL 
 I2C_STATUS 
 ADDR_RST 
 timeout (ms) for pm runtime autosuspend 
 timeout (ms) for transfer message 
 SPRD i2c data structure 
		
		  If the read data count is larger than rx fifo full threshold,
		  we should enable the rx fifo full interrupt to read data
		  again.
		
		  If the write data count is arger than tx fifo depth which
		  means we can not write all data in one time, then we should
		  enable the tx fifo empty interrupt to write again.
	
	  We should enable rx fifo full interrupt to get data when receiving
	  full data.
	
	  From I2C databook, the prescale calculation formula:
	  prescale = freq_i2c  (4  freq_scl) - 1;
	
	  From I2C databook, the high period of SCL clock is recommended as
	  40% (25), and the low period of SCL clock is recommended as 60%
	  (35), then the formula should be:
	  high = (prescale  2  2)  5
	  low = (prescale  2  3)  5
 Start hold timing = hold time(us)  source clock 
	
	  If we got one ACK from slave when writing data, and we did not
	  finish this transmission (i2c_tran is not zero), then we should
	  continue to write data.
	 
	  For reading data, ack is always true, if i2c_tran is not 0 which
	  means we still need to contine to read data from slave.
	
	  If we did not get one ACK from slave when writing data, we should
	  return -EIO to notify users.
 Transmission is done and clear ack and start operation 
	
	  If we did not get one ACK from slave when writing data, then we
	  should finish this transmission since we got some errors.
	 
	  When writing data, if i2c_tran == 0 which means we have writen
	  done all data, then we can finish this transmission.
	 
	  When reading data, if conut < rx fifo full threshold, which
	  means we can read all data in one time, then we can finish this
	  transmission too.
 We only support 100k and 400k now, otherwise will return error. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Synopsys DesignWare I2C adapter driver.
  Based on the TI DAVINCI I2C adapter driver.
  Copyright (C) 2006 Texas Instruments.
  Copyright (C) 2007 MontaVista Software Inc.
  Copyright (C) 2009 Provigent Ltd.
  i2c_dw_init_regmap() - Initialize registers map
  @dev: device private data
  Autodetects needed register access mode and creates the regmap with
  corresponding readwrite callbacks. This must be called before doing any
  other register access.
	
	  Skip detecting the registers map configuration if the regmap has
	  already been provided by a higher code.
	
	  Note we'll check the return value of the regmap IO accessors only
	  at the probe stage. The rest of the code won't do this because
	  basically we have MMIO-based regmap so non of the readwrite methods
	  can fail.
	
	  Only standard mode at 100kHz, fast mode at 400kHz,
	  fast mode plus at 1MHz and high speed mode at 3.4MHz are supported.
  The HCNTLCNT information coming from ACPI should be the most accurate
  for given platform. However, some systems get it wrong. On such systems
  we get better results by calculating those based on the input clock.
	
	  Try to get SDA hold time and CNT values from an ACPI method for
	  selected speed modes.
	
	  Some DSTDs use a non standard speed, round down to the lowest
	  standard speed.
 CONFIG_ACPI 
 CONFIG_ACPI 
	
	  Find bus speed from the "clock-frequency" device property, ACPI
	  or by using fast mode if neither is set.
	
	  DesignWare I2C core doesn't seem to have solid strategy to meet
	  the tHD;STA timing spec.  Configuring _HCNT based on tHIGH spec
	  will result in violation of the tHD;STA spec.
		
		  Conditional expression:
		 
		    IC_[FS]S_SCL_HCNT + (1+4+3) >= IC_CLK  tHIGH
		 
		  This is based on the DW manuals, and represents an ideal
		  configuration.  The resulting I2C bus speed will be
		  faster than any of the others.
		 
		  If your hardware is free from tHD;STA issue, try this one.
		
		  Conditional expression:
		 
		    IC_[FS]S_SCL_HCNT + 3 >= IC_CLK  (tHD;STA + tf)
		 
		  This is just experimental rule; the tHD;STA period turned
		  out to be proportinal to (_HCNT + 3).  With this setting,
		  we could meet both tHIGH and tHD;STA timing specs.
		 
		  If unsure, you'd better to take this alternative.
		 
		  The reason why we need to take into account "tf" here,
		  is the same as described in i2c_dw_scl_lcnt().
	
	  Conditional expression:
	 
	    IC_[FS]S_SCL_LCNT + 1 >= IC_CLK  (tLOW + tf)
	 
	  DW I2C core starts counting the SCL CNTs for the LOW period
	  of the SCL clock (tLOW) as soon as it pulls the SCL line.
	  In order to meet the tLOW timing spec, we need to take into
	  account the fall time of SCL signal (tf).  Default tf value
	  should be 0.3 us, for safety.
 Configure SDA Hold Time if required 
 Keep previous hold time setting if no one set it 
		
		  Workaround for avoiding TX arbitration lost in case I2C
		  slave pulls SDA down "too quickly" after falling edge of
		  SCL by enabling non-zero SDA RX hold. Specification says it
		  extends incoming SDA low to high transition while SCL is
		  high but it appears to help also above issue.
		
		  The enable status register may be unimplemented, but
		  in that case this test reads zero and exits the loop.
		
		  Wait 10 times the signaling period of the highest I2C
		  transfer supported by the driver (for 400KHz this is
		  25us) as described in the DesignWare I2C databook.
	
	  Clock is not necessary if we got LCNTHCNT values directly from
	  the platform code.
 Optional interface clock 
  Waiting for bus not busy
 wrong msgs[] data 
	
	  Try to detect the FIFO depth if not set by interface driver,
	  the depth could be from 2 to 256 from HW spec.
 Disable controller 
 Disable all interrupts 
 SPDX-License-Identifier: GPL-2.0-or-later
   i2c-pca-isa.c driver for PCA9564 on ISA boards
     Copyright (C) 2004 Arcom Control Systems
     Copyright (C) 2008 Pengutronix
 Data sheet recommends 59kHz for 100kHz operation due to variation
 Do polling 
 apparently only an external reset will do it. not a lot can be done 
 .data intentionally left NULL, not needed with ISA 
  CBUS I2C driver for Nokia Internet Tablets.
  Copyright (C) 2004-2010 Nokia Corporation
  Based on code written by Juha Yrjölä, David Weinehall, Mikko Ylinen and
  Felipe Balbi. Converted to I2C driver by Aaro Koskinen.
  This file is subject to the terms and conditions of the GNU General
  Public License. See the file "COPYING" in the main directory of this
  archive for more details.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
  Bit counts are derived from Nokia implementation. These should be checked
  if other CBUS implementations appear.
 host lock 
  cbus_send_bit - sends one bit over the bus
  @host: the host we're using
  @bit: one bit of information to send
  cbus_send_data - sends @len amount of data over the bus
  @host: the host we're using
  @data: the data to send
  @len: size of the transfer
  cbus_receive_bit - receives one bit from the bus
  @host: the host we're using
  cbus_receive_word - receives 16-bit word from the bus
  @host: the host we're using
  cbus_transfer - transfers data over the bus
  @host: the host we're using
  @rw: readwrite flag
  @dev: device address
  @reg: register address
  @data: if @rw == I2C_SBUS_WRITE data to send otherwise 0
 We don't want interrupts disturbing our transfer 
 Reset state and start of transfer, SEL stays down during transfer 
 Set the DAT pin to output 
 Send the device address 
 Send the rw flag 
 Send the register address 
 Indicate end of transfer, SEL goes up until next transfer 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2000  Frodo Looijaard <frodol@dds.nl>,
                       Philip Edelbrock <phil@netroedge.com>,
                       Mark D. Studebaker <mdsxyz123@yahoo.com>,
                       Dan Eaton <dan.eaton@rocketlogix.com> and
                       Stephen Rousset <stephen.rousset@rocketlogix.com>
    This is the driver for the SMB Host controller on
    Acer Labs Inc. (ALI) M1535 South Bridge.
    The M1535 is a South bridge for portable systems.
    It is very similar to the M15x3 South bridges also produced
    by Acer Labs Inc.  Some of the registers within the part
    have moved and some have been redefined slightly. Additionally,
    the sequencing of the SMBus transactions has been modified
    to be more consistent with the sequencing recommended by
    the manufacturer and observed through testing.  These
    changes are reflected in this driver and can be identified
    by comparing this driver to the i2c-ali15x3 driver.
    For an overview of these chips see http:www.acerlabs.com
    The SMB controller is part of the 7101 device, which is an
    ACPI-compliant Power Management Unit (PMU).
    The whole 7101 device has to be enabled for the SMB to work.
    You can't just enable the SMB alone.
    The SMB and the ACPI have separate IO spaces.
    We make sure that the SMB is enabled. We leave the ACPI alone.
    This driver controls the SMB Host only.
    This driver does not use interrupts.
 Note: we assume there can only be one ALI1535, with one SMBus interface 
 ALI1535 SMBus address offsets 
 PCI Address Constants 
 Other settings 
 times 1100 sec 
 ALI1535 address lock bits 
 dwe 
 ALI1535 command constants 
 Enable 10-bit addressing in	
  I2C read			
 Time-out Command (write)	
 Bit 9 of 10-bit address in	
 Alert-Response-Address	
 (read)			
 Kill Command (write)		
 Bit 8 of 10-bit address in	
  Alert-Response-Address	
  (read)			
 Mask for isolating bits 9-8	
  of 10-bit address in I2C	
  Read Command		
 ALI1535 status register bits 
 host busy 
 transaction complete 
 device error 
 bus error    
 failed bus transaction 
 all the bad error bits 
 reset block data index 
 ALI1535 device address register bits 
 ReadWrite Bit in Device	
  Address field		
  -> Write = 0		
  -> Read  = 1		
 SMB IO Space enable		
 Detect whether a ALI1535 can be found, and initialize it, where necessary.
   Note the differences between kernels with the old PCI BIOS interface and
   newer kernels with the real PCI interface. In compat.h some things are
	 Check the following things:
		- SMB IO address is initialized
		- Device is enabled
		- We can use the addresses
 Determine the address of the SMBus area 
 check if whole device is enabled 
 Is SMB Host controller enabled? 
 set SMB clock to 74KHz as recommended in data sheet 
	
	  The interrupt routing for SMB is set up in register 0x77 in the
	  1533 ISA Bridge device, NOT in the 7101 device.
	  Don't bother with finding the 1533 device and reading the register.
	if ((....... & 0x0F) == 1)
		dev_dbg(&dev->dev, "ALI1535 using Interrupt 9 for SMBus.\n");
 get status 
 Make sure the SMBus host is ready to start transmitting 
 Check the busy bit first 
		 If the host controller is still busy, it may have timed out
		  in the previous transaction, resulting in a "SMBus Timeout"
		  printk.  I've tried the following to reset a stuck busy bit.
		    1. Reset the controller with an KILL command. (this
		       doesn't seem to clear the controller if an external
		       device is hung)
		    2. Reset the controller and the other SMBus devices with a
		       T_OUT command. (this clears the host busy bit if an
		       external device is hung, but it comes back upon a new
		       access to a device)
		    3. Disable and reenable the controller in SMBHSTCFG. Worst
		       case, nothing seems to work except power reset.
		 Try resetting entire SMB bus, including other devices - This
		  may not work either - it clears the BUSY bit but then the
		  BUSY bit may come back on when you try and use the chip
		  again.  If that's the case you are stuck.
 now check the error bits and the busy bit 
 do a clear-on-write 
			 This is probably going to be correctable only by a
			  power reset as one of the bits now appears to be
 This may be a bus or device with electrical problems. 
 check and clear done bit 
 start the transaction by writing anything to the start register 
 We will always wait for a fraction of a second! 
 If the SMBus is still busy, we give up 
	 Unfortunately the ALI SMB controller maps "no response" and "bus
	  collision" into a single bit. No response is the usual case so don't
	  do a printk.  This means that bus collisions go unreported.
 haven't ever seen this 
 check to see if the "command complete" indication is set 
 take consequent actions for error conditions 
 issue "kill" to reset host controller 
 issue "timeout" to reset all devices on bus 
 Return negative errno on error. 
 make sure SMBus is idle 
 clear status register (clear-on-write) 
 output command 
 output command 
 output command 
 output command 
 output command 
 Reset SMBBLKDAT 
 Result put in SMBHSTDAT0 
 Reset SMBBLKDAT 
 set up the sysfs linkage to our parent device 
	
	  do not call pci_disable_device(dev) since it can cause hard hangs on
	  some systems during power-off
 SPDX-License-Identifier: GPL-2.0-only
  I2C bus driver for Amlogic Meson SoCs
  Copyright (C) 2014 Beniamino Galvani <b.galvani@gmail.com>
 Meson I2C register map 
 Control register fields 
  struct meson_i2c - Meson I2C device private data
  @adap:	I2C adapter instance
  @dev:	Pointer to device structure
  @regs:	Base address of the device memory mapped registers
  @clk:	Pointer to clock structure
  @msg:	Pointer to the current I2C message
  @state:	Current state in the driver state machine
  @last:	Flag set for the last message in the transfer
  @count:	Number of bytes to be sentreceived in current transfer
  @pos:	Current position in the sendreceive buffer
  @error:	Flag set when an error is received
  @lock:	To avoid race conditions between irq handler and xfer code
  @done:	Completion used to wait for transfer termination
  @tokens:	Sequence of tokens to be written to the device
  @num_tokens:	Number of tokens
  @data:	Pointer to the controlller's platform data
 clock divider has 12 bits 
 Disable HIGHLOW mode 
		
		  The bit is set when the IGNORE_NAK bit is cleared
		  and the device didn't respond. In this case, the
		  I2C controller automatically generates a STOP
		  condition.
 Restart the processing 
 Start the transfer 
	
	  Protect access to i2c struct and registers from interrupt
	  handlers triggered by a transfer terminated after the
	  timeout period
 Abort any active operation 
	
	  A transfer is triggered when START bit changes from 0 to 1.
	  Ensure that the bit is set to 0 after probe
 Disable filtering 
 SPDX-License-Identifier: GPL-2.0-or-later
   Nano River Technologies viperboard i2c master driver
   (C) 2012 by Lemonage GmbH
   Author: Lars Poeschel <poeschel@lemonage.de>
   All rights reserved.
 i2c bus frequency module parameter 
 check for protocol error 
 send the read request 
 read the actual data 
 first read transfer 
 copy the received data 
 second read transfer if neccessary 
 copy the received data 
 directly send the message 
 read data 
 send the addr and len, we're interested to board 
 in case of protocol error, return the error 
 write data 
 send the addr, the data goes to to board 
 This is the actual algorithm we define 
 setup i2c adapter description 
 save the param in usb capabable memory 
 setting the bus frequency 
 attach to i2c layer 
 SPDX-License-Identifier: GPL-2.0
  i2c-ocores.c: I2C bus driver for OpenCores I2C controller
  (https:opencores.orgprojecti2coverview)
  Peter Korsgaard <peter@korsgaard.com>
  Support for the GRLIB port of the controller by
  Andreas Larsson <andreas@gaisler.com>
  'process_lock' exists because ocores_process() and ocores_process_timeout()
  can't run in parallel.
 see STATE_ 
 registers 
 write only 
 read only, same address as OCI2C_CMD 
 Broken IRQ for FU540-C000 SoC 
	
	  If we spin here is because we are in timeout, so we are going
	  to be in STATE_ERROR. See ocores_process_timeout()
 stop has been sent 
 error? 
 end of msg? 
 end? 
 send start? 
  ocores_process_timeout() - Process timeout event
  @i2c: ocores I2C device instance
  ocores_wait() - Wait until something change in a given register
  @i2c: ocores I2C device instance
  @reg: register to query
  @mask: bitmask to apply on register value
  @val: expected result
  @timeout: timeout in jiffies
  Timeout is necessary to avoid to stay here forever when the chip
  does not answer correctly.
  Return: 0 on success, -ETIMEDOUT on timeout
  ocores_poll_wait() - Wait until is possible to process some data
  @i2c: ocores I2C device instance
  Used when the device is in polling mode (interrupts disabled).
  Return: 0 on success, -ETIMEDOUT on timeout
 transfer is over 
 on going transfer 
		
		  We wait for the data to be transferred (8bit),
		  then we start polling on the ACKNACK bit
	
	  once we are here we expect to get the expected result immediately
	  so if after 1ms we timeout then something is broken.
  ocores_process_polling() - It handles an IRQ-less transfer
  @i2c: ocores I2C device instance
  Even if IRQ are disabled, the I2C OpenCore IP behavior is exactly the same
  (only that IRQ are not produced). This means that we can re-use entirely
  ocores_isr(), we just add our polling code around it.
  It can run in atomic context
 timeout 
 all messages have been transferred 
 make sure the device is disabled 
 Init the device 
  Read and write functions for the GRLIB port of the controller. Registers are
  32-bit big endian and the PRELOW and PREHIGH registers are merged into one
  register. The subsequent registers have their offsets decreased accordingly.
 no 'reg-shift', check for deprecated 'regstep' 
 Set to default value 
	
	  Since the SoC does have an interrupt, its DT has an interrupt
	  property - But this should be bypassed as the IRQ logic in this
	  SoC is broken.
 hook up driver to tree 
 add i2c adapter to i2c tree 
 add in known devices to the bus 
 disable i2c logic 
 remove adapter & data 
 make sure the device is disabled 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2012 FUJITSU SEMICONDUCTOR LIMITED
 I2C register address definitions 
 Bus Status
 Bus Control
 Clock Control
 Address
 Data
 Expansion CS
 Bus Clock Freq
 Bus Control 2
 I2C register bit definitions 
 First Byte Transfer
 General Call Address
 Address as Slave
 TransferReceive
 Last Received Bit
 Arbitration Lost
 Repeated Start Cond.
 Bus Busy
 Interrupt
 Interrupt Enable
 Gen. Call Access Ack.
 Acknowledge
 Master Slave Select
 Start Condition Cont.
 Bus Error Int Enable
 Bus Error
 CCR Clock Period Sel.
 Enable
 Speed Mode Select
 CSR Clock Period Sel.
 SCL Low Drive
 SDA Low Drive
 SCL Status
 SDA Status
 PCLK frequency 
 STANDARD MODE frequency 
 FAST MODE frequency 
 (clkrate <= 18000000) 
 calculate the value of CS bits in CCR register on standard mode 
 calculate the value of CS bits in CSR register on standard mode 
 calculate the value of CS bits in CCR register on fast mode 
 calculate the value of CS bits in CSR register on fast mode 
 (clkrate > 18000000) 
 calculate the value of CS bits in CCR register on standard mode 
 calculate the value of CS bits in CSR register on standard mode 
 calculate the value of CS bits in CCR register on fast mode 
 calculate the value of CS bits in CSR register on fast mode 
 min I2C clock frequency 14M 
 max I2C clock frequency 200M 
 I2C clock frequency 18M 
 Fast Mode
 Standard Mode
	
	  clear IRQ (INT=0, BER=0)
	  set Stop Condition (MSS=0)
	  Interrupt Disable
 Set own Address 
 Set PCLK frequency 
 Set Clock and enable, Set fast mode 
 Set Clock and enable, Set standard mode 
 clear IRQ (INT=0, BER=0), Interrupt Disable 
 Disable clock 
 Generate Start Condition 
 Bus is busy 
 Start Condition + Enable Interrupts 
 get BSR & BCR registers 
 wait 2 clock periods to ensure the stop has been through the bus 
 clear IRQ, and continue 
 send the new start 
 data 
 address 
 last message, send stop and complete 
 sentinel  }
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
    Copyright (c) 1998 - 2002  Frodo Looijaard <frodol@dds.nl>,
    Philip Edelbrock <phil@netroedge.com>, and Mark D. Studebaker
    <mdsxyz123@yahoo.com>
    Copyright (C) 2007 - 2014  Jean Delvare <jdelvare@suse.de>
    Copyright (C) 2010         Intel Corporation,
                               David Woodhouse <dwmw2@infradead.org>
  Supports the following Intel IO Controller Hubs (ICH):
 					IO			Block	I2C
 					region	SMBus	Block	proc.	block
  Chip name			PCI ID	size	PEC	buffer	call	read
  ---------------------------------------------------------------------------
  82801AA (ICH)		0x2413	16	no	no	no	no
  82801AB (ICH0)		0x2423	16	no	no	no	no
  82801BA (ICH2)		0x2443	16	no	no	no	no
  82801CA (ICH3)		0x2483	32	soft	no	no	no
  82801DB (ICH4)		0x24c3	32	hard	yes	no	no
  82801E (ICH5)		0x24d3	32	hard	yes	yes	yes
  6300ESB			0x25a4	32	hard	yes	yes	yes
  82801F (ICH6)		0x266a	32	hard	yes	yes	yes
  6310ESB6320ESB		0x269b	32	hard	yes	yes	yes
  82801G (ICH7)		0x27da	32	hard	yes	yes	yes
  82801H (ICH8)		0x283e	32	hard	yes	yes	yes
  82801I (ICH9)		0x2930	32	hard	yes	yes	yes
  EP80579 (Tolapai)		0x5032	32	hard	yes	yes	yes
  ICH10			0x3a30	32	hard	yes	yes	yes
  ICH10			0x3a60	32	hard	yes	yes	yes
  53400 Series (PCH)		0x3b30	32	hard	yes	yes	yes
  6 Series (PCH)		0x1c22	32	hard	yes	yes	yes
  Patsburg (PCH)		0x1d22	32	hard	yes	yes	yes
  Patsburg (PCH) IDF		0x1d70	32	hard	yes	yes	yes
  Patsburg (PCH) IDF		0x1d71	32	hard	yes	yes	yes
  Patsburg (PCH) IDF		0x1d72	32	hard	yes	yes	yes
  DH89xxCC (PCH)		0x2330	32	hard	yes	yes	yes
  Panther Point (PCH)		0x1e22	32	hard	yes	yes	yes
  Lynx Point (PCH)		0x8c22	32	hard	yes	yes	yes
  Lynx Point-LP (PCH)		0x9c22	32	hard	yes	yes	yes
  Avoton (SOC)			0x1f3c	32	hard	yes	yes	yes
  Wellsburg (PCH)		0x8d22	32	hard	yes	yes	yes
  Wellsburg (PCH) MS		0x8d7d	32	hard	yes	yes	yes
  Wellsburg (PCH) MS		0x8d7e	32	hard	yes	yes	yes
  Wellsburg (PCH) MS		0x8d7f	32	hard	yes	yes	yes
  Coleto Creek (PCH)		0x23b0	32	hard	yes	yes	yes
  Wildcat Point (PCH)		0x8ca2	32	hard	yes	yes	yes
  Wildcat Point-LP (PCH)	0x9ca2	32	hard	yes	yes	yes
  BayTrail (SOC)		0x0f12	32	hard	yes	yes	yes
  Braswell (SOC)		0x2292	32	hard	yes	yes	yes
  Sunrise Point-H (PCH) 	0xa123  32	hard	yes	yes	yes
  Sunrise Point-LP (PCH)	0x9d23	32	hard	yes	yes	yes
  DNV (SOC)			0x19df	32	hard	yes	yes	yes
  Emmitsburg (PCH)		0x1bc9	32	hard	yes	yes	yes
  Broxton (SOC)		0x5ad4	32	hard	yes	yes	yes
  Lewisburg (PCH)		0xa1a3	32	hard	yes	yes	yes
  Lewisburg Supersku (PCH)	0xa223	32	hard	yes	yes	yes
  Kaby Lake PCH-H (PCH)	0xa2a3	32	hard	yes	yes	yes
  Gemini Lake (SOC)		0x31d4	32	hard	yes	yes	yes
  Cannon Lake-H (PCH)		0xa323	32	hard	yes	yes	yes
  Cannon Lake-LP (PCH)		0x9da3	32	hard	yes	yes	yes
  Cedar Fork (PCH)		0x18df	32	hard	yes	yes	yes
  Ice Lake-LP (PCH)		0x34a3	32	hard	yes	yes	yes
  Ice Lake-N (PCH)		0x38a3	32	hard	yes	yes	yes
  Comet Lake (PCH)		0x02a3	32	hard	yes	yes	yes
  Comet Lake-H (PCH)		0x06a3	32	hard	yes	yes	yes
  Elkhart Lake (PCH)		0x4b23	32	hard	yes	yes	yes
  Tiger Lake-LP (PCH)		0xa0a3	32	hard	yes	yes	yes
  Tiger Lake-H (PCH)		0x43a3	32	hard	yes	yes	yes
  Jasper Lake (SOC)		0x4da3	32	hard	yes	yes	yes
  Comet Lake-V (PCH)		0xa3a3	32	hard	yes	yes	yes
  Alder Lake-S (PCH)		0x7aa3	32	hard	yes	yes	yes
  Alder Lake-P (PCH)		0x51a3	32	hard	yes	yes	yes
  Alder Lake-M (PCH)		0x54a3	32	hard	yes	yes	yes
  Features supported by this driver:
  Software PEC				no
  Hardware PEC				yes
  Block buffer				yes
  Block process call transaction	yes
  I2C block read transaction		yes (doesn't use the block buffer)
  Slave mode				no
  SMBus Host Notify			yes
  Interrupt processing			yes
  See the file Documentationi2cbussesi2c-i801.rst for details.
 I801 SMBus address offsets 
 ICH3 and later 
 ICH4 and later 
 ICH4 and later 
 ICH3 and later 
 ICH3 and later 
 ICH3 and later 
 PCI Address Constants 
 Host configuration bits for SMBHSTCFG 
 TCO configuration bits for TCOCTL 
 Auxiliary status register bits, ICH4+ only 
 Auxiliary control register bits, ICH4+ only 
 I801 command constants 
 unimplemented 
 ICH5 and later 
 I801 Host Control register bits 
 ICH3 and later 
 I801 Hosts Status register bits 
 Host Notify Status register bits 
 Host Notify Command register bits 
 Older devices have their ID defined in <linuxpci_ids.h> 
 Patsburg also has three 'Integrated Device Function' SMBus controllers 
 Relative to gpio_chip->base 
 isr processing 
 Command state used by isr for byte-by-byte block transactions 
	
	  If set to true the host controller registers are reserved for
	  ACPI AML use. Protected by acpi_lock.
 Not really a feature, but it's convenient to handle it as such 
 Make sure the SMBus host is ready to start transmitting.
	
	  Clear CRC status if needed.
	  During normal operation, i801_check_post() takes care
	  of it after every operation.  We do it here only in case
	  the hardware was already in this state when the driver
	  started.
  Convert the status register to an error code, and clear it.
  Note that status only contains the bits we want to clear, not the
  actual register value.
	
	  If the SMBus is still busy, we give up
	  Note: This timeout condition only happens when using polling
	  transactions.  For interrupt operation, NAKtimeout is indicated by
	  DEV_ERR.
 try to stop the current command 
 Check if it worked 
		
		  This may be a PEC error, check and clear it.
		 
		  AUXSTS is handled differently from HSTSTS.
		  For HSTSTS, i801_isr() or i801_wait_intr()
		  has already cleared the error bits in hardware,
		  and we are passed a copy of the original value
		  in "status".
		  For AUXSTS, the hardware register is left
		  for us to handle here.
		  This is asymmetric, slightly iffy, but safe,
		  since all this code is serialized and the CRCE
		  bit is harmless as long as it's cleared before
		  the next operation.
 Clear status flags except BYTE_DONE, to be cleared by caller 
 Wait for BUSY being cleared and either INTR or an error flag being set 
 Wait for either BYTE_DONE or an error flag being set 
	 the current contents of SMBHSTCNT can be overwritten, since PEC,
 reset the data buffer index 
 Use 32-byte buffer to process this transaction 
 For SMBus block reads, length is received with first byte 
 FIXME: Recover 
 Read next byte 
 Set LAST_BYTE for last byte of read transaction 
 Write next byte, except for IRQ after last byte 
 Clear BYTE_DONE to continue with next byte 
	
	  With the tested platforms, reading SMBNTFDDAT (22 + (p)->smba)
	  always returns 0. Our current implementation doesn't provide
	  data, so we just ignore it.
 clear Host Notify bit and return 
  There are three kinds of interrupts:
  1) i801 signals transaction completion with one of these interrupts:
       INTR - Success
       DEV_ERR - Invalid command, NAK or communication timeout
       BUS_ERR - SMI# transaction collision
       FAILED - transaction was canceled due to a KILL request
     When any of these occur, update ->status and signal completion.
     ->status must be cleared before kicking off the next transaction.
  2) For byte-by-byte (I2C readwrite) transactions, one BYTE_DONE interrupt
     occurs for each byte of a byte-by-byte to prepare the next byte.
  3) Host Notify interrupts
 Confirm this is our interrupt 
	
	  Clear irq sources and report transaction result.
	  ->status must be cleared before the next transaction is started.
  For "byte-by-byte" block transactions:
    I2C write uses cmd=I801_BLOCK_DATA, I2C_EN=1
    I2C read uses cmd=I801_I2C_BLOCK_DATA
 Recover 
 Retrievestore value in SMBBLKDAT 
 signals SMBBLKDAT ready 
 Block transaction function 
 set I2C_EN bit in configuration register 
 max for SMBus block reads 
	 Experience has shown that the block buffer can only be used for
	   SMBus (not I2C) block transactions, even though the datasheet
 restore saved configuration register value 
 Return negative errno on error. 
		
		  NB: page 240 of ICH5 datasheet shows that the R#W
		  bit should be cleared here, even when reading.
		  However if SPD Write Disable is set (Lynx Point and later),
		  the read will fail if we don't set the R#W bit.
			 NB: page 240 of ICH5 datasheet also shows
		
		  Bit 0 of the slave address register always indicate a write
		  command.
 enabledisable hardware PEC 
	 Some BIOSes don't like it when PEC is enabled at reboot or resume
	   time, so we forcibly disable it after every transaction. Turn off
 Result put in SMBHSTDAT0 
 Unlock the SMBus device for use by BIOSACPI 
 clear Host Notify bit to allow a new notification 
 Scan the system ROM for the signature "FJKEYINF" 
 Can't fail 
 just use the first address 
 & ~0x80, ignore enableddisabled bit 
 We use our own function to check for onboard devices instead of
   dmi_find_device() as some buggy BIOS's have the devices we are interested
 Bogus string reference 
 NOTE: Keep this list in sync with driversplatformx86dell-smo8800.c 
	
	  Check that ACPI device SMO88xx is present and is functioning.
	  Function acpi_get_devices() already filters all ACPI devices
	  which are not present or are not functioning.
	  ACPI device SMO88xx represents our ST microelectronics lis3lv02d
	  accelerometer but unfortunately ACPI does not provide any other
	  information (like I2C address).
  Accelerometer's I2C address is not specified in DMI nor ACPI,
  so it is needed to define mapping table based on DMI product names.
	
	  Dell platform team told us that these Latitude devices have
	  ST microelectronics accelerometer at I2C address 0x29.
	
	  Additional individual entries were added after verification.
 Register optional slaves 
 Only register slaves on main SMBus channel 
 Instantiate SPD EEPROMs unless the SMBus is multiplexed 
 CONFIG_X86 && CONFIG_DMI 
 Setup multiplexing if needed 
 Prepare the platform data 
 Register GPIO descriptor lookup table 
	
	  Register the mux device, we use PLATFORM_DEVID_NONE here
	  because since we are referring to the GPIO chip by name we are
	  anyways in deep trouble if there is more than one of these
	  devices, and there should likely only be one platform controller
	  hub.
 Remove branch classes from trunk 
 Remember for later 
	
	  We must access the NO_REBOOT bit over the Primary to Sideband
	  bridge (P2SB). The BIOS prevents the P2SB device from being
	  enumerated by the PCI subsystem, so we need to unhidehide it
	  to lookup the P2SB BAR.
 Unhide the P2SB device, if it is hidden 
 Hide the P2SB device, if it was hidden before 
 If we have ACPI based watchdog use that instead 
	
	  Always populate the main iTCO IO resource here. The second entry
	  for NO_REBOOT MMIO is filled by the SPT specific function.
	
	  Once BIOS AML code touches the OpRegion we warn and inhibit any
	  further access from the driver itself. This device is now owned
	  by the system firmware.
		
		  BIOS is accessing the host controller so prevent it from
		  suspending automatically from now on.
 SMBus timing 
 Disable features on user request 
 Determine the address of the SMBus area 
 Disable SMBus interrupt feature if SMBus using SMI# 
 Clear special mode bits 
 Remember original Host Notify setting 
 Default timeout in interrupt mode: 200 ms 
 Complain if an interrupt is already pending 
 We ignore errors - multiplexing is optional 
 if acpi_reserved is set then usage_count is incremented already 
	
	  do not call pci_disable_device(dev) since it can cause hard hangs on
	  some systems during power-off (eg. Fujitsu-Siemens Lifebook E8010)
 Restore config registers to avoid hard hang on some systems 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2013 STMicroelectronics
  I2C master mode controller driver, used in STMicroelectronics devices.
  Author: Maxime Coquelin <maxime.coquelin@st.com>
 SSC registers 
 SSC Control 
 SSC Interrupt Enable 
 SSC Status 
 SSC I2C Control 
 SSC Tx FIFO Status 
 SSC Rx FIFO Status 
 SSC Clear bit operation 
 SSC Clock Prescaler 
  struct st_i2c_timings - per-Mode tuning parameters
  @rate: I2C bus rate
  @rep_start_hold: I2C repeated start hold time requirement
  @rep_start_setup: I2C repeated start set up time requirement
  @start_hold: I2C start hold time requirement
  @data_setup_time: I2C data set up time requirement
  @stop_setup_time: I2C stop set up time requirement
  @bus_free_time: I2C bus free time requirement
  @sda_pulse_min_limit: I2C SDA pulse mini width limit
  struct st_i2c_client - client specific data
  @addr: 8-bit slave addr, including rw bit
  @count: number of bytes to be transfered
  @xfered: number of bytes already transferred
  @buf: data buffer
  @result: result of the transfer
  @stop: last I2C msg to be sent, i.e. STOP to be generated
  struct st_i2c_dev - private data of the controller
  @adap: I2C adapter for this controller
  @dev: device for this controller
  @base: virtual memory area
  @complete: completion of I2C message
  @irq: interrupt line for th controller
  @clk: hw ssc block clock
  @mode: I2C mode of the controller. Standard or Fast only supported
  @scl_min_width_us: SCL line minimum pulse width in us
  @sda_min_width_us: SDA line minimum pulse width in us
  @client: I2C transfert information
  @busy: I2C transfer on-going
  From I2C Specifications v0.5.
  All the values below have +10% margin added to be
  compatible with some out-of-spec devices,
  like HDMI link of the Toshiba 19AV600 TV.
	
	  Counter only counts up to 7 but fifo size is 8...
	  When fifo is full, counter is 0 and RIR bit of status register is
	  set
	
	  FIFO needs to be emptied before reseting the IP,
	  else the controller raises a BUSY error.
  st_i2c_hw_config() - Prepare SSC block, calculate and apply tuning timings
  @i2c_dev: Controller's private data
 SSC Control register setup 
 Baudrate 
 Pre-scaler baudrate 
 Enable I2C mode 
 Repeated start hold time 
 Repeated start set up time 
 Start hold time 
 Data set up time 
 Stop set up time 
 Bus free time 
 Prescalers set up 
 Noise suppression witdh 
 Noise suppression max output data delay width 
	
	  SSP IP is dual role SPII2C to generate 9 clock pulses
	  we switch to SPI node, 9 bit words and write a 0. This
	  has been validate with a oscilloscope and is easier
	  than switching to GPIO mode.
 Disable interrupts 
  st_i2c_write_tx_fifo() - Write a byte in the Tx FIFO
  @i2c_dev: Controller's private data
  @byte: Data to write in the Tx FIFO
  st_i2c_wr_fill_tx_fifo() - Fill the Tx FIFO in write mode
  @i2c_dev: Controller's private data
  This functions fills the Tx FIFO with I2C transfert buffer when
  in write mode.
  st_i2c_rd_fill_tx_fifo() - Fill the Tx FIFO in read mode
  @i2c_dev: Controller's private data
  @max: Maximum amount of data to fill into the Tx FIFO
  This functions fills the Tx FIFO with fixed pattern when
  in read mode to trigger clock.
  st_i2c_terminate_xfer() - Send either STOP or REPSTART condition
  @i2c_dev: Controller's private data
  st_i2c_handle_write() - Handle FIFO empty interrupt in case of write
  @i2c_dev: Controller's private data
 End of xfer, send stop or repstart 
  st_i2c_handle_read() - Handle FIFO empty interrupt in case of read
  @i2c_dev: Controller's private data
 Trash the address read back 
 End of xfer, send stop or repstart 
 Penultimate byte to xfer, disable ACK gen. 
 Last received byte is to be handled by NACK interrupt 
  st_i2c_isr_thread() - Interrupt routine
  @irq: interrupt number
  @data: Controller's private data
 Use __fls() to check error bits first 
 Last received byte handled by NACK interrupt 
	
	  Read IEN register to ensure interrupt mask write is effective
	  before re-enabling interrupt at GIC level, and thus avoid spurious
	  interrupts.
  st_i2c_xfer_msg() - Transfer a single I2C message
  @i2c_dev: Controller's private data
  @msg: I2C message to transfer
  @is_first: first message of the sequence
  @is_last: last message of the sequence
 Write slave address 
 Pre-fill Tx fifo with data in case of write 
  st_i2c_xfer() - Transfer a single I2C message
  @i2c_adap: Adapter pointer to the controller
  @msgs: Pointer to data to be written.
  @num: Number of messages to be executed
 Go in idle state if available 
 In case idle state available, select it 
  P2WI (Push-Pull Two Wire Interface) bus driver.
  Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
  This file is licensed under the terms of the GNU General Public License
  version 2.  This program is licensed "as is" without any warranty of any
  kind, whether express or implied.
  The P2WI controller looks like an SMBus controller which only supports byte
  data transfers. But, it differs from standard SMBus protocol on several
  aspects:
  - it supports only one slave device, and thus drop the address field
  - it adds a parity bit every 8bits of data
  - only one read access is required to read a byte (instead of a write
    followed by a read access in standard SMBus protocol)
  - there's no Ack bit after each byte transfer
  This means this bus cannot be used to interface with standard SMBus
  devices (the only known device to support this interface is the AXP221
  PMIC).
 P2WI registers 
 CTRL fields 
 CLK CTRL fields 
 STATUS fields 
 DATA LENGTH fields
 LINE CTRL fields
 PMU MODE CTRL fields 
 Clear interrupts 
	
	  Authorize a p2wi node without any children to be able to use an
	  i2c-dev from userpace.
	  In this case the slave_addr is set to -1 and won't be checked when
	  launching a P2WI transfer.
 SPDX-License-Identifier: GPL-2.0-only
   i2c-versatile.c
   Copyright (C) 2006 ARM Ltd.
   written by Russell King, Deep Blue Solutions Ltd.
 SPDX-License-Identifier: GPL-2.0
  driversi2cbussesi2c-tegra.c
  Copyright (C) 2010 Google, Inc.
  Author: Colin Cross <ccross@android.com>
 configuration load timeout in microseconds 
 packet header size in bytes 
  I2C Controller will use PIO mode for transfers up to 32 bytes in order to
  avoid DMA overhead, otherwise external APB DMA controller will be used.
  Note that the actual MAX PIO length is 20 bytes because 32 bytes include
  I2C_PACKET_HEADER_SIZE.
  msg_end_type: The bus control which needs to be sent at end of transfer.
  @MSG_END_STOP: Send stop pulse.
  @MSG_END_REPEAT_START: Send repeat-start.
  @MSG_END_CONTINUE: Don't send stop or repeat-start.
  struct tegra_i2c_hw_feature : per hardware generation features
  @has_continue_xfer_support: continue-transfer supported
  @has_per_pkt_xfer_complete_irq: Has enabledisable capability for transfer
 		completion interrupt on per packet basis.
  @has_config_load_reg: Has the config load register to load the new
 		configuration.
  @clk_divisor_hs_mode: Clock divisor in HS mode.
  @clk_divisor_std_mode: Clock divisor in standard mode. It is
 		applicable if there is no fast clock source i.e. single clock
 		source.
  @clk_divisor_fast_mode: Clock divisor in fast mode. It is
 		applicable if there is no fast clock source i.e. single clock
 		source.
  @clk_divisor_fast_plus_mode: Clock divisor in fast mode plus. It is
 		applicable if there is no fast clock source (i.e. single
 		clock source).
  @has_multi_master_mode: The I2C controller supports running in single-master
 		or multi-master mode.
  @has_slcg_override_reg: The I2C controller supports a register that
 		overrides the second level clock gating.
  @has_mst_fifo: The I2C controller contains the new MST FIFO interface that
 		provides additional features and allows for longer messages to
 		be transferred in one go.
  @quirks: I2C adapter quirks for limiting writeread transfer size and not
 		allowing 0 length transfers.
  @supports_bus_clear: Bus Clear support to recover from bus hang during
 		SDA stuck low from device for some unknown reasons.
  @has_apb_dma: Support of APBDMA on corresponding Tegra chip.
  @tlow_std_mode: Low period of the clock in standard mode.
  @thigh_std_mode: High period of the clock in standard mode.
  @tlow_fast_fastplus_mode: Low period of the clock in fastfast-plus modes.
  @thigh_fast_fastplus_mode: High period of the clock in fastfast-plus modes.
  @setup_hold_time_std_mode: Setup and hold time for start and stop conditions
 		in standard mode.
  @setup_hold_time_fast_fast_plus_mode: Setup and hold time for start and stop
 		conditions in fastfast-plus modes.
  @setup_hold_time_hs_mode: Setup and hold time for start and stop conditions
 		in HS mode.
  @has_interface_timing_reg: Has interface timing register to program the tuned
 		timing settings.
  struct tegra_i2c_dev - per device I2C context
  @dev: device reference for power management
  @hw: Tegra I2C HW feature
  @adapter: core I2C layer adapter information
  @div_clk: clock reference for div clock of I2C controller
  @clocks: array of I2C controller clocks
  @nclocks: number of clocks in the array
  @rst: reset control for the I2C controller
  @base: ioremapped registers cookie
  @base_phys: physical base address of the I2C controller
  @cont_id: I2C controller ID, used for packet header
  @irq: IRQ number of transfer complete interrupt
  @is_dvc: identifies the DVC I2C controller, has a different register layout
  @is_vi: identifies the VI I2C controller, has a different register layout
  @msg_complete: transfer completion notifier
  @msg_err: error code for completed message
  @msg_buf: pointer to current message data
  @msg_buf_remaining: size of unsent data in the message buffer
  @msg_read: indicates that the transfer is a read access
  @bus_clk_rate: current I2C bus clock rate
  @multimaster_mode: indicates that I2C controller is in multi-master mode
  @tx_dma_chan: DMA transmit channel
  @rx_dma_chan: DMA receive channel
  @dma_phys: handle to DMA resources
  @dma_buf: pointer to allocated DMA buffer
  @dma_buf_size: DMA buffer size
  @dma_mode: indicates active DMA transfer
  @dma_complete: DMA completion notifier
  @atomic_mode: indicates active atomic transfer
  If necessary, i2c_writel() and i2c_readl() will offset the register
  in order to talk to the I2C block inside the DVC block.
 read back register to make sure that register writes completed 
	
	  VI I2C controller has known hardware bug where writes get stuck
	  when immediate multiple writes happen to TX_FIFO register.
	  Recommended software work around is to read I2C register after
	  each write to TX_FIFO register to flush out the data.
  One of the Tegra I2C blocks is inside the DVC (Digital Voltage Controller)
  block.  This block is identical to the rest of the I2C blocks, except that
  it only supports master mode, it has registers moved around, and it needs
  some extra init to get it into I2C mode.  The register moves are handled
  by i2c_readl() and i2c_writel().
	
	  The reset shouldn't ever fail in practice. The failure will be a
	  sign of a severe problem that needs to be resolved. Still we don't
	  want to fail the initialization completely because this may break
	  kernel boot up since voltage regulators use I2C. Hence, we will
	  emit a noisy warning on error, which won't stay unnoticed and
	  won't hose machine entirely.
 make sure clock divisor programmed correctly 
	
	  Configure setup and hold times only when tsu_thd is non-zero.
	  Otherwise, preserve the chip default values.
	
	  NACK interrupt is generated before the I2C controller generates
	  the STOP condition on the bus.  So, wait for 2 clock periods
	  before disabling the controller so that the STOP condition has
	  been delivered properly.
	
	  Catch overflow due to message fully sent before the check for
	  RX FIFO availability.
 round down to exclude partial word at the end of buffer 
	
	  If there is a partial word at the end of buffer, handle it
	  manually to prevent overwriting past the end of buffer.
		
		  buf_remaining > 3 check not needed as rx_fifo_avail == 0
		  when (words_to_transfer was > rx_fifo_avail) earlier
		  in this function.
 RX FIFO must be drained, otherwise it's an Overflow case. 
 round down to exclude partial word at the end of buffer 
	
	  This hunk pushes 4 bytes at a time into the TX FIFO.
	 
	  It's very common to have < 4 bytes, hence there is no word
	  to push if we have less than 4 bytes to transfer.
		
		  Update state before writing to FIFO.  Note that this may
		  cause us to finish writing all bytes (AKA buf_remaining
		  goes to 0), hence we have a potential for an interrupt
		  (PACKET_XFER_COMPLETE is not maskable), but GIC interrupt
		  is disabled at this point.
	
	  If there is a partial word at the end of buffer, handle it manually
	  to prevent reading past the end of buffer, which could cross a page
	  boundary and fault.
		
		  buf_remaining > 3 check not needed as tx_fifo_avail == 0
		  when (words_to_transfer was > tx_fifo_avail) earlier
		  in this function for non-zero words_to_transfer.
	
	  I2C transfer is terminated during the bus clear, so skip
	  processing the other interrupts.
				
				  Overflow error condition: message fully sent,
				  with no XFER_COMPLETE interrupt but hardware
				  asks to transfer more.
	
	  During message read XFER_COMPLETE interrupt is triggered prior to
	  DMA completion and during message write XFER_COMPLETE interrupt is
	  triggered after DMA completion.
	 
	  PACKETS_XFER_COMPLETE indicates completion of all bytes of transfer,
	  so forcing msg_buf_remaining to 0 in DMA mode.
		
		  Underflow error condition: XFER_COMPLETE before message
		  fully sent.
 mask all interrupts on error 
		
		  Under some rare circumstances (like running KASAN +
		  NFS root) CPU, which handles interrupt, may stuck in
		  uninterruptible state for a significant time.  In this
		  case we will get timeout if I2C transfer is running on
		  a sibling CPU, despite of IRQ being raised.
		 
		  In order to handle this rare condition, the IRQ status
		  needs to be checked after timeout.
 start recovery upon arbitration loss in single master mode 
	
	  Transfer time in mSec = Total bits  transfer rate
	  Total bits = 9 bits per byte (including ACK bit) + Start & stop bits
		
		  Synchronize DMA first, since dmaengine_terminate_sync()
		  performs synchronization after the transfer's termination
		  and we want to get a completion if transfer succeeded.
 check whether follow up message is coming 
 payload size is only 12 bit 
 interrupt will be enabled during of transfer time 
	
	  VI I2C is in VE power domain which is not always ON and not
	  IRQ-safe.  Thus, IRQ-safe device shouldn't be attached to a
	  non IRQ-safe domain because this prevents powering off the power
	  domain.
	 
	  VI I2C device shouldn't be marked as IRQ-safe because VI I2C won't
	  be used for atomic transfers.
	
	  VI I2C device is attached to VE power domain which goes through
	  power ONOFF during runtime PM resumesuspend, meaning that
	  controller needs to be re-initialized after power ON.
	
	  We need to ensure that clocks are enabled so that registers can be
	  restored in tegra_i2c_init().
	
	  In case we are runtime suspended, disable clocks again so that we
	  don't unbalance the clock reference counts during the next runtime
	  resume transition.
  Driver for the i2c controller on the Marvell line of host bridges
  (e.g, gt642[46]0, mv643[46]0, mv644[46]0, and Orion SoC family).
  Author: Mark A. Greer <mgreer@mvista.com>
  2005 (c) MontaVista, Software, Inc.  This file is licensed under
  the terms of the GNU General Public License version 2.  This program
  is licensed "as is" without any warranty of any kind, whether express
  or implied.
 Ctlr status values 
 Register defines (I2C bridge) 
 Bridge Control values 
 Bridge Status values 
 Driver states 
 Driver actions 
 5us delay in order to avoid repeated start timing violation 
 Clk div is 2 to the power n, not 2 to the power n + 1 
 	Finite State Machine & Interrupt Routines
 Reset hardware and initialize FSM 
	
	  If state is idle, then this is likely the remnants of an old
	  operation that driver has given up on or the user has killed.
	  If so, issue the stop condition and go to idle.
 The status from the ctlr [mostly] tells us what to do next 
 Start condition interrupt 
 0x08 
 0x10 
 Performing a write 
 0x18 
 0xd0 
 0x28 
 Performing a read 
 40 
 0xe0 
 0x50 
 0x58 
 0x20 
 30 
 48 
 Doesn't seem to be a device at other end 
 We should only get here if we have further messages 
		
		  We're never at the start of the message here, and by this
		  time it's already too late to do any protocol mangling.
		  Thankfully, do not advertise support for that feature.
	
	  Transaction is a one message read transaction, read data
	  for this message.
	
	  Transaction is a two messages writeread transaction, read
	  data for the second (read) message.
 	I2C Msg Execution Routines
 Timed out 
 InterruptedError 
 errno value 
 Build transaction 
 Single write message transaction 
 Single read message transaction 
	
	  Transaction with one write and one read message. This is
	  guaranteed by the mv64xx_i2c_can_offload() checks.
 Execute transaction 
	
	  We can offload a transaction consisting of a single
	  message, as long as the message has a length between 1 and
	  8 bytes.
	
	  We can offload a transaction consisting of two messages, if
	  the first is a write and a second is a read, and both have
	  a length between 1 and 8 bytes.
 	I2C Core Support Routines (Interface to higher level I2C code)
 	Driver Interface & Early Init Routines
	 CLK is mandatory when using DT to describe the i2c bus. We
	  need to know tclk in order to calculate bus clock
	  factors.
 100kHz by default 
	 Its not yet defined how timeouts will be specified in device tree.
	  So hard code the value to 1 second.
	
	  For controllers embedded in new SoCs activate the
	  Transaction Generator support and the errata fix.
 The delay is only needed in standard mode (100kHz) 
 The delay is only needed in standard mode (100kHz) 
 CONFIG_OF 
 CONFIG_OF 
 Not all platforms have clocks 
 SPDX-License-Identifier: GPL-2.0
   i2c slave support for Atmel's AT91 Two-Wire Interface (TWI)
   Copyright (C) 2017 Juergen Fitschen <me@jue.yt>
 slave address has been detected on I2C bus 
 byte transmitted to remote master 
 byte received from remote master 
 master sent stop 
 Make sure twi_clk doesn't get turned off! 
 SPDX-License-Identifier: GPL-2.0+
 Expose an I2C passthrough to the ChromeOS EC.
 Copyright (C) 2013 Google, Inc.
  struct ec_i2c_device - Driver data for I2C tunnel
  @dev: Device node
  @adap: I2C adapter
  @ec: Pointer to EC device
  @remote_bus: The EC bus number we tunnel to on the other side.
  @request_buf: Buffer for transmitting data; we expect most transfers to fit.
  @response_buf: Buffer for receiving data; we expect most transfers to fit.
  ec_i2c_count_message - Count bytes needed for ec_i2c_construct_message
  @i2c_msgs: The i2c messages to read
  @num: The number of i2c messages.
  Returns the number of bytes the messages will take up.
  ec_i2c_construct_message - construct a message to go to the EC
  This function effectively stuffs the standard i2c_msg format of Linux into
  a format that the EC understands.
  @buf: The buffer to fill.  We assume that the buffer is big enough.
  @i2c_msgs: The i2c messages to read.
  @num: The number of i2c messages.
  @bus_num: The remote bus number we want to talk to.
  Returns 0 or a negative error number.
  ec_i2c_count_response - Count bytes needed for ec_i2c_parse_response
  @i2c_msgs: The i2c messages to to fill up.
  @num: The number of i2c messages expected.
  Returns the number of response bytes expeced.
  ec_i2c_parse_response - Parse a response from the EC
  We'll take the EC's response and copy it back into msgs.
  @buf: The buffer to parse.
  @i2c_msgs: The i2c messages to to fill up.
  @num: The number of i2c messages; will be modified to include the actual
 	 number received.
  Returns 0 or a negative error number.
 Other side could send us back fewer messages, but not more 
 Unexpected; no errors should come when NULL response 
 Indicate success by saying how many messages were sent 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2009-2013, 2016-2018, The Linux Foundation. All rights reserved.
  Copyright (c) 2014, Sony Mobile Communications AB.
 QUP Registers 
 QUP States and reset values 
 QUP OPERATIONAL FLAGS 
 I2C mini core related values 
 Most significant word offset in FIFO port 
 PackingUnpacking words in FIFOs, and IO modes 
 QUP tags 
 QUP v2 tags 
 Status, Error flags 
 Maximum transfer length for single DMA descriptor 
 Maximum transfer length for all DMA descriptors 
  Minimum transfer timeout for i2c transfers in seconds. It will be added on
  the top of maximum transfer time calculated from i2c bus speed to compensate
  the overheads.
 Default values. Use these if FW query fails 
  Max tags length (start, stop and maximum 2 bytes address) for each QUP
  data transfer
 Max data length for each DATARD tags 
 TAG length for DATA READ in RX FIFO  
  count: no of blocks
  pos: current block number
  tx_tag_len: tx tag length for current block
  rx_tag_len: rx tag length for current block
  data_len: remaining data length for current message
  cur_blk_len: data length for current block
  total_tx_len: total tx length including tag bytes for current QUP transfer
  total_rx_len: total rx length including tag bytes for current QUP transfer
  tx_fifo_data_pos: current byte number in TX FIFO word
  tx_fifo_free: number of free bytes in current QUP block write.
  rx_fifo_data_pos: current byte number in RX FIFO word
  fifo_available: number of available bytes in RX FIFO for current
 		   QUP block read
  tx_fifo_data: QUP TX FIFO write works on word basis (4 bytes). New byte write
 		 to TX FIFO will be appended in this data and will be written to
 		 TX FIFO when all the 4 bytes are available.
  rx_fifo_data: QUP RX FIFO read works on word basis (4 bytes). This will
 		 contains the 4 bytes of RX data.
  cur_data: pointer to tell cur data position for current message
  cur_tx_tags: pointer to tell cur position in tags
  tx_tags_sent: all tx tag bytes have been written in FIFO word
  send_last_word: for tx FIFO, last word send is pending in current block
  rx_bytes_read: if all the bytes have been read from rx FIFO.
  rx_tags_fetched: all the rx tag bytes have been fetched from rx fifo word
  is_tx_blk_mode: whether tx uses block or FIFO mode in case of non BAM xfer.
  is_rx_blk_mode: whether rx uses block or FIFO mode in case of non BAM xfer.
  tags: contains tx tag bytes for current QUP transfer
 Current posion in user message buffer 
 I2C protocol errors 
 QUP core errors 
 To check if this is the last msg 
 To configure when bus is in run state 
 dma parameters 
 To check if the current transfer is using DMA 
 The threshold length above which block mode will be used 
 function to write data in tx fifo 
 function to read data from rx fifo 
 function to write tags in tx fifo for i2c read transfer 
 Clear Error interrupt 
 Clear the error bits in QUP_ERROR_FLAGS 
 Clear the error bits in QUP_I2C_STATUS 
	
	  Check for BAM mode and returns if already error has come for current
	  transfer. In Error case, sometimes, QUP generates more than one
	  interrupt.
 Reset the QUP State in case of error 
		
		  Don’t reset the QUP state in case of BAM mode. The BAM
		  flush operation needs to be scheduled in transfer function
		  which will clear the remaining schedule descriptors in BAM
		  HW FIFO and generates the BAM interrupt.
		
		  Ideally, QUP_MAX_OUTPUT_DONE_FLAG should be checked
		  for FIFO mode also. But, QUP_MAX_OUTPUT_DONE_FLAG lags
		  behind QUP_OUTPUT_SERVICE_FLAG sometimes. The only reason
		  of interrupt for write message in FIFO mode is
		  QUP_MAX_OUTPUT_DONE_FLAG condition.
	
	  State transition takes 3 AHB clocks cycles + 3 I2C master clock
	  cycles. So retry once after a 1uS delay.
 Check if I2C bus returns to IDLE state 
 Write out the pair and the last odd value 
 Read 1 byte indicating the length of the SMBus message 
 Handle tags for SMBus block read 
 Send _STOP commands for the last block 
 0 implies 256 bytes 
 scratch buf to read the start and len tags 
 schedule the EOT and FLUSH I2C tags 
 scratch buf to read the BAM EOT FLUSH tags 
 abort TX descriptors 
 wait for remaining interrupts to occur 
 set BAM mode 
 mask fifo irqs 
 set RUN STATE 
		
		  Make DMA descriptor and schedule the BAM transfer if its
		  already crossed the maximum length. Since the memory for all
		  tags buffers have been taken for 2 maximum possible
		  transfers length so it will never cross the buffer actual
		  length.
 Reading 2 words at time 
 0 is used to specify a length 256 (QUP_READ_LIMIT) 
 Configure QUP as I2C mini core 
  Configure registers related with reconfiguration during run and call it
  before each i2c sub transfer.
  Configure registers related with transfer mode (FIFOBlock)
  before starting of i2c transfer. It will be called only once in
  QUP RESET state.
 Clear required variables before starting of any QUP v2 sub transfer. 
 Receive data from RX FIFO for read message in QUP v2 i2c transfer. 
 Receive tags for read message in QUP v2 i2c transfer. 
  Read the data and tags from RX FIFO. Since in read case, the tags will be
  preceded by received data bytes so
  1. Check if rx_tags_fetched is false i.e. the start of QUP block so receive
     all tag bytes and discard that.
  2. Read the data from RX FIFO. When all the data bytes have been read then
     set rx_bytes_read to true.
  Write bytes in TX FIFO for write message in QUP v2 i2c transfer. QUP TX FIFO
  write works on word basis (4 bytes). Append new data byte write for TX FIFO
  in tx_fifo_data and write to TX FIFO when all the 4 bytes are present.
 Transfer tags for read message in QUP v2 i2c transfer. 
  Write the data and tags in TX FIFO. Since in write case, both tags and data
  need to be written and QUP write tags can have maximum 256 data length, so
  1. Check if tx_tags_sent is false i.e. the start of QUP block so write the
     tags to TX FIFO and set tx_tags_sent to true.
  2. Check if send_last_word is true. It will be set when last few data bytes
     (less than 4 bytes) are remaining to be written in FIFO because of no FIFO
     space. All this data bytes are available in tx_fifo_data so write this
     in FIFO.
  3. Write the data to TX FIFO and check for cur_blk_len. If it is non zero
     then more data is pending otherwise following 3 cases can be possible
     a. if tx_fifo_data_pos is zero i.e. all the data bytes in this block
        have been written in TX FIFO so nothing else is required.
     b. tx_fifo_free is non zero i.e tx FIFO is free so copy the remaining data
        from tx_fifo_data to tx FIFO. Since, qup_i2c_write_blk_data do write
 	 in 4 bytes and FIFO space is in multiple of 4 bytes so tx_fifo_free
        will be always greater than or equal to 4 bytes.
     c. tx_fifo_free is zero. In this case, last few bytes (less than 4
        bytes) are copied to tx_fifo_data but couldn't be sent because of
        FIFO full so make send_last_word true.
  Main transfer function which read or write i2c data.
  The QUP v2 supports reconfiguration during run in which multiple i2c sub
  transfers can be scheduled.
	
	  Check if its SMBus Block read for which the top level read will be
	  done into 2 QUP reads. One with message length 1 while other one is
	  with actual length.
			
			  If the message length is already read in
			  the first byte of the buffer, account for
			  that by setting the offset
 If it is first sub transfer, then configure i2c bus clocks 
	
	  In FIFO mode, tx FIFO can be written directly while in block mode the
	  it will be written after getting OUT_BLOCK_WRITE_REQ interrupt
 Move to pause state for all the transfers, except last one 
  Transfer one readwrite message in i2c transfer. It splits the message into
  multiple of blk_xfer_limit data length blocks and schedule each
  QUP block individually.
 Handle SMBus block read length 
  QUP v2 supports 3 modes
  Programmed IO using FIFO mode : Less than FIFO size
  Programmed IO using Block mode : Greater than FIFO size
  DMA using BAM : Appropriate for any transaction size but the address should
 		   be DMA applicable
  This function determines the mode which will be used for this transfer. An
  i2c transfer contains multiple message. Following are the rules to determine
  the mode used.
  1. Determine complete length, maximum tx and rx length for complete transfer.
  2. If complete transfer length is greater than fifo size then use the DMA
     mode.
  3. In FIFO or block mode, tx and rx can operate in different mode so check
     for maximum tx and rx length to determine mode.
 All i2c_msgs should be transferred using either dma or cpu 
 Configure QUP as I2C mini core 
  The QUP block will issue a NACK and STOP on the bus when reaching
  the end of the read, the length of the read is specified as one byte
  which limits the possible read to 256 (QUP_READ_LIMIT) bytes.
 2 tag bytes for each block + 5 for start, stop tags 
 We support frequencies up to FAST Mode Plus (1MHz) 
	
	  Bootloaders might leave a pending interrupt on certain QUP's,
	  so we reset the core before registering for interrupts.
	
	  The blockfifo size w.r.t. 'actual data' is 12 due to 'tag'
	  associated with each byte writtenreceived
		
		  in QUP v1, QUP_CONFIG uses N as 15 i.e 16 bits constitutes a
		  single transfer but the block size is in bytes so divide the
		  in_blk_sz and out_blk_sz by 2
 33%66% duty cycle 
	
	  Time it takes for a byte to be clocked out on the bus.
	  Each byte takes 9 clock cycles (8 bits + 1 ack).
 SPDX-License-Identifier: GPL-2.0-only
  Driver for the Diolan u2c-12 USB-I2C adapter
  Copyright (c) 2010-2011 Ericsson AB
  Derived from:
   i2c-tiny-usb.c
   Copyright (C) 2006-2007 Till Harbaum (Till@Harbaum.org)
 commands via USB, must match command ids in the firmware 
 Returns list of detected devices 
 400 kHz 
 100 kHz 
 2 kHz, minimum speed 
 in ms 
 in ms 
 Maximum supported receive length 
 Structure to hold all of our device specific stuff 
 output buffer 
 input buffer 
 Endpoints    
 the usb device for this device 
 the interface for this device 
 i2c related things 
 Output buffer length 
 Number of enqueued messages 
 I2C clock frequency in Hz 
 usb layer 
 Send command to device, and get response. 
			
			  Stop command processing if a previous command
			  returned an error.
			  Note that we still need to retrieve all messages.
					
					  Return ENXIO if NACK was received as
					  response to the address phase,
					  EIO otherwise
 strip off return code 
 Send command (no data) 
 Send command with one byte of data 
 Send command with two bytes of data 
  Flush input queue.
  If we don't do this at startup and the controller has queued up
  messages which were not retrieved, it will stop responding
  at some point.
 Enable or disable clock synchronization (stretching) 
 Set clock synchronization timeout in ms 
 Set I2C speed 
 Configure I2C clock synchronization 
 i2c layer 
				
				  Don't send NACK if this is the first byte
				  of a SMBUS_BLOCK message.
				
				  Adjust count if first received byte is length
  Return list of supported functionality.
 device layer 
 allocate memory for our device state and initialize it 
 save our data pointer in this interface device 
 setup i2c adapter description 
 initialize diolan i2c interface 
 and finally attach to i2c layer 
 SPDX-License-Identifier: GPL-2.0
  SuperH Mobile I2C Controller
  Copyright (C) 2014-19 Wolfram Sang <wsa@sang-engineering.com>
  Copyright (C) 2008 Magnus Damm
  Portions of the code based on out-of-tree driver i2c-sh7343.c
  Copyright (c) 2006 Carlos Munoz <carlos@kenati.com>
 Transmit operation:                                                      
 0 byte transmit                                                          
 BUS:     S     A8     ACK   P()                                         
 IRQ:       DTE   WAIT                                                    
 ICIC:                                                                    
 ICCR: 0x94       0x90                                                    
 ICDR:      A8                                                            
 1 byte transmit                                                          
 BUS:     S     A8     ACK   D8(1)   ACK   P()                           
 IRQ:       DTE   WAIT         WAIT                                       
 ICIC:      -DTE                                                          
 ICCR: 0x94                    0x90                                       
 ICDR:      A8    D8(1)                                                   
 2 byte transmit                                                          
 BUS:     S     A8     ACK   D8(1)   ACK   D8(2)   ACK   P()             
 IRQ:       DTE   WAIT         WAIT          WAIT                         
 ICIC:      -DTE                                                          
 ICCR: 0x94                                  0x90                         
 ICDR:      A8    D8(1)        D8(2)                                      
 3 bytes or more, +---------+ gets repeated                               
 Receive operation:                                                       
 0 byte receive - not supported since slave may hold SDA low              
 1 byte receive       [TX] | [RX]                                         
 BUS:     S     A8     ACK | D8(1)   ACK   P()                           
 IRQ:       DTE   WAIT     |   WAIT     DTE                               
 ICIC:      -DTE           |   +DTE                                       
 ICCR: 0x94       0x81     |   0xc0                                       
 ICDR:      A8             |            D8(1)                             
 2 byte receive        [TX]| [RX]                                         
 BUS:     S     A8     ACK | D8(1)   ACK   D8(2)   ACK   P()             
 IRQ:       DTE   WAIT     |   WAIT          WAIT     DTE                 
 ICIC:      -DTE           |                 +DTE                         
 ICCR: 0x94       0x81     |                 0xc0                         
 ICDR:      A8             |                 D8(1)    D8(2)               
 3 byte receive       [TX] | [RX]                                     () 
 BUS:     S     A8     ACK | D8(1)   ACK   D8(2)   ACK   D8(3)   ACK    P 
 IRQ:       DTE   WAIT     |   WAIT          WAIT         WAIT      DTE   
 ICIC:      -DTE           |                              +DTE            
 ICCR: 0x94       0x81     |                              0xc0            
 ICDR:      A8             |                 D8(1)        D8(2)     D8(3) 
 4 bytes or more, this part is repeated    +---------+                    
 Interrupt order and BUSY flag                                            
     ___                                                 _                
 SDA ___\___XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXAAAAAAAAA___                 
 SCL      \_1\_2\_3\_4\_5\_6\_7\_8\___9\_____                   
        S   D7  D6  D5  D4  D3  D2  D1  D0              P()              
                                           ___                            
 WAIT IRQ ________________________________   \___________                
 TACK IRQ ____________________________________   \_______                
 DTE  IRQ __________________________________________   \_                
 AL   IRQ XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                
         _______________________________________________                  
 BUSY __                                               \_                
 () The STOP condition is only sent by the master at the end of the last 
 I2C message or if the I2C_M_STOP flag is set. Similarly, the BUSY bit is 
 only cleared after the STOP condition, so, between messages we have to   
 poll for the DTE bit.                                                    
 Register offsets 
 Register bits 
	
	  Conditional expression:
	    ICCL >= COUNT_CLK  (tLOW + tf)
	 
	  SH-Mobile IIC hardware starts counting the LOW period of
	  the SCL signal (tLOW) as soon as it pulls the SCL line.
	  In order to meet the tLOW timing spec, we need to take into
	  account the fall time of SCL signal (tf).  Default tf value
	  should be 0.3 us, for safety.
	
	  Conditional expression:
	    ICCH >= COUNT_CLK  (tHIGH + tf)
	 
	  SH-Mobile IIC hardware is aware of SCL transition period 'tr',
	  and can ignore it.  SH-Mobile IIC controller starts counting
	  the HIGH period of the SCL signal (tHIGH) after the SCL input
	  voltage increases at VIH.
	 
	  Afterward it turned out calculating ICCH using only tHIGH spec
	  will result in violation of the tHD;STA timing spec.  We need
	  to take into account the fall time of SDA signal (tf) at START
	  condition, in order to meet both tHIGH and tHD;STA specs.
 one more bit of ICCL in ICIC 
 one more bit of ICCH in ICIC 
 tLOW = 4.7 us 
 tHD;STA = tHIGH = 4.0 us 
 tf = 0.3 us 
 tLOW = 1.3 us 
 tHD;STA = tHIGH = 0.6 us 
 tf = 0.3 us 
 L = 5, H = 4, L + H = 9 
 issue start and trigger DTE interrupt 
 disable DTE interrupt and write client address 
 write data 
 issue a stop (or rep_start) 
 select read mode 
 just read data 
 enable DTE interrupt, issue stop 
 enable DTE interrupt, read data, issue stop 
 switch from TX (address) to RX (data) adds two interrupts 
 Simulate PIO end condition after DMA transfer 
 remember state 
 Kick off TxDMA after preface was done 
 don't interrupt transaction - continue to issue stop 
 Kick off RxDMA after preface was done 
 TODO: add delay here to support slow acks 
 defeat write posting to avoid spurious WAIT interrupts 
 Initialize channel registers 
 Enable channel and configure rx ack 
 Set the clock 
 Enable all interrupts to begin with 
		 the interrupt handler may wake us up before the
		  transfer is finished, so poll the hardware
		  until we're done.
 handle missing acknowledge and arbitration lost 
 Wake up device and enable clock 
 Process all messages 
 The interrupt handler takes care of the rest... 
 'stop_after_dma' tells if DMA xfer was complete 
 Disable channel 
 Disable clock and mark device as idle 
  r8a7740 has an errata regarding I2C IO pad reset needing this workaround.
 dummy read 
 dummy read 
 Newer variants come with two new bits in ICIC 
 Init DMA 
 setup the private data 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-only
  i2c-exynos5.c - Samsung Exynos5 I2C Controller Driver
  Copyright (C) 2013 Samsung Electronics Co., Ltd.
  HSI2C controller from Samsung supports 2 modes of operation
  1. Auto mode: Where in master automatically controls the whole transaction
  2. Manual mode: Software controls the transaction by issuing commands
     START, READ, WRITE, STOP, RESTART in I2C_MANUAL_CMD register.
  Operation mode can be selected by setting AUTO_MODE bit in I2C_CONF register
  Special bits are available for both modes of operation to set commands
  and for checking transfer status
 Register Map 
 I2C_CTL Register bits 
 I2C_FIFO_CTL Register bits 
 I2C_TRAILING_CTL Register bits 
 I2C_INT_EN Register bits 
 I2C_INT_STAT Register bits 
 I2C_FIFO_STAT Register bits 
 I2C_CONF Register bits 
 I2C_AUTO_CONF Register bits 
 I2C_TIMEOUT Register bits 
 I2C_MANUAL_CMD register bits 
 I2C_TRANS_STATUS register bits 
 I2C_TRANS_STATUS register bits for Exynos5 variant 
 I2C_TRANS_STATUS register bits for Exynos7 variant 
 I2C_ADDR register bits 
 IRQ synchronization 
	
	  Since the TRANS_DONE bit is cleared on read, and we may read it
	  either during an IRQ or after a transaction, keep track of its
	  state here.
 Controller operating frequency 
 Version of HS-I2C Hardware 
  struct exynos_hsi2c_variant - platform specific HSI2C driver data
  @fifo_depth: the fifo depth supported by the HSI2C module
  @hw: the hardware variant of Exynos I2C controller
  Specifies platform specific configuration of HSI2C module.
  Note: A structure for driver specific platform data is used for future
  expansion of its usage.
  exynos5_i2c_set_timing: updates the registers with appropriate
  timing values calculated
  Timing values for operation are calculated against either 100kHz
  or 1MHz controller operating frequency.
  Returns 0 on success, -EINVAL if the cycle length cannot
  be calculated.
	
	  In case of HSI2C controller in Exynos5 series
	  FPCLK  FI2C =
	  (CLK_DIV + 1)  (TSCLK_L + TSCLK_H + 2) + 8 + 2  FLT_CYCLE
	 
	  In case of HSI2C controllers in Exynos7 series
	  FPCLK  FI2C =
	  (CLK_DIV + 1)  (TSCLK_L + TSCLK_H + 2) + 8 + FLT_CYCLE
	 
	  clk_cycle := TSCLK_L + TSCLK_H
	  temp := (CLK_DIV + 1)  (clk_cycle + 2)
	 
	  Constraints: 4 <= temp, 0 <= CLK_DIV < 256, 2 <= clk_cycle <= 510
	 
 always set Fast Speed timings 
  exynos5_i2c_init: configures the controller for I2C functionality
  Programs I2C controller for Master mode operation
 Clear to disable Timeout 
 Set and clear the bit for reset 
 We don't expect calculations to fail during the run 
 Initialize the configure registers 
  exynos5_i2c_irq: top level IRQ servicing routine
  INT_STATUS registers gives the interrupt details. Further,
  FIFO_STATUS or TRANS_STATUS registers are to be check for detailed
  state of the bus.
 handle interrupt related to the transfer status 
  exynos5_i2c_wait_bus_idle
  Wait for the bus to go idle, indicated by the MASTER_BUSY bit being
  cleared.
  Returns -EBUSY if the bus cannot be bought to idle
 wait for 100 milli seconds for the bus to be idle 
	
	  Specification says master should send nine clock pulses. It can be
	  emulated by sending manual read command (nine pulses for read eight
	  bits + one pulse for NACK).
	
	  HSI2C_MASTER_ST_LOSE state in EXYNOS7 variant before transaction
	  indicates that bus is stuck (SDA is low). In such case bus recovery
	  can be performed.
  exynos5_i2c_message_start: Configures the bus and starts the xfer
  i2c: struct exynos5_i2c pointer for the current bus
  stop: Enables stop after transfer if set. Set for last transfer of
        in the list of messages.
  Configures the bus for readwrite function
  Sets chip address to talk to, message length to be sent.
  Enables appropriate interrupts and sends start xfer command.
	
	  Enable interrupts before starting the transfer so that we don't
	  miss any INT_I2C interrupts.
	
	  If this is the last message to be transfered (stop == 1)
	  Then check if the bus can be brought back to idle.
 Return the state as in interrupt routine 
 Clear pending interrupts from u-boot or misc causes 
 SPDX-License-Identifier: GPL-2.0-or-later
  TI DAVINCI I2C adapter driver.
  Copyright (C) 2006 Texas Instruments.
  Copyright (C) 2007 MontaVista Software Inc.
  Updated by Vinod & Sudhakar Feb 2005
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
 ----- global defines ----------------------------------------------- 
 set SDA and SCL as GPIO 
 set SCL as output when used as GPIO
 set SDA as output when used as GPIO
 read SCL GPIO level 
 read SDA GPIO level 
set the SCL GPIO high 
set the SDA GPIO high 
 set the SCL GPIO low 
 set the SDA GPIO low 
 timeout for pm runtime autosuspend 
 ms 
 default platform data to use if not supplied in the platform_device 
 put I2C into reset 
 take I2C out of reset 
	 NOTE: I2C Clock divider programming info
	  As per I2C specs the following formulas provide prescaler
	  and lowhigh divider values
	  input clk --> PSC Div -----------> ICCLH Div --> output clock
	                        module clk
	 
	  output clk = module clk  (PSC + 1) [ (ICCL + d) + (ICCH + d) ]
	 
	  Thus,
	  (ICCL + ICCH) = clk = (input clk  ((psc +1)  output clk)) - 2d;
	 
	  where if PSC == 0, d = 7,
	        if PSC == 1, d = 6
	        if PSC > 1 , d = 5
	 
	  Note:
	  d is always 6 on Keystone I2C controller
	
	  Both Davinci and current Keystone User Guides recommend a value
	  between 7MHz and 12MHz. In reality 7MHz module clock doesn't
	  always produce enough margin between SDA and SCL transitions.
	  Measurements show that the higher the module clock is, the
	  bigger is the margin, providing more reliable communication.
	  So we better target for 12MHz.
 better to run under spec than over 
 Avoid driving the bus too fast because of rounding errors above 
	
	  According to I2C-BUS Spec 2.1, in FAST-MODE LOW period should be at
	  least 1.3uS, which is not the case with 50% duty cycle. Driving HIGH
	  to LOW ratio as 1 to 2 is more safe.
	
	  It's not always possible to have 1 to 2 ratio when d=7, so fall back
	  to minimal possible clkh in this case.
	 
	  Note:
	  CLKH is not allowed to be 0, in this case I2C clock is not generated
	  at all
  This function configures I2C and brings I2C out of reset.
  This function is called during I2C init function. This function
  also gets called if I2C encounters any errors.
 put I2C into reset 
 compute clock dividers 
	 Respond at reserved "SMBus Host" slave address" (and zero);
	  we seem to have no option to not respond...
 Take the I2C module out of reset: 
 Enable interrupts 
  This routine does i2c bus recovery by using i2c_generic_scl_recovery
  which is provided by I2C Bus recovery infrastructure.
 Disable interrupts 
 put I2C into reset 
 read the state of SCL 
 read the state of SDA 
 SCL output, SDA input 
 change to GPIO mode 
 change back to I2C mode 
  Waiting for bus not busy
	
	  if bus is still "busy" here, it's most probably a HW problem like
	  short-circuit
  Low level master readwrite transaction. This function is called
  from i2c_davinci_xfer.
 Introduce a delay, required for some boards (e.g Davinci EVM) 
 set the slave address 
 Take I2C out of reset and configure it as master 
 if the slave address is ten bit address, enable XA bit 
 Enable receive or transmit interrupts 
	
	  Write mode register first as needed for correct behaviour
	  on OMAP-L138, but don't set STT yet to avoid a race with XRDY
	  occurring before we have loaded DXR
	
	  First byte should be set here, not after interrupt,
	  because transmit-data-ready interrupt can come before
	  NACK-interrupt during sending of previous message and
	  ICDXR may have wrong data
	  It also saves us one interrupt, slightly faster
 Set STT to begin transmit now DXR is loaded 
		 This should be 0 if all bytes were transferred
		  or dev->cmd_err denotes an error.
 no error 
 We have an error 
  Prepare controller for a transaction and call i2c_davinci_xfer_msg
 Throw away data 
  Interrupt service routine. This gets called whenever an I2C interrupt
  occurs.
 Arbitration lost, must retry 
 signal can terminate transfer 
 signal can terminate transfer 
 put I2C into reset 
 take I2C out of reset 
 work with hotplug and coldplug 
 I2C may be needed to bring up other drivers 
 SPDX-License-Identifier: GPL-2.0
  I2C driver for the Renesas EMEV2 SoC
  Copyright (C) 2015 Wolfram Sang <wsa@sang-engineering.com>
  Copyright 2013 Codethink Ltd.
  Copyright 2010-2015 Renesas Electronics Corporation
 I2C Registers 
 start 
 shift 
 control 
 slave address 
 clock select 
 extension 
 status 
 status For emulation 
 IIC flag 
 I2C IICACT0 Masks 
 I2C IICC0 Masks 
 I2C IICCL0 Masks 
 I2C IICSE0 Masks 
 I2C IICF0 Masks 
 Send Stop condition 
 Wait for stop condition 
 If I2C active 
 Disable I2C operation 
 Transfer mode set 
 Can Issue start without detecting a stop, Reservation disabled. 
 I2C enable, 9 bit interrupt mode 
 Enable I2C operation 
 Send start condition 
 Send slave address and RW type 
 Wait for transaction 
 Received NACK (result of setting slave address and RW) 
 Extra setup for read transactions 
 8 bit interrupt mode 
 Wait for transaction 
 Send  receive data 
 Read transaction 
 Write transaction 
 Received NACK 
 Write data 
 Wait for RW transaction 
 I2C transfer completed 
 Extension code, do not participate 
 Stop detected, we don't know if it's for slave or master 
 Notify slave device 
 Pretend we did not handle the interrupt 
 Only handle interrupts addressed to us 
 Enable stop interrupts 
 Transmission or Reception 
 9 bit interrupt mode 
 Send data 
 NACK, stop transmitting 
 8 bit interrupt mode 
 Recv data 
 Set slave address 
	
	  Wait for interrupt to finish. New slave irqs cannot happen because we
	  cleared the slave address and, thus, only extension codes will be
	  detected which do not use the slave ptr.
 SPDX-License-Identifier: GPL-2.0-only
  I2C bus driver for Conexant Digicolor SoCs
  Author: Baruch Siach <baruch@tkos.co.il>
  Copyright (C) 2015 Paradox Innovation Ltd.
  Provides I2C support for Philips PNX010xPNX4008 boards.
  Authors: Dennis Kovalev <dkovalev@ru.mvista.com>
 	    Vitaly Wool <vwool@ru.mvista.com>
  2004-2006 (c) MontaVista Software, Inc. This file is licensed under
  the terms of the GNU General Public License version 2. This program
  is licensed "as is" without any warranty of any kind, whether express
  or implied.
 msec 
 Return value 
 Interface mode 
 IO completion 
 Timeout 
 Data buffer 
 Length of data buffer 
 RX Bytes to order via TX 
 Rx FIFO reg (RO) 
 Tx FIFO reg (WO) 
 Status reg (RO) 
 Ctl reg 
 Clock divider low 
 Clock divider high 
 I2C address 
 Rx FIFO level (RO) 
 Tx FIFO level (RO) 
 Num of bytes Rx-ed (RO) 
 Num of bytes Tx-ed (RO) 
 Tx slave FIFO (RO) 
 Tx slave FIFO level (RO) 
  i2c_pnx_start - start a device
  @slave_addr:		slave address
  @alg_data:		pointer to local driver data structure
  Generate a START signal in the desired mode.
 Check for 7 bit slave addresses only 
 First, make sure bus is idle 
 Somebody else is monopolizing the bus 
 Sorry, we lost the bus 
	
	  OK, I2C is enabled and we have the bus.
	  Clear the current TDI and AFI status flags.
 Write the slave address, START bit and RW bit 
  i2c_pnx_stop - stop a device
  @alg_data:		pointer to local driver data structure
  Generate a STOP signal to terminate the master transaction.
 Only 1 msec max timeout due to interrupt context 
 Write a STOP bit to TX FIFO 
 Wait until the STOP is seen. 
 may be called from interrupt context 
  i2c_pnx_master_xmit - transmit data to slave
  @alg_data:		pointer to local driver data structure
  Sends one byte of data to the slave
 We still have something to talk about... 
 Wait until the STOP is seen. 
 Disable master interrupts 
 zero-sized transfer 
 Disable master interrupts. 
 Stop timer. 
  i2c_pnx_master_rcv - receive data from slave
  @alg_data:		pointer to local driver data structure
  Reads one byte data from the slave
	 Check, whether there is already data,
	  or we didn't 'ask' for it yet.
		 'Asking' is done asynchronously, e.g. dummy TX of several
		  bytes is done before the first actual RX arrives in FIFO.
		  Therefore, ordered bytes (via TX) are counted separately.
 Last byte, do not acknowledge next rcv. 
				
				  Enable interrupt RFDAIE (data in Rx fifo),
				  and disable DRMIE (need data for Tx)
			
			  Now we'll 'ask' for data:
			  For each byte we want to receive, we must
			  write a (dummy) byte to the Tx-FIFO.
 Handle data. 
 Wait until the STOP is seen. 
 Disable master interrupts 
 Kill timer. 
 let's see what kind of event this is 
 We lost arbitration in the midst of a transfer 
 Disable master interrupts. 
 Stop timer, to prevent timeout. 
 Slave did not acknowledge, generate a STOP 
 Disable master interrupts. 
 Our return value. 
 Stop timer, to prevent timeout. 
		
		  Two options:
		  - Master Tx needs data.
		  - There is data in the Rx-fifo
		  The latter is only the case if we have requested for data,
		  via a dummy write. (See 'i2c_pnx_master_rcv'.)
		  We therefore check, as a sanity check, whether that interrupt
		  has been enabled.
 Clear TDI and AFI bits 
 Reset master and disable interrupts 
		 If there is data in the fifo's after transfer,
		  flush fifo's by reset.
  i2c_pnx_xfer - generic transfer entry point
  @adap:		pointer to I2C adapter structure
  @msgs:		array of messages
  @num:		number of messages
  Initiates the transfer
 Process transactions in a loop. 
 initialize the completion var 
 Enable master interrupt 
 Put start-code and slave-address on the bus. 
 Wait for completion 
 Clear TDI and AFI bits in case they are set. 
 Cleanup to be sure... 
		
		  At this point, it is planned to add an OF timeout property.
		  As soon as there is a consensus about how to call and handle
		  this, sth. like the following can be put here:
		 
		  of_property_read_u32(pdev->dev.of_node, "timeout",
		                       &alg_data->timeout);
 Register IO resource 
	
	  Clock Divisor High This value is the number of system clocks
	  the serial clock (SCL) will be high.
	  For example, if the system clock period is 50 ns and the maximum
	  desired serial period is 10000 ns (100 kHz), then CLKHI would be
	  set to 0.5(f_sysf_i2c)-2=0.5(20e6100e3)-2=98. The actual value
	  programmed into CLKHI will vary from this slightly due to
	  variations in the output pad's rise and fall times as well as
	  the deglitching filter length.
 Register this adapter with the I2C subsystem 
 We need to make sure I2C is initialized before USB 
 SPDX-License-Identifier: GPL-2.0-or-later
  Actions Semiconductor Owl SoC's I2C driver
  Copyright (c) 2014 Actions Semi Inc.
  Author: David Liu <liuwei@actions-semi.com>
  Copyright (c) 2018 Linaro Ltd.
  Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
 I2C registers 
 I2Cx_CTL Bit Mask 
 I2Cx_STAT Bit Mask 
 I2Cx_CMD Bit Mask 
 I2Cx_FIFOCTL Bit Mask 
 I2Cc_FIFOSTAT Bit Mask 
 I2C bus timeout 
 Clear status registers 
 Reset FIFO 
 Wait 50ms for FIFO reset complete 
 Set clock divider factor 
 Handle NACK from slave 
 Clear NACK error bit by writing "1" 
 Handle bus error 
 Clear BUS error bit by writing "1" 
 Handle FIFO read 
 Handle the remaining bytes which were not sent 
 Clear pending interrupts 
 Check for Bus busy 
 Reset I2C controller 
 Set bus frequency 
	
	  Spinlock should be released before calling reset FIFO and
	  bus busy check since those functions may sleep
 Reset FIFO 
 Check for bus busy 
 Check for Arbitration lost 
 Enabledisable I2C controller interrupt 
	
	  Select: FIFO enable, Master mode, Stop enable, Data count enable,
	  Send start bit
 Handle repeated start condition 
 Set internal address length and enable repeated start 
 Write slave address 
 Write internal register address 
 Set address length 
 Set data count for the message 
 Write data to FIFO 
 Check for FIFO full 
 Ignore the NACK if needed 
 Start the transfer 
 Wait for Command Execute Completed or NACK Error bits 
 Send stop condition and release the bus 
 Disable I2C controller 
 We support only frequencies of 100k and 400k for now 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  HiSilicon I2C Controller Driver for Kunpeng SoC
  Copyright (c) 2021 HiSilicon Technologies Co., Ltd.
 Intermediates for recording the transfer process 
 I2C bus configuration 
  Initialize the transfer information and start the I2C bus transfer.
  We only configure the transfer and do some prepost works here, and
  wait for the transfer done. The major transfer process is performed
  in the IRQ handler.
 Signal the SR bit when we start transferring a new message 
 Signal the STOP bit at the last frame of the last message 
 Update the transfer index after per message transfer is done. 
 Drain the rx fifo before finish the transfer 
  Helper function for calculating and configuring the HIGH and LOW
  periods of SCL clock. The caller will pass the ratio of the
  counts (divide  divisor) according to the target speed mode,
  and the target registers.
 Total SCL clock cycles per speed period 
 Total HIGH level SCL clock cycles including edges 
 Total LOW level SCL clock cycles including edges 
 Fall edge SCL clock cycles 
 Rise edge SCL clock cycles 
 Calculated HIGH and LOW periods of SCL clock 
 For default condition force the bus speed to standard mode. 
 SPDX-License-Identifier: GPL-2.0
   i2c Support for Atmel's AT91 Two-Wire Interface (TWI)
   Copyright (C) 2011 Weinmann Medical GmbH
   Author: Nikolaus Voss <n.voss@weinmann.de>
   Evolved from original work by:
   Copyright (C) 2004 Rick Bronson
   Converted to 2.6 by Andrew Victor <andrew@sanpeople.com>
   Borrowed heavily from original work by:
   Copyright (C) 2000 Philip Edelbrock <phil@stimpy.netroedge.com>
 sentinel 
 due to errata, CLEAR cmd is not working 
 sentinel 
 SPDX-License-Identifier: GPL-2.0-or-later
  i2c-amd756-s4882.c - i2c-amd756 extras for the Tyan S4882 motherboard
  Copyright (C) 2004, 2008 Jean Delvare <jdelvare@suse.de>
  We select the channels by sending commands to the Philips
  PCA9556 chip at I2C address 0x18. The main adapter is used for
  the non-multiplexed part of the bus, and 4 virtual adapters
  are defined for the multiplexed addresses: 0x50-0x53 (memory
  module EEPROM) located on channels 1-4, and 0x4c (LM63)
  located on multiplexed channels 0 and 5-7. We define one
  virtual adapter per CPU, which corresponds to two multiplexed
  channels:
    CPU0: virtual adapter 1, channels 1 and 0
    CPU1: virtual adapter 2, channels 2 and 5
    CPU2: virtual adapter 3, channels 3 and 6
    CPU3: virtual adapter 4, channels 4 and 7
 Wrapper access functions for multiplexed SMBus 
 We exclude the multiplexed addresses 
 We remember the last used channels combination so as to only switch
   channels when it is really needed. This greatly reduces the SMBus
   overhead, but also assumes that nobody will be writing to the PCA9556
 We exclude the non-multiplexed addresses 
 CPU0: channels 1 and 0 enabled 
 CPU1: channels 2 and 5 enabled 
 CPU2: channels 3 and 6 enabled 
 CPU3: channels 4 and 7 enabled 
 Configure the PCA9556 multiplexer 
 All IO to output mode 
 Unregister physical bus 
 Define the 5 virtual adapters and algorithms structures 
 Fill in the new structures 
 Register virtual adapters 
 Restore physical bus 
 Restore physical bus 
  Copyright (c) 2003-2015 Broadcom Corporation
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
		 interrupt after the first read to examine
		  the length byte before proceeding further
	
	  Update receive length. Re-read len to get the latest value,
	  and then add 4 to have a minimum value that can be safely
	  written. This is to account for the byte read above, the
	  transfer in progress and any delays in the register IO
 read length byte 
		
		  We expect at least 2 interrupts for I2C_M_RECV_LEN
		  transactions. The length is updated during the first
		  interrupt, and the buffer contents are only copied
		  during subsequent interrupts. If in case the interrupts
		  get merged we would complete the transaction without
		  copying out the bytes from RX fifo. To avoid this now we
		  drain the fifo as and when data is available.
		  We drained the rlen byte already, decrement total length
		  by one.
abort transfer 
 account for error check byte 
 update remaining bytes and message length 
 SADDR ACK for SMBUS_QUICK 
 TX FIFO got empty, fill it up again 
 data is in FIFO, read it 
 Transfer complete 
	
	  The controller uses 5  SCL clock internally.
	  So prescale value should be divided by 5.
 Reset FIFO 
 set slave addr 
 Build control word for transfer 
 read 
 10-bit address mode
 set FIFO threshold if reading 
 set data length to be transferred 
 fill fifo during tx 
 set interrupt mask 
 set cmd reg 
 update msg->len with actual received length 
 SMBAlert irq 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
  SMBus driver for ACPI SMBus CMI
  Copyright (C) 2009 Crane Cai <crane.cai@amd.com>
 SMBUS HID definition as supported by Microsoft Windows 
 Some IBM BIOSes omit the leading underscore 
 SPDX-License-Identifier: GPL-2.0-only
    i2c-isch.c - Linux kernel driver for Intel SCH chipset SMBus
    - Based on i2c-piix4.c
    Copyright (c) 1998 - 2002 Frodo Looijaard <frodol@dds.nl> and
    Philip Edelbrock <phil@netroedge.com>
    - Intel SCH support
    Copyright (c) 2007 - 2008 Jacob Jun Pan <jacob.jun.pan@intel.com>
   Supports:
	Intel SCH chipsets (AF82US15W, AF82US15L, AF82UL11L)
   Note: we assume there can only be one device, with one SMBus interface.
 SCH SMBus address offsets 
 TSA 
 Other settings 
 I2C constants 
 backbone speed in kHz 
  Start the i2c transaction -- the i2c_access will prepare the transaction
  and this function will execute it.
  return 0 for success and others for failure.
 Make sure the SMBus host is ready to start transmitting 
 Can not be busy since we checked it in sch_access 
 start the transaction by setting bit 4 
 If the SMBus is still busy, we give up 
 Clock stops and slave is stuck in mid-transmission 
 Completion clear failed 
  This is the main access entry for i2c-sch access
  adap is i2c_adapter pointer, addr is the i2c device bus address, read_write
  (0 for read and 1 for write), size is i2c transaction type and data is the
  union of transaction for data to be transferred or data read from bus.
  return 0 for success and others for failure.
 Make sure the SMBus host is not busy 
		
		  We can't determine if we have 33 or 25 MHz clock for
		  SMBus, so expect 33 MHz and calculate a bus clock of
		  100 kHz. If we actually run at 25 MHz the bus will be
		  run ~75 kHz instead which should do no harm.
 Error in transaction 
 set up the sysfs linkage to our parent device 
 SPDX-License-Identifier: GPL-2.0-or-later
  X-Gene SLIMpro I2C Driver
  Copyright (c) 2014, Applied Micro Circuits Corporation
  Author: Feng Kan <fkan@apm.com>
  Author: Hieu Le <hnle@apm.com>
  This driver provides support for X-Gene SLIMpro I2C device access
  using the APM X-Gene SLIMpro mailbox driver.
 Operation time out in ms 
 Use I2C bus 1 only 
  SLIMpro I2C message encode
  dev		- Controller number (0-based)
  chip		- I2C chip address
  op		- SLIMPRO_IIC_READ or SLIMPRO_IIC_WRITE
  proto	- SLIMPRO_IIC_SMB_PROTOCOL or SLIMPRO_IIC_I2C_PROTOCOL
  addrlen	- Length of the address field
  datalen	- Length of the data field
  Encode for upper address for block data
 PCC related defines 
 dma_buffer[0] is used for length 
  This function tests and clears a bitmask then returns its old value
	
	  Response message format:
	  mssg[0] is the return code of the operation
	  mssg[1] is the first data word
	  mssg[2] is NOT used
 Check if platform sends interrupt 
 Response message msg[1] contains the return value. 
 Copy the message to the PCC comm space 
 Check of invalid data or no device 
 Copy to destination 
 Return list of supported functionality.
 Request mailbox channel 
		
		  This is the shared communication region
		  for the OS and Platform to communicate over.
 Setup I2C adapter 
 SPDX-License-Identifier: GPL-2.0-or-later
 ------------------------------------------------------------------------- 
 i2c-elektor.c i2c-hw access for PCF8584 style isa bus adaptes             
 ------------------------------------------------------------------------- 
   Copyright (C) 1995-97 Simon G. Vogl
                   1998-99 Hans Berglund
 ------------------------------------------------------------------------- 
 With some changes from Kyösti Mälkki <kmalkki@cc.hut.fi> and even
 Partially rewriten by Oleg I. Vdovikin for mmapped support of
 vdovikin: removed static struct i2c_pcf_isa gpi; code -
  this module in real supports only one device, due to missing arguments
  in some functions, called from the algo-pcf module. Sometimes it's
 ----- local functions ----------------------------------------------	
 enable irq if any specified for serial operation 
 API UP2000 needs some hardware fudging to make the write stick 
 ------------------------------------------------------------------------
  Encapsulate the above functions in the correct operations structure.
  This is only done when more than one hardware adapter is supported.
	 check to see we have memory mapped PCF8584 connected to the
 yeap, we've found cypress, let's check config 
				 UP2000 board has this register set to 0xe1,
				   but the most significant bit as seems can be
				   reset during the proper initialisation
				   sequence if guys from API decides to do that
				   (so, we can even enable Tsunami Pchip
				 so just check for ROMCS at 0xe0000,
				   ROMCS enabled for writes
 seems to be UP2000 like board 
					 UP2000 drives ISA with
					   8.25 MHz (PCI4) clock
 sanity checks for mmapped IO 
 SPDX-License-Identifier: GPL-2.0
   i2c Support for Atmel's AT91 Two-Wire Interface (TWI)
   Copyright (C) 2011 Weinmann Medical GmbH
   Author: Nikolaus Voss <n.voss@weinmann.de>
   Evolved from original work by:
   Copyright (C) 2004 Rick Bronson
   Converted to 2.6 by Andrew Victor <andrew@sanpeople.com>
   Borrowed heavily from original work by:
   Copyright (C) 2000 Philip Edelbrock <phil@stimpy.netroedge.com>
 FIFO should be enabled immediately after the software reset 
 enable digital filter 
 enable advanced digital filter 
 enable analog filter 
  Calculate symmetric clock as stated in datasheet:
  twi_clk = F_MAIN  (2  (cdiv  (1 << ckdiv) + offset))
		
		  hold time = HOLD + 3 x T_peripheral_clock
		  Use clk rate in kHz to prevent overflows when computing
		  hold.
		
		  filter width = 0 to AT91_TWI_FILTR_THRES_MAX
		  peripheral clocks
 8bit write works with and without FIFO 
 send stop when last byte has been written 
	
	  When this callback is called, THRTX FIFO is likely not to be empty
	  yet. So we have to wait for TXCOMP or NACK bits to be set into the
	  Status Register to be sure that the STOP bit has been sent and the
	  transfer is completed. The NACK interrupt has already been enabled,
	  we just have to enable TXCOMP one.
		
		  DMA controller is triggered when at least 4 data can be
		  written into the TX FIFO
	
	  If we are in this case, it means there is garbage data in RHR, so
	  delete them.
 8bit read works with and without FIFO 
 return if aborting, we only needed to read RHR to clear RXRDY
 handle I2C_SMBUS_BLOCK_DATA 
 ensure length byte is a valid value 
 abort and send the stop by reading one more byte 
 send stop if second but last byte has been read 
 The last two bytes have to be read without using dma 
 Keep in mind that we won't use dma to read the last two bytes 
		
		  DMA controller is triggered when at least 4 data can be
		  read from the RX FIFO
	
	  In reception, the behavior of the twi device (before sama5d2) is
	  weird. There is some magic about RXRDY flag! When a data has been
	  almost received, the reception of a new one is anticipated if there
	  is no stop command to send. That is the reason why ask for sending
	  the stop command not on the last data but on the second last one.
	 
	  Unfortunately, we could still have the RXRDY flag set even if the
	  transfer is done and we have read the last data. It might happen
	  when the i2c slave device sends too quickly data after receiving the
	  ack from the master. The data has been almost received before having
	  the order to send stop. In this case, sending the stop command could
	  cause a RXRDY interrupt with a TXCOMP one. It is better to manage
	  the RXRDY interrupt first in order to not keep garbage data in the
	  Receive Holding Register for the next transfer.
		
		  Read all available bytes at once by polling RXRDY usable w
		  and wo FIFO. With FIFO enabled we could also read RXFL and
		  avoid polling RXRDY.
	
	  When a NACK condition is detected, the I2C controller sets the NACK,
	  TXCOMP and TXRDY bits all together in the Status Register (SR).
	 
	  1 - Handling NACK errors with CPU write transfer.
	 
	  In such case, we should not write the next byte into the Transmit
	  Holding Register (THR) otherwise the I2C controller would start a new
	  transfer and the I2C slave is likely to reply by another NACK.
	 
	  2 - Handling NACK errors with DMA write transfer.
	 
	  By setting the TXRDY bit in the SR, the I2C controller also triggers
	  the DMA controller to write the next data into the THR. Then the
	  result depends on the hardware version of the I2C controller.
	 
	  2a - Without support of the Alternative Command mode.
	 
	  This is the worst case: the DMA controller is triggered to write the
	  next data into the THR, hence starting a new transfer: the I2C slave
	  is likely to reply by another NACK.
	  Concurrently, this interrupt handler is likely to be called to manage
	  the first NACK before the I2C controller detects the second NACK and
	  sets once again the NACK bit into the SR.
	  When handling the first NACK, this interrupt handler disables the I2C
	  controller interruptions, especially the NACK interrupt.
	  Hence, the NACK bit is pending into the SR. This is why we should
	  read the SR to clear all pending interrupts at the beginning of
	  at91_do_twi_transfer() before actually starting a new transfer.
	 
	  2b - With support of the Alternative Command mode.
	 
	  When a NACK condition is detected, the I2C controller also locks the
	  THR (and sets the LOCK bit in the SR): even though the DMA controller
	  is triggered by the TXRDY bit to write the next data into the THR,
	  this data actually won't go on the I2C bus hence a second NACK is not
	  generated.
 catch error flags 
	
	  WARNING: the TXCOMP bit in the Status Register is NOT a clear on
	  read flag but shows the state of the transmission at the time the
	  Status Register is read. According to the programmer datasheet,
	  TXCOMP is set when both holding register and internal shifter are
	  empty and STOP condition has been sent.
	  Consequently, we should enable NACK interrupt rather than TXCOMP to
	  detect transmission failure.
	  Indeed let's take the case of an i2c write command using DMA.
	  Whenever the slave doesn't acknowledge a byte, the LOCK, NACK and
	  TXCOMP bits are set together into the Status Register.
	  LOCK is a clear on write bit, which is set to prevent the DMA
	  controller from sending new data on the i2c bus after a NACK
	  condition has happened. Once locked, this i2c peripheral stops
	  triggering the DMA controller for new data but it is more than
	  likely that a new DMA transaction is already in progress, writing
	  into the Transmit Holding Register. Since the peripheral is locked,
	  these new data won't be sent to the i2c bus but they will remain
	  into the Transmit Holding Register, so TXCOMP bit is cleared.
	  Then when the interrupt handler is called, the Status Register is
	  read: the TXCOMP bit is clear but NACK bit is still set. The driver
	  manage the error properly, without waiting for timeout.
	  This case can be reproduced easyly when writing into an at24 eeprom.
	 
	  Besides, the TXCOMP bit is already set before the i2c transaction
	  has been started. For read transactions, this bit is cleared when
	  writing the START bit into the Control Register. So the
	  corresponding interrupt can safely be enabled just after.
	  However for write transactions managed by the CPU, we first write
	  into THR, so TXCOMP is cleared. Then we can safely enable TXCOMP
	  interrupt. If TXCOMP interrupt were enabled before writing into THR,
	  the interrupt handler would be called immediately and the i2c command
	  would be reported as completed.
	  Also when a write transaction is managed by the DMA controller,
	  enabling the TXCOMP interrupt in this function may lead to a race
	  condition since we don't know whether the TXCOMP interrupt is enabled
	  before or after the DMA has started to write into THR. So the TXCOMP
	  interrupt is enabled later by at91_twi_write_data_dma_callback().
	  Immediately after in that DMA callback, if the alternative command
	  mode is not used, we still need to send the STOP condition manually
	  writing the corresponding bit into the Control Register.
 Clear pending interrupts, such as NACK. 
 Reset FIFO mode register 
 Flush FIFOs 
 if only one byte is to be read, immediately stop transfer 
		
		  When using dma without alternative command mode, the last
		  byte has to be read manually in order to not send the stop
		  command too late and then to receive extra data.
		  In practice, there are some issues if you use the dma to
		  read n-1 bytes because of latency.
		  Reading n-2 bytes with dma and the two last ones manually
		  seems to be the best solution.
 first stop DMA transfer if still in progress 
 then flush THRFIFO and unlock TX if locked 
	
	  some faulty I2C slave devices might hold SDA down;
	  we can send a bus clear command, hoping that the pins will be
	  released
 1st msg is put into the internal address, start with 2nd 
  The hardware can handle at most two messages concatenated by a
  repeated start via it's internal address feature.
	
	  The actual width of the access will be chosen in
	  dmaengine_prep_slave_sg():
	  for each buffer in the scatter-gather list, if its size is aligned
	  to addr_width then addr_width accesses will be performed to transfer
	  the buffer. On the other hand, if the buffer size is not aligned to
	  addr_width then the buffer is transferred using single byte accesses.
	  Please refer to the Atmel eXtended DMA controller driver.
	  When FIFOs are used, the TXRDYM threshold can always be set to
	  trigger the XDMAC when at least 4 data can be written into the TX
	  FIFO, even if single byte accesses are performed.
	  However the RXRDYM threshold must be set to fit the access width,
	  deduced from buffer length, so the XDMAC is triggered properly to
	  read data from the RX FIFO.
 SPDX-License-Identifier: GPL-2.0
  driversi2cbussesi2c-mt7621.c
  Copyright (C) 2013 Steven Liu <steven_liu@mediatek.com>
  Copyright (C) 2016 Michael Lee <igvtee@gmail.com>
  Copyright (C) 2018 Jan Breuer <jan.breuer@jaybee.cz>
  Improve driver for i2cdetect from i2c-tools to detect i2c devices on the bus.
  (C) 2014 Sittisak <sittisaks@hotmail.com>
 REG_SM0CFG2_REG 
 REG_SM0CTL0_REG 
 REG_SM0CTL1_REG 
 timeout waiting for I2C devices to respond 
	
	  Don't set SM0CTL0_ODRAIN as its bit meaning is inverted. To
	  configure open-drain mode, this bit needs to be cleared.
 wait hardware idle 
 start sequence 
 write address 
 10 bits address 
 7 bits address 
 check address ACK 
 transfer data 
 the return value is number of executed messages 
 sentinel  }
  Copyright (C) 2014 Broadcom Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  PER_I2CBSC count register mask depends on 1 byte4 byte data register
  size. Cable modem and DSL SoCs with Peripheral i2c cores use 1 byte per
  data register whereas STB SoCs use 4 byte per data register transfer,
  account for this difference in total count per transaction and mask to
  use.
 BSC CTL register field definitions 
 BSC_IIC_ENABLE rw enable and interrupt field definitions 
 BSC_CTLHI control register field definitions 
 msecs 
 Condition mask used for non combined transfer 
 BSC data transfer direction 
 BSC data transfer direction combined format 
 BSC block register map structure to cache fields to be written 
 slave address 
 tx data buffer
 rxtx data length 
 control register 
 xfer enable and status 
 rx data buffer 
 more control fields 
 reserved 
 register accessors for both be and le cpu arch 
 Enable BSC  CTL interrupt line 
 Disable BSC CTL interrupt line 
 Wait for device to be ready 
 i2c xfer completion function, handles both irq and polling mode 
 we are in polling mode 
 Set xfer STARTSTOP conditions for subsequent transfer 
 Send I2C request check completion 
 Make sure the hardware is ready 
 only if we are in interrupt mode 
 enable BSC CTL interrupt line 
 initiate transfer by setting iic_enable 
 Wait for transaction to finish or timeout 
 Actual data transfer through the BSC master 
 see if the transaction needs to check NACK conditions 
 set data transfer direction 
 set the readwrite length 
 Write data into data_in register 
 Initiate xfer, the function will return on completion 
 Read data from data_out register 
 Write a single byte of data to the i2c bus 
 Send i2c address 
 First byte is 11110XX0 where XX is upper 2 bits 
 Second byte is the remaining 8 bits 
 For read, send restart without stop condition 
 Then re-send the first byte with the read bit set 
 Master transfer function 
 Loop through all messages 
 Send slave address 
 Perform data transfer 
 in case we did not get find a valid speed 
 set 4 byte data inout xfers  
 set bus speed 
 Map hardware registers 
 We need to reset the controller after the release 
 Allocate memory for private data structure 
 Map hardware registers 
 Get the interrupt number 
 disable the bsc interrupt line 
 register the ISR handler 
 set the data inout register size for compatible SoCs 
 Add the i2c adapter 
 SPDX-License-Identifier: GPL-2.0-or-later
  I2C bus driver for the Cadence I2C controller.
  Copyright (C) 2009 - 2014 Xilinx, Inc.
 Register offsets for the I2C device. 
 Control Register, RW 
 Status Register, RO 
 I2C Address Register, RW 
 I2C Data Register, RW 
 IRQ Status Register, RW 
 Transfer Size Register, RW 
 Time Out Register, RW 
 IRQ Mask Register, RO 
 IRQ Enable Register, WO 
 IRQ Disable Register, WO 
 Control Register Bit mask definitions 
 Hold Bus bit 
 Read or Write Master transfer 0 = Transmitter, 1 = Receiver 
 1 = Auto init FIFO to zeroes 
 Status Register Bit mask definitions 
  I2C Address Register Bit mask definitions
  Normal addressing mode uses [6:0] bits. Extended addressing mode uses [9:0]
  bits. A write access to this register always initiates a transfer if the I2C
  is in master mode.
 I2C Address Mask 
  I2C Interrupt Registers Bit mask definitions
  All the four interrupt registers (StatusMaskEnableDisable) have the same
  bit definitions.
 timeout for pm runtime autosuspend 
 ms 
 FIFO depth at which the DATA interrupt occurs 
 Transfer size in multiples of data interrupt depth 
  enum cdns_i2c_mode - I2C Controller current operating mode
  @CDNS_I2C_MODE_SLAVE:       I2C controller operating in slave mode
  @CDNS_I2C_MODE_MASTER:      I2C Controller operating in master mode
  enum cdns_i2c_slave_state - Slave state when I2C is operating in slave mode
  @CDNS_I2C_SLAVE_STATE_IDLE: I2C slave idle
  @CDNS_I2C_SLAVE_STATE_SEND: I2C slave sending data to master
  @CDNS_I2C_SLAVE_STATE_RECV: I2C slave receiving data from master
  struct cdns_i2c - I2C device private data structure
  @dev:		Pointer to device structure
  @membase:		Base address of the I2C device
  @adap:		I2C adapter instance
  @p_msg:		Message pointer
  @err_status:		Error status in Interrupt Status Register
  @xfer_done:		Transfer complete status
  @p_send_buf:		Pointer to transmit buffer
  @p_recv_buf:		Pointer to receive buffer
  @send_count:		Number of bytes still expected to send
  @recv_count:		Number of bytes still expected to receive
  @curr_recv_count:	Number of bytes to be received in current transfer
  @irq:		IRQ number
  @input_clk:		Input clock to I2C controller
  @i2c_clk:		Maximum I2C clock speed
  @bus_hold_flag:	Flag used in repeated start for clearing HOLD bit
  @clk:		Pointer to struct clk
  @clk_rate_change_nb:	Notifier block for clock rate changes
  @quirks:		flag for broken hold bit usage in r1p10
  @ctrl_reg:		Cached value of the control register.
  @ctrl_reg_diva_divb: value of fields DIV_A and DIV_B from CR register
  @slave:		Registered slave instance.
  @dev_mode:		I2C operating role(masterslave).
  @slave_state:	I2C Slave state(idlereadwrite).
  cdns_i2c_clear_bus_hold - Clear bus hold bit
  @id:	Pointer to driver data struct
  Helper to clear the controller's bus hold bit.
 Disable all interrupts 
 Clear FIFO and transfer size 
 Update device mode and state 
 Enable i2c master 
		
		  This delay is needed to give the IP some time to switch to
		  the master mode. With lower values(like 110 us) i2cdetect
		  will not detect any slave and without this delay, the IP will
		  trigger a timeout interrupt.
 Enable i2c slave 
 Setting slave address 
 Enable slave sendreceive interrupts 
 Prepare backend for data reception 
 Fetch number of bytes to receive 
 Read data and send to backend 
 Prepare backend for data transmission 
 Send data over bus 
  cdns_i2c_slave_isr - Interrupt handler for the I2C device in slave role
  @ptr:       Pointer to I2C device private data
  This function handles the data interrupt and transfer complete interrupt of
  the I2C device in slave role.
  Return: IRQ_HANDLED always
 Fetch the interrupt status 
 Ignore masked interrupts 
 Fetch transfer mode (sendreceive) 
 Handle data sendreceive 
 Send data to master 
 Receive data from master 
 Master indicated xfer stop or fifo underflowoverflow 
  cdns_i2c_master_isr - Interrupt handler for the I2C device in master role
  @ptr:       Pointer to I2C device private data
  This function handles the data interrupt, transfer complete interrupt and
  the error interrupts of the I2C device in master role.
  Return: IRQ_HANDLED always
 Signal completion only after everything is updated 
 Handling nack and arbitration lost interrupt 
	
	  Check if transfer size register needs to be updated again for a
	  large data receive operation.
 When receiving, handle data interrupt and completion interrupt 
 Read data if receive data valid is set 
				
				  Clear hold bit that was set for FIFO control
				  if RX data left is less than or equal to
				  FIFO DEPTH unless repeated start is selected
		
		  The controller sends NACK to the slave when transfer size
		  register reaches zero without considering the HOLD bit.
		  This workaround is implemented for large data transfers to
		  maintain transfer size non-zero while performing a large
		  receive operation.
 wait while fifo is full 
			
			  Check number of bytes to be received against maximum
			  transfer size and update register accordingly.
 Set the slave address in address register
 Clear hold (if not repeated start) and signal completion 
 When sending, handle transfer complete interrupt 
		
		  If there is more data to be sent, calculate the
		  space available in FIFO and fill with that many bytes.
			
			  Signal the completion of transaction and
			  clear the hold bus bit if there are no
			  further messages to be processed.
 Update the status for errors 
  cdns_i2c_isr - Interrupt handler for the I2C device
  @irq:	irq number for the I2C device
  @ptr:	void pointer to cdns_i2c structure
  This function passes the control to slavemaster based on current role of
  i2c controller.
  Return: IRQ_HANDLED always
  cdns_i2c_mrecv - Prepare and start a master receive operation
  @id:		pointer to the i2c device structure
 Put the controller in master receive mode and clear the FIFO 
	
	  Check for the message size against FIFO depth and set the
	  'hold bus' bit if it is greater than FIFO depth.
 Clear the interrupts in interrupt status register 
	
	  The no. of bytes to receive is checked against the limit of
	  max transfer size. Set transfer size register with no of bytes
	  receive if it is less than transfer size and transfer size if
	  it is more. Enable the interrupts.
 Determine hold_clear based on number of bytes to receive and hold flag 
		
		  In case of Xilinx Zynq SOC, clear the HOLD bit before transfer size
		  register reaches '0'. This is an IP bug which causes transfer size
		  register overflow to 0xFF. To satisfy this timing requirement,
		  disable the interrupts on current processor core between register
		  writes to slave address register and control register.
 Read it back to avoid bufferring and make sure write happens 
  cdns_i2c_msend - Prepare and start a master send operation
  @id:		pointer to the i2c device
 Set the controller in Master transmit mode and clear the FIFO. 
	
	  Check for the message size against FIFO depth and set the
	  'hold bus' bit if it is greater than FIFO depth.
 Clear the interrupts in interrupt status register. 
	
	  Calculate the space available in FIFO. Check the message length
	  against the space available, and fill the FIFO accordingly.
	  Enable the interrupts.
	
	  Clear the bus hold flag if there is no more data
	  and if it is the last message.
 Set the slave address in address register - triggers operation. 
  cdns_i2c_master_reset - Reset the interface
  @adap:	pointer to the i2c adapter driver instance
  This function cleanup the fifos, clear the hold bit and status
  and disable the interrupts.
 Disable the interrupts 
 Clear the hold bit and fifos 
 Update the transfercount register to zero 
 Clear the interrupt status register 
 Clear the status register 
 Check for the TEN Bit mode on each msg 
 Check for the RW flag on each msg 
 Wait for the signal of completion 
 If it is bus arbitration error, try again 
  cdns_i2c_master_xfer - The main i2c transfer function
  @adap:	pointer to the i2c adapter driver instance
  @msgs:	pointer to the i2c message structure
  @num:	the number of messages to transfer
  Initiates the sendrecv activity based on the transfer message received.
  Return: number of msgs processed on success, negative error otherwise
 Check i2c operating mode and switch if possible 
 Set mode to master 
 Mark flag to change role once xfer is completed 
 Check if the bus is free 
	
	  Set the flag to one when multiple messages are to be
	  processed with a repeated start.
		
		  This controller does not give completion interrupt after a
		  master receive message if HOLD bit is set (repeated start),
		  resulting in SW timeout. Hence, if a receive message is
		  followed by any other message, an error is returned
		  indicating that this sequence is not supported.
 Process the msg one by one 
 Report the other error interrupts to application 
 Switch i2c mode to slave 
  cdns_i2c_func - Returns the supported features of the I2C driver
  @adap:	pointer to the i2c adapter structure
  Return: 32 bit value, each bit corresponding to a feature
 Store slave information 
 Enable I2C slave 
 Remove slave information 
 Enable I2C master 
  cdns_i2c_calc_divs - Calculate clock dividers
  @f:		I2C clock frequency
  @input_clk:	Input clock frequency
  @a:		First divider (return value)
  @b:		Second divider (return value)
  f is used as input and output variable. As input it is used as target I2C
  frequency. On function exit f holds the actually resulting I2C frequency.
  Return: 0 on success, negative errno otherwise.
 calculate (divisor_a+1) x (divisor_b+1) 
	
	  If the calculated value is negative or 0, the fscl input is out of
	  range. Return error.
  cdns_i2c_setclk - This function sets the serial clock rate for the I2C device
  @clk_in:	I2C clock input frequency in Hz
  @id:		Pointer to the I2C device structure
  The device must be idle rather than busy transferring data before setting
  these device options.
  The data rate is set by values in the control register.
  The formula for determining the correct register values is
 	Fscl = Fpclk(22 x (divisor_a+1) x (divisor_b+1))
  See the hardware data sheet for a full explanation of setting the serial
  clock rate. The clock can not be faster than the input clock divide by 22.
  The two most common clock rates are 100KHz and 400KHz.
  Return: 0 on success, negative error otherwise
  cdns_i2c_clk_notifier_cb - Clock rate change callback
  @nb:		Pointer to notifier block
  @event:	Notification reason
  @data:	Pointer to notification data object
  This function is called when the cdns_i2c input clock frequency changes.
  The callback checks whether a valid bus frequency can be generated after the
  change. If so, the change is acknowledged, otherwise the change is aborted.
  New dividers are written to the HW in the pre- or post change notification
  depending on the scaling direction.
  Return:	NOTIFY_STOP if the rate change should be aborted, NOTIFY_OK
 		to acknowledge the change, NOTIFY_DONE if the notification is
 		considered irrelevant.
 scale up 
 scale down 
 scale up 
  cdns_i2c_runtime_suspend -  Runtime suspend method for the driver
  @dev:	Address of the platform_device structure
  Put the driver into low power mode.
  Return: 0 always
  cdns_i2c_init -  Controller initialisation
  @id:		Device private data structure
  Initialise the i2c controller.
	
	  Cadence I2C controller has a bug wherein it generates
	  invalid read transaction after HW timeout in master receiver mode.
	  HW timeout is not used by this driver and the interrupt is disabled.
	  But the feature itself cannot be disabled. Hence maximum value
	  is written to this register to reduce the chances of error.
  cdns_i2c_runtime_resume - Runtime resume
  @dev:	Address of the platform_device structure
  Runtime resume callback.
  Return: 0 on success and error value on error
 end of table  }
  cdns_i2c_probe - Platform registration call
  @pdev:	Handle to the platform device structure
  This function does all the memory allocation and registration for the i2c
  device. User can modify the address mode to 10 bit address mode using the
  ioctl call with option I2C_TENBIT.
  Return: 0 on success, negative error otherwise
 Default retry value. 
 Set initial mode to master 
  cdns_i2c_remove - Unregister the device after releasing the resources
  @pdev:	Handle to the platform device structure
  This function frees all the resources allocated to the device.
  Return: 0 always
 SPDX-License-Identifier: GPL-2.0
  Intel BayTrail PMIC I2C bus semaphore implementation
  Copyright (c) 2014, Intel Corporation.
 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
  AMD MP2 PCIe communication driver
  Authors: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
           Elie Morisse <syniurge@gmail.com>
 there is only one data mailbox for two i2c adapters 
 Set up intx irq 
 CONFIG_PM 
 SPDX-License-Identifier: GPL-2.0-or-later
    Copyright (c) 1999  Frodo Looijaard <frodol@dds.nl> and
    Philip Edelbrock <phil@netroedge.com> and
    Mark D. Studebaker <mdsxyz123@yahoo.com>
    This is the driver for the SMB Host controller on
    Acer Labs Inc. (ALI) M1541 and M1543C South Bridges.
    The M1543C is a South bridge for desktop systems.
    The M1533 is a South bridge for portable systems.
    They are part of the following ALI chipsets:
       "Aladdin Pro 2": Includes the M1621 Slot 1 North bridge
       with AGP and 100MHz CPU Front Side bus
       "Aladdin V": Includes the M1541 Socket 7 North bridge
       with AGP and 100MHz CPU Front Side bus
       "Aladdin IV": Includes the M1541 Socket 7 North bridge
       with host bus up to 83.3 MHz.
    For an overview of these chips see http:www.acerlabs.com
    The M1533M1543C devices appear as FOUR separate devices
    on the PCI bus. An output of lspci will show something similar
    to the following:
	00:02.0 USB Controller: Acer Laboratories Inc. M5237
	00:03.0 Bridge: Acer Laboratories Inc. M7101
	00:07.0 ISA bridge: Acer Laboratories Inc. M1533
	00:0f.0 IDE interface: Acer Laboratories Inc. M5229
    The SMB controller is part of the 7101 device, which is an
    ACPI-compliant Power Management Unit (PMU).
    The whole 7101 device has to be enabled for the SMB to work.
    You can't just enable the SMB alone.
    The SMB and the ACPI have separate IO spaces.
    We make sure that the SMB is enabled. We leave the ACPI alone.
    This driver controls the SMB Host only.
    The SMB Slave controller on the M15X3 is not enabled.
    This driver does not use interrupts.
 Note: we assume there can only be one ALI15X3, with one SMBus interface 
 ALI15X3 SMBus address offsets 
 PCI Address Constants 
 used to unlock xxxBA registers 
 Other settings 
 times 1100 sec 
 this is what the Award 1004 BIOS sets them to on a ASUS P5A MB.
   We don't use these here. If the bases aren't set to some value we
   tell user to upgrade BIOS and we fail.
 ALI15X3 address lock bits 
 ALI15X3 command constants 
 ALI15X3 status register bits 
 device error 
 collision or no response 
 terminated by abort 
 all the bad error bits 
 If force_addr is set to anything different from 0, we forcibly enable
	 Check the following things:
		- SMB IO address is initialized
		- Device is enabled
		- We can use the addresses
	 Unlock the register.
	   The data sheet says that the address registers are read-only
	   if the lock bits are 1, but in fact the address registers
	   are zero unless you clear the lock bits.
 Determine the address of the SMBus area 
 make sure it works 
 check if whole device is enabled 
 Is SMB Host controller enabled? 
 set SMB clock to 74KHz as recommended in data sheet 
	
	  The interrupt routing for SMB is set up in register 0x77 in the
	  1533 ISA Bridge device, NOT in the 7101 device.
	  Don't bother with finding the 1533 device and reading the register.
	if ((....... & 0x0F) == 1)
		dev_dbg(&ALI15X3_dev->dev, "ALI15X3 using Interrupt 9 for SMBus.\n");
 Another internally used function 
 get status 
 Make sure the SMBus host is ready to start transmitting 
 Check the busy bit first 
	
	   If the host controller is still busy, it may have timed out in the
	   previous transaction, resulting in a "SMBus Timeout" Dev.
	   I've tried the following to reset a stuck busy bit.
		1. Reset the controller with an ABORT command.
		   (this doesn't seem to clear the controller if an external
		   device is hung)
		2. Reset the controller and the other SMBus devices with a
		   T_OUT command.  (this clears the host busy bit if an
		   external device is hung, but it comes back upon a new access
		   to a device)
		3. Disable and reenable the controller in SMBHSTCFG
	   Worst case, nothing seems to work except power reset.
 Abort - reset the host controller 
	
	   Try resetting entire SMB bus, including other devices -
	   This may not work either - it clears the BUSY bit but
	   then the BUSY bit may come back on when you try and use the chip again.
	   If that's the case you are stuck.
 now check the error bits and the busy bit 
 do a clear-on-write 
			 this is probably going to be correctable only by a power reset
 This may be a bus or device with electrical problems. 
 check and clear done bit 
 start the transaction by writing anything to the start register 
 We will always wait for a fraction of a second! 
 If the SMBus is still busy, we give up 
	
	  Unfortunately the ALI SMB controller maps "no response" and "bus
	  collision" into a single bit. No response is the usual case so don't
	  do a printk.
	  This means that bus collisions go unreported.
 haven't ever seen this 
 Return negative errno on error. 
 clear all the bits (clear-on-write) 
 make sure SMBus is idle 
 Reset SMBBLKDAT 
 output command 
 Result put in SMBHSTDAT0 
 Reset SMBBLKDAT 
 set up the sysfs linkage to our parent device 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2006-2007 PA Semi, Inc
  SMBus host driver for PA Semi PWRficient
 Register offsets 
 Register defs 
 Got NACK? 
 Clear XEN 
 All our ops take 8-bit shifted addresses 
 set up the sysfs linkage to our parent device 
  (C) Copyright 2009-2010
  Nokia Siemens Networks, michael.lawnick.ext@nsn.com
  Portions Copyright (C) 2010 - 2016 Cavium, Inc.
  This is a driver for the i2c adapter in Cavium Networks' OCTEON processors.
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  octeon_i2c_int_enable - enable the CORE interrupt
  @i2c: The struct octeon_i2c
  The interrupt will be asserted when there is non-STAT_IDLE state in
  the SW_TWSI_EOP_TWSI_STAT register.
 disable the CORE interrupt 
 clear TSSTIFLG events 
  octeon_i2c_int_enable78 - enable the CORE interrupt
  @i2c: The struct octeon_i2c
  The interrupt will be asserted when there is non-STAT_IDLE state in the
  SW_TWSI_EOP_TWSI_STAT register.
	
	  The interrupt can be disabled in two places, but we only
	  want to make the disable_irq_nosync() call once, so keep
	  track with the atomic variable.
 disable the CORE interrupt 
  octeon_i2c_hlc_int_enable78 - enable the ST interrupt
  @i2c: The struct octeon_i2c
  The interrupt will be asserted when there is non-STAT_IDLE state in
  the SW_TWSI_EOP_TWSI_STAT register.
 disable the ST interrupt 
 HLC interrupt service routine 
 All adaptors have an irq.  
	
	  "clock-rate" is a legacy binding, the official binding is
	  "clock-frequency".  Try the official one first and then
	  fall back if it doesn't exist.
 SPDX-License-Identifier: GPL-2.0-only
 ------------------------------------------------------------------------- 
 i2c-iop3xx.c i2c driver algorithms for Intel XScale IOP3xx & IXP46x       
 ------------------------------------------------------------------------- 
 Copyright (C) 2003 Peter Milne, D-TACQ Solutions Ltd
                     <Peter dot Milne at D hyphen TACQ dot com>
  With acknowledgements to i2c-algo-ibm_ocp.c by
  Ian DaSilva, MontaVista Software, Inc. idasilva@mvista.com
  And i2c-algo-pcf.c, which was created by Simon G. Vogl and Hans Berglund:
  Copyright (C) 1995-1997 Simon G. Vogl, 1998-2000 Hans Berglund
  And which acknowledged Kyösti Mälkki <kmalkki@cc.hut.fi>,
  Frodo Looijaard <frodol@dds.nl>, Martin Bailey<mbailey@littlefeet-inc.com>
  Major cleanup by Deepak Saxena <dsaxena@plexity.net>, 012005:
  - Use driver model to pass per-chip info instead of hardcoding and #ifdefs
  - Use ioremap__raw_readl__raw_writel instead of direct dereference
  - Make it work with IXP46x chips
  - Cleanup function names, coding style, etc
  - writing to slave address causes latchup on iop331.
 	fix: driver refuses to address self.
 global unit counter 
 Follows devman 9.3 
	
	  Every time unit enable is asserted, GPOD needs to be cleared
	  on IOP3XX to avoid data corruption on the bus. We use the
	  gpiod_set_raw_value() to make sure the 0 hits the hardware
	  GPOD register. These descriptors are only passed along to
	  the device if this is necessary.
 NB SR bits not same position as CR IE bits :-( 
  NB: the handler has to clear the source of the interrupt!
  Then it passes the SR flags of interest to BH via adap data
 check all error conditions, clear them , report most important 
  sleep until interrupted, then recover and analyse the SR
  saved by handler
 returns 1 on correct comparison 
  Concrete compare_funcs
	 avoid writing to my slave address (hangs on 80331),
	  forbidden in Intel developer manual
  Description:  This function implements combined transactions.  Combined
  transactions consist of combinations of reading and writing blocks of data.
  FROM THE SAME ADDRESS
  Each transfer (i.e. a read or a write) is separated by a repeated start
  condition.
  master_xfer() - main readwrite entry
	
	  Disable the actual HW unit
 set the adapter enumeration # 
	
	  Default values...should these come in from board code?
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
 M_CMD OP codes for I2C 
 M_CMD params for I2C 
 I2C SCL COUNTER fields 
  Hardware uses the underlying formula to calculate time periods of
  SCL clock cycle. Firmware uses some additional cycles excluded from the
  below formula and it is confirmed that the time periods are within
  specification limits.
  time of high period of SCL: t_high = (t_high_cnt  clk_div)  source_clock
  time of low period of SCL: t_low = (t_low_cnt  clk_div)  source_clock
  time of full period of SCL: t_cycle = (t_cycle_cnt  clk_div)  source_clock
  clk_freq_out = t  t_cycle
  source_clock = 19.2 MHz
 Disable the TX Watermark interrupt to stop TX 
 TX Complete, Disable the TX Watermark interrupt 
 if this is err with done-bit not set, handle that through timeout. 
 Get FIFO IRQ 
 Set device in suspended since resume failed 
 Disable the interrupt so that the system can enter low-power mode 
	
	  Set the bus quota for core and cpu to a reasonable value for
	  register access.
	  Set quota for DDR based on bus speed.
 Make client i2c transfers start failing 
 SPDX-License-Identifier: GPL-2.0-or-later
    SMBus driver for nVidia nForce2 MCP
    Added nForce3 Pro 150  Thomas Leibold <thomas@plx.com>,
	Ported to 2.5 Patrick Dreker <patrick@dreker.de>,
    Copyright (c) 2003  Hans-Frieder Vogt <hfvogt@arcor.de>,
    Based on
    SMBus 2.0 driver for AMD-8111 IO-Hub
    Copyright (c) 2002 Vojtech Pavlik
    SUPPORTED DEVICES		PCI ID
    nForce2 MCP			0064
    nForce2 Ultra 400 MCP	0084
    nForce3 Pro150 MCP		00D4
    nForce3 250Gb MCP		00E4
    nForce4 MCP			0052
    nForce4 MCP-04		0034
    nForce MCP51		0264
    nForce MCP55		0368
    nForce MCP61		03EB
    nForce MCP65		0446
    nForce MCP67		0542
    nForce MCP73		07D8
    nForce MCP78S		0752
    nForce MCP79		0AA2
    This driver supports the 2 SMBuses that are included in the MCP of the
    nForce2345xx chipsets.
 Note: we assume there can only be one nForce2, with two SMBus interfaces 
  nVidia nForce2 SMBus control register definitions
  (Newer incarnations use standard BARs 4 and 5 instead)
  ACPI 2.0 chapter 13 SMBus 2.0 EC register model
 protocol, PEC 
 status 
 address 
 command 
 32 data registers 
#define NVIDIA_SMB_BCNT		(smbus->base + 0x24)	 number of data
#define NVIDIA_SMB_STATUS_ABRT	(smbus->base + 0x3c)	 register used to
							   check the status of
 control register 
#define NVIDIA_SMB_STATUS_ABRT_STS	0x01		 Bit to notify that
 Misc definitions 
 We disable the second SMBus channel on these boards 
 For multiplexing support, we need a global reference to the 1st
 Return negative errno on error 
 other functionality might be possible, but is not tested 
 Older incarnations of the device used non-standard BARs 
 we support 2 SMBus adapters 
 SMBus adapter 1 
 to have a check value 
 SMBus adapter 2 
 to have a check value 
 we did not find even one of the SMBuses, so we give up 
 SPDX-License-Identifier: GPL-2.0
  Driver for the Renesas R-Car I2C unit
  Copyright (C) 2014-19 Wolfram Sang <wsa@sang-engineering.com>
  Copyright (C) 2011-2019 Renesas Electronics Corporation
  Copyright (C) 2012-14 Renesas Solutions Corp.
  Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
  This file is based on the driversi2cbussesi2c-sh7760.c
  (c) 2005-2008 MSC Vertriebsges.m.b.H, Manuel Lauss <mlau@msc-ge.com>
 register offsets 
 slave ctrl 
 master ctrl 
 slave status 
 master status 
 slave irq enable 
 master irq enable 
 clock dividers 
 slave address 
 master address 
 data port 
 first bit setup cycle (Gen3) 
 DMA enable (Gen3) 
 ICSCR 
 slave data buffer select 
 slave interface enable 
 general call address enable 
 forced non acknowledgment 
 ICMCR 
 non-fifo mode switch 
 override SCL pin 
 override SDA pin 
 override pins 
 master if enable 
 force stop bit 
 enable start bit gen 
 ICSSR (also for ICSIER) 
 general call received 
 slave transmit mode 
 stop received 
 slave data empty 
 slave data transmitted 
 slave data received 
 slave addr received 
 ICMSR (also for ICMIE) 
 nack received 
 arbitration lost 
 sent a stop 
 slave addr xfer done 
 ICDMAER 
 DMA Slave Received Enable 
 DMA Slave Transmitted Enable 
 DMA Master Received Enable 
 DMA Master Transmitted Enable 
 ICFBSCR 
 17Tcyc delay 1st bit between SDA and SCL 
 persistent flags 
 HW forbids RXDMA sometimes 
 protected by adapter lock 
 reset master mode 
 start clock 
 Waiting did not help, try to recover 
 Fall back to previously used values if not supplied 
	
	  calculate SCL clock
	  see
	 	ICCCR
	 
	  ick	= clkp  (1 + CDF)
	  SCL	= ick  (20 + SCGD  8 + F[(ticf + tr + intd)  ick])
	 
	  ick  : I2C internal clock < 20 MHz
	  ticf : I2C SCL falling time
	  tr   : I2C SCL rising  time
	  intd : LSI internal delay
	  clkp : peripheral_clk
	  F[]  : integer up-valuation
	
	  it is impossible to calculate large scale
	  number on u32. separate it
	 
	  F[(ticf + tr + intd)  ick] with sum = (ticf + tr + intd)
	   = F[sum  ick  1000000000]
	   = F[(ick  1000000)  sum  1000]
	
	  SCL	= ick  (20 + SCGD  8 + F[(ticf + tr + intd)  ick])
	 
	  Calculation result (= SCL) should be less than
	  bus_speed for hardware safety
	 
	  We could use something along the lines of
	 	div = ick  (bus_speed + 1) + 1;
	 	scgd = (div - 20 - round + 7)  8;
	 	scl = ick  (20 + (scgd  8) + round);
	  (not fully verified) but that would get pretty involved
 keep icccr value 
	
	  We don't have a test case but the HW engineers say that the write order
	  of ICMSR and ICMCR depends on whether we issue START or REP_START. Since
	  it didn't cause a drawback for me, let's rather be safe than sorry.
 Gen3 can only do one RXDMA per transfer and we just completed it 
 Disable DMA Master ReceivedTransmitted, must be last! 
 Do various checks to see if DMA is feasible at all 
		
		  The last two bytes needs to be fetched using PIO in
		  order for the STOP phase to work.
		
		  First byte in message was sent using PIO.
 Enable DMA Master ReceivedTransmitted 
 FIXME: sometimes, unknown interrupt happened. Do nothing 
 Check if DMA can be enabled and take over 
		
		  Prepare next data to ICRXTX register.
		  This data will go to _SHIFT_ register.
		 
		     
		  [ICRXTX] -> [SHIFT] -> [I2C bus]
		
		  The last data was pushed to ICRXTX on _PREV_ empty irq.
		  It is on _SHIFT_ register, and will sent to I2C bus.
		 
		 		  
		  [ICRXTX] -> [SHIFT] -> [I2C bus]
			
			  If current msg is the _LAST_ msg,
			  prepare stop condition here.
			  ID_DONE will be set on STOP irq.
 FIXME: sometimes, unknown interrupt happened. Do nothing 
		
		  Address transfer phase finished, but no data at this point.
		  Try to use DMA to receive data.
 get received data 
 If next received data is the _LAST_, go to new phase. 
 address detected 
 read or write request 
 dummy read 
 Clear SSR, too, because of old STOPs to other clients than us 
 master sent stop 
 clear our NACK 
 master wants to write to us 
 Send NACK in case of error 
 master wants to read from us 
  This driver has a lock-free design because there are IP cores (at least
  R-Car Gen2) which have an inherent race condition in their hardware design.
  There, we need to switch to RCAR_BUS_PHASE_DATA as soon as possible after
  the interrupt was generated, otherwise an unwanted repeated message gets
  generated. It turned out that taking a spinlock at the beginning of the ISR
  was already causing repeated messages. Thus, this driver was converted to
  the now lockless behaviour. Please keep this in mind when hacking the driver.
  R-Car Gen3 seems to have this fixed but earlier versions than R-Car Gen2 are
  likely affected. Therefore, we have different interrupt handler entries.
 Arbitration lost 
 Nack 
 HW automatically sends STOP after received NACK 
 Stop 
 The last message also made it 
 Clear START or STOP immediately, except for REPSTART after read 
 Only handle interrupts that are currently enabled 
 Only handle interrupts that are currently enabled 
	
	  Clear START or STOP immediately, except for REPSTART after read or
	  if a spurious interrupt was detected.
 I2C is a special case, we need to poll the status of a reset 
 Check bus state before init otherwise bus busy info will be lost 
 Gen3 needs a reset before allowing RXDMA once 
 init first message 
 cleanup DMA if it couldn't complete properly due to an error 
 The number of transfer 
 Check bus state before init otherwise bus busy info will be lost 
 init first message 
 The number of transfer 
 Keep device active for slave address detection logic 
 ensure no irq is running before clearing ptr 
 Gen2: must be 0 if not using slave 
	
	  This HW can't do:
	  I2C_SMBUS_QUICK (setting FSB during START didn't work)
	  I2C_M_NOSTART (automatically sends address after START)
	  I2C_M_IGNORE_NAK (automatically sends STOP after NAK)
 Otherwise logic will break because some bytes must always use PIO 
 Init DMA 
 Activate device for clock calculation 
 Gen2: must be 0 if not using slave 
 Stay always active when multi-master to keep arbitration working 
 CONFIG_PM_SLEEP 
  Cavium ThunderX i2c driver.
  Copyright (C) 2015,2016 Cavium Inc.
  Authors: Fred Martin <fmartin@caviumnetworks.com>
 	    Jan Glauber <jglauber@cavium.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  Enable the CORE interrupt.
  The interrupt will be asserted when there is non-STAT_IDLE state in the
  SW_TWSI_EOP_TWSI_STAT register.
  Disable the CORE interrupt.
 DT 
 ACPI 
 TODO: ACPI support 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2009 ST-Ericsson SA
  Copyright (C) 2009 STMicroelectronics
  I2C master mode controller driver, used in Nomadik 8815
  and Ux500 platforms.
  Author: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
  Author: Sachin Verma <sachin.verma@st.com>
 I2C Controller register offsets 
 Control registers 
 Peripheral Enable 
 Operating mode 
 Slave addressing mode 
 Speed mode 
 Slave general call mode 
 Flush Transmit 
 Flush Receive 
 DMA Tx enable 
 DMA Rx Enable 
 DMA sync. logic enable 
 Loopback mode 
 Filtering on 
 Force stop enable 
 Master controller (MCR) register 
 Operation 
 7-bit address 
 10-bit Extended address 
 Extended address 
 Address type 
 Stop condition 
 Transaction length 
 Status register (SR) 
 Operation 
 controller status 
 Abort cause 
 Receive type 
 Transfer length 
 Interrupt mask setclear (IMSCR) bits 
 some bits in ICR are reserved 
 first three msb bits are reserved 
 maximum threshold value 
 up to 100 Kbs 
 up to 400 Kbs 
 up to 3.4 Mbs 
 up to 1 Mbs 
  struct i2c_vendor_data - per-vendor variations
  @has_mtdws: variant has the MTDWS bit
  @fifodepth: variant FIFO depth
 operation 
  struct i2c_nmk_client - client specific data
  @slave_adr: 7-bit slave address
  @count: no. bytes to be transferred
  @buffer: client data buffer
  @xfer_bytes: bytes transferred till now
  @operation: current I2C operation
  struct nmk_i2c_dev - private data structure of the controller.
  @vendor: vendor data for this variant.
  @adev: parent amba device.
  @adap: corresponding I2C adapter.
  @irq: interrupt line for the controller.
  @virtbase: virtual io memory area.
  @clk: hardware i2c block clock.
  @cli: holder of client specific data.
  @clk_freq: clock frequency for the operation mode
  @tft: Tx FIFO Threshold in bytes
  @rft: Rx FIFO Threshold in bytes
  @timeout: Slave response timeout (ms)
  @sm: speed mode
  @stop: stop condition.
  @xfer_complete: acknowledge completion for a I2C message.
  @result: controller propogated result.
 controller's abort causes 
  flush_i2c_fifo() - This function flushes the I2C FIFO
  @dev: private data of I2C Driver
  This function flushes the I2C Tx and Rx FIFOs. It returns
  0 on successful flushing of FIFO
	
	  flush the transmit and receive FIFO. The flushing
	  operation takes several cycles before to be completed.
	  On the completion, the I2C internal logic clears these
	  bits, until then no one must access Tx, Rx FIFO and
	  should poll on these bits waiting for the completion.
  disable_all_interrupts() - Disable all interrupts of this I2c Bus
  @dev: private data of I2C Driver
  clear_all_interrupts() - Clear all interrupts of I2C Controller
  @dev: private data of I2C Driver
  init_hw() - initialize the I2C hardware
  @dev: private data of I2C Driver
 disable the controller 
 enable peripheral, master mode operation 
  load_i2c_mcr_reg() - load the MCR register
  @dev: private data of controller
  @flags: message flags
 10-bit address transaction 
		
		  Get the top 3 bits.
		  EA10 represents extended address in MCR. This includes
		  the extension (MSB bits) of the 7 bit address loaded
		  in A7
 7-bit address transaction 
 start byte procedure not applied 
 check the operation, master readwrite? 
 stop or repeated start? 
  setup_i2c_controller() - setup the controller
  @dev: private data of controller
	
	  set the slsu:
	 
	  slsu defines the data setup time after SCL clock
	  stretching in terms of i2c clk cycles + 1 (zero means
	  "wait one cycle"), the needed setup time for the three
	  modes are 250ns, 100ns, 10ns respectively.
	 
	  As the time for one cycle T in nanoseconds is
	  T = (1f)  1000000000 =>
	  slsu = cycles  (1000000000  f) + 1
 Fast 
 High 
 Standard 
	
	  The spec says, in case of std. mode the divider is
	  2 whereas it is 3 for fast and fastplus mode of
	  operation. TODO - high speed support.
	
	  generate the mask for baud rate counters. The controller
	  has two baud rate counters. One is used for High speed
	  operation, and the other is for std, fast mode, fast mode
	  plus operation. Currently we do not supprt high speed mode
	  so set brcr1 to 0.
 set the baud rate counter register 
	
	  set the speed mode. Currently we support
	  only standard and fast mode of operation
	  TODO - support for fast mode plus (up to 1Mbs)
	  and high speed (up to 3.4 Mbs)
 set the Tx and Rx FIFO threshold 
  read_i2c() - Read from I2C client device
  @dev: private data of I2C Driver
  @flags: message flags
  This function reads from i2c client device when controller is in
  master mode. There is a completion timeout. If there is no transfer
  before timeout error is returned.
 load the current CR value 
 enable the controller 
 enable interrupts by setting the mask 
 Controller timed out 
 write to the Tx FIFO 
  write_i2c() - Write data to I2C client.
  @dev: private data of I2C Driver
  @flags: message flags
  This function writes data to I2C client
 load the current CR value 
 enable the controller 
 enable interrupts by settings the masks 
 Fill the TX FIFO with transmit data 
	
	  check if we want to transfer a single or multiple bytes, if so
	  set the MTDWS bit (Master Transaction Done Without Stop)
	  to start repeated start operation
 Controller timed out 
  nmk_i2c_xfer_one() - transmit a single I2C message
  @dev: device with a message encoded into it
  @flags: message flags
 read operation 
 write operation 
		
		  Check if the controller I2C operation status
		  is set to ABORT(11b).
 get the abort cause 
  nmk_i2c_xfer() - I2C transfer function used by kernel framework
  @i2c_adap: Adapter pointer to the controller
  @msgs: Pointer to data to be written.
  @num_msgs: Number of messages to be executed
  This is the function called by the generic kernel i2c_transfer()
  or i2c_smbus...() API calls. Note that this code is protected by the
  semaphore set in the kernel i2c_transfer() function.
  NOTE:
  READ TRANSFER : We impose a restriction of the first message to be the
 		index message for any read transaction.
 		- a no index is coded as '0',
 		- 2byte big endian index is coded as '3'
 		!!! msg[0].buf holds the actual index.
 		This is compatible with generic messages of smbus emulator
 		that send a one byte index.
 		eg. a I2C transation to read 2 bytes from index 0
 			idx = 0;
 			msg[0].addr = client->addr;
 			msg[0].flags = 0x0;
 			msg[0].len = 1;
 			msg[0].buf = &idx;
 			msg[1].addr = client->addr;
 			msg[1].flags = I2C_M_RD;
 			msg[1].len = 2;
 			msg[1].buf = rd_buff
 			i2c_transfer(adap, msg, 2);
  WRITE TRANSFER : The I2C standard interface interprets all data as payload.
 		If you want to emulate an SMBUS write transaction put the
 		index as first byte(or first and second) in the payload.
 		eg. a I2C transation to write 2 bytes from index 1
 			wr_buff[0] = 0x1;
 			wr_buff[1] = 0x23;
 			wr_buff[2] = 0x46;
 			msg[0].flags = 0x0;
 			msg[0].len = 3;
 			msg[0].buf = wr_buff;
 			i2c_transfer(adap, msg, 1);
  To read or write a block of data (multiple bytes) using SMBUS emulation
  please use the i2c_smbus_read_i2c_block_data()
  or i2c_smbus_write_i2c_block_data() API
 Attempt three times to send the message queue 
 setup the i2c controller 
 return the no. messages processed 
  disable_interrupts() - disable the interrupts
  @dev: private data of controller
  @irq: interrupt number
  i2c_irq_handler() - interrupt routine
  @irq: interrupt number
  @arg: data passed to the handler
  This is the interrupt handler for the i2c driver. Currently
  it handles the major interrupts like Rx & Tx FIFO management
  interrupts, master transaction interrupts, arbitration and
  bus error interrupts. The rest of the interrupts are treated as
  unhandled.
 load Tx FIFO and Rx FIFO threshold values 
 read interrupt status register 
 Transmit FIFO nearly empty interrupt 
			
			  in read operation why do we care for writing?
			  so disable the Transmit FIFO interrupt
			
			  if done, close the transfer by disabling the
			  corresponding TXFNE interrupt
	
	  Rx FIFO nearly full interrupt.
	  This is set when the numer of entries in Rx FIFO is
	  greater or equal than the threshold value programmed
	  in RFT
 Read the Rx FIFO 
 Rx FIFO full 
 Master Transaction Done withwithout stop 
 Master Arbitration lost interrupt 
	
	  Bus Error interrupt.
	  This happens when an unexpected startstop condition occurs
	  during the transaction.
 get the status 
	
	  Tx FIFO overrun interrupt.
	  This is set when a write operation in Tx FIFO is performed and
	  the Tx FIFO is full.
 unhandled interrupts by this driver - TODO
 Default to 100 kHz if no frequency is given in the node 
 This driver only supports 'standard' and 'fast' modes of operation. 
 Tx FIFO threshold 
 Rx FIFO threshold 
 Slave response timeout(ms) 
 disable the controller 
 Guessed from TFTRRFTR = 7 
 Guessed from TFTRRFTR = 15 
 SPDX-License-Identifier: GPL-2.0-or-later
    Copyright (c) 2003 Mark M. Hoffman <mhoffman@lightlink.com>
    This module must be considered BETA unless and until
    the chipset manufacturer releases a datasheet.
    The register definitions are based on the SiS630.
    This module relies on quirk_sis_96x_smbus (driverspciquirks.c)
    for just about every machine for which users have reported.
    If this module isn't detecting your 96x south bridge, have a 
    look there.
    We assume there can only be one SiS96x with one SMBus interface.
 base address register in PCI config space 
 SiS96x SMBus registers 
 register count for request_region 
 Other settings 
 SiS96x SMBus constants 
 Execute a SMBus transaction.
   int size is from SIS96x_QUICK to SIS96x_BLOCK_DATA
 Make sure the SMBus host is ready to start transmitting 
 kill the transaction 
 check it again 
 Turn off timeout interrupts, set fast host clock 
 clear all (sticky) status flags 
 start the transaction by setting bit 4 and size bits 
 We will always wait for a fraction of a second! 
 If the SMBus is still busy, we give up 
 device error - probably missing ACK 
 bus collision 
 Finish up by resetting the bus 
 Return negative errno on error. 
 Everything is happy, let's grab the memory and set things up. 
 set up the sysfs linkage to our parent device 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
 Copyright (c) 2017-20 Linaro Limited.
 Max number of resources + 1 for a NULL terminator 
 HIGH period of the SCL clock in clock ticks 
 LOW period of the SCL clock 
 set-up time for STOP condition 
 set-up time for a repeated START condition 
 data hold time 
 hold time (repeated) START condition 
 bus free time between a STOP and START condition 
 pulse width of spikes suppressed by the input filter 
	
	  we reset the whole controller, here and for implicity use
	  master[0].xxx for waiting on it.
	
	  Call validate queue to make sure queue is empty before starting.
	  This is to avoid overflow  underflow of queue.
				 The LS byte of this register represents the
				  first byte read from the slave during a read
				  access.
	
	  Call validate queue to make sure queue is empty before starting.
	  This is to avoid overflow  underflow of queue.
 Memory 
 Clocks 
 Retrieve CCI clock rate 
		 cci clock set by the bootloader or via assigned clock rate
		  in DT.
 Interrupt 
 SPDX-License-Identifier: GPL-2.0-only
  driversi2cbussesi2c-tegra-bpmp.c
  Copyright (c) 2016 NVIDIA Corporation.  All rights reserved.
  Author: Shardar Shariff Md <smohammed@nvidia.com>
  Serialized I2C message header size is 6 bytes and includes address, flags
  and length
  Linux flags are translated to BPMP defined I2C flags that are used in BPMP
  firmware I2C driver to avoid any issues in future if Linux I2C flags are
  changed.
  The serialized I2C format is simply the following:
  [addr little-endian][flags little-endian][len little-endian][data if write]
  [addr little-endian][flags little-endian][len little-endian][data if write]
   ...
  The flags are translated from Linux kernel representation to seriali2c
  representation. Any undefined flag being set causes an error.
  The data is there only for writes. Reads have the data transferred in the
  other direction, and thus data is not present.
  See deserialize_i2c documentation for the data format in the other direction.
  The data in the BPMP -> CPU direction is composed of sequential blocks for
  those messages that have I2C_M_RD. So, for example, if you have:
  - !I2C_M_RD, len == 5, data == a0 01 02 03 04
  - !I2C_M_RD, len == 1, data == a0
  - I2C_M_RD, len == 2, data == [uninitialized buffer 1]
  - !I2C_M_RD, len == 1, data == a2
  - I2C_M_RD, len == 2, data == [uninitialized buffer 2]
  ...then the data in the BPMP -> CPU direction would be 4 bytes total, and
  would contain 2 bytes that will go to uninitialized buffer 1, and 2 bytes
  that will go to uninitialized buffer 2.
 SPDX-License-Identifier: GPL-2.0-or-later
    Copyright (c) 1998 - 2002 Frodo Looijaard <frodol@dds.nl> and
    Philip Edelbrock <phil@netroedge.com>
   Supports:
	Intel PIIX4, 440MX
	Serverworks OSB4, CSB5, CSB6, HT-1000, HT-1100
	ATI IXP200, IXP300, IXP400, SB600, SB700SP5100, SB800
	AMD Hudson-2, ML, CZ
	Hygon CZ
	SMSC Victory66
   Note: we assume there can only be one device, with one or more
   SMBus interfaces.
   The device can register multiple i2c_adapters (up to PIIX4_MAX_ADAPTERS).
   For devices supporting multiple ports the i2c_adapter should provide
   an i2c_algorithm to access them.
 PIIX4 SMBus address offsets 
 count for request_region 
 PCI Address Constants 
 Other settings 
 PIIX4 constants 
 Multi-port constants 
 HUDSON2, KERNCZ reserves ports 3, 4 
 SB800 constants 
  SB800 port is selected by bits 2:1 of the smb_en register (0x2c)
  or the smb_sel register (0x2e), depending on bit 0 of register 0x2f.
  Hudson-2Bolton port is always selected by bits 2:1 of register 0x2f.
 On kerncz and Hudson2, SmBus0Sel is at bit 20:19 of PMx00 DecodeEn 
 insmod parameters 
 If force is set to anything different from 0, we forcibly enable the
 If force_addr is set to anything different from 0, we forcibly enable
 The IBM entry is in a separate table because we only check it
  SB800 globals
 SB800 
 Port number, shifted 
	 On some motherboards, it was reported that accessing the SMBus
 Don't access SMBus on IBM systems which get corrupted eeproms 
 Determine the address of the SMBus areas 
	 If force_addr is set, we program the new address here. Just to make
			 This should never need to be done, but has been
			  noted that many Dell machines have the SMBus
			  interface on the PIIX4 disabled!? NOTE: This assumes
			  IO space and other allocations WERE done by the
			  Bios!  Don't complain if your hardware does weird
			  things after enabling this. :') Check for Bios
			  updates before resorting to this.
 SB800 and later SMBus does not support forcing address 
 Determine the address of the SMBus areas 
 Aux SMBus does not support IRQ information 
 Request the SMBus I2C bus config region 
 Find which register is used for port selection 
	 Set up auxiliary SMBus controllers found on some
 Read address of auxiliary SMBus controller 
 Make sure the SMBus host is ready to start transmitting 
 start the transaction by setting bit 6 
 We will always wait for a fraction of a second! (See PIIX4 docs errata) 
 Extra delay for SERVERWORKS_CSB5 
 If the SMBus is still busy, we give up 
 Clock stops and slave is stuck in mid-transmission 
 Return negative errno on error. 
 Reset SMBBLKDAT 
 Reset SMBBLKDAT 
 clear response register 
 request ownership flag 
 kick off IMC Mailbox command 96 
 clear response register 
 release ownership flag 
 kick off IMC Mailbox command 96 
  Handles access to multiple SMBus ports on the SB800.
  The port is selected by bits 2:1 of the smb_en register (0x2c).
  Returns negative errno on error.
  Note: The selected port must be returned to the initial selection to avoid
  problems on certain systems.
 Request the SMBUS semaphore, avoid conflicts with the IMC 
 Check the semaphore status 
 SMBus is still owned by the IMC, we give up 
	
	  Notify the IMC (Integrated Micro Controller) if required.
	  Among other responsibilities, the IMC is in charge of monitoring
	  the System fans and temperature sensors, and act accordingly.
	  All this is done through SMBus and canwill collide
	  with our transactions if they are long (BLOCK_DATA).
	  Therefore we need to request the ownership flag during those
	  transactions.
 If IMC communication fails do not retry 
 Release the semaphore 
 set up the sysfs linkage to our parent device 
			
			  Detect if IMC is active or not, this method is
			  described on coreboot's AMD IMC notes
 base address location etc changed in SB800 
		
		  Try to register multiplexed main SMBus adapter,
		  give up if we can't
 Try to register main SMBus adapter, give up if we can't 
 Check for auxiliary SMBus on some AMD chipsets 
 SB800 added aux bus too 
		 Try to add the aux adapter if it exists,
 SPDX-License-Identifier: GPL-2.0-only
 	i2c-ali1563.c - i2c driver for the ALi 1563 Southbridge
 	Copyright (C) 2004 Patrick Mochel
 		      2005 Rudolf Marek <r.marek@assembler.cz>
 	The 1563 southbridge is deceptively similar to the 1533, with a
 	few notable exceptions. One of those happens to be the fact they
 	upgraded the i2c core to be 2.0 compliant, and happens to be almost
 	identical to the i2c controller found in the Intel 801 south
 	bridges.
 	This driver is based on a mix of the 15x3, 1535, and i801 drivers,
 	with a little help from the ALi 1563 spec.
 Issue 'kill' to host controller 
 device error - no response, ignore the autodetection case 
 bus collision 
 Issue timeout, hoping it helps 
 Clear byte-ready bit 
 Start transaction and wait for byte-ready bit to be set 
 Do we need this? 
 Do we need this? 
 Map the size to what the chip understands 
 Write the command register 
 Beware it uses DAT0 register and not CMD! 
 Result put in SMBHSTDAT0 
	 SMB IO Base in high 12 bits and must be aligned with the
 Check if device is enabled 
 SPDX-License-Identifier: GPL-2.0-only
  SMBus 2.0 driver for AMD-8111 IO-Hub.
  Copyright (c) 2002 Vojtech Pavlik
  AMD PCI control registers definitions.
 deliver SCI 
 deliver PCI IRQ 
 16x clock speedup 
  ACPI 2.0 chapter 13 PCI interface definitions.
 data register 
 status of controller 
 command register 
 interrupt control register 
 smi event pending 
 sci event pending 
 burst mode enabled 
 byte in data reg is command 
 data ready for embedded controller 
 data ready for host 
 read EC 
 write EC 
 enable burst mode 
 disable burst mode 
 query EC 
  ACPI 2.0 chapter 13 access of registers of the EC
  ACPI 2.0 chapter 13 SMBus 2.0 EC register model
 protocol, PEC 
 status 
 address 
 command 
 32 data registers 
 number of data bytes 
 alarm address 
 2 bytes alarm data 
 set up the sysfs linkage to our parent device 
 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
  Mellanox i2c driver
  Copyright (C) 2016-2020 Mellanox Technologies
 General defines 
 usec 
 usec 
 LPC I2C registers 
 LPC I2C masks and parametres 
  Check validity of received i2c messages parameters.
  Returns 0 if OK, other - in case of invalid parameters.
  Check if transfer is completed and status of operation.
  Returns 0 - transfer completed (both ACK or NACK),
  negative - transfer isn't finished.
			
			  The slave is unable to accept the data. No such
			  slave, command not understood, or unable to accept
			  any more data.
	
	  All upper layers currently are never use transfer with more than
	  2 messages. Actually, it's also not so relevant in Mellanox systems
	  because of HW limitation. Max size of transfer is not more than 32
	  or 68 bytes in the current x86 LPCI2C bridge.
 Reset CPLD LPCI2C block 
 Make sure the CPLD is ready to start transmitting. 
  Wait for master transfer to complete.
  It puts current process to sleep until we get interrupt or timeout expires.
  Returns the number of transferred or read bytes or error (<0).
		
		  Actual read data len will be always the same as
		  requested len. 0xff (line pull-up) will be returned
		  if slave has no data to return. Thus don't read
		  MLXCPLD_LPCI2C_NUM_DAT_REG reg from CPLD.  Only in case of
		  SMBus block read transaction data len can be different,
		  check this case.
 Notify HW about SMBus block read transaction 
 Don't write to CPLD buffer in read transaction 
	
	  Set target slave address with command for master transfer.
	  It should be latest executed function before CPLD transaction.
  Generic lpc-i2c transfer.
  Returns the number of processed messages or error (<0).
 Check bus state 
		
		  Usually it means something serious has happened.
		  We can not have unfinished previous transfer
		  so it doesn't make any sense to try to stop it.
		  Probably we were not able to recover from the
		  previous error.
		  The only reasonable thing - is soft reset.
 Do real transfer. Can't fail 
 Wait for transaction complete 
 Read frequency setting. 
 Set frequency only if it is not 100KHz, which is default. 
 Set I2C bus frequency if platform data provides this info. 
 Register with i2c layer 
 Read capability register 
 Check support for extended transaction length 
 Check support for smbus block transaction 
 SPDX-License-Identifier: GPL-2.0-or-later
    Copyright (c) 1998 - 2002  Frodo Looijaard <frodol@dds.nl>,
    Philip Edelbrock <phil@netroedge.com>, Kyösti Mälkki <kmalkki@cc.hut.fi>,
    Mark D. Studebaker <mdsxyz123@yahoo.com>
    Copyright (C) 2005 - 2008  Jean Delvare <jdelvare@suse.de>
   Supports the following VIA south bridges:
   Chip name          PCI ID  REV     I2C block
   VT82C596A          0x3050             no
   VT82C596B          0x3051             no
   VT82C686A          0x3057  0x30       no
   VT82C686B          0x3057  0x40       yes
   VT8231             0x8235             no?
   VT8233             0x3074             yes
   VT8233A            0x3147             yes?
   VT8235             0x3177             yes
   VT8237R            0x3227             yes
   VT8237A            0x3337             yes
   VT8237S            0x3372             yes
   VT8251             0x3287             yes
   CX700              0x8324             yes
   VX800VX820        0x8353             yes
   VX855VX875        0x8409             yes
   Note: we assume there can only be one device, with one SMBus interface.
 SMBus address offsets 
 PCI Address Constants 
 SMBus data in configuration space can be found in two places,
 Other settings 
 VT82C596 constants 
 If force is set to anything different from 0, we forcibly enable the
 If force_addr is set to anything different from 0, we forcibly enable
 Return -1 on error, 0 on success 
 Make sure the SMBus host is ready to start transmitting 
 Start the transaction by setting bit 6 
 We will always wait for a fraction of a second 
 If the SMBus is still busy, we give up 
 Resetting status register 
 Return negative errno on error, 0 on success 
 Reset SMBBLKDAT 
 Reset SMBBLKDAT 
 Determine the address of the SMBus areas 
 try 2nd address and config reg. for 596 
 no matches at all 
	 If force_addr is set, we program the new address here. Just to make
			 NOTE: This assumes IO space and other allocations
			  WERE done by the Bios!  Don't complain if your
			  hardware does weird things after enabling this.
			  :') Check for Bios updates before resorting to
			  this.
		 The VT82C686B (rev 0x40) does support I2C block
	 Always return failure here.  This is to allow other drivers to bind
	  to this pci device.  We don't really want to have control over the
	  pci device, we only wanted to read as few register values from it.
 SPDX-License-Identifier: GPL-2.0-or-later
  i2c-nforce2-s4985.c - i2c-nforce2 extras for the Tyan S4985 motherboard
  Copyright (C) 2008 Jean Delvare <jdelvare@suse.de>
  We select the channels by sending commands to the Philips
  PCA9556 chip at I2C address 0x18. The main adapter is used for
  the non-multiplexed part of the bus, and 4 virtual adapters
  are defined for the multiplexed addresses: 0x50-0x53 (memory
  module EEPROM) located on channels 1-4. We define one virtual
  adapter per CPU, which corresponds to one multiplexed channel:
    CPU0: virtual adapter 1, channel 1
    CPU1: virtual adapter 2, channel 2
    CPU2: virtual adapter 3, channel 3
    CPU3: virtual adapter 4, channel 4
 Wrapper access functions for multiplexed SMBus 
 We exclude the multiplexed addresses 
 We remember the last used channels combination so as to only switch
   channels when it is really needed. This greatly reduces the SMBus
   overhead, but also assumes that nobody will be writing to the PCA9556
 We exclude the non-multiplexed addresses 
 CPU0: channel 1 enabled 
 CPU1: channel 2 enabled 
 CPU2: channel 3 enabled 
 CPU3: channel 4 enabled 
 Configure the PCA9556 multiplexer 
 All IO to output mode 
 Unregister physical bus 
 Define the 5 virtual adapters and algorithms structures 
 Fill in the new structures 
 Register virtual adapters 
 Restore physical bus 
 Restore physical bus 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 MediaTek Inc.
  Author: Xudong Chen <xudong.chen@mediatek.com>
 i2c host adapter 
 set in i2c probe 
 i2c base addr 
 dma base address
 main clock for i2c bus 
 DMA clock for i2c via DMA 
 PMIC clock for i2c from PMIC 
 Arbitrator clock for i2c 
 can use i2c pins from PMIC 
 IO config push-pull mode 
 interrupt status 
 The speed in transfer 
  struct i2c_spec_values:
  @min_low_ns: min LOW period of the SCL clock
  @min_su_sta_ns: min set-up time for a repeated START condition
  @max_hd_dat_ns: max data hold time
  @min_su_dat_ns: min data set-up time
 Set ioconfig 
 If use i2c pin from PMIC mt6397 side, need set PATH_DIR first 
  Check and Calculate i2c ac-timing
  Hardware design:
  sample_ns = (1000000000  (sample_cnt + 1))  clk_src
  xxx_cnt_div =  spec->min_xxx_ns  sample_ns
  Sample_ns is rounded down for xxx_cnt_div would be greater
  than the smallest spec.
  The sda_timing is chosen as the middle value between
  the largest and smallest.
  Calculate i2c port speed
  Hardware design:
  i2c_bus_freq = parent_clk  (clock_div  2  sample_cnt  step_cnt)
  clock_div: fixed in hardware, but may be various in different SoCs
  The calculation want to pick the highest bus frequency that is still
  less than or equal to i2c->speed_hz. The calculation try to get
  sample_cnt and step_cn
 Find the best combination 
	 Search for the best pair (sample_cnt, step_cnt) with
	  0 < sample_cnt < MAX_SAMPLE_CNT_DIV
	  0 < step_cnt < max_step_cnt
	  sample_cnt  step_cnt >= opt_div
	  optimizing for sample_cnt  step_cnt being minimal
		 In this case, hardware can't support such
		  low i2c_bus_freq
 Set master code speed register 
 Set the high speed mode register 
 Disable the high speed transaction 
 Clear interrupt status 
 Enable interrupt 
 Set transfer and transaction len 
 Prepare buffer data to start transfer 
 Clear interrupt mask 
 checking if we can skip restart and optimize using WRRD mode 
		 ignore the first restart irq after the master code,
		  otherwise the first transfer will be discarded.
 combined two messages into one transaction 
 always use DMA mode. 
 the return value is number of executed messages 
	
	  when occurs ack error, i2c controller generate two interrupts
	  first is the ack error interrupt, then the complete interrupt
	  i2c->irq_stat need keep the two interrupt value.
 SPDX-License-Identifier: GPL-2.0-only
  CE4100 PCI-I2C glue code for PXA's driver
  Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
  The CE4100's I2C device is more or less the same one as found on PXA.
  It does not support slave mode, the register slightly moved. This PCI
  device provides three bars, every contains a single I2C controller.
 SPDX-License-Identifier: GPL-2.0-or-later
    i2c Support for Via Technologies 82C586B South Bridge
    Copyright (c) 1998, 1999 Kyösti Mälkki <kmalkki@cc.hut.fi>
 Power management registers 
 silicon revision code 
 clock bit in DIROUTIN register 
 io-region reservation 
   It does not appear from the datasheet that the GPIO pins are
   open drain. So a we set a low value by setting the direction to
   output and a high value by setting the direction to input and
   relying on the required I2C pullup. The data value is initialized
   to 0 in via_init() and never changed.
 later revision 
 set up the sysfs linkage to our parent device 
 SPDX-License-Identifier: GPL-2.0
  Renesas RIIC driver
  Copyright (C) 2013 Wolfram Sang <wsa@sang-engineering.com>
  Copyright (C) 2013 Renesas Solutions Corp.
  This i2c core has a lot of interrupts, namely 8. We use their chaining as
  some kind of state machine.
  1) The main xfer routine kicks off a transmission by putting the start bit
  (or repeated start) on the bus and enabling the transmit interrupt (TIE)
  since we need to send the slave address + RW bit in every case.
  2) TIE sends slave address + RW bit and selects how to continue.
  3a) Write case: We keep utilizing TIE as long as we have data to send. If we
  are done, we switch over to the transmission done interrupt (TEIE) and mark
  the message as completed (includes sending STOP) there.
  3b) Read case: We switch over to receive interrupt (RIE). One dummy read is
  needed to start clocking, then we keep receiving until we are done. Note
  that we use the RDRFS mode all the time, i.e. we ACKNACK every byte by
  writing to the ACKBT bit. I tried using the RDRFS mode only at the end of a
  message to create the final NACK as sketched in the datasheet. This caused
  some subtle races (when byte n was processed and byte n+1 was already
  waiting), though, and I started with the safe approach.
  4) If we got a NACK somewhere, we flag the error and stop the transmission
  via NAKIE.
  Also check the comments in the interrupt routines for some gory details.
 Should be 1 on writes 
 On read, switch over to receive interrupt 
 On write, initialize length 
	
	  Switch to transmission ended interrupt when done. Do check here
	  after bytes_left was initialized to support SMBUS_QUICK (new msg has
	  0 length then)
	
	  This acks the TIE interrupt. We get another TIE immediately if our
	  value could be moved to the shadow shift register right away. So
	  this must be after updates to ICIER (where we want to disable TIE)!
 We got a NACKIE 
 dummy read 
 Transfer is complete, but do not send STOP 
 dummy read 
 STOP must come before we set ACKBT! 
 Reading acks the RIE interrupt 
 read back registers to confirm writes have fully propagated 
	
	  Assume the default register settings:
	   FER.SCLE = 1 (SCL sync circuit enabled, adds 2 or 3 cycles)
	   FER.NFE = 1 (noise circuit enabled)
	   MR3.NF = 0 (1 cycle of noise filtered out)
	 
	  Freq (CKS=000) = (I2CCLK + tr + tf) (BRH + 3 + 1) + (BRL + 3 + 1)
	  Freq (CKS!=000) = (I2CCLK + tr + tf) (BRH + 2 + 1) + (BRL + 2 + 1)
	
	  Determine reference clock rate. We must be able to get the desired
	  frequency with only 62 clock ticks max (31 high, 31 low).
	  Aim for a duty of 60% LOW, 40% HIGH.
		
		  60% low time must be less than BRL + 2 + 1
		  BRL max register value is 0x1F.
 Remove automatic clock ticks for sync circuit and NF 
	
	  Remove clock ticks for rise and fall times. Convert ns to clock
	  ticks.
 Adjust for min register values for when SCLE=1 and NFE=1 
 Changing the order of accessing IICRST and ICE may break things! 
 Sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
  I2C bus driver for Kontron COM modules
  Copyright (c) 2010-2013 Kontron Europe GmbH
  Author: Michael Brunner <michael.brunner@kontron.com>
  The driver is based on the i2c-ocores driver by Peter Korsgaard.
 2.7 mHz 
 100 kHz 
  kempld_get_mutex must be called prior to calling this function.
 Ready? 
 Stop has been sent 
 Error? 
 10 bit address? 
 Set read bit if necessary 
 Second part of 10 bit addressing 
 Handle the transfer 
  kempld_get_mutex must be called prior to calling this function.
 Make sure the device is disabled 
 Round to the best matching value 
 Activate I2C bus output on GPIO pins 
 Enable the device 
 Add I2C adapter to I2C tree 
	
	  Disable I2C logic if it was not activated before the
	  driver loaded
 SPDX-License-Identifier: GPL-2.0-only
  driver for the i2c-tiny-usb adapter - 1.0
  http:www.harbaum.orgtilli2c_tiny_usb
  Copyright (C) 2006-2007 Till Harbaum (Till@Harbaum.org)
 include interfaces to usb layer 
 include interface to i2c layer 
 commands via USB, must match command ids in the firmware 
 i2c bit delay, default is 10us -> 100kHz max
   (in practice, due to additional delays in the i2c bitbanging
 ----- begin of i2c layer ---------------------------------------------- 
 and directly send the message 
 read data 
 write data 
 read status 
 get functionality from adapter 
 This is the actual algorithm we define 
 ----- end of i2c layer ------------------------------------------------ 
 ----- begin of usb layer ---------------------------------------------- 
  Initially the usb i2c interface uses a vidpid pair donated by
  Future Technology Devices International Ltd., later a pair was
  bought from EZPrototypes
 FTDI 
 EZPrototypes 
 Terminating entry 
 Structure to hold all of our device specific stuff 
 the usb device for this device 
 the interface for this device 
 i2c related things 
 do control transfer 
 do control transfer 
 allocate memory for our device state and initialize it 
 save our data pointer in this interface device 
 setup i2c adapter description 
 and finally attach to i2c layer 
 inform user about successful attachment to i2c layer 
 ----- end of usb layer ------------------------------------------------ 
 SPDX-License-Identifier: GPL-2.0-only
  General Purpose I2C multiplexer
  Copyright (C) 2017 Axentia Technologies AB
  Author: Peter Rosin <peda@axentia.se>
 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
  Mellanox i2c mux driver
  Copyright (C) 2016-2020 Mellanox Technologies
 mlxcpld_mux - mux control structure:
  @last_val - last selected register value or -1 if mux deselected
  @client - I2C device client
  @pdata: platform data
 MUX logic description.
  Driver can support different mux control logic, according to CPLD
  implementation.
  Connectivity schema.
  i2c-mlxcpld                                 Digital               Analog
  driver
  --------                                  -> mux1 (virt bus2) -> mux -> |
  | I2CLPC | i2c physical                     -> mux2 (virt bus3) -> mux -> |
  | bridge | bus 1                 ---------                               |
  | logic  |--------------------->  mux reg                                |
  | in CPLD|                       ---------                               |
  --------   i2c-mux-mlxpcld          ^     -> muxn (virt busn) -> mux -> |
      |        driver                   |                                    |
      |        ---------------        |                              Devices
      |         CPLD (i2c bus) select |
      |         registers for --------
      |         mux selection  deselect
      |        ---------------
      |                 |
  <-------->     <----------->
  i2c cntrl      Board cntrl reg
  reg space      space (mux select,
                 IO, LED, WD, info)
 Write to mux register. Don't use i2c_transfer() and i2c_smbus_xfer()
  for this as they will try to lock adapter a second time.
 Only select the channel if its different from the last channel 
 Deselect active channel 
 Probereomove functions 
 force the first selection 
 Create an adapter for each channel. 
 Notify caller when all channels' adapters are created. 
 SPDX-License-Identifier: GPL-2.0-only
  Pinctrl based I2C DeMultiplexer
  Copyright (C) 2015-16 by Wolfram Sang, Sang Engineering <wsa@sang-engineering.com>
  Copyright (C) 2015-16 by Renesas Electronics Corporation
  See the bindings doc for DTS setup and the sysfs doc for usage information.
  (look for filenames containing 'i2c-demux-pinctrl' in Documentation)
	
	  Check if there are pinctrl states at all. Note: we cant' use
	  devm_pinctrl_get_select() because we need to distinguish between
	  the -ENODEV from devm_pinctrl_get() and pinctrl_lookup_state().
 continue if just no pinctrl states (e.g. i2c-gpio), otherwise exit 
 there are states. check and use them 
 Now fill out current adapter structure. cur_chan must be up to date 
 switch to first parent as active master 
 SPDX-License-Identifier: GPL-2.0-only
  Linear Technology LTC4306 and LTC4305 I2C multiplexerswitch
  Copyright (C) 2017 Analog Devices Inc.
  Based on: i2c-mux-pca954x.c
  Datasheet: http:cds.linear.comdocsendatasheet4306.pdf
 gpiolib assumes all GPIOs default input 
 Reset and enable the mux if an enable GPIO is specified. 
	
	  Write the mux register at addr to verify
	  that the mux is in fact present. This also
	  initializes the mux to disconnected state.
 Now create an adapter for each channel 
 SPDX-License-Identifier: GPL-2.0-only
  I2C multiplexer using pinctrl API
  Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
 Do not add any adapter for the idle state (if it's there at all). 
 SPDX-License-Identifier: GPL-2.0-only
  GPIO-based I2C Arbitration Using a Challenge & Response Mechanism
  Copyright (C) 2012 Google, Inc
  struct i2c_arbitrator_data - Driver data for I2C arbitrator
  @our_gpio: GPIO descriptor we'll use to claim.
  @their_gpio: GPIO descriptor that the other side will use to claim.
  @slew_delay_us: microseconds to wait for a GPIO to go high.
  @wait_retry_us: we'll attempt another claim after this many microseconds.
  @wait_free_us: we'll give up after this many microseconds.
  i2c_arbitrator_select - claim the I2C bus
  Use the GPIO-based signalling protocol; return -EBUSY if we fail.
 Start a round of trying to claim the bus 
 Indicate that we want to claim the bus 
 Wait for the other master to release it 
 We got it, so return 
 It didn't release, so give up, wait, and try again 
 Give up, release our claim 
  i2c_arbitrator_deselect - release the I2C bus
  Release the I2C bus using the GPIO-based signalling protocol.
 Release the bus and wait for the other master to notice 
 We only support probing from device tree; no platform_data 
 Request GPIOs, our GPIO as unclaimed to begin with 
 At the moment we only support a single two master (us + 1 other) 
 Arbitration parameters 
 Find our parent 
 Actually add the mux adapter 
 SPDX-License-Identifier: GPL-2.0
  I2C multiplexer
  Copyright (c) 2008-2009 Rodolfo Giometti <giometti@linux.it>
  Copyright (c) 2008-2009 Eurotech S.p.A. <info@eurotech.it>
  This module supports the PCA954x and PCA984x series of I2C multiplexerswitch
  chips made by NXP Semiconductors.
  This includes the:
 	 PCA9540, PCA9542, PCA9543, PCA9544, PCA9545, PCA9546, PCA9547,
 	 PCA9548, PCA9846, PCA9847, PCA9848 and PCA9849.
  These chips are all controlled via the I2C bus itself, and all have a
  single 8-bit register. The upstream "parent" bus fans out to two,
  four, or eight downstream busses or channels; which of these
  are selected is determined by the chip type and register contents. A
  mux can select only one sub-bus at a time; a switch can select any
  combination simultaneously.
  Based on:
 	pca954x.c from Kumar Gala <galak@kernel.crashing.org>
  Copyright (C) 2006
  Based on:
 	pca954x.c from Ken Harrenstien
  Copyright (C) 2004 Google, Inc. (Ken Harrenstien)
  Based on:
 	i2c-virtual_cb.c from Brian Kuschak <bkuschak@yahoo.com>
  and
 	pca9540.c from Jean Delvare <jdelvare@suse.de>.
 used for muxes only 
 last register value 
 MUX_IDLE_AS_IS, MUX_IDLE_DISCONNECT or >= 0 for channel 
 Provide specs for the PCA954x types we know about 
 Write to mux register. Don't use i2c_transfer()i2c_smbus_xfer()
 We make switches look like muxes, not sure how to be smarter. 
 Only select the channel if its different from the last channel 
 Set the mux back to a predetermined channel 
 Deselect active channel 
 otherwise leave as-is 
	
	  Set the mux into a state consistent with the new
	  idle_state.
 Disconnect multiplexer 
  I2C initprobingexit functions
 Reset the mux if a reset GPIO is specified. 
 Give the chip some time to recover. 
	
	  Write the mux register at addr to verify
	  that the mux is in fact present. This also
	  initializes the mux to a channel
	  or disconnected state.
 Now create an adapter for each channel 
	
	  The attr probably isn't going to be needed in most cases,
	  so don't fail completely on error.
  I2C multiplexer driver for PCA9541 bus master selector
  Copyright (c) 2010 Ericsson AB.
  Author: Guenter Roeck <linux@roeck-us.net>
  Derived from:
   pca954x.c
   Copyright (c) 2008-2009 Rodolfo Giometti <giometti@linux.it>
   Copyright (c) 2008-2009 Eurotech S.p.A. <info@eurotech.it>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  The PCA9541 is a bus master selector. It supports two I2C masters connected
  to a single slave bus.
  Before each bus transaction, a master has to acquire bus ownership. After the
  transaction is complete, bus ownership has to be released. This fits well
  into the I2C multiplexer framework, which provides select and release
  functions for this purpose. For this reason, this driver is modeled as
  single-channel I2C bus multiplexer.
  This driver assumes that the two bus masters are controlled by two different
  hosts. If a single host controls both masters, platform code has to ensure
  that only one of the masters is instantiated at any given time.
 arbitration timeouts, in jiffies 
 125 ms until forcing bus ownership 
 250 ms until acquisition failure 
 arbitration retry delays, in us 
  Write to chip register. Don't use i2c_transfer()i2c_smbus_xfer()
  as they will try to lock the adapter a second time.
  Read from chip register. Don't use i2c_transfer()i2c_smbus_xfer()
  as they will try to lock adapter a second time.
  Arbitration management functions
 Release bus. Also reset NTESTON and BUSINIT if it was set. 
  Arbitration is defined as a two-step process. A bus master can only activate
  the slave bus if it owns it; otherwise it has to request ownership first.
  This multi-step process ensures that access contention is resolved
  gracefully.
  Bus	Ownership	Other master	Action
  state		requested access
  ----------------------------------------------------
  off	-		yes		wait for arbitration timeout or
 					for other master to drop request
  off	no		no		take ownership
  off	yes		no		turn on bus
  on	yes		-		done
  on	no		-		wait for arbitration timeout or
 					for other master to release bus
  The main contention point occurs if the slave bus is off and both masters
  request ownership at the same time. In this case, one master will turn on
  the slave bus, believing that it owns it. The other master will request
  bus ownership. Result is that the bus is turned on, and master which did
  _not_ own the slave bus before ends up owning it.
 Control commands per PCA9541 datasheet 
  Channel arbitration
  Return values:
   <0: error
   0 : bus not acquired
   1 : bus acquired
		
		  Bus is off. Request ownership or turn it on unless
		  other master requested ownership.
			
			  Other master did not request ownership,
			  or arbitration timeout expired. Take the bus.
			
			  Other master requested ownership.
			  Set extra long timeout to give it time to acquire it.
		
		  Bus is on, and we own it. We are done with acquisition.
		  Reset NTESTON and BUSINIT, then return success.
		
		  Other master owns the bus.
		  If arbitration timeout has expired, force ownership.
		  Otherwise request it.
 Time is up, take the bus and reset it. 
 Request bus ownership if needed 
 give up after this time 
 force bus ownership after this time 
  I2C initprobingexit functions
	
	  I2C accesses are unprotected here.
	  We have to lock the I2C segment before releasing the bus.
 Create mux adapter 
 SPDX-License-Identifier: GPL-2.0-or-later
  I2C multiplexer using a single register
  Copyright 2015 Freescale Semiconductor
  York Sun  <yorksun@freescale.com>
	
	  Write to the register, followed by a read to ensure the write is
	  completed on a "posted" bus, for example PCI or write buffers.
	  The endianness of reading doesn't matter and the return data
	  is not used.
 map address from "reg" if exists 
 SPDX-License-Identifier: GPL-2.0-only
  I2C multiplexer using GPIO API
  Peter Korsgaard <peter.korsgaard@barco.com>
 FIXME: stop poking around inside gpiolib 
		
		  In ACPI land the mux should be a direct child of the i2c
		  bus it muxes.
 FIXME: find a proper way to access the GPIO device 
 SPDX-License-Identifier: GPL-2.0-or-later
  i2c-algo-pcf.c i2c driver algorithms for PCF8584 adapters
    Copyright (C) 1995-1997 Simon G. Vogl
 		   1998-2000 Hans Berglund
  With some changes from Kyösti Mälkki <kmalkki@cc.hut.fi> and
  Frodo Looijaard <frodol@dds.nl>, and also from Martin Bailey
  <mbailey@littlefeet-inc.com>
  Partially rewriten by Oleg I. Vdovikin <vdovikin@jscc.ru> to handle multiple
  messages, proper stoprepstart signaling during receive, added detect code
 print several statistical values 
 debug the protocol by showing transferred bits 
  module parameters:
 setting states on the bus with the right timing: 
 other auxiliary functions 
	
	  Cleanup from LAB -- reset and enable ESO.
	  This resets the PCF8584; since we've lost the bus, no
	  further attempts should be made by callers to clean up
	  (no i2c_stop() etc.)
	
	  We pause for a time period sufficient for any running
	  I2C transaction to complete -- the arbitration logic won't
	  work properly until the next START is seen.
	  It is assumed the bus driver or client has set a proper value.
	 
	  REVISIT: should probably use msleep instead of mdelay if we
	  know we can sleep.
 wait for 100 us 
  This should perform the 'PCF8584 initialization sequence' as described
  in the Philips IC12 data book (1995, Aug 29).
  There should be a 30 clock cycle wait after reset, I assume this
  has been fulfilled.
  There should be a delay at the end equal to the longest I2C message
  to synchronize the BB-bit (in multimaster systems). How long is
  this? I assume 1 second is always long enough.
  vdovikin: added detect code for PCF8584
 S1=0x80: S0 selected, serial interface off 
	
	  check to see S1 now used as RW ctrl -
	  PCF8584 does that when ESO is zero
 definitely not PCF8584 
 load own address in S0, effective address is (own << 1) 
 check it's really written 
 S1=0xA0, next byte in S2 
 check to see S2 now selected 
 load clock register S2 
 check it's really written, the only 5 lowest bits does matter 
 Enable serial interface, idle, S0 selected 
 check to see PCF is really idled and we can access status register 
 arbitration lost 
 got a better one ?? 
 got a better one ?? 
 increment number of bytes to read by one -- read dummy byte 
 arbitration lost 
 dummy read 
 Check for bus busy 
 Send START 
 Wait for PIN (pending interrupt NOT) 
 arbitration lost 
 Check LRB (last rcvd bit - slave ack) 
 exported algorithm data: 
  registering functions to load algorithms at runtime
 register new adapter to i2c module... 
 SPDX-License-Identifier: GPL-2.0+
  i2c-algo-bit.c: i2c driver algorithms for bit-shift adapters
    Copyright (C) 1995-2000 Simon G. Vogl
  With some changes from Frodo Looijaard <frodol@dds.nl>, Kyösti Mälkki
  <kmalkki@cc.hut.fi> and Jean Delvare <jdelvare@suse.de>
 ----- global defines ----------------------------------------------- 
 DEBUG 
 ----- global variables ---------------------------------------------	
 see if the line-setting functions work	
 --- setting states on the bus with the right timing: ---------------	
  Raise scl line, and do checking for delays. This is necessary for slower
  devices.
 Not all adapters have scl sense line... 
		 This hw knows how to read the clock line, so we wait
		  until it actually gets high.  This is safer as some
		  chips may hold it low ("clock stretching") while they
		  are processing data internally.
			 Test one last time, as we may have been preempted
			  between last check and timeout test.
 --- other auxiliary functions --------------------------------------	
 assert: scl, sda are high 
 assert: scl is low 
 assert: scl is low 
 send a byte without start cond., look for arbitration,
 returns:
  1 if the device acknowledged
  0 if the device did not ack
  -ETIMEDOUT if an error occurred (while raising the scl line)
 assert: scl is low 
 timed out 
		 FIXME do arbitration here:
		  if (sb && !getsda(adap)) -> ouch! Get out of here.
		 
		  Report a unique code, so higher level code can retry
		  the whole (combined) message and NOT issue STOP.
 timeout 
	 read ack: SDA should be pulled down by slave, or it may
	  NAK (usually to report problems with the data we wrote).
 ack: sda is pulled low -> success 
 assert: scl is low (sda undef) 
 read byte via i2c port, without startstop sequence	
 acknowledge is sent in i2c_read.			
 assert: scl is low 
 timeout 
 assert: scl is low 
  Sanity check for the adapter hardware - check the reaction of
  the bus lines only if it seems to be idle.
 ----- Utility functions
 try_address tries to contact a chip for a number of
  times before it gives up.
  return values:
  1 chip answered
  0 chip did not answer
  -x transmission error
 OKACK; or ignored NAK 
		 A slave NAKing the master means the slave didn't like
		  something about the data it saw.  For example, maybe
		  the SMBus PEC was wrong.
		 Timeout; or (someday) lost arbitration
		 
		  FIXME Lost ARB implies retrying the transaction from
		  the first message, after the "winning" master issues
		  its STOP.  As a rule, upper layer code has no reason
		  to know or care about this ... it is NOT an error.
 assert: sda is high 
 send ack 
 timeout 
 counts bytes read 
 read timed out 
		 Some SMBus transactions require that we receive the
			 The original count value accounts for the extra
			   bytes, that is, either 1 for a regular transaction,
 doAddress initiates the transfer by generating the start condition (in
  try_address) and transmits the address in the necessary format to handle
  reads, writes as well as 10bit-addresses.
  returns:
   0 everything went okay, the chip ack'ed, or IGNORE_NAK flag was set
  -x an error occurred (like: -ENXIO if the device did not answer, or
 	-ETIMEDOUT, for example if the lines are stuck...)
 a ten bit address 
 try extended address code...
 the remaining 8 bit address 
 the chip did not ack  xmission error occurred 
 okay, now switch into reading mode 
 normal 7bit address	
 read bytes into buffer
 write bytes from buffer 
  We print a warning when we are not flagged to support atomic transfers but
  will try anyhow. That's what the I2C core would do as well. Sadly, we can't
  modify the algorithm struct at probe time because this struct is exported
  'const'.
 -----exported algorithm data: -------------------------------------	
  registering functions to load algorithms at runtime
 register new adapter to i2c module... 
	
	  We tried forcing SCLSDA to an initial state here. But that caused a
	  regression, sadly. Check Bugzilla #200045 for details.
 Complain if SCL can't be read 
 SPDX-License-Identifier: GPL-2.0-or-later
   i2c-algo-pca.c i2c driver algorithms for PCA9564 adapters
     Copyright (C) 2004 Arcom Control Systems
     Copyright (C) 2008 Pengutronix
		 Ignore the reset function from the module,
		  we can use the parallel bus reset.
		
		  After a reset we need to re-apply any configuration
		  (calculated in pca_init) to get the bus in a working state.
  Generate a start condition on the i2c bus.
  returns after the start condition has occurred
  Generate a repeated start condition on the i2c bus
  return after the repeated start condition has occurred
  Generate a stop condition on the i2c bus
  returns after the stop condition has been generated
  STOPs do not generate an interrupt or set the SI flag, since the
  part returns the idle state (0xf8). Hence we don't need to
  pca_wait here.
  Send the slave address and RW bit
  returns after the address has been sent
  Transmit a byte.
  Returns after the byte has been transmitted
  Receive a byte
  returns immediately.
  Setup ACK or NACK for next received byte and wait for it to arrive.
  Returns after next byte has arrived.
 On reset or stop the bus is idle 
 A START condition has been transmitted 
 A repeated start condition has been transmitted 
 SLA+W has been transmitted; ACK has been received 
 Data byte in I2CDAT has been transmitted; ACK has been received 
 SLA+W has been transmitted; NOT ACK has been received 
 SLA+R has been transmitted; ACK has been received 
 Data bytes has been received; ACK has been returned 
 SLA+R has been transmitted; NOT ACK has been received 
 Data byte in I2CDAT has been transmitted; NOT ACK has been received 
 Arbitration lost during SLA+W, SLA+R or data bytes 
			
			  The PCA9564 data sheet (2006-09-01) says "A
			  START condition will be transmitted when the
			  bus becomes free (STOP or SCL and SDA high)"
			  when the STA bit is set (p. 11).
			 
			  In case this won't work, try pca_reset()
			  instead.
 Data byte has been received; NOT ACK has been returned 
 Bus error - SDA stuck low 
 Bus error - SCL stuck low (PCA9665) 
 Bus error - SCL stuck low (PCA9564) 
 Bus error during master or slave mode due to illegal START or STOP condition 
	 The trick here is to check if there is an indirect register
	  available. If there is one, we will read the value we first
	  wrote on I2C_PCA_IADR. Otherwise, we will read the last value
	  we wrote on I2C_PCA_ADR
 Store settings as these will be needed when the PCA chip is reset 
 Values can be found on PCA9665 datasheet section 7.3.2.6 
		 These values are the maximum raise and fall values allowed
		  by the I2C operation mode (Standard, Fast or Fast+)
		  They are used (added) below to calculate the clock dividers
		  of PCA9665. Note that they are slightly different of the
		  real maximum, to allow the change on mode exactly on the
		  maximum clock rate for each mode
 To avoid integer overflow, use clock100 for calculations 
 Raise 11e-8s, Fall 11e-8s 
 Raise 11e-8s, Fall 11e-8s 
 Raise 29e-8s, Fall 29e-8s 
 Raise 29e-8s, Fall 98e-8s 
		 The minimum clock that respects the thitlow = 134157 is
		  64800 Hz. Below that, we have to fix the tlow to 255 and
		  calculate the thi factor.
 Store settings as these will be needed when the PCA chip is reset 
 500 us for oscillator to stabilise 
  registering functions to load algorithms at runtime
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2013 - 2014 Texas Instruments Incorporated - https:www.ti.com
  Authors:
     Jyri Sarha <jsarha@ti.com>
     Sergej Sawazki <ce3a@gmx.de>
  Gpio controlled clock implementation
  DOC: basic gpio gated clock which can be enabled and disabled
       with gpio output
  Traits of this clock:
  prepare - clk_(un)prepare only ensures parent is (un)prepared
  enable - clk_enable and clk_disable are functional & control gpio
  rate - inherits rate from parent.  No clk_set_rate support
  parent - fixed parent.  No clk_set_parent support
  struct clk_gpio - gpio gated clock
  @hw:		handle between common and hardware-specific interfaces
  @gpiod:	gpio descriptor
  Clock with a gpio control for enabling and disabling the parent clock
  or switching between two parents by asserting or deasserting the gpio.
  Implements .enable, .disable and .is_enabled or
  .get_parent, .set_parent and .determine_rate depending on which clk_ops
  is used.
  DOC: basic clock multiplexer which can be controlled with a gpio output
  Traits of this clock:
  prepare - clk_prepare only ensures that parents are prepared
  rate - rate is only affected by parent switching.  No clk_set_rate support
  parent - parent is adjustable through clk_set_parent
 SPDX-License-Identifier: GPL-2.0
  Nuvoton NPCM7xx Clock Generator
  All the clocks are initialized by the bootloader, so this driver allow only
  reading of current settings directly from the hardware.
  Copyright (C) 2018 Nuvoton Technologies tali.perry@nuvoton.com
	
	  If this clock is exported via DT, set onecell_idx to constant
	  defined in includedt-bindingsclocknuvoton, NPCM7XX-clock.h for
	  this specific clock.  Otherwise, set to -1.
	
	  If this clock is exported via DT, set onecell_idx to constant
	  defined in includedt-bindingsclocknuvoton, NPCM7XX-clock.h for
	  this specific clock.  Otherwise, set to -1.
	
	  If this clock is exported via DT, set onecell_idx to constant
	  defined in includedt-bindingsclocknuvoton, NPCM7XX-clock.h for
	  this specific clock.  Otherwise, set to -1.
	
	  If this clock is exported via DT, set onecell_idx to constant
	  defined in includedt-bindingsclocknuvoton, NPCM7XX-clock.h for
	  this specific clock.  Otherwise, set to -1.
	
	  If this clock is exported via DT, set onecell_idx to constant
	  defined in includedt-bindingsclocknuvoton, NPCM7XX-clock.h for
	  this specific clock.  Otherwise, set to -1.
  Single copy of strings used to refer to clocks within this driver indexed by
  above enum.
AKA system clock.
AKA CLK2
AKA CLK4
 divided by 2
 configurable dividers: 
30-28 ADCCKDIV
27-26 CLK4DIV
25-21 TIMCKDIV
20-16 UARTDIV
15-11 MMCCKDIV
10-6 AHB3CKDIV
5-2 PCICKDIV
0 CLK2DIV
31-30 APB4CKDIV
29-28 APB3CKDIV
27-26 APB2CKDIV
25-24 APB1CKDIV
23-22 APB5CKDIV
20-16 CLKOUTDIV
15-13 GFXCKDIV
12-8 SUCKDIV
7-4 SU48CKDIV
3-0 SD1CKDIV
10-6 SPI0CKDV
5-1 SPIXCKDV
 Register plls 
 Register fixed dividers 
 Register muxes 
 Register clock dividers specified in npcm7xx_divs 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) STMicroelectronics 2018 - All Rights Reserved
  Author: Olivier Bideau <olivier.bideau@st.com> for STMicroelectronics.
  Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
 STM32 Composite clock 
 MP1 Gate clock with set & clear registers 
 STM32 PLL 
 lock pll enabledisable registers 
	 We can't use readl_poll_timeout() because we can be blocked if
	  someone enables this clock before clocksource changes.
	  Only jiffies counter is available. Jiffies are incremented by
	  interruptions and enable op does not allow to be interrupted.
 Kernel Timer 
 lock the kernel output divider register 
 The divider of RTC clock concerns only ck_hse clock 
 STM32 GATE 
 Peripheral gates 
 Multi gates 
 Kernel multi mux 
  Kernel simple mux 
  External  Internal Oscillators 
 ck_csi is used by IO compensation and should be critical 
 PLLs 
 ODF 
 MUX system clocks 
 Kernel Timers 
 Peripheral clocks 
 Kernel clocks 
 Particulary Kernel Clocks (no mux or no gate) 
 RTC clock 
 MCO clocks 
 Debug clocks 
 reset lock 
 RCC Reset Configuration 
 RCC Clock Configuration 
 Device gets a reference count on the clock 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for Silicon Labs Si514 Programmable Oscillator
  Copyright (C) 2015 Topic Embedded Products
  Author: Mike Looijmans <mike.looijmans@topic.nl>
 I2C registers 
 Register values 
 Multiplierdivider settings 
 29-bit Fractional part of multiplier M 
 Integer part of multiplier M, 65..78 
 2nd divider, as 2^x 
 1st divider, must be even and 10<=x<=1022 
 Enables or disables the output driver 
 Retrieve clock multiplier and dividers from hardware 
 Calculate LP1LP2 according to table 13 in the datasheet 
 65.259980246 
 67.859763463 
 72.937624981 
 75.843265046 
	
	  Writing to SI514_REG_M_INT_FRAC triggers the clock change, so that
	  must be written last
 Calculate divider settings for a given frequency 
 Determine the minimum value of LS_DIV and resulting target freq. 
 Determine minimum HS_DIV, round up to even number 
 M = LS_DIV x HS_DIV x frequency  F_XO (in fixed-point) 
 Calculate resulting frequency given the register settings 
  Update output frequency for big frequency changes (> 1000 ppm).
  The chip supports <1000ppm changes "on the fly", we haven't implemented
  that here.
 Undefined state now, best to leave disabled 
 Trigger calibration 
 Applying a new frequency can take up to 10ms 
 SPDX-License-Identifier: GPL-2.0
  LMK04832 Ultra Low-Noise JESD204B Compliant Clock Jitter Cleaner
  Pin compatible with the LMK0482x family
  Datasheet: https:www.ti.comlitdssymlinklmk04832.pdf
  Copyright (c) 2020, Xiphos Systems Corp.
 0x000 - 0x00d System Functions 
 0x100 - 0x137 Device Clock and SYSREF Clock Output Control 
 0x138 - 0x145 SYSREF, SYNC, and Device Config 
 0x146 - 0x14a CLKin Control 
 0x14b - 0x152 Holdover 
 0x153 - 0x15f PLL1 Configuration 
 0x160 - 0x16e PLL2 Configuration 
 0x16F - 0x555 Misc Registers 
  lmk04832_device_info - Holds static device information that is specific to
                         the chip revision
  pid:          Product Identifier
  maskrev:      IC version identifier
  num_channels: Number of available output channels (clkout count)
  vco0_range:   {min, max} of the VCO0 operating range (in MHz)
  vco1_range:   {min, max} of the VCO1 operating range (in MHz)
 WARNING PROD_ID is inverted in the datasheet 
  struct lmk04832 - The LMK04832 device structure
  @dev: reference to a struct device, linked to the spi_device
  @regmap: struct regmap instance use to access the chip
  @sync_mode: operational mode for SYNC signal
  @sysref_mux: select SYSREF source
  @sysref_pulse_cnt: number of SYSREF pulses generated while not in continuous
                     mode.
  @sysref_ddly: SYSREF digital delay value
  @oscin: PLL2 input clock
  @vco: reference to the internal VCO clock
  @sclk: reference to the internal sysref clock (SCLK)
  @vco_rate: user provided VCO rate
  @reset_gpio: reference to the reset GPIO
  @dclk: list of internal device clock references.
         Each pair of clkout clocks share a single device clock (DCLKX_Y)
  @clkout: list of output clock references
  @clk_data: holds clkout related data like clk_hw and number of clocks
 Don't set LMK04832_BIT_OSCIN_PD since other clocks depend on it 
  lmk04832_check_vco_ranges - Check requested VCO frequency against VCO ranges
  @lmk:   Reference to the lmk device
  @rate:  Desired output rate for the VCO
  The LMK04832 has 2 internal VCO, each with independent operating ranges.
  Use the device_info structure to determine which VCO to use based on rate.
  Returns VCO_MUX value or negative errno.
  lmk04832_calc_pll2_params - Get PLL2 parameters used to set the VCO frequency
  @prate: parent rate to the PLL2, usually OSCin
  @rate:  Desired output rate for the VCO
  @n:     reference to PLL2_N
  @p:     reference to PLL2_P
  @r:     reference to PLL2_R
  This functions assumes LMK04832_BIT_PLL2_MISC_REF_2X_EN is set since it is
  recommended in the datasheet because a higher phase detector frequencies
  makes the design of wider loop bandwidth filters possible.
  the VCO rate can be calculated using the following expression:
 	VCO = OSCin  2  PLL2_N  PLL2_P  PLL2_R
  Returns vco rate or negative errno.
 Set PLL2_P to a fixed value to simplify optimizations 
	
	  PLL2_N registers must be programmed after other PLL2 dividers are
	  programmed to ensure proper VCO frequency calibration
  lmk04832_register_vco - Initialize the internal VCO and clock distribution
                          path in PLL2 single loop mode.
 lmk04832_sclk_sync - Establish deterministic phase relationship between sclk
                        and dclk
  @lmk: Reference to the lmk device
  The synchronization sequence:
  - in the datasheet https:www.ti.comlitdssymlinklmk04832.pdf, p.31
    (8.3.3.1 How to enable SYSREF)
  - Ti forum: https:e2e.ti.comsupportclock-and-timingf48t970972
  Returns 0 or negative errno.
 1. (optional) mute all sysref_outputs during synchronization 
 2. Enable and write device clock digital delay to applicable clocks 
	
	  3. Configure SYNC_MODE to SYNC_PIN and SYSREF_MUX to Normal SYNC,
	     and clear SYSREF_REQ_EN (see 6.)
 4. Clear SYNXC_DISx or applicable clocks and clear SYNC_DISSYSREF 
	
	  5. If SCLKX_Y_DDLY != 0, Set SYSREF_CLR=1 for at least 15 clock
	     distribution path cycles (VCO cycles), then back to 0. In
	     PLL2-only use case, this will be complete in less than one SPI
	     transaction. If SYSREF local digital delay is not used, this step
	     can be skipped.
	
	  6. Toggle SYNC_POL state between inverted and not inverted.
	     If you use an external signal on the SYNC pin instead of toggling
	     SYNC_POL, make sure that SYSREF_REQ_EN=0 so that the SYSREF_MUX
	     does not shift into continuous SYSREF mode.
 7. Set all SYNC_DISx=1, including SYNC_DISSYSREF 
 8. Restore state of SYNC_MODE and SYSREF_MUX to desired values 
	
	  9. (optional) if SCLKx_y_DIS_MODE was used to mute SYSREF outputs
	     during the SYNC event, restore SCLKx_y_DIS_MODE=0 for active state,
	     or set SYSREF_GBL_PD=0 if SCLKx_y_DIS_MODE is set to a conditional
	     option.
	
	  10. (optional) To reduce power consumption, after the synchronization
	      event is complete, DCLKx_y_DDLY_PD=1 and SYSREF_DDLY_PD=1 disable the
	      digital delay counters (which are only used immediately after the
	      SYNC pulse to delay the output by some number of VCO counts).
 Enable Duty Cycle Correction 
	
	  While using Divide-by-2 or Divide-by-3 for DCLK_X_Y_DIV, SYNC
	  procedure requires to first program Divide-by-4 and then back to
	  Divide-by-2 or Divide-by-3 before doing SYNC.
 Set initial parent 
 SPDX-License-Identifier: GPL-2.0-only
  Nomadik clock implementation
  Copyright (C) 2013 ST-Ericsson AB
  Author: Linus Walleij <linus.walleij@linaro.org>
  The Nomadik clock tree is described in the STN8815A12 DB V4.2
  reference manual for the chip, page 94 ff.
  Clock IDs are in the STn8815 Reference Manual table 3, page 27.
 Lock protecting the SRC_CR register 
 Base address of the SRC 
 The main chrystal need to be enabled for reboot to work 
 sentinel  }
 Set all timers to use the 2.4 MHz TIMCLK 
 The machine uses an external oscillator circuit 
 Disable this too: also run by external oscillator 
  struct clk_pll1 - Nomadik PLL1 clock
  @hw: corresponding clock hardware entry
  @id: PLL instance: 1 or 2
  struct clk_src - Nomadik src clock
  @hw: corresponding clock hardware entry
  @id: the clock ID
  @group1: true if the clock is in group1, else it is in group0
  @clkbit: bit 0...31 corresponding to the clock in each clock register
 Unknown PLL 
  The Nomadik SRC clocks are gated, but not in the sense that
  you read-modify-write a register. Instead there are separate
  clock enable and clock disable registers. Writing a '1' bit in
  the enable register for a certain clock ungates that clock without
  affecting the other clocks. The disable register works the opposite
  way.
 spin until enabled 
 spin until disabled 
 Do not force-disable the static SDRAM controller 
 Vital for multiplatform 
	
	  The HCLK divides PLL1 with 1 (passthru), 2, 3 or 4.
 SPDX-License-Identifier: GPL-2.0
 This chip has only one register of 8 bit width. 
  Ordered by frequency. For frequency the hardware can generate with
  multiple settings, the one with lowest jitter is listed first.
 sentinel 
  CLKOUT - configurable clock output
 Exact matches 
		
		  Find the first entry that has a frequency higher than the
		  requested one.
			
			  If this is the first entry, clamp the value to the
			  lowest possible frequency.
			
			  Otherwise, determine whether the previous entry or
			  current one is closer.
 If the last entry was still too high, clamp the value 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2010-2011 Canonical Ltd <jeremy.kerr@canonical.com>
  Copyright (C) 2011-2012 Linaro Ltd <mturquette@linaro.org>
  Standard functionality for the common clock API.  See Documentationdriver-apiclk.rst
    private data structures    
           runtime pm          
           locking             
	
	  On UP systems, spin_trylock_irqsave() always returns true, even if
	  we already hold the lock. So, in that case, we rely only on
	  reference counting.
	
	  .is_prepared is optional for clocks that can prepare
	  fall back to software usage counter if it is missing
	
	  .is_enabled is only mandatory for clocks that gate
	  fall back to software usage counter if .is_enabled is missing
	
	  Check if clock controller's device is runtime active before
	  calling .is_enabled callback. If not, assume that clock is
	  disabled, because we might be called from atomic context, from
	  which pm_runtime_get() is not allowed.
	  This function is called mainly from clk_disable_unused_subtree,
	  which ensures proper runtime pm activation of controller before
	  taking enable spinlock, but the below check is needed if one tries
	  to call it from other places.
    helper functions   
 search the 'proper' clk tree first 
 if not found, then search the orphan tree 
  clk_core_get - Find the clk_core parent of a clk
  @core: clk to find parent of
  @p_index: parent index to search for
  This is the preferred method for clk providers to find the parent of a
  clk when that parent is external to the clk controller. The parent_names
  array is indexed and treated as a local name matching a string in the device
  node's 'clock-names' property or as the 'con_id' matching the device's
  dev_name() in a clk_lookup. This allows clk providers to use their own
  namespace instead of looking for a globally unique parent string.
  For example the following DT snippet would allow a clock registered by the
  clock-controller@c001 that has a clk_init_data::parent_data array
  with 'xtal' in the 'name' member to find the clock provided by the
  clock-controller@f00abcd without needing to get the globally unique name of
  the xtal clk.
       parent: clock-controller@f00abcd {
               reg = <0xf00abcd 0xabcd>;
               #clock-cells = <0>;
       };
       clock-controller@c001 {
               reg = <0xc001 0xf00d>;
               clocks = <&parent>;
               clock-names = "xtal";
               #clock-cells = <1>;
       };
  Returns: -ENOENT when the provider can't be found or the clk doesn't
  exist in the provider or the name can't be found in the DT node or
  in a clkdev lookup. NULL when the provider knows about the clk but it
  isn't provided on this system.
  A valid clk_core pointer when the clk can be found in the provider.
		
		  If the DT search above couldn't find the provider fallback to
		  looking up via clkdev based clk_lookups.
		
		  We have a direct reference but it isn't registered yet?
		  Orphan it and let clk_reparent() update the orphan status
		  when the parent is registered.
 Only cache it if it's not an error 
	
	  Clk must have a parent because num_parents > 0 but the parent isn't
	  known yet. Best to return 0 as the rate of this clk until we can
	  properly recalc the rate based on the parent's rate.
 if NO_REPARENT flag set, pass through to current parent 
 find the parent that can provide the fastest rate <= rate 
  __clk_mux_determine_rate - clk_ops::determine_rate implementation for a mux type clk
  @hw: mux type clk to determine rate on
  @req: rate request, also used to return preferred parent and frequencies
  Helper for finding best parent to provide a given frequency. This can be used
  directly as a determine_rate callback (e.g. for a mux), or from a more
  complex clock that may combine a mux with other operations.
  Returns: 0 on success, -EERROR value on error
        clk api        
  clk_rate_exclusive_put - release exclusivity over clock rate control
  @clk: the clk over which the exclusivity is released
  clk_rate_exclusive_put() completes a critical section during which a clock
  consumer cannot tolerate any other consumer making any operation on the
  clock which could result in a rate change or rate glitch. Exclusive clocks
  cannot have their rate changed, either directly or indirectly due to changes
  further up the parent chain of clocks. As a result, clocks up parent chain
  also get under exclusive control of the calling consumer.
  If exlusivity is claimed more than once on clock, even by the same consumer,
  the rate effectively gets locked as exclusivity can't be preempted.
  Calls to clk_rate_exclusive_put() must be balanced with calls to
  clk_rate_exclusive_get(). Calls to this function may sleep, and do not return
  error status.
	
	  if there is something wrong with this consumer protect count, stop
	  here before messing with the provider
  clk_rate_exclusive_get - get exclusivity over the clk rate control
  @clk: the clk over which the exclusity of rate control is requested
  clk_rate_exclusive_get() begins a critical section during which a clock
  consumer cannot tolerate any other consumer making any operation on the
  clock which could result in a rate change or rate glitch. Exclusive clocks
  cannot have their rate changed, either directly or indirectly due to changes
  further up the parent chain of clocks. As a result, clocks up parent chain
  also get under exclusive control of the calling consumer.
  If exlusivity is claimed more than once on clock, even by the same consumer,
  the rate effectively gets locked as exclusivity can't be preempted.
  Calls to clk_rate_exclusive_get() should be balanced with calls to
  clk_rate_exclusive_put(). Calls to this function may sleep.
  Returns 0 on success, -EERROR otherwise
  clk_unprepare - undo preparation of a clock source
  @clk: the clk being unprepared
  clk_unprepare may sleep, which differentiates it from clk_disable.  In a
  simple case, clk_unprepare can be used instead of clk_disable to gate a clk
  if the operation may sleep.  One example is a clk which is accessed over
  I2c.  In the complex case a clk gate operation may require a fast and a slow
  part.  It is this reason that clk_unprepare and clk_disable are not mutually
  exclusive.  In fact clk_disable must be called before clk_unprepare.
	
	  CLK_SET_RATE_GATE is a special case of clock protection
	  Instead of a consumer claiming exclusive rate control, it is
	  actually the provider which prevents any consumer from making any
	  operation which could result in a rate change or rate glitch while
	  the clock is prepared.
  clk_prepare - prepare a clock source
  @clk: the clk being prepared
  clk_prepare may sleep, which differentiates it from clk_enable.  In a simple
  case, clk_prepare can be used instead of clk_enable to ungate a clk if the
  operation may sleep.  One example is a clk which is accessed over I2c.  In
  the complex case a clk ungate operation may require a fast and a slow part.
  It is this reason that clk_prepare and clk_enable are not mutually
  exclusive.  In fact clk_prepare must be called before clk_enable.
  Returns 0 on success, -EERROR otherwise.
  clk_disable - gate a clock
  @clk: the clk being gated
  clk_disable must not sleep, which differentiates it from clk_unprepare.  In
  a simple case, clk_disable can be used instead of clk_unprepare to gate a
  clk if the operation is fast and will never sleep.  One example is a
  SoC-internal clk which is controlled via simple register writes.  In the
  complex case a clk gate operation may require a fast and a slow part.  It is
  this reason that clk_unprepare and clk_disable are not mutually exclusive.
  In fact clk_disable must be called before clk_unprepare.
  clk_gate_restore_context - restore context for poweroff
  @hw: the clk_hw pointer of clock whose state is to be restored
  The clock gate restore context function enables or disables
  the gate clocks based on the enable_count. This is done in cases
  where the clock context is lost and based on the enable_count
  the clock either needs to be enableddisabled. This
  helps restore the state of gate clocks.
  clk_save_context - save clock context for poweroff
  Saves the context of the clock register for powerstates in which the
  contents of the registers will be lost. Occurs deep within the suspend
  code.  Returns 0 on success.
  clk_restore_context - restore clock context after poweroff
  Restore the saved clock context upon resume.
  clk_enable - ungate a clock
  @clk: the clk being ungated
  clk_enable must not sleep, which differentiates it from clk_prepare.  In a
  simple case, clk_enable can be used instead of clk_prepare to ungate a clk
  if the operation will never sleep.  One example is a SoC-internal clk which
  is controlled via simple register writes.  In the complex case a clk ungate
  operation may require a fast and a slow part.  It is this reason that
  clk_enable and clk_prepare are not mutually exclusive.  In fact clk_prepare
  must be called before clk_enable.  Returns 0 on success, -EERROR
  otherwise.
  clk_is_enabled_when_prepared - indicate if preparing a clock also enables it.
  @clk: clock source
  Returns true if clk_prepare() implicitly enables the clock, effectively
  making clk_enable()clk_disable() no-ops, false otherwise.
  This is of interest mainly to power management code where actually
  disabling the clock also requires unpreparing it to have any material
  effect.
  Regardless of the value returned here, the caller must always invoke
  clk_enable() or clk_prepare_enable()  and counterparts for usage counts
  to be right.
	
	  some gate clocks have special needs during the disable-unused
	  sequence.  call .disable_unused if available, otherwise fall
	  back to .disable
	
	  At this point, core protection will be disabled
	  - if the provider is not protected at all
	  - if the calling consumer is the only one which has exclusivity
	    over the provider
  __clk_determine_rate - get the closest rate actually supported by a clock
  @hw: determine the rate of this clock
  @req: target rate request
  Useful for clk_ops such as .set_rate and .determine_rate.
  clk_hw_round_rate() - round the given rate for a hw clk
  @hw: the hw clk for which we are rounding a rate
  @rate: the rate which is to be rounded
  Takes in a rate as input and rounds it to a rate that the clk can actually
  use.
  Context: prepare_lock must be held.
           For clk providers to call from within clk_ops such as .round_rate,
           .determine_rate.
  Return: returns rounded rate of hw clk if clk supports round_rate operation
          else returns the parent rate.
  clk_round_rate - round the given rate for a clk
  @clk: the clk for which we are rounding a rate
  @rate: the rate which is to be rounded
  Takes in a rate as input and rounds it to a rate that the clk can actually
  use which is then returned.  If clk doesn't support round_rate operation
  then the parent rate is returned.
  __clk_notify - call clk notifier chain
  @core: clk that is changing rate
  @msg: clk notifier type (see includelinuxclk.h)
  @old_rate: old clk rate
  @new_rate: new clk rate
  Triggers a notifier call chain on the clk rate-change notification
  for 'clk'.  Passes a pointer to the struct clk and the previous
  and current rates to the notifier callback.  Intended to be called by
  internal clock code only.  Returns NOTIFY_DONE from the last driver
  called if all went well, or NOTIFY_STOP or NOTIFY_BAD immediately if
  a driver returns that.
  __clk_recalc_accuracies
  @core: first clk in the subtree
  Walks the subtree of clks starting with clk and recalculates accuracies as
  it goes.  Note that if a clk does not implement the .recalc_accuracy
  callback then it is assumed that the clock will take on the accuracy of its
  parent.
  clk_get_accuracy - return the accuracy of clk
  @clk: the clk whose accuracy is being returned
  Simply returns the cached accuracy of the clk, unless
  CLK_GET_ACCURACY_NOCACHE flag is set, which means a recalc_rate will be
  issued.
  If clk is NULL then returns 0.
  __clk_recalc_rates
  @core: first clk in the subtree
  @msg: notification type (see includelinuxclk.h)
  Walks the subtree of clks starting with clk and recalculates rates as it
  goes.  Note that if a clk does not implement the .recalc_rate callback then
  it is assumed that the clock will take on the rate of its parent.
  clk_recalc_rates also propagates the POST_RATE_CHANGE notification,
  if necessary.
	
	  ignore NOTIFY_STOP and NOTIFY_BAD return values for POST_RATE_CHANGE
	  & ABORT_RATE_CHANGE notifiers
  clk_get_rate - return the rate of clk
  @clk: the clk whose rate is being returned
  Simply returns the cached rate of the clk, unless CLK_GET_RATE_NOCACHE flag
  is set, which means a recalc_rate will be issued.
  If clk is NULL then returns 0.
 Found it first try! 
 Something else is here, so keep looking 
 Maybe core hasn't been cached but the hw is all we know? 
 Didn't match, but we're expecting a clk_hw 
 Maybe it hasn't been cached (clk_set_parent() path) 
 Fallback to comparing globally unique names 
  clk_hw_get_parent_index - return the index of the parent clock
  @hw: clk_hw associated with the clk being consumed
  Fetches and returns the index of parent clock. Returns -EINVAL if the given
  clock does not have a current parent.
  Update the orphan status of @core and all its children.
 avoid duplicate POST_RATE_CHANGE notifications 
	
	  1. enable parents for CLK_OPS_PARENT_ENABLE clock
	 
	  2. Migrate prepare state between parents and prevent race with
	  clk_enable().
	 
	  If the clock is not prepared, then a race with
	  clk_enabledisable() is impossible since we already have the
	  prepare lock (future calls to clk_enable() need to be preceded by
	  a clk_prepare()).
	 
	  If the clock is prepared, migrate the prepared state to the new
	  parent and also protect against a race with clk_enable() by
	  forcing the clock and the new parent on.  This ensures that all
	  future calls to clk_enable() are practically NOPs with respect to
	  hardware and software states.
	 
	  See also: Comment for clk_set_parent() below.
 enable old_parent & parent if CLK_OPS_PARENT_ENABLE is set 
 migrate prepare count if > 0 
 update the clk tree topology 
	
	  Finish the migration of prepare state and undo the changes done
	  for preventing a race with clk_enable().
 re-balance ref counting if CLK_OPS_PARENT_ENABLE is set 
 change clock input source 
  __clk_speculate_rates
  @core: first clk in the subtree
  @parent_rate: the "future" rate of clk's parent
  Walks the subtree of clks starting with clk, speculating rates as it
  goes and firing off PRE_RATE_CHANGE notifications as necessary.
  Unlike clk_recalc_rates, clk_speculate_rates exists only for sending
  pre-rate change notifications and returns early if no clks in the
  subtree have subscribed to the notifications.  Note that if a clk does not
  implement the .recalc_rate callback then it is assumed that the clock will
  take on the rate of its parent.
 abort rate change if a driver returns NOTIFY_BAD or NOTIFY_STOP 
 include clk in new parent's PRE_RATE_CHANGE notifications 
  calculate the new rates returning the topmost clock that has to be
  changed.
 sanity 
 save parent rate, if it exists 
 find the closest rate and parent clkrate 
 pass-through clock without adjustable parent 
 pass-through clock with adjustable parent 
 some clocks must be gated to change parent 
 try finding the new parent index 
  Notify about rate changes in a subtree. Always walk down the whole tree
  so that in case of an error we can walk down the whole tree again and
  abort the change.
 Skip children who will be reparented to another clock 
 handle the new child who might not be in core->children yet 
  walk down a subtree and set the new rates notifying the rate
  change on the way
	
	  Use safe iteration, as change_rate can actually swap parents
	  for certain clock types.
 Skip children who will be reparented to another clock 
 handle the new child who might not be in core->children yet 
 simulate what the rate would be if it could be freely set 
 restore the protection 
 bail early if nothing to do 
 fail on a direct rate set of a protected provider 
 calculate new rates and get the topmost changed clock 
 notify that we are about to change rates 
 change the rates 
  clk_set_rate - specify a new rate for clk
  @clk: the clk whose rate is being changed
  @rate: the new rate for clk
  In the simplest case clk_set_rate will only adjust the rate of clk.
  Setting the CLK_SET_RATE_PARENT flag allows the rate change operation to
  propagate up to clk's parent; whether or not this happens depends on the
  outcome of clk's .round_rate implementation.  If parent_rate is unchanged
  after calling .round_rate then upstream parent propagation is ignored.  If
  parent_rate comes back with a new rate for clk's parent then we propagate
  up to clk's parent and set its rate.  Upward propagation will continue
  until either a clk does not support the CLK_SET_RATE_PARENT flag or
  .round_rate stops requesting changes to clk's parent_rate.
  Rate changes are accomplished via tree traversal that also recalculates the
  rates for the clocks and fires off POST_RATE_CHANGE notifiers.
  Returns 0 on success, -EERROR otherwise.
 prevent racing with updates to the clock topology 
  clk_set_rate_exclusive - specify a new rate and get exclusive control
  @clk: the clk whose rate is being changed
  @rate: the new rate for clk
  This is a combination of clk_set_rate() and clk_rate_exclusive_get()
  within a critical section
  This can be used initially to ensure that at least 1 consumer is
  satisfied when several consumers are competing for exclusivity over the
  same clock provider.
  The exclusivity is not applied if setting the rate failed.
  Calls to clk_rate_exclusive_get() should be balanced with calls to
  clk_rate_exclusive_put().
  Returns 0 on success, -EERROR otherwise.
 prevent racing with updates to the clock topology 
	
	  The temporary protection removal is not here, on purpose
	  This function is meant to be used instead of clk_rate_protect,
	  so before the consumer code path protect the clock provider
  clk_set_rate_range - set a rate range for a clock source
  @clk: clock source
  @min: desired minimum clock rate in Hz, inclusive
  @max: desired maximum clock rate in Hz, inclusive
  Returns success (0) or negative errno.
 Save the current values in case we need to rollback the change 
		
		  FIXME:
		  We are in bit of trouble here, current rate is outside the
		  the requested range. We are going try to request appropriate
		  range boundary but there is a catch. It may fail for the
		  usual reason (clock broken, clock protected, etc) but also
		  because:
		  - round_rate() was not favorable and fell on the wrong
		    side of the boundary
		  - the determine_rate() callback does not really check for
		    this corner case when determining the rate
 rollback the changes 
  clk_set_min_rate - set a minimum clock rate for a clock source
  @clk: clock source
  @rate: desired minimum clock rate in Hz, inclusive
  Returns success (0) or negative errno.
  clk_set_max_rate - set a maximum clock rate for a clock source
  @clk: clock source
  @rate: desired maximum clock rate in Hz, inclusive
  Returns success (0) or negative errno.
  clk_get_parent - return the parent of a clk
  @clk: the clk whose parent gets returned
  Simply returns clk->parent.  Returns NULL if clk is NULL.
 TODO: Create a per-user clk and change callers to call clk_put 
  clk_has_parent - check if a clock is a possible parent for another
  @clk: clock source
  @parent: parent clock source
  This function can be used in drivers that need to check that a clock can be
  the parent of another without actually changing the parent.
  Returns true if @parent is a possible parent for @clk, false otherwise.
 NULL clocks should be nops, so return success if either is NULL. 
 Optimize for the case where the parent is already the parent. 
 verify ops for multi-parent clks 
 check that we are allowed to re-parent if the clock is in use 
 try finding the new parent index 
 propagate PRE_RATE_CHANGE notifications 
 abort if a driver objects 
 do the re-parent 
 propagate rate an accuracy recalculation accordingly 
  clk_set_parent - switch the parent of a mux clk
  @clk: the mux clk whose input we are switching
  @parent: the new input to clk
  Re-parent clk to use parent as its new input source.  If clk is in
  prepared state, the clk will get enabled for the duration of this call. If
  that's not acceptable for a specific clk (Eg: the consumer can't handle
  that, the reparenting is glitchy in hardware, etc), use the
  CLK_SET_PARENT_GATE flag to allow reparenting only when clk is unprepared.
  After successfully changing clk's parent clk_set_parent will update the
  clk topology, sysfs topology and propagate rate recalculation via
  __clk_recalc_rates.
  Returns 0 on success, -EERROR otherwise.
  clk_set_phase - adjust the phase shift of a clock signal
  @clk: clock signal source
  @degrees: number of degrees the signal is shifted
  Shifts the phase of a clock signal by the specified
  degrees. Returns 0 on success, -EERROR otherwise.
  This function makes no distinction about the input or reference
  signal that we adjust the clock signal phase against. For example
  phase locked-loop clock signal generators we may shift phase with
  respect to feedback clock signal input, but for other cases the
  clock phase may be shifted with respect to some other, unspecified
  signal.
  Additionally the concept of phase shift does not propagate through
  the clock tree hierarchy, which sets it apart from clock rates and
  clock accuracy. A parent clock phase attribute does not have an
  impact on the phase attribute of a child clock.
 sanity check degrees 
 Always try to update cached phase if possible 
  clk_get_phase - return the phase shift of a clock signal
  @clk: clock signal source
  Returns the phase shift of a clock node in degrees, otherwise returns
  -EERROR.
 Assume a default value of 50% 
 Don't trust the clock provider too much 
  clk_set_duty_cycle - adjust the duty cycle ratio of a clock signal
  @clk: clock signal source
  @num: numerator of the duty cycle ratio to be applied
  @den: denominator of the duty cycle ratio to be applied
  Apply the duty cycle ratio if the ratio is valid and the clock can
  perform this operation
  Returns (0) on success, a negative errno otherwise.
 sanity check the ratio 
  clk_get_scaled_duty_cycle - return the duty cycle ratio of a clock signal
  @clk: clock signal source
  @scale: scaling factor to be applied to represent the ratio as an integer
  Returns the duty cycle ratio of a clock node multiplied by the provided
  scaling factor, or negative errno on error.
  clk_is_match - check if two clk's point to the same hardware clock
  @p: clk compared against q
  @q: clk compared against p
  Returns true if the two struct clk pointers both point to the same hardware
  clock node. Put differently, returns true if struct clk p and struct clk q
  share the same struct clk_core object.
  Returns false otherwise. Note that two NULL clks are treated as matching.
 trivial case: identical struct clk's or both NULL 
 true if clk->core pointers match. Avoid dereferencing garbage 
        debugfs support        
 This should be JSON format, i.e. elements separated with a comma 
  This can be dangerous, therefore don't provide any real compile time
  configuration option for this feature.
  People who want to use this will need to modify the source code directly.
 Unknown flags 
	
	  Go through the following options to fetch a parent's name.
	 
	  1. Fetch the registered parent clock and use its name
	  2. Use the global (fallback) name if specified
	  3. Use the local fw_name if provided
	  4. Fetch parent clock's clock-output-name if DT index was set
	 
	  This may still fail in some cases, such as when the parent is
	  specified directly via a struct clk_hw pointer, but it isn't
	  registered (yet).
  clk_debug_register - add a clk node to the debugfs clk directory
  @core: the clk being added to the debugfs clk directory
  Dynamically adds a clk to the debugfs clk directory if debugfs has been
  initialized.  Otherwise it bails out early since the debugfs clk directory
  will be created lazily by clk_debug_init as part of a late_initcall.
  clk_debug_unregister - remove a clk node from the debugfs clk directory
  @core: the clk being removed from the debugfs clk directory
  Dynamically removes a clk and all its child nodes from the
  debugfs clk directory if clk->dentry points to debugfs created by
  clk_debug_register in __clk_core_init.
  clk_debug_init - lazily populate the debugfs clk directory
  clks are often initialized very early during boot before memory can be
  dynamically allocated and well before debugfs is setup. This function
  populates the debugfs clk directory once at boot-time when we know that
  debugfs is setup. It should only be called once at boot-time, all other clks
  added dynamically will be done so with clk_debug_register.
	
	  walk the list of orphan clocks and reparent any that newly finds a
	  parent.
		
		  We need to use __clk_set_parent_before() and _after() to
		  to properly migrate any prepareenable count of the orphan
		  clock. This is important for CLK_IS_CRITICAL clocks, which
		  are enabled during init but might not have a parent yet.
 update the clk tree topology 
  __clk_core_init - initialize the data structures in a struct clk_core
  @core:	clk_core being initialized
  Initializes the lists in struct clk_core, queries the hardware for the
  parent and rate and sets them both.
 check to see if a clock with this name is already registered 
 check that clk_ops are sane.  See Documentationdriver-apiclk.rst 
	
	  optional platform-specific magic
	 
	  The .init callback is not used by any of the basic clock types, but
	  exists for weird hardware that must perform initialization magic for
	  CCF to get an accurate view of clock for any other callbacks. It may
	  also be used needs to perform dynamic allocations. Such allocation
	  must be freed in the terminate() callback.
	  This callback shall not be used to initialize the parameters state,
	  such as rate, parent, etc ...
	 
	  If it exist, this callback should called before any other callback of
	  the clock
	
	  Populate core->parent if parent has already been clk_core_init'd. If
	  parent has not yet been clk_core_init'd then place clk in the orphan
	  list.  If clk doesn't have any parents then place it in the root
	  clk list.
	 
	  Every time a new clk is clk_init'd then we walk the list of orphan
	  clocks and re-parent any that are children of the clock currently
	  being clk_init'd.
	
	  Set clk's accuracy.  The preferred method is to use
	  .recalc_accuracy. For simple clocks and lazy developers the default
	  fallback is to use the parent's accuracy.  If a clock doesn't have a
	  parent (or is orphaned) then accuracy is set to zero (perfect
	  clock).
	
	  Set clk's phase by clk_core_get_phase() caching the phase.
	  Since a phase is by definition relative to its parent, just
	  query the current clock phase, or just assume it's in phase.
	
	  Set clk's duty cycle.
	
	  Set clk's rate.  The preferred method is to use .recalc_rate.  For
	  simple clocks and lazy developers the default fallback is to use the
	  parent's rate.  If a clock doesn't have a parent (or is orphaned)
	  then rate is set to zero.
	
	  Enable CLK_IS_CRITICAL clocks so newly added critical clocks
	  don't get accidentally disabled when walking the orphan tree and
	  reparenting clocks
  clk_core_link_consumer - Add a clk consumer to the list of consumers in a clk_core
  @core: clk to add consumer to
  @clk: consumer to link to a clk
  clk_core_unlink_consumer - Remove a clk consumer from the list of consumers in a clk_core
  @clk: consumer to unlink
  alloc_clk - Allocate a clk consumer, but leave it unlinked to the clk_core
  @core: clk to allocate a consumer for
  @dev_id: string describing device name
  @con_id: connection ID string on device
  Returns: clk consumer left unlinked from the consumer list
  free_clk - Free a clk consumer
  @clk: clk consumer to free
  Note, this assumes the clk has been unlinked from the clk_core consumer
  list.
  clk_hw_create_clk: Allocate and link a clk consumer to a clk_core given
  a clk_hw
  @dev: clk consumer device
  @hw: clk_hw associated with the clk being consumed
  @dev_id: string describing device name
  @con_id: connection ID string on device
  This is the main function used to create a clk pointer for use by clk
  consumers. It connects a consumer to the clk_core and clk_hw structures
  used by the framework and clk provider respectively.
 This is to allow this function to be chained to others 
  clk_hw_get_clk - get clk consumer given an clk_hw
  @hw: clk_hw associated with the clk being consumed
  @con_id: connection ID string on device
  Returns: new clk consumer
  This is the function to be used by providers which need
  to get a consumer clk and act on the clock element
  Calls to this function must be balanced with calls clk_put()
	
	  Avoid unnecessary string look-ups of clk_core's possible parents by
	  having a cache of namesclk_hw pointers to clk_core pointers.
 Copy everything over because it might be __initdata 
 throw a WARN if any entries are NULL 
	
	  The init data is not supposed to be used outside of registration path.
	  Set it to NULL so that provider drivers can't use it either and so that
	  we catch use of hw->init early on in the core.
	
	  Don't call clk_hw_create_clk() here because that would pin the
	  provider module to itself and prevent it from ever being removed.
  dev_or_parent_of_node() - Get device node of @dev or @dev's parent
  @dev: Device to get device node of
  Return: device node pointer of @dev, or the device node pointer of
  @dev->parent if dev doesn't have a device node, or NULL if neither
  @dev or @dev->parent have a device node.
  clk_register - allocate a new clock, register it and return an opaque cookie
  @dev: device that is registering this clock
  @hw: link to hardware-specific clock data
  clk_register is the deprecated interface for populating the clock tree with
  new clock nodes. Use clk_hw_register() instead.
  Returns: a pointer to the newly allocated struct clk which
  cannot be dereferenced by driver code but may be used in conjunction with the
  rest of the clock API.  In the event of an error clk_register will return an
  error code; drivers must test for an error code after calling clk_register.
  clk_hw_register - register a clk_hw and return an error code
  @dev: device that is registering this clock
  @hw: link to hardware-specific clock data
  clk_hw_register is the primary interface for populating the clock tree with
  new clock nodes. It returns an integer equal to zero indicating success or
  less than zero indicating failure. Drivers must test for an error code after
  calling clk_hw_register().
  of_clk_hw_register - register a clk_hw and return an error code
  @node: device_node of device that is registering this clock
  @hw: link to hardware-specific clock data
  of_clk_hw_register() is the primary interface for populating the clock tree
  with new clock nodes when a struct device is not available, but a struct
  device_node is. It returns an integer equal to zero indicating success or
  less than zero indicating failure. Drivers must test for an error code after
  calling of_clk_hw_register().
 Free memory allocated for a clock. 
  Empty clk_ops for unregistered clocks. These are used temporarily
  after clk_unregister() was called on a clock and until last clock
  consumer calls clk_put() and the struct clk object is freed.
 Remove this clk from all parent caches 
  clk_unregister - unregister a currently registered clock
  @clk: clock to unregister
	
	  Assign empty clock ops for consumers that might still hold
	  a reference to this clock.
 Reparent all children to the orphan list. 
  clk_hw_unregister - unregister a currently registered clk_hw
  @hw: hardware-specific clock data to unregister
  devm_clk_register - resource managed clk_register()
  @dev: device that is registering this clock
  @hw: link to hardware-specific clock data
  Managed clk_register(). This function is deprecated, use devm_clk_hw_register() instead.
  Clocks returned from this function are automatically clk_unregister()ed on
  driver detach. See clk_register() for more information.
  devm_clk_hw_register - resource managed clk_hw_register()
  @dev: device that is registering this clock
  @hw: link to hardware-specific clock data
  Managed clk_hw_register(). Clocks registered by this function are
  automatically clk_hw_unregister()ed on driver detach. See clk_hw_register()
  for more information.
  devm_clk_unregister - resource managed clk_unregister()
  @dev: device that is unregistering the clock data
  @clk: clock to unregister
  Deallocate a clock allocated with devm_clk_register(). Normally
  this function will not need to be called and the resource management
  code will ensure that the resource is freed.
  devm_clk_hw_unregister - resource managed clk_hw_unregister()
  @dev: device that is unregistering the hardware-specific clock data
  @hw: link to hardware-specific clock data
  Unregister a clk_hw registered with devm_clk_hw_register(). Normally
  this function will not need to be called and the resource management
  code will ensure that the resource is freed.
  devm_clk_hw_get_clk - resource managed clk_hw_get_clk()
  @dev: device that is registering this clock
  @hw: clk_hw associated with the clk being consumed
  @con_id: connection ID string on device
  Managed clk_hw_get_clk(). Clocks got with this function are
  automatically clk_put() on driver detach. See clk_put()
  for more information.
	 This should not happen because it would mean we have drivers
	  passing around clk_hw pointers instead of having the caller use
	  proper clk_get() style APIs
  clkdev helpers
	
	  Before calling clk_put, all calls to clk_rate_exclusive_get() from a
	  given user should be balanced with calls to clk_rate_exclusive_put()
	  and by that same consumer
 We voiced our concern, let's sanitize the situation 
        clk rate change notifiers        
  clk_notifier_register - add a clk rate change notifier
  @clk: struct clk  to watch
  @nb: struct notifier_block  with callback info
  Request notification when clk's rate changes.  This uses an SRCU
  notifier because we want it to block and notifier unregistrations are
  uncommon.  The callbacks associated with the notifier must not
  re-enter into the clk framework by calling any top-level clk APIs;
  this will cause a nested prepare_lock mutex.
  In all notification cases (pre, post and abort rate change) the original
  clock rate is passed to the callback via struct clk_notifier_data.old_rate
  and the new frequency is passed via struct clk_notifier_data.new_rate.
  clk_notifier_register() must be called from non-atomic context.
  Returns -EINVAL if called with null arguments, -ENOMEM upon
  allocation failure; otherwise, passes along the return value of
  srcu_notifier_chain_register().
 search the list of notifiers for this clk 
 if clk wasn't in the notifier list, allocate new clk_notifier 
  clk_notifier_unregister - remove a clk rate change notifier
  @clk: struct clk 
  @nb: struct notifier_block  with callback info
  Request no further notification for changes to 'clk' and frees memory
  allocated in clk_notifier_register.
  Returns -EINVAL if called with null arguments; otherwise, passes
  along the return value of srcu_notifier_chain_unregister().
 XXX the notifier code should handle this better 
  struct of_clk_provider - Clock provider registration structure
  @link: Entry in global list of clock providers
  @node: Pointer to device tree node of clock provider
  @get: Get clock callback.  Returns NULL or a struct clk for the
        given clock specifier
  @get_hw: Get clk_hw callback.  Returns NULL, ERR_PTR or a
        struct clk_hw for the given clock specifier
  @data: context pointer to be passed into @get callback
  of_clk_add_provider() - Register a clock provider for a node
  @np: Device node pointer associated with clock provider
  @clk_src_get: callback for decoding clock
  @data: context pointer for @clk_src_get callback.
  This function is deprecated. Use of_clk_add_hw_provider() instead.
  of_clk_add_hw_provider() - Register a clock provider for a node
  @np: Device node pointer associated with clock provider
  @get: callback for decoding clk_hw
  @data: context pointer for @get callback.
  We allow a child device to use its parent device as the clock provider node
  for cases like MFD sub-devices where the child device driver wants to use
  devm_() APIs but not list the device in DT as a sub-node.
  devm_of_clk_add_hw_provider() - Managed clk provider node registration
  @dev: Device acting as the clock provider (used for DT node and lifetime)
  @get: callback for decoding clk_hw
  @data: context pointer for @get callback
  Registers clock provider for given device's node. If the device has no DT
  node or if the device node lacks of clock provider information (#clock-cells)
  then the parent device's node is scanned for this information. If parent node
  has the #clock-cells then it is used in registration. Provider is
  automatically released at device exit.
  Return: 0 on success or an errno on failure.
  of_clk_del_provider() - Remove a previously registered clock provider
  @np: Device node pointer associated with clock provider
  devm_of_clk_del_provider() - Remove clock provider registered using devm
  @dev: Device to whose lifetime the clock provider was bound
  of_parse_clkspec() - Parse a DT clock specifier for a given device node
  @np: device node to parse clock specifier from
  @index: index of phandle to parse clock out of. If index < 0, @name is used
  @name: clock name to find and parse. If name is NULL, the index is used
  @out_args: Result of parsing the clock specifier
  Parses a device node's "clocks" and "clock-names" properties to find the
  phandle and cells for the index or name that is desired. The resulting clock
  specifier is placed into @out_args, or an errno is returned when there's a
  parsing error. The @index argument is ignored if @name is non-NULL.
  Example:
  phandle1: clock-controller@1 {
 	#clock-cells = <2>;
  }
  phandle2: clock-controller@2 {
 	#clock-cells = <1>;
  }
  clock-consumer@3 {
 	clocks = <&phandle1 1 2 &phandle2 3>;
 	clock-names = "name1", "name2";
  }
  To get a device_node for `clock-controller@2' node you may call this
  function a few different ways:
    of_parse_clkspec(clock-consumer@3, -1, "name2", &args);
    of_parse_clkspec(clock-consumer@3, 1, NULL, &args);
    of_parse_clkspec(clock-consumer@3, 1, "name2", &args);
  Return: 0 upon successfully parsing the clock specifier. Otherwise, -ENOENT
  if @name is NULL or -EINVAL if @name is non-NULL and it can't be found in
  the "clock-names" property of @np.
 Walk up the tree of devices looking for a clock property that matches 
		
		  For named clocks, first look up the name in the
		  "clock-names" property.  If it cannot be found, then index
		  will be an error code and of_parse_phandle_with_args() will
		  return -EINVAL.
		
		  No matching clock found on this node.  If the parent node
		  has a "clock-ranges" property, then we can try one of its
		  clocks.
  of_clk_get_from_provider() - Lookup a clock from a clock provider
  @clkspec: pointer to a clock specifier data structure
  This function looks up a struct clk from the registered list of clock
  providers, an input is a clock specifier data structure as returned
  from the of_parse_phandle_with_args() function call.
  of_clk_get_by_name() - Parse and lookup a clock referenced by a device node
  @np: pointer to clock consumer node
  @name: name of consumer's clock input, or NULL for the first clock reference
  This function parses the clocks and clock-names properties,
  and uses them to look up the struct clk from the registered list of clock
  providers.
  of_clk_get_parent_count() - Count the number of clocks a device node has
  @np: device node to count
  Returns: The number of clocks that are possible parents of this node
	 if there is an indices property, use it to transfer the index
	  specified into an array offset for the clock-output-names property.
 We went off the end of 'clock-indices' without finding it 
		
		  Best effort to get the name if the clock has been
		  registered with the framework. If the clock isn't
		  registered, we return the node name as the name of
		  the clock as long as #clock-cells = 0.
  of_clk_parent_fill() - Fill @parents with names of @np's parents and return
  number of parents
  @np: Device node pointer associated with clock provider
  @parents: pointer to char array that hold the parents' names
  @size: size of the @parents array
  Return: number of parents for the clock node.
  This function looks for a parent clock. If there is one, then it
  checks that the provider for this parent clock was initialized, in
  this case the parent clock will be ready.
 this parent is ready we can check the next one 
 at least one parent is not ready, we exit now 
		
		  Here we make assumption that the device tree is
		  written correctly. So an error means that there is
		  no more parent. As we didn't exit yet, then the
		  previous parent are ready. If there is no clock
		  parent, no need to wait for them, then we can
		  consider their absence as being ready
  of_clk_detect_critical() - set CLK_IS_CRITICAL flag from Device Tree
  @np: Device node pointer associated with clock provider
  @index: clock index
  @flags: pointer to top-level framework flags
  Detects if the clock-critical property exists and, if so, sets the
  corresponding CLK_IS_CRITICAL flag.
  Do not use this function. It exists only for legacy Device Tree
  bindings, such as the one-clock-per-node style that are outdated.
  Those bindings typically put all clock data into .dts and the Linux
  driver has no clock data, thus making it impossible to set this flag
  correctly from the driver. Only those drivers may call
  of_clk_detect_critical from their setup functions.
  Return: error code or zero on success
  of_clk_init() - Scan and init clock providers from the DT
  @matches: array of compatible values and init functions for providers.
  This function scans the device tree for matching clock providers
  and calls their initialization functions. It also does it by trying
  to follow the dependencies.
 First prepare the list of the clocks providers 
 Don't populate platform devices 
		
		  We didn't manage to initialize any of the
		  remaining providers during the last loop, so now we
		  initialize all the remaining ones unconditionally
		  in case the clock parent was not mandatory
 SPDX-License-Identifier: GPL-2.0-or-later
   Cirrus Logic CLPS711X CLK driver
   Copyright (C) 2014 Alexander Shiyan <shc_work@mail.ru>
 Read PLL multiplier value and sanity check 
	 Timer1 in free running mode.
	  Counter will wrap around to 0xffff when it underflows
	  and will continue to count down.
	 Timer2 in prescale mode.
	  Value writen is automatically re-loaded when
	  the counter underflows.
 SPDX-License-Identifier: GPL-2.0+
 Copyright IBM Corp
 Globally visible clocks 
 Keeps track of all clocks 
 TODO: ask Aspeed about the actual parent data 
				 clk rst   name			parent	flags 
 Video Engine 
 2D engine 
 SDRAM 
 Video Capture 
 PCIePCI 
 DAC 
 USB2.0 Host port 2 
 LPC 
 USB1.1 (requires port 2 enabled) 
 GFX CRT 
 HAC 
 USB2 hubUSB2 host port 1USB1.1 dev 
 UART1 
 UART2 
 UART5 
 eSPI 
 MAC1 
 MAC2 
 RSA 
 UART3 
 UART4 
 SDIOSD 
 LPC masterLPC+ 
 Yep, really. Aspeed confirmed this is correct 
 Pass through mode 
 F = 24Mhz  (2-OD)  [(N + 2)  (D + 1)] 
 Pass through mode 
 F = clkin  [(M+1)  (N+1)]  (P + 1) 
	
	  If the IP is in reset, treat the clock as not enabled,
	  this happens with some clocks such as the USB one when
	  coming from cold reset. Without this, aspeed_clk_enable()
	  will fail to lift the reset.
 Put IP in reset 
 Delay 100us 
 Enable clock 
 A delay of 10ms is specified by the ASPEED docs 
 Take IP out of reset 
 SCU04 resets 
	
	  SCUD4 resets start at an offset to separate them from
	  the SCU04 resets.
 SoC generations share common layouts but have different divisors 
 UART clock div13 setting 
 TODO: Find the parent data for the uart clock 
	
	  Memory controller (M-PLL) PLL. This clock is configured by the
	  bootloader, and is exposed to Linux as a read-only clock rate.
 SDSDIO clock divider and gate 
 MAC AHB bus clock divider 
 RMII 50MHz RCLK 
 RMII1 50MHz (RCLK) output enable 
 RMII2 50MHz (RCLK) output enable 
 LPC Host (LHCLK) clock divider 
 P-Bus (BCLK) clock divider 
 Fixed 24MHz clock 
	
	  TODO: There are a number of clocks that not included in this driver
	  as more information is required:
	    D2-PLL
	    D-PLL
	    YCLK
	    RGMII
	    RMII
	    UART[1..5] clock source mux
		 Special case: the USB port 1 clock (bit 14) is always
		  working the opposite way from the other ones.
	
	  CLKIN is the crystal oscillator, 24, 48 or 25MHz selected by
	  strapping
	
	  High-speed PLL clock derived from the crystal. This the CPU clock,
	  and we assume that it is enabled. It can be configured through the
	  HPLL_PARAM register, or set to a specified frequency by strapping.
	
	  Strap bits 11:10 define the CPUAHB clock frequency ratio (aka HCLK)
	    00: Select CPU:AHB = 1:1
	    01: Select CPU:AHB = 2:1
	    10: Select CPU:AHB = 4:1
	    11: Select CPU:AHB = 3:1
 APB clock clock selection register SCU08 (aka PCLK) 
 CLKIN is the crystal oscillator, 24 or 25MHz selected by strapping 
	
	  High-speed PLL clock derived from the crystal. This the CPU clock,
	  and we assume that it is enabled
 Strap bits 11:9 define the AXIAHB clock frequency ratio (aka HCLK)
 APB clock clock selection register SCU08 (aka PCLK) 
	
	  This way all clocks fetched before the platform device probes,
	  except those we assign here for early use, will be deferred.
	
	  We check that the regmap works on this very first access,
	  but as this is an MMIO-backed regmap, subsequent regmap
	  access is not going to fail and we skip error checks from
	  this point.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2015 Maxime Ripard <maxime.ripard@free-electrons.com>
 Make sure we don't end up with a 0 multiplier 
 Make sure we don't overflow the multiplier 
			
			  This is the best case for us if we have a
			  perfect match without changing the parent
			  rate.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018 Socionext Inc.
  Copyright (C) 2016 Linaro Ltd.
 if read only, just return current value 
 register the clock 
	
	  The registers on CLKSEL(9) or CLKSEL(10) need additional
	  writing to become valid.
	
	  This way all clocks fetched before the platform device probes,
	  except those we assign here for early use, will be deferred.
	
	  PLLs are set by bootloader so this driver registers them as the
	  fixed factor.
	
	  timer consumes "rclk" so it needs to register here.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2019 NXP
  Clock driver for LS1028A Display output interfaces(LCD, DPHY).
 PLLDIG register offsets and bit masks 
 Range of the VCO frequencies, in Hz 
 Range of the output frequencies, in Hz 
 Maximum value of the reduced frequency divider 
 Best value of multiplication factor divider 
  Denominator part of the fractional part of the
  loop multiplication factor.
	
	  Use Bypass mode with PLL off by default, the frequency overshoot
	  detector output was disable. SSCG Bypass mode should be enable.
 Check if PLL is bypassed 
	
	  If RFDPHI1 has a value of 1 the VCO frequency is also divided by
	  one.
 update the divider value 
 waiting for old lock state to clear 
 Wait until PLL is locked or timeout 
 Enable fractional divider 
	
	  The frequency of the VCO cannot be changed during runtime.
	  Therefore, let the user specify a desired frequency.
 SPDX-License-Identifier: GPL-2.0-only
 TWL6040 clock module driver for OMAP4 McPDM functional clock
 Copyright (C) 2012 Texas Instruments Inc.
 Peter Ujfalusi <peter.ujfalusi@ti.com>
 Same for HPPLL and LPPLL 
  TWL6040A2 Phoenix Audio IC erratum #6: "PDM Clock Generation Issue At
  Cold Temperature". This affects cold boot and deeper idle states it
  seems. The workaround consists of resetting HPPLL and LPPLL.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2013 Freescale Semiconductor, Inc.
  Copyright 2021 NXP
  clock driver for Freescale QorIQ SoCs.
 only on clockgen-1.0, which lacks CGB 
 Only allowed if PLL <= 80% of max cpu freq 
 CLKSEL_xxx 
 CGx_PLLn 
 PLL_DIVn 
  cmux freq must be >= platform pll.
  If not set, cmux freq must be >= platform pll2
 PLLCnGSR[CFG] is 8 bits, not 6 
 version 3 cg: reg layout different 
 array should be -1 terminated 
 1 << n bit set if PLL n is valid 
 CG_xxx 
 mutable copy 
  Don't allow setting for now, as the clock options haven't been
  sanitized for additional restrictions.
	
	  Find the rate for the default clksel, and treat it as the
	  maximum rated core frequency.  If this is an incorrect
	  assumption, certain clock options (possibly including the
	  default clksel) may be inappropriately excluded on certain
	  chips.
  Legacy nodes may get probed before the parent clockgen node.
  It is assumed that device trees with legacy nodes will not
  contain a "clocks" property -- otherwise the input clocks may
  not be initialized at this point.
 Legacy node 
 Register the input clock under the desired name. 
	
	  This indicates a mix of legacy nodes with the new coreclk
	  mechanism, which should never happen.  If this error occurs,
	  don't use the wrong input clock just because coreclk isn't
	  ready yet.
 Legacy node 
 Get the multiple of PLL 
 Check if this PLL is disabled 
		
		  For platform PLL, there are MAX_PLL_DIV divider clocks.
		  For core PLL, there are 4 divider clocks at most.
 Legacy node 
 Legacy node 
		
		  ls1021a devtree labels the platform PLL
		  with the core PLL compatible
 P2040 1.0 
 P2040 1.1 
 P2041 1.0 
 P2041 1.1 
 P3041 1.0 
 P3041 1.1 
 P4040 2.0 
 P4080 2.0 
 P5010 1.0 
 P5010 2.0 
 P5020 1.0 
 P5021 1.0 
 P5040 1.0 
 The Security (E) bit 
 May have already been called by a legacy probe 
 Compatibility hack for old, broken device trees 
 Don't create cpufreq device for legacy clockgen blocks 
 Legacy nodes 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2010 Broadcom
  Copyright (C) 2012 Stephen Warren
  Copyright (C) 2016 Neil Armstrong <narmstrong@baylibre.com>
 Standard regmap gate clocks 
 Regmap offsets 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2014 Philipp Zabel, Pengutronix
  PWM (mis)used as clock output
	
	  FIXME: pwm_apply_args() should be removed when switching to the
	  atomic PWM API.
 SPDX-License-Identifier: GPL-2.0-only
   Copyright (C) 2013 Daniel Tang <tangrs@tangrs.id.au>
 SPDX-License-Identifier: GPL-2.0+
 clk-max77686.c - Clock driver for Maxim 77686MAX77802
 Copyright (C) 2012 Samsung Electornics
 Jonghwa Lee <jonghwa3.lee@samsung.com>
 MAX77802: Enable low-jitter mode on the 32khz clocks. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2019-20 Sean Anderson <seanga2@gmail.com>
  Copyright (c) 2019 Western Digital Corporation or its affiliates.
 Gated clocks, no mux, no divider 
 Gated divider clocks 
 Divider clocks, no gate, no mux 
 Muxed gated divider clocks 
  PLL control register bits.
 PLL2 only 
  PLL lock register bits.
  Clock selector register bits.
  PLLs.
  PLLs configuration: by default PLL0 runs at 780 MHz and PLL1 at 299 MHz.
  The first 2 SRAM banks depend on ACLKCPU clock which is by default PLL0
  rate divided by 2. Set PLL1 to 390 MHz so that the third SRAM bank has the
  same clock as the first 2.
 780 MHz 
 390 MHz 
 299 MHz 
  struct k210_sysclk - sysclk driver data
  @regs: system controller registers start address
  @clk_lock: clock setting spinlock
  @plls: SoC PLLs descriptors
  @aclk: ACLK clock
  @clks: All other clocks
  Set ACLK parent selector: 0 for IN0, 1 for PLL0.
	
	  For PLL0, we need to re-parent ACLK to IN0 to keep the CPU cores and
	  SRAM running.
 Set PLL factors 
	
	  Reset the PLL: ensure reset is low before asserting it.
	  The magic NOPs come from the Kendryte reference SDK.
	
	  Bypassing before powering off is important so child clocks do not
	  stop working. This is especially important for pll0, the indirect
	  parent of the cpu clock.
 .index = 0 for in0  },
 PLL0 and PLL1 only have IN0 as parent 
 PLL2 has IN0, PLL0 and PLL1 as parents 
  ACLK has IN0 and PLL0 as parents.
 .index = 0 for in0  },
  All muxed clocks have IN0 and PLL0 as parents.
 .index = 0 for in0  },
 .index = 0 for in0 
	
	  Critical clocks: there are no consumers of the SRAM clocks,
	  including the AI clock for the third SRAM bank. The CPU clock
	  is only referenced by the uarths serial device and so would be
	  disabled if the serial console is disabled to switch to another
	  console. Mark all these clocks as critical so that they are never
	  disabled by the core clock management.
 Clocks with aclk as source 
 Clocks with PLL0 as source 
 Clocks with PLL2 as source 
 Clocks with IN0 as source 
 Clocks with APB0 as source 
 Clocks with APB1 as source 
 Mux clocks with in0 or pll0 as source 
 Check for registration errors 
  Enable PLL1 to be able to use the AI SRAM.
 Make sure ACLK selector is set to PLL0 
 Startup PLL1 to enable the aisram bank for general memory use 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2014 Samsung Electronics Co., Ltd.
  Sylwester Nawrocki <s.nawrocki@samsung.com>
 skip empty (null) phandles 
 skip empty (null) phandles 
  of_clk_set_defaults() - parse and set assigned clocks configuration
  @node: device node to apply clock settings for
  @clk_supplier: true if clocks supplied by @node should also be considered
  This function parses 'assigned-{clocksclock-parentsclock-rates}' properties
  and sets any specified clock parents and rates. The @clk_supplier argument
  should be set to true if @node may be also a clock supplier of any clock
  listed in its 'assigned-clocks' or 'assigned-clock-parents' properties.
  If @clk_supplier is false the function exits returning 0 as soon as it
  determines the @node is also a supplier of any of the clocks.
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for Silicon Labs Si570Si571 Programmable XOVCXO
  Copyright (C) 2010, 2011 Ericsson AB.
  Copyright (C) 2011 Guenter Roeck.
  Copyright (C) 2011 - 2021 Xilinx Inc.
  Author: Guenter Roeck <guenter.roeck@ericsson.com>
 	   Sören Brinkmann <soren.brinkmann@xilinx.com>
 Si570 registers 
  struct clk_si570:
  @hw:	Clock hw struct
  @regmap:	Device's regmap
  @div_offset:	Rgister offset for dividers
  @max_freq:	Maximum frequency for this device
  @fxtal:	Factory xtal frequency
  @n1:		Clock divider N1
  @hs_div:	Clock divider HSDIV
  @rfreq:	Clock multiplier RFREQ
  @frequency:	Current output frequency
  @i2c_client:	I2C client pointer
  si570_get_divs() - Read clock dividers from HW
  @data:	Pointer to struct clk_si570
  @rfreq:	Fractional multiplier (output)
  @n1:		Divider N1 (output)
  @hs_div:	Divider HSDIV (output)
  Returns 0 on success, negative errno otherwise.
  Retrieve clock dividers and multipliers from the HW.
 Handle invalid cases 
  si570_get_defaults() - Get default values
  @data:	Driver data structure
  @fout:	Factory frequency output
  @skip_recall:	If true, don't recall NVM into RAM
  Returns 0 on success, negative errno otherwise.
	
	  Accept optional precision loss to avoid arithmetic overflows.
	  Acceptable per Silicon Labs Application Note AN334.
  si570_update_rfreq() - Update clock multiplier
  @data:	Driver data structure
  Passes on regmap_bulk_write() return value.
  si570_calc_divs() - Caluclate clock dividers
  @frequency:	Target frequency
  @data:	Driver data structure
  @out_rfreq:	RFREG fractional multiplier (output)
  @out_n1:	Clock divider N1 (output)
  @out_hs_div:	Clock divider HSDIV (output)
  Returns 0 on success, negative errno otherwise.
  Calculate the clock dividers (@out_hs_div, @out_n1) and clock multiplier
  (@out_rfreq) for a given target @frequency.
 Calculate lowest possible value for n1 
  si570_set_frequency() - Adjust output frequency
  @data:	Driver data structure
  @frequency:	Target frequency
  Returns 0 on success.
  Update output frequency for big frequency changes (> 3,500 ppm).
	
	  The DCO reg should be accessed with a read-modify-write operation
	  per AN334
 Applying a new frequency can take up to 10ms 
  si570_set_frequency_small() - Adjust output frequency
  @data:	Driver data structure
  @frequency:	Target frequency
  Returns 0 on success.
  Update output frequency for small frequency changes (< 3,500 ppm).
	
	  This is a re-implementation of DIV_ROUND_CLOSEST
	  using the div64_u64 function lieu of letting the compiler
	  insert EABI calls
 Applying a new frequency (small change) can take up to 100us 
 adjust register offsets for 7ppm devices 
 Read the requested initial output frequency from device tree 
 Display a message indicating that we've successfully registered 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2010-2011 Canonical Ltd <jeremy.kerr@canonical.com>
  Copyright (C) 2011-2012 Mike Turquette, Linaro Ltd <mturquette@linaro.org>
  Fixed rate clock implementation
  DOC: basic fixed-rate clock that cannot gate
  Traits of this clock:
  prepare - clk_(un)prepare only ensures parents are prepared
  enable - clk_enable only ensures parents are enabled
  rate - rate is always a fixed value.  No clk_set_rate support
  parent - fixed parent.  No clk_set_parent support
 allocate fixed-rate clock 
 struct clk_fixed_rate assignments 
 register the clock 
  of_fixed_clk_setup() - Setup function for simple fixed rate clock
  @node:	device node for the clock
	
	  This function is not executed when of_fixed_clk_setup
	  succeeded.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2011 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
  Copyright (C) 2011 Richard Zhao, Linaro <richard.zhao@linaro.org>
  Copyright (C) 2011-2012 Mike Turquette, Linaro Ltd <mturquette@linaro.org>
  Adjustable divider clock implementation
  DOC: basic adjustable divider clock that cannot gate
  Traits of this clock:
  prepare - clk_prepare only ensures that parents are prepared
  enable - clk_enable only ensures that parents are enabled
  rate - rate is adjustable.  clk->rate = ceiling(parent->rate  divisor)
  parent - fixed parent.  No clk_set_parent support
	
	  The maximum divider we can use without overflowing
	  unsigned long in rate  i below
			
			  It's the most ideal case if the requested rate can be
			  divided from parent clock without needing to change
			  parent rate, so return the divider immediately.
 Even a read-only clock can propagate a rate change 
 if read only, just return current value 
 if read only, just return current value 
 allocate the divider 
 struct clk_divider assignments 
 register the clock 
  clk_register_divider_table - register a table based divider clock with
  the clock framework
  @dev: device registering this clock
  @name: name of this clock
  @parent_name: name of clock's parent
  @flags: framework-specific flags
  @reg: register address to adjust divider
  @shift: number of bits to shift the bitfield
  @width: width of the bitfield
  @clk_divider_flags: divider-specific flags for this clock
  @table: array of dividervalue pairs ending with a div set to 0
  @lock: shared register lock for this clock
  clk_hw_unregister_divider - unregister a clk divider
  @hw: hardware-specific clock data to unregister
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) STMicroelectronics 2017
  Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
 Reset Clock Control Registers 
 System clock parent 
 Kernel clock parent 
 i2c 1,2,3 src 
 usart 1,6 src 
 usart 2,3,4,5,7,8 src 
 lptim 2,3,4,5 src 
 RTC clock parent 
 Micro-controller output clock parent 
 LCD clock 
 Gate clock with ready bit and backup domain management 
	 We can't use readl_poll_timeout() because we can blocked if
	  someone enables this clock before clocksource changes.
	  Only jiffies counter is available. Jiffies are incremented by
	  interruptions and enable op does not allow to be interrupted.
  General config definition of a composite clock (only clock diviser for rate)
 Kernel Timer 
 CORE AND BUS 
 D1 DOMAIN 
  CPU Systick 
  APB3 peripheral 
 D2 DOMAIN 
  APB1 peripheral 
 Timers prescaler clocks 
  APB2 peripheral 
 D3 DOMAIN 
  APB4 peripheral 
 MUX clock configuration 
 Oscillary clock configuration 
 PLL configuration 
 ODF CLOCKS 
 PERIF CLOCKS 
 KERNEL CLOCKS 
 RTC clock 
  RTC & LSE registers are protected against parasitic write access.
  PWR_CR_DBP bit must be set to enable write access to RTC registers.
 STM32_PWR_CR 
 STM32_PWR_CR bit field 
 Micro-controller output clock 
 get RCC base @ from DT 
		 In any case disable backup domain write protection
		  and will never be enabled.
		  Needed by LSE & RTC clocks.
 Put parent names from DT 
 Register Internal oscillators 
 This clock is coming from outside. Frequencies unknown 
 Mux system clocks 
 Oscillary clocks 
 PLLs 
 Register the VCO 
 Register the 3 output dividers 
 Peripheral clocks 
 Kernel clocks 
 RTC clock (default state is off) 
 Micro-controller clocks 
 The RCC node is a clock and reset controller, and these
  functionalities are supported by different drivers that
  matches the same compatible strings.
 SPDX-License-Identifier: GPL-2.0-only
  driversclkclk-axm5516.c
  Provides clock implementations for three different types of clock devices on
  the Axxia device: PLL clock, a clock divider and a clock mux.
  Copyright (C) 2014 LSI Corporation
  struct axxia_clk - Common struct to all Axxia clocks.
  @hw: clk_hw for the common clk framework
  @regmap: Regmap for the clock control registers
  struct axxia_pllclk - Axxia PLL generated clock.
  @aclk: Common struct
  @reg: Offset into regmap for PLL control register
  axxia_pllclk_recalc - Calculate the PLL generated clock rate given the
  parent clock rate.
  struct axxia_divclk - Axxia clock divider
  @aclk: Common struct
  @reg: Offset into regmap for PLL control register
  @shift: Bit position for divider value
  @width: Number of bits in divider value
  axxia_divclk_recalc_rate - Calculate clock divider output rage
  struct axxia_clkmux - Axxia clock mux
  @aclk: Common struct
  @reg: Offset into regmap for PLL control register
  @shift: Bit position for selection value
  @width: Number of bits in selection value
  axxia_clkmux_get_parent - Return the index of selected parent clock
  PLLs
  Clock dividers
  Clock MUXes
 Table of all supported clocks indexed by the clock identifiers from the
  device tree binding
	 Update each entry with the allocated regmap and register the clock
	  with the common clock framework
 SPDX-License-Identifier: GPL-2.0
  Clock driver for Palmas device.
  Copyright (c) 2013, NVIDIA Corporation.
  Copyright (c) 2013-2014 Texas Instruments, Inc.
  Author:	Laxman Dewangan <ldewangan@nvidia.com>
 		Peter Ujfalusi <peter.ujfalusi@ti.com>
	
	  Clock can be disabled through external pin if it is externally
	  controlled.
 SPDX-License-Identifier: GPL-2.0-only
  Clock implementation for VIAWondermedia SoC's
  Copyright (C) 2012 Tony Prisk <linux@prisktech.co.nz>
 All clocks share the same lock as none can be changed concurrently 
  Add new PLL_TYPE_x definitions here as required. Use the first known model
  to support the new type as the name.
  Add case statements to vtwm_pll_recalc_rate(), vtwm_pll_round_round() and
  vtwm_pll_set_rate() to handle the new PLL_TYPE_x
 Special case for SDMMC devices 
 div == 0 is actually the highest divisor 
 If prate  rate would be decimal, incr the divisor 
	
	  If this is a request for SDMMC we have to adjust the divisor
	  when >31 to use the fixed predivisor
 SDMMC mask may need to be corrected before testing if its valid 
		
		  Bit 5 is a fixed 64 predivisor. If the requested divisor
		  is >31 then correct for the fixed divisor being required.
		
		  use 0x1f as the default mask since it covers
		  almost all the clocks and reduces dts properties
 PLL clock related functions 
 Helper macros for PLL_VT8500 
 Helper macros for PLL_WM8650 
 Helper macros for PLL_WM8750 
 Helper macros for PLL_WM8850 
 sanity check 
 use the prediv to double the resolution 
  M  parent [O1] =>  P [O2] =>  D [O3]
  Where O1 is 900MHz...3GHz;
  O2 is 600MHz >= (M  parent)  P >= 300MHz;
  M is 36...120 [25MHz parent]; D is 1 or 2 or 4 or 8.
  Possible ranges (O3):
  D = 8: 37,5MHz...75MHz
  D = 4: 75MHz...150MHz
  D = 2: 150MHz...300MHz
  D = 1: 300MHz...600MHz
	
	  Divisor P cannot be calculated. Test all divisors and find where M
	  will be as close as possible to the requested rate.
 calculate frequency (MHz) after pre-divisor 
 Find the closest match (lower or equal to requested) 
 error will always be +ve 
 if we got here, it wasn't an exact match 
 Find the closest match (lower or equal to requested) 
 error will always be +ve 
 if we got here, it wasn't an exact match 
 sanity check 
 Wrappers for initialization functions 
 SPDX-License-Identifier: GPL-2.0-only
  System Control and Power Interface (SCPI) Protocol based clock driver
  Copyright (C) 2015 ARM Ltd.
	
	  We can't figure out what rate it will be, so just return the
	  rate back to the caller. scpi_clk_recalc_rate() will be called
	  after the rate is set and we'll know what rate the clock is
	  running at then.
 find closest match to given frequency in OPP table 
 Add the virtual cpufreq device if it's DVFS clock provider 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2011 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
  Copyright (C) 2011 Richard Zhao, Linaro <richard.zhao@linaro.org>
  Copyright (C) 2011-2012 Mike Turquette, Linaro Ltd <mturquette@linaro.org>
  Simple multiplexer clock implementation
  DOC: basic adjustable multiplexer clock that cannot gate
  Traits of this clock:
  prepare - clk_prepare only ensures that parents are prepared
  enable - clk_enable only ensures that parents are enabled
  rate - rate is only affected by parent switching.  No clk_set_rate support
  parent - parent is adjustable through clk_set_parent
 allocate the mux 
 struct clk_mux assignments 
 SPDX-License-Identifier: GPL-2.0+
  Bitmain BM1880 SoC clock driver
  Copyright (c) 2019 Linaro Ltd.
  Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
  All PLL clocks are marked as CRITICAL, hence they are very crucial
  for the functioning of the SoC
  Clocks marked as CRITICAL are needed for the proper functioning
  of the SoC.
	
	  Since this clock is sourcing the DDR memory, let's mark it as
	  critical to avoid gating.
 Don't gate GPIO clocks as it is not owned by the GPIO driver 
	
	  Not sure which module this clock is sourcing but gating this clock
	  prevents the system from booting. So, let's mark it as critical.
  Clocks marked as CRITICAL are needed for the proper functioning
  of the SoC.
  Clocks marked as CRITICAL are all needed for the proper functioning
  of the SoC.
	
	  Since clk_a53 and clk_50m_a53 clocks are sourcing the CPU core,
	  let's mark them as critical to avoid gating.
 Don't gate GPIO clocks as it is not owned by the GPIO driver 
 SPDX-License-Identifier: GPL-2.0-or-later
  clk-si5351.c: Skyworks  Silicon Labs Si5351ABC I2C Clock Generator
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
  Rabeeh Khoury <rabeeh@solid-run.com>
  References:
  [1] "Si5351ABC Data Sheet"
      https:www.skyworksinc.com-mediaSkyworksSLdocumentspublicdata-sheetsSi5351-B.pdf
  [2] "AN619: Manually Generating an Si5351 Register Map"
      https:www.skyworksinc.com-mediaSkyworksSLdocumentspublicapplication-notesAN619.pdf
  Si5351 i2c regmap
 save rdiv and divby4 
 reserved registers 
 read-only 
  Si5351 xtal clock input
  Si5351 clkin clock input (Si5351C only)
  CMOS clock source constraints:
  The input frequency range of the PLL is 10Mhz to 40MHz.
  If CLKIN is >40MHz, the input divider must be used.
  Si5351 vxco clock input (Si5351B only)
  Si5351 pll ab
  Feedback Multisynth Divider Equations [2]
  fVCO = fIN  (a + bc)
  with 15 + 01048575 <= (a + bc) <= 90 + 01048575 and
  fIN = fXTAL or fIN = fCLKINCLKIN_DIV
  Feedback Multisynth Register Equations
  (1) MSNx_P1[17:0] = 128  a + floor(128  bc) - 512
  (2) MSNx_P2[19:0] = 128  b - c  floor(128  bc) = (128b) mod c
  (3) MSNx_P3[19:0] = c
  Transposing (2) yields: (4) floor(128  bc) = (128  b  MSNx_P2)c
  Using (4) on (1) yields:
  MSNx_P1 = 128  a + (128  bMSNx_P2)c - 512
  MSNx_P1 + 512 + MSNx_P2c = 128  a + 128  bc
  a + bc = (MSNx_P1 + MSNx_P2MSNx_P3 + 512)128
          = (MSNx_P1MSNx_P3 + MSNx_P2 + 512MSNx_P3)(128MSNx_P3)
 fVCO = fIN  (P1P3 + 512P3 + P2)(128P3) 
 determine integer part of feedback equation 
 find best approximation for bc = fVCO mod fIN 
 calculate parameters 
 recalculate rate by fIN  (a + bc) 
 write multisynth parameters 
 pllapllb ctrl is in clk6clk7 ctrl registers 
 Do a pll soft reset on the affected pll 
  Si5351 multisync divider
  for fOUT <= 150 MHz:
  fOUT = (fIN  (a + bc))  CLKOUTDIV
  with 6 + 01048575 <= (a + bc) <= 1800 + 01048575 and
  fIN = fVCO0, fVCO1
  Output Clock Multisynth Register Equations
  MSx_P1[17:0] = 128  a + floor(128  bc) - 512
  MSx_P2[19:0] = 128  b - c  floor(128  bc) = (128b) mod c
  MSx_P3[19:0] = c
  MS[6,7] are integer (P1) divide only, P1 = divide value,
  P2 and P3 are not applicable
  for 150MHz < fOUT <= 160MHz:
  MSx_P1 = 0, MSx_P2 = 0, MSx_P3 = 1, MSx_INT = 1, MSx_DIVBY4 = 11b
	
	  multisync0-5: fOUT = (128  P3  fIN)  (P1P3 + P2 + 512P3)
	  multisync6-7: fOUT = fIN  P1
 multisync6-7 can only handle freqencies < 150MHz 
 multisync frequency is 1MHz .. 160MHz 
 multisync can set pll 
		
		  find largest integer divider for max
		  vco frequency and given target rate
 determine the closest integer divider 
 disable divby4 
 determine integer part of divider equation 
 find best approximation for bc = fVCO mod fOUT 
 recalculate rate by fOUT = fIN  (a + bc) 
 calculate parameters 
 write multisynth parameters 
 enabledisable integer mode and divby4 on multisynth0-5 
  Si5351 clkout divider
 clk0clk4 can only connect to its own multisync 
 pll not used, no need to reset 
	
	  Do a pll soft reset on the parent pll -- needed to get a
	  deterministic phase relationship between the output clocks.
 clkout67 can only handle output freqencies < 150MHz 
 clkout freqency is 8kHz - 160MHz 
 request frequency if multisync master 
 use r divider for frequencies below 1MHz 
 round to closed rdiv 
 round to closed rdiv 
 write output divider 
 powerup clkout 
  Si5351 i2c probe and DT
	
	  property silabs,pll-source : <num src>, [<..>]
	  allow to selectively set pll source
 per clkout properties 
 CONFIG_OF 
	
	  Check for valid parent clock: VARIANT_A and VARIANT_B need XTAL,
	    VARIANT_C can have CLKIN instead.
 Disable interrupts 
 Ensure pll select is on XTAL for Si5351AB 
 setup clock configuration 
 register xtal input clock gate 
 register clkin input clock gate 
 Si5351C allows to mux either xtal or clkin to PLL input 
 register PLLA 
 register PLLB or VXCO (Si5351B) 
 register clk multisync and clk out divider 
 set initial clkout rate 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 Oleksij Rempel <linux@rempel-privat.de>.
	 i2s has two deviders: one for only external mclk and internal
 ahb gates 
 register pll 
 TODO: Convert to DT parent scheme 
 clock mux gate cells 
 clock div cells 
 clock ahb gate cells 
 check for errors on leaf clocks 
 register clk-provider 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018 ROHM Semiconductors
 clk control registers 
 BD71815 
 BD71828 
 BD71837 and BD71847 
  BD71837, BD71847, and BD71828 all use bit [0] to clk output control
 SPDX-License-Identifier: GPL-2.0-only
  Clkout driver for Rockchip RK808
  Copyright (c) 2014, Fuzhou Rockchip Electronics Co., Ltd
  Author:Chris Zhong <zyw@rock-chips.com>
	
	  For the default case, it match the following PMIC type.
	  RK805_ID
	  RK808_ID
	  RK818_ID
 optional override of the clockname 
 optional override of the clockname 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2013 NVIDIA CORPORATION.  All rights reserved.
 .set_rate requires either .round_rate or .determine_rate 
 SPDX-License-Identifier: GPL-2.0
  Driver for Silicon Labs Si544 Programmable Oscillator
  Copyright (C) 2018 Topic Embedded Products
  Author: Mike Looijmans <mike.looijmans@topic.nl>
 I2C registers (decimal as in datasheet) 
 Register values 
 Max freq depends on speed grade 
 Si544 Internal oscilator runs at 55.05 MHz 
 VCO range is 10.8 .. 12.1 GHz, max depends on speed grade 
 Lowest frequency synthesizeable using only the HS divider 
 Range and interpretation of the adjustment value 
  struct clk_si544_muldiv - Multiplierdivider settings
  @fb_div_frac:	integer part of feedback divider (32 bits)
  @fb_div_int:		fractional part of feedback divider (11 bits)
  @hs_div:		1st divider, 5..2046, must be even when >33
  @ls_div_bits:	2nd divider, as 2^x, range 0..5
                       If ls_div_bits is non-zero, hs_div must be even
  @delta_m:		Frequency shift for small -950..+950 ppm changes, 24 bit
 Enables or disables the output driver 
 Retrieve clock multiplier and dividers from hardware 
 Interpret as 24-bit signed number 
	
	  Writing to SI544_REG_FBDIV40 triggers the clock change, so that
	  must be written last
 Calculate divider settings for a given frequency 
 Determine the minimum value of LS_DIV and resulting target freq. 
 Determine minimum HS_DIV by rounding up 
 round up to even number when required 
 Calculate VCO frequency (in 10..12GHz range) 
 Calculate the integer part of the feedback divider 
 And the fractional bits using the remainder 
 Round to nearest multiple 
 Reset the frequency adjustment 
 Calculate resulting frequency given the register settings 
 Calculate VCO from the fractional part 
 Add the integer part of the VCO frequency 
 Apply divider to obtain the generated frequency 
	
	  The clock adjustment is much smaller than 1 Hz, round to the
	  nearest multiple. Apparently div64_s64 rounds towards zero, hence
	  check the sign and adjust into the proper direction.
 The accuracy is less than 1 Hz, so any rate is possible 
 Calculates the maximum "small" change, 950  rate  1000000 
 Try using the frequency adjustment feature for a <= 950ppm change 
 Too big for the delta adjustment, need to reprogram 
 Allow FCAL for this frequency update 
 Undefined state now, best to leave disabled 
 Trigger calibration 
 Applying a new frequency can take up to 10ms 
 Select page 0, just to be sure, there appear to be no more 
 SPDX-License-Identifier: GPL-2.0+
 clk-s2mps11.c - Clock driver for S2MPS11.
 Copyright (C) 2013,2014 Samsung Electornics
 This s2mps11_clks_init tructure is common to s2mps11, s2mps13 and s2mps14 
 Store clocks of_node in first element of s2mps11_clks array 
 Skip clocks not present in some devices 
 Drop the reference obtained in s2mps11_clk_parse_dt 
 Skip clocks not present on S2MPS14 
  Device is instantiated through parent MFD device and device matching is done
  through platform_device_id.
  However if device's DT node contains proper clock compatible and driver is
  built as a module, then the module matching will be done trough DT aliases.
  This requires of_device_id table.  In the same time this will not change the
  actual device matching so do not add .of_match_table.
 Sentinel 
  Synopsys HSDK SDP Generic PLL clock driver
  Copyright (C) 2017 Synopsys
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 ARC PLL control register 
 ARC PLL status register 
 ARC PLL frequency measurement register 
 ARC PLL monitor register 
 100 us 
 Powerdown and Bypass bits should be cleared 
 Check if PLL is bypassed 
 Check if PLL is disabled 
 input divider = reg.idiv + 1 
 fb divider = 2(reg.fbdiv + 1) 
 output divider = 2^(reg.odiv) 
	
	  Wait until CGU relocks and check error status.
	  If after timeout CGU is unlocked yet return error.
	
	  When core clock exceeds 500MHz, the divider for the interface
	  clock must be programmed to div-by-2.
	
	  Wait until CGU relocks and check error status.
	  If after timeout CGU is unlocked yet return error.
	
	  Program divider to div-by-1 if we succesfuly set core clock below
	  500MHz threshold.
 Core PLL needed early for ARC cpus timers 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-or-later
  WM831x clock control
  Copyright 2011-2 Wolfson Microelectronics PLC.
  Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
 wait 2-3 ms for new frequency taking effect 
 AUTO mode is always clocked from the crystal 
 XTAL_ENA can only be set via OTPInstantConfig so just read once 
 Module information 
 SPDX-License-Identifier: GPL-2.0-or-later
 Copyright IBM Corp
 Copyright ASPEED Technology
 Globally visible clocks 
 Keeps track of all clocks 
 AST2600 revision: A0, A1, A2, etc 
  Clocks marked with CLK_IS_CRITICAL:
   ref0 and ref1 are essential for the SoC to operate
   mpll is required if SDRAM is used
				    clk rst  name		parent	 flags 
 SDRAM 
 Video Engine 
 2D engine 
 vclk parent - dclkd1clkhclkmclk 
 Video Capture 
 PCIePCI 
 From dpll 
 DAC 
 USB2.0 Host port 2 
 Reserved 8 
 USB1.1 (requires port 2 enabled) 
 From dpllepll40mhz usb p1 phygpioc6dp phy pll 
 GFX CRT 
 Reserved 1112 
 HAC 
 USB2 hubUSB2 host port 1USB1.1 dev 
 UART5 
 Reserved 1619 
 MAC1 
 MAC2 
 Reserved 2223 
 HAC 
 RVAS 
 Reserved 26 
 For card clk 
 Reserved 282930 
 LPC 
 eSPI 
 Reserved 35 
 SDIOSD 
 LPC masterLPC+ 
 Reserved 38 RSA: no longer used 
 Reserved 39 
 I3C0 
 I3C1 
 I3C2 
 I3C3 
 I3C4 
 I3C5 
 I3C6 
 I3C7 
 UART1 
 UART2 
 UART3 
 UART4 
 MAC3 
 MAC4 
 UART6 
 UART7 
 UART8 
 UART9 
 UART10 
 UART11 
 UART12 
 UART13 
 FSI 
 For hplldpllepllmpll 
 Pass through mode 
 F = 25Mhz  [(M + 2)  (n + 1)]  (p + 1) 
 Pass through mode 
 F = 25Mhz  [(m + 1)  (n + 1)]  (p + 1) 
 Pass through mode 
 F = 25Mhz  (2-od)  [(m + 2)  (n + 1)] 
	
	  If the IP is in reset, treat the clock as not enabled,
	  this happens with some clocks such as the USB one when
	  coming from cold reset. Without this, aspeed_clk_enable()
	  will fail to lift the reset.
 Put IP in reset 
 Delay 100us 
 Enable clock 
 Clock is clear to enable, so use set to clear register 
 Clock is set to enable, so use write to set register 
 A delay of 10ms is specified by the ASPEED docs 
 Take IP out of reset 
 Use set to clear register 
 Use set to clear register 
 UART clock div13 setting 
 UART6~13 clock div13 setting 
 EMMC ext clock 
 SDSDIO clock divider and gate 
 MAC12 RMII 50MHz RCLK 
 MAC12 AHB bus clock divider 
 RMII1 50MHz (RCLK) output enable 
 RMII2 50MHz (RCLK) output enable 
 MAC12 RMII 50MHz RCLK 
 MAC34 AHB bus clock divider 
 RMII3 50MHz (RCLK) output enable 
 RMII4 50MHz (RCLK) output enable 
 LPC Host (LHCLK) clock divider 
 gfx d1clk : use dp clk 
 SoC Display clock selection 
 d1 clk div 0x308[17:15] x [14:12] - 8,7,6,5,4,3,2,1 
 3x3 = 9 
 P-Bus (BCLK) clock divider 
 Video Capture clock selection 
 Video Engine clock divider 
		
		  Special case: the USB port 1 clock (bit 14) is always
		  working the opposite way from the other ones.
	
	  High-speed PLL clock derived from the crystal. This the CPU clock,
	  and we assume that it is enabled
 Strap bits 12:11 define the AXIAHB clock frequency ratio (aka HCLK)
 USB 2.0 port1 phy 40MHz clock 
	
	  This way all clocks fetched before the platform device probes,
	  except those we assign here for early use, will be deferred.
	
	  We check that the regmap works on this very first access,
	  but as this is an MMIO-backed regmap, subsequent regmap
	  access is not going to fail and we skip error checks from
	  this point.
 SPDX-License-Identifier: GPL-2.0
  Driver for Silicon Labs Si5340, Si5341, Si5342, Si5344 and Si5345
  Copyright (C) 2019 Topic Embedded Products
  Author: Mike Looijmans <mike.looijmans@topic.nl>
  The Si5341 has 10 outputs and 5 synthesizers.
  The Si5340 is a smaller version of the Si5341 with only 4 outputs.
  The Si5345 is similar to the Si5341, with the addition of fractional input
  dividers and automatic input selection.
  The Si5342 and Si5344 are smaller versions of the Si5345.
 Range of the synthesizer fractional divider 
 The chip can get its input clock from 3 input pins or an XTAL 
 There is one PLL running at 13500–14256 MHz 
 The 5 frequency synthesizers obtain their input from the PLL 
 The output stages can be connected to any synth (full mux) 
 13500–14256 MHz 
 Status bits 
 Input selection 
 XTAL config bits 
 Input dividers (48-bit) 
 PLL configuration 
 Output configuration 
 Synthesize N divider 
 Synthesizer output enable, phase bypass, power mode 
 SI5341_OUT_CONFIG bits 
 Static configuration (to be moved to firmware) 
 Output configuration registers 0..9 are not quite logically organized 
 Also for si5345 
 for si5340, si5342 and si5344 
 The location of the R divider registers 
  Programming sequence from ClockBuilder, settings to initialize the system
  using only the XTAL input, without pre-divider.
  This also contains settings that aren't mentioned anywhere in the datasheet.
  The "known" settings like synth and output configuration are done later.
 INT mask (disable interrupts) 
 INT mask 
 Select XTAL as input 
 Not in datasheet 
 SPI config 
 LOS enable for XTAL 
 LOS timing 
 LOS setting (thresholds) 
 LOS setting (thresholds) end 
 LOS0_DIV_SEL 
 LOS1_DIV_SEL 
 LOS2_DIV_SEL 
 LOS3_DIV_SEL 
 Not in datasheet 
 Enable outputs 
 Not in datasheet 
 Not in datasheet 
 OUT LOS 
 XAXB_FREQ_OFFSET (=0)
 PXAXB (2^x) 
 Px divider setting (usually 0) 
 Px divider setting (usually 0) end 
 DESIGN_ID (ASCII string) 
 DESIGN_ID (ASCII string) end 
 N_FSTEP_MSK 
 Nx_FSTEPW (Frequency step) 
 Nx_FSTEPW (Frequency step) end 
 Nx_DELAY 
 Nx_DELAY end 
 Not in datasheet 
 Not in datasheet 
 Not in datasheet 
 XAXB_EXTCLK_EN=0 XAXB_PDNB=1 (use XTAL) 
 ZDM_EN=4 (Normal mode) 
 IN_EN (disable input clocks) 
 INx_TO_PFD_EN (disabled) 
 Not in datasheet 
 PDIV_ENB (datasheet does not mention what it is) 
 VCO_RESET_CALCODE (not described in datasheet) 
 VCO_RESET_CALCODE (not described in datasheet) 
 Read and interpret a 44-bit followed by a 32-bit value in the regmap 
 Shift left as far as possible without overflowing 
 44 bits (6 bytes) numerator 
 32 bits denominator 
 Program the fraction 
 VCO, we assume it runs at a constant frequency 
 Assume that PDIV is not being used, just read the PLL setting 
	
	  Though m_num is 64-bit, only the upper bits are actually used. While
	  calculating m_num and m_den, they are shifted as far as possible to
	  the left. To avoid 96-bit division here, we just shift them back so
	  we can do with just 64 bits.
 We cannot return the actual frequency in 32 bit, store it locally 
 Report kHz since the value is out of range 
 Apparently we cannot report errors 
 Enable register-based input selection 
 Enable input buffer for selected input 
 Enables the input to phase detector 
 Power down XTAL oscillator and buffer 
		
		  Set the P divider to "1". There's no explanation in the
		  datasheet of these registers, but the clockbuilder software
		  programs a "1" when the input is being used.
 Set update PDIV bit 
 Disable all input buffers 
 Disable input to phase detector 
 Power up XTAL oscillator and buffer, select clock mode 
 Synthesizers, there are 5 synthesizers that connect to any of the outputs 
 The synthesizer is on if all power and enable bits are set 
 This bit must be 0 for the synthesizer to receive clock input 
 In range 0..5 
 Disable output 
 Power down 
 Disable clock input to synth (set to 1 to disable) 
 Power up 
 Enable clock input to synth (set bit to 0 to enable) 
 Enable output 
 Synth clock frequency: Fvco  n_den  n_den, with Fvco in 13500-14256 MHz 
 Check for bogusuninitialized settings 
	
	  n_num and n_den are shifted left as much as possible, so to prevent
	  overflow in 64-bit math, we shift n_den 4 bits to the right
 Now we need to to 64-bit division: fn_num 
 And compensate for the 4 bits we dropped 
 The synthesizer accuracy is such that anything in range will work 
 see if there's an integer solution 
 Integer divider equal to n_num 
 Calculate a fractional solution 
 Bit 0=PDN, 1=OE so only a value of 0x2 enables the output 
 Disables and then powers down the output 
 Powers up and then enables the output 
 Calculate value as 24-bit integer
 If Rx_REG is zero, the divider is disabled, so return a "0" rate 
 Divider is 2(Rx_REG+1) 
 If rate is an even divisor, no changes to parent required 
 minimum r-divider is 2 
 Take a parent frequency near 400 MHz 
 We cannot change our parent's rate, report what we can do 
 Frequency divider is (r_div + 1)  2 
 For a value of "2", we set the "OUT0_RDIV_FORCE2" bit 
 Always write Rx_REG, because a zero value disables the divider 
  The chip can be bought in a pre-programmed version, or one can program the
  NVM in the chip to boot up in a preset mode. This routine tries to determine
  if that's the case, or if we need to reset and program everything from
  scratch. Returns negative error, or truefalse.
 Read the PLL divider value, it must have a non-zero value 
 Read active settings into the regmap cache for later reference 
 For revision 2 and up, the values are slightly different 
 Write "preamble" as specified by datasheet 
 The si5342..si5345 require a different preamble 
 Datasheet specifies a 300ms wait after sending the preamble 
 Perform a soft reset and write post-amble 
 The si5342..si5345 have an additional post-amble 
 Datasheet does not explain these nameless registers 
 Status 
 reset, fincfdec 
 NVM, interrupts, device ready 
 Update bits for P divider and synth config 
 Pages 0, 1, 2, 3, 9, A, B are valid, so there are 12 pages 
	 Datasheet warns: Any attempt to read or write any register other
	  than DEVICE_READY before DEVICE_READY reads as 0x0F may corrupt the
	  NVM programming and may corrupt the register contents, as they are
	  read from NVM. Note that this includes accesses to the PAGE register.
	  Also: DEVICE_READY is available on every register page, so no page
	  change is needed to read it.
	  Do this outside regmap to avoid automatic PAGE register access.
	  May take up to 300ms to complete.
 Set cm and ampl conservatively to 3v3 settings 
 normal differential 
 low-power differential 
 LVCMOS 
 Set SI recommended impedance for LVCMOS 
 Always enable the SYNC feature 
 chip seems to default to 2.5V when not set 
  If not pre-configured, calculate and set the PLL configuration manually.
  For low-jitter performance, the PLL should be set such that the synthesizers
  only need integer division.
  Without any user guidance, we'll set the PLL to 14GHz, which still allows
  the chip to generate any frequency on its outputs, but jitter performance
  may be sub-optimal.
 If the current register setting is invalid, pick the first input 
 Make sure the selected clock is also enabled and routed 
 Must be done before otherwise touching hardware 
 Populate the regmap cache in preparation for "cache only" 
		
		  We intend to send all 'final' register values in a single
		  transaction. So cache all register writes until we're done
		  configuring.
 Write the configuration pairs from the firmware blob 
 Input must be up and running at this point 
 PLL configuration is required 
 Register the PLL 
 clock framework made a copy of the name 
 Synchronize 
 wait for device to report input clock present and PLL lock 
 clear sticky alarm bits from initialization 
 Free the names, clk framework makes copies 
 SPDX-License-Identifier: GPL-2.0
  System Control and Power Interface (SCMI) Protocol based clock driver
  Copyright (C) 2018-2021 ARM Ltd.
	
	  We can't figure out what rate it will be, so just return the
	  rate back to the caller. scmi_clk_recalc_rate() will be called
	  after the rate is set and we'll know what rate the clock is
	  running at then.
 to round up 
	
	  We can't provide enabledisable callback as we can't perform the same
	  in atomic context. Since the clock framework provides standard API
	  clk_prepare_enable that helps cases using clk_enable in non-atomic
	  context, it should be fine providing prepareunprepare.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2011 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
  DOC: basic fixed multiplier and divider clock that cannot gate
  Traits of this clock:
  prepare - clk_prepare only ensures that parents are prepared
  enable - clk_enable only ensures that parents are enabled
  rate - rate is fixed.  clk->rate = parent->rate  div  mult
  parent - fixed parent.  No clk_set_parent support
	
	  We must report success but we can do so unconditionally because
	  clk_factor_round_rate returns values that ensure this call is a
	  nop.
	
	  We can not use clk_hw_unregister_fixed_factor, since it will kfree()
	  the hw, resulting in double free. Just unregister the hw and let
	  devres code kfree() it.
 You can't use devm without a dev 
 struct clk_fixed_factor assignments 
 Sentinel  },
		
		  Clear OF_POPULATED flag so that clock registration can be
		  attempted again from probe function.
  of_fixed_factor_clk_setup() - Setup function for simple fixed factor clock
  @node:	device node for the clock
	
	  This function is not executed when of_fixed_factor_clk_setup
	  succeeded.
 SPDX-License-Identifier: GPL-2.0-only
  Layerscape FlexSPI clock driver
  Copyright 2020 Michael Walle <michael@walle.cc>
	
	  Can't use devm_ioremap_resource() or devm_of_iomap() because the
	  resource might already be taken by the parent device.
 SPDX-License-Identifier: GPL-2.0-or-later
  Microchip Sparx5 SoC Clock driver.
  Copyright (c) 2019 Microchip Inc.
  Author: Lars Povlsen <lars.povlsen@microchip.com>
 Fractional rate 
 Best match 
 Straight match? 
 Try without rounding divider 
 Select the better match 
 Straight fit 
 SPDX-License-Identifier: GPL-2.0-only
  TI CDCE706 programmable 3-PLL clock synthesizer driver
  Copyright (c) 2014 Cadence Design Systems Inc.
  Reference: https:www.ti.comlitdssymlinkcdce706.pdf
  MOXA ART SoCs clock driver.
  Copyright (C) 2013 Jonas Jensen
  Jonas Jensen <jonas.jensen@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2.  This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  Driver for TI Multi PLL CDCE913925937949 clock synthesizer
  This driver always connects the Y1 to the input clock, Y2Y3 to PLL1,
  Y4Y5 to PLL2, and so on. PLL frequency is set on a first-come-first-serve
  basis. Clients can directly request any frequency that the chip can
  deliver using the standard clk framework. In addition, the device can
  be configured and activated via the devicetree.
  Copyright (C) 2014, Topic Embedded Products
  Licenced under GPL
 Each chip has different number of PLLs and outputs, for example:
  The CECE925 has 2 PLLs which can be routed through dividers to 5 outputs.
  Model this as 2 PLL clocks which are parents to the outputs.
 PLL parameters start at 0x10, steps of 0x10 
 Add CDCE925_OFFSET_PLL  (pll) to these registers before sending 
 1..127 for Y2-Y9; 1..1023 for Y1 
 1..511 
 1..4095 
 In bypass mode runs at same frequency 
 Output frequency of PLL is Fout = (FinPdiv)(NM) 
 Can always deliver parent_rate in bypass mode 
 In PLL mode, need to apply minmax range 
 When outside hw range, reduce to fit (rounding errors) 
 Bypass mode 
 calculate p = max(0, 4 - int(log2 (nm))) 
 Returns VCO range bits for VCO1_0_RANGE 
 I2C clock, hence everything must happen in (un)prepare because this
 Bits are spread out over 4 byte registers 
 Set PLL mux to bypass mode, leave the rest as is 
 According to data sheet: 
 p = max(0, 4 - int(log2 (nm))) 
 nn = n  2^p 
 q = int(nnm) 
 encode into register bits 
 Write to registers 
 Enable PLL 
 Disable clock by setting divider to "0" 
 Don't need the PLL, use bypass 
 No can do? 
		 TODO: Consider PLL frequency based on smaller nm values
 Y1 has 10-bit divider 
 First byte is command code 
 The CDCE925 uses a funky way to readwrite registers. Bulk mode is
 PWDN bit 
 Set input source for Y1 to be the XTAL 
 Register PLL clocks 
 Register output clock Y1 
 Mux Y1 to input 
 clock framework made a copy of the name 
 Register output clocks Y2 .. Y5
 Mux Y23 to PLL1 
 Mux Y45 to PLL2 
 Mux Y67 to PLL3 
 Mux Y89 to PLL4 
 clock framework made a copy of the name 
 Register the output clocks 
 clock framework made a copy of the name 
 SPDX-License-Identifier: GPL-2.0-only
  Clock driver for Hi655x
  Copyright (c) 2017, Linaro Ltd.
  Author: Daniel Lezcano <daniel.lezcano@linaro.org>
 SPDX-License-Identifier: GPL-2.0
  Cortina Gemini SoC Clock Controller driver
  Copyright (c) 2017 Linus Walleij <linus.walleij@linaro.org>
 Globally visible clocks 
  struct gemini_data_data - Gemini gated clocks
  @bit_idx: the bit used to gate this clock in the clock register
  @name: the clock name
  @parent_name: the name of the parent clock
  @flags: standard clock framework flags
  struct clk_gemini_pci - Gemini PCI clock
  @hw: corresponding clock hardware entry
  @map: regmap to access the registers
  @rate: current rate
  struct gemini_reset - gemini reset controller
  @map: regmap to access the containing system controller
  @rcdev: reset controller device
 Keeps track of all clocks 
	
	  The DDR controller may never have a driver, but certainly must
	  not be gated off.
	
	  The flash controller must be on to access NOR flash through the
	  memory map.
 We support 33 and 66 MHz 
  This is a self-deasserting reset controller.
 Manual says to always set BIT 30 (CPU1) to 1 
 Gives the fracions 1x, 1.5x, 1.85x and 2x 
 Remap the system controller for the exclusive register 
 RTC clock 32768 Hz 
 CPU clock derived as a fixed ratio from the AHB clock 
 Security clock is 1:1 or 0.75 of APB 
	
	  These are the leaf gates, at boot no clocks are gated.
	
	  The TV Interface Controller has a 5-bit half divider register.
	  This clock is supposed to be 27MHz as this is an exact multiple
	  of PAL and NTSC frequencies. The register is undocumented :(
	  FIXME: figure out the parent and how the divider works.
 FIXME: very unclear what the parent is 
 FIXME: very unclear what the parent is 
 sentinel  },
	
	  This way all clock fetched before the platform device probes,
	  except those we assign here for early use, will be deferred.
	
	  We check that the regmap works on this very first access,
	  but as this is an MMIO-backed regmap, subsequent regmap
	  access is not going to fail and we skip error checks from
	  this point.
	
	  XTAL is the crystal oscillator, 60 or 30 MHz selected from
	  strap pin E6
 VCO clock derived from the crystal 
 If we run on 30 MHz crystal we have to multiply with two 
 The AHB clock is always 13 of the VCO 
 The APB clock is always 16 of the AHB 
 Register the clocks to be accessed by the device tree 
 SPDX-License-Identifier: GPL-2.0
  Lochnagar clock control
  Copyright (c) 2017-2018 Cirrus Logic, Inc. and
                          Cirrus Logic International Semiconductor Ltd.
  Author: Charles Keepax <ckeepax@opensource.cirrus.com>
 SPDX-License-Identifier: GPL-2.0-or-later
  clk-xgene.c - AppliedMicro X-Gene Clock Interface
  Copyright (c) 2013, Applied Micro Circuits Corporation
  Author: Loc Ho <lho@apm.com>
 Register SCU_PCPPLL bit fields 
 Register SCU_SOCPLL bit fields 
 PLL Clock 
			
			 PLL VCO = Reference clock  NF
			 PCP PLL = PLL_VCO  2
			
			 Fref = Reference Clock  NREF;
			 Fvco = Fref  NFB;
			 Fout = Fvco  NOUT;
		
		  fvco = Reference clock  FBDIVC
		  PLL freq = fvco  NOUT
 allocate the APM clock structure 
 Register the clock 
  struct xgene_clk_pmd - PMD clock
  @hw:		handle between common and hardware-specific interfaces
  @reg:	register containing the fractional scale multiplier (scaler)
  @shift:	shift to the unit bit field
  @mask:	mask to the unit bit field
  @denom:	1denominator unit
  @lock:	register lock
  @flags: XGENE_CLK_PMD_SCALE_INVERTED - By default the scaler is the value read
 	from the register plus one. For example,
 		0 for (0 + 1)  denom,
 		1 for (1 + 1)  denom and etc.
 	If this flag is set, it is
 		0 for (denom - 0)  denom,
 		1 for (denom - 1)  denom and etc.
 freq = parent_rate  scaler  denom 
 freq = parent_rate  scaler  denom 
	
	  Compute the scaler:
	 
	  freq = parent_rate  scaler  denom, or
	  scaler = freq  denom  parent_rate
 Check if inverted 
 Check if the entry is disabled 
 Parse the DTS register for resource 
 IP Clock 
 CSR for IP clock 
 Offset to clock enable CSR 
 Mask bit for clock enable 
 Offset to CSR reset 
 Mask bit for disable CSR reset 
 CSR for divider 
 Offset to divider register 
 Bit shift to divider field 
 Width of the bit to divider field 
 First enable the clock 
 Second enable the CSR 
 First put the CSR in reset 
 Second disable the clock 
 Let's compute the divider 
 Rounded down 
 Set new divider 
 Let's compute the divider 
 Rounded down 
 allocate the APM clock structure 
 Register the clock 
 Register the clock for lookup 
 Check if the entry is disabled 
 Parse the DTS register for resource 
 if (strcmp(res->name, "csr-reg") == 0) 
 SPDX-License-Identifier: GPL-2.0
  CS2000  --  CIRRUS LOGIC Fractional-N Clock Synthesizer & Clock Multiplier
  Copyright (C) 2015 Renesas Electronics Corporation
  Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
 DEVICE_ID 
 DEVICE_CTRL 
 DEVICE_CFG1 
 DEVICE_CFG2 
 GLOBAL_CFG 
 FUNC_CFG1 
 FUNC_CFG2 
 suspendresume 
 FIXME: for Static ratio mode 
 enable both AUX_OUT, CLK_OUT 
	
	  ratio = rate_out  rate_in  2^20
	 
	  To avoid over flow, rate_out is u64.
	  The result should be u32.
	
	  ratio = rate_out  rate_in  2^20
	 
	  To avoid over flow, rate_out is u64.
	  The result should be u32 or unsigned long.
	
	  FIXME
	 
	  this driver supports static ratio mode only at this point.
 it uses ch0 only at this point 
 it uses ch0 only at this point 
 it uses ch0 only at this point 
 always return REF_CLK 
 not yet provided 
 not yet provided 
 it uses ch0 only at this point 
	
	  set default rate as 11.
	  otherwise .set_rate which setup ratio
	  is never called if user requests 11 rate
 CS2000 should be 0x0 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for IDT Versaclock 5
  Copyright (C) 2017 Marek Vasut <marek.vasut@gmail.com>
  Possible optimizations:
  - Use spread spectrum
  - Use integer divider in FOD if applicable
 VersaClock5 registers 
 Factory-reserved register block 
 Configuration register block 
 These registers are named "Unused Factory Reserved Registers" 
 bypass_sync<idx> bit 
 Output divider control for divider 1,2,3,4 
 Clock control register for clock 1,2 
 PLLVCO runs between 2.5 GHz and 3.0 GHz 
 VC5 Input mux settings 
 Maximum number of clk_out supported by this driver 
 Maximum number of FODs supported by this driver 
 flags to describe chip features 
 chip has built-in oscilator 
 chip has PFD requency doubler 
 chip has bits to disable FOD sync 
 Supported IDT VC5 models. 
 Structure to describe features of a particular VC5 model 
  VersaClock5 i2c regmap
 Factory reserved regs, make them read-only 
 Factory reserved regs, make them read-only 
  VersaClock5 input multiplexer between XTAL and CLKIN divider
 Invalid; should have been caught by vc5_probe() 
 The bypass_prediv is set, PLL fed from Ref_in directly. 
 The Sel_prediv2 is set, PLL fed from prediv2 (Ref_in  2) 
 PLL cannot operate with input clock above 50 MHz. 
 CLKIN within range of PLL input, feed directly to PLL. 
 CLKIN within range of PLL input, feed directly to PLL. 
 We have dedicated div-2 predivider. 
  VersaClock5 PLLVCO
 The PLL divider has 12 integer bits and 24 fractional bits 
 Determine integer part, which is 12 bit wide 
 Determine best fractional part, which is 24 bit wide 
 VCO frequency is divided by two before entering FOD 
 Avoid division by zero if the output is not configured. 
 The PLL divider has 12 integer bits and 30 fractional bits 
 VCO frequency is divided by two before entering FOD 
 Determine integer part, which is 12 bit wide 
	
	  WARNING: The clock chip does not output signal if the integer part
	           of the divider is 0xfff and fractional part is non-zero.
	           Clamp the divider at 0xffe to keep the code simple.
 Determine best fractional part, which is 30 bit wide 
	
	  Toggle magic bit in undocumented register for unknown reason.
	  This is what the IDT timing commander tool does and the chip
	  datasheet somewhat implies this is needed, but the register
	  and the bit is not documented.
	
	  When enabling a FOD, all currently enabled FODs are briefly
	  stopped in order to synchronize all of them. This causes a clock
	  disruption to any unrelated chips that might be already using
	  other clock outputs. Bypass the sync feature to avoid the issue,
	  which is possible on the VersaClock 6E family via reserved
	  registers.
	
	  If the input mux is disabled, enable it first and
	  select source from matching FOD.
 Enable the clock buffer 
 Disable the clock buffer 
 Input mux set to DISABLED 
	
	  The datasheet explicitly states 9000 - 25000 with 0.5pF
	  steps, but the Programmer's guide shows the steps are 0.430pF.
	  After getting feedback from Renesas, the .5pF steps were the
	  goal, but 430nF was the actual values.
	  Because of this, the actual range goes to 22760 instead of 25000
	
	  The Programmer's guide shows XTAL[5:0] but in reality,
	  XTAL[0] and XTAL[1] are both LSB which makes the math
	  strange.  With clarfication from Renesas, setting the
	  values should be simpler by ignoring XTAL[0]
	
	  Since the calculation ignores XTAL[0], there is one
	  special case where mapped_value = 32.  In reality, this means
	  the real mapped value should be 111111b.  In other cases,
	  the mapped_value needs to be shifted 1 to the left.
		
		  The mapped_value is really the high 6 bits of
		  VC5_XTAL_X1_LOAD_CAP and VC5_XTAL_X2_LOAD_CAP, so
		  shift the value 2 places.
 Register clock input mux 
 Configure Optional Loading Capacitance for external XTAL 
 clock framework made a copy of the name 
 Register frequency doubler 
 clock framework made a copy of the name 
 Register PFD 
 clock framework made a copy of the name 
 Register PLL 
 clock framework made a copy of the name 
 Register FODs 
 clock framework made a copy of the name 
 Register MUX-connected OUT0_I2C_SELB output 
 clock framework made a copy of the name 
 Register FOD-connected OUTx outputs 
 clock framework made a copy of the name 
 Fetch Clock Output configuration from DT (if specified) 
 clock framework made a copy of the name 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2011-2012 Calxeda, Inc.
 Need to re-lock PLL, so put it into bypass mode 
 Map system registers 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2010-2011 Canonical Ltd <jeremy.kerr@canonical.com>
  Copyright (C) 2011-2012 Mike Turquette, Linaro Ltd <mturquette@linaro.org>
  Gated clock implementation
  DOC: basic gatable clock which can gate and ungate it's ouput
  Traits of this clock:
  prepare - clk_(un)prepare only ensures parent is (un)prepared
  enable - clk_enable and clk_disable are functional & control gating
  rate - inherits rate from parent.  No clk_set_rate support
  parent - fixed parent.  No clk_set_parent support
  It works on following logic:
  For enabling clock, enable = 1
 	set2dis = 1	-> clear bit	-> set = 0
 	set2dis = 0	-> set bit	-> set = 1
  For disabling clock, enable = 0
 	set2dis = 1	-> set bit	-> set = 1
 	set2dis = 0	-> clear bit	-> set = 0
  So, result is always: enable xor set2dis.
 if a set bit disables this clk, flip it before masking 
 allocate the gate 
 struct clk_gate assignments 
 SPDX-License-Identifier: GPL-2.0-only
  driversclkclkdev.c
   Copyright (C) 2008 Russell King.
  Helper for the clk API to assist looking up a struct clk.
  Find the correct struct clk for the device and connection ID.
  We do slightly fuzzy matching here:
   An entry with a NULL ID is assumed to be a wildcard.
   If an entry has a device ID, it must match
   If an entry has a connection ID, it must match
  Then we take the most specific entry - with the following
  order of precedence: dev+con > dev only > con only.
  clkdev_create - allocate and add a clkdev lookup structure
  @clk: struct clk to associate with all clk_lookups
  @con_id: connection ID string on device
  @dev_fmt: format string describing device name
  Returns a clk_lookup structure, which can be later unregistered and
  freed.
  clkdev_hw_create - allocate and add a clkdev lookup structure
  @hw: struct clk_hw to associate with all clk_lookups
  @con_id: connection ID string on device
  @dev_fmt: format string describing device name
  Returns a clk_lookup structure, which can be later unregistered and
  freed.
  clkdev_drop - remove a clock dynamically allocated
	
	  Since dev_id can be NULL, and NULL is handled specially, we must
	  pass it as either a NULL format string, or with "%s".
  clk_register_clkdev - register one clock lookup for a struct clk
  @clk: struct clk to associate with all clk_lookups
  @con_id: connection ID string on device
  @dev_id: string describing device name
  con_id or dev_id may be NULL as a wildcard, just as in the rest of
  clkdev.
  To make things easier for mass registration, we detect error clks
  from a previous clk_register() call, and return the error code for
  those.  This is to permit this function to be called immediately
  after clk_register().
  clk_hw_register_clkdev - register one clock lookup for a struct clk_hw
  @hw: struct clk_hw to associate with all clk_lookups
  @con_id: connection ID string on device
  @dev_id: format string describing device name
  con_id or dev_id may be NULL as a wildcard, just as in the rest of
  clkdev.
  To make things easier for mass registration, we detect error clk_hws
  from a previous clk_hw_register_() call, and return the error code for
  those.  This is to permit this function to be called immediately
  after clk_hw_register_().
  devm_clk_release_clkdev - Resource managed clkdev lookup release
  @dev: device this lookup is bound
  @con_id: connection ID string on device
  @dev_id: format string describing device name
  Drop the clkdev lookup created with devm_clk_hw_register_clkdev.
  Normally this function will not need to be called and the resource
  management code will ensure that the resource is freed.
  devm_clk_hw_register_clkdev - managed clk lookup registration for clk_hw
  @dev: device this lookup is bound
  @hw: struct clk_hw to associate with all clk_lookups
  @con_id: connection ID string on device
  @dev_id: format string describing device name
  con_id or dev_id may be NULL as a wildcard, just as in the rest of
  clkdev.
  To make things easier for mass registration, we detect error clk_hws
  from a previous clk_hw_register_() call, and return the error code for
  those.  This is to permit this function to be called immediately
  after clk_hw_register_().
 SPDX-License-Identifier: GPL-2.0
  Freescale SAI BCLK as a generic clock driver
  Copyright 2020 Michael Walle <michael@walle.cc>
 set clock direction, we are the BCLK master 
 SPDX-License-Identifier: GPL-2.0-only
  AXI clkgen driver
  Copyright 2012-2013 Analog Devices Inc.
   Author: Lars-Peter Clausen <lars@metafoo.de>
 Lets see if we find a better setting in fractional mode 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2014 Intel Corporation
  Adjustable fractional divider clock implementation.
  Uses rational best approximation algorithm.
  Output is calculated as
 	rate = (m  n)  parent_rate				(1)
  This is useful when we have a prescaler block which asks for
  m (numerator) and n (denominator) values to be provided to satisfy
  the (1) as much as possible.
  Since m and n have the limitation by a range, e.g.
 	n >= 1, n < N_width, where N_width = 2^nwidth		(2)
  for some cases the output may be saturated. Hence, from (1) and (2),
  assuming the worst case when m = 1, the inequality
 	floor(log2(parent_rate  rate)) <= nwidth		(3)
  may be derived. Thus, in cases when
 	(parent_rate  rate) >> N_width				(4)
  we might scale up the rate by 2^scale (see the description of
  CLK_FRAC_DIVIDER_POWER_OF_TWO_PS for additional information), where
 	scale = floor(log2(parent_rate  rate)) - nwidth	(5)
  and assume that the IP, that needs m and n, has also its own
  prescaler, which is capable to divide by 2^scale. In this way
  we get the denominator to satisfy the desired range (2) and
  at the same time much much better result of m and n than simple
  saturated values.
	
	  Get rate closer to parent_rate to guarantee there is no overflow
	  for m and n. In the result it will be the nearest rate left shifted
	  by (scale - fd->nwidth) bits.
	 
	  For the detailed explanation see the top comment in this file.
 SPDX-License-Identifier: GPL-2.0
  Memory Mapped IO Fixed clock driver
  Copyright (C) 2018 Cadence Design Systems, Inc.
  Authors:
 	Jan Kotas <jank@cadence.com>
  This is not executed when of_fixed_mmio_clk_setup succeeded.
 SPDX-License-Identifier: GPL-2.0-only
  Author: Daniel Thompson <daniel.thompson@linaro.org>
  Inspired by clk-asm9260.c .
  Include list of clocks wich are not derived from system clock (SYSCLOCK)
  The index of these clocks is the secondary index of DT bindings
  This bitmask tells us which bit offsets (0..192) on STM32F4[23]xxx
  have gate bits associated with them. Its combined hweight is 71.
  "Multiplier" device for APBx clocks.
  The APBx dividers are power-of-two dividers and, if not running in 1:1
  mode, they also tap out the one of the low order state bits to run the
  timers. ST datasheets represent this feature as a (conditional) clock
  multiplier.
	
	  We must report success but we can do so unconditionally because
	  clk_apb_mul_round_rate returns values that ensure this call is a
	  nop.
 allocate the divider 
 struct clk_divider assignments 
 register the clock 
  Converts the primary and secondary indices (as they appear in DT) to an
  offset into our struct clock array.
 only bits set in table can be used as indices 
 mask out bits above our current index 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2017 NXP
  Dong Aisheng <aisheng.dong@nxp.com>
  clk_bulk_unprepare - undo preparation of a set of clock sources
  @num_clks: the number of clk_bulk_data
  @clks: the clk_bulk_data table being unprepared
  clk_bulk_unprepare may sleep, which differentiates it from clk_bulk_disable.
  Returns 0 on success, -EERROR otherwise.
  clk_bulk_prepare - prepare a set of clocks
  @num_clks: the number of clk_bulk_data
  @clks: the clk_bulk_data table being prepared
  clk_bulk_prepare may sleep, which differentiates it from clk_bulk_enable.
  Returns 0 on success, -EERROR otherwise.
 CONFIG_HAVE_CLK_PREPARE 
  clk_bulk_disable - gate a set of clocks
  @num_clks: the number of clk_bulk_data
  @clks: the clk_bulk_data table being gated
  clk_bulk_disable must not sleep, which differentiates it from
  clk_bulk_unprepare. clk_bulk_disable must be called before
  clk_bulk_unprepare.
  clk_bulk_enable - ungate a set of clocks
  @num_clks: the number of clk_bulk_data
  @clks: the clk_bulk_data table being ungated
  clk_bulk_enable must not sleep
  Returns 0 on success, -EERROR otherwise.
 SPDX-License-Identifier: GPL-2.0-only
  ARTPEC-6 clock initialization
  Copyright 2015-2016 Axis Comunications AB.
 Mandatory parent clock. 
 Read PLL1 factors configured by boot strap pins. 
 DDR3-2133 mode 
 DDR3-1866 mode 
 DDR3-1600 mode 
 DDR3-1333 mode 
 EPROBE_DEFER on the apb_clock is not handled in amba devices. 
 Mandatory parent clock. 
 Find clock names of optional parent clocks. 
 Lock the mux for internal clock reference. 
 Lock the mux for external clock reference. 
 SPDX-License-Identifier: GPL-2.0
  Marvell Armada CP110 System Controller
  Copyright (C) 2016 Marvell
  Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  CP110 has 6 core clocks:
   - PLL0		(1 Ghz)
     - PPv2 core	(13 PLL0)
     - x2 Core		(12 PLL0)
 	- Core		(12 x2 Core)
     - SDIO		(25 PLL0)
   - NAND clock, which is either:
     - Equal to SDIO clock
     - 25 PLL0
  CP110 has 32 gateable clocks, for the various peripherals in the IP.
 A number of gateable clocks need special handling 
 Register the PLL0 which is the root of the hw tree 
 PPv2 is PLL03 
 X2CORE clock is PLL02 
 Core clock is X2CORE2 
 NAND can be either PLL02.5 or core clock 
 SDIO clock is PLL02.5 
 create the unique name for all the gate clocks 
 SPDX-License-Identifier: GPL-2.0
  Marvell Armada 370 SoC clocks
  Copyright (C) 2012 Marvell
  Gregory CLEMENT <gregory.clement@free-electrons.com>
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
  Andrew Lunn <andrew@lunn.ch>
  Core Clocks
 Low part [0:31] 
  Clock Gating Control
 SPDX-License-Identifier: GPL-2.0
  Marvell Armada 39x SoC clocks
  Copyright (C) 2015 Marvell
  Gregory CLEMENT <gregory.clement@free-electrons.com>
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
  Andrew Lunn <andrew@lunn.ch>
  Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  SARL[14:10] : Ratios between CPU, NBCLK, HCLK and DCLK.
  SARL[15]    : TCLK frequency
 		 0 = 250 MHz
 		 1 = 200 MHz
  SARH[0]     : Reference clock frequency
                0 = 25 Mhz
                1 = 40 Mhz
  Clock Gating Control
 SPDX-License-Identifier: GPL-2.0
  Marvell Dove SoC clocks
  Copyright (C) 2012 Marvell
  Gregory CLEMENT <gregory.clement@free-electrons.com>
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
  Andrew Lunn <andrew@lunn.ch>
  Core Clocks
  Dove PLL sample-at-reset configuration
  SAR0[8:5]   : CPU frequency
 		 5  = 1000 MHz
 		 6  =  933 MHz
 		 7  =  933 MHz
 		 8  =  800 MHz
 		 9  =  800 MHz
 		 10 =  800 MHz
 		 11 = 1067 MHz
 		 12 =  667 MHz
 		 13 =  533 MHz
 		 14 =  400 MHz
 		 15 =  333 MHz
 		 others reserved.
  SAR0[11:9]  : CPU to L2 Clock divider ratio
 		 0 = (11)  CPU
 		 2 = (12)  CPU
 		 4 = (13)  CPU
 		 6 = (14)  CPU
 		 others reserved.
  SAR0[15:12] : CPU to DDR DRAM Clock divider ratio
 		 0  = (11)  CPU
 		 2  = (12)  CPU
 		 3  = (25)  CPU
 		 4  = (13)  CPU
 		 6  = (14)  CPU
 		 8  = (15)  CPU
 		 10 = (16)  CPU
 		 12 = (17)  CPU
 		 14 = (18)  CPU
 		 15 = (110)  CPU
 		 others reserved.
  SAR0[24:23] : TCLK frequency
 		 0 = 166 MHz
 		 1 = 125 MHz
 		 others reserved.
  Clock Gating Control
 SPDX-License-Identifier: GPL-2.0+
  Marvell Armada AP CPU Clock Controller
  Copyright (C) 2018 Marvell
  Omri Itach <omrii@marvell.com>
  Gregory Clement <gregory.clement@bootlin.com>
  struct cpu_dfs_regs: CPU DFS register mapping
  @divider_reg: full integer ratio from PLL frequency to CPU clock frequency
  @force_reg: request to force new ratio regardless of relation to other clocks
  @ratio_reg: central request to switch ratios
 AP806 CPU DFS register mapping
 AP807 CPU DFS register mapping 
  struct ap806_clk: CPU cluster clock controller instance
  @cluster: Cluster clock controller index
  @clk_name: Cluster clock controller name
  @dev : Cluster clock device
  @hw: HW specific structure of Cluster clock controller
  @pll_cr_base: CA72MP2 Register base (Device Sample at Reset register)
	
	  AP807 CPU divider has two channels with ratio 1:3 and divider_ratio
	  is 1. Otherwise, in the case of the AP806, divider_ratio is 0.
	
	  AP806 has 4 cpus and DFS for AP806 is controlled per
	  cluster (2 CPUs per cluster), cpu0 and cpu1 are fixed to
	  cluster0 while cpu2 and cpu3 are fixed to cluster1 whether
	  they are enabled or not.  Since cpu0 is the boot cpu, then
	  cluster0 must exist.  If cpu2 or cpu3 is enabled, cluster1
	  will exist and the cluster number is 2; otherwise the
	  cluster number is 1.
 If cpu2 or cpu3 is enabled 
	
	  DFS for AP806 is controlled per cluster (2 CPUs per cluster),
	  so allocate structs per cluster
 Initialize once for one cluster 
 SPDX-License-Identifier: GPL-2.0
  Marvell Armada AP806 System Controller
  Copyright (C) 2016 Marvell
  Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
 Convert to hertz 
 CPU clocks depend on the Sample At Reset configuration 
 Fixed clock is always 1200 Mhz 
 MSS Clock is fixed clock divided by 6 
 SDIO(eMMC) Clock is fixed clock divided by 3 
 AP-DCLK(HCLK) Clock is DDR clock divided by 2 
 SPDX-License-Identifier: GPL-2.0
  Marvell Kirkwood SoC clocks
  Copyright (C) 2012 Marvell
  Gregory CLEMENT <gregory.clement@free-electrons.com>
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
  Andrew Lunn <andrew@lunn.ch>
  Core Clocks
  Kirkwood PLL sample-at-reset configuration
  (6180 has different SAR layout than other Kirkwood SoCs)
  SAR0[4:3,22,1] : CPU frequency (6281,6292,6282)
 	4  =  600 MHz
 	6  =  800 MHz
 	7  = 1000 MHz
 	9  = 1200 MHz
 	12 = 1500 MHz
 	13 = 1600 MHz
 	14 = 1800 MHz
 	15 = 2000 MHz
 	others reserved.
  SAR0[19,10:9] : CPU to L2 Clock divider ratio (6281,6292,6282)
 	1 = (12)  CPU
 	3 = (13)  CPU
 	5 = (14)  CPU
 	others reserved.
  SAR0[8:5] : CPU to DDR DRAM Clock divider ratio (6281,6292,6282)
 	2 = (12)  CPU
 	4 = (13)  CPU
 	6 = (14)  CPU
 	7 = (29)  CPU
 	8 = (15)  CPU
 	9 = (16)  CPU
 	others reserved.
  SAR0[4:2] : Kirkwood 6180 cpul2ddr clock configuration (6180 only)
 	5 = [CPU =  600 MHz, L2 = (12)  CPU, DDR = 200 MHz = (13)  CPU]
 	6 = [CPU =  800 MHz, L2 = (12)  CPU, DDR = 200 MHz = (14)  CPU]
 	7 = [CPU = 1000 MHz, L2 = (12)  CPU, DDR = 200 MHz = (15)  CPU]
 	others reserved.
  SAR0[21] : TCLK frequency
 	0 = 200 MHz
 	1 = 166 MHz
 	others reserved.
 mv88f6180 has a fixed 1:2 CPU-to-L2 ratio 
  Clock Gating Control
  Clock Muxing Control
 lock must already be initialized 
 Count, allocate, and register clock muxes 
 SPDX-License-Identifier: GPL-2.0
  Marvell Armada 375 SoC clocks
  Copyright (C) 2014 Marvell
  Gregory CLEMENT <gregory.clement@free-electrons.com>
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
  Andrew Lunn <andrew@lunn.ch>
  Core Clocks
  For the Armada 375 SoCs, the CPU, DDR and L2 clocks frequencies are
  all modified at the same time, and not separately as for the Armada
  370 or the Armada XP SoCs.
  SAR1[21:17]   : CPU frequency    DDR frequency   L2 frequency
 		 6   =  400 MHz	    400 MHz	    200 MHz
 		 15  =  600 MHz	    600 MHz	    300 MHz
 		 21  =  800 MHz	    534 MHz	    400 MHz
 		 25  = 1000 MHz	    500 MHz	    500 MHz
 		 others reserved.
  SAR1[22]   : TCLK frequency
 		 0 = 166 MHz
 		 1 = 200 MHz
  Clock Gating Control
 SPDX-License-Identifier: GPL-2.0
  Marvell Armada 37xx SoC xtal clocks
  Copyright (C) 2016 Marvell
  Gregory CLEMENT <gregory.clement@free-electrons.com>
 SPDX-License-Identifier: GPL-2.0+
  Marvell Armada 37xx SoC Time Base Generator clocks
  Copyright (C) 2016 Marvell
  Gregory CLEMENT <gregory.clement@free-electrons.com>
 SPDX-License-Identifier: GPL-2.0
  Marvell MVEBU CPU clock handling.
  Copyright (C) 2012 Marvell
  Gregory CLEMENT <gregory.clement@free-electrons.com>
 Valid ratio are 1:1, 1:2 and 1:3 
 Set clock divider reload smooth bit mask 
 Now trigger the clock update 
 Wait for clocks to settle down then clear reload request 
	
	  PMU DFS registers are not mapped, Device Tree does not
	  describes them. We cannot change the frequency dynamically.
 Frequency is going up 
 Frequency is going down 
 SPDX-License-Identifier: GPL-2.0
  Marvell Orion SoC clocks
  Copyright (C) 2014 Thomas Petazzoni
  Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  Orion 5181
  Orion 5182
  Orion 5281
 On 5281, tclk is always 166 Mhz 
  Orion 6183
 SPDX-License-Identifier: GPL-2.0+
  Marvell Armada AP and CP110 helper
  Copyright (C) 2018 Marvell
  Gregory Clement <gregory.clement@bootlin.com>
 Do not create a name if there is no clock 
 SPDX-License-Identifier: GPL-2.0
  Marvell Armada 380385 SoC clocks
  Copyright (C) 2014 Marvell
  Gregory CLEMENT <gregory.clement@free-electrons.com>
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
  Andrew Lunn <andrew@lunn.ch>
  SAR[14:10] : Ratios between PCLK0, NBCLK, HCLK and DRAM clocks
  SAR[15]    : TCLK frequency
 		 0 = 250 MHz
 		 1 = 200 MHz
  Clock Gating Control
 SPDX-License-Identifier: GPL-2.0
  Marvell Dove PMU Core PLL divider driver
  Cleaned up by substantially rewriting, and converted to DT by
  Russell King.  Origin is not known.
	
	  Create the core PLL clock.  We treat this as a fixed rate
	  clock as we don't know any better, and documentation is sparse.
 SPDX-License-Identifier: GPL-2.0
  Marvell MV98DX3236 SoC clocks
  Copyright (C) 2012 Marvell
  Gregory CLEMENT <gregory.clement@free-electrons.com>
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
  Andrew Lunn <andrew@lunn.ch>
  For 98DX4251 Sample At Reset the CPU, DDR and Main PLL clocks are all
  defined at the same time
  SAR1[20:18]   : CPU frequency    DDR frequency   MPLL frequency
 		 0  =  400 MHz	    400 MHz	    800 MHz
 		 2  =  667 MHz	    667 MHz	    2000 MHz
 		 3  =  800 MHz	    800 MHz	    1600 MHz
 		 others reserved.
  For 98DX3236 Sample At Reset the CPU, DDR and Main PLL clocks are all
  defined at the same time
  SAR1[20:18]   : CPU frequency    DDR frequency   MPLL frequency
 		 1  =  667 MHz	    667 MHz	    2000 MHz
 		 2  =  400 MHz	    400 MHz	    400 MHz
 		 3  =  800 MHz	    800 MHz	    800 MHz
 		 5  =  800 MHz	    400 MHz	    800 MHz
 		 others reserved.
 Tclk = 200MHz, no SaR dependency 
  Clock Gating Control
 SPDX-License-Identifier: GPL-2.0+
  Marvell Armada 37xx SoC Peripheral clocks
  Copyright (C) 2016 Marvell
  Gregory CLEMENT <gregory.clement@free-electrons.com>
  Most of the peripheral clocks can be modelled like this:
              _____    _______    _______
  TBG-A-P  --|     |  |       |  |       |   ______
  TBG-B-P  --| Mux |--| div1 |--| div2 |--| Gate |--> perip_clk
  TBG-A-S  --|     |  |       |  |       |  |______|
  TBG-B-S  --|_____|  |_______|  |_______|
  However some clocks may use only one or two block or and use the
  xtal clock as parent.
 Storage registers for suspendresume operations 
 last entry 
 last entry 
 last entry 
 NB periph clocks 
 SB periph clocks 
	
	  This function is always called after the function
	  armada_3700_pm_dvfs_is_enabled, so no need to check again
	  if the base is valid.
	
	  The register and the offset inside this register accessed to
	  read the current divider depend on the load level
	
	  This function is always called after the function
	  armada_3700_pm_dvfs_is_enabled, so no need to check again
	  if the base is valid
	
	  The register and the offset inside this register accessed to
	  read the current divider depend on the load level
 only available when DVFS is enabled 
			
			  We found a load level matching the target
			  divider, switch to this load level and
			  return.
 We didn't find any valid divider 
  Workaround when base CPU frequnecy is 1000 or 1200 MHz
  Switching the CPU from the L2 or L3 frequencies (250300 or 200 MHz
  respectively) to L0 frequency (11.2 GHz) requires a significant
  amount of time to let VDD stabilize to the appropriate
  voltage. This amount of time is large enough that it cannot be
  covered by the hardware countdown register. Due to this, the CPU
  might start operating at L0 before the voltage is stabilized,
  leading to CPU stalls.
  To work around this problem, we prevent switching directly from the
  L2L3 frequencies to the L0 frequency, and instead switch to the L1
  frequency in-between. The sequence therefore becomes:
  1. First switch from L2L3 (200250300 MHz) to L1 (500600 MHz)
  2. Sleep 20ms for stabling VDD voltage
  3. Then switch from L1 (500600 MHz) to L0 (10001200 MHz).
	
	  System wants to go to L1 on its own. If we are going from L2L3,
	  remember when 20ms will expire. If from L0, set the value so that
	  next switch to L0 won't have to wait.
	
	  If we are setting to L2L3, just invalidate L1 expiration time,
	  sleeping is not needed.
	
	  We are going to L0 with rate >= 1GHz. Check whether we have been at
	  L1 for long enough time. If not, go to L1 for 20ms.
 only available when DVFS is enabled 
			
			  We found a load level matching the target
			  divider, switch to this load level and
			  return.
 Apply workaround when base CPU frequency is 1000 or 1200 MHz 
 We didn't find any valid divider 
 Follow the same order than what the Cortex-M3 does (ATF code) 
 SPDX-License-Identifier: GPL-2.0
  MVEBU Core divider clock
  Copyright (C) 2013 Marvell
  Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
  This structure describes the hardware details (bit offset and mask)
  to configure one particular core divider clock. Those hardware
  details may differ from one SoC to another. This structure is
  therefore typically instantiated statically to describe the
  hardware details.
  This structure describes the hardware details to configure the core
  divider clocks on a given SoC. Amongst others, it points to the
  array of core divider clock descriptors for this SoC, as well as
  the corresponding operations to manipulate them.
  This structure represents one core divider clock for the clock
  framework, and is dynamically allocated for each core divider clock
  existing in the current SoC.
  Description of the core divider clocks available. For now, we
  support only NAND, and it is available at the same register
  locations regardless of the SoC.
 NAND clock 
 NAND clock 
 Valid ratio are 1:4, 1:5, 1:6 and 1:8 
 Write new divider to the divider ratio register 
 Set reload-force for this clock 
 Now trigger the clock update 
	
	  Wait for clocks to settle down, and then clear all the
	  ratios request and the reload request.
 clks holds the clock array 
 corediv holds the clock specific array 
 SPDX-License-Identifier: GPL-2.0
  Marvell Armada XP SoC clocks
  Copyright (C) 2012 Marvell
  Gregory CLEMENT <gregory.clement@free-electrons.com>
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
  Andrew Lunn <andrew@lunn.ch>
  Core Clocks
  Armada XP Sample At Reset is a 64 bit bitfiled split in two
  register of 32 bits
 Low part [0:31] 
 High part [32:63] 
 Armada XP TCLK frequency is fixed to 250MHz 
	
	  The upper bit is not contiguous to the other ones and
	  located in the high part of the SAR registers
	
	  The upper bit is not contiguous to the other ones and
	  located in the high part of the SAR registers
  Clock Gating Control
 SPDX-License-Identifier: GPL-2.0
  Marvell EBU SoC common clock handling
  Copyright (C) 2012 Marvell
  Gregory CLEMENT <gregory.clement@free-electrons.com>
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
  Andrew Lunn <andrew@lunn.ch>
  Core Clocks
  This function can be used by the Kirkwood, the Armada 370, the
  Armada XP and the Armada 375 SoC. The name of the function was
  chosen following the dt convention: using the first known SoC
  compatible with it.
	
	  From Marvell engineer we got the following formula (when
	  this code was written, the datasheet was erroneous)
	  Spread percentage = 196  (H - L)  H
	  H = SSCG_High_Boundary
	  L = SSCG_Low_Boundary
	 
	  As the deviation is half of spread then it lead to the
	  following formula in the code.
	 
	  To avoid an overflow and not lose any significant digit in
	  the same time we have to use a 64 bit integer.
 Allocate struct for TCLK, cpu clk, and core ratio clocks 
 One more clock for the optional refclk 
 Register TCLK 
 Register CPU clock 
 Register fixed-factor clocks derived from CPU clock 
 Register optional refclk 
 SAR register isn't needed anymore 
  Clock Gating Control
 lock must already be initialized 
 Count, allocate, and register clock gates 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016-2017 Imagination Technologies
  Author: Paul Burton <paul.burton@mips.com>
  Use CLK_OF_DECLARE so that this driver is probed early enough to provide the
  CPU frequency for use with the GIC or cop0 counterstimers.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014, The Linux Foundation. All rights reserved.
 Setup PLL18 static bits 
 Set GMAC footswitch sleepwakeup values 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2016, Linaro Limited
  Copyright (c) 2014, The Linux Foundation. All rights reserved.
	
	  The vendor tree simply reads the status for this
	  RPM clock.
 to kHz 
 to kHz 
	
	  Active-only clocks don't care what the rate is during sleep. So,
	  they vote for zero.
 Don't send requests to the RPM if the rate has not been set. 
 Take peer clock's rate into account only if it's enabled. 
 Undo the active set vote and restore it 
 Take peer clock's rate into account only if it's enabled. 
 Take peer clock's rate into account only if it's enabled. 
	
	  RPM handles rate rounding and we don't have a way to
	  know what the rate will be, so just return whatever
	  rate is requested.
	
	  RPM handles rate rounding and we don't have a way to
	  know what the rate will be, so just return whatever
	  rate was set.
 MSM8660APQ8060 
 apq8064 
 ipq806x 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2014, The Linux Foundation. All rights reserved.
  clk_is_enabled_regmap - standard is_enabled() for regmap users
  @hw: clk to operate on
  Clocks that use regmap for their register IO can set the
  enable_reg and enable_mask fields in their struct clk_regmap and then use
  this as their is_enabled operation, saving some code.
  clk_enable_regmap - standard enable() for regmap users
  @hw: clk to operate on
  Clocks that use regmap for their register IO can set the
  enable_reg and enable_mask fields in their struct clk_regmap and then use
  this as their enable() operation, saving some code.
  clk_disable_regmap - standard disable() for regmap users
  @hw: clk to operate on
  Clocks that use regmap for their register IO can set the
  enable_reg and enable_mask fields in their struct clk_regmap and then use
  this as their disable() operation, saving some code.
  devm_clk_register_regmap - register a clk_regmap clock
  @dev: reference to the caller's device
  @rclk: clk to operate on
  Clocks that use regmap for their register IO should register their
  clk_regmap struct via this function so that the regmap is initialized
  and so that the clock is registered with the common clock framework.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2019, Jeffrey Hugo
 Instead of going directly to the block, XO is routed through this branch 
 force periph logic on to avoid perf counter corruption 
 tweak droop detector (GPUCC_GPU_DD_WRAP_CTRL) to reduce leakage 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018, The Linux Foundation. All rights reserved.
 Secondary and primary muxes share the same cp15 register 
 Wait for switch to complete. 
 Don't touch mux if CPU is off as it won't work 
 The divider can divide by 2, 4, 6 and 8. But we only really need div-2. 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
 listed as BRAMMO, but it doesn't really match 
 1152MHz configuration 
 600MHz configuration 
 800MHz configuration 
 1152MHz configuration 
 | CLK_ENABLE_HAND_OFF ,
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2017, Linaro Limited
  Author: Georgi Djakov <georgi.djakov@linaro.org>
 Wait for update to take effect 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2021, The Linux Foundation. All rights reserved.
 400MHz Configuration 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018, The Linux Foundation. All rights reserved.
 CLK_OFF would not toggle until LPASS is out of reset 
 CLK_OFF would not toggle until LPASS is out of reset 
 CLK_OFF would not toggle until LPASS is out of reset 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  Copyright (c) 2020-2021, Linaro Limited
 external clocks so add BRANCH_HALT_SKIP 
 external clocks so add BRANCH_HALT_SKIP 
 external clocks so add BRANCH_HALT_SKIP 
 external clocks so add BRANCH_HALT_SKIP 
 external clocks so add BRANCH_HALT_SKIP 
 external clocks so add BRANCH_HALT_SKIP 
 external clocks so add BRANCH_HALT_SKIP 
 external clocks so add BRANCH_HALT_SKIP 
 Clock ON depends on external parent clock, so don't poll 
 Clock ON depends on external parent clock, so don't poll 
 external clocks so add BRANCH_HALT_SKIP 
 external clocks so add BRANCH_HALT_SKIP 
 external clocks so add BRANCH_HALT_SKIP 
 external clocks so add BRANCH_HALT_SKIP 
 Clock ON depends on external parent clock, so don't poll 
 Clock ON depends on external parent clock, so don't poll 
 Clock ON depends on external parent clock, so don't poll 
 Clock ON depends on external parent clock, so don't poll 
 Clock ON depends on external parent clock, so don't poll 
 Clock ON depends on external parent clock, so don't poll 
 Clock ON depends on external parent clock, so don't poll 
 Clock ON depends on external parent clock, so don't poll 
 external clocks so add BRANCH_HALT_SKIP 
 external clocks so add BRANCH_HALT_SKIP 
	
	  Keep the critical clock always-On
	  GCC_CAMERA_AHB_CLK, GCC_CAMERA_XO_CLK, GCC_DISP_AHB_CLK, GCC_DISP_XO_CLK,
	  GCC_GPU_CFG_AHB_CLK, GCC_VIDEO_AHB_CLK, GCC_VIDEO_XO_CLK
 FORCE_MEM_CORE_ON for ufs phy ice core clocks 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2016, The Linux Foundation. All rights reserved.
			
			  The GPU IOMMU depends on this clock and hypervisor
			  will crash the SoC if this clock goes down, due to
			  secure contexts protection.
			
			  Any access to mmss depends on this clock.
			  Gating this clock has been shown to crash the system
			  when mmssnoc_axi_rpm_clk is inited in rpmcc.
	
	  Set the HMSS_AHB_CLK_SLEEP_ENA bit to allow the hmss_ahb_clk to be
	  turned off by hardware during certain apps low power modes.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2019, Linaro Ltd.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018, The Linux Foundation. All rights reserved.
 Disable SW_COLLAPSE for USB0 GDSCR 
 Enable SW_OVERRIDE for USB0 GDSCR 
 Disable SW_COLLAPSE for USB1 GDSCR 
 Enable SW_OVERRIDE for USB1 GDSCR 
 SW Workaround for UBI Huyara PLL 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015, 2017-2018, The Linux Foundation. All rights reserved.
 CFG_GDSCR 
 Wait 2^n CXO cycles between all states. Here, n=2 (4 cycles). 
 Returns 1 if GDSC status is status, 0 if not, and < 0 on error 
 If disabling votable gdscs, don't poll on status 
		
		  Add a short delay here to ensure that an enable
		  right after it was disabled does not put it in an
		  unknown state
		
		  The gds hw controller assertsde-asserts the status bit soon
		  after it receives a power onoff request from a master.
		  The controller then takes around 8 xo cycles to start its
		  internal state machine and update the status bit. During
		  this time, the status bit does not reflect the true status
		  of the core.
		  Add a delay of 1 us between writing to the SW_COLLAPSE bit
		  and polling the status bit.
	
	  If clocks to this power domain were already on, they will take an
	  additional 4 clock cycles to re-enable after the power domain is
	  enabled. Delay to account for this. A delay is also needed to ensure
	  clocks are not enabled within 400ns of enabling power to the
	  memories.
 Turn on HW trigger mode if supported 
		
		  Wait for the GDSC to go through a power down and
		  up cycle.  In case a firmware ends up polling status
		  bits for the gdsc, it might read an 'on' status before
		  the GDSC can finish the power cycle.
		  We wait 1us before returning to ensure the firmware
		  can't immediately poll the status bits.
 Turn off HW trigger mode if supported 
		
		  Wait for the GDSC to go through a power down and
		  up cycle.  In case we end up polling status
		  bits for the gdsc before the power cycle is completed
		  it might read an 'on' status wrongly.
	
	  Disable HW trigger: collapserestore occur based on registers writes.
	  Disable SW override: Use hardware state-machine for sequencing.
	  Configure wait time between states.
 Force gdsc ON if only ON state is supported 
 The regulator must be on, sync the kernel state 
		
		  Votable GDSCs can be ON due to Vote from other masters.
		  If a Votable GDSC is ON, make sure we have a Vote.
 Turn on HW trigger mode if supported 
		
		  Make sure the retain bit is set if the GDSC is already on,
		  otherwise we end up turning off the GDSC and destroying all
		  the register contents that we thought we were saving.
 If ALWAYS_ON GDSCs are not ON, turn them ON 
 Add subdomains 
 Remove subdomains 
  On SDM845+ the GPU GX domain is almost entirely controlled by the GMU
  running in the CX domain so the CPU doesn't need to know anything about the
  GX domain EXCEPT....
  Hardware constraints dictate that the GX be powered down before the CX. If
  the GMU crashes it could leave the GX on. In order to successfully bring back
  the device the CPU needs to disable the GX headswitch. There being no sane
  way to reach in and touch that register from deep inside the GPU driver we
  need to set up the infrastructure to be able to ensure that the GPU can
  ensure that the GX is off during this super special case. We do this by
  defining a GX gdsc with a dummy enable function and a "default" disable
  function.
  This allows us to attach with genpd_dev_pm_attach_by_name() in the GPU
  driver. During power up, nothing will happen from the CPU (and the GMU will
  power up normally but during power down this will ensure that the GX domain
  is really off - this gives us a semi standard way of doing what we need.
 Do nothing but give genpd the impression that we were successful 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
 Keep VIDEO_CC_AHB_CLK and VIDEO_CC_XO_CLK ALWAYS-ON 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2013, The Linux Foundation. All rights reserved.
	
	  Skip checking halt bit if we're explicitly ignoring the bit or the
	  clock is in hardware gated mode
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2020, The Linux Foundation. All rights reserved.
 600MHz configuration 
 860MHz configuration 
 1920MHz configuration 
 1080MHz configuration 
 SPDX-License-Identifier: GPL-2.0
  Qualcomm SDX55 APCS clock controller driver
  Copyright (c) 2020, Linaro Limited
  Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
  We use the notifier function for switching to a temporary safe configuration
  (mux and divider), while the A7 PLL is reconfigured.
 set the mux and divider to safe frequency (400mhz) 
	
	  Attach the power domain to cpudev. Since there is no dedicated driver
	  for CPUs and the SDX55 platform lacks hardware specific CPUFreq
	  driver, there seems to be no better place to do this. So do it here!
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014, The Linux Foundation. All rights reserved.
 Configure the rate of PLL4 if the bootloader hasn't already 
 Enable PLL4 source on the LPASS Primary PLL Mux 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014, The Linux Foundation. All rights reserved.
 Use the correct frequency plan depending on speed of PLL4 
 Enable PLL4 source on the LPASS Primary PLL Mux 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
  Copyright (c) 2020-2021, Linaro Ltd.
 For CPUSS functionality the AHB clock needs to be left enabled 
 For CPUSS functionality the SYS NOC clock needs to be left enabled 
	
	  Enable the following always-on clocks:
	  GCC_VIDEO_AHB_CLK, GCC_CAMERA_AHB_CLK, GCC_DISP_AHB_CLK,
	  GCC_VIDEO_XO_CLK, GCC_CAMERA_XO_CLK, GCC_DISP_XO_CLK,
	  GCC_CPUSS_GNOC_CLK, GCC_CPUSS_DVM_BUS_CLK, GCC_NPU_CFG_AHB_CLK and
	  GCC_GPU_CFG_AHB_CLK
 Disable the GPLL0 active input to NPU and GPU via MISC registers 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2020, The Linux Foundation. All rights reserved.
  Each of the CPU clusters (Power and Perf) on msm8996 are
  clocked via 2 PLLs, a primary and alternate. There are also
  2 Mux'es, a primary and secondary all connected together
  as shown below
                               +-------+
                XO             |       |
            +------------------>0      |
                               |       |
                     PLL2     | SMUX  +----+
                       +------->1      |    |
                       |       |       |    |
                       |       +-------+    |    +-------+
                       |                    +---->0      |
                       |                         |       |
  +---------------+    |             +----------->1      | CPU clk
  |Primary PLL    +----+ PLL_EARLY   |           |       +------>
  |               +------+-----------+    +------>2 PMUX |
  +---------------+      |                |      |       |
                         |   +------+     |   +-->3      |
                         +--^+  ACD +-----+   |  +-------+
  +---------------+          +------+         |
  |Alt PLL        |                           |
  |               +---------------------------+
  +---------------+         PLL_EARLY
  The primary PLL is what drives the CPU clk, except for times
  when we are reprogramming the PLL itself (for rate changes) when
  we temporarily switch to an alternate PLL.
  The primary PLL operates on a single VCO range, between 600MHz
  and 3GHz. However the CPUs do support OPPs with frequencies
  between 300MHz and 600MHz. In order to support running the CPUs
  at those frequencies we end up having to lock the PLL at twice
  the rate and drive the CPU clk via the PLL2 output and SMUX.
  So for frequencies above 600MHz we follow the following path
   Primary PLL --> PLL_EARLY --> PMUX(1) --> CPU clk
  and for frequencies between 300MHz and 600MHz we follow
   Primary PLL --> PLL2 --> SMUX(1) --> PMUX(0) --> CPU clk
  ACD stands for Adaptive Clock Distribution and is used to
  detect voltage droops.
 PLLs 
 CPU clock is critical and should never be gated 
 CPU clock is critical and should never be gated 
 Enable alt PLLs 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015 The Linux Foundation. All rights reserved.
  struct clk_fepll_vco - vco feedback divider corresponds for FEPLL clocks
  @fdbkdiv_shift: lowest bit for FDBKDIV
  @fdbkdiv_width: number of bits in FDBKDIV
  @refclkdiv_shift: lowest bit for REFCLKDIV
  @refclkdiv_width: number of bits in REFCLKDIV
  @reg: PLL_DIV register address
  struct clk_fepll - clk divider corresponds to FEPLL clocks
  @fixed_div: fixed divider value if divider is fixed
  @parent_map: map from software's parent index to hardware's src_sel field
  @cdiv: divider values for PLL_DIV
  @pll_vco: vco feedback divider
  @div_table: mapping for actual divider value to register divider value
              in case of non fixed divider
  @freq_tbl: frequency table
  Contains index for safe clock during APSS freq change.
  fepll500 is being used as safe clock so initialize it
  with its index in parents list gcc_xo_ddr_500_200.
 Calculates the VCO rate for FEPLL. 
  Round rate function for APSS CPU PLL Clock divider.
  It looks up the frequency table and returns the next higher frequency
  supported in hardware.
  Clock set rate function for APSS CPU PLL Clock divider.
  It looks up the frequency table and updates the PLL divider to corresponding
  divider value.
	
	  There is no status bit which can be checked for successful CPU
	  divider update operation so using delay for the same.
  Clock frequency calculation function for APSS CPU PLL Clock divider.
  This clock divider is nonlinear so this function calculates the actual
  divider and returns the output frequency by dividing VCO Frequency
  with this actual divider value.
	
	  Some dividers have value in 0.5 fraction so multiply both VCO
	  frequency(parent_rate) and pre_div with 2 to make integer
	  calculation.
 Calculates the rate for PLL divider.
  If the divider value is not fixed then it gets the actual divider value
  from divider table. Then, it calculate the clock rate by dividing the
  parent rate with actual divider value.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2020 Linaro Limited
 GPLL3 at 1100 MHz, main output enabled. 
 GPLL4 at 1200 MHz, main output enabled. 
 This is not in the documentation but is in the downstream driver 
 This is not in the documentation but is in the downstream driver 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
	
	  Keep the clocks always-ON
	  GCC_CAMERA_AHB_CLKXO_CLK, GCC_DISP_AHB_CLKXO_CLK
	  GCC_VIDEO_AHB_CLKXO_CLK, GCC_GPU_CFG_AHB_CLK
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018, The Linux Foundation. All rights reserved.
	
	  Configure gpu_cc_cx_gmu_clk with recommended
	  wakeupsleep settings
 Configure clk_dis_wait for gpu_cx_gdsc 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018, The Linux Foundation. All rights reserved.
  Notifier function for switching the muxes to safe parent
  while the hfpll is getting reprogrammed.
 Switch to safe parent 
	
	  By the time POST_RATE_CHANGE notifier is called,
	  clk framework itself would have changed the parent for the new rate.
	  Only otherwise, put back to the old parent.
 id < 0 for L2, otherwise id == physical CPU number 
 Rate is 1 because 0 causes problems for __clk_mux_determine_rate 
 Krait configurations have at most 4 CPUs and one L2 
	
	  We don't want the CPU or L2 clocks to be turned off at late init
	  if CPUFREQ or HOTPLUG configs are disabled. So, bump up the
	  refcount of these clocks. Any cpufreqhotplug manager can assume
	  that the clocks have already been prepared and enabled by the time
	  they take over.
	
	  Force reinit of HFPLLs and muxes to overwrite any potential
	  incorrect configuration of HFPLLs and muxes by the bootloader.
	  While at it, also make sure the cores are running at known rates
	  and print the current rate.
	 
	  The clocks are set to aux clock rate first to make sure the
	  secondary mux is not sourcing off of QSB. The rate is then set to
	  two different rates to force a HFPLL reinit under all
	  circumstances.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2021, The Linux Foundation. All rights reserved.
 1520MHz Configuration
	
	  Keep the clocks always-ON
	  DISP_CC_XO_CLK
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2021, The Linux Foundation. All rights reserved.
 500MHz Configuration 
	
	  Keep the clocks always-ON
	  GPU_CC_CB_CLK, GPUCC_CX_GMU_CLK
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2020, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0
  LPASS Audio CC and Always ON CC Glitch Free Mux clock driver
  Copyright (c) 2020 Linaro Ltd.
  Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018, The Linux Foundation. All rights reserved.
		
		  rather than marking the clock critical and forcing the clock
		  to be always enabled, we make sure that the clock is not
		  disabled: the firmware remains responsible of enabling this
		  clock (for more info check the commit log)
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2020, The Linux Foundation. All rights reserved.
  Copyright (c) 2020, AngeloGioacchino Del Regno
                      <angelogioacchino.delregno@somainline.org>
 800MHz configuration for GPU PLL0 
 740MHz configuration for GPU PLL1 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2021, The Linux Foundation. All rights reserved.
  Copyright (c) 2021, Konrad Dybcio <konrad.dybcio@somainline.org>
 Disable the GPLL0 active input to NPU and GPU via MISC registers 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013, The Linux Foundation. All rights reserved.
 Skip if already enabled or in FSM mode 
 Disable PLL bypass mode. 
	
	  HW requires a 5us delay between disabling the bypass and
	  de-asserting the reset. Delay 10us just to be safe.
 De-assert active-low PLL reset. 
 Wait until PLL is locked. 
 Enable PLL output. 
 Skip if in FSM mode 
 Wait for pll to enable. 
 Disable PLL bypass mode. 
	
	  HW requires a 5us delay between disabling the bypass and
	  de-asserting the reset. Delay 10us just to be safe.
 De-assert active-low PLL reset. 
 Enable PLL output. 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2015, 2018, The Linux Foundation. All rights reserved.
  Even though 40 bits are present, use only 32 for ease of calculation.
 TRION PLL specific settings and offsets 
 LUCID PLL specific settings and offsets 
 LUCID 5LPE PLL specific settings and offsets 
 ZONDA PLL specific 
 Make sure enable request goes through before waiting for update 
 Disable hwfsm 
 If in FSM mode, just vote for it 
 Skip if already enabled 
	
	  HW requires a 5us delay between disabling the bypass and
	  de-asserting the reset.
 Ensure that the write above goes through before returning. 
 If in FSM mode, just unvote it 
 Delay of 2 output clock ticks required until output is disabled 
 Upper ALPHA_BITWIDTH bits of Alpha 
 Latch the input to the PLL 
 Wait for 2 reference cycle before checking ACK bit 
	
	  PLL will latch the new L, Alpha and freq control word.
	  PLL will respond by raising PLL_ACK_LATCH output when new programming
	  has been latched in and PLL is being updated. When
	  UPDATE_LOGIC_BYPASS bit is not set, PLL_UPDATE will be cleared
	  automatically by hardware when PLL_ACK_LATCH is asserted by PLL.
 Wait for PLL output to stabilize 
	
	  a contains 16 bit alpha_val in two’s complement number in the range
	  of [-0.5, 0.5).
	
	  alpha_val should be in two’s complement number in the range
	  of [-0.5, 0.5) so if quotient >= 0.5 then increment the l value
	  since alpha value will be subtracted in this case.
		
		  Depending upon alpha_mode, it can be treated as MN value or
		  as a two’s complement number. When alpha_mode=1,
		  pll_alpha_val<15:8>=M and pll_apla_val<7:0>=N
		 
		 		Fout=FIN(L+(MN))
		 
		  M is a signed number (-128 to 127) and N is unsigned
		  (0 to 255). MN has to be within +-0.5.
		 
		  When alpha_mode=0, it is a two’s complement number in the
		  range [-0.5, 0.5).
		 
		 		Fout=FIN(L+(alpha_val)2^16)
		 
		  where alpha_val is two’s complement number.
	
	  Huayra PLL supports PLL dynamic programming. User can change L_VAL,
	  without having to go through the power on sequence.
 Ensure that the write above goes to detect L val change. 
 If in FSM mode, just vote for it 
 Set operation mode to RUN 
 Enable the PLL outputs 
 Enable the global PLL outputs 
 If in FSM mode, just unvote it 
 Disable the global PLL output 
 Disable the PLL outputs 
 Place the PLL mode in STANDBY 
 16 -> 0xf, 8 -> 0x7, 4 -> 0x3, 2 -> 0x1, 1 -> 0x0 
 If in FSM mode, just vote for it 
 Skip If PLL is already running 
 If in FSM mode, just unvote it 
 Disable main outputs 
 Place the PLL in STANDBY 
  Due to limited number of bits for fractional rate programming, the
  rounded up rate could be marginally higher than the requested rate.
 Check if calibration needs to be done i.e. PLL is in reset 
 Return early if calibration is not needed. 
 Setup PLL for calibration frequency 
 Bringup the PLL at calibration frequency 
	
	  If the PLL is in FSM mode, then treat set_rate callback as a
	  no-operation.
  clk_lucid_pll_configure - configure the lucid pll
  @pll: clk alpha pll
  @regmap: register map
  @config: configuration to apply for pll
 Disable PLL output 
 Set operation mode to OFF 
 Place the PLL in STANDBY mode 
  The TRION PLL requires a power-on self-calibration which happens when the
  PLL comes out of reset. Calibrate in case it is not completed.
 Return early if calibration is not needed. 
 Onoff to calibrate 
 Latch the PLL input 
 Wait for 2 reference cycles before checking the ACK bit. 
 Return the latch input to 0 
 Wait for PLL output to stabilize 
 change L_VAL without having to go through the power on sequence 
 If in FSM mode, just vote for it 
 Check if PLL is already enabled, return if enabled 
 Enable the PLL outputs 
 Enable the global PLL outputs 
 If in FSM mode, just unvote it 
 Disable the global PLL output 
 Disable the PLL outputs 
 Place the PLL mode in STANDBY 
  The Lucid 5LPE PLL requires a power-on self-calibration which happens
  when the PLL comes out of reset. Calibrate in case it is not completed.
 Return early if calibration is not needed. 
	
	  If the PLL is in FSM mode, then treat set_rate callback as a
	  no-operation.
 Disable PLL output 
 Set operation mode to OFF 
 Place the PLL in STANDBY mode 
 If in FSM mode, just vote for it 
 Get the PLL out of bypass mode 
	
	  HW requires a 1us delay between disabling the bypass and
	  de-asserting the reset.
 Set operation mode to RUN 
 If cfa mode then poll for freq lock 
 Enable the PLL outputs 
 Enable the global PLL outputs 
 If in FSM mode, just unvote it 
 Disable the global PLL output 
 Disable the PLL outputs 
 Put the PLL in bypass and reset 
 Place the PLL mode in OFF state 
 Wait before polling for the frequency latch 
 Read stay in cfa mode 
 If cfa mode then poll for freq lock 
 Wait for PLL output to stabilize 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014-2015, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
 Return the HW recalc rate for idle use case 
 Return the HW recalc rate for idle use case 
 Return the HW recalc rate for idle use case 
 Return the HW recalc rate for idle use case 
 Return the HW recalc rate for idle use case 
 Return the HW recalc rate for idle use case 
 Return the HW recalc rate for idle use case 
 Return the HW recalc rate for idle use case 
 Return the HW recalc rate for idle use case 
 Return the HW recalc rate for idle use case 
 reset state of disp_cc_mdss_dp_link_div_clk_src divider is 0x3 (div 4) 
 Return the HW recalc rate for idle use case 
 Return the HW recalc rate for idle use case 
 Enable hardware clock gating for DSI and MDP clocks 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2020, The Linux Foundation. All rights reserved.
	
	  Keep the CLK always-ON
	  LPASS_AUDIO_CORE_SYSNOC_SWAY_CORE_CLK
 PLL settings 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018, The Linux Foundation. All rights reserved.
 P_VIDEO_PLL0_OUT_EVEN, 
 P_VIDEO_PLL0_OUT_ODD, 
 { P_VIDEO_PLL0_OUT_EVEN, 2 }, 
 { P_VIDEO_PLL0_OUT_ODD, 3 }, 
 { .name = "video_pll0_out_even" }, 
 { .name = "video_pll0_out_odd" }, 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2013, 2018, The Linux Foundation. All rights reserved.
 Dynamic Frequency Scaling 
 Wait for update to take effect 
  Calculate mn:d rate
           parent_rate     m
    rate = ----------- x  ---
             hid_div       n
 50 % duty-cycle for Non-MND RCGs 
 50 % duty-cycle always 
 Duty-cycle cannot be modified for non-MND RCGs 
 Calculate 2d value 
 Check bit widths of 2d. If D is too big reduce duty cycle. 
 link rate of 270M 
 119 M 
 130.25 M 
 138.50 M 
 148.50 M 
 154 M 
 205.25 M 
 268.50 M 
 Link rate of 162M 
 119 M 
 130.25 M 
 138.50 M 
 148.50 M 
 154 M 
 205.25 M 
 268.50 M 
 Parent index is set statically in frequency table 
 Force the correct parent 
 Parent index is set statically in frequency table 
 Read the hardware to determine parent during set_rate 
	
	  This function does ping-pong the RCG between PLLs: if we don't
	  have at least one fixed PLL and two variable ones,
	  then it's not going to work correctly.
 This has to be a fixed rate PLL 
 Are we going back to a previously used rate? 
 On some targets, the GFX3D RCG may need to divide PLL frequency 
	
	  We should never get here; clk_gfx3d_determine_rate() should always
	  make us use a different parent than what we're currently using, so
	  clk_gfx3d_set_rate_and_parent() should always be called.
 wait for RCG to turn ON 
	
	  In case clock is disabled, update the CFG, M, N and D registers
	  and don't hit the update bit of CMD register.
	
	  Set the update bit because required configuration has already
	  been written in clk_rcg2_shared_set_rate()
	
	  Store current configuration as switching to safe source would clear
	  the SRC and DIV of CFG register
	
	  Park the RCG at a safe configuration - sourced off of safe source.
	  Force enable and disable the RCG while configuring it to safeguard
	  against any update signal coming from the downstream clock.
	  The current parent is still prepared and enabled at this point, and
	  the safe source is always on while application processor subsystem
	  is online. Therefore, the RCG can safely switch its parent.
 Write back the stored configuration corresponding to current rate 
 Common APIs to be used for DFS based RCGR 
 Allocate space for 1 extra since table is NULL terminated 
	
	  Assume that parent_rate is actually the parent because
	  we can't do any better at figuring it out when the table
	  hasn't been populated yet. We only populate the table
	  in determine_rate because we can't guarantee the parents
	  will be registered with the framework until then.
	
	  Rate changes with consumer writing a register in
	  their own IO region
 Parent rate is a fixed phy link rate 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2015 Linaro Limited
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2016, Linaro Limited
  Copyright (c) 2014, The Linux Foundation. All rights reserved.
 to kHz 
 Buffered clock needs a binary value 
 to kHz 
 Buffered clock needs a binary value 
	
	  Active-only clocks don't care what the rate is during sleep. So,
	  they vote for zero.
 Don't send requests to the RPM if the rate has not been set. 
 Take peer clock's rate into account only if it's enabled. 
 Undo the active set vote and restore it 
 Take peer clock's rate into account only if it's enabled. 
 Take peer clock's rate into account only if it's enabled. 
	
	  RPM handles rate rounding and we don't have a way to
	  know what the rate will be, so just return whatever
	  rate is requested.
	
	  RPM handles rate rounding and we don't have a way to
	  know what the rate will be, so just return whatever
	  rate was set.
 SM6125 
 SM6115 
 QCM2290 
 SPDX-License-Identifier: GPL-2.0
  Qualcomm APCS clock controller driver
  Copyright (c) 2017, Linaro Limited
  Author: Georgi Djakov <georgi.djakov@linaro.org>
  We use the notifier function for switching to a temporary safe configuration
  (mux and divider), while the A53 PLL is reconfigured.
 set the mux and divider to safe frequency (400mhz) 
 Use an unique name by appending parent's @unit-address 
 SPDX-License-Identifier: GPL-2.0
  Qualcomm A53 PLL driver
  Copyright (c) 2017, Linaro Limited
  Author: Georgi Djakov <georgi.djakov@linaro.org>
 Skip the freq that is not divisible 
 Fall on a53pll_freq if no freq_tbl is found from OPP 
 Use an unique name by appending @unit-address 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018-2021, The Linux Foundation. All rights reserved.
  struct bcm_db - Auxiliary data pertaining to each Bus Clock Manager(BCM)
  @unit: divisor used to convert Hz value to an RPMh msg
  @width: multiplier used to convert Hz value to an RPMh msg
  @vcd: virtual clock domain that this bcm belongs to
  @reserved: reserved to pad the struct
  struct clk_rpmh - individual rpmh clock data structure
  @hw:			handle between common and hardware-specific interfaces
  @res_name:		resource name for the rpmh clock
  @div:		clock divider to compute the clock rate
  @res_addr:		base address of the rpmh resource within the RPMh
  @res_on_val:		rpmh clock enable value
  @state:		rpmh clock requested state
  @aggr_state:		rpmh clock aggregated state
  @last_sent_aggr_state: rpmh clock last aggr state sent to RPMh
  @valid_state_mask:	mask to determine the state of the rpmh clock
  @unit:		divisor to convert rate to rpmh msg in magnitudes of Khz
  @dev:		device to which it is attached
  @peer:		pointer to the clock rpmh sibling
  Update state and aggregate state values based on enable value.
 Nothing required to be done if already off or on 
	
	  RPMh clocks have a fixed rate. Return static rate.
	
	  Since any non-zero value sent to hw would result in enabling the
	  clock, only send the value if the clock has already been prepared.
 Resource name must match resource id present in cmd-db 
 Resource name must match resource id present in cmd-db 
 Convert unit from Khz to Hz 
 typecast to silence compiler warning 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013, The Linux Foundation. All rights reserved.
	
	  These clocks select three inputs via two muxes. One mux selects
	  between csi0 and csi1 and the second mux selects between that mux's
	  output and csi2. The source and destination selections for each
	  mux must be clocking for the switch to succeed so just turn on
	  all three sources because it's easier than figuring out what source
	  needs to be on at what time.
	
	  Wait at least 6 cycles of slowest clock
	  for the glitch-free MUX to fully switch sources.
	
	  Wait at least 6 cycles of slowest clock
	  for the glitch-free MUX to fully switch sources.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2020, The Linux Foundation. All rights reserved.
 1152MHz configuration 
 532MHz configuration 
 533.2MHz configuration 
 1152MHz configuration 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
 Keep VIDEO_CC_XO_CLK ALWAYS-ON 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014, The Linux Foundation. All rights reserved.
  Copyright (c) BayLibre, SAS.
  Author : Neil Armstrong <narmstrong@baylibre.com>
 Use the correct frequency plan depending on speed of PLL4 
 Enable PLL4 source on the LPASS Primary PLL Mux 
 SPDX-License-Identifier: GPL-2.0-only
x
  Copyright (c) 2015, The Linux Foundation. All rights reserved.
 Disable the AHB DCD 
 Disable the NoC FSM for mmss_mmagic_cfg_ahb_clk 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
	
	  Configure gpu_cc_cx_gmu_clk with recommended
	  wakeupsleep settings
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2021, Konrad Dybcio <konrad.dybcio@somainline.org>
 Yeah, apparently it's not 2 
 Vote for GPLL0 to turn on. Needed by acpuclock. 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
 For CPUSS functionality the AHB clock needs to be left enabled 
 For CPUSS functionality the SYS NOC clock needs to be left enabled 
	
	  Disable the GPLL0 active input to MM blocks, NPU
	  and GPU via MISC registers.
	
	  Keep the clocks always-ON
	  GCC_CPUSS_GNOC_CLK, GCC_VIDEO_AHB_CLK, GCC_CAMERA_AHB_CLK,
	  GCC_DISP_AHB_CLK, GCC_GPU_CFG_AHB_CLK
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2016-2017, The Linux Foundation. All rights reserved.
  Copyright (c) 2018, Craig Tatlor.
			
			  Any access to mmss depends on this clock.
			  Gating this clock has been shown to crash the system
			  when mmssnoc_axi_rpm_clk is inited in rpmcc.
	
	  Set the HMSS_AHB_CLK_SLEEP_ENA bit to allow the hmss_ahb_clk to be
	  turned off by hardware during certain apps low power modes.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
  Copyright (c) BayLibre, SAS.
  Author : Neil Armstrong <narmstrong@baylibre.com>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2020, The Linux Foundation. All rights reserved.
  Copyright (c) 2020, Martin Botka <martin.botka@somainline.org>
  Copyright (c) 2020, Konrad Dybcio <konrad.dybcio@somainline.org>
 Voteable PLL 
 APSS controlled PLLs 
 RO to linux 
	
	  NOTE: Op does not work for div-3. Current assumption is that div-3
	  is not a recommended setting for this divider.
	
	  NOTE: Op does not work for div-3. Current assumption is that div-3
	  is not a recommended setting for this divider.
 Reset state of MDSS_DP_LINK_INTF_DIV is 0x3 (div-4) 
			
			  Dependency to be enabled before the branch is
			  enabled.
 This GDSC seems to hang the whole multimedia subsystem.
static struct gdsc bimc_smmu_gdsc = {
	.gdscr = 0xe020,
	.gds_hw_ctrl = 0xe024,
	.pd = {
		.name = "bimc_smmu",
	},
	.pwrsts = PWRSTS_OFF_ON,
	.parent = &bimc_smmu_gdsc.pd,
	.flags = HW_CTRL,
};
 SDM630 has only one DSI 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2018-2021, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2019, The Linux Foundation. All rights reserved.
 1380MHz configuration 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013, The Linux Foundation. All rights reserved.
 Two NS registers means mode control is in NS register 
  Calculate mn:d rate
           parent_rate     m
    rate = ----------- x  ---
             pre_div       n
 MN counter mode is in hw.enable_reg sometimes 
 Two NS registers means mode control is in NS register 
 MN counter mode is in hw.enable_reg sometimes 
 Read the hardware to determine parent during set_rate 
 bypass the pre divider 
 let us find appropriate mn values for this 
  This type of clock has a glitch-free mux that switches between the output of
  the MN counter and an always on clock source (XO). When clk_set_rate() is
  called we need to make sure that we don't switch to the MN counter if it
  isn't clocking because the mux will get stuck and the clock will stop
  outputting a clock. This can happen if the framework isn't aware that this
  clock is on and so clk_set_rate() doesn't turn on the new parent. To fix
  this we switch the mux in the enabledisable ops and reprogram the MN
  counter in the set_rate op. We also make sure to switch away from the MN
  counter in set_rate if software thinks the clock is off.
 Switch to XO to avoid glitches 
 Switch back to MN if it's clocking 
 Use MN 
 Use XO 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2020, The Linux Foundation. All rights reserved.
	
	  Disable the GPLL0 active input to NPU and GPU
	  via MISC registers.
	
	  Keep the clocks always-ON
	  GCC_VIDEO_AHB_CLK, GCC_CAMERA_AHB_CLK, GCC_DISP_AHB_CLK,
	  GCC_CPUSS_DVM_BUS_CLK, GCC_GPU_CFG_AHB_CLK,
	  GCC_SYS_NOC_CPUSS_AHB_CLK
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  Clock ON depends on external parent 'config noc', so cant poll
  delay and also mark as crtitical for camss boot
 XO critical input to camss, so no need to poll 
 required for cpuss 
 required for cpuss 
 required for cpuss 
  Clock ON depends on external parent 'config noc', so cant poll
  delay and also mark as crtitical for disp boot
 XO critical input to disp, so no need to poll 
 required for gpu 
 required for npu 
 Clock ON depends on external parent 'PIPE' clock, so dont poll 
 Clock ON depends on external parent 'PIPE' clock, so dont poll 
 required for cpuss 
 external clocks so add BRANCH_HALT_SKIP 
 external clocks so add BRANCH_HALT_SKIP 
 external clocks so add BRANCH_HALT_SKIP 
 external clocks so add BRANCH_HALT_SKIP 
 external clocks so add BRANCH_HALT_SKIP 
 external clocks so add BRANCH_HALT_SKIP 
  Clock ON depends on external parent 'config noc', so cant poll
  delay and also mark as crtitical for video boot
 XO critical input to video, so no need to poll 
 Disable the GPLL0 active input to NPU and GPU via MISC registers 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2021, Konrad Dybcio <konrad.dybcio@somainline.org>
	
	  Disable the GPLL0 active input to video block via
	  MISC registers.
	
	  Enable DUAL_EDGE mode for MCLK RCGs
	  This is requierd to enable MND divider mode
 SPDX-License-Identifier: GPL-2.0
  Qualcomm A7 PLL driver
  Copyright (c) 2020, Linaro Limited
  Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
 Configure PLL only if the l_val is zero 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.
 BLSP1 QUP1 and BLSP2 QUP5 use the same freqs 
 This GDSC does not exist, but ABI has to remain intact 
 V2 and V2.1 
 MSM8992 features less clocks and some have different freq tables 
		
		  Some 8992 boards might possibly use
		  PCIe1 clocks and controller, but it's not
		  standard and they should be disabled otherwise.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
 Default to our fastest rate 
 De-assert reset to FSM 
 Program bias count and lock count 
 Enable PLL FSM voting 
  Backwards compatibility with old DTs. Register a pass-through factor 11
  clock to translate 'path' clk into 'name' clk and register the 'path'
  clk as a fixed rate clock if it isn't present.
	
	  TODO: The RPM clock driver currently does not support the xo clock.
	  When xo is added to the RPM clock driver, we should change this
	  function to skip registration of xo factor clocks.
 Drop 'protected-clocks' from the list of clocks to register 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018, The Linux Foundation. All rights reserved.
  As per HW design, some of the CAMCC RCGs needs to
  move to XO clock during their clock disable so using
  clk_rcg2_shared_ops for such RCGs. This is required
  to power down the camera memories gracefully.
  Also, use CLK_SET_RATE_PARENT flag for the RCGs which
  have CAM_CC_PLL2_OUT_EVEN PLL as parent in frequency
  table and requires reconfiguration of the PLL frequency.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
 TODO: Remove after DTS updated to protect these 
 Disable the GPLL0 active input to MMSS and GPU via MISC registers 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
 { P_DISP_CC_PLL1_OUT_EVEN, 5 }, 
 { .hw = &disp_cc_pll1_out_even.clkr.hw }, 
 note: trion == lucid, except for the prepare() op 
 Enable clock gating for MDP clocks 
 DISP_CC_XO_CLK always-on 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
  Copyright (c) 2020, Linaro Ltd.
	
	  Keep the clocks always-ON as they are critical to the functioning
	  of the system:
	  GCC_SYS_NOC_CPUSS_AHB_CLK, GCC_CPUSS_AHB_CLK, GCC_CPUSS_GNOC_CLK
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2021, Konrad Dybcio <konrad.dybcio@somainline.org>
 Is this one even used by anything? Downstream doesn't tell. 
 Note: There might be more frequencies desired here. 
 Gating this clock will wreck havoc among MMSS! 
 V2 and V2.1 
 MSM8992 features less clocks and some have different freq tables 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2019, The Linux Foundation. All rights reserved.
 360MHz Configuration 
 Recommended WAKEUPSLEEP settings for the gpu_cc_cx_gmu_clk 
 Configure clk_dis_wait for gpu_cx_gdsc 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2019, The Linux Foundation. All rights reserved.
 Keep VIDEO_CC_XO_CLK ALWAYS-ON 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018, The Linux Foundation. All rights reserved.
 930MHz configuration 
 PWM clks do not have XO as parent as src clk is a balance root 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2021, The Linux Foundation. All rights reserved.
 CLK_OFF would not toggle until LPASS is out of reset 
 CLK_OFF would not toggle until LPASS is out of reset 
 CLK_OFF would not toggle until LPASS is out of reset 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018, The Linux Foundation. All rights reserved.
 Initialize a HFPLL at a given rate and enable it. 
 Configure PLL parameters for integer mode. 
 Pick the right VCO. 
 Disable PLL bypass mode. 
	
	  HW requires a 5us delay between disabling the bypass and
	  de-asserting the reset. Delay 10us just to be safe.
 De-assert active-low PLL reset. 
 Wait for PLL to lock. 
 Enable PLL output. 
 Enable an already-configured HFPLL. 
	
	  Disable the PLL output, disable test mode, enable the bypass mode,
	  and assert the reset.
  For optimization reasons, assumes no downstream clocks are actively using
  it.
 Pick the right VCO. 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021, The Linux Foundation. All rights reserved.
	
	  FIXME: dwc3 usb gadget cannot resume after GDSC power off
	  dwc3 7000000.dwc3: failed to enable ep0out
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2017, The Linux Foundation. All rights reserved.
 Start at 1 instead of 0 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2019, The Linux Foundation. All rights reserved.
 RO to linux 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018, The Linux Foundation. All rights reserved.
 TCSR clock 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2021, The Linux Foundation. All rights reserved.
 1200MHz Configuration 
 600MHz Configuration 
 1440MHz Configuration 
 760MHz Configuration 
 760MHz Configuration 
 760MHz Configuration 
 960MHz Configuration 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015, The Linux Foundation. All rights reserved.
	
	  Set the HMSS_AHB_CLK_SLEEP_ENA bit to allow the hmss_ahb_clk to be
	  turned off by hardware during certain apps low power modes.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 Paul Cercueil <paul@crapouillou.net>
 SPDX-License-Identifier: GPL-2.0
  X1000 SoC CGU driver
  Copyright (c) 2019 周琰杰 (Zhou Yanjie) <zhouyanjie@wanyeetech.com>
 CGU register offsets 
 bits within the OPCR register 
 bits within the USBPCR register 
 bits within the USBPCR1 register 
 External clocks 
 PLLs 
 Custom (SoC-specific) OTG PHY 
 Muxes & dividers 
 Gate-only clocks 
  CGU has some children devices, this is useful for probing children devices
  in the case where the device node is compatible with "simple-mfd".
 SPDX-License-Identifier: GPL-2.0-or-later
  Ingenic JZ4740 SoC CGU driver
  Copyright (c) 2015 Imagination Technologies
  Author: Paul Burton <paul.burton@mips.com>
 CGU register offsets 
 bits within a PLL control register 
 bits within the LCR register 
 bits within the CLKGR register 
 External clocks 
 Muxes & dividers 
 Gate-only clocks 
 SPDX-License-Identifier: GPL-2.0-or-later
  Ingenic JZ4780 SoC CGU driver
  Copyright (c) 2013-2015 Imagination Technologies
  Author: Paul Burton <paul.burton@mips.com>
  Copyright (c) 2020 周琰杰 (Zhou Yanjie) <zhouyanjie@wanyeetech.com>
 CGU register offsets 
 bits within the OPCR register 
 bits within the USBPCR register 
 bits within the USBPCR1 register 
 bits within the USBRDT register 
 bits within the USBVBFIL register 
 bits within the LCR register 
 bits within the CLKGR1 register 
 wait for the CPU to be powered up 
 External clocks 
 PLLs 
 Custom (SoC-specific) OTG PHY 
 Muxes & dividers 
 Gate-only clocks 
 SPDX-License-Identifier: GPL-2.0
  Ingenic JZ4725B SoC CGU driver
  Copyright (C) 2018 Paul Cercueil
  Author: Paul Cercueil <paul@crapouillou.net>
 CGU register offsets 
 bits within the LCR register 
 External clocks 
 Muxes & dividers 
 Gate-only clocks 
 not sure , -1, -1, -1 },
 not sure , -1, -1, -1 },
 Doc calls it EXT512, but it seems to be 256... 
 SPDX-License-Identifier: GPL-2.0
  JZ4760 SoC CGU driver
  Copyright 2018, Paul Cercueil <paul@crapouillou.net>
  CPM registers offset address definition
 The frequency after the N divider must be between 1 and 50 MHz. 
 The N divider must be >= 2. 
 External clocks 
 PLLs 
 TODO: PLL1 can depend on PLL0 
 Main clocks 
 Divided clocks 
 Those divided clocks can connect to PLL0 or PLL1 
 Those divided clocks can connect to EXT, PLL0 or PLL1 
 Those divided clocks can connect to EXT or PLL0 
 These divided clock can connect to PLL0 only 
 Gate-only clocks 
 Custom clocks 
 We only probe via devicetree, no need for a platform driver 
 JZ4760B has some small differences, but we don't implement them. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Ingenic SoC CGU driver
  Copyright (c) 2013-2015 Imagination Technologies
  Author: Paul Burton <paul.burton@mips.com>
  ingenic_cgu_gate_get() - get the value of clock gate register bit
  @cgu: reference to the CGU whose registers should be read
  @info: info struct describing the gate bit
  Retrieves the state of the clock gate bit described by info. The
  caller must hold cgu->lock.
  Return: true if the gate bit is set, else false.
  ingenic_cgu_gate_set() - set the value of clock gate register bit
  @cgu: reference to the CGU whose registers should be modified
  @info: info struct describing the gate bit
  @val: non-zero to gate a clock, otherwise zero
  Sets the given gate bit in order to gate or ungate a clock.
  The caller must hold cgu->lock.
  PLL operations
	
	  The frequency after the input divider must be between 10 and 50 MHz.
	  The highest divider yields the best resolution.
 If the PLL is enabled, verify that it's stable 
  Operations for all non-PLL clocks
		
		  Convert the hardware index to the parent index by skipping
		  over any -1's in the parents array.
		
		  Convert the parent index to the hardware index by adding
		  1 for any -1 in the parents array preceding the given
		  index. That is, we want the index of idx'th entry in
		  clk_info->parents which does not equal -1.
 idx should always be a valid parent 
 write the register 
 calculate the divide 
 Impose hardware constraints 
	
	  If the divider value itself must be divided before being written to
	  the divider register, we must ensure we don't have any bits set that
	  would be lost as a result of doing so.
 update the divide 
 clear the stop bit 
 set the change enable bit 
 update the hardware 
 wait for the change to take effect 
 ungate the clock 
 gate the clock 
  Setup functions.
 pass rate changes to the parent clock 
 nothing to do for gates or fixed dividers 
 SPDX-License-Identifier: GPL-2.0
  JZ4770 SoC CGU driver
  Copyright 2018, Paul Cercueil <paul@crapouillou.net>
  CPM registers offset address definition
 bits within the OPCR register 
 UHC PHY suspend 
 bits within the USBPCR1 register 
 UHC PHY power down 
 External clocks 
 PLLs 
 TODO: PLL1 can depend on PLL0 
 Main clocks 
 disable CCLK stop on idle
 Those divided clocks can connect to PLL0 or PLL1 
 Those divided clocks can connect to EXT, PLL0 or PLL1 
 Gate-only clocks 
 Custom clocks 
 We only probe via devicetree, no need for a platform driver 
 SPDX-License-Identifier: GPL-2.0
  X1830 SoC CGU driver
  Copyright (c) 2019 周琰杰 (Zhou Yanjie) <zhouyanjie@wanyeetech.com>
 CGU register offsets 
 bits within the OPCR register 
 bits within the USBPCR register 
 External clocks 
 PLLs 
 Custom (SoC-specific) OTG PHY 
 Muxes & dividers 
 Gate-only clocks 
  CGU has some children devices, this is useful for probing children devices
  in the case where the device node is compatible with "simple-mfd".
 SPDX-License-Identifier: GPL-2.0
  JZ47xx SoCs TCU clocks driver
  Copyright (C) 2019 Paul Cercueil <paul@crapouillou.net>
 8 channels max + watchdog + OST 
	
	  If the SoC has no global TCU clock, we must ungate the channel's
	  clock to be able to access its registers.
	  If we have a TCU clock, it will be enabled automatically as it has
	  been attached to the regmap.
 1024 divider 
 Reset channel and clock divider, set default parent 
 X1000 has OST, but it not belong TCU 
 sentinel  }
	
	  We set EXT as the default parent clock for all the TCU clocks
	  except for the watchdog one, where we set the RTC clock as the
	  parent. Since the EXT and PCLK are much faster than the RTC clock,
	  the watchdog would kick after a maximum time of 5s, and we might
	  want a slower kicking time.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2019 BayLibre, SAS.
  Author: Jerome Brunet <jbrunet@baylibre.com>
 Get the hhi system controller node 
 Populate regmap for the regmap backed clocks 
 array might be sparse 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 BayLibre, SAS.
  Author: Jerome Brunet <jbrunet@baylibre.com>
 Gives a hint that something is wrong 
 if read only, just return current value 
 Would prefer clk_regmap_div_ro_ops but clashes with qcom 
 SPDX-License-Identifier: GPL-2.0+
  Amlogic Meson-AXG Clock Controller Driver
  Copyright (c) 2016 Baylibre SAS.
  Author: Michael Turquette <mturquette@baylibre.com>
  Copyright (c) 2019 Baylibre SAS.
  Author: Neil Armstrong <narmstrong@baylibre.com>
  AO Configuration Clock registers offsets
  Register offsets from the data sheet must be multiplied by 4.
  Like every other peripheral clock gate in Amlogic Clock drivers,
  we are using CLK_IGNORE_UNUSED here, so we keep the state of the
  bootloader. The goal is to remove this flag at some point.
  Actually removing it will require some extensive test to be done safely.
 32k_by_oscin clock 
 cec clock 
 SPDX-License-Identifier: GPL-2.0+
  Amlogic Meson8 DDR clock controller
  Copyright (C) 2019 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
 Populate regmap 
 Register all clks 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0+
  Amlogic Meson-AXG Clock Controller Driver
  Copyright (c) 2016 BayLibre, SAS.
  Author: Neil Armstrong <narmstrong@baylibre.com>
  Copyright (c) 2018 Amlogic, inc.
  Author: Qiufang Dai <qiufang.dai@amlogic.com>
  Author: Yixun Lan <yixun.lan@amlogic.com>
 Reset Controller 
 Populate regmap 
 Register all clks 
 SPDX-License-Identifier: (GPL-2.0 OR MIT)
  Copyright (c) 2018 BayLibre, SAS.
  Author: Jerome Brunet <jbrunet@baylibre.com>
 Audio Master Clocks 
 Sample Clocks 
 TDM bit clock sources 
 TDM sample clock sources 
 Pad master clock sources 
 Pad bit clock sources 
 Pad sample clock sources 
 Common Clocks 
 AXG Clocks 
 AXGG12A Clocks 
 Provide aud_top signal name on axg and g12a 
 G12a clocks 
 SM1 Clocks 
  Array of all clocks provided by this provider
  The input clocks of the controller will be populated at runtime
  Array of all G12A clocks provided by this provider
  The input clocks of the controller will be populated at runtime
  Array of all SM1 clocks provided by this provider
  The input clocks of the controller will be populated at runtime
 Convenience table to populate regmap in .probe(). 
 Get the mandatory peripheral clock 
 Populate regmap for the regmap backed clocks 
 Take care to skip the registered input clocks 
 array might be sparse 
 Stop here if there is no reset 
 SPDX-License-Identifier: (GPL-2.0 OR MIT)
  Copyright (c) 2019 BayLibre, SAS.
  Author: Neil Armstrong <narmstrong@baylibre.com>
 Write the SYS_CPU_DYN_ENABLE bit before changing the divider 
 Update the divider while removing the SYS_CPU_DYN_ENABLE bit 
 SPDX-License-Identifier: GPL-2.0+
  Amlogic Meson-AXG Clock Controller Driver
  Copyright (c) 2016 Baylibre SAS.
  Author: Michael Turquette <mturquette@baylibre.com>
  Copyright (c) 2018 Amlogic, inc.
  Author: Qiufang Dai <qiufang.dai@amlogic.com>
  AO Configuration Clock registers offsets
  Register offsets from the data sheet must be multiplied by 4.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 BayLibre, SAS.
  Author: Neil Armstrong <narmstrong@baylibre.com>
  This vid_pll divided is a fully programmable fractionnal divider to
  achieve complex video clock rates.
  Here are provided the commonly used fraction values provided by Amlogic.
 21  => 2 
 52  => 2.5 
 31  => 3 
 72  => 3.5 
 154 => 3.75 
 41  => 4 
 51  => 5 
 61  => 6 
 254 => 6.25 
 71  => 7 
 152 => 7.5 
 121 => 12 
 141 => 14 
 151 => 15 
 SPDX-License-Identifier: GPL-2.0+
  AmLogic Meson-AXG Clock Controller Driver
  Copyright (c) 2016 Baylibre SAS.
  Author: Michael Turquette <mturquette@baylibre.com>
  Copyright (c) 2017 Amlogic, inc.
  Author: Qiufang Dai <qiufang.dai@amlogic.com>
		
		  This clock won't ever change at runtime so
		  CLK_SET_RATE_PARENT is not required
 sentinel  },
		
		  FIXME:
		  This clock, as fdiv2, is used by the SCPI FW and is required
		  by the platform to operate correctly.
		  Until the following condition are met, we need this clock to
		  be marked as critical:
		  a) The SCPI generic driver claims and enable all the clocks
		     it needs
		  b) CCF has a clock hand-off mechanism to make the sure the
		     clock stays on until the proper driver comes along
 sentinel  },
 skip the parent mpll3, reserved for debug 
 skip the parent 0, reserved for debug 
	
	  Following these parent clocks, we should also have had mpll2, mpll3
	  and gp0_pll but these clocks are too precious to be used here. All
	  the necessary rates for MMC and NAND operation can be acheived using
	  xtal or fclk_div clocks
 SDcard clock 
 EMMCNAND clock 
 VPU Clock 
 We need a specific parent for VPU clock source, let it be set in DT 
		
		  We want to avoid CCF to disable the VPU clock if
		  display has been set by Bootloader
 We need a specific parent for VPU clock source, let it be set in DT 
		
		  We want to avoid CCF to disable the VPU clock if
		  display has been set by Bootloader
 VAPB Clock 
 Video Clocks 
 MIPI DSI Host Clock 
		
		  bits 15:12 selects from 14 possible parents:
		  xtal, [rtc_oscin_i], [sys_cpu_div16], [ddr_dpll_pt],
		  hifi_pll, mpll0, mpll1, mpll2, mpll3, fdiv4,
		  fdiv3, fdiv5, [cts_msr_clk], fdiv7, gp0_pll
 Everything Else (EE) domain gates 
 Always On (AO) domain gates 
 Array of all clocks provided by this provider 
 Convenience table to populate regmap in .probe 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2015 Endless Mobile, Inc.
  Author: Carlo Caione <carlo@endlessm.com>
  Copyright (c) 2016 BayLibre, Inc.
  Michael Turquette <mturquette@baylibre.com>
 sentinel  },
		
		  This clock won't ever change at runtime so
		  CLK_SET_RATE_PARENT is not required
  Taken from the vendor driver for the 29702975MHz (both only differ in the
  FRAC part in HHI_VID_PLL_CNTL2) where these values are identical for Meson8,
  Meson8b and Meson8m2. This doubles the input (or output - it's not clear
  which one but the result is the same) clock. The vendor driver additionally
  has the following comment about: "optimise HPLL VCO 2.97GHz performance".
 sentinel  }
 sometimes also called "HPLL" or "HPLL PLL" 
		
		  FIXME bits 14:12 selects from 8 possible parents:
		  xtal, 1'b0 (wtf), fclk_div7, mpll_clkout1, mpll_clkout2,
		  fclk_div4, fclk_div3, fclk_div5
 sentinel  },
		
		  NOTE: We are skipping the parent with value 0x2 (which is
		  meson8b_cpu_in_div3) because it results in a duty cycle of
		  33% which makes the system unstable and can result in a
		  lockup of the whole system.
 FIXME all other parents are unknown: 
 also called LVDS_CLK_EN 
		
		  TODO: depending on the SoC there is also a second parent:
		  Meson8: unknown
		  Meson8b: hdmi_pll_dco
		  Meson8m2: vid2_pll
 TODO: parent 0x2 is vid_pll_pre_div_mult7_div2 
 FIXME: all other parents are unknown 
  The MALI IP is clocked by two identical clocks (mali_0 and mali_1)
  muxed by a glitch-free switch on Meson8b and Meson8m2. The CCF can
  actually manage this glitch-free mux because it does top-to-bottom
  updates the each clock tree and switches to the "inactive" one when
  CLK_SET_RATE_GATE is set.
  Meson8 only has mali_0 and no glitch-free mux.
		
		  Don't propagate rate changes up because the only changeable
		  parents are mpll1 and mpll2 but we need those for audio and
		  RGMII (Ethernet). We don't want to change the audio or
		  Ethernet clocks when setting the GPU frequency.
		
		  Don't propagate rate changes up because the only changeable
		  parents are mpll1 and mpll2 but we need those for audio and
		  RGMII (Ethernet). We don't want to change the audio or
		  Ethernet clocks when setting the GPU frequency.
 sentinel  },
			
			  Note:
			  meson8b and meson8m2 have different vpu_0_sels (with
			  different struct clk_hw). We fallback to the global
			  naming string mechanism so vpu_0_div picks up the
			  appropriate one.
			
			  Note:
			  meson8b and meson8m2 have different vpu_1_sels (with
			  different struct clk_hw). We fallback to the global
			  naming string mechanism so vpu_1_div picks up the
			  appropriate one.
  The VPU clock has two two identical clock trees (vpu_0 and vpu_1)
  muxed by a glitch-free switch on Meson8b and Meson8m2. The CCF can
  actually manage this glitch-free mux because it does top-to-bottom
  updates the each clock tree and switches to the "inactive" one when
  CLK_SET_RATE_GATE is set.
  Meson8 only has vpu_0 and no glitch-free mux.
 TODO: The second parent is currently unknown 
 TODO: the clock at index 0 is "DDR_PLL" which we don't support yet 
 TODO: the clock at index 0 is "DDR_PLL" which we don't support yet 
		
		  The parent is specific to origin of the audio data. Let the
		  consumer choose the appropriate parent.
 Everything Else (EE) domain gates 
 AIU gates 
 Always On (AO) domain gates 
 xtal 
 cpu_scale_out_sel 
 Reset Controller 
 Populate regmap for the regmap backed clocks 
	
	  register all clks and start with the first used ID (which is
	  CLKID_PLL_FIXED)
 array might be sparse 
	
	  FIXME we shouldn't program the muxes in notifier handlers. The
	  tricky programming sequence will be handled by the forthcoming
	  coordinated clock rates mechanism once that feature is released.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2015 Endless Mobile, Inc.
  Author: Carlo Caione <carlo@endlessm.com>
  Copyright (c) 2018 Baylibre, SAS.
  Author: Jerome Brunet <jbrunet@baylibre.com>
  In the most basic form, a Meson PLL is composed as follows:
                      PLL
         +--------------------------------+
         |                                |
         |             +--+               |
   in >>-----[ N ]--->|  |      +-----+  |
         |             |  |------| DCO |---->> out
         |  +--------->|  |      +--v--+  |
         |  |          +--+         |     |
         |  |                       |     |
         |  +--[ (M + (FFmax) ]<--+     |
         |                                |
         +--------------------------------+
  out = in  (m + frac  frac_max)  n
	
	  On some HW, N is set to zero on init. This value is invalid as
	  it would result in a division by zero. The rate can't be
	  calculated in this case
 Bail out if we are already over the requested rate 
 Round Closest 
 Round down 
 Check the predivider range 
 Get the boundaries out the way 
 the pre-divider gives a multiplier too big - stop 
	
	  The rate provided by the setting is not an exact match, let's
	  try to improve the result using the fractional parameter
 Is the clock locked now ? 
 do nothing if the PLL is already enabled 
 Make sure the pll is in reset 
 Enable the pll 
 Take the pll out reset 
 Put the pll is in reset 
 Disable the pll 
 If the pll is stopped, bail out now 
		
		  FIXME: Do we really needwant this HACK ?
		  It looks unsafe. what happens if the clock gets into a
		  broken state and we can't lock back on the old_rate ? Looks
		  like an infinite recursion is possible
  The Meson G12A PCIE PLL is fined tuned to deliver a very precise
  100MHz reference clock for the PCIe Analog PHY, and thus requires
  a strict register sequence to enable the PLL.
  To simplify, re-use the _init() op to enable the PLL and keep
  the other ops except set_rate since the rate is fixed.
 SPDX-License-Identifier: (GPL-2.0 OR MIT)
  Copyright (c) 2018 BayLibre, SAS.
  Author: Jerome Brunet <jbrunet@baylibre.com>
  Sample clock generator divider:
  This HW divider gates with value 0 but is otherwise a zero based divider:
  val >= 1
  divider = val + 1
  The duty cycle may also be set for the LR clock variant. The duty cycle
  ratio is:
  hi = [0 - val]
  duty_cycle = (1 + hi)  (1 + val)
	
	  The maximum divider we can use without overflowing
	  unsigned long in rate  i below
		
		  It's the most ideal case if the requested rate can be
		  divided from parent clock without needing to change
		  parent rate, so return the divider immediately.
 if the divider is initially disabled, assume max 
 SPDX-License-Identifier: GPL-2.0+
  Amlogic Meson-G12A Clock Controller Driver
  Copyright (c) 2016 Baylibre SAS.
  Author: Michael Turquette <mturquette@baylibre.com>
  Copyright (c) 2018 Amlogic, inc.
  Author: Qiufang Dai <qiufang.dai@amlogic.com>
  Author: Jian Hu <jian.hu@amlogic.com>
		
		  This clock won't ever change at runtime so
		  CLK_SET_RATE_PARENT is not required
 This clock feeds the CPU, avoid disabling it 
 This clock feeds the CPU, avoid disabling it 
		
		  This clock is used to debug the sys_pll range
		  Linux should not change it at runtime
		
		  This clock is used to debug the sys_pll range
		  Linux should not change it at runtime
		
		  Similar to fclk_div3, it seems that this clock is used by
		  the resident firmware and is required by the platform to
		  operate correctly.
		  Until the following condition are met, we need this clock to
		  be marked as critical:
		  a) Mark the clock used by a firmware resource, if possible
		  b) CCF has a clock hand-off mechanism to make the sure the
		     clock stays on until the proper driver comes along
		
		  This clock is used by the resident firmware and is required
		  by the platform to operate correctly.
		  Until the following condition are met, we need this clock to
		  be marked as critical:
		  a) Mark the clock used by a firmware resource, if possible
		  b) CCF has a clock hand-off mechanism to make the sure the
		     clock stays on until the proper driver comes along
 Datasheet names this field as "premux0" 
 Datasheet names this field as "premux1" 
 This sub-tree is used a parking clock 
 Datasheet names this field as "mux0_divn_tcnt" 
 Datasheet names this field as "postmux0" 
 Datasheet names this field as "Mux1_divn_tcnt" 
 Datasheet names this field as "postmux1" 
 This sub-tree is used a parking clock 
 Datasheet names this field as "Final_dyn_mux_sel" 
 Datasheet names this field as "Final_mux_sel" 
 Datasheet names this field as "Final_mux_sel" 
 Datasheet names this field as "premux0" 
 Datasheet names this field as "mux0_divn_tcnt" 
 Datasheet names this field as "postmux0" 
 Datasheet names this field as "premux1" 
 This sub-tree is used a parking clock 
 Datasheet names this field as "Mux1_divn_tcnt" 
 Datasheet names this field as "postmux1" 
 This sub-tree is used a parking clock 
 Datasheet names this field as "Final_dyn_mux_sel" 
 Datasheet names this field as "Final_mux_sel" 
 Datasheet names this field as "premux0" 
 Datasheet names this field as "premux1" 
 Datasheet names this field as "Mux0_divn_tcnt" 
 Datasheet names this field as "postmux0" 
 Datasheet names this field as "Mux1_divn_tcnt" 
 Datasheet names this field as "postmux1" 
 Datasheet names this field as "Final_dyn_mux_sel" 
 Datasheet names this field as "Final_mux_sel" 
 Datasheet names this field as "Cpu_clk_sync_mux_sel" bit 0 
 This CPU also have a dedicated clock tree 
 Datasheet names this field as "Cpu_clk_sync_mux_sel" bit 1 
 This CPU also have a dedicated clock tree 
 Datasheet names this field as "Cpu_clk_sync_mux_sel" bit 2 
 This CPU also have a dedicated clock tree 
 Datasheet names this field as "Cpu_clk_sync_mux_sel" bit 4 
 Wait for clock propagation beforeafter changing the mux 
		
		  This notifier means cpu_clk_postmux0 clock will be changed
		  to feed cpu_clk, this is the current path :
		  cpu_clk
		     \- cpu_clk_dyn
		           \- cpu_clk_postmux0
		                 \- cpu_clk_muxX_div
		                       \- cpu_clk_premux0
		 				\- fclk_div3 or fclk_div2
		 		OR
		                 \- cpu_clk_premux0
		 			\- fclk_div3 or fclk_div2
 Setup cpu_clk_premux1 to xtal 
 Setup cpu_clk_postmux1 to bypass divider 
 Switch to parking clk on cpu_clk_postmux1 
		
		  Now, cpu_clk is 24MHz in the current path :
		  cpu_clk
		     \- cpu_clk_dyn
		           \- cpu_clk_postmux1
		                 \- cpu_clk_premux1
		                       \- xtal
		
		  The cpu_clk_postmux0 has ben updated, now switch back
		  cpu_clk_dyn to cpu_clk_postmux0 and take the changes
		  in account.
 Configure cpu_clk_dyn back to cpu_clk_postmux0 
		
		  new path :
		  cpu_clk
		     \- cpu_clk_dyn
		           \- cpu_clk_postmux0
		                 \- cpu_clk_muxX_div
		                       \- cpu_clk_premux0
		 				\- fclk_div3 or fclk_div2
		 		OR
		                 \- cpu_clk_premux0
		 			\- fclk_div3 or fclk_div2
		
		  This notifier means sys_pll clock will be changed
		  to feed cpu_clk, this the current path :
		  cpu_clk
		     \- sys_pll
		           \- sys_pll_dco
 Configure cpu_clk to use cpu_clk_dyn 
		
		  Now, cpu_clk uses the dyn path
		  cpu_clk
		     \- cpu_clk_dyn
		           \- cpu_clk_dynX
		                 \- cpu_clk_dynX_sel
		 		     \- cpu_clk_dynX_div
		                       \- xtalfclk_div2fclk_div3
		                    \- xtalfclk_div2fclk_div3
		
		  The sys_pll has ben updated, now switch back cpu_clk to
		  sys_pll
 Configure cpu_clk to use sys_pll 
		 new path :
		  cpu_clk
		     \- sys_pll
		           \- sys_pll_dco
 G12B first CPU cluster uses sys1_pll 
 G12B second CPU cluster uses sys_pll 
		
		  This clock is used to debug the cpu_clk range
		  Linux should not change it at runtime
		
		  This clock is used to debug the cpu_clk range
		  Linux should not change it at runtime
		
		  This clock is set by the ROM monitor code,
		  Linux should not change it at runtime
		
		  This clock is set by the ROM monitor code,
		  Linux should not change it at runtime
		
		  This clock is set by the ROM monitor code,
		  Linux should not change it at runtime
			
			  Note:
			  G12A and G12B have different cpu_clks (with
			  different struct clk_hw). We fallback to the global
			  naming string mechanism so cpu_clk_trace_div picks
			  up the appropriate one.
		
		  This clock is set by the ROM monitor code,
		  Linux should not change it at runtime
		
		  This clock is set by the ROM monitor code,
		  Linux should not change it at runtime
		
		  This clock is set by the ROM monitor code,
		  Linux should not change it at runtime
		
		  This clock is set by the ROM monitor code,
		  Linux should not change it at runtime
		
		  This clock is set by the ROM monitor code,
		  Linux should not change it at runtime
  Internal gp0 pll emulation configuration parameters
 This clock feeds the DSU, avoid disabling it 
  Internal hifi pll emulation configuration parameters
  The Meson G12A PCIE PLL is fined tuned to deliver a very precise
  100MHz reference clock for the PCIe Analog PHY, and thus requires
  a strict register sequence to enable the PLL.
 Keep a single entry table for recalcround_rate() ops 
		
		  Display directly handle hdmi pll registers ATM, we need
		  NOCACHE to keep our view of the clock as accurate as possible
	
	  Following these parent clocks, we should also have had mpll2, mpll3
	  and gp0_pll but these clocks are too precious to be used here. All
	  the necessary rates for MMC and NAND operation can be acheived using
	  g12a_ee_core or fclk_div clocks
 SDIO clock 
 SDcard clock 
 EMMCNAND clock 
 Video Clocks 
		
		  bit 18 selects from 2 possible parents:
		  vid_pll_div or hdmi_pll
 VPU Clock 
		
		  bit 31 selects from 2 possible parents:
		  vpu_0 or vpu_1
 VDEC clocks 
 VAPB Clock 
		
		  bit 31 selects from 2 possible parents:
		  vapb_0 or vapb_1
 TOFIX: add support for cts_tcon 
 MIPI DSI Host Clocks 
 HDMI Clocks 
  The MALI IP is clocked by two identical clocks (mali_0 and mali_1)
  muxed by a glitch-free switch. The CCF can manage this glitch-free
  mux because it does top-to-bottom updates the each clock tree and
  switches to the "inactive" one when CLK_SET_RATE_GATE is set.
		
		  Don't request the parent to change the rate because
		  all GPU frequencies can be derived from the fclk_
		  clocks and one special GP0_PLL setting. This is
		  important because we need the MPLL clocks for audio.
		
		  Don't request the parent to change the rate because
		  all GPU frequencies can be derived from the fclk_
		  clocks and one special GP0_PLL setting. This is
		  important because we need the MPLL clocks for audio.
 SPICC SCLK source clock 
 Neural Network Accelerator source clock 
 Everything Else (EE) domain gates 
 Array of all clocks provided by this provider 
 Convenience table to populate regmap in .probe 
 Setup clock notifier for cpu_clk_postmux0 
 Setup clock notifier for cpu_clk_dyn mux 
 Setup clock notifier for cpu_clk mux 
 Setup clock notifier for sys1_pll 
 Add notifiers for the second CPU cluster 
 Setup clock notifier for cpub_clk_postmux0 
 Setup clock notifier for cpub_clk_dyn mux 
 Setup clock notifier for cpub_clk mux 
 Setup clock notifier for sys_pll 
 Setup clock notifier for cpu_clk mux 
 Setup clock notifier for sys_pll 
 SPDX-License-Identifier: (GPL-2.0 OR MIT)
  Copyright (c) 2018 BayLibre, SAS.
  Author: Jerome Brunet <jbrunet@baylibre.com>
	
	  This last calculation is here for cases when degrees is rounded
	  to 360, in which case val == (1 << width).
  This is a special clock for the audio controller.
  The phase of mst_sclk clock output can be controlled independently
  for the outside world (ph0), the tdmout (ph1) and tdmin (ph2).
  Controlling these 3 phases as just one makes things simpler and
  give the same clock view to all the element on the i2s bus.
  If necessary, we can still control the phase in the tdm block
  which makes these independent control redundant.
 Get phase 0 and sync it to phase 1 and 2 
 Phase are in sync, reading phase 0 is enough 
  This is a special clock for the audio controller.
  This drive a bit clock inverter for which the
  opposite value of the inverter bit needs to be manually
  set into another bit
 Get phase and sync the inverted value to ws 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2016 AmLogic, Inc.
  Michael Turquette <mturquette@baylibre.com>
 sentinel  },
 sentinel  },
		
		  This clock won't ever change at runtime so
		  CLK_SET_RATE_PARENT is not required
		
		  Display directly handle hdmi pll registers ATM, we need
		  NOCACHE to keep our view of the clock as accurate as possible
		
		  On gxl, there is a register shift due to
		  HHI_HDMI_PLL_CNTL1 which does not exist on gxbb,
		  so we use the HHI_HDMI_PLL_CNTL2 define from GXBB
		  instead which is defined at the same offset.
		
		  Display directly handle hdmi pll registers ATM, we need
		  NOCACHE to keep our view of the clock as accurate as possible
			
			  Note:
			  GXL and GXBB have different gp0_pll_dco (with
			  different struct clk_hw). We fallback to the global
			  naming string mechanism so gp0_pll picks up the
			  appropriate one.
		
		  FIXME:
		  This clock, as fdiv2, is used by the SCPI FW and is required
		  by the platform to operate correctly.
		  Until the following condition are met, we need this clock to
		  be marked as critical:
		  a) The SCPI generic driver claims and enable all the clocks
		     it needs
		  b) CCF has a clock hand-off mechanism to make the sure the
		     clock stays on until the proper driver comes along
		
		  bits 14:12 selects from 8 possible parents:
		  xtal, 1'b0 (wtf), fclk_div7, mpll_clkout1, mpll_clkout2,
		  fclk_div4, fclk_div3, fclk_div5
 the mother of dragons gates 
 NOTE: The datasheet doesn't list the parents for bit 10 
  The MALI IP is clocked by two identical clocks (mali_0 and mali_1)
  muxed by a glitch-free switch. The CCF can manage this glitch-free
  mux because it does top-to-bottom updates the each clock tree and
  switches to the "inactive" one when CLK_SET_RATE_GATE is set.
		
		  Don't request the parent to change the rate because
		  all GPU frequencies can be derived from the fclk_
		  clocks and one special GP0_PLL setting. This is
		  important because we need the MPLL clocks for audio.
		
		  Don't request the parent to change the rate because
		  all GPU frequencies can be derived from the fclk_
		  clocks and one special GP0_PLL setting. This is
		  important because we need the MPLL clocks for audio.
		
		 The parent is specific to origin of the audio data. Let the
		  consumer choose the appropriate parent
	
	  FIXME: This clock is provided by the ao clock controller but the
	  clock is not yet part of the binding of this controller, so string
	  name must be use to set this parent.
	
	  Following these parent clocks, we should also have had mpll2, mpll3
	  and gp0_pll but these clocks are too precious to be used here. All
	  the necessary rates for MMC and NAND operation can be acheived using
	  xtal or fclk_div clocks
 SDIO clock 
 SDcard clock 
 EMMCNAND clock 
 VPU Clock 
		
		  bits 9:10 selects from 4 possible parents:
		  fclk_div4, fclk_div3, fclk_div5, fclk_div7,
		
		  bits 25:26 selects from 4 possible parents:
		  fclk_div4, fclk_div3, fclk_div5, fclk_div7,
		
		  bit 31 selects from 2 possible parents:
		  vpu_0 or vpu_1
 VAPB Clock 
		
		  bits 9:10 selects from 4 possible parents:
		  fclk_div4, fclk_div3, fclk_div5, fclk_div7,
		
		  bits 25:26 selects from 4 possible parents:
		  fclk_div4, fclk_div3, fclk_div5, fclk_div7,
		
		  bit 31 selects from 2 possible parents:
		  vapb_0 or vapb_1
 Video Clocks 
			
			  Note:
			  GXL and GXBB have different hdmi_plls (with
			  different struct clk_hw). We fallback to the global
			  naming string mechanism so vid_pll_div picks up the
			  appropriate one.
	
	  Note:
	  GXL and GXBB have different hdmi_plls (with
	  different struct clk_hw). We fallback to the global
	  naming string mechanism so vid_pll_div picks up the
	  appropriate one.
		
		  bit 18 selects from 2 possible parents:
		  vid_pll_div or hdmi_pll
		
		  bits 16:18 selects from 8 possible parents:
		  vid_pll, fclk_div4, fclk_div3, fclk_div5,
		  vid_pll, fclk_div7, mp1
		
		  bits 16:18 selects from 8 possible parents:
		  vid_pll, fclk_div4, fclk_div3, fclk_div5,
		  vid_pll, fclk_div7, mp1
 TOFIX: add support for cts_tcon 
		
		  bits 31:28 selects from 12 possible parents:
		  vclk_div1, vclk_div2, vclk_div4, vclk_div6, vclk_div12
		  vclk2_div1, vclk2_div2, vclk2_div4, vclk2_div6, vclk2_div12,
		  cts_tcon
 HDMI Clocks 
 VDEC clocks 
		
		  bits 15:12 selects from 14 possible parents:
		  xtal, [rtc_oscin_i], [sys_cpu_div16], [ddr_dpll_pt],
		  vid_pll, vid2_pll (hevc), mpll0, mpll1, mpll2, fdiv4,
		  fdiv3, fdiv5, [cts_msr_clk], fdiv7, gp0_pll
 Everything Else (EE) domain gates 
 Always On (AO) domain gates 
 AIU gates 
 Array of all clocks provided by this provider 
 SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
  Copyright (c) 2016 AmLogic, Inc.
  Author: Michael Turquette <mturquette@baylibre.com>
  MultiPhase Locked Loops are outputs from a PLL with additional frequency
  scaling capabilities. MPLL rates are calculated as:
  f(N2_integer, SDM_IN ) = 2.0G(N2_integer + SDM_IN16384)
 Set the fractional part 
 Set the integer divider part 
 Enable the fractional part 
 Set spread spectrum if possible 
 Set the magic misc bit if required 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2017 BayLibre, SAS
  Author: Neil Armstrong <narmstrong@baylibre.com>
  Author: Jerome Brunet <jbrunet@baylibre.com>
  The AO Domain embeds a dualdivider to generate a more precise
  32,768KHz clock for low-power suspend mode and CEC.
      ______   ______
     |      | |      |
     | Div1 |-| Cnt1 |
    |______| |______|\
  -|  ______   ______  X--> Out
    \|      | |      |
     | Div2 |-| Cnt2 |
     |______| |______|
  The dividing can be switched to single or dual, with a counter
  for each divider to set when the switching is done.
 If we get an exact match, don't bother any further 
 SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
  Copyright (c) 2016 BayLibre, SAS.
  Author: Neil Armstrong <narmstrong@baylibre.com>
 AO Configuration Clock registers offsets 
		
		  FIXME: The 'fixme' parent obviously does not exist.
		 
		  ATM, CCF won't call get_parent() if num_parents is 1. It
		  does not allow NULL as a parent name either.
		 
		  On this particular mux, we only know the input #1 parent
		  but, on boot, unknown input #0 is set, so it is critical
		  to call .get_parent() on it
		 
		  Until CCF gets fixed, adding this fake parent that won't
		  ever be registered should work around the problem
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018-2019 SiFive, Inc.
  Wesley Terpstra
  Paul Walmsley
  This library supports configuration parsing and reprogramming of
  the CLN28HPC variant of the Analog Bits Wide Range PLL.  The
  intention is for this library to be reusable for any device that
  integrates this PLL; thus the register structure and programming
  details are expected to be provided by a separate IP block driver.
  The bulk of this code is primarily useful for clock configurations
  that must operate at arbitrary rates, as opposed to clock configurations
  that are restricted by software or manufacturer guidance to a small,
  pre-determined set of performance points.
  References:
  - Analog Bits "Wide Range PLL Datasheet", version 2015.10.01
  - SiFive FU540-C000 Manual v1p0, Chapter 7 "Clocking and Reset"
    https:static.dev.sifive.comFU540-C000-v1.0.pdf
 MIN_INPUT_FREQ: minimum input clock frequency, in Hz (Fref_min) 
 MAX_INPUT_FREQ: maximum input clock frequency, in Hz (Fref_max) 
 MIN_POST_DIVIDE_REF_FREQ: minimum post-divider reference frequency, in Hz 
 MAX_POST_DIVIDE_REF_FREQ: maximum post-divider reference frequency, in Hz 
 MIN_VCO_FREQ: minimum VCO frequency, in Hz (Fvco_min) 
 MAX_VCO_FREQ: maximum VCO frequency, in Hz (Fvco_max) 
 MAX_DIVQ_DIVISOR: maximum output divisor.  Selected by DIVQ = 6 
 MAX_DIVR_DIVISOR: maximum reference divisor.  Selected by DIVR = 63 
 MAX_LOCK_US: maximum PLL lock time, in microseconds (tLOCK_max) 
  ROUND_SHIFT: number of bits to shift to avoid precision loss in the rounding
               algorithm
  Private functions
  __wrpll_calc_filter_range() - determine PLL loop filter bandwidth
  @post_divr_freq: input clock rate after the R divider
  Select the value to be presented to the PLL RANGE input signals, based
  on the input clock frequency after the post-R-divider @post_divr_freq.
  This code follows the recommendations in the PLL datasheet for filter
  range selection.
  Return: The RANGE value to be presented to the PLL configuration inputs,
          or a negative return code upon error.
  __wrpll_calc_fbdiv() - return feedback fixed divide value
  @c: ptr to a struct wrpll_cfg record to read from
  The internal feedback path includes a fixed by-two divider; the
  external feedback path does not.  Return the appropriate divider
  value (2 or 1) depending on whether internal or external feedback
  is enabled.  This code doesn't test for invalid configurations
  (e.g. both or neither of WRPLL_FLAGS__FEEDBACK are set); it relies
  on the caller to do so.
  Context: Any context.  Caller must protect the memory pointed to by
           @c from simultaneous modification.
  Return: 2 if internal feedback is enabled or 1 if external feedback
          is enabled.
  __wrpll_calc_divq() - determine DIVQ based on target PLL output clock rate
  @target_rate: target PLL output clock rate
  @vco_rate: pointer to a u64 to store the computed VCO rate into
  Determine a reasonable value for the PLL Q post-divider, based on the
  target output rate @target_rate for the PLL.  Along with returning the
  computed Q divider value as the return value, this function stores the
  desired target VCO rate into the variable pointed to by @vco_rate.
  Context: Any context.  Caller must protect the memory pointed to by
           @vco_rate from simultaneous access or modification.
  Return: a positive integer DIVQ value to be programmed into the hardware
          upon success, or 0 upon error (since 0 is an invalid DIVQ value)
  __wrpll_update_parent_rate() - update PLL data when parent rate changes
  @c: ptr to a struct wrpll_cfg record to write PLL data to
  @parent_rate: PLL input refclk rate (pre-R-divider)
  Pre-compute some data used by the PLL configuration algorithm when
  the PLL's reference clock rate changes.  The intention is to avoid
  computation when the parent rate remains constant - expected to be
  the common case.
  Returns: 0 upon success or -ERANGE if the reference clock rate is
  out of range.
  wrpll_configure_for_rate() - compute PLL configuration for a target rate
  @c: ptr to a struct wrpll_cfg record to write into
  @target_rate: target PLL output clock rate (post-Q-divider)
  @parent_rate: PLL input refclk rate (pre-R-divider)
  Compute the appropriate PLL signal configuration values and store
  in PLL context @c.  PLL reprogramming is not glitchless, so the
  caller should switch any downstream logic to a different clock
  source or clock-gate it before presenting these values to the PLL
  configuration signals.
  The caller must pass this function a pre-initialized struct
  wrpll_cfg record: either initialized to zero (with the
  exception of the .name and .flags fields) or read from the PLL.
  Context: Any context.  Caller must protect the memory pointed to by @c
           from simultaneous access or modification.
  Return: 0 upon success; anything else upon failure.
 Initialize rounding data if it hasn't been initialized already 
 Put the PLL into bypass if the user requests the parent clock rate 
 Calculate the Q shift and target VCO rate 
 Precalculate the pre-Q divider target ratio 
	
	  Consider all values for R which land within
	  [MIN_POST_DIVR_FREQ, MAX_POST_DIVR_FREQ]; prefer smaller R
 Ensure rounding didn't take us out of range 
 Pick the best PLL jitter filter 
  wrpll_calc_output_rate() - calculate the PLL's target output rate
  @c: ptr to a struct wrpll_cfg record to read from
  @parent_rate: PLL refclk rate
  Given a pointer to the PLL's current input configuration @c and the
  PLL's input reference clock rate @parent_rate (before the R
  pre-divider), calculate the PLL's output clock rate (after the Q
  post-divider).
  Context: Any context.  Caller must protect the memory pointed to by @c
           from simultaneous modification.
  Return: the PLL's output clock rate, in Hz.  The return value from
          this function is intended to be convenient to pass directly
          to the Linux clock framework; thus there is no explicit
          error return value.
  wrpll_calc_max_lock_us() - return the time for the PLL to lock
  @c: ptr to a struct wrpll_cfg record to read from
  Return the minimum amount of time (in microseconds) that the caller
  must wait after reprogramming the PLL to ensure that it is locked
  to the input frequency and stable.  This is likely to depend on the DIVR
  value; this is under discussion with the manufacturer.
  Return: the minimum amount of time the caller must wait for the PLL
          to lock (in microseconds)
 SPDX-License-Identifier: GPL-2.0
  Xilinx VCU Init
  Copyright (C) 2016 - 2017 Xilinx, Inc.
  Contacts   Dhaval Shah <dshah@xilinx.com>
  struct xvcu_device - Xilinx VCU init device structure
  @dev: Platform device
  @pll_ref: pll ref clock source
  @aclk: axi clock source
  @logicore_reg_ba: logicore reg base address
  @vcu_slcr_ba: vcu_slcr Register base address
  @pll: handle for the VCU PLL
  @pll_post: handle for the VCU PLL post divider
  @clk_data: clocks provided by the vcu clock provider
  struct xvcu_pll_cfg - Helper data
  @fbdiv: The integer portion of the feedback divider to the PLL
  @cp: PLL charge pump control
  @res: PLL loop filter resistor control
  @lfhf: PLL loop filter high frequency capacitor control
  @lock_dly: Lock circuit configuration settings for lock windowsize
  @lock_cnt: Lock circuit counter setting
  xvcu_read - Read from the VCU register space
  @iomem:	vcu reg space base address
  @offset:	vcu reg offset from base
  Return:	Returns 32bit value from VCU register specified
  xvcu_write - Write to the VCU register space
  @iomem:	vcu reg space base address
  @offset:	vcu reg offset from base
  @value:	Value to write
	
	  The output divider of the PLL must be set to 12 to meet the
	  timing in the design.
 Protect register shared by clocks 
  xvcu_probe - Probe existence of the logicoreIP
 			and initialize PLL
  @pdev:	Pointer to the platform_device structure
  Return:	Returns 0 on success
 		Negative error code otherwise
	
	  Do the Gasket isolation and put the VCU out of reset
	  Bit 0 : Gasket isolation
	  Bit 1 : put VCU out of reset
  xvcu_remove - Insert gasket isolation
 			and disable the clock
  @pdev:	Pointer to the platform_device structure
  Return:	Returns 0 on success
 		Negative error code otherwise
 Add the Gasket isolation and put the VCU in reset. 
 SPDX-License-Identifier: GPL-2.0-only
  Marvell PXA25x family clocks
  Copyright (C) 2014 Robert Jarzmik
  Heavily inspired from former archarmmach-pxapxa25x.c.
  For non-devicetree platforms. Once pxa is fully converted to devicetree, this
  should go away.
 Define the refresh period in mSec for the SDRAM and the number of rows 
 standard 64ms SDRAM 
  Various clock factors driven by the CCCR register.
 Crystal Frequency to Memory Frequency Multiplier (L) 
 Memory Frequency to Run Mode Frequency Multiplier (M) 
 Run Mode Frequency to Turbo Mode Frequency Multiplier (N) 
 Note: we store the value N  2 here. 
  Get the clock frequency as reflected by CCCR and the turbo flag.
  We assume these values have been applied via a fcs.
  If info is not 0 we also display the current settings.
  In this table, PXA25x_CCCR(N2, M, L) has the following meaning, where :
    - freq_cpll = n  m  L  3.6864 MHz
    - n = N2  2
    - m = 2^(M - 1), where 1 <= M <= 3
    - l = L_clk_mult[L], ie. { 0, 27, 32, 36, 40, 45, 0, }[L]
 CPU  MEMBUS  CCCR                  DIV2 CCLKCFG      
	
	  All pinctrl logic has been wiped out of the clock driver, especially
	  for gpio11 and gpio12 outputs. Machine code should ensure proper pin
	  control (ie. pxa2xx_mfp_config() invocation).
 SPDX-License-Identifier: GPL-2.0-only
  Marvell PXA3xxx family clocks
  Copyright (C) 2014 Robert Jarzmik
  Heavily inspired from former archarmmach-pxapxa3xx.c
  For non-devicetree platforms. Once pxa is fully converted to devicetree, this
  should go away.
 crystal frequency to HSIO bus frequency multiplier (HSS) 
 crystal frequency to static memory controller multiplier (SMCFS) 
  Get the clock frequency as reflected by ACSR and the turbo flag.
  We assume these values have been applied via a fcs.
  If info is not 0 we also display the current settings.
	 This may loose precision for some rates but won't for the
	  standard 24.576MHz.
 Read XCLKCFG register turbo bit 
 Read XCLKCFG register turbo bit 
 Read XCLKCFG register turbo bit 
 SPDX-License-Identifier: GPL-2.0-only
  Marvell PXA family clocks
  Copyright (C) 2014 Robert Jarzmik
  Common clock code for PXA clocks ("CKEN" type clocks + DT)
 SDCLK0 Divide by 4 ControlStatus 
 SDRAM Free-Running Control 
 SDRAM Free-Running Control 
 SDRAM Free-Running Control 
 SDRAM Self-Refresh ControlStatus 
 SDRAMSSRAM Auto-Power-Down Enable 
 SDCLK2 Divide by 2 ControlStatus 
 SDCLK2 Run ControlStatus 
 SDCLK1 Divide by 2 ControlStatus 
 SDCLK1 Run ControlStatus 
 SDCKE1 Level ControlStatus 
 SDCLK0 Divide by 2 ControlStatus 
 SDCLK0 Run ControlStatus 
 SDCKE0 Level ControlStatus 
	 Calculate the next MDREFR.  If we're slowing down the SDRAM clock
	  we need to preset the smaller DRI before the change.	 If we're
	  speeding up we need to set the larger DRI value after the change.
	 If we're dividing the memory clock by two for the SDRAM clock, this
	  must be set prior to the change.  Clearing the divide must be done
	  after the change.
 Set new the CCCR and prepare CLKCFG 
 preset the MDREFR \n"
 set CLKCFG[FCS] \n"
 postset the MDREFR \n"
 SPDX-License-Identifier: GPL-2.0-only
  Marvell PXA27x family clocks
  Copyright (C) 2014 Robert Jarzmik
  Heavily inspired from former archarmmach-pxaclock.c.
 Define the refresh period in mSec for the SDRAM and the number of rows 
 standard 64ms SDRAM 
  Get the clock frequency as reflected by CCSR and the turbo flag.
  We assume these values have been applied via a fcs.
  If info is not 0 we also display the current settings.
  PXA270 definitions
  For the PXA27x:
  Control variables are A, L, 2N for CCCR; B, HT, T for CLKCFG.
  A = 0 => memory controller clock from table 3-7,
  A = 1 => memory controller clock = system bus clock
  Run mode frequency	= 13 MHz  L
  Turbo mode frequency = 13 MHz  L  N
  System bus frequency = 13 MHz  L  (B + 1)
  In CCCR:
  A = 1
  L = 16	  oscillator to run mode ratio
  2N = 6	  2  (turbo mode to run mode ratio)
  In CCLKCFG:
  B = 1	  Fast bus mode
  HT = 0	  Half-Turbo mode
  T = 1	  Turbo mode
  For now, just support some of the combinations in table 3-7 of
  PXA27x Processor Family Developer's Manual to simplify frequency
  change sequences.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013 Samsung Electronics Co., Ltd.
  Copyright (c) 2013 Linaro Ltd.
  Author: Thomas Abraham <thomas.ab@samsung.com>
  Common Clock Framework support for Exynos5250 SoC.
Below definitions are used for PWR_CTRL settings
 list of PLLs to be registered 
 number of PLLs 
  list of controller registers to be saved and restored during a
  suspendresume cycle.
 list of all parent clock list 
 fixed rate clocks generated outside the soc 
 fixed rate clocks generated inside the soc 
	
	  NOTE: Following table is sorted by (clock domain, register address,
	  bitfield shift) triplet in ascending order. When adding new entries,
	  please make sure that the order is kept, to avoid merge conflicts
	  and make further work with defined data easier.
	
	  CMU_CPU
	
	  CMU_CORE
	
	  CMU_TOP
	
	  CMU_CDREX
	
	  NOTE: Following table is sorted by (clock domain, register address,
	  bitfield shift) triplet in ascending order. When adding new entries,
	  please make sure that the order is kept, to avoid merge conflicts
	  and make further work with defined data easier.
	
	  CMU_CPU
	
	  CMU_TOP
	
	  NOTE: Following table is sorted by (clock domain, register address,
	  bitfield shift) triplet in ascending order. When adding new entries,
	  please make sure that the order is kept, to avoid merge conflicts
	  and make further work with defined data easier.
	
	  CMU_ACP
	
	  CMU_TOP
 DISP1 gates 
 MUX mout_aclk200_disp1_sub 
 MUX mout_aclk300_disp1_sub 
 sorted in descending order 
 PLL_36XX_RATE(rate, m, p, s, k) 
 Not in UM, but need for eDP on snow 
 sorted in descending order 
 PLL_36XX_RATE(rate, m, p, s, k) 
 sorted in descending order 
 PLL_35XX_RATE(fin, rate, m, p, s) 
 register exynox5250 clocks 
	
	  Enable arm clock down (in idle) and set arm divider
	  ratios in WFIWFE state.
	
	  Enable arm clock up (on exiting idle). Set arm divider
	  ratios when not in idle along with the standby duration
	  ratios.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 Samsung Electronics Co., Ltd.
  Author: Chanwoo Choi <cw00.choi@samsung.com>
  Common Clock Framework support for Exynos5433 SoC.
  Register offset definitions for CMU_TOP
 force all aclk clocks enabled 
 force all sclk_uart clocks enabled 
 ISP PLL has to be enabled for suspend: reset value + ENABLE bit 
 ISP PLL has to be enabled for suspend: reset value + ENABLE bit 
 list of all parent clock list 
 Xi2s{0|1}CDCLK input clock for I2SPCM 
 Xi2s1SDI input clock for SPDIF 
 XspiCLK[4:0] input clock for SPI 
 Xi2s1SCLK input clock for I2S1_BCLK 
 MUX_SEL_TOP0 
 MUX_SEL_TOP1 
 MUX_SEL_TOP2 
 MUX_SEL_TOP3 
 MUX_SEL_TOP4 
 MUX_SEL_TOP_MSCL 
 MUX_SEL_TOP_CAM1 
 MUX_SEL_TOP_FSYS0 
 MUX_SEL_TOP_FSYS1 
 MUX_SEL_TOP_PERIC0 
 MUX_SEL_TOP_PERIC1 
 MUX_SEL_TOP_DISP 
 DIV_TOP0 
 DIV_TOP1 
 DIV_TOP2 
 DIV_TOP3 
 DIV_TOP4 
 DIV_TOP_MSCL 
 DIV_TOP_CAM10 
 DIV_TOP_CAM11 
 DIV_TOP_FSYS0 
 DIV_TOP_FSYS1 
 DIV_TOP_FSYS2 
 DIV_TOP_PERIC0 
 DIV_TOP_PERIC1 
 DIV_TOP_PERIC2 
 DIV_TOP_PERIC3 
 DIV_TOP_PERIC4 
 ENABLE_ACLK_TOP 
 ENABLE_SCLK_TOP_MSCL 
 ENABLE_SCLK_TOP_CAM1 
 ENABLE_SCLK_TOP_DISP 
 ENABLE_SCLK_TOP_FSYS 
 ENABLE_SCLK_TOP_PERIC 
 MUX_ENABLE_TOP_PERIC1 
  ATLAS_PLL & APOLLO_PLL & MEM0_PLL & MEM1_PLL & BUS_PLL & MFC_PLL
  & MPHY_PLL & G3D_PLL & DISP_PLL & ISP_PLL
 sentinel  }
 AUD_PLL 
 sentinel  }
  Register offset definitions for CMU_CPIF
 force all sclk clocks enabled 
 MPHY PLL has to be enabled for suspend: reset value + ENABLE bit 
 list of all parent clock list 
 MUX_SEL_CPIF0 
 DIV_CPIF 
 ENABLE_SCLK_CPIF 
  Register offset definitions for CMU_MIF
 list of all parent clock list 
 dout_{mfc|bus|mem1|mem0}_pll is half fixed rate from parent mux 
 MUX_SEL_MIF0 
 MUX_SEL_MIF1 
 MUX_SEL_MIF2 
 MUX_SEL_MIF3 
 MUX_SEL_MIF4 
 MUX_SEL_MIF5 
 MUX_SEL_MIF6 
 MUX_SEL_MIF7 
 DIV_MIF1 
 DIV_MIF2 
 DIV_MIF3 
 DIV_MIF4 
 DIV_MIF5 
 ENABLE_ACLK_MIF0 
 ENABLE_ACLK_MIF1 
 ENABLE_ACLK_MIF2 
 ENABLE_ACLK_MIF3 
 ENABLE_PCLK_MIF 
 ENABLE_PCLK_MIF_SECURE_DREX0_TZ 
 ENABLE_PCLK_MIF_SECURE_DREX1_TZ 
 ENABLE_PCLK_MIF_SECURE_MONOTONIC_CNT 
 ENABLE_PCLK_MIF_SECURE_RTC 
 ENABLE_SCLK_MIF 
  Register offset definitions for CMU_PERIC
 pclk: sci, pmu, sysreg, gpio_{finger, ese, touch, nfc}, uart2-0 
 sclk: uart2-0 
 DIV_PERIC 
 ENABLE_ACLK_PERIC 
 ENABLE_PCLK_PERIC0 
 ENABLE_PCLK_PERIC1 
 ENABLE_SCLK_PERIC 
  Register offset definitions for CMU_PERIS
 ENABLE_ACLK_PERIS 
 ENABLE_PCLK_PERIS 
 ENABLE_PCLK_PERIS_SECURE_TZPC 
 ENABLE_PCLK_PERIS_SECURE_SECKEY_APBIF 
 ENABLE_PCLK_PERIS_SECURE_CHIPID_APBIF 
 ENABLE_PCLK_PERIS_SECURE_TOPRTC 
 ENABLE_PCLK_PERIS_SECURE_CUSTOM_EFUSE_APBIF 
 ENABLE_PCLK_PERIS_SECURE_ANTIRBK_CNT_APBIF 
 ENABLE_PCLK_PERIS_SECURE_OTP_CON_APBIF 
 ENABLE_SCLK_PERIS 
 ENABLE_SCLK_PERIS_SECURE_SECKEY 
 ENABLE_SCLK_PERIS_SECURE_CHIPID 
 ENABLE_SCLK_PERIS_SECURE_TOPRTC 
 ENABLE_SCLK_PERIS_SECURE_CUSTOM_EFUSE 
 ENABLE_SCLK_PERIS_SECURE_ANTIRBK_CNT 
 ENABLE_SCLK_PERIS_SECURE_OTP_CON 
  Register offset definitions for CMU_FSYS
 list of all parent clock list 
 PHY clocks from USBDRD30_PHY 
 PHY clocks from USBHOST30_PHY 
 PHY clocks from USBHOST20_PHY 
 PHY clocks from UFS_PHY 
 PHY clocks from LLI_PHY 
 MUX_SEL_FSYS0 
 MUX_SEL_FSYS1 
 MUX_SEL_FSYS2 
 MUX_SEL_FSYS3 
 MUX_SEL_FSYS4 
 ENABLE_ACLK_FSYS0 
 ENABLE_ACLK_FSYS1 
 ENABLE_PCLK_FSYS 
 ENABLE_SCLK_FSYS 
 ENABLE_IP_FSYS0 
  Register offset definitions for CMU_G2D
 list of all parent clock list 
 MUX_SEL_G2D0 
 DIV_G2D 
 DIV_ENABLE_ACLK_G2D 
 DIV_ENABLE_ACLK_G2D_SECURE_SMMU_G2D 
 DIV_ENABLE_PCLK_G2D 
 DIV_ENABLE_PCLK_G2D_SECURE_SMMU_G2D 
  Register offset definitions for CMU_DISP
 PLL has to be enabled for suspend 
 ignore status of external PHY muxes during suspend to avoid hangs 
 list of all parent clock list 
	
	  sclk_rgb_{vclk|tv_vclk} is half clock of sclk_decon_{vclk|tv_vclk}.
	  The divider has fixed value (2) between sclk_rgb_{vclk|tv_vclk}
	  and sclk_decon_{vclk|tv_vclk}.
 PHY clocks from MIPI_DPHY1 
 PHY clocks from MIPI_DPHY0 
 PHY clocks from HDMI_PHY 
 MUX_SEL_DISP0 
 MUX_SEL_DISP1 
 MUX_SEL_DISP2 
 MUX_SEL_DISP3 
 MUX_SEL_DISP4 
 DIV_DISP 
 ENABLE_ACLK_DISP0 
 ENABLE_ACLK_DISP1 
 ENABLE_PCLK_DISP 
 ENABLE_SCLK_DISP 
  Register offset definitions for CMU_AUD
 list of all parent clock list 
 MUX_SEL_AUD0 
 MUX_SEL_AUD1 
 DIV_AUD0 
 DIV_AUD1 
 ENABLE_ACLK_AUD 
 ENABLE_PCLK_AUD 
 ENABLE_SCLK_AUD0 
 ENABLE_SCLK_AUD1 
  Register offset definitions for CMU_BUS{0|1|2}
 Only for CMU_BUS2 
 Only for CMU_BUS2 
 Only for CMU_BUS2 
 list of all parent clock list 
 DIV_BUS0 
 CMU_BUS0 clocks 
 ENABLE_ACLK_BUS0 
 ENABLE_PCLK_BUS0 
 CMU_BUS1 clocks 
 DIV_BUS1 
 ENABLE_ACLK_BUS1 
 ENABLE_PCLK_BUS1 
 CMU_BUS2 clocks 
 MUX_SEL_BUS2 
 DIV_BUS2 
 ENABLE_ACLK_BUS2 
 ENABLE_PCLK_BUS2 
  Register offset definitions for CMU_G3D
 list of all parent clock list 
 MUX_SEL_G3D 
 DIV_G3D 
 ENABLE_ACLK_G3D 
 ENABLE_PCLK_G3D 
 ENABLE_SCLK_G3D 
  Register offset definitions for CMU_GSCL
 list of all parent clock list 
 MUX_SEL_GSCL 
 ENABLE_ACLK_GSCL 
 ENABLE_ACLK_GSCL_SECURE_SMMU_GSCL0 
 ENABLE_ACLK_GSCL_SECURE_SMMU_GSCL1 
 ENABLE_ACLK_GSCL_SECURE_SMMU_GSCL2 
 ENABLE_PCLK_GSCL 
 ENABLE_PCLK_GSCL_SECURE_SMMU_GSCL0 
 ENABLE_PCLK_GSCL_SECURE_SMMU_GSCL1 
 ENABLE_PCLK_GSCL_SECURE_SMMU_GSCL2 
  Register offset definitions for CMU_APOLLO
 list of all parent clock list 
 MUX_SEL_APOLLO0 
 MUX_SEL_APOLLO1 
 MUX_SEL_APOLLO2 
 DIV_APOLLO0 
 DIV_APOLLO1 
 ENABLE_ACLK_APOLLO 
 ENABLE_PCLK_APOLLO 
 ENABLE_SCLK_APOLLO 
  Register offset definitions for CMU_ATLAS
 list of all parent clock list 
 MUX_SEL_ATLAS0 
 MUX_SEL_ATLAS1 
 MUX_SEL_ATLAS2 
 DIV_ATLAS0 
 DIV_ATLAS1 
 ENABLE_ACLK_ATLAS 
 ENABLE_PCLK_ATLAS 
 ENABLE_SCLK_ATLAS 
  Register offset definitions for CMU_MSCL
 list of all parent clock list 
 MUX_SEL_MSCL0 
 MUX_SEL_MSCL1 
 DIV_MSCL 
 ENABLE_ACLK_MSCL 
 ENABLE_ACLK_MSCL_SECURE_SMMU_M2MSCALER0 
 ENABLE_ACLK_MSCL_SECURE_SMMU_M2MSCALER1 
 ENABLE_ACLK_MSCL_SECURE_SMMU_JPEG 
 ENABLE_PCLK_MSCL 
 ENABLE_PCLK_MSCL_SECURE_SMMU_M2MSCALER0 
 ENABLE_PCLK_MSCL_SECURE_SMMU_M2MSCALER1 
 ENABLE_PCLK_MSCL_SECURE_SMMU_JPEG 
 ENABLE_SCLK_MSCL 
  Register offset definitions for CMU_MFC
 MUX_SEL_MFC 
 DIV_MFC 
 ENABLE_ACLK_MFC 
 ENABLE_ACLK_MFC_SECURE_SMMU_MFC 
 ENABLE_PCLK_MFC 
 ENABLE_PCLK_MFC_SECURE_SMMU_MFC 
  Register offset definitions for CMU_HEVC
 MUX_SEL_HEVC 
 DIV_HEVC 
 ENABLE_ACLK_HEVC 
 ENABLE_ACLK_HEVC_SECURE_SMMU_HEVC 
 ENABLE_PCLK_HEVC 
 ENABLE_PCLK_HEVC_SECURE_SMMU_HEVC 
  Register offset definitions for CMU_ISP
 MUX_SEL_ISP 
 DIV_ISP 
 ENABLE_ACLK_ISP0 
 ENABLE_ACLK_ISP1 
 ENABLE_ACLK_ISP2 
 ENABLE_PCLK_ISP 
 ENABLE_SCLK_ISP 
  Register offset definitions for CMU_CAM0
 MUX_SEL_CAM00 
 MUX_SEL_CAM01 
 MUX_SEL_CAM02 
 MUX_SEL_CAM03 
 MUX_SEL_CAM04 
 DIV_CAM00 
 DIV_CAM01 
 DIV_CAM02 
 DIV_CAM03 
 ENABLE_ACLK_CAM00 
 ENABLE_ACLK_CAM01 
 ENABLE_ACLK_CAM02 
 ENABLE_PCLK_CAM0 
 ENABLE_SCLK_CAM0 
  Register offset definitions for CMU_CAM1
 MUX_SEL_CAM10 
 MUX_SEL_CAM11 
 MUX_SEL_CAM12 
 DIV_CAM10 
 DIV_CAM11 
 ENABLE_ACLK_CAM10 
 ENABLE_ACLK_CAM11 
 ENABLE_ACLK_CAM12 
 ENABLE_PCLK_CAM1 
 ENABLE_SCLK_CAM1 
  Register offset definitions for CMU_IMEM
 ENABLE_ACLK_IMEM_SLIMSSS 
 ENABLE_PCLK_IMEM_SLIMSSS 
 must be the last entry 
 for suspend some registers have to be set to certain values 
	
	  Enable runtime PM here to allow the clock core using runtime PM
	  for the registered clocks. Additionally, we increase the runtime
	  PM usage count before registering the clocks, to prevent the
	  clock core from runtime suspending the device.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2021 Linaro Ltd.
  Author: Sam Protsenko <semen.protsenko@linaro.org>
  Common Clock Framework support for Exynos850 SoC.
 Gate register bits 
 Gate register offsets range 
  exynos850_init_clocks - Set clocks initial configuration
  @np:			CMU device tree node with "reg" property (CMU addr)
  @reg_offs:		Register offsets array for clocks to init
  @reg_offs_len:	Number of register offsets in reg_offs array
  Set manual control mode for all gate clocks.
 Modify only gate clock registers 
 ---- CMU_TOP ------------------------------------------------------------- 
 Register Offset definitions for CMU_TOP (0x120e0000) 
  Do not provide PLL tables to core PLLs, as MANUAL_PLL_CTRL bit is not set
  for those PLLs by default, so set_rate operation would fail.
 CMU_TOP_PURECLKCOMP 
 List of parent clocks for Muxes in CMU_TOP 
 List of parent clocks for Muxes in CMU_TOP: for CMU_CORE 
 List of parent clocks for Muxes in CMU_TOP: for CMU_HSI 
 List of parent clocks for Muxes in CMU_TOP: for CMU_PERI 
 List of parent clocks for Muxes in CMU_TOP: for CMU_DPU 
 CMU_TOP_PURECLKCOMP 
 CORE 
 DPU 
 HSI 
 PERI 
 CMU_TOP_PURECLKCOMP 
 CORE 
 DPU 
 HSI 
 PERI 
 CORE 
 DPU 
 HSI 
 PERI 
 ---- CMU_HSI ------------------------------------------------------------- 
 Register Offset definitions for CMU_HSI (0x13400000) 
 List of parent clocks for Muxes in CMU_PERI 
 ---- CMU_PERI ------------------------------------------------------------ 
 Register Offset definitions for CMU_PERI (0x10030000) 
 List of parent clocks for Muxes in CMU_PERI 
 ---- CMU_CORE ------------------------------------------------------------ 
 Register Offset definitions for CMU_CORE (0x12000000) 
 List of parent clocks for Muxes in CMU_CORE 
 ---- CMU_DPU ------------------------------------------------------------- 
 Register Offset definitions for CMU_DPU (0x13000000) 
 List of parent clocks for Muxes in CMU_CORE 
 ---- platform_driver ----------------------------------------------------- 
 Keep bus clock running, so it's possible to access CMU registers 
 CMUs which belong to Power Domains and need runtime PM to be implemented 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013 Samsung Electronics Co., Ltd.
  Copyright (c) 2013 Linaro Ltd.
  Author: Thomas Abraham <thomas.ab@samsung.com>
  This file includes utility functions to register clocks to common
  clock framework for Samsung platforms.
 setup the essentials required to support clock lookup using ccf 
 add a clock instance to the clock lookup table used for dt based lookup 
 register a list of aliases 
 register a list of fixed clocks 
		
		  Unconditionally add a clock lookup for the fixed rate clocks.
		  There are not many of these on any of Samsung platforms.
 register a list of fixed factor clocks 
 register a list of mux clocks 
 register a list of div clocks 
 register a list of gate clocks 
  obtain the clock speed of all external fixed clock sources from device
  tree and register it
 utility function to get the rate of a specified clock 
  Common function which registers plls, muxes, dividers and gates
  for each CMU. It also add CMU register list to register cache.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 Samsung Electronics Co., Ltd.
  Author: Naveen Krishna Ch <naveenkrishna.ch@gmail.com>
 Register Offset definitions for CMU_TOPC (0x10570000) 
 List of parent clocks for Muxes in CMU_TOPC 
 Register Offset definitions for CMU_TOP0 (0x105D0000) 
 List of parent clocks for Muxes in CMU_TOP0 
 Register Offset definitions for CMU_TOP1 (0x105E0000) 
 List of parent clocks for Muxes in CMU_TOP1 
	
	  This clock is required for the CMU_FSYS1 registers access, keep it
	  enabled permanently until proper runtime PM support is added.
 Register Offset definitions for CMU_CCORE (0x105B0000) 
  List of parent clocks for Muxes in CMU_CCORE
 Register Offset definitions for CMU_PERIC0 (0x13610000) 
 List of parent clocks for Muxes in CMU_PERIC0 
 Register Offset definitions for CMU_PERIC1 (0x14C80000) 
 List of parent clocks for Muxes in CMU_PERIC1 
 Register Offset definitions for CMU_PERIS (0x10040000) 
 List of parent clocks for Muxes in CMU_PERIS 
 Register Offset definitions for CMU_FSYS0 (0x10E90000) 
  List of parent clocks for Muxes in CMU_FSYS0
 fixed rate clocks used in the FSYS0 block 
 Register Offset definitions for CMU_FSYS1 (0x156E0000) 
  List of parent clocks for Muxes in CMU_FSYS1
 fixed rate clocks used in the FSYS1 block 
 List of parent clocks for Muxes in CMU_MSCL 
 Register Offset definitions for CMU_AUD (0x114C0000) 
  List of parent clocks for Muxes in CMU_AUD
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013 Samsung Electronics Co., Ltd.
  Author: Padmavathi Venna <padma.v@samsung.com>
  Common Clock Framework support for Audio Subsystem Clock Controller.
  On Exynos5420 this will be a clock which has to be enabled before any
  access to audss registers. Typically a child of EPLL.
  On other platforms this will be -ENODEV.
 register exynos_audss clocks 
	
	  Enable runtime PM here to allow the clock core using runtime PM
	  for the registered clocks. Additionally, we increase the runtime
	  PM usage count before registering the clocks, to prevent the
	  clock core from runtime suspending the device.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013 Heiko Stuebner <heiko@sntech.de>
  Common Clock Framework support for s3c24xx external clock output.
  Clock for output-parent selection in misccr
 allocate the clkout 
  dclk and clkout init
 clk_data must be the last entry in the structure 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013 Samsung Electronics Co., Ltd.
  Copyright (c) 2013 Linaro Ltd.
  This file contains the utility functions to register the pll clocks.
 PLL enable control bit offset in @con_reg register 
 PLL lock status bit offset in @con_reg register 
 Assumming rate_table is in descending order 
 return minimum supported value 
 Wait until the PLL is locked 
	
	  This function might be called when the timekeeping API can't be used
	  to detect timeouts. One situation is when the clocksource is not yet
	  initialized, another when the timekeeping is suspended. udelay() also
	  cannot be used when the clocksource is not running on arm64, since
	  the current timer is used as cycle counter. So a simple busy loop
	  is used here in that special cases. The limit of iterations has been
	  derived from experimental measurements of various PLLs on multiple
	  Exynos SoC variants. Single register read time was usually in range
	  0.4...1.5 us, never less than 0.4 us.
  PLL2126 Clock Type
  PLL3000 Clock Type
  PLL35xx Clock Type
 Maximum lock time can be 270  PDIV cycles 
 Get required rate settings from table 
 If only s change, change just s value only
 Set PLL lock time. 
 Change PLL PMS values 
 Wait for PLL lock if the PLL is enabled 
  PLL36xx Clock Type
 Maximum lock time can be 3000  PDIV cycles 
 If only s change, change just s value only
 Set PLL lock time. 
 Change PLL PMS values 
  PLL0822x Clock Type
 Maximum lock time can be 150  PDIV cycles 
 Get required rate settings from table 
 Change PLL PMS values 
 Set PLL lock time 
 Write PMS values 
 Wait for PLL lock if the PLL is enabled 
  PLL0831x Clock Type
 Maximum lock time can be 500  PDIV cycles 
 Get required rate settings from table 
 Change PLL PMSK values 
	
	  kdiv is 16-bit 2's complement (s16), but stored as unsigned int.
	  Cast it to u16 to avoid leading 0xffff's in case of negative value.
 Set PLL lock time 
 Write PMSK values 
 Wait for PLL lock if the PLL is enabled 
  PLL45xx Clock Type
 Get required rate settings from table 
 If only s change, change just s value only
 Set PLL PMS values. 
 Set PLL AFC value. 
 Set PLL lock time. 
 Set new configuration. 
 Wait for PLL lock 
  PLL46xx Clock Type
 Get required rate settings from table 
 If only s change, change just s value only
 Set PLL lock time. 
 Maximum lock time bitfield is 16-bit. 
 Set PLL PMS and VSEL values. 
 Set PLL K, MFR and MRR values. 
 Write configuration to PLL 
 Wait for PLL lock 
  PLL6552 Clock Type
  PLL6553 Clock Type
  PLL Clock Type of S3C24XX before S3C2443
 Get required rate settings from table 
 Change PLL PMS values 
 Time to settle according to the manual 
 if we started the UPLL, then allow to settle 
  PLL2550x Clock Type
  PLL2550xx Clock Type
 Maximum lock time can be 270  PDIV cycles 
 Get required rate settings from table 
 If only s change, change just s value only
 Set PLL lock time. 
 Change PLL PMS values 
 Wait for PLL lock 
  PLL2650x Clock Type
 Maximum lock time can be 3000  PDIV cycles 
 Get required rate settings from table 
 Set PLL lock time. 
 Change PLL PMS values 
 Wait for PLL lock 
  PLL2650XX Clock Type
 Maximum lock time can be 3000  PDIV cycles 
 Change PLL PMS values 
 Set PLL lock time. 
 find count of rates in rate_table 
 clk_ops for 35xx and 2550 are similar 
 clk_ops for 36xx and 2650 are similar 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 Samsung Electronics Co., Ltd.
  Author: Thomas Abraham <thomas.ab@samsung.com>
  Copyright (c) 2015 Samsung Electronics Co., Ltd.
  Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
  This file contains the utility function to register CPU clock for Samsung
  Exynos platforms. A CPU clock is defined as a clock supplied to a CPU or a
  group of CPUs. The CPU clock is typically derived from a hierarchy of clock
  blocks which includes mux and divider blocks. There are a number of other
  auxiliary clocks supplied to the CPU domain such as the debug blocks and AXI
  clock for CPU domain. The rates of these auxiliary clocks are related to the
  CPU clock rate and this relation is usually specified in the hardware manual
  of the SoC or supplied after the SoC characterization.
  The below implementation of the CPU clock allows the rate changes of the CPU
  clock and the corresponding rate changes of the auxillary clocks of the CPU
  domain. The platform clock driver provides a clock register configuration
  for each configurable rate which is then used to program the clock hardware
  registers to acheive a fast co-oridinated rate change for all the CPU domain
  clocks.
  On a rate change request for the CPU clock, the rate change is propagated
  upto the PLL supplying the clock to the CPU domain clock blocks. While the
  CPU domain PLL is reconfigured, the CPU domain clocks are driven using an
  alternate clock source. If required, the alternate clock source is divided
  down in order to keep the output clock rate within the previous OPP limits.
  Helper function to wait until divider(s) have stabilized after the divider
  value has changed.
  Helper function to wait until mux has stabilized after the mux selection
  value was changed.
 common round rate callback useable for all types of CPU clocks 
 common recalc rate callback useable for all types of CPU clocks 
	
	  The CPU clock output (armclk) rate is the same as its parent
	  rate. Although there exist certain dividers inside the CPU
	  clock block that could be used to divide the parent clock,
	  the driver does not make use of them currently, except during
	  frequency transitions.
  Helper function to set the 'safe' dividers for the CPU clock. The parameters
  div and mask contain the divider value and the register bit mask of the
  dividers to be programmed.
 handler for pre-rate change notification from parent clock 
 find out the divider values to use for clock data 
	
	  For the selected PLL clock frequency, get the pre-defined divider
	  values. If the clock for sclk_hpm is not sourced from apll, then
	  the values for DIV_COPY and DIV_HPM dividers need not be set.
	
	  If the old parent clock speed is less than the clock speed of
	  the alternate parent, then it should be ensured that at no point
	  the armclk speed is more than the old_prate until the dividers are
	  set.  Also workaround the issue of the dividers being set to lower
	  values before the parent clock speed is set to new lower speed
	  (this can result in too high speed of armclk output clocks).
			
			  In Exynos4210, ATB clock parent is also mout_core. So
			  ATB clock also needs to be mantained at safe speed.
 select sclk_mpll as the alternate parent 
 alternate parent is active now. set the dividers 
 handler for post-rate change notification from parent clock 
 find out the divider values to use for clock data 
 select mout_apll as the alternate parent 
  Helper function to set the 'safe' dividers for the CPU clock. The parameters
  div and mask contain the divider value and the register bit mask of the
  dividers to be programmed.
 handler for pre-rate change notification from parent clock 
 find out the divider values to use for clock data 
	
	  For the selected PLL clock frequency, get the pre-defined divider
	  values.
	
	  If the old parent clock speed is less than the clock speed of
	  the alternate parent, then it should be ensured that at no point
	  the armclk speed is more than the old_prate until the dividers are
	  set.  Also workaround the issue of the dividers being set to lower
	  values before the parent clock speed is set to new lower speed
	  (this can result in too high speed of armclk output clocks).
 select the alternate parent 
 alternate parent is active now. set the dividers 
 handler for post-rate change notification from parent clock 
 select apll as the alternate parent 
  This notifier function is called for the pre-rate and post-rate change
  notifications of the parent clock of cpuclk.
  This notifier function is called for the pre-rate and post-rate change
  notifications of the parent clock of cpuclk.
 helper function to register a CPU clock 
 find count of configuration rates in cfg 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013 Samsung Electronics Co., Ltd.
  Author: Tarek Dakhran <t.dakhran@samsung.com>
  Common Clock Framework support for Exynos5410 SoC.
 list of PLLs 
 number of PLLs 
 list of all parent clocks 
 register exynos5410 clocks 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 Tomasz Figa <t.figa@samsung.com>
  Based on Exynos Audio Subsystem Clock Controller driver:
  Copyright (c) 2013 Samsung Electronics Co., Ltd.
  Author: Padmavathi Venna <padma.v@samsung.com>
  Driver for Audio Subsystem Clock Controller of S5PV210-compatible SoCs.
 CONFIG_PM_SLEEP 
 register s5pv210_audss clocks 
 iiscdclk0 is an optional external I2S codec clock 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013 Heiko Stuebner <heiko@sntech.de>
  Common Clock Framework support for S3C2443 and following SoCs.
 S3C2416 clock controller register offsets 
 the soc types 
  list of controller registers to be saved and restored during a
  suspendresume cycle.
 sentinel  },
 sentinel  },
 S3C2416 specific clocks 
 sentinel  },
 S3C2443 specific clocks 
 sentinel  },
 S3C2450 specific clocks 
  fixed rate clocks generated outside the soc
  Only necessary until the devicetree-move is complete
 Register external clocks only in non-dt cases 
 Register PLLs. 
 Register common internal clocks. 
 Register SoC-specific clocks. 
 as s3c2450 extends the s3c2416 clocks 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013 Samsung Electronics Co., Ltd.
  Author: Mateusz Krawczuk <m.krawczuk@partner.samsung.com>
  Based on clock drivers for S3C64xx and Exynos4 SoCs.
  Common Clock Framework support for all S5PC110S5PV210 SoCs.
 S5PC110S5PV210 clock controller register offsets 
 IDs of PLLs available on S5PV210S5P6442 SoCs 
 IDs of external clocks (used for legacy boards) 
 List of registers that need to be preserved across suspendresume. 
 Mux parent lists. 
 Common fixed factor clocks. 
 PLL input mux (fin_pll), which needs to be registered before PLLs. 
 Common clock muxes. 
 S5PV210-specific clock muxes. 
 S5P6442-specific clock muxes. 
 S5PV210-specific fixed rate clocks generated inside the SoC. 
 S5P6442-specific fixed rate clocks generated inside the SoC. 
 Common clock dividers. 
 S5PV210-specific clock dividers. 
 S5P6442-specific clock dividers. 
 Common clock gates. 
 S5PV210-specific clock gates. 
 S5P6442-specific clock gates. 
  Clock aliases for legacy clkdev look-up.
  NOTE: Needed only to support legacy board files.
 S5PV210-specific PLLs. 
 S5P6442-specific PLLs. 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 Samsung Electronics Co., Ltd.
  Author: Tomasz Figa <t.figa@samsung.com>
  Clock driver for Exynos clock output
  Device will be instantiated as child of PMU device without its own
  device node.  Therefore match compatibles against parent.
		
		  pdev->dev.parent was checked by exynos_clkout_match_parent_dev()
		  so it is not NULL.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013 Samsung Electronics Co., Ltd.
  Copyright (c) 2013 Linaro Ltd.
  Author: Thomas Abraham <thomas.ab@samsung.com>
  Common Clock Framework support for all Exynos4 SoCs.
 Exynos4 clock controller register offsets 
 Below definitions are used for PWR_CTRL settings 
 the exynos4 soc type 
 list of PLLs to be registered 
 number of PLLs 
  list of controller registers to be saved and restored during a
  suspendresume cycle.
 list of all parent clock list 
 Exynos 4210-specific parent groups 
 Exynos 4x12-specific parent groups 
 fixed rate clocks generated outside the soc 
 fixed rate clocks generated inside the soc 
 list of mux clocks supported in all exynos4 soc's 
 list of mux clocks supported in exynos4210 soc 
 list of mux clocks supported in exynos4x12 soc 
 list of divider clocks supported in all exynos4 soc's 
 list of divider clocks supported in exynos4210 soc 
 list of divider clocks supported in exynos4x12 soc 
 list of gate clocks supported in all exynos4 soc's 
 list of gate clocks supported in exynos4210 soc 
 list of gate clocks supported in exynos4x12 soc 
  The parent of the fin_pll clock is selected by the XOM[0] bit. This bit
  resides in chipid register space, outside of the clock controller memory
  mapped space. So to determine the parent of fin_pll clock, the chipid
  controller is first remapped and the value of XOM[0] bit is read to
  determine the parent clock.
 PLLs PMS values 
 sentinel  }
 sentinel  }
 sentinel  }
 sentinel  }
 sentinel  }
 sentinel  }
	
	  Enable arm clock down (in idle) and set arm divider
	  ratios in WFIWFE state.
 On Exynos4412 enable it also on core 2 and 3 
	
	  Disable the clock up feature in case it was enabled by bootloader.
 register exynos4 clocks 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013 Tomasz Figa <tomasz.figa at gmail.com>
  Common Clock Framework support for all S3C64xx SoCs.
 S3C64xx clock controller register offsets. 
 Helper macros to define clock arrays. 
 Helper macros for gate types present on S3C64xx. 
  List of controller registers to be saved and restored during
  a suspendresume cycle.
 List of parent clocks common for all S3C64xx SoCs. 
 S3C6400-specific parent clocks. 
 S3C6410-specific parent clocks. 
 Fixed rate clocks generated outside the SoC. 
 Fixed rate clocks generated inside the SoC. 
 List of clock muxes present on all S3C64xx SoCs. 
 List of clock muxes present on S3C6400. 
 List of clock muxes present on S3C6410. 
 List of clock dividers present on all S3C64xx SoCs. 
 List of clock dividers present on S3C6400. 
 List of clock dividers present on S3C6410. 
 List of clock gates present on all S3C64xx SoCs. 
 List of clock gates present on S3C6400. 
 List of clock gates present on S3C6410. 
 List of PLL clocks. 
 Aliases for common s3c64xx clocks. 
 Aliases for s3c6400-specific clocks. 
 Nothing to place here yet. 
 Aliases for s3c6410-specific clocks. 
 Register s3c64xx clocks. 
 Register external clocks. 
 Register PLLs. 
 Register common internal clocks. 
 Register SoC-specific clocks. 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013 Samsung Electronics Co., Ltd.
  Authors: Thomas Abraham <thomas.ab@samsung.com>
 	    Chander Kashyap <k.chander@samsung.com>
  Common Clock Framework support for Exynos5420 SoC.
 5800 specific 
 5800 specific 
 5800 specific 
 5800 specific 
 5800 specific 
 5800 specific 
 5800 specific 
 5800 specific 
 Exynos5x SoC type 
 list of PLLs 
 number of PLLs 
  list of controller registers to be saved and restored during a
  suspendresume cycle.
 list of all parent clocks 
 List of parents specific to exynos5800 
 fixed rate clocks generated outside the soc 
 fixed rate clocks generated inside the soc 
 Maudio Block 
 DISP1 Block 
 CDREX block 
 MAU Block 
 FSYS Block 
 PERIC Block 
 ISP Block 
 DISP1 Block 
 CDREX Block 
	
	  The three clocks below are controlled using the same register and
	  bits. They are put into one because there is a need of
	  synchronization between the BUS and DREXs (two external memory
	  interfaces).
	  They are put here to show this HW assumption and for clock
	  information summary completeness.
 Audio Block 
 USB3.0 
 MMC 
 UART and PWM 
 SPI 
 PCM 
 Audio - I2S 
 SPI Pre-Ratio 
 GSCL Block 
 PSGEN 
 ISP Block 
 G2D 
 sclk 
 Display 
 FSYS Block 
 PERIC Block 
 PERIS Block 
 GEN Block 
 GATE_IP_GEN doesn't list gates for smmu_jpeg2 and mc 
 GSCL Block 
 ISP 
 CDREX 
 DISP1 gates 
 MUX mout_user_aclk400_disp1 
 MUX mout_user_aclk300_disp1 
 MUX mout_user_aclk200_disp1 
 DIV dout_disp1_blk 
 GSC gates 
 GSC gates 
 MUX mout_user_aclk300_gscl 
 DIV dout_gscl_blk_300 
 G3D gates 
 MUX mout_user_aclk_g3d 
 MFC gates 
 MUX mout_user_aclk333 
 DIV dout_mfc_blk 
 MSCL Block 
 MSCL gates 
 MUX mout_user_aclk400_mscl 
 DIV dout_mscl_blk 
 MUX mout_user_mau_epll 
 for Exynos5800 
 register exynos5420 clocks 
	
	  Keep top part of G3D clock path enabled permanently to ensure
	  that the internal busses get their clock regardless of the
	  main G3D clock enablement status.
	
	  Keep top BPLL mux enabled permanently to ensure that DRAM operates
	  properly.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013 Heiko Stuebner <heiko@sntech.de>
  Common Clock Framework support for S3C2412 and S3C2413.
  list of controller registers to be saved and restored during a
  suspendresume cycle.
 sentinel  },
  The first two use the OM[4] setting, which is not readable from
  software, so assume it is set to xti.
	 errata "Watch-dogSoftware Reset Problem" specifies that
	  this reset must be done with the SYSCLK sourced from
	  EXTCLK instead of FOUT to avoid a glitch in the reset
	  mechanism.
	 
	  See the watchdog section of the S3C2412 manual for more
	  information on this fix.
  fixed rate clocks generated outside the soc
  Only necessary until the devicetree-move is complete
 xtal alias is necessary for the current cpufreq driver 
 Register external clocks only in non-dt cases 
 Register PLLs. 
 Register common internal clocks. 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013 Heiko Stuebner <heiko@sntech.de>
  Common Clock Framework support for S3C2410 and following SoCs.
 the soc types 
 list of PLLs to be registered 
  list of controller registers to be saved and restored during a
  suspendresume cycle.
 sentinel  },
 should be added _after_ the soc-specific clocks are created 
 S3C2410 specific clocks 
 sorted in descending order 
 2410A extras 
 2410 common 
 sentinel  },
	
	  armclk is directly supplied by the fclk, without
	  switching possibility like on the s3c244x below.
 uclk is fed from the unmodified upll 
 S3C244x specific clocks 
 sorted in descending order 
 sentinel  },
 sentinel  },
 sentinel  },
 S3C2440 specific clocks 
 S3C2442 specific clocks 
  fixed rate clocks generated outside the soc
  Only necessary until the devicetree-move is complete
 Register external clocks only in non-dt cases 
 Register PLLs. 
 S3C2440, S3C2442 
			
			  plls follow different calculation schemes, with the
			  upll following the same scheme as the s3c2410 plls
 Register PLLs. 
 Register common internal clocks. 
 Register SoC-specific clocks. 
	
	  Register common aliases at the end, as some of the aliased clocks
	  are SoC specific.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 Samsung Electronics Co., Ltd.
  Common Clock Framework support for Exynos3250 SoC.
 Below definitions are used for PWR_CTRL settings 
 list of all parent clock list 
 HACK: fin_pll hardcoded to xusbxti until detection is implemented. 
	
	  NOTE: Following table is sorted by register address in ascending
	  order and then bitfield shift in descending order, as it is done
	  in the User's Manual. When adding new entries, please make sure
	  that the order is preserved, to avoid merge conflicts and make
	  further work with defined data easier.
 SRC_LEFTBUS 
 SRC_RIGHTBUS 
 SRC_TOP0 
 SRC_TOP1 
 SRC_CAM 
 SRC_MFC 
 SRC_G3D 
 SRC_LCD 
 SRC_ISP 
 SRC_FSYS 
 SRC_PERIL0 
 SRC_PERIL1 
 SRC_CPU 
	
	  NOTE: Following table is sorted by register address in ascending
	  order and then bitfield shift in descending order, as it is done
	  in the User's Manual. When adding new entries, please make sure
	  that the order is preserved, to avoid merge conflicts and make
	  further work with defined data easier.
 DIV_LEFTBUS 
 DIV_RIGHTBUS 
 DIV_TOP 
 DIV_CAM 
 DIV_MFC 
 DIV_G3D 
 DIV_LCD 
 DIV_ISP 
 DIV_FSYS0 
 DIV_FSYS1 
 DIV_FSYS2 
 DIV_PERIL0 
 DIV_PERIL1 
 DIV_PERIL4 
 DIV_PERIL5 
 DIV_CPU0 
 DIV_CPU1 
	
	  NOTE: Following table is sorted by register address in ascending
	  order and then bitfield shift in descending order, as it is done
	  in the User's Manual. When adding new entries, please make sure
	  that the order is preserved, to avoid merge conflicts and make
	  further work with defined data easier.
 GATE_IP_LEFTBUS 
 GATE_IP_RIGHTBUS 
 GATE_IP_PERIR 
 GATE_SCLK_CAM 
 GATE_SCLK_MFC 
 GATE_SCLK_G3D 
 GATE_SCLK_LCD 
 GATE_SCLK_ISP_TOP 
 GATE_SCLK_FSYS 
 GATE_SCLK_PERIL 
 GATE_IP_CAM 
 GATE_IP_MFC 
 GATE_IP_G3D 
 GATE_IP_LCD 
 GATE_IP_ISP 
 GATE_IP_FSYS 
 GATE_IP_PERIL 
 APLL & MPLL & BPLL & UPLL 
 sentinel  }
 EPLL 
 sentinel  }
 VPLL 
 sentinel  }
	
	  Enable arm clock down (in idle) and set arm divider
	  ratios in WFIWFE state.
	
	  Disable the clock up feature on Exynos4x12, in case it was
	  enabled by bootloader.
  CMU DMC
	
	  NOTE: Following table is sorted by register address in ascending
	  order and then bitfield shift in descending order, as it is done
	  in the User's Manual. When adding new entries, please make sure
	  that the order is preserved, to avoid merge conflicts and make
	  further work with defined data easier.
 SRC_DMC 
 SRC_EPLL 
	
	  NOTE: Following table is sorted by register address in ascending
	  order and then bitfield shift in descending order, as it is done
	  in the User's Manual. When adding new entries, please make sure
	  that the order is preserved, to avoid merge conflicts and make
	  further work with defined data easier.
 DIV_DMC1 
  CMU ISP
	
	  NOTE: Following table is sorted by register address in ascending
	  order and then bitfield shift in descending order, as it is done
	  in the User's Manual. When adding new entries, please make sure
	  that the order is preserved, to avoid merge conflicts and make
	  further work with defined data easier.
 DIV_ISP0 
 DIV_ISP1 
	
	  NOTE: Following table is sorted by register address in ascending
	  order and then bitfield shift in descending order, as it is done
	  in the User's Manual. When adding new entries, please make sure
	  that the order is preserved, to avoid merge conflicts and make
	  further work with defined data easier.
 GATE_IP_ISP0 
 GATE_IP_ISP1 
 GATE_SCLK_ISP 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Samsung Electronics Co., Ltd.
 Author: Marek Szyprowski <m.szyprowski@samsung.com>
 Common Clock Framework support for Exynos5 power-domain dependent clocks
  Pass the needed clock provider context and register sub-CMU clocks
  NOTE: This function has to be called from the main, OF_CLK_DECLARE-
  initialized clock provider driver. This happens very early during boot
  process. Then this driver, during core_initcall registers two platform
  drivers: one which binds to the same device-tree node as OF_CLK_DECLARE
  driver and second, for handling its per-domain child-devices. Those
  platform drivers are bound to their devices a bit later in arch_initcall,
  when OF-core populates all device-tree nodes.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 Samsung Electronics Co., Ltd.
  Author: Rahul Sharma <rahul.sharma@samsung.com>
  Common Clock Framework support for Exynos5260 SoC.
  Applicable for all 2550 Type PLLS for Exynos5260, listed below
  DISP_PLL, EGL_PLL, KFC_PLL, MEM_PLL, BUS_PLL, MEDIA_PLL, G3D_PLL.
  Applicable for 2650 Type PLL for AUD_PLL.
 CMU_AUD 
 CMU_DISP 
 CMU_EGL 
 CMU_FSYS 
 CMU_G2D 
 CMU_G3D 
 CMU_GSCL 
 CMU_ISP 
 CMU_KFC 
 CMU_MFC 
 CMU_MIF 
 CMU_PERI 
 CMU_TOP 
 fixed rate clocks generated inside the soc 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 Samsung Electronics Co., Ltd.
  Author: Marek Szyprowski <m.szyprowski@samsung.com>
  Common Clock Framework support for Exynos4412 ISP module.
 Exynos4x12 specific registers, which belong to ISP power domain 
  Support for CMU saverestore across system suspends
 SPDX-License-Identifier: GPL-2.0
  Zynq UltraScale+ MPSoC clock controller
   Copyright (C) 2016-2019 Xilinx
  Based on driversclkzynqclkc.c
 Flags for parents 
  struct clock_parent - Clock parent
  @name:	Parent name
  @id:		Parent clock ID
  @flag:	Parent flags
  struct zynqmp_clock - Clock
  @clk_name:		Clock name
  @valid:		Validity flag of clock
  @type:		Clock type (OutputExternal)
  @node:		Clock topology nodes
  @num_nodes:		Number of nodes present in topology
  @parent:		Parent of clock
  @num_parents:	Number of parents of clock
  @clk_id:		Clock id
  zynqmp_is_valid_clock() - Check whether clock is valid or not
  @clk_id:	Clock index
  Return: 1 if clock is valid, 0 if clock is invalid else error code
  zynqmp_get_clock_name() - Get name of clock from Clock index
  @clk_id:	Clock index
  @clk_name:	Name of clock
  Return: 0 on success else error code
  zynqmp_get_clock_type() - Get type of clock
  @clk_id:	Clock index
  @type:	Clock type: CLK_TYPE_OUTPUT or CLK_TYPE_EXTERNAL
  Return: 0 on success else error code
  zynqmp_pm_clock_get_num_clocks() - Get number of clocks in system
  @nclocks:	Number of clocks in systemboard.
  Call firmware API to get number of clocks.
  Return: 0 on success else error code.
  zynqmp_pm_clock_get_name() - Get the name of clock for given id
  @clock_id:	ID of the clock to be queried
  @response:	Name of the clock with the given id
  This function is used to get name of clock specified by given
  clock ID.
  Return: Returns 0
  zynqmp_pm_clock_get_topology() - Get the topology of clock for given id
  @clock_id:	ID of the clock to be queried
  @index:	Node index of clock topology
  @response:	Buffer used for the topology response
  This function is used to get topology information for the clock
  specified by given clock ID.
  This API will return 3 node of topology with a single response. To get
  other nodes, master should call same API in loop with new
  index till error is returned. E.g First call should have
  index 0 which will return nodes 0,1 and 2. Next call, index
  should be 3 which will return nodes 3,4 and 5 and so on.
  Return: 0 on success else error+reason
  zynqmp_clk_register_fixed_factor() - Register fixed factor with the
 					clock framework
  @name:		Name of this clock
  @clk_id:		Clock ID
  @parents:		Name of this clock's parents
  @num_parents:	Number of parents
  @nodes:		Clock topology node
  Return: clock hardware to the registered clock
  zynqmp_pm_clock_get_parents() - Get the first 3 parents of clock for given id
  @clock_id:	Clock ID
  @index:	Parent index
  @response:	Parents of the given clock
  This function is used to get 3 parents for the clock specified by
  given clock ID.
  This API will return 3 parents with a single response. To get
  other parents, master should call same API in loop with new
  parent index till error is returned. E.g First call should have
  index 0 which will return parents 0,1 and 2. Next call, index
  should be 3 which will return parent 3,4 and 5 and so on.
  Return: 0 on success else error+reason
  zynqmp_pm_clock_get_attributes() - Get the attributes of clock for given id
  @clock_id:	Clock ID
  @response:	Clock attributes response
  This function is used to get clock's attributes(e.g. valid, clock type, etc).
  Return: 0 on success else error+reason
  __zynqmp_clock_get_topology() - Get topology data of clock from firmware
 				   response data
  @topology:		Clock topology
  @response:		Clock topology data received from firmware
  @nnodes:		Number of nodes
  Return: 0 on success else error+reason
  zynqmp_clock_get_topology() - Get topology of clock from firmware using
 				 PM_API
  @clk_id:		Clock index
  @topology:		Clock topology
  @num_nodes:		Number of nodes
  Return: 0 on success else error+reason
  __zynqmp_clock_get_parents() - Get parents info of clock from firmware
 				   response data
  @parents:		Clock parents
  @response:		Clock parents data received from firmware
  @nparent:		Number of parent
  Return: 0 on success else error+reason
  zynqmp_clock_get_parents() - Get parents info from firmware using PM_API
  @clk_id:		Clock index
  @parents:		Clock parents
  @num_parents:	Total number of parents
  Return: 0 on success else error+reason
 Get parents from firmware 
  zynqmp_get_parent_list() - Create list of parents name
  @np:			Device node
  @clk_id:		Clock index
  @parent_list:	List of parent's name
  @num_parents:	Total number of parents
  Return: 0 on success else error+reason
  zynqmp_register_clk_topology() - Register clock topology
  @clk_id:		Clock index
  @clk_name:		Clock Name
  @num_parents:	Total number of parents
  @parent_names:	List of parents name
  Return: Returns either clock hardware or error+reason
		
		  Clock name received from firmware is output clock name.
		  Intermediate clock names are postfixed with type of clock.
  zynqmp_register_clocks() - Register clocks
  @np:		Device node
  Return: 0 on success else error code
 get clock name, continue to next clock if name not found 
		 Check if clock is valid and output clock.
		  Do not register invalid or external clock.
 Get parents of clock
  zynqmp_get_clock_info() - Get clock information from firmware using PM_API
 skip query for Invalid clock 
 Get topology of all clock 
  zynqmp_clk_setup() - Setup the clock framework and register clocks
  @np:		Device node
  Return: 0 on success else error code
 SPDX-License-Identifier: GPL-2.0
  Zynq UltraScale+ MPSoC clock controller
   Copyright (C) 2016-2018 Xilinx
  Gated clock implementation
  struct zynqmp_clk_gate - gating clock
  @hw:		handle between common and hardware-specific interfaces
  @flags:	hardware-specific flags
  @clk_id:	Id of clock
  zynqmp_clk_gate_enable() - Enable clock
  @hw:		handle between common and hardware-specific interfaces
  Return: 0 on success else error code
  zynqmp_clk_gate_disable() - Disable clock
  @hw:		handle between common and hardware-specific interfaces
  zynqmp_clk_gate_is_enabled() - Check clock state
  @hw:		handle between common and hardware-specific interfaces
  Return: 1 if enabled, 0 if disabled else error code
  zynqmp_clk_register_gate() - Register a gate clock with the clock framework
  @name:		Name of this clock
  @clk_id:		Id of this clock
  @parents:		Name of this clock's parents
  @num_parents:	Number of parents
  @nodes:		Clock topology node
  Return: clock hardware of the registered clock gate
 allocate the gate 
 struct clk_gate assignments 
 SPDX-License-Identifier: GPL-2.0
  Zynq UltraScale+ MPSoC PLL driver
   Copyright (C) 2016-2018 Xilinx
  struct zynqmp_pll - PLL clock
  @hw:		Handle between common and hardware-specific interfaces
  @clk_id:	PLL clock ID
  @set_pll_mode:	Whether an IOCTL_SET_PLL_FRAC_MODE request be sent to ATF
 2^16 
  zynqmp_pll_get_mode() - Get mode of PLL
  @hw:		Handle between common and hardware-specific interfaces
  Return: Mode of PLL
  zynqmp_pll_set_mode() - Set the PLL mode
  @hw:		Handle between common and hardware-specific interfaces
  @on:		Flag to determine the mode
  zynqmp_pll_round_rate() - Round a clock frequency
  @hw:		Handle between common and hardware-specific interfaces
  @rate:	Desired clock frequency
  @prate:	Clock frequency of parent clock
  Return: Frequency closest to @rate the hardware can generate
 Enable the fractional mode if needed 
  zynqmp_pll_recalc_rate() - Recalculate clock frequency
  @hw:			Handle between common and hardware-specific interfaces
  @parent_rate:	Clock frequency of parent clock
  Return: Current clock frequency or 0 in case of error
  zynqmp_pll_set_rate() - Set rate of PLL
  @hw:			Handle between common and hardware-specific interfaces
  @rate:		Frequency of clock to be set
  @parent_rate:	Clock frequency of parent clock
  Set PLL divider to set desired rate.
  Returns:            rate which is set on success else error code
  zynqmp_pll_is_enabled() - Check if a clock is enabled
  @hw:		Handle between common and hardware-specific interfaces
  Return: 1 if the clock is enabled, 0 otherwise
  zynqmp_pll_enable() - Enable clock
  @hw:		Handle between common and hardware-specific interfaces
  Return: 0 on success else error code
	
	  Don't skip enabling clock if there is an IOCTL_SET_PLL_FRAC_MODE request
	  that has been sent to ATF.
  zynqmp_pll_disable() - Disable clock
  @hw:		Handle between common and hardware-specific interfaces
  zynqmp_clk_register_pll() - Register PLL with the clock framework
  @name:		PLL name
  @clk_id:		Clock ID
  @parents:		Name of this clock's parents
  @num_parents:	Number of parents
  @nodes:		Clock topology node
  Return: clock hardware to the registered clock
 SPDX-License-Identifier: GPL-2.0
  Zynq UltraScale+ MPSoC mux
   Copyright (C) 2016-2018 Xilinx
  DOC: basic adjustable multiplexer clock that cannot gate
  Traits of this clock:
  prepare - clk_prepare only ensures that parents are prepared
  enable - clk_enable only ensures that parents are enabled
  rate - rate is only affected by parent switching.  No clk_set_rate support
  parent - parent is adjustable through clk_set_parent
  struct zynqmp_clk_mux - multiplexer clock
  @hw:		handle between common and hardware-specific interfaces
  @flags:	hardware-specific flags
  @clk_id:	Id of clock
  zynqmp_clk_mux_get_parent() - Get parent of clock
  @hw:		handle between common and hardware-specific interfaces
  Return: Parent index on success or number of parents in case of error
		
		  clk_core_get_parent_by_index() takes num_parents as incorrect
		  index which is exactly what I want to return here
  zynqmp_clk_mux_set_parent() - Set parent of clock
  @hw:		handle between common and hardware-specific interfaces
  @index:	Parent index
  Return: 0 on success else error+reason
  zynqmp_clk_register_mux() - Register a mux table with the clock
 			       framework
  @name:		Name of this clock
  @clk_id:		Id of this clock
  @parents:		Name of this clock's parents
  @num_parents:	Number of parents
  @nodes:		Clock topology node
  Return: clock hardware of the registered clock mux
 SPDX-License-Identifier: GPL-2.0
  Zynq UltraScale+ MPSoC Divider support
   Copyright (C) 2016-2019 Xilinx
  Adjustable divider clock implementation
  DOC: basic adjustable divider clock that cannot gate
  Traits of this clock:
  prepare - clk_prepare only ensures that parents are prepared
  enable - clk_enable only ensures that parents are enabled
  rate - rate is adjustable.  clk->rate = ceiling(parent->rate  divisor)
  parent - fixed parent.  No clk_set_parent support
 has a fractional parent 
 has a fractional parent in custom type flag 
  struct zynqmp_clk_divider - adjustable divider clock
  @hw:		handle between common and hardware-specific interfaces
  @flags:	Hardware specific flags
  @is_frac:	The divider is a fractional divider
  @clk_id:	Id of clock
  @div_type:	divisor type (TYPE_DIV1 or TYPE_DIV2)
  @max_div:	maximum supported divisor (fetched from firmware)
  zynqmp_clk_divider_recalc_rate() - Recalc rate of divider clock
  @hw:			handle between common and hardware-specific interfaces
  @parent_rate:	rate of parent clock
  Return: 0 on success else error+reason
  zynqmp_clk_divider_round_rate() - Round rate of divider clock
  @hw:			handle between common and hardware-specific interfaces
  @rate:		rate of clock to be set
  @prate:		rate of parent clock
  Return: 0 on success else error+reason
 if read only, just return current value 
	
	  In case of two divisors, compute best divider values and return
	  divider2 value based on compute value. div1 will  be automatically
	  set to optimum based on required total divider value.
  zynqmp_clk_divider_set_rate() - Set rate of divider clock
  @hw:			handle between common and hardware-specific interfaces
  @rate:		rate of clock to be set
  @parent_rate:	rate of parent clock
  Return: 0 on success else error+reason
  zynqmp_clk_get_max_divisor() - Get maximum supported divisor from firmware.
  @clk_id:		Id of clock
  @type:		Divider type
  Return: Maximum divisor of a clock if query data is successful
 	   U16_MAX in case of query data is not success
	
	  To maintain backward compatibility return maximum possible value
	  (0xFFFF) if query for max divisor is not successful.
  zynqmp_clk_register_divider() - Register a divider clock
  @name:		Name of this clock
  @clk_id:		Id of clock
  @parents:		Name of this clock's parents
  @num_parents:	Number of parents
  @nodes:		Clock topology node
  Return: clock hardware to registered clock divider
 allocate the divider 
 struct clk_divider assignments 
	
	  To achieve best possible rate, maximum limit of divider is required
	  while computation.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020 SiFive, Inc.
  Copyright (C) 2020 Zong Li
 PRCI integration data for each WRPLL instance 
 Linux clock framework integration 
 List of clock controls provided by the PRCI 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020 SiFive, Inc.
  Copyright (C) 2020 Zong Li
  Private functions
  __prci_readl() - read from a PRCI register
  @pd: PRCI context
  @offs: register offset to read from (in bytes, from PRCI base address)
  Read the register located at offset @offs from the base virtual
  address of the PRCI register target described by @pd, and return
  the value to the caller.
  Context: Any context.
  Return: the contents of the register described by @pd and @offs.
 WRPLL-related private functions 
  __prci_wrpll_unpack() - unpack WRPLL configuration registers into parameters
  @c: ptr to a struct wrpll_cfg record to write config into
  @r: value read from the PRCI PLL configuration register
  Given a value @r read from an FU740 PRCI PLL configuration register,
  split it into fields and populate it into the WRPLL configuration record
  pointed to by @c.
  The COREPLLCFG0 macros are used below, but the other PLLCFG0 macros
  have the same register layout.
  Context: Any context.
 external feedback mode not supported 
  __prci_wrpll_pack() - pack PLL configuration parameters into a register value
  @c: pointer to a struct wrpll_cfg record containing the PLL's cfg
  Using a set of WRPLL configuration values pointed to by @c,
  assemble a PRCI PLL configuration register value, and return it to
  the caller.
  Context: Any context.  Caller must ensure that the contents of the
           record pointed to by @c do not change during the execution
           of this function.
  Returns: a value suitable for writing into a PRCI PLL configuration
           register
 external feedback mode not supported 
  __prci_wrpll_read_cfg0() - read the WRPLL configuration from the PRCI
  @pd: PRCI context
  @pwd: PRCI WRPLL metadata
  Read the current configuration of the PLL identified by @pwd from
  the PRCI identified by @pd, and store it into the local configuration
  cache in @pwd.
  Context: Any context.  Caller must prevent the records pointed to by
           @pd and @pwd from changing during execution.
  __prci_wrpll_write_cfg0() - write WRPLL configuration into the PRCI
  @pd: PRCI context
  @pwd: PRCI WRPLL metadata
  @c: WRPLL configuration record to write
  Write the WRPLL configuration described by @c into the WRPLL
  configuration register identified by @pwd in the PRCI instance
  described by @c.  Make a cached copy of the WRPLL's current
  configuration so it can be used by other code.
  Context: Any context.  Caller must prevent the records pointed to by
           @pd and @pwd from changing during execution.
  __prci_wrpll_write_cfg1() - write Clock enabledisable configuration
  into the PRCI
  @pd: PRCI context
  @pwd: PRCI WRPLL metadata
  @enable: Clock enable or disable value
  Linux clock framework integration
  See the Linux clock framework documentation for more information on
  these functions.
 TLCLKSEL clock integration 
 HFPCLK clock integration 
  Core clock mux control
  sifive_prci_coreclksel_use_hfclk() - switch the CORECLK mux to output HFCLK
  @pd: struct __prci_data  for the PRCI containing the CORECLK mux reg
  Switch the CORECLK mux to the HFCLK input source; return once complete.
  Context: Any context.  Caller must prevent concurrent changes to the
           PRCI_CORECLKSEL_OFFSET register.
 barrier 
  sifive_prci_coreclksel_use_corepll() - switch the CORECLK mux to output
  COREPLL
  @pd: struct __prci_data  for the PRCI containing the CORECLK mux reg
  Switch the CORECLK mux to the COREPLL output clock; return once complete.
  Context: Any context.  Caller must prevent concurrent changes to the
           PRCI_CORECLKSEL_OFFSET register.
 barrier 
  sifive_prci_coreclksel_use_final_corepll() - switch the CORECLK mux to output
  FINAL_COREPLL
  @pd: struct __prci_data  for the PRCI containing the CORECLK mux reg
  Switch the CORECLK mux to the final COREPLL output clock; return once
  complete.
  Context: Any context.  Caller must prevent concurrent changes to the
           PRCI_CORECLKSEL_OFFSET register.
 barrier 
  sifive_prci_corepllsel_use_dvfscorepll() - switch the COREPLL mux to
  output DVFS_COREPLL
  @pd: struct __prci_data  for the PRCI containing the COREPLL mux reg
  Switch the COREPLL mux to the DVFSCOREPLL output clock; return once complete.
  Context: Any context.  Caller must prevent concurrent changes to the
           PRCI_COREPLLSEL_OFFSET register.
 barrier 
  sifive_prci_corepllsel_use_corepll() - switch the COREPLL mux to
  output COREPLL
  @pd: struct __prci_data  for the PRCI containing the COREPLL mux reg
  Switch the COREPLL mux to the COREPLL output clock; return once complete.
  Context: Any context.  Caller must prevent concurrent changes to the
           PRCI_COREPLLSEL_OFFSET register.
 barrier 
  sifive_prci_hfpclkpllsel_use_hfclk() - switch the HFPCLKPLL mux to
  output HFCLK
  @pd: struct __prci_data  for the PRCI containing the HFPCLKPLL mux reg
  Switch the HFPCLKPLL mux to the HFCLK input source; return once complete.
  Context: Any context.  Caller must prevent concurrent changes to the
           PRCI_HFPCLKPLLSEL_OFFSET register.
 barrier 
  sifive_prci_hfpclkpllsel_use_hfpclkpll() - switch the HFPCLKPLL mux to
  output HFPCLKPLL
  @pd: struct __prci_data  for the PRCI containing the HFPCLKPLL mux reg
  Switch the HFPCLKPLL mux to the HFPCLKPLL output clock; return once complete.
  Context: Any context.  Caller must prevent concurrent changes to the
           PRCI_HFPCLKPLLSEL_OFFSET register.
 barrier 
 PCIE AUX clock APIs for enable, disable. 
 barrier 
 barrier 
  __prci_register_clocks() - register clock controls in the PRCI
  @dev: Linux struct device
  @pd: The pointer for PRCI per-device instance data
  @desc: The pointer for the information of clocks of each SoCs
  Register the list of clock controls described in __prci_init_clocks[] with
  the Linux clock framework.
  Return: 0 upon success or a negative error code upon failure.
 Register PLLs 
  sifive_prci_probe() - initialize prci data and check parent count
  @pdev: platform device pointer for the prci
  Return: 0 upon success or a negative error code upon failure.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018-2019 SiFive, Inc.
  Copyright (C) 2018-2019 Wesley Terpstra
  Copyright (C) 2018-2019 Paul Walmsley
  Copyright (C) 2020 Zong Li
  The FU540 PRCI implements clock and reset control for the SiFive
  FU540-C000 chip.  This driver assumes that it has sole control
  over all PRCI resources.
  This driver is based on the PRCI driver written by Wesley Terpstra:
  https:github.comriscvriscv-linuxcommit999529edf517ed75b56659d456d221b2ee56bb60
  References:
  - SiFive FU540-C000 manual v1p0, Chapter 7 "Clocking and Reset"
 PRCI integration data for each WRPLL instance 
 Linux clock framework integration 
 List of clock controls provided by the PRCI 
 SPDX-License-Identifier: GPL-2.0
  MStar MSC313 MPLL driver
  Copyright (C) 2020 Daniel Palmer <daniel@thingy.jp>
  pxa910 clock framework source file
  Copyright (C) 2012 Marvell
  Chao Xie <xiechao.mail@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
14.745MHZ 
 The gate clocks has mux parent. 
 The gate clocks has mux parent. 
 The gate clocks has mux parent. 
 SPDX-License-Identifier: GPL-2.0
  mmp APB clock operation source file
  Copyright (C) 2012 Marvell
  Chao Xie <xiechao.mail@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 Common APB clock register bit definitions 
 APB Bus Clock Enable 
 Functional Clock Enable 
 Reset Generation 
 Reset Generation 
	
	  It may share same register as MUX clock,
	  and it will impact FNCLK enable. Spinlock is needed
  mmp2 clock framework source file
  Copyright (C) 2012 Marvell
  Chao Xie <xiechao.mail@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
14.745MHZ 
19.23MHZ 
  mmp factor clock operation source file
  Copyright (C) 2012 Marvell
  Chao Xie <xiechao.mail@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  It is MN clock
  Fout from synthesizer can be given from two equations:
  numeratordenominator = Fin  (Fout  factor)
 calculate numerator 
 calculate denominator 
 Configures new clock rate
 calculate numerator 
 calculate denominator 
 struct clk_aux assignments 
 SPDX-License-Identifier: GPL-2.0-or-later
  MMP PLL clock rate calculation
  Copyright (C) 2020 Lubomir Rintel <lkundrak@v3.sk>
 Some PLLs, if not software controlled, output default clock. 
 MMP3 clock rate calculation 
 MMP2 clock rate calculation 
  mmp AXI peripharal clock operation source file
  Copyright (C) 2012 Marvell
  Chao Xie <xiechao.mail@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  pxa1928 clock framework source file
  Copyright (C) 2015 Linaro, Ltd.
  Rob Herring <robh@kernel.org>
  Based on driversclkmmpclk-of-mmp2.c:
  Copyright (C) 2012 Marvell
  Chao Xie <xiechao.mail@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
58.5MHZ 
26MHZ 
 The gate clocks has mux parent. 
 The gate clocks has mux parent. 
  mmp mix(div and mux) clock operation source file
  Copyright (C) 2014 Marvell
  Chao Xie <chao.xie@marvell.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  The mix clock is a clock combined mux and div type clock.
  Because the div field and mux field need to be set at same
  time, we can not divide it into 2 types of clock
  pxa910 clock framework source file
  Copyright (C) 2012 Marvell
  Chao Xie <xiechao.mail@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
14.745MHZ 
  pxa168 clock framework source file
  Copyright (C) 2012 Marvell
  Chao Xie <xiechao.mail@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
14.745MHZ 
  mmp2 clock framework source file
  Copyright (C) 2012 Marvell
  Chao Xie <xiechao.mail@gmail.com>
  Copyright (C) 2020 Lubomir Rintel <lkundrak@v3.sk>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 MMP3 specific below 
14.745MHZ 
19.23MHZ 
  2.0480 MHz 
  2.8224 MHz 
  4.0960 MHz 
  5.6448 MHz 
  8.1920 MHz 
 11.2896 MHz 
 12.2880 MHz 
 22.5792 MHz 
 24.5760 MHz 
 The gate clocks has mux parent. 
 The gate clocks has mux parent. 
 SPDX-License-Identifier: GPL-2.0-or-later
  MMP PMU power island support
  Copyright (C) 2020 Lubomir Rintel <lkundrak@v3.sk>
 Turn on the power island 
 Disable isolation 
 Some blocks need to be reset after a power up 
 Turn off and isolate the the power island. 
  mmp gate clock operation source file
  Copyright (C) 2014 Marvell
  Chao Xie <chao.xie@marvell.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  Some clocks will have mutiple bits to enable the clocks, and
  the bits to disable the clock is not same as enabling bits.
 Need delay 2 cycles. 
 allocate the gate 
 struct clk_gate assignments 
 SPDX-License-Identifier: GPL-2.0
  pxa168 clock framework source file
  Copyright (C) 2012 Marvell
  Chao Xie <xiechao.mail@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
14.745MHZ 
 The gate clocks has mux parent. 
 The gate clocks has mux parent. 
 SPDX-License-Identifier: GPL-2.0-or-later
  MMP Audio Clock Controller driver
  Copyright (C) 2020 Lubomir Rintel <lkundrak@v3.sk>
 Audio Controller Registers 
 SSPA Audio Control Register 
 SSPA Audio PLL Control 0 Register 
 SSPA Audio PLL Control 1 Register 
 Must be last 
 SPDX-License-Identifier: GPL-2.0-or-later
  Hisilicon clock driver
  Copyright (c) 2012-2013 Hisilicon Limited.
  Copyright (c) 2012-2013 Linaro Limited.
  Author: Haojian Zhuang <haojian.zhuang@linaro.org>
 	   Xin Li <li.xin@linaro.org>
 SPDX-License-Identifier: GPL-2.0-only
  Hi6220 stub clock driver
  Copyright (c) 2015 Hisilicon Limited.
  Copyright (c) 2015 Linaro Limited.
  Author: Leo Yan <leo.yan@linaro.org>
 Stub clocks id 
 Mailbox message 
 CPU dynamic frequency scaling 
 set the frequency in sram 
 compound mailbox message 
 check the constrained frequency 
 check the supported maximum frequency 
 calculate the real maximum frequency 
 convert from kHz to Hz 
 kHz 
 kHz 
 convert from kHz to Hz 
 Use mailbox client with blocking mode 
 Allocate mailbox channel 
 initialize buffer to zero 
 SPDX-License-Identifier: GPL-2.0-or-later
  Hi3519 Clock Driver
  Copyright (c) 2015-2016 HiSilicon Technologies Co., Ltd.
 SPDX-License-Identifier: GPL-2.0-only
  Hisilicon Hi6220 clock driver
  Copyright (c) 2015 Hisilicon Limited.
  Author: Bintian Wang <bintian.wang@huawei.com>
 clocks in AO (always on) controller 
 Allow reset driver to probe as well 
 clocks in sysctrl 
 clocks in media controller 
 clocks in pmctrl 
 clocks in acpu 
 SPDX-License-Identifier: GPL-2.0-or-later
  Hisilicon Hi3620 clock driver
  Copyright (c) 2012-2013 Hisilicon Limited.
  Copyright (c) 2012-2013 Linaro Limited.
  Author: Haojian Zhuang <haojian.zhuang@linaro.org>
 	   Xin Li <li.xin@linaro.org>
 clock parent list 
 share axi parent 
 fixed rate clocks 
 fixed factor clocks 
 max is 180M 
 SPDX-License-Identifier: GPL-2.0-or-later
  Hisilicon HiP04 clock driver
  Copyright (c) 2013-2014 Hisilicon Limited.
  Copyright (c) 2013-2014 Linaro Limited.
  Author: Haojian Zhuang <haojian.zhuang@linaro.org>
 fixed rate clocks 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2001-2021, Huawei Tech. Co., Ltd.
  Author: chenjun <chenjun14@huawei.com>
  Copyright (c) 2018, Linaro Ltd.
  Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
 crgctrl 
 clk_pmuctrl 
 clk_pctrl 
 clk_sctrl 
 clk_iomcu 
 clk_media1 
 clk_media2 
 SPDX-License-Identifier: GPL-2.0-or-later
  Hi3516CV300 Clock and Reset Generator Driver
  Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
 hi3516CV300 core CRG 
 hi3516CV300 sysctrl CRG 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 Linaro Ltd.
  Copyright (c) 2014 Hisilicon Limited.
 sfc 
 sdio0 
 sdio1 
 gsf 
 wdg0 
 I2C 
 SPDX-License-Identifier: GPL-2.0-or-later
  Hisilicon clock driver
  Copyright (c) 2013-2017 Hisilicon Limited.
  Copyright (c) 2017 Linaro Limited.
  Author: Kai Zhao <zhaokai1@hisilicon.com>
 	    Tao Wang <kevin.wangtao@hisilicon.com>
 	    Leo Yan <leo.yan@linaro.org>
	
	  LPM3 writes back the CPU frequency in shared SRAM so read
	  back the frequency.
	
	  LPM3 handles rate rounding so just return whatever
	  rate is requested.
 Use mailbox client without blocking 
 Allocate mailbox channel 
 SPDX-License-Identifier: GPL-2.0-only
  Hisilicon hi6220 SoC divider clock driver
  Copyright (c) 2015 Hisilicon Limited.
  Author: Bintian Wang <bintian.wang@huawei.com>
  struct hi6220_clk_divider - divider clock for hi6220
  @hw:		handle between common and hardware-specific interfaces
  @reg:	register containing divider
  @shift:	shift to the divider bit field
  @width:	width of the divider bit field
  @mask:	mask for setting divider rate
  @table:	the div table that the divider supports
  @lock:	register lock
 allocate the divider 
 Init the divider table 
 struct hi6220_clk_divider assignments 
 register the clock 
 SPDX-License-Identifier: GPL-2.0-or-later
  Hisilicon clock separated gate driver
  Copyright (c) 2012-2013 Hisilicon Limited.
  Copyright (c) 2012-2013 Linaro Limited.
  Author: Haojian Zhuang <haojian.zhuang@linaro.org>
 	   Xin Li <li.xin@linaro.org>
 clock separated gate register offset 
 enable register 
 bits in enabledisable register 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2016-2017 Linaro Ltd.
  Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
 crgctrl 
	
	  clk_gate_ufs_subsys is a system bus clock, mark it as critical
	  clock and keep it on for system suspend and resume.
 clk_pmuctrl 
 pmu register need shift 2 bits 
 clk_pctrl 
 clk_sctrl 
 clk_iomcu 
 clk_crgctrl_data initialization failed 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2017 HiSilicon Technologies Co., Ltd.
  Simple HiSilicon phase clock implementation.
 SPDX-License-Identifier: GPL-2.0-only
  Hisilicon Hi3559A clock driver
  Copyright (c) 2019-2020, Huawei Tech. Co., Ltd.
  Author: Dongjiu Geng <gengdongjiu@huawei.com>
 soc clk config 
 rate = 24000000  (fbdiv + frac  (1<<24) )  refdiv  
 shub mux clk 
 shub div clk 
 shub gate clk 
 SSP: 192M2 
 UART: 192M8 
 SPDX-License-Identifier: GPL-2.0-or-later
  Hi3798CV200 Clock and Reset Generator Driver
  Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
 hi3798CV200 core CRG 
 UART 
 I2C 
 SPI 
 SDIO 
 EMMC 
 PCIE
 Ethernet 
 COMBPHY0 
 COMBPHY1 
 USB2 
 USB3 
 hisi_phase_clock is resource managed 
 hi3798CV200 sysctrl CRG 
 SPDX-License-Identifier: GPL-2.0-or-later
  Hisilicon Reset Controller Driver
  Copyright (c) 2015-2016 HiSilicon Technologies Co., Ltd.
 SPDX-License-Identifier: GPL-2.0+
 OWL divider clock driver
 Copyright (c) 2014 Actions Semi Inc.
 Author: David Liu <liuwei@actions-semi.com>
 Copyright (c) 2018 Linaro Ltd.
 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
 SPDX-License-Identifier: GPL-2.0+
  Actions Semi Owl S500 SoC clock driver
  Copyright (c) 2014 Actions Semi Inc.
  Author: David Liu <liuwei@actions-semi.com>
  Copyright (c) 2018 Linaro Ltd.
  Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
  Copyright (c) 2018 LSI-TEC - Caninos Loucos
  Author: Edgar Bernardi Righi <edgar.righi@lsitec.org.br>
 pll clocks 
 bit0 ~ 4 
 bit8: 128 
 mux clock 
 gate clocks 
 divider clocks 
 factor clocks 
 composite clocks 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0+
 OWL composite clock driver
 Copyright (c) 2014 Actions Semi Inc.
 Author: David Liu <liuwei@actions-semi.com>
 Copyright (c) 2018 Linaro Ltd.
 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
	
	  We must report success but we can do so unconditionally because
	  owl_comp_fix_fact_round_rate returns values that ensure this call is
	  a nop.
 mux_ops 
 gate_ops 
 div_ops 
 mux_ops 
 gate_ops 
 fact_ops 
 gate_ops 
 fix_fact_ops 
 mux_ops 
 gate_ops 
 SPDX-License-Identifier: GPL-2.0-or-later
 Actions Semi Owl SoCs Reset Management Unit driver
 Copyright (c) 2018 Linaro Ltd.
 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
	
	  The reset control API expects 0 if reset is not asserted,
	  which is the opposite of what our hardware uses.
 SPDX-License-Identifier: GPL-2.0+
 OWL pll clock driver
 Copyright (c) 2014 Actions Semi Inc.
 Author: David Liu <liuwei@actions-semi.com>
 Copyright (c) 2018 Linaro Ltd.
 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
 fixed frequency 
 fixed frequency 
 fixed frequency 
 SPDX-License-Identifier: GPL-2.0+
  Actions Semi S700 clock driver
  Copyright (c) 2014 Actions Semi Inc.
  Author: David Liu <liuwei@actions-semi.com>
  Author: Pathiban Nallathambi <pn@denx.de>
  Author: Saravanan Sekar <sravanhome@gmail.com>
 pll clocks 
 mux clocks 
 bit0 ~ 4 
 bit8: 128 
 bit0 ~ 3 
 bit8: 7 
 divider clocks 
 gate clocks 
 composite clocks 
CMU_AUDIOPLL 24,1 unused
 for bluetooth pcm communication 
	
	  FIXME: Reset controller registration should be moved to
	  common code, once all SoCs of Owl family supports it.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0+
 OWL common clock driver
 Copyright (c) 2014 Actions Semi Inc.
 Author: David Liu <liuwei@actions-semi.com>
 Copyright (c) 2018 Linaro Ltd.
 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
 SPDX-License-Identifier: GPL-2.0+
 OWL mux clock driver
 Copyright (c) 2014 Actions Semi Inc.
 Author: David Liu <liuwei@actions-semi.com>
 Copyright (c) 2018 Linaro Ltd.
 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
 SPDX-License-Identifier: GPL-2.0+
 OWL gate clock driver
 Copyright (c) 2014 Actions Semi Inc.
 Author: David Liu <liuwei@actions-semi.com>
 Copyright (c) 2018 Linaro Ltd.
 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
 SPDX-License-Identifier: GPL-2.0+
 OWL S900 SoC clock driver
 Copyright (c) 2014 Actions Semi Inc.
 Author: David Liu <liuwei@actions-semi.com>
 Copyright (c) 2018 Linaro Ltd.
 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
 pll clocks 
 mux clocks 
 divider clocks 
 bit0 ~ 4 
 bit8: 128 
 factor clocks 
 gate clocks 
 composite clocks 
  pwm2 may be for backlight, do not gate it
  even it is "unused", because it may be
  enabled at boot stage, and in kernel, driver
  has no effective method to know the real status,
  so, the best way is keeping it as what it was.
	
	  FIXME: Reset controller registration should be moved to
	  common code, once all SoCs of Owl family supports it.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0+
 OWL factor clock driver
 Copyright (c) 2014 Actions Semi Inc.
 Author: David Liu <liuwei@actions-semi.com>
 Copyright (c) 2018 Linaro Ltd.
 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
			
			  It's the most ideal case if the requested rate can be
			  divided from parent clock without any need to change
			  parent rate, so return the divider immediately.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2014 Marvell Technology Group Ltd.
  Alexandre Belloni <alexandre.belloni@free-electrons.com>
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
 BG2Q CPU PLL is not part of global registers 
 overwrite default clock names with DT provided ones 
 simple register PLLs 
 TODO: add BG2Q AVPLL 
	
	  TODO: add reference clock bypass switches:
	  memPLLSWBypass, cpuPLLSWBypass, and sysPLLSWBypass
 clock divider cells 
 clock gate cells 
 cpuclk divider is fixed to 1 
 twdclk is derived from cpu3 
 check for errors on leaf clocks 
 register clk-provider 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2014 Marvell Technology Group Ltd.
  Alexandre Belloni <alexandre.belloni@free-electrons.com>
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
  The output frequency formula for the pll is:
  clkout = fbdiv  refdiv  parent  vcodiv
 copy pll_map to allow __initconst 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2014 Marvell Technology Group Ltd.
  Alexandre Belloni <alexandre.belloni@free-electrons.com>
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
  Clock dividers in Berlin2 SoCs comprise a complex cell to select
  input pll and divider. The virtual structure as it is used in Marvell
  BSP code can be seen as:
                       +---+
  pll0 --------------->| 0 |                   +---+
            +---+      |(B)|--+--------------->| 0 |      +---+
  pll1.0 -->| 0 |  +-->| 1 |  |   +--------+   |(E)|----->| 0 |   +---+
  pll1.1 -->| 1 |  |   +---+  +-->|(C) 1:M |-->| 1 |      |(F)|-->|(G)|->
  ...    -->|(A)|--+          |   +--------+   +---+  +-->| 1 |   +---+
  ...    -->|   |             +-->|(D) 1:3 |----------+   +---+
  pll1.N -->| N |                 +---------
            +---+
  (A) input pll clock mux controlled by               <PllSelect[1:n]>
  (B) input pll bypass mux controlled by              <PllSwitch>
  (C) programmable clock divider controlled by        <Select[1:n]>
  (D) constant div-by-3 clock divider
  (E) programmable clock divider bypass controlled by <Switch>
  (F) constant div-by-3 clock mux controlled by       <D3Switch>
  (G) clock gate controlled by                        <Enable>
  For whatever reason, above control signals come in two flavors:
  - single register dividers with all bits in one register
  - shared register dividers with bits spread over multiple registers
    (including signals for the same cell spread over consecutive registers)
  Also, clock gate and pll mux is not available on every div cell, so
  we have to deal with those, too. We reuse common clock composite driver
  for it.
 index == 0 is PLL_SWITCH 
 index > 0 is PLL_SELECT 
 PLL_SWITCH == 0 is index 0 
 constant divide-by-3 (dominant) 
 divider can be bypassed with DIV_SWITCH == 0 
 clock divider determined by DIV_SELECT 
 copy div_map to allow __initconst 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2014 Marvell Technology Group Ltd.
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
  Alexandre Belloni <alexandre.belloni@free-electrons.com>
  BG2BG2CD SoCs have the following audiovideo IO units:
  audiohd: HDMI TX audio
  audio0:  7.1ch TX
  audio1:  2ch TX
  audio2:  2ch RX
  audio3:  SPDIF TX
  video0:  HDMI video
  video1:  Secondary video
  video2:  SD auxiliary video
  There are no external audio clocks (ACLKI0, ACLKI1) and
  only one external video clock (VCLKI0).
  Currently missing bits and pieces:
  - audio_fast_pll is unknown
  - audiohd_pll is unknown
  - video0_pll is unknown
  - audio[023], audiohd parent pll is assumed to be audio_fast_pll
 overwrite default clock names with DT provided ones 
 simple register PLLs 
 audiovideo VCOs 
 reference clock bypass switches 
 clock muxes 
 clock divider cells 
 clock gate cells 
 twdclk is derived from cpu3 
 check for errors on leaf clocks 
 register clk-provider 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2014 Marvell Technology Group Ltd.
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
  Alexandre Belloni <alexandre.belloni@free-electrons.com>
  Berlin2 SoCs comprise up to two PLLs called AVPLL built upon a
  VCO with 8 channels each, channel 8 is the odd-one-out and does
  not provide muldiv.
  Unfortunately, its registers are not named but just numbered. To
  get in at least some kind of structure, we split each AVPLL into
  the VCOs and each channel into separate clock drivers.
  Also, here and there the VCO registers are a bit different with
  respect to bit shifts. Make sure to add a comment for those.
 BG2BG2CDs VCO_B has an additional shift of 4 for its VCO_CTRL0 reg 
 PLL Charge Pump Current = 10uA  (x + 1) 
 AVPLL VCO frequency: Fvco = (Fref  refdiv)  fbdiv 
	
	  Fch = (Fref  sync2) 
	     (sync1  div_hdmi  div_av1  div_av2  div_av3)
 BG2BG2CDs SYNC1 reg on AVPLL_B channel 1 is shifted by 4 
 Channel 8 has no dividers 
	
	  HDMI divider start at VCO_CTRL11, bit 7; MSB is enable, lower 2 bit
	  determine divider.
	
	  AV1 divider start at VCO_CTRL11, bit 28; MSB is enable, lower 2 bit
	  determine divider.
	
	  AV2 divider start at VCO_CTRL12, bit 18; each 7 bits wide,
	  zero is not a valid value.
	
	  AV3 divider start at VCO_CTRL14, bit 7; each 4 bits wide.
	  AV2AV3 form a fractional divider, where only specfic values for AV3
	  are allowed. AV3 != 0 divides by AV22, AV3=0 is bypass.
  Another nice quirk:
  On some production SoCs, AVPLL channels are scrambled with respect
  to the channel numbering in the registers but still referenced by
  their original channel numbers. We deal with it by having a flag
  and a translation table for the index.
 SPDX-License-Identifier: GPL-2.0-or-later
  Clock driver for Keystone 2 based devices
  Copyright (C) 2013 Texas Instruments.
 	Murali Karicheri <m-karicheri2@ti.com>
 	Santosh Shilimkar <santosh.shilimkar@ti.com>
 PSC register offsets 
 PSC module states 
 Maximum timeout to bail out state transition for module 
  struct clk_psc_data - PSC data
  @control_base: Base address for a PSC control
  @domain_base: Base address for a PSC domain
  @domain_id: PSC domain id number
  struct clk_psc - PSC clock structure
  @hw: clk_hw for the psc
  @psc_data: PSC driver specific data
  @lock: Spinlock used by the driver
 For disable, we always put the module in local reset 
  clk_register_psc - register psc clock
  @dev: device that is registering this clock
  @name: name of this clock
  @parent_name: name of clock's parent
  @psc_data: platform data to configure this clock
  @lock: spinlock used by this clock
  of_psc_clk_init - initialize psc clock through DT
  @node: device tree node for this clock
  @lock: spinlock used by this clock
 Domain transition registers at fixed address space of domain_id 0 
  of_keystone_psc_clk_init - initialize psc clock through DT
  @node: device tree node for this clock
 SPDX-License-Identifier: GPL-2.0-or-later
  PLL clock driver for Keystone devices
  Copyright (C) 2013 Texas Instruments Inc.
 	Murali Karicheri <m-karicheri2@ti.com>
 	Santosh Shilimkar <santosh.shilimkar@ti.com>
  struct clk_pll_data - pll data structure
  @has_pllctrl: If set to non zero, lower 6 bits of multiplier is in pllm
 	register of pll controller, else it is in the pll_ctrl0((bit 11-6)
  @phy_pllm: Physical address of PLLM in pll controller. Used when
 	has_pllctrl is non zero.
  @phy_pll_ctl0: Physical address of PLL ctrl0. This could be that of
 	Main PLL or any other PLLs in the device such as ARM PLL, DDR PLL
 	or PA PLL available on keystone2. These PLLs are controlled by
 	this register. Main PLL is controlled by a PLL controller.
  @pllm: PLL register map address for multiplier bits
  @pllod: PLL register map address for post divider bits
  @pll_ctl0: PLL controller map address
  @pllm_lower_mask: multiplier lower mask
  @pllm_upper_mask: multiplier upper mask
  @pllm_upper_shift: multiplier upper shift
  @plld_mask: divider mask
  @clkod_mask: output divider mask
  @clkod_shift: output divider shift
  @plld_mask: divider mask
  @postdiv: Fixed post divider
  struct clk_pll - Main pll clock
  @hw: clk_hw for the pll
  @pll_data: PLL driver specific data
	
	  get bits 0-5 of multiplier from pllctrl PLLM register
	  if has_pllctrl is non zero
 bit6-12 of PLLM is in Main PLL control register 
 read post divider from od bits
  _of_pll_clk_init - PLL initialisation via DT
  @node: device tree node for this clock
  @pllctrl: If true, lower 6 bits of multiplier is in pllm register of
 		pll controller, else it is in the control register0(bit 11-6)
 assume the PLL has output divider register bits 
		
		  Check if there is an post-divider register. If not
		  assume od bits are part of control register.
  of_keystone_pll_clk_init - PLL initialisation DT wrapper
  @node: device tree node for this clock
  of_keystone_main_pll_clk_init - Main PLL initialisation DT wrapper
  @node: device tree node for this clock
  of_pll_div_clk_init - PLL divider setup function
  @node: device tree node for this clock
  of_pll_mux_clk_init - PLL mux setup function
  @node: device tree node for this clock
  SCI Clock driver for keystone based devices
  Copyright (C) 2015-2016 Texas Instruments Incorporated - https:www.ti.com
 	Tero Kristo <t-kristo@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  struct sci_clk_provider - TI SCI clock provider representation
  @sci: Handle to the System Control Interface protocol handler
  @ops: Pointer to the SCI ops to be used by the clocks
  @dev: Device pointer for the clock provider
  @clocks: Clocks array for this device
  @num_clocks: Total number of clocks for this provider
  struct sci_clk - TI SCI clock representation
  @hw:		 Hardware clock cookie for common clock framework
  @dev_id:	 Device index
  @clk_id:	 Clock index
  @num_parents: Number of parents for this clock
  @provider:	 Master clock provider
  @flags:	 Flags for the clock
  @node:	 Link for handling clocks probed via DT
  @cached_req:	 Cached requested freq for determine rate calls
  @cached_res:	 Cached result freq for determine rate calls
  sci_clk_prepare - Prepare (enable) a TI SCI clock
  @hw: clock to prepare
  Prepares a clock to be actively used. Returns the SCI protocol status.
  sci_clk_unprepare - Un-prepares (disables) a TI SCI clock
  @hw: clock to unprepare
  Un-prepares a clock from active state.
  sci_clk_is_prepared - Check if a TI SCI clock is prepared or not
  @hw: clock to check status for
  Checks if a clock is prepared (enabled) in hardware. Returns non-zero
  value if clock is enabled, zero otherwise.
  sci_clk_recalc_rate - Get clock rate for a TI SCI clock
  @hw: clock to get rate for
  @parent_rate: parent rate provided by common clock framework, not used
  Gets the current clock rate of a TI SCI clock. Returns the current
  clock rate, or zero in failure.
  sci_clk_determine_rate - Determines a clock rate a clock can be set to
  @hw: clock to change rate for
  @req: requested rate configuration for the clock
  Determines a suitable clock rate and parent for a TI SCI clock.
  The parent handling is un-used, as generally the parent clock rates
  are not known by the kernel; instead these are internally handled
  by the firmware. Returns 0 on success, negative error value on failure.
  sci_clk_set_rate - Set rate for a TI SCI clock
  @hw: clock to change rate for
  @rate: target rate for the clock
  @parent_rate: rate of the clock parent, not used for TI SCI clocks
  Sets a clock frequency for a TI SCI clock. Returns the TI SCI
  protocol status.
  sci_clk_get_parent - Get the current parent of a TI SCI clock
  @hw: clock to get parent for
  Returns the index of the currently selected parent for a TI SCI clock.
  sci_clk_set_parent - Set the parent of a TI SCI clock
  @hw: clock to set parent for
  @index: new parent index for the clock
  Sets the parent of a TI SCI clock. Return TI SCI protocol status.
  _sci_clk_get - Gets a handle for an SCI clock
  @provider: Handle to SCI clock provider
  @sci_clk: Handle to the SCI clock to populate
  Gets a handle to an existing TI SCI hw clock, or builds a new clock
  entry and registers it with the common clock framework. Called from
  the common clock framework, when a corresponding of_clk_get call is
  executed, or recursively from itself when parsing parent clocks.
  Returns 0 on success, negative error code on failure.
	
	  From kernel point of view, we only care about a clocks parents,
	  if it has more than 1 possible parent. In this case, it is going
	  to have mux functionality. Otherwise it is going to act as a root
	  clock.
  sci_clk_get - Xlate function for getting clock handles
  @clkspec: device tree clock specifier
  @data: pointer to the clock provider
  Xlate function for retrieving clock TI SCI hw clock handles based on
  device tree clock specifier. Called from the common clock framework,
  when a corresponding of_clk_get call is executed. Returns a pointer
  to the TI SCI hw clock struct, or ERR_PTR value in failure.
 Sentinel  },
				
				  Linux kernel has inherent limitation
				  of 255 clock parents at the moment.
				  Right now, it is not expected that
				  any mux clock from sci-clk driver
				  would exceed that limit either, but
				  the ABI basically provides that
				  possibility. Print out a warning if
				  this happens for any clock.
  ti_sci_clk_probe - Probe function for the TI SCI clock driver
  @pdev: platform device pointer to be probed
  Probes the TI SCI clock device. Allocates a new clock provider
  and registers this to the common clock framework. Also applies
  any required flags to the identified clocks via clock lists
  supplied from DT. Returns 0 for success, negative error value
  for failure.
  ti_sci_clk_remove - Remove TI SCI clock device
  @pdev: platform device pointer for the device to be removed
  Removes the TI SCI device. Unregisters the clock provider registered
  via common clock framework. Any memory allocated for the device will
  be free'd silently via the devm framework. Returns 0 always.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020 Texas Instruments Incorporated - https:www.ti.com
 Sentinel  },
 Sentinel  },
 SPDX-License-Identifier: GPL-2.0
  PSC clock descriptions for TI DaVinci DM365
  Copyright (C) 2018 David Lechner <david@lechnology.com>
 REVISIT: gpio-davinci.c should be modified to drop con_id 
 REVISIT: why can't this be disabled? 
	
	  The TRM (ARM Subsystem User's Guide) shows two clocks input into
	  voice codec module (PLL2 SYSCLK4 with a DIV2 and PLL1 SYSCLK4). Its
	  not fully clear from documentation which clock should be considered
	  as parent for PSC. The clock chosen here is to maintain
	  compatibility with existing code in archarmmach-davincidm365.c
	
	  Its not fully clear from TRM (ARM Subsystem User's Guide) as to what
	  the parent of VPSS DAC LPSC should actually be. PLL1 SYSCLK3 feeds
	  into HDVICP and MJCP. The clock chosen here is to remain compatible
	  with code existing in archarmmach-davincidm365.c
 SPDX-License-Identifier: GPL-2.0
  PSC clock descriptions for TI DaVinci DM355
  Copyright (C) 2018 David Lechner <david@lechnology.com>
 REVISIT: gpio-davinci.c should be modified to drop con_id 
 REVISIT: why can't this be disabled? 
 SPDX-License-Identifier: GPL-2.0
  PSC clock descriptions for TI DaVinci DM644x
  Copyright (C) 2018 David Lechner <david@lechnology.com>
 REVISIT: gpio-davinci.c should be modified to drop con_id 
 REVISIT: why can't this be disabled? 
 REVISIT how to disable? 
 REVISIT how to disable? 
 SPDX-License-Identifier: GPL-2.0
  Clock driver for TI Davinci PSC controllers
  Copyright (C) 2017 David Lechner <david@lechnology.com>
  Based on: driversclkkeystonegate.c
  Copyright (C) 2013 Texas Instruments.
 	Murali Karicheri <m-karicheri2@ti.com>
 	Santosh Shilimkar <santosh.shilimkar@ti.com>
  And: archarmmach-davincipsc.c
  Copyright (C) 2006 Texas Instruments.
 PSC register offsets 
 PSC module states 
  struct davinci_lpsc_clk - LPSC clock structure
  @dev: the device that provides this LPSC or NULL
  @hw: clk_hw for the LPSC
  @pm_domain: power domain for the LPSC
  @genpd_clk: clock reference owned by @pm_domain
  @regmap: PSC MMIO region
  @md: Module domain (LPSC module id)
  @pd: Power domain
  @flags: LPSC_ quirk flags
  best_dev_name - get the "best" device name.
  @dev: the device
  Returns the device tree compatible name if the device has a DT node,
  otherwise return the device name. This is mainly needed because clkdev
  lookups are limited to 20 chars for dev_id and when using device tree,
  dev_name(dev) is much longer than that.
	
	  pm_clk_remove_clk() will call clk_put(), so we have to use clk_get()
	  to get the clock instead of using lpsc->hw.clk directly.
  davinci_lpsc_clk_register - register LPSC clock
  @dev: the clocks's device or NULL
  @name: name of this clock
  @parent_name: name of clock's parent
  @regmap: PSC MMIO region
  @md: local PSC number
  @pd: power domain
  @flags: LPSC_ flags
 for now, genpd is only registered when using device-tree 
 genpd attach needs a way to look up this clock 
 discard const qualifier 
 the clock node is the same as the reset node 
 not all modules support local reset 
	
	  init array with error so that of_clk_src_onecell_get() doesn't
	  return NULL for gaps in the sparse array
	
	  for now, a reset controller is only registered when there is a device
	  to associate it with.
 has to be postcore_initcall because davinci_gpio depend on PSC clocks 
 SPDX-License-Identifier: GPL-2.0
  PSC clock descriptions for TI DA850OMAP-L138AM18XX
  Copyright (C) 2018 David Lechner <david@lechnology.com>
 REVISIT: used dev_id instead of con_id 
 REVISIT: gpio-davinci.c should be modified to drop con_id 
 SPDX-License-Identifier: GPL-2.0
  PLL clock descriptions for TI DM365
  Copyright (C) 2018 David Lechner <david@lechnology.com>
  This is a bit of a hack to make OCSEL[OCSRC] on DM365 look like OCSEL[OCSRC]
  on DA850. On DM365, OCSEL[OCSRC] is just an enabledisable bit instead of a
  multiplexer. By modeling it as a single parent mux clock, the clock code will
  still do the right thing in this case.
 SPDX-License-Identifier: GPL-2.0
  Clock driver for DA8xxAM17xxAM18xxOMAP-L13x CFGCHIP
  Copyright (C) 2018 David Lechner <david@lechnology.com>
 --- Gate clocks --- 
 this clock divides by 4.5 
 --- MUX clocks --- 
 pll1_sysclk2 is not affected by CPU scaling, so use it for async3 
 --- USB 2.0 PHY clock --- 
	 The USB 2.0 PSC clock is only needed temporarily during the USB 2.0
	  PHY clock enable, but since clk_prepare() can't be called in an
	  atomic context (i.e. in clk_enable()), we have to prepare it here.
	 Locking the USB 2.O PLL requires that the USB 2.O PSC is enabled
	  temporaily. It can be turned back off once the PLL is locked.
	 Turn on the USB 2.0 PHY, but just the PLL, and not OTG. The USB 1.1
	  PHY may use the USB 2.0 PLL clock without USB 2.0 OTG being used.
 The parent clock rate must be one of the following 
 USB 2.0 PLL always supplies 48MHz 
 --- USB 1.1 PHY clock --- 
  da8xx_cfgchip_register_usb1_clk48 - Register a new USB 1.1 PHY clock
  @dev: The device
  @regmap: The CFGCHIP regmap
	
	  All existing boards use pll0_auxclk as the parent and new boards
	  should use device tree, so hard-coding the value (1) here.
	
	  All existing boards use usb0_clk48 as the parent and new boards
	  should use device tree, so hard-coding the value (0) here.
 --- platform device --- 
 has to be postcore_initcall because PSC devices depend on the async3 clock 
 SPDX-License-Identifier: GPL-2.0
  PLL clock descriptions for TI DM355
  Copyright (C) 2018 David Lechner <david@lechnology.com>
 SPDX-License-Identifier: GPL-2.0
  PLL clock descriptions for TI DA830OMAP-L137AM17XX
  Copyright (C) 2018 David Lechner <david@lechnology.com>
  NB: Technically, the clocks flagged as SYSCLK_FIXED_DIV are "fixed ratio",
  meaning that we could change the divider as long as we keep the correct
  ratio between all of the clocks, but we don't support that because there is
  currently not a need for it.
 SPDX-License-Identifier: GPL-2.0
  PLL clock descriptions for TI DM644X
  Copyright (C) 2018 David Lechner <david@lechnology.com>
 810MHz @ 1.3V, -810 only 
 SPDX-License-Identifier: GPL-2.0
  PSC clock descriptions for TI DA830OMAP-L137AM17XX
  Copyright (C) 2018 David Lechner <david@lechnology.com>
 REVISIT: gpio-davinci.c should be modified to drop con_id 
 SPDX-License-Identifier: GPL-2.0
  PLL clock driver for TI Davinci SoCs
  Copyright (C) 2018 David Lechner <david@lechnology.com>
  Based on archarmmach-davinciclock.c
  Copyright (C) 2006-2007 Texas Instruments.
  Copyright (C) 2008-2009 Deep Root Systems, LLC
 shared by most DIV registers 
  OMAP-L138 system reference guide recommends a wait for 4 OSCINCLKIN
  cycles to ensure that the PLLC has switched to bypass mode. Delay of 1us
  ensures we are good for all > 4MHz OSCINCLKIN inputs. Typically the input
  is ~25MHz. Units are micro seconds.
 From OMAP-L138 datasheet table 6-4. Units are micro seconds 
  From OMAP-L138 datasheet table 6-4; assuming prediv = 1, sqrt(pllm) = 4
  Units are micro seconds.
  struct davinci_pll_clk - Main PLL clock (aka PLLOUT)
  @hw: clk_hw for the pll
  @base: Base memory address
  @pllm_min: The minimum allowable PLLM[PLLM] value
  @pllm_max: The maxiumum allowable PLLM[PLLM] value
  @pllm_mask: Bitmask for PLLM[PLLM] value
 there is a limited range of valid outputs (see datasheet) 
 easy case when there is no PREDIV 
 see if the PREDIV clock can help us 
 PLLM works differently on DM365 
  davinci_pll_div_register - common DIV clock implementation
  @dev: The PLL platform device or NULL
  @name: the clock name
  @parent_name: the parent clock name
  @reg: the DIV register
  @fixed: if true, the divider is a fixed value
  @flags: bitmap of CLK_ flags from clock-provider.h
 this clocks just uses the clock notification feature 
  The PLL has to be switched into bypass mode while we are chaning the rate,
  so we do that on the PLLEN clock since it is the end of the line. This will
  switch to bypass before any of the parent clocks (PREDIV, PLL, POSTDIV) are
  changed and will switch back to the PLL after the changes have been made.
 Switch the PLL to bypass mode 
 Reset and enable PLL 
 Bring PLL out of reset 
 Remove PLL from bypass mode 
  davinci_pll_clk_register - Register a PLL clock
  @dev: The PLL platform device or NULL
  @info: The device-specific clock info
  @parent_name: The parent clock name
  @base: The PLL's memory region
  @cfgchip: CFGCHIP syscon regmap for info->unlock_reg or NULL
  This creates a series of clocks that represent the PLL.
      OSCIN > [PREDIV >] PLL > [POSTDIV >] PLLEN
  - OSCIN is the parent clock (on secondary PLL, may come from primary PLL)
  - PREDIV and POSTDIV are optional (depends on the PLL controller)
  - PLL is the PLL output (aka PLLOUT)
  - PLLEN is the bypass multiplexer
  Returns: The PLLOUT clock or a negative error code.
		
		  If a PLL has PLLCTL[CLKMODE], then it is the primary PLL.
		  We register a clock named "oscin" that serves as the internal
		  "input clock" domain shared by both PLLs (if there are 2)
		  and will be the parent clock to the AUXCLK, SYSCLKBP and
		  OBSCLK domains. NB: The various TRMs use "OSCIN" to mean
		  a number of different things. In this driver we use it to
		  mean the signal after the PLLCTL[CLKMODE] switch.
 Some? DM355 chips don't correctly report the PREDIV value 
 Unlock writing to PLL registers 
  davinci_pll_auxclk_register - Register bypass clock (AUXCLK)
  @dev: The PLL platform device or NULL
  @name: The clock name
  @base: The PLL memory region
  davinci_pll_sysclkbp_clk_register - Register bypass divider clock (SYSCLKBP)
  @dev: The PLL platform device or NULL
  @name: The clock name
  @base: The PLL memory region
  davinci_pll_obsclk_register - Register oscillator divider clock (OBSCLK)
  @dev: The PLL platform device or NULL
  @info: The clock info
  @base: The PLL memory region
 make sure divider is enabled just in case bootloader disabled it 
 The PLL SYSCLKn clocks have a mechanism for synchronizing rate changes. 
 apply the changes 
 Wait until for outstanding changes to take effect 
  davinci_pll_sysclk_register - Register divider clocks (SYSCLKn)
  @dev: The PLL platform device or NULL
  @info: The clock info
  @base: The PLL memory region
 PLLDIVn registers are not entirely consecutive 
 Only the ARM clock can change the parent PLL rate 
	
	  Platform data is optional, so allocate a new struct if one was not
	  provided. For device tree, this will always be the case.
 for device tree, we need to fill in the struct 
 needed in early boot for clocksourceclockevent 
 has to be postcore_initcall because PSC devices depend on PLL parent clocks 
 SPDX-License-Identifier: GPL-2.0
  PLL clock descriptions for TI DA850OMAP-L138AM18XX
  Copyright (C) 2018 David Lechner <david@lechnology.com>
  NB: Technically, the clocks flagged as SYSCLK_FIXED_DIV are "fixed ratio",
  meaning that we could change the divider as long as we keep the correct
  ratio between all of the clocks, but we don't support that because there is
  currently not a need for it.
 SPDX-License-Identifier: GPL-2.0
  PLL clock descriptions for TI DM646X
  Copyright (C) 2018 David Lechner <david@lechnology.com>
 SPDX-License-Identifier: GPL-2.0
  PSC clock descriptions for TI DaVinci DM646x
  Copyright (C) 2018 David Lechner <david@lechnology.com>
 REVISIT: gpio-davinci.c should be modified to drop con_id 
 REVISIT how to disable? 
 REVIST: disabling hangs system 
 REVIST: disabling hangs system 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Socionext Inc.
    Author: Masahiro Yamada <yamada.masahiro@socionext.com>
 sentinel  }
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Socionext Inc.
    Author: Masahiro Yamada <yamada.masahiro@socionext.com>
 allocate fixed-rate clock 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Socionext Inc.
    Author: Masahiro Yamada <yamada.masahiro@socionext.com>
 parent should be syscon node 
 avoid returning NULL for unused idx 
 System clock 
 Media IO clock, SD clock 
 Peripheral clock 
 SoC-glue clock 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Socionext Inc.
    Author: Masahiro Yamada <yamada.masahiro@socionext.com>
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Socionext Inc.
    Author: Masahiro Yamada <yamada.masahiro@socionext.com>
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Socionext Inc.
    Author: Masahiro Yamada <yamada.masahiro@socionext.com>
 sentinel  }
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Socionext Inc.
    Author: Masahiro Yamada <yamada.masahiro@socionext.com>
 1597.44 MHz 
 288 MHz 
 589.824 MHz 
 270 MHz 
 Ether, HSC, MIO 
 sentinel  }
 1600 MHz 
 288 MHz 
 589.824 MHz 
 270 MHz 
 250 MHz 
 HSC, MIO, RLE 
 Ether, SATA, USB3 
 sentinel  }
 1600 MHz 
 288 MHz 
 270 MHz 
 Ether, HSC, MIO 
 sentinel  }
 2400 MHz 
 2560 MHz 
 2949.12 MHz 
 HSC 
 PCIe, USB3 
 sentinel  }
 2400 MHz 
 HSC, RLE 
 GIO is always clock-enabled: no function for 0x2104 bit6 
 The document mentions 0x2104 bit 18, but not functional 
 sentinel  }
 1960 MHz 
 1600 MHz 
 2000 MHz 
 2000 MHz 
 Index 5 reserved for eMMC PHY 
 HSC, MIO 
 CPU gears 
 Note: both gear1 and gear4 are spll4.  This is not a bug. 
 sentinel  }
 ARM: 2200 MHz 
 Mali: 1300 MHz 
 Codec: 1600 MHz 
 2000 MHz 
 IPP: 2200 MHz 
 2520 MHz 
 Index 5 reserved for eMMC PHY 
 HSC 
 GIO is always clock-enabled: no function for 0x210c bit5 
	
	  clock for USB Link is enabled by the logic "OR" of bit 14 and bit 15.
	  We do not use bit 15 here.
 CPU gears 
 sentinel  }
 ARM: 2600 MHz 
 2000 MHz 
 IPP: 2400 MHz 
 =GIO0 
 =GIO1 
 =GIO1-1 
 CPU gears 
 sentinel  }
 ARM: 2500 MHz 
 800 MHz 
 =GIO 
 =GIO1P 
 CPU gears 
 sentinel  }
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Socionext Inc.
    Author: Masahiro Yamada <yamada.masahiro@socionext.com>
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Socionext Inc.
    Author: Masahiro Yamada <yamada.masahiro@socionext.com>
 status 
 set 
 update 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015 Vladimir Zapolskiy <vz@mleia.com>
 Common bitfield definitions for x397 PLL (lock), USB PLL and HCLK PLL 
 Clock registers on System Control Block 
 Clock registers on USB controller 
 Start from the last defined clock in dt bindings 
 System clocks, PLL 397x and HCLK PLL clocks 
 USB clocks 
 Only one control PWR_CTRL[10] for both muxes 
 Only one control PWR_CTRL[2] for all three muxes 
 Two clock sources external to the driver 
 Renumbered USB clocks, may have a parent from SCB table 
 Stub for composite clocks 
 Subclocks of composite clocks, clocks above are for CCF 
	
	  CLK_GET_RATE_NOCACHE is needed, if UART clock is disabled, its
	  divider register does not contain information about selected rate.
 USB controller clocks 
 Validate PLL clock parameters computed on round rate stage 
 Sanity check that round rate is equal to the requested one 
 Have to check all 20 possibilities to find the minimal M 
 Check for valid PLL parameter constraints 
 Store some intermediate valid parameters 
 Set only direct or non-integer mode of PLL 
	
	  The only supported USB clock is 48MHz, with PLL internal constraints
	  on Fclkin, Fcco and Fref this implies that Fcco must be 192MHz
	  and post-divider must be 4, this slightly simplifies calculation of
	  USB divider, USB PLL N and M parameters.
 USB divider clock 
 Main oscillator clock 
 must be in range 1..20 MHz 
 Check if valid USB divider and USB PLL parameters exists 
	
	  DDRAM clock must be 2 times higher than HCLK,
	  this implies DDRAM clock can not be enabled,
	  if HCLK clock rate is equal to ARM clock rate
 if read only, just return current value 
 Register 3 read-only muxes with a single control PWR_CTRL[2] 
 Register 2 read-only muxes with a single control PWR_CTRL[10] 
 3 always on gates with a single control PWR_CTRL[0] same as OSC 
	
	  ADCTS clock unfortunately cannot be registered as a composite one
	  due to a different connection of gate, div and mux, e.g. gating it
	  won't mean that the clock is off, if peripheral clock is its parent:
	 
	  rtc-->[gate]-->|     |
	                 | mux |--> adcts
	  pclk-->[div]-->|     |
	 
	  Constraints:
	  ADC --- resulting clock must be <= 4.5 MHz
	  TS  --- resulting clock must be <= 400 KHz
 USB controller clocks 
 Ensure that parent clocks are available and valid 
	
	  Divider part of PWM and MS clocks requires a quirk to avoid
	  a misinterpretation of formally valid zero value in register
	  bitfield, which indicates another clock gate. Instead of
	  adding complexity to a gate clock ensure that zero value in
	  divider clock is never met in runtime.
 Set 48MHz rate of USB PLL clock 
 These two clocks must be always on independently on consumers 
 Enable ARM VFP by default 
 Disable enabled by default clocks for NAND MLC and SLC 
  Clk driver for NXP LPC18xxLPC43xx Clock Generation Unit (CGU)
  Copyright (C) 2015 Joachim Eastwood <manabian@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 Clock Generation Unit (CGU) registers 
 PLL0 bits common to both audio and USB PLL 
 Register value that gives PLL0 postpre dividers equal to 1 
 21 reserved  },
 22 reserved  },
 23 reserved  },
 24 reserved  },
  PLL0 uses a special register value encoding. The compute functions below
  are taken or derived from the LPC1850 user manual (section 12.6.3.3).
 Compute PLL0 multiplier from decoded version 
 Compute PLL0 decoded multiplier from binary version 
 Compute PLL0 bandwidth SELI reg from multiplier 
 Compute PLL0 bandwidth SELP reg from multiplier 
 Power down PLL, disable clk output and dividers 
 Configure new PLL settings 
 Power up PLL and wait for lock 
	
	  The consumer of base clocks needs know if the
	  base clock is really enabled before it can be
	  accessed. It is therefore necessary to verify
	  this all the way up.
 SAFE_CLK can not be turned off 
 Register the internal 12 MHz RC oscillator (IRC) 
 Register crystal oscillator controlller 
 Register all PLLs 
 Register all clock dividers A-E 
  Clk driver for NXP LPC18xx43xx Configuration Registers (CREG)
  Copyright (C) 2015 Joachim Eastwood <manabian@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
	
	  Powering up the 32k oscillator takes a long while
	  and sadly there aren't any status bit to poll.
  Clk driver for NXP LPC18xxLPC43xx Clock Control Unit (CCU)
  Copyright (C) 2015 Joachim Eastwood <manabian@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 Bit defines for CCU branch configuration register 
 CCU branch feature bits 
	
	  Divider field is write only, so divider stat field must
	  be read so divider field can be set accordingly.
		
		  To safely disable a branch clock a squence of two separate
		  writes must be used. First write should set the AUTO bit
		  and the next write should clear the RUN bit.
	
	  The branch clock registers are only accessible
	  if the base (parent) clock is enabled. Register
	  access with a disabled base clock will hang the
	  system.
 Grab essential branch clocks for CPU and SDRAM 
 SPDX-License-Identifier: GPL-2.0
  r8a77995 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2017 Glider bvba
  Based on r8a7795-cpg-mssr.c
  Copyright (C) 2015 Glider bvba
  Copyright (C) 2015 Renesas Electronics Corp.
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-AP (GIC) 
  CPG Clock Data
  MD19		EXTAL (MHz)	PLL0		PLL1		PLL3
 --------------------------------------------------------------------
  0		48 x 1		x2504		x1003		x1003
  1		48 x 1		x2504		x1003		x583
 EXTAL div	PLL1 multdiv	PLL3 multdiv 
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  Renesas Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2015 Glider bvba
  Based on clk-mstp.c, clk-rcar-gen2.c, and clk-rcar-gen3.c
  Copyright (C) 2013 Ideas On Board SPRL
  Copyright (C) 2015 Renesas Electronics Corp.
  Module Standby and Software Reset register offets.
  If the registers exist, these are valid for SH-Mobile, R-Mobile,
  R-Car Gen2, R-Car Gen3, and RZG1.
  These are NOT valid for R-Car Gen1 and RZA1!
  Module Stop Status Register offsets
  System Module Stop Control Register offsets
  Standby Control Register offsets (RZA)
  Base address is FRQCR register
dummy, 0x010, 0x014, 0x410, 0x414, 0x418, 0x41C, 0x420,
  Software Reset Register offsets
  Software Reset Clearing Register offsets
  struct cpg_mssr_priv - Clock Pulse Generator  Module Standby
                         and Software Reset Private Data
  @rcdev: Optional reset controller entity
  @dev: CPGMSSR device
  @base: CPGMSSR register block base address
  @reg_layout: CPGMSSR register layout
  @rmw_lock: protects RMW register accesses
  @np: Device node in DT for this CPGMSSR module
  @num_core_clks: Number of Core Clocks in clks[]
  @num_mod_clks: Number of Module Clocks in clks[]
  @last_dt_core_clk: ID of the last Core Clock exported to DT
  @notifiers: Notifier chain to saverestore clock state for system resume
  @status_regs: Pointer to status registers array
  @control_regs: Pointer to control registers array
  @reset_regs: Pointer to reset registers array
  @reset_clear_regs:  Pointer to reset clearing registers array
  @smstpcr_saved: [].mask: Mask of SMSTPCR[] bits under our control
                  [].val: Saved values of SMSTPCR[]
  @clks: Array containing all Core and Module Clocks
  struct mstp_clock - MSTP gating clock
  @hw: handle between common and hardware-specific interfaces
  @index: MSTP clock number
  @priv: CPGMSSR private data
 dummy read to ensure write has completed 
 Skip NULLified clock 
 Multiply with the DIV6 register value 
 Skip NULLified clock 
 Reset module 
 Wait for at least one cycle of the RCLK clock (@ ca. 32 kHz) 
 Release module from reset state 
 !CONFIG_RESET_CONTROLLER 
 !CONFIG_RESET_CONTROLLER 
 RZG1N is (almost) identical to RZG1M w.r.t. clocks. 
 R-Car M2-N is (almost) identical to R-Car M2-W w.r.t. clocks. 
 sentinel  }
 This is the best we can do to check for the presence of PSCI 
 Save module registers with bits under our control 
 Save core clocks 
 This is the best we can do to check for the presence of PSCI 
 Restore core clocks 
 Restore module clocks 
 dummy read to ensure write has completed 
 Wait until enabled clocks are really enabled 
 CONFIG_PM_SLEEP && CONFIG_ARM_PSCI_FW 
 Reset Controller not supported for Standby Control SoCs 
 SPDX-License-Identifier: GPL-2.0
  r8a774a1 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2018 Renesas Electronics Corp.
  Based on r8a7796-cpg-mssr.c
  Copyright (C) 2016 Glider bvba
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-AP (GIC) 
  CPG Clock Data
    MD		EXTAL		PLL0	PLL1	PLL2	PLL3	PLL4	OSC
  14 13 19 17	(MHz)
 -------------------------------------------------------------------------
  0  0  0  0	16.66 x 1	x180	x192	x144	x192	x144	16
  0  0  0  1	16.66 x 1	x180	x192	x144	x128	x144	16
  0  0  1  0	Prohibited setting
  0  0  1  1	16.66 x 1	x180	x192	x144	x192	x144	16
  0  1  0  0	20    x 1	x150	x160	x120	x160	x120	19
  0  1  0  1	20    x 1	x150	x160	x120	x106	x120	19
  0  1  1  0	Prohibited setting
  0  1  1  1	20    x 1	x150	x160	x120	x160	x120	19
  1  0  0  0	25    x 1	x120	x128	x96	x128	x96	24
  1  0  0  1	25    x 1	x120	x128	x96	x84	x96	24
  1  0  1  0	Prohibited setting
  1  0  1  1	25    x 1	x120	x128	x96	x128	x96	24
  1  1  0  0	33.33  2	x180	x192	x144	x192	x144	32
  1  1  0  1	33.33  2	x180	x192	x144	x128	x144	32
  1  1  1  0	Prohibited setting
  1  1  1  1	33.33  2	x180	x192	x144	x192	x144	32
 EXTAL div	PLL1 multdiv	PLL3 multdiv	OSC prediv 
 Prohibited setting 				},
 Prohibited setting 				},
 Prohibited setting 				},
 Prohibited setting 				},
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  RZG2L CPG driver
  Copyright (C) 2021 Renesas Electronics Corp.
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 Divider tables 
 Mux clock tables 
 External Clock Inputs 
 Internal Core Clocks 
 Core output clk 
 Core Clocks 
 Critical Module Clocks 
 Module Clocks 
 Resets 
 SPDX-License-Identifier: GPL-2.0
  r8a77965 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2018 Jacopo Mondi <jacopo+renesas@jmondi.org>
  Copyright (C) 2019 Renesas Electronics Corp.
  Based on r8a7795-cpg-mssr.c
  Copyright (C) 2015 Glider bvba
  Copyright (C) 2015 Renesas Electronics Corp.
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-AP (GIC) 
  CPG Clock Data
    MD		EXTAL		PLL0	PLL1	PLL3	PLL4	OSC
  14 13 19 17	(MHz)
 -----------------------------------------------------------------
  0  0  0  0	16.66 x 1	x180	x192	x192	x144	16
  0  0  0  1	16.66 x 1	x180	x192	x128	x144	16
  0  0  1  0	Prohibited setting
  0  0  1  1	16.66 x 1	x180	x192	x192	x144	16
  0  1  0  0	20    x 1	x150	x160	x160	x120	19
  0  1  0  1	20    x 1	x150	x160	x106	x120	19
  0  1  1  0	Prohibited setting
  0  1  1  1	20    x 1	x150	x160	x160	x120	19
  1  0  0  0	25    x 1	x120	x128	x128	x96	24
  1  0  0  1	25    x 1	x120	x128	x84	x96	24
  1  0  1  0	Prohibited setting
  1  0  1  1	25    x 1	x120	x128	x128	x96	24
  1  1  0  0	33.33  2	x180	x192	x192	x144	32
  1  1  0  1	33.33  2	x180	x192	x128	x144	32
  1  1  1  0	Prohibited setting
  1  1  1  1	33.33  2	x180	x192	x192	x144	32
 EXTAL div	PLL1 multdiv	PLL3 multdiv	OSC prediv 
 Prohibited setting 				},
 Prohibited setting 				},
 Prohibited setting 				},
 Prohibited setting 				},
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  EMMA Mobile EV2 common clock framework support
  Copyright (C) 2013 Takashi Yoshii <takashi.yoshii.ze@renesas.com>
  Copyright (C) 2012 Magnus Damm
 EMEV2 SMU registers 
 not pretty, but hey 
 setup STI timer to run on 32.768 kHz and deassert reset 
 deassert reset for UART0->UART3 
 deassert reset for IIC0->IIC1 
 SPDX-License-Identifier: GPL-2.0
  r8a7743 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2016 Cogent Embedded Inc.
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-SYS (GIC) 
  CPG Clock Data
     MD	EXTAL		PLL0	PLL1	PLL3
  14 13 19	(MHz)		1	1
 ---------------------------------------------------
  0  0  0	15		x1722	x2082	x106
  0  0  1	15		x1722	x2082	x88
  0  1  0	20		x1302	x1562	x80
  0  1  1	20		x1302	x1562	x66
  1  0  0	26  2		x2002	x2402	x122
  1  0  1	26  2		x2002	x2402	x102
  1  1  0	30  2		x1722	x2082	x106
  1  1  1	30  2		x1722	x2082	x88
  1 :	Table 7.5a indicates VCO output (PLLx = VCO2)
 EXTAL div	PLL1 mult	PLL3 mult 
 RZG1N uses a 15 divider for ZG 
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  r8a7790 Common Clock Framework support
  Copyright (C) 2013  Renesas Solutions Corp.
  Contact: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  struct div6_clock - CPG 6 bit divider clock
  @hw: handle between common and hardware-specific interfaces
  @reg: IO-remapped register
  @div: divisor value (1-64)
  @src_mask: Bitmask covering the register bits to select the parent clock
  @nb: Notifier block to saverestore clock state for system resume
  @parents: Array to map from valid parent clocks indices to hardware indices
	
	  DIV6 clocks require the divisor field to be non-zero when stopping
	  the clock. However, some clocks (e.g. ZB on sh73a0) fail to be
	  re-enabled later if the divisor field is changed when stopping the
	  clock
 Only program the new divisor if the clock isn't stopped. 
		
		  TODO: This does not yet support DIV6 clocks with multiple
		  parents, as the parent selection bits are not restored.
		  Fortunately so far such DIV6 clocks are found only on
		  RSH-Mobile SoCs, while the resume functionality is only
		  needed on R-Car Gen3.
  cpg_div6_register - Register a DIV6 clock
  @name: Name of the DIV6 clock
  @num_parents: Number of parent clocks of the DIV6 clock (1, 4, or 8)
  @parent_names: Array containing the names of the parent clocks
  @reg: Mapped register used to control the DIV6 clock
  @notifiers: Optional notifier chain to saverestore state for system resume
	
	  Read the divisor. Disabling the clock overwrites the divisor, so we
	  need to cache its value for the enable operation.
 fixed parent clock 
 clock with EXSRC bits 6-7 
 VCLK with EXSRC bits 12-14 
 Filter out invalid parents 
 Register the clock. 
 Parse the DT properties. 
 SPDX-License-Identifier: GPL-2.0
  sh73a0 Core CPG Clocks
  Copyright (C) 2014  Ulrich Hecht
 ZSEL == 0 
 ZSEL == 1 
 extal1, extal1_div2, extal2, extal2_div2 
 handle CFG bit for PLL1 and PLL2 
		 We're leaking memory on purpose, there's no point in cleaning
		  up as the system won't boot anyway.
 Set SDHI clocks to a known state 
 SPDX-License-Identifier: GPL-2.0
  R7S9210 Clock Pulse Generator  Module Standby
  Based on r8a7795-cpg-mssr.c
  Copyright (C) 2018 Chris Brandt
  Copyright (C) 2018 Renesas Electronics Corp.
 Internal Clock ratio table 
 p0 is always 32 ;
 I,  G,  B, P1 
 FRQCR = 0x012 
 FRQCR = 0x112 
 FRQCR = 0x212 
 FRQCR = 0x322 
 FRQCR = 0x333 
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 Core Clock Outputs 
 The clock dividers in the table vary based on DT and register settings 
 If EXTAL is above 12MHz, then we know it is Mode 1 
 Illegal FRQCR value 
 Divider 1 is 12 
 Divider 1 is 1 
 Early Clocks 
 Core Clocks 
 Module Clocks 
 includes STBCR0 which doesn't exist 
 Callbacks 
 RZA2 has Standby Control Registers 
 SPDX-License-Identifier: GPL-2.0
  r8a7795 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2015 Glider bvba
  Copyright (C) 2018-2019 Renesas Electronics Corp.
  Based on clk-rcar-gen3.c
  Copyright (C) 2015 Renesas Electronics Corp.
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 ES1.x 
 ES1.x 
 ES1.x 
 ES1.x 
 ES1.x 
 ES1.x 
 ES1.x 
 ES1.x 
 ES1.x 
 ES1.x 
 RWDT 
 INTC-AP (GIC) 
  CPG Clock Data
    MD		EXTAL		PLL0	PLL1	PLL2	PLL3	PLL4	OSC
  14 13 19 17	(MHz)
 -------------------------------------------------------------------------
  0  0  0  0	16.66 x 1	x180	x192	x144	x192	x144	16
  0  0  0  1	16.66 x 1	x180	x192	x144	x128	x144	16
  0  0  1  0	Prohibited setting
  0  0  1  1	16.66 x 1	x180	x192	x144	x192	x144	16
  0  1  0  0	20    x 1	x150	x160	x120	x160	x120	19
  0  1  0  1	20    x 1	x150	x160	x120	x106	x120	19
  0  1  1  0	Prohibited setting
  0  1  1  1	20    x 1	x150	x160	x120	x160	x120	19
  1  0  0  0	25    x 1	x120	x128	x96	x128	x96	24
  1  0  0  1	25    x 1	x120	x128	x96	x84	x96	24
  1  0  1  0	Prohibited setting
  1  0  1  1	25    x 1	x120	x128	x96	x128	x96	24
  1  1  0  0	33.33  2	x180	x192	x144	x192	x144	32
  1  1  0  1	33.33  2	x180	x192	x144	x128	x144	32
  1  1  1  0	Prohibited setting
  1  1  1  1	33.33  2	x180	x192	x144	x192	x144	32
 EXTAL div	PLL1 multdiv	PLL3 multdiv	OSC prediv 
 Prohibited setting 				},
 Prohibited setting 				},
 Prohibited setting 				},
 Prohibited setting 				},
 sentinel  }
	
	  Fixups for R-Car H3 ES1.x
 USB-DMAC3-0 
 USB-DMAC3-1 
 EHCIOHCI3 
 HS-USB-IF3 
 FDP1-1 
 FDP1-0 
 TMU4 
 SYS-DMAC2 
 SYS-DMAC1 
 SYS-DMAC0 
 INTC-AP 
 AUDMAC1 
 AUDMAC0 
 PWM 
 FCPVD2 
 FCPVD1 
 FCPVD0 
 FCPVB1 
 FCPVB0 
 FCPVI1 
 FCPVI0 
 FCPF1 
 FCPF0 
 FCPCS 
 VSPD2 
 VSPD1 
 VSPD0 
 VSPBC 
 VSPBD 
 VSPI1 
 VSPI0 
 VIN7 
 VIN6 
 VIN5 
 VIN4 
 VIN3 
 VIN2 
 VIN1 
 VIN0 
 EAVB-IF 
 IMR3 
 IMR2 
 IMR1 
 IMR0 
 GPIO7 
 GPIO6 
 GPIO5 
 GPIO4 
 GPIO3 
 GPIO2 
 GPIO1 
 GPIO0 
 I2C6 
 I2C5 
 I2C4 
 I2C3 
	
	  Fixups for R-Car H3 ES2.x
 FDP1-2 
 USB3-IF1 
 FCPVD3 
 FCPVI2 
 FCPF2 
 FCPCI1 
 FCPCI0 
 VSPD3 
 VSPI2 
 CSI21 
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  RZG2L Clock Pulse Generator
  Copyright (C) 2021 Renesas Electronics Corp.
  Based on renesas-cpg-mssr.c
  Copyright (C) 2015 Glider bvba
  Copyright (C) 2013 Ideas On Board SPRL
  Copyright (C) 2015 Renesas Electronics Corp.
  struct rzg2l_cpg_priv - Clock Pulse Generator Private Data
  @rcdev: Reset controller entity
  @dev: CPG device
  @base: CPG register block base address
  @rmw_lock: protects register accesses
  @clks: Array containing all Core and Module Clocks
  @num_core_clks: Number of Core Clocks in clks[]
  @num_mod_clks: Number of Module Clocks in clks[]
  @last_dt_core_clk: ID of the last Core Clock exported to DT
  @notifiers: Notifier chain to saverestore clock state for system resume
  @info: Pointer to platform data
	
	  As per the HW manual, we should not directly switch from 533 MHz to
	  400 MHz and vice versa. To change the setting from 2’b01 (533 MHz)
	  to 2’b10 (400 MHz) or vice versa, Switch to 2’b11 (266 MHz) first,
	  and then switch to the target setting (2’b01 (533 MHz) or 2’b10
	  (400 MHz)).
	  Setting a value of '0' to the SEL_SDHI0_SET or SEL_SDHI1_SET clock
	  switching register is prohibited.
	  The clock mux has 3 input clocks(533 MHz, 400 MHz, and 266 MHz), and
	  the index to value mapping is done by adding 1 to the index.
 Prohibited clk source, change it to 533 MHz(reset value) 
 Skip NULLified clock 
  struct mstp_clock - MSTP gating clock
  @hw: handle between common and hardware-specific interfaces
  @off: register offset
  @bit: ONMON bit
  @enabled: soft state of the clock, if it is coupled with another clock
  @priv: CPGMSTP private data
  @sibling: pointer to the other coupled clock
 Skip NULLified clock 
 Reset module 
 Wait for at least one cycle of the RCLK clock (@ ca. 32 kHz) 
 Release module from reset state 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  RZA1 Core CPG Clocks
  Copyright (C) 2013 Ideas On Board SPRL
  Copyright (C) 2014 Wolfram Sang, Sang Engineering <wsa@sang-engineering.com>
 P0_2 
 -----------------------------------------------------------------------------
  Initialization
 enable input buffer 
 If mapping regs failed, skip non-pll clocks. System will boot anyhow 
	 FIXME:"i" and "g" are variable clocks with non-integer dividers (e.g. 23)
	  and the constraint that always g <= i. To get the rz platform started,
	  let them run at fixed current speed and implement the details later.
 SPDX-License-Identifier: GPL-2.0
  r8a77990 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2018-2019 Renesas Electronics Corp.
  Based on r8a7795-cpg-mssr.c
  Copyright (C) 2015 Glider bvba
  Copyright (C) 2015 Renesas Electronics Corp.
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-AP (GIC) 
  CPG Clock Data
  MD19		EXTAL (MHz)	PLL0		PLL1		PLL3
 --------------------------------------------------------------------
  0		48 x 1		x1001		x1003		x1003
  1		48 x 1		x1001		x1003		 x583
 EXTAL div	PLL1 multdiv	PLL3 multdiv 
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  r8a774e1 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2020 Renesas Electronics Corp.
  Based on r8a7795-cpg-mssr.c
  Copyright (C) 2015 Glider bvba
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-AP (GIC) 
  CPG Clock Data
    MD		EXTAL		PLL0	PLL1	PLL2	PLL3	PLL4	OSC
  14 13 19 17	(MHz)
 -------------------------------------------------------------------------
  0  0  0  0	16.66 x 1	x180	x192	x144	x192	x144	16
  0  0  0  1	16.66 x 1	x180	x192	x144	x128	x144	16
  0  0  1  0	Prohibited setting
  0  0  1  1	16.66 x 1	x180	x192	x144	x192	x144	16
  0  1  0  0	20    x 1	x150	x160	x120	x160	x120	19
  0  1  0  1	20    x 1	x150	x160	x120	x106	x120	19
  0  1  1  0	Prohibited setting
  0  1  1  1	20    x 1	x150	x160	x120	x160	x120	19
  1  0  0  0	25    x 1	x120	x128	x96	x128	x96	24
  1  0  0  1	25    x 1	x120	x128	x96	x84	x96	24
  1  0  1  0	Prohibited setting
  1  0  1  1	25    x 1	x120	x128	x96	x128	x96	24
  1  1  0  0	33.33  2	x180	x192	x144	x192	x144	32
  1  1  0  1	33.33  2	x180	x192	x144	x128	x144	32
  1  1  1  0	Prohibited setting
  1  1  1  1	33.33  2	x180	x192	x144	x192	x144	32
 EXTAL div	PLL1 multdiv	PLL3 multdiv	OSC prediv 
 Prohibited setting 				},
 Prohibited setting 				},
 Prohibited setting 				},
 Prohibited setting 				},
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  r8a7790 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2017 Glider bvba
  Based on clk-rcar-gen2.c
  Copyright (C) 2013 Ideas On Board SPRL
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-SYS (GIC) 
  CPG Clock Data
    MD		EXTAL		PLL0	PLL1	PLL3
  14 13 19	(MHz)		1	1
 ---------------------------------------------------
  0  0  0	15		x1722	x2082	x106
  0  0  1	15		x1722	x2082	x88
  0  1  0	20		x1302	x1562	x80
  0  1  1	20		x1302	x1562	x66
  1  0  0	26  2		x2002	x2402	x122
  1  0  1	26  2		x2002	x2402	x102
  1  1  0	30  2		x1722	x2082	x106
  1  1  1	30  2		x1722	x2082	x88
  1 :	Table 7.5a indicates VCO output (PLLx = VCO2)
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  r8a7796 (R-Car M3-WW+) Clock Pulse Generator  Module Standby and Software
  Reset
  Copyright (C) 2016-2019 Glider bvba
  Copyright (C) 2018-2019 Renesas Electronics Corp.
  Based on r8a7795-cpg-mssr.c
  Copyright (C) 2015 Glider bvba
  Copyright (C) 2015 Renesas Electronics Corp.
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-AP (GIC) 
  CPG Clock Data
    MD		EXTAL		PLL0	PLL1	PLL2	PLL3	PLL4	OSC
  14 13 19 17	(MHz)
 -------------------------------------------------------------------------
  0  0  0  0	16.66 x 1	x180	x192	x144	x192	x144	16
  0  0  0  1	16.66 x 1	x180	x192	x144	x128	x144	16
  0  0  1  0	Prohibited setting
  0  0  1  1	16.66 x 1	x180	x192	x144	x192	x144	16
  0  1  0  0	20    x 1	x150	x160	x120	x160	x120	19
  0  1  0  1	20    x 1	x150	x160	x120	x106	x120	19
  0  1  1  0	Prohibited setting
  0  1  1  1	20    x 1	x150	x160	x120	x160	x120	19
  1  0  0  0	25    x 1	x120	x128	x96	x128	x96	24
  1  0  0  1	25    x 1	x120	x128	x96	x84	x96	24
  1  0  1  0	Prohibited setting
  1  0  1  1	25    x 1	x120	x128	x96	x128	x96	24
  1  1  0  0	33.33  2	x180	x192	x144	x192	x144	32
  1  1  0  1	33.33  2	x180	x192	x144	x128	x144	32
  1  1  1  0	Prohibited setting
  1  1  1  1	33.33  2	x180	x192	x144	x192	x144	32
 EXTAL div	PLL1 multdiv	PLL3 multdiv	OSC prediv 
 Prohibited setting 				},
 Prohibited setting 				},
 Prohibited setting 				},
 Prohibited setting 				},
	
	  Fixups for R-Car M3-W+
 FCPCI0  
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  r8a774c0 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2018 Renesas Electronics Corp.
  Based on r8a77990-cpg-mssr.c
  Copyright (C) 2015 Glider bvba
  Copyright (C) 2015 Renesas Electronics Corp.
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-AP (GIC) 
  CPG Clock Data
  MD19		EXTAL (MHz)	PLL0		PLL1		PLL3
 --------------------------------------------------------------------
  0		48 x 1		x1001		x1003		x1003
  1		48 x 1		x1001		x1003		 x583
 EXTAL div	PLL1 multdiv	PLL3 multdiv 
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  r8a77470 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2018 Renesas Electronics Corp.
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-SYS (GIC) 
  CPG Clock Data
     MD	EXTAL		PLL0	PLL1	PLL3
  14 13	(MHz)		1	2
 ---------------------------------------------------
  0  0		20		x80	x78	x50
  0  1		26		x60	x60	x56
  1  0		Prohibited setting
  1  1		30		x52	x52	x50
  1 :	Table 7.4 indicates VCO output (PLL0 = VCO)
  2 :	Table 7.4 indicates VCO output (PLL1 = VCO)
 EXTAL div	PLL1 mult x2	PLL3 mult 
 Invalid				},
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  r8a7794 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2017 Glider bvba
  Based on clk-rcar-gen2.c
  Copyright (C) 2013 Ideas On Board SPRL
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-SYS (GIC) 
  CPG Clock Data
    MD		EXTAL		PLL0	PLL1	PLL3
  14 13 19	(MHz)		1	2
 ---------------------------------------------------
  0  0  1	15		x2003	x2082	x88
  0  1  1	20		x1503	x1562	x66
  1  0  1	26  2		x2303	x2402	x102
  1  1  1	30  2		x2003	x2082	x88
  1 :	Table 7.5c indicates VCO output (PLL0 = VCO3)
  2 :	Table 7.5c indicates VCO output (PLL1 = VCO2)
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  r8a779a0 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2020 Renesas Electronics Corp.
  Based on r8a7795-cpg-mssr.c
  Copyright (C) 2015 Glider bvba
  Copyright (C) 2015 Renesas Electronics Corp.
 PLL[23][01] 
 Select parentdivider using mode pin 
 OSC EXTAL predivider and fixed divider 
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
  Z0 Clock & Z1 Clock
 Maximum rate for normal mode 
 Set parent rate to initial value for normal modes 
 Set increased parent rate for boost modes 
	
	  Set KICK bit in FRQCRB to update hardware setting and wait for
	  clock change completion.
	
	  Note: There is no HW information about the worst case latency.
	 
	  Using experimental measurements, it seems that no more than
	  ~10 iterations are needed, independently of the CPU rate.
	  Since this value might be dependent on external xtal rate, pll1
	  rate or even the other emulation clocks rate, use 1000 as a
	  "super" safe value.
 PLLVCO x 1div x SYS-CPU divider 
  RPC Clocks
 some types use high bits 
		
		  Clock selectable between two parents and two fixed dividers
		  using a mode pin
		
		  Clock combining OSC EXTAL predivider and a fixed divider
 RWDT 
  CPG Clock Data
    MD	 EXTAL		PLL1	PLL20	PLL30	PLL4	PLL5	OSC
  14 13 (MHz)			   21	   31
  --------------------------------------------------------
  0  0	 16.66 x 1	x128	x216	x128	x144	x192	16
  0  1	 20    x 1	x106	x180	x106	x120	x160	19
  1  0	 Prohibited setting
  1  1	 33.33  2	x128	x216	x128	x144	x192	32
 EXTAL div	PLL1 multdiv	PLL5 multdiv	OSC prediv 
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  r8a7792 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2017 Glider bvba
  Based on clk-rcar-gen2.c
  Copyright (C) 2013 Ideas On Board SPRL
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-SYS (GIC) 
  CPG Clock Data
    MD		EXTAL		PLL0	PLL1	PLL3
  14 13 19	(MHz)		1	2
 ---------------------------------------------------
  0  0  0	15		x2003	x2082	x106
  0  0  1	15		x2003	x2082	x88
  0  1  0	20		x1503	x1562	x80
  0  1  1	20		x1503	x1562	x66
  1  0  0	26  2		x2303	x2402	x122
  1  0  1	26  2		x2303	x2402	x102
  1  1  0	30  2		x2003	x2082	x106
  1  1  1	30  2		x2003	x2082	x88
  1 :	Table 7.5b indicates VCO output (PLL0 = VCO3)
  2 :	Table 7.5b indicates VCO output (PLL1 = VCO2)
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  r8a774b1 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2019 Renesas Electronics Corp.
  Based on r8a7796-cpg-mssr.c
  Copyright (C) 2016 Glider bvba
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-AP (GIC) 
  CPG Clock Data
    MD		EXTAL		PLL0	PLL1	PLL3	PLL4	OSC
  14 13 19 17	(MHz)
 -----------------------------------------------------------------
  0  0  0  0	16.66 x 1	x180	x192	x192	x144	16
  0  0  0  1	16.66 x 1	x180	x192	x128	x144	16
  0  0  1  0	Prohibited setting
  0  0  1  1	16.66 x 1	x180	x192	x192	x144	16
  0  1  0  0	20    x 1	x150	x160	x160	x120	19
  0  1  0  1	20    x 1	x150	x160	x106	x120	19
  0  1  1  0	Prohibited setting
  0  1  1  1	20    x 1	x150	x160	x160	x120	19
  1  0  0  0	25    x 1	x120	x128	x128	x96	24
  1  0  0  1	25    x 1	x120	x128	x84	x96	24
  1  0  1  0	Prohibited setting
  1  0  1  1	25    x 1	x120	x128	x128	x96	24
  1  1  0  0	33.33  2	x180	x192	x192	x144	32
  1  1  0  1	33.33  2	x180	x192	x128	x144	32
  1  1  1  0	Prohibited setting
  1  1  1  1	33.33  2	x180	x192	x192	x144	32
 EXTAL div	PLL1 multdiv	PLL3 multdiv	OSC prediv 
 Prohibited setting 				},
 Prohibited setting 				},
 Prohibited setting 				},
 Prohibited setting 				},
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  r8a7745 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2016 Cogent Embedded Inc.
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-SYS (GIC) 
  CPG Clock Data
     MD	EXTAL		PLL0	PLL1	PLL3
  14 13 19	(MHz)		1	2
 ---------------------------------------------------
  0  0  1	15		x2003	x2082	x88
  0  1  1	20		x1503	x1562	x66
  1  0  1	26  2		x2303	x2402	x102
  1  1  1	30  2		x2003	x2082	x88
  1 :	Table 7.5b indicates VCO output (PLL0 = VCO3)
  2 :	Table 7.5b indicates VCO output (PLL1 = VCO2)
 EXTAL div	PLL1 mult	PLL3 mult	PLL0 mult 
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  r8a77970 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2017-2018 Cogent Embedded Inc.
  Based on r8a7795-cpg-mssr.c
  Copyright (C) 2015 Glider bvba
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-AP (GIC) 
  CPG Clock Data
    MD		EXTAL		PLL0	PLL1	PLL3
  14 13 19	(MHz)
 -------------------------------------------------
  0  0  0	16.66 x 1	x192	x192	x96
  0  0  1	16.66 x 1	x192	x192	x80
  0  1  0	20    x 1	x160	x160	x80
  0  1  1	20    x 1	x160	x160	x66
  1  0  0	27     2	x236	x236	x118
  1  0  1	27     2	x236	x236	x98
  1  1  0	33.33  2	x192	x192	x96
  1  1  1	33.33  2	x192	x192	x80
 EXTAL div	PLL1 multdiv	PLL3 multdiv 
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  R-Car MSTP clocks
  Copyright (C) 2013 Ideas On Board SPRL
  Copyright (C) 2015 Glider bvba
  Contact: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  MSTP clocks. We can't use standard gate clocks as we need to poll on the
  status register when enabling the clock.
  struct mstp_clock_group - MSTP gating clocks group
  @data: clock specifier translation for clocks in this group
  @smstpcr: module stop control register
  @mstpsr: module stop status register (optional)
  @lock: protects writes to SMSTPCR
  @width_8bit: registers are 8-bit, not 32-bit
  @clks: clocks in this group
  struct mstp_clock - MSTP gating clock
  @hw: handle between common and hardware-specific interfaces
  @bit_index: control bit index
  @group: MSTP clocks group
 dummy read to ensure write has completed 
 INTC-SYS is the module clock of the GIC, and must not be disabled 
 Skip clocks with no name. 
			
			  Register a clkdev to let board code retrieve the
			  clock by name and register aliases for non-DT
			  devices.
			 
			  FIXME: Remove this when all devices that require a
			  clock will be instantiated from DT.
 BSC on r8a73a4sh73a0 uses zb_clk instead of an mstp clock 
 SPDX-License-Identifier: GPL-2.0
  r8a77980 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2018 Renesas Electronics Corp.
  Copyright (C) 2018 Cogent Embedded, Inc.
  Based on r8a7795-cpg-mssr.c
  Copyright (C) 2015 Glider bvba
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-AP (GIC) 
  CPG Clock Data
    MD		EXTAL		PLL2	PLL1	PLL3	OSC
  14 13	(MHz)
  --------------------------------------------------------
  0  0		16.66 x 1	x240	x192	x192	16
  0  1		20    x 1	x200	x160	x160	19
  1  0		27    x 1	x148	x118	x118	26
  1  1		33.33  2	x240	x192	x192	32
 EXTAL div	PLL1 multdiv	PLL3 multdiv	OSC prediv 
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  r8a7742 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2020 Renesas Electronics Corp.
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-SYS (GIC) 
  CPG Clock Data
     MD	EXTAL		PLL0	PLL1	PLL3
  14 13 19	(MHz)		1	1
 ---------------------------------------------------
  0  0  0	15		x1722	x2082	x106
  0  0  1	15		x1722	x2082	x88
  0  1  0	20		x1302	x1562	x80
  0  1  1	20		x1302	x1562	x66
  1  0  0	26  2		x2002	x2402	x122
  1  0  1	26  2		x2002	x2402	x102
  1  1  0	30  2		x1722	x2082	x106
  1  1  1	30  2		x1722	x2082	x88
  1 :	Table 7.5a indicates VCO output (PLLx = VCO2)
 EXTAL div	PLL1 mult	PLL3 mult 
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  Renesas R-Car USB2.0 clock selector
  Copyright (C) 2017 Renesas Electronics Corp.
  Based on renesas-cpg-mssr.c
  Copyright (C) 2015 Glider bvba
  This module seems a mux, but this driver assumes a gate because
  ehciohci platform drivers don't support clk_set_parent() for now.
  If this driver acts as a gate, ehciohci-platform drivers don't need
  any modification.
 SPDX-License-Identifier: GPL-2.0
  R-Car Gen2 Clock Pulse Generator
  Copyright (C) 2016 Cogent Embedded Inc.
  Z Clock
  Traits of this clock:
  prepare - clk_prepare only ensures that parents are prepared
  enable - clk_enable only ensures that parents are enabled
  rate - rate is adjustable.  clk->rate = parent->rate  mult  32
  parent - fixed parent.  No clk_set_parent support
	
	  Set KICK bit in FRQCRB to update hardware setting and wait for
	  clock change completion.
	
	  Note: There is no HW information about the worst case latency.
	 
	  Using experimental measurements, it seems that no more than
	  ~10 iterations are needed, independently of the CPU rate.
	  Since this value might be dependent on external xtal rate, pll1
	  rate or even the other emulation clocks rate, use 1000 as a
	  "super" safe value.
 ADSP divisors 
 SDHI divisors 
 Skip first clock in SD table 
 sentinel  }
 R-Car Gen2 
		
		  PLL0 is a  configurable multiplier clock except on R-Car
		  V2HE2. Register the PLL0 clock as a fixed factor clock for
		  now as there's no generic multiplier clock implementation and
		  we  currently  have no need to change  the multiplier value.
 SPDX-License-Identifier: GPL-2.0
  r8a7740 Core CPG Clocks
  Copyright (C) 2014  Ulrich Hecht
 extal1 
 extal1 
 extalr 
		 PLLC01 are configurable multiplier clocks. Register them as
		  fixed factor clocks for now as there's no generic multiplier
		  clock implementation and we currently have no need to change
		  the multiplier value.
 extal2 
		 We're leaking memory on purpose, there's no point in cleaning
		  up as the system won't boot anyway.
 SPDX-License-Identifier: GPL-2.0
  r8a73a4 Core CPG Clocks
  Copyright (C) 2014  Ulrich Hecht
 extal1 
 extal1  2 
 extal2 
 extal2  2 
		 PLL01 are configurable multiplier clocks. Register them as
		  fixed factor clocks for now as there's no generic multiplier
		  clock implementation and we currently have no need to change
		  the multiplier value.
 XXX: enable bit? 
 XXX: enable bit? 
		 We're leaking memory on purpose, there's no point in cleaning
		  up as the system won't boot anyway.
 SPDX-License-Identifier: GPL-2.0
  R9A06G032 clock driver
  Copyright (C) 2018 Renesas Electronics Europe Limited
  Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
 This is used to describe a clock for instantiation 
 source index + 1 (0 == none) 
 these are used to populate the bitsel struct 
 for dividers 
 For fixed-factor ones 
 for dual gate 
 Internal clock IDs 
	
	  These are not hardware clocks, but are needed to handle the special
	  case where we have a 'selector bit' that doesn't just change the
	  parent for a clock, but also the gate it's supposed to use.
 R9A06G032_SYSCTRL_REG_PWRCTRL_PG1_PR2 
 R9A06G032_SYSCTRL_REG_PWRCTRL_PG0_0 
 protects concurrent access to gates 
 registerbit pairs are encoded as an uint16_t 
  This implements the R9A06G032 clock gate 'driver'. We cannot use the system's
  clock gate framework as the gates on the R9A06G032 have a special enabling
  sequence, therefore we use this little proxy.
 De-assert reset 
 Hardware manual recommends 5us delay after enabling clock & reset 
	 If the peripheral is memory mapped (i.e. an AXI slave), there is an
	  associated SLVRDY bit in the System Controller that needs to be set
	  so that the FlexWAY bus fabric passes on the readwrite requests.
 Clear 'Master Idle Request' bit 
 Note: We don't wait for FlexWAY Socket Connection signal 
 if clock is in reset, the gate might be on, and still not 'be' on 
	
	  important here, some clocks are already in use by the CM3, we
	  have to assume they are not Linux's to play with and try to disable
	  at the end of the boot!
 we know there are no more than 8 
  Attempts to find a value that is in range of min,max,
  and if a table of set dividers was specified for this
  register, try to find the fixed divider that is the closest
  to the target frequency
 + 1 to cope with rates that have the remainder dropped 
			
			  select the divider that generates
			  the value closest to the ideal frequency
	
	  this is a hack. Currently the serial driver asks for a clock rate
	  that is 16 times the baud rate -- and that is wildly outside the
	  range of the UART divider, somehow there is no provision for that
	  case of 'let the divider as is if outside range'.
	  The serial driver shouldn't play with these clocks anyway, there's
	  several uarts attached to this divider, and changing this impacts
	  everyone.
 + 1 to cope with rates that have the remainder dropped 
	
	  Need to write the bit 31 with the divider value to
	  latch it. Technically we should wait until it has been
	  cleared too.
	  TODO: Find whether this callback is sleepable, in case
	  the hardware does require some sort of spinloop here.
 populate (optional) divider table fixed values 
  This clock provider handles the case of the R9A06G032 where you have
  peripherals that have two potential clock source and two gates, one for
  each of the clock source - the used clock source (for all sub clocks)
  is selected by a single bit.
  That single bit affects all sub-clocks, and therefore needs to change the
  active gate (and turn the others off) and force a recalculation of the rates.
  This implements two clock providers, one 'bitselect' that
  handles the switch between both parents, and another 'dualgate'
  that knows which gate to poke at, depending on the parent's bit position.
 selector register + bit 
 a single bit in the register selects one of two parent clocks 
 allocate the gate 
 selector register + bit 
 we always turn off the 'other' gate, regardless 
 allocate the gate 
	
	  important here, some clocks are already in use by the CM3, we
	  have to assume they are not Linux's to play with and try to disable
	  at the end of the boot!
 keep that selector register around 
 SPDX-License-Identifier: GPL-2.0
  R-Car Gen3 Clock Pulse Generator Library
  Copyright (C) 2015-2018 Glider bvba
  Copyright (C) 2019 Renesas Electronics Corp.
  Based on clk-rcar-gen3.c
  Copyright (C) 2015 Renesas Electronics Corp.
  SDn Clock
 SDn divider
            sd_srcfc   sd_fc   div
  stp_hck   (div)      (div)     = sd_srcfc x sd_fc
 ---------------------------------------------------------
   0         0 (1)      1 (4)      4 : SDR104  HS200  HS400 (8 TAP)
   0         1 (2)      1 (4)      8 : SDR50
   1         2 (4)      1 (4)     16 : HS  SDR25
   1         3 (8)      1 (4)     32 : NS  SDR12
   1         4 (16)     1 (4)     64
   0         0 (1)      0 (2)      2
   0         1 (2)      0 (2)      4 : SDR104  HS200  HS400 (4 TAP)
   1         2 (4)      0 (2)      8
   1         3 (8)      0 (2)     16
   1         4 (16)     0 (2)     32
   NOTE: There is a quirk option to ignore the first row of the dividers
   table when searching for suitable settings. This is because HS400 on
   early ES versions of H3 and M3-W requires a specific setting to work.
	CPG_SD_DIV_TABLE_DATA(stp_hck,  sd_srcfc,   sd_fc,  sd_div) 
	
	  One notifier covers both RPC and RPCD2 clocks as they are both
	  controlled by the same RPCCKCR register...
 SPDX-License-Identifier: GPL-2.0
  r8a7791 Clock Pulse Generator  Module Standby and Software Reset
  Copyright (C) 2015-2017 Glider bvba
  Based on clk-rcar-gen2.c
  Copyright (C) 2013 Ideas On Board SPRL
 Core Clock Outputs exported to DT 
 External Input Clocks 
 Internal Core Clocks 
 Module Clocks 
 External Clock Inputs 
 Internal Core Clocks 
 Core Clock Outputs 
 RWDT 
 INTC-SYS (GIC) 
  CPG Clock Data
    MD		EXTAL		PLL0	PLL1	PLL3
  14 13 19	(MHz)		1	1
 ---------------------------------------------------
  0  0  0	15		x1722	x2082	x106
  0  0  1	15		x1722	x2082	x88
  0  1  0	20		x1302	x1562	x80
  0  1  1	20		x1302	x1562	x66
  1  0  0	26  2		x2002	x2402	x122
  1  0  1	26  2		x2002	x2402	x102
  1  1  0	30  2		x1722	x2082	x106
  1  1  1	30  2		x1722	x2082	x88
  1 :	Table 7.5a indicates VCO output (PLLx = VCO2)
 R-Car M2-N uses a 15 divider for ZG 
 Core Clocks 
 Module Clocks 
 Critical Module Clocks 
 Callbacks 
 SPDX-License-Identifier: GPL-2.0
  r8a7778 Core CPG Clocks
  Copyright (C) 2014  Ulrich Hecht
 PLL multipliers per bits 11, 12, and 18 of MODEMR 
 Clock dividers per bits 1 and 2 of MODEMR 
		 We're leaking memory on purpose, there's no point in cleaning
		  up as the system won't boot anyway.
 SPDX-License-Identifier: GPL-2.0
  r8a7779 Core CPG Clocks
  Copyright (C) 2013, 2014 Horms Solutions Ltd.
  Contact: Simon Horman <horms@verge.net.au>
 -----------------------------------------------------------------------------
  CPG Clock Data
 		MD1 = 1			MD1 = 0
 		(PLLA = 1500)		(PLLA = 1600)
 		(MHz)			(MHz)
 ------------------------------------------------+--------------------
  clkz		1000   (23)		800   (12)
  clkzs	 250   (16)		200   (18)
  clki		 750   (12)		800   (12)
  clks		 250   (16)		200   (18)
  clks1	 125   (112)		100   (116)
  clks3	 187.5 (18)		200   (18)
  clks4	  93.7 (116)		100   (116)
  clkp		  62.5 (124)		 50   (132)
  clkg		  62.5 (124)		 66.6 (124)
  clkb, CLKOUT
  (MD2 = 0)	  62.5 (124)		 66.6 (124)
  (MD2 = 1)	  41.6 (136)		 50   (132)
    MD		PLLA Ratio
  12 11
 ------------------------
  0  0		x42
  0  1		x48
  1  0		x56
  1  1		x64
 -----------------------------------------------------------------------------
  Initialization
		 We're leaking memory on purpose, there's no point in cleaning
		  up as the system won't boot anyway.
 SPDX-License-Identifier: GPL-2.0
  R-Car Gen3 Clock Pulse Generator
  Copyright (C) 2015-2018 Glider bvba
  Copyright (C) 2019 Renesas Electronics Corp.
  Based on clk-rcar-gen3.c
  Copyright (C) 2015 Renesas Electronics Corp.
 PLL Enable Control Register 
 PLLn Circuit Status 
 PLLn Control Registers 
 PLL Circuit Mult. Ratio 
 RCLK Clock Source Select 
 PLL Clocks 
 PLL refclk x (setting + 1) x mult 
  Z Clock & Z2 Clock
  Traits of this clock:
  prepare - clk_prepare only ensures that parents are prepared
  enable - clk_enable only ensures that parents are enabled
  rate - rate is adjustable.
         clk->rate = (parent->rate  mult  32 )  fixed_div
  parent - fixed parent.  No clk_set_parent support
 Maximum rate for normal mode 
 Set parent rate to initial value for normal modes 
 Set increased parent rate for boost modes 
	
	  Set KICK bit in FRQCRB to update hardware setting and wait for
	  clock change completion.
	
	  Note: There is no HW information about the worst case latency.
	 
	  Using experimental measurements, it seems that no more than
	  ~10 iterations are needed, independently of the CPU rate.
	  Since this value might be dependent on external xtal rate, pll1
	  rate or even the other emulation clocks rate, use 1000 as a
	  "super" safe value.
 PLLVCO x 1div x SYS-CPU divider 
 Missing PLL024 post-divider 
 Manual RCLK parent selection 
 Skip first clock in SD table 
 sentinel  }
 some types use high bits 
		
		  PLL0 is implemented as a custom clock, to change the
		  multiplier when cpufreq changes between normal and boost
		  modes.
		
		  PLL2 is implemented as a custom clock, to change the
		  multiplier when cpufreq changes between normal and boost
		  modes.
		
		  PLL4 is a configurable multiplier clock. Register it as a
		  fixed factor clock for now as there's no generic multiplier
		  clock implementation and we currently have no need to change
		  the multiplier value.
			
			  RINT is default.
			  Only if EXTALR is populated, we switch to it.
 Select parent clock of RCLK by MD28 
		
		  Clock selectable between two parents and two fixed dividers
		  using a mode pin
		
		  Clock combining OSC EXTAL predivider and a fixed divider
		
		  Clock selectable between two parents and two fixed dividers
		  using RCKCR.CKSEL
		
		  Register RPCSRC as fixed factor clock based on the
		  MD[4:1] pins and CPG_RPCCKCR[4:3] register value for
		  which has been set prior to booting the kernel.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2014 Google, Inc.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2014 Google, Inc.
 Fractional PLL operating modes 
 calculate vco 
 set operating mode 
 get operating mode (intfrac) and calculate rate accordingly 
 SPDX-License-Identifier: GPL-2.0-only
  Pistachio SoC clock controllers
  Copyright (C) 2014 Google, Inc.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2015 Heiko Stuebner <heiko@sntech.de>
 sentinel  },
 sentinel  },
 cluster_b: aclkm in clksel0, rest in clksel1 
 cluster_l: aclkm in clksel2, rest in clksel3 
	
	  Clock-Architecture Diagram 2
	
	  stclk_mcu is listed as child of fclk_mcu_src in diagram 5,
	  but stclk_mcu has an additional own divider in diagram 2
	
	  Clock-Architecture Diagram 3
	
	  We use aclk_vdpu by default ---GRF_SOC_CON0[7] setting in system,
	  so we ignore the mux and make clocks nodes as following,
 sclk_timer has a gate in the sgrf 
	
	  Clock-Architecture Diagram 4
 pmu_grf_soc_con0[6] allows to select between xin32k and pvtm_pmu 
 pmu_grf_soc_con0[6] allows to select between xin32k and pvtm_pmu 
	
	  Clock-Architecture Diagram 5
 aclk_cci_pre gates 
 aclkm_core_ gates 
 armclk gates 
 sclk_cs_pre gates 
 aclk_bus gates 
 sclk_ddr gates 
 clk_hsadc_tsp is part of diagram2 
 fclk_mcu_src gates 
 hclk_cpu gates 
 pclk_cpu gates 
	
	  video clk gates
	  aclk_video(_pre) can actually select between parents of aclk_vdpu
	  and aclk_vepu by setting bit GRF_SOC_CON0[7].
 aclk_rga_pre gates 
 aclk_vio0 gates 
 sclk_isp gates 
 hclk_vio gates 
	
	  pclk_vio gates
	  pclk_vio comes from the exactly same source as hclk_vio
 ext_vip gates in diagram3 
 gpu gates 
 aclk_peri gates 
 hclk_peri gates 
 pclk_peri gates 
 pclk_pd_alive gates 
 Watchdog pclk is controlled by sgrf_soc_con3[7]. 
	
	  pclk_vio gates
	  pclk_vio comes from the exactly same source as hclk_vio
 pclk_pd_pmu gates 
 timer gates 
	
	  pwm1 supplies vdd_logic on a lot of boards, is currently unhandled
	  but needs to stay enabled there (including its parents) at all times.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2016 Rockchip Electronics Co. Ltd.
  Author: Elaine <zhangqing@rock-chips.com>
 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac 
 sentinel  },
 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac 
 vco = 1016064000 
 vco = 983040000 
 vco = 983040000 
 vco = 860156000 
 vco = 903168000 
 vco = 819200000 
 sentinel  },
	
	  Clock-Architecture Diagram 1
 PD_MISC 
	
	  Clock-Architecture Diagram 2
 PD_CORE 
 PD_GPU 
 PD_DDR 
	
	  Clock-Architecture Diagram 3
 PD_BUS 
 PD_I2S 
 PD_UART 
	
	  Clock-Architecture Diagram 4
	
	  Clock-Architecture Diagram 5
 PD_VIDEO 
	
	  Clock-Architecture Diagram 6
 PD_VIO 
	
	  Clock-Architecture Diagram 7
 PD_PERI 
	
	  Clock-Architecture Diagram 8
 PD_GMAC 
	
	  Clock-Architecture Diagram 9
 PD_VOP 
 PD_PERI 
 PD_GMAC 
 PD_BUS 
 Watchdog pclk is controlled from the secure GRF 
 PD_MMC 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2014 MundoReader S.L.
  Author: Heiko Stuebner <heiko@sntech.de>
  Copyright (c) 2016 Rockchip Electronics Co. Ltd.
  Author: Xing Zheng <zhengxing@rock-chips.com>
  based on
  samsungclk.c
  Copyright (c) 2013 Samsung Electronics Co., Ltd.
  Copyright (c) 2013 Linaro Ltd.
  Author: Thomas Abraham <thomas.ab@samsung.com>
  Register a clock branch.
  Most clock branches have a form like
  src1 --|--\
         |M |--[GATE]-[DIV]-
  src2 --|--
  sometimes without one of those components.
		
		  The POST_RATE_CHANGE notifier runs directly after the
		  divider clock is set in clk_change_rate, so we'll have
		  remuxed back to the original parent before clk_change_rate
		  reaches the mux itself.
  fractional divider must set that denominator is 20 times larger than
  numerator to generate precise clock frequency.
 notifier on the fraction divider to catch rate changes 
 without gate, register a simple factor clock 
 catch simple muxes 
 none of the cases above matched 
 Protect the clocks that needs to stay on 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2021 Rockchip Electronics Co. Ltd.
  Author: Elaine Zhang <zhangqing@rock-chips.com>
 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac 
 sentinel  },
	
	  Clock-Architecture Diagram 1
 SRC_CLK 
 PD_CORE 
 PD_GPU 
 PD_NPU 
 PD_DDR 
 PD_GIC_AUDIO 
 PD_SECURE_FLASH 
 PD_PIPE 
 PD_PHP 
 PD_USB 
 PD_PERI 
 PD_VI 
 PD_VO 
 PD_VPU 
 PD_RGA 
 PD_RKVENC 
 PD_BUS 
 PD_TOP 
 PD_PMU 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2016 Rockchip Electronics Co. Ltd.
  Author: Lin Huang <hl@rock-chips.com>
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2015 Rockchip Electronics Co. Ltd.
  Author: Xing Zheng <zhengxing@rock-chips.com>
          Jeffy Chen <jeffy.chen@rock-chips.com>
 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac 
 sentinel  },
	
	  Clock-Architecture Diagram 1
 PD_DDR 
 PD_CORE 
 PD_MISC 
 PD_BUS 
 PD_VIDEO 
 PD_VIO 
 PD_PERI 
	
	  Clock-Architecture Diagram 2
 PD_UART 
	
	  Clock-Architecture Diagram 3
 PD_VOP 
 PD_PERI 
 PD_GPU 
 PD_BUS 
 PD_MMC 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2014 MundoReader S.L.
  Author: Heiko Stuebner <heiko@sntech.de>
 sentinel  },
 2 ^ (val + 1) 
 sentinel  },
	
	  Clock-Architecture Diagram 2
 these two are set by the cpuclk and should not be changed 
	
	  the 480m are generated inside the usb block from these clocks,
	  but they are also a source for the hsicphy clock.
	
	  Clock-Architecture Diagram 4
 clk_core_pre gates 
 aclk_cpu gates 
 hclk_cpu gates 
 hclk_ahb2apb is part of a clk branch 
 hclk_peri gates 
 aclk_lcdc0_pre gates 
 aclk_lcdc1_pre gates 
 atclk_cpu gates 
 pclk_cpu gates 
 aclk_peri 
 pclk_peri gates 
 sentinel  },
 sentinel  },
 do not source aclk_cpu_pre from the apll, to keep complexity down 
 reparent aclk_cpu_pre from apll 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2017 Rockchip Electronics Co. Ltd.
  Author: Elaine <zhangqing@rock-chips.com>
 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac 
 sentinel  },
	
	  Clock-Architecture Diagram 1
 PD_DDR 
 PD_CORE 
 PD_MISC 
 PD_CPU 
 PD_VIDEO 
 PD_VIO 
 PD_PERI 
	
	  Clock-Architecture Diagram 2
 PD_UART 
	
	  Clock-Architecture Diagram 3
 PD_VOP 
 PD_PERI 
 PD_BUS 
 PD_MMC 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2014 MundoReader S.L.
  Author: Heiko Stuebner <heiko@sntech.de>
  Copyright (c) 2015 Rockchip Electronics Co. Ltd.
  Author: Xing Zheng <zhengxing@rock-chips.com>
 Assumming rate_table is in descending order 
 return minimum supported value 
  Wait for the pll to reach the locked state.
  The calling set_rate function is responsible for making sure the
  grf regmap is available.
  PLL used in RK3036
	
	  Lock time typical 250, max 500 input clock cycles @24MHz
	  So define a very safe maximum of 1000us, meaning 24000 cycles.
 fractional mode 
 update pll values 
 GPLL CON2 is not HIWORD_MASK 
 wait for the pll to lock 
 Get required rate settings from table 
 when no rate setting for the current rate, rely on clk_set_rate 
  PLL used in RK3066, RK3188 and RK3288
 enter reset mode 
 update pll values 
 leave reset and wait the reset_delay 
 wait for the pll to lock 
 Get required rate settings from table 
 when no rate setting for the current rate, rely on clk_set_rate 
  PLL used in RK3399
	
	  Lock time typical 250, max 500 input clock cycles @24MHz
	  So define a very safe maximum of 1000us, meaning 24000 cycles.
 fractional mode 
 update pll values 
 xPLL CON2 is not HIWORD_MASK 
 wait for the pll to lock 
 Get required rate settings from table 
 when no rate setting for the current rate, rely on clk_set_rate 
  Common registering of pll clocks
 name the actual pll 
 create the mux on top of the real pll 
 the actual muxing is xin24m, pll-output, xin32k 
 now create the actual pll 
 keep all plls untouched for now 
 find count of rates in rate_table 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 MundoReader S.L.
  Author: Heiko Stuebner <heiko@sntech.de>
  based on clksamsungclk-cpu.c
  Copyright (c) 2014 Samsung Electronics Co., Ltd.
  Author: Thomas Abraham <thomas.ab@samsung.com>
  A CPU clock is defined as a clock supplied to a CPU or a group of CPUs.
  The CPU clock is typically derived from a hierarchy of clock
  blocks which includes mux and divider blocks. There are a number of other
  auxiliary clocks supplied to the CPU domain such as the debug blocks and AXI
  clock for CPU domain. The rates of these auxiliary clocks are related to the
  CPU clock rate and this relation is usually specified in the hardware manual
  of the SoC or supplied after the SoC characterization.
  The below implementation of the CPU clock allows the rate changes of the CPU
  clock and the corresponding rate changes of the auxillary clocks of the CPU
  domain. The platform clock driver provides a clock register configuration
  for each configurable rate which is then used to program the clock hardware
  registers to acheive a fast co-oridinated rate change for all the CPU domain
  clocks.
  On a rate change request for the CPU clock, the rate change is propagated
  upto the PLL supplying the clock to the CPU domain clock blocks. While the
  CPU domain PLL is reconfigured, the CPU domain clocks are driven using an
  alternate clock source. If required, the alternate clock source is divided
  down in order to keep the output clock rate within the previous OPP limits.
  struct rockchip_cpuclk: information about clock supplied to a CPU core.
  @hw:		handle between ccf and cpu clock.
  @alt_parent:	alternate parent clock to use when switching the speed
 		of the primary parent clock.
  @reg_base:	base register for cpu-clock values.
  @clk_nb:	clock notifier registered for changes in clock speed of the
 		primary parent clock.
  @rate_count:	number of rates in the rate_table
  @rate_table:	pll-rates and their associated dividers
  @reg_data:	cpu-specific register settings
  @lock:	clock lock
 alternate parent is active now. set the dividers 
 check validity of the new rate 
	
	  If the old parent clock speed is less than the clock speed
	  of the alternate parent, then it should be ensured that at no point
	  the armclk speed is more than the old_rate until the dividers are
	  set.
 calculate dividers 
		
		  Change parents and add dividers in a single transaction.
		 
		  NOTE: we do this in a single transaction so we're never
		  dividing the primary parent by the extra dividers that were
		  needed for the alt.
 select alternate parent 
	
	  post-rate change event, re-mux to primary parent and remove dividers.
	 
	  NOTE: we do this in a single transaction so we're never dividing the
	  primary parent by the extra dividers that were needed for the alt.
 remove dividers 
  This clock notifier is called when the frequency of the parent clock
  of cpuclk is to be changed. This notifier handles the setting up all
  the divider clocks, remux to temporary parent and handling the safe
  frequency levels when using temporary parent.
 only allow rate changes when we have a rate table 
 disallow automatic parent changes by ccf 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2014 MundoReader S.L.
  Author: Heiko Stuebner <heiko@sntech.de>
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2014 MundoReader S.L.
  Author: Heiko Stuebner <heiko@sntech.de>
 sentinel  },
 sentinel },
	
	  Clock-Architecture Diagram 1
	
	  Clock-Architecture Diagram 2
	
	  Clock-Architecture Diagram 3
	
	  Clock-Architecture Diagram 4
 aclk_cpu gates 
 hclk_cpu gates 
 pclk_cpu gates 
 ddrctrl [DDR Controller PHY clock] gates 
 ddrphy gates 
 aclk_peri gates 
 hclk_peri gates 
 pclk_peri gates 
 sclk_gpu gates 
 pclk_pd_alive gates 
 Watchdog pclk is controlled by RK3288_SGRF_SOC_CON0[1]. 
 pclk_pd_pmu gates 
 hclk_vio gates 
 aclk_vio0 gates 
 aclk_vio1 gates 
 aclk_rga_pre gates 
	
	  Other ungrouped clocks.
 pwm-regulators on some boards, so handoff-critical later 
  Some CRU registers will be reset in maskrom when the system
  wakes up from fastboot.
  So save them before suspend, restore them after resume.
 We turn aclk_dmac1 on for suspend; this will restore it 
	
	  Going into deep sleep (specifically setting PMU_CLR_DMA in
	  RK3288_PMU_PWRMODE_CON1) appears to fail unless
	  "aclk_dmac1" is on.
	
	  Switch PLLs other than DPLL (for SDRAM) to slow mode to
	  avoid crashes on resume. The Mask ROM on the system will
	  put APLL, CPLL, and GPLL into slow mode at resume time
	  anyway (which is why we restore them), but we might not
	  even make it to the Mask ROM if this isn't done at suspend
	  time.
	 
	  NOTE: only APLL truly matters here, but we'll do them all.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2016 Rockchip Electronics Co. Ltd.
  Author: Shawn Lin <shawn.lin@rock-chips.com>
          Andy Yan <andy.yan@rock-chips.com>
 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac 
 sentinel  },
	
	  Clock-Architecture Diagram 2
 PD_CORE 
 PD_RKVENC 
 PD_RKVDEC 
 PD_PMU_wrapper 
	
	  Clock-Architecture Diagram 3
 PD_DSP_wrapper 
	
	  Clock-Architecture Diagram 4
	
	  Clock-Architecture Diagram 5
 PD_BUS 
 PD_DDR 
	
	  Clock-Architecture Diagram 6
 PD_PERI 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 Fuzhou Rockchip Electronics Co., Ltd
	
	  The maximum divider we can use without overflowing
	  unsigned long in rate  i below
			
			  It's the most ideal case if the requested rate can be
			  divided from parent clock without needing to change
			  parent rate, so return the divider immediately.
  Register a clock branch.
  Most clock branches have a form like
  src1 --|--\
         |M |--[GATE]-[DIV]-
  src2 --|--
  sometimes without one of those components.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2014 MundoReader S.L.
  Author: Heiko Stuebner <heiko@sntech.de>
  Copyright (c) 2015 Rockchip Electronics Co. Ltd.
  Author: Xing Zheng <zhengxing@rock-chips.com>
 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac 
 sentinel  },
	
	  Clock-Architecture Diagram 1
	
	  Clock-Architecture Diagram 2
	
	  Clock-Architecture Diagram 3
 aclk_cpu gates 
 hclk_cpu gates 
 pclk_cpu gates 
 aclk_vio gates 
 xin24m gates 
 aclk_peri gates 
 hclk_peri gates 
 pclk_peri gates 
	
	  Make uart_pll_clk a child of the gpll, as all other sources are
	  not that usable  stable.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2018 Rockchip Electronics Co. Ltd.
  Author: Elaine Zhang<zhangqing@rock-chips.com>
 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac 
 sentinel  },
	
	  Clock-Architecture Diagram 1
	
	  Clock-Architecture Diagram 3
 PD_CORE 
 PD_GPU 
	
	  Clock-Architecture Diagram 4
 PD_DDR 
	
	  Clock-Architecture Diagram 5
 PD_VI 
	
	  Clock-Architecture Diagram 6
 PD_VO 
 PD_VPU 
	
	  Clock-Architecture Diagram 7
 PD_MMC_NAND 
 PD_SDCARD 
 PD_USB 
 PD_GMAC 
	
	  Clock-Architecture Diagram 8
 PD_BUS 
 PD_CRYPTO 
	
	  Clock-Architecture Diagram 9
 PD_BUS_TOP 
 PD_VI 
 PD_VO 
 PD_BUS 
 aclk_dmac is controlled by sgrf_soc_con1[11]. 
 PD_VPU 
 PD_CRYPTO 
 PD_SDCARD 
 PD_PERI 
 PD_MMC_NAND 
 PD_USB 
 PD_GMAC 
	
	  Clock-Architecture Diagram 2
	
	  Clock-Architecture Diagram 9
 PD_PMU 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2016 Rockchip Electronics Co. Ltd.
  Author: Xing Zheng <zhengxing@rock-chips.com>
 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac 
 sentinel  },
 CRU parents 
 PMU CRU parents 
 cluster_l: aclkm in clksel0, rest in clksel1 
 cluster_b: aclkm in clksel2, rest in clksel3 
	
	  CRU Clock-Architecture
 usbphy 
 little core 
 big core 
 gmac 
 spdif 
 i2s 
 uart 
 cci 
 vcodec 
 vdu 
 iep 
 rga 
 center 
 gpu 
 perihp 
 sdio & sdmmc 
 pcie 
 emmc 
 perilp0 
 aclk_perilp0 gates 
 hclk_perilp0 gates 
 pclk_perilp0 gates 
 crypto 
 cm0s_perilp 
 fclk_cm0s gates 
 perilp1 
 hclk_perilp1 gates 
 pclk_perilp1 gates 
 saradc 
 tsadc 
 cif_testout 
 vio 
 hdcp 
 edp 
 hdmi 
 vop0 
 vop1 
 isp 
	
	  We use pclkin_cifinv by default GRF_SOC_CON20[9] (GSC20_9) setting in system,
	  so we ignore the mux and make clocks nodes as following,
	 
	  pclkin_cifinv --|-------\
	                  |GSC20_9|-- pclkin_cifmux -- |G27_6| -- pclkin_isp1_wrapper
	  pclkin_cif    --|-------
 cif 
 gic 
 alive 
 pclk_alive_gpll_src is controlled by PMUGRF_SOC_CON0[6] 
 Watchdog pclk is controlled by RK3399 SECURE_GRF_SOC_CON3[8]. 
 testout 
 spi 
 i2c 
 timer 
 clk_test 
 clk_test_pre is controlled by CRU_MISC_CON[3] 
 ddrc 
	
	  PMU CRU Clock-Architecture
 pmu clock gates 
 ddrc 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2014 Google, Inc
  Author: Alexandru M Stan <amstan@chromium.org>
  Each fine delay is between 44ps-77ps. Assume each fine delay is 60ps to
  simplify calculations. So 45degs could be anywhere between 33deg and 57.8deg.
 Constant signal, no measurable phase shift 
 degreesdelaynum  1000000 
	
	  The below calculation is based on the output clock from
	  MMC host to the card, which expects the phase clock inherits
	  the clock rate from its parent, namely the output clock
	  provider of MMC host. However, things may go wrong if
	  (1) It is orphan.
	  (2) It is assigned to the wrong parent.
	 
	  This check help debug the case (1), which seems to be the
	  most likely problem we often face and which makes it difficult
	  for people to debug unstable mmc tuning results.
	
	  Due to the inexact nature of the "fine" delay, we might
	  actually go non-monotonic.  We don't go _too_ monotonic
	  though, so we should be OK.  Here are options of how we may
	  work:
	 
	  Ideally we end up with:
	    1.0, 2.0, ..., 69.0, 70.0, ...,  89.0, 90.0
	 
	  On one extreme (if delay is actually 44ps):
	    .73, 1.5, ..., 50.6, 51.3, ...,  65.3, 90.0
	  The other (if delay is actually 77ps):
	    1.3, 2.6, ..., 88.6. 89.8, ..., 114.0, 90
	 
	  It's possible we might make a delay that is up to 25
	  degrees off from what we think we're making.  That's OK
	  though because we should be REALLY far from any bad range.
	
	  Convert to delay; do a little extra work to make sure we
	  don't overflow 32-bit  64-bit numbers.
 PSECS_PER_SEC  10000  10 
	
	  rockchip_mmc_clk is mostly used by mmc controllers to sample
	  the intput data, which expects the fixed phase after the tuning
	  process. However if the clock rate is changed, the phase is stale
	  and may break the data sampling. So here we try to restore the phase
	  for that case, except that
	  (1) cached_phase is invaild since we inevitably cached it when the
	  clock provider be reparented from orphan to its real parent in the
	  first place. Otherwise we may mess up the initialization of MMC cards
	  since we only set the default sample phase and drive phase later on.
	  (2) the new coming rate is higher than the older one since mmc driver
	  set the max-frequency to match the boards' ability but we can't go
	  over the heads of that, otherwise the tests smoke out the issue.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2019 Rockchip Electronics Co. Ltd.
  Author: Finley Xiao <finley.xiao@rock-chips.com>
 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac 
 sentinel  },
	
	  Clock-Architecture Diagram 1
	
	  Clock-Architecture Diagram 2
	
	  Clock-Architecture Diagram 3
	
	  Clock-Architecture Diagram 4
	
	  Clock-Architecture Diagram 5
	
	  Clock-Architecture Diagram 6
	
	  Clock-Architecture Diagram 7
	
	  Clock-Architecture Diagram 8
 aclk_dmaci0 is controlled by sgrf_clkgat_con. 
 aclk_dmac1 is controlled by sgrf_clkgat_con. 
 watchdog pclk is controlled by sgrf_clkgat_con. 
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015 Heiko Stuebner <heiko@sntech.de>
  Synopsys AXS10X SDP Generic PLL clock driver
  Copyright (C) 2017 Synopsys
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 PLL registers addresses 
  Bit fields of the PLL IDIVFBDIVODIV registers:
   ________________________________________________________________________
  |31                15|    14    |   13   |  12  |11         6|5         0|
  |-------RESRVED------|-NOUPDATE-|-BYPASS-|-EDGE-|--HIGHTIME--|--LOWTIME--|
  |____________________|__________|________|______|____________|___________|
  Following macros determine the way of access to these registers
  They should be set up only using the macros.
  reg should be an u32 variable.
 100 us 
			
			  Wait until CGU relocks and check error status.
			  If after timeout CGU is unlocked yet return error
  Synopsys AXS10X SDP I2S PLL clock driver
  Copyright (C) 2016 Synopsys
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 PLL registers addresses 
 27 Mhz 
 28.224 Mhz 
 SPDX-License-Identifier: GPL-2.0-only
  Purna Chandra Mandal,<purna.mandal@microchip.com>
  Copyright (C) 2015 Microchip Technology Inc.  All rights reserved.
 FRC Postscaler 
 SPLL fields 
 step of div_4 -> div_2 -> no_div 
 PIC32MZDA clock data 
 SYSCLK is now running from BFRCCLK. Report clock failure. 
 TODO: detect reason of failure and recover accordingly 
 register fixed rate clocks 
 fixed rate (optional) clock 
 divider clock 
 PLL ICLK mux 
 PLL 
 SYSTEM clock 
 Peripheral bus clocks 
 Reference oscillator clock 
 register clkdev 
 register clock provider 
 force enable critical clocks 
 register NMI for failsafe clock monitor 
 SPDX-License-Identifier: GPL-2.0-only
  Purna Chandra Mandal,<purna.mandal@microchip.com>
  Copyright (C) 2015 Microchip Technology Inc.  All rights reserved.
 OSCCON Reg fields 
 SPLLCON Reg fields 
 Peripheral Bus Clock Reg Fields 
 Reference Oscillator Control Reg fields 
 Reference Oscillator Trim Register Fields 
 Mux Slew Control Register fields 
 Clock Poll Timeout 
 SoC specific clock needed during SPLL clock rate switch 
 add instruction pipeline delay while CPU clock is in-transition. 
 Perpheral bus clocks 
	 eq. clk_rate = parent_rate  divider.
	 
	  Find best divider to produce closest of target divided rate.
 check & wait for DIV_READY 
 calculate clkdiv and best rate 
 apply new div 
 wait again for DIV_READY 
 confirm that new div is applied correctly 
 Reference oscillator operations 
 initialize clock in disabled state 
	 fout = fin  [2  {div + (trim  512)}]
	 	= fin  512  [1024  div + 2  trim]
	 	= fin  256  (512  div + trim)
	 	= (fin << 8)  ((div << 9) + trim)
	 Find integer approximation of floating-point arithmetic.
	       fout = fin  [2  {rodiv + (rotrim  512)}] ... (1)
	  i.e. fout = fin  2  DIV
	       whereas DIV = rodiv + (rotrim  512)
	 
	  Since kernel does not perform floating-point arithmatic so
	  (rotrim512) will be zero. And DIV & rodiv will result same.
	 
	  ie. fout = (fin  256)  [(512  rodiv) + rotrim]  ... from (1)
	  ie. rotrim = ((fin  256)  fout) - (512  DIV)
 get rodiv 
 get trim 
 calculate dividers for new rate 
 caclulate new rate (rounding) based on new rodiv & rotrim 
 find a parent which can generate nearest clkrate >= rate 
 get parent 
 skip if parent runs slower than target rate 
 if no match found, retain old rate 
 wait until ACTIVE bit is zero or timeout 
 calculate & apply new 
 calculate new rodiv & rotrim for new rate 
 wait till source change is active 
 apply parent, if required 
 apply RODIV 
 apply ROTRIM 
 enable & activate divider switching 
 wait till divswen is in-progress 
 leave the clk gated as it was 
 PLL iclk divider, treated fixed 
	 pll_in_rate = parent_rate  idiv
	  pll_out_rate = pll_in_rate  mult  div;
	
	  We can't change SPLL counters when it is in-active use
	  by SYSCLK. So check before applying new countersrate.
 Is spll_clk active parent of sys_clk ? 
 apply new multiplier & divisor 
 sys unlock before write 
 insert few nops (5-stage) to ensure CPU does not hang 
 Wait until PLL is locked (maximum 100 usecs). 
 SPLL clock operation 
 cache PLL idiv; PLL driver uses it as constant.
 System mux clock(aka SCLK) 
 sys-div to divider 
 apply new div 
 wait until BUSY is cleared 
 find new_osc 
 set new parent 
 initate switch 
 add nop to flush pipeline (as cpu_clk is in-flux) 
 wait for SWEN bit to clear 
	
	  SCLK clock-switching logic might reject a clock switching request
	  if pre-requisites (like new clk_src not present or unstable) are
	  not met.
	  So confirm before claiming success.
 Maintain reference to this clk, required in spll_clk_set_rate() 
 apply slew divider on both up and down scaling 
 sclk with post-divider 
 sclk with no slew and no post-divider 
 secondary oscillator 
 enable SOSC 
 wait till warm-up period expires or ready-status is updated 
 check enabled and ready status 
 SPDX-License-Identifier: GPL-2.0
  Mediatek MT7621 Clock Driver
  Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
 Configuration registers 
 SPDX-License-Identifier: GPL-2.0-or-later
 Copyright 2020 Cerno
 sentinel  }
  Copyright (C) 2014 Broadcom Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 some clocks at the ASIU level are always enabled 
 some clocks at the ASIU level are always enabled 
 if clock divisor is not enabled, simply return parent rate 
 clock rate = parent rate  (high_div + 1) + (low_div + 1) 
 simply disable the divisor if one wants the same rate as parent 
  Copyright (C) 2014 Broadcom Corporation
  Copyright 2014 Linaro Limited
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 Root CCU 
 no policy control 
 AON CCU 
 Master CCU 
 Verify 
 Verify 
 Verify 
 Verify 
 Slave CCU 
 Device tree match table callback functions 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2015 Broadcom
 SPDX-License-Identifier: GPL-2.0
 sentinel 
 sentinel 
 sentinel 
 sentinel 
 sentinel 
 sentinel 
 sentinel 
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2016 Rafał Miłecki <rafal@milecki.pl>
 Enable measurement 
 Read initial value 
	
	  At minimum we should loop for a bit to let hardware do the
	  measurement. This isn't very accurate however, so for a better
	  precision lets try getting 20 different values for and use average.
 Got different value, use it 
 Same value over and over, give up 
 Disable measurement to save power 
 We need it very early for arch code, before device model gets ready 
  Copyright (C) 2014 Broadcom Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  PLL MACRO_SELECT modes 0 to 5 choose pre-calculated PLL output frequencies
  from a look-up table. Mode 7 allows user to manipulate PLL clock dividers
 number of delay loops waiting for PLL to lock 
 number of VCO frequency bands 
	
	  Add half of the divisor so the result will be rounded to closest
	  instead of rounded down.
  Based on the target frequency, find a match from the VCO frequency parameter
  table and return its index
 latch input value so core power can be shut down 
 power down the core 
 power up the PLL and make sure it's not latched 
 certain PLLs also need to be ungated from the ASIU top level 
  Determines if the change to be applied to the PLL is minor (just an update
  or the fractional divider). If so, then we can avoid going through a
  disruptive reset and lock sequence.
 PLL needs to be locked 
	
	  reference frequency = parent frequency  PDIV
	  If PDIV = 0, then it becomes a multiplier (x2)
 determine Ki and Kp index based on target VCO frequency 
 program fractional part of NDIV 
 put PLL in reset 
 set PLL in user mode before modifying PLL controls 
 program integer part of NDIV 
 program fractional part of NDIV 
 program PDIV 
 PLL needs to be locked 
	
	  PLL output frequency =
	 
	  ((ndiv_int + ndiv_frac  2^20)  (parent clock rate  pdiv)
 break now if perfect match 
 channel enable is active low 
 also make sure channel is not held 
  Some PLLs require the PLL SW override bit to be set before changes can be
  applied to the PLL
 Some SoCs do not require the pwr_base, thus failing is not fatal 
 some PLLs require gating control at the top ASIU level 
		 Some SoCs have a split statuscontrol.  If this does not
		  exist, assume they are unified.
 initialize and register the PLL itself 
 now initialize and register all leaf clocks 
  Copyright (C) 2013 Broadcom Corporation
  Copyright 2013 Linaro Limited
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 These are used when a selector or trigger is found to be unneeded 
 Validity checking 
 Fixed dividers don't need triggers 
 A bit position must be less than the number of bits in a 32-bit register. 
  A bitfield must be at least 1 bit wide.  Both the low-order and
  high-order bits must lie within a 32-bit register.  We require
  fields to be less than 32 bits wide, mainly because we use
  shifting to produce field masks, and shifting a full word width
  is not well-defined by the C standard.
  All gates, if defined, have a status bit, and for hardware-only
  gates, that's it.  Gates that can be software controlled also
  have an enable bit.  And a gate that can be hardware or software
  controlled will have a hardwaresoftware select bit.
  A selector bitfield must be valid.  Its parent_sel array must
  also be reasonable for the field.
		
		  Make sure the selector field can hold all the
		  selector values we expect to be able to use.  A
		  clock only needs to have a selector defined if it
		  has more than one parent.  And in that case the
		  highest selector value will be in the last entry
		  in the array.
  A fixed divider just needs to be non-zero.  A variable divider
  has to have a valid divider bitfield, and if it has a fraction,
  the width of the fraction must not be no more than the width of
  the divider as a whole.
 Any fixed divider value but 0 is OK 
  If a clock has two dividers, the combined number of fractional
  bits must be representable in a 32-bit unsigned value.  This
  is because we scale up a dividend using both dividers before
  dividing to improve accuracy, and we need to avoid overflow.
 A trigger just needs to represent a valid bit position 
 Determine whether the set of peripheral clock registers are valid. 
	
	  First validate register offsets.  This is the only place
	  where we need something from the ccu, so we do these
	  together.
  Scan an array of parent clock names to determine whether there
  are any entries containing BAD_CLK_NAME.  Such entries are
  placeholders for non-supported clocks.  Keep track of the
  position of each clock name in the original array.
  Allocates an array of pointers to to hold the names of all
  non-null entries in the original array, and returns a pointer to
  that array in names.  This will be used for registering the
  clock with the common clock code.  On successful return,
  count indicates how many entries are in that names array.
  If there is more than one entry in the resulting names array,
  another array is allocated to record the parent selector value
  for each (defined) parent clock.  This is the value that
  represents this parent clock in the clock's source selector
  register.  The position of the clock in the original parent array
  defines that selector value.  The number of entries in this array
  is the same as the number of entries in the parent names array.
  The array of selector values is returned.  If the clock has no
  parents, no selector is required and a null pointer is returned.
  Returns a null pointer if the clock names array supplied was
  null.  (This is not an error.)
  Returns a pointer-coded error if an error occurs.
 In case of early return 
	
	  Count the number of names in the null-terminated array,
	  and find out how many of those are actually clock names.
 If all clocks are unsupported, we treat it as no clock 
 Avoid exceeding our parent clock limit 
	
	  There is one parent name for each defined parent clock.
	  We also maintain an array containing the selector value
	  for each defined clock.  If there's only one clock, the
	  selector is not required, but we allocate space for the
	  array anyway to keep things simple.
 There is at least one parent, so allocate a selector array 
 Now fill in the parent names and selector arrays 
	
	  If a peripheral clock has multiple parents, the value
	  used by the hardware to select that parent is represented
	  by the parent clock's position in the "clocks" list.  Some
	  values don't have defined or supported clocks; these will
	  have BAD_CLK_NAME entries in the parents[] array.  The
	  list is terminated by a NULL entry.
	 
	  We need to supply (only) the names of defined parent
	  clocks when registering a clock though, so we use an
	  array of parent selector values to map between the
	  indexes the common clock code uses and the selector
	  values we need.
  Caller is responsible for freeing the parent_names[] and
  parent_sel[] arrays in the peripheral clock's "data" structure
  that can be assigned if the clock has one or more parent clocks
  associated with it.
 Make sure everything makes sense before we set it up 
 safe if never added 
  Set up a CCU.  Call the provided ccu_clks_setup callback to
  initialize the array of clocks provided by the CCU.
	
	  Set up each defined kona clock and save the result in
	  the clock framework clock array (in ccu->data).  Then
	  register as a provider for these clocks.
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2010,2015 Broadcom
  Copyright (C) 2012 Stephen Warren
  DOC: BCM2835 CPRMAN (clock manager for the "audio" domain)
  The clock tree on the 2835 has several levels.  There's a root
  oscillator running at 19.2Mhz.  After the oscillator there are 5
  PLLs, roughly divided as "camera", "ARM", "core", "DSI displays",
  and "HDMI displays".  Those 5 PLLs each can divide their output to
  produce up to 4 channels.  Finally, there is the level of clocks to
  be consumed by other hardware components (like "H264" or "HDMI
  state machine"), which divide off of some subset of the PLL
  channels.
  All of the clocks in the tree are exposed in the DT, because the DT
  may want to make assignments of the final layer of clocks to the
  PLL channels, and some components of the hardware will actually
  skip layers of the tree (for example, the pixel clock comes
  directly from the PLLH PIX channel without using a CM_CTL clock
  generator).
 no definition for 0x0b8  and 0x0bc 
 General bits for the CM_CTL regs 
  Names of clocks used within the driver that need to be replaced
  with an external parent's name.  This array is in the order that
  the clocks node in the DT references external clocks.
 spinlock for all clocks 
	
	  Real names of cprman clock parents looked up through
	  of_clk_get_parent_name(), which will be used in the
	  parent_names[] arrays for clock registration.
 Must be last 
 Does a cycle of measuring a clock through the TCNT clock, which may
  source from many other clocks in the system.
 1ms 
 do a kind delay at the start 
 Finish off whatever is left of OSCCOUNT 
 Wait for BUSY to clear. 
 Bit in CM_LOCK to indicate when the PLL has locked. 
	
	  Highest rate for the VCO before we have to use the
	  pre-divide-by-2.
 Bitmap encoding which parents accept rate change propagation. 
 Number of integer bits in the divider 
 Number of fractional bits in the divider 
	
	  On BCM2711 there isn't a pre-divisor available in the PLL feedback
	  loop. Bits 13:14 of ANA1 (PLLA,PLLB,PLLC,PLLD) have been re-purposed
	  for to for VCO RANGE bits.
 Take the PLL out of reset. 
 Wait for the PLL to lock. 
	
	  ANA register setup is done as a series of writes to
	  ANA3-ANA0, in that order.  This lets us write all 4
	  registers as a single cycle of the serdes interface (taking
	  100 xosc clocks), whereas if we were to update ana0, 1, and
	  3 individually through their partial-write registers, each
	  would be their own serdes cycle.
 Unmask the reference clock from the oscillator. 
 Set the PLL multiplier from the oscillator. 
  The CM dividers do fixed-point division, so we can't use the
  generic integer divider code like the PLL dividers do (and we can't
  fake it by having some fixed shifts preceding it in the clock tree,
  because we'd run out of bits in a 32-bit unsigned long).
 Round up and mask off the unused bits 
 different clamping limits apply for a mash clock 
 clamp to min divider of 2 
 clamp to the highest possible integer divider 
 clamp to min divider of 1 
 clamp to the highest possible fractional divider 
 apply the clamping  limits 
	
	  The divisor is a 12.12 fixed point field, but only some of
	  the bits are populated in any given clock.
 BUSY will remain high until the divider completes its cycle. 
	 Debug code to measure the clock once it's turned on to see
	  if it's ticking at the rate we expect.
	
	  Setting up frac support
	 
	  In principle it is recommended to stopstart the clock first,
	  but as we set CLK_SET_RATE_GATE during registration of the
	  clock this requirement should be take care of by the
	  clk-framework.
			
			  Return a value which is the maximum deviation
			  below the ideal rate, for use as a metric.
 clamp to min divider of 2 if we're dealing with a mash clock 
 TODO: Be smart, and only test a subset of the available divisors. 
	
	  Select parent clock that results in the closest but lower rate
		
		  Don't choose a PLLC-derived clock as our parent
		  unless it had been manually set that way.  PLLC's
		  frequency gets adjusted by the firmware due to
		  over-temp or under-voltage conditions, without
		  prior notification to our clock consumer.
  The VPU clock can never be disabled (it doesn't have an ENABLE
  bit), so it gets its own set of clock ops.
 All of the PLLs derive from the external oscillator. 
	
	  PLLH's channels have a fixed divide by 10 afterwards, which
	  is what our consumers are actually using.
	
	  Replace our strings referencing parent clocks with the
	  actual clock-output-name of the parent.
	
	  Pass the CLK_SET_RATE_PARENT flag if we are allowed to propagate
	  rate changes on at least of the parents.
		 If the clock wasn't actually enabled at boot, it's not
		  critical.
 assignment helper macros for different clock types 
 parent mux arrays plus helper macros 
 main oscillator parent mux 
 main peripherial parent mux 
  Restrict clock sources for the PCM peripheral to the oscillator and
  PLLD_PER because other source may have varying rates or be switched
  off.
  Prevent other sources from being selected by replacing their names in
  the list of potential parents with dummy entries (entry index is
  significant).
 main vpu parent mux 
  DSI parent clocks.  The DSI byteDDRDDR2 clocks come from the DSI
  analog PHY.  The _inv variants are generated internally to cprman,
  but we don't use them so they aren't hooked up.
  the real definition of all the pll, pll_dividers and clocks
  these make use of the above REGISTER_ macros
 the PLL + PLL dividers 
	
	  PLLA is the auxiliary PLL, used to drive the CCP2
	  (Compact Camera Port 2) transmitter clock.
	 
	  It is in the PX LDO power domain, which is on when the
	  AUDIO domain is on.
 PLLB is used for the ARM's clock. 
	
	  PLLC is the core PLL, used to drive the core VPU clock.
	 
	  It is in the PX LDO power domain, which is on when the
	  AUDIO domain is on.
	
	  PLLD is the display PLL, used to drive DSI display panels.
	 
	  It is in the PX LDO power domain, which is on when the
	  AUDIO domain is on.
	
	  VPU firmware assumes that PLLD_PER isn't disabled by the ARM core.
	  Otherwise this could cause firmware lookups. That's why we mark
	  it as critical.
	
	  PLLH is used to supply the pixel clock or the AUX clock for the
	  TV encoder.
	 
	  It is in the HDMI power domain.
 the clocks 
 clocks with oscillator parent mux 
 One Time Programmable Memory clock.  Maximum 10Mhz. 
	
	  Used for a 1Mhz clock for the system clocksource, and also used
	  bythe watchdog timer and the camera pulse generator.
	
	  Clock for the temperature sensor.
	  Generally run at 2Mhz, max 5Mhz.
 clocks with vpu parent mux 
	
	  Secondary SDRAM clock.  Used for low-voltage modes when the PLL
	  in the SDRAM controller can't be used.
	
	  VPU clock.  This doesn't have an enable bit, since it drives
	  the bus for everything else, and is special so it doesn't need
	  to be gated for rate changes.  It is also known as "clk_audio"
	  in various hardware documentation.
 clocks with per parent mux 
 Arasan EMMC clock 
 EMMC2 clock (only available for BCM2711) 
 General purpose (GPIO) clocks 
 HDMI state machine 
 TV encoder clock.  Only operating frequency is 108Mhz.  
		
		  Allow rate change propagation only on PLLH_AUX which is
		  assigned index 7 in the parent array.
 dsi clocks 
 the gates 
	
	  CM_PERIICTL (and CM_PERIACTL, CM_SYSCTL and CM_VPUCTL if
	  you have the debug bit set in the power manager, which we
	  don't bother exposing) are individual gates off of the
	  non-stop vpu clock.
  Permanently take a reference on the parent of the SDRAM clock.
  While the SDRAM is being driven by its dedicated PLL most of the
  time, there is a little loop running in the firmware that
  periodically switches the SDRAM to using our CM clock to do PVT
  recalibration, with the assumption that the previously configured
  SDRAM parent is still enabled and running.
	
	  Make sure the external oscillator has been registered.
	 
	  The other (DSI) clocks are not present on older device
	  trees, which we still need to support for backwards
	  compatibility.
  Copyright (C) 2015 Broadcom Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  Copyright (C) 2013 Broadcom Corporation
  Copyright 2013 Linaro Limited
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  "Policies" affect the frequencies of bus clocks provided by a
  CCU.  (I believe these polices are named "Deep Sleep", "Economy",
  "Normal", and "Turbo".)  A lower policy number has lower power
  consumption, and policy 2 is the default.
 Bitfield operations 
 Produces a mask of set bits covering a range of a 32-bit value 
 Extract the value of a bitfield found within a given register value 
 Replace the value of a bitfield found within a given register value 
 Divider and scaling helpers 
 Convert a divider into the scaled divisor value it represents. 
  Build a scaled divider value as close as possible to the
  given whole part (div_value) and fractional part (expressed
  in billionths).
 The scaled minimum divisor representable by a divider 
 The scaled maximum divisor representable by a divider 
  Convert a scaled divisor into its divider representation as
  stored in a divider register field.
 Return a rate scaled for use when dividing by a scaled divisor. 
 CCU access 
 Read a 32-bit register value from a CCU's address space. 
 Write a 32-bit register value into a CCU's address space. 
  Enabledisable write access to CCU protected registers.  The
  WR_ACCESS register for all CCUs is at offset 0.
  Poll a register in a CCU's address space, returning when the
  specified bit in that register's value is set (or clear).  Delay
  a microsecond after each read of the register.  Returns true if
  successful, or false if we gave up trying.
  Caller must ensure the CCU lock is held.
 Policy operations 
 If we don't need to control policy for this CCU, we're done. 
 Ensure we're not busy before we start 
	
	  If it's a synchronous request, we'll wait for the voltage
	  and frequency of the active load to stabilize before
	  returning.  To do this we select the active load by
	  setting the ATL bit.
	 
	  An asynchronous request instead ramps the voltage in the
	  background, and when that process stabilizes, the target
	  load is copied to the active load and the CCU frequency
	  is switched.  We do this by selecting the target load
	  (ATL bit clear) and setting the request auto-copy (AC bit
	  set).
	 
	  Note, we do NOT read-modify-write this register.
 Wait for indication that operation is complete. 
 If we don't need to control policy for this CCU, we're done. 
 Ensure we're not busy before we start 
 Now set the bit to stop the engine (NO read-modify-write) 
 Wait for indication that it has stopped. 
  A CCU has four operating conditions ("policies"), and some clocks
  can be disabled or enabled based on which policy is currently in
  effect.  Such clocks have a bit in a "policy mask" register for
  each policy indicating whether the clock is enabled for that
  policy or not.  The bit position for a clock is the same for all
  four registers, and the 32-bit registers are at consecutive
  addresses.
	
	  We need to stop the CCU policy engine to allow update
	  of our policy bits.
	
	  For now, if a clock defines its policy bit we just mark
	  it "enabled" for all four policies.
 We're done updating; fire up the policy engine again. 
 Gate operations 
 Determine whether a clock is gated.  CCU lock must be held.  
 If there is no gate we can assume it's enabled. 
 Determine whether a clock is gated. 
 Avoid taking the lock if we can 
  Commit our desired gate state to the hardware.
  Returns true if successful, false otherwise.
 Nothing we can change 
 For a hardwaresoftware gate, set which is in control 
	
	  If software is in control, enable or disable the gate.
	  If hardware is, clear the enabled bit for good measure.
	  If a software controlled gate can't be disabled, we're
	  required to write a 0 into the enable bit (but the gate
	  will be enabled).
 For a hardware controlled gate, we're done 
 Otherwise wait for the gate to be in desired state 
  Initialize a gate.  Our desired state (hardwaresoftware select,
  and if software, its enable state) is committed to hardware
  without the usual checks to see if it's already set up that way.
  Returns true if successful, false otherwise.
  Set a gate to enabled or disabled state.  Does nothing if the
  gate is not currently under software control, or if it is already
  in the requested state.  Returns true if successful, false
  otherwise.  CCU lock must be held.
 Nothing to do 
 No change 
 Revert the change 
 Enable or disable a gate.  Returns 0 if successful, -EIO otherwise 
	
	  Avoid taking the lock if we can.  We quietly ignore
	  requests to change state that don't make sense.
 Hysteresis operations 
  If a clock gate requires a turn-off delay it will have
  "hysteresis" register bits defined.  The first, if set, enables
  the delay; and if enabled, the second bit determines whether the
  delay is "low" or "high" (1 means high).  For now, if it's
  defined for a clock, we set it.
 Trigger operations 
  Caller must ensure CCU lock is held and access is enabled.
  Returns true if successful, false otherwise.
 Trigger the clock and wait for it to finish 
 Divider operations 
 Read a divider value and return the scaled divisor it represents. 
 Extract the full divider field from the register value 
 Return the scaled divisor value it represents 
  Convert a divider's scaled divisor value into its recorded form
  and commit it into the hardware divider register.
  Returns 0 on success.  Returns -EINVAL for invalid arguments.
  Returns -ENXIO if gating failed, and -EIO if a trigger failed.
	
	  If we're just initializing the divider, and no initial
	  state was defined in the device tree, we just find out
	  what its current value is rather than updating it.
 Convert the scaled divisor to the value we need to record 
 Clock needs to be enabled before changing the rate 
 Replace the divider value and record the result 
 If the trigger fails we still want to disable the gate 
 Disable the clock again if it was disabled to begin with 
 return first error 
  Initialize a divider by committing our desired state to hardware
  without the usual checks to see if it's already set up that way.
  Returns true if successful, false otherwise.
 No change 
 Revert the change 
 Common clock rate helpers 
  Implement the common clock framework recalc_rate method, taking
  into account a divider and an optional pre-divider.  The
  pre-divider register pointer may be NULL.
 actually this would be a caller bug 
	
	  If there is a pre-divider, divide the scaled parent rate
	  by the pre-divider value first.  In this case--to improve
	  accuracy--scale the parent rate by both the pre-divider
	  value and the divider before actually computing the
	  result of the pre-divider.
	 
	  If there's only one divider, just scale the parent rate.
	
	  Get the scaled divisor value, and divide the scaled
	  parent rate by that to determine this clock's resulting
	  rate.
  Compute the output rate produced when a given parent rate is fed
  into two dividers.  The pre-divider can be NULL, and even if it's
  non-null it may be nonexistent.  It's also OK for the divider to
  be nonexistent, and in that case the pre-divider is also ignored.
  If scaled_div is non-null, it is used to return the scaled divisor
  value used by the (downstream) divider to produce that rate.
	
	  If there is a pre-divider, divide the scaled parent rate
	  by the pre-divider value first.  In this case--to improve
	  accuracy--scale the parent rate by both the pre-divider
	  value and the divider before actually computing the
	  result of the pre-divider.
	 
	  If there's only one divider, just scale the parent rate.
	 
	  For simplicity we treat the pre-divider as fixed (for now).
	
	  Compute the best possible divider and ensure it is in
	  range.  A fixed divider can't be changed, so just report
	  the best we can do.
 OK, figure out the resulting rate 
 Common clock parent helpers 
  For a given parent selector (register field) value, find the
  index into a selector's parent_sel array that contains it.
  Returns the index, or BAD_CLK_INDEX if it's not found.
  Fetch the current value of the selector, and translate that into
  its corresponding index in the parent array we registered with
  the clock framework.
  Returns parent array index that corresponds with the value found,
  or BAD_CLK_INDEX if the found value is out of range.
 If there's no selector, there's only one parent 
 Get the value in the selector register 
 Look up that selector's parent array index and return it 
  Commit our desired selector value to the hardware.
  Returns 0 on success.  Returns -EINVAL for invalid arguments.
  Returns -ENXIO if gating failed, and -EIO if a trigger failed.
	
	  If we're just initializing the selector, and no initial
	  state was defined in the device tree, we just find out
	  what its current value is rather than updating it.
 Clock needs to be enabled before changing the parent 
 Replace the selector value and record the result 
 If the trigger fails we still want to disable the gate 
 Disable the clock again if it was disabled to begin with 
 return first error 
  Initialize a selector by committing our desired state to hardware
  without the usual checks to see if it's already set up that way.
  Returns true if successful, false otherwise.
  Write a new value into a selector register to switch to a
  different parent clock.  Returns 0 on success, or an error code
  (from __sel_commit()) otherwise.
 No change 
 Revert the change 
 Clock operations 
 Quietly avoid a zero rate 
	
	  If there is no other parent to choose, use the current one.
	  Note:  We don't honor (or use) CLK_SET_RATE_NO_REPARENT.
 Unless we can do better, stick with current parent 
 Check whether any other parent clock can produce a better result 
 We don't support CLK_SET_RATE_PARENT 
 If there's only one parent we don't require a selector 
	
	  The regular trigger is used by default, but if there's a
	  pre-trigger we want to use that instead.
 Don't proliferate weird errors 
 Not all callers would handle an out-of-range value gracefully 
	
	  A fixed divider can't be changed.  (Nor can a fixed
	  pre-divider be, but for now we never actually try to
	  change that.)  Tolerate a request for a no-op change.
	
	  Get the scaled divisor value needed to achieve a clock
	  rate as close as possible to what was requested, given
	  the parent clock rate supplied.
	
	  We aren't updating any pre-divider at this point, so
	  we'll use the regular trigger.
 Don't proliferate weird errors 
 Put a peripheral clock into its initial state 
	
	  For the pre-divider and selector, the pre-trigger is used
	  if it's present, otherwise we just use the regular trigger.
 Set a CCU and all its clocks into their desired initial state 
  Copyright (C) 2014 Broadcom Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 something is seriously wrong 
  Determine the mdiv (post divider) based on the frequency ID being used.
  There are 4 sources that can be used to derive the output clock rate:
     - 25 MHz Crystal
     - System clock
     - PLL channel 0 (slow clock)
     - PLL channel 1 (fast clock)
		
		  offset mode is active. Read the ndiv from the PLLARM OFFSET
		  register
 offset mode not active 
  The output frequency of the ARM PLL is calculated based on the ARM PLL
  divider values:
    pdiv = ARM PLL pre-divider
    ndiv = ARM PLL multiplier
    mdiv = ARM PLL post divider
  The frequency is calculated by:
    ((ndiv  parent clock rate)  pdiv)  mdiv
 in bypass mode, use parent rate 
 PLL needs to be locked 
 SPDX-License-Identifier: GPL-2.0+
  Raspberry Pi driver for firmware controlled clocks
  Even though clk-bcm2835 provides an interface to the hardware registers for
  the system clocks we've had to factor out 'pllb' as the firmware 'owns' it.
  We're not allowed to change it directly as we might race with the
  over-temperature and under-voltage protections provided by the firmware.
  Copyright (C) 2019 Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
  Structure of the message passed to Raspberry Pi's firmware in order to
  change clock rates. The 'disable_turbo' option is only available to the ARM
  clock (pllb) which we enable by default as turbo mode will alter multiple
  clocks at once.
  Even though we're able to access the clock registers directly we're bound to
  use the firmware interface as the firmware ultimately takes care of
  mitigating overheatingundervoltage situations and we would be changing
  frequencies behind his back.
  For more information on the firmware interface check:
  https:github.comraspberrypifirmwarewikiMailbox-property-interface
	
	  The firmware will do the rounding but that isn't part of
	  the interface with the firmware, so we just do our best
	  here.
	
	  We can be probed either through the an old-fashioned
	  platform device registration or through a DT node that is a
	  child of the firmware node. Handle both cases.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2017 Broadcom
 sentinel  }
  Copyright (C) 2017 Broadcom
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  Copyright (C) 2014 Broadcom Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  MIPI PLL VCO frequency parameter table
 rate (Hz) ndiv_int ndiv_frac pdiv 
  Copyright (C) 2015 Broadcom Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  Copyright (C) 2013 Broadcom Corporation
  Copyright 2013 Linaro Limited
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 Root CCU 
 AON CCU 
 Hub CCU 
 Master CCU 
 also called usbh_48m 
 also called usbh_12m 
 Slave CCU 
 Device tree match table callback functions 
  Copyright (C) 2015 Broadcom Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
	 bypass_shift, the last value passed into ENABLE_VAL(), is not defined
	  in NS2.  However, it doesn't appear to be used anywhere, so setting
	  it to 0.
	 bypass_shift, the last value passed into ENABLE_VAL(), is not defined
	  in NS2.  However, it doesn't appear to be used anywhere, so setting
	  it to 0.
	 bypass_shift, the last value passed into ENABLE_VAL(), is not defined
	  in NS2.  However, it doesn't appear to be used anywhere, so setting
	  it to 0.
	 bypass_shift, the last value passed into ENABLE_VAL(), is not defined
	  in NS2.  However, it doesn't appear to be used anywhere, so setting
	  it to 0.
 SPDX-License-Identifier: GPL-2.0
  H8S2678 clock driver
  Copyright 2015 Yoshinori Sato <ysato@users.sourceforge.jp>
 SPDX-License-Identifier: GPL-2.0
  H8300 divide clock driver
  Copyright 2015 Yoshinori Sato <ysato@users.sourceforge.jp>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2020 BAIKAL ELECTRONICS, JSC
  Authors:
    Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
  Baikal-T1 CCU Dividers clock driver
  AXI Main Interconnect (axi_main_clk) and DDR AXI-bus (axi_ddr_clk) clocks
  must be left enabled in any case, since former one is responsible for
  clocking a bus between CPU cores and the rest of the SoC components, while
  the later is clocking the AXI-bus between DDR controller and the Main
  Interconnect. So should any of these clocks get to be disabled, the system
  will literally stop working. That's why we marked them as critical.
  APB-bus clock is marked as critical since it's a main communication bus
  for the SoC devices registers IO-operations.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2020 BAIKAL ELECTRONICS, JSC
  Authors:
    Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
  Baikal-T1 CCU Dividers interface driver
  Use the next two methods until there are generic field setter and
  getter available with non-constant mask support.
	
	  Until there is nsec-version of readl_poll_timeout() is available
	  we have to implement the next polling loop.
  This method is used for the clock divider blocks, which support the
  on-the-fly rate change. So due to lacking the EN bit functionality
  they can't be gated before the rate adjustment.
  This method is used for the clock divider blocks, which don't support
  the on-the-fly rate change.
	
	  Also disable the clock divider block if it was enabled by default
	  or by the bootloader.
 The next delay must be enough to cover all the resets. 
  It can be dangerous to change the Divider settings behind clock framework
  back, therefore we don't provide any kernel config based compile time option
  for this feature to enable.
 !CCU_DIV_ALLOW_WRITE_DEBUGFS 
 !CCU_DIV_ALLOW_WRITE_DEBUGFS 
 !CONFIG_DEBUG_FS 
 !CONFIG_DEBUG_FS 
	
	  Note since Baikal-T1 System Controller registers are MMIO-backed
	  we won't check the regmap IO operations return status, because it
	  must be zero anyway.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2020 BAIKAL ELECTRONICS, JSC
  Authors:
    Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
  Baikal-T1 CCU PLL interface driver
	
	  Make sure PLL is working with valid input signal (Fdiv). If
	  you want to speed the function up just reduce CCU_PLL_NR_MAX.
	  This will cause a worse approximation though.
	
	  Find a closest [nr;nf;od] vector taking into account the
	  limitations like: 1) 700MHz <= Fvco <= 3.5GHz, 2) PLL Od is
	  either 1 or even number within the acceptable range (alas 1s
	  is also excluded by the next loop).
 Use Od factor to fulfill the limitation 2). 
		
		  Make sure Fvco is within the acceptable range to fulfill
		  the condition 1). Note due to the CCU_PLL_CLKOD_FACTOR value
		  the actual upper limit is also divided by that factor.
		  It's not big problem for us since practically there is no
		  need in clocks with that high frequency.
		
		  Bypass the out-of-bound values, which can't be properly
		  handled by the rational fraction approximation algorithm.
 Select the best approximation of the target rate. 
  This method is used for PLLs, which support the on-the-fly dividers
  adjustment. So there is no need in gating such clocks.
  This method is used for PLLs, which don't support the on-the-fly dividers
  adjustment. So the corresponding clocks are supposed to be gated first.
	
	  Disable PLL if it was enabled by default or left enabled by the
	  system bootloader.
  It can be dangerous to change the PLL settings behind clock framework back,
  therefore we don't provide any kernel config based compile time option for
  this feature to enable.
 !CCU_PLL_ALLOW_WRITE_DEBUGFS 
 !CCU_PLL_ALLOW_WRITE_DEBUGFS 
 !CONFIG_DEBUG_FS 
 !CONFIG_DEBUG_FS 
	
	  Note since Baikal-T1 System Controller registers are MMIO-backed
	  we won't check the regmap IO operations return status, because it
	  must be zero anyway.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2020 BAIKAL ELECTRONICS, JSC
  Authors:
    Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
  Baikal-T1 CCU PLL clocks driver
  Alas we have to mark all PLLs as critical. CPU and DDR PLLs are sources of
  CPU cores and DDR controller reference clocks, due to which they obviously
  shouldn't be ever gated. SATA and PCIe PLLs are the parents of APB-bus and
  DDR controller AXI-bus clocks. If they are gated the system will be
  unusable. Moreover disabling SATA and Ethernet PLLs causes automatic reset
  of the corresponding subsystems. So until we aren't ready to re-initialize
  all the devices consuming those PLLs, they will be marked as critical too.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2012-2016 Zhang, Keguang <keguang.zhang@gmail.com>
 clock derived from 33 MHz OSC clk 
 clock derived from PLL clk 
	                                 _____
	          _______________________|     |
	  OSC ___                       | MUX |___ CPU CLK
	         \___ PLL ___ CPU DIV ___|     |
	                                 |_____|
	                                 _____
	          _______________________|     |
	  OSC ___                       | MUX |___ DC  CLK
	         \___ PLL ___ DC  DIV ___|     |
	                                 |_____|
	                                 _____
	          _______________________|     |
	  OSC ___                       | MUX |___ DDR CLK
	         \___ PLL ___ DDR DIV ___|     |
	                                 |_____|
 clock derived from AHB clk 
 APB clk is always half of the AHB clk 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2012-2016 Zhang, Keguang <keguang.zhang@gmail.com>
 allocate the divider 
 register the clock 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2016 Yang Ling <gnaygnil@gmail.com>
 clock derived from 24 MHz OSC clk 
 clock derived from AHB clk 
 SPDX-License-Identifier: GPL-2.0-only
  Zynq clock controller
   Copyright (C) 2012 - 2013 Xilinx
   Sören Brinkmann <soren.brinkmann@xilinx.com>
 get clock output names from DT 
 ps_clk 
 PLLs 
 CPU clocks 
 Timers 
 DDR clocks 
 Peripheral clocks 
 leave debug clocks in the state the bootloader set them up to 
 One gated clock for all APER clocks. 
 SPDX-License-Identifier: GPL-2.0-only
  Zynq PLL driver
   Copyright (C) 2013 Xilinx
   Sören Brinkmann <soren.brinkmann@xilinx.com>
  struct zynq_pll
  @hw:		Handle between common and hardware-specific interfaces
  @pll_ctrl:	PLL control register
  @pll_status:	PLL status register
  @lock:	Register lock
  @lockbit:	Indicates the associated PLL_LOCKED bit in the PLL status
 		register.
 Register bitfield defines 
  zynq_pll_round_rate() - Round a clock frequency
  @hw:		Handle between common and hardware-specific interfaces
  @rate:	Desired clock frequency
  @prate:	Clock frequency of parent clock
  Returns frequency closest to @rate the hardware can generate.
  zynq_pll_recalc_rate() - Recalculate clock frequency
  @hw:			Handle between common and hardware-specific interfaces
  @parent_rate:	Clock frequency of parent clock
  Returns current clock frequency.
	
	  makes probably sense to redundantly save fbdiv in the struct
	  zynq_pll to save the IO access.
  zynq_pll_is_enabled - Check if a clock is enabled
  @hw:		Handle between common and hardware-specific interfaces
  Returns 1 if the clock is enabled, 0 otherwise.
  Not sure this is a good idea, but since disabled means bypassed for
  this clock implementation we say we are always enabled.
  zynq_pll_enable - Enable clock
  @hw:		Handle between common and hardware-specific interfaces
  Returns 0 on success
 Power up PLL and wait for lock 
  zynq_pll_disable - Disable clock
  @hw:		Handle between common and hardware-specific interfaces
  Returns 0 on success
 shut down PLL 
  clk_register_zynq_pll() - Register PLL with the clock framework
  @name:	PLL name
  @parent:	Parent clock name
  @pll_ctrl:	Pointer to PLL control register
  @pll_status:	Pointer to PLL status register
  @lock_index:	Bit index to this PLL's lock status bit in @pll_status
  @lock:	Register lock
  Returns handle to the registered clock.
 Populate the struct 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020 Intel Corporation.
  Zhu YiXin <yixin.zhu@intel.com>
  Rahul Tanwar <rahul.tanwar@intel.com>
  Calculate formula:
  rate = (prate  mult + (prate  frac)  frac_div)  div
 SPDX-License-Identifier: GPL-2.0-only
  Intel Atom platform clocks driver for BayTrail and CherryTrail SoCs
  Copyright (C) 2016, Intel Corporation
  Author: Irina Tirdea <irina.tirdea@intel.com>
 25 MHz 
 19.2 MHz 
 protect access to PMC registers 
 Return an index in parent table 
 Return clk index of parent 
 Abstract status in simpler enableddisabled value 
 enabled 
 disabled 
	
	  On some systems, the pmc_plt_clocks already enabled by the
	  firmware are being marked as critical to avoid them being
	  gated by the clock framework.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020 Intel Corporation.
  Zhu YiXin <yixin.zhu@intel.com>
  Rahul Tanwar <rahul.tanwar@intel.com>
 if predivide bit is enabled, modify div by factor of 2.5 
 if predivide bit is enabled, modify rounded rate by factor of 2.5 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020 Intel Corporation.
  Zhu YiXin <yixin.zhu@intel.com>
  Rahul Tanwar <rahul.tanwar@intel.com>
 Gate0 clock shift 
 Gate1 clock shift 
 Gate2 clock shift 
 Gate3 clock shift 
 Register definition 
  Below table defines the pair's of regval & effective dividers.
  It's more efficient to provide an explicit table due to non-linear
  relation between values.
	
	  Marking ngi_clk (next generation interconnect) and noc_clk
	  (network on chip peripheral clk) as critical clocks because
	  these are shared parent clock sources for many different
	  peripherals.
 SPDX-License-Identifier: MIT
  clock framework for AMD Stoney based clocks
  Copyright 2018 Advanced Micro Devices, Inc.
 Clock Driving Strength 2 register 
 Clock Control 1 register 
 Auxiliary clock1 enable bit 
 25Mhz auxiliary output clock freq bit 
 SPDX-License-Identifier: GPL-2.0-only
  Intel Low Power Subsystem clocks.
  Copyright (C) 2013, Intel Corporation
  Authors: Mika Westerberg <mika.westerberg@linux.intel.com>
 	    Heikki Krogerus <heikki.krogerus@linux.intel.com>
 LPSS free running clock 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2020 MediaTek Inc.
  Copyright (c) 2020 BayLibre, SAS
  Author: James Liao <jamesjj.liao@mediatek.com>
          Fabien Parent <fparent@baylibre.com>
 VDEC0 
 VDEC1 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 MediaTek Inc.
  Author: James Liao <jamesjj.liao@mediatek.com>
 CLK_CFG_0 
 CLK_CFG_1 
 CLK_CFG_2 
 CLK_CFG_3 
 CLK_CFG_4 
 CLK_CFG_6 
 CLK_CFG_7 
 CLK_CFG_8 
 CLK_CFG_9 
 PERI0 
 PERI1 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2020 MediaTek Inc.
  Copyright (c) 2020 BayLibre, SAS
  Author: James Liao <jamesjj.liao@mediatek.com>
          Fabien Parent <fparent@baylibre.com>
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 MediaTek Inc.
  Author: Kevin Chen <kevin-cw.chen@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2017 MediaTek Inc.
  Author: Kevin Chen <kevin-cw.chen@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 MediaTek Inc.
  Author: Weiyi Lu <weiyi.lu@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2019 MediaTek Inc.
  Author: James Liao <jamesjj.liao@mediatek.com>
          Fabien Parent <fparent@baylibre.com>
 CLK_MUX_SEL0 
 CLK_MUX_SEL1 
 CLK_MUX_SEL8 
 CLK_SEL_9 
 CLK_MUX_SEL13 
 TOP1 
 TOP2 
 TOP3 
 TOP4 
 TOP5 
 sentinel 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 MediaTek Inc.
 Author: Weiyi Lu <weiyi.lu@mediatek.com>
 AUDIO0 
 AUDIO1 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018 MediaTek Inc.
  Author: Wenzhen Yu <Wenzhen Yu@mediatek.com>
 	   Ryder Lee <ryder.lee@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 MM0 
 MM1 
 MM2 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
  CRITICAL CLOCK:
  axi_sel is the main bus clock of whole SOC.
  spm_sel is the clock of the always-on co-processor.
  bus_aximem_sel is clock of the bus that access emi.
 CLK_CFG_0 
 CLK_CFG_1 
 CLK_CFG_2 
 CLK_CFG_4 
 CLK_CFG_5 
 CLK_CFG_6 
 CLK_CFG_7 
 CLK_CFG_8 
 CLK_CFG_9 
 CLK_CFG_10 
 CLK_CFG_11 
 CLK_CFG_12 
 CLK_CFG_13 
 CLK_CFG_14 
 CLK_CFG_15 
 CLK_CFG_16 
 CLK_AUDDIV_0 
  CRITICAL CLOCK:
  infra_133m and infra_66m are main peripheral bus clocks of SOC.
  infra_device_apc and infra_device_apc_sync are for device access permission control module.
 INFRA0 
 INFRA1 
 INFRA2 
 INFRA3 
 INFRA4 
 INFRA5 
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 MediaTek Inc.
  Author: James Liao <jamesjj.liao@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 MediaTek Inc.
 Author: Weiyi Lu <weiyi.lu@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 MediaTek Inc.
  Author: Shunli Wang <shunli.wang@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015 Linaro Ltd.
  Author: Pi-Cheng Chen <pi-cheng.chen@linaro.org>
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 MediaTek Inc.
 Author: Weiyi Lu <weiyi.lu@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 MediaTek Inc.
  Author: Owen Chen <owen.chen@mediatek.com>
fmeter div select 4
 Total 12 subsys 
 CKSYS 
 CG 
 clk cfg update 
 CLK_CFG_0 
 CLK_CFG_1 
 CLK_CFG_2 
 CLK_CFG_3 
 CLK_CFG_4 
 CLK_CFG_5 
 CLK_CFG_6 
 CLK_CFG_7 
 TOP0 
 TOP1 
 TOP2 
 INFRA_TOPAXI 
 INFRA PERI 
 INFRA mode 0 
 INFRA mode 1 
 INFRA mode 2 
 INFRA mode 3 
 additional CCF control for mipi26M race condition(dispcamera) 
 AUDIO0 
 MPLL, CCIPLL, MAINPLL set HW mode, TDCLKSQ, CLKSQ1 
 [4]:no need 
[1,2,3,8]: no need
 sentinel 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 MediaTek Inc.
 Author: Weiyi Lu <weiyi.lu@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2020 MediaTek Inc.
  Copyright (c) 2020 BayLibre, SAS
  Author: James Liao <jamesjj.liao@mediatek.com>
          Fabien Parent <fparent@baylibre.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018 MediaTek Inc.
  Author: Wenzhen Yu <Wenzhen Yu@mediatek.com>
 	   Ryder Lee <ryder.lee@mediatek.com>
 PERI0 
 PERI1 
 INFRA_TOPCKGEN_CKMUXSEL 
 CLK_CFG_0 
 CLK_CFG_1 
 CLK_CFG_2 
 CLK_CFG_3 
 CLK_CFG_4 
 CLK_CFG_5 
 CLK_CFG_6 
 CLK_CFG_7 
 CLK_CFG_8 
 PERI_GLOBALCON_CKSEL 
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 VPP0_0 
 VPP0_1 
 VPP0_2 
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 WPE_VPP0 
 WPE_VPP1 
 WPE_VPP0 
 WPE_VPP1 
 sentinel 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2019 MediaTek Inc.
  Author: James Liao <jamesjj.liao@mediatek.com>
          Fabien Parent <fparent@baylibre.com>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 MediaTek Inc.
  Author: Weiyi Lu <weiyi.lu@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 MediaTek Inc.
  Author: Weiyi Lu <weiyi.lu@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 VDEC0 
 VDEC1 
 VDEC2 
 VDEC_SOC0 
 VDEC_SOC1 
 VDEC_SOC2 
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 MediaTek Inc.
  Author: Kevin Chen <kevin-cw.chen@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2019 MediaTek Inc.
  Author: Wendell Lin <wendell.lin@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 MediaTek Inc.
  Author: Weiyi Lu <weiyi.lu@mediatek.com>
 CLK_CFG_0 
 CLK_CFG_1 
 CLK_CFG_2 
 CLK_CFG_3 
 CLK_CFG_4 
 CLK_CFG_5 
 CLK_CFG_6 
 CLK_CFG_7 
 CLK_CFG_8 
 CLK_CFG_9 
 CLK_CFG_10 
 CLK_CFG_11 
 CLK_CFG_12 
 CLK_CFG_13 
 CLK_CFG_14 
 CLK_CFG_15 
 CLK_CFG_16 
 CLK_CFG_17 
 CLK_AUDDIV_4 
 mp0_pll_divider_cfg 
 mp2_pll_divider_cfg 
 bus_pll_divider_cfg 
 TOP0 
 TOP1 
 PERI0 
 PERI1 
 PERI2 
 sentinel 
 sentinel 
 sentinel 
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015 MediaTek Inc.
  Author: James Liao <jamesjj.liao@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 MediaTek Inc.
 Author: Weiyi Lu <weiyi.lu@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018 MediaTek Inc.
  Author: Wenzhen Yu <Wenzhen Yu@mediatek.com>
 	   Ryder Lee <ryder.lee@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 MediaTek Inc.
  Author: Shunli Wang <shunli.wang@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 MediaTek Inc.
  Author: Owen Chen <owen.chen@mediatek.com>
	
	  If the parent has been changed when the clock was disabled, it will
	  not be effective yet. Set the update bit to ensure the mux gets
	  updated.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 MediaTek Inc.
  Author: Chen Zhong <chen.zhong@mediatek.com>
 	   Sean Wang <sean.wang@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 MediaTek Inc.
  Author: James Liao <jamesjj.liao@mediatek.com>
  For some clocks, we don't care what their actual rates are. And these
  clocks may change their rate on different products or different scenarios.
  So we model these clocks' rate as 0, to denote it's not an actual rate.
 CLK_CFG_0 
 CLK_CFG_1 
 CLK_CFG_2 
 CLK_CFG_3 
 CLK_CFG_4 
 CLK_CFG_5 
 7:5 ),
 CLK_CFG_6 
	
	  The dpi0_sel clock should not propagate rate changes to its parent
	  clock so the dpi driver can have full control over PLL and divider.
 CLK_CFG_7 
 CLK_CFG_12 
 CLK_CFG_13 
 PERI0 
 PERI1 
 sentinel 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 MediaTek Inc.
 Author: Weiyi Lu <weiyi.lu@mediatek.com>
 MM0 
 MM1 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
	
	  CLK_CFG_0
	  top_axi and top_bus_aximem are bus clocks, should not be closed by Linux.
	  top_spm and top_scp are main clocks in always-on co-processor.
 CLK_CFG_1 
 CLK_CFG_2 
 CLK_CFG_3 
 CLK_CFG_4 
 CLK_CFG_5 
 CLK_CFG_6 
 CLK_CFG_7 
 CLK_CFG_8 
	
	  CLK_CFG_9
	  top_pwrmcu is main clock in other co-processor, should not be
	  handled by Linux.
 CLK_CFG_10 
 CLK_CFG_11 
 CLK_CFG_12 
 CLK_CFG_13 
 CLK_CFG_14 
 CLK_CFG_15 
	
	  CLK_CFG_16
	  top_mcupm is main clock in other co-processor, should not be
	  handled by Linux.
	
	  CLK_CFG_17
	  top_dvfsrc is for internal DVFS usage, should not be handled by Linux.
 CLK_CFG_18 
 CLK_CFG_19 
 CLK_CFG_20 
 CLK_CFG_21 
 CLK_CFG_22 
 CLK_CFG_23 
	
	  CLK_CFG_24
	  i2so4_mck is not used in MT8195.
	
	  CLK_CFG_25
	  i2so5_mck and i2si4_mck are not used in MT8195.
	
	  CLK_CFG_26
	  i2si5_mck is not used in MT8195.
 CLK_CFG_27 
 CLK_CFG_28 
	
	  CLK_CFG_29
	  top_ulposctop_ulposc_coretop_srck are clock source of always on co-processor,
	  should not be closed by Linux.
	
	  the clocks in CLK_CFG_30 ~ 37 are backup clock source, no need to handled
	  by Linux.
 CLK_MISC_CFG_3 
 apll12_div5 ~ 8 are not used in MT8195. 
 TOP0 
	
	  cfg_axi_east, cfg_axi_east_north, cfg_axi_north and cfg_axi_south
	  are peripheral bus clock branches.
 TOP1 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2019 MediaTek Inc.
  Author: Wendell Lin <wendell.lin@mediatek.com>
  CRITICAL CLOCK:
  axi_sel is the main bus clock of whole SOC.
  spm_sel is the clock of the always-on co-processor.
  sspm_sel is the clock of the always-on co-processor.
 CLK_CFG_0 
 CLK_CFG_1 
 CLK_CFG_2 
 CLK_CFG_3 
 CLK_CFG_4 
 CLK_CFG_5 
 CLK_CFG_6 
 CLK_CFG_7 
 CLK_CFG_8 
 CLK_CFG_9 
 CLK_CFG_10 
 CLK_CFG_11 
 CLK_CFG_12 
 CLK_CFG_13 
 INFRA0 
 INFRA1 
 INFRA2 
 INFRA3 
  CRITICAL CLOCK:
  apmixed_appll26m is the toppest clock gate of all PLLs.
 sentinel 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2019 MediaTek Inc.
  Author: Wendell Lin <wendell.lin@mediatek.com>
 MM0 
 MM1 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2019 MediaTek Inc.
  Author: Wendell Lin <wendell.lin@mediatek.com>
 VDEC0 
 VDEC1 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 MediaTek Inc.
  Author: James Liao <jamesjj.liao@mediatek.com>
 default 7 bits integer, can be overridden with pcwibits. 
  MediaTek PLLs are configured through their pcw value. The pcw value describes
  a divider in the PLL feedback loop which consists of 7 bits for the integer
  part and the remaining bits (if present) for the fractional part. Also they
  have a 3 bit power-of-two post divider.
 The fractional part of the PLL divider. 
 disable tuner 
 set postdiv 
 postdiv and pcw need to set at the same time if on same register 
 set pcw 
 restore tuner_en 
  mtk_pll_calc_values - calculate good values for a given input frequency.
  @pll:	The pll
  @pcw:	The pcw value (output)
  @postdiv:	The post divider (output)
  @freq:	The desired target frequency
  @fin:	The input frequency
 _pcw = freq  postdiv  fin  2^pcwfbits 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
  The "en_reg" and "pcw_chg_reg" fields are standard offset register compared
  with "reg" field, so set zero to imply it.
  No tuner control in apu pll, so set "tuner_XXX" as zero to imply it.
  No rst or post divider enable in apu pll, so set "rst_bar_mask" and "en_mask"
  as zero to imply it.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2019 MediaTek Inc.
  Author: Wendell Lin <wendell.lin@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2020 MediaTek Inc.
  Copyright (c) 2020 BayLibre, SAS
  Author: James Liao <jamesjj.liao@mediatek.com>
          Fabien Parent <fparent@baylibre.com>
 MM0 
 MM1 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2020 MediaTek Inc.
  Copyright (c) 2020 BayLibre, SAS
  Author: James Liao <jamesjj.liao@mediatek.com>
          Fabien Parent <fparent@baylibre.com>
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 INFRA_AO0 
 infra_ao_sej is main clock is for secure engine with JTAG support 
 INFRA_AO1 
 infra_ao_device_apc is for device access permission control module 
 INFRA_AO2 
 INFRA_AO3 
 infra_ao_device_apc_sync is for device access permission control module 
 INFRA_AO4 
 infra_ao_133m_m_peri infra_ao_66m_m_peri are main clocks of peripheral 
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2016 MediaTek Inc.
  Author: Kevin Chen <kevin-cw.chen@mediatek.com>
  For some clocks, we don't care what their actual rates are. And these
  clocks may change their rate on different products or different scenarios.
  So we model these clocks' rate as 0, to denote it's not an actual rate.
  Clock mux ddrphycfg is needed by the DRAM controller. We mark it as
  critical as otherwise the system will hang after boot.
  Clock gates dramc and dramc_b are needed by the DRAM controller.
  We mark them as critical as otherwise the system will hang after boot.
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 VDEC0 
 VDEC1 
 VDEC2 
 VDEC0 
 VDEC1 
 VDEC2 
 VDEC0 
 VDEC1 
 VDEC2 
 sentinel 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 MediaTek Inc.
  Author: Owen Chen <owen.chen@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 MediaTek Inc.
  Author: Weiyi Lu <weiyi.lu@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 VDO0_0 
 VDO0_1 
 VDO0_2 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 MediaTek Inc.
  Author: Chen Zhong <chen.zhong@mediatek.com>
 	   Sean Wang <sean.wang@mediatek.com>
 for consumer 
 TOP0 
 TOP1 
 PERI0 
 PERI1 
 CLK_CFG_0 
 CLK_CFG_1 
 CLK_CFG_2 
 CLK_CFG_3 
 CLK_CFG_4 
 CLK_CFG_5 
 CLK_CFG_6 
 CLK_CFG_7 
 CLK_AUDDIV_0 
 PERI_GLOBALCON_CKSEL 
 sentinel 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 MediaTek Inc.
 Author: Weiyi Lu <weiyi.lu@mediatek.com>
 Infra global controller reset set register 
  CRITICAL CLOCK:
  axi_sel is the main bus clock of whole SOC.
  spm_sel is the clock of the always-on co-processor.
 CLK_CFG_0 
 CLK_CFG_1 
 CLK_CFG_2 
 CLK_CFG_3 
 CLK_CFG_4 
 CLK_CFG_5 
 CLK_CFG_6 
 CLK_CFG_7 
 CLK_CFG_8 
 CLK_CFG_9 
 CLK_CFG_10 
 mp0_pll_divider_cfg 
 mp2_pll_divider_cfg 
 bus_pll_divider_cfg 
 TOP 
 INFRA0 
 INFRA1 
 INFRA2 
 INFRA3 
  CRITICAL CLOCK:
  apmixed_appll26m is the toppest clock gate of all PLLs.
 AUDIO0 
 sentinel 
 sentinel 
 sentinel 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2019 MediaTek Inc.
  Author: Wendell Lin <wendell.lin@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 MediaTek Inc.
  Author: Owen Chen <owen.chen@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 MediaTek Inc.
  Author: Chen Zhong <chen.zhong@mediatek.com>
 	   Sean Wang <sean.wang@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 MediaTek Inc.
  Author: Kevin-CW Chen <kevin-cw.chen@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 MediaTek Inc.
  Author: Shunli Wang <shunli.wang@mediatek.com>
  For some clocks, we don't care what their actual rates are. And these
  clocks may change their rate on different products or different scenarios.
  So we model these clocks' rate as 0, to denote it's not an actual rate.
 sentinel 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2019 MediaTek Inc.
  Author: Wendell Lin <wendell.lin@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 MediaTek Inc.
  Author: Shunli Wang <shunli.wang@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 MediaTek Inc.
 Author: Weiyi Lu <weiyi.lu@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 MDP0 
 MDP1 
 sentinel 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 MediaTek Inc.
  Author: Ryder Lee <ryder.lee@mediatek.com>
 AUDIO0 
 AUDIO1 
 AUDIO2 
 AUDIO3 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 MediaTek Inc.
  Author: Weiyi Lu <weiyi.lu@mediatek.com>
 VDEC0 
 VDEC1 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 MediaTek Inc.
  Author: Weiyi Lu <weiyi.lu@mediatek.com>
 MM0 
 MM1 
 MM2 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2019 MediaTek Inc.
  Author: Wendell Lin <wendell.lin@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 MediaTek Inc.
  Author: Shunli Wang <shunli.wang@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 VPP1_0 
 VPP1_1 
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 MediaTek Inc.
  Author: Shunli Wang <shunli.wang@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 MediaTek Inc.
  Author: Owen Chen <owen.chen@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 MediaTek Inc.
 Author: Weiyi Lu <weiyi.lu@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 MediaTek Inc.
  Author: Owen Chen <owen.chen@mediatek.com>
 MM 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 MediaTek Inc.
  Author: Owen Chen <owen.chen@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 MediaTek Inc.
 Author: Weiyi Lu <weiyi.lu@mediatek.com>
 VDEC0 
 VDEC1 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2019 MediaTek Inc.
  Author: Wendell Lin <wendell.lin@mediatek.com>
 AUDIO0 
 AUDIO1 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 MediaTek Inc.
  Author: Sean Wang <sean.wang@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 AUD0 
 AUD1 
 AUD2 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 MediaTek Inc.
 Author: Weiyi Lu <weiyi.lu@mediatek.com>
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 MediaTek Inc.
 Author: Weiyi Lu <weiyi.lu@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 MediaTek Inc.
  Author: Weiyi Lu <weiyi.lu@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 VDO1_0 
 VDO1_1 
 VDO1_2 
 VDO1_3 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 MediaTek Inc.
  Author: Owen Chen <owen.chen@mediatek.com>
 AUDIO0 
 AUDIO1 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 MediaTek Inc.
  Author: Shunli Wang <shunli.wang@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 MediaTek Inc.
  Author: James Liao <jamesjj.liao@mediatek.com>
 MM0 
 MM1 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 MediaTek Inc.
  Author: James Liao <jamesjj.liao@mediatek.com>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 MediaTek Inc.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2020 MediaTek Inc.
  Copyright (c) 2020 BayLibre, SAS
  Author: James Liao <jamesjj.liao@mediatek.com>
          Fabien Parent <fparent@baylibre.com>
 CLK_MUX_SEL0 
 CLK_MUX_SEL1 
 CLK_MUX_SEL8 
 CLK_SEL_9 
 CLK_MUX_SEL13 
 TOP0 
 TOP1 
 TOP2 
 TOP3 
 TOP4 
 TOP5 
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 MediaTek Inc.
  Author: Chen Zhong <chen.zhong@mediatek.com>
 	   Sean Wang <sean.wang@mediatek.com>
 AUDIO0 
 AUDIO1 
 AUDIO2 
 AUDIO3 
 sentinel 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2021 MediaTek Inc.
 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
 sentinel 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2012 Freescale Semiconductor, Inc.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2012 Freescale Semiconductor, Inc.
 Gate off cpu clock in WFI for power saving 
 Clear BYPASS for SAIF 
 SAIF has to use frac div for functional operation 
	
	  Source ssp clock from ref_io than ref_xtal,
	  as ref_xtal only provides 24 MHz as maximum.
	
	  480 MHz seems too high to be ssp clock source directly,
	  so set frac to get a 288 MHz ref_io.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2012 Freescale Semiconductor, Inc.
  HW_SAIF_CLKMUX_SEL:
   DIRECT(0x0): SAIF0 clock pins selected for SAIF0 input clocks, and SAIF1
 		clock pins selected for SAIF1 input clocks.
   CROSSINPUT(0x1): SAIF1 clock inputs selected for SAIF0 input clocks, and
 		SAIF0 clock inputs selected for SAIF1 input clocks.
   EXTMSTR0(0x2): SAIF0 clock pin selected for both SAIF0 and SAIF1 input
 		clocks.
   EXTMSTR1(0x3): SAIF1 clock pin selected for both SAIF0 and SAIF1 input
 		clocks.
 Gate off cpu clock in WFI for power saving 
 0 is a bad default value for a divider 
 Clear BYPASS for SAIF 
 SAIF has to use frac div for functional operation 
 Extra fec clock setting 
	
	  Source ssp clock from ref_io than ref_xtal,
	  as ref_xtal only provides 24 MHz as maximum.
	
	  480 MHz seems too high to be ssp clock source directly,
	  so set frac0 to get a 288 MHz ref_io0 and ref_io1.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2012 Freescale Semiconductor, Inc.
  struct clk_frac - mxs fractional divider clock
  @hw: clk_hw for the fractional divider clock
  @reg: register address
  @shift: the divider bit shift
  @width: the divider bit width
  @busy: busy bit shift
  The clock is an adjustable fractional divider with a busy bit to wait
  when the divider is adjusted.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2012 Freescale Semiconductor, Inc.
  struct clk_pll - mxs pll clock
  @hw: clk_hw for the pll
  @base: base address of the pll
  @power: the shift of power bit
  @rate: the clock rate of the pll
  The mxs pll is a fixed rate clock with power and gate control,
  and the shift of gate bit is always 31.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2012 DENX Software Engineering, GmbH
  Pulled from code:
  Portions copyright (C) 2003 Russell King, PXA MMCI Driver
  Portions copyright (C) 2004-2005 Pierre Ossman, W83L51xD SDMMC driver
  Copyright 2008 Embedded Alley Solutions, Inc.
  Copyright 2009-2011 Freescale Semiconductor, Inc.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2012 Freescale Semiconductor, Inc.
  struct clk_div - mxs integer divider clock
  @divider: the parent class
  @ops: pointer to clk_ops of parent class
  @reg: register address
  @busy: busy bit shift
  The mxs divider clock is a subclass of basic clk_divider with an
  addtional busy bit.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2012 Freescale Semiconductor, Inc.
  struct clk_ref - mxs reference clock
  @hw: clk_hw for the reference clock
  @reg: register address
  @idx: the index of the reference clock within the same register
  The mxs reference clock sources from pll.  Every 4 reference clocks share
  one register space, and @idx is used to identify them.  Each reference
  clock has a gate control and a fractional  divider.  The rate is calculated
  as pll rate   (18  FRAC), where FRAC = 18 ~ 35.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2014 Chen-Yu Tsai
  Author: Chen-Yu Tsai <wens@csie.org>
  Allwinner A23 APB0 clock driver
  Based on clk-sun6i-apb0.c
  Allwinner A31 APB0 clock driver
  Copyright (C) 2014 Free Electrons
  Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
 The A23 APB0 clock is a standard 2 bit wide divider clock 
		
		  This happens with clk nodes instantiated through mfd,
		  as those do not have their resources assigned in the
		  device tree. Do not print an error in this case.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2014 Free Electrons
  Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
  Allwinner A31 APB0 clock driver
  The APB0 clk has a configurable divisor.
  We must use a clk_div_table and not a regular power of 2
  divisor here, because the first 2 values divide the clock
  by 2.
 sentinel  },
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
 ahb_sdram 
 dram_output 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2013-2015 Emilio López
  Emilio López <emilio@elopez.com.ar>
  sunxi_usb_reset... - reset bits in usb clk registers handling
  sunxi_usb_clk_setup() - Setup function for usb gate clocks
 Worst-case size approximation and memory allocation 
 Adjust to the real max 
 Register a reset controller for usb with reset bits 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
 We only have a single reset signal 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2013 Emilio López
  Emilio López <emilio@elopez.com.ar>
 allocate fixed-rate and gate clock structs 
 set up gate and fixed rate properties 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2013 Emilio López
  Emilio López <emilio@elopez.com.ar>
  Copyright 2013 Chen-Yu Tsai
  Chen-Yu Tsai <wens@csie.org>
  sun7i_a20_gmac_clk_setup - Setup function for A20A31 GMAC clock module
  This clock looks something like this
                                ________________________
   MII TX clock from PHY >-----|___________    _________|----> to GMAC core
   GMAC Int. RGMII TX clk >----|___________\____gate---|----> to PHY
   Ext. 125MHz RGMII TX clk >--|__divider__            |
                               |________________________|
  The external 125 MHz reference is optional, i.e. GMAC can use its
  internal TX clock just fine. The A31 GMAC clock module does not have
  the divider controls for the external reference.
  To keep it simple, let the GMAC use either the MII TX clock for MII mode,
  and its internal TX clock for GMII and RGMII modes. The GMAC driver should
  select the appropriate source and gateungate the output to the PHY.
  Only the GMAC should use this clock. Altering the clock so that it doesn't
  match the GMAC's operation parameters will result in the GMAC not being
  able to send traffic out. The GMAC driver should set the clock rate and
  enabledisable this clock to configure the required state. The clock
  driver then responds by auto-reparenting the clock.
 Select mii_phy_tx_clk 
 Select gmac_int_tx_clk 
 allocate mux and gate clock structs 
 gmac clock requires exactly 2 parents 
 set up gate and fixed rate properties 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015 Chen-Yu Tsai
  Chen-Yu Tsai <wens@csie.org>
  sunxi_ve_reset... - reset bit in ve clk registers handling
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2013 Emilio López
  Emilio López <emilio@elopez.com.ar>
  sun4i_a10_get_mod0_factors() - calculates m, n factors for MOD0-style clocks
  MOD0 rate is calculated as follows
  rate = (parent_rate >> p)  (m + 1);
	 These clocks can only divide, so we will never be able to achieve
 user manual says "n" but it's really "p" 
		
		  This happens with mod0 clk nodes instantiated through
		  mfd, as those do not have their resources assigned at
		  CLK_OF_DECLARE time yet, so do not print an error.
 sentinel  }
 The MBUS clocks needs to be always enabled 
 Get the main MMC clock 
 And its rate 
 Now, get the MMC parent (most likely some PLL) 
 And its rate 
 Get MMC clock divider 
 Get the main MMC clock 
 And its rate 
 Now, get the MMC parent (most likely some PLL) 
 And its rate 
 Get MMC clock divider 
		
		  We can only outphase the clocks by multiple of the
		  PLL's period.
		 
		  Since the MMC clock in only a divider, and the
		  formula to get the outphasing in degrees is deg =
		  360  delta  period
		 
		  If we simplify this formula, we can see that the
		  only thing that we're concerned about is the number
		  of period we want to outphase our clock from, and
		  the divider set by the MMC clock.
  sunxi_mmc_setup - Common setup function for mmc module clocks
  The only difference between module clocks on different platforms is the
  width of the mux register bits and the valid values, which are passed in
  through struct factors_data. The phase clocks parts are identical.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2015 Jens Kuske <jenskuske@gmail.com>
  Based on clk-simple-gates.c, which is:
  Copyright 2015 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2013 Emilio López
  Emilio López <emilio@elopez.com.ar>
 Maximum number of parents our clocks have 
  sun4i_get_pll1_factors() - calculates n, k, m, p factors for PLL1
  PLL1 rate is calculated as follows
  rate = (parent_rate  n  (k + 1) >> p)  (m + 1);
  parent_rate is always 24Mhz
 Normalize value to a 6M multiple 
 m is always zero for pll1 
 k is 1 only on these cases 
 p will be 3 for divs under 10 
 p will be 2 for divs between 10 - 20 and odd divs under 32 
	 p will be 1 for even divs under 32, divs under 40 and odd pairs
 any other entries have p = 0 
 calculate a suitable n based on k and p 
  sun6i_a31_get_pll1_factors() - calculates n, k and m factors for PLL1
  PLL1 rate is calculated as follows
  rate = parent_rate  (n + 1)  (k + 1)  (m + 1);
  parent_rate should always be 24MHz
	
	  We can operate only on MHz, this will make our life easier
	  later.
	
	  Round down the frequency to the closest multiple of either
	  6 or 16
 If the frequency is a multiple of 32 MHz, k is always 3 
 If the frequency is a multiple of 9 MHz, k is always 2 
 If the frequency is a multiple of 8 MHz, k is always 1 
 Otherwise, we don't use the k factor 
	
	  If the frequency is a multiple of 2 but not a multiple of
	  3, m is 3. This is the first time we use 6 here, yet we
	  will use it on several other places.
	  We use this number because it's the lowest frequency we can
	  generate (with n = 0, k = 0, m = 3), so every other frequency
	  somehow relates to this frequency.
	
	  If the frequency is a multiple of 6MHz, but the factor is
	  odd, m will be 3
 Otherwise, we end up with m = 1 
 Calculate n thanks to the above factors we already got 
	
	  If n end up being outbound, and that we can still decrease
	  m, do it.
  sun8i_a23_get_pll1_factors() - calculates n, k, m, p factors for PLL1
  PLL1 rate is calculated as follows
  rate = (parent_rate  (n + 1)  (k + 1) >> p)  (m + 1);
  parent_rate is always 24Mhz
 Normalize value to a 6M multiple 
 m is always zero for pll1 
 k is 1 only on these cases 
 p will be 2 for divs under 20 and odd divs under 32 
	 p will be 1 for even divs under 32, divs under 40 and odd pairs
 any other entries have p = 0 
 calculate a suitable n based on k and p 
  sun4i_get_pll5_factors() - calculates n, k factors for PLL5
  PLL5 rate is calculated as follows
  rate = parent_rate  n  (k + 1)
  parent_rate is always 24Mhz
 Normalize value to a parent_rate multiple (24M) 
  sun6i_a31_get_pll6_factors() - calculates n, k factors for A31 PLL6x2
  PLL6x2 rate is calculated as follows
  rate = parent_rate  (n + 1)  (k + 1)
  parent_rate is always 24Mhz
 Normalize value to a parent_rate multiple (24M) 
  sun5i_a13_get_ahb_factors() - calculates m, p factors for AHB
  AHB rate is calculated as follows
  rate = parent_rate >> p
 divide only 
	
	  user manual says valid speed is 8k ~ 276M, but tests show it
	  can work at speeds up to 300M, just after reparenting to pll6
 p = 0 ~ 3 
  sun6i_a31_get_ahb_factors() - calculates m, p factors for AHB
  AHB rate is calculated as follows
  rate = parent_rate >> p
  if parent is pll6, then
  parent_rate = pll6 rate  (m + 1)
	
	  clock can only divide, so we will never be able to achieve
	  frequencies higher than the parent frequency
 calculate pre-divider if parent is pll6 
  sun6i_ahb1_recalc() - calculates AHB clock rate from m, p factors and
 			 parent index
 apply pre-divider first if parent is pll6 
 clk divider 
  sun4i_get_apb1_factors() - calculates m, p factors for APB1
  APB1 rate is calculated as follows
  rate = (parent_rate >> p)  (m + 1);
 Invalid rate! 
  sun7i_a20_get_out_factors() - calculates m, p factors for CLK_OUT_AB
  CLK_OUT rate is calculated as follows
  rate = (parent_rate >> p)  (m + 1);
	 These clocks can only divide, so we will never be able to achieve
  sunxi_factors_clk_setup() - Setup function for factor clocks
 user manual says "n" but it's really "p" 
  sunxi_mux_clk_setup() - Setup function for muxes
 Protect CPU clock 
  sunxi_divider_clk_setup() - Setup function for simple divider clocks
 sentinel 
 sentinel 
  sunxi_gates_clk_setup() - Setup function for leaf gates on clocks
  sunxi_divs_clk_setup() helper data
 data for the factor clock 
 number of outputs 
	
	  List of outputs. Refer to the diagram for sunxi_divs_clk_setup():
	  self or base factor clock refers to the output from the pll
	  itself. The remaining refer to fixed or configurable divider
	  outputs.
 is it the base factor clock? (only one) 
 is it a fixed divisor? if not... 
 is it a table based divisor? 
 otherwise it's a normal divisor with this shift 
 is it power-of-two based? 
 is it independently gateable? 
 sentinel 
 Protect PLL5_DDR 
 M, DDR 
 P, other 
 No output for the base factor clock 
 M, SATA 
 P, other 
 base factor clock, 2x 
 pll6  4, used as ahb input 
 normal output 
 base factor clock, 2x 
  sunxi_divs_clk_setup() - Setup function for leaf divisors on clocks
  These clocks look something like this
             ________________________
            |         ___divisor 1---|----> to consumer
  parent >--|  pll______divisor 2---|----> to consumer
            |        \_______________|____> to consumer
            |________________________|
 if number of children known, use it 
 Try to find a name for base factor clock 
 If we don't have a .self clk use the first output-name up to '_' 
 Set up factor clock that we will be dividing 
	 It's not a good idea to have automatic reparenting changing
 If this is the base factor clock, only update clks 
 If this leaf clock can be gated, create a gate 
 Leaves can be fixed or configurable divisors 
		 Wrap the (potential) gate and the divisor on a composite
 Adjust to the real max 
  sun6i display
  rate = parent_rate  (m + 1);
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2014 Chen-Yu Tsai
  Chen-Yu Tsai <wens@csie.org>
 The MBUS clocks needs to be always enabled 
 parents is deep copied 
 TODO: The composite clock stuff will leak a bit here. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2013 Emilio López
  Emilio López <emilio@elopez.com.ar>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2013 Emilio López <emilio@elopez.com.ar>
  Adjustable factor-based clock implementation
  DOC: basic adjustable factor-based clock
  Traits of this clock:
  prepare - clk_prepare only ensures that parents are prepared
  enable - clk_enable only ensures that parents are enabled
  rate - rate is adjustable.
         clk->rate = (parent->rate  N  (K + 1) >> P)  (M + 1)
  parent - fixed parent.  No clk_set_parent support
 Fetch the register value 
 Get each individual factor if applicable 
 get mux details from mux clk structure 
 Calculate the rate 
 find the parent that can help provide the fastest rate <= rate 
 Fetch the register value 
 Set up the new factors - macros do not do anything if width is 0 
 Apply them now 
 delay 500us so pll stabilizes 
 if we have a mux, we will have >1 parents 
	
	  some factor clocks, such as pll5 and pll6, may have multiple
	  outputs, and have their name designated in factors_data
 set up factors properties 
 Add a gate if this factor clock can be gated 
 set up gate properties 
 Add a mux if this factor clock can be muxed 
 set up gate properties 
 TODO: The composite clock stuff will leak a bit here. 
 TODO: The composite clock stuff will leak a bit here. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2014 Free Electrons
  Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
  Allwinner A31 APB0 clock gates driver
 sentinel  }
 Worst-case size approximation and memory allocation 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2014 Chen-Yu Tsai
  Chen-Yu Tsai <wens@csie.org>
  sun9i_a80_get_pll4_factors() - calculates n, p, m factors for PLL4
  PLL4 rate is calculated as follows
  rate = (parent_rate  n >> p)  (m + 1);
  parent_rate is always 24MHz
  p and m are named div1 and div2 in Allwinner's SDK
 Normalize value to a 6 MHz multiple (24 MHz  4) 
 If n is too large switch to steps of 12 MHz 
 If n is still too large switch to steps of 24 MHz 
 n must be between 12 and 255 
  sun9i_a80_get_gt_factors() - calculates m factor for GT
  GT rate is calculated as follows
  rate = parent_rate  (m + 1);
 maximum divider is 4 
 The GT bus clock needs to be always enabled 
  sun9i_a80_get_ahb_factors() - calculates p factor for AHB012
  AHB rate is calculated as follows
  rate = parent_rate >> p;
 maximum p is 3 
  sun9i_a80_get_apb1_factors() - calculates m, p factors for APB1
  APB1 rate is calculated as follows
  rate = (parent_rate >> p)  (m + 1);
 Highest possible divider is 256 (p = 3, m = 31) 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015 Chen-Yu Tsai
  Chen-Yu Tsai	<wens@csie.org>
 one clockreset pair per word 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2015 Chen-Yu Tsai
  Chen-Yu Tsai <wens@csie.org>
  Allwinner A80 CPUS clock driver
  sun9i_a80_cpus_clk_setup() - Setup function for a80 cpus composite clk
 Fetch the register value 
 apply pre-divider first if parent is pll4 
 clk divider 
	
	  clock can only divide, so we will never be able to achieve
	  frequencies higher than the parent frequency
 calculate pre-divider if parent is pll4 
 pre-divider is 1 ~ 32 
 we were asked to pass back divider values 
 find the parent that can help provide the fastest rate <= rate 
 need to know which parent is used to apply pre-divider 
 we have a mux, we will have >1 parents 
 set up clock properties 
 un-shifted mask is what mux_clk expects 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2013 Emilio López
  Emilio López <emilio@elopez.com.ar>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2014 Free Electrons
  Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
  Allwinner A31 AR100 clock driver
  sun6i_get_ar100_factors - Calculates factors p, m for AR100
  AR100 rate is calculated as follows
  rate = (parent_rate >> p)  (m + 1);
 clock only divides 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2013 Emilio López
  Emilio López <emilio@elopez.com.ar>
  Copyright 2015 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
 Setup the gate part of the PLL2 
 Setup the multiplier part of the PLL2 
	
	  PLL2-1x
	 
	  This is supposed to have a post divider, but we won't need
	  to use it, we just need to initialise it to 4, and use a
	  fixed divider.
	
	  PLL2-2x
	 
	  This clock doesn't use the post divider, and really is just
	  a fixed divider from the PLL2 base clock.
 PLL2-4x 
 PLL2-8x 
 SPDX-License-Identifier: GPL-2.0
 sentinel }
 sentinel }
 sentinel }
 sentinel }
 sentinel }
 SPDX-License-Identifier: GPL-2.0-or-later
  clk-h32mx.c
   Copyright (C) 2014 Atmel
  Alexandre Belloni <alexandre.belloni@free-electrons.com>
 SPDX-License-Identifier: GPL-2.0
 CONFIG_HAVE_AT91_AUDIO_PLL 
 CONFIG_HAVE_AT91_GENERATED_CLK 
 CONFIG_HAVE_AT91_H32MX 
 CONFIG_HAVE_AT91_I2S_MUX_CLK 
 CONFIG_HAVE_AT91_SMD 
 CONFIG_HAVE_AT91_USB_CLK 
	
	  If the device supports different mainck rates, this value has to be
	  set in the UTMI Clock Trimming register.
	  - 9x5: mainck supports several rates but it is indicated that a
	    12 MHz is needed in case of USB.
	  - sama5d3 and sama5d2: mainck supports several rates. Configuring
	    the FREQ field of the UTMI Clock Trimming register is mandatory.
	  - sama5d4: mainck is at 12 MHz.
	 
	  We only need to retrieve sama5d3 or sama5d2 sfr regmap.
 CONFIG_HAVE_AT91_UTMI 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>
 SPDX-License-Identifier: GPL-2.0
  The TCB is used as the clocksource so its clock is needed early. This means
  this can't be a platform driver.
 SPDX-License-Identifier: GPL-2.0
					   
					     This feeds pllack_divck which
					     feeds CPU. It should not be
					     disabled.
					   
					     This feeds CPU. It should not
					     be disabled.
 Some clks are used for a clocksource 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>
 SPDX-License-Identifier: GPL-2.0
  The TCB is used as the clocksource so its clock is needed early. This means
  this can't be a platform driver.
 SPDX-License-Identifier: GPL-2.0+
   Copyright (C) 2019 Microchip Technology Inc.
 Recommended value for PMC_PLL_ACR 
 Enable the UTMI internal bandgap 
 Enable the UTMI internal regulator 
	
	  Calculate the multiplier associated with the current
	  divider that provide the closest rate to the requested one.
 Check if resulted rate is a valid.  
 This function should be called with spinlock acquired. 
 Stop if enabled an nothing changed. 
 Stop if nothing changed. 
	
	  We switch to safe divider to avoid overclocking of other domains
	  feed by us while the frac PLL (our parent) is changed.
 Stop if nothing changed. 
		
		  This means the PLL is not setup by bootloaders. In this
		  case we need to set the minimum rate for it. Otherwise
		  a clock child of this PLL may be enabled before setting
		  its rate leading to enabling this PLL with unsupported
		  rate. This will lead to PLL not being locked at all.
 We only support one changeable PLL. 
 SPDX-License-Identifier: GPL-2.0
  SAMA7G5 PMC code.
  Copyright (C) 2020 Microchip Technology Inc. and its subsidiaries
  Author: Claudiu Beznea <claudiu.beznea@microchip.com>
  PLL clocks identifiers
  @PLL_ID_CPU:		CPU PLL identifier
  @PLL_ID_SYS:		System PLL identifier
  @PLL_ID_DDR:		DDR PLL identifier
  @PLL_ID_IMG:		Image subsystem PLL identifier
  @PLL_ID_BAUD:	Baud PLL identifier
  @PLL_ID_AUDIO:	Audio PLL identifier
  @PLL_ID_ETH:		Ethernet PLL identifier
  PLL type identifiers
  @PLL_TYPE_FRAC:	fractional PLL identifier
  @PLL_TYPE_DIV:	divider PLL identifier
 Layout for fractional PLLs. 
 Layout for DIVPMC dividers. 
 Layout for DIVIO dividers. 
  CPU PLL output range.
  Notice: The upper limit has been setup to 1000000002 due to hardware
  block which cannot output exactly 1GHz.
 PLL output range. 
 CPU PLL characteristics. 
 PLL characteristics. 
  PLL clocks description
  @n:		clock name
  @p:		clock parent
  @l:		clock layout
  @c:		clock characteristics
  @t:		clock type
  @f:		clock flags
  @eid:	export index in sama7g5->chws[] array
  @safe_div:	intermediate divider need to be set on PRE_RATE_CHANGE
 		notification
		   
		     This feeds cpupll_divpmcck which feeds CPU. It should
		     not be disabled.
 This feeds CPU. It should not be disabled. 
		  
		    Safe div=15 should be safe even for switching bw 1GHz and
		    90MHz (frac pll might go up to 1.2GHz).
		   
		     This feeds syspll_divpmcck which may feed critical parts
		     of the systems like timers. Therefore it should not be
		     disabled.
		   
		     This may feed critical parts of the systems like timers.
		     Therefore it should not be disabled.
		   
		     This feeds ddrpll_divpmcck which feeds DDR. It should not
		     be disabled.
 This feeds DDR. It should not be disabled. 
  Master clock (MCK[1..4]) description
  @n:			clock name
  @ep:			extra parents names array
  @ep_chg_chg_id:	index in parents array that specifies the changeable
 			parent
  @ep_count:		extra parents count
  @ep_mux_table:	mux table for extra parents
  @id:			clock id
  @c:			true if clock is critical and cannot be disabled
  System clock description
  @n:	clock name
  @p:	clock parent name
  @id: clock id
 Mux table for programmable clocks. 
  Peripheral clock description
  @n:		clock name
  @p:		clock parent name
  @r:		clock range values
  @id:		clock id
  @chgp:	index in parent array of the changeable parent
  Generic clock description
  @n:			clock name
  @pp:			PLL parents
  @pp_mux_table:	PLL parents mux table
  @r:			clock output range
  @pp_chg_id:		id in parent array of changeable PLL parent
  @pp_count:		PLL parents count
  @id:			clock id
 MCK0 characteristics. 
 MCK0 layout. 
 Programmable clock layout. 
 Peripheral clock layout. 
 Some clks are used for a clocksource 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>
 Fist step: check the available dividers. 
 Step two: try to request rate from parent. 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  The TCB is used as the clocksource so its clock is needed early. This means
  this can't be a platform driver.
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>
 Check if parent_rate is a valid input rate 
	
	  Calculate minimum divider based on the minimum multiplier, the
	  parent_rate and the requested rate.
	  Should always be 2 according to the input and output characteristics
	  of the PLL blocks.
	
	  Calculate the maximum divider which is limited by PLL register
	  layout (limited by the MUL or DIV field size).
	
	  Iterate over the acceptable divider values to find the best
	  dividermultiplier pair (the one that generates the closest
	  rate to the requested one).
		
		  Calculate the multiplier associated with the current
		  divider that provide the closest rate to the requested one.
		
		  Compare the remainder with the best remainder found until
		  now and elect a new best multiplierdivider pair if the
		  current remainder is smaller than the best one.
		
		  We've found a perfect match!
		  Stop searching now and use this multiplierdivider pair.
 We haven't found any multiplierdivider pair => return -ERANGE 
 Check if bestrate is a valid output rate  
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>
 Address in SECURAM that say if we suspend to backup mode. 
 sentinel  }
 This has to happen before arch_initcall because of the tcb_clksrc driver 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (C) 2015 Atmel Corporation,
                      Nicolas Ferre <nicolas.ferre@atmel.com>
  Based on clk-programmable & clk-peripheral drivers by Boris BREZILLON.
 do not look for a rate that is outside of our range 
	
	  The audio_pll rate can be modified, unlike the five others clocks
	  that should never be altered.
	  The audio_pll can technically be used by multiple consumers. However,
	  with the rate locking, the first consumer to enable to clock will be
	  the one definitely setting the rate of the clock.
	  Since audio IPs are most likely to request the same rate, we enforce
	  that the only clks able to modify gck rate are those of audio IPs.
 No modification of hardware as we have the flag CLK_SET_PARENT_GATE set 
 No modification of hardware as we have the flag CLK_SET_RATE_GATE set 
  clk_generated_startup - Initialize a given clock to its default parent and
  divisor parameter.
  @gck:	Generated clock to set the startup parameters for.
  Take parameters from the hardware and update local clock configuration
  accordingly.
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>
 MCK div reference to be used by notifier. 
 This function must be called with lock acquired. 
		
		  We want to avoid any overclocking of MCK DIV domain. To do
		  this we set a safe divider (the underclocking is not of
		  interest as we can go as low as 32KHz). The relation
		  bw this clock and its parents are as follows:
		 
		  FRAC PLL -> DIV PLL -> MCK DIV
		 
		  With the proper safe divider we should be good even with FRAC
		  PLL at its maximum value.
 Switch to safe divider. 
		
		  At this point we want to restore MCK DIV domain to its maximum
		  allowed rate.
 Update the div to preserve MCK DIV clock rate. 
 First: check the dividers of MCR. 
 Second: try to request rate form changeable parent. 
 Wait here only if parent is being changed. 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (C) 2016 Atmel Corporation,
 		       Songjun Wu <songjun.wu@atmel.com>,
                      Nicolas Ferre <nicolas.ferre@atmel.com>
   Copyright (C) 2017 Free Electrons,
 		       Quentin Schulz <quentin.schulz@free-electrons.com>
  The Sama5d2 SoC has two audio PLLs (PMC and PAD) that shares the same parent
  (FRAC). FRAC can output between 620 and 700MHz and only multiply the rate of
  its own parent. PMC and PAD can then divide the FRAC rate to best match the
  asked rate.
  Traits of FRAC clock:
  enable - clk_enable writes nd, fracr parameters and enables PLL
  rate - rate is adjustable.
         clk->rate = parent->rate  ((nd + 1) + (fracr  2^22))
  parent - fixed parent.  No clk_set_parent support
  Traits of PMC clock:
  enable - clk_enable writes qdpmc, and enables PMC output
  rate - rate is adjustable.
         clk->rate = parent->rate  (qdpmc + 1)
  parent - fixed parent.  No clk_set_parent support
  Traits of PAD clock:
  enable - clk_enable writes divisors and enables PAD output
  rate - rate is adjustable.
         clk->rate = parent->rate  (qdaudio  div))
  parent - fixed parent.  No clk_set_parent support
	
	  reset and enable have to be done in 2 separated writes
	  for AT91_PMC_AUDIO_PLL0
 do it in 2 separated writes 
 we can cast here as we verified the bounds just above 
	
	  Rate divisor is actually made of two different divisors, multiplied
	  between themselves before dividing the rate.
	  tmp_qd goes from 1 to 31 and div is either 2 or 3.
	  In order to avoid testing twice the rate divisor (e.g. divisor 12 can
	  be found with (tmp_qd, div) = (2, 6) or (3, 4)), we remove any loop
	  for a rate divisor when div is 2 and tmp_qd is a multiple of 3.
	  We cannot inverse it (condition div is 3 and tmp_qd is even) or we
	  would miss some rate divisor that aren't reachable with div being 2
	  (e.g. rate divisor 90 is made with div = 3 and tmp_qd = 30, thus
	  tmp_qd is even so we skip it because we think div 2 could make this
	  rate divisor which isn't possible since tmp_qd has to be <= 31).
 got exact match 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-or-later
  driversclkat91sckc.c
   Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>
 DT backward compatibility 
 DT backward compatibility 
 MD_SLCK and TD_SLCK. 
	
	  Assume that if it has already been selected (for example by the
	  bootloader), enough time has aready passed.
 SPDX-License-Identifier: GPL-2.0
  While the TCB can be used as the clocksource, the system timer is most likely
  to be used instead. However, the pinctrl driver doesn't support probe
  deferring properly. Once this is fixed, this can be switched to a platform
  driver.
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>
  The purpose of this clock is to generate a 480 MHz signal. A different
  rate can't be configured.
	
	  If mainck rate is different from 12 MHz, we have to configure the
	  FREQ field of the SFR_UTMICKTRIM register to generate properly
	  the utmi clock.
	
	  Not supported on SAMA5D2 but it's not an issue since MAINCK
	  maximum value is 24 MHz.
 UTMI clk rate is fixed. 
 SPDX-License-Identifier: GPL-2.0
   Copyright (C) 2018 Microchip Technology Inc,
                      Codrin Ciubotariu <codrin.ciubotariu@microchip.com>
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>
 SPDX-License-Identifier: GPL-2.0-or-later
  driversclkat91clk-slow.c
   Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>
  Copyright (C) 2012 ST Microelectronics
  Viresh Kumar <vireshk@kernel.org>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  Fractional Synthesizer clock implementation
  DOC: Fractional Synthesizer clock
  Fout from synthesizer can be given from below equation:
  Fout= Fin2div (division factor)
  div is 17 bits:-
 	0-13 (fractional part)
 	14-16 (integer part)
 	div is (16-14 bits).(13-0 bits) (in binary)
 	Fout = Fin(2  div)
 	Fout = ((Fin  10000)(2  div))  10000
 	Fout = (2^14  (Fin  10000)(2^14  (2  div)))  10000
 	Fout = (((Fin  10000) << 14)(2  (div << 14)))  10000
  div << 14 simply 17 bit value written at register.
  Max error due to scaling down by 10000 is 10 KHz
 Configures new clock rate of frac 
 struct clk_frac assignments 
  Copyright (C) 2012 ST Microelectronics
  Viresh Kumar <vireshk@kernel.org>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  SPEAr clk - Common routines
 previous clock was best 
  SPEAr6xx machines clock framework source file
  Copyright (C) 2012 ST Microelectronics
  Viresh Kumar <vireshk@kernel.org>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 PLL_CLK_CFG register masks 
 CORE CLK CFG register masks 
 PERIP_CLK_CFG register masks 
 PERIP1_CLK_ENB register masks 
 vco rate configuration table, in ascending order of rates 
 vco 332 & pll 166 MHz 
 vco 532 & pll 266 MHz 
 vco 664 & pll 332 MHz 
 aux rate configuration table, in ascending order of rates 
 For PLL1 = 332 MHz 
 12.296 MHz 
 41.5 MHz 
 83 MHz 
 166 MHz 
 gpt rate configuration table, in ascending order of rates 
 For pll1 = 332 MHz 
 41.5 MHz 
 55.3 MHz 
 83 MHz 
 clock derived from 32 KHz osc clk 
 clock derived from 30 MHz osc clk 
 clock derived from pll1 clk 
 gpt clocks 
 clock derived from pll3 clk 
 clock derived from ahb clk 
 clock derived from apb clk 
  archarmmach-spear13xxspear1340_clock.c
  SPEAr1340 machine clock framework source file
  Copyright (C) 2012 ST Microelectronics
  Viresh Kumar <vireshk@kernel.org>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 Clock Configuration Registers 
 PLL related registers and bit values 
 PLL_CFG bit values 
 PERIP_CLK_CFG bit values 
 I2S_CLK_CFG register mask 
 pll rate configuration table, in ascending order of rates 
 PCLK 24MHz 
 vco 1572, pll 49.125 MHz 
 vco 1000, pll 125 MHz 
 vco 800, pll 400 MHz 
 vco 1000, pll 500 MHz 
 vco 1328, pll 664 MHz 
 vco 1600, pll 800 MHz 
 vco 1, pll 1 GHz 
 vco 1200, pll 1200 MHz 
 vco-pll4 rate configuration table, in ascending order of rates 
 vco 1000, pll 250 MHz 
 vco 1328, pll 332 MHz 
 vco 1600, pll 400 MHz 
 vco 1, pll 1 GHz 
  All below entries generate 166 MHz for
  different values of vco1div2
 for vco1div2 = 600 MHz 
 for vco1div2 = 500 MHz 
 for vco1div2 = 400 MHz 
 for vco1div2 = 332 MHz 
 for vco1div2 = 250 MHz 
 for vco1div2 = 200 MHz 
  Synthesizer Clock derived from vcodiv2. This clock is one of the
  possible clocks to feed cpu directly.
  We can program this synthesizer to make cpu run on different clock
  frequencies.
  Following table provides configuration values to let cpu run on 200,
  250, 332, 400 or 500 MHz considering different possibilites of input
  (vco1div2) clock.
  --------------------------------------------------------------------
  vco1div2(Mhz)	fout(Mhz)	cpuclk = fout2		div
  --------------------------------------------------------------------
  400			200		100			0x04000
  400			250		125			0x03333
  400			332		166			0x0268D
  400			400		200			0x02000
  --------------------------------------------------------------------
  500			200		100			0x05000
  500			250		125			0x04000
  500			332		166			0x03031
  500			400		200			0x02800
  500			500		250			0x02000
  --------------------------------------------------------------------
  600			200		100			0x06000
  600			250		125			0x04CCE
  600			332		166			0x039D5
  600			400		200			0x03000
  600			500		250			0x02666
  --------------------------------------------------------------------
  664			200		100			0x06a38
  664			250		125			0x054FD
  664			332		166			0x04000
  664			400		200			0x0351E
  664			500		250			0x02A7E
  --------------------------------------------------------------------
  800			200		100			0x08000
  800			250		125			0x06666
  800			332		166			0x04D18
  800			400		200			0x04000
  800			500		250			0x03333
  --------------------------------------------------------------------
  sys rate configuration table is in descending order of divisor.
 aux rate configuration table, in ascending order of rates 
 12.29MHz for vic1div2=600MHz and 10.24MHz for VCO1div2=500MHz 
 14.70MHz for vic1div2=600MHz and 12.29MHz for VCO1div2=500MHz 
 48MHz for vic1div2=600MHz and 40 MHz for VCO1div2=500MHz 
 57.14MHz for vic1div2=600MHz and 48 MHz for VCO1div2=500MHz 
 83.33MHz for vic1div2=600MHz and 69.44MHz for VCO1div2=500MHz 
 100MHz for vic1div2=600MHz and 83.33 MHz for VCO1div2=500MHz 
 125MHz for vic1div2=600MHz and 104.1MHz for VCO1div2=500MHz 
 150MHz for vic1div2=600MHz and 125MHz for VCO1div2=500MHz 
 166MHz for vic1div2=600MHz and 138.88MHz for VCO1div2=500MHz 
 200MHz for vic1div2=600MHz and 166MHz for VCO1div2=500MHz 
 250MHz for vic1div2=600MHz and 208.33MHz for VCO1div2=500MHz 
 300MHz for vic1div2=600MHz and 250MHz for VCO1div2=500MHz 
 gmac rate configuration table, in ascending order of rates 
 For gmac phy input clk 
 divided by 6 
 divided by 4 
 divided by 3 
 divided by 2 
 clcd rate configuration table, in ascending order of rates 
 25 Mhz , for vc01div4 = 300 MHz
 27 Mhz , for vc01div4 = 300 MHz
 25 Mhz , for vc01div4 = 250 MHz
 27 Mhz , for vc01div4 = 250 MHz
 58 Mhz , for vco1div4 = 393 MHz 
 58 Mhz , for vco1div4 = 332 MHz 
 58 Mhz , for vco1div4 = 300 MHz 
 65 Mhz , for vc01div4 = 300 MHz
 58 Mhz , for vc01div4 = 250 MHz
 74 Mhz , for vc01div4 = 300 MHz
 65 Mhz , for vc01div4 = 250 MHz
 72 Mhz , for vc01div4 = 250 MHz
 58 Mhz , for vco1div4 = 200 MHz 
 74 Mhz , for vc01div4 = 250 MHz
 108 Mhz , for vc01div4 = 300 MHz
 108 Mhz , for vc01div4 = 250 MHz
 148.5 Mhz , for vc01div4 = 300 MHz
 144 Mhz , for vc01div4 = 250 MHz
 148 Mhz , for vc01div4 = 250 MHz
 148.5 MHz, for vc01div4 = 250 MHz
 i2s prescaler1 masks 
 i2s sclk (bit clock) syynthesizers masks 
 i2s prs1 aux rate configuration table, in ascending order of rates 
 For parent clk = 49.152 MHz 
 2.048 MHz, smp freq = 8Khz 
 2.816 MHz, smp freq = 11Khz 
 4.096 MHz, smp freq = 16Khz 
 5.632 MHz, smp freq = 22Khz 
	
	  with parent clk = 49.152, freq gen is 8.192 MHz, smp freq = 32Khz
	  with parent clk = 12.288, freq gen is 2.048 MHz, smp freq = 8Khz
 For parent clk = 49.152 MHz 
 11.289 MHz, smp freq = 44Khz
 12.288 MHz, smp freq = 48Khz
 i2s sclk aux rate configuration table, in ascending order of rates 
 For sclk = ref_clk  x2y 
 adc rate configuration table, in ascending order of rates 
 possible adc range is 2.5 MHz to 20 MHz. 
 For ahb = 166.67 MHz 
 2.68 MHz 
 7.94 MHz 
 15.87 MHz 
 19.84 MHz 
 General synth rate configuration table, in ascending order of rates 
 22.5792 MHz for vco1div4=300 MHz
 24.576 MHz for vco1div4=300 MHz
 25 MHz for vco1div4=300 MHz
 22.5792 MHz for vco1div4=250 MHz
 24.576 MHz for vco1div4=250 MHz
 25 MHz for vco1div4=250 MHz
 45.1584 MHz for vco1div4=300 MHz
 50 MHz for vco1div4=300 MHz
 45.1584 MHz for vco1div4=250 MHz
 50 MHz for vco1div4=250 MHz
 81.92 MHz for vco1div4=300 MHz
 81.92 MHz for vco1div4=250 MHz
 100 MHz for vco1div4=300 MHz
 100 MHz for vco1div4=250 MHz
 200 MHz for vco1div4=300 MHz
 210 MHz for vco1div4=300 MHz
 220 MHz for vco1div4=300 MHz
 230 MHz for vco1div4=300 MHz
 200 MHz for vco1div4=250 MHz
 250 MHz for vco1div4=300 MHz
 210 MHz for vco1div4=250 MHz
 220 MHz for vco1div4=250 MHz
 230 MHz for vco1div4=250 MHz
 240 MHz for vco1div4=250 MHz
 250 MHz for vco1div4=250 MHz
 clock parents 
 clock derived from 32 KHz osc clk 
 clock derived from 24 or 25 MHz osc clk 
 vco-pll 
 vco div n clocks 
 peripherals 
 clock derived from pll4 clk 
 clock derived from pll1 clk 
 gpt clocks 
 others 
 gmac 
 clcd 
 i2s 
 clock derived from ahb clk 
 clock derived from apb clk 
 RAS clks 
  SPEAr3xx machines clock framework source file
  Copyright (C) 2012 ST Microelectronics
  Viresh Kumar <vireshk@kernel.org>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 PLL_CLK_CFG register masks 
 CORE CLK CFG register masks 
 PERIP_CLK_CFG register masks 
 PERIP1_CLK_ENB register masks 
 pll rate configuration table, in ascending order of rates 
 vco 332 & pll 166 MHz 
 vco 532 & pll 266 MHz 
 vco 664 & pll 332 MHz 
 aux rate configuration table, in ascending order of rates 
 For PLL1 = 332 MHz 
 2.049 MHz 
 2.822 MHz 
 4.098 MHz 
 5.644 MHz 
 8.197 MHz 
 11.254 MHz 
 12.296 MHz 
 41.5 MHz 
 83 MHz 
 166 MHz 
 gpt rate configuration table, in ascending order of rates 
 For pll1 = 332 MHz 
 41.5 MHz 
 55.3 MHz 
 83 MHz 
 clock parents 
 array of all spear 310 clock lookups 
 array of all spear 320 clock lookups 
 Enforce ras_apb_clk 
 Enforce ras_apb_clk 
 clock derived from 32 KHz osc clk 
 clock derived from 24 MHz osc clk 
 clock derived from pll1 clk 
 gpt clocks 
 general synths clocks 
 clock derived from pll3 clk 
 clock derived from ahb clk 
 clock derived from apb clk 
 RAS clk enable 
  archarmmach-spear13xxspear1310_clock.c
  SPEAr1310 machine clock framework source file
  Copyright (C) 2012 ST Microelectronics
  Viresh Kumar <vireshk@kernel.org>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 PLL related registers and bit values 
 PLL_CFG bit values 
 PERIP_CLK_CFG bit values 
 I2S_CLK_CFG register mask 
 Check Fractional synthesizer reg masks 
 PERIP1_CLK_ENB register masks 
 PERIP2_CLK_ENB register masks 
 RAS_CLK_ENB register masks 
 RAS Area Control Register 
 pll rate configuration table, in ascending order of rates 
 PCLK 24MHz 
 vco 1572, pll 49.125 MHz 
 vco 1000, pll 125 MHz 
 vco 800, pll 400 MHz 
 vco 1000, pll 500 MHz 
 vco 1328, pll 664 MHz 
 vco 1600, pll 800 MHz 
 vco 1, pll 1 GHz 
 vco-pll4 rate configuration table, in ascending order of rates 
 vco 1000, pll 250 MHz 
 vco 1328, pll 332 MHz 
 vco 1600, pll 400 MHz 
 vco 1, pll 1 GHz 
 aux rate configuration table, in ascending order of rates 
 For VCO1div2 = 500 MHz 
 12.29 MHz 
 48 MHz 
 83 MHz 
 125 MHz 
 166 MHz 
 250 MHz 
 gmac rate configuration table, in ascending order of rates 
 For gmac phy input clk 
 divided by 6 
 divided by 4 
 divided by 3 
 divided by 2 
 clcd rate configuration table, in ascending order of rates 
 25 Mhz , for vc01div4 = 250 MHz
 27 Mhz , for vc01div4 = 250 MHz
 58 Mhz , for vco1div4 = 393 MHz 
 58 Mhz , for vco1div4 = 332 MHz 
 58 Mhz , for vc01div4 = 250 MHz
 72 Mhz , for vc01div4 = 250 MHz
 58 Mhz , for vco1div4 = 200 MHz 
 74 Mhz , for vc01div4 = 250 MHz
 108 Mhz , for vc01div4 = 250 MHz
 144 Mhz , for vc01div4 = 250 MHz
 i2s prescaler1 masks 
 i2s sclk (bit clock) syynthesizers masks 
 i2s prs1 aux rate configuration table, in ascending order of rates 
 For parent clk = 49.152 MHz 
 2.048 MHz, smp freq = 8Khz 
 2.816 MHz, smp freq = 11Khz 
 4.096 MHz, smp freq = 16Khz 
 5.632 MHz, smp freq = 22Khz 
	
	  with parent clk = 49.152, freq gen is 8.192 MHz, smp freq = 32Khz
	  with parent clk = 12.288, freq gen is 2.048 MHz, smp freq = 8Khz
 For parent clk = 49.152 MHz 
 11.289 MHz, smp freq = 44Khz
 12.288 MHz 
 i2s sclk aux rate configuration table, in ascending order of rates 
 For i2s_ref_clk = 12.288MHz 
 1.53 MHz 
 3.07 Mhz 
 adc rate configuration table, in ascending order of rates 
 possible adc range is 2.5 MHz to 20 MHz. 
 For ahb = 166.67 MHz 
 2.68 MHz 
 7.94 MHz 
 15.87 MHz 
 19.84 MHz 
 General synth rate configuration table, in ascending order of rates 
 For vco1div4 = 250 MHz 
 25 MHz 
 50 MHz 
 100 MHz 
 250 MHz 
 clock parents 
 clock derived from 32 KHz osc clk 
 clock derived from 24 or 25 MHz osc clk 
 vco-pll 
 vco div n clocks 
 peripherals 
 clock derived from pll4 clk 
 clock derived from pll1 clk 
 gpt clocks 
 others 
 gmac 
 clcd 
 i2s 
 clock derived from ahb clk 
 clock derived from apb clk 
 RAS clks 
  Copyright (C) 2012 ST Microelectronics
  Viresh Kumar <vireshk@kernel.org>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  VCO-PLL clock implementation
  DOC: VCO-PLL clock
  VCO and PLL rate are derived from following equations:
  In normal mode
  vco = (2  M[15:8]  Fin)N
  In Dithered mode
  vco = (2  M[15:0]  Fin)(256  N)
  pll_rate = pll2^p
  vco and pll are very closely bound to each other, "vco needs to program:
  mode, m & n" and "pll needs to program p", both share common enabledisable
  logic.
  clk_register_vco_pll() registers instances of both vco & pll.
  CLK_SET_RATE_PARENT flag is forced for pll, as it will always pass its
  set_rate to vco. A single rate table exists for both the clocks, which
  configures m, n and p.
 PLL_CTR register masks 
 PLL FRQ register masks 
 Calculates pll clk rate for specific value of mode, m, n and p 
 previous clock was best 
 calculate numerator & denominator 
 Normal mode 
 Dithered mode 
 Configures new clock rate of vco 
 struct clk_vco assignments 
  Copyright (C) 2012 ST Microelectronics
  Viresh Kumar <vireshk@kernel.org>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  Auxiliary Synthesizer clock implementation
  DOC: Auxiliary Synthesizer clock
  Aux synth gives rate for different values of eq, x and y
  Fout from synthesizer can be given from two equations:
  Fout1 = (Fin  XY)2		EQ1
  Fout2 = Fin  XY			EQ2
 calculate numerator 
 calculate denominator 
 Configures new clock rate of aux 
 struct clk_aux assignments 
  Copyright (C) 2012 ST Microelectronics
  Viresh Kumar <vireshk@kernel.org>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  General Purpose Timer Synthesizer clock implementation
  DOC: General Purpose Timer Synthesizer clock
  Calculates gpt synth clk rate for different values of mscale and nscale
  Fout= Fin((2 ^ (N+1))  (M+1))
 Configures new clock rate of gpt 
 struct clk_gpt assignments 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2012 ARM Limited
 SPDX-License-Identifier: GPL-2.0-only
  Clock driver for the ARM IntegratorAP, IntegratorCP, Versatile AB and
  Versatile PB boards.
  Copyright (C) 2012 Linus Walleij
 Base offset for the core module 
 Remap the core module base if not done yet 
 SPDX-License-Identifier: GPL-2.0-only
  Driver for the ICST307 VCO clock found in the ARM Reference designs.
  We wrap the custom interface from <asmhardwareicst.h> into the generic
  clock framework.
  Copyright (C) 2012-2015 Linus Walleij
  TODO: when all ARM reference designs are migrated to generic clocks, the
  ICST clock code from the ARM tree should probably be merged into this
  file.
 Magic unlocking token used on all Versatile boards 
  struct clk_icst - ICST VCO clock wrapper
  @hw: corresponding clock hardware entry
  @map: register map
  @vcoreg_off: VCO register address
  @lockreg_off: VCO lock register address
  @params: parameters for this ICST instance
  @rate: current rate
  @ctype: the type of control register for the ICST
  vco_get() - get ICST VCO settings from a certain ICST
  @icst: the ICST clock to get
  @vco: the VCO struct to return the value in
	
	  The IntegratorAP core clock can only access the low eight
	  bits of the v PLL divider. Bit 8 is tied low and always zero,
	  r is hardwired to 22 and output divider s is hardwired to 1
	  (divide by 2) according to the document
	  "Integrator CM926EJ-S, CM946E-S, CM966E-S, CM1026EJ-S and
	  CM1136JF-S User Guide" ARM DUI 0138E, page 3-13 thru 3-14.
	
	  The IntegratorAP system clock on the base board can only
	  access the low eight bits of the v PLL divider. Bit 8 is tied low
	  and always zero, r is hardwired to 46, and the output divider is
	  hardwired to 3 (divide by 4) according to the document
	  "Integrator AP ASIC Development Motherboard" ARM DUI 0098B,
	  page 3-16.
	
	  The IntegratorAP PCI clock is using an odd pattern to create
	  the child clock, basically a single bit called DIVXY is used
	  to select between two different hardwired values: setting the
	  bit to 0 yields v = 17, r = 22 and OD = 1, whereas setting the
	  bit to 1 yields v = 14, r = 14 and OD = 1 giving the frequencies
	  33 or 25 MHz respectively.
	
	  The IntegratorCP core clock can access the low eight bits
	  of the v PLL divider. Bit 8 is tied low and always zero,
	  r is hardwired to 22 and the output divider s is accessible
	  in bits 8 thru 10 according to the document
	  "IntegratorCM940T, CM920T, CM740T, and CM720T User Guide"
	  ARM DUI 0157A, page 3-20 thru 3-23 and 4-10.
  vco_set() - commit changes to an ICST VCO
  @icst: the ICST clock to set
  @vco: the VCO struct to set the changes from
 Mask the bits used by the VCO 
 Uses 12 bits 
 Uses 12 bits 
 Regular auxilary oscillator 
 This magic unlocks the VCO so it can be controlled 
 This locks the VCO again 
 Slam to closest megahertz 
 Slam to closest 0.5 megahertz 
 Divides between 3 and 50 MHz in steps of 0.25 MHz 
 Slam to closest 0.25 MHz 
		
		  If we're below or less than halfway from 25 to 33 MHz
		  select 25 MHz
 Else just return the default frequency 
 This clock is especially primitive 
 This locks the VCO again 
  In a device tree, an memory-mapped ICST clock appear as a child
  of a syscon node. Assume this and probe it only as a child of a
  syscon.
  The core modules on the IntegratorAP and IntegratorCP have
  especially crippled ICST525 control.
 Minimum 12 MHz, VDW = 4 
	
	  Maximum 160 MHz, VDW = 152 for all core modules, but
	  CM926EJ-S, CM1026EJ-S and CM1136JF-S can actually
	  go to 200 MHz (max VDW = 192).
 r is hardcoded to 22 and this is the actual divisor, +2 
 Minimum 3 MHz, VDW = 4 
 Maximum 50 MHz, VDW = 192 
 r is hardcoded to 46 and this is the actual divisor, +2 
 Minimum 25 MHz 
 Maximum 33 MHz 
 r is hardcoded to 14 or 22 and this is the actual divisors +2 
 We do not release this reference, we are using it perpetually 
 Parent clock name is not the same as node parent 
 SPDX-License-Identifier: GPL-2.0-only
   linuxarcharmcommonicst307.c
   Copyright (C) 2003 Deep Blue Solutions, Ltd, All Rights Reserved.
   Support functions for calculating clocksdivisors for the ICST307
   clock generators.  See https:www.idt.com for more information
   on these devices.
   This is an almost identical implementation to the ICST525 clock generator.
   The s2div and idx2s files are different
  Divisors for each OD setting.
  Ascending divisor S values.
	
	  First, find the PLL output divisor such
	  that the PLL output is within spec.
	
	  Now find the closest divisor combination
	  which gives a PLL output of 'f'.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2013 ARM Limited
		
		  If DT isn't setting the parent, force it to be
		  the 1 MHz clock without going through the framework.
		  We do this before clk_register() so that it can determine
		  the parent and setup the tree properly.
 SPDX-License-Identifier: GPL-2.0-only
  Clock driver for the ARM IntegratorIM-PD1 board
  Copyright (C) 2012-2013 Linus Walleij
  There are two VCO's on the IM-PD1
 24 MHz 
 24 MHz 
 SPDX-License-Identifier: GPL-2.0-only
  abx500 clock implementation for ux500 platform.
  Copyright (C) 2012 ST-Ericsson SA
  Author: Ulf Hansson <ulf.hansson@linaro.org>
 Clock definitions for ab8500 
 Enable SWAT 
 ab8500_sysclk2 
 ab8500_sysclk3 
 ab8500_sysclk4 
 ab_ulpclk 
 ab8500_intclk 
 ab8500_audioclk 
 SPDX-License-Identifier: GPL-2.0-only
  PRCMU clock implementation for ux500 platform.
  Copyright (C) 2012 ST-Ericsson SA
  Author: Ulf Hansson <ulf.hansson@linaro.org>
 PRCMU clock operations. 
 "rate" can be used for changing the initial frequency 
 SPDX-License-Identifier: GPL-2.0-only
  Clock definitions for u8500 platform.
  Copyright (C) 2012 ST-Ericsson SA
  Author: Ulf Hansson <ulf.hansson@linaro.org>
	
	  We allocate the reset controller here so that we can fill in the
	  base addresses properly and pass to the reset controller init
	  function later on.
 Not much choice but to continue 
 Clock sources 
 FIXME: Add sys, ulp and int clocks here. 
 PRCMU clocks 
	
	  FIXME: Add special handled PRCMU clocks here:
	  1. clkout0yuv, use PRCMU as parent + need regulator + pinctrl.
	  2. ab9540_clkout1yuv, see clkout0yuv
 PRCC P-clocks 
	 PRCC K-clocks
	 
	  FIXME: Some drivers requires PERPIH[n| to be automatically enabled
	  by enabling just the K-clock, even if it is not a valid parent to
	  the K-clock. Until drivers get fixed we might need some kind of
	  "parent muxed join".
 Periph1 
 Periph2 
 Note that rate is received from parent. 
 Periph3 
 Periph6 
 SPDX-License-Identifier: GPL-2.0-only
  Sysctrl clock implementation for ux500 platform.
  Copyright (C) 2013 ST-Ericsson SA
  Author: Ulf Hansson <ulf.hansson@linaro.org>
 Sysctrl clock operations. 
 set main clock registers 
 handle clocks with more than one parent 
 SPDX-License-Identifier: GPL-2.0-only
  PRCC clock implementation for ux500 platform.
  Copyright (C) 2012 ST-Ericsson SA
  Author: Ulf Hansson <ulf.hansson@linaro.org>
 PRCC clock operations. 
 SPDX-License-Identifier: GPL-2.0-only
  Reset controller portions for the U8500 PRCC
  Copyright (C) 2021 Linus Walleij <linus.walleij@linaro.org>
 This macro flattens the 2-dimensional PRCC numberspace 
  Reset registers in each PRCC - the reset lines are active low
  so what you need to do is write a bit for the peripheral you
  want to put into reset into the CLEAR register, this will assert
  the reset by pulling the line low. SET take the device out of
  reset. The status reflects the actual state of the line.
	
	  Assert reset and then release it. The one microsecond
	  delay is found in the vendor reference code.
 Active low so return the inverse value of the bit 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
 Data in .init is copied by clk_register(), so stack variable OK 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, 2013, NVIDIA CORPORATION.  All rights reserved.
 PLLA_OUT0 
 make sure the DMIC sync clocks have a valid parent 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015, NVIDIA CORPORATION.  All rights reserved.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
 Global data of Tegra CPU CAR ops 
 Handlers for SoC-specific reset lines 
	
	  If peripheral is on the APB bus then we must read the APB bus to
	  flush the write operation in apb bus. This will avoid peripheral
	  access after disabling clock. Since the reset driver has no
	  knowledge of which reset IDs represent which devices, simply do
	  this all the time.
	
	  All non-boot peripherals will be in reset state on resume.
	  Wait for 5us of reset propagation delay before de-asserting
	  the peripherals based on the saved context.
 SPDX-License-Identifier: GPL-2.0-only
  Based on clk-super.c
  Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
  Based on older tegra20-cpufreq driver by Colin Cross <ccross@google.com>
  Copyright (C) 2010 Google, Inc.
  Author: Dmitry Osipenko <digetx@gmail.com>
  Copyright (C) 2019 GRATE-DRIVER project
 check whether thermal throttling is active 
	
	  Switch parent to PLLP for all CCLK rates that are suitable for PLLP.
	  PLLX will be disabled in this case, saving some power.
	
	  Tegra30+ has the following CPUG clock topology:
	 
	         +---+  +-------+  +-+            +-+                +-+
	  PLLP+->+   +->+DIVIDER+->+0|  +-------->+0|  ------------->+0|
	         |   |  +-------+  | |  |  +---+  | |  |             | |
	  PLLC+->+MUX|             | +->+  | S |  | +->+             | +->+CPU
	   ...   |   |             | |  |  | K |  | |  |  +-------+  | |
	  PLLX+->+-->+------------>+1|  +->+ I +->+1|  +->+ DIV2  +->+1|
	         +---+             +++     | P |  +++     |SKIPPER|  +++
	                            ^      | P |   ^      +-------+   ^
	                            |      | E |   |                  |
	                 PLLX_SEL+--+      | R |   |       OVERHEAT+--+
	                                   +---+   |
	                                           |
	                          SUPER_CDIV_ENB+--+
	 
	  Tegra20 is similar, but simpler. It doesn't have the divider and
	  thermal DIV2 skipper.
	 
	  At least for now we're not going to use clock-skipper, hence let's
	  ensure that it is disabled.
	
	  CPU needs to be temporarily re-parented away from PLLX if PLLX
	  changes its rate. PLLP is a safe parent for CPU on all Tegra SoCs.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, 2013, NVIDIA CORPORATION.  All rights reserved.
 SOR1 mux'es 
 PLLP 
		
		  Tegra210 has control on enablingdisabling PLLP branches to
		  CPU, register a gate clock "pll_p_out_cpu" for this gating
		  function and parent "pll_p_out4" to it, so when we are
		  re-parenting CPU off from "pll_p_out4" the PLLP branching to
		  CPU can be disabled automatically.
 PLLP_OUT_HSIO 
 PLLP_OUT_XUSB 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2015-2020, NVIDIA CORPORATION.  All rights reserved.
	
	  CCF assumes that neither the parent nor its rate will change during
	  ->set_rate(), so the parent rate passed in here was cached from the
	  parent before the ->set_rate() call.
	 
	  This can lead to wrong results being reported for the EMC clock if
	  the parent andor parent rate have changed as part of the EMC rate
	  change sequence. Fix this by overriding the parent clock with what
	  we know to be the correct value after the rate change.
 XXX implement cache? 
 if the rate has changed... 
 ... but the clock source remains the same ... 
 ... switch to the alternative clock source. 
			
			  This should never happen because we can't deal with
			  it.
 set the new parent clock to the required rate 
 enable the new parent clock 
 update the EMC source configuration to reflect the new parent 
	
	  Finally, switch the EMC programming with both old and new parent
	  clocks enabled.
		
		  If we're unable to switch to the new EMC frequency, we no
		  longer need the new parent to be enabled.
 reparent to new parent clock and disable the old parent clock 
 do basic sanity checking on the EMC timings 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
 Tegra CPU clock and reset control regs 
 1 GHz 
 912 MHz 
 816 MHz 
 760 MHz 
 750 MHz 
 608 MHz 
 456 MHz 
 312 MHz 
 PLL parameters 
 PLLC 
 PLLC_OUT1 
 PLLM 
 PLLM_OUT1 
 PLLX 
 PLLU 
 PLLD 
 PLLD_OUT0 
 PLLA 
 PLLA_OUT0 
 PLLE 
 CCLK 
 SCLK 
 twd 
 audio 
 audio_2x 
 ac97 
 emc 
 dsi 
 pex 
 dev1 OSC divider 
 dev2 OSC divider 
 cdev1 
 cdev2 
 clk_m 
 pll_ref 
 Tegra20 CPU clock and reset control functions 
 check CPU been reset or not 
 switch coresite to clk_m, save off original source 
 Is CPU complex already running on PLLX? 
 restore PLLX settings if CPU is on different PLL 
 wait for PLL stabilization if PLLX was enabled 
	
	  Restore original burst policy setting for calls resulting from CPU
	  LP2 in idle or system suspend.
 must be the last entry 
  Some clocks may be used by different drivers depending on the board
  configuration.  List those here to register them twice in the clock lookup
  table under two names.
 must be the last entry 
	
	  Tegra20 CDEV1 and CDEV2 clocks are a bit special case, their parent
	  clock is created by the pinctrl driver. It is possible for clk user
	  to request these clocks before pinctrl driver got probed and hence
	  user will get an orphaned clock. That might be undesirable because
	  user may expect parent clock to be enabled by the child.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
 Data in .init is copied by clk_register(), so stack variable OK 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
 Data in .init is copied by clk_register(), so stack variable OK 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2016-2020 NVIDIA Corporation
	
	  The mrq_clk_request structure has an anonymous union at offset 4
	  that contains all possible sub-command structures. Copy the data
	  to that union. Ideally we'd be able to refer to it by name, but
	  doing so would require changing the ABI header and increase the
	  maintenance burden.
 XXX check parent ID in response 
 clock not exposed by BPMP 
 hardware clock initialization 
 keep a private copy of the ID to parent index map 
 SPDX-License-Identifier: GPL-2.0-only
  driversclktegraclk-emc.c
  Copyright (c) 2014, NVIDIA CORPORATION.  All rights reserved.
  Author:
 	Mikko Perttunen <mperttunen@nvidia.com>
  List of clock sources for various parents the EMC clock can have.
  When we change the timing to a timing with a parent that has the same
  clock source as the current parent, we must first change to a backup
  timing that has a different clock source.
 Common clock framework callback implementations 
	
	  CCF wrongly assumes that the parent won't change during set_rate,
	  so get the parent rate explicitly.
  Rounds up unless no higher rate exists, in which case down. This way is
  safer since things have EMC rate floors. Also don't touch parent_rate
  since we don't want the CCF to play with our parent clocks.
  Get backup timing to use as an intermediate step when a change between
  two timings with the same clock source has been requested. First try to
  find a timing with a higher clock rate to avoid a rate below any set rate
  floors. If that is not possible, find a lower rate.
	
	  When emc_set_timing changes the parent rate, CCF will propagate
	  that downward to us, so ignore any set_rate calls while a rate
	  change is already going on.
		
		  Parent clock source not changed but parent rate has changed,
		  need to temporarily switch to another parent
 Initialization and deinitialization 
		
		  Store timings for all ram codes as we cannot read the
		  fuses until the apbmisc driver is loaded.
 Allow debugging tools to see the EMC clock 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012-2020 NVIDIA CORPORATION.  All rights reserved.
  TEGRA210_CAR_BANK_COUNT: the number of peripheral clock register
  banks present in the Tegra210 CAR IP block.  The banks are
  identified by single letters, e.g.: L, H, U, V, W, X, Y.  See
  periph_regs[] in driversclktegraclk.c
 I2S registers to handle during APE MBIST WAR 
 DISPA registers to handle during MBIST WAR 
 VIC register to handle during MBIST WAR 
 APE, DISPA and VIC base addesses needed for MBIST WAR 
  SDM fractional divisor is 16-bit 2's complement signed number within
  (-2^12 ... 2^12-1) range. Represented in PLL data structure as unsigned
  16-bit value, with "0" divisor mapped to 0xFFFF. Data "0" is used to
  indicate that SDM is disabled.
  Effective ndiv value when SDM is enabled: ndiv + 12 + sdm_din2^13
 This macro returns ndiv effective scaled to SDM range 
 Tegra CPU clock and reset control regs 
 possible OSC frequencies in Hz 
 PLLA 
 PLLD 
 PLLD2 and PLLDP  and PLLC4 
 PLLRE 
 PLLE 
 PLLX 
 PLLMB 
 PLLP 
 PLLU 
 skip if PLLE is not enabled yet 
  PLLCX: PLLC, PLLC2, PLLC3, PLLA1
  Hybrid PLLs with dynamic ramp. Dynamic ramp is allowed for any transition
  that changes NDIV only, while PLL is already locked.
 PLL is ON: only check if defaults already set 
 Defaults assert PLL reset, and set IDDQ 
  PLLA
  PLL with dynamic ramp and fractional SDM. Dynamic ramp is not used.
  Fractional SDM is allowed to provide exact audio rates.
		
		  PLL is ON: check if defaults already set, then set those
		  that can be updated in flight.
 ignore lock enable 
 ignore all but control bit 
 Enable lock detect 
 set IDDQ, enable lock detect, disable dynamic ramp and SDM 
  PLLD
  PLL with fractional SDM.
		
		  PLL is ON: check if defaults already set, then set those
		  that can be updated in flight.
 ignore lock, DSI and SDM controls, make sure IDDQ not set 
 Enable lock detect 
 set IDDQ, enable lock detect, disable SDM 
  PLLD2, PLLDP
  PLL with fractional SDM and Spread Spectrum (SDM is a must if SSC is used).
		
		  PLL is ON: check if defaults already set, then set those
		  that can be updated in flight.
 ignore lock enable 
		
		  If SSC is used, check all settings, otherwise just confirm
		  that SSC is not used on boot as well. Do nothing when using
		  this function for PLLC4 that has only MISC0.
 Enable lock detect 
 set IDDQ, enable lock detect, configure SDMSSC  
 When using this function for PLLC4 exit here 
 if SSC used set by 1st enable 
  PLLC4
  Base and misc0 layout is the same as PLLD2PLLDP, but no SDMSSC support.
  VCO is exposed to the clock tree via fixed 13 and 15 dividers.
  PLLRE
  VCO is exposed to the clock tree directly along with post-divider output
		
		  PLL is ON: check if defaults already set, then set those
		  that can be updated in flight.
 Ignore lock enable 
 The PLL doesn't work if it's in IDDQ. 
 Enable lock detect 
 set IDDQ, enable lock detect 
 cf rate 
 ignore lock enable 
 ignore all but control bit 
 Get ready dyn ramp state machine settings 
		
		  PLL is ON: check if defaults already set, then set those
		  that can be updated in flight.
 Configure dyn ramp, disable lock override 
 Enable lock detect 
 Enable lock detect and CPU output 
 Setup 
 Configure dyn ramp state machine, disable lock override 
 Set IDDQ 
 Disable SDM 
 PLLMB 
		
		  PLL is ON: check if defaults already set, then set those
		  that can be updated in flight.
 Enable lock detect 
 set IDDQ, enable lock detect 
  PLLP
  VCO is exposed to the clock tree directly along with post-divider output.
  Both VCO and post-divider output rates are fixed at 408MHz and 204MHz,
  respectively.
 Ignore lock enable (will be set), make sure not in IDDQ if enabled 
 Ignore branch controls 
		
		  PLL is ON: check if defaults already set, then set those
		  that can be updated in flight.
 Enable lock detect 
 set IDDQ, enable lock detect 
 Preserve branch control 
  PLLU
  VCO is exposed to the clock tree directly along with post-divider output.
  Both VCO and post-divider output rates are fixed at 480MHz and 240MHz,
  respectively.
 Ignore lock enable (will be set) and IDDQ if under hw control 
		
		  PLL is ON: check if defaults already set, then set those
		  that can be updated in flight.
 Enable lock detect 
 set IDDQ, enable lock detect 
 Lock detection safety delays 
  Common configuration for PLLs with fixed input divider policy:
  - always set fixed M-value based on the reference rate
  - always set P-value value 1:1 for output rates above VCO minimum, and
    choose minimum necessary P-value for output rates below VCO maximum
  - calculate N-value based on selected M and P
  - calculate SDM_DIN fractional part
 Store P as HW value, as that is what is expected 
 If ssc is enabled SDM enabled as well, even for integer n 
  clk_pll_set_gain - set gain to m, n to calculate correct VCO rate
  @cfg: struct tegra_clk_pll_freq_table  cfg
  For Normal mode:
      Fvco = Fref  NDIV  MDIV
  For fractional mode:
      Fvco = Fref  (NDIV + 0.5 + SDM_DIN  PLL_SDM_COEFF)  MDIV
  PLL post divider maps - two types: quasi-linear and exponential
  post divider.
 1 GHz 
 actual: 996.0 MHz 
 actual: 994.0 MHz 
 actual: 998.4 MHz 
 actual: 507.0 MHz 
 actual: 505.6 MHz 
 actual: 598.0 MHz 
 actual: 595.2 MHz 
 actual: 792.0 MHz 
 actual: 793.0 MHz 
 PLLE special case: use cpcon field to store cml divider value 
 actual: 663.0 MHz 
 cf = 4.8MHz, allowed exception 
 actual: 282240234 
 actual: 368640381 
 actual: 282239807 
 actual: 368640137 
 actual: 238.3 MHz 
 actual: 282239844 
 actual: 368639844 
 actual: 594000183 
 actual: 594000183 
 sw policy, always tegra_pll_ref 
 disable spread-spectrum for pll_d2 
 actual: 269.8 MHz 
 actual: 468.0 MHz 
 Oscillator Frequency in KHz 
 UTMIP PLL Enable Delay Count  
 UTMIP PLL Stable count 
  UTMIP PLL Active delay count 
 UTMIP PLL Xtal frequency count 
 Program UTMIP PLL stable and active counts 
 [FIXME] arclk_rst.h says WRONG! This should be 1ms -> 0x50 Check! 
 Program UTMIP PLL delay and oscillator frequency counts 
 Remove power downs from UTMIP PLL control bits 
 Enable samplers for SNPS, XUSB_HOST, XUSB_DEV 
 Setup HW control of UTMIPLL 
 Enable HW control UTMIPLL 
 clear IDDQ bit 
	
	  During clocks resume, same PLLU init and enable sequence get
	  executed. So, readx_poll_timeout_atomic can't be used here as it
	  uses ktime_get() and timekeeping resume doesn't happen by that
	  time. So, using tegra210_wait_for_mask for PLL LOCK.
 skip initialization when pllu is in hw controlled mode 
 enable hw controlled mode 
 enable UTMIPLL hw control if not yet done by the bootloader 
  The SOR hardware blocks are driven by two clocks: a module clock that is
  used to access registers and a pixel clock that is sourced from the same
  pixel clock that also drives the head attached to the SOR. The module
  clock is typically called sorX (with X being the SOR instance) and the
  pixel clock is called sorX_out. The source for the SOR pixel clock is
  referred to as the "parent" clock.
  On Tegra186 and newer, clocks are provided by the BPMP. Unfortunately the
  BPMP implementation for the SOR clocks doesn't exactly match the above in
  some aspects. For example, the SOR module is really clocked by the pad or
  sor_safe clocks, but BPMP models the sorX clock as being sourced by the
  pixel clocks. Conversely the sorX_out clock is sourced by the sor_safe or
  pad clocks on BPMP.
  In order to allow the display driver to deal with all SoC generations in
  a unified way, implement the BPMP semantics in this driver.
	
	  Bit 0 of the mux selects sor1_pad_clkout, irrespective of bit 1, so
	  the sor1_pad_clkout parent appears twice in the list below. This is
	  merely to support clk_get_parent() if firmware happened to set
	  these bits to 0b11. While not an invalid setting, code should
	  always set the bits to 0b01 to select sor1_pad_clkout.
	
	  On Tegra210, the sor0 clock doesn't have a mux it bitfield 31:29,
	  but it is hardwired to the pll_d_out0 clock.
 xusb_ss_div2 
 pll_d_dsi_out 
 dsia 
 dsib 
 csi_tpg 
 la 
 cml0 
 cml1 
 emc 
 mc 
 PLLC 
 PLLC_OUT1 
 PLLC_UD 
 PLLC2 
 PLLC3 
 PLLM 
 PLLMB 
 PLLM_UD 
 PLLMB_UD 
 PLLP_UD 
 PLLU_VCO 
 PLLU_OUT 
 PLLU_OUT1 
 PLLU_OUT2 
 PLLU_480M 
 PLLU_60M 
 PLLU_48M 
 PLLD 
 PLLD_OUT0 
 PLLRE 
 PLLE 
 PLLC4 
 PLLC4_OUT0 
 PLLC4_OUT1 
 PLLC4_OUT2 
 PLLC4_OUT3 
 PLLDP 
 PLLD2 
 PLLD2_OUT0 
 PLLP_OUT2 
 Tegra210 CPU clock and reset control functions 
 check CPU been reset or not 
 flow controller would take care in the power sequence. 
	
	  Save the bootloader configured clock registers SPARE_REG0,
	  MISC_CLK_ENB, CLK_MASK_ARM, CPU_SOFTRST_CTRL.
	
	  Restore the bootloader configured clock registers SPARE_REG0,
	  MISC_CLK_ENB, CLK_MASK_ARM, CPU_SOFTRST_CTRL from saved context.
	
	  Tegra clock programming sequence recommends peripheral clock to
	  be enabled prior to changing its clock source and divider to
	  prevent glitchless frequency switch.
	  So, enable all peripheral clocks before restoring their source
	  and dividers.
 wait for all writes to happen to have all the clocks enabled 
 restore PLLs and all peripheral clock rates 
 restore saved context of peripheral clocks and reset state 
 switch coresite to clk_m, save off original source 
 TODO find a way to enable this on-demand 
 This MUST be the last entry. 
  tegra210_clock_apply_init_table - initialize clocks on Tegra210 SoCs
  Program an initial clock rate and enable or disable clocks needed
  by the rest of the kernel, for Tegra210 SoCs.  It is intended to be
  called by assigning a pointer to it to tegra_clk_apply_init_table -
  this will be called as an arch_initcall.  No return value.
  tegra210_car_barrier - wait for pending writes to the CAR to complete
  Wait for any outstanding writes to the CAR MMIO space from this CPU
  to complete before continuing execution.  No return value.
  tegra210_clock_assert_dfll_dvco_reset - assert the DFLL's DVCO reset
  Assert the reset line of the DFLL's DVCO.  No return value.
  tegra210_clock_deassert_dfll_dvco_reset - deassert the DFLL's DVCO reset
  Deassert the reset line of the DFLL's DVCO, allowing the DVCO to
  operate.  No return value.
		
		  Considering adsp cpu clock (min: 12.5MHZ, max: 1GHz)
		  a delay of 5us ensures that it's at least
		  6  adsp_cpu_cycle_period long.
  tegra210_clock_init - Tegra210-specific clock initialization
  @np: struct device_node  of the DT node for the SoC CAR IP block
  Register most SoC clocks for the Tegra210 system-on-chip.  Intended
  to be called by the OF init code when a DT node with the
  "nvidia,tegra210-car" string is encountered, and declared with
  CLK_OF_DECLARE.  No return value.
 For Tegra210, PLLD is the only source for DSIA & DSIB 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, 2013, NVIDIA CORPORATION.  All rights reserved.
 override default prop dlys 
 rise->rise prop dly A 
 rise->rise prop dly inc A 
 RST_DFLL_DVCO bitfields 
 CPU_FINETRIM_SELECT and CPU_FINETRIM_DR bitfields 
 fcpu0 
 fcpu1 
 fcpu2 
 fcpu3 
 fl2 
 ftop 
 CPU_FINETRIM_R bitfields 
 fcpu0 
 fcpu1 
 fcpu2 
 fcpu3 
 fl2 
 ftop 
 PLLM override registers 
 Tegra CPU clock and reset control regs 
 actual: 598.0 MHz 
 actual: 596.4 MHz 
 actual: 595.2 MHz 
 actual: 598.0 MHz 
 sw policy, hw capability 50 MHz 
 actual: 598.0 MHz 
 actual: 596.4 MHz 
 actual: 595.2 MHz 
 actual: 598.0 MHz 
 actual: 792.0 MHz 
 actual: 793.0 MHz 
 actual: 789.6 MHz 
 actual: 787.2 MHz 
 actual: 793.0 MHz 
 sw policy, hw capability 50 MHz 
 1 GHz 
 actual: 996.0 MHz 
 actual: 988.0 MHz 
 actual: 991.2 MHz 
 actual: 998.4 MHz 
 actual: 988.0 MHz 
 sw policy, hw capability 50 MHz 
 PLLE special case: use cpcon field to store cml divider value 
 sw policy, hw capability 38 MHz 
 possible OSC frequencies in Hz 
 peripheral mux definitions 
 clk_32k 
 PLLC 
 PLLC_OUT1 
 PLLC2 
 PLLC3 
 PLLM 
 PLLM_OUT1 
 PLLM_UD 
 PLLU 
 PLLU_480M 
 PLLU_60M 
 PLLU_48M 
 PLLU_12M 
 PLLD 
 PLLD_OUT0 
 PLLD2 
 PLLD2_OUT0 
 PLLRE 
 PLLE 
 xusb_ss_div2 
 dsia mux 
 dsib mux 
 emc mux 
 Tegra114 CPU clock and reset control functions 
 check CPU been reset or not 
 flow controller would take care in the power sequence. 
 switch coresite to clk_m, save off original source 
  dfll_socdfll_ref apparently must be kept enabled, otherwise I2C5
  breaks
 must be the last entry 
  tegra114_car_barrier - wait for pending writes to the CAR to complete
  Wait for any outstanding writes to the CAR MMIO space from this CPU
  to complete before continuing execution.  No return value.
 probably unnecessary 
  tegra114_clock_tune_cpu_trimmers_high - use high-voltage propagation delays
  When the CPU rail voltage is in the high-voltage range, use the
  built-in hardwired clock propagation delays in the CPU clock
  shaper.  No return value.
 Use hardwired rise->rise & fall->fall clock propagation delays 
  tegra114_clock_tune_cpu_trimmers_low - use low-voltage propagation delays
  When the CPU rail voltage is in the low-voltage range, use the
  extended clock propagation delays set by
  tegra114_clock_tune_cpu_trimmers_init().  The intention is to
  maintain the input clock duty cycle that the FCPU subsystem
  expects.  No return value.
	
	  Use software-specified rise->rise & fall->fall clock
	  propagation delays (from
	  tegra114_clock_tune_cpu_trimmers_init()
  tegra114_clock_tune_cpu_trimmers_init - set up and enable clk prop delays
  Program extended clock propagation delays into the FCPU clock
  shaper and enable them.  XXX Define the purpose - peak current
  reduction?  No return value.
 XXX Initial voltage rail state assumption issues? 
 Increment the rise->rise clock delay by four steps 
	
	  Use the rise->rise clock propagation delay specified in the
	  r field
  tegra114_clock_assert_dfll_dvco_reset - assert the DFLL's DVCO reset
  Assert the reset line of the DFLL's DVCO.  No return value.
  tegra114_clock_deassert_dfll_dvco_reset - deassert the DFLL's DVCO reset
  Deassert the reset line of the DFLL's DVCO, allowing the DVCO to
  operate.  No return value.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, 2013, NVIDIA CORPORATION.  All rights reserved.
 timeout = 2  lock time 
	
	  Power Management Controller (PMC) can override the PLLM clock
	  settings, including the enable-state. The PLLM is enabled when
	  PLLM's CaR state is ON and when PLLM isn't gated by PMC.
		
		  PLL_P_OUT1 rate is not listed in PLLA table
 Raise VCO to guarantee 0.5% accuracy 
  SDM (Sigma Delta Modulator) divisor is 16-bit 2's complement signed number
  within (-2^12 ... 2^12-1) range. Represented in PLL data structure as
  unsigned 16-bit value, with "0" divisor mapped to 0xFFFF. Data "0" is used
  to indicate that SDM is disabled.
  Effective ndiv value when SDM is enabled: ndiv + 12 + sdm_din2^13
 PLLMMB are used for memory; we do not change rate 
	
	  PLLE is already disabled, and setup cleared;
	  create falling edge on PLLE IDDQ input.
 configure dividers 
  Structure defining the fields for USB UTMI clocks Parameters.
 Oscillator Frequency in Hz 
 UTMIP PLL Enable Delay Count  
 UTMIP PLL Stable count 
  UTMIP PLL Active delay count 
 UTMIP PLL Xtal frequency count 
 Program UTMIP PLL stable and active counts 
 Remove power downs from UTMIP PLL control bits 
 Program UTMIP PLL delay and oscillator frequency counts 
 Remove power downs from UTMIP PLL control bits 
 Disable lock override 
 Enable HW control of XUSB brick PLL 
 Enable HW control of SATA PLL 
 Program UTMIP PLL stable and active counts 
 Remove power downs from UTMIP PLL control bits 
 Program UTMIP PLL delay and oscillator frequency counts 
 Remove power downs from UTMIP PLL control bits 
 Setup HW control of UTMIPLL 
	
	  Setup SW override of UTMIPLL assuming USB2.0 ports are assigned
	  to USB2
 Enable HW control of UTMIPLL 
 ensure parent is set to pll_ref 
 Default to _calc_rate if unspecified 
 Data in .init is copied by clk_register(), so stack variable OK 
	
	  If the pll has a set_defaults callback, it will take care of
	  configuring dynamic ramping and setting IDDQ in that path.
 program minimum rate by default 
 disable lock override 
	
	  Most of PLLC register fields are shadowed, and can not be read
	  directly from PLL hw. Hence, actual PLLC boot state is unknown.
	  Initialize PLL to default state: disabled, reset; shadow registers
	  loaded with default parameters; dividers are preset for half of
	  minimum VCO rate (the latter assured that shadowed divider settings
	  are within supported range).
 initialize PLL to minimum rate 
 Disable lock override 
 If PLLE HW sequencer is enabled, SW should not disable PLLE 
 SPDX-License-Identifier: GPL-2.0-only
  clk-dfll.c - Tegra DFLL clock source common code
  Copyright (C) 2012-2019 NVIDIA Corporation. All rights reserved.
  Aleksandr Frid <afrid@nvidia.com>
  Paul Walmsley <pwalmsley@nvidia.com>
  This library is for the DVCO and DFLL IP blocks on the Tegra124
  SoC. These IP blocks together are also known at NVIDIA as
  "CL-DVFS". To try to avoid confusion, this code refers to them
  collectively as the "DFLL."
  The DFLL is a root clocksource which tolerates some amount of
  supply voltage noise. Tegra124 uses it to clock the fast CPU
  complex when the target CPU speed is above a particular rate. The
  DFLL can be operated in either open-loop mode or closed-loop mode.
  In open-loop mode, the DFLL generates an output clock appropriate
  to the supply voltage. In closed-loop mode, when configured with a
  target frequency, the DFLL minimizes supply voltage while
  delivering an average frequency equal to the target.
  Devices clocked by the DFLL must be able to tolerate frequency
  variation. In the case of the CPU, it's important to note that the
  CPU cycle time will vary. This has implications for
  performance-measurement code and any code that relies on the CPU
  cycle time to delay for a certain length of time.
  DFLL control registers - access via dfll_{readl,writel}
 DFLL_CTRL: DFLL control register 
 DFLL_CONFIG: DFLL sample rate control 
 DFLL_PARAMS: tuning coefficients for closed loop integrator 
 DFLL_TUNE0: delay line configuration register 0 
 DFLL_TUNE1: delay line configuration register 1 
 DFLL_FREQ_REQ: target DFLL frequency control 
 DFLL_DROOP_CTRL: droop prevention control 
 DFLL_OUTPUT_CFG: closed loop mode control registers 
 NOTE: access via dfll_i2c_{readl,writel} 
 DFLL_OUTPUT_FORCE: closed loop mode voltage forcing control 
 DFLL_MONITOR_CTRL: internal monitor data source control 
 DFLL_MONITOR_DATA: internal monitor data output 
  I2C output control registers - access via dfll_i2c_{readl,writel}
 DFLL_I2C_CFG: I2C controller configuration register 
 DFLL_I2C_VDD_REG_ADDR: PMIC I2C address for closed loop mode 
 DFLL_I2C_STS: I2C controller status 
 DFLL_INTR_STS: DFLL interrupt status register 
 DFLL_INTR_EN: DFLL interrupt enable register 
  Integrated I2C controller registers - relative to td->i2c_controller_base
 DFLL_I2C_CLK_DIVISOR: I2C controller clock divisor 
  Other constants
 MAX_DFLL_VOLTAGES: number of LUT entries in the DFLL IP block 
  REF_CLK_CYC_PER_DVCO_SAMPLE: the number of ref_clk cycles that the hardware
     integrates the DVCO counter over - used for debug rate monitoring and
     droop control
  REF_CLOCK_RATE: the DFLL reference clock rate currently supported by this
  driver, in Hz
  enum dfll_ctrl_mode - DFLL hardware operating mode
  @DFLL_UNINITIALIZED: (uninitialized state - not in hardware bitfield)
  @DFLL_DISABLED: DFLL not generating an output clock
  @DFLL_OPEN_LOOP: DVCO running, but DFLL not adjusting voltage
  @DFLL_CLOSED_LOOP: DVCO running, and DFLL adjusting voltage to match
 		      the requested rate
  The integer corresponding to the last two states, minus one, is
  written to the DFLL hardware to change operating modes.
  enum dfll_tune_range - voltage range that the driver believes it's in
  @DFLL_TUNE_UNINITIALIZED: DFLL tuning not yet programmed
  @DFLL_TUNE_LOW: DFLL in the low-voltage range (or open-loop mode)
  Some DFLL tuning parameters may need to change depending on the
  DVCO's voltage; these states represent the ranges that the driver
  supports. These are software states; these values are never
  written into registers.
  struct dfll_rate_req - target DFLL rate request data
  @rate: target frequency, after the postscaling
  @dvco_target_rate: target frequency, after the postscaling
  @lut_index: LUT index at which voltage the dvco_target_rate will be reached
  @mult_bits: value to program to the MULT bits of the DFLL_FREQ_REQ register
  @scale_bits: value to program to the SCALE bits of the DFLL_FREQ_REQ register
 Parameters from DT 
 I2C interface parameters 
 lut array entries are regulator framework selectors or PWM values
 PWM interface 
 mode_name: map numeric DFLL modes to names for friendly console messages 
  Register accessors
 I2C output control registers - for addresses above DFLL_I2C_CFG 
  dfll_is_running - is the DFLL currently generating a clock?
  @td: DFLL instance
  If the DFLL is currently generating an output clock signal, return
  true; otherwise return false.
  Runtime PM suspendresume callbacks
  tegra_dfll_runtime_resume - enable all clocks needed by the DFLL
  @dev: DFLL device 
  Enable all clocks needed by the DFLL. Assumes that clk_prepare()
  has already been called on all the clocks.
  XXX Should also handle context restore when returning from off.
  tegra_dfll_runtime_suspend - disable all clocks needed by the DFLL
  @dev: DFLL device 
  Disable all clocks needed by the DFLL. Assumes that other code
  will later call clk_unprepare().
  DFLL tuning operations (per-voltage-range tuning settings)
  dfll_tune_low - tune to DFLL and CPU settings valid for any voltage
  @td: DFLL instance
  Tune the DFLL oscillator parameters and the CPU clock shaper for
  the low-voltage range. These settings are valid for any voltage,
  but may not be optimal.
  Output clock scaler helpers
  dfll_scale_dvco_rate - calculate scaled rate from the DVCO rate
  @scale_bits: clock scaler value (bits in the DFLL_FREQ_REQ_SCALE field)
  @dvco_rate: the DVCO rate
  Apply the same scaling formula that the DFLL hardware uses to scale
  the DVCO rate.
  DFLL mode switching
  dfll_set_mode - change the DFLL control mode
  @td: DFLL instance
  @mode: DFLL control mode (see enum dfll_ctrl_mode)
  Change the DFLL's operating mode between disabled, open-loop mode,
  and closed-loop mode, or vice versa.
  DVCO rate control
  DFLL-to-I2C controller interface
  dfll_i2c_set_output_enabled - enabledisable I2C PMIC voltage requests
  @td: DFLL instance
  @enable: whether to enable or disable the I2C voltage requests
  Set the master enable control for I2C control value updates. If disabled,
  then I2C control messages are inhibited, regardless of the DFLL mode.
  DFLL-to-PWM controller interface
  dfll_pwm_set_output_enabled - enabledisable PWM voltage requests
  @td: DFLL instance
  @enable: whether to enable or disable the PWM voltage requests
  Set the master enable control for PWM control value updates. If disabled,
  then the PWM signal is not driven. Also configure the PWM output pad
  to the appropriate state.
  dfll_set_force_output_value - set fixed value for force output
  @td: DFLL instance
  @out_val: value to force output
  Set the fixed value for force output, DFLL will output this value when
  force output is enabled.
  dfll_set_force_output_enabled - enabledisable force output
  @td: DFLL instance
  @enable: whether to enable or disable the force output
  Set the enable control for fouce output with fixed value.
  dfll_force_output - force output a fixed value
  @td: DFLL instance
  @out_sel: value to force output
  Set the fixed value for force output, DFLL will output this value.
  dfll_load_lut - load the voltage lookup table
  @td: struct tegra_dfll 
  Load the voltage-to-PMIC register value lookup table into the DFLL
  IP block memory. Look-up tables can be loaded at any time.
  dfll_init_i2c_if - set up the DFLL's DFLL-I2C interface
  @td: DFLL instance
  During DFLL driver initialization, program the DFLL-I2C interface
  with the PMU slave address, vdd register offset, and transfer mode.
  This data is used by the DFLL to automatically construct I2C
  voltage-set commands, which are then passed to the DFLL's internal
  I2C controller.
 default hs divisor just in case 
  dfll_init_out_if - prepare DFLL-to-PMIC interface
  @td: DFLL instance
  During DFLL driver initialization or resume from context loss,
  disable the I2C command output to the PMIC, set safe voltage and
  output limits, and disable and clear limit interrupts.
 clear DFLL_OUTPUT_CFG before setting new value 
 set initial voltage 
  Setget the DFLL's targeted output clock rate
  find_lut_index_for_rate - determine I2C LUT index for given DFLL rate
  @td: DFLL instance
  @rate: clock rate
  Determines the index of a I2C LUT entry for a voltage that approximately
  produces the given DFLL clock rate. This is used when forcing a value
  to the integrator during rate changes. Returns -ENOENT if a suitable
  LUT index is not found.
  dfll_calculate_rate_request - calculate DFLL parameters for a given rate
  @td: DFLL instance
  @req: DFLL-rate-request structure
  @rate: the desired DFLL rate
  Populate the DFLL-rate-request record @req fields with the scale_bits
  and mult_bits fields, based on the target input rate. Returns 0 upon
  success, or -EINVAL if the requested rate in req->rate is too high
  or low for the DFLL to generate.
	
	  If requested rate is below the minimum DVCO rate, active the scaler.
	  In the future the DVCO minimum voltage should be selected based on
	  chip temperature and the actual minimum rate should be calibrated
	  at runtime.
 Convert requested rate into frequency request and scale settings 
  dfll_set_frequency_request - start the frequency change operation
  @td: DFLL instance
  @req: rate request structure
  Tell the DFLL to try to change its output frequency to the
  frequency represented by @req. DFLL must be in closed-loop mode.
 FIXME: td->cg_scale? ;
  tegra_dfll_request_rate - set the next rate for the DFLL to tune to
  @td: DFLL instance
  @rate: clock rate to target
  Convert the requested clock rate @rate into the DFLL control logic
  settings. In closed-loop mode, update new settings immediately to
  adjust DFLL output rate accordingly. Otherwise, just save them
  until the next switch to closed loop. Returns 0 upon success,
  -EPERM if the DFLL driver has not yet been initialized, or -EINVAL
  if @rate is outside the DFLL's tunable range.
  DFLL enabledisable & open-loop <-> closed-loop transitions
  dfll_disable - switch from open-loop mode to disabled mode
  @td: DFLL instance
  Switch from OPEN_LOOP state to DISABLED state. Returns 0 upon success
  or -EPERM if the DFLL is not currently in open-loop mode.
  dfll_enable - switch a disabled DFLL to open-loop mode
  @td: DFLL instance
  Switch from DISABLED state to OPEN_LOOP state. Returns 0 upon success
  or -EPERM if the DFLL is not currently disabled.
  dfll_set_open_loop_config - prepare to switch to open-loop mode
  @td: DFLL instance
  Prepare to switch the DFLL to open-loop mode. This switches the
  DFLL to the low-voltage tuning range, ensures that I2C output
  forcing is disabled, and disables the output clock rate scaler.
  The DFLL's low-voltage tuning range parameters must be
  characterized to keep the downstream device stable at any DVCO
  input voltage. No return value.
 always tune low (safe) in open loop 
  tegra_dfll_lock - switch from open-loop to closed-loop mode
  @td: DFLL instance
  Switch from OPEN_LOOP state to CLOSED_LOOP state. Returns 0 upon success,
  -EINVAL if the DFLL's target rate hasn't been set yet, or -EPERM if the
  DFLL is not currently in open-loop mode.
  tegra_dfll_unlock - switch from closed-loop to open-loop mode
  @td: DFLL instance
  Switch from CLOSED_LOOP state to OPEN_LOOP state. Returns 0 upon success,
  or -EPERM if the DFLL is not currently in open-loop mode.
  Clock framework integration
  When the DFLL is being controlled by the CCF, always enter closed loop
  mode when the clk is enabled. This requires that a DFLL rate request
  has been set beforehand, which implies that a clk_set_rate() call is
  always required before a clk_enable().
 Must use determine_rate since it allows for rates exceeding 2^31-1 
	
	  Don't set the rounded rate, since it doesn't really matter as
	  the output rate will be voltage controlled anyway, and cpufreq
	  freaks out if any rounding happens.
  dfll_register_clk - register the DFLL output clock with the clock framework
  @td: DFLL instance
  Register the DFLL's output clock with the Linux clock framework and register
  the DFLL driver as an OF clock provider. Returns 0 upon success or -EINVAL
  or -ENOMEM upon failure.
  dfll_unregister_clk - unregister the DFLL output clock
  @td: DFLL instance
  Unregister the DFLL's output clock from the Linux clock framework
  and from clkdev. No return value.
  Debugfs interface
  Monitor control
  dfll_calc_monitored_rate - convert DFLL_MONITOR_DATA_VAL rate into real freq
  @monitor_data: value read from the DFLL_MONITOR_DATA_VAL bitfield
  @ref_rate: DFLL reference clock rate
  Convert @monitor_data from DFLL_MONITOR_DATA_VAL units into cycles
  per second. Returns the converted value.
  dfll_read_monitor_rate - return the DFLL's output rate from internal monitor
  @td: DFLL instance
  If the DFLL is enabled, return the last rate reported by the DFLL's
  internal monitoring hardware. This works in both open-loop and
  closed-loop mode, and takes the output scaler setting into account.
  Assumes that the monitor was programmed to monitor frequency before
  the sample period started. If the driver believes that the DFLL is
  currently uninitialized or disabled, it will return 0, since
  otherwise the DFLL monitor data register will return the last
  measured rate from when the DFLL was active.
 CONFIG_DEBUG_FS 
  DFLL initialization
  dfll_set_default_params - program non-output related DFLL parameters
  @td: DFLL instance
  During DFLL driver initialization or resume from context loss,
  program parameters for the closed loop integrator, DVCO tuning,
  voltage droop control and monitor control.
  dfll_init_clks - clk_get() the DFLL source clocks
  @td: DFLL instance
  Call clk_get() on the DFLL source clocks and save the pointers for later
  use. Returns 0 upon success or error (see devm_clk_get) if one or more
  of the clocks couldn't be looked up.
  dfll_init - Prepare the DFLL IP block for use
  @td: DFLL instance
  Do everything necessary to prepare the DFLL IP block for use. The
  DFLL will be left in DISABLED state. Called by dfll_probe().
  Returns 0 upon success, or passes along the error from whatever
  function returned it.
  tegra_dfll_suspend - check DFLL is disabled
  @dev: DFLL instance
  DFLL clock should be disabled by the CPUFreq driver. So, make
  sure it is disabled and disable all clocks needed by the DFLL.
  tegra_dfll_resume - reinitialize DFLL on resume
  @dev: DFLL instance
  DFLL is disabled and reset during suspend and resume.
  So, reinitialize the DFLL IP block back for use.
  DFLL clock is enabled later in closed loop mode by CPUFreq
  driver before switching its clock source to DFLL output.
  DT data fetch
  Find a PMIC voltage register-to-voltage mapping for the given voltage.
  An exact voltage match is required.
  Find a PMIC voltage register-to-voltage mapping for the given voltage,
  rounding up to the closest supported voltage.
  dfll_build_pwm_lut - build the PWM regulator lookup table
  @td: DFLL instance
  @v_max: Vmax from OPP table
  Look-up table in hw is ignored when PWM is used as DFLL interface to PMIC.
  In this case closed loop output is controlling duty cycle directly. The sw
  look-up that maps PWM duty cycle to voltage is still built by this function.
 since opp voltage is exact mv 
 determine voltage boundaries 
 determine rate boundaries 
  dfll_build_i2c_lut - build the I2C voltage register lookup table
  @td: DFLL instance
  @v_max: Vmax from OPP table
  The DFLL hardware has 33 bytes of look-up table RAM that must be filled with
  PMIC voltage register values that span the entire DFLL operating range.
  This function builds the look-up table based on the OPP table provided by
  the soc-specific platform driver (td->soc->opp_dev) and the PMIC
  register-to-voltage mapping queried from the regulator framework.
  On success, fills in td->lut and returns 0, or -err on failure.
  read_dt_param - helper function for reading required parameters from the DT
  @td: DFLL instance
  @param: DT property name
  @dest: output pointer for the value read
  Read a required numeric parameter from the DFLL device node, or complain
  if the property doesn't exist. Returns a boolean indicating success for
  easy chaining of multiple calls to this function.
  dfll_fetch_i2c_params - query PMIC I2C params from DT & regulator subsystem
  @td: DFLL instance
  Read all the parameters required for operation in I2C mode. The parameters
  can originate from the device tree or the regulator subsystem.
  Returns 0 on success or -err on failure.
  dfll_fetch_common_params - read DFLL parameters from the device tree
  @td: DFLL instance
  Read all the DT parameters that are common to both I2C and PWM operation.
  Returns 0 on success or -EINVAL on any failure.
  API exported to per-SoC platform drivers
  tegra_dfll_register - probe a Tegra DFLL device
  @pdev: DFLL platform_device 
  @soc: Per-SoC integration and characterization data for this DFLL instance
  Probe and initialize a DFLL device instance. Intended to be called
  by a SoC-specific shim driver that passes in per-SoC integration
  and configuration data via @soc. Returns 0 on success or -err on failure.
 Enable the clocks and set the device up 
  tegra_dfll_unregister - release all of the DFLL driver resources for a device
  @pdev: DFLL platform_device 
  Unbind this driver from the DFLL hardware device represented by
  @pdev. The DFLL must be disabled for this to succeed. Returns a
  soc pointer upon success or -EBUSY if the DFLL is still active.
 Try to prevent removal while the DFLL is active 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, 2013, NVIDIA CORPORATION.  All rights reserved.
 osc_div2 
 osc_div4 
 pll_ref 
 clk_32k 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012-2014 NVIDIA CORPORATION.  All rights reserved.
  TEGRA124_CAR_BANK_COUNT: the number of peripheral clock register
  banks present in the Tegra124132 CAR IP block.  The banks are
  identified by single letters, e.g.: L, H, U, V, W, X.  See
  periph_regs[] in driversclktegraclk.c
 Tegra CPU clock and reset control regs 
 possible OSC frequencies in Hz 
 1 GHz 
 actual: 996.0 MHz 
 actual: 988.0 MHz 
 actual: 991.2 MHz 
 actual: 998.4 MHz 
 actual: 988.0 MHz 
 sw policy, hw capability 50 MHz 
 actual: 598.0 MHz 
 actual: 596.4 MHz 
 actual: 595.2 MHz 
 actual: 598.0 MHz 
 sw policy, hw capability 50 MHz 
 actual: 598.0 MHz 
 actual: 596.4 MHz 
 actual: 595.2 MHz 
 actual: 598.0 MHz 
 actual: 598.0 MHz 
 actual: 596.4 MHz 
 actual: 595.2 MHz 
 actual: 598.0 MHz 
 sw policy, hw capability 38 MHz 
 actual: 792.0 MHz 
 actual: 793.0 MHz 
 actual: 789.6 MHz 
 actual: 787.2 MHz 
 actual: 793.0 MHz 
 sw policy, hw capability 50 MHz 
 PLLE special case: use cpcon field to store cml divider value 
 sw policy, hw capability 38 MHz 
 actual: 591.5 MHz 
 actual: 596.4 MHz 
 actual: 595.2 MHz 
 actual: 591.5 MHz 
 sw policy, hw capability 38 MHz 
 actual: 598.0 MHz 
 actual: 596.4 MHz 
 actual: 595.2 MHz 
 actual: 598.0 MHz 
 sw policy, hw capability 38 MHz 
 xusb_ss_div2 
 cml0 
 cml1 
 PLLC 
 PLLC_OUT1 
 PLLC_UD 
 PLLC2 
 PLLC3 
 PLLM 
 PLLM_OUT1 
 PLLM_UD 
 PLLU 
 PLLU_480M 
 PLLU_60M 
 PLLU_48M 
 PLLU_12M 
 PLLD 
 PLLD_OUT0 
 PLLRE 
 PLLE 
 PLLC4 
 PLLDP 
 PLLD2 
 PLLD2_OUT0 
 Tegra124 CPU clock and reset control functions 
 check CPU been reset or not 
 flow controller would take care in the power sequence. 
 switch coresite to clk_m, save off original source 
 must be the last entry 
 must be the last entry 
 Tegra132 requires the SOC_THERM clock to remain active 
 must be the last entry 
  tegra124_clock_apply_init_table - initialize clocks on Tegra124 SoCs
  Program an initial clock rate and enable or disable clocks needed
  by the rest of the kernel, for Tegra124 SoCs.  It is intended to be
  called by assigning a pointer to it to tegra_clk_apply_init_table -
  this will be called as an arch_initcall.  No return value.
  tegra124_car_barrier - wait for pending writes to the CAR to complete
  Wait for any outstanding writes to the CAR MMIO space from this CPU
  to complete before continuing execution.  No return value.
  tegra124_clock_assert_dfll_dvco_reset - assert the DFLL's DVCO reset
  Assert the reset line of the DFLL's DVCO.  No return value.
  tegra124_clock_deassert_dfll_dvco_reset - deassert the DFLL's DVCO reset
  Deassert the reset line of the DFLL's DVCO, allowing the DVCO to
  operate.  No return value.
  tegra132_clock_apply_init_table - initialize clocks on Tegra132 SoCs
  Program an initial clock rate and enable or disable clocks needed
  by the rest of the kernel, for Tegra132 SoCs.  It is intended to be
  called by assigning a pointer to it to tegra_clk_apply_init_table -
  this will be called as an arch_initcall.  No return value.
  tegra124_132_clock_init_pre - clock initialization preamble for T124T132
  @np: struct device_node  of the DT node for the SoC CAR IP block
  Register most of the clocks controlled by the CAR IP block.
  Everything in this function should be common to Tegra124 and Tegra132.
  No return value.
 For Tegra124 & Tegra132, PLLD is the only source for DSIA & DSIB 
  tegra124_132_clock_init_post - clock initialization postamble for T124T132
  @np: struct device_node  of the DT node for the SoC CAR IP block
  Register most of the clocks controlled by the CAR IP block.
  Everything in this function should be common to Tegra124
  and Tegra132.  This function must be called after
  tegra124_132_clock_init_pre(), otherwise clk_base will not be set.
  No return value.
  tegra124_clock_init - Tegra124-specific clock initialization
  @np: struct device_node  of the DT node for the SoC CAR IP block
  Register most SoC clocks for the Tegra124 system-on-chip.  Most of
  this code is shared between the Tegra124 and Tegra132 SoCs,
  although some of the initial clock settings and CPU clocks differ.
  Intended to be called by the OF init code when a DT node with the
  "nvidia,tegra124-car" string is encountered, and declared with
  CLK_OF_DECLARE.  No return value.
  tegra132_clock_init - Tegra132-specific clock initialization
  @np: struct device_node  of the DT node for the SoC CAR IP block
  Register most SoC clocks for the Tegra132 system-on-chip.  Most of
  this code is shared between the Tegra124 and Tegra132 SoCs,
  although some of the initial clock settings and CPU clocks differ.
  Intended to be called by the OF init code when a DT node with the
  "nvidia,tegra132-car" string is encountered, and declared with
  CLK_OF_DECLARE.  No return value.
	
	  On Tegra132, these clocks are controlled by the
	  CLUSTER_clocks IP block, located in the CPU complex
 SPDX-License-Identifier: GPL-2.0+
  Based on driversclktegraclk-emc.c
  Copyright (c) 2014, NVIDIA CORPORATION.  All rights reserved.
  Author: Dmitry Osipenko <digetx@gmail.com>
  Copyright (C) 2019 GRATE-DRIVER project
	
	  EMC stands for External Memory Controller.
	 
	  We don't want EMC clock to be disabled ever by gating its
	  parent and whatnot because system is busted immediately in that
	  case, hence the clock is marked as critical.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, 2013, NVIDIA CORPORATION.  All rights reserved.
 SCLK_MUX 
 SCLK 
 SCLK 
 HCLK 
 PCLK 
 CCLKG 
 CCLKLP 
			
			  TEGRA210_CPU_CLK flag is not needed for cclk_lp as
			  cluster switching is not currently supported on
			  Tegra210 and also cpu_lp is not used.
 PLLX 
 PLLX_OUT0 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
 Data in .init is copied by clk_register(), so stack variable OK 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018 NVIDIA CORPORATION.  All rights reserved.
  based on clk-mux.c
  Copyright (C) 2011 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
  Copyright (C) 2011 Richard Zhao, Linaro <richard.zhao@linaro.org>
  Copyright (C) 2011-2012 Mike Turquette, Linaro Ltd <mturquette@linaro.org>
 Data in .init is copied by clk_register(), so stack variable OK 
 SPDX-License-Identifier: GPL-2.0-only
  Utility functions for parsing Tegra CVB voltage tables
  Copyright (C) 2012-2019 NVIDIA Corporation.  All rights reserved.
 cvb_mv = ((c2  speedo  s_scale + c1)  speedo  s_scale + c0) 
 apply only speedo scale: output mv = cvb_mv  v_scale 
 combined: apply voltage scale and round to cvb alignment step 
  tegra_cvb_add_opp_table - build OPP table from Tegra CVB tables
  @dev: the struct device  for which the OPP table is built
  @tables: array of CVB tables
  @count: size of the previously mentioned array
  @align: parameters of the regulator step and offset
  @process_id: process id of the HW module
  @speedo_id: speedo id of the HW module
  @speedo_value: speedo value of the HW module
  @max_freq: highest safe clock rate
  On Tegra, a CVB table encodes the relationship between operating voltage
  and safe maximal frequency for a given module (e.g. GPU or CPU). This
  function calculates the optimal voltage-frequency operating points
  for the given arguments and exports them via the OPP library for the
  given @dev. Returns a pointer to the struct cvb_table that matched
  or an ERR_PTR on failure.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
	
	  If LP_DIV2_BYPASS is not set and PLLX is current parent then
	  PLLX2 is the input source to CCLKLP.
	
	  For LP mode super-clock switch between PLLX direct
	  and divided-by-2 outputs is allowed only when other
	  than PLLX clock source is current parent.
 enable PLLP branches to CPU before selecting PLLP source 
 disable PLLP branches to CPU if not used 
 Data in .init is copied by clk_register(), so stack variable OK 
 Data in .init is copied by clk_register(), so stack variable OK 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
 Tegra CPU clock and reset control regs 
 PLLM override registers 
 actual: 1039.5 MHz 
 actual: 831.6 MHz 
 actual: 519.75 MHz 
 actual: 415.8 MHz 
 1.7 GHz 
 actual: 1699.2 MHz 
 actual: 1699.2 MHz 
 actual: 1699.2 MHz 
 1.6 GHz 
 actual: 1599.0 MHz 
 actual: 1599.7 MHz 
 1.5 GHz 
 actual: 1499.8 MHz 
 1.4 GHz 
 actual: 1399.7 MHz 
 1.3 GHz 
 actual: 1299.2 MHz 
 actual: 1299.2 MHz 
 1.2 GHz 
 actual: 1199.9 MHz 
 1.1 GHz 
 actual: 1099.8 MHz 
 actual: 1099.8 MHz 
 actual: 1099.5 MHz 
 1 GHz 
 actual: 999.6 MHz 
 PLLE special case: use cpcon field to store cml divider value 
 PLL parameters 
 PLLC 
 PLLC_OUT1 
 PLLM 
 PLLM_OUT1 
 PLLX 
 PLLX_OUT0 
 PLLU 
 PLLD 
 PLLD_OUT0 
 PLLD2 
 PLLD2_OUT0 
 PLLE 
	
	  Clock input to cclk_g divided from pll_p using
	  U71 divider of cclk_g.
	
	  Clock input to cclk_g divided from pll_p_out3 using
	  U71 divider of cclk_g.
	
	  Clock input to cclk_g divided from pll_p_out4 using
	  U71 divider of cclk_g.
 CCLKG 
	
	  Clock input to cclk_lp divided from pll_p using
	  U71 divider of cclk_lp.
	
	  Clock input to cclk_lp divided from pll_p_out3 using
	  U71 divider of cclk_lp.
	
	  Clock input to cclk_lp divided from pll_p_out4 using
	  U71 divider of cclk_lp.
 CCLKLP 
 SCLK 
 twd 
 dsia 
 pcie 
 afi 
 emc 
 cml0 
 cml1 
 Tegra30 CPU clock and reset control functions 
 check CPU been reset or not 
 switch coresite to clk_m, save off original source 
 Is CPU complex already running on PLLX? 
 restore PLLX settings if CPU is on different PLL 
 wait for PLL stabilization if PLLX was enabled 
	
	  Restore original burst policy setting for calls resulting from CPU
	  LP2 in idle or system suspend.
 must be the last entry 
  Some clocks may be used by different drivers depending on the board
  configuration.  List those here to register them twice in the clock lookup
  table under two names.
 must be the last entry 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
 Macros to assist peripheral gate clock 
 Peripheral gate clock ops 
	
	  If peripheral is in the APB bus then read the APB bus to
	  flush the write operation in apb bus. This will avoid the
	  peripheral access after disabling clock
	
	  Some clocks are duplicated and some of them are marked as critical,
	  like fuse and fuse_burn for example, thus the enable_refcnt will
	  be non-zero here if the "unused" duplicate is disabled by CCF.
 Data in .init is copied by clk_register(), so stack variable OK 
 SPDX-License-Identifier: GPL-2.0-only
  Tegra124 DFLL FCPU clock source driver
  Copyright (C) 2012-2019 NVIDIA Corporation.  All rights reserved.
  Aleksandr Frid <afrid@nvidia.com>
  Paul Walmsley <pwalmsley@nvidia.com>
 Maximum CPU frequency, indexed by CPU speedo id 
  OMAP APLL clock support
  Copyright (C) 2013 Texas Instruments, Inc.
  J Keerthy <j-keerthy@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 Check is already locked 
  TI clock autoidle support
  Copyright (C) 2013 Texas Instruments, Inc.
  Tero Kristo <t-kristo@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  we have some non-atomic readwrite
  operations behind it, so lets
  take one lock for handling autoidle
  of all clocks
  omap2_clk_deny_idle - disable autoidle on an OMAP clock
  @clk: struct clk  to disable autoidle for
  Disable autoidle on an OMAP clock.
  omap2_clk_allow_idle - enable autoidle on an OMAP clock
  @clk: struct clk  to enable autoidle for
  Enable autoidle on an OMAP clock.
  _clk_generic_allow_autoidle_all - enable autoidle for all clocks
  Enables hardware autoidle for all registered DT clocks, which have
  the feature.
  _clk_generic_deny_autoidle_all - disable autoidle for all clocks
  Disables hardware autoidle for all registered DT clocks, which have
  the feature.
  of_ti_clk_autoidle_setup - sets up hardware autoidle for a clock
  @node: pointer to the clock device node
  Checks if a clock has hardware autoidle support or not (check
  for presence of 'ti,autoidle-shift' property in the device tree
  node) and sets up the hardware autoidle feature for the clock
  if available. If autoidle is available, the clock is also added
  to the autoidle list for later processing. Returns 0 on success,
  negative error value on failure.
 Check if this clock has autoidle support or not 
  omap2_clk_enable_autoidle_all - enable autoidle on all OMAP clocks that
  support it
  Enable clock autoidle on all OMAP clocks that have allow_idle
  function pointers associated with them.  This function is intended
  to be temporary until support for this is added to the common clock
  code.  Returns 0.
  omap2_clk_disable_autoidle_all - disable autoidle on all OMAP clocks that
  support it
  Disable clock autoidle on all OMAP clocks that have allow_idle
  function pointers associated with them.  This function is intended
  to be temporary until support for this is added to the common clock
  code.  Returns 0.
  TI clock support
  Copyright (C) 2013 Texas Instruments, Inc.
  Tero Kristo <t-kristo@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  ti_clk_setup_ll_ops - setup low level clock operations
  @ops: low level clock ops descriptor
  Sets up low level clock operations for TI clock driver. This is used
  to provide various callbacks for the clock driver towards platform
  specific code. Returns 0 on success, -EBUSY if ll_ops have been
  registered already.
  ti_dt_clocks_register - register DT alias clocks during boot
  @oclks: list of clocks to register
  Register alias or non-standard DT clock entries during boot. By
  default, DT clocks are found based on their node name. If any
  additional con-id  dev-id -> clock mapping is required, use this
  function to list these.
  ti_clk_retry_init - retries a failed clock init at later phase
  @node: device not for the clock
  @user: user data pointer
  @func: init function to be called for the clock
  Adds a failed clock init to the retry list. The retry list is parsed
  once all the other clocks have been initialized.
  ti_clk_get_reg_addr - get register address for a clock register
  @node: device node for the clock
  @index: register index from the clock node
  @reg: pointer to target register struct
  Builds clock register address from device tree information, and returns
  the data via the provided output pointer @reg. Returns 0 on success,
  negative error value on failure.
 OCP barrier 
  omap2_clk_provider_init - init master clock provider
  @parent: master node
  @index: internal index for clk_reg_ops
  @syscon: syscon regmap pointer for accessing clock registers
  @mem: iomem pointer for the clock provider memory area, only used if
        syscon is not provided
  Initializes a master clock IP block. This basically sets up the
  mapping from clocks node to the memory map index. All the clocks
  are then initialized through the common of_clk_init call, and the
  clocks will access their memory maps based on the node layout.
  Returns 0 in success.
 get clocks for this parent 
 add clocks node info 
  omap2_clk_legacy_provider_init - initialize a legacy clock provider
  @index: index for the clock provider
  @mem: iomem pointer for the clock provider memory area
  Initializes a legacy clock provider memory mapping.
  ti_dt_clk_init_retry_clks - init clocks from the retry list
  Initializes any clocks that have failed to initialize before,
  reasons being missing parent node(s) during earlier init. This
  typically happens only for DPLLs which need to have both of their
  parent clocks ready during init.
  ti_clk_add_aliases - setup clock aliases
  Sets up any missing clock aliases. No return value.
  ti_clk_setup_features - setup clock features flags
  @features: features definition to use
  Initializes the clock driver features flags based on platform
  provided data. No return value.
  ti_clk_get_features - get clock driver features flags
  Get TI clock driver features description. Returns a pointer
  to the current feature setup.
  omap2_clk_enable_init_clocks - prepare & enable a list of clocks
  @clk_names: ptr to an array of strings of clock names to enable
  @num_clocks: number of clock names in @clk_names
  Prepare and enable a list of clocks, named by @clk_names.  No
  return value. XXX Deprecated; only needed until these clocks are
  properly claimed and enabled by the drivers or core code that uses
  them.  XXX What code disables & calls clk_put on these clocks?
  ti_clk_add_alias - add a clock alias for a TI clock
  @dev: device alias for this clock
  @clk: clock handle to create alias for
  @con: connection ID for this clock
  Creates a clock alias for a TI clock. Allocates the clock lookup entry
  and assigns the data to it. Returns 0 if successful, negative error
  value otherwise.
  ti_clk_register - register a TI clock to the common clock framework
  @dev: device for this clock
  @hw: hardware clock handle
  @con: connection ID for this clock
  Registers a TI clock to the common clock framework, and adds a clock
  alias for it. Returns a handle to the registered clock if successful,
  ERR_PTR value in failure.
  ti_clk_register_omap_hw - register a clk_hw_omap to the clock framework
  @dev: device for this clock
  @hw: hardware clock handle
  @con: connection ID for this clock
  Registers a clk_hw_omap clock to the clock framewor, adds a clock alias
  for it, and adds the list to the available clk_hw_omap type clocks.
  Returns a handle to the registered clock if successful, ERR_PTR value
  in failure.
  omap2_clk_for_each - call function for each registered clk_hw_omap
  @fn: pointer to a callback function
  Call @fn for each registered clk_hw_omap, passing @hw to each
  function.  @fn must return 0 for success or any other value for
  failure.  If @fn returns non-zero, the iteration across clocks
  will stop and the non-zero return value will be passed to the
  caller of omap2_clk_for_each().
  omap2_clk_is_hw_omap - check if the provided clk_hw is OMAP clock
  @hw: clk_hw to check if it is an omap clock or not
  Checks if the provided clk_hw is OMAP clock or not. Returns true if
  it is, false otherwise.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
 FAPLL Control Register PLL_CTRL 
 FAPLL powerdown register PWD 
 The bypass bit is inverted on the ddr_pll.. 
  The audio_pll_clk1 input is hard wired to the 27MHz bypass clock,
  and the audio_pll_clk1 synthesizer is hardwared to 32KiHz output.
 Synthesizer divider register 
 Synthesizer frequency register 
 PLL pre-divider is P and multiplier is N 
	
	  So far no luck getting decent clock with PLL divider,
	  PLL does not seem to lock and the signal does not look
	  right. It seems the divider can only be used together
	  with the multiplier?
  See dm816x TRM chapter 1.10.3 Flying Adder PLL fore more info
 The audio_pll_clk1 is hardwired to produce 32.768KiHz clock 
	
	  PLL in bypass sets the synths in bypass mode too. The PLL rate
	  can be also be set to 27MHz, so we can't use parent_rate to
	  check for bypass mode.
	
	  Synth frequency integer and fractional divider.
	  Note that the phase output K is 8, so the result needs
	  to be multiplied by SYNTH_PHASE_K.
 Synth post-divider M 
 Only post divider m available with no fractional divider? 
 Produce the rate with just post divider M? 
 Need to recalculate the fractional divider? 
 Register the parent PLL 
	
	  Set up the child synthesizers starting at index 1 as the
	  PLL output is at index 0. We need to check the clock-indices
	  for numbering in case there are holes in the synth mapping,
	  and then probe the synth register to see if it has a FREQ
	  register available.
 Check for hardwired audio_pll_clk1 
 Does the synthesizer have a FREQ register? 
 Register the child synthesizers as the FAPLL outputs 
 Add clock alias for the outputs 
  TI Multiplexer Clock
  Copyright (C) 2013 Texas Instruments, Inc.
  Tero Kristo <t-kristo@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
	
	  FIXME need a mux-specific flag to determine if val is bitwise or
	  numeric. e.g. sys_clkin_ck's clksel field is 3 bits wide, but ranges
	  from 0x1 to 0x7 (index starts at one)
	  OTOH, pmd_trace_clk_mux_ck uses a separate bit for each clock, so
	  val = 0x4 really means "bit 2, index starts at bit 0"
  clk_mux_save_context - Save the parent selcted in the mux
  @hw: pointer  struct clk_hw
  Save the parent mux value.
  clk_mux_restore_context - Restore the parent in the mux
  @hw: pointer  struct clk_hw
  Restore the saved parent mux value.
 allocate the mux 
 struct clk_mux assignments 
  of_mux_clk_setup - Setup function for simple mux rate clock
  @node: DT node for the clock
  Sets up a basic clock multiplexer.
 Generate bit-mask based on parent info 
 SPDX-License-Identifier: GPL-2.0-only
  OMAP5 Clock init
  Copyright (C) 2013 Texas Instruments, Inc.
  Tero Kristo (t-kristo@ti.com)
  OMAP543x TRM, section "3.6.3.9.5 DPLL_USB Preferred Settings"
  states it must be at 960MHz
	
	  This must also be set to sys_32k_ck to match or
	  the ABE DPLL will not lock on a warm reboot when
	  ABE timers are used.
  AM43XX Clock init
  Copyright (C) 2013 Texas Instruments, Inc
      Tero Kristo (t-kristo@ti.com)
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
 Managed by MPPULL 
 REVISIT: which bit? 
 Only on MPUPLL 
 Only on MPUPLL 
 For ADPLL shared register access 
 See MAX_CON_ID 
 Separate con_id in format "pll040dcoclkldo" to fit MAX_CON_ID 
  Locked and bypass are not actually mutually exclusive:  if you only care
  about the DCO clock and not CLKOUT you can clear M2PWDNZ before enabling
  the PLL, resulting in status (FREQLOCK | PHASELOCK | BYPASS) after lock.
  Note that the DCO clock is never subject to bypass: if the PLL is off,
  dcoclk is low.
 PLL parent is always clkinp, bypass only affects the children 
 Internal input clock divider N2 
 Setting PLL bypass puts clkout and clkoutx2 into bypass 
 Internal mux, sources from divider N2 or clkinpulow 
 Internal divider M2, sources DCO 
 Internal fixed divider, after M2 before clkout 
 Output clkout with a mux and gate, sources from div2 or bypass 
 Output clkoutx2 with a mux and gate, sources from M2 or bypass 
 Internal mux, sources from DCO and clkinphif 
 Output clkouthif with a divider M3, sources from hif 
 Output clock dcoclkldo is the DCO 
 Output clkdcoldo, gated output of DCO 
 Internal divider M2, sources from DCO 
 Output clkoutldo, gated output of M2 
 Internal mux, sources from divider N2 or clkinpulow 
 Output clkout, sources M2 or bypass 
 MPU PLL manages the lock register for all PLLs 
  AM33XX Clock init
  Copyright (C) 2013 Texas Instruments, Inc
      Tero Kristo (t-kristo@ti.com)
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
  OMAP2 Clock init
  Copyright (C) 2013 Texas Instruments, Inc
      Tero Kristo (t-kristo@ti.com)
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
 SPDX-License-Identifier: GPL-2.0-only
  OMAP4 Clock init
  Copyright (C) 2013 Texas Instruments, Inc.
  Tero Kristo (t-kristo@ti.com)
  OMAP4 ABE DPLL default frequency. In OMAP4460 TRM version V, section
  "3.6.3.2.3 CM1_ABE Clock Generator" states that the "DPLL_ABE_X2_CLK
  must be set to 196.608 MHz" and hence, the DPLL locked frequency is
  half of this value.
  OMAP4 USB DPLL default frequency. In OMAP4430 TRM version V, section
  "3.6.3.9.5 DPLL_USB Preferred Settings" shows that the preferred
  locked frequency for the USB DPLL is 960MHz.
	
	  XXX: All the clock aliases below are only needed for legacy
	  hwmod support. Once hwmod is removed, these can be removed
	  also.
	
	  Lock USB DPLL on OMAP4 devices so that the L3INIT power
	  domain can transition to retention state when not in use.
	
	  On OMAP4460 the ABE DPLL fails to turn on if in idle low-power
	  state when turning the ABE clock domain. Workaround this by
	  locking the ABE DPLL on boot.
	  Lock the ABE DPLL in any case to avoid issues with audio.
 SPDX-License-Identifier: GPL-2.0-only
  OMAP23 interface clock control
  Copyright (C) 2011 Nokia Corporation
  Paul Walmsley
 Register offsets 
 Private functions 
 XXX 
 XXX 
  omap2430_clk_i2chs_find_idlest - return CM_IDLEST info for 2430 I2CHS
  @clk: struct clk  being enabled
  @idlest_reg: void __iomem  to store CM_IDLEST reg address into
  @idlest_bit: pointer to a u8 to store the CM_IDLEST bit shift into
  @idlest_val: pointer to a u8 to store the CM_IDLEST indicator
  OMAP2430 I2CHS CM_IDLEST bits are in CM_IDLEST1_CORE, but the
  CM_CLKEN bits are in CM_{I,F}CLKEN2_CORE.  This custom function
  passes back the correct CM_IDLEST register address for I2CHS
  modules.  No return value.
 Public data 
 2430 I2CHS has non-standard IDLEST register 
  DRA7 ATL (Audio Tracking Logic) clock driver
  Copyright (C) 2013 Texas Instruments, Inc.
  Peter Ujfalusi <peter.ujfalusi@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 the driver for the IP has been loaded 
 configured 
 Baseband Word Select Mux 
 Audio Word Select Mux 
 Cached divider value 
 Get configuration for the ATL instances 
		
		  Enable the clock if it has been asked prior to loading the
		  hw driver
  OMAP gate clock support
  Copyright (C) 2013 Texas Instruments, Inc.
  Tero Kristo <t-kristo@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  omap36xx_gate_clk_enable_with_hsdiv_restore - enable clocks suffering
          from HSDivider PWRDN problem Implements Errata ID: i556.
  @hw: DPLL output struct clk_hw
  3630 only: dpll3_m3_ck, dpll4_m2_ck, dpll4_m3_ck, dpll4_m4_ck,
  dpll4_m5_ck & dpll4_m6_ck dividers gets loaded with reset
  valueafter their respective PWRDN bits are set.  Any dummy write
  (Any other value different from the Read value) to the
  corresponding CM_CLKSEL register will refresh the dividers.
 Clear PWRDN bit of HSDIVIDER 
 Parent is the x2 node, get parent of parent for the m2 div 
 Restore the dividers 
 Write any other value different from the Read value 
 Write the original divider 
  TI Fixed Factor Clock
  Copyright (C) 2013 Texas Instruments, Inc.
  Tero Kristo <t-kristo@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  of_ti_fixed_factor_clk_setup - Setup function for TI fixed factor clock
  @node: device node for this clock
  Sets up a simple fixed factor clock based on device tree info.
 SPDX-License-Identifier: GPL-2.0-only
  OMAP234 DPLL clock functions
  Copyright (C) 2005-2008 Texas Instruments, Inc.
  Copyright (C) 2004-2010 Nokia Corporation
  Contacts:
  Richard Woodruff <r-woodruff2@ti.com>
  Paul Walmsley
 DPLL rate rounding: minimum DPLL multiplier, divider values 
 Possible error results from _dpll_test_mult 
  Scale factor to mitigate roundoff errors in DPLL rate rounding.
  The higher the scale factor, the greater the risk of arithmetic overflow,
  but the closer the rounded rate to the target rate.  DPLL_SCALE_FACTOR
  must be a power of DPLL_SCALE_BASE.
  DPLL valid Fint frequency range for OMAP36xx and OMAP4xxx.
  From device data manual section 4.3 "DPLL and DLL Specifications".
 _dpll_test_fint() return codes 
 Private functions 
  _dpll_test_fint - test whether an Fint value is valid for the DPLL
  @clk: DPLL struct clk to test
  @n: divider value (N) to test
  Tests whether a particular divider @n will result in a valid DPLL
  internal clock frequency Fint. See the 34xx TRM 4.7.6.2 "DPLL Jitter
  Correction".  Returns 0 if OK, -1 if the enclosing loop can terminate
  (assuming that it is counting N upwards), or -2 if the enclosing loop
  should skip to the next iteration (again assuming N is increasing).
 DPLL divider must result in a valid jitter correction val 
  _dpll_test_mult - test a DPLL multiplier value
  @m: pointer to the DPLL m (multiplier) value under test
  @n: current DPLL n (divider) value under test
  @new_rate: pointer to storage for the resulting rounded rate
  @target_rate: the desired DPLL rate
  @parent_rate: the DPLL's parent clock rate
  This code tests a DPLL multiplier value, ensuring that the
  resulting rate will not be higher than the target_rate, and that
  the multiplier value itself is valid for the DPLL.  Initially, the
  integer pointed to by the m argument should be prescaled by
  multiplying by DPLL_SCALE_FACTOR.  The code will replace this with
  a non-scaled m upon return.  This non-scaled m will result in a
  new_rate as close as possible to target_rate (but not greater than
  target_rate) given the current (parent_rate, n, prescaled m)
  triple. Returns DPLL_MULT_UNDERFLOW in the event that the
  non-scaled m attempted to underflow, which can allow the calling
  function to bail out early; or 0 upon success.
 Unscale m and round if necessary 
	
	  The new rate must be <= the target rate to avoid programming
	  a rate that is impossible for the hardware to handle
 Guard against m underflow 
  _omap2_dpll_is_in_bypass - check if DPLL is in bypass mode or not
  @v: bitfield value of the DPLL enable
  Checks given DPLL enable bitfield to see whether the DPLL is in bypass
  mode or not. Returns 1 if the DPLL is in bypass, 0 otherwise.
	
	  Each set bit in the mask corresponds to a bypass value equal
	  to the bitshift. Go through each set-bit in the mask and
	  compare against the given register value.
 Public functions 
 Reparent the struct clk in case the dpll is in bypass 
  omap2_get_dpll_rate - returns the current DPLL CLKOUT rate
  @clk: struct clk  of a DPLL
  DPLLs can be locked or bypassed - basically, enabled or disabled.
  When locked, the DPLL output depends on the M and N values.  When
  bypassed, on OMAP2xxx, the output rate is either the 32KiHz clock
  or sys_clk.  Bypass rates on OMAP3 depend on the DPLL: DPLLs 1 and
  2 are bypassed with dpll1_fclk and dpll2_fclk respectively
  (generated by DPLL3), while DPLL 3, 4, and 5 bypass rates are sys_clk.
  Returns the current DPLL CLKOUT rate (not CLKOUTX2) if the DPLL is
  locked, or the appropriate bypass rate if the DPLL is bypassed, or 0
  if the clock @clk is not a DPLL.
 Return bypass rate if DPLL is bypassed 
 DPLL rate rounding code 
  omap2_dpll_round_rate - round a target rate for an OMAP DPLL
  @hw: struct clk_hw containing the struct clk  for a DPLL
  @target_rate: desired DPLL clock rate
  @parent_rate: parent's DPLL clock rate
  Given a DPLL and a desired target rate, round the target rate to a
  possible, programmable rate for this DPLL.  Attempts to select the
  minimum possible n.  Stores the computed (m, n) in the DPLL's
  dpll_data structure so set_rate() will not need to call this
  (expensive) function again.  Returns ~0 if the target rate cannot
  be rounded, or the rounded rate upon success.
 Is the (input clk, divider) pair valid for the DPLL? 
 Compute the scaled DPLL multiplier, based on the divider 
		
		  Since we're counting n up, a m overflow means we
		  can bail out completely (since as n increases in
		  the next iteration, there's no way that m can
		  increase beyond the current m)
 m can't be set low enough for this n - try with a larger n 
 skip rates above our target rate 
  AM33XX Clock init
  Copyright (C) 2013 Texas Instruments, Inc
      Tero Kristo (t-kristo@ti.com)
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
 AM3_L3_L3_MAIN_CLKCTRL, needed during suspend 
 Required for external peripherals like, Audio codecs 
	 TRM ERRATA: Timer 3 & 6 default parent (TCLKIN) may not be always
	     physically present, in such a case HWMOD enabling of
	     clock would be failure with default parent. And timer
	     probe thinks clock is already enabled, this leads to
	     crash upon accessing timer 3 & 6 registers in probe.
	     Fix by setting parent of both these timers to master
	     oscillator clock.
	
	  The On-Chip 32K RC Osc clock is not an accurate clock-source as per
	  the designspec, so as a result, for example, timer which supposed
	  to get expired @60Sec, but will expire somewhere ~@40Sec, which is
	  not expected by any use-case, so change WDT1 clock source to PRCM
	  32KHz clock.
  OMAP DPLL clock support
  Copyright (C) 2013 Texas Instruments, Inc.
  Tero Kristo <t-kristo@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  _register_dpll - low level registration of a DPLL clock
  @user: pointer to the hardware clock definition for the clock
  @node: device node for the clock
  Finalizes DPLL registration process. In case a failure (clk-ref or
  clk-bypass is missing), the clock is added to retry list and
  the initialization is retried on later stage.
 register the clock 
  _register_dpll_x2 - Registers a DPLLx2 clock
  @node: device node for this clock
  @ops: clk_ops for this clock
  @hw_ops: clk_hw_ops for this clock
  Initializes a DPLL x 2 clock from device tree data.
 Check if register defined, if not, drop hw-ops 
 register the clock 
  of_ti_dpll_setup - Setup function for OMAP DPLL clocks
  @node: device node containing the DPLL info
  @ops: ops for the DPLL
  @ddt: DPLL data template to use
  Initializes a DPLL clock from device tree data.
	
	  Special case for OMAP2 DPLL, register order is different due to
	  missing idlest_reg, also clkhwops is different. Detected from
	  missing idlest_mask.
 DCC beyond 1.4GHz 
  OMAP3 Clock init
  Copyright (C) 2013 Texas Instruments, Inc
      Tero Kristo (t-kristo@ti.com)
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
  In AM35xx IPSS, the {ICK,FCK} enable bits for modules are exported
  in the same register at a bit offset of 0x8. The EN_ACK for ICK is
  at an offset of 4 from ICK enable bit.
  omap3430es2_clk_ssi_find_idlest - return CM_IDLEST info for SSI
  @clk: struct clk  being enabled
  @idlest_reg: void __iomem  to store CM_IDLEST reg address into
  @idlest_bit: pointer to a u8 to store the CM_IDLEST bit shift into
  @idlest_val: pointer to a u8 to store the CM_IDLEST indicator
  The OMAP3430ES2 SSI target CM_IDLEST bit is at a different shift
  from the CM_{I,F}CLKEN bit.  Pass back the correct info via
  @idlest_reg and @idlest_bit.  No return value.
  omap3430es2_clk_dss_usbhost_find_idlest - CM_IDLEST info for DSS, USBHOST
  @clk: struct clk  being enabled
  @idlest_reg: void __iomem  to store CM_IDLEST reg address into
  @idlest_bit: pointer to a u8 to store the CM_IDLEST bit shift into
  @idlest_val: pointer to a u8 to store the CM_IDLEST indicator
  Some OMAP modules on OMAP3 ES2+ chips have both initiator and
  target IDLEST bits.  For our purposes, we are concerned with the
  target IDLEST bits, which exist at a different bit position than
  the CLKEN bit position for these modules (DSS and USBHOST) (The
  default find_idlest code assumes that they are at the same
  position.)  No return value.
 USBHOST_IDLE has same shift 
  omap3430es2_clk_hsotgusb_find_idlest - return CM_IDLEST info for HSOTGUSB
  @clk: struct clk  being enabled
  @idlest_reg: void __iomem  to store CM_IDLEST reg address into
  @idlest_bit: pointer to a u8 to store the CM_IDLEST bit shift into
  @idlest_val: pointer to a u8 to store the CM_IDLEST indicator
  The OMAP3430ES2 HSOTGUSB target CM_IDLEST bit is at a different
  shift from the CM_{I,F}CLKEN bit.  Pass back the correct info via
  @idlest_reg and @idlest_bit.  No return value.
  am35xx_clk_find_idlest - return clock ACK info for AM35XX IPSS
  @clk: struct clk  being enabled
  @idlest_reg: void __iomem  to store CM_IDLEST reg address into
  @idlest_bit: pointer to a u8 to store the CM_IDLEST bit shift into
  @idlest_val: pointer to a u8 to store the CM_IDLEST indicator
  The interface clocks on AM35xx IPSS reflects the clock idle status
  in the enable register itsel at a bit offset of 4 from the enable
  bit. A value of 1 indicates that clock is enabled.
  am35xx_clk_find_companion - find companion clock to @clk
  @clk: struct clk  to find the companion clock of
  @other_reg: void __iomem  to return the companion clock CM_CLKEN va in
  @other_bit: u8  to return the companion clock bit shift in
  Some clocks don't have companion clocks.  For example, modules with
  only an interface clock (such as HECC) don't have a companion
  clock.  Right now, this code relies on the hardware exporting a bit
  in the correct companion register that indicates that the
  nonexistent 'companion clock' is active.  Future patches will
  associate this type of code with per-module data structures to
  avoid this issue, and remove the casts.  No return value.
  am35xx_clk_ipss_find_idlest - return CM_IDLEST info for IPSS
  @clk: struct clk  being enabled
  @idlest_reg: void __iomem  to store CM_IDLEST reg address into
  @idlest_bit: pointer to a u8 to store the CM_IDLEST bit shift into
  @idlest_val: pointer to a u8 to store the CM_IDLEST indicator
  The IPSS target CM_IDLEST bit is at a different shift from the
  CM_{I,F}CLKEN bit.  Pass back the correct info via @idlest_reg
  and @idlest_bit.  No return value.
  omap3_clk_lock_dpll5 - locks DPLL5
  Locks DPLL5 to a pre-defined frequency. This is required for proper
  operation of USB.
	
	  Errata sprz319f advisory 2.1 documents a USB host clock drift issue
	  that can be worked around using specially crafted dpll5 settings
	  with a dpll5_m2 divider set to 8. Set the dpll5 rate to 8x the USB
	  host clock rate, its .set_rate handler() will detect that frequency
	  and use the errata settings.
 Program dpll5_m2_clk divider 
 SPDX-License-Identifier: GPL-2.0-only
  DRA7 Clock init
  Copyright (C) 2013 Texas Instruments, Inc.
  Tero Kristo (t-kristo@ti.com)
  TI composite clock support
  Copyright (C) 2013 Texas Instruments, Inc.
  Tero Kristo <t-kristo@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 Check for presence of each component clock 
 Mark this node as found 
 All components exists, proceed with registration 
 Free component clock list entries 
 Number of component clocks to be put inside this clock 
 Get device node pointers for each component clock 
  ti_clk_add_component - add a component clock to the pool
  @node: device node of the component clock
  @hw: hardware clock definition for the component clock
  @type: type of the component clock
  Adds a component clock to the list of available components, so that
  it can be registered by a composite clock.
  Default clock type
  Copyright (C) 2005-2008, 2015 Texas Instruments, Inc.
  Copyright (C) 2004-2010 Nokia Corporation
  Contacts:
  Richard Woodruff <r-woodruff2@ti.com>
  Paul Walmsley
  Tero Kristo <t-kristo@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  MAX_MODULE_ENABLE_WAIT: maximum of number of microseconds to wait
  for a module to indicate that it is no longer in idle
  CM module register offsets, used for calculating the companion
  register addresses.
  _wait_idlest_generic - wait for a module to leave the idle state
  @clk: module clock to wait for (needed for register offsets)
  @reg: virtual address of module IDLEST register
  @mask: value to mask against to determine if the module is active
  @idlest: idle state indicator (0 or 1) for the clock
  @name: name of the clock (for printk)
  Wait for a module to leave idle, where its idle-status register is
  not inside the CM module.  Returns 1 if the module left idle
  promptly, or 0 if the module did not leave idle before the timeout
  elapsed.  XXX Deprecated - should be moved into drivers for the
  individual IP block that the IDLEST register exists in.
 Wait until module enters enabled state 
  _omap2_module_wait_ready - wait for an OMAP module to leave IDLE
  @clk: struct clk  belonging to the module
  If the necessary clocks for the OMAP hardware IP block that
  corresponds to clock @clk are enabled, then wait for the module to
  indicate readiness (i.e., to leave IDLE).  This code does not
  belong in the clock code and will be moved in the medium term to
  module-dependent code.  No return value.
 Not all modules have multiple clocks that their IDLEST depends on 
 IDLEST register not in the CM module 
  omap2_clk_dflt_find_companion - find companion clock to @clk
  @clk: struct clk  to find the companion clock of
  @other_reg: void __iomem  to return the companion clock CM_CLKEN va in
  @other_bit: u8  to return the companion clock bit shift in
  Note: We don't need special code here for INVERT_ENABLE for the
  time being since INVERT_ENABLE only applies to clocks enabled by
  CM_CLKEN_PLL
  Convert CM_ICLKEN <-> CM_FCLKEN.  This conversion assumes it's
  just a matter of XORing the bits.
  Some clocks don't have companion clocks.  For example, modules with
  only an interface clock (such as MAILBOXES) don't have a companion
  clock.  Right now, this code relies on the hardware exporting a bit
  in the correct companion register that indicates that the
  nonexistent 'companion clock' is active.  Future patches will
  associate this type of code with per-module data structures to
  avoid this issue, and remove the casts.  No return value.
	
	  Convert CM_ICLKEN <-> CM_FCLKEN.  This conversion assumes
	  it's just a matter of XORing the bits.
  omap2_clk_dflt_find_idlest - find CM_IDLEST reg va, bit shift for @clk
  @clk: struct clk  to find IDLEST info for
  @idlest_reg: void __iomem  to return the CM_IDLEST va in
  @idlest_bit: u8  to return the CM_IDLEST bit shift in
  @idlest_val: u8  to return the idle status indicator
  Return the CM_IDLEST register address and bit shift corresponding
  to the module that "owns" this clock.  This default code assumes
  that the CM_IDLEST bit shift is the CM_CLKEN bit shift, and that
  the IDLEST register address ID corresponds to the CM_CLKEN
  register address ID (e.g., that CM_FCLKEN2 corresponds to
  CM_IDLEST2).  This is not true for all modules.  No return value.
	
	  24xx uses 0 to indicate not ready, and 1 to indicate ready.
	  34xx reverses this, just to keep us on our toes
	  AM35xx uses both, depending on the module.
  omap2_dflt_clk_enable - enable a clock in the hardware
  @hw: struct clk_hw  of the clock to enable
  Enable the clock @hw in the hardware.  We first call into the OMAP
  clockdomain code to "enable" the corresponding clockdomain if this
  is the first enabled user of the clockdomain.  Then program the
  hardware to enable the clock.  Then wait for the IP block that uses
  this clock to leave idle (if applicable).  Returns the error value
  from clkdm_clk_enable() if it terminated with an error, or -EINVAL
  if @hw has a null clock enable_reg, or zero upon success.
 FIXME should not have INVERT_ENABLE bit here 
 OCP barrier 
  omap2_dflt_clk_disable - disable a clock in the hardware
  @hw: struct clk_hw  of the clock to disable
  Disable the clock @hw in the hardware, and call into the OMAP
  clockdomain code to "disable" the corresponding clockdomain if all
  clockshwmods in that clockdomain are now disabled.  No return
  value.
 No OCP barrier needed here since it is a disable operation 
  omap2_dflt_clk_is_enabled - is clock enabled in the hardware?
  @hw: struct clk_hw  to check
  Return 1 if the clock represented by @hw is enabled in the
  hardware, or 0 otherwise.  Intended for use in the struct
  clk_ops.is_enabled function pointer.
 SPDX-License-Identifier: GPL-2.0-only
  DRA7 Clock init
  Copyright (C) 2013 Texas Instruments, Inc.
  Tero Kristo (t-kristo@ti.com)
  AM43XX Clock init
  Copyright (C) 2013 Texas Instruments, Inc
      Tero Kristo (t-kristo@ti.com)
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
 AM4_L3_L3_MAIN_CLKCTRL, needed during suspend 
	
	  cpsw_cpts_rft_clk  has got the choice of 3 clocksources
	  dpll_core_m4_ck, dpll_core_m5_ck and dpll_disp_m2_ck.
	  By default dpll_core_m4_ck is selected, witn this as clock
	  source the CPTS doesnot work properly. It gives clockcheck errors
	  while running PTP.
	  clockcheck: clock jumped backward or running slower than expected!
	  By selecting dpll_core_m5_ck as the clocksource fixes this issue.
	  In AM335x dpll_core_m5_ck is the default clocksource.
 SPDX-License-Identifier: GPL-2.0-only
  OMAP4-specific DPLL control functions
  Copyright (C) 2011 Texas Instruments, Inc.
  Rajendra Nayak
  Maximum DPLL input frequency (FINT) and output frequency (FOUT) that
  can supported when using the DPLL low-power mode. Frequencies are
  defined in OMAP443060 Public TRM section 3.6.3.3.2 "Enable Control,
  Status, and Low-Power Operation Mode".
  Bitfield declarations
 Static rate multiplier for OMAP4 REGM4XEN clocks 
 Clear the bit to allow gatectrl 
 Set the bit to deny gatectrl 
  omap4_dpll_lpmode_recalc - compute DPLL low-power setting
  @dd: pointer to the dpll data structure
  Calculates if low-power mode can be enabled based upon the last
  multiplier and divider values calculated. If low-power mode can be
  enabled, then the bit to enable low-power mode is stored in the
  last_rounded_lpmode variable. This implementation is based upon the
  criteria for enabling low-power mode as described in the OMAP443060
  Public TRM section 3.6.3.3.2 "Enable Control, Status, and Low-Power
  Operation Mode".
  omap4_dpll_regm4xen_recalc - compute DPLL rate, considering REGM4XEN bit
  @hw: pointer to the clock to compute the rate for
  @parent_rate: clock rate of the DPLL parent
  Compute the output rate for the OMAP4 DPLL represented by @clk.
  Takes the REGM4XEN bit into consideration, which is needed for the
  OMAP4 ABE DPLL.  Returns the DPLL's output rate (before M-dividers)
  upon success, or 0 upon error.
 regm4xen adds a multiplier of 4 to DPLL calculations 
  omap4_dpll_regm4xen_round_rate - round DPLL rate, considering REGM4XEN bit
  @hw: struct hw_clk containing the struct clk  of the DPLL to round a rate for
  @target_rate: the desired rate of the DPLL
  @parent_rate: clock rate of the DPLL parent
  Compute the rate that would be programmed into the DPLL hardware
  for @clk if set_rate() were to be provided with the rate
  @target_rate.  Takes the REGM4XEN bit into consideration, which is
  needed for the OMAP4 ABE DPLL.  Returns the rounded rate (before
  M-dividers) upon success, -EINVAL if @clk is null or not a DPLL, or
  ~0 if an error occurred in omap2_dpll_round_rate().
	
	  First try to compute the DPLL configuration for
	  target rate without using the 4X multiplier.
	
	  If we did not find a valid DPLL configuration, try again, but
	  this time see if using the 4X multiplier can help. Enabling the
	  4X multiplier is equivalent to dividing the target rate by 4.
  omap4_dpll_regm4xen_determine_rate - determine rate for a DPLL
  @hw: pointer to the clock to determine rate for
  @req: target rate request
  Determines which DPLL mode to use for reaching a desired rate.
  Checks whether the DPLL shall be in bypass or locked mode, and if
  locked, calculates the M,N values for the DPLL via round-rate.
  Returns 0 on success and a negative error value otherwise.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
 SPDX-License-Identifier: GPL-2.0-only
  OMAP34 - specific DPLL control functions
  Copyright (C) 2009-2010 Texas Instruments, Inc.
  Copyright (C) 2009-2010 Nokia Corporation
  Written by Paul Walmsley
  Testing and integration fixes by Jouni Högander
  36xx support added by Vishwanath BS, Richard Woodruff, and Nishanth
  Menon
  Parts of this code are based on code written by
  Richard Woodruff, Tony Lindgren, Tuukka Tikkanen, Karthik Dasu
 CM_AUTOIDLE_PLL.AUTO_ bit values 
 Forward declarations 
 Private functions 
 _omap3_dpll_write_clken - write clken_bits arg to a DPLL's enable bits 
 _omap3_wait_dpll_status: wait for a DPLL to enter a specific state 
 From 3430 TRM ES2 4.7.6.2 
  _omap3_noncore_dpll_lock - instruct a DPLL to lock and wait for readiness
  @clk: pointer to a DPLL struct clk
  Instructs a non-CORE DPLL to lock.  Waits for the DPLL to report
  readiness before returning.  Will save and restore the DPLL's
  autoidle state across the enable, per the CDP code.  If the DPLL
  locked successfully, return 0; if the DPLL did not lock in the time
  allotted, or DPLL3 was passed in, return -EINVAL.
 Check if already locked 
  _omap3_noncore_dpll_bypass - instruct a DPLL to bypass and wait for readiness
  @clk: pointer to a DPLL struct clk
  Instructs a non-CORE DPLL to enter low-power bypass mode.  In
  bypass mode, the DPLL's rate is set equal to its parent clock's
  rate.  Waits for the DPLL to report readiness before returning.
  Will save and restore the DPLL's autoidle state across the enable,
  per the CDP code.  If the DPLL entered bypass mode successfully,
  return 0; if the DPLL did not enter bypass in the time allotted, or
  DPLL3 was passed in, or the DPLL does not support low-power bypass,
  return -EINVAL.
  _omap3_noncore_dpll_stop - instruct a DPLL to stop
  @clk: pointer to a DPLL struct clk
  Instructs a non-CORE DPLL to enter low-power stop. Will save and
  restore the DPLL's autoidle state across the stop, per the CDP
  code.  If DPLL3 was passed in, or the DPLL does not support
  low-power stop, return -EINVAL; otherwise, return 0.
  _lookup_dco - Lookup DCO used by j-type DPLL
  @clk: pointer to a DPLL struct clk
  @dco: digital control oscillator selector
  @m: DPLL multiplier to set
  @n: DPLL divider to set
  See 36xx TRM section 3.5.3.3.3.2 "Type B DPLL (Low-Jitter)"
  XXX This code is not needed for 3430AM35xx; can it be optimized
  out in non-multi-OMAP builds for those chips?
 watch out for overflow 
  _lookup_sddiv - Calculate sigma delta divider for j-type DPLL
  @clk: pointer to a DPLL struct clk
  @sd_div: target sigma-delta divider
  @m: DPLL multiplier to set
  @n: DPLL divider to set
  See 36xx TRM section 3.5.3.3.3.2 "Type B DPLL (Low-Jitter)"
  XXX This code is not needed for 3430AM35xx; can it be optimized
  out in non-multi-OMAP builds for those chips?
 watch out for overflow 
	
	  target sigma-delta to near 250MHz
	  sd = ceil[(m(n+1))  (clkinp_MHz  250)]
 shift from MHz to 10Hz for 38.4 and 19.2 
  omap3_noncore_dpll_ssc_program - set spread-spectrum clocking registers
  @clk:	struct clk  of DPLL to set
  Enable the DPLL spread spectrum clocking if frequency modulation and
  frequency spreading have been set, otherwise disable it.
  omap3_noncore_dpll_program - set non-core DPLL M,N values directly
  @clk:	struct clk  of DPLL to set
  @freqsel:	FREQSEL value to set
  Program the DPLL with the last M, N values calculated, and wait for
  the DPLL to lock. Returns -EINVAL upon error, or 0 upon success.
 3430 ES2 TRM: 4.7.6.9 DPLL Programming Sequence 
	
	  Set jitter correction. Jitter correction applicable for OMAP343X
	  only since freqsel field is no longer present on other devices.
 Set DPLL multiplier, divider 
 Handle Duty Cycle Correction 
 Enable DCC 
 Disable DCC 
 Configure dco and sd_div for dplls that have these fields 
	
	  Errata i810 - DPLL controller can get stuck while transitioning
	  to a power saving state. Software must ensure the DPLL can not
	  transition to a low power state while changing MN values.
	  Easiest way to accomplish this is to prevent DPLL autoidle
	  before doing the MN re-program.
 OCP barrier 
 Set 4X multiplier and low-power mode 
 We let the clock framework set the other output dividers later 
 REVISIT: Set ramp-up delay? 
 Public functions 
  omap3_dpll_recalc - recalculate DPLL rate
  @hw: struct clk_hw containing the DPLL struct clk
  @parent_rate: clock rate of the DPLL parent
  Recalculate and propagate the DPLL rate.
 Non-CORE DPLL (e.g., DPLLs that do not control SDRC) clock functions 
  omap3_noncore_dpll_enable - instruct a DPLL to enter bypass or lock mode
  @hw: struct clk_hw containing then pointer to a DPLL struct clk
  Instructs a non-CORE DPLL to enable, e.g., to enter bypass or lock.
  The choice of modes depends on the DPLL's programmed rate: if it is
  the same as the DPLL's parent clock, it will enter bypass;
  otherwise, it will enter lock.  This code will wait for the DPLL to
  indicate readiness before returning, unless the DPLL takes too long
  to enter the target state.  Intended to be used as the struct clk's
  enable function.  If DPLL3 was passed in, or the DPLL does not
  support low-power stop, or if the DPLL took too long to enter
  bypass or lock, return -EINVAL; otherwise, return 0.
  omap3_noncore_dpll_disable - instruct a DPLL to enter low-power stop
  @hw: struct clk_hw containing then pointer to a DPLL struct clk
  Instructs a non-CORE DPLL to enter low-power stop.  This function is
  intended for use in struct clkops.  No return value.
 Non-CORE DPLL rate set code 
  omap3_noncore_dpll_determine_rate - determine rate for a DPLL
  @hw: pointer to the clock to determine rate for
  @req: target rate request
  Determines which DPLL mode to use for reaching a desired target rate.
  Checks whether the DPLL shall be in bypass or locked mode, and if
  locked, calculates the M,N values for the DPLL via round-rate.
  Returns a 0 on success, negative error value in failure.
  omap3_noncore_dpll_set_parent - set parent for a DPLL clock
  @hw: pointer to the clock to set parent for
  @index: parent index to select
  Sets parent for a DPLL clock. This sets the DPLL into bypass or
  locked mode. Returns 0 with success, negative error value otherwise.
  omap3_noncore_dpll_set_rate - set rate for a DPLL clock
  @hw: pointer to the clock to set parent for
  @rate: target rate for the clock
  @parent_rate: rate of the parent clock
  Sets rate for a DPLL clock. First checks if the clock parent is
  reference clock (in bypass mode, the rate of the clock can't be
  changed) and proceeds with the rate change operation. Returns 0
  with success, negative error value otherwise.
 Freqsel is available only on OMAP343X devices 
  omap3_noncore_dpll_set_rate_and_parent - set rate and parent for a DPLL clock
  @hw: pointer to the clock to set rate and parent for
  @rate: target rate for the DPLL
  @parent_rate: clock rate of the DPLL parent
  @index: new parent index for the DPLL, 0 - reference, 1 - bypass
  Sets rate and parent for a DPLL clock. If new parent is the bypass
  clock, only selects the parent. Otherwise proceeds with a rate
  change, as this will effectively also change the parent as the
  DPLL is put into locked mode. Returns 0 with success, negative error
  value otherwise.
	
	  clk-ref at index[0], in which case we only need to set rate,
	  the parent will be changed automatically with the lock sequence.
	  With clk-bypass case we only need to change parent.
 DPLL autoidle readset code 
  omap3_dpll_autoidle_read - read a DPLL's autoidle bits
  @clk: struct clk  of the DPLL to read
  Return the DPLL's autoidle bits, shifted down to bit 0.  Returns
  -EINVAL if passed a null pointer or if the struct clk does not
  appear to refer to a DPLL.
  omap3_dpll_allow_idle - enable DPLL autoidle bits
  @clk: struct clk  of the DPLL to operate on
  Enable DPLL automatic idle control.  This automatic idle mode
  switching takes effect only when the DPLL is locked, at least on
  OMAP3430.  The DPLL will enter low-power stop when its downstream
  clocks are gated.  No return value.
	
	  REVISIT: CORE DPLL can optionally enter low-power bypass
	  by writing 0x5 instead of 0x1.  Add some mechanism to
	  optionally enter this mode.
  omap3_dpll_deny_idle - prevent DPLL from automatically idling
  @clk: struct clk  of the DPLL to operate on
  Disable DPLL automatic idle control.  No return value.
 Clock control for DPLL outputs 
 Find the parent DPLL for the given clkoutx2 clock 
 Walk up the parents of clk, looking for a DPLL 
 clk does not have a DPLL as a parent?  error in the clock data 
  omap3_clkoutx2_recalc - recalculate DPLL X2 output virtual clock rate
  @hw: pointer  struct clk_hw
  @parent_rate: clock rate of the DPLL parent
  Using parent clock DPLL data, look up DPLL state.  If locked, set our
  rate to the dpll_clk  2; otherwise, just use dpll_clk.
  omap3_core_dpll_save_context - Save the m and n values of the divider
  @hw: pointer  struct clk_hw
  Before the dpll registers are lost save the last rounded rate m and n
  and the enable mask.
  omap3_core_dpll_restore_context - restore the m and n values of the divider
  @hw: pointer  struct clk_hw
  Restore the last rounded rate m and n
  and the enable mask.
  omap3_non_core_dpll_save_context - Save the m and n values of the divider
  @hw: pointer  struct clk_hw
  Before the dpll registers are lost save the last rounded rate m and n
  and the enable mask.
  omap3_core_dpll_restore_context - restore the m and n values of the divider
  @hw: pointer  struct clk_hw
  Restore the last rounded rate m and n
  and the enable mask.
 nothing to be done 
 OMAP34 non-CORE DPLL clkops 
  omap3_dpll4_set_rate - set rate for omap3 per-dpll
  @hw: clock to change
  @rate: target rate for clock
  @parent_rate: clock rate of the DPLL parent
  Check if the current SoC supports the per-dpll reprogram operation
  or not, and then do the rate change if supported. Returns -EINVAL
  if not supported, 0 for success, and potential error codes from the
  clock rate change.
	
	  According to the 12-5 CDP code from TI, "Limitation 2.5"
	  on 3430ES1 prevents us from changing DPLL multipliers or dividers
	  on DPLL4.
  omap3_dpll4_set_rate_and_parent - set rate and parent for omap3 per-dpll
  @hw: clock to change
  @rate: target rate for clock
  @parent_rate: rate of the parent clock
  @index: parent index, 0 - reference clock, 1 - bypass clock
  Check if the current SoC support the per-dpll reprogram operation
  or not, and then do the rate + parent change if supported. Returns
  -EINVAL if not supported, 0 for success, and potential error codes
  from the clock rate change.
 Apply DM3730 errata sprz319 advisory 2.1. 
		
		  From DM3730 errata advisory 2.1, table 35 and 36.
		  The N value is increased by 1 compared to the tables as the
		  errata lists register values while last_rounded_field is the
		  real divider value.
 Update the M, N and rounded rate values and program the DPLL. 
  omap3_dpll5_set_rate - set rate for omap3 dpll5
  @hw: clock to change
  @rate: target rate for clock
  @parent_rate: rate of the parent clock
  Set rate for the DPLL5 clock. Apply the sprz319 advisory 2.1 on OMAP36xx if
  the DPLL is used for USB host (detected through the requested rate).
  OMAP clkctrl clock support
  Copyright (C) 2017 Texas Instruments, Inc.
  Tero Kristo <t-kristo@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 These timeouts are in us 
	
	  There are two special cases where ktime_to_ns() can't be
	  used to track the timeouts. First one is during early boot
	  when the timers haven't been initialized yet. The second
	  one is during suspend-resume cycle while timekeeping is
	  being suspended  resumed. Clocksource for the system
	  can be from a timer that requires pm_runtime access, which
	  will eventually bring us here with timekeeping_suspended,
	  during both suspend entry and resume paths. This happens
	  at least on am43xx platform. Account for flakeyness
	  with udelay() by multiplying the timeout value by 2.
 Wait until module is enabled 
 Wait until module is disabled 
 Get clkctrl clock base name based on clkctrl_name or dts node 
 l4per-clkctrl:1234:0 style naming based on clkctrl_name 
 l4per:1234:0 old style naming based on clkctrl_name 
 l4per_cm:1234:0 old style naming based on parent node name 
 l4per-clkctrl:1234:0 style naming based on node name 
 Get clock name based on compatible string for clkctrl 
 Two letter minimum name length for l3, l4 etc 
	
	  The code below can be removed when all clkctrl nodes use domain
	  specific compatible proprerty and standard clock node naming
		
		  Create default clkdm name, replace _cm from end of parent
		  node name with _clkdm
		
		  Create default clkdm name, replace _clkctrl from end of
		  node name with _clkdm
 Replace any dash from the clkdm name with underscore 
 Generate clocks 
  ti_clk_is_in_standby - Check if clkctrl clock is in standby or not
  @clk: clock to check standby status for
  Finds whether the provided clock is in standby mode or not. Returns
  true if the provided clock is a clkctrl type clock and it is in standby,
  false otherwise.
  TI Divider Clock
  Copyright (C) 2013 Texas Instruments, Inc.
  Tero Kristo <t-kristo@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  The reverse of DIV_ROUND_UP: The maximum number which
  divided by m is r
	
	  The maximum divider we can use without overflowing
	  unsigned long in rate  i below
			
			  It's the most ideal case if the requested rate can be
			  divided from parent clock without needing to change
			  parent rate, so return the divider immediately.
  clk_divider_save_context - Save the divider value
  @hw: pointer  struct clk_hw
  Save the divider value
  clk_divider_restore_context - restore the saved the divider value
  @hw: pointer  struct clk_hw
  Restore the saved the divider value
 register the clock 
 Determine required size for divider table 
 Clk divider table not provided, determine minmax divs 
  of_ti_divider_clk_setup - Setup function for simple div rate clock
  @node: device node for this clock
  Sets up a basic divider clock.
 SPDX-License-Identifier: GPL-2.0-only
 MPU 481c5040.adpll.clkout 
 DDR 481c5290.adpll.clkout 
  OMAP interface clock support
  Copyright (C) 2013 Texas Instruments, Inc.
  Tero Kristo <t-kristo@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  OMAP clockdomain support
  Copyright (C) 2013 Texas Instruments, Inc.
  Tero Kristo <t-kristo@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  omap2_clkops_enable_clkdm - increment usecount on clkdm of @hw
  @hw: struct clk_hw  of the clock being enabled
  Increment the usecount of the clockdomain of the clock pointed to
  by @hw; if the usecount is 1, the clockdomain will be "enabled."
  Only needed for clocks that don't use omap2_dflt_clk_enable() as
  their enable function pointer.  Passes along the return value of
  clkdm_clk_enable(), -EINVAL if @hw is not associated with a
  clockdomain, or 0 if clock framework-based clockdomain control is
  not implemented.
  omap2_clkops_disable_clkdm - decrement usecount on clkdm of @hw
  @hw: struct clk_hw  of the clock being disabled
  Decrement the usecount of the clockdomain of the clock pointed to
  by @hw; if the usecount is 0, the clockdomain will be "disabled."
  Only needed for clocks that don't use omap2_dflt_clk_disable() as their
  disable function pointer.  No return value.
  omap2_init_clk_clkdm - look up a clockdomain name, store pointer in clk
  @hw: Pointer to clk_hw_omap used to obtain OMAP clock struct ptr to use
  Convert a clockdomain name stored in a struct clk 'clk' into a
  clockdomain pointer, and save it into the struct clk.  Intended to be
  called during clk_register(). Returns 0 on success, -EERROR otherwise.
  ti_dt_clockdomains_setup - setup device tree clockdomains
  Initializes clockdomain nodes for a SoC. This parses through all the
  nodes with compatible = "ti,clockdomain", and add the clockdomain
  info for all the clocks listed under these. This function shall be
  called after rest of the DT clock init has completed and all
  clock nodes have been registered.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2012 Sascha Hauer <kernel@pengutronix.de>
 default 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2012-2013 Freescale Semiconductor, Inc.
 sources for multiplexer clocks, this is used multiple times 
 FTM counter clock source, not module clock 
 Backward compatibility if device tree is missing clks assignments 
 Clock source from external clock via LVDs PAD 
 Do not bypass PLLs initially 
	
	  ftm_ext_clk and ftm_fix_clk are FTM timer counter's
	  selectable clock sources, both use a common enable bit
	  in CCM_CSCDR1, selecting "dummy" clock as parent of
	  "ftm0_ext_fix" make it serve only for enabledisable.
 ftm(n)_clk are FTM module operation clock 
 Add the clocks to provider list 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2015 Freescale Semiconductor, Inc.
 epdc_pre_sels, epdc_sels, esai_sels only exists on i.MX6ULL 
 ipp_di clock is external input 
 Do not bypass PLLs initially 
	
	  Bit 20 is the reserved and read-only bit, we do this only for:
	  - Do nothing for usbphy clk_enabledisable
	  - Keep refcount when do usbphy clk_enabledisable, in that case,
	  the clk framework many need to enabledisable usbphy's parent
	
	  usbphy_gate needs to be on after system boots up, and software
	  never needs to control it anymore.
					name		   parent_name	   reg		idx 
						   name		parent_name	 mult  div 
 CCGR0 
 CCGR1 
 CCGR2 
 CCGR3 
	
	  Although the imx6ull reference manual lists CCGR2 as the csi clk
	  gate register, tests have shown that it is actually the CCGR3
	  register bit 01, same as for the imx6ul.
 CCGR4 
 CCGR5 
 CCGR6 
 CCOSR 
 mask handshake of mmdc 
	
	  Lower the AHB clock rate before changing the parent clock source,
	  as AHB clock rate can NOT be higher than 133MHz, but its parent
	  will be switched from 396MHz PFD to 528MHz PLL in order to increase
	  AXI clock rate, so we need to lower AHB rate first to make sure at
	  any time, AHB rate is <= 133MHz.
 Change periph_pre clock to pll2_bus to adjust AXI rate to 264MHz 
 Make sure AHB rate is 132MHz  
 set perclk to from OSC 
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2021 NXP
 Set to imx_ccm_lock to protect register access shared with clock control 
 CGC1 
 CGC2 
 PCC3 
 register the pcc3 reset controller 
 PCC4 
 sai ipg, NOT from sai sel 
 sai ipg 
 register the pcc4 reset controller 
 PCC5 
 register the pcc5 reset controller 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0
  This fixups the register CCM_CSCMR1 write value.
  The writereaddivider values of the aclk_podf field
  of that register have the relationship described by
  the following table:
  write value       read value        divider
  3b'000            3b'110            7
  3b'001            3b'111            8
  3b'010            3b'100            5
  3b'011            3b'101            6
  3b'100            3b'010            3
  3b'101            3b'011            4
  3b'110            3b'000            1
  3b'111            3b'001            2(default)
  That's why we do the xor operation below.
 i.MX boards use device trees now.  For build tests without CONFIG_OF, do nothing 
 Stop if there are no more of_stdout references 
 Only enable the clock if it's not NULL 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2013 Freescale Semiconductor, Inc.
  struct clk_fixup_mux - imx integer fixup multiplexer clock
  @mux: the parent class
  @ops: pointer to clk_ops of parent class
  @fixup: a hook to fixup the write value
  The imx fixup multiplexer clock is a subclass of basic clk_mux
  with an addtional fixup hook.
 SPDX-License-Identifier: GPL-2.0
  pll v1
  @clk_hw	clock source
  @parent	the parent clock name
  @base	base address of pll registers
  PLL clock version 1, found on i.MX12125273135
	
	  Get the resulting clock rate from a PLL register value and the input
	  frequency. PLLs with this register layout can be found on i.MX1,
	  i.MX21, i.MX27 and i,MX31
	 
	                   mfi + mfn  (mfd + 1)
	   f = 2  f_ref  --------------------
	                         pd + 1
	
	  On all i.MXs except i.MX1 and i.MX21 mfn is a 10bit
	  2's complements number.
	  On i.MX27 the bit 9 is the sign bit.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2019 NXP.
 CORE SEL 
 Sentinel  }
		
		  Disable bind attributes: clocks are not removed and
		  reloading the driver will crash or break devices.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2011-2013 Freescale Semiconductor, Inc.
  Copyright 2011 Linaro Ltd.
 sentinel  }
 sentinel  }
 sentinel  }
 skip empty (null) phandles 
 PLL6 bypass is not part of the assigned clock list 
  The only way to disable the MMDC_CH1 clock is to move it to pll3_sw_clk
  via periph2_clk2_sel and then to disable pll3_sw_clk by selecting the
  bypass clock source, since there is no CG bit for mmdc_ch1.
 Disable pll3_sw_clk by selecting the bypass clock source 
 Enable pll3_sw_clk by disabling the bypass 
  We have to follow a strict procedure when changing the LDB clock source,
  otherwise we risk introducing a glitch that can lock up the LDB divider.
  Things to keep in mind:
  1. The current and new parent clock inputs to the mux must be disabled.
  2. The default clock input for ldb_di01_clk_sel is mmdc_ch1_axi, which
     has no CG bit.
  3. pll2_pfd2_396m can not be gated if it is used as memory clock.
  4. In the RTL implementation of the LDB_DI_CLK_SEL muxes the top four
     options are in one mux and the PLL3 option along with three unused
     inputs is in a second mux. There is a third mux with two inputs used
     to decide between the first and second 4-port mux:
     pll5_video_div 0 --|\
     pll2_pfd0_352m 1 --| |_
     pll2_pfd2_396m 2 --| | `-|\
     mmdc_ch1_axi   3 --|    | |
                              | |--
     pll3_usb_otg   4 --|\    | |
                    5 --| |_,-|
                    6 --| |
                    7 --|
  The ldb_di01_clk_sel[1:0] bits control both 4-port muxes at the same time.
  The ldb_di01_clk_sel[2] bit controls the 2-port mux. The code below
  switches the parent to the bottom mux first and then manipulates the top
  mux to ensure that no glitch will enter the divider.
 Print a notice if a glitch might have been introduced already 
 Only switch to or from pll2_pfd2_396m if it is disabled 
 First switch to the bottom mux 
 Then configure the top mux before switching back to it 
 Make sure PLL2 PFDs 0-2 are gated 
 Cannot gate PFD2 if pll2_pfd2_396m is the parent of MMDC clock 
 Make sure PLL3 PFDs 0-3 are gated 
 Make sure PLL5 is disabled 
 Clock source from external clock via CLK12 PADs 
 Audiovideo PLL post dividers do not work on i.MX6q revision 1.0 
                                    type               name    parent_name        base         div_mask 
 Do not bypass PLLs initially 
	
	  Bit 20 is the reserved and read-only bit, we do this only for:
	  - Do nothing for usbphy clk_enabledisable
	  - Keep refcount when do usbphy clk_enabledisable, in that case,
	  the clk framework may need to enabledisable usbphy's parent
	
	  usbphy_gate needs to be on after system boots up, and software
	  never needs to control it anymore.
	
	  The ENET PLL is special in that is has multiple outputs with
	  different post-dividers that are all affected by the single bypass
	  bit, so a single mux bit affects 3 independent branches of the clock
	  tree. There is no good way to model this in the clock framework and
	  dynamically changing the bypass bit, will yield unexpected results.
	  So we treat any configuration that bypasses the ENET PLL as
	  essentially static with the divider ratios reflecting the bypass
	  status.
	 
	
	  lvds1_gate and lvds2_gate are pseudo-gates.  Both can be
	  independently configured as clock inputs or outputs.  We treat
	  the "output_enable" bit as a gate, even though it's really just
	  enabling clock output. Initially the gate bits are cleared, as
	  otherwise the exclusive configuration gets locked in the setup done
	  by software running before the clock driver, with no way to change
	  it.
                                            name              parent_name        reg       idx 
                                                name         parent_name     mult div 
                                              name                reg       shift width parent_names     num_parents 
		
		  The LDB_DI01_SEL muxes are registered read-only due to a hardware
		  bug. Set the muxes to the requested values before registering the
		  ldb_di_sel clocks.
                                          name         reg      shift width busy: reg, shift parent_names  num_parents 
                                                  name                parent_name          reg       shift width 
                                                        name                 parent_name    reg        shift width busy: reg, shift 
                                            name             parent_name          reg         shift 
		
		  The multiplexer and divider of the imx6q clock gpu2d get
		  redefinedreused as mlb_sys_sel and mlb_sys_clk_podf on imx6dl.
	
	  The gpt_3m clock is not available on i.MX6Q TO1.0.  Let's point it
	  to clock gpt_ipg_per to ease the gpt driver code.
	
	  The gpmi needs 100MHz frequency in the EDOSync mode,
	  We can not get the 100MHz from the pll2_pfd0_352m.
	  So choose pll2_pfd2_396m as enfc_sel's parent.
	
	  Let's initially set up CLKO with OSC24M, since this configuration
	  is widely used by imx6q board designs to clock audio codec.
 Audio-related clocks configuration 
 All existing boards with PCIe use LVDS1 
	
	  Initialize the GPU clock muxes, so that the maximum specified clock
	  rates for the respective SoC are not exceeded.
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2018 NXP
 	Dong Aisheng <aisheng.dong@nxp.com>
  struct clk_lpcg_scu - Description of LPCG clock
  @hw: clk_hw of this LPCG
  @reg: register of this LPCG clock
  @bit_idx: bit index of this LPCG clock
  @hw_gate: HW auto gate enable
  This structure describes one LPCG clock
 for state save&restore 
	
	  FIXME: Sometimes writes don't work unless the CPU issues
	  them twice
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2019-2021 NXP
 	Dong Aisheng <aisheng.dong@nxp.com>
 Keep sorted in the ascending order 
 SPDX-License-Identifier: GPL-2.0
 Register offsets 
 default 
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2018-2021 NXP
 	Dong Aisheng <aisheng.dong@nxp.com>
 ARM core 
 LSIO SS 
 DMA SS 
 Audio SS 
 Connectivity 
 Display controller SS 
 MIPI-LVDS SS 
 MIPI CSI SS 
 Parallel Interface SS 
 GPU SS 
 CM40 SS 
 CM41 SS 
 HDMI TX SS 
 HDMI RX SS 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2018-2021 NXP
    Dong Aisheng <aisheng.dong@nxp.com>
  struct clk_scu - Description of one SCU clock
  @hw: the common clk_hw
  @rsrc_id: resource ID of this SCU clock
  @clk_type: type of this clock resource
 for state save&restore 
  struct clk_gpr_scu - Description of one SCU GPR clock
  @hw: the common clk_hw
  @rsrc_id: resource ID of this SCU clock
  @gpr_id: GPR ID index to control the divider
  struct imx_sc_msg_req_set_clock_rate - clock set rate protocol
  @hdr: SCU protocol header
  @rate: rate to set
  @resource: clock resource to set rate
  @clk: clk type of this resource
  This structure describes the SCU protocol of clock rate set
  struct imx_sc_msg_get_clock_rate - clock get rate protocol
  @hdr: SCU protocol header
  @req: get rate request protocol
  @resp: get rate response protocol
  This structure describes the SCU protocol of clock rate get
  struct imx_sc_msg_get_clock_parent - clock get parent protocol
  @hdr: SCU protocol header
  @req: get parent request protocol
  @resp: get parent response protocol
  This structure describes the SCU protocol of clock get parent
  struct imx_sc_msg_set_clock_parent - clock set parent protocol
  @hdr: SCU protocol header
  @req: set parent request protocol
  This structure describes the SCU protocol of clock set parent
  struct imx_sc_msg_req_clock_enable - clock gate protocol
  @hdr: SCU protocol header
  @resource: clock resource to gate
  @clk: clk type of this resource
  @enable: whether gate off the clock
  @autog: HW auto gate enable
  This structure describes the SCU protocol of clock gate
 pd_np will be used to attach power domains later 
  clk_scu_recalc_rate - Get clock rate for a SCU clock
  @hw: clock to get rate for
  @parent_rate: parent rate provided by common clock framework, not used
  Gets the current clock rate of a SCU clock. Returns the current
  clock rate, or zero in failure.
  clk_scu_round_rate - Round clock rate for a SCU clock
  @hw: clock to round rate for
  @rate: rate to round
  @parent_rate: parent rate provided by common clock framework, not used
  Returns the current clock rate, or zero in failure.
	
	  Assume we support all the requested rate and let the SCU firmware
	  to handle the left work
 CPU frequency scaling can ONLY be done by ARM-Trusted-Firmware 
  clk_scu_set_rate - Set rate for a SCU clock
  @hw: clock to change rate for
  @rate: target rate for the clock
  @parent_rate: rate of the clock parent, not used for SCU clocks
  Sets a clock frequency for a SCU clock. Returns the SCU
  protocol status.
  clk_scu_prepare - Enable a SCU clock
  @hw: clock to enable
  Enable the clock at the DSC slice level
  clk_scu_unprepare - Disable a SCU clock
  @hw: clock to enable
  Disable the clock at the DSC slice level
	
	  Note on MX8, the clocks are tightly coupled with power domain
	  that once the power domain is off, the clock status may be
	  lost. So we make it NOCACHE to let user to retrieve the real
	  clock status from HW instead of using the possible invalid
	  cached rate.
 DC SS needs to handle bypass clock using non-cached clock rate 
 For API backwards compatiblilty, simply return NULL for success 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2009 by Sascha Hauer, Pengutronix
 CCM_CGCR0(17): reserved 
 CCM_CGCR0(29-31): reserved 
 CCM_CGCR1(0): reserved in datasheet, used as audmux in FSL kernel 
 CCM_CGCR1(12): reserved in datasheet, used as esai in FSL kernel 
 CCM_CGCR1(16): reserved in datasheet, used as gpio1 in FSL kernel 
 CCM_CGCR1(17): reserved in datasheet, used as gpio2 in FSL kernel 
 CCM_CGCR1(18): reserved in datasheet, used as gpio3 in FSL kernel 
 CCM_CGCR1(23): reserved in datasheet, used as i2c1 in FSL kernel 
 CCM_CGCR1(24): reserved in datasheet, used as i2c2 in FSL kernel 
 CCM_CGCR1(25): reserved in datasheet, used as i2c3 in FSL kernel 
 CCM_CGCR1(27): reserved in datasheet, used as iomuxc in FSL kernel 
 CCM_CGCR1(28): reserved in datasheet, used as kpp in FSL kernel 
 CCM_CGCR1(30): reserved in datasheet, used as owire in FSL kernel 
 CCM_CGCR2(4): reserved in datasheet, used as rtic in FSL kernel 
 CCM_CGCR2(19): reserved in datasheet, but used as wdt in FSL kernel 
 Clock source for gpt must be derived from AHB 
	
	  Let's initially set up CLKO parent as ipg, since this configuration
	  is used on some imx25 board designs to clock the audio codec.
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2019-2021 NXP
 	Dong Aisheng <aisheng.dong@nxp.com>
 Keep sorted in the ascending order 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2012 Freescale Semiconductor, Inc.
  Copyright 2012 Linaro Ltd.
  struct clk_pfd - IMX PFD clock
  @hw:		clock source
  @reg:	PFD register address
  @idx:	the index of PFD encoded in the register
  PFD clock found on i.MX6 series.  Each register for PFD has 4 clk_pfd
  data encoded, and member idx is used to specify the one.  And each
  register has SET, CLR and TOG registers at offset 0x4 0x8 and 0xc.
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2016 Freescale Semiconductor, Inc.
  Copyright 2017~2018 NXP
  Author: Dong Aisheng <aisheng.dong@nxp.com>
  struct clk_pfdv2 - IMX PFD clock
  @hw:		clock source
  @reg:	PFD register address
  @gate_bit:	Gate bit offset
  @vld_bit:	Valid bit offset
  @frac_off:	PLL Fractional Divider offset
	
	  PFD can NOT change rate without gating.
	  as the PFDs may enabled in HW by default but no
	  consumer used it, the enable count is '0', so the
	  'SET_RATE_GATE' can NOT help on blocking the set_rate
	  ops especially for 'assigned-clock-xxx'. In order
	  to simplify the case, just disable the PFD if it is
	  enabled in HW but not in SW.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2011 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
 Low-power Audio Playback Mode clock 
 This is used multiple times 
 dptc_core , "dummy"
 wrck_clk_root ,
 pll1_ref_clk ,
 ddr_clk_root ,
 arm_axi_clk_root , "dummy"
 lpsr_clk_root , "dummy"
 tve_out , "usb_phy_sel",
 spdif0_clk_root ,
 usbphy2_clk , "dummy" 
 move usb phy clk to 24MHz 
	
	  This clock is called periph_clk in the i.MX50 Reference Manual, but
	  it comes closest in scope to the main_bus_clk of i.MX51 and i.MX53
 Set SDHC parents to be PLL2 
 set SDHC root clock to 200MHZ
 set the usboh3 parent to pll2_sw 
 Set SDHC parents to be PLL2 
 set SDHC root clock to 166.25MHZ
	
	  Reference Manual says: Functionality of CCDR[18] and CLPCR[23] is no
	  longer supported. Set to one for better power saving.
	 
	  The effect of not setting these bits is that MIPI clocks can't be
	  enabled without the IPU clock being enabled aswell.
 Set SDHC parents to be PLL2 
 set SDHC root clock to 200MHZ
 move can bus clk to 24MHz 
 make sure step clock is running from 24MHz 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2014 Freescale Semiconductor, Inc.
 ipp_di clock is external input 
 Clock source from external clock via CLK12 PAD 
                                    type               name    parent_name        base         div_mask 
 Do not bypass PLLs initially 
	
	  Bit 20 is the reserved and read-only bit, we do this only for:
	  - Do nothing for usbphy clk_enabledisable
	  - Keep refcount when do usbphy clk_enabledisable, in that case,
	  the clk framework may need to enabledisable usbphy's parent
	
	  usbphy_gate needs to be on after system boots up, and software
	  never needs to control it anymore.
 FIXME 100MHz is used for pcie ref for all imx6 pcie, excepted imx6q 
                                       name              parent_name     reg           idx 
                                                name         parent_name       mult div 
                                                name                reg           shift   width   parent_names       num_parents 
                                                name                reg           shift   width   parent_names       num_parents 
                                                    name              parent_name          reg          shift width 
                                               name        reg          shift width busy: reg,   shift parent_names       num_parents 
                                                   name             parent_name    reg          shift width busy: reg,   shift 
                                            name             parent_name          reg         shift 
 CCGR0 
 CCGR1 
 CCGR2 
 CCGR3 
 CCGR4 
 CCGR5 
 CCGR6 
 mask handshake of mmdc 
 Set the default 132MHz for EIM module 
 set parent clock for LCDIF1 pixel clock 
 Set the parent clks of PCIe lvds1 and pcie_axi to be pcie ref, axi 
	
	  Init enet system AHB clock, set to 200MHz
	  pll2_pfd2_396m-> ENET_PODF-> ENET_AHB
 Audio clocks 
 Set parent clock for vadc 
 default parent of can_sel clock is invalid, manually set it here 
 Update gpu clock from default 528M to 720M 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2018 NXP.
  This driver supports the fractional plls found in the imx8m SOCs
  Documentation for this fractional pll can be found at:
    https:www.nxp.comdocsenreference-manualIMX8MDQLQRM.pdf#page=834
 return directly if the pll is in powerdown or in bypass 
 Wait for the pll's divfi and divff to be reloaded 
  To simplify the clock calculation, we can keep the 'PLL_OUTPUT_VAL' at zero
  (means the PLL output will be divided by 2). So the PLL output can use
  the below formula:
  pllout = parent_rate  8  2  DIVF_VAL;
  where DIVF_VAL = 1 + DIVFI + DIVFF  2^24.
 Set the NEV_DIV_VAL to reload the DIVFI and DIVFF 
 clear the NEV_DIV_VAL 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2018 NXP.
  Copyright (C) 2017 Pengutronix, Lucas Stach <kernel@pengutronix.de>
 CCM ROOT 
 PLL bypass out 
 PLL OUT GATE 
 SYS PLL1 fixed output 
 SYS PLL2 fixed output 
 CORE 
 For backwards compatibility 
 CORE SEL 
 BUS 
 AHB 
 AHB clock is used by the AHB bus therefore marked as critical 
 IPG 
	
	  DRAM clocks are manipulated from TF-A outside clock framework.
	  The fw_managed helper sets GET_RATE_NOCACHE and clears SET_PARENT_GATE
	  as div value should always be read from hardware
 IP 
 Sentinel  },
		
		  Disable bind attributes: clocks are not removed and
		  reloading the driver will crash or break devices.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
 use old gpt clk setting, gpt1 root clk must be twice as gpt counter freq 
 Set clock rate for USBPHY, the USB_PLL at CCM is from USBOTG2 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2013-2014 Freescale Semiconductor, Inc.
  ERR005311 CCM: After exit from WAIT mode, unwanted interrupt(s) taken
            during WAIT mode entry process could cause cache memory
            corruption.
  Software workaround:
      To prevent this issue from occurring, software should ensure that the
  ARM to IPG clock ratio is less than 12:5 (that is < 2.4x), before
  entering WAIT mode.
  This function will set the ARM clk to max value within the 12:5 limit.
  As IPG clock is fixed at 66MHz(so ARM freq must not exceed 158.4MHz),
  ARM freq are one of below setpoints: 396MHz, 792MHz and 996MHz, since
  the clk APIs can NOT be called in idle thread(may cause kernel schedule
  as there is sleep function in PLL wait function), so here we just slow
  down ARM to below freq according to previous freq:
  run mode      wait mode
  396MHz   ->   132MHz;
  792MHz   ->   158.4MHz;
  996MHz   ->   142.3MHz;
	
	  According to hardware design, arm podf change need
	  PLL1 clock enabled.
 Clock source from external clock via CLK1 PAD 
                                    type               name    parent_name        base         div_mask 
 Do not bypass PLLs initially 
	
	  usbphy1 and usbphy2 are implemented as dummy gates using reserve
	  bit 20.  They are used by phy driver to keep the refcount of
	  parent PLL correct. usbphy1_gate and usbphy2_gate only needs to be
	  turned on during boot, and software will not need to control it
	  anymore after that.
                                                           dev   name              parent_name      flags                reg        shift width div: flags, div_table lock 
                                       name         parent_name     reg           idx 
                                                name         parent_name     mult div 
                                              name                reg       shift width parent_names     num_parents 
                                          name       reg        shift width busy: reg, shift parent_names  num_parents 
                                                   name                 parent_name          reg       shift width 
                                                name         parent_name reg       shift width busy: reg, shift 
                                            name            parent_name          reg         shift 
 Ensure the MMDC CH0 handshake is bypassed 
 Ensure the AHB clk is at 132MHz. 
 Audio-related clocks configuration 
 set PLL5 video as lcdif pix parent clock 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2016 Freescale Semiconductor, Inc.
  Copyright 2017-2018 NXP.
 ipp_di clock is external input 
 Do not bypass PLLs initially 
	
	  Bit 20 is the reserved and read-only bit, we do this only for:
	  - Do nothing for usbphy clk_enabledisable
	  - Keep refcount when do usbphy clk_enabledisable, in that case,
	  the clk framework many need to enabledisable usbphy's parent
	
	  usbphy_gate needs to be on after system boots up, and software
	  never needs to control it anymore.
					name		   parent_name	   reg		idx 
						   name		parent_name	 mult  div 
 CCGR0 
 CCGR1 
 CCGR2 
 CCGR3 
 CCGR4 
 CCGR5 
 CCGR6 
 mask handshake of mmdc 
 Lower the AHB clock rate before changing the clock source. 
 Change periph_pre clock to pll2_bus to adjust AXI rate to 264MHz 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2016 Freescale Semiconductor, Inc.
  Copyright 2017~2018 NXP
  Author: Dong Aisheng <aisheng.dong@nxp.com>
 PLL Control Status Register (xPLLCSR) 
 PLL Configuration Register (xPLLCFG) 
 PLL Numerator Register (xPLLNUM) 
 PLL Denominator Register (xPLLDENOM) 
 Valid PLL MULT Table 
	
	  NOTE: The value of numerator must always be configured to be
	  less than the value of the denominator. If we can't get a proper
	  pair of mfnmfd, we simply return the round_rate without using
	  the frac part.
 check if mult is in valid MULT table 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014 Lucas Stach <l.stach@pengutronix.de>, Pengutronix
 switch to PLL bypass clock 
 reprogram PLL 
 switch back to PLL clock 
 Ensure the divider is what we expect 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2012 Freescale Semiconductor, Inc.
  Copyright 2012 Linaro Ltd.
  struct clk_pllv3 - IMX PLL clock version 3
  @hw:		clock source
  @base:	 base address of PLL registers
  @power_bit:	 pll power bit mask
  @powerup_set: set power_bit to power up the PLL
  @div_mask:	 mask of divider bits
  @div_shift:	 shift of divider bits
  @ref_clock:	reference clock rate
  @num_offset:	num register offset
  @denom_offset: denom register offset
  IMX PLL clock version 3, found on i.MX6 series.  Divider for pllv3
  is actually a multiplier, and always sits at bit 0.
 No need to wait for lock when pll is not powered up 
 integer part, can be 20 or 22 
 numerator, 30-bit value 
 denominator, 30-bit value, must be less than mfn 
 use max supported value for best accuracy 
 rate = parent_rate  (mfi + mfnmfd) 
 clear bit for mfi=20 
 set bit for mfi=22 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2017-2018 NXP.
 Assumming rate_table is in descending order 
 return minimum supported value 
 fvco = (m  65536 + k)  Fin  (p  65536) 
 Bypass clock and set lock to pll output lock 
 Enable RST 
 Enable BYPASS 
	
	  According to SPEC, t3 - t2 need to be greater than
	  1us and 1FREF, respectively.
	  FREF is FIN  Prediv, the prediv is [1, 63], so choose
	  3us.
 Disable RST 
 Wait Lock 
 Bypass 
 Enable RST 
 Enable BYPASS 
	
	  According to SPEC, t3 - t2 need to be greater than
	  1us and 1FREF, respectively.
	  FREF is FIN  Prediv, the prediv is [1, 63], so choose
	  3us.
 Disable RST 
 Wait Lock
 Bypass 
	
	  RESETB = 1 from 0, PLL starts its normal
	  operation after lock time
	
	  Set RST to 0, power down mode is enabled and
	  every digital block is reset
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2018 NXP.
    Dong Aisheng <aisheng.dong@nxp.com>
 restore div val 
 store the current div val 
  NOTE: In order to reuse the most code from the common divider,
  we also design our divider following the way that provids an extra
  clk_divider_flags, however it's fixed to CLK_DIVIDER_ONE_BASED by
  default as our HW is. Besides that it supports only CLK_DIVIDER_READ_ONLY
  flag which can be specified by user flexibly.
 cache gate status 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2016 Freescale Semiconductor, Inc.
  Copyright 2017~2018 NXP
  Author: Dong Aisheng <aisheng.dong@nxp.com>
 used by soscsircfircddrspllapll dividers 
 sentinel  },
 SCG1 
 NOTE: xPLL config can't be changed when xPLL is enabled 
							   name		    parent_name	   reg			shift	width	flags 
						name	 parent_name	 base 
 APLL PFDs 
 SPLL PFDs 
 PLL Mux 
 scsddrnic select different clock source requires that clock to be enabled first 
 PCC2 
 PCC3 
 SMC1 
 SPDX-License-Identifier: GPL-2.0-only
   Copyright (C) 2008 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2016 Freescale Semiconductor, Inc.
  Copyright 2017~2018 NXP
	
	  release the sw reset for peripherals associated with
	  with this pcc clock.
		
		  make sure clock is gated during clock tree initialization,
		  the HW ONLY allow clock parentrate changed with clock gated,
		  during clock tree initialization, clocks could be enabled
		  by bootloader, so the HW status will mismatch with clock tree
		  prepare count, then clock core driver will allow parentrate
		  change since the prepare count is zero, but HW actually
		  prevent the parentrate change due to the clock is enabled.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2010-2011 Canonical Ltd <jeremy.kerr@canonical.com>
  Copyright (C) 2011-2012 Mike Turquette, Linaro Ltd <mturquette@linaro.org>
  Gated clock implementation
  DOC: basic gateable clock which can gate and ungate its output
  Traits of this clock:
  prepare - clk_(un)prepare only ensures parent is (un)prepared
  enable - clk_enable and clk_disable are functional & control gating
  rate - inherits rate from parent.  No clk_set_rate support
  parent - fixed parent.  No clk_set_parent support
 struct clk_gate2 assignments 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014 Freescale Semiconductor, Inc.
  struct clk_gate_exclusive - i.MX specific gate clock which is mutually
  exclusive with other gate clocks
  @gate: the parent class
  @exclusive_mask: mask of gate bits which are mutually exclusive to this
 	gate clock
  The imx exclusive gate clock is a subclass of basic clk_gate
  with an addtional mask to indicate which other gate bits in the same
  register is mutually exclusive to this gate clock.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2013 Freescale Semiconductor, Inc.
  struct clk_fixup_div - imx integer fixup divider clock
  @divider: the parent class
  @ops: pointer to clk_ops of parent class
  @fixup: a hook to fixup the write value
  The imx fixup divider clock is a subclass of basic clk_divider
  with an addtional fixup hook.
 Zero based divider 
 SPDX-License-Identifier: (GPL-2.0 OR MIT)
  Copyright 2018 NXP.
  This driver supports the SCCG plls found in the imx8m SOCs
  Documentation for this SCCG pll can be found at:
    https:www.nxp.comdocsenreference-manualIMX8MDQLQRM.pdf#page=834
 PLL CFGs 
 These are the specification limits for the SSCG PLL 
 don't wait for lock if all plls are bypassed 
 set bypass here too since the parent might be the same 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2017-2018 NXP.
 CCM ROOT 
 PLL bypass out 
 PLL out gate 
 SYS PLL1 fixed output 
 SYS PLL2 fixed output 
 Core Slice 
 For backwards compatibility 
 CORE SEL 
 BUS 
 AHB 
 IPG 
	
	  DRAM clocks are manipulated from TF-A outside clock framework.
	  The fw_managed helper sets GET_RATE_NOCACHE and clears SET_PARENT_GATE
	  as div value should always be read from hardware
 IP 
 CCGR 
 Sentinel  },
		
		  Disable bind attributes: clocks are not removed and
		  reloading the driver will crash or break devices.
 SPDX-License-Identifier: GPL-2.0
 PLL Register Offsets 
 PLL Register Bit definitions 
 1000  udelay(1) = 1ms 
 use dpdck0_2 
 Wait for lock 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2012 Freescale Semiconductor, Inc.
  Copyright 2012 Linaro Ltd.
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2018 NXP
 	Dong Aisheng <aisheng.dong@nxp.com>
  struct imx8qxp_lpcg_data - Description of one LPCG clock
  @id: clock ID
  @name: clock name
  @parent: parent clock name
  @flags: common clock flags
  @offset: offset of this LPCG clock
  @bit_idx: bit index of this LPCG clock
  @hw_gate: whether supports HW autogate
  This structure describes one LPCG clock
  struct imx8qxp_ss_lpcg - Description of one subsystem LPCG clocks
  @lpcg: LPCG clocks array of one subsystem
  @num_lpcg: the number of LPCG clocks
  @num_max: the maximum number of LPCG clocks
  This structure describes each subsystem LPCG clocks information
  which then will be used to create respective LPCGs clocks
	
	  A trick here is that we set the num of clks to the MAX instead
	  of the count from clock-indices because one LPCG supports up to
	  8 clock outputs which each of them is fixed to 4 bits. Then we can
	  easily get the clock by clk-indices (bit-offset)  4.
	  And the cost is very limited few pointers.
 try new binding to parse clocks from device tree first 
	
	  Please don't replace this with devm_platform_ioremap_resource.
	 
	  devm_platform_ioremap_resource calls devm_ioremap_resource which
	  differs from devm_ioremap by also calling devm_request_mem_region
	  and preventing other mappings in the same area.
	 
	  On imx8 the LPCG nodes map entire subsystems and overlap
	  peripherals, this means that using devm_platform_ioremap_resource
	  will cause many devices to fail to probe including serial ports.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  Copyright 2018-2019 NXP.
 PLL bypass out 
 PLL out gate 
 SYS PLL1 fixed output 
 SYS PLL2 fixed output 
 CORE 
 CORE SEL 
 BUS 
	
	  DRAM clocks are manipulated from TF-A outside clock framework.
	  The fw_managed helper sets GET_RATE_NOCACHE and clears SET_PARENT_GATE
	  as div value should always be read from hardware
 Sentinel  },
		
		  Disable bind attributes: clocks are not removed and
		  reloading the driver will crash or break devices.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2018 NXP
	
	  write twice to make sure non-target interface
	  SEL_AB point the same clk input.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2012 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
  0  ckih, mpll, ppll, mpll_075, arm, hsp, hsp_div, hsp_sel, ahb,
  9  ipg, arm_per_div, ahb_per_div, ipg_per, uart_sel, uart_div,
 15  esdhc_sel, esdhc1_div, esdhc2_div, esdhc3_div, spdif_sel,
 20  spdif_div_pre, spdif_div_post, ssi_sel, ssi1_div_pre,
 24  ssi1_div_post, ssi2_div_pre, ssi2_div_post, usb_sel, usb_div,
 29  nfc_div, asrc_gate, pata_gate, audmux_gate, can1_gate,
 34  can2_gate, cspi1_gate, cspi2_gate, ect_gate, edio_gate,
 39  emi_gate, epit1_gate, epit2_gate, esai_gate, esdhc1_gate,
 44  esdhc2_gate, esdhc3_gate, fec_gate, gpio1_gate, gpio2_gate,
 49  gpio3_gate, gpt_gate, i2c1_gate, i2c2_gate, i2c3_gate,
 54  iomuxc_gate, ipu_gate, kpp_gate, mlb_gate, mshc_gate,
 59  owire_gate, pwm_gate, rngc_gate, rtc_gate, rtic_gate, scc_gate,
 65  sdma_gate, spba_gate, spdif_gate, ssi1_gate, ssi2_gate,
 70  uart1_gate, uart2_gate, uart3_gate, usbotg_gate, wdog_gate,
 75  max_gate, admux_gate, csi_gate, csi_div, csi_sel, iim_gate,
 81  gpu2d_gate, ckil, clk_max
		
		  We are basically stuck. Continue with a default entry and hope we
		  get far enough to actually show the above message
 divide by 1 not allowed  
	
	  SCC is needed to boot via mmc after a watchdog reset. The clock code
	  before conversion to common clk also enabled UART1 (which isn't
	  handled here and not needed for mmc) and IIM (which is enabled
	  unconditionally above).
 SPDX-License-Identifier: GPL-2.0-or-later
  clkgen-mux.c: ST GEN-MUX Clock driver
  Copyright (C) 2014 STMicroelectronics (R&D) Limited
  Authors: Stephen Gallimore <stephen.gallimore@st.com>
 	    Pankaj Dev <pankaj.dev@st.com>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2014 STMicroelectronics R&D Ltd
  Authors:
  Stephen Gallimore <stephen.gallimore@st.com>,
  Pankaj Dev <pankaj.dev@st.com>.
  Maximum input clock to the PLL before we divide it down by 2
  although in reality in actual systems this has never been seen to
  be used.
  DOC: A Frequency Synthesizer that multiples its input clock by a fixed factor
  Traits of this clock:
  prepare - clk_(un)prepare only ensures parent is (un)prepared
  enable - clk_enable and clk_disable are functional & control the Fsyn
  rate - inherits rate from parent. set_rateround_raterecalc_rate
  parent - fixed parent.  No clk_set_parent support
  struct st_clk_quadfs_pll - A pll which outputs a fixed multiplier of
                                   its parent clock, found inside a type of
                                   ST quad channel frequency synthesizer block
  @hw: handle between common and hardware-specific interfaces.
  @regs_base: base address of the configuration registers.
  @lock: spinlock.
  @data: local driver data
  @ndiv: regmap field for the ndiv control.
	
	  Bring block out of reset if we have reset control.
	
	  Use a fixed input clock noise bandwidth filter for the moment
	
	  Power up the PLL
	
	  Powerdown the PLL and then put block into soft reset if we have
	  reset control.
 ndiv value 
 Formula
   VCO frequency = (fin x ndiv)  pdiv
   ndiv = VCOfreq  pdiv  fin
 Output clock range: 384Mhz to 660Mhz 
		 This means that PDIV would be 2 instead of 1.
 Converting formula value to reg value 
	
	  Sanity check required pointers.
  DOC: A digital frequency synthesizer
  Traits of this clock:
  prepare - clk_(un)prepare only ensures parent is (un)prepared
  enable - clk_enable and clk_disable are functional
  rate - set rate is functional
  parent - fixed parent.  No clk_set_parent support
  struct st_clk_quadfs_fsynth - One clock output from a four channel digital
                                   frequency synthesizer (fsynth) block.
  @hw: handle between common and hardware-specific interfaces
  @nsb: regmap field in the output control register for the digital
        standby of this fsynth channel. This control is active low so
        the channel is in standby when the control bit is cleared.
  @nsdiv: regmap field in the output control register for
           for the optional divide by 3 of this fsynth channel. This control
           is active low so the divide by 3 is active when the control bit is
           cleared and the divide is bypassed when the bit is set.
	
	  Cached hardware values from set_rate so we can program the
	  hardware in enable. There are two reasons for this:
	 
	   1. The registers may not be writable until the parent has been
	      enabled.
	 
	   2. It restores the clock rate when a driver does an enable
	      on PM restore, after a suspend to RAM has lost the hardware
	      setup.
	
	  Pulse the program enable register lsb to make the hardware take
	  notice of the new mdpe values with a glitchless transition.
	
	  Ensure the mdpe parameters are ignored while we are
	  reprogramming them so we can get a glitchless change
	  when fine tuning the speed of a running clock.
	
	  'nsdiv' is a register value ('BIN') which is translated
	  to a decimal value according to following rules.
	 
	      nsdiv      ns.dec
	        0        3
	        1        1
 sdiv_reg (8 downto 0) 
 md value 
 initial condition to say: "infinite deviation" 
 pe value 
 Boundary test to avoid useless iteration 
 No solution 
 Try to find best deviation 
 No solution found 
 pe fine tuning if deviation not 0: +- 2 around computed pe value 
 Check if this is a better solution 
	
	  Get the initial hardware values for recalc_rate
	
	  If All are NULL then assume no clock rate is programmed.
	
	  In some integrations you can only change the fsynth programming when
	  the parent entity containing it is enabled.
	
	  Sanity check required pointers, note that nsdiv3 is optional.
		
		  If we read an empty clock name then the channel is unused
		
		  If there was an error registering this clock output, clean
		  up and move on to the next one.
 No longer need local copy of the PLL name 
 SPDX-License-Identifier: GPL-2.0-only
  clk-flexgen.c
  Copyright (C) ST-Microelectronics SA 2013
  Author:  Maxime Coquelin <maxime.coquelin@st.com> for ST-Microelectronics.
 Crossbar 
 Pre-divisor's gate 
 Pre-divisor 
 Final divisor's gate 
 Final divisor 
 Asynchronous mode control 
 hw control flags 
 disable only the final gate 
 Round div according to exact prate and wished rate 
	
	 pdiv is mainly targeted for low freq results, while fdiv
	 should be used for div <= 64. The other way round can
	 lead to 'duty cycle' issues.
 Crossbar element config 
 Pre-divider's gate config (in xbar register)
 Pre-divider config 
 Final divider's gate config 
 Final divider config 
 Final divider sync config 
 This clk needs to be on so that memory interface is accessible 
 Those clks need to be on so that memory interface is accessible 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep A9 running 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep A9 running 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep bus interconnect alive 
 This clk needs to be on to keep bus interconnect alive 
 First try to get output information from the compatible data 
		
		  If we read an empty clock name then the output is unused
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2014 STMicroelectronics (R&D) Limited
  Authors:
  Stephen Gallimore <stephen.gallimore@st.com>,
  Pankaj Dev <pankaj.dev@st.com>.
  PLL configuration register bits for PLL3200 C32
  PLL configuration register bits for PLL4600 C28
 407 C0 PLL0 
 407 C0 PLL1 
 407 A9 
 418 A9 
  DOC: Clock Generated by PLL, rate set and enabled by bootloader
  Traits of this clock:
  prepare - clk_(un)prepare only ensures parent is (un)prepared
  enable - clk_enabledisable only ensures parent is enabled
  rate - rate is fixed. No clk_set_rate support
  parent - fixed parent.  No clk_set_parent support
  PLL clock that is integrated in the ClockGenA instances on the STiH415
  and STiH416.
  @hw: handle between common and hardware-specific interfaces.
  @regs_base: base of the PLL configuration register(s).
 Charge pump table: highest ndiv value for cp=6 to 25 
 Output clock range: 800Mhz to 1600Mhz 
 Checks 
 No solution found 
 Computing recommended charge pump value 
 Note: input is divided to avoid overflow 
 PLL output structure
  FVCO >> 2 >> FVCOBY2 (no output)
                  |> Divider (ODF) >> PHI
  FVCOby2 output = (input  2  NDIV)  IDF (assuming FRAC_CONTROL==L)
  Rules:
    4Mhz <= INFF input <= 350Mhz
    4Mhz <= INFIN (INFF  IDF) <= 50Mhz
    19.05Mhz <= FVCOby2 output (PHI w ODF=1) <= 3000Mhz
    1 <= i (registerdec value for IDF) <= 7
    8 <= n (registerdec value for NDIV) <= 246
 Output clock range: 19Mhz to 3000Mhz 
 For better jitter, IDF should be smallest and NDIV must be maximum 
 INFIN checks 
 Invalid case 
 Invalid case 
 To work around 'y' when n=x.y 
 Optimization: shorting loop 
 No solution found 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
		
		  adj_parent_rate might have been modified by our clock.
		  Unapply the pre-divider if there's one, and give
		  the actual frequency the parent needs to run at.
		
		  parent_rate might have been modified by our clock.
		  Unapply the pre-divider if there's one, and give
		  the actual frequency the parent needs to run at.
  This clock notifier is called when the frequency of the of the parent
  PLL clock is to be changed. The idea is to switch the parent to a
  stable clock, such as the main oscillator, while the PLL frequency
  stabilizes.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2016 Maxime Ripard. All rights reserved.
  The Audio PLL is supposed to have 4 outputs: 3 fixed factors from
  the base (2x, 4x and 8x), and one variable divider (the one true
  pll audio).
  With sigma-delta modulation for fractional-N on the audio PLL,
  we have to use specific dividers. This means the variable divider
  can no longer be used, as the audio codec requests the exact clock
  rates we support through this mechanism. So we now hard code the
  variable divider to 1. This means the clock rates will no longer
  match the clock names.
	
	  The datasheet is wrong here, this doesn't have any
	  offset
 Sentinel  },
 M 
 P 
 mux 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 We hardcode the divider to 1 for now 
  The A13 is the A10s minus the TS, GPS, HDMI, I2S and the keypad
  The GR8 is the A10s CCU minus the HDMI and keypad, plus SPDIF
 Force the PLL-Audio-1x divider to 1 
	
	  Use the peripheral PLL as the AHB parent, instead of CPU 
	  AXI which have rate changes due to cpufreq.
	 
	  This is especially a big deal for the HS timer whose parent
	  clock is AHB.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
	
	  We must report success but we can do so unconditionally because
	  clk_factor_round_rate returns values that ensure this call is a
	  nop.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
	
	  The maximum divider we can use without overflowing
	  unsigned long in rate  m  p below
				
				  It's the most ideal case if the requested
				  rate can be divided from parent clock without
				  needing to change parent rate, so return the
				  divider immediately.
 Adjust parent_rate according to pre-dividers 
 Adjust parent_rate according to pre-dividers 
 Adjust target rate according to post-dividers 
  Support for MMC timing mode switching
  The MMC clocks on some SoCs support switching between old and
  new timing modes. A platform specific API is provided to query
  and set the timing mode on supported SoCs.
  In addition, a special class of ccu_mp_ops is provided, which
  takes in to account the timing mode switch. When the new timing
  mode is active, the clock output rate is halved. This new class
  is a wrapper around the generic ccu_mp_ops. When clock rates
  are passed through to ccu_mp_ops callbacks, they are doubled
  if the new timing mode bit is set, to account for the post
  divider. Conversely, when clock rates are passed back, they
  are halved if the mode bit is set.
 adjust the requested clock rate 
 re-adjust the requested clock rate back 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2016 Chen-Yu Tsai. All rights reserved.
  The CPU PLLs are actually NP clocks, with P being 1 or 4. However
  P should only be used for output frequencies lower than 228 MHz.
  Neither mainline Linux, U-boot, nor the vendor BSPs use these.
  For now we can just model it as a multiplier clock, and force P to 1.
  The Audio PLL has d1, d2 dividers in addition to the usual N, M
  factors. Since we only need 2 frequencies from this PLL: 22.5792 MHz
  and 24.576 MHz, ignore them for now. Enforce d1 = 0 and d2 = 0.
 Some PLLs are input  N  div1  div2. Model them as NKMP with no K 
 input divider 
 output divider 
 input divider 
 output divider 
 input divider 
 output divider 
 input divider 
 input divider 
 external divider p 
 input divider 
 output divider 
 input divider 
 output divider 
 input divider 
 output divider 
 input divider 
 output divider 
 Sentinel  },
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 mux 
 no gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 AHB0 bus gates 
 AHB1 bus gates 
 AHB2 bus gates 
 APB0 bus gates 
 APB1 bus gates 
 module clocks 
 AHB0 bus gates 
 AHB1 bus gates 
 AHB2 bus gates 
 APB0 bus gates 
 APB1 bus gates 
 AHB0 reset controls 
 AHB1 reset controls 
 AHB2 reset controls 
 APB0 reset controls 
 APB1 reset controls 
 bail out if P divider is not used 
	
	  If P is used, output should be less than 288 MHz. When we
	  set P to 1, we should also decrease the multiplier so the
	  output doesn't go out of range, but not too much such that
	  the multiplier stays above 12, the minimal operation value.
	 
	  To keep it simple, set the multiplier to 17, the reset value.
 And clear P 
 Enforce d1 = 0, d2 = 0 for Audio PLL 
 Enforce P = 1 for both CPU cluster PLLs 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2016 Icenowy Zheng <icenowy@aosc.xyz>
  Based on ccu-sun8i-h3.c, which is:
  Copyright (c) 2016 Maxime Ripard. All rights reserved.
 N 
 K 
 M 
 P 
 gate 
 lock 
  The Audio PLL is supposed to have 4 outputs: 3 fixed factors from
  the base (2x, 4x and 8x), and one variable divider (the one true
  pll audio).
  With sigma-delta modulation for fractional-N on the audio PLL,
  we have to use specific dividers. This means the variable divider
  can no longer be used, as the audio codec requests the exact clock
  rates we support through this mechanism. So we now hard code the
  variable divider to 1. This means the clock rates will no longer
  match the clock names.
 N 
 M 
 gate 
 lock 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 K 
 M 
 gate 
 lock 
 N 
 K 
 gate 
 lock 
 post-div 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 K 
 gate 
 lock 
 post-div 
 N 
 M 
 gate 
 lock 
 Sentinel  },
 M 
 P 
 mux 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 We hardcode the divider to 1 for SDM support 
 Force the PLL-Audio-1x divider to 1 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2016 Maxime Ripard. All rights reserved.
 N 
 K 
 M 
 P 
 gate 
 lock 
  The Audio PLL is supposed to have 4 outputs: 3 fixed factors from
  the base (2x, 4x and 8x), and one variable divider (the one true
  pll audio).
  With sigma-delta modulation for fractional-N on the audio PLL,
  we have to use specific dividers. This means the variable divider
  can no longer be used, as the audio codec requests the exact clock
  rates we support through this mechanism. So we now hard code the
  variable divider to 1. This means the clock rates will no longer
  match the clock names.
 N 
 M 
 gate 
 lock 
 Minimum rate 
 Maximum rate 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 K 
 M 
 gate 
 lock 
 N 
 K 
 gate 
 lock 
 post-div 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 K 
 gate 
 lock 
 post-div 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 Sentinel  },
 M 
 P 
 mux 
 Sentinel  },
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 We hardcode the divider to 1 for now 
 copy from pll_cpux_clk 
 > 8 clock cycles at 24 MHz 
 index of 24 MHz oscillator 
 Force the PLL-Audio-1x divider to 1 
 Gate then ungate PLL CPU after any rate changes 
 Reparent CPU during PLL CPU rate changes 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2020 Yangtao Li <frank@allwinnertech.com>
  The CPU PLL is actually NP clock, with P being 1, 2 or 4. However
  P should only be used for output frequencies lower than 288 MHz.
  For now we can just model it as a multiplier clock, and force P to 1.
  The M factor is present in the register's description, but not in the
  frequency formula, and it's documented as "M is only used for backdoor
  testing", so it's not modelled and then force to 0.
 Some PLLs are input  N  div1  P. Model them as NKMP with no K 
 input divider 
 output divider 
 input divider 
 output divider 
 input divider 
 output divider 
 input divider 
 output divider 
  For Video PLLs, the output divider is described as "used for testing"
  in the user manual. So it's not modelled and forced to 0.
 input divider 
 input divider 
 input divider 
 input divider 
 output divider 
  The COM PLL has m0 dividers in addition to the usual N, M
  factors. Since we only need 1 frequencies from this PLL: 45.1584 MHz,
  ignore it for now.
 input divider 
  The Audio PLL has m0, m1 dividers in addition to the usual N, M
  factors. Since we only need 4 frequencies from this PLL: 22.5792 MHz,
  24.576 MHz, 90.3168MHz and 98.304MHz ignore them for now.
  Enforce the default for them, which is m0 = 1, m1 = 0.
 M 
 P 
 mux 
 M 
 P 
 mux 
 M 
 P 
 mux 
 M 
 P 
 mux 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 post-div 
 M 
 P 
 mux 
 gate 
 post-div 
 M 
 P 
 mux 
 gate 
 post-div 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
  There are OHCI 12M clock source selection bits for 2 USB 2.0 ports.
  We will force them to 0 (12M divided from 48M).
 M 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 Fixed factor clocks 
 copy from pll_cpux_clk 
 index of pll periph0 
	
	  Enable lock and enable bits on all PLLs.
	 
	  Due to the current design, multiple PLLs share one power switch,
	  so switching PLL is easy to cause stability problems.
	  When initializing, we enable them by default. When disable,
	  we only turn off the output of PLL.
	
	  In order to pass the EMI certification, the SDM function of
	  the peripheral 1 bus is enabled, and the frequency is still
	  calculated using the previous division factor.
	
	  Force the output divider of video PLLs to 0.
	 
	  See the comment before pll-video0 definition for the reason.
	
	  Enforce m1 = 0, m0 = 1 for Audio PLL
	 
	  See the comment before pll-audio definition for the reason.
	
	  Force OHCI 12M clock sources to 00 (12MHz divided from 48MHz)
	 
	  This clock mux is still mysterious, and the code just enforces
	  it to have a valid clock parent.
 Gate then ungate PLL CPU after any rate changes 
 Reparent CPU during PLL CPU rate changes 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
 Adjust target rate according to post-dividers 
 most SoCs require M to be 0 if fractional mode is used 
 Sigma delta modulation requires specific N and M factors 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2017 Chen-Yu Tsai <wens@csie.org>
 Set the pattern 
 Make sure SDM is enabled 
  Sigma delta modulation provides a way to do fractional-N frequency
  synthesis, in essence allowing the PLL to output any frequency
  within its operational range. On earlier SoCs such as the A10A20,
  some PLLs support this. On later SoCs, all PLLs support this.
  The datasheets do not explain what the "wave top" and "wave bottom"
  parameters mean or do, nor how to calculate the effective output
  frequency. The only examples (and real world usage) are for the audio
  PLL to generate 24.576 and 22.5792 MHz clock rates used by the audio
  peripherals. The author lacks the underlying domain knowledge to
  pursue this.
  The goal and function of the following code is to support the two
  clock rates used by the audio subsystem, allowing for proper audio
  playback and capture without any pitch or speed changes.
 We can't calculate the effective clock rate, so just fail. 
 nothing found 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 Icenowy Zheng <icenowy@aosc.io>
	
	  Mixer1 reset line is shared with wb, so only RST_WB is
	  exported here.
	
	  Mixer1 reset line is shared with wb, so only RST_WB is
	  exported here.
	  V3s doesn't have mixer1, so it also shares this struct.
 The clocks need to be enabled for us to access the registers 
 The reset control needs to be asserted for the controls to work 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2016 Icenowy Zheng <icenowy@aosc.xyz>
  Define the parent as an array that can be reused to save space
  instead of having compound literals for each gate. Also have it
  non-const so we can change it on the A83T.
 M 
 P 
 mux 
 gate 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 Chen-Yu Tsai. All rights reserved.
  The CPU PLLs are actually NP clocks, with P being 1 or 4. However
  P should only be used for output frequencies lower than 228 MHz.
  Neither mainline Linux, U-boot, nor the vendor BSPs use these.
  For now we can just model it as a multiplier clock, and force P to 1.
  The Audio PLL has d1, d2 dividers in addition to the usual N, M
  factors. Since we only need 2 frequencies from this PLL: 22.5792 MHz
  and 24.576 MHz, ignore them for now. Enforce the default for them,
  which is d1 = 0, d2 = 1.
 clock rates doubled for post divider 
 Some PLLs are input  N  div1  P. Model them as NKMP with no K 
 input divider 
 output divider 
 input divider 
 output divider 
 input divider 
 output divider 
 input divider 
 output divider 
 input divider 
 output divider 
 input divider 
 output divider 
 input divider 
 output divider 
 input divider 
 external divider p 
 M 
 P 
 mux 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 TODO divider has minimum of 2 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 bail out if P divider is not used 
	
	  If P is used, output should be less than 288 MHz. When we
	  set P to 1, we should also decrease the multiplier so the
	  output doesn't go out of range, but not too much such that
	  the multiplier stays above 12, the minimal operation value.
	 
	  To keep it simple, set the multiplier to 17, the reset value.
 And clear P 
 Enforce d1 = 0, d2 = 1 for Audio PLL 
 Enforce P = 1 for both CPU cluster PLLs 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2016 Chen-Yu Tsai. All rights reserved.
 The bus clock needs to be enabled for us to access the registers 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
	
	  The reset control API expects 0 if reset is not asserted,
	  which is the opposite of what our hardware uses.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2016 Maxime Ripard. All rights reserved.
  The Audio PLL is supposed to have 4 outputs: 3 fixed factors from
  the base (2x, 4x and 8x), and one variable divider (the one true
  pll audio).
  With sigma-delta modulation for fractional-N on the audio PLL,
  we have to use specific dividers. This means the variable divider
  can no longer be used, as the audio codec requests the exact clock
  rates we support through this mechanism. So we now hard code the
  variable divider to 1. This means the clock rates will no longer
  match the clock names.
 N 
 M 
 gate 
 lock 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 K 
 M 
 gate 
 lock 
 N 
 K 
 gate 
 lock 
 post-div 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
  The MIPI PLL has 2 modes: "MIPI" and "HDMI".
  The MIPI mode is a standard NKM-style clock. The HDMI mode is an
  integer  fractional clock with switchable multipliers and dividers.
  This is not supported here. We hardcode the PLL to MIPI mode.
 N 
 K 
 M 
 gate 
 lock 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 Sentinel  },
 M 
 P 
 mux 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 TODO: the parent for most of the USB clocks is not known 
 We hardcode the divider to 1 for now 
 copy from pll_cpux_clk 
 > 8 clock cycles at 24 MHz 
 index of 24 MHz oscillator 
 Force the PLL-Audio-1x divider to 1 
 Force PLL-MIPI to MIPI mode 
 Gate then ungate PLL CPU after any rate changes 
 Reparent CPU during PLL CPU rate changes 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2020 Arm Ltd.
  Based on the H6 CCU driver, which is:
    Copyright (c) 2017 Icenowy Zheng <icenowy@aosc.io>
  The CPU PLL is actually NP clock, with P being 1, 2 or 4. However
  P should only be used for output frequencies lower than 288 MHz.
  For now we can just model it as a multiplier clock, and force P to 1.
  The M factor is present in the register's description, but not in the
  frequency formula, and it's documented as "M is only used for backdoor
  testing", so it's not modelled and then force to 0.
 Some PLLs are input  N  div1  P. Model them as NKMP with no K 
 input divider 
 output divider 
 input divider 
 output divider 
 input divider 
 output divider 
 input divider 
 output divider 
 input divider 
 output divider 
  For Video PLLs, the output divider is described as "used for testing"
  in the user manual. So it's not modelled and forced to 0.
 input divider 
 input divider 
 input divider 
 input divider 
 output divider 
 input divider 
 output divider 
  TODO: Determine SDM settings for the audio PLL. The manual suggests
  PLL_FACTOR_N=16, PLL_POST_DIV_P=2, OUTPUT_DIV=2, pattern=0xe000c49b
  for 24.576 MHz, and PLL_FACTOR_N=22, PLL_POST_DIV_P=3, OUTPUT_DIV=2,
  pattern=0xe001288c for 22.5792 MHz.
  This clashes with our fixed PLL_POST_DIV_P.
 input divider 
 M 
 P 
 mux 
 M 
 P 
 mux 
 M 
 P 
 mux 
 M 
 P 
 mux 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 gate 
 M 
 N 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 N 
 mux 
 gate 
 M 
 N 
 mux 
 gate 
 M 
 N 
 mux 
 gate 
 post-div 
 M 
 N 
 mux 
 gate 
 post-div 
 M 
 N 
 mux 
 gate 
 post-div 
 M 
 N 
 mux 
 gate 
 M 
 N 
 mux 
 gate 
 M 
 N 
 mux 
 gate 
 M 
 mux 
 gate 
 M 
 mux 
 gate 
  There are OHCI 12M clock source selection bits for the four USB 2.0 ports.
  We will force them to 0 (12M divided from 48M).
 M 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 mux 
 gate 
 Fixed factor clocks 
  The divider of pll-audio is fixed to 24 for now, so 24576000 and 22579200
  rates can be set exactly in conjunction with sigma-delta modulation.
 Enable the lock bits and the output enable bits on all PLLs 
	
	  Force the output divider of video PLLs to 0.
	 
	  See the comment before pll-video0 definition for the reason.
	
	  Force OHCI 12M clock sources to 00 (12MHz divided from 48MHz)
	 
	  This clock mux is still mysterious, and the code just enforces
	  it to have a valid clock parent.
	
	  Force the post-divider of pll-audio to 12 and the output divider
	  of it to 2, so 24576000 and 22579200 rates can be set exactly.
	
	  First clock parent (osc32K) is unusable for CEC. But since there
	  is no good way to force parent switch (both run with same frequency),
	  just set second clock parent here.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2017 Icenowy Zheng <icenowy@aosc.xyz>
  Information about AR100 and AHBAPB clocks in R_CCU are gathered from
  clock definitions in the BSP source code.
  Information about the gateresets are gathered from the clock header file
  in the BSP source code, although most of them are unused. The existence
  of the hardware block is verified with "3.1 Memory Mapping" chapter in
  "Allwinner H6 V200 User Manual V1.1"; and the parent APB buses are verified
  with "3.3.2.1 System Bus Tree" chapter inthe same document.
 Information of IR(RX) mod clock is gathered from BSP source code 
 M 
 P 
 mux 
 gate 
  BSP didn't use the 1-wire function at all now, and the information about
  this mod clock is guessed from the IR mod clock above. The existence of
  this mod clock is proven by BSP clock header, and the dividers are verified
  by contents in the 1-wire related chapter of the User Manual.
 M 
 P 
 mux 
 gate 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2016 Maxime Ripard. All rights reserved.
  The Audio PLL is supposed to have 4 outputs: 3 fixed factors from
  the base (2x, 4x and 8x), and one variable divider (the one true
  pll audio).
  With sigma-delta modulation for fractional-N on the audio PLL,
  we have to use specific dividers. This means the variable divider
  can no longer be used, as the audio codec requests the exact clock
  rates we support through this mechanism. So we now hard code the
  variable divider to 1. This means the clock rates will no longer
  match the clock names.
 N 
 M 
 gate 
 lock 
 Minimum rate 
 Maximum rate 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 K 
 M 
 gate 
 lock 
 Minimum rate 
 Maximum rate 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
  The output function can be changed to something more complex that
  we do not handle yet.
  Hardcode the mode so that we don't fall in that case.
	
	  The bit 23 and 22 are called "LDO{1,2}_EN" on the SoC's
	  user manual, and by experiments the PLL doesn't work without
	  these bits toggled.
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 M 
 gate 
 lock 
 Sentinel  },
 M 
 P 
 mux 
 Sentinel  },
 M 
 P 
 mux 
 gate 
  MMC clocks are the new timing mode (see A83T & H3) variety, but without
  the mode switch. This means they have a 2x post divider between the clock
  and the MMC module. This is not documented in the manual, but is taken
  into consideration when setting the mmc module clocks in the BSP kernel.
  Without it, MMC performance is degraded.
  We model it here to be consistent with other SoCs supporting this mode.
  The alternative would be to add the 2x multiplier when setting the MMC
  module clock in the MMC driver, just for the A64.
 M 
 P 
 mux 
 gate 
 post-div 
 M 
 P 
 mux 
 gate 
 post-div 
 M 
 P 
 mux 
 gate 
 post-div 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 Fixed Factor clocks 
 We hardcode the divider to 1 for now 
 copy from pll_cpux_clk 
 > 8 clock cycles at 24 MHz 
 index of 24 MHz oscillator 
 Force the PLL-Audio-1x divider to 1 
 Gate then ungate PLL CPU after any rate changes 
 Reparent CPU during PLL CPU rate changes 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2016 Maxime Ripard. All rights reserved.
  The Audio PLL is supposed to have 4 outputs: 3 fixed factors from
  the base (2x, 4x and 8x), and one variable divider (the one true
  pll audio).
  With sigma-delta modulation for fractional-N on the audio PLL,
  we have to use specific dividers. This means the variable divider
  can no longer be used, as the audio codec requests the exact clock
  rates we support through this mechanism. So we now hard code the
  variable divider to 1. This means the clock rates will no longer
  match the clock names.
 N 
 M 
 gate 
 lock 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 K 
 M 
 gate 
 lock 
 N 
 K 
 gate 
 lock 
 post-div 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
  The MIPI PLL has 2 modes: "MIPI" and "HDMI".
  The MIPI mode is a standard NKM-style clock. The HDMI mode is an
  integer  fractional clock with switchable multipliers and dividers.
  This is not supported here. We hardcode the PLL to MIPI mode.
 N 
 K 
 M 
 gate 
 lock 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 Sentinel  },
 M 
 P 
 mux 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 TODO: the parent for most of the USB clocks is not known 
 We hardcode the divider to 1 for now 
 Force the PLL-Audio-1x divider to 1 
 Force PLL-MIPI to MIPI mode 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 Chen-Yu Tsai. All rights reserved.
  sunxi_ccu_set_mmc_timing_mode: Configure the MMC clock timing mode
  @clk: clock to be configured
  @new_mode: true for new timing mode introduced in A83T and later
  Returns 0 on success, -ENOTSUPP if the clock does not support
  switching modes.
  sunxi_ccu_set_mmc_timing_mode: Get the current MMC clock timing mode
  @clk: clock to query
  Returns 0 if the clock is in old timing mode, > 0 if it is in
  new timing mode, and -ENOTSUPP if the clock does not support
  this function.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2016 Icenowy Zheng <icenowy@aosc.io>
 MAX is guessed by the BSP table 
  The Audio PLL is supposed to have 4 outputs: 3 fixed factors from
  the base (2x, 4x and 8x), and one variable divider (the one true
  pll audio).
  We don't have any need for the variable divider for now, so we just
  hardcode it to match with the clock names
 N 
 M 
 gate 
 lock 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 M 
 frac enable 
 frac select 
 frac rate 0 
 frac rate 1 
 gate 
 lock 
 N 
 K 
 M 
 gate 
 lock 
 Sentinel  },
 M 
 P 
 mux 
 gate 
 M 
 P 
 mux 
 gate 
 The BSP header file has a CIR_CFG, but no mod clock uses this definition 
  TODO: BSP says the parent is pll-audio, however common sense and experience
  told us it should be pll-ve. pll-ve is totally not used in BSP code.
 copy from pll_cpu_clk 
 > 8 clock cycles at 24 MHz 
 index of 24 MHz oscillator 
 Force the PLL-Audio-1x divider to 4 
 Gate then ungate PLL CPU after any rate changes 
 Reparent CPU during PLL CPU rate changes 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
 Get our parent clock, it's the one that can adjust its rate 
 And its rate 
 Now, get our parent's parent (most likely some PLL) 
 And its rate 
 Get our parent clock divider 
 Get our parent clock, it's the one that can adjust its rate 
 And its rate 
 Now, get our parent's parent (most likely some PLL) 
 And its rate 
 Get our parent divider 
		
		  We can only outphase the clocks by multiple of the
		  PLL's period.
		 
		  Since our parent clock is only a divider, and the
		  formula to get the outphasing in degrees is deg =
		  360  delta  period
		 
		  If we simplify this formula, we can see that the
		  only thing that we're concerned about is the number
		  of period we want to outphase our clock from, and
		  the divider set by our parent clock.
