 SPDX-License-Identifier: GPL-2.0
  High-level sync()-related operations
  Write out and wait upon all dirty data associated with this
  superblock.  Filesystem data as well as the underlying block
  device.  Takes the superblock lock.
	
	  We need to be protected against the filesystem going from
	  ro to rw or vice versa.
	
	  No point in syncing out anything if the filesystem is read-only.
	
	  Do the filesystem syncing work.  For simple filesystems
	  writeback_inodes_sb(sb) just dirties buffers with inodes so we have
	  to submit IO for these buffers via sync_blockdev().  This also
	  speeds up the wait == 1 case since in that case write_inode()
	  methods call sync_dirty_buffer() and thus effectively write one block
	  at a time.
  Sync everything. We start by waking flusher threads so that most of
  writeback runs on all devices in parallel. Then we sync all inodes reliably
  which effectively also waits for all flusher threads to finish doing
  writeback. At this point all data is on disk so metadata should be stable
  and we tell filesystems to sync their metadata via ->sync_fs() calls.
  Finally, we writeout all block devices because some filesystems (e.g. ext2)
  just write metadata (such as inodes or bitmaps) to block device page cache
  and do not sync it on their own in ->sync_fs().
	
	  Sync twice to reduce the possibility we skipped some inodes  pages
	  because they were temporarily locked
  sync a single super
  vfs_fsync_range - helper to sync a range of data & metadata to disk
  @file:		file to sync
  @start:		offset in bytes of the beginning of data range to sync
  @end:		offset in bytes of the end of data range (inclusive)
  @datasync:		perform only datasync
  Write back data in range @start..@end and metadata for @file to disk.  If
  @datasync is set only metadata needed to access modified file data is
  written.
  vfs_fsync - perform a fsync or fdatasync on a file
  @file:		file to sync
  @datasync:		only perform a fdatasync operation
  Write back data and metadata for @file to disk.  If @datasync is
  set only metadata needed to access modified file data is written.
 inclusive 
			
			  The range starts outside a 32 bit machine's
			  pagecache addressing capabilities.  Let it "succeed"
			
			  Out to EOF
 inclusive 
  ksys_sync_file_range() permits finely controlled syncing over a segment of
  a file in the range offset .. (offset+nbytes-1) inclusive.  If nbytes is
  zero then ksys_sync_file_range() will operate from offset out to EOF.
  The flag bits are:
  SYNC_FILE_RANGE_WAIT_BEFORE: wait upon writeout of all pages in the range
  before performing the write.
  SYNC_FILE_RANGE_WRITE: initiate writeout of all those dirty pages in the
  range which are not presently under writeback. Note that this may block for
  significant periods due to exhaustion of disk request structures.
  SYNC_FILE_RANGE_WAIT_AFTER: wait upon writeout of all pages in the range
  after performing the write.
  Useful combinations of the flag bits are:
  SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE: ensures that all pages
  in the range which were dirty on entry to ksys_sync_file_range() are placed
  under writeout.  This is a start-write-for-data-integrity operation.
  SYNC_FILE_RANGE_WRITE: start writeout of all dirty pages in the range which
  are not presently under writeout.  This is an asynchronous flush-to-disk
  operation.  Not suitable for data integrity operations.
  SYNC_FILE_RANGE_WAIT_BEFORE (or SYNC_FILE_RANGE_WAIT_AFTER): wait for
  completion of writeout of all pages in the range.  This will be used after an
  earlier SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE operation to wait
  for that operation to complete and to return the result.
  SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE|SYNC_FILE_RANGE_WAIT_AFTER
  (a.k.a. SYNC_FILE_RANGE_WRITE_AND_WAIT):
  a traditional sync() operation.  This is a write-for-data-integrity operation
  which will ensure that all pages in the range which were dirty on entry to
  ksys_sync_file_range() are written to disk.  It should be noted that disk
  caches are not flushed by this call, so there are no guarantees here that the
  data will be available on disk after a crash.
  SYNC_FILE_RANGE_WAIT_BEFORE and SYNC_FILE_RANGE_WAIT_AFTER will detect any
  IO errors or ENOSPC conditions and will return those to the caller, after
  clearing the EIO and ENOSPC flags in the address_space.
  It should be noted that none of these operations write out the file's
  metadata.  So unless the application is strictly performing overwrites of
  already-instantiated disk blocks, there are no guarantees here that the data
  will be available after a crash.
 It would be nice if people remember that not all the world's an i386
 SPDX-License-Identifier: GPL-2.0
   linuxfsioctl.c
   Copyright (C) 1991, 1992  Linus Torvalds
 So that the fiemap access checks can't overflow on 32 bit machines. 
  vfs_ioctl - call filesystem specific ioctl methods
  @filp:	open file to invoke ioctl method on
  @cmd:	ioctl command to execute
  @arg:	command-specific argument for ioctl
  Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise
  returns -ENOTTY.
  Returns 0 on success, -errno on error.
  fiemap_fill_next_extent - Fiemap helper function
  @fieinfo:	Fiemap context passed into ->fiemap
  @logical:	Extent logical start offset, in bytes
  @phys:	Extent physical start offset, in bytes
  @len:	Extent length, in bytes
  @flags:	FIEMAP_EXTENT flags that describe this extent
  Called from file system ->fiemap callback. Will populate extent
  info as passed in via arguments and copy to user memory. On
  success, extent count on fieinfo is incremented.
  Returns 0 on success, -errno on error, 1 if this was the last
  extent that will fit in user array.
 only count the extents 
  fiemap_prep - check validity of requested flags for fiemap
  @inode:	Inode to operate on
  @fieinfo:	Fiemap context passed into ->fiemap
  @start:	Start of the mapped range
  @len:	Length of the mapped range, can be truncated by this function.
  @supported_flags:	Set of fiemap flags that the file system understands
  This function must be called from each ->fiemap instance to validate the
  fiemap request against the file system parameters.
  Returns 0 on success, or a negative error on failure.
	
	  Shrink request scope to what the fs can actually handle.
  This provides compatibility with legacy XFS pre-allocation ioctls
  which predate the fallocate syscall.
  Only the l_start, l_len and l_whence fields of the 'struct space_resv'
  are used here, rest are ignored.
 on ia32 l_start is on a 32-bit boundary 
 just account for different alignment 
 SunOS compatibility item. 
 Did FASYNC state change ? 
 fasync() adjusts filp->f_flags 
 If filesystem doesn't support freeze feature, return. 
 Freeze 
 Thaw 
  fileattr_fill_xflags - initialize fileattr with xflags
  @fa:		fileattr pointer
  @xflags:	FS_XFLAG_ flags
  Set ->fsx_xflags, ->fsx_valid and ->flags (translated xflags).  All
  other fields are zeroed.
  fileattr_fill_flags - initialize fileattr with flags
  @fa:		fileattr pointer
  @flags:	FS__FL flags
  Set ->flags, ->flags_valid and ->fsx_xflags (translated flags).
  All other fields are zeroed.
  vfs_fileattr_get - retrieve miscellaneous file attributes
  @dentry:	the object to retrieve from
  @fa:		fileattr pointer
  Call i_op->fileattr_get() callback, if exists.
  Return: 0 on success, or a negative error on failure.
  copy_fsxattr_to_user - copy fsxattr to userspace.
  @fa:		fileattr pointer
  @ufa:	fsxattr user pointer
  Return: 0 on success, or -EFAULT on failure.
  Generic function to check FS_IOC_FSSETXATTRFS_IOC_SETFLAGS values and reject
  any invalid configurations.
  Note: must be called with inode lock held.
	
	  The IMMUTABLE and APPEND_ONLY flags can only be changed by
	  the relevant capability.
	
	  Project Quota ID state is only allowed to change from within the init
	  namespace. Enforce that restriction only if we are trying to change
	  the quota ID state. Everything else is allowed in user namespaces.
		
		  Caller is allowed to change the project ID. If it is being
		  changed, make sure that the new value is valid.
 Check extent size hints. 
	
	  It is only valid to set the DAX flag on regular files and
	  directories on filesystems.
 Extent size hints of zero turn off the flags. 
  vfs_fileattr_set - change miscellaneous file attributes
  @mnt_userns:	user namespace of the mount
  @dentry:	the object to change
  @fa:		fileattr pointer
  After verifying permissions, call i_op->fileattr_set() callback, if
  exists.
  Verifying attributes involves retrieving current attributes with
  i_op->fileattr_get(), this also allows initializing attributes that have
  not been set by the caller to current values.  Inode lock is held
  thoughout to prevent racing with another instance.
  Return: 0 on success, or a negative error on failure.
 initialize missing bits from old_ma 
 hint only 
 hint only 
  do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()'d.
  It's just a simple helper for sys_ioctl and compat_sys_ioctl.
  When you add any new common ioctls to the switches above and below,
  please ensure they have compatible arguments in compat mode.
 anon_bdev filesystems may not have a block size 
  compat_ptr_ioctl - generic implementation of .compat_ioctl file operation
  This is not normally called as a function, but instead set in struct
  file_operations as
      .compat_ioctl = compat_ptr_ioctl,
  On most architectures, the compat_ptr_ioctl() just passes all arguments
  to the corresponding ->ioctl handler. The exception is archs390, where
  compat_ptr() clears the top bit of a 32-bit pointer value, so user space
  pointers to the second 2GB alias the first 2GB, as is the case for
  native 32-bit s390 user space.
  The compat_ptr_ioctl() function must therefore be used only with ioctl
  functions that either ignore the argument or pass a pointer to a
  compatible data type.
  If any ioctl command handled by fops->unlocked_ioctl passes a plain
  integer instead of a pointer, or any of the passed data types
  is incompatible between 32-bit and 64-bit architectures, a proper
  handler is required instead of compat_ptr_ioctl.
 RED-PEN how should LSM module know it's handling 32bit? 
 FICLONE takes an int argument, so don't use compat_ptr() 
 these get messy on amd64 due to alignment differences 
	
	  These access 32-bit values anyway so no further handling is
	  necessary.
	
	  everything else in do_vfs_ioctl() takes either a compatible
	  pointer argument or no argument -- call it with a modified
	  argument.
 SPDX-License-Identifier: GPL-2.0-only
  Performs necessary checks before doing a clone.
  Can adjust amount of bytes to clone via @req_count argument.
  Returns appropriate error code that caller should return or
  zero in case the clone should be allowed.
 The start of both ranges must be aligned to an fs block. 
 Ensure offsets don't wrap. 
 Dedupe requires both ranges to be within EOF. 
 Ensure the infile range is within the infile. 
	
	  If the user wanted us to link to the infile's EOF, round up to the
	  next block boundary for this check.
	 
	  Otherwise, make sure the count is also block-aligned, having
	  already confirmed the starting offsets' block alignment.
 Don't allow overlapped cloning within the same file. 
	
	  We shortened the request but the caller can't deal with that, so
	  bounce the request back to userspace.
  Ensure that we don't remap a partial EOF block in the middle of something
  else.  Assume that the offsets have already been checked for block
  alignment.
  For clone we only link a partial EOF block above or at the destination file's
  EOF.  For deduplication we accept a partial EOF block only if it ends at the
  destination file's EOF (can not link it into the middle of a file).
  Shorten the request if possible.
 Read a page's worth of file data into the page cache. 
  Lock two pages, ensuring that we lock in offset order if the pages are from
  the same file.
 Always lock in order of increasing index. 
 Unlock two pages, being careful not to unlock the same page twice. 
  Compare extents of two files to see if they are the same.
  Caller must have locked both inodes to prevent write races.
		
		  Now that we've locked both pages, make sure they're still
		  mapped to the file data we're interested in.  If not,
		  someone is invalidating pages on us and we lose.
  Check that the two inodes are eligible for cloning, the ranges make
  sense, and then flush all dirty data.  Caller must ensure that the
  inodes have been locked against any other modifications.
  If there's an error, then the usual negative error code is returned.
  Otherwise returns 0 with len set to the request length.
 Don't touch certain kinds of inodes 
 Don't reflink dirs, pipes, sockets... 
 Zero length dedupe exits immediately; reflink goes to EOF. 
 Check that we don't violate system file offset limits. 
 Wait for the completion of any pending IOs on both files 
	
	  Check that the extents are the same.
 If can't alter the file contents, we're done. 
	
	  FICLONEFICLONERANGE ioctls enforce that src and dest files are on
	  the same mount. Practically, they only need to be on the same file
	  system.
 Check whether we are allowed to dedupe the destination file 
	
	  This is redundant if called from vfs_dedupe_file_range(), but other
	  callers need it and it's not performance sesitive...
 Arbitrary 1G limit on a single dedupe request, can be raised. 
 pre-format output fields to sane values 
 SPDX-License-Identifier: GPL-2.0
 The maximal length of core_pattern is also specified in sysctl.c 
 racy but harmless 
		
		  Ensure that this coredump name component can't cause the
		  resulting corefile path to consist of a ".." or ".".
		
		  Empty names are fishy and could be used to create a "" in a
		  corefile name, causing the coredump to happen one directory
		  level too high. Enforce that all components of the core
		  pattern are at least one character long.
 format_corename will inspect the pattern parameter, and output a
  name into corename, which must have space for at least
  CORENAME_MAX_SIZE bytes plus one byte for the zero terminator.
	 Repeat as long as we have more pattern to process and more output
		
		  Split on spaces before doing template expansion so that
		  %e and %E don't get split if they have spaces in them
 single % at the end, drop that 
 Double percent, output one percent 
 pid 
 global pid 
 uid 
 gid 
 signal that caused the coredump 
 UNIX time of coredump 
 hostname 
 executable, could be changed by prctl PR_SET_NAME etc 
 file name of executable 
 core limit size 
	 Backward compatibility with core_uses_pid:
	 
	  If core_pattern does not include a %p (as is the default)
	  and core_uses_pid is set, then .%pid will be appended to
 ignore all signals except SIGKILL, see prepare_signal() 
		
		  Wait for all the threads to become inactive, so that
		  all the thread context (extended register state, like
		  fpu etc) gets copied to the memory.
		
		  see coredump_task_exit(), curr->task must not see
		  ->task == NULL before we read ->next.
	
	  SIGKILL or freezing() interrupt the coredumping. Perhaps we
	  can do try_to_freeze() and check __fatal_signal_pending(),
	  but then we need to teach dump_write() to restart and clear
	  TIF_SIGPENDING.
	
	  We actually want wait_event_freezable() but then we need
	  to clear TIF_SIGPENDING and improve dump_interrupted().
  umh_pipe_setup
  helper function to customize the process used
  to collect the core in userspace.  Specifically
  it sets up a pipe and installs it as fd 0 (stdin)
  for the process.  Returns 0 on success, or
  PTR_ERR on failure.
  Note that it also sets the core limit to 1.  This
  is a special value that we use to trap recursive
  core dumps
 and disallow core files too 
 require nonrelative corefile path and be extra careful 
		
		  We must use the same mm->flags while dumping core to avoid
		  inconsistency of bit flags, since this flag is not protected
		  by any locks.
	
	  We cannot trust fsuid as being the "true" uid of the process
	  nor do we know its entire history. We only know it was tainted
	  so we dump it as root in mode 2, and only into a controlled
	  environment (pipe handler or fully qualified path).
 Setuid core dump mode 
 Dump root private 
			 See umh_pipe_setup() which sets RLIMIT_CORE = 1.
			 
			  Normally core limits are irrelevant to pipes, since
			  we're not writing to the file system, but we use
			  cprm.limit of 1 here as a special value, this is a
			  consistent way to catch recursive crashes.
			  We can still crash if the core_pattern binary sets
			  RLIM_CORE = !1, but it runs as root, and can do
			  lots of stupid things.
			 
			  Note that we use task_tgid_vnr here to grab the pid
			  of the process group leader.  That way we get the
			  right pid if a thread in a multi-threaded
			  core_pattern process dies.
		
		  Unlink the file if it exists unless this is a SUID
		  binary - in that case, we're running around with root
		  privs and don't want to unlink another user's coredump.
			
			  If it doesn't exist, that's fine. If there's some
			  other problem, we'll catch it at the filp_open().
		
		  There is a race between unlinking and creating the
		  file, but if that causes an EEXIST here, that's
		  fine - another process raced with us while creating
		  the corefile, and the other process won. To userspace,
		  what matters is that at least one of the two processes
		  writes its coredump successfully, not which one.
			
			  Using user namespaces, normal user tasks can change
			  their current->fs->root to point to arbitrary
			  directories. Since the intention of the "only dump
			  with a fully qualified path" rule is to control where
			  coredumps may be placed using root privileges,
			  current->fs->root must not be used. Instead, use the
			  root directory of init_task.
		
		  AK: actually i see no reason to not allow this for named
		  pipes etc, but keep the previous behaviour for now.
		
		  Don't dump core if the filesystem changed owner or mode
		  of the file during file creation. This is an issue when
		  a process dumps core while its cwd is e.g. on a vfat
		  filesystem.
 get us an unshared descriptor table; almost always a no-op 
 The cell spufs coredump code reads the file descriptor tables 
		
		  umh disabled with CONFIG_STATIC_USERMODEHELPER_PATH="" would
		  have this set to NULL.
		
		  Ensures that file size is big enough to contain the current
		  file postion. This prevents gdb from complaining about
		  a truncated file if the last "write" to the file was
		  dump_skip.
  Core dumping helper functions.  These are the only things you should
  do on a core-file: use only these functions to write out all the
  necessary info.
		
		  To avoid having to allocate page tables for virtual address
		  ranges that have never been used yet, and also to make it
		  easy to generate sparse core files, use a helper that returns
		  NULL when encountering an empty page table entry that would
		  otherwise have been filled with the zero page.
  The purpose of always_dump_vma() is to make sure that special kernel mappings
  that are useful for post-mortem analysis are included in every core dump.
  In that way we ensure that the core dump is fully interpretable later
  without matching up the same kernel and hardware config to see what PC values
  meant. These special mappings include - vDSO, vsyscall, and other
  architecture specific mappings
 Any vsyscall mappings? 
	
	  Assume that all vmas with a .name op should always be dumped.
	  If this changes, a new vm_ops field can easily be added.
	
	  arch_vma_name() returns non-NULL for special architecture mappings,
	  such as vDSO sections.
  Decide how much of @vma's contents should be included in a core dump.
 always dump the vdso and vsyscall sections 
 support for DAX 
 Hugetlb memory check 
 Do not dump IO mapped devices or special mappings 
 By default, dump shared memory if mapped from an anonymous file. 
 Dump segments that have been written to.  
	
	  If this is the beginning of an executable file mapping,
	  dump the first page to aid in determining what was mapped here.
  Helper function for iterating across a vma list.  It ensures that the caller
  will visit `gate_vma' prior to terminating the search.
  Under the mmap_lock, take a snapshot of relevant information about the task's
  VMAs.
	
	  Once the stack expansion code is fixed to not change VMA bounds
	  under mmap_lock in read mode, this can be changed to take the
	  mmap_lock in read mode.
 SPDX-License-Identifier: GPL-2.0
   linuxfsnamei.c
   Copyright (C) 1991, 1992  Linus Torvalds
  Some corrections by tytso.
 [Feb 1997 T. Schoebel-Theuer] Complete rewrite of the pathname
  lookup logic.
 [Feb-Apr 2000, AV] Rewrite to the new namespace architecture.
 [Feb-1997 T. Schoebel-Theuer]
  Fundamental changes in the pathname lookup mechanisms (namei)
  were necessary because of omirr.  The reason is that omirr needs
  to know the _real_ pathname, not the user-supplied one, in case
  of symlinks (and also when transname replacements occur).
  The new code replaces the old recursive symlink resolution with
  an iterative one (in case of non-nested symlink chains).  It does
  this with calls to <fs>_follow_link().
  As a side effect, dir_namei(), _namei() and follow_link() are now 
  replaced with a single function lookup_dentry() that can handle all 
  the special cases of the former code.
  With the new dcache, the pathname is stored at each inode, at least as
  long as the refcount of the inode is positive.  As a side effect, the
  size of the dcache depends on the inode cache and thus is dynamic.
  [29-Apr-1998 C. Scott Ananian] Updated above description of symlink
  resolution to correspond with current state of the code.
  Note that the symlink resolution is not completely iterative.
  There is still a significant amount of tail- and mid- recursion in
  the algorithm.  Also, note that <fs>_readlink() is not used in
  lookup_dentry(): lookup_dentry() on the result of <fs>_readlink()
  may return different results than <fs>_follow_link().  Many virtual
  filesystems (including proc) exhibit this behavior.
 [24-Feb-97 T. Schoebel-Theuer] Side effects caused by new implementation:
  New symlink semantics: when open() is called with flags O_CREAT | O_EXCL
  and the name already exists in form of a symlink, try to create the new
  name indicated by the symlink. The old code always complained that the
  name already exists, due to not following the symlink even if its target
  is nonexistent.  The new semantics affects also mknod() and link() when
  the name is a symlink pointing to a non-existent name.
  I don't know which semantics is the right one, since I have no access
  to standards. But I found by trial that HP-UX 9.0 has the full "new"
  semantics implemented, while SunOS 4.1.1 and Solaris (SunOS 5.4) have the
  "old" one. Personally, I think the new semantics is much more logical.
  Note that "ln old new" where "new" is a symlink pointing to a non-existing
  file does succeed in both HP-UX and SunOs, but not in Solaris
  and in the old Linux semantics.
 [16-Dec-97 Kevin Buhr] For security reasons, we change some symlink
  semantics.  See the comments in "open_namei" and "do_link" below.
  [10-Sep-98 Alan Modra] Another symlink change.
 [Feb-Apr 2000 AV] Complete rewrite. Rules for symlinks:
 	inside the path - always follow.
 	in the last component in creationremovalrenaming - never follow.
 	if LOOKUP_FOLLOW passed - follow.
 	if the pathname has trailing slashes - follow.
 	otherwise - don't follow.
  (applied in that order).
  [Jun 2000 AV] Inconsistent behaviour of open() in case if flags==O_CREAT
  restored for 2.4. This is the last surviving part of old 4.2BSD bug.
  During the 2.4 we need to fix the userland stuff depending on it -
  hopefully we will be able to get rid of that wart in 2.5. So far only
  XEmacs seems to be relying on it...
  [Sep 2001 AV] Single-semaphore locking scheme (kudos to David Holland)
  implemented.  Let's see if raised priority of ->s_vfs_rename_mutex gives
  any extra contention...
 In order to reduce some races, while at the same time doing additional
  checking and hopefully speeding things up, we copy filenames to the
  kernel data space before using them..
  POSIX.1 2.4: an empty pathname is invalid (ENOENT).
  PATH_MAX includes the nul terminator --RR.
	
	  First, try to embed the struct filename inside the names_cache
	  allocation
	
	  Uh-oh. We have a name that's approaching PATH_MAX. Allocate a
	  separate struct filename so we can dedicate the entire
	  names_cache allocation for the pathname, and re-do the copy from
	  userland.
		
		  size is chosen that way we to guarantee that
		  result->iname[0] is within the same object and that
		  kname can't be equal to result->iname, no matter what.
 The empty path is special. 
  check_acl - perform ACL permission checking
  @mnt_userns:	user namespace of the mount the inode was found from
  @inode:	inode to check permissions on
  @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...)
  This function performs the ACL permission checking. Since this function
  retrieve POSIX acls it needs to know whether it is called from a blocking or
  non-blocking context and thus cares about the MAY_NOT_BLOCK bit.
  If the inode has been found through an idmapped mount the user namespace of
  the vfsmount must be passed through @mnt_userns. This function will then take
  care to map the inode according to @mnt_userns before checking permissions.
  On non-idmapped mounts or if permission checking is to be performed on the
  raw inode simply passs init_user_ns.
 no ->get_acl() calls in RCU mode... 
  acl_permission_check - perform basic UNIX permission checking
  @mnt_userns:	user namespace of the mount the inode was found from
  @inode:	inode to check permissions on
  @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...)
  This function performs the basic UNIX permission checking. Since this
  function may retrieve POSIX acls it needs to know whether it is called from a
  blocking or non-blocking context and thus cares about the MAY_NOT_BLOCK bit.
  If the inode has been found through an idmapped mount the user namespace of
  the vfsmount must be passed through @mnt_userns. This function will then take
  care to map the inode according to @mnt_userns before checking permissions.
  On non-idmapped mounts or if permission checking is to be performed on the
  raw inode simply passs init_user_ns.
 Are we the owner? If so, ACL's don't matter 
 Do we have ACL's? 
 Only RWX matters for groupother mode bits 
	
	  Are the group permissions different from
	  the other permissions in the bits we care
	  about? Need to check group ownership if so.
 Bits in 'mode' clear that we require? 
  generic_permission -  check for access rights on a Posix-like filesystem
  @mnt_userns:	user namespace of the mount the inode was found from
  @inode:	inode to check access rights for
  @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC,
 		%MAY_NOT_BLOCK ...)
  Used to check for readwriteexecute permissions on a file.
  We use "fsuid" for this, letting us set arbitrary permissions
  for filesystem access without changing the "normal" uids which
  are used for other things.
  generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk
  request cannot be satisfied (eg. requires blocking or too much complexity).
  It would then be called again in ref-walk mode.
  If the inode has been found through an idmapped mount the user namespace of
  the vfsmount must be passed through @mnt_userns. This function will then take
  care to map the inode according to @mnt_userns before checking permissions.
  On non-idmapped mounts or if permission checking is to be performed on the
  raw inode simply passs init_user_ns.
	
	  Do the basic permission checks.
 DACs are overridable for directories 
	
	  Searching includes executable on directories, else just read.
	
	  Readwrite DACs are always overridable.
	  Executable DACs are overridable when there is
	  at least one exec bit set.
  do_inode_permission - UNIX permission checking
  @mnt_userns:	user namespace of the mount the inode was found from
  @inode:	inode to check permissions on
  @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...)
  We _really_ want to just do "generic_permission()" without
  even looking at the inode->i_op values. So we keep a cache
  flag in inode->i_opflags, that says "this has not special
  permission function, use the fast case".
 This gets set once for the inode lifetime 
  sb_permission - Check superblock-level permissions
  @sb: Superblock of inode to check permission on
  @inode: Inode to check permission on
  @mask: Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)
  Separate out file-system wide checks from inode-specific permission checks.
 Nobody gets write access to a read-only fs. 
  inode_permission - Check for access rights to a given inode
  @mnt_userns:	User namespace of the mount the inode was found from
  @inode:	Inode to check permission on
  @mask:	Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)
  Check for readwriteexecute permissions on an inode.  We use fs[ug]id for
  this, letting us set arbitrary permissions for filesystem access without
  changing the "normal" UIDs which are used for other things.
  When checking for MAY_APPEND, MAY_WRITE must also be set in @mask.
		
		  Nobody gets write access to an immutable file.
		
		  Updating mtime will likely cause i_uid and i_gid to be
		  written back improperly if their true value is unknown
		  to the vfs.
  path_get - get a reference to a path
  @path: path to get the reference to
  Given a path increment the reference count to the dentry and the vfsmount.
  path_put - put a reference to a path
  @path: path to put the reference to
  Given a path decrement the reference count to the dentry and the vfsmount.
 path.dentry.d_inode 
  path_connected - Verify that a dentry is below mnt.mnt_root
  Rename can sometimes move a file or directory outside of a bind
  mount, path_connected allows those cases to be detected.
 Bind mounts can have disconnected paths 
 path_put is needed afterwards regardless of success or failure 
	
	  For scoped-lookups (where nd->root has been zeroed), we need to
	  restart the whole lookup from scratch -- because set_root() is wrong
	  for these lookups (nd->dfd is the root, not the filesystem root).
 Nothing to do if nd->root is zero or is managed by the VFS user. 
  Path walking has 2 modes, rcu-walk and ref-walk (see
  Documentationfilesystemspath-lookup.txt).  In situations when we can't
  continue in RCU mode, we attempt to drop out of rcu-walk mode and grab
  normal reference counts on dentries and vfsmounts to transition to ref-walk
  mode.  Refcounts are grabbed at the last known good point before rcu-walk
  got stuck, so ref-walk may continue from there. If this is not successful
  (eg. a seqcount has changed), then failure is returned and it's up to caller
  to restart the path walk from the beginning in ref-walk mode.
  try_to_unlazy - try to switch to ref-walk mode.
  @nd: nameidata pathwalk data
  Returns: true on success, false on failure
  try_to_unlazy attempts to legitimize the current nd->path and nd->root
  for ref-walk mode.
  Must be called from rcu-walk context.
  Nothing should touch nameidata between try_to_unlazy() failure and
  terminate_walk().
  try_to_unlazy_next - try to switch to ref-walk mode.
  @nd: nameidata pathwalk data
  @dentry: next dentry to step into
  @seq: seq number to check @dentry against
  Returns: true on success, false on failure
  Similar to to try_to_unlazy(), but here we have the next dentry already
  picked by rcu-walk and want to legitimize that in addition to the current
  nd->path and nd->root for ref-walk mode.  Must be called from rcu-walk context.
  Nothing should touch nameidata between try_to_unlazy_next() failure and
  terminate_walk().
	
	  We need to move both the parent and the dentry from the RCU domain
	  to be properly refcounted. And the sequence number in the dentry
	  validates both dentry counters, since we checked the sequence
	  number of the parent after we got the child sequence number. So we
	  know the parent must still be valid if the child sequence number is
	
	  Sequence counts matched. Now make sure that the root is
	  still valid and get it if required.
  complete_walk - successful completion of path walk
  @nd:  pointer nameidata
  If we had been in RCU mode, drop out of it and legitimize nd->path.
  Revalidate the final result, unless we'd already done that during
  the path walk or the filesystem doesn't ask for it.  Return 0 on
  success, -error on failure.  In case of failure caller does not
  need to drop nd->path.
		
		  We don't want to zero nd->root for scoped-lookups or
		  externally-managed nd->root.
		
		  While the guarantee of LOOKUP_IS_SCOPED is (roughly) "don't
		  ever step outside the root during lookup" and should already
		  be guaranteed by the rest of namei, we want to avoid a namei
		  BUG resulting in userspace being given a path that was not
		  scoped within the root at some point during the lookup.
		 
		  So, do a final sanity-check to make sure that in the
		  worst-case scenario (a complete bypass of LOOKUP_IS_SCOPED)
		  we won't silently return an fd completely outside of the
		  requested root to userspace.
		 
		  Userspace could move the path outside the root after this
		  check, but as discussed elsewhere this is not a concern (the
		  resolved file was inside the root at some point).
	
	  Jumping to the real root in a scoped-lookup is a BUG in namei, but we
	  still have to ensure it doesn't happen because it will cause a breakout
	  from the dirfd.
 Absolute path arguments to path_init() are allowed. 
  Helper to directly jump to a known parsed path from ->get_link,
  caller must have taken a reference to path beforehand.
 Not currently safe for scoped-lookups. 
  may_follow_link - Check symlink following for unsafe situations
  @nd: nameidata pathwalk data
  In the case of the sysctl_protected_symlinks sysctl being enabled,
  CAP_DAC_OVERRIDE needs to be specifically ignored if the symlink is
  in a sticky world-writable directory. This is to protect privileged
  processes from failing races against path names that may change out
  from under them by way of other users creating malicious symlinks.
  It will permit symlinks to be followed only when outside a sticky
  world-writable directory, or when the uid of the symlink and follower
  match, or when the directory owner matches the symlink's owner.
  Returns 0 if following the symlink is allowed, -ve on error.
 Allowed if owner and follower match. 
 Allowed if parent directory not sticky and world-writable. 
 Allowed if parent directory and link owner match. 
  safe_hardlink_source - Check for safe hardlink conditions
  @mnt_userns:	user namespace of the mount the inode was found from
  @inode: the source inode to hardlink from
  Return false if at least one of the following conditions:
     - inode is not a regular file
     - inode is setuid
     - inode is setgid and group-exec
     - access failure for read and write
  Otherwise returns true.
 Special files should not get pinned to the filesystem. 
 Setuid files should not get pinned to the filesystem. 
 Executable setgid files should not get pinned to the filesystem. 
 Hardlinking to unreadable or unwritable sources is dangerous. 
  may_linkat - Check permissions for creating a hardlink
  @mnt_userns:	user namespace of the mount the inode was found from
  @link: the source to hardlink from
  Block hardlink when all of:
   - sysctl_protected_hardlinks enabled
   - fsuid does not match inode
   - hardlink source is unsafe (see safe_hardlink_source() above)
   - not CAP_FOWNER in a namespace with the inode owner uid mapped
  If the inode has been found through an idmapped mount the user namespace of
  the vfsmount must be passed through @mnt_userns. This function will then take
  care to map the inode according to @mnt_userns before checking permissions.
  On non-idmapped mounts or if permission checking is to be performed on the
  raw inode simply passs init_user_ns.
  Returns 0 if successful, -ve on error.
 Inode writeback is not safe when the uid or gid are invalid. 
	 Source inode owner (or CAP_FOWNER) can hardlink all they like,
	  otherwise, it must be a safe source.
  may_create_in_sticky - Check whether an O_CREAT open in a sticky directory
 			  should be allowed, or not, on files that already
 			  exist.
  @mnt_userns:	user namespace of the mount the inode was found from
  @nd: nameidata pathwalk data
  @inode: the inode of the file to open
  Block an O_CREAT open of a FIFO (or a regular file) when:
    - sysctl_protected_fifos (or sysctl_protected_regular) is enabled
    - the file already exists
    - we are in a sticky directory
    - we don't own the file
    - the owner of the directory doesn't own the file
    - the directory is world writable
  If the sysctl_protected_fifos (or sysctl_protected_regular) is set to 2
  the directory doesn't have to be world writable: being group writable will
  be enough.
  If the inode has been found through an idmapped mount the user namespace of
  the vfsmount must be passed through @mnt_userns. This function will then take
  care to map the inode according to @mnt_userns before checking permissions.
  On non-idmapped mounts or if permission checking is to be performed on the
  raw inode simply passs init_user_ns.
  Returns 0 if the open is allowed, -ve on error.
  follow_up - Find the mountpoint of path's vfsmount
  Given a path, find the mountpoint of its source file system.
  Replace @path with the path of the mountpoint in the parent mount.
  Up is towards .
  Return 1 if we went up a level and 0 if we were already at the
  root.
  Perform an automount
  - return -EISDIR to tell follow_managed() to stop and return the path we
    were called with.
	 We don't want to mount if someone's just doing a stat -
	  unless they're stat'ing a directory and appended a '' to
	  the name.
	 
	  We do, however, want to mount if someone wants to open or
	  create a file of any type under the mountpoint, wants to
	  traverse through the mountpoint or wants to open the
	  mounted directory.  Also, autofs may mark negative dentries
	  as being automount points.  These will need the attentions
	  of the daemon to instantiate them before they can be used.
  mount traversal - out-of-line part.  One note on ->d_flags accesses -
  dentries are pinned but not locked here, so negative dentry can go
  positive right under us.  Use of smp_load_acquire() provides a barrier
  sufficient for ->d_inode and ->d_flags consistency.
		 Allow the filesystem to manage the transit without i_mutex
 something's mounted on it..
 ... in our namespace
 here we know it's positive
 uncovered automount point
 possible if you race with several mount --move
 fastpath 
  Follow down to the covering mount currently visible to userspace.  At each
  point, the filesystem owning that dentry may be queried as to whether the
  caller is permitted to proceed or not.
  Try to skip to top of mountpoint pile in rcuwalk mode.  Fail if
  we meet a managed dentry that would need blocking.
		
		  Don't forget we might have a non-mountpoint managed dentry
		  that wants to block transit.
				
				  We don't need to re-check ->d_seq after this
				  ->d_inode read - there will be an RCU delay
				  between mount hash removal and ->mnt_root
				  becoming unpinned.
 path might've been clobbered by __follow_mount_rcu()
 out of RCU mode, so the value doesn't matter 
  This looks up the name in dcache and possibly revalidates the found dentry.
  NULL is returned if the dentry does not exist in the cache.
  Parent directory has inode locked exclusive.  This is one
  and only case when ->lookup() gets called on non in-lookup
  dentries - as the matter of fact, this only gets called
  when directory is guaranteed to have no in-lookup children
  at all.
 Don't create child dentry for a dead directory. 
	
	  Rename seqlock is not required here because in the off chance
	  of a false negative due to a concurrent rename, the caller is
	  going to fall back to non-racy lookup.
		
		  This sequence count validates that the inode matches
		  the dentry name information from lookup.
		
		  This sequence count validates that the parent had no
		  changes while we did the lookup of the dentry above.
		 
		  The memory barrier in read_seqcount_begin of child is
		   enough, we can use __read_seqcount_retry here.
 we'd been told to redo it in non-rcu mode 
 Fast lookup failed, do it the slow way 
 Don't go there if it's already dead 
 we need to grab link before we do unlazy.  And we can't skip
 unlazy even if we fail to grab the link - cleanup needs it
 pure jump
  Do we need to follow links? We _really_ want to be able
  to do this check without having to look at inode->i_op,
  so we keep a cache of "no, this doesn't need follow_link"
  for the common case.
 not a symlink or should not follow 
 make sure that d_is_symlink above matches inode 
 we know that mountpoint was pinned 
 rare case of legitimate dget_parent()... 
			
			  If there was a racing rename or mount along our
			  path, then we can't be sure that ".." hasn't jumped
			  above nd->root (and so userspace should retry or use
			  some fallback).
	
	  "." and ".." are special - ".." especially so because it has
	  to be able to know about the current root directory and
	  parent relationships.
  We can do the critical dentry name comparison and hashing
  operations one word at a time, but we are limited to:
  - Architectures with fast unaligned word accesses. We could
    do a "get_unaligned()" if this helps and is sufficiently
    fast.
  - non-CONFIG_DEBUG_PAGEALLOC configurations (so that we
    do not trap on the (extremely unlikely) case of a page
    crossing operation.
  - Furthermore, we need an efficient 64-bit compile for the
    64-bit case in order to generate the "number of bytes in
    the final mask". Again, that could be replaced with a
    efficient population count instruction or similar.
 Architecture provides HASH_MIX and fold_hash() in <asmhash.h> 
  Register pressure in the mixing function is an issue, particularly
  on 32-bit x86, but almost any function requires one state value and
  one temporary.  Instead, use a function designed for two state values
  and no temporaries.
  This function cannot create a collision in only two iterations, so
  we have two iterations to achieve avalanche.  In those two iterations,
  we have six layers of mixing, which is enough to spread one bit's
  influence out to 2^6 = 64 state bits.
  Rotate constants are scored by considering either 64 one-bit input
  deltas or 64632 = 2016 two-bit input deltas, and finding the
  probability of that delta causing a change to each of the 128 output
  bits, using a sample of random initial states.
  The Shannon entropy of the computed probabilities is then summed
  to produce a score.  Ideally, any input change has a 50% chance of
  toggling any given output bit.
  Mixing scores (in bits) for (12,45):
  Input delta: 1-bit      2-bit
  1 round:     713.3    42542.6
  2 rounds:   2753.7   140389.8
  3 rounds:   5954.1   233458.2
  4 rounds:   7862.6   256672.2
  Perfect:    8192     258048
             (64128) (64632  128)
  Fold two longs into one 32-bit hash value.  This must be fast, but
  latency isn't quite as critical, as there is a fair bit of additional
  work done before the hash value is used.
 32-bit case 
  Mixing scores (in bits) for (7,20):
  Input delta: 1-bit      2-bit
  1 round:     330.3     9201.6
  2 rounds:   1246.4    25475.4
  3 rounds:   1907.1    31295.1
  4 rounds:   2042.3    31718.6
  Perfect:    2048      31744
             (3264)   (32312  64)
 Use arch-optimized multiply if one exists 
  Return the hash of a string of known length.  This is carfully
  designed to match hash_name(), which is the more critical function.
  In particular, we must end by hashing a final word containing 0..7
  payload bytes, to match the way that hash_name() iterates until it
  finds the delimiter after the name.
 Return the "hash_len" (hash and length) of a null-terminated string 
  Calculate the length and hash of the path component, and
  return the "hash_len" as the result.
 !CONFIG_DCACHE_WORD_ACCESS: Slow, byte-at-a-time version 
 Return the hash of a string of known length 
 Return the "hash_len" (hash and length) of a null-terminated string 
  We know there's a real path component here of at least
  one character.
  Name resolution.
  This is the basic name resolution function, turning a pathname into
  the final dentry. We expect 'base' to be positive and a directory.
  Returns 0 and nd will have valid dentry and mnt on success.
  Returns error and drops reference to input namei data on failure.
 depth <= nd->depth
 short-circuit the 'hardening' idiocy
 At this point we know we have a real path component. 
		
		  If it wasn't NUL, we know it was ''. Skip that
		  slash, and continue until no more slashes.
 pathname or trailing symlink, done 
 last component of nested symlink 
 not the last component 
 a symlink to follow 
 must be paired with terminate_walk() 
 LOOKUP_CACHED requires RCU, ask caller to retry 
 Absolute pathname -- fetch the root (LOOKUP_IN_ROOT uses nd->dfd). 
 Relative pathname -- get the starting-point it is relative to. 
 Caller must check execute permissions on the starting path component 
 For scoped-lookups we need to set the root to the dirfd as well. 
 Returns 0 and nd will be valid on success; Retuns error, otherwise. 
 no d_weak_revalidate(), please...
 Returns 0 and nd will be valid on success; Retuns error, otherwise. 
 Note: this does not consume "name" 
 does lookup, returns the object with parent locked 
  vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair
  @dentry:  pointer to dentry of the base directory
  @mnt: pointer to vfs mount of the base directory
  @name: pointer to file name
  @flags: lookup flags
  @path: pointer to struct path to fill
 the first argument of filename_lookup() is ignored with root 
	
	  See if the low-level filesystem might want
	  to use its own hash..
  try_lookup_one_len - filesystem helper to lookup single pathname component
  @name:	pathname component to lookup
  @base:	base directory to lookup from
  @len:	maximum length @len should be interpreted to
  Look up a dentry by name in the dcache, returning NULL if it does not
  currently exist.  The function does not try to create a dentry.
  Note that this routine is purely a helper for filesystem usage and should
  not be called by generic code.
  The caller must hold base->i_mutex.
  lookup_one_len - filesystem helper to lookup single pathname component
  @name:	pathname component to lookup
  @base:	base directory to lookup from
  @len:	maximum length @len should be interpreted to
  Note that this routine is purely a helper for filesystem usage and should
  not be called by generic code.
  The caller must hold base->i_mutex.
  lookup_one - filesystem helper to lookup single pathname component
  @mnt_userns:	user namespace of the mount the lookup is performed from
  @name:	pathname component to lookup
  @base:	base directory to lookup from
  @len:	maximum length @len should be interpreted to
  Note that this routine is purely a helper for filesystem usage and should
  not be called by generic code.
  The caller must hold base->i_mutex.
  lookup_one_len_unlocked - filesystem helper to lookup single pathname component
  @name:	pathname component to lookup
  @base:	base directory to lookup from
  @len:	maximum length @len should be interpreted to
  Note that this routine is purely a helper for filesystem usage and should
  not be called by generic code.
  Unlike lookup_one_len, it should be called without the parent
  i_mutex held, and will take the i_mutex itself if necessary.
  Like lookup_one_len_unlocked(), except that it yields ERR_PTR(-ENOENT)
  on negatives.  Returns known positive or ERR_PTR(); that's what
  most of the users want.  Note that pinned negative with unlocked parent
  _can_ become positive at any time, so callers of lookup_one_len_unlocked()
  need to be very careful; pinned positives have ->d_inode stable, so
  this one avoids such problems.
	 Find something mounted on "pts" in the same directory as
	  the input path.
 	Check whether we can remove a link victim from directory dir, check
   whether the type of victim is right.
   1. We can't do it if dir is read-only (done in permission())
   2. We should have write and exec permissions on dir
   3. We can't remove anything from append-only dir
   4. We can't do anything with immutable dir (done in permission())
   5. If the sticky bit on dir is set we should either
 	a. be owner of dir, or
 	b. be owner of victim, or
 	c. have CAP_FOWNER capability
   6. If the victim is append-only or immutable we can't do antyhing with
      links pointing to it.
   7. If the victim has an unknown uid or gid we can't change the inode.
   8. If we were asked to remove a directory and victim isn't one - ENOTDIR.
   9. If we were asked to remove a non-directory and victim isn't one - EISDIR.
  10. We can't remove a root or mountpoint.
  11. We don't allow removal of NFS sillyrenamed files; it's handled by
      nfs_async_unlink().
 Inode writeback is not safe when the uid or gid are invalid. 
	Check whether we can create an object with dentry child in directory
   dir.
   1. We can't do it if child already exists (open has special treatment for
      this case, but since we are inlined it's OK)
   2. We can't do it if dir is read-only (done in permission())
   3. We can't do it if the fs can't represent the fsuid or fsgid.
   4. We should have write and exec permissions on dir
   5. We can't do it if dir is immutable (done in permission())
  p1 and p2 should be directories on the same fs.
  vfs_create - create new file
  @mnt_userns:	user namespace of the mount the inode was found from
  @dir:	inode of @dentry
  @dentry:	pointer to dentry of the base directory
  @mode:	mode of the new file
  @want_excl:	whether the file must not yet exist
  Create a new file.
  If the inode has been found through an idmapped mount the user namespace of
  the vfsmount must be passed through @mnt_userns. This function will then take
  care to map the inode according to @mnt_userns before checking permissions.
  On non-idmapped mounts or if permission checking is to be performed on the
  raw inode simply passs init_user_ns.
 shouldn't it be ENOSYS? 
	
	  An append-only file must be opened in append mode for writing.
 O_NOATIME can only be set by the owner or superuser 
  Attempt to atomically look up, create and open a file from a negative
  dentry.
  Returns 0 if successful.  The file will have been created and attached to
  @file by the filesystem calling finish_open().
  If the file was looked up only or didn't need creating, FMODE_OPENED won't
  be set.  The caller will need to perform the open themselves.  @path will
  have been updated to point to the new dentry.  This may be negative.
  Returns an error code otherwise.
  Look up and maybe create and open the last component.
  Must be called with parent locked (exclusive in O_CREAT case).
  Returns 0 on success, that is, if
   the file was successfully atomically created (if necessary) and opened, or
   the file was not completely opened at this time, though lookups and
   creations were performed.
  These case are distinguished by presence of FMODE_OPENED on file->f_mode.
  In the latter case dentry returned in @path might be negative if O_CREAT
  hadn't been specified.
  An error code is returned on failure.
 Cached positive dentry: will open in f_op->open 
	
	  Checking write permission is tricky, bacuse we don't know if we are
	  going to actually need it: O_CREAT opens should work as long as the
	  file exists.  But checking existence breaks atomicity.  The trick is
	  to check access and if not granted clear O_CREAT from the flags.
	 
	  Another problem is returing the "right" error value (e.g. for an
	  O_EXCL open we want to return EEXIST not EROFS).
 Negative dentry, just create the file 
 we _can_ be in RCU mode here 
 create side of things 
 trailing slashes? 
		
		  do _not_ fail yet - we might not need that or fail with
		  a different error; let lookup_open() decide; we'll be
		  dropping this one anyway.
  Handle the last step of open()
 Don't check for write permission, don't truncate 
  vfs_tmpfile - create tmpfile
  @mnt_userns:	user namespace of the mount the inode was found from
  @dentry:	pointer to dentry of the base directory
  @mode:	mode of the new tmpfile
  @open_flag:	flags
  Create a temporary file.
  If the inode has been found through an idmapped mount the user namespace of
  the vfsmount must be passed through @mnt_userns. This function will then take
  care to map the inode according to @mnt_userns before checking permissions.
  On non-idmapped mounts or if permission checking is to be performed on the
  raw inode simply passs init_user_ns.
 we want directory to be writable 
 Don't check for other permissions, the inode was just created 
	
	  Note that only LOOKUP_REVAL and LOOKUP_DIRECTORY matter here. Any
	  other flags passed in are ignored!
	
	  Yucky last component or no last component at all?
	  (foo., foo.., )
 don't fail immediately if it's ro, at least try to report other errors 
	
	  Do the final lookup.
	
	  Special case - lookup gave negative, but... we had foobar
	  From the vfs_mknod() POV we just have a negative dentry -
	  all is fine. Let's be bastards - you had  on the end, you've
	  been asking for (non-existent) directory. -ENOENT for you.
  vfs_mknod - create device node or file
  @mnt_userns:	user namespace of the mount the inode was found from
  @dir:	inode of @dentry
  @dentry:	pointer to dentry of the base directory
  @mode:	mode of the new device node or file
  @dev:	device number of device to create
  Create a device node or file.
  If the inode has been found through an idmapped mount the user namespace of
  the vfsmount must be passed through @mnt_userns. This function will then take
  care to map the inode according to @mnt_userns before checking permissions.
  On non-idmapped mounts or if permission checking is to be performed on the
  raw inode simply passs init_user_ns.
 zero mode translates to S_IFREG 
  vfs_mkdir - create directory
  @mnt_userns:	user namespace of the mount the inode was found from
  @dir:	inode of @dentry
  @dentry:	pointer to dentry of the base directory
  @mode:	mode of the new directory
  Create a directory.
  If the inode has been found through an idmapped mount the user namespace of
  the vfsmount must be passed through @mnt_userns. This function will then take
  care to map the inode according to @mnt_userns before checking permissions.
  On non-idmapped mounts or if permission checking is to be performed on the
  raw inode simply passs init_user_ns.
  vfs_rmdir - remove directory
  @mnt_userns:	user namespace of the mount the inode was found from
  @dir:	inode of @dentry
  @dentry:	pointer to dentry of the base directory
  Remove a directory.
  If the inode has been found through an idmapped mount the user namespace of
  the vfsmount must be passed through @mnt_userns. This function will then take
  care to map the inode according to @mnt_userns before checking permissions.
  On non-idmapped mounts or if permission checking is to be performed on the
  raw inode simply passs init_user_ns.
  vfs_unlink - unlink a filesystem object
  @mnt_userns:	user namespace of the mount the inode was found from
  @dir:	parent directory
  @dentry:	victim
  @delegated_inode: returns victim inode, if the inode is delegated.
  The caller must hold dir->i_mutex.
  If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and
  return a reference to the inode in delegated_inode.  The caller
  should then break the delegation on that inode and retry.  Because
  breaking a delegation may take a long time, the caller should drop
  dir->i_mutex before doing so.
  Alternatively, a caller may pass NULL for delegated_inode.  This may
  be appropriate for callers that expect the underlying filesystem not
  to be NFS exported.
  If the inode has been found through an idmapped mount the user namespace of
  the vfsmount must be passed through @mnt_userns. This function will then take
  care to map the inode according to @mnt_userns before checking permissions.
  On non-idmapped mounts or if permission checking is to be performed on the
  raw inode simply passs init_user_ns.
 We don't d_delete() NFS sillyrenamed files--they still exist. 
  Make sure that the actual truncation of the file will occur outside its
  directory's i_mutex.  Truncate can take a long time if there is a lot of
  writeout happening, and we don't want to prevent access to the directory
  while waiting on the IO.
 Why not before? Because we want correct error value 
 truncate the inode here 
  vfs_symlink - create symlink
  @mnt_userns:	user namespace of the mount the inode was found from
  @dir:	inode of @dentry
  @dentry:	pointer to dentry of the base directory
  @oldname:	name of the file to link to
  Create a symlink.
  If the inode has been found through an idmapped mount the user namespace of
  the vfsmount must be passed through @mnt_userns. This function will then take
  care to map the inode according to @mnt_userns before checking permissions.
  On non-idmapped mounts or if permission checking is to be performed on the
  raw inode simply passs init_user_ns.
  vfs_link - create a new link
  @old_dentry:	object to be linked
  @mnt_userns:	the user namespace of the mount
  @dir:	new parent
  @new_dentry:	where to create the new link
  @delegated_inode: returns inode needing a delegation break
  The caller must hold dir->i_mutex
  If vfs_link discovers a delegation on the to-be-linked file in need
  of breaking, it will return -EWOULDBLOCK and return a reference to the
  inode in delegated_inode.  The caller should then break the delegation
  and retry.  Because breaking a delegation may take a long time, the
  caller should drop the i_mutex before doing so.
  Alternatively, a caller may pass NULL for delegated_inode.  This may
  be appropriate for callers that expect the underlying filesystem not
  to be NFS exported.
  If the inode has been found through an idmapped mount the user namespace of
  the vfsmount must be passed through @mnt_userns. This function will then take
  care to map the inode according to @mnt_userns before checking permissions.
  On non-idmapped mounts or if permission checking is to be performed on the
  raw inode simply passs init_user_ns.
	
	  A link to an append-only or immutable file cannot be created.
	
	  Updating the link count will likely cause i_uid and i_gid to
	  be writen back improperly if their true value is unknown to
	  the vfs.
 Make sure we don't allow creating hardlink to an unlinked file 
  Hardlinks are often used in delicate situations.  We avoid
  security-related surprises by not following symlinks on the
  newname.  --KAB
  We don't follow them on the oldname either to be compatible
  with linux 2.0, and to avoid hard-linking to directories
  and other special files.  --ADM
	
	  To use null names we require CAP_DAC_READ_SEARCH
	  This ensures that not everyone will be able to create
	  handlink using the passed filedescriptor.
  vfs_rename - rename a filesystem object
  @rd:		pointer to &struct renamedata info
  The caller must hold multiple mutexes--see lock_rename()).
  If vfs_rename discovers a delegation in need of breaking at either
  the source or destination, it will return -EWOULDBLOCK and return a
  reference to the inode in delegated_inode.  The caller should then
  break the delegation and retry.  Because breaking a delegation may
  take a long time, the caller should drop all locks before doing
  so.
  Alternatively, a caller may pass NULL for delegated_inode.  This may
  be appropriate for callers that expect the underlying filesystem not
  to be NFS exported.
  The worst of all namespace operations - renaming directory. "Perverted"
  doesn't even start to describe it. Somebody in UCB had a heck of a trip...
  Problems:
 	a) we can get into loop creation.
 	b) race potential - two innocent renames can create a loop together.
 	   That's where 4.4 screws up. Current fix: serialization on
 	   sb->s_vfs_rename_mutex. We might be more accurate, but that's another
 	   story.
 	c) we have to lock _four_ objects - parents and victim (if it exists),
 	   and source (if it is not a directory).
 	   And that - after we got ->i_mutex on parents (until then we don't know
 	   whether the target exists).  Solution: try to be smart with locking
 	   order for inodes.  We rely on the fact that tree topology may change
 	   only under ->s_vfs_rename_mutex _and_ that parent of the object we
 	   move will be locked.  Thus we can rank directories by the tree
 	   (ancestors first) and rank all non-directories after them.
 	   That works since everybody except rename does "lock parent, lookup,
 	   lock child" and rename is under ->s_vfs_rename_mutex.
 	   HOWEVER, it relies on the assumption that any object with ->lookup()
 	   has no more than 1 dentry.  If "hybrid" objects will ever appear,
 	   we'd better make sure that there's no link(2) for them.
 	d) conversion from fhandle to dentry may come in the wrong moment - when
 	   we are removing the target. Solution: we will have to grab ->i_mutex
 	   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on
 	   ->i_mutex on parents, which works but leads to some truly excessive
 	   locking].
	
	  If we are going to change the parent - check write permissions,
	  we'll need to flip '..'.
 source must exist 
 unless the source is a directory trailing slashes give -ENOTDIR 
 source should not be ancestor of target 
 target should not be an ancestor of source 
  vfs_readlink - copy symlink body into userspace buffer
  @dentry: dentry on which to get symbolic link
  @buffer: user memory pointer
  @buflen: size of buffer
  Does not touch atime.  That's up to the caller if necessary
  Does not call security hook.
  vfs_get_link - get symlink body
  @dentry: dentry on which to get symbolic link
  @done: caller needs to free returned data with this
  Calls security hook and i_op->get_link() on the supplied inode.
  It does not touch atime.  That's up to the caller if necessary.
  Does not work on "special" symlinks like proc$$fdN
 get the link contents into pagecache 
  The nofs argument instructs pagecache_write_begin to pass AOP_FLAG_NOFS
