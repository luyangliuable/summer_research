 SPDX-License-Identifier: GPL-2.0
  ACRN: Memory mapping management
  Copyright (C) 2020 Intel Corporation. All rights reserved.
  Authors:
 	Fei Li <lei1.li@intel.com>
 	Shuo Liu <shuo.a.liu@intel.com>
  acrn_mm_region_add() - Set up the EPT mapping of a memory region.
  @vm:			User VM.
  @user_gpa:		A GPA of User VM.
  @service_gpa:	A GPA of Service VM.
  @size:		Size of the region.
  @mem_type:		Combination of ACRN_MEM_TYPE_.
  @mem_access_right:	Combination of ACRN_MEM_ACCESS_.
  Return: 0 on success, <0 on error.
  acrn_mm_region_del() - Del the EPT mapping of a memory region.
  @vm:		User VM.
  @user_gpa:	A GPA of the User VM.
  @size:	Size of the region.
  Return: 0 on success, <0 for error.
  acrn_vm_ram_map() - Create a RAM EPT mapping of User VM.
  @vm:		The User VM pointer
  @memmap:	Info of the EPT mapping
  Return: 0 on success, <0 for error.
 Get the page number of the map region 
 Lock the pages of user memory map region 
 Create a kernel map for the map region 
 Record Service VM va <-> User VM pa mapping 
 Calculate count of vm_memory_region_op 
 Prepare the vm_memory_region_batch 
 Fill each vm_memory_region_op 
 Inform the ACRN Hypervisor to set up EPT mappings 
  acrn_vm_all_ram_unmap() - Destroy a RAM EPT mapping of User VM.
  @vm:	The User VM
 SPDX-License-Identifier: GPL-2.0
  ACRN HSM irqfd: use eventfd objects to inject virtual interrupts
  Copyright (C) 2020 Intel Corporation. All rights reserved.
  Authors:
 	Shuo Liu <shuo.a.liu@intel.com>
 	Yakui Zhao <yakui.zhao@intel.com>
  struct hsm_irqfd - Properties of HSM irqfd
  @vm:		Associated VM pointer
  @wait:	Entry of wait-queue
  @shutdown:	Async shutdown work
  @eventfd:	Associated eventfd
  @list:	Entry within &acrn_vm.irqfds of irqfds of a VM
  @pt:		Structure for selectpoll on the associated eventfd
  @msi:	MSI data
 remove from wait queue 
 Called with wqh->lock held and interrupts disabled 
 An event has been signaled, inject an interrupt 
 Do shutdown work in thread to hold wqh->lock 
  Assign an eventfd to a VM and create a HSM irqfd associated with the
  eventfd. The properties of the HSM irqfd are built from a &struct
  acrn_irqfd.
	
	  Install custom wake-up handling to be notified whenever underlying
	  eventfd is signaled.
 Check the pending event in this stage 
 SPDX-License-Identifier: GPL-2.0
  ACRN_HSM: Virtual Machine management
  Copyright (C) 2020 Intel Corporation. All rights reserved.
  Authors:
 	Jason Chen CJ <jason.cj.chen@intel.com>
 	Yakui Zhao <yakui.zhao@intel.com>
 List of VMs 
  acrn_vm_list is read in a worker thread which dispatch IO requests and
  is wrote in VM creation ioctl. Use the rwlock mechanism to protect it.
 Remove from global VM list 
  acrn_msi_inject() - Inject a MSI interrupt into a User VM
  @vm:		User VM
  @msi_addr:	The MSI address
  @msi_data:	The MSI data
  Return: 0 on success, <0 on error
 might be used in interrupt context, so use GFP_ATOMIC 
	
	  msi_addr: addr[19:12] with dest vcpu id
	  msi_data: data[7:0] with vector
 SPDX-License-Identifier: GPL-2.0
  ACRN Hypervisor Service Module (HSM)
  Copyright (C) 2020 Intel Corporation. All rights reserved.
  Authors:
 	Fengwei Yin <fengwei.yin@intel.com>
 	Yakui Zhao <yakui.zhao@intel.com>
  When devacrn_hsm is opened, a 'struct acrn_vm' object is created to
  represent a VM instance and continues to be associated with the opened file
  descriptor. All ioctl operations on this file descriptor will be targeted to
  the VM instance. Release of this file descriptor will destroy the object.
  HSM relies on hypercall layer of the ACRN hypervisor to do the
  sanity check against the input parameters.
 SPDX-License-Identifier: GPL-2.0
  ACRN HSM eventfd - use eventfd objects to signal expected IO requests
  Copyright (C) 2020 Intel Corporation. All rights reserved.
  Authors:
 	Shuo Liu <shuo.a.liu@intel.com>
 	Yakui Zhao <yakui.zhao@intel.com>
  struct hsm_ioeventfd - Properties of HSM ioeventfd
  @list:	Entry within &acrn_vm.ioeventfds of ioeventfds of a VM
  @eventfd:	Eventfd of the HSM ioeventfd
  @addr:	Address of IO range
  @data:	Data for matching
  @length:	Length of IO range
  @type:	Type of IO range (ACRN_IOREQ_TYPE_MMIOACRN_IOREQ_TYPE_PORTIO)
  @wildcard:	Data matching or not
 Either one is wildcard, the data matching will be skipped. 
  Assign an eventfd to a VM and create a HSM ioeventfd associated with the
  eventfd. The properties of the HSM ioeventfd are built from a &struct
  acrn_ioeventfd.
 Check for range overflow 
	
	  Currently, acrn_ioeventfd is used to support vhost. 1,2,4,8 width
	  accesses can cover vhost's requirements.
	
	  ACRN_IOEVENTFD_FLAG_DATAMATCH flag is set in virtio 1.0 support, the
	  writing of notification register of each virtqueue may trigger the
	  notification. There is no data matching requirement.
 register the IO range into ioreq client 
		
		  IO requests are dispatched by range check only, so a
		  acrn_ioreq_client need process both READ and WRITE accesses
		  of same range. READ accesses are safe to be ignored here
		  because virtio PCI devices write the notify registers for
		  notification.
 reading does nothing and return 0 
 reading does nothing and return 0 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2015-2017 Pengutronix, Uwe Kleine-König <kernel@pengutronix.de>
 reset data and clock 
 DOUT is logically inverted 
	
	  Resetting dout isn't necessary protocol wise, but it makes the
	  signals more pretty because the dout level is deterministic between
	  cycles. Note that this only affects dout between the master and the
	  first siox device. dout for the later devices depend on the output of
	  the previous siox device.
 XXX: determine automatically like spi does 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2015-2017 Pengutronix, Uwe Kleine-König <kernel@pengutronix.de>
  The lowest bit in the SIOX status word signals if the in-device watchdog is
  ok. If the bit is set, the device is functional.
  On writing the watchdog timer is reset when this bit toggles.
  Bits 1 to 3 of the status word read as the bitwise negation of what was
  clocked in before. The value clocked in is changed in each cycle and so
  allows to detect transmitreceive problems.
  Each Siox-Device has a 4 bit type number that is neither 0 nor 15. This is
  available in the upper nibble of the read status.
  On write these bits are DC.
	
	  bits 3:1 of status sample the respective bit in the status
	  byte written in the previous cycle but inverted. So if you wrote the
	  status word as 0xa before (counter = 0b101), it is expected to get
	  back the counter bits as 0b010.
	 
	  So given the last status written this function toggles the there
	  unset counter bits in the read value such that the counter bits in
	  the return value are all zero iff the bits were read as expected to
	  simplify error detection.
	
	  If the device knows which value the type bits should have, check
	  against this value otherwise just rule out the invalid values 0b0000
	  and 0b1111.
  If there is a type or counter error the device is called "unsynced".
  A device is called "connected" if it is synced and the watchdog is not
  asserted.
	
	  The counter bits change in each second cycle, the watchdog bit
	  toggles each time.
	  The counter bits hold values from [0, 6]. 7 would be possible
	  theoretically but the protocol designer considered that a bad idea
	  for reasons unknown today. (Maybe that's because then the status read
	  back has only zeros in the counter bits then which might be confused
	  with a stuck-at-0 error. But for the same reason (with s01) 0
	  could be skipped.)
 prepare data pushed out to devices in buf[0..setbuf_len) 
		
		  If the device or a previous one is unsynced, don't pet the
		  watchdog. This is done to ensure that the device is kept in
		  reset when something is wrong.
			
			  Don't trigger watchdog if there is no driver or a
			  sync problem
 interpret data pulled in from devices in buf[setbuf_len..] 
		
		  If the watchdog bit wasn't toggled in this cycle, report the
		  watchdog as active to give a consistent view for drivers and
		  sysfs consumers.
 Check counter and type bits 
 only report a new error if the last cycle was ok 
 If the device is unsynced report the watchdog as active 
 The watchdog state changed just now 
 only give data read to driver if the device is connected 
		
		  Set the task to idle while holding the lock. This makes sure
		  that we don't sleep too long when the bus is reenabled before
		  schedule_timeout is reached.
		
		  I'm not clear ifwhy it is important to set the state to
		  RUNNING again, but it fixes a "do not call blocking ops when
		  !TASK_RUNNING;"-warning.
 up to now there is only a single driver so keeping this simple 
 XXX? require to write <type> <inbytes> <outbytes> 
 remove device 
 don't care to make the buffer smaller again 
	
	  This must be done without holding the master lock because we're
	  called from device_remove_store which also holds a sysfs mutex.
	  device_unregister tries to aquire the same lock.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2017, Linaro Ltd.
  sysmon_send_event() - send notification of other remote's SSR event
  @sysmon:	sysmon context
  @event:	sysmon event context
  sysmon_request_shutdown() - request graceful shutdown of remote
  @sysmon:	sysmon context
  Return: boolean indicator of the remote processor acking the request
  ssctl_request_shutdown() - request shutdown via SSCTL QMI service
  @sysmon:	sysmon context
  Return: boolean indicator of the remote processor acking the request
  ssctl_send_event() - send notification of other remote's SSR event
  @sysmon:	sysmon context
  @event:	sysmon event context
  ssctl_new_server() - QMI callback indicating a new service
  @qmi:	QMI handle
  @svc:	service information
  Return: 0 if we're interested in this service, -EINVAL otherwise.
  ssctl_del_server() - QMI callback indicating that @svc is removed
  @qmi:	QMI handle
  @svc:	service information
  sysmon_start() - start callback for the sysmon remoteproc subdevice
  @subdev:	instance of the sysmon subdevice
  Inform all the listners of sysmon notifications that the rproc associated
  to @subdev has booted up. The rproc that booted up also needs to know
  which rprocs are already up and running, so send start notifications
  on behalf of all the online rprocs.
 Don't request graceful shutdown if we've crashed 
  sysmon_notify() - notify sysmon target of another's SSR
  @nb:		notifier_block associated with sysmon instance
  @event:	unused
  @data:	SSR identifier of the remote that is going down
 Skip non-running rprocs and the originating instance 
 Only SSCTL version 2 supports SSR events 
  qcom_add_sysmon_subdev() - create a sysmon subdev for the given remoteproc
  @rproc:	rproc context to associate the subdev with
  @name:	name of this subdev, to use in SSR
  @ssctl_instance: instance id of the ssctl QMI service
  Return: A new qcom_sysmon object, or NULL on failure
  qcom_remove_sysmon_subdev() - release a qcom_sysmon
  @sysmon:	sysmon context, as retrieved by qcom_add_sysmon_subdev()
  qcom_sysmon_shutdown_acked() - query the success of the last shutdown
  @sysmon:	sysmon context
  When sysmon is used to request a graceful shutdown of the remote processor
  this can be used by the remoteproc driver to query the success, in order to
  know if it should fall back to other means of requesting a shutdown.
  Return: boolean indicator of the success of the last shutdown request
  sysmon_probe() - probe sys_mon channel
  @rpdev:	rpmsg device handle
  Find the sysmon context associated with the ancestor remoteproc and assign
  this rpmsg device with said sysmon context.
  Return: 0 on success, negative errno on failure.
  sysmon_remove() - sys_mon channel remove handler
  @rpdev:	rpmsg device handle
  Disassociate the rpmsg device with the sysmon instance.
 SPDX-License-Identifier: GPL-2.0-only
  OMAP Remote Processor driver
  Copyright (C) 2011-2020 Texas Instruments Incorporated - http:www.ti.com
  Copyright (C) 2011 Google, Inc.
  Ohad Ben-Cohen <ohad@wizery.com>
  Brian Swetland <swetland@google.com>
  Fernando Guzman Lugo <fernando.lugo@ti.com>
  Mark Grosen <mgrosen@ti.com>
  Suman Anna <s-anna@ti.com>
  Hari Kanigeri <h-kanigeri2@ti.com>
 default auto-suspend delay (ms) 
  struct omap_rproc_boot_data - boot data structure for the DSP omap rprocs
  @syscon: regmap handle for the system control configuration module
  @boot_reg: boot register offset within the @syscon regmap
  @boot_reg_shift: bit-field shift required for the boot address value in
 		    @boot_reg
  struct omap_rproc_mem - internal memory structure
  @cpu_addr: MPU virtual address of the memory region
  @bus_addr: bus address used to access the memory region
  @dev_addr: device address of the memory region from DSP view
  @size: size of the memory region
  struct omap_rproc_timer - data structure for a timer used by a omap rproc
  @odt: timer pointer
  @timer_ops: OMAP dmtimer ops for @odt timer
  @irq: timer irq
  struct omap_rproc - omap remote processor state
  @mbox: mailbox channel handle
  @client: mailbox client to request the mailbox channel
  @boot_data: boot data structure for setting processor boot address
  @mem: internal memory regions data
  @num_mems: number of internal memory regions
  @num_timers: number of rproc timer(s)
  @num_wd_timers: number of rproc watchdog timers
  @timers: timer(s) info used by rproc
  @autosuspend_delay: auto-suspend delay value to be used for runtime pm
  @need_resume: if true a resume is needed in the system resume callback
  @rproc: rproc handle
  @reset: reset handle
  @pm_comp: completion primitive to sync for suspend response
  @fck: functional clock for the remoteproc
  @suspend_acked: state machine flag to store the suspend request ack
  struct omap_rproc_mem_data - memory definitions for an omap remote processor
  @name: name for this memory entry
  @dev_addr: device address for the memory entry
  struct omap_rproc_dev_data - device data for the omap remote processor
  @device_name: device name of the remote processor
  @mems: memory definitions for this remote processor
  omap_rproc_request_timer() - request a timer for a remoteproc
  @dev: device requesting the timer
  @np: device node pointer to the desired timer
  @timer: handle to a struct omap_rproc_timer to return the timer handle
  This helper function is used primarily to request a timer associated with
  a remoteproc. The returned handle is stored in the .odt field of the
  @timer structure passed in, and is used to invoke other timer specific
  ops (like starting a timer either during device initialization or during
  a resume operation, or for stoppingfreeing a timer).
  Return: 0 on success, otherwise an appropriate failure
 clean counter, remoteproc code will set the value 
  omap_rproc_start_timer() - start a timer for a remoteproc
  @timer: handle to a OMAP rproc timer
  This helper function is used to start a timer associated with a remoteproc,
  obtained using the request_timer ops. The helper function needs to be
  invoked by the driver to start the timer (during device initialization)
  or to just resume the timer.
  Return: 0 on success, otherwise a failure as returned by DMTimer ops
  omap_rproc_stop_timer() - stop a timer for a remoteproc
  @timer: handle to a OMAP rproc timer
  This helper function is used to disable a timer associated with a
  remoteproc, and needs to be called either during a device shutdown
  or suspend operation. The separate helper function allows the driver
  to just stop a timer without having to release the timer during a
  suspend operation.
  Return: 0 on success, otherwise a failure as returned by DMTimer ops
  omap_rproc_release_timer() - release a timer for a remoteproc
  @timer: handle to a OMAP rproc timer
  This helper function is used primarily to release a timer associated
  with a remoteproc. The dmtimer will be available for other clients to
  use once released.
  Return: 0 on success, otherwise a failure as returned by DMTimer ops
  omap_rproc_get_timer_irq() - get the irq for a timer
  @timer: handle to a OMAP rproc timer
  This function is used to get the irq associated with a watchdog timer. The
  function is called by the OMAP remoteproc driver to register a interrupt
  handler to handle watchdog events on the remote processor.
  Return: irq id on success, otherwise a failure as returned by DMTimer ops
  omap_rproc_ack_timer_irq() - acknowledge a timer irq
  @timer: handle to a OMAP rproc timer
  This function is used to clear the irq associated with a watchdog timer. The
  The function is called by the OMAP remoteproc upon a watchdog event on the
  remote processor to clear the interrupt status of the watchdog timer.
  omap_rproc_watchdog_isr() - Watchdog ISR handler for remoteproc device
  @irq: IRQ number associated with a watchdog timer
  @data: IRQ handler data
  This ISR routine executes the required necessary low-level code to
  acknowledge a watchdog timer interrupt. There can be multiple watchdog
  timers associated with a rproc (like IPUs which have 2 watchdog timers,
  one per Cortex M3M4 core), so a lookup has to be performed to identify
  the timer to acknowledge its interrupt.
  The function also invokes rproc_report_crash to report the watchdog event
  to the remoteproc driver core, to trigger a recovery.
  Return: IRQ_HANDLED on success, otherwise IRQ_NONE
  omap_rproc_enable_timers() - enable the timers for a remoteproc
  @rproc: handle of a remote processor
  @configure: boolean flag used to acquire and configure the timer handle
  This function is used primarily to enable the timers associated with
  a remoteproc. The configure flag is provided to allow the driver to
  to either acquire and start a timer (during device initialization) or
  to just start a timer (during a resume operation).
  Return: 0 on success, otherwise an appropriate failure
  omap_rproc_disable_timers() - disable the timers for a remoteproc
  @rproc: handle of a remote processor
  @configure: boolean flag used to release the timer handle
  This function is used primarily to disable the timers associated with
  a remoteproc. The configure flag is provided to allow the driver to
  to either stop and release a timer (during device shutdown) or to just
  stop a timer (during a suspend operation).
  Return: 0 on success or no timers
  omap_rproc_mbox_callback() - inbound mailbox message handler
  @client: mailbox client pointer used for requesting the mailbox channel
  @data: mailbox payload
  This handler is invoked by omap's mailbox driver whenever a mailbox
  message is received. Usually, the mailbox payload simply contains
  the index of the virtqueue that is kicked by the remote processor,
  and we let remoteproc core handle it.
  In addition to virtqueue indices, we also have some out-of-band values
  that indicates different events. Those values are deliberately very
  big so they don't coincide with virtqueue indices.
		
		  remoteproc detected an exception, notify the rproc core.
		  The remoteproc core will handle the recovery.
 msg contains the index of the triggered vring 
 kick a virtqueue 
 wake up the rproc before kicking it 
 send the index of the triggered virtqueue in the mailbox payload 
  omap_rproc_write_dsp_boot_addr() - set boot address for DSP remote processor
  @rproc: handle of a remote processor
  Set boot address for a supported DSP remote processor.
  Return: 0 on success, or -EINVAL if boot address is not aligned properly
  Power up the remote processor.
  This function will be invoked only after the firmware for this rproc
  was loaded, parsed successfully, and all of its resource requirements
  were met.
	
	  Ping the remote processor. this is only for sanity-sake;
	  there is no functional effect whatsoever.
	 
	  Note that the reply will _not_ arrive immediately: this message
	  will wait in the mailbox fifo until the remote processor is booted.
	
	  remote processor is up, so update the runtime pm status and
	  enable the auto-suspend. The device usage count is incremented
	  manually for balancing it for auto-suspend
 power off the remote processor 
	
	  cancel any possible scheduled runtime suspend by incrementing
	  the device usage count, and resuming the device. The remoteproc
	  also needs to be woken up if suspended, to avoid the remoteproc
	  OS to continue to remember any context that it has saved, and
	  avoid potential issues in misindentifying a subsequent device
	  reboot as a power restore boot
	
	  update the runtime pm states and status now that the remoteproc
	  has stopped
 schedule the next auto-suspend 
  omap_rproc_da_to_va() - internal memory translation helper
  @rproc: remote processor to apply the address translation for
  @da: device address to translate
  @len: length of the memory buffer
  Custom function implementing the rproc .da_to_va ops to provide address
  translation (device address to kernel virtual address) for internal RAMs
  present in a DSP or IPU device). The translated addresses can be used
  either by the remoteproc core for loading, or by any rpmsg bus drivers.
  Return: translated virtual address in kernel memory space on success,
          or NULL on failure.
 __force to make sparse happy with type conversion 
 1 sec is long enough time to let the remoteproc side suspend the device 
	
	  The remoteproc side is returning the ACK message before saving the
	  context, because the context saving is performed within a SYSBIOS
	  function, and it cannot have any inter-dependencies against the IPC
	  layer. Also, as the SYSBIOS needs to preserve properly the processor
	  register set, sending this ACK or signalling the completion of the
	  context save through a shared memory variable can never be the
	  absolute last thing to be executed on the remoteproc side, and the
	  MPU cannot use the ACK message as a sync point to put the remoteproc
	  into reset. The only way to ensure that the remote processor has
	  completed saving the context is to check that the module has reached
	  STANDBY state (after saving the context, the SYSBIOS executes the
	  appropriate target-specific WFI instruction causing the module to
	  enter STANDBY).
	
	  IOMMUs would have to be disabled specifically for runtime suspend.
	  They are handled automatically through System PM callbacks for
	  regular system suspend
 ignore errors on re-enabling code 
	
	  IOMMUs would have to be enabled specifically for runtime resume.
	  They would have been already enabled automatically through System
	  PM callbacks for regular system resume
 boot address could be lost after suspend, so restore it 
	
	  remoteproc is running at the time of system suspend, so remember
	  it so as to wake it up during system resume
	
	  remoteproc was auto-suspended at the time of system suspend,
	  so no need to wake-up the processor (leave it in suspended
	  state, will be woken up during a subsequent runtime_resume)
	
	  do not even attempt suspend if the remote processor is not
	  idled for runtime auto-suspend
 CONFIG_PM 
 end 
	
	  Timer nodes are directly used in client nodes as phandles, so
	  retrieve the count using appropriate size
 All existing OMAP IPU and DSP processors have an MMU 
 SPDX-License-Identifier: GPL-2.0-only
  ST's Remote Processor Control Driver
  Copyright (C) 2015 STMicroelectronics - All Rights Reserved
  Author: Ludovic Barre <ludovic.barre@st.com>
 send the index of the triggered virtqueue in the mailbox payload 
 Update memory entry va 
  No need to map vdev buffer 
 Register memory region 
 Register reserved memory for vdev buffer allocation 
  Fetch state of the processor: 0 is off, 1 is on.
		
		  To control a co-processor without IPC mechanism.
		  This driver can be used without mbox and rpmsg.
 SPDX-License-Identifier: GPL-2.0-only
  TI K3 DSP Remote Processor(s) driver
  Copyright (C) 2018-2020 Texas Instruments Incorporated - https:www.ti.com
 	Suman Anna <s-anna@ti.com>
  struct k3_dsp_mem - internal memory structure
  @cpu_addr: MPU virtual address of the memory region
  @bus_addr: Bus address used to access the memory region
  @dev_addr: Device address of the memory region from DSP view
  @size: Size of the memory region
  struct k3_dsp_mem_data - memory definitions for a DSP
  @name: name for this memory entry
  @dev_addr: device address for the memory entry
  struct k3_dsp_dev_data - device data structure for a DSP
  @mems: pointer to memory definitions for a DSP
  @num_mems: number of memory regions in @mems
  @boot_align_addr: boot vector address alignment granularity
  @uses_lreset: flag to denote the need for local reset management
  struct k3_dsp_rproc - k3 DSP remote processor driver structure
  @dev: cached device pointer
  @rproc: remoteproc device handle
  @mem: internal memory regions data
  @num_mems: number of internal memory regions
  @rmem: reserved memory regions data
  @num_rmems: number of reserved memory regions
  @reset: reset control handle
  @data: pointer to DSP-specific device data
  @tsp: TI-SCI processor control handle
  @ti_sci: TI-SCI handle
  @ti_sci_id: TI-SCI device identifier
  @mbox: mailbox channel handle
  @client: mailbox client to request the mailbox channel
  k3_dsp_rproc_mbox_callback() - inbound mailbox message handler
  @client: mailbox client pointer used for requesting the mailbox channel
  @data: mailbox payload
  This handler is invoked by the OMAP mailbox driver whenever a mailbox
  message is received. Usually, the mailbox payload simply contains
  the index of the virtqueue that is kicked by the remote processor,
  and we let remoteproc core handle it.
  In addition to virtqueue indices, we also have some out-of-band values
  that indicate different events. Those values are deliberately very
  large so they don't coincide with virtqueue indices.
		
		  remoteproc detected an exception, but error recovery is not
		  supported. So, just log this for now
 silently handle all other valid messages 
 msg contains the index of the triggered vring 
  Kick the remote processor to notify about pending unprocessed messages.
  The vqid usage is not used and is inconsequential, as the kick is performed
  through a simulated GPIO (a bit in an IPC interrupt-triggering register),
  the remote processor is expected to process both its Tx and Rx virtqueues.
 send the index of the triggered virtqueue in the mailbox payload 
 Put the DSP processor into reset 
 Release the DSP processor from reset 
  The C66x DSP cores have a local reset that affects only the CPU, and a
  generic module reset that powers on the device and allows the DSP internal
  memories to be accessed while the local reset is asserted. This function is
  used to release the global reset on C66x DSPs to allow loading into the DSP
  internal RAMs. The .prepare() ops is invoked by remoteproc core before any
  firmware loading, and is followed by the .start() ops after loading to
  actually let the C66x DSP cores run.
  This function implements the .unprepare() ops and performs the complimentary
  operations to that of the .prepare() ops. The function is used to assert the
  global reset on applicable C66x cores. This completes the second portion of
  powering down the C66x DSP cores. The cores themselves are only halted in the
  .stop() callback through the local reset, and the .unprepare() ops is invoked
  by the remoteproc core after the remoteproc is stopped to balance the global
  reset.
  Power up the DSP remote processor.
  This function will be invoked only after the firmware for this rproc
  was loaded, parsed successfully, and all of its resource requirements
  were met.
	
	  Ping the remote processor, this is only for sanity-sake for now;
	  there is no functional effect whatsoever.
	 
	  Note that the reply will _not_ arrive immediately: this message
	  will wait in the mailbox fifo until the remote processor is booted.
  Stop the DSP remote processor.
  This function puts the DSP processor into reset, and finishes processing
  of any pending messages.
  Custom function to translate a DSP device address (internal RAMs only) to a
  kernel virtual address.  The DSPs can access their RAMs at either an internal
  address visible only from a DSP, or at the SoC-level bus address. Both these
  addresses need to be looked through for translation. The translated addresses
  can be used either by the remoteproc core for loading (when using kernel
  remoteproc loader), or by any rpmsg bus drivers.
 handle DSP-view addresses 
 handle SoC-view addresses 
 handle static DDR reserved memory regions 
 use reserved memory region 0 for vring DMA allocations 
 use remaining reserved memory regions for static carveouts 
 64-bit address regions currently not supported 
	
	  ensure the DSP local reset is asserted to ensure the DSP doesn't
	  execute bogus code in .prepare() when the module reset is released.
 C71x cores only have a L1P Cache, there are no L1P SRAMs 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 MediaTek Inc.
  scp_ipi_register() - register an ipi function
  @scp:	mtk_scp structure
  @id:		IPI ID
  @handler:	IPI handler
  @priv:	private data for IPI handler
  Register an ipi function to receive ipi interrupt from SCP.
  Returns 0 if ipi registers successfully, -error on error.
  scp_ipi_unregister() - unregister an ipi function
  @scp:	mtk_scp structure
  @id:		IPI ID
  Unregister an ipi function to receive ipi interrupt from SCP.
  scp_memcpy_aligned() - Copy src to dst, where dst is in SCP SRAM region.
  @dst:	Pointer to the destination buffer, should be in SCP SRAM region.
  @src:	Pointer to the source buffer.
  @len:	Length of the source buffer to be copied.
  Since AP access of SCP SRAM don't support byte write, this always write a
  full word at a time, and may cause some extra bytes to be written at the
  beginning & ending of dst.
  scp_ipi_lock() - Lock before operations of an IPI ID
  @scp:	mtk_scp structure
  @id:		IPI ID
  Note: This should not be used by drivers other than mtk_scp.
  scp_ipi_lock() - Unlock after operations of an IPI ID
  @scp:	mtk_scp structure
  @id:		IPI ID
  Note: This should not be used by drivers other than mtk_scp.
  scp_ipi_send() - send data from AP to scp.
  @scp:	mtk_scp structure
  @id:		IPI ID
  @buf:	the data buffer
  @len:	the data buffer length
  @wait:	number of msecs to wait for ack. 0 to skip waiting.
  This function is thread-safe. When this function returns,
  SCP has received the data and starts the processing.
  When the processing completes, IPI handler registered
  by scp_ipi_register will be called in interrupt context.
  Returns 0 if sending data successfully, -error on error.
 Wait until SCP receives the last command 
 send the command to SCP 
 wait for SCP's ACK 
 SPDX-License-Identifier: GPL-2.0-only
  TI AMx3 Wakeup M3 Remote Processor driver
  Copyright (C) 2014-2015 Texas Instruments, Inc.
  Dave Gerlach <d-gerlach@ti.com>
  Suman Anna <s-anna@ti.com>
  struct wkup_m3_mem - WkupM3 internal memory structure
  @cpu_addr: MPU virtual address of the memory region
  @bus_addr: Bus address used to access the memory region
  @dev_addr: Device address from Wakeup M3 view
  @size: Size of the memory region
  struct wkup_m3_rproc - WkupM3 remote processor state
  @rproc: rproc handle
  @pdev: pointer to platform device
  @mem: WkupM3 memory information
  @rsts: reset control
 __force to make sparse happy with type conversion 
 umem always needs to be processed first 
		
		  The wkupm3 has umem at address 0 in its view, so the device
		  addresses for each memory region is computed as a relative
		  offset of the bus address for umem, and therefore needs to be
		  processed first.
 SPDX-License-Identifier: GPL-2.0-only
  PRU-ICSS remoteproc driver for various TI SoCs
  Copyright (C) 2014-2020 Texas Instruments Incorporated - https:www.ti.com
  Author(s):
 	Suman Anna <s-anna@ti.com>
 	Andrew F. Davis <afd@ti.com>
 	Grzegorz Jaszczyk <grzegorz.jaszczyk@linaro.org> for Texas Instruments
 PRU_ICSS_PRU_CTRL registers 
 CTRL register bit-fields 
 PRU_ICSS_PRU_DEBUG registers 
 PRURTUTx_PRU Core IRAM address masks 
 PRU device addresses for various type of PRU RAMs 
 Instruction RAM 
 Primary Data RAM 
 Secondary Data RAM 
 Shared Data RAM 
  enum pru_iomem - PRU core memoryregister range identifiers
  @PRU_IOMEM_IRAM: PRU Instruction RAM range
  @PRU_IOMEM_CTRL: PRU Control register range
  @PRU_IOMEM_DEBUG: PRU Debug register range
  @PRU_IOMEM_MAX: just keep this one at the end
  enum pru_type - PRU core type identifier
  @PRU_TYPE_PRU: Programmable Real-time Unit
  @PRU_TYPE_RTU: Auxiliary Programmable Real-Time Unit
  @PRU_TYPE_TX_PRU: Transmit Programmable Real-Time Unit
  @PRU_TYPE_MAX: just keep this one at the end
  struct pru_private_data - device data for a PRU core
  @type: type of the PRU core (PRU, RTU, Tx_PRU)
  @is_k3: flag used to identify the need for special load handling
  struct pru_rproc - PRU remoteproc structure
  @id: id of the PRU core within the PRUSS
  @dev: PRU core device pointer
  @pruss: back-reference to parent PRUSS structure
  @rproc: remoteproc pointer for this PRU core
  @data: PRU core specific data
  @mem_regions: data for each of the PRU memory regions
  @fw_name: name of firmware image used during loading
  @mapped_irq: virtual interrupt numbers of created fw specific mapping
  @pru_interrupt_map: pointer to interrupt mapping description (firmware)
  @pru_interrupt_map_sz: pru_interrupt_map size
  @dbg_single_step: debug state variable to set PRU into single step mode
  @dbg_continuous: debug state variable to restore PRU execution mode
  @evt_count: number of mapped events
  Control PRU single-step mode
  This is a debug helper function used for controlling the single-step
  mode of the PRU. The PRU Debug registers are not accessible when the
  PRU is in RUNNING state.
  Writing a non-zero value sets the PRU into single-step mode irrespective
  of its previous state. The PRU mode is saved only on the first set into
  a single-step mode. Writing a zero value will restore the PRU into its
  original mode.
  Create PRU-specific debugfs entries
  The entries are created only if the parent remoteproc debugfs directory
  exists, and will be cleaned up by the remoteproc core.
  Parse the custom PRU interrupt map resource and configure the INTC
  appropriately.
 not having pru_interrupt_map is not an error 
 currently supporting only type 0 
	
	  parse and fill in system event to interrupt channel and
	  channel-to-host mapping. The interrupt controller to be used
	  for these mappings for a given PRU remoteproc is always its
	  corresponding sibling PRUSS INTC node.
	
	  reset references to pru interrupt map - they will stop being valid
	  after rproc_start returns
 dispose irq mapping - new firmware can provide new mapping 
  Convert PRU device address (data spaces only) to kernel virtual address.
  Each PRU has access to all data memories within the PRUSS, accessible at
  different ranges. So, look through both its primary and secondary Data
  RAMs as well as any shared Data RAM to convert a PRU device address to
  kernel virtual address. Data RAM0 is primary Data RAM for PRU0 and Data
  RAM1 is primary Data RAM for PRU1.
 PRU1 has its local RAM addresses reversed 
  Convert PRU device address (instruction space) to kernel virtual address.
  A PRU does not have an unified address space. Each PRU has its very own
  private Instruction RAM, and its device address is identical to that of
  its primary Data RAM device address.
	
	  GNU binutils do not support multiple address spaces. The GNU
	  linker's default linker script places IRAM at an arbitrary high
	  offset, in order to differentiate it from DRAM. Hence we need to
	  strip the artificial offset in the IRAM addresses coming from the
	  ELF file.
	 
	  The TI proprietary linker would never set those higher IRAM address
	  bits anyway. PRU architecture limits the program counter to 16-bit
	  word-address range. This in turn corresponds to 18-bit IRAM
	  byte-address range for ELF.
	 
	  Two more bits are added just in case to make the final 20-bit mask.
	  Idea is to have a safeguard in case TI decides to add banking
	  in future SoCs.
  Provide address translations for only PRU Data RAMs through the remoteproc
  core for any PRU client drivers. The PRU Instruction RAM access is restricted
  only to the PRU loader code.
 PRU-specific address translator used by PRU loader. 
  Custom memory copy implementation for ICSSG PRURTUTx_PRU Cores
  The ICSSG PRURTUTx_PRU cores have a memory copying issue with IRAM
  memories, that is not seen on previous generation SoCs. The data is reflected
  properly in the IRAM memories only for integer (4-byte) copies. Any unaligned
  copies result in all the other pre-existing bytes zeroed out within that
  4-byte boundary, thereby resulting in wrong textcode in the IRAMs. Also, the
  IRAM memory port interface does not allow any 8-byte copies (as commonly used
  by ARM64 memcpy implementation) and throws an exception. The DRAM memory
  ports do not show this behavior.
	
	  TODO: relax limitation of 4-byte aligned dest addresses and copy
	  sizes
 src offsets in ELF firmware image can be non-aligned 
 go through the available ELF segments 
 grab the kernel address for this device address 
 skip the memzero logic performed by remoteproc ELF loader 
 first, get the section header 
 compute name table section header entry in shdr array 
 finally, compute the name table section address in elf 
 make sure we have the entire irq map 
 make sure irq map has at least the header 
  Use a custom parse_fw callback function for dealing with PRU firmware
  specific sections.
  The firmware blob can contain optional ELF sections: .resource_table section
  and .pru_irq_map one. The second one contains the PRUSS interrupt mapping
  description, which needs to be setup before powering on the PRU core. To
  avoid RAM wastage this ELF section is not mapped to any ELF segment (by the
  firmware linker) and therefore is not loaded to PRU memory.
 load optional rsc table 
 find .pru_interrupt_map section, not having it is not an error 
 preserve pointer to PRU interrupt map together with it size 
  Compute PRU id based on the IRAM addresses. The PRU IRAMs are
  always at a particular offset within the PRUSS address space.
 use a custom load function to deal with PRU-specific quirks 
 use a custom parse function to deal with PRU-specific resources 
 error recovery is not supported for PRUs 
	
	  rproc_add will auto-boot the processor normally, but this is not
	  desired with PRU client driven boot-flow methodology. A PRU
	  applicationclient driver will boot the corresponding PRU
	  remote-processor as part of its state machine either through the
	  remoteproc sysfs interface or through the equivalent kernel API.
 SPDX-License-Identifier: GPL-2.0-only
  Qualcomm self-authenticating modem subsystem remoteproc driver
  Copyright (C) 2016 Linaro Ltd.
  Copyright (C) 2014 Sony Mobile Communications AB
  Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
 RMB Status Register Values 
 PBLMBA interface registers 
 QDSP6SS Register Offsets 
 AXI Halt Register Offsets 
 QACCEPT Register Offsets 
 QDSP6SS_RESET 
 QDSP6SS CBCR 
 QDSP6SS_GFMUX_CTL 
 QDSP6SS_PWR_CTL 
 QDSP6v56 parameters 
 QDSP6v65 parameters 
 MBA is restricted to a maximum size of 1M 
		
		  When the AXI pipeline is being reset with the Q6 modem partly
		  operational there is possibility of AXI valid signal to
		  glitch, leading to spurious transactions and Q6 hangs. A work
		  around is employed by asserting the AXI_GATING_VALID_OVERRIDE
		  BIT before triggering Q6 MSS reset. AXI_GATING_VALID_OVERRIDE
		  is withdrawn post MSS assert followed by a MSS deassert,
		  while holding the PDC reset.
 De-assert QDSP6 stop core 
 Trigger boot FSM 
 Reset the modem so that boot FSM is in reset state 
 Turn on the XO clock needed for PLL setup 
 Configure Q6 core CBCR to auto-enable after reset sequence 
 De-assert the Q6 stop core signal 
 Wait for 10 us for any staggering logic to settle 
 Trigger the boot FSM to start the Q6 out-of-reset sequence 
 Poll the MSS_STATUS for FSM completion 
 Reset the modem so that boot FSM is in reset state 
 Override the ACC value if required 
 Assert resets, stop core 
 BHS require xo cbcr to be enabled 
 Read CLKOFF bit to go low indicating CLK is enabled 
 Enable power block headswitch and wait for it to stabilize 
 Put LDO in bypass mode 
 Deassert QDSP6 compiler memory clamp 
 Deassert memory peripheral sleep and L2 memory standby 
 Turn on L1, L2, ETB and JU memories 1 at a time 
 MSS_MSM8998 
			
			  Read back value to ensure the write is done then
			  wait for 1us for both memory peripheral and data
			  array to turn on.
 Remove word line clamp 
 Assert resets, stop core 
 Enable power block headswitch and wait for it to stabilize 
		
		  Turn on memories. L2 banks should be done individually
		  to minimize inrush current.
 Remove IO clamp 
 Bring core out of reset 
 Turn on core clock 
 Start core execution 
 Wait for PBL status 
 Wait for accept 
 Wait for active transactions to complete 
 Request Q-channel transaction takedown 
		
		  If the request is denied, reset the Q-channel takedown request,
		  wait for active transactions to complete and retry takedown.
 Rely on mss_restart to clear out pending transactions on takedown failure 
 Check if we're already idle 
 Assert halt request 
 Wait for halt 
 Clear halt request (port will remain halted until reset) 
 Hypervisor mapping to access metadata by modem 
 Metadata authentication done, remove modem access 
	
	  Some versions of the MBA firmware will upon boot wipe the MPSS region as well, so provide
	  the Q6 access to this region.
 Assign MBA image access in DDR to q6 
		
		  To avoid high MX current during LPASSMSS restart.
	 In case of failure or coredump scenario where reclaiming MBA memory
	  could not happen reclaim it here.
 Initialize the RMB validator 
	
	  In case of a modem subsystem restart on secure devices, the modem
	  memory can be reclaimed only after MBA is loaded.
 Share ownership between Linux and MSS, during segment loading 
 Load firmware segments 
 Firmware is large enough to be non-split 
 Replace "xxx.xxx" with "xxx.bxx" 
 Transfer ownership of modem ddr region to q6 
 Unlock mba before copying segments 
 Reset ownership back to Linux to copy segments 
 Reclaim mba after copying segments 
 Try to reset ownership back to Q6 
 Reset Dump Segment Mask 
	
	  In the absence of mbampss sub-child, extract the mba and mpss
	  reserved memory regions from device's memory-region property.
 Fallback to regulators for old device trees 
 SPDX-License-Identifier: GPL-2.0
  Qualcomm Peripheral Image Loader for Q6V5
  Copyright (C) 2016-2018 Linaro Ltd.
  Copyright (C) 2014 Sony Mobile Communications AB
  Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  qcom_q6v5_prepare() - reinitialize the qcom_q6v5 context before start
  @q6v5:	reference to qcom_q6v5 context to be reinitialized
  Return: 0 on success, negative errno on failure
  qcom_q6v5_unprepare() - unprepare the qcom_q6v5 context after stop
  @q6v5:	reference to qcom_q6v5 context to be unprepared
  Return: 0 on success, 1 if handover hasn't yet been called
 Sometimes the stop triggers a watchdog rather than a stop-ack 
  qcom_q6v5_wait_for_start() - wait for remote processor start signal
  @q6v5:	reference to qcom_q6v5 context
  @timeout:	timeout to wait for the event, in jiffies
  qcom_q6v5_unprepare() should not be called when this function fails.
  Return: 0 on success, -ETIMEDOUT on timeout
  qcom_q6v5_request_stop() - request the remote processor to stop
  @q6v5:	reference to qcom_q6v5 context
  @sysmon:	reference to the remote's sysmon instance, or NULL
  Return: 0 on success, negative errno on failure
 Don't perform SMP2P dance if sysmon already shut down the remote 
  qcom_q6v5_panic() - panic handler to invoke a stop on the remote
  @q6v5:	reference to qcom_q6v5 context
  Set the stop bit and sleep in order to allow the remote processor to flush
  its caches etc for post mortem debugging.
  Return: 200ms
  qcom_q6v5_init() - initializer of the q6v5 common struct
  @q6v5:	handle to be initialized
  @pdev:	platform_device reference for acquiring resources
  @rproc:	associated remoteproc instance
  @crash_reason: SMEM id for crash reason string, or 0 if none
  @load_state: load state resource string
  @handover:	function to be called when proxy resources should be released
  Return: 0 on success, negative errno on failure
  qcom_q6v5_deinit() - deinitialize the q6v5 common struct
  @q6v5:	reference to qcom_q6v5 context to be deinitialized
 SPDX-License-Identifier: GPL-2.0-only
  TI K3 R5F (MCU) Remote Processor driver
  Copyright (C) 2017-2020 Texas Instruments Incorporated - https:www.ti.com
 	Suman Anna <s-anna@ti.com>
 This address can either be for ATCM or BTCM with the other at address 0x0 
 R5 TI-SCI Processor Configuration Flags 
 Available from J7200 SoCs onwards 
 Applicable to only AM64x SoCs 
 R5 TI-SCI Processor Control Flags 
 R5 TI-SCI Processor Status Flags 
 Applicable to only AM64x SoCs 
  struct k3_r5_mem - internal memory structure
  @cpu_addr: MPU virtual address of the memory region
  @bus_addr: Bus address used to access the memory region
  @dev_addr: Device address from remoteproc view
  @size: Size of the memory region
  All cluster mode values are not applicable on all SoCs. The following
  are the modes supported on various SoCs:
    Split mode      : AM65x, J721E, J7200 and AM64x SoCs
    LockStep mode   : AM65x, J721E and J7200 SoCs
    Single-CPU mode : AM64x SoCs only
  struct k3_r5_soc_data - match data to handle SoC variations
  @tcm_is_double: flag to denote the larger unified TCMs in certain modes
  @tcm_ecc_autoinit: flag to denote the auto-initialization of TCMs for ECC
  @single_cpu_mode: flag to denote if SoCIP supports Single-CPU mode
  struct k3_r5_cluster - K3 R5F Cluster structure
  @dev: cached device pointer
  @mode: Mode to configure the Cluster - Split or LockStep
  @cores: list of R5 cores within the cluster
  @soc_data: SoC-specific feature data for a R5FSS
  struct k3_r5_core - K3 R5 core structure
  @elem: linked list item
  @dev: cached device pointer
  @rproc: rproc handle representing this core
  @mem: internal memory regions data
  @sram: on-chip SRAM memory regions data
  @num_mems: number of internal memory regions
  @num_sram: number of on-chip SRAM memory regions
  @reset: reset control handle
  @tsp: TI-SCI processor control handle
  @ti_sci: TI-SCI handle
  @ti_sci_id: TI-SCI device identifier
  @atcm_enable: flag to control ATCM enablement
  @btcm_enable: flag to control BTCM enablement
  @loczrama: flag to dictate which TCM is at device address 0x0
  struct k3_r5_rproc - K3 remote processor state
  @dev: cached device pointer
  @cluster: cached pointer to parent cluster structure
  @mbox: mailbox channel handle
  @client: mailbox client to request the mailbox channel
  @rproc: rproc handle
  @core: cached pointer to r5 core structure being used
  @rmem: reserved memory regions data
  @num_rmems: number of reserved memory regions
  k3_r5_rproc_mbox_callback() - inbound mailbox message handler
  @client: mailbox client pointer used for requesting the mailbox channel
  @data: mailbox payload
  This handler is invoked by the OMAP mailbox driver whenever a mailbox
  message is received. Usually, the mailbox payload simply contains
  the index of the virtqueue that is kicked by the remote processor,
  and we let remoteproc core handle it.
  In addition to virtqueue indices, we also have some out-of-band values
  that indicate different events. Those values are deliberately very
  large so they don't coincide with virtqueue indices.
		
		  remoteproc detected an exception, but error recovery is not
		  supported. So, just log this for now
 silently handle all other valid messages 
 msg contains the index of the triggered vring 
 kick a virtqueue 
 send the index of the triggered virtqueue in the mailbox payload 
 assert local reset on all applicable cores 
 disable PSC modules on all applicable cores 
 enable PSC modules on all applicable cores 
 deassert local reset on all applicable cores 
  The R5F cores have controls for both a reset and a haltrun. The code
  execution from DDR requires the initial boot-strapping code to be run
  from the internal TCMs. This function is used to release the resets on
  applicable cores to allow loading into the TCMs. The .prepare() ops is
  invoked by remoteproc core before any firmware loading, and is followed
  by the .start() ops after loading to actually let the R5 cores run.
  The Single-CPU mode on applicable SoCs (eg: AM64x) only uses Core0 to
  execute code, but combines the TCMs from both cores. The resets for both
  cores need to be released to make this possible, as the TCMs are in general
  private to each core. Only Core0 needs to be unhalted for running the
  cluster in this mode. The function uses the same reset logic as LockStep
  mode for this (though the behavior is agnostic of the reset release order).
 Re-use LockStep-mode reset logic for Single-CPU mode 
	
	  Newer IP revisions like on J7200 SoCs support hw auto-initialization
	  of TCMs, so there is no need to perform the sw memzero. This bit is
	  configurable through System Firmware, the default value does perform
	  auto-init, but account for it in case it is disabled
	
	  Zero out both TCMs unconditionally (access from v8 Arm core is not
	  affected by ATCM & BTCM enable configuration values) so that ECC
	  can be effective on all TCM addresses.
  This function implements the .unprepare() ops and performs the complimentary
  operations to that of the .prepare() ops. The function is used to assert the
  resets on all applicable cores for the rproc device (depending on LockStep
  or Split mode). This completes the second portion of powering down the R5F
  cores. The cores themselves are only halted in the .stop() ops, and the
  .unprepare() ops is invoked by the remoteproc core after the remoteproc is
  stopped.
  The Single-CPU mode on applicable SoCs (eg: AM64x) combines the TCMs from
  both cores. The access is made possible only with releasing the resets for
  both cores, but with only Core0 unhalted. This function re-uses the same
  reset assert logic as LockStep mode for this mode (though the behavior is
  agnostic of the reset assert order).
 Re-use LockStep-mode reset logic for Single-CPU mode 
  The R5F start sequence includes two different operations
  1. Configure the boot vector for R5F core(s)
  2. UnhaltRun the R5F core(s)
  The sequence is different between LockStep and Split modes. The LockStep
  mode requires the boot vector to be configured only for Core0, and then
  unhalt both the cores to start the execution - Core1 needs to be unhalted
  first followed by Core0. The Split-mode requires that Core0 to be maintained
  always in a higher power state that Core1 (implying Core1 needs to be started
  always only after Core0 is started).
  The Single-CPU mode on applicable SoCs (eg: AM64x) only uses Core0 to execute
  code, so only Core0 needs to be unhalted. The function uses the same logic
  flow as Split-mode for this.
	
	  Ping the remote processor, this is only for sanity-sake for now;
	  there is no functional effect whatsoever.
	 
	  Note that the reply will _not_ arrive immediately: this message
	  will wait in the mailbox fifo until the remote processor is booted.
 TODO: add boot_addr sanity checking 
 boot vector need not be programmed for Core1 in LockStep mode 
 unhaltrun all applicable cores 
  The R5F stop function includes the following operations
  1. Halt R5F core(s)
  The sequence is different between LockStep and Split modes, and the order
  of cores the operations are performed are also in general reverse to that
  of the start function. The LockStep mode requires each operation to be
  performed first on Core0 followed by Core1. The Split-mode requires that
  Core0 to be maintained always in a higher power state that Core1 (implying
  Core1 needs to be stopped first before Core0).
  The Single-CPU mode on applicable SoCs (eg: AM64x) only uses Core0 to execute
  code, so only Core0 needs to be halted. The function uses the same logic
  flow as Split-mode for this.
  Note that the R5F halt operation in general is not effective when the R5F
  core is running, but is needed to make sure the core won't run after
  deasserting the reset the subsequent time. The asserting of reset can
  be done here, but is preferred to be done in the .unprepare() ops - this
  maintains the symmetric behavior between the .start(), .stop(), .prepare()
  and .unprepare() ops, and also balances them well between sysfs 'state'
  flow and device bindunbind or module removal.
 halt all applicable cores 
  Internal Memory translation helper
  Custom function implementing the rproc .da_to_va ops to provide address
  translation (device address to kernel virtual address) for internal RAMs
  present in a DSP or IPU device). The translated addresses can be used
  either by the remoteproc core for loading, or by any rpmsg bus drivers.
 handle both R5 and SoC views of ATCM and BTCM 
 handle R5-view addresses of TCMs 
 handle SoC-view addresses of TCMs 
 handle any SRAM regions using SoC-view addresses 
 handle static DDR reserved memory regions 
  Internal R5F Core configuration
  Each R5FSS has a cluster-level setting for configuring the processor
  subsystem either in a safetyfault-tolerant LockStep mode or a performance
  oriented Split mode on most SoCs. A fewer SoCs support a non-safety mode
  as an alternate for LockStep mode that exercises only a single R5F core
  called Single-CPU mode. Each R5F core has a number of settings to either
  enabledisable each of the TCMs, control which TCM appears at the R5F core's
  address 0x0. These settings need to be configured before the resets for the
  corresponding core are released. These settings are all protected and managed
  by the System Processor.
  This function is used to pre-configure these settings for each R5F core, and
  the configuration is all done through various ti_sci_proc functions that
  communicate with the System Processor. The function also ensures that both
  the cores are halted before the .prepare() step.
  The function is called from k3_r5_cluster_rproc_init() and is invoked either
  once (in LockStep mode or Single-CPU modes) or twice (in Split mode). Support
  for LockStep-mode is dictated by an eFUSE register bit, and the config
  settings retrieved from DT are adjusted accordingly as per the permitted
  cluster mode. Another eFUSE register bit dictates if the R5F cluster only
  supports a Single-CPU mode. All cluster level settings like Cluster mode and
  TEINIT (exception handling state dictating ARM or Thumb mode) can only be set
  and retrieved using Core0.
  The function behavior is different based on the cluster mode. The R5F cores
  are configured independently as per their individual settings in Split mode.
  They are identically configured in LockStep mode using the primary Core0
  settings. However, some individual settings cannot be set in LockStep mode.
  This is overcome by switching to Split-mode initially and then programming
  both the cores with the same settings, before reconfiguing again for
  LockStep mode.
 check if only Single-CPU mode is supported on applicable SoCs 
 check conventional LockStep vs Split mode configuration 
 always enable ARM mode and set boot vector to 0 
			
			  Single-CPU configuration bit can only be configured
			  on Core0 and system firmware will NACK any requests
			  with the bit configured, so program it only on
			  permitted cores
			
			  LockStep configuration bit is Read-only on Split-mode
			  _only_ devices and system firmware will NACK any
			  requests with the bit configured, so program it only
			  on permitted devices
		
		  work around system firmware limitations to make sure both
		  cores are programmed symmetrically in LockStep. LockStep
		  and TEINIT config is only allowed with Core0.
 use reserved memory region 0 for vring DMA allocations 
 use remaining reserved memory regions for static carveouts 
		
		  R5Fs do not have an MMU, but have a Region Address Translator
		  (RAT) module that provides a fixed entry translation between
		  the 32-bit processor addresses to 64-bit bus addresses. The
		  RAT is programmable only by the R5F cores. Support for RAT
		  is currently not supported, so 64-bit address regions are not
		  supported. The absence of MMUs implies that the R5F device
		  addressessupported memory regions are restricted to 32-bit
		  bus addresses, and are identical
  Each R5F core within a typical R5FSS instance has a total of 64 KB of TCMs,
  split equally into two 32 KB banks between ATCM and BTCM. The TCMs from both
  cores are usable in Split-mode, but only the Core0 TCMs can be used in
  LockStep-mode. The newer revisions of the R5FSS IP maximizes these TCMs by
  leveraging the Core1 TCMs as well in certain modes where they would have
  otherwise been unusable (Eg: LockStep-mode on J7200 SoCs, Single-CPU mode on
  AM64x SoCs). This is done by making a Core1 TCM visible immediately after the
  corresponding Core0 TCM. The SoC memory map uses the larger 64 KB sizes for
  the Core0 TCMs, and the dts representation reflects this increased size on
  supported SoCs. The Core0 TCM sizes therefore have to be adjusted to only
  half the original size in Split mode.
 K3 R5s have a Region Address Translator (RAT) but no MMU 
 error recovery is not supported at present 
 create only one rproc in lockstep mode or single-cpu mode 
 undo core0 upon any failures on core1 in split-mode 
	
	  lockstep mode and single-cpu modes have only one rproc associated
	  with first core, whereas split-mode has two rprocs associated with
	  each core, and requires that core1 be powered down first
		
		  TCMs are designed in general to support RAM-like backing
		  memories. So, map these as Normal Non-Cached memories. This
		  also avoidsfixes any potential alignment faults due to
		  unaligned data accesses when using memcpy() or memset()
		  functions (normally seen with device type memory).
		
		  TODO:
		  The R5F cores can place ATCM & BTCM anywhere in its address
		  based on the corresponding Region Registers in the System
		  Control coprocessor. For now, place ATCM and BTCM at
		  addresses 0 and 0x41010000 (same as the bus address on AM65x
		  SoCs) based on loczrama setting
	
	  Use SoC Power-on-Reset values as default if no DT properties are
	  used to dictate the TCM configurations
  free the resources explicitly since driver model is not being used
  for the child R5F devices
	
	  default to most common efuse configurations - Split-mode on AM64x
	  and LockStep-mode on all others
 sentinel  },
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) STMicroelectronics 2018 - All Rights Reserved
  Authors: Ludovic Barre <ludovic.barre@st.com> for STMicroelectronics.
           Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
 Update memory entry va 
 Register associated reserved memory regions 
  No need to map vdev buffer 
 Register memory region 
 Register reserved memory for vdev buffer alloc 
 500 ms time out 
 200 ms time out to detach should be fair enough 
 Initialise mailbox structure table 
 clear remote proc Deep Sleep 
 Inform the remote processor of the detach 
 Allow remote processor to auto-reboot 
 request shutdown of the remote processor 
 to allow platform Standby power mode, set remote proc Deep Sleep 
 update coprocessor state to OFF if available 
 The resource table has already been mapped, nothing to do 
 no rsc table 
	
	  Assuming the resource table fits in 1kB is fair.
	  Notice for the detach, that this 1 kB memory area has to be reserved in the coprocessor
	  firmware for the resource table. On detach, the remoteproc core re-initializes this
	  entire area by overwriting it with the initial values stored in rproc->clean_table.
	
	  if platform is secured the hold boot bit must be written by
	  smc call and read normally.
	  if not secure the hold boot bit could be readwrite normally
	
	  See if we can check the M4 status, i.e if it was started
	  from the boot loader or not.
 remember this 
 no coprocessor state syscon (optional) 
 no need to go further 
 See if we can get the resource table 
 no rsc table syscon (optional) 
 See stm32_rproc_parse_dt() 
		
		  We couldn't get the coprocessor's state, assume
		  it is not running.
 SPDX-License-Identifier: GPL-2.0-or-later
  SLIM core rproc driver
  Copyright (C) 2016 STMicroelectronics
  Author: Peter Griffin <peter.griffin@linaro.org>
 SLIM core registers 
 DMEM registers 
 peripherals registers 
  Remoteproc slim specific device handlers
 disable CPU pipeline clock & reset CPU pipeline 
 disable SLIM core STBus sync 
 enable cpu pipeline clock 
 clear int & cmd mailbox 
 enable all channels cmd & int 
 enable cpu 
 mask all (cmd & int) channels 
 disable cpu pipeline clock 
 __force to make sparse happy with type conversion 
  st_slim_rproc_alloc() - allocate and initialise slim rproc
  @pdev: Pointer to the platform_device struct
  @fw_name: Name of firmware for rproc to use
  Function for allocating and initialising a slim rproc for use by
  device drivers whose IP is based around the SLIM core. It
  obtains and enables any clocks required by the SLIM core and also
  ioremaps the various IO.
  Returns st_slim_rproc pointer or PTR_ERR() on error.
 get imem and dmem 
 Register as a remoteproc device 
   st_slim_rproc_put() - put slim rproc resources
   @slim_rproc: Pointer to the st_slim_rproc struct
   Function for calling respective _put() functions on slim_rproc resources.
 SPDX-License-Identifier: GPL-2.0
  Qualcomm Technology Inc. ADSP Peripheral Image Loader for SDM845.
  Copyright (c) 2018, The Linux Foundation. All rights reserved.
 time out value 
 mask values 
QDSP6SS register offsets
TCSR register offsets
 Reset the retention logic 
 QDSP6 master port needs to be explicitly halted 
 Wait for halt ACK from QDSP6 
 Assert the LPASS PDC Reset 
 Place the LPASS processor into reset 
 wait after asserting subsystem restart from AOSS 
 Clear the halt request for the AXIM and AHBM for Q6 
 De-assert the LPASS PDC Reset 
 Remove the LPASS reset 
 wait after de-asserting subsystem restart from AOSS 
 Enable the XO clock 
 Enable the QDSP6SS sleep clock 
 Enable the QDSP6 core clock 
 Program boot address 
 De-assert QDSP6 stop core. QDSP6 will execute after out of reset 
 Trigger boot FSM to start QDSP6 
 Wait for core to come out of reset 
 Fall back to the  old "cc_lpass" if "restart" is absent 
 SPDX-License-Identifier: GPL-2.0-only
  Remote processor machine-specific module for DA8XX
  Copyright (C) 2013 Texas Instruments, Inc.
  OMAP-L138 Technical References:
  http:www.ti.comproductomap-l138
  struct da8xx_rproc_mem - internal memory structure
  @cpu_addr: MPU virtual address of the memory region
  @bus_addr: Bus address used to access the memory region
  @dev_addr: Device address of the memory region from DSP view
  @size: Size of the memory region
  struct da8xx_rproc - da8xx remote processor instance state
  @rproc: rproc handle
  @mem: internal memory regions data
  @num_mems: number of internal memory regions
  @dsp_clk: placeholder for platform's DSP clk
  @ack_fxn: chip-specific ack function for ack'ing irq
  @irq_data: ack_fxn function parameter
  @chipsig: virt ptr to DSP interrupt registers (CHIPSIG & CHIPSIG_CLR)
  @bootreg: virt ptr to DSP boot address register (HOST1CFG)
  @irq: irq # used by this instance
  handle_event() - inbound virtqueue message workqueue function
  This function is registered as a kernel thread and is scheduled by the
  kernel handler.
 Process incoming buffers on all our vrings 
  da8xx_rproc_callback() - inbound virtqueue message handler
  This handler is invoked directly by the kernel whenever the remote
  core (DSP) has modified the state of a virtqueue.  There is no
  "payload" message indicating the virtqueue index as is the case with
  mailbox-based implementations on OMAP4.  As such, this handler "polls"
  each known virtqueue index for every invocation.
 Clear interrupt level source 
		
		  ACK intr to AINTC.
		 
		  It has already been ack'ed by the kernel before calling
		  this function, but since the ARM<->DSP interrupts in the
		  CHIPSIG register are "level" instead of "pulse" variety,
		  we need to ack it after taking down the level else we'll
		  be called again immediately after returning.
 hw requires the start (boot) address be on 1KB boundary 
 kick a virtqueue 
 Interrupt remote proc 
 error recovery is not supported at present 
 everything the ISR needs is now setup, so hook it up 
	
	  rproc_add() can end up enabling the DSP's clk with the DSP
	  not in reset, but da8xx_rproc_start() needs the DSP to be
	  held in reset at the time it is called.
	
	  The devm subsystem might end up releasing things before
	  freeing the irq, thus allowing an interrupt to sneak in while
	  the device is being removed.  This should prevent that.
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
 Copyright 2021 NXP 
 att flags 
 DSP own area 
 DSP instruction area 
 Definitions for i.MX8MP 
 DAP registers 
 DSP audio mix registers 
 Definitions for i.MX8ULP 
  enum - Predefined Mailbox Messages
  @RP_MBOX_SUSPEND_SYSTEM: system suspend request for the remote processor
  @RP_MBOX_SUSPEND_ACK: successful response from remote processor for a
  suspend request
  @RP_MBOX_RESUME_SYSTEM: system resume request for the remote processor
  @RP_MBOX_RESUME_ACK: successful response from remote processor for a
  resume request
  struct imx_dsp_rproc - DSP remote processor state
  @regmap: regmap handler
  @rproc: rproc handler
  @dsp_dcfg: device configuration pointer
  @clks: clocks needed by this device
  @cl: mailbox client to request the mailbox channel
  @cl_rxdb: mailbox client to request the mailbox channel for doorbell
  @tx_ch: mailbox tx channel handle
  @rx_ch: mailbox rx channel handle
  @rxdb_ch: mailbox rx doorbell channel handle
  @pd_dev: power domain device
  @pd_dev_link: power domain device link
  @ipc_handle: System Control Unit ipc handle
  @rproc_work: work for processing virtio interrupts
  @pm_comp: completion primitive to sync for suspend response
  @num_domains: power domain number
  @flags: control flags
  struct imx_dsp_rproc_dcfg - DSP remote processor configuration
  @dcfg: imx_rproc_dcfg handler
  @reset: reset callback function
 dev addr , sys addr  , size	    , flags 
 DDR (Data) 
 dev addr , sys addr  , size	    , flags 
 DDR (Data) 
 dev addr , sys addr  , size	    , flags 
 DDR (Data) 
 dev addr , sys addr  , size	    , flags 
 DDR (Data) 
 Reset function for DSP on i.MX8MP 
 Put DSP into reset and stall 
 Keep reset asserted for 10 cycles 
 Take the DSP out of reset and keep stalled for FW loading 
 Reset function for DSP on i.MX8ULP 
 Put DSP into reset and stall 
 Configure resources of DSP through TFA 
 Take the DSP out of reset and keep stalled for FW loading 
 Specific configuration for i.MX8MP 
 Specific configuration for i.MX8ULP 
 Specific configuration for i.MX8QXP 
 Specific configuration for i.MX8QM 
  Start function for rproc_ops
  There is a handshake for start procedure: when DSP starts, it
  will send a doorbell message to this driver, then the
  REMOTE_IS_READY flags is set, then driver will kick
  a message to DSP.
  Stop function for rproc_ops
  It clears the REMOTE_IS_READY flags
 Make sure work is finished 
  imx_dsp_rproc_sys_to_da() - internal memory translation helper
  @priv: private data pointer
  @sys: system address (DDR address)
  @len: length of the memory buffer
  @da: device address to translate
  Convert system address (DDR address) to device address (DSP)
  for there may be memory remap for device.
 Parse address translation table 
 Main virtqueue message work function
  This function is executed upon scheduling of the i.MX DSP remoteproc
  driver's workqueue. The workqueue is scheduled by the mailbox rx
  handler.
  This work function processes both the Tx and Rx virtqueue indices on
  every invocation. The rproc_vq_interrupt function can detect if there
  are new unprocessed messages or not (returns IRQ_NONE vs IRQ_HANDLED),
  but there is no need to check for these return values. The index 0
  triggering will process all pending Rx buffers, and the index 1 triggering
  will process all newly available Tx buffers and will wakeup any potentially
  blocked senders.
  NOTE:
     The current logic is based on an inherent design assumption of supporting
     only 2 vrings, but this can be changed if needed.
  imx_dsp_rproc_rx_tx_callback() - inbound mailbox message handler
  @cl: mailbox client pointer used for requesting the mailbox channel
  @data: mailbox payload
  This handler is invoked by mailbox driver whenever a mailbox
  message is received. Usually, the SUSPEND and RESUME related messages
  are handled in this function, other messages are handled by remoteproc core
  imx_dsp_rproc_rxdb_callback() - inbound mailbox message handler
  @cl: mailbox client pointer used for requesting the mailbox channel
  @data: mailbox payload
  For doorbell, there is no message specified, just set REMOTE_IS_READY
  flag.
 Remote is ready after firmware is loaded and running 
  imx_dsp_rproc_mbox_init() - request mailbox channels
  @priv: private data pointer
  Request three mailbox channels (tx, rx, rxdb).
 Channel for sending message 
 Channel for receiving message 
	
	  RX door bell is used to receive the ready signal from remote
	  after firmware loaded.
  imx_dsp_rproc_add_carveout() - request mailbox channels
  @priv: private data pointer
  This function registers specified memory entry in @rproc carveouts list
  The carveouts can help to mapping the memory address for DSP.
 Remap required addresses 
 Register memory region 
		
		  Ignore the first memory region which will be used vdev buffer.
		  No need to do extra handlings, rproc_add_virtio_dev will handle it.
 Register memory region 
  imx_dsp_rproc_elf_load_segments() - load firmware segments to memory
  @rproc: remote processor which will be booted using these fw segments
  @fw: the ELF firmware image
  This function specially checks if memsz is zero or not, otherwise it
  is mostly same as rproc_elf_load_segments().
 go through the available ELF segments 
		
		   There is a case that with PT_LOAD type, the
		   filesz = memsz = 0. If memsz = 0, rproc_da_to_va
		   should return NULL ptr, then error is returned.
		   So this case should be skipped from the loop.
		   Add !memsz checking here.
 grab the kernel address for this device address 
 put the segment where the remote processor expects it 
		
		  Zero out remaining memory for this segment.
		 
		  This isn't strictly required since dma_alloc_coherent already
		  did this for us. albeit harmless, we may consider removing
		  this.
 Prepare function for rproc_ops 
	
	  Clear buffers after pm rumtime for internal ocram is not
	  accessible if power and clock are not enabled.
 Unprepare function for rproc_ops 
 Kick function for rproc_ops 
	
	  Send the index of the triggered virtqueue as the mu payload.
	  Let remote processor know which virtqueue is used.
  imx_dsp_attach_pm_domains() - attach the power domains
  @priv: private data pointer
  On i.MX8QM and i.MX8QXP there is multiple power domains
  required, so need to link them.
 If only one domain, then no need to link the device 
		
		  device_link_add will check priv->pd_dev[i], if it is
		  NULL, then will break.
  imx_dsp_rproc_detect_mode() - detect DSP control mode
  @priv: private data pointer
  Different platform has different control method for DSP, which depends
  on how the DSP is integrated in platform.
  For i.MX8QXP and i.MX8QM, DSP should be started and stopped by System
  Control Unit.
  For i.MX8MP and i.MX8ULP, DSP should be started and stopped by system
  integration module.
 DSP clocks 
 There are multiple power domains required by DSP on some platform 
 Get clocks 
 pm runtime functions 
	
	  There is power domain attached with mailbox, if setup mailbox
	  in probe(), then the power of mailbox is always enabled,
	  the power can't be saved.
	  So move setup of mailbox to runtime resume.
 Reset DSP if needed 
	
	  Same flow as start procedure.
	  Load the ELF segments to memory firstly.
 Start the remote processor 
 Tell DSP that suspend is happening 
	
	  DSP need to save the context at suspend.
	  Here waiting the response for DSP, then power can be disabled.
	
	  The power of DSP is disabled in suspend, so force pm runtime
	  to be suspend, then we can reenable the power and clocks at
	  resume stage.
	
	  The power of DSP is disabled at suspend, the memory of dsp
	  is reset, the image segments are lost. So need to reload
	  firmware and restart the DSP if it is in running state.
 SPDX-License-Identifier: GPL-2.0+
  Ingenic JZ47xx remoteproc driver
  Copyright 2019, Paul Cercueil <paul@crapouillou.net>
  struct vpu - Ingenic VPU remoteproc private structure
  @irq: interrupt number
  @clks: pointers to the VPU and AUX clocks
  @aux_base: raw pointer to the AUX interface registers
  @mem_info: array of struct vpu_mem_info, which contain the mapping info of
             each of the external memories
  @dev: private pointer to the device
 The clocks must be enabled for the firmware to be loaded in TCSM 
 Reset the AUX and enable message IRQ 
 Keep AUX in reset mode 
 Ack the interrupt 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017 Pengutronix, Oleksij Rempel <kernel@pengutronix.de>
 Address: 0x020D8000 
  struct imx_rproc_mem - slim internal memory structure
  @cpu_addr: MPU virtual address of the memory region
  @sys_addr: Bus address used to access the memory region
  @size: Size of the memory region
 att flags 
 M4 own area. Can be mapped at probe 
 dev addr , sys addr  , size	    , flags 
 ITCM   
 OCRAM_S 
 OCRAM 
 OCRAM 
 OCRAM 
 QSPI Code - alias 
 DDR (Code) - alias 
 DTCM 
 OCRAM_S - alias 
 OCRAM 
 OCRAM 
 OCRAM 
 DDR (Data) 
 dev addr , sys addr  , size	    , flags 
 TCML - alias 
 OCRAM_S 
 OCRAM 
 OCRAM 
 QSPI Code - alias 
 DDR (Code) - alias 
 TCML 
 TCMU 
 OCRAM_S 
 OCRAM 
 OCRAM 
 DDR (Data) 
 dev addr , sys addr  , size	    , flags 
 OCRAM_S (M4 Boot code) - alias 
 OCRAM_S (Code) 
 OCRAM (Code) - alias 
 OCRAM_EPDC (Code) - alias 
 OCRAM_PXP (Code) - alias 
 TCML (Code) 
 DDR (Code) - alias, first part of DDR (Data) 
 TCMU (Data) 
 OCRAM (Data) 
 OCRAM_EPDC (Data) 
 OCRAM_PXP (Data) 
 DDR (Data) 
 dev addr , sys addr  , size	    , flags 
 TCML (M4 Boot Code) - alias 
 OCRAM_S (Code) 
 OCRAM_S (Code) - alias 
 TCML (Code) 
 DDR (Code) - alias, first part of DDR (Data) 
 TCMU (Data) 
 OCRAM_S (Data) - alias? 
 DDR (Data) 
 parse address translation table 
	
	  On device side we have many aliases, so we need to convert device
	  address (M4) to system bus address first.
 __force to make sparse happy with type conversion 
 Update memory entry va 
 Register associated reserved memory regions 
		
		  Ignore the first memory region which will be used vdev buffer.
		  No need to do extra handlings, rproc_add_virtio_dev will handle it.
 No need to translate pa to da, i.MX use same map 
 Register memory region 
	
	  Send the index of the triggered virtqueue as the mu payload.
	  Let remote processor know which virtqueue is used.
 The resource table has already been mapped in imx_rproc_addr_init 
 remap required addresses 
 memory-region is optional property 
 remap optional addresses 
 Not map vdevbuffer, vdevring region 
 Not use resource version, because we might share region 
 Remote core is not under control of Linux 
	
	  clk for M4 block including memory. Should be
	  enabled before .start for FW transfer.
 set some other name then imx 
 SPDX-License-Identifier: GPL-2.0-only
  Character device interface driver for Remoteproc framework.
  Copyright (c) 2020, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0-only
  Qualcomm Peripheral Image Loader helpers
  Copyright (C) 2016 Linaro Ltd
  Copyright (C) 2015 Sony Mobile Communications Inc
  Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  struct minidump_region - Minidump region
  @name		: Name of the region to be dumped
  @seq_num:		: Use to differentiate regions with same name.
  @valid		: This entry to be dumped (if set to 1)
  @address		: Physical address of region to be dumped
  @size		: Size of the region
  struct minidump_subsystem_toc: Subsystem's SMEM Table of content
  @status : Subsystem toc init status
  @enabled : if set to 1, this region would be copied during coredump
  @encryption_status: Encryption status for this subsystem
  @encryption_required : Decides to encrypt the subsystem regions or not
  @region_count : Number of regions added in this subsystem toc
  @regions_baseptr : regions base pointer of the subsystem
  struct minidump_global_toc: Global Table of Content
  @status : Global Minidump init status
  @md_revision : Minidump revision
  @enabled : Minidump enable status
  @subsystems : Array of subsystems toc
 Get Global minidump ToC
 check if global table pointer exists and init is set 
 Get subsystem table of contents using the minidump id 
	
	  Collect minidump if SS ToC is valid and segment table
	  is initialized in memory and encryption status is set.
  qcom_add_glink_subdev() - try to add a GLINK subdevice to rproc
  @rproc:	rproc handle to parent the subdevice
  @glink:	reference to a GLINK subdev context
  @ssr_name:	identifier of the associated remoteproc for ssr notifications
  qcom_remove_glink_subdev() - remove a GLINK subdevice from rproc
  @rproc:	rproc handle
  @glink:	reference to a GLINK subdev context
  qcom_register_dump_segments() - register segments for coredump
  @rproc:	remoteproc handle
  @fw:		firmware header
  Register all segments of the ELF in the remoteproc coredump segment list
  Return: 0 on success, negative errno on failure.
  qcom_add_smd_subdev() - try to add a SMD subdevice to rproc
  @rproc:	rproc handle to parent the subdevice
  @smd:	reference to a Qualcomm subdev context
  qcom_remove_smd_subdev() - remove the smd subdevice from rproc
  @rproc:	rproc handle
  @smd:	the SMD subdevice to remove
 Match in the global qcom_ssr_subsystem_list with name 
 Add to global notification list 
  qcom_register_ssr_notifier() - register SSR notification handler
  @name:	Subsystem's SSR name
  @nb:		notifier_block to be invoked upon subsystem's state change
  This registers the @nb notifier block as part the notifier chain for a
  remoteproc associated with @name. The notifier block's callback
  will be invoked when the remote processor's SSR events occur
  (prepost startup and prepost shutdown).
  Return: a subsystem cookie on success, ERR_PTR on failure.
  qcom_unregister_ssr_notifier() - unregister SSR notification handler
  @notify:	subsystem cookie returned from qcom_register_ssr_notifier
  @nb:		notifier_block to unregister
  This function will unregister the notifier from the particular notifier
  chain.
  Return: 0 on success, %ENOENT otherwise.
  qcom_add_ssr_subdev() - register subdevice as restart notification source
  @rproc:	rproc handle
  @ssr:	SSR subdevice handle
  @ssr_name:	identifier to use for notifications originating from @rproc
  As the @ssr is registered with the @rproc SSR events will be sent to all
  registered listeners for the remoteproc when it's SSR events occur
  (prepost startup and prepost shutdown).
  qcom_remove_ssr_subdev() - remove subdevice as restart notification source
  @rproc:	rproc handle
  @ssr:	SSR subdevice handle
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2019-2020 Linaro Ltd.
  The PIL relocation information region is used to communicate memory regions
  occupied by co-processor firmware for post mortem crash analysis.
  It consists of an array of entries with an 8 byte textual identifier of the
  region followed by a 64 bit base address and 32 bit size, both little
  endian.
 Already initialized? 
  qcom_pil_info_store() - store PIL information of image in IMEM
  @image:	name of the image
  @base:	base address of the loaded image
  @size:	size of the loaded image
  Return: 0 on success, negative errno on failure
		
		  An empty record means we didn't find it, given that the
		  records are packed.
 Use two writel() as base is only aligned to 4 bytes on odd entries 
 SPDX-License-Identifier: GPL-2.0-only
  Remote Processor Framework
  Copyright (C) 2011 Texas Instruments, Inc.
  Copyright (C) 2011 Google, Inc.
  Ohad Ben-Cohen <ohad@wizery.com>
  Mark Grosen <mgrosen@ti.com>
  Brian Swetland <swetland@google.com>
  Fernando Guzman Lugo <fernando.lugo@ti.com>
  Suman Anna <s-anna@ti.com>
  Robert Tivy <rtivy@ti.com>
  Armando Uribe De Leon <x0095078@ti.com>
 remoteproc debugfs parent dir 
  A coredump-configuration-to-string lookup table, for exposing a
  human readable configuration via debugfs. Always keep in sync with
  enum rproc_coredump_mechanism
 Expose the current coredump configuration via debugfs 
  By writing to the 'coredump' debugfs entry, we control the behavior of the
  coredump mechanism dynamically. The default value of this entry is "disabled".
  The 'coredump' debugfs entry supports these commands:
  disabled:	By default coredump collection is disabled. Recovery will
 		proceed without collecting any dump.
  enabled:	When the remoteproc crashes the entire coredump will be copied
 		to a separate buffer and exposed to userspace.
  inline:	The coredump will not be copied to a separate buffer and the
 		recovery process will have to wait until data is read by
 		userspace. But this avoid usage of extra memory.
 remove end of line 
  Some remote processors may support dumping trace logs into a shared
  memory buffer. We expose this trace buffer using debugfs, so users
  can easily tell what's going on remotely.
  We will most probably improve the rproc tracing facilities later on,
  but this kind of lightweight and simple mechanism is always good to have,
  as it provides very early tracing with little to no dependencies at all.
 expose the name of the remote processor via debugfs 
 need room for the name, a newline and a terminating null 
 expose recovery flag via debugfs 
  By writing to the 'recovery' debugfs entry, we control the behavior of the
  recovery mechanism dynamically. The default value of this entry is "enabled".
  The 'recovery' debugfs entry supports these commands:
  enabled:	When enabled, the remote processor will be automatically
 		recovered whenever it crashes. Moreover, if the remote
 		processor crashes while recovery is disabled, it will
 		be automatically recovered too as soon as recovery is enabled.
  disabled:	When disabled, a remote processor will remain in a crashed
 		state if it crashes. This is useful for debugging purposes;
 		without it, debugging a crash is substantially harder.
  recover:	This function will trigger an immediate recovery if the
 		remote processor is in a crashed state, without changing
 		or checking the recovery state (enableddisabled).
 		This is useful during debugging sessions, when one expects
 		additional crashes to happen after enabling recovery. In this
 		case, enabling recovery will make it hard to debug subsequent
 		crashes, so it's recommended to keep recovery disabled, and
 		instead use the "recover" command as needed.
 remove end of line 
 change the flag and begin the recovery process if needed 
 begin the recovery process without changing the flag 
 expose the crash trigger via debugfs 
 Expose resource table content via debugfs 
 Expose carveout content via debugfs 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 MediaTek Inc.
  scp_get() - get a reference to SCP.
  @pdev:	the platform device of the module requesting SCP platform
 		device for using SCP API.
  Return: Return NULL if failed.  otherwise reference to SCP.
  scp_put() - "free" the SCP
  @scp:	mtk_scp structure from scp_get().
 read the ipi buf addr from FW itself first 
 use default ipi buf addr if the FW doesn't have it 
 SCP won't send another interrupt until we set SCP_TO_HOST to 0. 
		
		  SCP won't send another interrupt until we clear
		  MT8192_SCP2APMCU_IPC.
 go through the available ELF segments 
 grab the kernel address for this device address 
 put the segment where the remote processor expects it 
 Clear SCP to host interrupt 
 Reset clocks before loading FW 
 Initialize TCM before loading FW. 
 Turn on the power of SCP's SRAM before using it. 
	
	  Set I-cache and D-cache size before loading SCP FW.
	  SCP SRAM logical address may change when cache size setting differs.
 clear SPM interrupt, SCP2SPM_IPC_CLR 
 enable SRAM clock 
 enable MPU for all memory regions 
 Hold SCP in reset while loading FW. 
 optional memory region 
 optional memory region 
 Disable SCP watchdog 
 Disable SRAM clock 
 Disable SCP watchdog 
  scp_get_device() - get device struct of SCP
  @scp:	mtk_scp structure
  scp_get_rproc() - get rproc struct of SCP
  @scp:	mtk_scp structure
  scp_get_vdec_hw_capa() - get video decoder hardware capability
  @scp:	mtk_scp structure
  Return: video decoder hardware capability
  scp_get_venc_hw_capa() - get video encoder hardware capability
  @scp:	mtk_scp structure
  Return: video encoder hardware capability
  scp_mapping_dm_addr() - Mapping SRAMDRAM to kernel virtual address
  @scp:	mtk_scp structure
  @mem_addr:	SCP views memory address
  Mapping the SCP's SRAM address 
  DMEM (Data Extended Memory) memory address 
  Working buffer memory address to
  kernel virtual address.
  Return: Return ERR_PTR(-EINVAL) if mapping failed,
  otherwise the mapped kernel virtual address
 reserved memory is optional. 
 Reserved SCP code size 
 l1tcm is an optional memory region 
 register SCP initialization IPI 
 SPDX-License-Identifier: GPL-2.0-only
  Coredump functionality for Remoteproc framework.
  Copyright (c) 2020, The Linux Foundation. All rights reserved.
  rproc_coredump_cleanup() - clean up dump_segments list
  @rproc: the remote processor handle
  rproc_coredump_add_segment() - add segment of device memory to coredump
  @rproc:	handle of a remote processor
  @da:		device address
  @size:	size of segment
  Add device memory to the list of segments to be included in a coredump for
  the remoteproc.
  Return: 0 on success, negative errno on error.
  rproc_coredump_add_custom_segment() - add custom coredump segment
  @rproc:	handle of a remote processor
  @da:		device address
  @size:	size of segment
  @dumpfn:	custom dump function called for each segment during coredump
  @priv:	private data
  Add device memory to the list of segments to be included in the coredump
  and associate the segment with the given custom dump function and private
  data.
  Return: 0 on success, negative errno on error.
  rproc_coredump_set_elf_info() - set coredump elf information
  @rproc:	handle of a remote processor
  @class:	elf class for coredump elf file
  @machine:	elf machine for coredump elf file
  Set elf information which will be used for coredump elf file.
  Return: 0 on success, negative errno on error.
 Copy the vmalloc'ed header first. 
	
	  Find out the segment memory chunk to be copied based on offset.
	  Keep copying data until count bytes are read.
 EOF check 
  rproc_coredump() - perform coredump
  @rproc:	rproc handle
  This function will generate an ELF header for the registered segments
  and create a devcoredump device associated with rproc. Based on the
  coredump configuration this function will directly copy the segments
  from device memory to userspace or copy segments from device memory to
  a separate buffer, which can then be read by userspace.
  The first approach avoids using extra vmalloc memory. But it will stall
  recovery flow until dump is read by userspace.
		
		  For default configuration buffer includes headers & segments.
		  For inline dump buffer just includes headers as segments are
		  directly read from device memory.
 e_ident field is common for both elf32 and elf64 
 Initialize the dump state struct to be used by rproc_coredump_read 
	
	  Wait until the dump is read and free is called. Data is freed
	  by devcoredump framework automatically after 5 minutes.
  rproc_coredump_using_sections() - perform coredump using section headers
  @rproc:	rproc handle
  This function will generate an ELF header for the registered sections of
  segments and create a devcoredump device associated with rproc. Based on
  the coredump configuration this function will directly copy the segments
  from device memory to userspace or copy segments from device memory to
  a separate buffer, which can then be read by userspace.
  The first approach avoids using extra vmalloc memory. But it will stall
  recovery flow until dump is read by userspace.
	
	  We allocate two extra section headers. The first one is null.
	  Second section header is for the string table. Also space is
	  allocated for string table.
 the extra byte is for the null character at index 0 
 e_ident field is common for both elf32 and elf64 
	
	  The zeroth index of the section header is reserved and is rarely used.
	  Set the section header as null (SHN_UNDEF) and move to the next one.
 Initialize the string table. 
 Fill in the string table section header. 
 No need to copy segments for inline dumps 
 Initialize the dump state struct to be used by rproc_coredump_read 
	 Wait until the dump is read and free is called. Data is freed
	  by devcoredump framework automatically after 5 minutes.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2016-2018 Linaro Ltd.
  Copyright (C) 2014 Sony Mobile Communications AB
  Copyright (c) 2012-2018, The Linux Foundation. All rights reserved.
 Q6SS Register Offsets 
 AXI Halt Register Offsets 
 Q6SS_RESET 
 Q6SS_BRC_RESET 
 Q6SS_GFMUX_CTL 
 Q6SS_PWR_CTL 
 Q6SS parameters 
 Q6SS configstatus registers 
 Assert resets, stop core 
 BHS require xo cbcr to be enabled 
 Read CLKOFF bit to go low indicating CLK is enabled 
 Enable power block headswitch and wait for it to stabilize 
 Put LDO in bypass mode 
 Deassert Q6 compiler memory clamp 
 Deassert memory peripheral sleep and L2 memory standby 
 Turn on L1, L2, ETB and JU memories 1 at a time 
		
		  Read back value to ensure the write is done then
		  wait for 1us for both memory peripheral and data
		  array to turn on.
 Remove word line clamp 
 Remove IO clamp 
 Bring core out of reset 
 Turn on core clock 
 Start core execution 
 Release Q6 and WCSS reset 
 Lithium configuration - clock gating and bus arbitration 
 Write bootaddr to EVB so that Q6WCSS will jump there after reset 
 Toggle the restart 
 Enable GCC_WDSP_Q6SS_AHBS_CBCR clock 
 Remove reset to the WCNSS QDSP6SS 
 Enable Q6SSTOP_AHBFABRIC_CBCR clock 
 Enable the LCCCSR CBC clock, Q6SSTOP_Q6SSTOP_LCC_CSR_CBCR clock 
 Enable the Q6AHBS CBC, Q6SSTOP_Q6SS_AHBS_CBCR clock 
 Enable the TCM slave CBC, Q6SSTOP_Q6SS_TCM_SLAVE_CBCR clock 
 Enable the Q6SS AHB master CBC, Q6SSTOP_Q6SS_AHBM_CBCR clock 
 Enable the Q6SS AXI master CBC, Q6SSTOP_Q6SS_AXIM_CBCR clock 
 Enable the Q6SS XO CBC 
 Read CLKOFF bit to go low indicating CLK is enabled 
 Enable QDSP6 sleep clock clock 
 Enable the Enable the Q6 AXI clock, GCC_WDSP_Q6SS_AXIM_CBCR
 Assert resets, stop core 
 Program the QDSP6SS PWR_CTL register 
	
	  Enable memories by turning on the QDSP6 memory foothead switch, one
	  bank at a time to avoid in-rush current
 Enable the Q6 core clock at the GFM, Q6SSTOP_QDSP6SS_GFMUX_CTL 
 Enable sleep clock branch needed for BCR circuit 
 Start core execution 
 Check if we're already idle 
 Assert halt request 
 Wait for halt 
 Clear halt request (port will remain halted until reset) 
 assert clamps to avoid MX current inrush 
 Disable memories by turning off memory footheadswitch 
 Clear the BHS_ON bit 
 1 - Assert WCSSQ6 HALTREQ 
 2 - Enable WCSSAON_CONFIG 
 3 - Set SSCAON_CONFIG 
 4 - SSCAON_CONFIG 1 
 5 - wait for SSCAON_STATUS 
 6 - De-assert WCSS_AON reset 
 7 - Disable WCSSAON_CONFIG 13 
 8 - De-assert WCSSQ6 HALTREQ 
 1 - Halt Q6 bus interface 
 2 - Disable Q6 Core clock 
 3 - Clamp IO 
 4 - Clamp WL 
 5 - Clear Erase standby 
 6 - Clear Sleep RTN 
 7 - turn off Q6 memory foothead switch one bank at a time 
 8 - Assert QMC memory RTN 
 9 - Turn off BHS 
 10 - Wait till BHS Reset is done 
 11 -  Assert WCSS reset 
 12 - Assert Q6 reset 
 WCSS powerdown 
 Q6 Power down 
 SPDX-License-Identifier: GPL-2.0-only
  Qualcomm Wireless Connectivity Subsystem Iris driver
  Copyright (C) 2016 Linaro Ltd
  Copyright (C) 2014 Sony Mobile Communications AB
  Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0-only
  Qualcomm Wireless Connectivity Subsystem Peripheral Image Loader
  Copyright (C) 2016 Linaro Ltd
  Copyright (C) 2014 Sony Mobile Communications AB
  Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
 1: in progress, 0: done 
 1: in progress, 0: done 
 Indicate NV download capability 
 Clear PMU cfg register 
 Clear XO_MODE 
 Reset IRIS 
 Wait for PMU.iris_reg_reset_sts 
 Clear IRIS reset 
 Start IRIS XO configuration 
 Wait for XO configuration to finish 
 Stop IRIS XO configuration 
 Add some delay for XO to settle 
 We have a ready_irq, but it didn't fire in time. 
	
	  XXX: At this point we're supposed to release the resources that we
	  have been holding on behalf of the WCNSS. Unfortunately this
	  interrupt comes way before the other side seems to be done.
	 
	  So we're currently relying on the ready interrupt firing later then
	  this and we just disable the resources at the end of wcnss_start().
	
	  If attaching the power domains suceeded we can skip requesting
	  the regulators for the power domains. For old device trees we need to
	  reserve extra space to manage them through the regulator interface.
	
	  We might need to fallback to regulators instead of power domains
	  for old device trees. Don't report an error in that case.
 SPDX-License-Identifier: GPL-2.0-only
  Remote Processor Framework
  Copyright (C) 2011 Texas Instruments, Inc.
  Copyright (C) 2011 Google, Inc.
  Ohad Ben-Cohen <ohad@wizery.com>
  Brian Swetland <swetland@google.com>
  Mark Grosen <mgrosen@ti.com>
  Fernando Guzman Lugo <fernando.lugo@ti.com>
  Suman Anna <s-anna@ti.com>
  Robert Tivy <rtivy@ti.com>
  Armando Uribe De Leon <x0095078@ti.com>
 XXX: pokes into bus_dma_range 
 Unique indices for remoteproc devices 
 translate rproc_crash_type to string 
  This is the IOMMU fault handler we register with the IOMMU API
  (when relevant; not all remote processors access memory through
  an IOMMU).
  IOMMU core will invoke this handler whenever the remote processor
  will try to access an unmapped device address.
	
	  Let the iommu core know we're not really handling this fault;
	  we just used it as a recovery trigger.
	
	  Return physical address according to virtual address location
	  - in vmalloc: if region ioremapped or defined as dma_alloc_coherent
	  - in kernel: if region allocated in generic dma memory pool
  rproc_da_to_va() - lookup the kernel virtual address for a remoteproc address
  @rproc: handle of a remote processor
  @da: remoteproc device address to translate
  @len: length of the memory region @da is pointing to
  @is_iomem: optional pointer filled in to indicate if @da is iomapped memory
  Some remote processors will ask us to allocate them physically contiguous
  memory regions (which we call "carveouts"), and map them to specific
  device addresses (which are hardcoded in the firmware). They may also have
  dedicated memory regions internal to the processors, and use them either
  exclusively or alongside carveouts.
  They may then ask us to copy objects into specific device addresses (e.g.
  codedata sections) or expose us certain symbols in other device address
  (e.g. their trace buffer).
  This function is a helper function with which we can go over the allocated
  carveouts and translate specific device addresses to kernel virtual addresses
  so we can access the referenced memory. This function also allows to perform
  translations on the internal remoteproc memory regions through a platform
  implementation specific da_to_va ops, if present.
  Note: phys_to_virt(iommu_iova_to_phys(rproc->domain, da)) will work too,
  but only on kernel direct mapped RAM memory. Instead, we're just using
  here the output of the DMA API for the carveouts, which should be more
  correct.
  Return: a valid kernel address on success or NULL on failure
  Verify that carveout is allocated 
 try next carveout if da is too small 
 try next carveout if da is too large 
  rproc_find_carveout_by_name() - lookup the carveout region by a name
  @rproc: handle of a remote processor
  @name: carveout name to find (format string)
  @...: optional parameters matching @name string
  Platform driver has the capability to register some pre-allacoted carveout
  (physically contiguous memory regions) before rproc firmware loading and
  associated resource table analysis. These regions may be dedicated memory
  regions internal to the coprocessor or specified DDR region with specific
  attributes
  This function is a helper function with which we can go over the
  allocated carveouts and return associated region characteristics like
  coprocessor address, length or processor virtual address.
  Return: a valid pointer on carveout entry on success or NULL on failure.
 Compare carveout and requested names 
  rproc_check_carveout_da() - Check specified carveout da configuration
  @rproc: handle of a remote processor
  @mem: pointer on carveout to check
  @da: area device address
  @len: associated area size
  This function is a helper function to verify requested device area (couple
  da, len) is part of specified carveout.
  If da is not set (defined as FW_RSC_ADDR_ANY), only requested length is
  checked.
  Return: 0 if carveout matches request else error
 Check requested resource length 
 Address doesn't match registered carveout configuration 
 Check requested resource belongs to registered carveout 
 actual size of vring (in bytes) 
 Search for pre-registered carveout 
 Register carveout in in list 
	
	  Assign an rproc-wide unique index for this vring
	  TODO: assign a notifyid for rvdev updates as well
	  TODO: support predefined notifyids (via resource table)
 Potentially bump max_notifyid 
 Let the rproc know the notifyid of this vring.
 verify queue size and vring alignment are sane 
	
	  At this point rproc_stop() has been called and the installed resource
	  table in the remote processor memory may no longer be accessible. As
	  such and as per rproc_stop(), rproc->table_ptr points to the cached
	  resource table (rproc->cached_table).  The cached resource table is
	  only available when a remote processor has been booted by the
	  remoteproc core, otherwise it is NULL.
	 
	  Based on the above, reset the virtio device section in the cached
	  resource table only if there is one to work with.
  rproc_rvdev_release() - release the existence of a rvdev
  @dev: the subdevice's dev
  rproc_handle_vdev() - handle a vdev fw resource
  @rproc: the remote processor
  @ptr: the vring resource descriptor
  @offset: offset of the resource entry
  @avail: size of available data (for sanity checking the image)
  This resource entry requests the host to statically register a virtio
  device (vdev), and setup everything needed to support it. It contains
  everything needed to make it possible: the virtio device id, virtio
  device features, vrings information, virtio config space, etc...
  Before registering the vdev, the vrings are allocated from non-cacheable
  physically contiguous memory. Currently we only support two vrings per
  remote processor (temporary limitation). We might also want to consider
  doing the vring allocation only later when ->find_vqs() is invoked, and
  then release them upon ->del_vqs().
  Note: @da is currently not really handled correctly: we dynamically
  allocate it using the DMA API, ignoring requested hard coded addresses,
  and we don't take care of any required IOMMU programming. This is all
  going to be taken care of when the generic iommu-based DMA API will be
  merged. Meanwhile, statically-addressed iommu-based firmware images should
  use RSC_DEVMEM resource entries to map their required @da to the physical
  address of their base CMA region (ouch, hacky!).
  Return: 0 on success, or an appropriate error code otherwise
 make sure resource isn't truncated 
 make sure reserved bytes are zeroes 
 we currently support only two vrings per rvdev 
 Initialise vdev subdevice 
 Make device dma capable by inheriting from parent's capabilities 
 parse the vrings 
 remember the resource offset
 allocate the vring resources 
  rproc_handle_trace() - handle a shared trace buffer resource
  @rproc: the remote processor
  @ptr: the trace resource descriptor
  @offset: offset of the resource entry
  @avail: size of available data (for sanity checking the image)
  In case the remote processor dumps trace logs into memory,
  export it via debugfs.
  Currently, the 'da' member of @rsc should contain the device address
  where the remote processor is dumping the traces. Later we could also
  support dynamically allocating this address using the generic
  DMA API (but currently there isn't a use case for that).
  Return: 0 on success, or an appropriate error code otherwise
 make sure reserved bytes are zeroes 
 set the trace buffer dma properties 
 set pointer on rproc device 
 make sure snprintf always null terminates, even if truncating 
 create the debugfs entry 
  rproc_handle_devmem() - handle devmem resource entry
  @rproc: remote processor handle
  @ptr: the devmem resource entry
  @offset: offset of the resource entry
  @avail: size of available data (for sanity checking the image)
  Remote processors commonly need to access certain on-chip peripherals.
  Some of these remote processors access memory via an iommu device,
  and might require us to configure their iommu before they can access
  the on-chip peripherals they need.
  This resource entry is a request to map such a peripheral device.
  These devmem entries will contain the physical address of the device in
  the 'pa' member. If a specific device address is expected, then 'da' will
  contain it (currently this is the only use case supported). 'len' will
  contain the size of the physical region we need to map.
  Currently we just "trust" those devmem entries to contain valid physical
  addresses, but this is going to change: we want the implementations to
  tell us ranges of physical addresses the firmware is allowed to request,
  and not allow firmwares to request access to physical addresses that
  are outside those ranges.
  Return: 0 on success, or an appropriate error code otherwise
 no point in handling this resource without a valid iommu domain 
 make sure reserved bytes are zeroes 
	
	  We'll need this info later when we'll want to unmap everything
	  (e.g. on shutdown).
	 
	  We can't trust the remote processor not to change the resource
	  table, so we must maintain this info independently.
  rproc_alloc_carveout() - allocated specified carveout
  @rproc: rproc handle
  @mem: the memory entry to allocate
  This function allocate specified memory entry @mem using
  dma_alloc_coherent() as default allocator
  Return: 0 on success, or an appropriate error code otherwise
		
		  Check requested da is equal to dma address
		  and print a warn message in case of missalignment.
		  Don't stop rproc_start sequence as coprocessor may
		  build pa to da translation on its side.
	
	  Ok, this is non-standard.
	 
	  Sometimes we can't rely on the generic iommu-based DMA API
	  to dynamically allocate the device address and then set the IOMMU
	  tables accordingly, because some remote processors might
	  _require_ us to use hard coded device addresses that their
	  firmware was compiled with.
	 
	  In this case, we must use the IOMMU API directly and map
	  the memory to the device address as expected by the remote
	  processor.
	 
	  Obviously such remote processor devices should not be configured
	  to use the iommu-based DMA API: we expect 'dma' to contain the
	  physical address in this case.
		
		  We'll need this info later when we'll want to unmap
		  everything (e.g. on shutdown).
		 
		  We can't trust the remote processor not to change the
		  resource table, so we must maintain this info independently.
 Update device address as undefined by requester 
  rproc_release_carveout() - release acquired carveout
  @rproc: rproc handle
  @mem: the memory entry to release
  This function releases specified memory entry @mem allocated via
  rproc_alloc_carveout() function by @rproc.
  Return: 0 on success, or an appropriate error code otherwise
 clean up carveout allocations 
  rproc_handle_carveout() - handle phys contig memory allocation requests
  @rproc: rproc handle
  @ptr: the resource entry
  @offset: offset of the resource entry
  @avail: size of available data (for image validation)
  This function will handle firmware requests for allocation of physically
  contiguous memory regions.
  These request entries should come first in the firmware's resource table,
  as other firmware entries might request placing other data objects inside
  these memory regions (e.g. datacode segments, trace resource entries, ...).
  Allocating memory this way helps utilizing the reserved physical memory
  (e.g. CMA) more efficiently, and also minimizes the number of TLB entries
  needed to map it (in case @rproc is using an IOMMU). Reducing the TLB
  pressure is important; it may have a substantial impact on performance.
  Return: 0 on success, or an appropriate error code otherwise
 make sure reserved bytes are zeroes 
	
	  Check carveout rsc already part of a registered carveout,
	  Search by name, then check the da and length
 Update memory carveout with resource table info 
 Register carveout in in list 
  rproc_add_carveout() - register an allocated carveout region
  @rproc: rproc handle
  @mem: memory entry to register
  This function registers specified memory entry in @rproc carveouts list.
  Specified carveout should have been allocated before registering.
  rproc_mem_entry_init() - allocate and initialize rproc_mem_entry struct
  @dev: pointer on device struct
  @va: virtual address
  @dma: dma address
  @len: memory carveout length
  @da: device address
  @alloc: memory carveout allocation function
  @release: memory carveout release function
  @name: carveout name
  This function allocates a rproc_mem_entry struct and fill it with parameters
  provided by client.
  Return: a valid pointer on success, or NULL on failure
  rproc_of_resm_mem_entry_init() - allocate and initialize rproc_mem_entry struct
  from a reserved memory phandle
  @dev: pointer on device struct
  @of_resm_idx: reserved memory phandle index in "memory-region"
  @len: memory carveout length
  @da: device address
  @name: carveout name
  This function allocates a rproc_mem_entry struct and fill it with parameters
  provided by client.
  Return: a valid pointer on success, or NULL on failure
  rproc_of_parse_firmware() - parse and return the firmware-name
  @dev: pointer on device struct representing a rproc
  @index: index to use for the firmware-name retrieval
  @fw_name: pointer to a character string, in which the firmware
            name is returned on success and unmodified otherwise.
  This is an OF helper function that parses a device's DT node for
  the "firmware-name" property and returns the firmware name pointer
  in @fw_name on success.
  Return: 0 on success, or an appropriate failure.
  A lookup table for resource handlers. The indices are defined in
  enum fw_resource_type.
 handle firmware resource entries before booting the remote processor 
 make sure table isn't truncated 
  rproc_alloc_registered_carveouts() - allocate all carveouts registered
  in the list
  @rproc: the remote processor handle
  This function parses registered carveout list, performs allocation
  if alloc() ops registered and updates resource table information
  if rsc_offset set.
  Return: 0 on success
 update resource table 
			
			  Some remote processors might need to know the pa
			  even though they are behind an IOMMU. E.g., OMAP4's
			  remote M3 processor needs this so it can control
			  on-chip hardware accelerators that are not behind
			  the IOMMU, and therefor must know the pa.
			 
			  Generally we don't want to expose physical addresses
			  if we don't have to (remote processors are generally
			  _not_ trusted), so we might want to do this only for
			  remote processor that _must_ have this (e.g. OMAP4's
			  dual M3 subsystem).
			 
			  Non-IOMMU processors might also want to have this info.
			  In this case, the device address and the physical address
			  are the same.
 Use va if defined else dma to generate pa 
  rproc_resource_cleanup() - clean up and free all acquired resources
  @rproc: rproc handle
  This function will free all resources acquired for @rproc, and it
  is called whenever @rproc either shuts down or fails to boot.
 clean up debugfs trace entries 
 clean up iommu mapping entries 
 nothing much to do besides complaining 
 clean up carveout allocations 
 clean up remote vdev entries 
 load the ELF segments to memory 
	
	  The starting device has been given the rproc->cached_table as the
	  resource table. The address of the vring along with the other
	  allocated resources (carveouts etc) is stored in cached_table.
	  In order to pass this information to the remote device we must copy
	  this information to device memory. We also update the table_ptr so
	  that any subsequent changes will be applied to the loaded version.
 power up the remote processor 
 Start any subdevices for the remote processor 
 Attach to the remote processor 
 Start any subdevices for the remote processor 
  take a firmware and boot a remote processor with it.
	
	  if enabling an IOMMU isn't relevant for this rproc, this is
	  just a nop
 Prepare rproc for firmware loading if needed 
 Load resource table, core dump segment list etc from the firmware 
 reset max_notifyid 
 reset handled vdev 
 handle fw resources which are required to boot rproc 
 Allocate carveout resources associated to rproc 
 release HW resources if needed 
 Not having a resource table is acceptable 
	
	  If it is possible to detach the remote processor, keep an untouched
	  copy of the resource table.  That way we can start fresh again when
	  the remote processor is re-attached, that is:
	 
	       DETACHED -> ATTACHED -> DETACHED -> ATTACHED
	 
	  Free'd in rproc_reset_rsc_table_on_detach() and
	  rproc_reset_rsc_table_on_stop().
 A resource table was never retrieved, nothing to do here 
	
	  If we made it to this point a clean_table _must_ have been
	  allocated in rproc_set_rsc_table().  If one isn't present
	  something went really wrong and we must complain.
 Remember where the external entity installed the resource table 
	
	  If we made it here the remote processor was started by another
	  entity and a cache table doesn't exist.  As such make a copy of
	  the resource table currently used by the remote processor and
	  use that for the rest of the shutdown process.  The memory
	  allocated here is free'd in rproc_detach().
	
	  Use a copy of the resource table for the remainder of the
	  shutdown process.
	
	  Reset the memory area where the firmware loaded the resource table
	  to its original value.  That way when we re-attach the remote
	  processor the resource table is clean and ready to be used again.
	
	  The clean resource table is no longer needed.  Allocated in
	  rproc_set_rsc_table().
 A resource table was never retrieved, nothing to do here 
	
	  If a cache table exists the remote processor was started by
	  the remoteproc core.  That cache table should be used for
	  the rest of the shutdown process.
	
	  If we made it here the remote processor was started by another
	  entity and a cache table doesn't exist.  As such make a copy of
	  the resource table currently used by the remote processor and
	  use that for the rest of the shutdown process.  The memory
	  allocated here is free'd in rproc_shutdown().
	
	  Since the remote processor is being switched off the clean table
	  won't be needed.  Allocated in rproc_set_rsc_table().
	
	  Use a copy of the resource table for the remainder of the
	  shutdown process.
  Attach to remote processor - similar to rproc_fw_boot() but without
  the steps that deal with the firmware image.
	
	  if enabling an IOMMU isn't relevant for this rproc, this is
	  just a nop
 Do anything that is needed to boot the remote processor 
 reset max_notifyid 
 reset handled vdev 
	
	  Handle firmware resources required to attach to a remote processor.
	  Because we are attaching rather than booting the remote processor,
	  we expect the platform driver to properly set rproc->table_ptr.
 Allocate carveout resources associated to rproc 
 release HW resources if needed 
  take a firmware and boot it up.
  Note: this function is called asynchronously upon registration of the
  remote processor (so we must wait until it completes before we try
  to unregister the device. one other option is just to use kref here,
  that might be cleaner).
	
	  Since the remote processor is in a detached state, it has already
	  been booted by another entity.  As such there is no point in waiting
	  for a firmware image to be loaded, we can simply initiate the process
	  of attaching to it immediately.
	
	  We're initiating an asynchronous firmware loading, so we can
	  be built-in kernel code, without hanging the boot process.
 No need to continue if a stop() operation has not been provided 
 Stop any subdevices for the remote processor 
 the installed resource table is no longer accessible 
 power off the remote processor 
  __rproc_detach(): Does the opposite of __rproc_attach()
 No need to continue if a detach() operation has not been provided 
 Stop any subdevices for the remote processor 
 the installed resource table is no longer accessible 
 Tell the remote processor the core isn't available anymore 
  rproc_trigger_recovery() - recover a remoteproc
  @rproc: the remote processor
  The recovery is done by resetting all the virtio devices, that way all the
  rpmsg drivers will be reseted along with the remote processor making the
  remoteproc functional again.
  This function can sleep, so it cannot be called from atomic context.
  Return: 0 on success or a negative value upon failure
 State could have changed before we got the mutex 
 generate coredump 
 load firmware 
 boot the remote processor up again 
  rproc_crash_handler_work() - handle a crash
  @work: work treating the crash
  This function needs to handle everything related to a crash, like cpu
  registers and stack dump, information to help to debug the fatal error, etc.
 handle only the first crash detected 
  rproc_boot() - boot a remote processor
  @rproc: handle of a remote processor
  Boot a remote processor (i.e. load its firmware, power it on, ...).
  If the remote processor is already powered on, this function immediately
  returns (successfully).
  Return: 0 on success, and an appropriate error value otherwise
 skip the boot or attach process if rproc is already powered up 
 load firmware 
  rproc_shutdown() - power off the remote processor
  @rproc: the remote processor
  Power off a remote processor (previously booted with rproc_boot()).
  In case @rproc is still being used by an additional user(s), then
  this function will just decrement the power refcount and exit,
  without really powering off the device.
  Every call to rproc_boot() must (eventually) be accompanied by a call
  to rproc_shutdown(). Calling rproc_shutdown() redundantly is a bug.
  Notes:
  - we're not decrementing the rproc's refcount, only the power refcount.
    which means that the @rproc handle stays valid even after rproc_shutdown()
    returns, and users can still use it with a subsequent rproc_boot(), if
    needed.
 if the remote proc is still needed, bail out 
 clean up all acquired resources 
 release HW resources if needed 
 Free the copy of the resource table 
  rproc_detach() - Detach the remote processor from the
  remoteproc core
  @rproc: the remote processor
  Detach a remote processor (previously attached to with rproc_attach()).
  In case @rproc is still being used by an additional user(s), then
  this function will just decrement the power refcount and exit,
  without disconnecting the device.
  Function rproc_detach() calls __rproc_detach() in order to let a remote
  processor know that services provided by the application processor are
  no longer available.  From there it should be possible to remove the
  platform driver and even power cycle the application processor (if the HW
  supports it) without needing to switch off the remote processor.
  Return: 0 on success, and an appropriate error value otherwise
 if the remote proc is still needed, bail out 
 clean up all acquired resources 
 release HW resources if needed 
 Free the copy of the resource table 
  rproc_get_by_phandle() - find a remote processor by phandle
  @phandle: phandle to the rproc
  Finds an rproc handle using the remote processor's phandle, and then
  return a handle to the rproc.
  This function increments the remote processor's refcount, so always
  use rproc_put() to decrement it back once rproc isn't needed anymore.
  Return: rproc handle on success, and NULL on failure
 prevent underlying implementation from being removed 
  rproc_set_firmware() - assign a new firmware
  @rproc: rproc handle to which the new firmware is being assigned
  @fw_name: new firmware name to be assigned
  This function allows remoteproc drivers or clients to configure a custom
  firmware name that is different from the default name used during remoteproc
  registration. The function does not trigger a remote processor boot,
  only sets the firmware name used for a subsequent boot. This function
  should also be called only when the remote processor is offline.
  This allows either the userspace to configure a different name through
  sysfs or a kernel-level remoteproc or a remoteproc client driver to set
  a specific firmware when it is controlling the boot and shutdown of the
  remote processor.
  Return: 0 on success or a negative value upon failure
		
		  An offline processor without a start()
		  function makes no sense.
		
		  A remote processor in a detached state without an
		  attach() function makes not sense.
		
		  When attaching to a remote processor the device memory
		  is already available and as such there is no need to have a
		  cached table.
		
		  When adding a remote processor, the state of the device
		  can be offline or detached, nothing else.
  rproc_add() - register a remote processor
  @rproc: the remote processor handle to register
  Registers @rproc with the remoteproc framework, after it has been
  allocated with rproc_alloc().
  This is called by the platform-specific rproc implementation, whenever
  a new remote processor device is probed.
  Note: this function initiates an asynchronous firmware loading
  context, which will look for virtio devices supported by the rproc's
  firmware.
  If found, those virtio devices will be created and added, so as a result
  of registering this remote processor, additional virtio drivers might be
  probed.
  Return: 0 on success and an appropriate error code otherwise
 add char device for this remoteproc 
 create debugfs entries 
 if rproc is marked always-on, request it to boot 
 expose to rproc_get_by_phandle users 
  devm_rproc_add() - resource managed rproc_add()
  @dev: the underlying device
  @rproc: the remote processor handle to register
  This function performs like rproc_add() but the registered rproc device will
  automatically be removed on driver detach.
  Return: 0 on success, negative errno on failure
  rproc_type_release() - release a remote processor instance
  @dev: the rproc's device
  This function should _never_ be called directly.
  It will be called by the driver core when no one holds a valid pointer
  to @dev anymore.
	
	  Allocate a firmware name if the caller gave us one to work
	  with.  Otherwise construct a new one using a default pattern.
 Default to rproc_coredump if no coredump function is specified 
 Default to ELF loader if no load function is specified 
  rproc_alloc() - allocate a remote processor handle
  @dev: the underlying device
  @name: name of this remote processor
  @ops: platform-specific handlers (mainly startstop)
  @firmware: name of firmware file to load, can be NULL
  @len: length of private data needed by the rproc driver (in bytes)
  Allocates a new remote processor handle, but does not register
  it yet. if @firmware is NULL, a default name is used.
  This function should be used by rproc implementations during initialization
  of the remote processor.
  After creating an rproc handle using this function, and when ready,
  implementations should then call rproc_add() to complete
  the registration of the remote processor.
  Note: _never_ directly deallocate @rproc, even if it was not registered
  yet. Instead, when you need to unroll rproc_alloc(), use rproc_free().
  Return: new rproc pointer on success, and NULL on failure
 Assign a unique device index and name 
  rproc_free() - unroll rproc_alloc()
  @rproc: the remote processor handle
  This function decrements the rproc dev refcount.
  If no one holds any reference to rproc anymore, then its refcount would
  now drop to zero, and it would be freed.
  rproc_put() - release rproc reference
  @rproc: the remote processor handle
  This function decrements the rproc dev refcount.
  If no one holds any reference to rproc anymore, then its refcount would
  now drop to zero, and it would be freed.
  rproc_del() - unregister a remote processor
  @rproc: rproc handle to unregister
  This function should be called when the platform specific rproc
  implementation decides to remove the rproc device. it should
  _only_ be called if a previous invocation of rproc_add()
  has completed successfully.
  After rproc_del() returns, @rproc isn't freed yet, because
  of the outstanding reference created by rproc_alloc. To decrement that
  one last refcount, one still needs to call rproc_free().
  Return: 0 on success and -EINVAL if @rproc isn't valid
 TODO: make sure this works with rproc->power > 1 
 the rproc is downref'ed as soon as it's removed from the klist 
 Ensure that no readers of rproc_list are still active 
  devm_rproc_alloc() - resource managed rproc_alloc()
  @dev: the underlying device
  @name: name of this remote processor
  @ops: platform-specific handlers (mainly startstop)
  @firmware: name of firmware file to load, can be NULL
  @len: length of private data needed by the rproc driver (in bytes)
  This function performs like rproc_alloc() but the acquired rproc device will
  automatically be released on driver detach.
  Return: new rproc instance, or NULL on failure
  rproc_add_subdev() - add a subdevice to a remoteproc
  @rproc: rproc handle to add the subdevice to
  @subdev: subdev handle to register
  Caller is responsible for populating optional subdevice function pointers.
  rproc_remove_subdev() - remove a subdevice from a remoteproc
  @rproc: rproc handle to remove the subdevice from
  @subdev: subdev handle, previously registered with rproc_add_subdev()
  rproc_get_by_child() - acquire rproc handle of @dev's ancestor
  @dev:	child device to find ancestor of
  Return: the ancestor rproc instance, or NULL if not found
  rproc_report_crash() - rproc crash reporter function
  @rproc: remote processor
  @type: crash type
  This function must be called every time a crash is detected by the low-level
  drivers implementing a specific remoteproc. This should not be called from a
  non-remoteproc driver.
  This function can be called from atomicinterrupt context.
 Prevent suspend while the remoteproc is being recovered 
 Have a worker handle the error; ensure system is not suspended 
	
	  Delay for the longest requested duration before returning. This can
	  be used by the remoteproc drivers to give the remote processor time
	  to perform any requested operations (such as flush caches), when
	  it's not possible to signal the Linux side due to the panic.
 SPDX-License-Identifier: GPL-2.0-only
  Remote Processor Framework
  By writing to the 'recovery' sysfs entry, we control the behavior of the
  recovery mechanism dynamically. The default value of this entry is "enabled".
  The 'recovery' sysfs entry supports these commands:
  enabled:	When enabled, the remote processor will be automatically
 		recovered whenever it crashes. Moreover, if the remote
 		processor crashes while recovery is disabled, it will
 		be automatically recovered too as soon as recovery is enabled.
  disabled:	When disabled, a remote processor will remain in a crashed
 		state if it crashes. This is useful for debugging purposes;
 		without it, debugging a crash is substantially harder.
  recover:	This function will trigger an immediate recovery if the
 		remote processor is in a crashed state, without changing
 		or checking the recovery state (enableddisabled).
 		This is useful during debugging sessions, when one expects
 		additional crashes to happen after enabling recovery. In this
 		case, enabling recovery will make it hard to debug subsequent
 		crashes, so it's recommended to keep recovery disabled, and
 		instead use the "recover" command as needed.
 change the flag and begin the recovery process if needed 
 begin the recovery process without changing the flag 
  A coredump-configuration-to-string lookup table, for exposing a
  human readable configuration via sysfs. Always keep in sync with
  enum rproc_coredump_mechanism
 Expose the current coredump configuration via debugfs 
  By writing to the 'coredump' sysfs entry, we control the behavior of the
  coredump mechanism dynamically. The default value of this entry is "default".
  The 'coredump' sysfs entry supports these commands:
  disabled:	This is the default coredump mechanism. Recovery will proceed
 		without collecting any dump.
  default:	When the remoteproc crashes the entire coredump will be
 		copied to a separate buffer and exposed to userspace.
  inline:	The coredump will not be copied to a separate buffer and the
 		recovery process will have to wait until data is read by
 		userspace. But this avoid usage of extra memory.
 Expose the loaded  running firmware name via sysfs 
	
	  If the remote processor has been started by an external
	  entity we have no idea of what image it is running.  As such
	  simply display a generic string rather then rproc->firmware.
 Change firmware name via sysfs 
  A state-to-string lookup table, for exposing a human readable state
  via sysfs. Always keep in sync with enum rproc_state
 Expose the state of the remote processor via sysfs 
 Change remote processor state via sysfs 
 Expose the name of the remote processor via sysfs 
 create remoteproc device class for sysfs 
 SPDX-License-Identifier: GPL-2.0-only
  Remote Processor Framework Elf loader
  Copyright (C) 2011 Texas Instruments, Inc.
  Copyright (C) 2011 Google, Inc.
  Ohad Ben-Cohen <ohad@wizery.com>
  Brian Swetland <swetland@google.com>
  Mark Grosen <mgrosen@ti.com>
  Fernando Guzman Lugo <fernando.lugo@ti.com>
  Suman Anna <s-anna@ti.com>
  Robert Tivy <rtivy@ti.com>
  Armando Uribe De Leon <x0095078@ti.com>
  Sjur Brændeland <sjur.brandeland@stericsson.com>
  rproc_elf_sanity_check() - Sanity Check for ELF32ELF64 firmware image
  @rproc: the remote processor handle
  @fw: the ELF firmware image
  Make sure this fw image is sane (ie a correct ELF32ELF64 file).
  Return: 0 on success and -EINVAL upon any failure
	
	  Elf files are beginning with the same structure. Thus, to simplify
	  header parsing, we can use the elf32_hdr one for both elf64 and
	  elf32.
 We assume the firmware has the same endianness as the host 
 BIG ENDIAN 
  rproc_elf_get_boot_addr() - Get rproc's boot address.
  @rproc: the remote processor handle
  @fw: the ELF firmware image
  Note that the boot address is not a configurable property of all remote
  processors. Some will always boot at a specific hard-coded address.
  Return: entry point address of the ELF image
  rproc_elf_load_segments() - load firmware segments to memory
  @rproc: remote processor which will be booted using these fw segments
  @fw: the ELF firmware image
  This function loads the firmware segments to memory, where the remote
  processor expects them.
  Some remote processors will expect their code and data to be placed
  in specific device addresses, and can't have them dynamically assigned.
  We currently support only those kind of remote processors, and expect
  the program header's paddr member to contain those addresses. We then go
  through the physically contiguous "carveout" memory regions which we
  allocated (and mapped) earlier on behalf of the remote processor,
  and "translate" device address to kernel addresses, so we can copy the
  segments where they are expected.
  Currently we only support remote processors that required carveout
  allocations and got them mapped onto their iommus. Some processors
  might be different: they might not have iommus, and would prefer to
  directly allocate memory for every segmentresource. This is not yet
  supported, though.
  Return: 0 on success and an appropriate error code otherwise
 go through the available ELF segments 
 grab the kernel address for this device address 
 put the segment where the remote processor expects it 
		
		  Zero out remaining memory for this segment.
		 
		  This isn't strictly required since dma_alloc_coherent already
		  did this for us. albeit harmless, we may consider removing
		  this.
 look for the resource table and handle it 
 First, get the section header according to the elf class 
 Compute name table section header entry in shdr array 
 Finally, compute the name table section address in elf 
 make sure we have the entire table 
 make sure table has at least the header 
 we don't support any version beyond the first 
 make sure reserved bytes are zeroes 
 make sure the offsets array isn't truncated 
  rproc_elf_load_rsc_table() - load the resource table
  @rproc: the rproc handle
  @fw: the ELF firmware image
  This function finds the resource table inside the remote processor's
  firmware, load it into the @cached_table and update @table_ptr.
  Return: 0 on success, negative errno on failure.
	
	  Create a copy of the resource table. When a virtio device starts
	  and calls vring_new_virtqueue() the address of the allocated vring
	  will be stored in the cached_table. Before the device is started,
	  cached_table will be copied into device memory.
  rproc_elf_find_loaded_rsc_table() - find the loaded resource table
  @rproc: the rproc handle
  @fw: the ELF firmware image
  This function finds the location of the loaded resource table. Don't
  call this function if the table wasn't loaded yet - it's a bug if you do.
  Return: pointer to the resource table if it is found or NULL otherwise.
  If the table wasn't loaded yet the result is unspecified.
 SPDX-License-Identifier: GPL-2.0-only
  Qualcomm ADSPSLPI Peripheral Image Loader for MSM8974 and MSM8996
  Copyright (C) 2016 Linaro Ltd
  Copyright (C) 2014 Sony Mobile Communications AB
  Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
 Handle single power domain 
 Handle single power domain 
 SPDX-License-Identifier: GPL-2.0-only
  Remote processor messaging transport (OMAP platform-specific bits)
  Copyright (C) 2011 Texas Instruments, Inc.
  Copyright (C) 2011 Google, Inc.
  Ohad Ben-Cohen <ohad@wizery.com>
  Brian Swetland <swetland@google.com>
 kick the remote processor, and let it know which virtqueue to poke at 
  rproc_vq_interrupt() - tell remoteproc that a virtqueue is interrupted
  @rproc: handle to the remote processor
  @notifyid: index of the signalled virtqueue (unique per this @rproc)
  This function should be called by the platform-specific rproc driver,
  when the remote processor signals that a specific virtqueue has pending
  messages available.
  Return: IRQ_NONE if no message was found in the @notifyid virtqueue,
  and otherwise returns IRQ_HANDLED.
 we're temporarily limited to two virtqueues per rvdev 
 Search allocated memory region by name 
 zero vring 
	
	  Create the new vq, and tell virtio we're not interested in
	  the 'weak' smp barriers, since we're talking with a real device.
 Update vring in resource table 
 provide the vdev features as retrieved from the firmware 
	
	  Packed ring isn't enabled on remoteproc for now,
	  because remoteproc uses vring_new_virtqueue() which
	  creates virtio rings on preallocated memory.
 Give virtio_ring a chance to accept features 
 Give virtio_rproc a chance to accept features. 
 Make sure we don't have any features > 32 bits! 
	
	  Remember the finalized features of our vdev, and provide it
	  to the remote processor once it is powered on.
  This function is called whenever vdev is released, and is responsible
  to decrement the remote processor's refcount which was taken when vdev was
  added.
  Never call this function directly; it will be called by the driver
  core when needed.
  rproc_add_virtio_dev() - register an rproc-induced virtio device
  @rvdev: the remote vdev
  @id: the device type identification (used to match it with a driver).
  This function registers a virtio device. This vdev's partent is
  the rproc device.
  Return: 0 on success or an appropriate error value otherwise
 Try to find dedicated vdev buffer carveout 
 Associate reserved memory to vdev device 
 Use dma address as carveout no memmapped yet 
 Associate vdev buffer memory pool to vdev subdev 
		
		  If we don't have dedicated buffer, just attempt to re-assign
		  the reserved memory from our parent. A default memory-region
		  at index 0 from the parent's memory-regions is assigned for
		  the rvdev dev to allocate from. Failure is non-critical and
		  the allocations will fall back to global pools, so don't
		  check return value either.
 Allocate virtio device 
	
	  We're indirectly making a non-temporary copy of the rproc pointer
	  here, because drivers probed with this vdev will indirectly
	  access the wrapping rproc.
	 
	  Therefore we must increment the rproc refcount here, and decrement
	  it _only_ when the vdev is released.
 Reference the vdev and vring allocations 
  rproc_remove_virtio_dev() - remove an rproc-induced virtio device
  @dev: the virtio device
  @data: must be null
  This function unregisters an existing virtio device.
  Return: 0
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2020 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
 Only bits [31:20] and [17:14] are usable, all other bits must be zero 
	
	  The SRAM content as seen by the ARC core always starts at 0x0
	  regardless of the value given here (this was discovered by trial and
	  error). For SoCs older than Meson6 we probably have to set
	  AO_REMAP_REG1_MOVE_AHB_SRAM_TO_0X0_INSTEAD_OF_DDR to achieve the
	  same. (At least) For Meson8 and newer that bit must not be set.
	
	  Convert from 0xd9000000 to 0xc9000000 as the vendor driver does.
	  This only seems to be relevant for the AO_CPU_CNTL register. It is
	  unknown why this is needed.
 The memory from the ARC core's perspective always starts at 0x0. 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  TI Keystone DSP remoteproc driver
  Copyright (C) 2015-2017 Texas Instruments Incorporated - http:www.ti.com
  struct keystone_rproc_mem - internal memory structure
  @cpu_addr: MPU virtual address of the memory region
  @bus_addr: Bus address used to access the memory region
  @dev_addr: Device address of the memory region from DSP view
  @size: Size of the memory region
  struct keystone_rproc - keystone remote processor driver structure
  @dev: cached device pointer
  @rproc: remoteproc device handle
  @mem: internal memory regions data
  @num_mems: number of internal memory regions
  @dev_ctrl: device control regmap handle
  @reset: reset control handle
  @boot_offset: boot register offset in @dev_ctrl regmap
  @irq_ring: irq entry for vring
  @irq_fault: irq entry for exception
  @kick_gpio: gpio used for virtio kicks
  @workqueue: workqueue for processing virtio interrupts
 Put the DSP processor into reset 
 Configure the boot address and boot the DSP processor 
  Process the remoteproc exceptions
  The exception reporting on Keystone DSP remote processors is very simple
  compared to the equivalent processors on the OMAP family, it is notified
  through a software-designed specific interrupt source in the IPC interrupt
  generation register.
  This function just invokes the rproc_report_crash to report the exception
  to the remoteproc driver core, to trigger a recovery.
  Main virtqueue message workqueue function
  This function is executed upon scheduling of the keystone remoteproc
  driver's workqueue. The workqueue is scheduled by the vring ISR handler.
  There is no payload message indicating the virtqueue index as is the
  case with mailbox-based implementations on OMAP family. As such, this
  handler processes both the Tx and Rx virtqueue indices on every invocation.
  The rproc_vq_interrupt function can detect if there are new unprocessed
  messages or not (returns IRQ_NONE vs IRQ_HANDLED), but there is no need
  to check for these return values. The index 0 triggering will process all
  pending Rx buffers, and the index 1 triggering will process all newly
  available Tx buffers and will wakeup any potentially blocked senders.
  NOTE:
  1. A payload could be added by using some of the source bits in the
     IPC interrupt generation registers, but this would need additional
     changes to the overall IPC stack, and currently there are no benefits
     of adapting that approach.
  2. The current logic is based on an inherent design assumption of supporting
     only 2 vrings, but this can be changed if needed.
  Interrupt handler for processing vring kicks from remote processor
  Power up the DSP remote processor.
  This function will be invoked only after the firmware for this rproc
  was loaded, parsed successfully, and all of its resource requirements
  were met.
  Stop the DSP remote processor.
  This function puts the DSP processor into reset, and finishes processing
  of any pending messages.
  Kick the remote processor to notify about pending unprocessed messages.
  The vqid usage is not used and is inconsequential, as the kick is performed
  through a simulated GPIO (a bit in an IPC interrupt-triggering register),
  the remote processor is expected to process both its Tx and Rx virtqueues.
  Custom function to translate a DSP device address (internal RAMs only) to a
  kernel virtual address.  The DSPs can access their RAMs at either an internal
  address visible only from a DSP, or at the SoC-level bus address. Both these
  addresses need to be looked through for translation. The translated addresses
  can be used either by the remoteproc core for loading (when using kernel
  remoteproc loader), or by any rpmsg bus drivers.
 handle DSP-view addresses 
 handle SoC-view addresses 
 zero out memories to start in a pristine state 
 construct a custom default fw name - subject to change in future 
 assuming a single digit alias 
 enable clock for accessing DSP internal memories 
 ensure the DSP is in reset before loading firmware 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0
  FPGA Manager Core
   Copyright (C) 2013-2015 Altera Corporation
   Copyright (C) 2017 Intel Corporation
  With code from the mailing list:
  Copyright (C) 2013 Xilinx, Inc.
  After all the FPGA image has been written, do the device specific steps to
  finish and set the FPGA into operating mode.
  fpga_image_info_alloc - Allocate an FPGA image info struct
  @dev: owning device
  Return: struct fpga_image_info or NULL
  fpga_image_info_free - Free an FPGA image info struct
  @info: FPGA image info struct to free
  Call the low level driver's write_init function.  This will do the
  device-specific things to get the FPGA into the state where it is ready to
  receive an FPGA image. The low level driver only gets to see the first
  initial_header_size bytes in the buffer.
	
	  First try to use miter to map the first fragment to access the
	  header, this is the typical path.
 Otherwise copy the fragments into temporary memory. 
  fpga_mgr_buf_load_sg - load fpga from image in buffer from a scatter list
  @mgr:	fpga manager
  @info:	fpga image specific information
  @sgt:	scatterlist table
  Step the low level fpga manager through the device-specific steps of getting
  an FPGA ready to be configured, writing the image to it, then doing whatever
  post-configuration steps necessary.  This code assumes the caller got the
  mgr pointer from of_fpga_mgr_get() or fpga_mgr_get() and checked that it is
  not an error code.
  This is the preferred entry point for FPGA programming, it does not require
  any contiguous kernel memory.
  Return: 0 on success, negative error code otherwise.
 Write the FPGA image to the FPGA. 
	
	  Write the FPGA image to the FPGA.
  fpga_mgr_buf_load - load fpga from image in buffer
  @mgr:	fpga manager
  @info:	fpga image info
  @buf:	buffer contain fpga image
  @count:	byte count of buf
  Step the low level fpga manager through the device-specific steps of getting
  an FPGA ready to be configured, writing the image to it, then doing whatever
  post-configuration steps necessary.  This code assumes the caller got the
  mgr pointer from of_fpga_mgr_get() and checked that it is not an error code.
  Return: 0 on success, negative error code otherwise.
	
	  This is just a fast path if the caller has already created a
	  contiguous kernel buffer and the driver doesn't require SG, non-SG
	  drivers will still work on the slow path.
	
	  Convert the linear kernel pointer into a sg_table of pages for use
	  by the driver.
	
	  The temporary pages list is used to code share the merging algorithm
	  in sg_alloc_table_from_pages
  fpga_mgr_firmware_load - request firmware and load to fpga
  @mgr:	fpga manager
  @info:	fpga image specific information
  @image_name:	name of image file on the firmware search path
  Request an FPGA image using the firmware class, then write out to the FPGA.
  Update the state before each step to provide info on what step failed if
  there is a failure.  This code assumes the caller got the mgr pointer
  from of_fpga_mgr_get() or fpga_mgr_get() and checked that it is not an error
  code.
  Return: 0 on success, negative error code otherwise.
  fpga_mgr_load - load FPGA from scattergather table, buffer, or firmware
  @mgr:	fpga manager
  @info:	fpga image information.
  Load the FPGA from an image which is indicated in @info.  If successful, the
  FPGA ends up in operating mode.
  Return: 0 on success, negative error code otherwise.
 requesting FPGA image from firmware 
 Preparing FPGA to receive image 
 Writing image to FPGA 
 Finishing configuration after image has been written 
 FPGA reports to be in normal operating mode 
  fpga_mgr_get - Given a device, get a reference to an fpga mgr.
  @dev:	parent device that fpga mgr was registered with
  Return: fpga manager struct or IS_ERR() condition containing error code.
  of_fpga_mgr_get - Given a device node, get a reference to an fpga mgr.
  @node:	device node
  Return: fpga manager struct or IS_ERR() condition containing error code.
  fpga_mgr_put - release a reference to an fpga manager
  @mgr:	fpga manager structure
  fpga_mgr_lock - Lock FPGA manager for exclusive use
  @mgr:	fpga manager
  Given a pointer to FPGA Manager (from fpga_mgr_get() or
  of_fpga_mgr_put()) attempt to get the mutex. The user should call
  fpga_mgr_lock() and verify that it returns 0 before attempting to
  program the FPGA.  Likewise, the user should call fpga_mgr_unlock
  when done programming the FPGA.
  Return: 0 for success or -EBUSY
  fpga_mgr_unlock - Unlock FPGA manager after done programming
  @mgr:	fpga manager
  fpga_mgr_create - create and initialize an FPGA manager struct
  @parent:	fpga manager device from pdev
  @name:	fpga manager name
  @mops:	pointer to structure of fpga manager ops
  @priv:	fpga manager private data
  The caller of this function is responsible for freeing the struct with
  fpga_mgr_free().  Using devm_fpga_mgr_create() instead is recommended.
  Return: pointer to struct fpga_manager or NULL
  fpga_mgr_free - free an FPGA manager created with fpga_mgr_create()
  @mgr:	fpga manager struct
  devm_fpga_mgr_create - create and initialize a managed FPGA manager struct
  @parent:	fpga manager device from pdev
  @name:	fpga manager name
  @mops:	pointer to structure of fpga manager ops
  @priv:	fpga manager private data
  This function is intended for use in an FPGA manager driver's probe function.
  After the manager driver creates the manager struct with
  devm_fpga_mgr_create(), it should register it with fpga_mgr_register().  The
  manager driver's remove function should call fpga_mgr_unregister().  The
  manager struct allocated with this function will be freed automatically on
  driver detach.  This includes the case of a probe function returning error
  before calling fpga_mgr_register(), the struct will still get cleaned up.
  Return: pointer to struct fpga_manager or NULL
  fpga_mgr_register - register an FPGA manager
  @mgr: fpga manager struct
  Return: 0 on success, negative error code otherwise.
	
	  Initialize framework state by requesting low level driver read state
	  from device.  FPGA may be in reset mode or may have been programmed
	  by bootloader or EEPROM.
  fpga_mgr_unregister - unregister an FPGA manager
  @mgr: fpga manager struct
  This function is intended for use in an FPGA manager driver's remove function.
	
	  If the low level driver provides a method for putting fpga into
	  a desired state upon unregister, do it.
  devm_fpga_mgr_register - resource managed variant of fpga_mgr_register()
  @dev: managing device for this FPGA manager
  @mgr: fpga manager struct
  This is the devres variant of fpga_mgr_register() for which the unregister
  function will be called automatically when the managing device is detached.
	
	  Make sure that the struct fpga_manager  that is passed in is
	  managed itself.
 SPDX-License-Identifier: GPL-2.0
  Driver for FPGA Management Engine (FME) Partial Reconfiguration
  Copyright (C) 2017-2018 Intel Corporation, Inc.
  Authors:
    Kang Luwei <luwei.kang@intel.com>
    Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Wu Hao <hao.wu@intel.com>
    Joseph Grecco <joe.grecco@intel.com>
    Enno Luebbers <enno.luebbers@intel.com>
    Tim Whisonant <tim.whisonant@intel.com>
    Ananda Ravuri <ananda.ravuri@intel.com>
    Christopher Rauer <christopher.rauer@intel.com>
    Henry Mitchel <henry.mitchel@intel.com>
 get fme header region 
 check port id 
	
	  align PR buffer per PR bandwidth, as HW ignores the extra padding
	  data automatically.
 prepare fpga_image_info for PR 
 fme device has been unregistered. 
	
	  it allows userspace to reset the PR region's logic by disabling and
	  reenabling the bridge to clear things out between acceleration runs.
	  so no need to hold the bridges after partial reconfiguration.
  dfl_fme_create_mgr - create fpga mgr platform device as child device
  @pdata: fme platform_device's pdata
  Return: mgr platform device if successful, and error code otherwise.
	
	  Each FME has only one fpga-mgr, so allocate platform device using
	  the same FME platform device id.
  dfl_fme_destroy_mgr - destroy fpga mgr platform device
  @pdata: fme platform device's pdata
  dfl_fme_create_bridge - create fme fpga bridge platform device as child
  @pdata: fme platform device's pdata
  @port_id: port id for the bridge to be created.
  Return: bridge platform device if successful, and error code otherwise.
  dfl_fme_destroy_bridge - destroy fpga bridge platform device
  @fme_br: fme bridge to destroy
  dfl_fme_destroy_bridge - destroy all fpga bridge platform device
  @pdata: fme platform device's pdata
  dfl_fme_create_region - create fpga region platform device as child
  @pdata: fme platform device's pdata
  @mgr: mgr platform device needed for region
  @br: br platform device needed for region
  @port_id: port id
  Return: fme region if successful, and error code otherwise.
	
	  Each FPGA device may have more than one port, so allocate platform
	  device using the same port platform device id.
  dfl_fme_destroy_region - destroy fme region
  @fme_region: fme region to destroy
  dfl_fme_destroy_regions - destroy all fme regions
  @pdata: fme platform device's pdata
 Initialize the region and bridge sub device list 
 Create fpga mgr platform device 
 Read capability register to check number of regions and bridges 
 Create bridge for each port 
 Create region for each port 
 SPDX-License-Identifier: GPL-2.0-only
  FPGA Manager Driver for Altera ArriaCycloneStratix CvP
  Copyright (C) 2017 DENX Software Engineering
  Anatolij Gustschin <agust@denx.de>
  Manage Altera FPGA firmware using PCIe CvP.
  Firmware must be in binary "rbf" format.
 BAR used for data transfer in memory mode 
 dummy writes to clear CvP state machine 
 CVP STATUS timeout for USERMODE polling 
 Vendor Specific Extended Capability Registers 
 16bit 
 32bit 
 CVP_CONFIG_READY 
 CVP_CONFIG_ERROR 
 ctrl block is enabling CVP 
 USERMODE 
 CVP_CONFIG_DONE 
 PLD_CLK_IN_USE 
 32bit 
 CVP (1) or normal mode (0) 
 PMA (1) or fabric clock (0) 
 NUMCLKS bits offset 
 32bit 
 32bit 
 32bit 
 CVP_CONFIG_ERROR_LATCHED 
 Vendor Specific Offset V1 
 V2 Defines 
 8bit 
 Write block sizes 
 Optional CvP config error status check for debugging 
 switches between CvP clock and internal clock 
 set 1 CVP clock cycle for every CVP Data Register Write 
 dummy data, could be any value 
 use small usleep value to re-check and break early 
 STEP 10 (optional) - check CVP_CONFIG_ERROR flag 
  CvP Version2 Functions
  Recent Intel FPGAs use a credit mechanism to throttle incoming
  bitstreams and a different method of clearing the state.
 Clear the START_XFER and CVP_CONFIG bits 
 Return if there is space in FIFO 
 Limit the check credit byte traffic 
 write up to 3 trailing bytes, if any 
 STEP 12 - reset START_XFER bit 
 STEP 13 - reset CVP_CONFIG bit 
	
	  STEP 14
	  - set CVP_NUMCLKS to 1 and then issue CVP_DUMMY_WR dummy
	    writes to the HIP
 STEP 15 - poll CVP_CONFIG_READY bit for 0 with 10us timeout 
 Determine allowed clock to data ratio 
 ratio for all compressed images 
 for uncompressed and encrypted images 
 for uncompressed and unencrypted images 
 STEP 1 - read CVP status and check CVP_EN flag 
	
	  STEP 2
	  - set HIP_CLK_SEL and CVP_MODE (must be set in the order mentioned)
 switch from fabric to PMA clock 
 set CVP mode 
	
	  STEP 3
	  - set CVP_NUMCLKS to 1 and issue CVP_DUMMY_WR dummy writes to the HIP
 STEP 4 - set CVP_CONFIG bit 
 request control block to begin transfer using CVP 
 STEP 5 - poll CVP_CONFIG READY for 1 with timeout 
	
	  STEP 6
	  - set CVP_NUMCLKS to 1 and issue CVP_DUMMY_WR dummy writes to the HIP
 STEP 7 - set START_XFER 
 STEP 8 - start transfer (set CVP_NUMCLKS for bitstream) 
 STEP 9 - write 32-bit data from RBF file to CVP data register 
 Use credit throttling if available 
		
		  STEP 10 (optional) and STEP 11
		  - check error flag
		  - loop until data transfer completed
		  Config images can be huge (more than 40 MiB), so
		  only check after a new 4k data block has been written.
		  This reduces the number of checks and speeds up the
		  configuration process.
 STEP 16 - check CVP_CONFIG_ERROR_LATCHED bit 
 STEP 17 - reset CVP_MODE and HIP_CLK_SEL bit 
 STEP 18 - poll PLD_CLK_IN_USE and USER_MODE bits 
 Discover the Vendor Specific Offset for this device 
	
	  First check if this is the expected FPGA device. PCI config
	  space access works without enabling the PCI device, memory
	  space access is enabled further down.
	
	  Enable memory BAR access. We cannot use pci_enable_device() here
	  because it will make the driver unusable with FPGA devices that
	  have additional big IOMEM resources (e.g. 4GiB BARs) on 32-bit
	  platform. Such BARs will not have an assigned address range and
	  pci_enable_device() will fail, complaining about not claimed BAR,
	  even if the concerned BAR is not needed for FPGA configuration
	  at all. Thus, enable the device via PCI config space command.
 SPDX-License-Identifier: GPL-2.0-only
  Altera Passive Serial SPI Driver
   Copyright (c) 2017 United Western Technologies, Corporation
   Joshua Clayton <stillcompiling@gmail.com>
  Manage Altera FPGA firmware that is loaded over SPI using the passive
  serial configuration method.
  Firmware must be in binary "rbf" format.
  Works on Arria 10, Cyclone V and Stratix V. Should work on Cyclone series.
  May work on other Altera FPGAs.
          |   Arria 10  |   Cyclone5  |   Stratix5  |
  t_CF2ST0 |     [; 600] |     [; 600] |     [; 600] |ns
  t_CFG    |        [2;] |        [2;] |        [2;] |µs
  t_STATUS | [268; 3000] | [268; 1506] | [268; 1506] |µs
  t_CF2ST1 |    [; 3000] |    [; 1506] |    [; 1506] |µs
  t_CF2CK  |     [3010;] |     [1506;] |     [1506;] |µs
  t_ST2CK  |       [10;] |        [2;] |        [2;] |µs
  t_CD2UM  |  [175; 830] |  [175; 437] |  [175; 437] |µs
 these values for Cyclone5 are compatible with Stratix5 
 min(t_STATUS) 
 max(t_CF2ST1) 
 max { min(t_CFG), max(tCF2ST0) } 
 min(t_ST2CK) 
 Array index is enum altera_ps_devtype 
 wait min reset pulse time 
 wait for max { max(t_STATUS), max(t_CF2ST1) } 
 wait for min(t_ST2CK)
 set buffer to lsb first 
	
	  After CONF_DONE goes high, send two additional falling edges on DCLK
	  to begin initialization and enter user mode
 someone added a altera_ps_devtype without adding to the map array 
 Register manager with unique name 
 SPDX-License-Identifier: GPL-2.0
  FPGA Manager Driver for FPGA Management Engine (FME)
  Copyright (C) 2017-2018 Intel Corporation, Inc.
  Authors:
    Kang Luwei <luwei.kang@intel.com>
    Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Wu Hao <hao.wu@intel.com>
    Joseph Grecco <joe.grecco@intel.com>
    Enno Luebbers <enno.luebbers@intel.com>
    Tim Whisonant <tim.whisonant@intel.com>
    Ananda Ravuri <ananda.ravuri@intel.com>
    Christopher Rauer <christopher.rauer@intel.com>
    Henry Mitchel <henry.mitchel@intel.com>
 FME Partial Reconfiguration Sub Feature Register Set 
 FME PR Control Register Bitfield 
 Reset PR engine 
 Ack for PR engine reset 
 PR Region ID 
 Start to request PR service 
 PR data push completion 
 FME PR Status Register Bitfield 
 Number of available entries in HW queue inside the PR engine. 
 PR operation status 
 Controller status 
 PR host status 
 FME PR Data Register Bitfield 
 PR data from the raw-binary file. 
 FME PR Error Register 
 PR Operation errors detected. 
 CRC error detected. 
 Incompatible PR bitstream detected. 
 PR data push protocol violated. 
 PR data fifo overflow error detected 
	
	  driver can push data to PR hardware using PR_DATA register once HW
	  has enough pr_credit (> 1), pr_credit reduces one for every 32bit
	  pr data write to PR_DATA register. If pr_credit <= 1, driver needs
	  to wait for enough pr_credit from hardware by polling.
 SPDX-License-Identifier: GPL-2.0
  Driver for FPGA Device Feature List (DFL) Support
  Copyright (C) 2017-2018 Intel Corporation, Inc.
  Authors:
    Kang Luwei <luwei.kang@intel.com>
    Zhang Yi <yi.z.zhang@intel.com>
    Wu Hao <hao.wu@intel.com>
    Xiao Guangrong <guangrong.xiao@linux.intel.com>
  when adding a new feature dev support in DFL framework, it's required to
  add a new item in enum dfl_id_type and provide related information in below
  dfl_devs table which is indexed by dfl_id_type, e.g. name string used for
  platform device creation (define name strings in dfl.h, as they could be
  reused by platform device drivers).
  if the new feature dev needs chardev support, then it's required to add
  a new item in dfl_chardevs table and configure dfl_devs[i].devt_type as
  index to dfl_chardevs table. If no chardev support just set devt_type
  as one invalid index (DFL_FPGA_DEVT_MAX).
  dfl_dev_info - dfl feature device information.
  @name: name string of the feature platform device.
  @dfh_id: id value in Device Feature Header (DFH) register by DFL spec.
  @id: idr id of the feature dev.
  @devt_type: index to dfl_chrdevs[].
 it is indexed by dfl_id_type 
  dfl_chardev_info - chardev information of dfl feature device
  @name: nmae string of the char device.
  @devt: devt of the char device.
 indexed by enum dfl_fpga_devt_type 
  introduce a global port_ops list, it allows port drivers to register ops
  in such list, then other feature devices (e.g. FME), could use the port
  functions even related port platform device is hidden. Below is one example,
  in virtualization case of PCIe-based FPGA DFL device, when SRIOV is
  enabled, port (and it's AFU) is turned into VF and port platform device
  is hidden from system but it's still required to access port to finish FPGA
  reconfiguration function in FME.
  dfl_fpga_port_ops_get - get matched port ops from the global list
  @pdev: platform device to match with associated port ops.
  Return: matched port ops on success, NULL otherwise.
  Please note that must dfl_fpga_port_ops_put after use the port_ops.
 match port_ops using the name of platform device 
  dfl_fpga_port_ops_put - put port ops
  @ops: port ops.
  dfl_fpga_port_ops_add - add port_ops to global list
  @ops: port ops to add.
  dfl_fpga_port_ops_del - remove port_ops from global list
  @ops: port ops to del.
  dfl_fpga_check_port_id - check the port id
  @pdev: port platform device.
  @pport_id: port id to compare.
  Return: 1 if port device matches with given port id, otherwise 0.
 freeing resources by put_device() after device_initialize() 
 add mmio resource 
 then add irq resource 
 calls release_dfl_dev() which does the clean up  
  dfl_fpga_dev_feature_uinit - uinit for sub features of dfl feature device
  @pdev: feature device.
  dfl_fpga_dev_feature_init - init for sub features of dfl feature device
  @pdev: feature device.
  @feature_drvs: drvs for sub features.
  This function will match sub features with given feature drvs list and
  use matched drv to init related sub feature.
  Return: 0 on success, negative error code otherwise.
  dfl_fpga_dev_ops_register - register cdev ops for feature dev
  @pdev: feature dev.
  @fops: file operations for feature dev's cdev.
  @owner: owning moduledriver.
  Return: 0 on success, negative error code otherwise.
	
	  set parent to the feature device so that its refcount is
	  decreased after the last refcount of cdev is gone, that
	  makes sure the feature device is valid during device
	  file's life-cycle.
  dfl_fpga_dev_ops_unregister - unregister cdev ops for feature dev
  @pdev: feature dev.
  struct build_feature_devs_info - info collected during feature dev build.
  @dev: device to enumerate.
  @cdev: the container device for all feature devices.
  @nr_irqs: number of irqs for all feature devices.
  @irq_table: Linux IRQ numbers for all irqs, indexed by local irq index of
 	       this device.
  @feature_dev: current feature device.
  @ioaddr: header register region address of current FIU in enumeration.
  @start: register resource start of current FIU.
  @len: max register resource length of current FIU.
  @sub_features: a sub features linked list for feature device in enumeration.
  @feature_num: number of sub features for feature device in enumeration.
  struct dfl_feature_info - sub feature info collected during feature dev build
  @fid: id of this sub feature.
  @mmio_res: mmio resource of this sub feature.
  @ioaddr: mapped base address of mmio resource.
  @node: node in sub_features linked list.
  @irq_base: start of irq index in this sub feature.
  @nr_irqs: number of irqs of this sub feature.
  register current feature device, it is called when we need to switch to
  another feature parsing or we have parsed all features on given device
  feature list.
	
	  we do not need to care for the memory which is associated with
	  the platform device. After calling platform_device_unregister(),
	  it will be automatically freed by device's release() callback,
	  platform_device_release().
	
	  the count should be initialized to 0 to make sure
	 __fpga_port_enable() following __fpga_port_disable()
	  works properly for port device.
	  and it should always be 0 for fme device.
 each sub feature has one MMIO resource 
 fill features and resource information for feature dev 
 save resource information for each feature 
		
		  the FIU header feature has some fundamental functions (sriov
		  set, port enabledisable) needed for the dfl bus device and
		  other sub features. So its mmio resource should be mapped by
		  DFL bus device. And we should not assign it to feature
		  devices (dfl-fmeafu) again.
		
		  reset it to avoid build_info_free() freeing their resource.
		 
		  The resource of successfully registered feature devices
		  will be freed by platform_device_unregister(). See the
		  comments in build_info_create_dev().
	
	  we use -ENODEV as the initialization indicator which indicates
	  whether the id need to be reclaimed
	
	  it is a valid id, free it. See comments in
	  build_info_create_dev()
 workaround for private features with invalid size, use 4K instead 
	
	  Ideally DFL framework should only read info from DFL header, but
	  current version DFL only provides mmio resources information for
	  each feature in DFL Header, no field for interrupt resources.
	  Interrupt resource information is provided by specific mmio
	  registers of each private feature which supports interrupt. So in
	  order to parse and assign irq resources, DFL framework has to look
	  into specific capability registers of these private features.
	 
	  Once future DFL version supports generic interrupt resource
	  information in common DFL headers, the generic interrupt parsing
	  code will be added. But in order to be compatible to old version
	  DFL, the driver may still fall back to these quirks.
  when create sub feature instances, for private features, it doesn't need
  to provide resource size and feature id as they could be read from DFH
  register. For afu sub feature, its register region only contains user
  defined registers, so never trust any information from it, just use the
  resource size information provided by its parent FIU.
 read feature size and id if inputs are invalid 
 create platform device for dfl feature dev 
	
	  find and parse FIU's child AFU via its NEXT_AFU register.
	  please note that only Port has valid NEXT_AFU pointer per spec.
  parse_feature - parse a feature on given device feature list
  @binfo: build feature devices information.
  @ofst: offset to current FIU header
 walk through the device feature list via DFH's next DFH pointer. 
 stop parsing if EOL(End of List) is set or offset is 0 
 commit current feature device when reach the end of list 
 remove all device feature lists in the list. 
 remove irq table 
  dfl_fpga_enum_info_add_dfl - add info of a device feature list to enum info
  @info: ptr to dfl_fpga_enum_info
  @start: mmio resource address of the device feature list.
  @len: mmio resource length of the device feature list.
  One FPGA device may have one or more Device Feature Lists (DFLs), use this
  function to add information of each DFL to common data structure for next
  step enumeration.
  Return: 0 on success, negative error code otherwise.
  dfl_fpga_enum_info_add_irq - add irq table to enum info
  @info: ptr to dfl_fpga_enum_info
  @nr_irqs: number of irqs of the DFL fpga device to be enumerated.
  @irq_table: Linux IRQ numbers for all irqs, indexed by local irq index of
 	       this device.
  One FPGA device may have several interrupts. This function adds irq
  information of the DFL fpga device to enum info for next step enumeration.
  This function should be called before dfl_fpga_feature_devs_enumerate().
  As we only support one irq domain for all DFLs in the same enum info, adding
  irq table a second time for the same enum info will return error.
  If we need to enumerate DFLs which belong to different irq domains, we
  should fill more enum info and enumerate them one by one.
  Return: 0 on success, negative error code otherwise.
  dfl_fpga_feature_devs_enumerate - enumerate feature devices
  @info: information for enumeration.
  This function creates a container device (base FPGA region), enumerates
  feature devices based on the enumeration info and creates platform devices
  under the container device.
  Return: dfl_fpga_cdev struct on success, -errno on failure
 create and init build info for enumeration 
	
	  start enumeration for all feature devices based on Device Feature
	  Lists.
  dfl_fpga_feature_devs_remove - remove all feature devices
  @cdev: fpga container device.
  Remove the container device and all feature devices under given container
  devices.
 remove released ports 
  __dfl_fpga_cdev_find_port - find a port under given container device
  @cdev: container device
  @data: data passed to match function
  @match: match function used to find specific port from the port device list
  Find a port device under container device. This function needs to be
  invoked with lock held.
  Return: pointer to port's platform device if successful, NULL otherwise.
  NOTE: you will need to drop the device reference with put_device() after use.
  dfl_fpga_cdev_release_port - release a port platform device
  @cdev: parent container device.
  @port_id: id of the port platform device.
  This function allows user to release a port platform device. This is a
  mandatory step before turn a port from PF into VF for SRIOV support.
  Return: 0 on success, negative error code otherwise.
  dfl_fpga_cdev_assign_port - assign a port platform device back
  @cdev: parent container device.
  @port_id: id of the port platform device.
  This function allows user to assign a port platform device back. This is
  a mandatory step after disable SRIOV support.
  Return: 0 on success, negative error code otherwise.
  dfl_fpga_cdev_config_ports_pf - configure ports to PF access mode
  @cdev: parent container device.
  This function is needed in sriov configuration routine. It could be used to
  configure the all released ports from VF access mode to PF.
  dfl_fpga_cdev_config_ports_vf - configure ports to VF access mode
  @cdev: parent container device.
  @num_vfs: VF device number.
  This function is needed in sriov configuration routine. It could be used to
  configure the released ports from PF access mode to VF.
  Return: 0 on success, negative error code otherwise.
	
	  can't turn multiple ports into 1 VF device, only 1 port for 1 VF
	  device, so if released port number doesn't match VF device number,
	  then reject the request with -EINVAL error code.
  dfl_fpga_set_irq_triggers - set eventfd triggers for dfl feature interrupts
  @feature: dfl sub feature.
  @start: start of irq index in this dfl sub feature.
  @count: number of irqs.
  @fds: eventfds to bind with irqs. unbind related irq if fds[n] is negative.
 	 unbind "count" specified number of irqs if fds ptr is NULL.
  Bind given eventfds with irqs in this dfl sub feature. Unbind related irq if
  fds[n] is negative. Unbind "count" specified number of irqs if fds ptr is
  NULL.
  Return: 0 on success, negative error code otherwise.
 overflow 
 exceeds nr_irqs 
  dfl_feature_ioctl_get_num_irqs - dfl feature _GET_IRQ_NUM ioctl interface.
  @pdev: the feature device which has the sub feature
  @feature: the dfl sub feature
  @arg: ioctl argument
  Return: 0 on success, negative error code otherwise.
  dfl_feature_ioctl_set_irq - dfl feature _SET_IRQ ioctl interface.
  @pdev: the feature device which has the sub feature
  @feature: the dfl sub feature
  @arg: ioctl argument
  Return: 0 on success, negative error code otherwise.
 SPDX-License-Identifier: GPL-2.0
  Lattice MachXO2 Slave SPI Driver
  Manage Lattice FPGA firmware that is loaded over SPI using
  the slave serial configuration interface.
  Copyright (C) 2018 Paolo Pisati <p.pisati@gmail.com>
 MachXO2 Programming Guide - sysCONFIG Programming Commands 
  Max CCLK in Slave SPI mode according to 'MachXO2 Family Data
  Sheet' sysCONFIG Port Timing Specifications (3-36)
 Status register bits, errors and error mask 
 no error 
 preamble error 
 abort error 
 overflow error 
 SDM EOF 
 check refresh status 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2011-2015 Xilinx Inc.
  Copyright (c) 2015, National Instruments Corp.
  FPGA Manager Driver for Xilinx Zynq, heavily based on xdevcfg driver
  in their vendor tree.
 Offsets into SLCR regmap 
 FPGA Software Reset Control 
 Level Shifters Enable 
 Constant Definitions 
 Control Register 
 Lock Register 
 Interrupt Status Register 
 Interrupt Mask Register 
 Status Register 
 DMA Source Address Register 
 DMA Destination Address Reg 
 DMA Source Transfer Length 
 DMA Destination Transfer 
 Unlock Register 
 Misc. Control Register 
 Control Register Bit definitions 
 Signal to reset FPGA 
 Enable PCAP for PR 
 Enable PCAP 
 Lower rate to allow decrypt on the fly 
 System booted in secure mode 
 Miscellaneous Control Register bit definitions 
 Internal PCAP loopback 
 Status register bit definitions 
 FPGA init status 
 Interrupt StatusMask Register Bit definitions 
 DMA command done 
 DMA and PCAP cmd done 
 FPGA programmed 
 Miscellaneous constant values 
 Invalid DMA addr 
 Used to unlock the dev 
 Timeout for polling reset bits 
 Delay for polling reset bits 
 Signal this is the last DMA transfer, wait for the AXI and PCAP before
  interrupting
 Timeout for DMA completion 
 Masks for controlling stuff in SLCR 
 Disable all Level shifters 
 Enable Level shifters from PS to PL 
 Enable Level shifters from PL to PS 
 Enable global resets 
 Disable global resets 
 Cause the specified irq mask bits to generate IRQs 
 Must be called with dma_lock held 
 Feed the DMA queue until it is full. 
			 The last transfer waits for the PCAP to finish too,
			  notice this also changes the irq_mask to ignore
			  IXR_DMA_DONE_MASK which ensures we do not trigger
			  the completion too early.
	 Once the first transfer is queued we can turn on the ISR, future
	  calls to zynq_step_dma will happen from the ISR context. The
	  dma_lock spinlock guarantees this handover is done coherently, the
	  ISR enable is put at the end to avoid another CPU spinning in the
	  ISR on this lock.
		 The last transfer changes to DMA & PCAP mode since we do
		  not want to continue until everything has been flushed into
		  the PCAP.
	 If anything other than DMA completion is reported stop and hand
	  control back to zynq_fpga_ops_write, something went wrong,
	  otherwise progress the DMA.
 Sanity check the proposed bitstream. It must start with the sync word in
  the correct byte order, and be dword aligned. The input is a Xilinx .bin
  file with every 32 bit quantity swapped.
 check if bitstream is encrypted & and system's still secure 
 don't globally reset PL if we're doing partial reconfig 
 assert AXI interface resets 
 disable all level shifters 
 enable level shifters from PS to PL 
		 create a rising edge on PCFG_INIT. PCFG_INIT follows
		  PCFG_PROG_B, so we need to poll it after setting PCFG_PROG_B
		  to make sure the rising edge actually happens.
		  Note: PCFG_PROG_B is low active, sequence as described in
		  UG585 v1.10 page 211
	 set configuration register with following options:
	  - enable PCAP interface
	  - set throughput for maximum speed (if bistream not encrypted)
	  - set CPU in user mode
 We expect that the command queue is empty right now. 
 ensure internal PCAP loopback is disabled 
	 The hardware can only DMA multiples of 4 bytes, and it requires the
	  starting addresses to be aligned to 64 bits (UG585 pg 212).
 enable clock 
 zynq_step_dma will turn on interrupts 
	 There doesn't seem to be a way to force cancel any DMA, so if
	  something went wrong we are relying on the hardware to have halted
	  the DMA before we get here, if there was we could use
	  wait_for_completion_interruptible too.
 Release 'PR' control back to the ICAP 
 for the partial reconfig case we didn't touch the level shifters 
 enable level shifters from PL to PS 
 deassert AXI interface resets 
 unlock the device 
 SPDX-License-Identifier: GPL-2.0
  Driver for FPGA Accelerated Function Unit (AFU)
  Copyright (C) 2017-2018 Intel Corporation, Inc.
  Authors:
    Wu Hao <hao.wu@intel.com>
    Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Joseph Grecco <joe.grecco@intel.com>
    Enno Luebbers <enno.luebbers@intel.com>
    Tim Whisonant <tim.whisonant@intel.com>
    Ananda Ravuri <ananda.ravuri@intel.com>
    Henry Mitchel <henry.mitchel@intel.com>
 us 
 us 
  __afu_port_enable - enable a port by clear reset
  @pdev: port platform device.
  Enable Port by clear the port soft reset bit, which is set by default.
  The AFU is unable to respond to any MMIO access while in reset.
  __afu_port_enable function should only be used after __afu_port_disable
  function.
  The caller needs to hold lock for protection.
 Clear port soft reset 
	
	  HW clears the ack bit to indicate that the port is fully out
	  of reset.
  __afu_port_disable - disable a port by hold reset
  @pdev: port platform device.
  Disable Port by setting the port soft reset bit, it puts the port into reset.
  The caller needs to hold lock for protection.
 Set port soft reset 
	
	  HW sets ack bit to 1 when all outstanding requests have been drained
	  on this port and minimum soft reset pulse width has elapsed.
	  Driver polls port_soft_reset_ack to determine if reset done by HW.
  This function resets the FPGA Port and its accelerator (AFU) by function
  __port_disable and __port_enable (set port soft reset bit and then clear
  it). Userspace can do Port reset at any time, e.g. during DMA or Partial
  Reconfiguration. But it should never cause any system level issue, only
  functional failure (e.g. DMA or PR operation failure) and be recoverable
  from the failure.
  Note: the accelerator (AFU) is not accessible when its port is in reset
  (disabled). Any attempts on MMIO access to AFU while in reset, will
  result errors reported via port error reporting sub feature (if present).
		
		  userclk sysfs interfaces are only visible in case port
		  revision is 0, as hardware with revision >0 doesn't
		  support this.
	
	  sysfs entries are visible only if related private feature is
	  enumerated.
 No extension support for now 
		
		  Let sub-feature's ioctl function to handle the cmd
		  Sub-feature's ioctl returns -ENODEV when cmd is not
		  handled in this sub feature, and returns 0 and other
		  error code if cmd is handled.
 Support debug access to the mapping 
 SPDX-License-Identifier: GPL-2.0
  FPGA tofrom HPS Bridge Driver for Altera SoCFPGA Devices
   Copyright (C) 2013-2016 Altera Corporation, All Rights Reserved.
  Includes this patch from the mailing list:
    fpga: altera-hps2fpga: fix HPS2FPGA bridge visibility to L3 masters
    Signed-off-by: Anatolij Gustschin <agust@denx.de>
  This driver manages bridges on a Altera SOCFPGA between the ARM host
  processor system (HPS) and the embedded FPGA.
  This driver supports enabling and disabling of the configured ports, which
  allows for safe reprogramming of the FPGA, assuming that the new FPGA image
  uses the same port configuration.  Bridges must be disabled before
  reprogramming the FPGA and re-enabled after the FPGA has been programmed.
 The L3 REMAP register is write only, so keep a cached value. 
 bring bridge out of reset 
 Allow bridge to be visible to L3 masters or not 
 SPDX-License-Identifier: GPL-2.0
  FPGA Region - Support for FPGA programming under Linux
   Copyright (C) 2013-2016 Altera Corporation
   Copyright (C) 2017 Intel Corporation
  fpga_region_get - get an exclusive reference to an fpga region
  @region: FPGA Region struct
  Caller should call fpga_region_put() when done with region.
  Return fpga_region struct if successful.
  Return -EBUSY if someone already has a reference to the region.
  Return -ENODEV if @np is not an FPGA Region.
  fpga_region_put - release a reference to a region
  @region: FPGA region
  fpga_region_program_fpga - program FPGA
  @region: FPGA region
  Program an FPGA using fpga image info (region->info).
  If the region has a get_bridges function, the exclusive reference for the
  bridges will be held if programming succeeds.  This is intended to prevent
  reprogramming the region until the caller considers it safe to do so.
  The caller will need to call fpga_bridges_put() before attempting to
  reprogram the region.
  Return 0 for success or negative error code.
	
	  In some cases, we already have a list of bridges in the
	  fpga region struct.  Or we don't have any bridges.
  fpga_region_create - alloc and init a struct fpga_region
  @parent: device parent
  @mgr: manager that programs this region
  @get_bridges: optional function to get bridges to a list
  The caller of this function is responsible for freeing the resulting region
  struct with fpga_region_free().  Using devm_fpga_region_create() instead is
  recommended.
  Return: struct fpga_region or NULL
  fpga_region_free - free an FPGA region created by fpga_region_create()
  @region: FPGA region
  devm_fpga_region_create - create and initialize a managed FPGA region struct
  @parent: device parent
  @mgr: manager that programs this region
  @get_bridges: optional function to get bridges to a list
  This function is intended for use in an FPGA region driver's probe function.
  After the region driver creates the region struct with
  devm_fpga_region_create(), it should register it with fpga_region_register().
  The region driver's remove function should call fpga_region_unregister().
  The region struct allocated with this function will be freed automatically on
  driver detach.  This includes the case of a probe function returning error
  before calling fpga_region_register(), the struct will still get cleaned up.
  Return: struct fpga_region or NULL
  fpga_region_register - register an FPGA region
  @region: FPGA region
  Return: 0 or -errno
  fpga_region_unregister - unregister an FPGA region
  @region: FPGA region
  This function is intended for use in an FPGA region driver's remove function.
  fpga_region_init - init function for fpga_region class
  Creates the fpga_region class and registers a reconfig notifier.
 SPDX-License-Identifier: GPL-2.0
  FPGA to SDRAM Bridge Driver for Altera SoCFPGA Devices
   Copyright (C) 2013-2016 Altera Corporation, All Rights Reserved.
  This driver manages a bridge between an FPGA and the SDRAM used by the ARM
  host processor system (HPS).
  The bridge contains 4 read ports, 4 write ports, and 6 command ports.
  Reconfiguring these ports requires that no SDRAM transactions occur during
  reconfiguration.  The code reconfiguring the ports cannot run out of SDRAM
  nor can the FPGA access the SDRAM during reconfiguration.  This driver does
  not support reconfiguring the ports.  The ports are configured by code
  running out of on chip ram before Linux is started and the configuration
  is passed in a handoff register in the system manager.
  This driver supports enabling and disabling of the configured ports, which
  allows for safe reprogramming of the FPGA, assuming that the new FPGA image
  uses the same port configuration.  Bridges must be disabled before
  reprogramming the FPGA and re-enabled after the FPGA has been programmed.
  From the Cyclone V HPS Memory Map document:
    These registers are used to store handoff information between the
    preloader and the OS. These 8 registers can be used to store any
    information. The contents of these registers have no impact on
    the state of the HPS hardware.
 Get f2s bridge configuration saved in handoff register 
 SPDX-License-Identifier: GPL-2.0
  Driver for FPGA Accelerated Function Unit (AFU) Error Reporting
  Copyright 2019 Intel Corporation, Inc.
  Authors:
    Wu Hao <hao.wu@linux.intel.com>
    Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Joseph Grecco <joe.grecco@intel.com>
    Enno Luebbers <enno.luebbers@intel.com>
    Tim Whisonant <tim.whisonant@intel.com>
    Ananda Ravuri <ananda.ravuri@intel.com>
    Mitchel Henry <henry.mitchel@intel.com>
 mask or unmask port errors by the error mask register. 
 clear port errors. 
	
	  clear Port Errors
	 
	  - Check for AP6 State
	  - Halt Port by keeping Port in reset
	  - Set PORT Error mask to all 1 to mask errors
	  - Clear all errors
	  - Set Port mask to all 0 to enable errors
	  - All errors start capturing new errors
	  - Enable Port by pulling the port out of reset
 if device is still in AP6 power state, can not clear any error. 
 Halt Port by keeping Port in reset 
 Mask all errors 
 Clear errors if err input matches with current port errors.
 Clear mask 
 Enable the Port by clearing the reset 
	
	  sysfs entries are visible only if related private feature is
	  enumerated.
 SPDX-License-Identifier: GPL-2.0
  FPGA Bridge Driver for FPGA Management Engine (FME)
  Copyright (C) 2017-2018 Intel Corporation, Inc.
  Authors:
    Wu Hao <hao.wu@intel.com>
    Joseph Grecco <joe.grecco@intel.com>
    Enno Luebbers <enno.luebbers@intel.com>
    Tim Whisonant <tim.whisonant@intel.com>
    Ananda Ravuri <ananda.ravuri@intel.com>
    Henry Mitchel <henry.mitchel@intel.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019-2021 Xilinx, Inc.
 SPDX-License-Identifier: GPL-2.0
  FPGA Manager Driver for Altera SOCFPGA
   Copyright (C) 2013-2015 Altera Corporation
 Register offsets 
 Register bit defines 
 SOCFPGA_FPGMGR_STAT register mode field values 
ramping
 This is a flag value that doesn't really happen in this register field 
 SOCFPGA_FPGMGR_CTL register 
 SOCFPGA_FPGMGR_DCLKSTAT register 
 SOCFPGA_FPGMGR_GPIO_ registers share the same bit positions 
 In power-up order. Reverse for power-down. 
 Values to set in the CTRL register 
 flag that this table entry is a valid mode 
 For SOCFPGA_FPGMGR_STAT_MSEL field 
  Set the DCLKCNT, wait for DCLKSTAT to report the count completed, and clear
  the complete status.
 Clear any existing DONE status. 
 Issue the DCLK count. 
 Poll DCLKSTAT to see if it completed in the timeout period. 
	
	  HW doesn't support an interrupt for changes in state, so poll to see
	  if it matches the requested state within the timeout period.
 set irqs to level sensitive 
 set interrupt polarity 
 clear irqs 
 unmask interrupts 
 enable interrupts 
 clear irqs 
 success 
 disable irqs 
 Check that this MSEL setting is supported 
 get value from MSEL pins 
 Adjust CTRL for the CDRATIO 
 Set NCE to 0. 
	
	  Step 1:
	   - Set CTRL.CFGWDTH, CTRL.CDRATIO to match cfg mode
	   - Set CTRL.NCE to 0
 Step 2: Set CTRL.EN to 1 
 Step 3: Set CTRL.NCONFIGPULL to 1 to put FPGA in reset 
 Step 4: Wait for STATUS.MODE to report FPGA is in reset phase 
 Step 5: Set CONTROL.NCONFIGPULL to 0 to release FPGA from reset 
 Timeout waiting for reset 
  Prepare the FPGA to receive the configuration data.
 Steps 1 - 5: Reset the FPGA 
 Step 6: Wait for FPGA to enter configuration phase 
 Step 7: Clear nSTATUS interrupt 
 Step 8: Set CTRL.AXICFGEN to 1 to enable transfer of config data 
  Step 9: write data to the FPGA data register
 Write out the complete 32-bit chunks. 
 Write out remaining non 32-bit chunks. 
 This will never happen. 
	
	  Step 10:
	   - Observe CONF_DONE and nSTATUS (active low)
	   - if CONF_DONE = 1 and nSTATUS = 1, configuration was successful
	   - if CONF_DONE = 0 and nSTATUS = 0, configuration failed
 Step 11: Clear CTRL.AXICFGEN to disable transfer of config data 
	
	  Step 12:
	   - Write 4 to DCLKCNT
	   - Wait for STATUS.DCNTDONE = 1
	   - Clear W1C bit in STATUS.DCNTDONE
 Step 13: Wait for STATUS.MODE to report USER MODE 
 Step 14: Set CTRL.EN to 0 
 Translate state register values to FPGA framework state 
 SPDX-License-Identifier: GPL-2.0
  FPGA Manager Driver for Altera Arria10 SoCFPGA
  Copyright (C) 2015-2016 Altera Corporation
 FPGA CD Ratio Value 
 Configuration width 1632 bit 
  struct a10_fpga_priv - private data for fpga manager
  @regmap: regmap for register access
  @fpga_data_addr: iomap for single address data register to FPGA
  @clk: clock
  from the register map description of cdratio in imgcfg_ctrl_02:
   Normal Configuration    : 32bit Passive Parallel
   Partial Reconfiguration : 16bit Passive Parallel
 Clear any existing DONE status. 
 Issue the DCLK regmap. 
 wait till the dclkcnt done 
 Clear DONE status. 
 Is the bitstream encrypted? 
 Is the bitstream compressed? 
	
	  cd ratio is dependent on cfg width and whether the bitstream
	  is encrypted andor compressed.
	 
	  | width | encr. | compr. | cd ratio |
	  |  16   |   0   |   0    |     1    |
	  |  16   |   0   |   1    |     4    |
	  |  16   |   1   |   0    |     2    |
	  |  16   |   1   |   1    |     4    |
	  |  32   |   0   |   0    |     1    |
	  |  32   |   0   |   1    |     8    |
	  |  32   |   1   |   0    |     4    |
	  |  32   |   1   |   1    |     8    |
 If 32 bit, double the cd ratio by incrementing the field  
 Start the FPGA programming by initialize the FPGA Manager 
 Check for passive parallel (msel == 000 or 001) 
 Make sure no external devices are interfering 
 Set cfg width 
 Determine cd ratio from bitstream header and set cd ratio 
	
	  Clear s2f_nce to enable chip select.  Leave pr_request
	  unasserted and override disabled.
 Set cfg_ctrl to enable s2f dclk and data 
	
	  Disable overrides not needed for pr.
	  s2f_config==1 leaves reset deasseted.
 Enable override for data, dclk, nce, and pr_request to CSS 
 Send some clocks to clear out any errors 
 Assert pr_request 
 Provide 2048 DCLKs before starting the config data streaming. 
 Wait for pr_ready 
  write data to the FPGA data register
 Write out the complete 32-bit chunks 
 Write out remaining non 32-bit chunks 
 This will never happen 
 Wait for pr_done 
 Clear pr_request 
 Send some clocks to clear out any errors 
 Disable s2f dclk and data 
 Deassert chip select 
 Disable data, dclk, nce, and pr_request override to CSS 
 Return any errors regarding pr_done or pr_error 
 Final check 
 First mmio base is for register access 
 Second mmio base is for writing FPGA image data 
 regmap for register access 
 SPDX-License-Identifier: GPL-2.0-only
  Xilinx Spartan6 and 7 Series Slave Serial SPI Driver
  Copyright (C) 2017 DENX Software Engineering
  Anatolij Gustschin <agust@denx.de>
  Manage Xilinx FPGA firmware that is loaded over SPI using
  the slave serial configuration interface.
  wait_for_init_b - wait for the INIT_B pin to have a given state, or wait
  a given delay if the pin is unavailable
  @mgr:        The FPGA manager object
  @value:      Value INIT_B to wait for (1 = asserted = low)
  @alt_udelay: Delay to wait if the INIT_B GPIO is not available
  Returns 0 when the INIT_B GPIO reached the given state or -ETIMEDOUT if
  too much time passed waiting for that. If no INIT_B GPIO is available
  then always return 0.
 min is 500 ns 
 program latency 
	
	  This loop is carefully written such that if the driver is
	  scheduled out for more than 'timeout', we still check for DONE
	  before giving up and we apply 8 extra CCLK cycles in all cases.
 PROGRAM_B is active low 
 SPDX-License-Identifier: GPL-2.0
  Driver for Altera Partial Reconfiguration IP Core
  Copyright (C) 2016-2017 Intel Corporation
  Based on socfpga-a10.c Copyright (C) 2015-2016 Altera Corporation
   by Alan Tull <atull@opensource.altera.com>
 Write out the complete 32-bit chunks 
 Write out remaining non 32-bit chunks 
 This will never happen 
 SPDX-License-Identifier: GPL-2.0
  Driver for FPGA Management Engine Error Management
  Copyright 2019 Intel Corporation, Inc.
  Authors:
    Kang Luwei <luwei.kang@intel.com>
    Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Wu Hao <hao.wu@intel.com>
    Joseph Grecco <joe.grecco@intel.com>
    Enno Luebbers <enno.luebbers@intel.com>
    Tim Whisonant <tim.whisonant@intel.com>
    Ananda Ravuri <ananda.ravuri@intel.com>
    Mitchel, Henry <henry.mitchel@intel.com>
 Workaround: disable MBP_ERROR if feature revision is 0 
	
	  sysfs entries are visible only if related private feature is
	  enumerated.
 Workaround: keep MBP_ERROR always masked if revision is 0 
 SPDX-License-Identifier: GPL-2.0
  DFL device driver for Nios private feature on Intel PAC (Programmable
  Acceleration Card) N3000
  Copyright (C) 2019-2020 Intel Corporation, Inc.
  Authors:
    Wu Hao <hao.wu@intel.com>
    Xu Yilun <yilun.xu@intel.com>
  N3000 Nios private feature registers, named as NIOS_SPI_XX on spec.
  NS is the abbreviation of NIOS_SPI.
 Nios handshake registers, indirect access 
 Mode for retimer A, link 0, the same below 
 The retimers we use on Intel PAC N3000 is Parkvale, abbreviated to PKVL 
 When GROUP MASK field == GROUP_OK  
 loop count 
 usec 
 usec 
 FEC mode setting is not supported in early FW versions 
 If no 25G links, FEC mode setting is not supported either 
 get the valid FEC mode for 25G links 
	
	  FEC mode should always be the same for all links, as we set them
	  in this way.
	
	  The SPI is shared by the Nios core inside the FPGA, Nios will use
	  this SPI master to do some one time initialization after power up,
	  and then release the control to OS. The driver needs to poll on
	  INIT_DONE to see when driver could take the control.
	 
	  Please note that after Nios firmware version 3.0.0, INIT_START is
	  introduced, so driver needs to trigger START firstly and then check
	  INIT_DONE.
	
	  If Nios version register is totally uninitialized(== 0x0), then the
	  Nios firmware is missing. So host could take control of SPI master
	  safely, but initialization work for Nios is not done. To restore the
	  card, we need to reprogram a new Nios firmware via the BMC chip on
	  SPI bus. So the driver doesn't error out, it continues to create the
	  spi controller device and spi_board_info for BMC.
 read NIOS_INIT to check if retimer initialization is done 
 check if retimers are initialized already 
 configure FEC mode per module param 
		
		  When the retimer is to be set to 10G mode, there is no FEC
		  mode setting, so the REQ_FEC_MODE field will be ignored by
		  Nios firmware in this case. But we should still fill the FEC
		  mode field cause host could not get the retimer working mode
		  until the Nios init is done.
		 
		  For now the driver doesn't support the retimer FEC mode
		  switching per user's request. It is always set to Reed
		  Solomon FEC.
		 
		  The driver will set the same FEC mode for all links.
 polls on NIOS_INIT_DONE 
		
		  After INIT_DONE is detected, it still needs to check if the
		  Nios firmware reports any error during the retimer
		  configuration.
		
		  If the retimer configuration is failed, the Nios firmware
		  will still release the spi controller for host to
		  communicate with the BMC. It makes possible for people to
		  reprogram a new Nios firmware and restore the card. So the
		  driver doesn't error out, it continues to create the spi
		  controller device and spi_board_info for BMC.
	
	  We don't use the time based timeout here for performance.
	 
	  The regbus readwrite is on the critical path of Intel PAC N3000
	  image programming. The time based timeout checking will add too much
	  overhead on it. Usually the state changes in 1 or 2 loops on the
	  test server, and we set 10000 times loop here for safety.
 SPDX-License-Identifier: GPL-2.0-only
  FPGA Manager Driver for Lattice iCE40.
   Copyright (c) 2016 Joel Holdsworth
  This driver adds support to the FPGA manager for configuring the SRAM of
  Lattice iCE40 FPGAs through slave SPI.
 Hz 
 Hz 
 us (>200ns) 
 us 
 Lock the bus, assert CRESET_B and SS_B and delay >200ns 
 Come out of reset 
 Abort if the chip-select failed 
 Check CDONE is de-asserted i.e. the FPGA is reset 
 Wait for the housekeeping to complete, and release SS_B 
 Check CDONE is asserted 
 Send of zero-padding to activate the firmware 
 Check board setup data. 
 Set up the GPIOs 
 SPDX-License-Identifier: GPL-2.0-only
  Technologic Systems TS-73xx SBC FPGA loader
  Copyright (C) 2016 Florian Fainelli <f.fainelli@gmail.com>
  FPGA Manager Driver for the on-board Altera Cyclone II FPGA found on
  TS-7300, heavily based on load_fpga.c in their vendor tree.
 us 
 us 
 us 
 Reset the FPGA 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017, National Instruments Corp.
  Copyright (c) 2017, Xilinx Inc
  FPGA Bridge Driver for the Xilinx LogiCORE Partial Reconfiguration
  Decoupler IP Core.
 SPDX-License-Identifier: GPL-2.0
  FPGA Manager Driver for Intel Stratix10 SoC
   Copyright (C) 2018 Intel Corporation
  FPGA programming requires a higher level of privilege (EL3), per the SoC
  design.
 Indicates buffer is in use if set 
  struct s10_svc_buf
  buf:  virtual address of buf provided by service layer
  lock: locked if buffer is in use
  Free buffers allocated from the service layer's pool that are not in use.
  Return true when all buffers are freed.
  Returns count of how many buffers are not in use.
  s10_unlock_bufs
  Given the returned buffer address, match that address to our buffer struct
  and unlock that buffer.  This marks it as available to be refilled and sent
  (or freed).
  priv: private data
  kaddr: kernel address of buffer that was returned from service layer
  s10_receive_callback - callback for service layer to use to provide client
  (this driver) messages received through the mailbox.
  client: service layer client struct
  data: message from service layer
	
	  Here we set status bits as we receive them.  Elsewhere, we always use
	  test_and_clear_bit() to check status in priv->status
  s10_ops_write_init - prepare for FPGA reconfiguration by requesting
  partial reconfig and allocating buffers from the service layer.
 Allocate buffers from the service layer's pool. 
  s10_send_buf - send a buffer to the service layer queue
  mgr: fpga manager struct
  buf: fpga image buffer
  count: size of buf in bytes
  Returns # of bytes transferred or -ENOBUFS if the all the buffers are in use
  or if the service queue is full. Never returns 0.
 getlock a buffer that that's not being used 
  Send an FPGA image to privileged layers to write to the FPGA.  When done
  sending, free all service layer buffers we allocated in write_init.
	
	  Loop waiting for buffers to be returned.  When a buffer is returned,
	  reuse it to send more data or free if if all data has been sent.
		
		  If callback hasn't already happened, wait for buffers to be
		  returned from service layer
 not timed out 
 Not error or timeout, so ret is # of jiffies until timeout 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2019 Xilinx, Inc.
 Constant Definitions 
  struct zynqmp_fpga_priv - Private data structure
  @dev:	Device data structure
  @flags:	flags which is used to identify the bitfile type
 ensure all writes are done before initiate FW call 
 SPDX-License-Identifier: GPL-2.0
  Driver for FPGA Management Engine (FME) Global Performance Reporting
  Copyright 2019 Intel Corporation, Inc.
  Authors:
    Kang Luwei <luwei.kang@intel.com>
    Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Wu Hao <hao.wu@intel.com>
    Xu Yilun <yilun.xu@intel.com>
    Joseph Grecco <joe.grecco@intel.com>
    Enno Luebbers <enno.luebbers@intel.com>
    Tim Whisonant <tim.whisonant@intel.com>
    Ananda Ravuri <ananda.ravuri@intel.com>
    Mitchel, Henry <henry.mitchel@intel.com>
  Performance Counter Registers for Cache.
  Cache Events are listed below as CACHE_EVNT_.
  Performance Counter Registers for Fabric.
  Fabric Events are listed below as FAB_EVNT_
  Performance Counter Registers for Clock.
  Clock Counter can't be reset or frozen by SW.
  Performance Counter Registers for IOMMU  VT-D.
  VT-D Events are listed below as VTD_EVNT_ and VTD_SIP_EVNT_
  struct fme_perf_priv - priv data structure for fme perf driver
  @dev: parent device.
  @ioaddr: mapped base address of mmio region.
  @pmu: pmu data structure for fme perf counters.
  @id: id of this fme performance report private feature.
  @fab_users: current user number on fabric counters.
  @fab_port_id: used to indicate current working mode of fabric counters.
  @fab_lock: lock to protect fabric counters working mode.
  @cpu: active CPU to which the PMU is bound for accesses.
  @cpuhp_node: node for CPU hotplug notifier link.
  @cpuhp_state: state for CPU hotplug notification;
  struct fme_perf_event_ops - callbacks for fme perf events
  @event_init: callback invoked during event init.
  @event_destroy: callback invoked during event destroy.
  @read_counter: callback to read hardware counters.
  There are no default events, but we need to create
  "events" group (with empty attrs) before updating
  it with detected events (using pmu->attr_update).
	
	  For 64bit counter registers, the counter may increases and carries
	  out of bit [31] between 2 32bit reads. So add extra reads to help
	  to prevent this issue. This only happens in platforms which don't
	  support 64bit read - readq is split into 2 readl.
 set channel access type and cache event code. 
	
	  as fabric counter set only can be in either overall or port mode.
	  In overall mode, it counts overall data for FPGA, and in port mode,
	  it is configured to monitor on one individual port.
	 
	  so every time, a new event is initialized, driver checks
	  current working mode and if someone is using this counter set.
	
	  skip if current working mode matches, otherwise change the working
	  mode per input port_id, to monitor overall data or another port.
 FME Perf Basic Events 
 FME Perf Cache Events 
 FME Perf Fabric Events 
 FME Perf VTD Events 
 FME Perf VTD SIP Events 
 test the event attr type check for PMU enumeration 
	
	  fme counters are shared across all cores.
	  Therefore, it does not support per-process mode.
	  Also, it does not support event sampling mode.
 read and save current working mode for fabric counters 
 Register the pmu instance for cpu hotplug 
 SPDX-License-Identifier: GPL-2.0
  Driver for FPGA Management Engine (FME)
  Copyright (C) 2017-2018 Intel Corporation, Inc.
  Authors:
    Kang Luwei <luwei.kang@intel.com>
    Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Joseph Grecco <joe.grecco@intel.com>
    Enno Luebbers <enno.luebbers@intel.com>
    Tim Whisonant <tim.whisonant@intel.com>
    Ananda Ravuri <ananda.ravuri@intel.com>
    Henry Mitchel <henry.mitchel@intel.com>
  Bitstream (static FPGA region) identifier number. It contains the
  detailed version and other information of this static FPGA region.
  Bitstream (static FPGA region) meta data. It contains the synthesis
  date, seed and other information of this static FPGA region.
 threshold1 reached 
 threshold2 reached 
 threshold1 policy: 0 - AP2 (90% throttle)  1 - AP1 (50% throttle) 
 temperature is always supported, and check hardware cap for others 
	
	  create hwmon to allow userspace monitoring temperature and other
	  threshold information.
	 
	  temp1_input      -> FPGA device temperature
	  temp1_max        -> hardware threshold 1 -> 50% or 90% throttling
	  temp1_crit       -> hardware threshold 2 -> 100% throttling
	  temp1_emergency  -> hardware trip_threshold to shutdown FPGA
	  temp1_max_alarm  -> hardware threshold 1 alarm
	  temp1_crit_alarm -> hardware threshold 2 alarm
	 
	  create device specific sysfs interfaces, e.g. read temp1_max_policy
	  to understand the actual hardware throttling action (50% vs 90%).
	 
	  If hardware doesn't support automatic throttling per thresholds,
	  then all above sysfs interfaces are not visible except temp1_input
	  for temperature.
 in Watts 
 in Watts 
 in Watts 
 in 0.1 Watts 
 in 0.1 Watts 
 No extension support for now 
		
		  Let sub-feature's ioctl function to handle the cmd.
		  Sub-feature's ioctl returns -ENODEV when cmd is not
		  handled in this sub feature, and returns 0 or other
		  error code if cmd is handled.
 SPDX-License-Identifier: GPL-2.0
  Driver for FPGA Accelerated Function Unit (AFU) MMIO Region Management
  Copyright (C) 2017-2018 Intel Corporation, Inc.
  Authors:
    Wu Hao <hao.wu@intel.com>
    Xiao Guangrong <guangrong.xiao@linux.intel.com>
  afu_mmio_region_init - init function for afu mmio region support
  @pdata: afu platform device's pdata.
  afu_mmio_region_add - add a mmio region to given feature dev.
  @region_index: region index.
  @region_size: region size.
  @phys: region's physical address of this region.
  @flags: region flags (access permission).
  Return: 0 on success, negative error code otherwise.
 check if @index already exists 
  afu_mmio_region_destroy - destroy all mmio regions under given feature dev.
  @pdata: afu platform device's pdata.
  afu_mmio_region_get_by_index - find an afu region by index.
  @pdata: afu platform device's pdata.
  @region_index: region index.
  @pregion: ptr to region for result.
  Return: 0 on success, negative error code otherwise.
  afu_mmio_region_get_by_offset - find an afu mmio region by offset and size
  @pdata: afu platform device's pdata.
  @offset: region offset from start of the device fd.
  @size: region size.
  @pregion: ptr to region for result.
  Find the region which fully contains the region described by input
  parameters (offset and size) from the feature dev's region linked list.
  Return: 0 on success, negative error code otherwise.
 SPDX-License-Identifier: GPL-2.0
  FPGA Region - Device Tree support for FPGA programming under Linux
   Copyright (C) 2013-2016 Altera Corporation
   Copyright (C) 2017 Intel Corporation
  of_fpga_region_find - find FPGA region
  @np: device node of FPGA Region
  Caller will need to put_device(&region->dev) when done.
  Returns FPGA Region struct or NULL
  of_fpga_region_get_mgr - get reference for FPGA manager
  @np: device node of FPGA region
  Get FPGA Manager from "fpga-mgr" property or from ancestor region.
  Caller should call fpga_mgr_put() when done with manager.
  Return: fpga manager struct or IS_ERR() condition containing error code.
  of_fpga_region_get_bridges - create a list of bridges
  @region: FPGA region
  Create a list of bridges including the parent bridge and the bridges
  specified by "fpga-bridges" property.  Note that the
  fpga_bridges_enabledisableput functions are all fine with an empty list
  if that happens.
  Caller should call fpga_bridges_put(&region->bridge_list) when
  done with the bridges.
  Return 0 for success (even if there are no bridges specified)
  or -EBUSY if any of the bridges are in use.
 If parent is a bridge, add to list 
 -EBUSY means parent is a bridge that is under use. Give up. 
 Zero return code means parent was a bridge and was added to list. 
 If overlay has a list of bridges, use it. 
 If parent bridge is in list, skip it. 
 If node is a bridge, get it and add to list 
 If any of the bridges are in use, give up 
  child_regions_with_firmware
  @overlay: device node of the overlay
  If the overlay adds child FPGA regions, they are not allowed to have
  firmware-name property.
  Return 0 for OK or -EINVAL if child FPGA region adds firmware-name.
  of_fpga_region_parse_ov - parse and check overlay applied to region
  @region: FPGA region
  @overlay: overlay applied to the FPGA region
  Given an overlay applied to an FPGA region, parse the FPGA image specific
  info in the overlay and do some checking.
  Returns:
    NULL if overlay doesn't direct us to program the FPGA.
    fpga_image_info struct if there is an image to program.
    error code for invalid overlay.
	
	  Reject overlay if child FPGA Regions added in the overlay have
	  firmware-name property (would mean that an FPGA region that has
	  not been added to the live tree yet is doing FPGA programming).
 Read FPGA region properties from the overlay 
 If overlay is not programming the FPGA, don't need FPGA image info 
	
	  If overlay informs us FPGA was externally programmed, specifying
	  firmware here would be ambiguous.
  of_fpga_region_notify_pre_apply - pre-apply overlay notification
  @region: FPGA region that the overlay was applied to
  @nd: overlay notification data
  Called when an overlay targeted to an FPGA Region is about to be applied.
  Parses the overlay for properties that influence how the FPGA will be
  programmed and does some checking. If the checks pass, programs the FPGA.
  If the checks fail, overlay is rejected and does not get added to the
  live tree.
  Returns 0 for success or negative error code for failure.
 If overlay doesn't program the FPGA, accept it anyway. 
 error; reject overlay 
  of_fpga_region_notify_post_remove - post-remove overlay notification
  @region: FPGA region that was targeted by the overlay that was removed
  @nd: overlay notification data
  Called after an overlay has been removed if the overlay's target was a
  FPGA region.
  of_fpga_region_notify - reconfig notifier for dynamic DT changes
  @nb:		notifier block
  @action:	notifier action
  @arg:	reconfig data
  This notifier handles programming an FPGA when a "firmware-name" property is
  added to an fpga-region.
  Returns NOTIFY_OK or error if FPGA programming fails.
 not for us 
 not for us 
 should not happen 
 Find the FPGA mgr specified by region or parent region. 
  fpga_region_init - init function for fpga_region class
  Creates the fpga_region class and registers a reconfig notifier.
 SPDX-License-Identifier: GPL-2.0
  FPGA Freeze Bridge Controller
   Copyright (C) 2016 Altera Corporation. All rights reserved.
  Poll status until status bit is set or we have a timeout.
  enable = 1 : allow traffic through the bridge
  enable = 0 : disable traffic through the bridge
 SPDX-License-Identifier: GPL-2.0
  Driver for Altera Partial Reconfiguration IP Core
  Copyright (C) 2016-2017 Intel Corporation
  Based on socfpga-a10.c Copyright (C) 2015-2016 Altera Corporation
   by Alan Tull <atull@opensource.altera.com>
 First mmio base is for register access 
 SPDX-License-Identifier: GPL-2.0
  Driver for FPGA Device Feature List (DFL) PCIe device
  Copyright (C) 2017-2018 Intel Corporation, Inc.
  Authors:
    Zhang Yi <Yi.Z.Zhang@intel.com>
    Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Joseph Grecco <joe.grecco@intel.com>
    Enno Luebbers <enno.luebbers@intel.com>
    Tim Whisonant <tim.whisonant@intel.com>
    Ananda Ravuri <ananda.ravuri@intel.com>
    Henry Mitchel <henry.mitchel@intel.com>
 container device 
 PCI Device ID 
 VF Device 
 remove all children feature devices 
 default method of finding dfls starting at offset 0 of bar 0 
 start to find Device Feature List from Bar 0 
	
	  PF device has FME and PortsAFUs, and VF device only has one
	  PortAFU. Check them and add related "Device Feature List" info
	  for the next step enumeration.
		
		  find more Device Feature Lists (e.g. Ports) per information
		  indicated by FME module.
 skip ports which are not implemented. 
			
			  add Port's Device Feature List information for next
			  step enumeration.
 release IO mappings for next step enumeration 
 enumerate feature devices under pci device 
 allocate enumeration info via pci_dev 
 add irq info for enumeration if the device support irq 
 start enumeration with prepared enumeration information 
		
		  disable SRIOV and then put released ports back to default
		  PF access mode.
		
		  before enable SRIOV, put released ports into VF access mode
		  first of all.
 SPDX-License-Identifier: GPL-2.0
  FPGA Region Driver for FPGA Management Engine (FME)
  Copyright (C) 2017-2018 Intel Corporation, Inc.
  Authors:
    Wu Hao <hao.wu@intel.com>
    Joseph Grecco <joe.grecco@intel.com>
    Enno Luebbers <enno.luebbers@intel.com>
    Tim Whisonant <tim.whisonant@intel.com>
    Ananda Ravuri <ananda.ravuri@intel.com>
    Henry Mitchel <henry.mitchel@intel.com>
 SPDX-License-Identifier: GPL-2.0
  Driver for FPGA Accelerated Function Unit (AFU) DMA Region Management
  Copyright (C) 2017-2018 Intel Corporation, Inc.
  Authors:
    Wu Hao <hao.wu@intel.com>
    Xiao Guangrong <guangrong.xiao@linux.intel.com>
  afu_dma_pin_pages - pin pages of given dma memory region
  @pdata: feature device platform data
  @region: dma memory region to be pinned
  Pin all the pages of given dfl_afu_dma_region.
  Return 0 for success or negative error code.
  afu_dma_unpin_pages - unpin pages of given dma memory region
  @pdata: feature device platform data
  @region: dma memory region to be unpinned
  Unpin all the pages of given dfl_afu_dma_region.
  Return 0 for success or negative error code.
  afu_dma_check_continuous_pages - check if pages are continuous
  @region: dma memory region
  Return true if pages of given dma memory region have continuous physical
  address, otherwise return false.
  dma_region_check_iova - check if memory area is fully contained in the region
  @region: dma memory region
  @iova: address of the dma memory area
  @size: size of the dma memory area
  Compare the dma memory area defined by @iova and @size with given dma region.
  Return true if memory area is fully contained in the region, otherwise false.
  afu_dma_region_add - add given dma region to rbtree
  @pdata: feature device platform data
  @region: dma region to be added
  Return 0 for success, -EEXIST if dma region has already been added.
  Needs to be called with pdata->lock heold.
  afu_dma_region_remove - remove given dma region from rbtree
  @pdata: feature device platform data
  @region: dma region to be removed
  Needs to be called with pdata->lock heold.
  afu_dma_region_destroy - destroy all regions in rbtree
  @pdata: feature device platform data
  Needs to be called with pdata->lock heold.
  afu_dma_region_find - find the dma region from rbtree based on iova and size
  @pdata: feature device platform data
  @iova: address of the dma memory area
  @size: size of the dma memory area
  It finds the dma region from the rbtree based on @iova and @size:
  - if @size == 0, it finds the dma region which starts from @iova
  - otherwise, it finds the dma region which fully contains
    [@iova, @iova+size)
  If nothing is matched returns NULL.
  Needs to be called with pdata->lock held.
 the iova region is not fully covered. 
  afu_dma_region_find_iova - find the dma region from rbtree by iova
  @pdata: feature device platform data
  @iova: address of the dma region
  Needs to be called with pdata->lock held.
  afu_dma_map_region - map memory region for dma
  @pdata: feature device platform data
  @user_addr: address of the memory region
  @length: size of the memory region
  @iova: pointer of iova address
  Map memory region defined by @user_addr and @length, and return dma address
  of the memory region via @iova.
  Return 0 for success, otherwise error code.
	
	  Check Inputs, only accept page-aligned user memory region with
	  valid length.
 Check overflow 
 Pin the user memory region 
 Only accept continuous pages, return error else 
 As pages are continuous then start to do DMA mapping 
  afu_dma_unmap_region - unmap dma memory region
  @pdata: feature device platform data
  @iova: dma address of the region
  Unmap dma memory region based on @iova.
  Return 0 for success, otherwise error code.
 SPDX-License-Identifier: GPL-2.0
  FPGA Bridge Framework Driver
   Copyright (C) 2013-2016 Altera Corporation, All Rights Reserved.
   Copyright (C) 2017 Intel Corporation
 Lock for addingremoving bridges to linked lists
  fpga_bridge_enable - Enable transactions on the bridge
  @bridge: FPGA bridge
  Return: 0 for success, error code otherwise.
  fpga_bridge_disable - Disable transactions on the bridge
  @bridge: FPGA bridge
  Return: 0 for success, error code otherwise.
  of_fpga_bridge_get - get an exclusive reference to an fpga bridge
  @np: node pointer of an FPGA bridge
  @info: fpga image specific information
  Return fpga_bridge struct if successful.
  Return -EBUSY if someone already has a reference to the bridge.
  Return -ENODEV if @np is not an FPGA Bridge.
  fpga_bridge_get - get an exclusive reference to an fpga bridge
  @dev:	parent device that fpga bridge was registered with
  @info:	fpga manager info
  Given a device, get an exclusive reference to an fpga bridge.
  Return: fpga bridge struct or IS_ERR() condition containing error code.
  fpga_bridge_put - release a reference to a bridge
  @bridge: FPGA bridge
  fpga_bridges_enable - enable bridges in a list
  @bridge_list: list of FPGA bridges
  Enable each bridge in the list.  If list is empty, do nothing.
  Return 0 for success or empty bridge list; return error code otherwise.
  fpga_bridges_disable - disable bridges in a list
  @bridge_list: list of FPGA bridges
  Disable each bridge in the list.  If list is empty, do nothing.
  Return 0 for success or empty bridge list; return error code otherwise.
  fpga_bridges_put - put bridges
  @bridge_list: list of FPGA bridges
  For each bridge in the list, put the bridge and remove it from the list.
  If list is empty, do nothing.
  of_fpga_bridge_get_to_list - get a bridge, add it to a list
  @np: node pointer of an FPGA bridge
  @info: fpga image specific information
  @bridge_list: list of FPGA bridges
  Get an exclusive reference to the bridge and it to the list.
  Return 0 for success, error code from of_fpga_bridge_get() otherwise.
  fpga_bridge_get_to_list - given device, get a bridge, add it to a list
  @dev: FPGA bridge device
  @info: fpga image specific information
  @bridge_list: list of FPGA bridges
  Get an exclusive reference to the bridge and it to the list.
  Return 0 for success, error code from fpga_bridge_get() otherwise.
  fpga_bridge_create - create and initialize a struct fpga_bridge
  @parent:	FPGA bridge device from pdev
  @name:	FPGA bridge name
  @br_ops:	pointer to structure of fpga bridge ops
  @priv:	FPGA bridge private data
  The caller of this function is responsible for freeing the bridge with
  fpga_bridge_free().  Using devm_fpga_bridge_create() instead is recommended.
  Return: struct fpga_bridge or NULL
  fpga_bridge_free - free an fpga bridge created by fpga_bridge_create()
  @bridge:	FPGA bridge struct
  devm_fpga_bridge_create - create and init a managed struct fpga_bridge
  @parent:	FPGA bridge device from pdev
  @name:	FPGA bridge name
  @br_ops:	pointer to structure of fpga bridge ops
  @priv:	FPGA bridge private data
  This function is intended for use in an FPGA bridge driver's probe function.
  After the bridge driver creates the struct with devm_fpga_bridge_create(), it
  should register the bridge with fpga_bridge_register().  The bridge driver's
  remove function should call fpga_bridge_unregister().  The bridge struct
  allocated with this function will be freed automatically on driver detach.
  This includes the case of a probe function returning error before calling
  fpga_bridge_register(), the struct will still get cleaned up.
   Return: struct fpga_bridge or NULL
  fpga_bridge_register - register an FPGA bridge
  @bridge: FPGA bridge struct
  Return: 0 for success, error code otherwise.
  fpga_bridge_unregister - unregister an FPGA bridge
  @bridge: FPGA bridge struct
  This function is intended for use in an FPGA bridge driver's remove function.
	
	  If the low level driver provides a method for putting bridge into
	  a desired state upon unregister, do it.
 $Id: capi.c,v 1.1.2.7 20040428 09:48:59 armin Exp $
  CAPI 2.0 Interface for Linux
  Copyright 1996 by Carsten Paeth <calle@calle.de>
  This software may be used and distributed according to the terms
  of the GNU General Public License, incorporated herein by reference.
 -------- driver information -------------------------------------- 
 allocated 
 CONFIG_ISDN_CAPI_MIDDLEWARE 
 -------- defines ------------------------------------------------- 
 -------- data structures ----------------------------------------- 
 transmit path 
 CONFIG_ISDN_CAPI_MIDDLEWARE 
 -------- global variables ---------------------------------------- 
 -------- datahandles --------------------------------------------- 
 -------- struct capiminor ---------------------------------------- 
 Allocate the least unused minor number. 
 -------- struct capincci ----------------------------------------- 
 !CONFIG_ISDN_CAPI_MIDDLEWARE 
 !CONFIG_ISDN_CAPI_MIDDLEWARE 
 -------- handle data queue --------------------------------------- 
 fatal error, do not requeue 
 fatal error, do not requeue 
 NCCI 
 Data32 
 Data length 
 Flags 
 ups, drop packet 
 CONFIG_ISDN_CAPI_MIDDLEWARE 
 -------- function called by lower level -------------------------- 
 CONFIG_ISDN_CAPI_MIDDLEWARE 
 Info field
 CONFIG_ISDN_CAPI_MIDDLEWARE 
 ups, let capi application handle it :-) 
 CONFIG_ISDN_CAPI_MIDDLEWARE 
 -------- file_operations for capidev ----------------------------- 
 CONFIG_ISDN_CAPI_MIDDLEWARE 
 CONFIG_ISDN_CAPI_MIDDLEWARE 
 -------- tty_operations for capincci ----------------------------- 
 !CONFIG_ISDN_CAPI_MIDDLEWARE 
 !CONFIG_ISDN_CAPI_MIDDLEWARE 
 -------- proc functions ----------------------------------------- 
  proccapicapi20:
   minor applid nrecvctlpkt nrecvdatapkt nsendctlpkt nsenddatapkt
  proccapicapi20ncci:
   applid ncci
 -------- init function and module interface ---------------------- 
 $Id: capiutil.c,v 1.13.6.4 20010923 22:24:33 kai Exp $
  CAPI 2.0 convert capi message to capi message struct
  From CAPI 2.0 Development Kit AVM 1995 (msg.c)
  Rewritten for Linux 1996 by Carsten Paeth <calle@calle.de>
  This software may be used and distributed according to the terms
  of the GNU General Public License, incorporated herein by reference.
 from CAPI2.0 DDK AVM Berlin GmbH 
00 
01 
02 
03 
04 
05 
06 
07 
08 
09 
0a 
0b 
0c 
0d 
0e 
0f 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
1a 
1b 
1c 
1d 
1e 
1f 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
2a 
2b 
2c 
2d 
2e 
2f 
 ALERT_REQ  [0x01] = "\x03\x04\x0c\x27\x2f\x1c\x01\x01",
 CONNECT_REQ  [0x02] = "\x03\x14\x0e\x10\x0f\x11\x0d\x06\x08\x0a\x05\x07\x09\x01\x0b\x28\x22\x04\x0c\x27\x2f\x1c\x01\x01",
 DISCONNECT_REQ  [0x04] = "\x03\x04\x0c\x27\x2f\x1c\x01\x01",
 LISTEN_REQ  [0x05] = "\x03\x25\x12\x13\x10\x11\x01",
 INFO_REQ  [0x08] = "\x03\x0e\x04\x0c\x27\x2f\x1c\x01\x01",
 FACILITY_REQ  [0x09] = "\x03\x1f\x1e\x01",
 SELECT_B_PROTOCOL_REQ  [0x0a] = "\x03\x0d\x06\x08\x0a\x05\x07\x09\x01\x01",
 CONNECT_B3_REQ  [0x0b] = "\x03\x2b\x01",
 DISCONNECT_B3_REQ  [0x0d] = "\x03\x2b\x01",
 DATA_B3_REQ  [0x0f] = "\x03\x18\x1a\x19\x20\x01",
 RESET_B3_REQ  [0x10] = "\x03\x2b\x01",
 ALERT_CONF  [0x13] = "\x03\x23\x01",
 CONNECT_CONF  [0x14] = "\x03\x23\x01",
 DISCONNECT_CONF  [0x16] = "\x03\x23\x01",
 LISTEN_CONF  [0x17] = "\x03\x23\x01",
 MANUFACTURER_REQ  [0x18] = "\x03\x2a\x15\x21\x29\x01",
 INFO_CONF  [0x1a] = "\x03\x23\x01",
 FACILITY_CONF  [0x1b] = "\x03\x23\x1f\x1b\x01",
 SELECT_B_PROTOCOL_CONF  [0x1c] = "\x03\x23\x01",
 CONNECT_B3_CONF  [0x1d] = "\x03\x23\x01",
 DISCONNECT_B3_CONF  [0x1f] = "\x03\x23\x01",
 DATA_B3_CONF  [0x21] = "\x03\x19\x23\x01",
 RESET_B3_CONF  [0x22] = "\x03\x23\x01",
 CONNECT_IND  [0x26] = "\x03\x14\x0e\x10\x0f\x11\x0b\x28\x22\x04\x0c\x27\x2f\x1c\x01\x01",
 CONNECT_ACTIVE_IND  [0x27] = "\x03\x16\x17\x28\x01",
 DISCONNECT_IND  [0x28] = "\x03\x2c\x01",
 MANUFACTURER_CONF  [0x2a] = "\x03\x2a\x15\x21\x29\x01",
 INFO_IND  [0x2c] = "\x03\x26\x24\x01",
 FACILITY_IND  [0x2d] = "\x03\x1f\x1d\x01",
 CONNECT_B3_IND  [0x2f] = "\x03\x2b\x01",
 CONNECT_B3_ACTIVE_IND  [0x30] = "\x03\x2b\x01",
 DISCONNECT_B3_IND  [0x31] = "\x03\x2d\x2b\x01",
 DATA_B3_IND  [0x33] = "\x03\x18\x1a\x19\x20\x01",
 RESET_B3_IND  [0x34] = "\x03\x2b\x01",
 CONNECT_B3_T90_ACTIVE_IND  [0x35] = "\x03\x2b\x01",
 CONNECT_RESP  [0x38] = "\x03\x2e\x0d\x06\x08\x0a\x05\x07\x09\x01\x16\x17\x28\x04\x0c\x27\x2f\x1c\x01\x01",
 CONNECT_ACTIVE_RESP  [0x39] = "\x03\x01",
 DISCONNECT_RESP  [0x3a] = "\x03\x01",
 MANUFACTURER_IND  [0x3c] = "\x03\x2a\x15\x21\x29\x01",
 INFO_RESP  [0x3e] = "\x03\x01",
 FACILITY_RESP  [0x3f] = "\x03\x1f\x01",
 CONNECT_B3_RESP  [0x41] = "\x03\x2e\x2b\x01",
 CONNECT_B3_ACTIVE_RESP  [0x42] = "\x03\x01",
 DISCONNECT_B3_RESP  [0x43] = "\x03\x01",
 DATA_B3_RESP  [0x45] = "\x03\x19\x01",
 RESET_B3_RESP  [0x46] = "\x03\x01",
 CONNECT_B3_T90_ACTIVE_RESP  [0x47] = "\x03\x01",
 MANUFACTURER_RESP  [0x4e] = "\x03\x2a\x15\x21\x29\x01",
-------------------------------------------------------
-------------------------------------------------------
  capi_cmd2par() - find parameter string for CAPI 2.0 commandsubcommand
  @cmd:	command number
  @subcmd:	subcommand number
  Return value: static string, NULL if commandsubcommand unknown
-------------------------------------------------------
 $$$$$ assert (cmsg->p); 
-------------------------------------------------------
  capi_cmd2str() - convert CAPI 2.0 commandsubcommand number to name
  @cmd:	command number
  @subcmd:	subcommand number
  Return value: static string
-------------------------------------------------------
-------------------------------------------------------
00  NULL,
01  NULL,
02  NULL,
03  "ControllerPLCINCCI",
04  "AdditionalInfo",
05  "B1configuration",
06  "B1protocol",
07  "B2configuration",
08  "B2protocol",
09  "B3configuration",
0a  "B3protocol",
0b  "BC",
0c  "BChannelinformation",
0d  "BProtocol",
0e  "CalledPartyNumber",
0f  "CalledPartySubaddress",
10  "CallingPartyNumber",
11  "CallingPartySubaddress",
12  "CIPmask",
13  "CIPmask2",
14  "CIPValue",
15  "Class",
16  "ConnectedNumber",
17  "ConnectedSubaddress",
18  "Data32",
19  "DataHandle",
1a  "DataLength",
1b  "FacilityConfirmationParameter",
1c  "Facilitydataarray",
1d  "FacilityIndicationParameter",
1e  "FacilityRequestParameter",
1f  "FacilitySelector",
20  "Flags",
21  "Function",
22  "HLC",
23  "Info",
24  "InfoElement",
25  "InfoMask",
26  "InfoNumber",
27  "Keypadfacility",
28  "LLC",
29  "ManuData",
2a  "ManuID",
2b  "NCPI",
2c  "Reason",
2d  "Reason_B3",
2e  "Reject",
2f  "Useruserdata"
-------------------------------------------------------
 truncated, need bigger buffer 
-------------------------------------------------------
 invalid commandsubcommand 
----- Metastruktur 0 -----
-------------------------------------------------------
  cdebbuf_free() - free CAPI debug buffer
  @cdb:	buffer to free
  capi_message2str() - format CAPI 2.0 message for printing
  @msg:	CAPI 2.0 message
  Allocates a CAPI debug buffer and fills it with a printable representation
  of the CAPI 2.0 message in @msg.
  Return value: allocated debug buffer, NULL on error
  The returned buffer should be freed by a call to cdebbuf_free() after use.
 !CONFIG_CAPI_TRACE 
  Kernel CAPI 2.0 Module - proccapi handling
  Copyright 1999 by Carsten Paeth <calle@calle.de>
  Copyright 2002 by Kai Germaschewski <kai@germaschewski.name>
  This software may be used and distributed according to the terms
  of the GNU General Public License, incorporated herein by reference.
 proccapi
 ===========================================================================
 proccapicontroller:
      cnr driver cardstate name driverinfo
 proccapicontrstats:
      cnr nrecvctlpkt nrecvdatapkt nsentctlpkt nsentdatapkt
 ---------------------------------------------------------------------------
 proccapiapplications:
      applid l3cnt dblkcnt dblklen #ncci recvqueuelen
 proccapiapplstats:
      applid nrecvctlpkt nrecvdatapkt nsentctlpkt nsentdatapkt
 ---------------------------------------------------------------------------
 ---------------------------------------------------------------------------
 proccapidrivers is always empty 
 ---------------------------------------------------------------------------
 $Id: kcapi.c,v 1.1.2.8 20040326 19:57:20 armin Exp $
  Kernel CAPI 2.0 Module
  Copyright 1999 by Carsten Paeth <calle@calle.de>
  Copyright 2002 by Kai Germaschewski <kai@germaschewski.name>
  This software may be used and distributed according to the terms
  of the GNU General Public License, incorporated herein by reference.
 ------------------------------------------------------------- 
 ------------------------------------------------------------- 
 -------- controller ref counting -------------------------------------- 
 ------------------------------------------------------------- 
 -------- util functions ------------------------------------ 
 ------------------------------------------------------------ 
 -------- Receiver ------------------------------------------ 
  capi_ctr_handle_message() - handle incoming CAPI message
  @ctr:	controller descriptor structure.
  @appl:	application ID.
  @skb:	message.
  Called by hardware driver to pass a CAPI message to the application.
  capi_ctr_ready() - signal CAPI controller ready
  @ctr:	controller descriptor structure.
  Called by hardware driver to signal that the controller is up and running.
  capi_ctr_down() - signal CAPI controller not ready
  @ctr:	controller descriptor structure.
  Called by hardware driver to signal that the controller is down and
  unavailable for use.
 ------------------------------------------------------------- 
  attach_capi_ctr() - register CAPI controller
  @ctr:	controller descriptor structure.
  Called by hardware driver to register a controller with the CAPI subsystem.
  Return value: 0 on success, error code < 0 on error
  detach_capi_ctr() - unregister CAPI controller
  @ctr:	controller descriptor structure.
  Called by hardware driver to remove the registration of a controller
  with the CAPI subsystem.
  Return value: 0 on success, error code < 0 on error
 ------------------------------------------------------------- 
 -------- CAPI2.0 Interface ---------------------------------- 
 ------------------------------------------------------------- 
  capi20_isinstalled() - CAPI 2.0 operation CAPI_INSTALLED
  Return value: CAPI result code (CAPI_NOERROR if at least one ISDN controller
 	is ready for use, CAPI_REGNOTINSTALLED otherwise)
  capi20_register() - CAPI 2.0 operation CAPI_REGISTER
  @ap:		CAPI application descriptor structure.
  Register an application's presence with CAPI.
  A unique application ID is assigned and stored in @ap->applid.
  After this function returns successfully, the message receive
  callback function @ap->recv_message() may be called at any time
  until capi20_release() has been called for the same @ap.
  Return value: CAPI result code
  capi20_release() - CAPI 2.0 operation CAPI_RELEASE
  @ap:		CAPI application descriptor structure.
  Terminate an application's registration with CAPI.
  After this function returns successfully, the message receive
  callback function @ap->recv_message() will no longer be called.
  Return value: CAPI result code
  capi20_put_message() - CAPI 2.0 operation CAPI_PUT_MESSAGE
  @ap:		CAPI application descriptor structure.
  @skb:	CAPI message.
  Transfer a single message to CAPI.
  Return value: CAPI result code
	
	  The controller reference is protected by the existence of the
	  application passed to us. We assume that the caller properly
	  synchronizes this service with capi20_release.
  capi20_get_manufacturer() - CAPI 2.0 operation CAPI_GET_MANUFACTURER
  @contr:	controller number.
  @buf:	result buffer (64 bytes).
  Retrieve information about the manufacturer of the specified ISDN controller
  or (for @contr == 0) the driver itself.
  Return value: CAPI result code
  capi20_get_version() - CAPI 2.0 operation CAPI_GET_VERSION
  @contr:	controller number.
  @verp:	result structure.
  Retrieve version information for the specified ISDN controller
  or (for @contr == 0) the driver itself.
  Return value: CAPI result code
  capi20_get_serial() - CAPI 2.0 operation CAPI_GET_SERIAL_NUMBER
  @contr:	controller number.
  @serial:	result buffer (8 bytes).
  Retrieve the serial number of the specified ISDN controller
  or (for @contr == 0) the driver itself.
  Return value: CAPI result code
  capi20_get_profile() - CAPI 2.0 operation CAPI_GET_PROFILE
  @contr:	controller number.
  @profp:	result structure.
  Retrieve capability information for the specified ISDN controller
  or (for @contr == 0) the number of installed controllers.
  Return value: CAPI result code
  capi20_manufacturer() - CAPI 2.0 operation CAPI_MANUFACTURER
  @cmd:	command.
  @data:	parameter.
  Perform manufacturer specific command.
  Return value: CAPI result code
 ------------------------------------------------------------- 
 -------- Init & Cleanup ------------------------------------- 
 ------------------------------------------------------------- 
  init  exit functions
  Audio crossconnectingconferrencing (hardware level).
  Copyright 2002 by Andreas Eversberg (jolly@eversberg.eu)
  This software may be used and distributed according to the terms
  of the GNU General Public License, incorporated herein by reference.
  The process of adding and removing parties tofrom a conference:
  There is a chain of struct dsp_conf which has one or more members in a chain
  of struct dsp_conf_member.
  After a party is added, the conference is checked for hardware capability.
  Also if a party is removed, the conference is checked again.
  There are 3 different solutions: -1 = software, 0 = hardware-crossconnect
  1-n = hardware-conference. The n will give the conference number.
  Depending on the change after removal or insertion of a party, hardware
  commands are given.
  The current solution is stored within the struct dsp_conf entry.
  HOW THE CMX WORKS:
  There are 3 types of interaction: One member is alone, in this case only
  data flow from upper to lower layer is done.
  Two members will also exchange their data so they are crossconnected.
  Three or more members will be added in a conference and will hear each
  other but will not receive their own speech (echo) if not enabled.
  Features of CMX are:
   - Crossconnecting or even conference, if more than two members are together.
   - Force mixing of transmit data with other crossconnectconference members.
   - Echo generation to benchmark the delay of audio processing.
   - Use hardware to minimize cpu load, disable FIFO load and minimize delay.
   - Dejittering and clock generation.
  There are 2 buffers:
  RX-Buffer
                  R             W
                  |             |
  ----------------+-------------+-------------------
  The rx-buffer is a ring buffer used to store the received data for each
  individual member. This is only the case if data needs to be dejittered
  or in case of a conference where different clocks require reclocking.
  The transmit-clock (R) will read the buffer.
  If the clock overruns the write-pointer, we will have a buffer underrun.
  If the write pointer always has a certain distance from the transmit-
  clock, we will have a delay. The delay will dynamically be increased and
  reduced.
  TX-Buffer
                   R        W
                   |        |
  -----------------+--------+-----------------------
  The tx-buffer is a ring buffer to queue the transmit data from user space
  until it will be mixed or sent. There are two pointers, R and W. If the write
  pointer W would reach or overrun R, the buffer would overrun. In this case
  (some) data is dropped so that it will not overrun.
  Additionally a dynamic dejittering can be enabled. this allows data from
  user space that have jitter and different clock source.
  Clock:
  A Clock is not required, if the data source has exactly one clock. In this
  case the data source is forwarded to the destination.
  A Clock is required, because the data source
   - has multiple clocks.
   - has no usable clock due to jitter or packet loss (VoIP).
  In this case the system's clock is used. The clock resolution depends on
  the jiffie resolution.
  If a member joins a conference:
  - If a member joins, its rx_buff is set to silence and change read pointer
    to transmit clock.
  The procedure of received data from card is explained in cmx_receive.
  The procedure of received data from user space is explained in cmx_transmit.
  The procedure of transmit data to card is cmx_send.
  Interaction with other features:
  DTMF:
  DTMF decoding is done before the data is crossconnected.
  Volume change:
  Changing rx-volume is done before the data is crossconnected. The tx-volume
  must be changed whenever data is transmitted to the card by the cmx.
  Tones:
  If a tone is enabled, it will be processed whenever data is transmitted to
  the card. It will replace the tx-data from the user space.
  If tones are generated by hardware, this conference member is removed for
  this time.
  Disable rx-data:
  If cmx is realized in hardware, rx data will be disabled if requested by
  the upper layer. If dtmf decoding is done by software and enabled, rx data
  will not be disabled but blocked to the upper layer.
  HFC conference engine:
  If it is possible to realize all features using hardware, hardware will be
  used if not forbidden by control command. Disabling rx-data provides
  absolutely traffic free audio processing. (except for the quick 1-frame
  upload of a tone loop, only once for a new tone)
 delay.h is required for hw_lock.h 
  debugging of multi party conference,
  by using conference even with two members
 #define CMX_CONF_DEBUG 
#define CMX_DEBUG  massive readwrite pointer output 
#define CMX_DELAY_DEBUG  gives rx-buffer delay overview 
#define CMX_TX_DEBUG  massive readwrite on tx-buffer with content 
  debug cmx memory structure
  search conference
 search conference 
  add member to conference
 clear rx buffer 
 rx_W and rx_R will be adjusted on first frame 
  del member from conference
 find us in conf 
  new conference
  del conference
  send HW message to hfc card
  do hardware update and set the softwarehardware flag
  either a conference or a dsp instance can be given
  if only dsp instance is given, the instance is not associated with a conf
  and therefore removed. if a conference is given, the dsp is expected to
  be member of that conference.
 dsp gets updated (no conf) 
 remove HFC conference if enabled 
 process hw echo 
 NO ECHO: remove PCM slot if assigned 
 echo is enabled, find out if we use soft or hardware 
 ECHO: already echo 
 ECHO: if slot already assigned 
 2 means loop 
 ECHO: find slot 
 no more slots available 
 assign free slot 
 loop 
 conf gets updated (all members) 
 check all members in our conference 
 check if member uses mixing 
 remove HFC conference if enabled 
 remove PCM slot if assigned 
 check if member has echo turned on 
 check if member has tx_mix turned on 
 check if member changes volume at an not suppoted level 
 check if tx-data turned on 
 check if pipeline exists 
 check if encryption is enabled 
 check if member is on a card with PCM support 
 check if relations are on the same PCM bus 
 determine if members are on the same hfc chip 
 if there are members already in a conference 
 if any member is not in a conference 
 if no member, this is an error 
 one member 
	
	  ok, now we are sure that all members are on the same pcm.
	  now we will see if we have only two members, so we can do
	  crossconnections, which don't have any limitations.
 if we have only two members 
 remove HFC conference if enabled 
 if members have two banks (and not on the same chip) 
 if both members have same slots with crossed banks 
 all members have same slot 
 find a new slot 
 no more slots available 
 assign free slot 
 if members have one bank (or on the same chip) 
 if both members have different crossed slots 
 all members have same slot 
 find two new slot 
 no more slots available 
 no more slots available 
 assign free slots 
	
	  if we have more than two, we may check if we have a conference
	  unit available on the chip. also all members must be on the same
 if not the same HFC chip 
 for more than two members.. 
 if all members already have the same conference 
	
	  if there is an existing conference, but not all members have joined
			 if no conference engine on our chip, change to
 in case of hdlc, change to software 
 join to current conference 
 get a free timeslot first 
				
				  not checking current member, because
				  slot will be overwritten.
 dsp must be on the same PCM 
 dsp must be on a slot 
 no more slots available 
 assign free slot & set PCM & join conf 
 loop 
	
	  no member is in a conference yet, so we find a free one
 dsp must be on the same chip 
 dsp must have joined a HW conference 
 slot must be within range 
 no more conferences available 
 join all members 
  conf_id != 0: join or change conference
  conf_id == 0: split from conference if not already
 if conference doesn't change 
 first remove us from current conf 
 remove us from conf 
 update hardware 
 conf now empty? 
 update members left on conf 
 if split 
 now add us to conf 
 the conference doesn't exist, so we create 
 add conference member 
 if we are alone, we do nothing! 
 update hardware 
 update members on conf 
  audio data is received from card
 check if we have sompen 
 half of the buffer should be larger than maximum packet size 
	
	  initialize pointers if not already -
	  also add delay if requested by PH_SIGNAL
 if frame contains time code, write directly 
 printk(KERN_DEBUG "%s %08x\n", dsp->name, hh->id); 
	
	  if we underrun (or maybe overrun),
	  we set our new read pointer, and write silence to buffer
 flush rx buffer and set delay to dsp_poll  2 
 if we have reached double delay, jump back to middle 
 flush buffer 
 show where to write 
 write data into rx_buffer 
 increase write-pointer 
  send (mixed) audio data to card and control jitter
 don't process if: 
 if not active 
 hardware conf 
 OR hardware echo 
 AND no tx-data 
 AND not soft tones 
 no tx_data for user space required 
 preload if we have delay set 
 PREPARE RESULT 
 set pointers, indexes and stuff 
 transmit data 
 received data 
 result 
 tx-pointers 
 rx-pointers 
 preload with silence, if required 
 PROCESS TONESTX-DATA ONLY 
 -> copy tone 
 clear tx buffer 
 if we have tx-data but do not use mixing 
 -> send tx-data and continue when not enough 
 write tx_buff 
 PROCESS DATA (one member  no conf) 
 -> if echo is NOT enabled 
 -> send tx-data if available or use 0-volume 
 write tx_buff 
 -> if echo is enabled 
			
			  -> mix tx-data with echo if available,
			  or use echo only
 echo 
 PROCESS DATA (two members) 
 "other" becomes other party 
 received data 
 end of rx-pointer 
 start rx-pointer at current read position
 -> if echo is NOT enabled 
			
			  -> copy other member's rx-data,
			  if tx-data is available, mix
 -> if echo is enabled 
			
			  -> mix other member's rx-data with echo,
			  if tx-data is available, mix
 tx-data + rx_data + echo 
 PROCESS DATA (three or more members) 
 -> if echo is NOT enabled 
		
		  -> subtract rx-data from conf-data,
		  if tx-data is available, mix
 conf-rx+tx 
 conf-rx 
 -> if echo is enabled 
		
		  -> encode conf-data, if tx-data
		  is available, mix
 conf(echo)+tx 
 conf(echo) 
	
	  send tx-data if enabled - don't filter,
	  because we want what we send, not what we filtered
 queue and trigger 
 exit because only tx_data is used 
 queue (trigger later) 
 send data only to card, if we don't just calculated tx_data 
 adjust volume 
 pipeline 
 crypt 
 queue and trigger 
 counter for jitter check 
 calculate the next time to fire 
 last sample count 
 if we have last sample count 
 lock 
 printk(KERN_DEBUG "len=%d dsp_count=0x%x\n", length, dsp_count); 
	
	  check if jitter needs to be checked (this is every second)
 loop all members that do not require conference mixing 
 transmission required 
			
			  unused mixbuffer is given to prevent a
			  potential null-pointer-bug
 loop all members that require conference mixing 
 count members and check hardware 
 check for hdlc conf 
 mix all data 
 get range of data to mix 
 add member's data 
 process each member 
 transmission 
 delete rx-data, increment buffers, change pointers 
 move receive pointer when receiving 
 delete rx-data 
 increment rx-buffer pointer 
 write incremented read pointer 
 check current rx_delay 
 will be the delay before next write 
 check for lower delay 
 check current tx_delay 
 will be the delay before next write 
 check for lower delay 
 find the lowest of all rx_delays 
			
			  remove rx_delay only if we have delay AND we
			  have not preset cmx_delay AND
			  the delay is greater dsp_poll
 delete rx-data 
 increment rx-buffer pointer 
 write incremented read pointer 
 find the lowest of all tx_delays 
			
			  remove delay only if we have delay AND we
			  have enabled tx_dejitter
 delete tx-data 
 increment rx-buffer pointer 
 write incremented read pointer 
 scroll up delays 
 (infinite) delay 
 (infinite) delay 
 if next event would be in the past ... 
 unlock 
  audio data is transmitted from upper layer to the dsp
 todo: , l = skb->len; 
 check if there is enough space, and then copy 
 write-pointer should not overrun nor reach read pointer 
 write to the space we have left 
 end one byte prior tx_R 
 write until all byte are copied 
 show current buffer 
 copy transmit data to tx-buffer 
  hdlc data is received from card and sent to all members.
 not if not active 
 check if we have sompen 
 no conf 
 in case of software echo 
 in case of hardware conference 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2008  by Andreas Eversberg <andreas@eversberg.eu>
  Quick API description:
  A clock source registers using mISDN_register_clock:
 	name = text string to name clock source
 	priority = value to priorize clock sources (0 = default)
 	ctl = callback function to enabledisable clock source
 	priv = private pointer of clock source
 	return = pointer to clock source structure;
  Note: Callback 'ctl' can be called before mISDN_register_clock returns!
        Also it can be called during mISDN_unregister_clock.
  A clock source calls mISDN_clock_update with given samples elapsed, if
  enabled. If function call is delayed, tv must be set with the timestamp
  of the actual event.
  A clock source unregisters using mISDN_unregister_clock.
  To get current clock, call mISDN_clock_get. The signed short value
  counts the number of samples since. Time since last clock event is added.
 counter of last clock 
 time stamp of last clock 
 already received one timestamp 
 last used clock source still exists but changes, disable 
 new clock source selected, enable 
 no clock received yet 
 increment sample counter by given samples 
 timestamp must be set, if function call is delayed 
 calc elapsed time by system clock 
 timestamp must be set, if function call is delayed 
 add elapsed time to counter and set new timestamp 
 calc elapsed time by system clock 
 add elapsed time to counter 
  Blowfish encryptiondecryption for mISDN_dsp.
  Copyright Andreas Eversberg (jolly@eversberg.eu)
  This software may be used and distributed according to the terms
  of the GNU General Public License, incorporated herein by reference.
  how to encode a sample stream to 64-bit blocks that will be encryped
  first of all, data is collected until a block of 9 samples are received.
  of course, a packet may have much more than 9 sample, but is may have
  not excacly the multiple of 9 samples. if there is a rest, the next
  received data will complete the block.
  the block is then converted to 9 uLAW samples without the least sigificant
  bit. the result is a 7-bit encoded sample.
  the samples will be reoganised to form 8 bytes of data:
  (5(6) means: encoded sample no. 5, bit 6)
  0(6) 0(5) 0(4) 0(3) 0(2) 0(1) 0(0) 1(6)
  1(5) 1(4) 1(3) 1(2) 1(1) 1(0) 2(6) 2(5)
  2(4) 2(3) 2(2) 2(1) 2(0) 3(6) 3(5) 3(4)
  3(3) 3(2) 3(1) 3(0) 4(6) 4(5) 4(4) 4(3)
  4(2) 4(1) 4(0) 5(6) 5(5) 5(4) 5(3) 5(2)
  5(1) 5(0) 6(6) 6(5) 6(4) 6(3) 6(2) 6(1)
  6(0) 7(6) 7(5) 7(4) 7(3) 7(2) 7(1) 7(0)
  8(6) 8(5) 8(4) 8(3) 8(2) 8(1) 8(0)
  the missing bit 0 of the last byte is filled with some
  random noise, to fill all 8 bytes.
  the 8 bytes will be encrypted using blowfish.
  the result will be converted into 9 bytes. the bit 7 is used for
  checksumme (CS) for sync (0, 1) and for the last bit:
  (5(6) means: crypted byte 5, bit 6)
  1    0(7) 0(6) 0(5) 0(4) 0(3) 0(2) 0(1)
  0    0(0) 1(7) 1(6) 1(5) 1(4) 1(3) 1(2)
  0    1(1) 1(0) 2(7) 2(6) 2(5) 2(4) 2(3)
  0    2(2) 2(1) 2(0) 3(7) 3(6) 3(5) 3(4)
  0    3(3) 3(2) 3(1) 3(0) 4(7) 4(6) 4(5)
  CS   4(4) 4(3) 4(2) 4(1) 4(0) 5(7) 5(6)
  CS   5(5) 5(4) 5(3) 5(2) 5(1) 5(0) 6(7)
  CS   6(6) 6(5) 6(4) 6(3) 6(2) 6(1) 6(0)
  7(0) 7(6) 7(5) 7(4) 7(3) 7(2) 7(1) 7(0)
  the checksum is used to detect transmission errors and frame drops.
  synchronisation of received block is done by shifting the upper bit of each
  byte (bit 7) to a shift register. if the rigister has the first five bits
  (10000), this is used to find the sync. only if sync has been found, the
  current block of 9 received bytes are decrypted. before that the check
  sum is calculated. if it is incorrect the block is dropped.
  this will avoid loud noise due to corrupt encrypted data.
  if the last block is corrupt, the current decoded block is repeated
  until a valid block has been received.
   some blowfish parts are taken from the
  crypto-api for faster implementation
  Round loop unrolling macros, S is a pointer to a S-Box array
  organized in 4 unsigned longs at a row.
  encrypt isdn data frame
  every block with 9 samples is encrypted
 collect a block of 9 samples 
 transcode 9 samples xlaw to 8 bytes 
 fill unused bit with random noise of audio input 
 encrypt 
 calculate 3-bit checksumme 
		
		  transcode 8 crypted bytes to 9 data bytes with sync
		  and checksum information
 write current count 
  decrypt isdn data frame
  every block with 9 bytes is decrypted
		
		  shift upper bit and rotate data to buffer ring
		  send current decrypted data
 repeat if no sync has been found 
 check if not in sync 
 transcode receive data to 64 bit block of encrypted data 
 bit7 = 0 
 bit7 = 0 
 bit7 = 0 
 bit7 = 0 
 calculate 3-bit checksumme 
 check if frame is valid 
 decrypt 
 transcode 8 crypted bytes to 9 sample bytes 
 start with new decoded frame 
 write current count and sync 
 used to encrypt S and P boxes 
  initialize the dsp for encryption and decryption using the same key
  Calculates the blowfish S and P boxes for encryption and decryption.
  The margin of keylen must be 4-56 bytes.
  returns 0 if ok.
 Set dsp states 
 Copy the initialization s-boxes 
 Set the p-boxes 
 Actual subkey generation 
  turn encryption off
 SPDX-License-Identifier: GPL-2.0-or-later
  l1oip.c  low level driver for tunneling layer 1 over IP
  NOTE: It is not compatible with TDMoIP nor "ISDN over IP".
  Author	Andreas Eversberg (jolly@eversberg.eu)
 module parameters:
  type:
 Value 1	= BRI
 Value 2	= PRI
 Value 3 = BRI (multi channel frame, not supported yet)
 Value 4 = PRI (multi channel frame, not supported yet)
 A multi channel frame reduces overhead to a single frame for all
 b-channels, but increases delay.
 (NOTE: Multi channel frames are not implemented yet.)
  codec:
 Value 0 = transparent (default)
 Value 1 = transfer ALAW
 Value 2 = transfer ULAW
 Value 3 = transfer generic 4 bit compression.
  ulaw:
 0 = we use a-Law (default)
 1 = we use u-Law
  limit:
 limitation of B-channels to control bandwidth (1...126)
 BRI: 1 or 2
 PRI: 1-30, 31-126 (126, because dchannel ist not counted here)
 Also limited ressources are used for stack, resulting in less channels.
 It is possible to have more channels than 30 in PRI mode, this must
 be supported by the application.
  ip:
 byte representation of remote ip address (127.0.0.1 -> 127,0,0,1)
 If not given or four 0, no remote address is set.
 For multiple interfaces, concat ip addresses. (127,0,0,1,127,0,0,1)
  port:
 port number (local interface)
 If not given or 0, port 931 is used for fist instance, 932 for next...
 For multiple interfaces, different ports must be given.
  remoteport:
 port number (remote interface)
 If not given or 0, remote port equals local port
 For multiple interfaces on equal sites, different ports must be given.
  ondemand:
 0 = fixed (always transmit packets, even when remote side timed out)
 1 = on demand (only transmit packets, when remote side is detected)
 the default is 0
 NOTE: ID must also be set for on demand.
  id:
 optional value to identify frames. This value must be equal on both
 peers and should be random. If omitted or 0, no ID is transmitted.
  debug:
 NOTE: only one debug value must be given for all cards
 enable debugging (see l1oip.h for debug options)
 Special mISDN controls:
 op = MISDN_CTRL_SETPEER
 p1 = bytes 0-3 : remote IP address in network order (left element first)
 p2 = bytes 1-2 : remote port in network order (high byte first)
 optional:
 p2 = bytes 3-4 : local port in network order (high byte first)
 op = MISDN_CTRL_UNSETPEER
  Use l1oipctrl for comfortable setting or removing ip address.
 (Layer 1 Over IP CTRL)
 L1oIP-Protocol
 --------------
 Frame Header:
 7 6 5 4 3 2 1 0
 +---------------+
 |Ver|T|I|Coding |
 +---------------+
 |  ID byte 3   |
 +---------------+
 |  ID byte 2   |
 +---------------+
 |  ID byte 1   |
 +---------------+
 |  ID byte 0   |
 +---------------+
 |M|   Channel   |
 +---------------+
 |    Length    |
 +---------------+
 | Time Base MSB |
 +---------------+
 | Time Base LSB |
 +---------------+
 | Data....	|
 ...
 |               |
 +---------------+
 |M|   Channel   |
 +---------------+
 |    Length    |
 +---------------+
 | Time Base MSB |
 +---------------+
 | Time Base LSB |
 +---------------+
 | Data....	|
 ...
  Only included in some cases.
 - Ver = Version
 If version is missmatch, the frame must be ignored.
 - T = Type of interface
 Must be 0 for S0 or 1 for E1.
 - I = Id present
 If bit is set, four ID bytes are included in frame.
 - ID = Connection ID
 Additional ID to prevent Denial of Service attacs. Also it prevents hijacking
 connections with dynamic IP. The ID should be random and must not be 0.
 - Coding = Type of codec
 Must be 0 for no transcoding. Also for D-channel and other HDLC frames.
 1 and 2 are reserved for explicitly use of a-LAW or u-LAW codec.
 3 is used for generic table compressor.
 - M = More channels to come. If this flag is 1, the following byte contains
 the length of the channel data. After the data block, the next channel will
 be defined. The flag for the last channel block (or if only one channel is
 transmitted), must be 0 and no length is given.
 - Channel = Channel number
 0 reserved
 1-3 channel data for S0 (3 is D-channel)
 1-31 channel data for E1 (16 is D-channel)
 32-127 channel data for extended E1 (16 is D-channel)
 - The length is used if the M-flag is 1. It is used to find the next channel
 inside frame.
 NOTE: A value of 0 equals 256 bytes of data.
 -> For larger data blocks, a single frame must be used.
 -> For larger streams, a single frame or multiple blocks with same channel ID
 must be used.
 - Time Base = Timestamp of first sample in frame
 The "Time Base" is used to rearange packets and to detect packet loss.
 The 16 bits are sent in network order (MSB first) and count 18000 th of a
 second. This causes a wrap around each 8,192 seconds. There is no requirement
 for the initial "Time Base", but 0 should be used for the first packet.
 In case of HDLC data, this timestamp counts the packet or byte number.
 Two Timers:
 After initialisation, a timer of 15 seconds is started. Whenever a packet is
 transmitted, the timer is reset to 15 seconds again. If the timer expires, an
 empty packet is transmitted. This keep the connection alive.
 When a valid packet is received, a timer 65 seconds is started. The interface
 become ACTIVE. If the timer expires, the interface becomes INACTIVE.
 Dynamic IP handling:
 To allow dynamic IP, the ID must be non 0. In this case, any packet with the
 correct port number and ID will be accepted. If the remote side changes its IP
 the new IP is used for all transmitted packets until it changes again.
 On Demand:
 If the ondemand parameter is given, the remote IP is set to 0 on timeout.
 This will stop keepalive traffic to remote. If the remote is online again,
 traffic will continue to the remote address. This is useful for road warriors.
 This feature only works with ID set, otherwhise it is highly unsecure.
 Socket and Thread
 -----------------
 The complete socket opening and closing is done by a thread.
 When the thread opened a socket, the hc->socket descriptor is set. Whenever a
 packet shall be sent to the socket, the hc->socket must be checked whether not
 NULL. To prevent change in socket descriptor, the hc->socket_lock must be used.
 To change the socket, a recall of l1oip_socket_open() will safely kill the
 socket process and create a new one.
 0...3 
  send a frame via socket, if open and restart timer
 restart timer 
 drop if we have no remote ip or port 
 assemble frame 
 version and coding 
 type 
 id 
 id 
 m-flag, channel 
 time base 
 add data to frame 
 check for socket in safe condition 
 seize socket 
 send packet 
 give socket back 
 no locking required 
  receive channel data from socket
 prepare message 
 send message up 
 expand 16 bit sequence number to 32 bit sequence number 
 time has changed forward 
 time has changed backwards 
  parse frame and extract channel data
 initial frame length 
 check length 
 check version 
 check type 
 get id flag 
 check coding 
 check packet_id 
 get channel and multiframe flag 
 check length on multiframe 
 single frame, subtract timebase 
 get time base 
 if inactive, we send up a PH_ACTIVATE and activate 
 distribute packet 
 multiframe 
 restart timer 
 only adjust timer 
 if ip or source port changes 
  socket stuff
 allocate buffer memory 
 make daemon 
 create socket 
 set incoming address 
 set outgoing address 
 bind to incoming port 
 check sk 
 build send message 
 give away socket 
 read loop 
 get socket back, check first if in use, maybe by send function 
 if hc->socket is NULL, it is in use until it is given back 
 free recvbuf 
 close socket 
 if we got killed, signal completion 
 show termination of thread 
 kill thread 
 if active, we send up a PH_DEACTIVATE and deactivate 
 in case of reopen, we need to close first 
 create receive process 
 send an empty l1oip frame at D-channel 
  timer stuff
 state that timer must be initialized next time 
 if timeout, we send up a PH_DEACTIVATE and deactivate 
 if we have ondemand set, we remove ip address 
  message handling
 send frame 
			
			  This is technically bounded by L1OIP_MAX_PERFRAME but
			  MAX_DFRAME_LEN_L1 < L1OIP_MAX_PERFRAME
 BRI: 1=B1 2=B2  PRI: 1..15,17.. 
 b-channel can be only open once 
 check for AIS  ulaw-silence 
 check for silence 
 send frame 
			
			  This is technically bounded by L1OIP_MAX_PERFRAME but
			  MAX_DFRAME_LEN_L1 < L1OIP_MAX_PERFRAME
 fill features structure 
 create confirm 
  cleanup module and stack
  module and stack init
 as is 
 alaw 
 ulaw 
 4bit 
 TODO: create a parent device for this driver 
 two seconds first time 
 state that we have timer off 
 SPDX-License-Identifier: GPL-2.0-only
  finite state machine implementation
  Author       Karsten Keil <kkeil@novell.com>
  Thanks to    Jan den Ouden
               Fritz Elfert
  Copyright 2008  by Karsten Keil <kkeil@novell.com>
 SPDX-License-Identifier: GPL-2.0-only
  Author	Karsten Keil <kkeil@novell.com>
  Copyright 2008  by Karsten Keil <kkeil@novell.com>
 have still activ TEI 
 All TEI are inactiv 
 restart da timer 
 check again 
 have still activ TEI 
 All TEI are inactiv 
 only net send UI 
 SAPI 0 CR = 1 
 TEI 127 
 UI frame 
 CR:=1 for net command 
 same tei is in use 
 same tei is in use 
 and it wasn't our request 
 duplicate assignment; remove 
 T202  2 sec 
 We need open here L1 for the manager as well (refcounting) 
 Extension bit != 1 
 3GPP TS 08.56 6.1.11.2 
 not for us 
 EA0 formal error 
 EA1 formal error 
 not for us 
 not UI 
 not tei entity 
 dyn tei 
 T201  1 sec 
 T202  2 sec 
 We need open here L1 for the manager as well (refcounting) 
 not locked lock is taken in release tei 
 currently we only have one option 
 This function does create a L2 for fixed TEI in NT Mode 
 EA0 and CR must be  0 
 invalid EA1 
 not a fixed tei 
 We got a SABME for a fixed TEI 
 not locked lock is taken in release tei 
 save original header behind normal header 
 SPDX-License-Identifier: GPL-2.0-or-later
  l1oip_codec.c  generic codec using lookup table
   -> conversion from a-Law to u-Law
   -> conversion from u-Law to a-Law
   -> compression by reducing the number of sample resolution to 4
  NOTE: It is not compatible with any standard codec like ADPCM.
  Author	Andreas Eversberg (jolly@eversberg.eu)
  How the codec works:
  --------------------
  The volume is increased to increase the dynamic range of the audio signal.
  Each sample is converted to a-LAW with only 16 steps of level resolution.
  A pair of two samples are stored in one byte.
  The first byte is stored in the upper bits, the second byte is stored in the
  lower bits.
  To speed up compression and decompression, two lookup tables are formed:
  - 16 bits index for two samples (law encoded) with 8 bit compressed result.
  - 8 bits index for one compressed data with 16 bits decompressed result.
  NOTE: The bytes are handled as they are law-encoded.
 definitions of codec. don't use calculations, code may run slower. 
 alaw -> ulaw 
 ulaw -> alaw 
 alaw -> 4bit compression 
 4bit -> alaw decompression 
 ulaw -> 4bit compression 
 4bit -> ulaw decompression 
  Compresses data to the result buffer
  The result size must be at least half of the input buffer.
  The number of samples also must be even!
 send saved byte and first input byte 
 if len has an odd number, we save byte for next call 
 Decompress data to the result buffer
  The result size must be the number of sample in packet. (2  input data)
  The number of samples in the result are even!
  law conversion
  generatefree compression and decompression table
 in case, it is called again 
 alloc conversion tables 
 generate compression table 
 generate decompression table 
  Audio support data for ISDN4Linux.
  Copyright Andreas Eversberg (jolly@eversberg.eu)
  This software may be used and distributed according to the terms
  of the GNU General Public License, incorporated herein by reference.
 tones loops 
 all tones are alaw encoded 
 the last sample+1 is in phase with the first sample. the error is low 
  generate ulaw from alaw samples 
  tone sequence definition 
  copy tone data 
 an sk_buff is generated from the number of samples needed.
  the count will be changed and may begin from 0 each pattern period.
  the clue is to precalculate the pointers and legths to use only one
  memcpy per function call, or two memcpy if the tone sequence changes.
  pattern - the type of the pattern
  count - the sample from the beginning of the pattern (phase)
  len - the number of bytes
  return - the sk_buff with the sample
  if tones has finished (e.g. knocking tone), dsp->tones is turned off
 if we have no tone, we copy silence 
 process pattern 
 points to the current pattern 
 gives current sequence index 
 gives current sample 
 copy sample 
 find sample to start with 
 wrap around 
 check if we are currently playing this tone 
 calculate start and number of samples 
 copy memory 
 reduce length 
 return sk_buff 
  send HW message to hfc card 
 unlocking is not required, because we don't expect a response 
  timer expires 
 set next tone 
 set timer 
  setrelease tone 
  tones are relaized by streaming or by special loop commands if supported
  by hardware. when hardware is used, the patterns will be controlled by
  timers.
 we turn off the tone 
 set first tone 
 set timer 
  Audio support data for mISDN_dsp.
  Copyright 20022003 by Andreas Eversberg (jolly@eversberg.eu)
  Rewritten by Peter
  This software may be used and distributed according to the terms
  of the GNU General Public License, incorporated herein by reference.
 ulaw[unsigned char] -> signed 16-bit 
 alaw[unsigned char] -> signed 16-bit 
 signed 16-bit -> law 
 alaw -> ulaw 
 ulaw -> alaw 
  generate table for conversion of s16 to alawulaw 
 Sign (7th) bit = 1 
 Sign bit = 0 
 Convert the scaled magnitude to segment number. 
 Combine the sign, segment, and quantization bits. 
 rounding error ;
!< define the add-in bias for 16 bit samples 
 Get the sample into sign-magnitude. 
 set aside the sign 
 get magnitude 
 Convert from 16 bit linear to ulaw. 
 generating ulaw-table 
 generating alaw-table 
  the seven bit sample is the number of every second alaw-sample ordered by
  aplitude. 0x00 is negative, 0x7f is positive amplitude.
  generate table for conversion law fromto 7-bit alaw-like sample 
 generate alaw table, sorted by the linear value 
 generate tabels 
 spl is the source: the law-sample (converted to alaw) 
 find the 7-bit-sample 
 write 7-bit audio value 
 mix 2law -> law 
  generate mix table to mix two law samples into one 
  generate different volume changes 
  change the volume of the given skb 
 this is a helper function for changing volume of skb. the range may be
  -8 to 8, which is a shift to the power of 2. 0 == no volume, 3 == volume8
 get correct conversion table 
 change volume 
 SPDX-License-Identifier: GPL-2.0-only
  Author	Karsten Keil <kkeil@novell.com>
  Copyright 2008  by Karsten Keil <kkeil@novell.com>
 L2 for all 
 broadcast not handled yet 
 test if a race happens 
 can't fail 
 SPDX-License-Identifier: GPL-2.0-only
  Author	Karsten Keil <kkeil@novell.com>
  Copyright 2008  by Karsten Keil <kkeil@novell.com>
 do not force anything here, we need send INFO 0 
 Tell HW to send INFO 1 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2008  by Karsten Keil <kkeil@novell.com>
 nothing to do: the device is part of its parent's data structure 
 hangs 
 do nothing, it's static 
 sysfs_remove_link(&dev->dev.kobj, "device"); 
 SPDX-License-Identifier: GPL-2.0-only
  general timer device for using in ISDN stacks
  Author	Karsten Keil <kkeil@novell.com>
  Copyright 2008  by Karsten Keil <kkeil@novell.com>
 protect lists 
 it might have been moved to ->expired 
 SPDX-License-Identifier: GPL-2.0-or-later
  dsp_pipeline.c: pipelined audio processing
  Copyright (C) 2007, Nadi Sarrar
  Nadi Sarrar <nadi@beronet.com>
 sysfs 
					 This is a hack to make the hwec
  Author       Andreas Eversberg (jolly@eversberg.eu)
  Based on source code structure by
 		Karsten Keil (keil@isdn4linux.de)
 		This file is (c) under GNU PUBLIC LICENSE
  Thanks to    Karsten Keil (great drivers)
               Cologne Chip (great chips)
  This module does:
 		Real-time tone generation
 		DTMF detection
 		Real-time cross-connection and conferrence
 		Compensate jitter due to system load and hardware fault.
 		All features are done in kernel space and will be realized
 		using hardware, if available and supported by chip set.
 		Blowfish encryptiondecryption
 STRUCTURE:
  The dsp module provides layer 2 for b-channels (64kbit). It provides
  transparent audio forwarding with special digital signal processing:
  - (1) generation of tones
  - (2) detection of dtmf tones
  - (3) crossconnecting and conferences (clocking)
  - (4) echo generation for delay test
  - (5) volume control
  - (6) disable receive data
  - (7) pipeline
  - (8) encryptiondecryption
  Look:
              TX            RX
          ------upper layer------
              |             ^
              |             |(6)
              v             |
        +-----+-------------+-----+
        |(3)(4)                   |
        |           CMX           |
        |                         |
        |           +-------------+
        |           |       ^
        |           |       |
        |+---------+|  +----+----+
        ||(1)      ||  |(2)      |
        ||         ||  |         |
        ||  Tones  ||  |  DTMF   |
        ||         ||  |         |
        ||         ||  |         |
        |+----+----+|  +----+----+
        +-----+-----+       ^
              |             |
              v             |
         +----+----+   +----+----+
         |(5)      |   |(5)      |
         |         |   |         |
         |TX Volume|   |RX Volume|
         |         |   |         |
         |         |   |         |
         +----+----+   +----+----+
              |             ^
              |             |
              v             |
         +----+-------------+----+
         |(7)                    |
         |                       |
         |  Pipeline Processing  |
         |                       |
         |                       |
         +----+-------------+----+
              |             ^
              |             |
              v             |
         +----+----+   +----+----+
         |(8)      |   |(8)      |
         |         |   |         |
         | Encrypt |   | Decrypt |
         |         |   |         |
         |         |   |         |
         +----+----+   +----+----+
              |             ^
              |             |
              v             |
          ------card  layer------
              TX            RX
  Above you can see the logical data flow. If software is used to do the
  process, it is actually the real data flow. If hardware is used, data
  may not flow, but hardware commands to the card, to provide the data flow
  as shown.
  NOTE: The channel must be activated in order to make dsp work, even if
  no data flow to the upper layer is intended. Activation can be done
  after and before controlling the setting using PH_CONTROL requests.
  DTMF: Will be detected by hardware if possible. It is done before CMX
  processing.
  Tones: Will be generated via software if endless looped audio fifos are
  not supported by hardware. Tones will override all data from CMX.
  It is not required to join a conference to use tones at any time.
  CMX: Is transparent when not used. When it is used, it will do
  crossconnections and conferences via software if not possible through
  hardware. If hardware capability is available, hardware is used.
  Echo: Is generated by CMX and is used to check performance of hard and
  software CMX.
  The CMX has special functions for conferences with one, two and more
  members. It will allow different types of data flow. Receive and transmit
  data toform upper layer may be switched onoff individually without losing
  features of CMX, Tones and DTMF.
  Echo Cancellation: Sometimes we like to cancel echo from the interface.
  Note that a VoIP call may not have echo caused by the IP phone. The echo
  is generated by the telephone line connected to it. Because the delay
  is high, it becomes an echo. RESULT: Echo Cachelation is required if
  both echo AND delay is applied to an interface.
  Remember that software CMX always generates a more or less delay.
  If all used features can be realized in hardware, and if transmit andor
  receive data ist disabled, the card may not sendreceive any data at all.
  Not receiving is useful if only announcements are played. Not sending is
  useful if an answering machine records audio. Not sending and receiving is
  useful during most states of the call. If supported by hardware, tones
  will be played without cpu load. Small PBXs and NT-Mode applications will
  not need expensive hardware when processing calls.
  LOCKING:
  When data is received from upper or lower layer (card), the complete dsp
  module is locked by a global lock.  This lock MUST lock irq, because it
  must lock timer events by DSP poll timer.
  When data is ready to be transmitted down, the data is queued and sent
  outside lock and timer event.
  PH_CONTROL must not change any settings, join or split conference members
  during process of data.
  HDLC:
  It works quite the same as transparent, except that HDLC data is forwarded
  to all other conference members if no hardware bridging is possible.
  Send data will be writte to sendq. Sendq will be sent if confirm is received.
  Conference cannot join, if one member is not hdlc.
int spinnest = 0;
 global dsp lock 
 check if rx may be turned off or must be turned on 
 not disabled 
 software dtmf 
 echo in software 
 bridge in software 
	 data is not required by user space and not required
 no conf 
 check all members in conf 
 enable "fill empty" feature 
 turn on DTMF 
 init goertzel 
 check dtmf hardware 
 turn off DTMF 
 join  update conference 
 dsp_cmx_hardware will also be called here 
 remove from conference 
 dsp_cmx_hardware will also be called here 
 play tone 
 stop tone 
 reset tx buffers (user space data) 
 change volume 
 change volume 
 enable echo 
 soft echo 
 disable echo 
 enable receive to user space 
 disable receive to user space 
 enable mixing of tx data 
 disable mixing of tx data 
 enable txdata 
 disable txdata 
	case DSP_DELAY:  use delay algorithm instead of dynamic
 milliseconds to samples 
			 clip to half of maximum usable buffer
	case DSP_JITTER:  use dynamic jitter algorithm instead of
 use dynamic jitter algorithm for tx-buffer 
 use tx-buffer without dejittering
 turn blowfish on 
 set new cont 
 send indication if it worked to set it 
 turn blowfish off 
 FROM DOWN 
 trigger next hdlc frame, if any 
 hdlc 
 if receive is not allowed 
 decrypt if enabled 
 pipeline 
 change volume if requested 
 check if dtmf soft decoding is turned on 
 we need to process receive data if software 
 process data from card at cmx 
 send dtmf result, if any 
 if receive is not allowed 
 getting coefficients 
 change volume 
 bchannel now active 
 rx_W and rx_R will be adjusted on first frame 
 send activation to upper layer 
 bchannel now inactive 
 FROM UP 
 hdlc 
 send data to tx-buffer (if no tone is played) 
 enable fill_empty feature 
 send ph_activate 
			dsp_cmx_conf(dsp, 0);  dsp_cmx_hardware will also be
		 wait until workqueue has finished,
		  must lock here, or we may hit send-process currently
 MUST not be locked, because it waits until queue is done. 
		dsp_cmx_conf(dsp, 0);  dsp_cmx_hardware will also be called
 wait until data has been acknowledged 
 send queued data 
 in locked date, we must have still data in queue 
 flush transparent data, if not acked 
 send packet up 
 send packet down 
 default enabled 
 set frame size to start 
 current PCM id 
 current PCM id 
 current CPM slot 
 current conference number 
 set tone timer 
 init pipeline append to list 
 set packet size 
 init conversion tables 
 set sample timer 
 SPDX-License-Identifier: GPL-2.0-or-later
  dsp_hwec.c:
  builtin mISDN dsp pipeline element for enabling the hw echocanceller
  Copyright (C) 2007, Nadi Sarrar
  Nadi Sarrar <nadi@beronet.com>
  DTMF decoder.
  Copyright            by Andreas Eversberg (jolly@eversberg.eu)
 			based on different decoders such as ISDN4Linux
  This software may be used and distributed according to the terms
  of the GNU General Public License, incorporated herein by reference.
 number of frequencies to be analyzed 
 For DTMF recognition:
  2  cos(2  PI  k  N) precalculated for all k
 k << 15 (source: hfc-4s8s documentation (www.colognechip.de)) 
 digit matrix 
 dtmf detection using goertzel algorithm
  init function
 check for hardware or software features
 check for volume change 
 check if encryption is enabled 
 check if pipeline exists 
  calculate the coefficients of the given sample and decode 
 the given sample is decoded. if the sample is not long enough for a
  complete frame, the decoding is finished and continued with the next
  call of this function.
  the algorithm is very good for detection with a minimum of errors. i
  tested it allot. it even works with very short tones (40ms). the only
  disadvantage is, that it doesn't work good with different volumes of both
  tones. this will happen, if accoustically coupled dialers are used.
  it sometimes detects tones during speech, which is normal for decoders.
  use sequences to given commands during calls.
  dtmf - points to a structure of the current dtmf state
  spl and len - the sample
  fmt - 0 = alaw, 1 = ulaw, 2 = coefficients from HFC DTMF hw-decoder
	 Note: The function will loop until the buffer has not enough samples
	  left to decode a full frame.
 convert samples 
 alaw 
 ulaw 
 HFC coefficients 
 compute |X(k)|2 
 now we have a full buffer of signed long samples - we do goertzel 
 compute |X(k)|2 
	 our (squared) coefficients have been calculated, we need to process
	  them.
 calc digit (lowgrouphighgroup) 
 tones which are not on, must be below 9 dB 
 touchtones must match within 6 dB 
 ignore 
 noise in between 
 good level found. This is allowed only one time per group 
 lowgroup 
 Bad. Another tone found. 
 higroup 
 Bad. Another tone found. 
 get digit or null 
 the tone (or no tone) must remain 3 times without change 
 SPDX-License-Identifier: GPL-2.0-only
  Author	Karsten Keil <kkeil@novell.com>
  Copyright 2008  by Karsten Keil <kkeil@novell.com>
 read back dropped byte count 
 we return the old values 
 at least 2 for sapi  tei 
 at least 2 for sapi  tei 
 if allocation did fail upper functions still may call us 
		 we have no data to send - this may happen after recovery
		  from overflow or too small allocation.
 confirm imediately to allow next data 
 check oversize 
 HW lock must be obtained 
 write to fifo 
 check oversize 
 HW lock must be obtained 
 check for pending next_skb 
 write to fifo 
 The function allocates a new receive skb on demand with a size for the
  requirements of the current protocol. It returns the tailroom of the
  receive skb or an error.
 send what we have now and try a new buffer 
 on HDLC we have to drop too big frames 
 update current minmax length first 
 with HDLC we do not know the length yet 
 SPDX-License-Identifier: GPL-2.0-only
  Author	Karsten Keil <kkeil@novell.com>
  Copyright 2008  by Karsten Keil <kkeil@novell.com>
 tei 127 
 		in states 1-3 for broadcast
		mISDN_queue_data(&l2->inst, l2->inst.id | MSG_BROADCAST,
 		    MGR_SHORTSTATUS | INDICATION, SSTATUS_L2_ESTABLISHED,
 		    0, NULL, 0);
 n(s)!=v(r) 
 I or S 
	mISDN_queue_data(&l2->inst, l2->inst.id | MSG_BROADCAST,
 		MGR_SHORTSTATUS_IND, SSTATUS_L2_RELEASED,
 		0, NULL, 0);
 Maybe not needed 
 not our business 
 not our business 
 I-Frame 
 S-Frame 
 saved copy 
 ETS 300-125 5.3.2.1 Test: TC13010 
 SPDX-License-Identifier: GPL-2.0-only
  Author	Karsten Keil <kkeil@novell.com>
  Copyright 2008  by Karsten Keil <kkeil@novell.com>
 if we have a address, we use it 
 use default for L2 messages 
 SPDX-License-Identifier: GPL-2.0-only
  isac.c   ISAC specific routines
  Author       Karsten Keil <keil@isdn4linux.de>
  Copyright 2009  by Karsten Keil <keil@isdn4linux.de>
 Restart frame 
 should not happen 
 dummy to avoid warning 
 RME 
 RPF 
 XPR 
 CISQ 
 RSC - never 
 SIN - never 
 EXI 
 XMR 
 XDU 
 MOS 
 direct TX 
 skb can be freed 
 TODO: implement for IPAC_TYPE_ISACX 
 B1 
 B2 
 we only support IOM2 mode 
 D-Channel Busy 
 discard frame; reset transceiver 
 Transmitter reset 
 E-Channel not supported 
 Disable all IRQ 
 clear LDD 
 enable transmitter 
 transparent mode 0, RAC, stopgo 
 all HDLC IRQ unmasked 
 old isac 
 only IOM 2 Mode 
 RMC 
 RMC 
 RMC 
 !(VFR && !RDO && CRC && !RAB) 
 Do RMC 
 HSCX B 
 HSCX A 
 RRES 
 XRES 
 ISAC EXI 
 only for ISACHSCX without PCI IRQ test 
 B1 and ICA 
 B2 and ICB 
 init 
 rec off 
 std adj. 
 ints off 
 ex trans 
 trans 
 trans 
 hdlc,crc 
 IPAC 
 ints off 
 ex trans 
 HSCX 
 ints off 
 ex trans 
 direct TX 
 conf is default 0, but can be overwritten by card setup 
 nothing special for IPACX to do here 
 b-channel can be only open once 
 cq->channel: 0 disable, 1 B1 loop 2 B2 loop, 3 both 
		 default values for IOM time slots
 SPDX-License-Identifier: GPL-2.0-only
  speedfax.c	low level stuff for Sedlbauer Speedfax+ cards
 		based on the ISAR DSP
 		Thanks to Sedlbauer AG for informations and HW
  Author       Karsten Keil <keil@isdn4linux.de>
  Copyright 2009  by Karsten Keil <keil@isdn4linux.de>
 TIGER 100 Registers 
 Tiger AUX BITs 
 1 and 5 are inputs 
 HW access lock 
 protect Cards 
 for us or shared ? 
 shared 
 cq->channel: 0 disable, 1 B1 loop 2 B2 loop, 3 both 
 RESET Receiver and Transmitter 
 SPDX-License-Identifier: GPL-2.0-or-later
  hfcpci.c     low level driver for CCD's hfc-pci based cards
  Author     Werner Cornelius (werner@isdn4linux.de)
             based on existing driver for CCD hfc ISA cards
             type approval valid for HFC-S PCI A based card
  Copyright 1999  by Werner Cornelius (werner@isdn-development.de)
  Copyright 2008  by Karsten Keil <kkeil@novell.com>
  Module options:
  debug:
 	NOTE: only one poll value must be given for all cards
 	See hfc_pci.h for debug flags.
  poll:
 	NOTE: only one poll value must be given for all cards
 	Give the number of samples for each fifo process.
 	By default 128 is used. Decrease to reduce delay, increase to
 	reduce cpu load. If unsure, don't mess with it!
 	A value of 128 will use controller's interrupt. Other values will
 	use kernel timer, because the controller will not allow lower values
 	than 128.
 	Also note that the value depends on the kernel timer frequency.
 	If kernel uses a frequency of 1000 Hz, steps of 8 samples are possible.
 	If the kernel uses 100 Hz, steps of 80 samples are possible.
 	If the kernel uses 300 Hz, steps of about 26 samples are possible.
 start of PCI IO memory 
 FIFO memory 
 marker saving last b-fifo frame count 
 number of 3.125ms interrupts (3.5s) 
 number of 3.125ms interrupts (97 ms) 
 CLKDEL in TE mode 
 CLKDEL in NT mode 
 card lock 
 Interface functions 
  free hardware resources used by driver
 disable memory mapped ports + busmaster 
  set mode (NT or TE)
 ST-Bit delay for NT-Mode 
 NT-MODE 
 G1 
 ST-Bit delay for TE-Mode 
 TE-MODE 
 F2 
 Deactivate 
  function called to reset the HFC PCI chip. A complete software reset of chip
  and fifos is done.
 enable memory mapped ports, disable busmaster 
 enable memory ports + busmaster 
 Reset On 
 Timeout 10ms 
 Reset Off 
 max 50000 us 
 only D fifos enabled 
 no exchange 
 no echo connect , threshold 
 set tx_lo mode, error in datasheet ! 
 ST Auto awake 
 HFC Master Mode 
 Clear already pending ints 
 set NTTE mode 
	
	  Init GCIIOM2 in master mode
	  Slots 0 and 1 are set for B-chan 1 and 2
	  D- and monitorCI channel are not enabled
	  STIO1 is used as output for data, B1+B2 from ST->IOM+HFC
	  STIO2 is used as data input, B1+B2 from IOM->ST
	  ST B-channel send disabled -> continuous 1s
	  The IOM slots are always enabled
 set data flow directions: connect B1,B2: HFC tofrom PCM 
 set data flow directions 
  Timer function called when kernel timer expires
 WD RESET 
 	WriteReg(hc, HFCD_DATA, HFCD_CTMT, hc->hw.ctmt | 0x80);
 	add_timer(&hc->hw.timer);
  select a b-channel entry matching and active
  clear the desired B-channel rx fifo
 init F pointers to remain constant 
  clear the desired B-channel tx fifo
 init F pointers to remain constant 
  read a complete B-frame out of the buffer
 point to Z-Regs 
 new position in fifo 
 buffer wrap 
 next buffer 
 complete transfer 
 maximum 
 start of data 
 copy data 
 rest remaining 
 start of buffer 
 rest 
 next buffer 
  D-channel receive procedure
 next buffer 
 complete transfer 
 maximum 
 start of data 
 copy data 
 rest remaining 
 start of buffer 
 rest 
 next buffer 
  check for transparent receive data and read max one 'poll' size if avail
 pointer to z reg 
 no data avail 
 bytes actually buffered 
 new position in fifo 
 buffer wrap 
 fcnt_tx contains available bytes in tx-fifo 
 remaining bytes to send (bytes in tx-fifo) 
 complete transfer 
 maximum 
 start of data 
 copy data 
 rest remaining 
 start of buffer 
 rest 
 bch, id, !force 
 new position 
  B-channel main receive routine
  D-channel send routine
 frame count actually buffered 
 if wrap around 
 now determine free bytes in FIFO buffer 
 count now contains available bytes 
 source pointer 
 end fifo 
 limit size 
 first copy 
 remaining bytes 
 start of buffer 
 new position 
 for next buffer 
 new pos actual buffer 
 next frame 
  B-channel send routine
 fcnt contains available bytes in fifo 
 new buffer Position 
 buffer wrap 
 end of fifo 
 limit size 
 first copy 
 remaining bytes 
 start of buffer 
 now send data 
 fcnt contains available bytes in fifo 
 remaining bytes to send (bytes in fifo) 
 maximum fill shall be poll2 
 data is suitable for fifo 
 new buffer Position 
 buffer wrap 
 source pointer 
 end of fifo 
 limit size 
 first copy 
 remaining bytes 
 start of buffer 
 new position 
 now send data 
 frame count actually buffered 
 if wrap around 
 now determine free bytes in FIFO buffer 
 count now contains available bytes 
 new buffer Position 
 buffer wrap 
 source pointer 
 end fifo 
 limit size 
 first copy 
 remaining bytes 
 start of buffer 
 new position 
 for next buffer 
 next frame 
  handle L1 state changes TE
  handle L1 state changes NT
 Clear already pending ints 
 allow G2 -> G3 transition 
  Layer 1 callback function
 HFC ST 3 
 HFC ST 2 
  Interrupt handler
 not initialised 
 shared 
 state machine irq 
 timer irq 
 B1 rx 
 B2 rx 
 B1 tx 
 B2 tx 
 D rx 
 D tx 
  timer callback for D-chan busy resolution. Currently no function
  activatedeactivate hardware for selected channels and mode
 PCM SLOT USE 
 B1 and B2 normal mode 
 B1 and B2 exchanged 
 B1 and B2 normal mode 
 B1 and B2 normal mode 
 used for init 
 init case 
  Layer 1 B-channel hardware access
  Layer2 -> Layer 1 Dchannel data
 direct TX 
 skb can be freed 
 prepare deactivation 
  Layer2 -> Layer 1 Bchannel data
 direct TX 
  called for card init message
		
		  Finally enable IRQ output
		  this is only allowed, if an IRQ routine is already
		  established for this HFC, so don't do that earlier
 Timeout 80ms 
 now switch timer interrupt off 
 reinit mode reg 
 channel 0 disabled loop 
 enable IOM-loop 
 disable IOM-loop 
 disable IOM-loop 
 TODO: E-Channel 
 b-channel can be only open once 
 TODO: E-channel 
  device control function
 Allocate memory for FIFOS 
 the memory needs to be on a 32k boundary within the first 4G 
 We silently assume the address is okay if nonzero 
 enable memory mapped ports, disable busmaster 
 At this point the needed PCI config is done 
 fifos are still not enabled 
 default PCM master 
 interrupt output off ! 
 must release after free_irq! 
 private data in the PCI devices list 
 B1 rx&tx 
 B2 rx&tx 
 if next event would be in the past ... 
 indicate the use of controller's timer 
 SPDX-License-Identifier: GPL-2.0-only
  avm_fritz.c    low level stuff for AVM FRITZ!CARD PCI ISDN cards
                 Thanks to AVM, Berlin for informations
  Author       Karsten Keil <keil@isdn4linux.de>
  Copyright 2009  by Karsten Keil <keil@isdn4linux.de>
 Fritz PCI v2.0 
 data struct 
 hw lock 
 protect Cards 
 Interface functions 
 dummy 
 used for init 
 all bytes the same - no worry about endian 
		 Here we lost an TX interrupt, so
		  restart transmitting the whole frame on HDLC
		  in transparent mode we send the next data
 shared  IRQ from other HW 
 shared  IRQ from other HW 
 direct TX 
 disable IRQ 
 RESET Receiver and Transmitter 
 Timeout 10ms 
 cq->channel: 0 disable, 1 B1 loop 2 B2 loop, 3 both 
 b-channel can be only open once 
  device control function
 SPDX-License-Identifier: GPL-2.0-or-later
  hfcmulti.c  low level driver for hfc-4shfc-8shfc-e1 based cards
  Author	Andreas Eversberg (jolly@eversberg.eu)
  ported to mqueue mechanism:
 		Peter Sprenger (sprengermoving-bytes.de)
  inspired by existing hfc-pci driver:
  Copyright 1999  by Werner Cornelius (werner@isdn-development.de)
  Copyright 2008  by Karsten Keil (kkeil@suse.de)
  Copyright 2008  by Andreas Eversberg (jolly@eversberg.eu)
  Thanks to Cologne Chip AG for this great controller!
  module parameters:
  type:
 	By default (0), the card is automatically detected.
 	Or use the following combinations:
 	Bit 0-7   = 0x00001 = HFC-E1 (1 port)
  or	Bit 0-7   = 0x00004 = HFC-4S (4 ports)
  or	Bit 0-7   = 0x00008 = HFC-8S (8 ports)
 	Bit 8     = 0x00100 = uLaw (instead of aLaw)
 	Bit 9     = 0x00200 = Disable DTMF detect on all B-channels via hardware
 	Bit 10    = spare
 	Bit 11    = 0x00800 = Force PCM bus into slave mode. (otherwhise auto)
  or   Bit 12    = 0x01000 = Force PCM bus into master mode. (otherwhise auto)
 	Bit 13	  = spare
 	Bit 14    = 0x04000 = Use external ram (128K)
 	Bit 15    = 0x08000 = Use external ram (512K)
 	Bit 16    = 0x10000 = Use 64 timeslots instead of 32
  or	Bit 17    = 0x20000 = Use 128 timeslots instead of anything else
 	Bit 18    = spare
 	Bit 19    = 0x80000 = Send the Watchdog a Signal (Dual E1 with Watchdog)
  (all other bits are reserved and shall be 0)
 	example: 0x20204 one HFC-4S with dtmf detection and 128 timeslots on PCM
 		 bus (PCM master)
  port: (optional or required for all ports on all installed cards)
 	HFC-4SHFC-8S only bits:
 	Bit 0	  = 0x001 = Use master clock for this ST interface
 			    (ony once per chip).
 	Bit 1     = 0x002 = transmitter line setup (non capacitive mode)
 			    Don't use this unless you know what you are doing!
 	Bit 2     = 0x004 = Disable E-channel. (No E-channel processing)
 	example: 0x0001,0x0000,0x0000,0x0000 one HFC-4S with master clock
 		 received from port 1
 	HFC-E1 only bits:
 	Bit 0     = 0x0001 = interface: 0=copper, 1=optical
 	Bit 1     = 0x0002 = reserved (later for 32 B-channels transparent mode)
 	Bit 2     = 0x0004 = Report LOS
 	Bit 3     = 0x0008 = Report AIS
 	Bit 4     = 0x0010 = Report SLIP
 	Bit 5     = 0x0020 = Report RDI
 	Bit 8     = 0x0100 = Turn off CRC-4 Multiframe Mode, use double frame
 			     mode instead.
 	Bit 9	  = 0x0200 = Force get clock from interface, even in NT mode.
  or	Bit 10	  = 0x0400 = Force put clock to interface, even in TE mode.
 	Bit 11    = 0x0800 = Use direct RX clock for PCM sync rather than PLL.
 			     (E1 only)
 	Bit 12-13 = 0xX000 = elastic jitter buffer (1-3), Set both bits to 0
 			     for default.
  (all other bits are reserved and shall be 0)
  debug:
 	NOTE: only one debug value must be given for all cards
 	enable debugging (see hfc_multi.h for debug options)
  poll:
 	NOTE: only one poll value must be given for all cards
 	Give the number of samples for each fifo process.
 	By default 128 is used. Decrease to reduce delay, increase to
 	reduce cpu load. If unsure, don't mess with it!
 	Valid is 8, 16, 32, 64, 128, 256.
  pcm:
 	NOTE: only one pcm value must be given for every card.
 	The PCM bus id tells the mISDNdsp module about the connected PCM bus.
 	By default (0), the PCM bus id is 100 for the card that is PCM master.
 	If multiple cards are PCM master (because they are not interconnected),
 	each card with PCM master will have increasing PCM id.
 	All PCM busses with the same ID are expected to be connected and have
 	common time slots slots.
 	Only one chip of the PCM bus must be master, the others slave.
 	-1 means no support of PCM bus not even.
 	Omit this value, if all cards are interconnected or none is connected.
 	If unsure, don't give this parameter.
  dmask and bmask:
 	NOTE: One dmask value must be given for every HFC-E1 card.
 	If omitted, the E1 card has D-channel on time slot 16, which is default.
 	dmask is a 32 bit mask. The bit must be set for an alternate time slot.
 	If multiple bits are set, multiple virtual card fragments are created.
 	For each bit set, a bmask value must be given. Each bit on the bmask
 	value stands for a B-channel. The bmask may not overlap with dmask or
 	with other bmask values for that card.
 	Example: dmask=0x00020002 bmask=0x0000fffc,0xfffc0000
 		This will create one fragment with D-channel on slot 1 with
 		B-channels on slots 2..15, and a second fragment with D-channel
 		on slot 17 with B-channels on slot 18..31. Slot 16 is unused.
 	If bit 0 is set (dmask=0x00000001) the D-channel is on slot 0 and will
 	not function.
 	Example: dmask=0x00000001 bmask=0xfffffffe
 		This will create a port with all 31 usable timeslots as
 		B-channels.
 	If no bits are set on bmask, no B-channel is created for that fragment.
 	Example: dmask=0xfffffffe bmask=0,0,0,0.... (31 0-values for bmask)
 		This will create 31 ports with one D-channel only.
 	If you don't know how to use it, you don't need it!
  iomode:
 	NOTE: only one mode value must be given for every card.
 	-> See hfc_multi.h for HFC_IO_MODE_ values
 	By default, the IO mode is pci memory IO (MEMIO).
 	Some cards require specific IO mode, so it cannot be changed.
 	It may be useful to set IO mode to register io (REGIO) to solve
 	PCI bridge problems.
 	If unsure, don't give this parameter.
  clockdelay_nt:
 	NOTE: only one clockdelay_nt value must be given once for all cards.
 	Give the value of the clock control register (A_ST_CLK_DLY)
 	of the ST interfaces in NT mode.
 	This register is needed for the TBR3 certification, so don't change it.
  clockdelay_te:
 	NOTE: only one clockdelay_te value must be given once
 	Give the value of the clock control register (A_ST_CLK_DLY)
 	of the ST interfaces in TE mode.
 	This register is needed for the TBR3 certification, so don't change it.
  clock:
 	NOTE: only one clock value must be given once
 	Selects interface with clock source for mISDN and applications.
 	Set to card number starting with 1. Set to -1 to disable.
 	By default, the first card is used as clock source.
  hwid:
 	NOTE: only one hwid value must be given once
 	Enable special embedded devices with XHFC controllers.
  debug register access (never use this, it will flood your system log)
  #define HFC_REGISTER_DEBUG
  #define IRQCOUNT_DEBUG
  #define IRQ_DEBUG
 global hfc list lock 
 if we have a master card (yet) 
 may not acquire other lock inside 
 default = 128 samples = 16ms 
 number of POLL_TIMER interrupts for G2 timeout (ca 1s) 
 CLKDEL in TE mode 
#define	CLKDEL_NT	0x6c	 CLKDEL in NT mode
 DIP Switches for Beronet 1S2S4S cards 
 DIP Switches for Beronet 8S+ cards 
 DIP Switches for Beronet E1 cards 
  module stuff
 The hardware ID 
 HFC_IO_MODE_PCIMEM 
 HFC_IO_MODE_REGIO 
 write fifo data (REGIO) 
 write fifo data (PCIMEM) 
 read fifo data (REGIO) 
 read fifo data (PCIMEM) 
 was _io before 
 was _io before 
 slow down a PCI read access by 1 PCI clock cycle 
was _io before
 select local bridge port address by writing to CIP port 
 data = HFC_inb(c, cipv);  was _io before 
 restore R_CTRL for normal PCI read cycle speed 
 was _io before 
 select local bridge port address by writing to CIP port 
 define a 32 bit dword with 4 identical bytes for write sequence 
	
	  write this 32 bit dword to the bridge data port
	  this will initiate a write sequence of up to 4 writes to the same
	  address on the local bus interface the number of write accesses
	  is undefined but >=1 and depends on the next PCI transaction
	  during write sequence on the local bus
 Do data pin read low byte 
 Do data pin read low byte 
 Setup GPIO's 
 GPIO out 
 GPIO dir 
 GPIO sel 
 Setup TDM path - sets fsync and tdm_clk as inputs 
 misc_con 
 Setup Echo length (256 taps) 
 Setup timeslots 
 Setup the tdm channel masks for all chips 
 Setup convergence rate 
vpm_out(wc, x, 0x20, (0x00 | 0x08 | 0x20 | 0x10)); 
 Initialize echo cans 
		
		  ARM arch at least disallows a udelay of
		  more than 2ms... it gives a fake "__bad_udelay"
		  reference at link-time.
		  long delays in kernel code are pretty sucky anyway
		  for now work around it using 5 x 2ms instead of 1 x 10ms
 Put in bypass mode 
 Enable bypass 
 UNUSED 
  Interface to enabledisable the HW Echocan
  these functions are called within a spin_lock_irqsave on
  the channel instance lock, so we are not disturbed by irqs
  we can later easily change the interface to make  other
  things configurable, for now we configure the taps
 FILLME 
  Speech Design resync feature
  NOTE: This is called sometimes outside interrupt handler.
  We must lock irqsave, so no other interrupt (other card) will occur!
  Also multiple interrupts may nest, so must lock each access (lists, card)!
 must be locked inside other locks 
 select new master 
 Disable sync of all cards 
 get SYNC_I 
 Enable new sync master 
 switch to jatt PLL, if not disabled by RX_SYNC 
 switch to jatt 
				 Use the crystal clock for the PCM
 switch quartz 
 This must be called AND hc must be locked irqsave!!! 
  free hardware resources used by driver
 soft reset also masks all interrupts 
 instead of 'wait' that may cause locking 
 release Speech Design card, if PLX was initialized 
 Termination off 
 Disconnect the PCM 
 Put the DSP in Reset 
 disable memory mapped ports  io ports 
 prevent resync 
  function called to reset the HFC chip. A complete software reset of chip
  and fifos is done. All configuration of the chip is done.
 reset all registers 
 revision check 
 set s-ram size 
 Speech Design PLX bridge 
 The first and the last cards are terminating the PCM bus 
 hc is currently the last 
 Disconnect the PCM 
 Put the DSP in Reset 
		
		  If we are the 3rd PLXSD card or higher, we must turn
		  termination of last PLXSD card off.
 shift clock for DSP 
 shift clock for DSP 
 we only want the real Z2 read-pointer for revision > 0 
 select pcm mode 
 soft reset 
 R_FIFO_THRES ,
 16 Bytes TXRX );
 Speech Design PLX bridge pcm and sync mode 
 Connect PCM 
 PCM setup 
 sync via SYNC_I  O 
 V_C2O_EN 
 sync from interface 
 set clock speed 
 R_CLK_CFG , 0x40 
 B410P GPIO 
 check if R_F0_CNT counts (8 kHz frame count) 
 Timeout minimum 10ms 
 1 ms 
 it counts, so we keep the pcm mode 
 does not count 
 only one pcm master 
 retry with master clock 
 Timeout min. 10ms 
 1 ms 
 Release the DSP Reset 
 pcm id 
 SD has proprietary bridging 
 set up timer 
 set E1 state machine IRQ 
 set DTMF detection 
 conference engine 
 setting leds 
 HFC-E1 OEM 
 HFC-4S OEM 
 V_AUTO_SYNCI 
 set master clock 
 setting misc irq 
 RAM access test 
  control the watchdog
 printk("Sending Watchdog Kill %x\n",hc->wdbyte); 
  output leds
 HFC-E1 OEM 
		 2 red steady:       LOS
		  1 red steady:       L1 not active
		  2 green steady:     L1 active
		  1st green flashing: activity on TX
		  2nd green flashing: activity on RX
 leds are inverted 
 HFC-4S OEM 
		 red steady:     PH_DEACTIVATE
		  green steady:   PH_ACTIVATE
		  green flashing: activity on TX
 led green 
 led off 
 led red 
 led off 
green
red
 HFC 1S2S Beronet 
		 red steady:     PH_DEACTIVATE
		  green steady:   PH_ACTIVATE
		  green flashing: activity on TX
 led green 
 led off 
 led red 
 led off 
 HFC 8S+ Beronet 
		 off:      PH_DEACTIVATE
		  steady:   PH_ACTIVATE
		  flashing: activity on TX
 leds off 
 led on 
 led off 
			 HFC_outb(hc, R_BRG_PCM_CFG, 1);
 was _io before 
  read dtmf coefficients
 only process enabled B-channels 
 read W(n-1) coefficient 
 decode float (see chip doc) 
 store coefficient 
 read W(n) coefficient 
 decode float (see chip doc) 
 store coefficient 
 restart DTMF processing 
  fill fifo as much as possible
 must be int for calculation 
 no data 
 reset fifo 
 repeat until F2 is equal 
		
		  Old FIFO handling doesn't give us the current Z2 read
		  pointer, so we cannot send the next frame before the fifo
		  is empty. It makes no difference except for a slightly
		  lower performance.
 one frame only for ST D-channels, to allow resending 
 F-counter full condition 
 repeat unti Z2 is equal 
 keep not too full, so pointers will not overrun 
 fill transparent data only to maxinum transparent load (minus 4) 
 no space of 4 bytes 
 if no data 
 empty 
 if done with FIFO audio data during PCM connection 
 connect slot 
 Enable FIFO, no interrupt 
 Enable FIFO, no interrupt 
 no data 
 "fill fifo if empty" feature 
 fill buffer, to prevent future underrun 
 if audio data and connected slot 
 disconnect slot 
 Enable FIFO, no interrupt 
 Enable FIFO, no interrupt 
 show activity 
 fill fifo to what we have left 
 Have to prep the audio data 
 if not all data has been written 
 NOTE: fifo is started by the calling function 
 if all data has been written, terminate frame 
 increment f-counter 
 check for next frame 
	
	  now we have no more data, so in case of transparent,
	  we set the last byte in fifo to 'silence' in case we will get
	  no more data at all. this prevents sending an undefined value.
 NOTE: only called if E1 card is in active state 
 = 0, to make GCC happy 
 = 0, to make GCC happy 
	 on first AND before getting next valid frame, R_FIFO must be written
 ignore if rx is off BUT change fifo (above) to start pending TX 
 not exact but fair enough 
 repeat until F1 is equal 
 repeat until Z1 is equal 
 complete hdlc frame 
 if buffer is empty 
 Dchannel 
 show activity 
 empty fifo with what we have 
 HDLC 
 increment Z2,F2-counter 
 check size 
 there is at least one complete frame, check crc 
 there is an incomplete frame 
 transparent 
 only bch is transparent 
  Interrupt handler
 manager address 
 process queued resync jobs 
 lock, so e1_resync gets not changed 
 disable JATT, if RX_SYNC is set 
 set jatt to quartz 
 switch to JATT, in case it is not already 
 fifo is started when switching to rx-fifo 
 LOS 
 AIS 
 SLIP 
 RDI 
 state machine 
 undocumented: delay after R_ST_SEL 
 undocumented: status changes during read 
 repeat 
 Speech Design TE-sync indication 
 start fifo 
 start fifo 
 irq is not for us 
 LOST IRQ 
 clear irq! 
 misc IRQ 
 ignore disabled irqs 
 state machine 
 undocumented: status changes during read 
 repeat 
 broadcast state change to all fragments 
 FIFO IRQ 
  timer callback for D-chan busy resolution. Currently no function
  activatedeactivate hardware for selected channels and mode
  configure B-channel with the given protocol
  ch eqals to the HFC-channel (0-31)
  ch is the number of channel (0-4,4-7,8-11,12-15,16-19,20-23,24-27,28-31
  for ST, 1-31 for E1)
  the hdlc interrupts will be setunset
 remove from slot 
 remove from slot 
 FIFO->ST 
 disable pcm slot 
 set pcm slot 
 FIFO->ST 
 PCM->ST 
 put on slot 
 loop 
 disable pcm slot 
 ST->FIFO 
 set pcm slot 
 ST->FIFO 
 ST->(FIFO,PCM) 
 put on slot 
 reversed 
 loop 
 disable TX fifo 
 disable RX fifo 
 undocumented: delay after R_ST_SEL 
 B-channel 
 rx path 
 ST -> PCM 
 PCM -> FIFO 
 tx path 
 PCM -> ST 
 FIFO -> PCM 
 tx silence 
 enable TX fifo 
 Enable FIFO, no interrupt 
 tx silence 
 enable RX fifo 
 Enable FIFO, no interrupt
 undocumented: delay after R_ST_SEL 
 B-channel 
 D-channel 
 enable TX fifo 
 E1 or B-channel 
 D-Channel without HDLC fill flags 
 enable RX fifo 
 full 8 bits 
 2 bits dchannel 
 undocumented: delay after R_ST_SEL 
  connectdisconnect PCM
 disable PCM 
 enable pcm 
  setdisable conference
  setdisable sample loop
 NOTE: this function is experimental and therefore disabled 
  Layer 1 callback function
 start activation 
 undocumented: delay after R_ST_SEL 
 F3 
 wait at least 5,21us 
 activate 
 start deactivation 
 undocumented: delay after R_ST_SEL 
 deactivate 
 undocumented: delay after R_ST_SEL 
 activate 
 wait at least 5,21us 
 activate 
  Layer2 -> Layer 1 Transfer
 direct TX 
 skb can be freed 
 start fifo 
 start activation 
 undocumented: delay after R_ST_SEL 
 G1 
 wait at least 5,21us 
 activate 
 start deactivation 
 undocumented: delay after R_ST_SEL 
 deactivate 
 direct TX 
 start fifo 
 activate B-channel if not already activated 
 start decoder 
 set sample loop 
 set silence 
 locked there 
  bchannel control function
 turn off  on rx stream 
 reset fifo on rx on 
 fill features structure 
 create confirm 
 connect to pcm timeslot (0..N) 
 release interface from pcm timeslot 
 join conference (0..7) 
 split conference 
 locked there 
  handle D-channel events
  handle state change event
 reset fifos on e1 activation 
 undocumented: delay after R_ST_SEL 
 G4 
 wait at least 5,21us 
 one extra count for the next event 
 undocumented: delay after R_ST_SEL 
 allow G2 -> G3 transition 
  called for card mode init message
 E1 
 skip unused chan 
 E1, port 0 
 2 ms 
 512 ms 
 G0 
 F0 
 SLAVE (clock master) 
 MASTER (clock slave) 
 MASTER (clock master) 
 undoc register 
 state machine setup 
 wait at least 5,21us 
 ST 
 select interface 
 undocumented: delay after R_ST_SEL 
 clock delay 
 G1 
 clock delay 
 F2 
 V_ST_PU_CTRL ;
 A_ST_CTRL3 ,
 V_ST_PULSE );
 line setup 
 disable E-channel 
 enable B-channel receive 
 state machine setup 
 wait at least 5,21us 
 state machine interrupts 
 unset sync on port 
 b-channel can be only open once 
  device control function
 init the watchdog 
 set the watchdog timer 
 V_WD_EN ;
 init the watchdog register and reset the counter 
 enable the watchdog output for Speech-Design 
 reset the watchdog counter 
 locked there 
 locked there 
  initialize the card
  start timer irq, wait some time and check if we have interrupts.
  if not, reset chip and try again.
 set interrupts but leave global interrupt disabled 
 enable PCI & LINT1 irq 
	
	  Finally enable IRQ output
	  this is only allowed, if an IRQ routine is already
	  established for this HFC, so don't do that earlier
 printk(KERN_DEBUG "no master irq set!!!\n"); 
 Timeout 100ms 
 turn IRQ off until chip is completely initialized 
disable IRQs
  find pci device and set it up
 set memory access methods 
 use mode from card config 
 required 
 MEMBASE 1 is PLX PCI Bridge 
 MEMBASE 1 is PLX PCI Bridge 
 At this point the needed PCI config is done 
 fifos are still not enabled 
  remove port
 E1 
 remove sync 
 free channels 
 skip unused chan 
 remove sync 
 free channels 
 unregister clock source 
 disable and free irq 
 disable D-channels & B-channels 
 dimm leds 
 release hardware 
 set optical line type 
 set LOS report 
 set AIS report 
 set SLIP report 
 set RDI report 
 set CRC-4 Mode 
 set forced clock 
 set JATT PLL 
 set elastic jitter buffer 
 default 
 skip unused channel 
 set master clock 
 set transmitter line to non capacitive 
 disable E-channel 
 dip settings, port mode Jumpers 
 allocate card+fifo structure 
 fragment card 
 default card layout 
 set chip specific features 
 ulaw silence 
 alaw silence 
 setup pci, hc->slots may change due to PLXSD 
 create channels 
 release already registered ports 
 for each S0 port 
 for each E1 port 
 disp switches 
		
		  Get DIP setting for beroNet 1S2S4S cards
		  DIP Setting: (collect GPIO 131415 (R_GPIO_IN1) +
		  GPI 1923 (R_GPI_IN2))
 Port mode (TENT) jumpers 
		
		  Get DIP Setting for beroNet 8S0+ cards
		  Enable PCI auxbridge function
 prepare access to auxport 
		
		  some dummy reads are required to
		  read valid DIP switch data
 disable PCI auxbridge function 
		
		  get DIP Setting for beroNet E1 cards
		  DIP Setting: collect GPI 4567 (R_GPI_IN0)
 add to list 
 use as clock source 
 initialize hardware 
 start IRQ and return 
0	{VENDOR_BN, "HFC-1S Card (mini PCI)", 4, 1, 1, 3, 0, DIP_4S, 0, 0},
1	{VENDOR_BN, "HFC-2S Card", 4, 2, 1, 3, 0, DIP_4S, 0, 0},
2	{VENDOR_BN, "HFC-2S Card (mini PCI)", 4, 2, 1, 3, 0, DIP_4S, 0, 0},
3	{VENDOR_BN, "HFC-4S Card", 4, 4, 1, 2, 0, DIP_4S, 0, 0},
4	{VENDOR_BN, "HFC-4S Card (mini PCI)", 4, 4, 1, 2, 0, 0, 0, 0},
5	{VENDOR_CCD, "HFC-4S Eval (old)", 4, 4, 0, 0, 0, 0, 0, 0},
6	{VENDOR_CCD, "HFC-4S IOB4ST", 4, 4, 1, 2, 0, DIP_4S, 0, 0},
7	{VENDOR_CCD, "HFC-4S", 4, 4, 1, 2, 0, 0, 0, 0},
8	{VENDOR_DIG, "HFC-4S Card", 4, 4, 0, 2, 0, 0, HFC_IO_MODE_REGIO, 0},
9	{VENDOR_CCD, "HFC-4S Swyx 4xS0 SX2 QuadBri", 4, 4, 1, 2, 0, 0, 0, 0},
10	{VENDOR_JH, "HFC-4S (junghanns 2.0)", 4, 4, 1, 2, 0, 0, 0, 0},
11	{VENDOR_PRIM, "HFC-2S Primux Card", 4, 2, 0, 0, 0, 0, 0, 0},
12	{VENDOR_BN, "HFC-8S Card", 8, 8, 1, 0, 0, 0, 0, 0},
13	{VENDOR_BN, "HFC-8S Card (+)", 8, 8, 1, 8, 0, DIP_8S,
14	{VENDOR_CCD, "HFC-8S Eval (old)", 8, 8, 0, 0, 0, 0, 0, 0},
15	{VENDOR_CCD, "HFC-8S IOB4ST Recording", 8, 8, 1, 0, 0, 0, 0, 0},
16	{VENDOR_CCD, "HFC-8S IOB8ST", 8, 8, 1, 0, 0, 0, 0, 0},
17	{VENDOR_CCD, "HFC-8S", 8, 8, 1, 0, 0, 0, 0, 0},
18	{VENDOR_CCD, "HFC-8S", 8, 8, 1, 0, 0, 0, 0, 0},
19	{VENDOR_BN, "HFC-E1 Card", 1, 1, 0, 1, 0, DIP_E1, 0, 0},
20	{VENDOR_BN, "HFC-E1 Card (mini PCI)", 1, 1, 0, 1, 0, 0, 0, 0},
21	{VENDOR_BN, "HFC-E1+ Card (Dual)", 1, 1, 0, 1, 0, DIP_E1, 0, 0},
22	{VENDOR_BN, "HFC-E1 Card (Dual)", 1, 1, 0, 1, 0, DIP_E1, 0, 0},
23	{VENDOR_CCD, "HFC-E1 Eval (old)", 1, 1, 0, 0, 0, 0, 0, 0},
24	{VENDOR_CCD, "HFC-E1 IOB1E1", 1, 1, 0, 1, 0, 0, 0, 0},
25	{VENDOR_CCD, "HFC-E1", 1, 1, 0, 1, 0, 0, 0, 0},
26	{VENDOR_CCD, "HFC-4S Speech Design", 4, 4, 0, 0, 0, 0,
27	{VENDOR_CCD, "HFC-E1 Speech Design", 1, 1, 0, 0, 0, 0,
28	{VENDOR_CCD, "HFC-4S OpenVox", 4, 4, 1, 0, 0, 0, 0, 0},
29	{VENDOR_CCD, "HFC-2S OpenVox", 4, 2, 1, 0, 0, 0, 0, 0},
30	{VENDOR_CCD, "HFC-8S OpenVox", 8, 8, 1, 0, 0, 0, 0, 0},
31	{VENDOR_CCD, "XHFC-4S Speech Design", 5, 4, 0, 0, 0, 0,
32	{VENDOR_JH, "HFC-8S (junghanns)", 8, 8, 1, 0, 0, 0, 0, 0},
33	{VENDOR_BN, "HFC-2S Beronet Card PCIe", 4, 2, 1, 3, 0, DIP_4S, 0, 0},
34	{VENDOR_BN, "HFC-4S Beronet Card PCIe", 4, 4, 1, 2, 0, DIP_4S, 0, 0},
 Cards with HFC-4S Chip 
 BN1S mini PCI 
 BN2S 
 BN2S mini PCI 
 BN4S 
 BN4S mini PCI 
 Old Eval 
 IOB4ST 
 4S 
 4S Swyx 
 Primux 
 OpenVox 4 
 OpenVox 2 
 BN2S PCIe 
 BN4S PCIe 
 Cards with HFC-8S Chip 
 BN8S 
 BN8S+ 
 old Eval 
 IOB8ST Recording 
 IOB8ST  
 IOB8ST  
 8S 
 OpenVox 8 
 Junganns 8S  
 Cards with HFC-E1 Chip 
 BNE1 
 BNE1 mini PCI 
 BNE1 + (Dual) 
 BNE1 (Dual) 
 Old Eval 
 IOB1E1 
 E1 
 PLX PCI Bridge 
 PLX PCI Bridge 
 Junghanns E1 
 get rid of all devices of this driver 
	 Register the embedded devices.
 Register the PCI cards 
 SPDX-License-Identifier: GPL-2.0-or-later
 hfcsusb.c
  mISDN driver for Colognechip HFC-S USB chip
  Copyright 2001 by Peter Sprenger (sprenger@moving-bytes.de)
  Copyright 2008 by Martin Bachem (info@bachem-it.com)
  module params
    debug=<n>, default=0, with n=0xHHHHGGGG
       H - l1 driver flags described in hfcsusb.h
       G - common mISDN debug flags described at mISDNhw.h
    poll=<n>, default 128
      n : burst size of PH_DATA_IND at transparent rx data
  Revision: 0.3.3 (socket), 2008-11-05
 some function prototypes 
 start next background transfer for control channel 
  queue a control transfer request to write HFC-S USB
  chip register using CTRL resuest queue
 control completion routine handling background control cmds 
 decrement actual count 
 pointer wrap 
 start next transfer 
 handle LED bits   
 handle LED requests  
  Layer2 -> Layer 1 Bchannel data
  send full DB channel status information
  as MPH_INFORMATION_IND
  Layer2 -> Layer 1 Dchannel data
  Layer 1 callback function
 E-Channel logging 
 b-channel can be only open once 
  device control function
  S0 TE state change event handler
  S0 NT state change event handler
 allow G2 -> G3 transition 
  disableenable BChannel for desired protocoll
 setup val for CON_HDLC 
 enable FIFO 
 used for init 
 already in idle state 
 force sending sending INFO1 
 start l1 activation 
  Layer 1 B-channel hardware access
 collect data from incoming interrupt or isochron USB data 
 DE-Channel SKB range check 
 we have a complete hdlc packet 
 remove CRC & status 
 deliver transparent data to layer2 
 receive completion routine for all ISO tx fifos   
	
	  ISO transfer only partially completed,
	  look at individual frame status for details
 clear status, so go on with ISO transfers 
 USB data log for every D ISO in 
					
					  save fifo fill-level threshold bits
					  to use them later in TX ISO URB
					  completions
 signal S0 layer1 state change 
 receive completion routine for all interrupt rx fifos 
 cancel automatic rescheduling 
 USB data log for every D INT in 
 the threshold mask is in the 2nd status byte 
 signal S0 layer1 state change 
 if we have more than the 2 status bytes -> collect data 
 transmit completion routine for all ISO tx fifos 
	
	  ISO transfer only partially completed,
	  look at individual frame status for details
 clear status, so go on with ISO transfers 
 is FifoFull-threshold set for our channel? 
 predict dataflow to avoid fifo overflow 
 analyze tx success of previous ISO packets 
 Generate next ISO Packets 
 > not complete 
 how much bit do we put on the line? 
 signal frame completion 
						 add 2 byte flags and 16bit
 copy tx data to iso-urb buffer 
 USB data log for every D ISO out 
 we lower data margin every msec 
		
		  abuse DChannel tx iso completion to trigger NT mode state
		  changes tx_iso_complete is assumed to be called every
		  fifo->intervall (ms)
  allocs urbs and start isoc transfer with two pending urbs to avoid
  gaps in the transfer chain
 allocate Memory for Iso out Urbs 
 Init the first iso 
 start the interrupt transfer for the given fifo 
 do Chip reset 
 aux = output, reset off 
 set USB_SIZE to match the wMaxPacketSize for INT or BULK transfers 
 set USB_SIZE_I to match the the wMaxPacketSize for ISO transfers 
 enable PCMGCI master mode 
 set default values 
 enable master mode 
 init the fifos 
 select the desired fifo 
 set 2 bit for D- & E-channel 
 enable all fifos 
 reset the fifo 
 disable both B receivers 
 start USB data pipes dependand on device's endpoint configuration 
 quick check if endpoint already running 
 start rx endpoints using USB INT IN method 
 start rx endpoints using USB ISO IN method 
 start tx endpoints using USB ISO OUT method 
 stop USB data pipes dependand on device's endpoint configuration 
 quick check if endpoint currently running 
 rx endpoints using USB INT IN method 
 rx endpoints using USB ISO IN method 
 tx endpoints using USB ISO OUT method 
 Hardware Initialization 
 check the chip id 
 first set the needed config, interface and alternate 
 init the background machinery for control requests 
	
	  stop all endpoints gracefully
	  TODO: mISDN_core should generate CLOSE_CHANNEL
	        signals after calling mISDN_unregister_device()
  Layer 1 B-channel hardware access
 enable E-Channel logging 
 if vendor and product ID is OK, start probing alternate settings 
 default settings 
 check for all endpoints in this alternate setting 
 get endpoint base 
 (alt_idx < intf->num_altsetting) 
 not found a valid USB Ta Endpoint config 
 got no mem 
 get endpoint base 
 init Endpoints 
 save device 
 save used interface 
 and alternate config 
 control size 
 store used config 
 store found vendor 
 create the control pipes needed for register access 
 function called when an active device is removed 
 SPDX-License-Identifier: GPL-2.0-only
  w6692.c     mISDN driver for Winbond w6692 based cards
  Author      Karsten Keil <kkeil@suse.de>
              based on the w6692 I4L driver from Petr Novak <petr.novak@i.cz>
  Copyright 2009  by Karsten Keil <keil@isdn4linux.de>
 private data in the PCI devices list 
 feature mask - bit set per card nr 
 hw lock 
 protect Cards 
  LED ON 
  LED OFF 
 Restart frame 
 should not happen 
 Transmit underruncollision 
 RDOV 
 TIN2 - never 
 MOC - not supported 
 ISC - Level1 change 
 only if it is not handled yet 
 resend 
 handle XDOW only once 
 resend - no XRST needed 
 possible a shared  IRQ reqest 
 XINT01 - never 
 End IRQ Handler 
 D-Channel Busy 
 discard frame; reset transceiver 
 Transmitter reset 
 enable all IRQ but extern 
 Reset D-chan receiver and transmitter 
 Reset B-chan receiver and transmitter 
 enable peripheral 
		 seems that USR implemented some power control features
		  Pin 79 is connected to the oscilator circuit so we
		  have to handle it here
 all sw off 
  POWER UP LED OFF  ALAW 
 LED OFF 
 Timeout 10ms 
 direct TX 
 b-channel can be only open once 
 direct TX 
 skb can be freed 
 E-Channel not supported 
  LED OFF 
 SPDX-License-Identifier: GPL-2.0-only
  NETJet mISDN driver
  Author       Karsten Keil <keil@isdn4linux.de>
  Copyright 2009  by Karsten Keil <keil@isdn4linux.de>
 lock HW 
 protect Cards 
 only stop dma and interrupts if both channels NULL 
 Reset On 
 now edge triggered for TJ320 GE 130700 
 see comment in IRQ function 
 TJ320 
 Reset Off and status read clear 
 Reset Off and status read clear 
 configure AUX pins (all output except ISAC IRQ pin) 
 only transparent use the count here, HDLC overun is detected later 
 valid frame received 
 Note receive is via the WRITE DMA channel 
 sync with current DMA address at start or after exception 
	 currently we simple sync to the next complete free area
	  this hast the advantage that we have always maximum time to
	  handle TX irq
 Note send is via the READ DMA channel 
 shared IRQ 
 write to clear 
 set bits in sval to indicate which page is free 
 the 2nd write area is free 
 the 1st write area is free 
 the 2nd read area is free 
 the 1st read area is free 
 test if we have a DMA interrupt 
 got a write dma int 
 got a read dma int 
 direct TX 
 cq->channel: 0 disable, 1 B1 loop 2 B2 loop, 3 both 
 b-channel can be only open once 
  device control function
	 the TJ300 and TJ320 must be detected, the IRQ handling is different
	  unfortunately the chips use the same device ID, but the TJ320 has
	  the bit20 in status PCI cfg register set
 We cannot select cards with PCI_SUB... IDs, since here are cards with
  SUB IDs set to PCI_ANY_ID, so we need to match all and reject
 SPDX-License-Identifier: GPL-2.0-only
  mISDNinfineon.c
 		Support for cards based on following Infineon ISDN chipsets
 		- ISAC + HSCX
 		- IPAC and IPAC-X
 		- ISAC-SX + HSCX
  Supported cards:
 		- Dialogic Diva 2.0
 		- Dialogic Diva 2.0U
 		- Dialogic Diva 2.01
 		- Dialogic Diva 2.02
 		- Sedlbauer Speedwin
 		- HST Saphir3
 		- Develo (former ELSA) Microlink PCI (Quickstep 1000)
 		- Develo (former ELSA) Quickstep 3000
 		- Berkom Scitel BRIX Quadro
 		- Dr.Neuhaus (Sagem) Niccy
  Author       Karsten Keil <keil@isdn4linux.de>
  Copyright 2009  by Karsten Keil <keil@isdn4linux.de>
 HW access lock 
 slave cards 
 PCI interface specific defines 
 Diva 2.02.0U 
 DIVA_PCI_CTRL bits 
 Diva 2.012.02 
 Siemens PITA 
 TIGER 100 Registers 
 Tiger AUX BITs 
 1 and 5 are inputs 
 ELSA (now Develo) PCI cards 
 Dr NeuhausSagem Niccy 
 Scitel PLX 
 Gazel 
 Gazel PLX 
 protect Cards 
 Interface functions 
 for us or shared ? 
 shared 
 for us or shared ? 
 shared 
 ACK PITA INT0 
 for us or shared ? 
 shared 
 shared 
 for us or shared ? 
 shared 
 shared 
 Workaround PCI9060 
 IOM off 
 SPDX-License-Identifier: GPL-2.0-or-later
  isdnhdlc.c  --  General purpose ISDN HDLC decoder.
  Copyright (C)
 	2009	Karsten Keil		<keil@b1-systems.de>
 	2002	Wolfgang Mües		<wolfgang@iksw-muees.de>
 	2001	Frode Isaksen		<fisaksen@bewan.com>
       2001	Kai Germaschewski	<kai.germaschewski@gmx.de>
-------------------------------------------------------------------
-------------------------------------------------------------------
 too small - framing error 
 crc error 
 remove CRC 
 good frame 
  isdnhdlc_decode - decodes HDLC frames from a transparent bit stream.
  The source buffer is scanned for valid HDLC frames looking for
  flags (01111110) to indicate the start of a frame. If the start of
  the frame is found, the bit stuffing is removed (0 after 5 1's).
  When a new flag is found, the complete frame has been received
  and the CRC is checked.
  If a valid frame is found, the function returns the frame length
  excluding the CRC with the bit HDLC_END_OF_FRAME set.
  If the beginning of a valid frame is found, the function returns
  the length.
  If a framing error is found (too many 1s and not a flag) the function
  returns the length with the bit HDLC_FRAMING_ERROR set.
  If a CRC error is found the function returns the length with the
  bit HDLC_CRC_ERROR set.
  If the frame length exceeds the destination buffer size, the function
  returns the length with the bit HDLC_LENGTH_ERROR set.
  src - source buffer
  slen - source buffer length
  count - number of bytes removed (decoded) from the source buffer
  dst _ destination buffer
  dsize - destination buffer size
  returns - number of decoded bytes in the destination buffer and status
  flag.
 the code is for bitreverse streams 
 bad frame 
 good byte received 
 frame too long 
  isdnhdlc_encode - encodes HDLC frames to a transparent bit stream.
  The bit stream starts with a beginning flag (01111110). After
  that each byte is added to the bit stream with bit stuffing added
  (0 after 5 1's).
  When the last byte has been removed from the source buffer, the
  CRC (2 bytes is added) and the frame terminates with the ending flag.
  For the dchannel, the idle character (all 1's) is also added at the end.
  If this function is called with empty source buffer (slen=0), flags or
  idle character will be generated.
  src - source buffer
  slen - source buffer length
  count - number of bytes removed (encoded) from source buffer
  dst _ destination buffer
  dsize - destination buffer size
  returns - number of encoded bytes in the destination buffer
 special handling for one byte frames 
 closing sequence, CRC + flag(s) 
 the code is for bitreverse streams 
 Finished this frame, send flags 
 the code is for bitreverse streams 
 the code is for bitreverse streams 
 SPDX-License-Identifier: GPL-2.0-only
  mISDNisar.c   ISAR (Siemens PSB 7110) specific functions
  Author Karsten Keil (keil@isdn4linux.de)
  Copyright 2009  by Karsten Keil <keil@isdn4linux.de>
 define this to enable static debug messages, if you kernel supports
  dynamic debugging, you should use debugfs for this
 #define DEBUG 
  send msg to ISAR mailbox
  if msg is NULL use isar->buf
  receive message from ISAR mailbox
  if msg is NULL use isar->buf
  poll answer message from ISAR mailbox
  should be used only with ISAR IRQs disabled before DSP was started
 disable ISAR IRQ 
 disable ISAR IRQ 
 the ISAR is big endian 
 10ms delay 
 NORMAL mode entered 
 Enable IRQs of ISAR 
 max 1s 
 10ms delay 
 max 100 ms 
 max 300 ms 
 disable ISAR IRQ 
 last 2 are the FCS 
 ABORT 
 set_skb_flag(skb, DF_NOMOREDATA); 
 PCTRL_CMD_FRH 
 last 2 are the FCS 
 ABORT 
 use the card buffer 
 last frame 
 1s (200 ms) Flags before data 
 ignore in STFAX_SILDET 
 TOA 5 db 
 REL -46 dbm 
 6 db 
 6 db 
 dummy slot 
 Here we are selecting the best datapath for requested protocol 
 New Setup 
 init 
 no init for dpath 0 
 best is datapath 2 
 only datapath 1 
 Clear resources 
 Dpath 1, 2 
 Buffer Config 
 direct TX 
 b-channel can be only open once 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015-2016, Linaro Limited
 Refuse sharing shared memory provided by application 
 teedev has been detached from driver 
  tee_shm_alloc_kernel_buf() - Allocate shared memory for kernel buffer
  @ctx:	Context that allocates the shared memory
  @size:	Requested size of shared memory
  The returned memory registered in secure world and is suitable to be
  passed as a memory buffer in parameter argument to
  tee_client_invoke_func(). The memory allocated is later freed with a
  call to tee_shm_free().
  @returns a pointer to 'struct tee_shm'
  tee_shm_get_fd() - Increase reference count and return file descriptor
  @shm:	Shared memory handle
  @returns user space file descriptor to shared memory
  tee_shm_free() - Free shared memory
  @shm:	Handle to shared memory to free
	
	  dma_buf_put() decreases the dmabuf reference counter and will
	  call tee_shm_release() when the last reference is gone.
	 
	  In the case of driver private memory we call tee_shm_release
	  directly instead as it doesn't have a reference counter.
  tee_shm_va2pa() - Get physical address of a virtual address
  @shm:	Shared memory handle
  @va:		Virtual address to tranlsate
  @pa:		Returned physical address
  @returns 0 on success and < 0 on failure
 Check that we're in the range of the shm 
  tee_shm_pa2va() - Get virtual address of a physical address
  @shm:	Shared memory handle
  @pa:		Physical address to tranlsate
  @va:		Returned virtual address
  @returns 0 on success and < 0 on failure
 Check that we're in the range of the shm 
  tee_shm_get_va() - Get virtual address of a shared memory plus an offset
  @shm:	Shared memory handle
  @offs:	Offset from start of this shared memory
  @returns virtual address of the shared memory + offs if offs is within
 	the bounds of this shared memory, else an ERR_PTR
  tee_shm_get_pa() - Get physical address of a shared memory plus an offset
  @shm:	Shared memory handle
  @offs:	Offset from start of this shared memory
  @pa:		Physical address to return
  @returns 0 if offs is within the bounds of this shared memory, else an
 	error code.
  tee_shm_get_from_id() - Find shared memory object and increase reference
  count
  @ctx:	Context owning the shared memory
  @id:		Id of shared memory object
  @returns a pointer to 'struct tee_shm' on success or an ERR_PTR on failure
  tee_shm_put() - Decrease reference count on a shared memory handle
  @shm:	Shared memory handle
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015, Linaro Limited
  tee_shm_pool_alloc_res_mem() - Create a shared memory pool from reserved
  memory range
  @priv_info:	Information for driver private shared memory pool
  @dmabuf_info: Information for dma-buf shared memory pool
  Start and end of pools will must be page aligned.
  Allocation with the flag TEE_SHM_DMA_BUF set will use the range supplied
  in @dmabuf, others will use the range provided by @priv.
  @returns pointer to a 'struct tee_shm_pool' or an ERR_PTR on failure.
	
	  Create the pool for driver private shared memory
 8 byte aligned );
	
	  Create the pool for dma_buf shared memory
 Start and end must be page aligned 
  tee_shm_pool_free() - Free a shared memory pool
  @pool:	The shared memory pool to free
  There must be no remaining shared memory allocated from this pool when
  this function is called.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015-2016, Linaro Limited
  TEE Client UUID name space identifier (UUIDv4)
  Value here is random UUID that is allocated as name space identifier for
  forming Client UUID's for TEE environment using UUIDv5 scheme.
  Unprivileged devices in the lower half range and privileged devices in
  the upper half range.
	
	  Default user-space behaviour is to wait for tee-supplicant
	  if not present for any requests in this context.
  uuid_v5() - Calculate UUIDv5
  @uuid: Resulting UUID
  @ns: Name space ID for UUIDv5 function
  @name: Name for UUIDv5 function
  @size: Size of name
  UUIDv5 is specific in RFC 4122.
  This implements section (for SHA-1):
  4.3.  Algorithm for Creating a Name-Based UUID
 Tag for version 5 
 Nil UUID to be passed to TEE environment 
	
	  In Linux environment client UUID is based on UUIDv5.
	 
	  Determine client UUID with following semantics for 'name':
	 
	  For TEEC_LOGIN_USER:
	  uid=<uid>
	 
	  For TEEC_LOGIN_GROUP:
	  gid=<gid>
	 
 Currently no input flags are supported 
	
	  When user space closes the file descriptor the shared memory
	  should be freed or if tee_shm_get_fd() failed then it will
	  be freed immediately.
 Currently no input flags are supported 
	
	  When user space closes the file descriptor the shared memory
	  should be freed or if tee_shm_get_fd() failed then it will
	  be freed immediately.
 All unused attribute bits has to be zero 
			
			  If a NULL pointer is passed to a TA in the TEE,
			  the ip.c IOCTL parameters is set to TEE_MEMREF_NULL
			  indicating a NULL memory reference.
				
				  If we fail to get a pointer to a shared
				  memory object (and increase the ref count)
				  from an identifier we return an error. All
				  pointers that has been added in params have
				  an increased ref count. It's the callers
				  responibility to do tee_shm_put() on all
				  resolved pointers.
				
				  Ensure offset + size does not overflow
				  offset and does not overflow the size of
				  the referred shared memory object.
 Pass NULL pointer to OP-TEE 
 Unknown attribute 
	
	  If we've succeeded to open the session but failed to communicate
	  it back to user space, close the session again to avoid leakage.
 Decrease ref count for all valid shared memory pointers 
 Decrease ref count for all valid shared memory pointers 
 invalid shm id 
 All unused attribute bits has to be zero 
 Only out and inout values can be updated 
			
			  Only the size of the memref can be updated.
			  Since we don't have access to the original
			  parameters here, only store the supplied size.
			  The driver will copy the updated size into the
			  original parameters.
 Not valid for this driver 
  tee_device_alloc() - Allocate a new struct tee_device instance
  @teedesc:	Descriptor for this driver
  @dev:	Parent device for this device
  @pool:	Shared memory pool, NULL if not used
  @driver_data: Private driver data for this device
  Allocates a new struct tee_device instance. The device is
  removed by tee_device_unregister().
  @returns a pointer to a 'struct tee_device' or an ERR_PTR on failure
 1 as tee_device_unregister() does one final tee_device_put() 
  tee_device_register() - Registers a TEE device
  @teedev:	Device to register
  tee_device_unregister() need to be called to remove the @teedev if
  this function fails.
  @returns < 0 on failure
 Shouldn't put in this state 
  tee_device_unregister() - Removes a TEE device
  @teedev:	Device to unregister
  This function should be called to remove the @teedev even if
  tee_device_register() hasn't been called yet. Does nothing if
  @teedev is NULL.
	
	  No need to take a mutex any longer now since teedev->desc was
	  set to NULL before teedev->c_no_users was completed.
  tee_get_drvdata() - Return driver_data pointer
  @teedev:	Device containing the driver_data pointer
  @returns the driver_data pointer supplied to tee_register().
	
	  Default behaviour for in kernel client is to not wait for
	  tee-supplicant if not present for any requests in this context.
	  Also this flag could be configured again before call to
	  tee_client_open_session() if any in kernel client requires
	  different behaviour.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2021, Linaro Limited
  This file implement the FF-A ABI used when communicating with secure world
  OP-TEE OS via FF-A.
  This file is divided into the following sections:
  1. Maintain a hash table for lookup of a global FF-A memory handle
  2. Convert between struct tee_param and struct optee_msg_param
  3. Low level support functions to register shared memory in secure world
  4. Dynamic shared memory pool based on alloc_pages()
  5. Do a normal scheduled call into secure world
  6. Driver initialization.
  1. Maintain a hash table for lookup of a global FF-A memory handle
  FF-A assigns a global memory handle for each piece shared memory.
  This handle is then used when communicating with secure world.
  Main functions are optee_shm_add_ffa_handle() and optee_shm_rem_ffa_handle()
  2. Convert between struct tee_param and struct optee_msg_param
  optee_ffa_from_msg_param() and optee_ffa_to_msg_param() are the main
  functions.
  optee_ffa_from_msg_param() - convert from OPTEE_MSG parameters to
 				struct tee_param
  @optee:	main service struct
  @params:	subsystem internal parameter representation
  @num_params:	number of elements in the parameter arrays
  @msg_params:	OPTEE_MSG parameters
  Returns 0 on success or <0 on failure
 Check that the entire offset could be stored. 
  optee_ffa_to_msg_param() - convert from struct tee_params to OPTEE_MSG
 			      parameters
  @optee:	main service struct
  @msg_params:	OPTEE_MSG parameters
  @num_params:	number of elements in the parameter arrays
  @params:	subsystem itnernal parameter representation
  Returns 0 on success or <0 on failure
  3. Low level support functions to register shared memory in secure world
  Functions to register and unregister shared memory both for normal
  clients and for tee-supplicant.
	
	  We're skipping the OPTEE_FFA_YIELDING_CALL_UNREGISTER_SHM call
	  since this is OP-TEE freeing via RPC so it has already retired
	  this ID.
  4. Dynamic shared memory pool based on alloc_pages()
  Implements an OP-TEE specific shared memory pool.
  The main function is optee_ffa_shm_pool_alloc_pages().
  optee_ffa_shm_pool_alloc_pages() - create page-based allocator pool
  This pool is used with OP-TEE over FF-A. In this case command buffers
  and such are allocated from kernel's own memory.
  5. Do a normal scheduled call into secure world
  The function optee_ffa_do_call_with_arg() performs a normal scheduled
  call into secure world. During this call may normal world request help
  from normal world using RPCs, Remote Procedure Calls. This includes
  delivery of non-secure interrupts to for instance allow rescheduling of
  the current task.
 Interrupt delivered by now 
 Initialize waiter 
			
			  Out of threads in secure world, wait for a thread
			  become available.
		
		  OP-TEE has returned with a RPC request.
		 
		  Note that data->data4 (passed in register w7) is already
		  filled in by ffa_ops->sync_send_receive() returning
		  above.
	
	  We're done with our thread in secure world, if there's any
	  thread waiters wake up one.
  optee_ffa_do_call_with_arg() - Do a FF-A call to enter OP-TEE in secure world
  @ctx:	calling context
  @shm:	shared memory holding the message to pass to secure world
  Does a FF-A call to OP-TEE in secure world and handles eventual resulting
  Remote Procedure Calls (RPC) from OP-TEE.
  Returns return code from FF-A, 0 is OK
  6. Driver initialization
  During driver inititialization is the OP-TEE Secure Partition is probed
  to find out which features it supports so the driver can be initialized
  with a matching configuration.
 same as for clnt ops 
	
	  tee_device_unregister() is safe to call even if the
	  devices hasn't been registered with
	  tee_device_register() yet.
 486178e0-e7f8-11e3-bc5e0002a5d5c51b 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015-2021, Linaro Limited
  Copyright (c) 2016, EPAM Systems
  This file implement the SMC ABI used when communicating with secure world
  OP-TEE OS via raw SMCs.
  This file is divided into the following sections:
  1. Convert between struct tee_param and struct optee_msg_param
  2. Low level support functions to register shared memory in secure world
  3. Dynamic shared memory pool based on alloc_pages()
  4. Do a normal scheduled call into secure world
  5. Driver initialization.
  1. Convert between struct tee_param and struct optee_msg_param
  optee_from_msg_param() and optee_to_msg_param() are the main
  functions.
 Check that the memref is covered by the shm object 
  optee_from_msg_param() - convert from OPTEE_MSG parameters to
 			    struct tee_param
  @optee:	main service struct
  @params:	subsystem internal parameter representation
  @num_params:	number of elements in the parameter arrays
  @msg_params:	OPTEE_MSG parameters
  Returns 0 on success or <0 on failure
  optee_to_msg_param() - convert from struct tee_params to OPTEE_MSG parameters
  @optee:	main service struct
  @msg_params:	OPTEE_MSG parameters
  @num_params:	number of elements in the parameter arrays
  @params:	subsystem itnernal parameter representation
  Returns 0 on success or <0 on failure
  2. Low level support functions to register shared memory in secure world
  Functions to enabledisable shared memory caching in secure world, that
  is, lazy freeing of previously allocated shared memory. Freeing is
  performed when a request has been compled.
  Functions to register and unregister shared memory both for normal
  clients and for tee-supplicant.
  optee_enable_shm_cache() - Enables caching of some shared memory allocation
 			      in OP-TEE
  @optee:	main service struct
 We need to retry until secure world isn't busy. 
  __optee_disable_shm_cache() - Disables caching of some shared memory
 				 allocation in OP-TEE
  @optee:	main service struct
  @is_mapped:	true if the cached shared memory addresses were mapped by this
 		kernel, are safe to dereference, and should be freed
 We need to retry until secure world isn't busy. 
 All shm's freed 
			
			  Shared memory references that were not mapped by
			  this kernel must be ignored to prevent a crash.
  optee_disable_shm_cache() - Disables caching of mapped shared memory
 			       allocations in OP-TEE
  @optee:	main service struct
  optee_disable_unmapped_shm_cache() - Disables caching of shared memory
 					allocations in OP-TEE which are not
 					currently mapped
  @optee:	main service struct
  The final entry in each pagelist page is a pointer to the next
  pagelist page.
  optee_fill_pages_list() - write list of user pages to given shared
  buffer.
  @dst: page-aligned buffer where list of pages will be stored
  @pages: array of pages that represents shared buffer
  @num_pages: number of entries in @pages
  @page_offset: offset of user buffer from page start
  @dst should be big enough to hold list of user page addresses and
 	links to the next pages of buffer
	
	  Refer to OPTEE_MSG_ATTR_NONCONTIG description in optee_msg.h
	  for details.
	
	  Currently OP-TEE uses 4k page size and it does not looks
	  like this will change in the future.  On other hand, there are
	  no know ARM architectures with page size < 4k.
	  Thus the next built assert looks redundant. But the following
	  code heavily relies on this assumption, so it is better be
	  safe than sorry.
	
	  If linux page is bigger than 4k, and user buffer offset is
	  larger than 4k8k12ketc this will skip first 4k pages,
	  because they bear no value data for OP-TEE.
	
	  In the least bits of msg_arg->params->u.tmem.buf_ptr we
	  store buffer offset from 4k page, as described in OP-TEE ABI.
	
	  We don't want to register supplicant memory in OP-TEE.
	  Instead information about it will be passed in RPC code.
  3. Dynamic shared memory pool based on alloc_pages()
  Implements an OP-TEE specific shared memory pool which is used
  when dynamic shared memory is supported by secure world.
  The main function is optee_shm_pool_alloc_pages().
	
	  Shared memory private to the OP-TEE driver doesn't need
	  to be registered with OP-TEE.
  optee_shm_pool_alloc_pages() - create page-based allocator pool
  This pool is used when OP-TEE supports dymanic SHM. In this case
  command buffers and such are allocated from kernel's own memory.
  4. Do a normal scheduled call into secure world
  The function optee_smc_do_call_with_arg() performs a normal scheduled
  call into secure world. During this call may normal world request help
  from normal world using RPCs, Remote Procedure Calls. This includes
  delivery of non-secure interrupts to for instance allow rescheduling of
  the current task.
		
		  In the least bits of u.tmem.buf_ptr we store buffer offset
		  from 4k page, as described in OP-TEE ABI.
  optee_handle_rpc() - handle RPC from secure world
  @ctx:	context doing the RPC
  @param:	value of registers for the RPC
  @call_ctx:	call context. Preserved during one OP-TEE invocation
  Result of RPC is written back into @param.
		
		  A foreign interrupt was raised while secure world was
		  executing, since they are handled in Linux a dummy RPC is
		  performed to let Linux take the interrupt through the normal
		  vector.
  optee_smc_do_call_with_arg() - Do an SMC to OP-TEE in secure world
  @ctx:	calling context
  @arg:	shared memory holding the message to pass to secure world
  Does and SMC to OP-TEE in secure world and handles eventual resulting
  Remote Procedure Calls (RPC) from OP-TEE.
  Returns return code from secure world, 0 is OK
 Initialize waiter 
			
			  Out of threads in secure world, wait for a thread
			  become available.
	
	  We're done with our thread in secure world, if there's any
	  thread waiters wake up one.
  5. Driver initialization
  During driver inititialization is secure world probed to find out which
  features it supports so the driver can be initialized with a matching
  configuration. This involves for instance support for dynamic shared
  memory instead of a static memory carvout.
	
	  TODO This isn't enough to tell if it's UP system (from kernel
	  point of view) or not, is_smp() returns the information
	  needed, but can't be called directly from here.
 8 bytes aligned );
 Simple wrapper functions to be able to use a function pointer 
 optee_remove - Device Removal Routine
  @pdev: platform device information struct
  optee_remove is called by platform subsystem to alert the driver
  that it should release the device
	
	  Ask OP-TEE to free all cached shared memory objects to decrease
	  reference counters and also avoid wild pointers in secure world
	  into the old shared memory range.
 optee_shutdown - Device Removal Routine
  @pdev: platform device information struct
  platform_shutdown is called by the platform subsystem to alert
  the driver that a shutdown, reboot, or kexec is happening and
  device must be disabled.
	
	  Try to use dynamic shared memory if possible
	
	  If dynamic shared memory is not available or failed - try static one
	
	  Ensure that there are no pre-existing shm objects before enabling
	  the shm cache so that there's no chance of receiving an invalid
	  address during shutdown. This could occur, for example, if we're
	  kexec booting from an older kernel that did not properly cleanup the
	  shm cache.
		
		  tee_device_unregister() is safe to call even if the
		  devices hasn't been registered with
		  tee_device_register() yet.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015-2021, Linaro Limited
 Go to interruptible sleep 
 Increases count as secure world doesn't have a reference 
	
	  Match the tee_shm_get_from_id() in cmd_alloc_suppl() as secure
	  world has released its reference.
	 
	  It's better to do this before sending the request to supplicant
	  as we'd like to let the process doing the initial allocation to
	  do release the last reference too in order to avoid stacking
	  many pending fput() on the client process. This could otherwise
	  happen if secure world does many allocate and free in a single
	  invoke.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015-2021, Linaro Limited
  Copyright (c) 2016, EPAM Systems
 Unregister OP-TEE specific client devices on TEE bus 
	
	  The two devices have to be unregistered before we can free the
	  other resources.
	
	  The kernel may have crashed at the same time that all available
	  secure world threads were suspended and we cannot reschedule the
	  suspended threads without access to the crashed kernel's wait_queue.
	  Therefore, we cannot reliably initialize the OP-TEE driver in the
	  kdump kernel.
 If both failed there's no point with this module 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 Linaro Ltd.
 Fill invoke cmd params 
 Open context with OP-TEE driver 
 Open session with device enumeration pseudo TA 
 Device enumeration pseudo TA not found 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015, Linaro Limited
 Abort all request retrieved by supplicant 
 Abort all queued requests 
  optee_supp_thrd_req() - request service from supplicant
  @ctx:	context doing the request
  @func:	function requested
  @num_params:	number of elements in @param array
  @param:	parameters for function
  Returns result of operation to be passed to secure world
	
	  Return in case there is no supplicant available and
	  non-blocking request.
 Insert the request in the request list 
 Tell an eventual waiter there's a new request 
	
	  Wait for supplicant to process and return result, once we've
	  returned from wait_for_completion(&req->c) successfully we have
	  exclusive access again.
			
			  There's no supplicant available and since the
			  supp->mutex currently is held none can
			  become available until the mutex released
			  again.
			 
			  Interrupting an RPC to supplicant is only
			  allowed as a way of slightly improving the user
			  experience in case the supplicant hasn't been
			  started yet. During normal operation the supplicant
			  will serve all requests in a timely manner and
			  interrupting then wouldn't make sense.
		
		  Supplicant should not mix synchronous and asnynchronous
		  requests.
 Not enough room for parameters 
	
	  If there's memrefs we need to decrease those as they where
	  increased earlier and we'll even refuse to accept any below.
	
	  We only expect parameters as TEE_IOCTL_PARAM_ATTR_TYPE_NONE with
	  or without the TEE_IOCTL_PARAM_ATTR_META bit set.
 At most we'll need one meta parameter so no need to check for more 
  optee_supp_recv() - receive request for supplicant
  @ctx:	context receiving the request
  @func:	requested function in supplicant
  @num_params:	number of elements allocated in @param, updated with number
 		used elements
  @param:	space for parameters for @func
  Returns 0 on success or <0 on failure
		
		  If we didn't get a request we'll block in
		  wait_for_completion() to avoid needless spinning.
		 
		  This is where supplicant will be hanging most of
		  the time, let's make this interruptable so we
		  can easily restart supplicant if needed.
		
		  tee-supplicant support meta parameters -> requsts can be
		  processed asynchronously.
  optee_supp_send() - send result of request from supplicant
  @ctx:	context sending result
  @ret:	return value of request
  @num_params:	number of parameters returned
  @param:	returned parameters
  Returns 0 on success or <0 on failure.
 Something is wrong, let supplicant restart. 
 Update out and inout parameters 
 Let the requesting thread continue 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015-2021, Linaro Limited
	
	  We're preparing to make a call to secure world. In case we can't
	  allocate a thread in secure world we'll end up waiting in
	  optee_cq_wait_for_completion().
	 
	  Normally if there's no contention in secure world the call will
	  complete and we can cleanup directly with optee_cq_wait_final().
	
	  We add ourselves to the queue, but we don't wait. This
	  guarantees that we don't lose a completion if secure world
	  returns busy and another thread just exited and try to complete
	  someone.
 Move to end of list to get out of the way for other waiters 
	
	  We're done with the call to secure world. The thread in secure
	  world that was used for this call is now available for some
	  other task to use.
 Get out of the list 
 Wake up one eventual waiting task 
	
	  If we're completed we've got a completion from another task that
	  was just done with its call to secure world. Since yet another
	  thread now is available in secure world wake up another eventual
	  waiting task.
 Requires the filpstate mutex to be held 
	
	  rpc_arg_count is set to the number of allocated parameters in
	  the RPC argument struct if a second MSG arg struct is expected.
	  The second arg struct will then be used for RPC.
 +2 for the meta parameters added below 
	
	  Initialize and add the meta parameters needed when opening a
	  session.
 A new session has been created, add it to the list. 
 Close session again to avoid leakage 
 Check that the session is valid and remove it from the list 
 Check that the session is valid 
 Check that the session is valid 
	
	  Allow kernel address to register with OP-TEE as kernel
	  pages are configured as normal memory only.
 SPDX-License-Identifier: MIT
  Copyright 2019 Advanced Micro Devices, Inc.
 Map the allocated memory in to TEE 
 Unmap the shared memory from TEE 
 SPDX-License-Identifier: MIT
  Copyright 2019 Advanced Micro Devices, Inc.
 Close any open session 
 Check if session entry 'i' is valid 
  alloc_session() - Allocate a session structure
  @ctxdata:    TEE Context data structure
  @session:    Session ID for which 'struct amdtee_session' structure is to be
               allocated.
  Scans the TEE context's session list to check if TA is already loaded in to
  TEE. If yes, returns the 'session' structure for that TA. Else allocates,
  initializes a new 'session' structure and adds it to context's session list.
  The caller must hold a mutex.
  Returns:
  'struct amdtee_session ' on success and NULL on failure.
 Scan session list to check if TA is already loaded in to TEE 
 Allocate a new session and add to list 
 Requires mutex to be held 
 Load the TA binary into TEE environment 
 Find an empty session index for the given TA 
 Open session with loaded TA 
	
	  Check that the session is valid and clear the session
	  usage bit
 Close the session 
	
	  Send a MAP command to TEE and get the corresponding
	  buffer Id
 Unmap the shared memory from TEE 
 Check that the session is valid 
 SPDX-License-Identifier: MIT
  Copyright 2019 Advanced Micro Devices, Inc.
 AMD TEE does not support meta parameter 
 It is assumed that all values are within 2^32-1 
 Assumes amd->param_types is valid 
		
		  It is assumed that buf_id remains unchanged for
		  both open_session and invoke_cmd call
 field 'c' not supported by AMD TEE 
 Caller must hold a mutex 
 Caller must hold a mutex 
 Size must be page aligned 
 Create buffer list 
 Unload the TA on error 
  Runtime PM support code
   Copyright (C) 2009-2010 Magnus Damm
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  driversshsuperhywaysuperhyway.c
  SuperHyway Bus Driver
  Copyright (C) 2004, 2005  Paul Mundt <lethal@linux-sh.org>
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  superhyway_add_device - Add a SuperHyway module
  @base: Physical address where module is mapped.
  @sdev: SuperHyway device to add, or NULL to allocate a new one.
  @bus: Bus where SuperHyway module resides.
  This is responsible for adding a new SuperHyway module. This sets up a new
  struct superhyway_device for the module being added if @sdev == NULL.
  Devices are initially added in the order that they are scanned (from the
  top-down of the memory map), and are assigned an ID based on the order that
  they are added. Any manual addition of a module will thus get the ID after
  the devices already discovered regardless of where it resides in memory.
  Further work can and should be done in superhyway_scan_bus(), to be sure
  that any new modules are properly discovered and subsequently registered.
  superhyway_register_driver - Register a new SuperHyway driver
  @drv: SuperHyway driver to register.
  This registers the passed in @drv. Any devices matching the id table will
  automatically be populated and handed off to the driver's specified probe
  routine.
  superhyway_unregister_driver - Unregister a SuperHyway driver
  @drv: SuperHyway driver to unregister.
  This cleans up after superhyway_register_driver(), and should be invoked in
  the exit path of any module drivers.
  driversshsuperhywaysuperhyway-sysfs.c
  SuperHyway Bus sysfs interface
  Copyright (C) 2004, 2005  Paul Mundt <lethal@linux-sh.org>
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
 VCR flags 
 Misc 
  Core maple bus functionality
   Copyright (C) 2007 - 2009 Adrian McMenamin
   Copyright (C) 2001 - 2008 Paul Mundt
   Copyright (C) 2000 - 2001 YAEGASHI Takeshi
   Copyright (C) 2001 M. R. Brown
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
 mutex to protect queue of waiting packets 
  maple_driver_register - register a maple driver
  @drv: maple driver to be registered.
  Registers the passed in @drv, while updating the bus type.
  Devices with matching function IDs will be automatically probed.
  maple_driver_unregister - unregister a maple driver.
  @drv: maple driver to unregister.
  Cleans up after maple_driver_register(). To be invoked in the exit
  path of any module drivers.
 set hardware registers to enable next round of dma 
 set trig type to 0 for software trigger, 1 for hardware (VBLANK) 
	
	 Maple system register
	 bits 31 - 16	timeout in units of 20nsec
	 bit 12	hard trigger - set 0 to keep responding to VBLANK
	 bits 9 - 8	set 00 for 2 Mbps, 01 for 1 Mbps
	 bits 3 - 0	delay (in 1.3ms) between VBLANK and start of DMA
	 max delay is 11
  maple_getcond_callback - setup handling MAPLE_COMMAND_GETCOND
  @dev: device responding
  @callback: handler callback
  @interval: interval in jiffies between callbacks
  @function: the function code for the device
  maple_add_packet - add a single instruction to the maple bus queue
  @mdev: maple device
  @function: function on device being queried
  @command: maple command to add
  @length: length of command string (in 32 bit words)
  @data: remainder of command string
	 zero this out to avoid kobj subsystem
 process the command queue into a maple command block
  terminating command has bit 32 of first long set to 0
 build up command queue 
 disable DMA 
 check if there is a driver registered likely to match this device 
 process initial MAPLE_COMMAND_DEVINFO for each device or port 
	 copy the data as individual elements in
 Do this silently - as not a real device 
 Driver does not exist yet 
  if device has been registered for the given
  port and unit then return 1 - allows identification
  of which devices need to be attached or detached
 bounce if we cannot add 
			 Ensure we don't have block reads and devinfo
			 calls interfering with one another - so flag the
 VBLANK bottom half - implemented via workqueue 
	
	 Set up essential commands - to fetch data and
	 check devices are still present
		
		 Scan the empty ports - bus is flakey and may have
		 mis-reported emptyness
 handle devices added via hotplugs - placing them on queue for DEVINFO 
 mark that we are checking sub devices 
 mark a device as removed 
 handle empty port or hotplug removal 
		
		 Block devices play up
		 and give the impression they have
		 been removed even when still in place or
		 trip the mtd layer when they have
		 really gone - this code traps that eventuality
		 and ensures we aren't overloaded with useless
		 error messages
 Some hardware devices generate false detach messages on unit 0 
 preprocess hotplugs or scans 
 maple dma end bottom half - implemented via workqueue 
 if scanning is 1 then we have subdevices to check 
check if we have actually tested all ports yet 
 mark that we have been through the first scan 
 Load everything into the bottom half 
 Trap empty port case 
  maple_bus_type - core maple bus structure
 allocate memory for maple bus dma 
 set up DMA interrupt handler 
 set up VBLANK interrupt handler 
 setup maple ports 
 prepare initial queue 
 Push init to later to ensure hardware gets detected 
  Helper routines for SuperH Clock Pulse Generator blocks (CPG).
   Copyright (C) 2010  Magnus Damm
   Copyright (C) 2010 - 2012  Paul Mundt
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  Divmult table lookup helpers
  Common div ops
 XXX: Should use a post-change notifier 
	
	  div6 clocks require the divisor field to be non-zero or the
	  above CKSTP toggle silently fails. Ensure that the divisor
	  array is reset to its initial state on disable.
  div6 support
 Search the parent 
 Rebuild the frequency table 
  div4 support
	 we really need a better way to determine parent index, but for
	  now assume internal parent comes with CLK_ENABLE_ON_INIT set,
	  no CLK_ENABLE_ON_INIT means external clock...
 Rebiuld the frequency table 
 FSI-DIV 
 clks[i].enable_reg came from SH_CLK_FSIDIV() 
 remove .enable_reg 
  SuperH clock framework
   Copyright (C) 2005 - 2010  Paul Mundt
  This clock framework is derived from the OMAP version by:
 	Copyright (C) 2004 - 2008 Nokia Corporation
 	Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
   Modified for omap shared clock framework by Tony Lindgren <tony@atomide.com>
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
 clock disable operations are not passed on to hardware during boot 
 Termination entry 
 Used for clocks that always have same value as the parent clock 
 Propagate rate to children 
  recalculate_root_clocks - recalculate and propagate all root clocks
  Recalculates all root clocks (clocks with no parent), which if the
  clock's .recalc is set correctly, should also propagate their rates.
  Called at init.
	
	  Propagate mappings.
		
		  dummy mapping for root clocks with no specified ranges
		
		  If we're on a child clock and it provides no mapping of its
		  own, inherit the mapping from its root clock.
	
	  Establish initial mapping.
		
		  Bump the refcount for an existing mapping
 Nothing to do 
	
	  trap out already registered clocks
 disable all clocks with zero use count 
 from now on allow clock disable operations 
  IRQ domain support for SH INTC subsystem
  Copyright (C) 2012  Paul Mundt
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  intc_irq_domain_evt_xlate() - Generic xlate for vectored IRQs.
  This takes care of exception vector to hwirq translation through
  by way of evt2irq() translation.
  Note: For platforms that use a flat vector space without INTEVT this
  basically just mimics irq_domain_xlate_onecell() by way of a nopped
  out evt2irq() implementation.
	
	  Quick linear revmap check
	
	  Linear domains have a hard-wired assertion that IRQs start at
	  0 in order to make some performance optimizations. Lamely
	  restrict the linear case to these conditions here, taking the
	  tree penalty for linear cases with non-zero hwirq bases.
  IRQ chip definitions for INTC IRQs.
  Copyright (C) 2007, 2008 Magnus Damm
  Copyright (C) 2009 - 2012 Paul Mundt
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  This is held with the irq desc lock held, so we don't require any
  additional locking here at the intc desc level. The affinity mask is
  later tested in the enabledisable paths.
 read register and write zero only to the associated bit 
 8bit 
 16bit 
 32bit 
		
		  only set secondary masking method directly
		  primary masking method is using intc_prio_level[irq]
		  priority level will be set during next enable()
 SH7706, SH7707 and SH7709 do not support high level triggered 
 all recent SH-Mobile  R-Mobile ARM support this 
 PINT has 2-bit sense registers, should fail on EDGE_BOTH 
  Common INTC2 register accessors
  Copyright (C) 2007, 2008 Magnus Damm
  Copyright (C) 2009, 2010 Paul Mundt
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
 scan through physical windows and convert address 
 no windows defined, register must be 1:1 mapped virt:phys 
 Defeat write posting 
 Defeat write posting 
 Defeat write posting 
 Defeat write posting 
 Defeat write posting 
 Defeat write posting 
  Support for hardware-assisted userspace interrupt masking.
  Copyright (C) 2010  Paul Mundt
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
	
	  Minimal acceptable IRQ levels are in the 2 - 16 range, but
	  these are chomped so as to not interfere with normal IRQs.
	 
	  Level 1 is a special case on some CPUs in that it's not
	  directly settable, but given that USERIMASK cuts off below a
	  certain level, we don't care about this limitation here.
	  Level 0 on the other hand equates to user masking disabled.
	 
	  We use the default priority level as a cut off so that only
	  special case opt-in IRQs can be mangled.
  Support for hardware-managed IRQ auto-distribution.
  Copyright (C) 2010  Paul Mundt
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
		
		  Skip this entry if there's no auto-distribution
		  register associated with it.
	
	  It's possible we've gotten here with no distribution options
	  available for the IRQ in question, so we just skip over those.
	
	  Nothing to do for this IRQ.
  Support for virtual IRQ subgroups.
  Copyright (C) 2010  Paul Mundt
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  Tags for the radix tree
		
		  Catch early lookups for subgroup VIRQs that have not
		  yet been allocated an IRQ. This already includes a
		  fast-path out if the tree is untagged, so there is no
		  need to explicitly test the root tree.
 scan for duplicates 
		
		  Set the virtual IRQ as non-threadable.
 Set handler data before installing the handler 
  Support for virtual IRQ subgroups debugfs mapping.
  Copyright (C) 2010  Paul Mundt
  Modelled after archpowerpckernelirq.c.
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
	
	  XXX.. use arch_debugfs_dir here when all of the intc users are
	  converted.
  Shared interrupt handling code for IPR and INTC2 types of IRQs.
  Copyright (C) 2007, 2008 Magnus Damm
  Copyright (C) 2009 - 2012 Paul Mundt
  Based on intc2.c and ipr.c
  Copyright (C) 1999  Niibe Yutaka & Takeshi Yaegashi
  Copyright (C) 2000  Kazumoto Kojima
  Copyright (C) 2001  David J. Mckay (david.mckay@st.com)
  Copyright (C) 2003  Takashi Kusuda <kusuda-takashi@hitachi-ul.co.jp>
  Copyright (C) 2005, 2006  Paul Mundt
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  Default priority level
  - this needs to be at least 2 for 5-bit priorities on 7780
 2 - 16 
 for now 
	
	  Prefer single interrupt source bitmap over other combinations:
	 
	  1. bitmap, single interrupt source
	  2. priority, single interrupt source
	  3. bitmap, multiple interrupt sources (groups)
	  4. priority, multiple interrupt sources (groups)
 must have primary masking method 
	
	  set priority level
 enable secondary masking method if present 
 add irq to d->prio list if priority is available 
			
			  only secondary priority should access registers, so
			  set _INTC_FN(h) = REG_FN_ERR for intc_set_priority()
 add irq to d->sense list if sense is available 
 irq should be disabled by default 
 disable bits matching force_disable before registering irqs 
 disable bits matching force_enable before registering irqs 
 _INTC_ADDR_E() and _INTC_ADDR_D() are 8 bits 
 register the vectors one by one 
			
			  In the case of multi-evt handling and sparse
			  IRQ support, each vector still needs to have
			  its own backing irq_desc.
 redirect this interrupts to the first one 
 enable bits matching force_enable after registering irqs 
 enable wakeup irqs belonging to this intc controller 
			
			  This will catch the redirect and VIRQ cases
			  due to the dummy_irq_chip being inserted.
  Shared interrupt handling code for IPR and INTC2 types of IRQs.
  Copyright (C) 2007, 2008 Magnus Damm
  Copyright (C) 2009, 2010 Paul Mundt
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
 go through and enabledisable all mask bits 
 go through and enabledisable all priority fields 
	
	  Nothing to do for this IRQ.
 SPDX-License-Identifier: GPL-2.0
  Allwinner A64 Display Engine 2.0 Bus Driver
  Copyright (C) 2018 Icenowy Zheng <icenowy@aosc.io>
 sentinel  }
  Simple Power-Managed Bus Driver
  Copyright (C) 2014-2015 Glider bvba
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
	
	  Allow user to use driver_override to bind this driver to a
	  transparent bus device which has a different compatible string
	  that's not listed in simple_pm_bus_of_match. We don't want to do any
	  of the simple-pm-bus tasks for these devices, so return early.
	
	  These are transparent bus devices (not simple-pm-bus matches) that
	  have their child nodes populated automatically.  So, don't need to
	  do anything more. We only match with the device if this driver is
	  the most specific match because we don't want to incorrectly bind to
	  a device that has a more specific driver.
 Match if the device is only a bus. 
 sentinel  }
  Bus driver for MIPS Common Device Memory Map (CDMM).
  Copyright (C) 2014-2015 Imagination Technologies Ltd.
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
 Access control and status register fields 
 Each block of device registers is 64 bytes 
 Default physical base address 
 Bus operations 
 Device attributes 
  Standard driver callback helpers.
  All the CDMM driver callbacks need to be executed on the appropriate CPU from
  workqueues. For the standard driver callbacks we need a work function
  (mips_cdmm_{void,int}_work()) to do the actual call from the right CPU, and a
  wrapper function (generated with BUILD_PERCPU_HELPER) to arrange for the work
  function to be called on that CPU.
  struct mips_cdmm_work_dev - Data for per-device call work.
  @fn:		CDMM driver callback function to call for the device.
  @dev:	CDMM device to pass to @fn.
  mips_cdmm_void_work() - Call a void returning CDMM driver callback.
  @data:	struct mips_cdmm_work_dev pointer.
  A work_on_cpu() callback function to call an arbitrary CDMM driver callback
  function which doesn't return a value.
  mips_cdmm_int_work() - Call an int returning CDMM driver callback.
  @data:	struct mips_cdmm_work_dev pointer.
  A work_on_cpu() callback function to call an arbitrary CDMM driver callback
  function which returns an int.
  BUILD_PERCPU_HELPER() - Helper to call a CDMM driver callback on right CPU.
  @_ret:	Return type (void or int).
  @_name:	Name of CDMM driver callback function.
  Generates a specific device callback function to call a CDMM driver callback
  function on the appropriate CPU for the device, and if applicable return the
  result.
 Driver callback functions 
 int mips_cdmm_probe(struct device) 
 int mips_cdmm_remove(struct device) 
 void mips_cdmm_shutdown(struct device) 
 Driver registration 
  mips_cdmm_driver_register() - Register a CDMM driver.
  @drv:	CDMM driver information.
  Register a CDMM driver with the CDMM subsystem. The driver will be informed
  of matching devices which are discovered.
  Returns:	0 on success.
  mips_cdmm_driver_unregister() - Unregister a CDMM driver.
  @drv:	CDMM driver information.
  Unregister a CDMM driver from the CDMM subsystem.
 CDMM initialisation and bus discovery 
  struct mips_cdmm_bus - Info about CDMM bus.
  @phys:		Physical address at which it is mapped.
  @regs:		Virtual address where registers can be accessed.
  @drbs:		Total number of DRBs.
  @drbs_reserved:	Number of DRBs reserved.
  @discovered:		Whether the devices on the bus have been discovered yet.
  @offline:		Whether the CDMM bus is going offline (or very early
 			coming back online), in which case it should be
 			reconfigured each time.
  mips_cdmm_get_bus() - Get the per-CPU CDMM bus information.
  Get information about the per-CPU CDMM bus, if the bus is present.
  The caller must prevent migration to another CPU, either by disabling
  pre-emption or by running from a pinned kernel thread.
  Returns:	Pointer to CDMM bus information for the current CPU.
 		May return ERR_PTR(-errno) in case of error, so check with
 		IS_ERR().
 Avoid early use of per-cpu primitives before initialised 
 Get bus pointer 
 Attempt allocation if NULL 
  mips_cdmm_cur_base() - Find current physical base address of CDMM region.
  Returns:	Physical base address of CDMM region according to cdmmbase CP0
 		register, or 0 if the CDMM region is disabled.
  mips_cdmm_phys_base() - Choose a physical base address for CDMM region.
  Picking a suitable physical address at which to map the CDMM region is
  platform specific, so this weak function can be overridden by platform
  code to pick a suitable value if none is configured by the bootloader.
  By default this method tries to find a CDMM-specific node in the system
  dtb. Note that this won't work for early serial console.
  mips_cdmm_setup() - Ensure the CDMM bus is initialised and usable.
  @bus:	Pointer to bus information for current CPU.
 		IS_ERR(bus) is checked, so no need for caller to check.
  The caller must prevent migration to another CPU, either by disabling
  pre-emption or by running from a pinned kernel thread.
  Returns	0 on success, -errno on failure.
 Don't set up bus a second time unless marked offline 
 If CDMM region is still set up, nothing to do 
		
		  The CDMM region isn't set up as expected, so it needs
		  reconfiguring, but then we can stop checking it.
 If the CDMM region is already configured, inherit that setup 
 Otherwise, ask platform code for suggestions 
 Otherwise, copy what other CPUs have done 
 Otherwise, complain once 
		
		  If you hit this, either your bootloader needs to set up the
		  CDMM on the boot CPU, or else you need to implement
		  mips_cdmm_phys_base() for your platform (see asmcdmm.h).
 Already complained? 
 Record our success for other CPUs to copy 
 Enable CDMM 
  mips_cdmm_early_probe() - Minimally probe for a specific device on CDMM.
  @dev_type:	CDMM type code to look for.
  Minimally configure the in-CPU Common Device Memory Map (CDMM) and look for a
  specific device. This can be used to find a device very early in boot for
  example to configure an early FDC console device.
  The caller must prevent migration to another CPU, either by disabling
  pre-emption or by running from a pinned kernel thread.
  Returns:	MMIO pointer to device memory. The caller can read the ACSR
 		register to find more information about the device (such as the
 		version number or the number of blocks).
 		May return IOMEM_ERR_PTR(-errno) in case of error, so check with
 		IS_ERR().
 Skip the first block if it's reserved for more registers 
 Look for a specific device type 
  mips_cdmm_release() - Release a removed CDMM device.
  @dev:	Device object
  Clean up the struct mips_cdmm_device for an unused CDMM device. This is
  called automatically by the driver core when a device is removed.
  mips_cdmm_bus_discover() - Discover the devices on the CDMM bus.
  @bus:	CDMM bus information, must already be set up.
 Skip the first block if it's reserved for more registers 
 Discover devices 
  CPU hotplug and initialisation
  All the CDMM driver callbacks need to be executed on the appropriate CPU from
  workqueues. For the CPU callbacks, they need to be called for all devices on
  that CPU, so the work function calls bus_for_each_dev, using a helper
  (generated with BUILD_PERDEV_HELPER) to call the driver callback if the
  device's CPU matches.
  BUILD_PERDEV_HELPER() - Helper to call a CDMM driver callback if CPU matches.
  @_name:	Name of CDMM driver callback function.
  Generates a bus_for_each_dev callback function to call a specific CDMM driver
  callback function for the device if the device's CPU matches that pointed to
  by the data argument.
  This is used for informing drivers for all devices on a given CPU of some
  event (such as the CPU going onlineoffline).
  It is expected to already be called from the appropriate CPU.
 bus_for_each_dev callback helper functions 
 int mips_cdmm_cpu_down_helper(...) 
 int mips_cdmm_cpu_up_helper(...) 
  mips_cdmm_cpu_down_prep() - Callback for CPUHP DOWN_PREP:
 			       Tear down the CDMM bus.
  @cpu:	unsigned int CPU number.
  This function is executed on the hotplugged CPU and calls the CDMM
  driver cpu_down callback for all devices on that CPU.
 Inform all the devices on the bus 
	
	  While bus is offline, each use of it should reconfigure it just in
	  case it is first use when coming back online again.
  mips_cdmm_cpu_online() - Callback for CPUHP ONLINE: Bring up the CDMM bus.
  @cpu:	unsigned int CPU number.
  This work_on_cpu callback function is executed on a given CPU to discover
  CDMM devices on that CPU, or to call the CDMM driver cpu_up callback for all
  devices already discovered on that CPU.
  It is used as work_on_cpu callback function during
  initialisation. When CPUs are brought online the function is
  invoked directly on the hotplugged CPU.
 Bus now set up, so we can drop the offline flag if still set 
 Inform all the devices on the bus 
  mips_cdmm_init() - Initialise CDMM bus.
  Initialise CDMM bus, discover CDMM devices for online CPUs, and arrange for
  hotplug notifications so the CDMM drivers can be kept up to date.
 Register the bus 
 We want to be notified about new CPUs 
  NBUS driver for TS-4600 based boards
  Copyright (c) 2016 - Savoir-faire Linux
  Author: Sebastien Bourdelin <sebastien.bourdelin@savoirfairelinux.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  This driver implements a GPIOs bit-banged bus, called the NBUS by Technologic
  Systems. It is used to communicate with the peripherals in the FPGA on the
  TS-4600 SoM.
  request all gpios required by the bus.
  the data gpios are used for reading and writing values, their directions
  should be adjusted accordingly.
			 when used as output the default state of the data
  reset the bus in its initial state.
  The data, csn, strobe and ale lines must be zero'ed to let the FPGA knows a
  new transaction can be process.
  let the FPGA knows it can process.
  read a byte value from the data gpios.
  return 0 on success or negative errno on failure.
  set the data gpios accordingly to the byte value.
  reading the bus consists of resetting the bus, then notifying the FPGA to
  send the data in the data gpios and return the read value.
  return 0 on success or negative errno on failure.
  writing to the bus consists of resetting the bus, then define the type of
  command (addressvalue), write the data and notify the FPGA to retrieve the
  value in the data gpios.
  read the value in the FPGA register at the given address.
  return 0 on success or negative errno on failure.
 bus access must be atomic 
 set the bus in read mode 
 write address 
 set the data gpios direction as input before reading 
 reading value MSB first 
 read a byte from the bus, leave on error 
 append the byte read to the final value 
 restore the data gpios direction as output after reading 
  write the desired value in the FPGA register at the given address.
 bus access must be atomic 
 set the bus in write mode 
 write address 
 writing value MSB first 
 wait for completion 
	
	  FIXME: pwm_apply_args() should be removed when switching to
	  the atomic PWM API.
	
	  we can now start the FPGA and populate the peripherals.
	
	  let the child nodes retrieve this instance of the ts-nbus.
 shutdown the FPGA 
  Tegra ACONNECT Bus Driver
  Copyright (C) 2016, NVIDIA CORPORATION.  All rights reserved.
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
 SPDX-License-Identifier: GPL-2.0
  ti-sysc.c - Texas Instruments sysc interconnect target driver
 disabled and restored modules list lock 
  struct sysc - TI sysc interconnect target module registers and capabilities
  @dev: struct device pointer
  @module_pa: physical address of the interconnect target module
  @module_size: size of the interconnect target module
  @module_va: virtual address of the interconnect target module
  @offsets: register offsets from module base
  @mdata: ti-sysc to hwmod translation data for a module
  @clocks: clocks used by the interconnect target module
  @clock_roles: clock role names for the found clocks
  @nr_clocks: number of clocks used by the interconnect target module
  @rsts: resets used by the interconnect target module
  @legacy_mode: configured for legacy mode if set
  @cap: interconnect target module capabilities
  @cfg: interconnect target module configuration
  @cookie: data used by legacy platform callbacks
  @name: name if available
  @revision: interconnect target module revision
  @reserved: target module is reserved and already in use
  @enabled: sysc runtime enabled status
  @needs_resume: runtime resume needed on resume from suspend
  @child_needs_resume: runtime resume needed for child on resume from suspend
  @disable_on_idle: status flag used for disabling modules with resets
  @idle_work: work structure used to perform delayed idle on a module
  @pre_reset_quirk: module specific pre-reset quirk
  @post_reset_quirk: module specific post-reset quirk
  @reset_done_quirk: module specific reset done quirk
  @module_enable_quirk: module specific enable quirk
  @module_disable_quirk: module specific disable quirk
  @module_unlock_quirk: module specific sysconfig unlock quirk
  @module_lock_quirk: module specific sysconfig lock quirk
 Only i2c revision has LO and HI register with stride of 4 
 Only i2c revision has LO and HI register with stride of 4 
 Account for udelay flakeyness 
 Account for udelay flakeyness 
 Poll on reset status 
 Does the clock alias already exist? 
	
	  Use clkdev_add() instead of clkdev_alloc() to avoid the MAX_DEV_ID
	  limit for clk_get(). If cl ever needs to be freed, it should be done
	  with clkdev_drop().
 Always add a slot for main clocks fck and ick even if unused 
 Main clocks may not have ick 
 Main clocks may not have ick 
 Assume no holes for opt clocks 
 Assume no holes for opt clocks 
  sysc_init_resets - init rstctrl reset line if configured
  @ddata: device driver data
  See sysc_rstctrl_reset_deassert().
  sysc_parse_and_check_child_range - parses module IO region from ranges
  @ddata: device driver data
  In general we only need rev, syss, and sysc registers and not the whole
  module range. But we do want the offsets for these registers from the
  module base. This allows us to check them against the legacy hwmod
  platform data. Let's also check the ranges are configured properly.
 Interconnect instances to probe before l4_per instances 
 am34 l4_wkup 
 omap45 and dra7 l4_cfg 
 omap4 l4_wkup 
 omap5 and dra7 l4_wkup without dra7 dcan segment 
  sysc_defer_non_critical - defer non_critical interconnect probing
  @ddata: device driver data
  We want to probe l4_cfg and l4_wkup interconnect instances before any
  l4_per instances as l4_per instances depend on resources on l4_cfg and
  l4_wkup interconnects.
  sysc_check_one_child - check child configuration
  @ddata: device driver data
  @np: child device node
  Let's avoid messy situations where we have new interconnect target
  node but children have "ti,hwmods". These belong to the interconnect
  target node and are managed by this driver.
  So far only I2C uses 16-bit read access with clockactivity with revision
  in two registers with stride of 4. We can detect this based on the rev
  register size to configure things far enough to be able to properly read
  the revision register.
  sysc_parse_one - parses the interconnect target module registers
  @ddata: device driver data
  @reg: register to parse
  sysc_check_registers - check for misconfigured register overlaps
  @ddata: device driver data
  sysc_ioremap - ioremap register space for the interconnect target module
  @ddata: device driver data
  Note that the interconnect target module registers can be anywhere
  within the interconnect target module range. For example, SGX has
  them at offset 0x1fc00 in the 32MB module address space. And cpsw
  has them at offset 0x1200 in the CPSW_WR child. Usually the
  the interconnect target module registers are at the beginning of
  the module range though.
  sysc_map_and_check_registers - ioremap and check device registers
  @ddata: device driver data
  sysc_show_rev - read and show interconnect target module revision
  @bufp: buffer to print the information to
  @ddata: device driver data
  sysc_show_registers - show information about interconnect target module
  @ddata: device driver data
  sysc_write_sysconfig - handle sysconfig quirks for register write
  @ddata: device driver data
  @value: register value
 Caller needs to manage sysc_clkdm_deny_idle() and sysc_clkdm_allow_idle() 
	
	  Some modules like DSS reset automatically on idle. Enable optional
	  reset clocks and wait for OCP softreset to complete.
	
	  Some modules like i2c and hdq1w have unusable reset status unless
	  the module reset quirk is enabled. Skip status check on enable.
	
	  Some subsystem private interconnects, like DSS top level module,
	  need only the automatic OCP softreset handling with no sysconfig
	  register bits to configure.
	
	  Set CLOCKACTIVITY, we only use it for ick. And we only configure it
	  based on the SYSC_QUIRK_USE_CLOCKACT flag, not based on the hardware
	  capabilities. See the old HWMOD_SET_DEFAULT_CLOCKACT flag.
 Set SIDLE mode 
 Set WAKEUP 
 Set MIDLE mode 
 Autoidle bit must enabled separately if available 
 Save context and flush posted write 
 Caller needs to manage sysc_clkdm_deny_idle() and sysc_clkdm_allow_idle() 
 Set MIDLE mode 
 Set SIDLE mode 
 Save context and flush posted write 
  Checks if device context was lost. Assumes the sysconfig register value
  after lost context is different from the configured value. Only works for
  enabled devices.
  Eventually we may want to also add support to using the context lost
  registers that some SoCs have.
 Nothing to do if enabled and context not lost 
 Disable target module if it is enabled 
 Enable target module 
 Some modules like am335x gpmc need reset and restore of sysconfig 
 Disable target module if no leave_enabled was set 
 Module revision register based quirks 
 These drivers need to be fixed to not use pm_runtime_irq_safe() 
 Uarts on omap4 and later 
 Quirks that need to be set based on the module address 
 Quirks that need to be set based on detected module 
 Errata i893 handling for dra7 dcan1 and 2 
 PRUSS on am3, am4 and am5 
 Watchdog on am3 and am4 
 Some timers on omap4 and later 
  Early quirks based on module base and register offsets only that are
  needed before the module revision can be read
 Quirks that also consider the revision register value 
  DSS needs dispc outputs disabled to reset modules. Returns mask of
  enabled DSS interrupts. Eventually we may be able to do this on
  dispc init rather than top-level DSS init.
 Remap the whole module range to be able to reset dispc outputs 
 DISP_CONTROL 
 FRAMEDONE 
 FRAMEDONETV 
 EVSYNC bits 
 DISPC_CONTROL2 
 FRAMEDONE2 
 DISPC_CONTROL3 
 FRAMEDONE3 
 DSS needs child outputs disabled and SDI registers cleared for reset 
 Get enabled outputs 
 Clear IRQSTATUS 
 Disable outputs 
 Poll IRQSTATUS 
 Clear DSS_SDI_CONTROL 
 Clear DSS_PLL_CONTROL 
 Clear DSS_CONTROL to switch DSS clock sources to PRCM if not 
 1-wire needs module's internal clocks enabled for reset 
 HDQ_CTRL_STATUS 
 AESS (Audio Engine SubSystem) needs autogating set after enable 
 AESS_AUTO_GATING_ENABLE 
 I2C needs to be disabled for reset 
 I2C_CON, omap23 is different from omap4 and later 
 I2C_EN 
 RTC on am3 and 4 needs to be unlocked and locked for sysconfig 
 RTC_STATUS BUSY bit may stay active for 132768 seconds (~30 usec) 
 Now we have ~15 microseconds to readwrite various registers 
 OTG omap2430 glue layer up to omap4 needs OTG_FORCESTDBY configured 
 OTG_FORCESTDBY 
 OTG_FORCESTDBY 
 ENABLEFORCE 
 36xx SGX needs a quirk for to bypass OCP IPG interrupt logic 
 OCP_DEBUG_CONFIG 
 THALIA_INT_BYPASS 
 Watchdog timer needs a disable sequence after reset 
 PRUSS needs to set MSTANDBY_INIT inorder to idle properly 
  Note that pdata->init_module() typically does a reset first. After
  pdata->init_module() is done, PM runtime can be used for the interconnect
  target module.
  Note that the caller must ensure the interconnect target module is enabled
  before calling reset. Otherwise reset will not complete.
  At this point the module is configured enough to read the revision but
  module may not be completely configured yet to use PM runtime. Enable
  all clocks directly during init to configure the quirks needed for PM
  runtime based on the revision register.
	
	  Always enable clocks. The bootloader may or may not have enabled
	  the related clocks.
 No re-enable of clockdomain autoidle to prevent module autoidle 
  Only some devices on omap4 and later have SYSCONFIG reset done
  bit. We can detect this if there is no SYSSTATUS at all, or the
  SYSTATUS bit 0 is not used. Note that some SYSSTATUS registers
  have multiple bits for the child devices like OHCI and EHCI.
  Depends on SYSC being parsed first.
  Many child device drivers need to have fck and opt clocks available
  to get the clock rate for device internal configuration etc.
 Caller needs to take list_lock if ever used outside of cpu_pm 
  sysc_context_notifier - optionally reset and restore module after idle
  @nb: notifier block
  @cmd: unused
  @v: unused
  Some interconnect target modules need to be restored, or reset and restored
  on CPU_PM CPU_PM_CLUSTER_EXIT notifier. This is needed at least for am335x
  OTG and GPMC target modules even if the modules are unused.
 No need to restore context 
  sysc_add_restored - optionally add reset and restore quirk hanlling
  @ddata: device data
  sysc_legacy_idle_quirk - handle children in omap_device compatible way
  @ddata: device driver data
  @child: child device driver
  Allow idle for child devices as done with _od_runtime_suspend().
  Otherwise many child devices will not idle because of the permanent
  parent usecount set in pm_runtime_irq_safe().
  Note that the long term solution is to just modify the child device
  drivers to not set pm_runtime_irq_safe() and then this can be just
  dropped.
 Device tree configured quirks 
  Common sysc register bits found on omap2, also known as type1
 All omap2 and 3 timers, and timers 1, 2 & 10 on omap 4 and 5 
  SHAM2 (SHA1MD5) sysc found on omap3, a variant of sysc_regbits_omap2
  with different sidle position
  AES register bits found on omap3 and later, a variant of
  sysc_regbits_omap2 with different sidle position
  Common sysc register bits found on omap4, also known as type2
  Common sysc register bits found on omap4, also known as type3
  SmartReflex sysc found on omap34xx
  SmartReflex sysc found on omap36xx and later
  McASP register bits found on omap4 and later
  McASP found on dra7 and later
  FS USB host found on omap4 and later
  PRUSS found on some AM33xx, AM437x and AM57xx SoCs
	
	  One time decrement of clock usage counts if left on from init.
	  Note that we disable opt clocks unconditionally in this case
	  as they are enabled unconditionally during init without
	  considering sysc_opt_clks_needed() at that point.
 Keep permanent PM runtime usage count for SYSC_QUIRK_NO_IDLE 
	
	  Decrement PM runtime usage count for SYSC_QUIRK_NO_IDLE_ON_INIT
	  and SYSC_QUIRK_NO_RESET_ON_INIT
  SoC model and features detection. Only needed for SoCs that need
  special handling for quirks, no need to list others.
 sentinel  },
  List of SoCs variants with disabled features. By default we assume all
  devices in the device tree are available so no need to list those SoCs.
 OMAP34303530 and AM3517 variants with some accelerators disabled 
 OMAP3630DM3730 variants with some accelerators disabled 
 sentinel  },
  One time init to detect the booted SoC, disable unavailable features
  and initialize list for optional cpu_pm notifier.
  Note that we initialize static data shared across all ti-sysc instances
  so ddata is only used for SoC type. This can be called from module_init
  once we no longer need to rely on platform data.
	
	  Check and warn about possible old incomplete dtb. We now want to see
	  simple-pm-bus instead of simple-bus in the dtb for genpd using SoCs.
 Ignore devices that are not available on HS and EMU SoCs 
 timer12 
 rng 
	
	  Add disabled devices to the list based on the module base.
	  Note that this must be done before we attempt to access the
	  device and have module revision checks working.
  Ignore timers tagged with no-reset and no-idle. These are likely in use,
  for example by driversclocksourcetimer-ti-dm-systimer.c. If more checks
  are needed, we could also look at the timer register configuration.
 sentinel  },
 Balance use counts as PM runtime should have enabled these all 
 At least earlycon won't survive without deferred idle 
 SPDX-License-Identifier: GPL-2.0-or-later
  OMAP3XXX L3 Interconnect Driver
  Copyright (C) 2011 Texas Corporation
 	Felipe Balbi <balbi@ti.com>
 	Santosh Shilimkar <santosh.shilimkar@ti.com>
 	Sricharan <r.sricharan@ti.com>
  omap3_l3_block_irq - handles a register block's irq
  @l3: struct omap3_l3 
  @base: register block base address
  @error: L3_ERROR_LOG register of our block
  Called in hard-irq context. Caller should take care of locking
  OMAP36xx TRM gives, on page 2001, Figure 9-10, the Typical Error
  Analysis Sequence, we are following that sequence here, please
  refer to that Figure for more information on the subject.
		
		  if we have a timeout error, there's nothing we can
		  do besides rebooting the board. So let's BUG on any
		  of such errors and handle the others. timeout error
		  is severe and not expected to occur.
 No timeout error for debug sources 
 identify the error source 
 Clear the status register 
 clear the error log register 
  Address map functions for Marvell EBU SoCs (Kirkwood, Armada
  370XP, Dove, Orion5x and MV78xx0)
  This file is licensed under the terms of the GNU General Public
  License version 2.  This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  The Marvell EBU SoCs have a configurable physical address space:
  the physical address at which certain devices (PCIe, NOR, NAND,
  etc.) sit can be configured. The configuration takes place through
  two sets of registers:
  - One to configure the access of the CPU to the devices. Depending
    on the families, there are between 8 and 20 configurable windows,
    each can be use to create a physical memory window that maps to a
    specific device. Devices are identified by a tuple (target,
    attribute).
  - One to configure the access to the CPU to the SDRAM. There are
    either 2 (for Dove) or 4 (for other families) windows to map the
    SDRAM into the physical address space.
  This driver:
  - Reads out the SDRAM address decoding windows at initialization
    time, and fills the mvebu_mbus_dram_info structure with these
    informations. The exported function mv_mbus_dram_info() allow
    device drivers to get those informations related to the SDRAM
    address decoding windows. This is because devices also have their
    own windows (configured through registers that are part of each
    device register space), and therefore the drivers for Marvell
    devices have to configure those device -> SDRAM windows to ensure
    that DMA works properly.
  - Provides an API for platform code or device drivers to
    dynamically add or remove address decoding windows for the CPU ->
    device accesses. This API is mvebu_mbus_add_window_by_id(),
    mvebu_mbus_add_window_remap_by_id() and
    mvebu_mbus_del_window().
  - Provides a debugfs interface in syskerneldebugmvebu-mbus to
    see the list of CPU -> SDRAM windows and their configuration
    (file 'sdram') and the list of CPU -> devices windows and their
    configuration (file 'devices').
  DDR target is the same on all platforms.
  CPU Address Decode Windows registers
 Only on HW IO coherency capable platforms 
 Relative to mbusbridge_base 
 Maximum number of windows, for all known platforms 
  Used to store the state of one MBus window accross suspendresume.
 Used during suspendresume 
  We provide two variants of the mv_mbus_dram_info() function:
  - The normal one, where the described DRAM ranges may overlap with
    the IO windows, but for which the DRAM ranges are guaranteed to
    have a power of two size. Such ranges are suitable for the DMA
    masters that only DMA between the RAM and the device, which is
    actually all devices except the crypto engines.
  - The 'nooverlap' one, where the described DRAM ranges are
    guaranteed to not overlap with the IO windows, but for which the
    DRAM ranges will not have power of two sizes. They will only be
    aligned on a 64 KB boundary, and have a size multiple of 64
    KB. Such ranges are suitable for the DMA masters that DMA between
    the crypto SRAM (which is mapped through an IO window) and a
    device. This is the case for the crypto engines.
 Checks whether the given window has remap capability 
  Functions to manipulate the address decoding windows
 Checks whether the given window number is available 
  Checks whether the given (base, base+size) area doesn't overlap an
  existing region
		
		  Check if the current window overlaps with the
		  proposed physical range
 Skip window if need remap but is not supported 
  Debugfs debugging
 Common function used for Dove, Kirkwood, Armada 370XP and Orion 5x 
 Special function for Dove 
  SoC-specific functions and definitions
	 The register layout is a bit annoying and the below code
	  tries to cope with it.
	  - At offset 0x0, there are the registers for the first 8
	    windows, with 4 registers of 32 bits per window (ctrl,
	    base, remap low, remap high)
	  - Then at offset 0x80, there is a hole of 0x10 bytes for
	    the internal registers base address and internal units
	    sync barrier register.
	  - Then at offset 0x90, there the registers for 12
	    windows, with only 2 registers of 32 bits per window
	    (ctrl, base).
  Use the memblock information to find the MBus bridge hole in the
  physical address space.
		
		  This part of the memory is above 4 GB, so we don't
		  care for the MBus bridge hole.
		
		  The MBus bridge hole is at the end of the RAM under
		  the 4 GB limit.
  This function fills in the mvebu_mbus_dram_info_nooverlap data
  structure, by looking at the mvebu_mbus_dram_info data, and
  removing the parts of it that overlap with IO windows.
		
		  The CS is fully enclosed inside the MBus bridge
		  area, so ignore it.
		
		  Beginning of CS overlaps with end of MBus, raise CS
		  base address, and shrink its size.
		
		  End of CS overlaps with beginning of MBus, shrink
		  CS size.
		
		  We only take care of entries for which the chip
		  select is enabled, and that don't have high base
		  address bits set (devices can only access the first
		  32 bits of the memory).
 We've written 16 words to the store address 
		
		  Chip select enabled?
 CS address decoding done inside 
 the DDR controller, no need to  
 provide attributes 
 We've written 4 words to the store address 
  Some variants of Orion5x have 4 remappable windows, some other have
  only two of them.
  Public API of the driver
 Get dram info 
 Try to find matching DRAM window for phyaddr 
	
	  If no base has been initialized, doesn't make sense to
	  register the debugfs entries. We may be on a multiplatform
	  kernel that isn't running a Marvell EBU SoC.
  The window IDs in the ranges DT property have the following format:
   - bits 28 to 31: MBus custom field
   - bits 24 to 27: window target ID
   - bits 16 to 23: window attribute ID
   - bits  0 to 15: unused
 Allow a node with no 'ranges' property 
		
		  An entry with a non-zero custom field do not
		  correspond to a static window, so skip it.
	
	  These are optional, so we make sure that resource_size(x) will
	  return 0.
	
	  Set the resource to 0 so that it can be left unmapped by
	  mvebu_mbus_common_init() if the DT doesn't carry the
	  necessary information. This is needed to preserve backward
	  compatibility.
 Get optional pcie-{mem,io}-aperture properties 
 Setup statically declared windows in the DT 
  CCI cache coherent interconnect driver
  Copyright (C) 2013 ARM Ltd.
  Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  Use the port MSB as valid flag, shift can be made dynamic
  by computing number of bits required for port indexes.
  Code disabling CCI cpu ports runs with D-cache invalidated
  and SCTLR bit clear so data accesses must be kept to a minimum
  to improve performance; for now shift is left static to
  avoid one more data access while disabling the CCI port.
  __cci_ace_get_port - Function to retrieve the port index connected to
 			a cpu or device.
  @dn: device node of the device to look-up
  @type: port type
  Return value:
 	- CCI port index if success
 	- -ENODEV if failure
	
	  Port index look-up speeds up the function disabling ports by CPU,
	  since the logical to port index mapping is done once and does
	  not change after system boot.
	  The stashed index array is initialized for all possible CPUs
	  at probe time.
 too early to use cpu->of_node 
  Functions to enabledisable a CCI interconnect slave port
  They are called by low-level power management code to disable slave
  interfaces snoops and DVM broadcast.
  Since they may execute with cache data allocation disabled and
  after the caches have been cleaned and invalidated the functions provide
  no explicit locking since they may run with D-cache disabled, so normal
  cacheable kernel locks based on ldrexstrex may not work.
  Locking has to be provided by BSP implementations to ensure proper
  operations.
  cci_port_control() - function to control a CCI port
  @port: index of the port to setup
  @enable: if true enables the port, if false disables it
	
	  This function is called from power down procedures
	  and must not execute any instruction that might
	  cause the processor to be put in a quiescent state
	  (eg wfi). Hence, cpu_relax() can not be added to this
	  read loop to optimize power, since it might hide possibly
	  disruptive operations.
  cci_disable_port_by_cpu() - function to disable a CCI port by CPU
 			       reference
  @mpidr: mpidr of the CPU whose CCI port should be disabled
  Disabling a CCI port for a CPU implies disabling the CCI port
  controlling that CPU cluster. Code disabling CPU CCI ports
  must make sure that the CPU running the code is the last active CPU
  in the cluster ie all other CPUs are quiescent in a low power state.
  Return:
 	0 on success
 	-ENODEV on port look-up failure
  cci_enable_port_for_self() - enable a CCI port for calling CPU
  Enabling a CCI port for the calling CPU implies enabling the CCI
  port controlling that CPU's cluster. Caller must make sure that the
  CPU running the code is the first active CPU in the cluster and all
  other CPUs are quiescent in a low power state  or waiting for this CPU
  to complete the CCI initialization.
  Because this is called when the MMU is still off and with no stack,
  the code must be position independent and ideally rely on callee
  clobbered registers only.  To achieve this we must code this function
  entirely in assembler.
  On success this returns with the proper CCI port enabled.  In case of
  any failure this never returns as the inability to enable the CCI is
  fatal and there is no possible recovery at this stage.
 Loop over the cpu_port array looking for a matching MPIDR 
 Found a match, now test port validity 
 no match, loop with the next cpu_port entry 
 CCI port not found -- cheaply try to stall this CPU 
 Use matched port index to look up the corresponding ports entry 
 Enable the CCI port 
 poll the status reg for completion 
  __cci_control_port_by_device() - function to control a CCI port by device
 				    reference
  @dn: device node pointer of the device whose CCI port should be
       controlled
  @enable: if true enables the port, if false disables it
  Return:
 	0 on success
 	-ENODEV on port look-up failure
  __cci_control_port_by_index() - function to control a CCI port by port index
  @port: port index previously retrieved with cci_ace_get_port()
  @enable: if true enables the port, if false disables it
  Return:
 	0 on success
 	-ENODEV on port index out of range
 	-EPERM if operation carried out on an ACE PORT
	
	  CCI control for ports connected to CPUS is extremely fragile
	  and must be made to go through a specific and controlled
	  interface (ie cci_disable_port_by_cpu(); control by general purpose
	  indexing is therefore disabled for ACE ports.
	
	  If there is no CCI port that is under kernel control
	  return early and report probe status.
 initialize a stashed array of ACE ports to speed-up look-up 
	
	  Multi-cluster systems may need this data when non-coherent, during
	  cluster power-uppower-down. Make sure it reaches main memory.
 !CONFIG_ARM_CCI400_PORT_CTRL 
 CONFIG_ARM_CCI400_PORT_CTRL 
  To sort out early init calls ordering a helper function is provided to
  check if the CCI driver has beed initialized. Function check if the driver
  has been initialized, if not it calls the init function that probes
  the driver and updates the return value.
 SPDX-License-Identifier: GPL-2.0-only
  Qualcomm External Bus Interface 2 (EBI2) driver
  an older version of the Qualcomm Parallel Interface Controller (QPIC)
  Copyright (C) 2016 Linaro Ltd.
  Author: Linus Walleij <linus.walleij@linaro.org>
  See the device tree bindings for this block for more details on the
  hardware.
  CS0, CS1, CS4 and CS5 are two bits wide, CS2 and CS3 are one bit.
 Power management etc 
  SLOW CSn CFG
  Bits 31-28: RECOVERY recovery cycles (0 = 1, 1 = 2 etc) this is the time the
              memory continues to drive the data bus after OE is de-asserted.
              Inserted when reading one CS and switching to another CS or read
              followed by write on the same CS. Valid values 0 thru 15.
  Bits 27-24: WR_HOLD write hold cycles, these are extra cycles inserted after
              every write minimum 1. The data out is driven from the time WE is
              asserted until CS is asserted. With a hold of 1, the CS stays
              active for 1 extra cycle etc. Valid values 0 thru 15.
  Bits 23-16: WR_DELTA initial latency for write cycles inserted for the first
              write to a page or burst memory
  Bits 15-8:  RD_DELTA initial latency for read cycles inserted for the first
              read to a page or burst memory
  Bits 7-4:   WR_WAIT number of wait cycles for every write access, 0=1 cycle
              so 1 thru 16 cycles.
  Bits 3-0:   RD_WAIT number of wait cycles for every read access, 0=1 cycle
              so 1 thru 16 cycles.
  FAST CSn CFG
  Bits 31-28: ?
  Bits 27-24: RD_HOLD: the length in cycles of the first segment of a read
              transfer. For a single read trandfer this will be the time
              from CS assertion to OE assertion.
  Bits 18-24: ?
  Bits 17-16: ADV_OE_RECOVERY, the number of cycles elapsed before an OE
              assertion, with respect to the cycle where ADV is asserted.
              2 means 2 cycles between ADV and OE. Values 0, 1, 2 or 3.
  Bits 5:     ADDR_HOLD_ENA, The address is held for an extra cycle to meet
              hold time requirements with ADV assertion.
  The manual mentions "write precharge cycles" and "precharge cycles".
  We have not been able to figure out which bit fields these correspond to
  in the hardware, or what valid values exist. The current hypothesis is that
  this is something just used on the FAST chip selects. There is also a "byte
  device enable" flag somewhere for 8bit memories.
  struct cs_data - struct with info on a chipselect setting
  @enable_mask: mask to enable the chipselect in the EBI2 config
  @slow_cfg: offset to XMEMC slow CS config
  @fast_cfg: offset to XMEMC fast CS config
 CS0 
 CS1 
 CS2 
 CS3 
 CS4 
 CS5 
  struct ebi2_xmem_prop - describes an XMEM config property
  @prop: the device tree binding name
  @max: maximum value for the property
  @slowreg: true if this property is in the SLOW CS config register
  else it is assumed to be in the FAST config register
  @shift: the bit field start in the SLOW or FAST register for this
  property
 boolean prop 
 Next set up the XMEMC 
 All are regular u32 values 
 First check boolean props 
 We're dealing with an u32 
 Allegedly this turns the power save mode off 
 Disable all chipselects 
 Walk over the child nodes and see what chipselects we use 
 Figure out the chipselect 
 We have at least one child 
 SPDX-License-Identifier: GPL-2.0-only
  ARM Integrator Logical Module bus driver
  Copyright (C) 2020 Linaro Ltd.
  Author: Linus Walleij <linus.walleij@linaro.org>
  See the device tree bindings for this block for more details on the
  hardware.
 All information about the connected logic modules are in here 
 Base address for the expansion modules 
 Walk over the child nodes and see what chipselects we use 
 First populate the syscon then any devices 
 Look up the system controller 
 Loop over the connected modules 
  RSB (Reduced Serial Bus) driver.
  Author: Chen-Yu Tsai <wens@csie.org>
  This file is licensed under the terms of the GNU General Public License
  version 2.  This program is licensed "as is" without any warranty of any
  kind, whether express or implied.
  The RSB controller looks like an SMBus controller which only supports
  byte and word data transfers. But, it differs from standard SMBus
  protocol on several aspects:
  - it uses addresses set at runtime to address slaves. Runtime addresses
    are sent to slaves using their 12bit hardware addresses. Up to 15
    runtime addresses are available.
  - it adds a parity bit every 8bits of data and address for read and
    write accesses; this replaces the ack bit
  - only one read access is required to read a byte (instead of a write
    followed by a read access in standard SMBus protocol)
  - there's no Ack bit after each read access
  This means this bus cannot be used to interface with standard SMBus
  devices. Devices known to support this interface include the AXP223,
  AXP809, and AXP806 PMICs, and the AC100 audio codec, all from X-Powers.
  A description of the operation and wire protocol can be found in the
  RSB section of Allwinner's A80 user manual, which can be found at
      https:github.comallwinner-zhdocumentstreemasterA80
  This document is officially released by Allwinner.
  This driver is based on i2c-sun6i-p2wi.c, the P2WI bus driver.
 RSB registers 
 Global control 
 Clock control 
 Interrupt controls 
 Interrupt status 
 Address to send with readwrite command 
 Data to readwrite 
 Line control 
 Device mode (init) control 
 RSB Command 
 Device address  runtime address 
 CTRL fields 
 CLK CTRL fields 
 STATUS fields 
 LINE CTRL fields
 DEVICE MODE CTRL field values 
 CMD values 
 DAR fields 
 bus  slave device related functions 
  sunxi_rsb_device_create() - allocate and add an RSB device
  @rsb:	RSB controller
  @node:	RSB slave device node
  @hwaddr:	RSB slave hardware address
  @rtaddr:	RSB slave runtime address
  sunxi_rsb_device_unregister(): unregister an RSB device
  @rdev:	rsb_device to be removed
  sunxi_rsb_driver_register() - Register device driver with RSB core
  @rdrv:	device driver to be associated with slave-device.
  This API will register the client driver with the RSB framework.
  It is typically called from the driver's module-init function.
 common code that starts a transfer 
 abort the transfer 
 clear any interrupt flags 
 RSB regmap functions 
 RSB controller driver functions 
 Clear interrupts 
 send init sequence 
 clear interrupt status bits 
  There are 15 valid runtime addresses, though Allwinner typically
  skips the first, for unknown reasons, and uses the following three.
  0x17, 0x2d, 0x3a, 0x4e, 0x59, 0x63, 0x74, 0x8b,
  0x9c, 0xa6, 0xb1, 0xc5, 0xd2, 0xe8, 0xff
  No designs with 2 RSB slave devices sharing identical hardware
  addresses on the same bus have been seen in the wild. All designs
  use 0x2d for the primary PMIC, 0x3a for the secondary PMIC if
  there is one, and 0x45 for peripheral ICs.
  The hardware does not seem to support re-setting runtime addresses.
  Attempts to do so result in the slave devices returning a NACK.
  Hence we just hardcode the mapping here, like Allwinner does.
 Primary PMIC: AXP223, AXP809, AXP81X, ... 
 Secondary PMIC: AXP806, ... 
 Peripheral IC: AC100, ... 
 0 is an invalid runtime address 
 Runtime addresses for all slaves should be set first 
		
		  Since no devices have been registered yet, we are the
		  only ones using the bus, we can skip locking the bus.
 setup command parameters 
 send command 
 Then we start adding devices and probing them 
 reset the controller 
	
	  Clock frequency and delay calculation code is from
	  Allwinner U-boot sources.
	 
	  From A83 user manual:
	  bus clock frequency = parent clock frequency  (2  (divider + 1))
 Keep the clock and PM reference counts consistent. 
 initialize all devices on the bus into RSB mode 
 SPDX-License-Identifier: GPL-2.0-or-later
  omap-ocp2scp.c - transform ocp interface protocol to scp protocol
  Copyright (C) 2012 Texas Instruments Incorporated - http:www.ti.com
  Author: Kishon Vijay Abraham I <kishon@ti.com>
	
	  As per AM572x TRM: http:www.ti.comlitugspruhz6spruhz6.pdf
	  under section 26.3.2.2, table 26-26 OCP2SCP TIMING Caution;
	  As per OMAP4430 TRM: http:www.ti.comlitugswpu231apswpu231ap.pdf
	  under section 23.12.6.2.2 , Table 23-1213 OCP2SCP TIMING Caution;
	  As per OMAP4460 TRM: http:www.ti.comlitugswpu235abswpu235ab.pdf
	  under section 23.12.6.2.2, Table 23-1213 OCP2SCP TIMING Caution;
	  As per OMAP543x TRM http:www.ti.comlitpdfswpu249
	  under section 27.3.2.2, Table 27-27 OCP2SCP TIMING Caution;
	 
	  Read path of OCP2SCP is not working properly due to low reset value
	  of SYNC2 parameter in OCP2SCP. Suggested reset value is 0x6 or more.
  Driver for NVIDIA Generic Memory Interface
  Copyright (C) 2016 Host Mobility AB. All rights reserved.
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 stop GMI operation 
	
	  We currently only support one child device due to lack of
	  chip-select address decoding. Which means that we only have one
	  chip-select line from the GMI controller.
 Decode the CS# 
 Invalid binding 
		
		  If we reach here it means that the child node has an empty
		  ranges or it does not exist at all. Attempt to decode the
		  CS# from the reg property instead.
 Valid chip selects are CS0-CS7 
 The default values that are provided below are reset values 
  OMAP L3 Interconnect error handling driver
  Copyright (C) 2011-2015 Texas Instruments Incorporated - http:www.ti.com
 	Santosh Shilimkar <santosh.shilimkar@ti.com>
 	Sricharan <r.sricharan@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  l3_handle_target() - Handle Target specific parse and reporting
  @l3:		pointer to l3 struct
  @base:	base address of clkdm
  @flag_mux:	flagmux corresponding to the event
  @err_src:	error source index of the slave (target)
  This does the second part of the error interrupt handling:
 	3) Parse in the slave information
 	4) Print the logged information.
 	5) Add dump stack to provide kernel trace.
 	6) Clear the source if known.
  This handles two types of errors:
 	1) Custom errors in L3 :
 		Target like DMMFWEMIF generates SRESP=ERR error
 	2) Standard L3 error:
 		- Unsupported CMD.
 			L3 tries to access target while it is idle
 		- OCP disconnect.
 		- Address hole error:
 			If DSSISSFDIFUSBHOSTFS access a target where they
 			do not have connectivity, the error is logged in
 			their default target which is DMM2.
 	On High Secure devices, firewall errors are possible and those
 	can be trapped as well. But the trapping is implemented as part
 	secure software and hence need not be implemented here.
 We DONOT expect err_src to go out of bounds 
 Read the stderrlog_main_source from clk domain 
 Nothing to be handled here as of now 
 STDERRLOG_MSTADDR Stores the NTTP master address. 
 clear the std error log
  l3_interrupt_handler() - interrupt handler for l3 events
  @irq:	irq number
  @_l3:	pointer to l3 structure
  Interrupt Handler for L3 error detection.
 	1) Identify the L3 clockdomain partition to which the error belongs to.
 	2) Identify the slave where the error information is logged
 	... handle the slave event..
 	7) if the slave is unknown, mask out the slave.
 Get the Type of interrupt 
		
		  Read the regerr register of the clock domain
		  to determine the source
 Get the corresponding error and analyse 
 Identify the source from control status register 
			
			  Certain plaforms may have "undocumented" status
			  pending on boot. So dont generate a severe warning
			  here. Just mask it off to prevent the error from
			  reoccuring and locking up the system.
 Mark these bits as to be ignored 
 Error found so break the for loop 
 Get mem resources 
 First entry cannot be submodule 
	
	  Setup interrupt Handlers
  l3_resume_noirq() - resume function for l3_noc
  @dev:	pointer to l3_noc device structure
  We only have the resume handler only since we
  have already maintained the delta register
  configuration as part of configuring the system
 Dummy read to force OCP barrier 
 SPDX-License-Identifier: GPL-2.0-only
  TI da8xx master peripheral priority driver
  Copyright (C) 2016 BayLibre SAS
  Author:
    Bartosz Golaszewski <bgolaszewski@baylibre.com>
  REVISIT: Linux doesn't have a good framework for the kind of performance
  knobs this driver controls. We can't use device tree properties as it deals
  with hardware configuration rather than description. We also don't want to
  commit to maintaining some random sysfs attributes.
  For now we just hardcode the register values for the boards that need
  some changes (as is the case for the LCD controller on da850-lcdk - the
  first board we support here). When linux gets an appropriate framework,
  we'll easily convert the driver to it.
  Default memory settings of da850 do not meet the throughputlatency
  requirements of tilcdc. This results in the image displayed being
  incorrect and the following warning being displayed by the LCDC
  drm driver:
    tilcdc da8xx_lcdc.0: tilcdc_crtc_irq(0x00000020): FIFO underfow
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2020 BAIKAL ELECTRONICS, JSC
  Authors:
    Serge Semin <Sergey.Semin@baikalelectronics.ru>
  Baikal-T1 AXI-bus driver
  struct bt1_axi - Baikal-T1 AXI-bus private data
  @dev: Pointer to the device structure.
  @qos_regs: AXI Interconnect QoS tuning registers.
  @sys_regs: Baikal-T1 System Controller registers map.
  @irq: Errors IRQ number.
  @aclk: AXI reference clock.
  @arst: AXI Interconnect reset line.
  @count: Number of errors detected.
	
	  Print backtrace on each CPU. This might be pointless if the fault
	  has happened on the same CPU as the IRQ handler is executed or
	  the other core proceeded further execution despite the error.
	  But if it's not, by looking at the trace we would get straight to
	  the cause of the problem.
	
	  Performing unaligned read from the memory will cause the CM2 bus
	  error while unaligned writing - the AXI bus write error handled
	  by this driver.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2020 BAIKAL ELECTRONICS, JSC
  Authors:
    Serge Semin <Sergey.Semin@baikalelectronics.ru>
  Baikal-T1 APB-bus driver
  struct bt1_apb - Baikal-T1 APB EHB private data
  @dev: Pointer to the device structure.
  @regs: APB EHB registers map.
  @res: No-device error injection memory region.
  @irq: Errors IRQ number.
  @rate: APB-bus reference clock rate.
  @pclk: APB-reference clock.
  @prst: APB domain reset line.
  @count: Number of errors detected.
	
	  Print backtrace on each CPU. This might be pointless if the fault
	  has happened on the same CPU as the IRQ handler is executed or
	  the other core proceeded further execution despite the error.
	  But if it's not, by looking at the trace we would get straight to
	  the cause of the problem.
 Unmask IRQ and clear it' pending flag. 
	
	  Either dummy read from the unmapped address in the APB IO area
	  or manually set the IRQ status.
  EIM driver for Freescale's i.MX chips
  Copyright (C) 2013 Freescale Semiconductor, Inc.
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 i.MX121 
 i.MX25273135 
 i.MX50536Q 
 i.MX51 
 CS0(128M) CS1(0M)  CS2(0M)  CS3(0M)  
 CS0(64M)  CS1(64M) CS2(0M)  CS3(0M)  
 CS0(64M)  CS1(32M) CS2(32M) CS3(0M)  
 CS0(32M)  CS1(32M) CS2(32M) CS3(32M) 
 Found it. Set up IOMUXC_GPR1[11:0] with it. 
 Parse and set the timing for this device. 
	
	  the child node's "reg" property may contain multiple address ranges,
	  extract the chip select for each.
 get the CS index from this child node's "reg" property. 
 prevent re-configuring a CS that's already been configured 
 set the timing for WEIM 
 get the resource 
 get the clock 
 parse the device node 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2015 Masahiro Yamada <yamada.masahiro@socionext.com>
 System Bus Controller registers 
 base address of bank0 space 
 bank_enable 
 timing parameter 0 of bank0 
 timing parameter 1 of bank0 
 timing parameter 2 of bank0 
 timing parameter 3 of bank0 
 timing parameter 4 of bank0 
 register stride to next bank 
 number of banks (chip select) 
 data to squash bank 0, 1 
	
	  If BOOT_SWAP was asserted on power-on-reset, the CS0 and CS1 are
	  swapped.  In this case, bank0 and bank1 should be swapped as well.
			
			  If SBC_BASE0 or SBC_BASE1 is set to zero, the access
			  to anywhere in the system bus space is routed to
			  bank 0 (if boot swap if off) or bank 1 (if boot swap
			  if on).  It means that CPUs cannot get access to
			  bank 2 or later.  In other words, bank 01 cannot
			  be disabled even if its bank_enable bits is cleared.
			  This seems odd, but it is how this hardware goes.
			  As a workaround, dummy data (0xffffffff) should be
			  set when the bank 01 is unused.  As for bank 2 and
			  later, they can be simply disable by clearing the
			  bank_enable bit.
 Now, the bus is configured.  Populate platform_devices below it 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  Turris Mox module configuration bus driver
  Copyright (C) 2019 Marek Behún <kabel@kernel.org>
  @name:	module name for sysfs
  @hwirq_base:	base index for IRQ for this module (-1 if no IRQs)
  @nirqs:	how many interrupts does the shift register provide
  @desc:	module description for kernel log
 do not change order of this array! 
  @nsame:	how many modules with same id are already in moxtet->modules
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2014-2021 Broadcom
 return 1 if the hardware doesn't have ARB_ERR_CAP_MASTER 
 Invalid captured address, bail out 
 Read the address and master 
 clear the GISB error 
 Invalid captured address, bail out 
 Invalid captured address, bail out 
 Read the address and master 
 clear the GISB error 
  Dump out gisb errors on die or panic.
 iterate over each GISB arb registered handlers 
 Interrupt is optional 
 If we do not have a valid mask, assume all masters are enabled 
	 Proceed with reading the litteral names if we agree on the
	  number of masters
 Make sure we provide the same timeout value that was configured before, and
  do this before the GISB timeout interrupt handler has any chance to run.
 SPDX-License-Identifier: GPL-2.0-only
  Intel IXP4xx Expansion Bus Controller
  Copyright (C) 2021 Linaro Ltd.
  Author: Linus Walleij <linus.walleij@linaro.org>
 Bits inside each CS timing register 
 Only on IXP45x and IXP46x 
 Always zero 
 Only on IXP43x 
 Only on IXP43x 
 Only on IXP42x 
 Always zero 
 Fuses on the IXP43x 
 Number of device tree values in "reg" 
 Several chip selects can be joined into one device 
	
	  The following will readmodifywrite the configuration for one
	  chipselect, attempting to leave the boot defaults in place unless
	  something is explicitly defined.
 Size set-up first align to 2^9 .. 2^24 
 All are regular u32 values 
 Handle bools (single bits) first 
 This assumes max value fills all the assigned bits (and it does) 
		
		  This bit for Intel strata flash is currently unused, but let's
		  report it if we find one.
	
	  If several chip selects are joined together into one big
	  device area, we call ourselves recursively for each successive
	  chip select. For a 32MB flash chip this results in two calls
	  for example.
		
		  The memory window always starts from CS base so we need to add
		  the start and size to get to the size from the start of the CS
		  base. For example if CS0 is at 0x50000000 and the reg is
		  <0 0xe40000 0x40000> the size is e80000.
		 
		  Roof this if we have several regs setting the same CS.
 Just this one, so set it up and return 
 We check that the regmap work only on first read 
 Check some fuses 
 Walk over the child nodes and see what chipselects we use 
 We have at least one child 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2017 Hisilicon Limited, All Rights Reserved.
  Author: Zhichang Yuan <yuanzhichang@hisilicon.com>
  Author: Zou Rongrong <zourongrong@huawei.com>
  Author: John Garry <john.garry@huawei.com>
  Setting this bit means each IO operation will target a different port
  address; 0 means repeated IO operations will use the same port,
  such as BT.
 data length of each operation 
 The max IO cycle counts supported is four per operation at maximum 
 LPC cycles count per start 
 0: read, 1: write 
 target address 
 write FIFO 
 read FIFO 
 The minimal nanosecond interval for each query on LPC cycle status 
  The maximum waiting time is about 128us.  It is specific for stream IO,
  such as ins.
  The fastest IO cycle time is about 390ns, but the worst case will wait
  for extra 256 lpc clocks, so (256 + 13)  30ns = 8 us. The maximum burst
  cycles is 16. So, the maximum waiting time is about 128us under worst
  case.
  Choose 1300 as the maximum.
 About 10us. This is specific for single IO operations, such as inb 
  hisi_lpc_target_in - trigger a series of LPC cycles for read operation
  @lpcdev: pointer to hisi lpc device
  @para: some parameters used to control the lpc IO operations
  @addr: the lpc IO target port address
  @buf: where the read back data is stored
  @opcnt: how many IO operations required, i.e. data width
  Returns 0 on success, non-zero on fail.
 IO mode, Read 
 whole operation must be atomic 
 whether the operation is finished 
  hisi_lpc_target_out - trigger a series of LPC cycles for write operation
  @lpcdev: pointer to hisi lpc device
  @para: some parameters used to control the lpc IO operations
  @addr: the lpc IO target port address
  @buf: where the data to be written is stored
  @opcnt: how many IO operations required, i.e. data width
  Returns 0 on success, non-zero on fail.
 default is increasing address 
 IO mode, write 
 whether the operation is finished 
  hisi_lpc_comm_in - input the data in a single operation
  @hostdata: pointer to the device information relevant to LPC controller
  @pio: the target IO port address
  @dwidth: the data length required to read from the target IO port
  When success, data is returned. Otherwise, ~0 is returned.
  hisi_lpc_comm_out - output the data in a single operation
  @hostdata: pointer to the device information relevant to LPC controller
  @pio: the target IO port address
  @val: a value to be output from caller, maximum is four bytes
  @dwidth: the data width required writing to the target IO port
  This function corresponds to out(b,w,l) only.
  hisi_lpc_comm_ins - input the data in the buffer in multiple operations
  @hostdata: pointer to the device information relevant to LPC controller
  @pio: the target IO port address
  @buffer: a buffer where readinput data bytes are stored
  @dwidth: the data width required writing to the target IO port
  @count: how many data units whose length is dwidth will be read
  When success, the data read back is stored in buffer pointed by buffer.
  Returns 0 on success, -errno otherwise.
  hisi_lpc_comm_outs - output the data in the buffer in multiple operations
  @hostdata: pointer to the device information relevant to LPC controller
  @pio: the target IO port address
  @buffer: a buffer where writeoutput data bytes are stored
  @dwidth: the data width required writing to the target IO port
  @count: how many data units whose length is dwidth will be written
  Released firmware describes the IO port max address as 0x3fff, which is
  the max host bus address. Fixup to a proper range. This will probably
  never be fixed in firmware.
  hisi_lpc_acpi_set_io_res - set the resources for a child
  @child: the device node to be updated the IO resource
  @hostdev: the device node associated with host controller
  @res: double pointer to be set to the address of translated resources
  @num_res: pointer to variable to hold the number of translated resources
  Returns 0 when successful, and a negative value for failure.
  For a given host controller, each child device will have an associated
  host-relative address resource.  This function will return the translated
  logical PIO addresses for each child devices resources.
	
	  The following code segment to retrieve the resources is common to
	  acpi_create_platform_device(), so consider a common helper function
	  in future.
 translate the IO resources 
  hisi_lpc_acpi_probe - probe children for ACPI FW
  @hostdev: LPC host device pointer
  Returns 0 when successful, and a negative value for failure.
  Create a platform device per child, fixing up the resources
  from bus addresses to Logical PIO addresses.
 Only consider the children of the host 
 ipmi 
 8250-compatible uart 
 CONFIG_ACPI
  hisi_lpc_probe - the probe callback function for hisi lpc host,
 		   will finish all the initialization.
  @pdev: the platform device corresponding to hisi lpc host
  Returns 0 on success, non-zero on fail.
 register the LPC host PIO resources 
 SPDX-License-Identifier: GPL-2.0-or-later
  TI PWM Subsystem driver
  Copyright (C) 2012 Texas Instruments Incorporated - http:www.ti.com
 Populate all the child nodes here... 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2014 ARM Limited
 Keep it last! 
 Default value 
 Use a canary for reads 
 The operation can take ages... Go to sleep, 100us initially 
	
	  "arm,vexpress-energy" function used to be described
	  by its first device only, now it requires both
 Confirm board type against DT property, if available 
 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
  Copyright 2013-2016 Freescale Semiconductor Inc.
  dpcon_open() - Open a control session for the specified object
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @dpcon_id:	DPCON unique ID
  @token:	Returned token; use in subsequent API calls
  This function can be used to open a control session for an
  already created object; an object may have been declared in
  the DPL or by calling the dpcon_create() function.
  This function returns a unique authentication token,
  associated with the specific object ID and the specific MC
  portal; this token must be used in all subsequent commands for
  this specific object.
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
 retrieve response parameters 
  dpcon_close() - Close the control session of the object
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPCON object
  After this function is called, no further operations are
  allowed on the object without opening a new control session.
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dpcon_enable() - Enable the DPCON
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPCON object
  Return:	'0' on Success; Error code otherwise
 prepare command 
 send command to mc
  dpcon_disable() - Disable the DPCON
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPCON object
  Return:	'0' on Success; Error code otherwise
 prepare command 
 send command to mc
  dpcon_reset() - Reset the DPCON, returns the object to initial state.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPCON object
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dpcon_get_attributes() - Retrieve DPCON attributes.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPCON object
  @attr:	Object's attributes
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
 retrieve response parameters 
  dpcon_set_notification() - Set DPCON notification destination
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPCON object
  @cfg:	Notification parameters
  Return:	'0' on Success; Error code otherwise
 prepare command 
 send command to mc
 SPDX-License-Identifier: GPL-2.0
  Management Complex (MC) userspace support
  Copyright 2021 NXP
 Common commands amongst all types of objects. Must be checked last. 
 Check if this is an accepted MC command 
	 Check if the size of the command is honored. Anything beyond the
	  last valid byte of the command should be zeroed.
	 Some MC commands request a token to be passed so that object
	  identification is possible. Check if the token passed in the command
	  is as expected.
 If needed, check if the module ID passed is valid 
 The module ID is represented by bits [4:9] from the cmdid 
	 Some commands alter how hardware resources are managed. For these
	  commands, check for CAP_NET_ADMIN.
 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
  Copyright 2013-2016 Freescale Semiconductor Inc.
  fsl_create_mc_io() - Creates an MC IO object
  @dev: device to be associated with the MC IO object
  @mc_portal_phys_addr: physical address of the MC portal to use
  @mc_portal_size: size in bytes of the MC portal
  @dpmcp_dev: Pointer to the DPMCP object associated with this MC IO
  object or NULL if none.
  @flags: flags for the new MC IO object
  @new_mc_io: Area to return pointer to newly created MC IO object
  Returns '0' on Success; Error code otherwise.
  fsl_destroy_mc_io() - Destroys an MC IO object
  @mc_io: MC IO object to destroy
  fsl_mc_portal_allocate - Allocates an MC portal
  @mc_dev: MC device for which the MC portal is to be allocated
  @mc_io_flags: Flags for the fsl_mc_io object that wraps the allocated
  MC portal.
  @new_mc_io: Pointer to area where the pointer to the fsl_mc_io object
  that wraps the allocated MC portal is to be returned
  This function allocates an MC portal from the device's parent DPRC,
  from the corresponding MC bus' pool of MC portals and wraps
  it in a new fsl_mc_io object. If 'mc_dev' is a DPRC itself, the
  portal is allocated from its own MC bus.
  fsl_mc_portal_free - Returns an MC portal to the pool of free MC portals
  of a given MC bus
  @mc_io: Pointer to the fsl_mc_io object that wraps the MC portal to free
	
	  Every mc_io obtained by calling fsl_mc_portal_allocate() is supposed
	  to have a DPMCP object associated with.
  fsl_mc_portal_reset - Resets the dpmcp object for a given fsl_mc_io object
  @mc_io: Pointer to the fsl_mc_io object that wraps the MC portal to free
 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
  Copyright 2013-2016 Freescale Semiconductor Inc.
  IO services to send MC commands to the MC hardware
  Timeout in milliseconds to wait for the completion of an MC command
  usleep_range() min and max values used to throttle down polling
  iterations while waiting for MC command completion
  mc_write_command - writes a command to a Management Complex (MC) portal
  @portal: pointer to an MC portal
  @cmd: pointer to a filled command
 copy command parameters into the portal 
		
		  Data is already in the expected LE byte-order. Do an
		  extra LE -> CPU conversion so that the CPU -> LE done in
		  the device io write api puts it back in the right order.
 submit the command by writing the header 
  mc_read_response - reads the response for the last MC command from a
  Management Complex (MC) portal
  @portal: pointer to an MC portal
  @resp: pointer to command response buffer
  Returns MC_CMD_STATUS_OK on Success; Error code otherwise.
 Copy command response header from MC portal: 
 Copy command response data from MC portal: 
		
		  Data is expected to be in LE byte-order. Do an
		  extra CPU -> LE to revert the LE -> CPU done in
		  the device io read api.
  mc_polling_wait_preemptible() - Waits for the completion of an MC
                                  command doing preemptible polling.
                                  uslepp_range() is called between
                                  polling iterations.
  @mc_io: MC IO object to be used
  @cmd: command buffer to receive MC response
  @mc_status: MC command completion status
	
	  Wait for response from the MC hardware:
		
		  TODO: When MC command completion interrupts are supported
		  call wait function here instead of usleep_range()
  mc_polling_wait_atomic() - Waits for the completion of an MC command
                             doing atomic polling. udelay() is called
                             between polling iterations.
  @mc_io: MC IO object to be used
  @cmd: command buffer to receive MC response
  @mc_status: MC command completion status
  mc_send_command() - Sends a command to the MC device using the given
                      MC IO object
  @mc_io: MC IO object to be used
  @cmd: command to be sent
  Returns '0' on Success; Error code otherwise.
	
	  Send command to the MC hardware:
	
	  Wait for response from the MC hardware:
 SPDX-License-Identifier: GPL-2.0
  fsl-mc object allocator driver
  Copyright (C) 2013-2016 Freescale Semiconductor, Inc.
  fsl_mc_resource_pool_add_device - add allocatable object to a resource
  pool of a given fsl-mc bus
  @mc_bus: pointer to the fsl-mc bus
  @pool_type: pool type
  @mc_dev: pointer to allocatable fsl-mc device
  fsl_mc_resource_pool_remove_device - remove an allocatable device from a
  resource pool
  @mc_dev: pointer to allocatable fsl-mc device
  It permanently removes an allocatable fsl-mc device from the resource
  pool. It's an error if the device is in use.
	
	  If the device is currently allocated, its resource is not
	  in the free list and thus, the device cannot be removed.
  fsl_mc_object_allocate - Allocates an fsl-mc object of the given
  pool type from a given fsl-mc bus instance
  @mc_dev: fsl-mc device which is used in conjunction with the
  allocated object
  @pool_type: pool type
  @new_mc_adev: pointer to area where the pointer to the allocated device
  is to be returned
  Allocatable objects are always used in conjunction with some functional
  device.  This function allocates an object of the specified type from
  the DPRC containing the functional device.
  NOTE: pool_type must be different from FSL_MC_POOL_MCP, since MC
  portals are allocated using fsl_mc_portal_allocate(), instead of
  this function.
  fsl_mc_object_free - Returns an fsl-mc object to the resource
  pool where it came from.
  @mc_adev: Pointer to the fsl-mc device
  A DPRC and the devices in the DPRC all share the same GIC-ITS device
  ID.  A block of IRQs is pre-allocated and maintained in a pool
  from which devices can allocate them when needed.
  Initialize the interrupt pool associated with an fsl-mc bus.
  It allocates a block of IRQs from the GIC-ITS.
 do nothing if the IRQ pool is already populated 
		
		  NOTE: This mc_dev_irq's MSI addrvalue pair will be set
		  by the fsl_mc_msi_write_msg() callback
  Teardown the interrupt pool associated with an fsl-mc bus.
  It frees the IRQs that were allocated to the pool, back to the GIC-ITS.
  Allocate the IRQs required by a given fsl-mc device.
  Frees the IRQs that were allocated for an fsl-mc device.
  fsl_mc_allocator_probe - callback invoked when an allocatable device is
  being added to the system
  fsl_mc_allocator_remove - callback invoked when an allocatable device is
  being removed from the system
 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
  Copyright 2013-2016 Freescale Semiconductor Inc.
  Copyright 2020 NXP
  cache the DPRC version to reduce the number of commands
  towards the mc firmware
  dprc_open() - Open DPRC object for use
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @container_id: Container ID to open
  @token:	Returned token of DPRC object
  Return:	'0' on Success; Error code otherwise.
  @warning	Required before any operation on the object.
 prepare command 
 send command to mc
 retrieve response parameters 
  dprc_close() - Close the control session of the object
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPRC object
  After this function is called, no further operations are
  allowed on the object without opening a new control session.
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dprc_reset_container - Reset child container.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPRC object
  @child_container_id:	ID of the container to reset
  @options: 32 bit options:
    - 0 (no bits set) - all the objects inside the container are
      reset. The child containers are entered recursively and the
      objects reset. All the objects (including the child containers)
      are closed.
    - bit 0 set - all the objects inside the container are reset.
      However the child containers are not entered recursively.
      This option is supported for API versions >= 6.5
  In case a software context crashes or becomes non-responsive, the parent
  may wish to reset its resources container before the software context is
  restarted.
  This routine informs all objects assigned to the child container that the
  container is being reset, so they may perform any cleanup operations that are
  needed. All objects handles that were owned by the child container shall be
  closed.
  Note that such request may be submitted even if the child software context
  has not crashed, but the resulting object cleanup operations will not be
  aware of that.
  Return:	'0' on Success; Error code otherwise.
	
	  If the DPRC object version was not yet cached, cache it now.
	  Otherwise use the already cached value.
	
	  MC API 6.5 introduced a new field in the command used to pass
	  some flags.
	  Bit 0 indicates that the child containers are not recursively reset.
 prepare command 
 send command to mc
  dprc_set_irq() - Set IRQ information for the DPRC to trigger an interrupt.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPRC object
  @irq_index:	Identifies the interrupt index to configure
  @irq_cfg:	IRQ configuration
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dprc_set_irq_enable() - Set overall interrupt state.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPRC object
  @irq_index:	The interrupt index to configure
  @en:		Interrupt state - enable = 1, disable = 0
  Allows GPP software to control when interrupts are generated.
  Each interrupt can have up to 32 causes.  The enabledisable control's the
  overall interrupt state. if the interrupt is disabled no causes will cause
  an interrupt.
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dprc_set_irq_mask() - Set interrupt mask.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPRC object
  @irq_index:	The interrupt index to configure
  @mask:	event mask to trigger interrupt;
 			each bit:
 				0 = ignore event
 				1 = consider event for asserting irq
  Every interrupt can have up to 32 causes and the interrupt model supports
  maskingunmasking each cause independently
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dprc_get_irq_status() - Get the current status of any pending interrupts.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPRC object
  @irq_index:	The interrupt index to configure
  @status:	Returned interrupts status - one bit per cause:
 			0 = no interrupt pending
 			1 = interrupt pending
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
 retrieve response parameters 
  dprc_clear_irq_status() - Clear a pending interrupt's status
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPRC object
  @irq_index:	The interrupt index to configure
  @status:	bits to clear (W1C) - one bit per cause:
 					0 = don't change
 					1 = clear status bit
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dprc_get_attributes() - Obtains container attributes
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPRC object
  @attr:	Returned container attributes
  Return:     '0' on Success; Error code otherwise.
 prepare command 
 send command to mc
 retrieve response parameters 
  dprc_get_obj_count() - Obtains the number of objects in the DPRC
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPRC object
  @obj_count:	Number of objects assigned to the DPRC
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
 retrieve response parameters 
  dprc_get_obj() - Get general information on an object
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPRC object
  @obj_index:	Index of the object to be queried (< obj_count)
  @obj_desc:	Returns the requested object descriptor
  The object descriptors are retrieved one by one by incrementing
  obj_index up to (not including) the value of obj_count returned
  from dprc_get_obj_count(). dprc_get_obj_count() must
  be called prior to dprc_get_obj().
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
 retrieve response parameters 
  dprc_set_obj_irq() - Set IRQ information for object to trigger an interrupt.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPRC object
  @obj_type:	Type of the object to set its IRQ
  @obj_id:	ID of the object to set its IRQ
  @irq_index:	The interrupt index to configure
  @irq_cfg:	IRQ configuration
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dprc_get_obj_region() - Get region information for a specified object.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPRC object
  @obj_type:	Object type as returned in dprc_get_obj()
  @obj_id:	Unique object instance as returned in dprc_get_obj()
  @region_index: The specific region to query
  @region_desc:  Returns the requested region descriptor
  Return:	'0' on Success; Error code otherwise.
      If the DPRC object version was not yet cached, cache it now.
      Otherwise use the already cached value.
		
		  MC API version 6.6 changed the size of the MC portals and software
		  portals to 64K (as implemented by hardware). If older API is in use the
		  size reported is less (64 bytes for mc portals and 4K for software
		  portals).
		
		  MC API version 6.3 introduced a new field to the region
		  descriptor: base_address. If the older API is in use then the base
		  address is set to zero to indicate it needs to be obtained elsewhere
		  (typically the device tree).
 send command to mc
 retrieve response parameters 
  dprc_get_api_version - Get Data Path Resource Container API version
  @mc_io:	Pointer to Mc portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @major_ver:	Major version of Data Path Resource Container API
  @minor_ver:	Minor version of Data Path Resource Container API
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc 
 retrieve response parameters 
  dprc_get_container_id - Get container ID associated with a given portal.
  @mc_io:		Pointer to Mc portal's IO object
  @cmd_flags:		Command flags; one or more of 'MC_CMD_FLAG_'
  @container_id:	Requested container id
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
 retrieve response parameters 
  dprc_get_connection() - Get connected endpoint and link status if connection
 			exists.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPRC object
  @endpoint1:	Endpoint 1 configuration parameters
  @endpoint2:	Returned endpoint 2 configuration parameters
  @state:	Returned link state:
 		1 - link is up;
 		0 - link is down;
 		-1 - no connection (endpoint2 information is irrelevant)
  Return:     '0' on Success; -ENOTCONN if connection does not exist.
 prepare command 
 send command to mc 
 retrieve response parameters 
 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
  Copyright 2013-2016 Freescale Semiconductor Inc.
  dpmcp_open() - Open a control session for the specified object.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @dpmcp_id:	DPMCP unique ID
  @token:	Returned token; use in subsequent API calls
  This function can be used to open a control session for an
  already created object; an object may have been declared in
  the DPL or by calling the dpmcp_create function.
  This function returns a unique authentication token,
  associated with the specific object ID and the specific MC
  portal; this token must be used in all subsequent commands for
  this specific object
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
 retrieve response parameters 
  dpmcp_close() - Close the control session of the object
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPMCP object
  After this function is called, no further operations are
  allowed on the object without opening a new control session.
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dpmcp_reset() - Reset the DPMCP, returns the object to initial state.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPMCP object
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
  Copyright 2013-2016 Freescale Semiconductor Inc.
  dpbp_open() - Open a control session for the specified object.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @dpbp_id:	DPBP unique ID
  @token:	Returned token; use in subsequent API calls
  This function can be used to open a control session for an
  already created object; an object may have been declared in
  the DPL or by calling the dpbp_create function.
  This function returns a unique authentication token,
  associated with the specific object ID and the specific MC
  portal; this token must be used in all subsequent commands for
  this specific object
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
 retrieve response parameters 
  dpbp_close() - Close the control session of the object
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPBP object
  After this function is called, no further operations are
  allowed on the object without opening a new control session.
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dpbp_enable() - Enable the DPBP.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPBP object
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dpbp_disable() - Disable the DPBP.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPBP object
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dpbp_reset() - Reset the DPBP, returns the object to initial state.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPBP object
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dpbp_get_attributes - Retrieve DPBP attributes.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPBP object
  @attr:	Returned object's attributes
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
 retrieve response parameters 
 SPDX-License-Identifier: GPL-2.0
  Freescale Management Complex (MC) bus driver
  Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  Copyright 2019-2020 NXP
  Author: German Rivera <German.Rivera@freescale.com>
  Default DMA mask for devices on a fsl-mc bus
  struct fsl_mc - Private data of a "fsl,qoriq-mc" platform device
  @root_mc_bus_dev: fsl-mc device representing the root DPRC
  @num_translation_ranges: number of entries in addr_translation_ranges
  @translation_ranges: array of bus to system address translation ranges
  @fsl_mc_regs: base address of register bank
  struct fsl_mc_addr_translation_range - bus to system address translation
  range
  @mc_region_type: Type of MC region for the range being translated
  @start_mc_offset: Start MC offset of the range being translated
  @end_mc_offset: MC offset of the first byte after the range (last MC
  offset of the range is end_mc_offset - 1)
  @start_phys_addr: system physical address corresponding to start_mc_addr
  fsl_mc_bus_match - device to driver matching callback
  @dev: the fsl-mc device to match against
  @drv: the device driver to search for matching fsl-mc object type
  structures
  Returns 1 on success, 0 otherwise.
 When driver_override is set, only bind to the matching driver 
	
	  If the object is not 'plugged' don't match.
	  Only exception is the root DPRC, which is a special case.
	
	  Traverse the match_id table of the given driver, trying to find
	  a matching for the given device.
  fsl_mc_bus_uevent - callback invoked when a device is added
  __fsl_mc_driver_register - registers a child device driver with the
  MC bus
  This function is implicitly invoked from the registration function of
  fsl_mc device drivers, which is generated by the
  module_fsl_mc_driver() macro.
  fsl_mc_driver_unregister - unregisters a device driver from the
  MC bus
  mc_get_version() - Retrieves the Management Complex firmware
 			version information
  @mc_io:		Pointer to opaque IO object
  @cmd_flags:		Command flags; one or more of 'MC_CMD_FLAG_'
  @mc_ver_info:	Returned version information structure
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
 retrieve response parameters 
  fsl_mc_get_version - function to retrieve the MC fw version information
  Return:	mc version when called after fsl-mc-bus probe; NULL otherwise.
  fsl_mc_get_root_dprc - function to traverse to the root dprc
		
		  Do identity mapping:
		
		  This function should not have been called for this MC object
		  type, as this object type is not supposed to have MMIO
		  regions
		
		  Older MC only returned region offset and no base address
		  If base address is in the region_desc use it otherwise
		  revert to old mechanism
			
			  Some versions of the MC firmware wrongly report
			  0 for register base address of the DPMCP associated
			  with child DPRC objects thus rendering them unusable.
			  This is particularly troublesome in ACPI boot
			  scenarios where the legacy way of extracting this
			  base address from the device tree does not apply.
			  Given that DPMCPs share the same base address,
			  workaround this by using the base address extracted
			  from the root DPRC container.
  fsl_mc_is_root_dprc - function to check if a given device is a root dprc
  Add a newly discovered fsl-mc device to be visible in Linux
		
		  Allocate an MC bus device object:
		
		  Allocate a regular fsl_mc_device object:
		
		  To get the DPRC's ICID, we need to open the DPRC
		  in get_dprc_icid(). For child DPRCs, we do so using the
		  parent DPRC's MC portal instead of the child DPRC's MC
		  portal, in case the child DPRC is already opened with
		  its own portal (e.g., the DPRC used by AIOP).
		 
		  NOTE: There cannot be more than one active open for a
		  given MC object, using the same MC portal.
			
			  device being added is a child DPRC device
			
			  device being added is the root DPRC device
		
		  A non-DPRC object has to be a child of a DPRC, use the
		  parent's ICID and interrupt domain.
	
	  Get MMIO regions for the device from the MC:
	 
	  NOTE: the root DPRC is a special case as its MMIO region is
	  obtained from the device tree
	
	  The device-specific probe callback will get invoked by device_add()
  fsl_mc_device_remove - Remove an fsl-mc device from being visible to
  Linux
  @mc_dev: Pointer to an fsl-mc device
	
	  The device-specific remove callback will get invoked by device_del()
	
	  We know that the device has an endpoint because we verified by
	  interrogating the firmware. This is the case when the device was not
	  yet discovered by the fsl-mc bus, thus the lookup returned NULL.
	  Force a rescan of the devices in this container and retry the lookup.
	
	  This means that the endpoint might reside in a different isolation
	  context (DPRCcontainer). Not much to do, so return a permssion
	  error.
		
		  Missing or empty ranges property ("ranges;") for the
		  'fsl,qoriq-mc' node. In this case, identity mapping
		  will be used.
  fsl_mc_bus_probe - callback invoked when the root MC bus is being
  added
			
			  HW ORs the PL and BMT bit, places the result in bit
			  14 of the StreamID and ORs in the ICID. Calculate it
			  accordingly.
		
		  Some bootloaders pause the MC firmware before booting the
		  kernel so that MC will not cause faults as soon as the
		  SMMU probes due to the fact that there's no configuration
		  in place for MC.
		  At this point MC should have all its SMMU setup done so make
		  sure it is resumed.
	
	  Get physical address of MC portal for the root DPRC:
  fsl_mc_bus_remove - callback invoked when the root MC bus is being
  removed
		
		  Pause the MC firmware so that it doesn't crash in certain
		  scenarios, such as kexec.
	
	  Make sure that the MC firmware is paused before the IOMMU setup for
	  it is done or otherwise the firmware will crash right after the SMMU
	  gets probed and enabled.
 SPDX-License-Identifier: GPL-2.0
  Freescale data path resource container (DPRC) driver
  Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  Copyright 2019-2020 NXP
  Author: German Rivera <German.Rivera@freescale.com>
  dprc_remove_devices - Removes devices for objects removed from a DPRC
  @mc_bus_dev: pointer to the fsl-mc device that represents a DPRC object
  @obj_desc_array: array of object descriptors for child objects currently
  present in the DPRC in the MC.
  @num_child_objects_in_mc: number of entries in obj_desc_array
  Synchronizes the state of the Linux bus driver with the actual state of
  the MC by removing devices that represent MC objects that have
  been dynamically removed in the physical DPRC.
		
		  Remove child objects that are in the DPRC in Linux,
		  but not in the MC:
		
		  There are no child objects for this DPRC in the MC.
		  So, remove all the child devices from Linux:
  check_plugged_state_change - Check change in an MC object's plugged state
  @mc_dev: pointer to the fsl-mc device for a given MC object
  @obj_desc: pointer to the MC object's descriptor in the MC
  If the plugged state has changed from unplugged to plugged, the fsl-mc
  device is bound to the corresponding device driver.
  If the plugged state has changed from plugged to unplugged, the fsl-mc
  device is unbound from the corresponding device driver.
	
	  Check if device is already known to Linux:
  dprc_add_new_devices - Adds devices to the logical bus for a DPRC
  @mc_bus_dev: pointer to the fsl-mc device that represents a DPRC object
  @obj_desc_array: array of device descriptors for child devices currently
  present in the physical DPRC.
  @num_child_objects_in_mc: number of entries in obj_desc_array
  Synchronizes the state of the Linux bus driver with the actual
  state of the MC by adding objects that have been newly discovered
  in the physical DPRC.
 probe the allocable objects first 
  dprc_scan_objects - Discover objects in a DPRC
  @mc_bus_dev: pointer to the fsl-mc device that represents a DPRC object
  @alloc_interrupts: if true the function allocates the interrupt pool,
  otherwise the interrupt allocation is delayed
  Detects objects added and removed from a DPRC and synchronizes the
  state of the Linux bus driver, MC by adding and removing
  devices accordingly.
  Two types of devices can be found in a DPRC: allocatable objects (e.g.,
  dpbp, dpmcp) and non-allocatable devices (e.g., dprc, dpni).
  All allocatable devices needed to be probed before all non-allocatable
  devices, to ensure that device drivers for non-allocatable
  devices can allocate any type of allocatable devices.
  That is, we need to ensure that the corresponding resource pools are
  populated before they can get allocation requests from probe callbacks
  of the device drivers for the non-allocatable devices.
		
		  Discover objects currently present in the physical DPRC:
				
				  Mark the obj entry as "invalid", by using the
				  empty string as obj type:
			
			  add a quirk for all versions of dpsec < 4.0...none
			  are coherent regardless of what the MC reports.
	
	  Allocate IRQ's before binding the scanned devices with their
	  respective drivers.
  dprc_scan_container - Scans a physical DPRC and synchronizes Linux bus state
  @mc_bus_dev: pointer to the fsl-mc device that represents a DPRC object
  @alloc_interrupts: if true the function allocates the interrupt pool,
                     otherwise the interrupt allocation is delayed
  Scans the physical DPRC and synchronizes the state of the Linux
  bus driver with the actual state of the MC by adding and removing
  devices as appropriate.
	
	  Discover objects in the DPRC:
  dprc_irq0_handler - Regular ISR for DPRC interrupt 0
  @irq_num: IRQ number of the interrupt being handled
  @arg: Pointer to device structure
  dprc_irq0_handler_thread - Handler thread function for DPRC interrupt 0
  @irq_num: IRQ number of the interrupt being handled
  @arg: Pointer to device structure
			
			  If the error is -ENXIO, we ignore it, as it indicates
			  that the object scan was aborted, as we detected that
			  an object was removed from the DPRC in the MC, while
			  we were scanning the DPRC.
  Disable and clear interrupt for a given DPRC object
	
	  Disable generation of interrupt, while we configure it:
	
	  Disable all interrupt causes for the interrupt:
	
	  Clear any leftover interrupts:
	
	  NOTE: devm_request_threaded_irq() invokes the device-specific
	  function that programs the MSI physically in the device
	
	  Enable all interrupt causes for the interrupt:
	
	  Enable generation of the interrupt:
  Setup interrupt for a given DPRC device
  dprc_setup - opens and creates a mc_io for DPRC
  @mc_dev: Pointer to fsl-mc device representing a DPRC
  It opens the physical DPRC in the MC.
  It configures the DPRC portal used to communicate with MC
		
		  This is a child DPRC:
  dprc_probe - callback invoked when a DPRC is being bound to this driver
  @mc_dev: Pointer to fsl-mc device representing a DPRC
  It opens the physical DPRC in the MC.
  It scans the DPRC to discover the MC objects contained in it.
  It creates the interrupt pool for the MC bus associated with the DPRC.
  It configures the interrupts for the DPRC device itself.
	
	  Discover MC objects in DPRC object:
	
	  Configure interrupt for the DPRC object associated with this MC bus:
  Tear down interrupt for a given DPRC object
  dprc_cleanup - function that cleanups a DPRC
  @mc_dev: Pointer to fsl-mc device representing the DPRC
  It closes the DPRC device in the MC.
  It destroys the interrupt pool associated with this MC bus.
	 this function should be called only for DPRCs, it
	  is an error to call it for regular objects
	 if this step fails we cannot go further with cleanup as there is no way of
	  communicating with the firmware
  dprc_remove - callback invoked when a DPRC is being unbound from this driver
  @mc_dev: Pointer to fsl-mc device representing the DPRC
  It removes the DPRC's child objects from Linux (not from the MC) and
  closes the DPRC device in the MC.
  It tears down the interrupts that were configured for the DPRC device.
  It destroys the interrupt pool associated with this MC bus.
 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
  Copyright 2021 NXP
 prepare command 
 send command to mc
 retrieve response parameters 
 prepare command 
 send command to mc
 prepare command 
 send command to mc
 SPDX-License-Identifier: GPL-2.0
  Freescale Management Complex (MC) bus driver MSI support
  Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  Author: German Rivera <German.Rivera@freescale.com>
  Generate a unique ID identifying the interrupt (only used within the MSI
  irqdomain.  Combine the icid with the interrupt index.
	
	  Make the base hwirq value for ICID10000 so it is readable
	  as a decimal value in procinterrupts.
	
	  set_desc should not be set by the caller
	
	  msi_desc->msg.address is 0x0 when this function is invoked in
	  the free_irq() code path. In this case, for the MC, we don't
	  really need to "unprogram" the MSI, so we just return.
		
		  IRQ is for the mc_bus_dev's DPRC itself
		
		  IRQ is for for a child device of mc_bus_dev
  NOTE: This function is invoked with interrupts disabled
	
	  Program the MSI (paddr, value) pair in the device:
	
	  irq_write_msi_msg should not be set by the caller
  fsl_mc_msi_create_irq_domain - Create a fsl-mc MSI interrupt domain
  @fwnode:	Optional firmware node of the interrupt controller
  @info:	MSI domain info
  @parent:	Parent irq domain
  Updates the domain and chip ops and creates a fsl-mc MSI
  interrupt domain.
  Returns:
  A domain pointer or NULL in case of failure.
		
		  if the msi-map property is missing assume that all the
		  child containers inherit the domain from the parent
	
	  NOTE: Calling this function will trigger the invocation of the
	  its_fsl_mc_msi_prepare() callback
 SPDX-License-Identifier: GPL-2.0-or-later
  MHI PCI driver - MHI over PCI controller driver
  This module is a generic driver for registering MHI-over-PCI devices,
  such as PCIe QCOM modems.
  Copyright (C) 2020 Linaro Ltd <loic.poulain@linaro.org>
  struct mhi_pci_dev_info - MHI PCI device specific information
  @config: MHI controller configuration
  @name: name of the PCI module
  @fw: firmware path (if any)
  @edl: emergency download mode firmware path (if any)
  @bar_num: PCI base address register to use for MHI MMIO register space
  @dma_data_width: DMA transfer word size (32 or 64 bits)
  @mru_default: default MRU size for MBIM network packets
  @sideband_wake: Devices using dedicated sideband GPIO for wakeup instead
 		   of inband wake support (such as sdx24)
 first ring is control+data ring 
 DIAG dedicated event ring 
 Hardware channels request dedicated hardware event rings 
 The EDL firmware is a flash-programmer exposing firehose protocol 
 MBIM Control Channel 
 MBIM Data Channel 
 EM120R-GL (sdx24) 
 EM160R-GL (sdx24) 
 T99W175 (sdx55), Both for eSIM and Non-eSIM 
 DW5930e (sdx55), With eSIM, It's also T99W175 
 DW5930e (sdx55), Non-eSIM, It's also T99W175 
 MV31-W (Cinterion) 
 Nothing to do for now 
 no-op 
 no-op 
 no-op 
	
	  Alloc one MSI vector for BHI + one vector per event ring, ideally...
	  No explicit pci_free_irq_vectors required, done by pcim_release.
 Patch msi vectors, use only one (shared) 
	 The runtime_get() MHI callback means:
	     Do whatever is requested to leave M3.
	 The runtime_put() MHI callback means:
	     Device can be moved in M3 state.
 Clean up MHI state 
 reschedule in two seconds 
 mhi_pdev.mhi_cntrl must be zero-initialized 
	 Have stored pci confspace at hand for restore in sudden PCI error.
	  cache the state locally and discard the PCI core one.
 MHI bus does not power up the controller by default 
 start health check 
 Only allow runtime-suspend if PME capable (for wakeup) 
 balancing probe put_noidle 
 Clean up MHI state 
 cause internal device reset 
 Be sure device reset has been executed 
 Restore initial known working PCI state 
 Is device status available ? 
 Clean up MHI state 
 Nothing to do 
 Nothing to do at MHI level 
 Transition to M3 state 
 Nothing to do at MHI level 
 Exit M3, transition to M0 state 
 Resume health check 
 It can be a remote wakeup (no mhi runtime_get), update access time 
	 Do not fail to not mess up our PCI device state, the device likely
	  lost power (d3cold) and we simply need to reset it from the recovery
	  procedure, trigger the recovery asynchronously to prevent system
	  suspend exit delaying.
	 Depending the platform, device may have lost power (d3cold), we need
	  to resume it now to check its state and recover when necessary.
	 We want to stop all operations, hibernation does not guarantee that
	  device will be in the same state as before freezing, especially if
	  the intermediate restore kernel reinitializes MHI device with new
	  context.
 Reinitialize the device 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
  Not all MHI state transitions are synchronous. Transitions like Linkdown,
  SYS_ERR, and shutdown can happen anytime asynchronously. This function will
  transition to a new state only if we're allowed to.
  Priority increases as we go down. For instance, from any state in L0, the
  transition can be made to states in L1, L2 and L3. A notable exception to
  this rule is state DISABLE.  From DISABLE state we can only transition to
  POR state. Also, while in L2 state, user cannot jump back to previous
  L1 or L0 states.
  Valid transitions:
  L0: DISABLE <--> POR
      POR <--> POR
      POR -> M0 -> M2 --> M0
      POR -> FW_DL_ERR
      FW_DL_ERR <--> FW_DL_ERR
      M0 <--> M0
      M0 -> FW_DL_ERR
      M0 -> M3_ENTER -> M3 -> M3_EXIT --> M0
  L1: SYS_ERR_DETECT -> SYS_ERR_PROCESS --> POR
  L2: SHUTDOWN_PROCESS -> LD_ERR_FATAL_DETECT
      SHUTDOWN_PROCESS -> DISABLE
  L3: LD_ERR_FATAL_DETECT <--> LD_ERR_FATAL_DETECT
      LD_ERR_FATAL_DETECT -> DISABLE
 L0 States 
 L1 States 
 L2 States 
 L3 States 
 NOP for backward compatibility, host allowed to ring DB in M2 state 
 Handle device ready state transition 
 poll register field every 25 milliseconds 
 Check if device entered error state 
 Wait for RESET to be cleared and READY bit to be set by the device 
 Configure MMIO registers 
 Add elements to all SW event rings 
 Skip if this is an offload or HW event 
 Update all cores 
 Ring the event ring db 
 Set MHI to M0 state 
 Wake up the device 
 Ring all event rings and CMD ring only if we're in mission mode 
 Only ring primary cmd ring if ring is not empty 
 Ring channel DB registers 
 Only ring DB if ring is not empty 
  After receiving the MHI state change event from the device indicating the
  transition to M1 state, the host can transition the device to M2 state
  for keeping it in low power state.
 If there are any pending resources, exit M2 immediately 
 MHI M3 completion handler 
 Handle device Mission Mode transition 
 Force MHI to be in M0 state before continuing 
 Add elements to all HW event rings 
 Update to all cores 
	
	  The MHI devices are only created when the client device switches its
	  Execution Environment (EE) to either SBL or AMSS states
 Handle shutdown transitions 
 Trigger MHI RESET so that the device will not access host memory 
 Wait for the reset bit to be cleared by the device 
		
		  Device will clear BHI_INTVEC as a part of RESET processing,
		  hence re-program it
 Release lock and wait for all pending threads to complete 
 Reset the ev rings and cmd rings 
 Skip offload events 
 Move to disable state 
 Handle system error transitions 
 We must notify MHI control driver so it can clean up first 
 Wake up threads waiting for state transition 
 Trigger MHI RESET so that the device will not access host memory 
 Wait for the reset bit to be cleared by the device 
		
		  Device will clear BHI_INTVEC as a part of RESET processing,
		  hence re-program it
 Release lock and wait for all pending threads to complete 
 Reset the ev rings and cmd rings 
 Skip offload events 
 Transition to next state 
 Queue a new work item and schedule work 
 SYS_ERR worker 
 skip if controller supports RDDM 
 Device State Transition worker 
			
			  The MHI devices are only created when the client
			  device switches its Execution Environment (EE) to
			  either SBL or AMSS states
 Return busy if there are any pending resources 
 Take MHI out of M2 state 
 Set MHI to M3 and wait for completion 
 Notify clients about entering LPM 
 Notify clients about exiting LPM 
 Set MHI to M0 and wait for completion 
 Wake up the device 
 Assert device wake db 
	
	  If force flag is set, then increment the wake count value and
	  ring wake db
		
		  If resources are already requested, then just increment
		  the wake count value and return
 De-assert device wake db 
	
	  Only continue if there is a single resource, else just decrement
	  and return
 Supply default wake routines if not provided by controller driver 
 Setup BHI INTVEC 
 Confirm that the device is in valid exec env 
		
		  device cleares INTVEC as part of RESET processing,
		  re-program it
 Transition to next state 
 Already powered down 
 If it's not a graceful shutdown, force MHI to linkdown state 
 Force link down or error fatal detected state 
 mark device inactive to avoid any further host processing 
 Wait for shutdown to complete 
 Check if device is already in RDDM 
 Wait for RDDM event 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2020, The Linux Foundation. All rights reserved.
 states 
 counters 
 for transfer device types only 
 Show controller and client(s) info 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
 MHI protocol requires the transfer ring to be aligned with ring length 
 if controller driver has set irq_flags, use it 
 Setup BHI_INTVEC IRQ 
 Setup channel ctxt 
 Skip if it is an offload channel 
 Setup event context 
 Skip if it is an offload event 
		
		  If the read pointer equals to the write pointer, then the
		  ring is empty
 Setup cmd context 
 Read channel db offset 
 Setup wake db 
 Setup channel db address for each channel in tre_ring 
 Read event ring db offset 
 Setup event db address for each ev_ring 
 Setup DB register for primary CMD rings 
 Write to MMIO registers 
 Already uninitialized 
 Update to all cores 
 Update to all cores 
 Populate event ring 
 This event ring has a dedicated channel 
 Priority is fixed to 1 for now 
	
	  The allocation of MHI channels can exceed 32KB in some scenarios,
	  so to avoid any memory possible allocation failures, vzalloc is
	  used here
 Populate channel configurations 
		
		  For some channels, local ring length should be bigger than
		  the transfer ring length due to internal logical channels
		  in device. So host can queue much more buffers than transfer
		  ring length. Example, RSC channels should have a larger local
		  channel length than transfer ring length.
		
		  For most channels, chtype is identical to channel directions.
		  So, if it is not defined then assign channel direction to
		  chtype
		
		  If MHI host allocates buffers, then the channel direction
		  should be DMA_FROM_DEVICE
		
		  Bi-directional and direction less channel must be an
		  offload channel
 Parse MHI channel configuration 
 Parse MHI event configuration 
 By default, host is allowed to ring DB in both M0 and M2 states 
 Skip for offload events 
 used in setting bei field of TRE 
 Read the MHI device info 
 Register controller with MHI bus 
 Init wakeup source 
 Drop the references to MHI devices created for channels 
		
		  This controller supports RDDM, so we need to manually clear
		  BHIE RX registers since POR values are undefined.
		
		  Allocate RDDM table for debugging purpose if specified
	
	  We need to set the mhi_chan->mhi_dev to NULL here since the MHI
	  devices for the channels will only get created if the mhi_dev
	  associated with it is NULL. This scenario will happen during the
	  controller suspend and resume.
 for MHI client devices, parent is the MHI controller device 
 for MHI controller device, parent is the bus device (e.g. pci device) 
 Bring device out of LPM 
		
		  If channel supports LPM notifications then status_cb should
		  be provided
 For non-offload channels then xfer_cb should be provided 
		
		  If channel supports LPM notifications then status_cb should
		  be provided
 For non-offload channels then xfer_cb should be provided 
		
		  If the channel event ring is managed by client, then
		  status_cb must be provided so that the framework can
		  notify pending data
 Call the user provided probe function 
 Skip if it is a controller device 
 Reset both channels 
 Wake all threads waiting for completion 
 Set the channel state to disabled 
 Reset the non-offload channel 
 De-init channel if it was enabled 
	
	  If the device is a controller type then there is no client driver
	  associated with it
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
 Setup RDDM vector table for RDDM transfer and program RXVEC 
 Collect RDDM buffer during kernel panic 
	
	  This should only be executing during a kernel panic, we expect all
	  other cores to shutdown while we're collecting RDDM buffer. After
	  returning from this function, we expect the device to reset.
	 
	  Normaly, we readwrite pm_state only after grabbing the
	  pm_lock, since we're in a panic, skipping it. Also there is no
	  gurantee that this state change would take effect since
	  we're setting it wo grabbing pm_lock
 update should take the effect immediately 
	
	  Make sure device is not already in RDDM. In case the device asserts
	  and a kernel panic follows, device will already be in RDDM.
	  Do not trigger SYS ERR again and proceed with waiting for
	  image download completion.
 Hardware reset so force device to enter RDDM 
 Download RDDM image from device 
 Wait for the image download to complete 
 Wait for the image download to complete 
 Wait for the image download to complete 
 Allocate memory for entries 
 Allocate and populate vector table 
 Vector table is the last entry 
 save hardware info from BHI 
 wait for ready on pass through or any other execution environment 
 SBL size provided is maximum size, not necessarily the image size 
 Download image using BHI 
 Error or in EDL mode, we're done 
 Wait for ready since EDL image was loaded 
	
	  If we're doing fbc, populate vector tables while
	  device transitioning into MHI READY state
 Load the firmware into BHIE vec table 
 Transitioning into MHI RESET->READY state 
 Vector table is the last entry 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
	
	  Writes to the new ring element must be visible to the hardware
	  before letting hw know there is new element to fetch.
 Generic MHI SoC reset 
 smp update 
 smp update 
 Only destroy virtual devices thats attached to bus 
	
	  If execution environment is specified, remove only those devices that
	  started in them based on ee_mask for the channels as we move on to a
	  different execution environment
	
	  For the suspend and resume case, this function will get called
	  without mhi_unregister_controller(). Hence, we need to drop the
	  references to mhi_dev created for ul and dl channels. We can
	  be sure that there will be no instances of mhi_dev left after
	  this.
 Notify the client and remove the device from MHI bus 
 Bind MHI channels to MHI devices 
 We use dl_chan as offload channels 
 Check next channel if it matches 
 Channel name is same for both UL and DL 
 Init wakeup source if available 
 Only proceed if event ring has pending events 
 For client managed event ring, notify pending data 
 proceed if power down is not already in progress 
 Wake up events waiting for state change 
 Update the WP 
 Update the RP 
 Update to all cores 
	
	  If it's a DB Event then we need to grab the lock
	  with preemption disabled and as a write because we
	  have to update db register and there are chances that
	  another thread could be doing the same.
 Get the TRB this event points to 
 If it's the last TRE, get length from the event 
 Unmap if it's not pre-mapped by client 
 truncate to buf len if xfer_len is larger 
 notify client 
 Release the reference got from mhi_queue() 
			
			  Recycle the buffer if buffer is pre-allocated,
			  if there is an error, not much we can do apart
			  from dropping the packet
 CC_EOT 
 switch(MHI_EV_READ_CODE(EV_TRB_CODE,event)) 
 offset to local descriptor 
 Received out of bound cookie 
 truncate to buf len if xfer_len is larger 
 notify the client 
	
	  Note: We're arbitrarily incrementing RP even though, completion
	  packet we processed might not be the same one, reason we can do this
	  is because device guaranteed to cache descriptors in order it
	  receive, so even though completion event is different we can re-use
	  all descriptors in between.
	  Example:
	  Transfer Ring has descriptors: A, B, C, D
	  Last descriptor host queue is D (WP) and first descriptor
	  host queue is A (RP).
	  The completion event we just serviced is descriptor C.
	  Then we can safely queue descriptors to replace A, B, and C
	  even though host did not receive any completions.
	
	  This is a quick check to avoid unnecessary event processing
	  in case MHI is already in error state, but it's still possible
	  to transition to error state while processing events
			
			  Only process the event ring elements whose channel
			  ID is within the maximum supported range.
		
		  Only process the event ring elements whose channel
		  ID is within the maximum supported range.
 process all pending events 
	
	  We can check PM state wo a lock here because there is no way
	  PM state can change from reg access valid to no access while this
	  thread being executed.
		
		  We may have a pending event but not allowed to
		  process it since we are probably in a suspended state,
		  so trigger a resume.
 Process ctrl events events 
	
	  We received an IRQ but no events to process, maybe device went to
	  SYS_ERR state? Check the state to confirm.
	 Packet is queued, take a usage ref to exit M3 if necessary
	  for host->device buffer, balanced put is done on buffer completion
	  for device->host buffer, balanced put is after ringing the DB
 Assert dev_wake (to exitprevent M1M2)
 increment WP 
 prepare the cmd tre 
 queue to hardware 
 bring host and device out of suspended states 
 no more processing events for this channel 
 Check of client manages channel context for offload channels 
 Pre-allocate buffer for xfer ring 
 Prepare transfer descriptors 
 mark all stale events related to channel as STALE event 
 Reset any pending buffers 
 Release the reference got from mhi_queue() 
 Nothing to reset, client doesn't queue buffers 
 Move channel to start state 
  pbias-regulator.c
  Copyright (C) 2014 Texas Instruments Incorporated - https:www.ti.com
  Author: Balaji T K <balajitk@ti.com>
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 Offset from SCM general area (and syscon) base 
 SPDX-License-Identifier: GPL-2.0+
 max8998.c - Voltage regulator driver for the Maxim 8998
  Copyright (C) 2009-2010 Samsung Electronics
  Kyungmin Park <kyungmin.park@samsung.com>
  Marek Szyprowski <m.szyprowski@samsung.com>
 voltages for selection 
 index to last changed voltage 
 value in a set 
 check if requested voltage 
 value is already defined 
 no predefine regulator found 
 check if requested voltage 
 value is already defined 
 Voltage stabilization 
 lp3974 hasn't got ENRAMP bit - ramp is assumed as true 
 MAX8998 has ENRAMP bit implemented, so test it
 search for closest to maximum 
 Swapped as register is inverted 
 count the number of regulators to be supported in pmic 
 NOTE: 
 For unused GPIO NOT marked as -1 (thereof equal to 0)  WARN_ON 
 will be displayed 
 Check if MAX8998 voltage selection GPIOs are defined 
 Check if SET1 is not equal to 0 
 Check if SET2 is not equal to 0 
 Set predefined values for BUCK1 registers 
 Check if SET3 is not equal to 0 
 Set predefined values for BUCK2 registers 
 SPDX-License-Identifier: GPL-2.0
 sky81452-regulator.c	SKY81452 regulator driver
 Copyright 2014 Skyworks Solutions Inc.
 Author : Gyungoh Yoo <jack.yoo@skyworksinc.com>
 registers 
 bit mask 
 SPDX-License-Identifier: GPL-2.0-only
  max8907-regulator.c -- support regulators in max8907
  Copyright (C) 2010 Gyungoh Yoo <jack.yoo@maxim-ic.com>
  Copyright (C) 2010-2012, NVIDIA CORPORATION. All rights reserved.
  Portions based on driversregulatortps65910-regulator.c,
      Copyright 2010 Texas Instruments Inc.
      Author: Graeme Gregory <gg@slimlogic.co.uk>
      Author: Jorge Eduardo Candelaria <jedu@slimlogic.co.uk>
 Backwards compatibility with MAX8907B; SD1 uses different voltages 
 SPDX-License-Identifier: GPL-2.0
 SY8827N regulator driver
 Copyright (C) 2020 Synaptics Incorporated
 Author: Jisheng Zhang <jszhang@kernel.org>
 SPDX-License-Identifier: GPL-2.0-or-later
 NXP PCF50633 PMIC Driver
  (C) 2006-2008 by Openmoko, Inc.
  Author: Balaji Rao <balajirrao@openmoko.org>
  All rights reserved.
  Broken down from monstrous PCF50633 driver mainly by
  Harald Welte and Andy Green and Werner Almesberger
 Already set by core driver 
 SPDX-License-Identifier: GPL-2.0+
 wm831x-ldo.c  --  LDO driver for the WM831x series
 Copyright 2009 Wolfson Microelectronics PLC.
 Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
  Shared
  General purpose LDOs
 Is the regulator on? 
 Is it reporting under voltage? 
  Analogue LDOs
 Is the regulator on? 
 Is it reporting under voltage? 
  Alive LDO
 Is the regulator on? 
 Module information 
 SPDX-License-Identifier: GPL-2.0-or-later
  Voltage regulation driver for active-semi ACT8945A PMIC
  Copyright (C) 2015 Atmel Corporation
  Author: Wenyou Yang <wenyou.yang@atmel.com>
  ACT8945A Global Register Map.
  Field Definitions.
 ON - [7] 
 VSET - [5:0] 
  ACT8945A Voltage Number
	
	  Ask the PMIC to enabledisable this output when entering hibernate
	  mode.
 Unlock expert registers. 
	
	  Ask the PMIC to enter the suspend mode on the next PWRHLD
	  transition.
	
	  Ask the PMIC to shutdown everything on the next PWRHLD transition.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) ST-Ericsson SA 2010
  Authors: Sundar Iyer <sundar.iyer@stericsson.com> for ST-Ericsson
           Bengt Jonsson <bengt.g.jonsson@stericsson.com> for ST-Ericsson
  UX500 common part of Power domain regulators
  power state reference count
 will initialize to zero 
 print power state count 
 print dump header 
 Access per-regulator data 
 print status 
 create directory 
 create "status" file 
 create "power-state-count" file 
  Regulator driver for TI TPS65912x PMICs
  Copyright (C) 2015 Texas Instruments Incorporated - https:www.ti.com
 	Andrew F. Davis <afd@ti.com>
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether expressed or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License version 2 for more details.
  Based on the TPS65218 driver and the previous TPS65912 driver by
  Margarita Olaya Cabrera <magi@slimlogic.co.uk>
 Operations permitted on DCDCx 
 Operations permitted on LDOx 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 MediaTek Inc.
  MT6358 regulators' information
  @desc: standard fields of regulator description.
  @qi: Mask for query enable signal status of regulators
 The array is indexed by id(MT6358_ID_XXX) 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
  TI LP8788 MFD - buck regulator driver
  Copyright 2012 Texas Instruments
  Author: Milo(Woogyom) Kim <milo.kim@ti.com>
 register address 
 maskshift bits 
 Addr 0Ch 
 Addr 1Dh 
 Addr 1Eh ~ 27h 
 Addr 28h ~ 2Bh 
 Addr 2Dh 
 BUCK 1 ~ 4 voltage ranges 
 no dvs for buck3, 4 
 no dvs platform data, then dvs will be selected by I2C registers 
  tps6507x-regulator.c
  Regulator driver for TPS65073 PMIC
  Copyright (C) 2009 Texas Instrument Incorporated - https:www.ti.com
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any kind,
  whether express or implied; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.
 DCDC's 
 LDOs 
 Number of step-down converters available 
 Number of LDO voltage regulators  available 
 Number of total regulators available 
 Supported voltage values for regulators (in microVolts) 
 The voltage mapping table for LDO2 is the same as VDCDCx 
 Does DCDC high or the low register defines output voltage? 
	
	  tps_board points to pmic related constants
	  coming from the board-evm file.
 common for all regulators 
 Register the regulators 
 SPDX-License-Identifier: GPL-2.0
 Regulator Driver for Freescale MC13892 PMIC
 Copyright 2010 Yong Shen <yong.shen@linaro.org>
 Based on draft driver from Arnaud Patard <arnaud.patard@rtp-net.org>
  Note: this table is used to derive SWxVSEL by index into
  the array. Offset the values by the index of 1100000uV
  to get the actual register value for that voltage selector
  if the HI bit is to be set as well.
 Update the stored state for Power Gates. 
 Construct the new register value 
 Overwrite the PWGTxEN with the stored version 
 Power Gate enable value is 0 
 Power Gate disable value is 1 
	 Power Gates state is stored in powermisc_pwgt_state
	
	  Figure out if the HI bit is set inside the switcher mode register
	  since this means the selector value we return is at a different
	  offset into the selector table.
	 
	  According to the MC13892 documentation note 59 (Table 47) the SW1
	  buck switcher does not support output range programming therefore
	  the HI bit must always remain 0. So do not do anything strange if
	  our register is MC13892_SWITCHERS0.
	
	  Don't mess with the HI bit or support HI voltage offsets for SW1.
	 
	  Since the get_voltage_sel callback has given a fudged value for
	  the selector offset, we need to back out that offset if HI is
	  to be set so we write the correct value to the register.
	 
	  The HI bit addition and selector offset handling COULD be more
	  complicated by shifting and masking off the voltage selector part
	  of the register then logical OR it back in, but since the selector
	  is at bits 4:0 there is very little point. This makes the whole
	  thing more readable and we do far less work.
 enable switch auto mode (on 2.0A silicon only) 
 update mc13892_vcam ops 
 SPDX-License-Identifier: GPL-2.0
 MCP16502 PMIC driver
 Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries
 Author: Andrei Stefanescu <andrei.stefanescu@microchip.com>
 Inspired from tps65086-regulator.c
  The PMIC has four sets of registers corresponding to four power modes:
  Performance, Active, Low-power, Hibernate.
  Registers:
  Each regulator has a register for each power mode. To access a register
  for a specific regulator and mode BASE_ and OFFSET_ need to be added.
  Operating modes:
  In order for the PMIC to transition to operating modes it has to be
  controlled via GPIO lines called LPM and HPM.
  The registers are fully configurable such that you can put all regulators in
  a low-power state while the PMIC is in Active mode. They are supposed to be
  configured at startup and then simply transition tofrom a global low-power
  state by setting the GPIO lpm pin highlow.
  This driver keeps the PMIC in Active mode, Low-power state is set for the
  regulators by enablingdisabling operating mode (FPWM or Auto PFM).
  The PMIC's Low-power and Hibernate modes are used during standbysuspend.
  To enter standbysuspend the PMIC will go to Low-power mode. From there, it
  will transition to Hibernate when the PWRHLD line is set to low by the MPU.
  This function is useful for iterating over all regulators and accessing their
  registers in a generic way or accessing a regulator device by its id.
  enum mcp16502_reg - MCP16502 regulators's registers
  @MCP16502_REG_A: active state register
  @MCP16502_REG_LPM: low power mode state register
  @MCP16502_REG_HIB: hibernate state register
  @MCP16502_REG_SEQ: startup sequence register
  @MCP16502_REG_CFG: configuration register
 Ramp delay (uVus) for buck1, ldo1, ldo2. 
 Ramp delay (uVus) for buck2, buck3, buck4. 
  struct mcp16502 - PMIC representation
  @lpm: LPM GPIO descriptor
  mcp16502_gpio_set_mode() - set the GPIO corresponding value
  Used to prepare transitioning into hibernate or resuming from it.
  mcp16502_get_reg() - get the PMIC's state configuration register for opmode
  @rdev: the regulator whose register we are searching
  @opmode: the PMIC's operating mode ACTIVE, Low-power, Hibernate
  mcp16502_get_mode() - return the current operating mode of a regulator
  Note: all functions that are not part of enteringexiting standbysuspend
 	 use the Active mode registers.
  Note: this is different from the PMIC's operatig mode, it is the
 	 MODE bit from the regulator's register.
  _mcp16502_set_mode() - helper for set_mode and set_suspend_mode
  @rdev: the regulator for which we are setting the mode
  @mode: the regulator's mode (the one from MODE bit)
  @opmode: the PMIC's operating mode: ActiveLow-powerHibernate
  mcp16502_set_mode() - regulator_ops set_mode
  mcp16502_get_status() - regulator_ops get_status
  mcp16502_suspend_get_target_reg() - get the reg of the target suspend PMIC
 				       mode
  mcp16502_set_suspend_voltage() - regulator_ops set_suspend_voltage
  mcp16502_set_suspend_mode() - regulator_ops set_suspend_mode
  mcp16502_set_suspend_enable() - regulator_ops set_suspend_enable
  mcp16502_set_suspend_disable() - regulator_ops set_suspend_disable
 CONFIG_SUSPEND 
 CONFIG_SUSPEND 
  LDOs cannot change operating modes.
 CONFIG_SUSPEND 
 MCP16502_REGULATOR(_name, _id, ranges, regulator_ops, ramp_table) 
 SPDX-License-Identifier: GPL-2.0+
 da9210-regulator.c - Regulator device driver for DA9210
 Copyright (C) 2013  Dialog Semiconductor Ltd.
 Default limits measured in millivolts and milliamps 
 Current limits for buck (uA) indices corresponds with register values 
 Clear handled events 
  I2C driver interface functions
 Mask all interrupt sources to deassert interrupt line 
 SPDX-License-Identifier: GPL-2.0-only
  Regulator driver for TI TPS6586x
  Copyright (C) 2010 Compulab Ltd.
  Author: Mike Rapoport <mike@compulab.co.il>
  Based on da903x
  Copyright (C) 2006-2008 Marvell International Ltd.
  Copyright (C) 2008 Compulab Ltd.
 supply control and voltage setting  
 converter settings  
  TPS6586X has 2 enable bits that are OR'ed to determine the actual
  regulator state. Clearing one of this bits allows switching
  regulator on and of with single register write.
	
	  The regulator is on, but it's enabled with the bit we don't
	  want to use, so we switch the enable bits
 only SM0 and SM1 can have the slew rate settings 
 Search version specific table first 
 SPDX-License-Identifier: GPL-2.0-only
  Regulator driver for tps65090 power management chip.
  Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
 Regulator enable bit, active high 
 Regulator wait time 0 bit 
 Regulator power good bit, 1=good 
 Regulator timeout bit, 1=wait 
 Overcurrent wait must be <= this 
  struct tps65090_regulator - Per-regulator data for a tps65090 regulator
  @dev: Pointer to our device.
  @desc: The struct regulator_desc for the regulator.
  @rdev: The struct regulator_dev for the regulator.
  @overcurrent_wait_valid: True if overcurrent_wait is valid.
  @overcurrent_wait: For FETs, the value to put in the WTFET bitfield.
  tps65090_reg_set_overcurrent_wait - Setup overcurrent wait
  This will set the overcurrent wait time based on what's in the regulator
  info.
  @ri:		Overall regulator data
  @rdev:	Regulator device
  Return: 0 if no error, non-zero if there was an error writing the register.
  tps65090_try_enable_fet - Try to enable a FET
  @rdev:	Regulator device
  Return: 0 if ok, -ENOTRECOVERABLE if the FET power good bit did not get
  set, or some other -ve value if another error occurred (e.g. i2c error)
  tps65090_fet_enable - Enable a FET, trying a few times if it fails
  Some versions of the tps65090 have issues when turning on the FETs.
  This function goes through several steps to ensure the best chance of the
  FET going on.  Specifically:
  - We'll make sure that we bump the "overcurrent wait" to the maximum, which
    increases the chances that we'll turn on properly.
  - We'll retry turning the FET on multiple times (turning off in between).
  @rdev:	Regulator device
  Return: 0 if ok, non-zero if it fails.
	
	  Try enabling multiple times until we succeed since sometimes the
	  first try times out.
 Try turning the FET off (and then on again) 
	
	  First enable output for internal control if require.
	  And then disable external control.
		
		  TPS5090 DCDC support the control from external digital input.
		  Configure it as per platform data.
		
		  Hand the GPIO descriptor management over to the regulator
		  core, remove it from devres management.
 Enable external control if it is require 
 SPDX-License-Identifier: GPL-2.0+
 arizona-ldo1.c  --  LDO1 supply for Arizona devices
 Copyright 2012 Wolfson Microelectronics PLC.
 Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
	 We assume that high output = regulator off
	  Don't use devm, since we need to get against the parent device
	  so clean up would happen at the wrong time
	
	  LDO1 can only be used to supply DCVDD so if it has no
	  consumers then DCVDD is supplied externally.
	
	  Since the chip usually supplies itself we provide some
	  default init_data for it.  This will be overridden with
	  platform data if provided.
 Module information 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018 ROHM Semiconductors
 bd71837-regulator.c ROHM BD71837MWVBD71847MWV regulator driver
 Typical regulator startup times as per data sheet in uS 
  BD718(374750) have two "enable control modes". ONOFF can either be
  controlled by software - or by PMIC internal HW state machine. Whether
  regulator should be under SW or HW control can be defined from device-tree.
  Let's provide separate ops for regulators to use depending on the "enable
  control mode".
  BUCK1234
  BUCK1RAMPRATE[1:0] BUCK1 DVS ramp rate setting
  00: 10.00mVusec 10mV 1uS
  01: 5.00mVusec	10mV 2uS
  10: 2.50mVusec	10mV 4uS
  11: 1.25mVusec	10mV 8uS
 These functions are used when regulators are under HW state machine control.
  We assume PMIC is in RUN state because SW running and able to query the
  status. Most of the regulators have fixed ON or OFF state at RUNIDLE so for
  them we just return a constant. BD71837 BUCK3 and BUCK4 are exceptions as
  they support configuring the ONOFF state for RUN.
  Note for next hacker - these PMICs have a register where the HW state can be
  read. If assuming RUN appears to be false in your use-case - you can
  implement state reading (although that is not going to be atomic) before
  returning the enable state.
  On BD71837 (not on BD71847, BD71850, ...)
  Bucks 1 to 4 support DVS. PWM mode is used when voltage is changed.
  Bucks 5 to 8 and LDOs can use PFM and must be disabled when voltage
  is changed. Hence we return -EBUSY for these if voltage is changed
  when BUCKLDO is enabled.
  On BD71847, BD71850, ... The LDO voltage can be changed when LDO is
  enabled. But if voltage is increased the LDO power-good monitoring
  must be disabled for the duration of changing + 1mS to ensure voltage
  has reached the higher level before HW does next under voltage detection
  cycle.
		
		  Let's allow scheduling as we use I2C anyways. We just need to
		  guarantee minimum of 1ms sleep - it shouldn't matter if we
		  exceed it due to the scheduling.
		
		  If we increase LDO voltage when LDO is enabled we need to
		  disable the power-good detection until voltage has reached
		  the new level. According to HW colleagues the maximum time
		  it takes is 1000us. I assume that on systems with light load
		  this might be less - and we could probably use DT to give
		  system specific delay value if performance matters.
		 
		  Well, knowing we use I2C here and can add scheduling delays
		  I don't think it is worth the hassle and I just add fixed
		  1ms sleep here (and allow scheduling). If this turns out to
		  be a problem we can change it to delay and make the delay
		  time configurable.
 We disable protection if it was enabled... 
 ...and we also want to re-enable it 
  BD71837 BUCK1234
  BD71847 BUCK12
  0.70 to 1.30V (10mV step)
  BD71837 BUCK5
  0.7V to 1.35V  (range 0)
  and
  0.675 to 1.325 (range 1)
 Ranges when VOLT_SEL bit is 0 
 Ranges when VOLT_SEL bit is 1  
  Range selector for first 3 linear ranges is 0x0
  and 0x1 for last 3 ranges.
  BD71847 BUCK3
 Ranges when VOLT_SEL bits are 00 
 Ranges when VOLT_SEL bits are 01 
 Ranges when VOLT_SEL bits are 11 
  BUCK6
  3.0V to 3.3V (step 100mV)
  BD71837 BUCK7
  BD71847 BUCK5
  000 = 1.605V
  001 = 1.695V
  010 = 1.755V
  011 = 1.8V (Initial)
  100 = 1.845V
  101 = 1.905V
  110 = 1.95V
  111 = 1.995V
  BUCK8
  0.8V to 1.40V (step 10mV)
  LDO1
  3.0 to 3.3V (100mV step)
  LDO2
  0.8 or 0.9V
  LDO3
  1.8 to 3.3V (100mV step)
  LDO4
  0.9 to 1.8V (100mV step)
  LDO5 for BD71837
  1.8 to 3.3V (100mV step)
  LDO5 for BD71837
  1.8 to 3.3V (100mV step)
  LDO6
  0.9 to 1.8V (100mV step)
  LDO7
  1.8 to 3.3V (100mV step)
	
	  BD718374750 ... (ICs supported by this driver) do not provide
	  warnings, only protection
	
	  And protection limit is not changeable. It can only be enabled
	  or disabled
  OPS common for BD71847 and BD71850
 BD71847 and BD71850 LDO 5 is by default OFF at RUN state 
  OPS for BD71837
  BD71837 bucks 3 and 4 support defining their enabledisable state also
  when buck enable state is under HW state machine control. In that case the
  bit [2] in CTRL register is used to indicate if regulator should be ON.
  OPS for all of the ICs - BD718(374750)
  There is a HW quirk in BD71837. The shutdown sequence timings for
  bucksLDOs which are controlled via register interface are changed.
  At PMIC poweroff the voltage for BUCK67 is cut immediately at the
  beginning of shut-down sequence. As bucks 6 and 7 are parent
  supplies for LDO5 and LDO6 - this causes LDO56 voltage
  monitoring to errorneously detect under voltage and force PMIC to
  emergency state instead of poweroff. In order to avoid this we
  disable voltage monitoring for LDO5 and LDO6
 LDO6 is supplied by buck5 
 LDO5 is supplied by buck6 
 LDO6 is supplied by buck7 
  Setups where regulator (especially the buck8) output voltage is scaled
  by adding external connection where some other regulator output is connected
  to feedback-pin (over suitable resistors) is getting popular amongst users
  of BD71837. (This allows for example scaling down the buck8 voltages to suit
  lover GPU voltages for projects where buck8 is (ab)used to supply power
  for GPU. Additionally some setups do allow DVS for buck8 but as this do
  produce voltage spikes the HW must be evaluated to be able to survive this
  - hence I keep the DVS disabled for non DVS bucks by default. I don't want
  to help you burn your proto board)
  So we allow describing this external connection from DT and scale the
  voltages accordingly. This is what the connection should look like:
  |------------|
  |	buck 8  |-------+----->Vout
  |		|	|
  |------------|	|
 	| FB pin	|
 	|		|
 	+-------+--R2---+
 		|
 		R1
 		|
 	V FB-pull-up
 	Here the buck output is sifted according to formula:
  Vout_o = Vo - (Vpu - Vo)R2R1
  Linear_step = step_orig(R1+R2)R1
  where:
  Vout_o is adjusted voltage output at vsel reg value 0
  Vo is original voltage output at vsel reg value 0
  Vpu is the pull-up voltage V FB-pull-up in the picture
  R1 and R2 are resistor values.
  As a real world example for buck8 and a specific GPU:
  VLDO = 1.6V (used as FB-pull-up)
  R1 = 1000ohms
  R2 = 150ohms
  VSEL 0x0 => 0.8V – (VLDO – 0.8)  R2  R1 = 0.68V
  Linear Step = 10mV  (R1 + R2)  R1 = 11.5mV
	
	  We do adjust the values in the global desc based on DT settings.
	  This may not be best approach as it can cause problems if more than
	  one PMIC is controlled from same processor. I don't see such use-case
	  for BD718x7 now - so we spare some bits.
	 
	  If this will point out to be a problem - then we can allocate new
	  bd718xx_regulator_data array at probe and just use the global
	  array as a template where we copy initial values. Then we can
	  use allocated descs for regultor registration and do IC specific
	  modifications to this copy while leaving other PMICs untouched. But
	  that means allocating new array for each PMIC - and currently I see
	  no need for that.
 The feedback loop connection does not make sense for LDOs 
 Register LOCK release 
	
	  Change the next stage from poweroff to be READY instead of SNVS
	  for all reset types because OTP loading at READY will clear SEL
	  bit allowing HW defaults for power rails to be used
	
	  There are cases when we want to leave the enable-control for
	  the HW state machine and use this driver only for voltage control.
	  One special case is when we use PMIC_STBY_REQ line from SoC to PMIC
	  in order to set the system to SUSPEND state.
	 
	  If regulator is taken under SW control the regulator state will not
	  be affected by PMIC state machine - Eg. regulator is likely to stay
	  on even in SUSPEND
		
		  Regulator register gets the regulator constraints and
		  applies them (set_machine_constraints). This should have
		  turned the control register(s) to correct values and we
		  can now switch the control from PMIC state machine to the
		  register interface
		 
		  At poweroff transition PMIC HW disables EN bit for
		  regulators but leaves SEL bit untouched. So if state
		  transition from POWEROFF is done to SNVS - then all power
		  rails controlled by SW (having SEL bit set) stay disabled
		  as EN is cleared. This will result boot failure if any
		  crucial systems are powered by these rails. We don't
		  enable SW control for crucial regulators if snvs state is
		  used
 SPDX-License-Identifier: GPL-2.0+
 wm831x-isink.c  --  Current sink driver for the WM831x series
 Copyright 2009 Wolfson Microelectronics PLC.
 Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
 We have a two stage enable: first start the ISINK... 
 ...then enable drive 
	 For current parts this is correct; probably need to revisit
	  in future.
 Module information 
 SPDX-License-Identifier: GPL-2.0+
 Regulator device driver for DA9061 and DA9062.
 Copyright (C) 2015-2017  Dialog Semiconductor
 Regulator IDs 
 Regulator capabilities and registers description 
 Main register fields 
 Event detection bit 
 Single regulator settings 
 Encapsulates all information for the regulators driver 
 Array size to be defined during init. Keep at end. 
 Regulator operations 
 Current limits array (in uA)
  - DA9061_ID_[BUCK1|BUCK3]
  - DA9062_ID_[BUCK1|BUCK2|BUCK4]
  Entry indexes corresponds to register values.
 Current limits array (in uA)
  - DA9061_ID_BUCK2
  - DA9062_ID_BUCK3
  Entry indexes corresponds to register values.
  Bucks use single mode register field for normal operation
  and suspend state.
  There are 3 modes to map to: FAST, NORMAL, and STANDBY.
 Sleep flag bit decides the mode 
  LDOs use sleep flags - one for normal and one for suspend state.
  There are 2 modes to map to: NORMAL and STANDBY (sleep) for each state.
 DA9061 Regulator information 
 DA9062 Regulator information 
 Regulator interrupt handlers 
 Allocate memory required by usable regulators 
 Initialise regulator structure 
 Register regulator 
 LDOs overcurrent event support 
 Module information 
 SPDX-License-Identifier: GPL-2.0-only
  Regulator driver for PWM Regulators
  Copyright (C) 2014 - STMicroelectronics Inc.
  Author: Lee Jones <lee.jones@linaro.org>
  Shared 
 Voltage table 
 Continuous mode info 
 regulator descriptor 
 Enable GPIO 
  Voltage table call-backs
	
	  The dutycycle for min_uV might be greater than the one for max_uV.
	  This is happening when the user needs an inversed polarity, but the
	  PWM device does not support inversing it in hardware.
	
	  The dutycycle for min_uV might be greater than the one for max_uV.
	  This is happening when the user needs an inversed polarity, but the
	  PWM device does not support inversing it in hardware.
 SPDX-License-Identifier: GPL-2.0-only
  Driver for TPS6105061052 boost converters, typically used for white LEDs
  or audio amplifiers.
  Copyright (C) 2011 ST-Ericsson SA
  Written on behalf of Linaro for ST-Ericsson
  Author: Linus Walleij <linus.walleij@linaro.org>
 There is an additional 5V 
  Registers the chip as a voltage regulator
 This instance is not set for regulator mode so bail out 
 Register regulator with framework 
 SPDX-License-Identifier: GPL-2.0+
 da9211-regulator.c - Regulator device driver for DA9211DA9212
 DA9213DA9223DA9214DA9224DA9215DA9225
 Copyright (C) 2015  Dialog Semiconductor Ltd.
 DEVICE IDs 
 DA9211 REGULATOR IDs 
 Default limits measured in millivolts and milliamps 
 Current limits for DA9211 buck (uA) indices
  corresponds with register values
 Current limits for DA9213 buck (uA) indices
  corresponds with register values
 Current limits for DA9215 buck (uA) indices
  corresponds with register values
 search for closest to maximum 
	 select one of 16 values: 0000 (2000mA or 3000mA)
	  to 1111 (5000mA or 6000mA).
	 If configuration for 12 bucks is different between platform data
	  and the register, driver should exit.
		
		  Hand the GPIO descriptor management over to the regulator
		  core, remove it from GPIO devres management.
  I2C driver interface functions
 SPDX-License-Identifier: GPL-2.0-only
  TI LP8788 MFD - ldo regulator driver
  Copyright 2012 Texas Instruments
  Author: Milo(Woogyom) Kim <milo.kim@ti.com>
 register address 
 DLDO 1 ~ 8 
 DLDO 9 ~ 12, ALDO 1 ~ 4 
 ALDO 5 ~ 10 
 maskshift bits 
 Addr 0Dh ~ 0Fh 
 Addr 10h 
 Addr 2Eh ~ 43h 
 Addr 44h ~ 59h 
 DLDO 1, 2, 3, 9 voltage table 
 DLDO 4 voltage table 
 DLDO 5, 7, 8 and ALDO 6 voltage table 
 DLDO 6 voltage table 
 DLDO 10, 11 voltage table 
 ALDO 1 voltage table 
 ALDO 7 voltage table 
	
	  Do not use devm here: the regulator core takes over the
	  lifecycle management of the GPIO descriptor.
	  FIXME: check default mode for GPIO here: high or low?
 if no GPIO for ldo pin, then set default enable mode 
 SPDX-License-Identifier: GPL-2.0+
 Copyright (c) 2013 Samsung Electronics Co., Ltd
		http:
 Ramp delay can be enableddisabled only for buck[1234] 
 Module information 
  Motorola CPCAP PMIC regulator driver
  Based on cpcap-regulator.c from Motorola Linux kernel tree
  Copyright (C) 2009-2011 Motorola, Inc.
  Rewritten for mainline kernel to use device tree and regmap
  Copyright (C) 2017 Tony Lindgren <tony@atomide.com>
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
  Resource assignment register bits. These seem to control the state
  idle modes adn are used at least for omap4.
 CPCAP_REG_ASSIGN2 bits - Resource Assignment 2 
 CPCAP_REG_ASSIGN3 bits - Resource Assignment 3 
 CPCAP_REG_ASSIGN4 bits - Resource Assignment 4 
  Enable register bits. At least CPCAP_BIT_AUDIO_LOW_PWR is generic,
  and not limited to audio regulator. Let's use the Motorola kernel
  naming for now until we have a better understanding of the other
  enable register bits. No idea why BIT(3) is not defined.
  Off mode configuration bit. Used currently only by SW5 on omap4. There's
  the following comment in Motorola Linux kernel tree for it:
  When set in the regulator mode, the regulator assignment will be changed
  to secondary when the regulator is disabled. The mode will be set back to
  primary when the regulator is turned on.
  SoC specific configuration for CPCAP regulator. There are at least three
  different SoCs each with their own parameters: omap3, omap4 and tegra2.
  The assign_reg and assign_mask seem to allow toggling between primary
  and secondary mode that at least omap4 uses for off mode.
  We need to also configure regulator idle mode for SoC off mode if
  CPCAP_REG_OFF_MODE_SEC is set.
  We need to also configure regulator idle mode for SoC off mode if
  CPCAP_REG_OFF_MODE_SEC is set.
 Quirk: 2775000 is before 2500000 for vrf1 regulator 
  SoC specific configuration for omap4. The data below is comes from Motorola
  Linux kernel tree. It's basically the values of cpcap_regltr_data,
  cpcap_regulator_mode_values and cpcap_regulator_off_mode_values, see
  CPCAP_REG macro above.
  SW1 to SW4 and SW6 seems to be unused for mapphone. Note that VSIM and
  VSIMCARD have a shared resource assignment bit.
 sentinel  },
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
 DA9121 Single-channel dual-phase 10A buck converter
 Copyright (C) 2020 Axis Communications AB
 DA9130 Single-channel dual-phase 10A buck converter (Automotive)
 DA9217 Single-channel dual-phase  6A buck converter
 DA9122 Dual-channel single-phase  5A buck converter
 DA9131 Dual-channel single-phase  5A buck converter (Automotive)
 DA9220 Dual-channel single-phase  3A buck converter
 DA9132 Dual-channel single-phase  3A buck converter (Automotive)
 Copyright (C) 2020 Dialog Semiconductor
 Chip data 
 Define ranges for different variants, enabling translation tofrom
  registers. Maximums give scope to allow for transients.
DA9121_TYPE_DA9121_DA9130
DA9121_TYPE_DA9220_DA9132
DA9121_TYPE_DA9122_DA9131
DA9121_TYPE_DA9217
 0=core, 12-buck 
 index for statuseventmask register selection 
 bit masks... 
 Notification for status inception 
 if NULL, notify - otherwise dev_warn this string 
 For second buck related event bits that are specific to DA9122, DA9220 variants 
 The status signals that may need servicing, depending on device variant.
  After assertion, they persist; so event is notified, the IRQ disabled,
  and status polled until clear again and IRQ is reenabled.
  SGPG1PG2 should be set when device first powers up and should never
  re-occur. When this driver starts, it is expected that these will have
  self-cleared for when the IRQs are enabled, so these should never be seen.
  If seen, the implication is that the device has reset.
  GPIO012 are not configured for use by default, so should not be seen.
 Default value of BUCK_BUCK1_0.CH1_SRC_DVC_UP 
 tBUCK_EN 
	 Possible events are tested to be within range for the variant, potentially
	  masked by the IRQ handler (not just warned about), as having been masked,
	  and the respective state cleared - then flagged to unmask for next IRQ.
	 Possible events are tested to be within range for the variant, currently
	  enabled, and having triggered this IRQ. The event may then be notified,
	  or a warning given for unexpected events - those from device POR, and
	  currently unsupported GPIO configurations.
 Mask the interrupts for persistent events OV, OC, UV, WARN, CRIT 
 clear the events 
 DA9121 chip register model 
 DA9121 regmap config for 1 channel variants 
 DA9121 regmap config for 2 channel variants 
	 Use configured subtype to select the regulator descriptor index and
	  register map, common to both consumer and automotive grade variants
 Set these up for of_regulator_match call which may want .of_map_modes 
 SPDX-License-Identifier: GPL-2.0+
 Functions to access SY3686A power management chip voltages
 Copyright (C) 2019 reMarkable AS - http:
 Authors: Lars Ivar Miljeteig <lars.ivar.miljeteig@remarkable.com>
          Alistair Francis <alistair@alistair23.me>
 SPDX-License-Identifier: GPL-2.0
  regulator_register_fixed_name - register a no-op fixed regulator
  @id: platform device id
  @name: name to be used for the regulator
  @supplies: consumers for this regulator
  @num_supplies: number of consumers
  @uv: voltage in microvolts
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) ST-Ericsson SA 2010
  Authors: Bengt Jonsson <bengt.g.jonsson@stericsson.com>
  This file is based on driversregulatorab8500.c
  AB8500 external regulators
  ab8500-ext supports the following regulators:
  - VextSupply3
 AB8500 external regulators 
 requires hw mode or high power mode 
 supply for VextSupply3 
 SIM supply for 3 V SIM cards 
  AB8500 external regulators
 fixed Vbat supplies VSMPS1_EXT_1V8 
 fixed Vbat supplies VSMPS2_EXT_1V36 and VSMPS5_EXT_1V15 
 fixed Vbat supplies VSMPS3_EXT_3V4 and VSMPS4_EXT_3V4 
  struct ab8500_ext_regulator_info - ab8500 regulator information
  @dev: device pointer
  @desc: regulator description
  @cfg: regulator configuration (extension of regulator FW configuration)
  @update_bank: bank to control onoff
  @update_reg: register to control onoff
  @update_mask: mask to enabledisable and set mode of regulator
  @update_val: bits holding the regulator current mode
  @update_val_hp: bits to set EN pin active (LPn pin deactive)
                  normally this means high power mode
  @update_val_lp: bits to set EN pin active and LPn pin active
                  normally this means low power mode
  @update_val_hw: bits to set regulator pins in HW control
                  SysClkReq pins and logic will choose mode
	
	  To satisfy both HW high power request and SW request, the regulator
	  must be on in high power.
	
	  Set the regulator in HW request mode if configured
	 If regulator is enabled and info->cfg->hwreq is set, the regulator
	   must be on in high power, so we don't need to write the register with
	   the same value.
 return the uV for the fixed regulators 
 check for AB8500 2.x 
 VextSupply3LPn is inverted on AB8500 2.x 
 register all regulators 
 assign per-regulator data 
 register regulator with framework 
 SPDX-License-Identifier: GPL-2.0-or-later
  Broadcom BCM590xx regulator driver
  Copyright 2014 Linaro Limited
  Author: Matt Porter <mporter@linaro.org>
 I2C slave 0 registers 
 I2C slave 1 registers 
  RFLDO to VSR regulators are
  accessed via I2C slave 0
 LDO regulator IDs 
 DCDC regulator IDs 
  GPLDO1 to VBUS regulators are
  accessed via I2C slave 1
 LDO group A: supported voltages in microvolts 
 LDO group C: supported voltages in microvolts 
 DCDC group CSR: supported voltages in microvolts 
 DCDC group IOSR1: supported voltages in microvolts 
 DCDC group SDSR1: supported voltages in microvolts 
 Register the regulators 
 SPDX-License-Identifier: GPL-2.0-or-later
  userspace-consumer.c
  Copyright 2009 CompuLab, Ltd.
  Author: Mike Rapoport <mike@compulab.co.il>
  Based of virtual consumer driver:
    Copyright 2008 Wolfson Microelectronics PLC.
    Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
	
	  sysfs_streq() doesn't need the \n's, but we add them so the strings
	  will be shared with show_state(), above.
 SPDX-License-Identifier: GPL-2.0
 Device driver for regulators in Hi6421 IC
 Copyright (c) <2011-2014> HiSilicon Technologies Co., Ltd.
              http:
 Copyright (c) <2013-2014> Linaro Ltd.
              https:
 Author: Guodong Xu <guodong.xu@linaro.org>
  struct hi6421_regulator_pdata - Hi6421 regulator data of platform device
  @lock: mutex to serialize regulator enable
  struct hi6421_regulator_info - hi6421 regulator information
  @desc: regulator description
  @mode_mask: ECO mode bitmask of LDOs; for BUCKs, this masks sleep
  @eco_microamp: eco mode load upper limit (in uA), valid for LDOs only
 HI6421 regulators 
 LDO 0, 4~7, 9~14, 16~20 have same voltage table. 
 LDO 8, 15 have same voltage table. 
 Ranges are sorted in ascending order. 
  _id - LDO id name string
  _match - of match name string
  v_table - voltage table
  vreg - voltage select register
  vmask - voltage select mask
  ereg - enable register
  emask - enable mask
  odelay - offon delay time in uS
  ecomask - eco mode mask
  ecoamp - eco mode load uppler limit in uA
 HI6421 LDO1~3 are linear voltage regulators at fixed uV_step
  _id - LDO id name string
  _match - of match name string
  _min_uV - minimum voltage supported in uV
  n_volt - number of votages available
  vstep - voltage increase in each linear step in uV
  vreg - voltage select register
  vmask - voltage select mask
  ereg - enable register
  emask - enable mask
  odelay - offon delay time in uS
  ecomask - eco mode mask
  ecoamp - eco mode load uppler limit in uA
 HI6421 LDOAUDIO is a linear voltage regulator with two 4-step ranges
  _id - LDO id name string
  _match - of match name string
  n_volt - number of votages available
  volt_ranges - array of linear_range
  vstep - voltage increase in each linear step in uV
  vreg - voltage select register
  vmask - voltage select mask
  ereg - enable register
  emask - enable mask
  odelay - offon delay time in uS
  ecomask - eco mode mask
  ecoamp - eco mode load uppler limit in uA
 HI6421 BUCK012 are linear voltage regulators at fixed uV_step
  _id - BUCK012 id name string
  _match - of match name string
  vreg - voltage select register
  vmask - voltage select mask
  ereg - enable register
  emask - enable mask
  sleepmask - mask of sleep mode
  etime - enable time
  odelay - offon delay time in uS
 HI6421 BUCK345 share similar configurations as LDOs, with exception
   that it supports SLEEP mode, so has different .ops.
  _id - LDO id name string
  _match - of match name string
  v_table - voltage table
  vreg - voltage select register
  vmask - voltage select mask
  ereg - enable register
  emask - enable mask
  odelay - offon delay time in uS
  sleepmask - mask of sleep mode
 HI6421 regulator information 
	 hi6421 spec requires regulator enablement must be serialized:
	   - Because when BUCK, LDO switching from off to on, it will have
	     a huge instantaneous current; so you can not turn on two or
	     more LDO or BUCKs simultaneously, or it may burn the chip.
 call regulator regmap helper 
 set mode 
 set mode 
 assign per-regulator data 
 SPDX-License-Identifier: GPL-2.0
 Device driver for regulators in Hi655x IC
 Copyright (c) 2016 HiSilicon Ltd.
 Authors:
 Chen Feng <puck.chen@hisilicon.com>
 Fei  Wang <w.f@huawei.com>
 LDO7 & LDO10 
  isl6271a-regulator.c
  Support for Intersil ISL6271A voltage regulator
  Copyright (C) 2010 Marek Vasut <marek.vasut@gmail.com>
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any kind,
  whether express or implied; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.
 PMIC details 
 SPDX-License-Identifier: GPL-2.0-only
  Driver for voltage controller regulators
  Copyright (C) 2017 Google, Inc.
 voltage rising or no OVP 
 Make sure no infinite loop even in crazy cases 
 Try to go back to original voltage 
 voltage rising or no OVP 
 Try to go back to original voltage 
 We use the value as int and as divider; sanity check 
 determine number of steps within the range of the vctrl regulator 
 create mapping control <=> output voltage 
 we rely on the table to be ordered by ascending voltage 
 pre-calculate OVP-safe downward transitions 
 use next lowest voltage 
 Use locked consumer API when not in regulator framework 
 determine current voltage selector from control voltage 
 Drop ctrl-supply here in favor of regulator core managed supply 
 SPDX-License-Identifier: GPL-2.0+
 SLG51000 High PSRR, Multi-Output Regulators
 Copyright (C) 2019  Dialog Semiconductor
 Author: Eric Jeong <eric.jeong.opensource@diasemi.com>
 to the check below 
 Read event[R0], status[R1] and mask[R2] register 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2020 NXP.
  NXP PCA9450 pmic driver
 dvs0 
 dvs1 
  BUCK123
  BUCK1RAM[1:0] BUCK1 DVS ramp rate setting
  00: 25mV1usec
  01: 25mV2usec
  10: 25mV4usec
  11: 25mV8usec
  BUCK123
  0.60 to 2.1875V (12.5mV step)
  BUCK456
  0.6V to 3.4V (25mV step)
  LDO1
  1.6 to 3.3V ()
  LDO2
  0.8 to 1.15V (50mV step)
  LDO34
  0.8 to 3.3V (100mV step)
  LDO5
  1.8 to 3.3V (100mV step)
  Buck3 removed on PCA9450B and connected with Buck1 internal for dual phase
  on PCA9450C as no Buck3.
 Check your board and dts for match the right pmic 
 Unmask all interrupt except PWRONWDOGRSVD 
 Clear PRESET_EN bit in BUCK123_DVS to use DVS registers 
 Set reset behavior on assertion of WDOG_B signal 
	
	  The driver uses the LDO5CTRL_H register to control the LDO5 regulator.
	  This is only valid if the SD_VSEL input of the PMIC is high. Let's
	  check if the pin is available as GPIO and set it to high.
 SPDX-License-Identifier: GPL-2.0-only
  Regulator driver for the Richtek RT5033
  Copyright (C) 2014 Samsung Electronics, Co., Ltd.
  Author: Beomho Seo <beomho.seo@samsung.com>
 SPDX-License-Identifier: GPL-2.0+
 da9052-regulator.c: Regulator driver for DA9052
 Copyright(c) 2011 Dialog Semiconductor Ltd.
 Author: David Dajun Chen <dchen@diasemi.com>
 Buck step size 
 Bit masks 
 DA9052 REGULATOR IDs 
 DA9052-BC BUCKs 
 DA9053-AABx BUCK-CORE 
	{800000, 1000000, 1200000, 1500000},	 DA9053-AABx BUCK-PRO,
						  BUCK-MEM and BUCK-PERI
	 Determine the even or odd position of the buck current limit
	  register field
 Select the appropriate current limit range 
 Select the appropriate current limit range 
	 Determine the even or odd position of the buck current limit
	  register field
	 Some LDOs and DCDCs are DVC controlled which requires enabling of
	  the activate bit to implment the changes on the output.
	 The DVC controlled LDOs and DCDCs ramp with 6.25mVµs after enabling
	  the activate bit.
 SPDX-License-Identifier: GPL-2.0-or-later
  Voltage regulator support for AMS AS3722 PMIC
  Copyright (C) 2013 ams
  Author: Florian Lobmaier <florian.lobmaier@ams.com>
  Author: Laxman Dewangan <ldewangan@nvidia.com>
 Regulator IDs 
 SPDX-License-Identifier: GPL-2.0-or-later
  reg-virtual-consumer.c
  Copyright 2008 Wolfson Microelectronics PLC.
  Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
	
	  sysfs_streq() doesn't need the \n's, but we add them so the strings
	  will be shared with show_mode(), above.
  tps65217-regulator.c
  Regulator driver for TPS65217 PMIC
  Copyright (C) 2011 Texas Instruments Incorporated - https:www.ti.com
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 Enable the regulator and password protection is level 1 
 Disable the regulator and password protection is level 1 
 Set the voltage based on vsel value and write protect level is 2 
 Set GO bit for DCDCx to initiate voltage transistion 
 Operations permitted on DCDCx, LDO2, LDO3 and LDO4 
 Operations permitted on LDO1 
 Allocate memory for strobes 
 Register the regulators 
 Store default strobe info 
 SPDX-License-Identifier: GPL-2.0+
 wm8350.c  --  Voltage and current regulation for the Wolfson WM8350 PMIC
 Copyright 2007, 2008 Wolfson Microelectronics PLC.
 Author: Liam Girdwood
         linux@wolfsonmicro.com
 Maximum value possible for VSEL 
 Microamps 
 turn on ISINK followed by DCDC 
 all DCDCs have same mV bits 
 all LDOs have same mV bits 
 all LDOs have same mV bits 
 all LDOs have same mV bits 
 slot valid ? 
 slot valid ? 
 force continuous mode 
 active  pulse skipping 
 standby mode 
 LDO mode 
 0 - 10mA - LDO 
 10mA - 100mA - Standby 
 > 100mA - Active 
 0 - 10mA - LDO 
 10mA - 100mA - Standby 
 > 100mA - Active 
 Query the regulator for it's most efficient mode @ uV,uA
  WM8350 regulator efficiency is pretty similar over
  different input and output uV.
 do any regulatior specific init 
 register regulator 
 register regulator IRQ 
  wm8350_register_led - Register a WM8350 LED output
  @wm8350: The WM8350 device to configure.
  @lednum: LED device index to create.
  @dcdc: The DCDC to use for the LED.
  @isink: The ISINK to use for the LED.
  @pdata: Configuration for the LED.
  The WM8350 supports the use of an ISINK together with a DCDC to
  provide a power-efficient LED driver.  This function registers the
  regulators and instantiates the platform device for a LED.  The
  operating modes for the LED regulators must be configured using
  wm8350_isink_set_flash(), wm8350_dcdc25_set_mode() and
  wm8350_dcdc_set_slot() prior to calling this function.
 Module information 
 SPDX-License-Identifier: GPL-2.0+
 Copyright (c) 2012-2014 Samsung Electronics Co., Ltd
              http:
 The highest number of possible regulators for supported devices. 
	
	  One bit for each S2MPS11S2MPS13S2MPS14S2MPU02 regulator whether
	  the suspend mode was enabled.
	
	  Array (size: number of regulators) with GPIO-s for external
	  sleep control.
 Ramp delay can be enableddisabled only for buck[2346] 
 Below LDO should be always on or does not support suspend mode. 
	
	  Don't enable suspend mode if regulator is already disabled because
	  this would effectively for a short time turn on the regulator after
	  resuming.
	  However we still want to toggle the suspend_state bit for regulator
	  in case if it got enabled before suspending the system.
 voltage range for s2mps15 LDO 3, 5, 15, 16, 18, 20, 23 and 27 
 voltage range for s2mps15 LDO 2, 6, 14, 17, 19, 21, 24 and 25 
 voltage range for s2mps15 LDO 4, 11, 12, 13, 22 and 26 
 voltage range for s2mps15 LDO 7, 8, 9 and 10 
 voltage range for s2mps15 LDO 1 
 voltage range for s2mps15 BUCK 1, 2, 3, 4, 5, 6 and 7 
 voltage range for s2mps15 BUCK 8, 9 and 10 
		
		  Hand the GPIO descriptor management over to the regulator
		  core, remove it from devres management.
 Module information 
 SPDX-License-Identifier: GPL-2.0+
 sy8106a-regulator.c - Regulator device driver for SY8106A
 Copyright (C) 2016 Ondřej Jirman <megous@megous.com>
 Copyright (c) 2017-2018 Icenowy Zheng <icenowy@aosc.io>
  The I2C controlled voltage will only work when this bit is set; otherwise
  it will behave like a fixed regulator.
 Enablingdisabling the regulator is not yet implemented 
 Default limits measured in millivolts 
	
	  This ramp_delay is a conservative default value which works on
	  H3H5 boards VDD-CPUX situations.
  I2C driver interface functions
 Ensure GO_BIT is enabled when probing 
 Probe regulator 
 SPDX-License-Identifier: GPL-2.0+
 Configure PAVDD on and softstart delay time to the minimum 
 Configure NAVDD on and softstart delay time to the minimum 
 Default EN pin to high, PAVDD and NAVDD will be on 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for Regulator part of Palmas PMIC Chips
  Copyright 2011-2013 Texas Instruments Inc.
  Author: Graeme Gregory <gg@slimlogic.co.uk>
  Author: Ian Lartey <ian@slimlogic.co.uk>
 Switch the enable value to ensure this is used for enable 
 SMPS3 and SMPS7 do not have tstep_addr setting 
  setup the hardware based sleep configuration of the SMPSLDO regulators
  from the platform data. This is different to the software based control
  supported by the regulator framework as it is controlled by toggling
  pins on the PMIC such as PREQ, SYSEN, ...
 Enable externally controlled regulator 
 Enable externally controlled regulator 
 Enable externally controlled regulator 
	
	  When SMPS45 is set to off and LDO8 tracking is enabled, the LDO8
	  output is defined by the LDO8_VOLTAGE.VSEL register divided by two,
	  and can be set from 0.45 to 1.65 V.
		 Miss out regulators which are not available due
		  to alternate functions.
 Register the regulators 
 Check if LDO8 is in tracking mode or not 
 LOD6 in vibrator mode will have enable time 2000us 
 Initialise sleepinit values from platform data 
		 Miss out regulators which are not available due
		  to alternate functions.
 Register the regulators 
			
			  To be confirmed. Discussion on going with PMIC Team.
			  It is of the order of ~60mVuS.
 Initialise sleepinit values from platform data 
		
		  Miss out regulators which are not available due
		  to slaving configurations.
 Initialise sleepinit values from platform data 
 Register the regulators 
			
			  Read and store the RANGE bit for later use
			  This must be done before regulator is probed,
			  otherwise we error in probe with unsupportable
			  ranges. Read the current smps mode for later use.
 Read the smps mode for later use. 
 set_mode overrides this value 
		
		  Miss out regulators which are not available due
		  to slaving configurations.
 Initialise sleepinit values from platform data 
 Register the regulators 
		
		  Read and store the RANGE bit for later use
		  This must be done before regulator is probed,
		  otherwise we error in probe with unsupportable
		  ranges. Read the current smps mode for later use.
 Read the smps mode for later use. 
 set_mode overrides this value 
 EINVAL: Property not found 
 use default value, when no value is specified 
 end  }
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018-2021, The Linux Foundation. All rights reserved.
  enum rpmh_regulator_type - supported RPMh accelerator types
  @VRM:	RPMh VRM accelerator which supports voting on enable, voltage,
 		and mode of LDO, SMPS, and BOB type PMIC regulators.
  @XOB:	RPMh XOB accelerator which supports voting on the enable state
 		of PMIC regulators.
  struct rpmh_vreg_hw_data - RPMh regulator hardware configurations
  @regulator_type:		RPMh accelerator type used to manage this
 				regulator
  @ops:			Pointer to regulator ops callback structure
  @voltage_range:		The single range of voltages supported by this
 				PMIC regulator type
  @n_voltages:			The number of unique voltage set points defined
 				by voltage_range
  @hpm_min_load_uA:		Minimum load current in microamps that requires
 				high power mode (HPM) operation.  This is used
 				for LDO hardware type regulators only.
  @pmic_mode_map:		Array indexed by regulator framework mode
 				containing PMIC hardware modes.  Must be large
 				enough to index all framework modes supported
 				by this regulator hardware type.
  @of_map_mode:		Maps an RPMH_REGULATOR_MODE_ mode value defined
 				in device tree to a regulator framework mode
  struct rpmh_vreg - individual RPMh regulator data structure encapsulating a
 		single regulator device
  @dev:			Device pointer for the top-level PMIC RPMh
 				regulator parent device.  This is used as a
 				handle in RPMh write requests.
  @addr:			Base address of the regulator resource within
 				an RPMh accelerator
  @rdesc:			Regulator descriptor
  @hw_data:			PMIC regulator configuration data for this RPMh
 				regulator
  @always_wait_for_ack:	Boolean flag indicating if a request must always
 				wait for an ACK from RPMh before continuing even
 				if it corresponds to a strictly lower power
 				state (e.g. enabled --> disabled).
  @enabled:			Flag indicating if the regulator is enabled or
 				not
  @bypassed:			Boolean indicating if the regulator is in
 				bypass (pass-through) mode or not.  This is
 				only used by BOB rpmh-regulator resources.
  @voltage_selector:		Selector used for get_voltage_sel() and
 				set_voltage_sel() callbacks
  @mode:			RPMh VRM regulator current framework mode
  struct rpmh_vreg_init_data - initialization data for an RPMh regulator
  @name:			Name for the regulator which also corresponds
 				to the device tree subnode name of the regulator
  @resource_name:		RPMh regulator resource name format string.
 				This must include exactly one field: '%s' which
 				is filled at run-time with the PMIC ID provided
 				by device tree property qcom,pmic-id.  Example:
 				"ldo%s1" for RPMh resource "ldoa1".
  @supply_name:		Parent supply regulator name
  @hw_data:			Configuration data for this PMIC regulator type
  rpmh_regulator_send_request() - send the request to RPMh
  @vreg:		Pointer to the RPMh regulator
  @cmd:		Pointer to the RPMh command to send
  @wait_for_ack:	Boolean indicating if execution must wait until the
 			request has been acknowledged as complete
  Return: 0 on success, errno on failure
 VRM voltage control register is set with voltage in millivolts. 
		
		  Cache the voltage and send it later when the regulator is
		  enabled or disabled.
  rpmh_regulator_vrm_set_load() - set the regulator mode based upon the load
 		current requested
  @rdev:		Regulator device pointer for the rpmh-regulator
  @load_uA:		Aggregated load current in microamps
  This function is used in the regulator_ops for VRM type RPMh regulator
  devices.
  Return: 0 on success, errno on failure
  rpmh_regulator_init_vreg() - initialize all attributes of an rpmh-regulator
  @vreg:		Pointer to the individual rpmh-regulator resource
  @dev:			Pointer to the top level rpmh-regulator PMIC device
  @node:		Pointer to the individual rpmh-regulator resource
 			device node
  @pmic_id:		String used to identify the top level rpmh-regulator
 			PMIC device on the board
  @pmic_rpmh_data:	Pointer to a null-terminated array of rpmh-regulator
 			resources defined for the top level PMIC device
  Return: 0 on success, errno on failure
 LVS hardware does not support voltage or mode configuration. 
 smps3 - smps5 not configured 
 ldo17 not configured 
 SPDX-License-Identifier: GPL-2.0-or-later
  tps65910.c  --  TI tps65910
  Copyright 2010 Texas Instruments Inc.
  Author: Graeme Gregory <gg@slimlogic.co.uk>
  Author: Jorge Eduardo Candelaria <jedu@slimlogic.co.uk>
 supported VIO voltages in microvolts 
 VSEL tables for TPS65910 specific LDOs and dcdc's 
 supported VRTC voltages in microvolts 
 supported VDD3 voltages in microvolts 
 supported VDIG1 voltages in microvolts 
 supported VDIG2 voltages in microvolts 
 supported VPLL voltages in microvolts 
 supported VDAC voltages in microvolts 
 supported VAUX1 voltages in microvolts 
 supported VAUX2 voltages in microvolts 
 supported VAUX33 voltages in microvolts 
 supported VMMC voltages in microvolts 
 supported BBCH voltages in microvolts 
 multiplier 0 == 1 but 2,3 normal 
 normalise to valid range 
 normalise to valid range
 The first 5 values of the selector correspond to 1V 
 The first 3 values of the selector correspond to 1V 
 Regulator ops (except VRTC) 
	
	  Regulator can not be control from multiple external input EN1, EN2
	  and EN3 together.
 External EN1 control 
 External EN2 control 
 External EN3 control for TPS65910 LDO only 
 Return if no external control is selected 
 Clear all sleep controls 
	
	  For regulator that has separate operational and sleep register make
	  sure that operational is used and clear sleep register to turn
	  regulator off when external control is inactive
 Give control of all register to control port 
		 Work around silicon erratum SWCZ010: output programmed
		  voltage level can go higher than expected or crash
		  Workaround: use no synchronization of DCDC clocks
 Register the regulators 
		
		  Failing on regulator for configuring externally control
		  is not a serious issue, just throw warning.
 Save regulator for cleanup 
	
	  Before bootloader jumps to kernel, it makes sure that required
	  external control signals are in desired state so that given rails
	  can be configure accordingly.
	  If rails are configured to be controlled from external control
	  then before shutting downrebooting the system, the external
	  control configuration need to be remove from the rails so that
	  its output will be available as per register programming even
	  if external controls are removed. This is require when the POR
	  value of the control signals are not in active state and before
	  bootloader initializes it, the system requires the rail output
	  to be active for booting.
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (C) 2020 MediaTek Inc.
 Author: Gene Chen <gene_chen@richtek.com>
 SPDX-License-Identifier: GPL-2.0+
 Regulator driver for DA9055 PMIC
 Copyright(c) 2012 Dialog Semiconductor Ltd.
 Author: David Dajun Chen <dchen@diasemi.com>
 DA9055 REGULATOR IDs 
 DA9055 BUCK current limit 
	
	  There are two voltage register set A & B for voltage ramping but
	  either one of then can be active therefore we first determine
	  the active register set.
 Get the voltage for the active register set AB 
	
	  Regulator register set AB is not selected through GPIO therefore
	  we use default register set A for voltage ramping.
 Select register set A 
 Set the voltage 
	
	  Here regulator register set AB is selected through GPIO.
	  Therefore we first determine the selected register set AB and
	  then set the desired voltage for that register set AB.
 Set the voltage 
 Select register set B for suspend voltage ramping. 
 Select register set B for voltage ramping. 
 Diselect register set B. 
  Configures regulator to be controlled either through GPIO 1 or 2.
  GPIO can control regulator state andor select the regulator register
  set AB for voltage ramping.
		
		  GPI pin is muxed with regulator to control the
		  regulator state.
		
		  Let the regulator know that its state is controlled
		  through GPI.
		
		  GPI pin is muxed with regulator to select the
		  regulator register set AB for voltage ramping.
		
		  Let the regulator know that its register set AB
		  will be selected through GPI for voltage ramping.
 Only LDO 5 and 6 has got the over current interrupt 
 SPDX-License-Identifier: GPL-2.0-or-later
  Voltage and current regulation for AD5398 and AD5821
  Copyright 2010 Analog Devices Inc.
  Enter bugs at http:blackfin.uclinux.org
 read chip enable bit 
 prepare register data 
 write the new current value back as well as enable bit 
 SPDX-License-Identifier: GPL-2.0-only
  linuxdriversregulatoraat2870-regulator.c
  Copyright (c) 2011, NVIDIA Corporation.
  Author: Jin Park <jinyoungp@nvidia.com>
 SPDX-License-Identifier: GPL-2.0-only
  Maxim MAX77620 Regulator driver
  Copyright (c) 2016-2018, NVIDIA CORPORATION.  All rights reserved.
  Author: Mallikarjun Kasoju <mkasoju@nvidia.com>
 	Laxman Dewangan <ldewangan@nvidia.com>
 Power Mode 
 SD Slew Rate 
 Regulator types 
 FPS power up period setting 
 FPS power down period setting 
 Update power mode 
 If rails are externally control of FPS then enable it always. 
	 Device specific ramp rate setting tells that platform has
	  different ramp rate from advertised value. In this case,
	  do not configure anything and just return success.
	
	  Set of_node_reuse flag to prevent driver core from attempting to
	  claim any pinmux resources already claimed by the parent device.
	  Otherwise PMIC driver will fail to re-probe.
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2020, The Linux Foundation. All rights reserved.
 Clear irq latch status to avoid spurious event 
 Enable OCP HW interrupt 
  qcom_labibb_check_ocp_status - Check the Over-Current Protection status
  @vreg: Main driver structure
  This function checks the STATUS1 register for the VREG_OK bit: if it is
  set, then there is no Over-Current event.
  Returns: Zero if there is no over-current, 1 if in over-current or
           negative number for error
  qcom_labibb_ocp_recovery_worker - Handle OCP event
  @work: OCP work structure
  This is the worker function to handle the Over Current Protection
  hardware event; This will check if the hardware is still
  signaling an over-current condition and will eventually stop
  the regulator if such condition is still signaled after
  LABIBB_MAX_OCP_COUNT times.
  If the driver that is consuming the regulator did not take action
  for the OCP condition, or the hardware did not stabilize, a cut
  of the LAB and IBB regulators will be forced (regulators will be
  disabled).
  As last, if the writes to shut down the LABIBB regulators fail
  for more than LABIBB_MAX_FATAL_COUNT, then a kernel panic will be
  triggered, as a last resort to protect the hardware from burning;
  this, however, is expected to never happen, but this is kept to
  try to further ensure that we protect the hardware at all costs.
		
		  If we tried to disable the regulator multiple times but
		  we kept failing, there's only one last hope to save our
		  hardware from the death: raise a kernel bug, reboot and
		  hope that the bootloader kindly saves us. This, though
		  is done only as paranoid checking, because failing the
		  regmap write to disable the vreg is almost impossible,
		  since we got here after multiple regmap RW.
 Disable the regulator immediately to avoid damage 
 We cannot trust it without OCP enabled. 
 Everything went fine: reset the OCP count! 
  qcom_labibb_ocp_isr - Interrupt routine for OverCurrent Protection
  @irq:  Interrupt number
  @chip: Main driver structure
  Over Current Protection (OCP) will signal to the client driver
  that an over-current event has happened and then will schedule
  a recovery worker.
  Disabling and eventually re-enabling the regulator is expected
  to be done by the driver, as some hardware may be triggering an
  over-current condition only at first initialization or it may
  be expected only for a very brief amount of time, after which
  the attached hardware may be expected to stabilize its current
  draw.
  Returns: IRQ_HANDLED for success or IRQ_NONE for failure.
 If the regulator is not enabled, this is a fake event 
 If we tried to recover for too many times it's not getting better 
	
	  If we (unlikely) can't read this register, to prevent hardware
	  damage at all costs, we assume that the overcurrent event was
	  real; Moreover, if the status register is not signaling OCP,
	  it was a spurious event, so it's all ok.
	
	  Disable the interrupt temporarily, or it will fire continuously;
	  we will re-enable it in the recovery worker function.
 Warn the user for overcurrent 
 Disable the interrupt to avoid hogging 
 Signal overcurrent event to drivers 
 Schedule the recovery work 
	
	  labibb supports only protection - and does not support setting
	  limit. Furthermore, we don't support disabling protection.
 If there is no OCP interrupt, there's nothing to set 
 IRQ polarities - LAB: trigger-low, IBB: trigger-high 
 Activate OCP HW level interrupt 
 Set OCP interrupt polarity 
  qcom_labibb_check_sc_status - Check the Short Circuit Protection status
  @vreg: Main driver structure
  This function checks the STATUS1 register on both LAB and IBB regulators
  for the ShortCircuit bit: if it is set on any of them, then we have
  experienced a short-circuit event.
  Returns: Zero if there is no short-circuit, 1 if in short-circuit or
           negative number for error
 We have to work on both regulators due to PBS... 
  qcom_labibb_sc_recovery_worker - Handle Short Circuit event
  @work: SC work structure
  This is the worker function to handle the Short Circuit Protection
  hardware event; This will check if the hardware is still
  signaling a short-circuit condition and will eventually never
  re-enable the regulator if such condition is still signaled after
  LABIBB_MAX_SC_COUNT times.
  If the driver that is consuming the regulator did not take action
  for the SC condition, or the hardware did not stabilize, this
  worker will stop rescheduling, leaving the regulators disabled
  as already done by the Portable Batch System (PBS).
  Returns: IRQ_HANDLED for success or IRQ_NONE for failure.
	
	  If we tried to check the regulator status multiple times but we
	  kept failing, then just bail out, as the Portable Batch System
	  (PBS) will disable the vregs for us, preventing hardware damage.
 Too many short-circuit events. Throw in the towel. 
	
	  The Portable Batch System (PBS) automatically disables LAB
	  and IBB when a short-circuit event is detected, so we have to
	  check and work on both of them at the same time.
	
	  If we have reached this point, we either have successfully
	  recovered from the SC condition or we had a spurious SC IRQ,
	  which means that we can re-enable the regulators, if they
	  have ever been disabled by the PBS.
 Everything went fine: reset the OCP count! 
	
	  Now that we have done basic handling of the short-circuit,
	  reschedule this worker in the regular system workqueue, as
	  taking action is not truly urgent anymore.
  qcom_labibb_sc_isr - Interrupt routine for Short Circuit Protection
  @irq:  Interrupt number
  @chip: Main driver structure
  Short Circuit Protection (SCP) will signal to the client driver
  that a regulation-out event has happened and then will schedule
  a recovery worker.
  The LAB and IBB regulators will be automatically disabled by the
  Portable Batch System (PBS) and they will be enabled again by
  the worker function if the hardware stops signaling the short
  circuit event.
  Returns: IRQ_HANDLED for success or IRQ_NONE for failure.
 Warn the user for short circuit 
	
	  Disable the interrupt temporarily, or it will fire continuously;
	  we will re-enable it in the recovery worker function.
 Signal out of regulation event to drivers 
 Schedule the short-circuit handling as high-priority work 
 Current limit setting needs secure access 
 IBB discharge resistor values in KOhms 
 Soft start time in microseconds 
		 Validate if the type of regulator is indeed
		  what's mentioned in DT.
 The Short Circuit interrupt is critical 
 OverCurrent Protection IRQ is optional 
 LAB Limits: 200-1600mA 
 IBB Limits: 0-1550mA 
 No override bit 
 SPDX-License-Identifier: GPL-2.0+
 pv88060-regulator.c - Regulator device driver for PV88060
 Copyright (C) 2015  Powerventure Semiconductor Ltd.
 PV88060 REGULATOR IDs 
 BUCKs 
 LDOs 
 SWTs 
 buck configuration register 
 Current limits array (in uA) for BUCK1
  Entry indexes corresponds to register values.
  I2C driver interface functions
 SPDX-License-Identifier: GPL-2.0+
 HW Enable + Soft start time 
 ramp delay dividend is 12500 uVuS, and divisor from 1 to 8 
 xor checksum for bit 6 to 0 
 Default over current 14A 
 Default over temperature 150'c 
 Default power good delay time 10us 
 Default slewrate 12.5mVuS 
 Default switch frequency 800KHz 
 Default voltage 750mV 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018 BayLibre SAS
 Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
 Regulator driver for MAXIM 7765077651 chargerpower-supply.
 range index 0 
 range index 1 
 range index 2 
 range index 3 
 Special case for max77651 SBB1 - pickable linear-range voltage mapping. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) STMicroelectronics 2019
 Authors: Gabriel Fernandez <gabriel.fernandez@st.com>
          Pascal Paillet <p.paillet@st.com>.
  Registers description
 list of supported regulators 
 use an arbitrary timeout of 20ms 
 use an arbitrary timeout of 20ms 
 SPDX-License-Identifier: GPL-2.0-or-later
  PCAP2 Regulator Driver
  Copyright (c) 2009 Daniel Ribeiro <drwyrm@gmail.com>
 V5 STBY and LOWPWR are on PCAP_REG_VREG2 
 VAUX2 ... VSIM2 STBY and LOWPWR are on PCAP_REG_LOWPWR 
 SW3 STBY is on PCAP_REG_AUXVREG 
 SWxS used to control SWx voltage on standby 
	VREG_INFO(SW1S,  PCAP_REG_LOWPWR,  NA, 12, NA, NA),
 the regulator doesn't support voltage switching 
 SPDX-License-Identifier: GPL-2.0-only
  Regulator driver for LP87565 PMIC
  Copyright (C) 2017 Texas Instruments Incorporated - https:www.ti.com
 BUCK's 
 LP87565 BUCK current limit 
 Conservatively give a 15% margin 
 Operations permitted on BUCKs 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  max8660.c  --  Voltage regulation for the Maxim 86608661
  based on max1586.c and wm8400-regulator.c
  Copyright (C) 2009 Wolfram Sang, Pengutronix e.K.
  Some info:
  Datasheet: http:datasheets.maxim-ic.comendsMAX8660-MAX8661.pdf
  This chip is a bit nasty because it is a write-only device. Thus, the driver
  uses shadow registers to keep track of its values. The main problem appears
  to be the initialization: When Linux boots up, we cannot know if the chip is
  in the default state or not, so we would have to pass such information in
  platform_data. As this adds a bit of complexity to the driver, this is left
  out for now until it is really needed.
  [A|S|M]DTV1 registers are currently not used, but [A|S|M]DTV2.
  If the driver is feature complete, it might be worth to check if one set of
  functions for V3-V7 is sufficient. For maximum flexibility during
  development, they are separated for now.
 not a real register 
 as chip is write only 
  DCDC functions
 Select target voltage register and activate regulation 
  LDO5 functions
 Select target voltage register and activate regulation 
  LDO67 functions
 Simulate always on 
 Otherwise devices can be toggled via software 
	
	  First, set up shadow registers to prevent glitches. As some
	  registers are shared between regulators, everything must be properly
	  set up for all regulators in advance.
 Finally register devices 
 Module information 
 SPDX-License-Identifier: GPL-2.0-or-later
  fixed.c
  Copyright 2008 Wolfson Microelectronics PLC.
  Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
  Copyright (c) 2009 Nokia Corporation
  Roger Quadros <ext-roger.quadros@nokia.com>
  This is useful for systems with mixed controllable and
  non-controllable regulators, as well as for allowing testing on
  systems with no controllable regulators.
  of_get_fixed_voltage_config - extract fixed_voltage_config structure info
  @dev: device requesting for fixed_voltage_config
  @desc: regulator description
  Populates fixed_voltage_config structure by extracting data from device
  tree node, returns a pointer to the populated structure of NULL if memory
  alloc fails.
	
	  The signal will be inverted by the GPIO core if flagged so in the
	  descriptor.
	
	  Some fixed regulators share the enable line between two
	  regulators which makes it necessary to get a handle on the
	  same descriptor for two different consumers. This will get
	  the GPIO descriptor, but only the first call will initialize
	  it so any flags such as inversion or open drain will only
	  be set up by the first caller and assumed identical on the
	  next caller.
	 
	  FIXME: find a better way to deal with this.
	
	  Do not use devm here: the regulator core takes over the
	  lifecycle management of the GPIO descriptor.
 SPDX-License-Identifier: GPL-2.0
 Regulator controller driver for UniPhier SoC
 Copyright 2018 Socionext Inc.
 Author: Kunihiko Hayashi <hayashi.kunihiko@socionext.com>
 USB3 controller data 
 USB VBUS 
 Sentinel  },
  tps62360.c -- TI tps62360
  Driver for processor core supply tps62360, tps62361B, tps62362 and tps62363.
  Copyright (c) 2012, NVIDIA Corporation.
  Author: Laxman Dewangan <ldewangan@nvidia.com>
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any kind,
  whether express or implied; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
  02111-1307, USA
 Register definitions 
 tps 62360 chip information 
  find_voltage_set_register: Find new voltage configuration register
  (VSET) id.
  The finding of the new VSET register will be based on the LRU mechanism.
  Each VSET register will have different voltage configured . This
  Function will look if any of the VSET register have requested voltage set
  or not.
      - If it is already there then it will make that register as most
        recently used and return as found so that caller need not to set
        the VSET register but need to set the proper gpios to select this
        VSET register.
      - If requested voltage is not found then it will use the least
        recently mechanism to get new VSET register for new configuration
        and will return not_found so that caller need to set new VSET
        register and then gpios (both).
	
	  If gpios are available to select the VSET register then least
	  recently used register for new configuration.
 Select proper VSET register vio gpios 
 Enable force PWM mode in FAST mode only. 
 If gpios are valid then all register set need to be control 
 Initialize internal pull updown control 
 Reset output discharge path to reduce power consumption 
 Get ramp value from ramp control register 
 ramp mVus = 32(2^ramp_ctrl) 
		
		  Initialize the lru index with vset_reg id
		  The index 0 will be most recently used and
 Register the regulators 
 Configure the output discharge path 
 SPDX-License-Identifier: GPL-2.0+
 Regulator support for WM8400
 Copyright 2008 Wolfson Microelectronics PLC.
 Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
 Datasheet: hibernate 
 Datasheet: standby 
 Datasheet: active with or without force PWM 
 Datasheet: active with force PWM 
 Datasheet: active 
 Datasheet: standby 
  wm8400_register_regulator - enable software control of a WM8400 regulator
  This function enables software control of a WM8400 regulator via
  the regulator API.  It is intended to be called from the
  platform_init() callback of the WM8400 MFD driver.
  @dev:      The WM8400 device to operate on.
  @reg:      The regulator to control.
  @initdata: Regulator initdata for the regulator.
 SPDX-License-Identifier: GPL-2.0+
 Regulator driver for ATC260x PMICs
 Copyright (C) 2019 Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
 Copyright (C) 2020 Cristian Ciocaltea <cristian.ciocaltea@gmail.com>
  Note LDO8 is not documented in datasheet (v2.4), but supported
  in the vendor's driver implementation (xapp-le-kernel).
 Instantiate the regulators 
 SPDX-License-Identifier: GPL-2.0-or-later
  max1586.c  --  Voltage and current regulation for the Maxim 1586
  Copyright (C) 2008 Robert Jarzmik
 minmax V3 voltage 
  V6 voltage
  On I2C bus, sending a "x" byte to the max1586 means :
    set V6 to either 0V, 1.8V, 2.5V, 3V depending on (x & 0x3)
  As regulator framework doesn't accept voltages to be 0V, we use 1uV.
  V3 voltage
  On I2C bus, sending a "x" byte to the max1586 means :
    set V3 to 0.700V + (x & 0x1f)  0.025V
  This voltage can be increased by external resistors
  R24 and R25=100kOhm as described in the data sheet.
  The gain is approximately: 1 + R24R25 + R24185.5kOhm
  The Maxim 1586 controls V3 and V6 voltages, but offers no way of reading back
  the set up value.
	
	  If matched is 0, ie. neither Output_V3 nor Output_V6 have been found,
	  return 0, which signals the normal situation where no subregulator is
	  available. This is normal because the max1586 doesn't provide any
	  readback support, so the subregulators can't report any status
	  anyway.  If matched < 0, return the error.
 Set curr_sel to default voltage on power-up 
 1.3V 
 Module information 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2016 MediaTek Inc.
 Author: Chen Zhong <chen.zhong@mediatek.com>
  MT6323 regulators' information
  @desc: standard fields of regulator description.
  @qi: Mask for query enable signal status of regulators
  @vselon_reg: Register sections for hardware control mode of bucks
  @vselctrl_reg: Register for controlling the buck control mode.
  @vselctrl_mask: Mask for query buck's voltage control mode.
 The array is indexed by id(MT6323_ID_XXX) 
 Query buck controller to select activated voltage register part 
 Read PMIC chip revision to update constraints and voltage table 
 sentinel  },
  max8973-regulator.c -- Maxim max8973A
  Regulator driver for MAXIM 8973A DC-DC step-down switching regulator.
  Copyright (c) 2012, NVIDIA Corporation.
  Author: Laxman Dewangan <ldewangan@nvidia.com>
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any kind,
  whether express or implied; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
  02111-1307, USA
 Register definitions 
 MAX8973_VOUT 
 MAX8973_VOUT_DVS 
 MAX8973_CONTROL1 
 MAX8973_CONTROL2 
 Maxim 8973 chip information 
  find_voltage_set_register: Find new voltage configuration register (VOUT).
  The finding of the new VOUT register will be based on the LRU mechanism.
  Each VOUT register will have different voltage configured . This
  Function will look if any of the VOUT register have requested voltage set
  or not.
      - If it is already there then it will make that register as most
        recently used and return as found so that caller need not to set
        the VOUT register but need to set the proper gpios to select this
        VOUT register.
      - If requested voltage is not found then it will use the least
        recently mechanism to get new VOUT register for new configuration
        and will return not_found so that caller need to set new VOUT
        register and then gpios (both).
	
	  If gpios are available to select the VOUT register then least
	  recently used register for new configuration.
 Select proper VOUT register vio gpios 
 Enable force PWM mode in FAST mode only. 
  Clock advance trip configuration 
 Configure inductor value 
 If external control is enabled then disable EN bit 
 +1 degC to trigger cool devive 
		
		  Initialize the lru index with vout_reg id
		  The index 0 will be most recently used and
		
		  If there is no DVS GPIO, the VOUT register
		  address is fixed.
		
		  We do not let the core switch this regulator onoff,
		  we just leave it on.
	
	  Register the regulators
	  Turn the GPIO descriptor over to the regulator core for
	  lifecycle management if we pass an ena_gpiod.
  TI TPS65132 Regulator driver
  Copyright (C) 2017 NVIDIA CORPORATION. All rights reserved.
  Author: Venkat Reddy Talla <vreddytalla@nvidia.com>
 		Laxman Dewangan <ldewangan@nvidia.com>
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation; either version 2 of the
  License, or (at your option) any later version.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any kind,
  whether express or implied; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.
 Hardware automatically enable discharge bit in enable 
 Ignore the error other than probe defer 
 Ignore the error other than probe defer 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014, Sony Mobile Communications AB.
  Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
 used if voltage is in mV 
 used if voltage is in uV 
 peak current in mA 
 pull down enable 
 average current in mA 
 force mode 
 power mode 
 pin control 
 pin function 
 NCP and switch 
 NCP 
 frequency: NCP and SMPS 
 clock source: SMPS 
 switch: control OCP and SS 
  Physically available PMIC regulator voltage ranges
  PM8018 regulators
  PM8058 regulators
  PM8901 regulators
  PM8921 regulators
		
		  If force-mode is encoded as 2 bits then the
		  possible register values are:
		  NONE, LPM, HPM
		  otherwise:
		  NONE, LPM, AUTO, HPM, BYPASS
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2021 ROHM Semiconductors
 regulator IRQ based event notification helpers
 Logic has been partially adapted from qcom-labibb driver.
 Author: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
  Should only be called from threaded handler to prevent potential deadlock
		
		  If the 'last resort' IC recovery failed we will have
		  nothing else left to do...
		
		  If h->die() was implemented we assume recovery has been
		  attempted (probably regulator was shut down) and we
		  just enable IRQ and bail-out.
 Driver could not get current status 
			
			  IC status reading succeeded. update error info
			  just in case the renable changed it.
			
			  The IC indicated problem is still ON - no point in
			  re-enabling the IRQ. Retry later.
	
	  Either IC reported problem cleared or no status checker was provided.
	  If problems are gone - good. If not - then the IRQ will fire again
	  and we'll have a new nice loop. In any case we should clear error
	  flags here and re-enable IRQs.
	
	  Things have been seemingly successful => zero retry-counter.
	
	  we spare a few cycles by not clearing statuses prior to this call.
	  The IC driver must initialize the status buffers for rdevs
	  which it indicates having active events via rdev_map.
	 
	  Maybe we should just to be on a safer side(?)
	
	  If status reading fails (which is unlikely) we don't ackdisable
	  IRQ but just increase fail count and retry when IRQ fires again.
	  If retry_count exceeds the given safety limit we call IC specific die
	  handler which can try disabling regulator(s).
	 
	  If no die handler is given we will just power-off as a last resort.
	 
	  We could try disabling all associated rdevs - but we might shoot
	  ourselves in the head and leave the problematic regulator enabled. So
	  if IC has no die-handler populated we just assume the regulator
	  can't be disabled.
	
	  Let's not disable IRQ if there were no status bits for us. We'd
	  better leave spurious IRQ handling to genirq
	
	  Some events are bogus if the regulator is disabled. Skip such events
	  if all relevant regulators are disabled
			
			  If any of the flagged regulators is enabled we do
			  handle this
 Disable IRQ if HW keeps line asserted 
	
	  IRQ seems to be for us. Let's fire correct notifiers  store error
	  flags
 If we have no recovery, just try shut down straight away 
 If die() failed shut down as a last attempt to save the HW 
  regulator_irq_helper - register IRQ based regulator eventerror notifier
  @dev:		device providing the IRQs
  @d:			IRQ helper descriptor.
  @irq:		IRQ used to inform eventserrors to be notified.
  @irq_flags:		Extra IRQ flags to be OR'ed with the default
 			IRQF_ONESHOT when requesting the (threaded) irq.
  @common_errs:	Errors which can be flagged by this IRQ for all rdevs.
 			When IRQ is re-enabled these errors will be cleared
 			from all associated regulators
  @per_rdev_errs:	Optional error flag array describing errors specific
 			for only some of the regulators. These errors will be
 			or'ed with common errors. If this is given the array
 			should contain rdev_amount flags. Can be set to NULL
 			if there is no regulator specific error flags for this
 			IRQ.
  @rdev:		Array of pointers to regulators associated with this
 			IRQ.
  @rdev_amount:	Amount of regulators associated with this IRQ.
  Return: handle to irq_helper or an ERR_PTR() encoded error code.
  regulator_irq_helper_cancel - drop IRQ based regulator eventerror notifier
  @handle:		Pointer to handle returned by a successful call to
 			regulator_irq_helper(). Will be NULLed upon return.
  The associated IRQ is released and work is cancelled when the function
  returns.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2015 MediaTek Inc.
 Author: Henry Chen <henryc.chen@mediatek.com>
 Default limits measured in millivolts and milliamps 
  I2C driver interface functions
 SPDX-License-Identifier: GPL-2.0+
 Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
 64 cycles per step 
 cycle based on 24M OSC 
 check whether need to care about LDO ramp up speed 
		
		  the delay for LDO ramp up time is
		  based on the register setting, we need
		  to calculate how many steps LDO need to
		  ramp up, and how much delay needed. (us)
 read LDO ramp up setting, only for core reg 
 Only core regulators have the ramp up delay configuration. 
		
		  In case vddpu was disabled by the bootloader, we need to set
		  a sane default until imx6-cpufreq was probed and changes the
		  voltage to the correct value. In this case we set 1.25V.
 set the default voltage of the pcie phy to be 1.100v 
 register regulator 
 end  }
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2020 ROHM Semiconductors
 ROHM BD9576MUFBD9573MUF regulator driver
 VOUT3 and 4 has 10mV step 
 Do not overwrite ERR config with WARN 
 Internal values are already micro-amperes 
 Internal values are already micro-amperes 
 We abuse uvd fields for OCW on VoutS1 
			
			  If both warning and error are requested, prioritize
			  ERROR configuration
	
	  limits are given in uA, rfet is mOhm
	  Divide lim_uA by 1000 to get Vfet in uV.
	  (We expect both Rfet and limit uA to be magnitude of hundreds of
	  milli Amperes & milli Ohms => we should still have decent accuracy)
	
	  BD9576 has enable control as a special value in limit reg. Can't
	  set limit but keep feature disabled or enable WO given limit.
	
	  Check that there is no mismatch for what the detection IRQs are to
	  be used.
	
	  BD9576 has enable control as a special value in limit reg. Can't
	  set limit but keep feature disabled or enable WO given limit.
	
	  Check that there is no mismatch for what the detection IRQs are to
	  be used.
	
	  BD9576MUF has fixed temperature limits
	  The detection can only be enableddisabled
 Protection can't be disabled 
	
	  Check that there is no mismatch for what the detection IRQs are to
	  be used.
	
	  If any of the regulators is interested in thermal warning we keep IRQ
	  enabled.
		
		  It seems we stil have same status. Ack and return
		  information that we are still out of limits and core
		  should not enable IRQ
	
	  Status was changed. Either prolem was solved or we have new issues.
	  Let's re-enable IRQs and be prepared to report problems again
	
	  Go through the set status bits and report either error or warning
	  to the notifier depending on what was flagged in DT
 There is 1 bit gap in register after Vout1 .. Vout4 statuses 
	
	  We (ab)use the uvd for OCW notification. DT parsing should
	  have added correct OCW flag to uvd_notif and uvd_err for S1
 There is 1 bit gap in register after Vout1 .. Vout4 statuses 
 Clear the sub-IRQ status 
 Clear the sub-IRQ status 
 All regulators are related to UVD and thermal IRQs... 
 ...But VoutS1 is not flagged by OVD IRQ 
 VOUT1 enable state judged by VOUT1_EN pin 
 See if we have GPIO defined 
 VOUT1_OPS gpio ctrl 
			
			  Regulator core prioritizes the ena_gpio over
			  enabledisableis_enabled callbacks so no need to
			  clear them. We can still use same ops
			
			  In theory it is possible someone wants to set
			  vout1-en LOW during OTP loading and set VOUT1 to be
			  controlled by GPIO - but control the GPIO from some
			  where else than this driver. For that to work we
			  should unset the is_enabled callback here.
			 
			  I believe such case where rohm,vout1-en-low is set
			  and vout1-en-gpios is not is likely to be a
			  misconfiguration. So let's just err out for now.
	
	  If more than one PMIC needs to be controlled by same processor then
	  allocate the regulator data array here and use bd9576_regulators as
	  template. At the moment I see no such use-case so I spare some
	  bytes and use bd9576_regulators directly for non-constant configs
	  like DDR voltage selection.
		
		  Clear the VOUT1 GPIO setting - rest of the regulators do not
		  support GPIO control
		
		  We can add both the possible error and warning flags here
		  because the core uses these only for status clearing and
		  if we use warnings - errors are always clear and the other
		  way around. We can also add CURRENT flag for all regulators
		  because it is never set if it is not supported. Same applies
		  to setting UVD for VoutS1 - it is not accidentally cleared
		  as it is never set.
 Register notifiers - can fail if IRQ is not given 
 SPDX-License-Identifier: GPL-2.0-only
  Regulator driver for National Semiconductors LP3971 PMIC chip
   Copyright (C) 2009 Samsung Electronics
   Author: Marek Szyprowski <m.szyprowski@samsung.com>
  Based on wm8350.c
 System control register 1 initial value,
	Voltage control registers shift:
	LP3971_BUCK1 -> 0
	LP3971_BUCK2 -> 4
	LP3971_BUCK3 -> 6
	Voltage control registers:
	LP3971_LDO1 -> LP3971_LDO_VOL_CONTR_BASE + 0
	LP3971_LDO2 -> LP3971_LDO_VOL_CONTR_BASE + 0
	LP3971_LDO3 -> LP3971_LDO_VOL_CONTR_BASE + 1
	LP3971_LDO4 -> LP3971_LDO_VOL_CONTR_BASE + 1
	LP3971_LDO5 -> LP3971_LDO_VOL_CONTR_BASE + 2
	Voltage control registers shift:
	LP3971_LDO1 -> 0, LP3971_LDO2 -> 4
	LP3971_LDO3 -> 0, LP3971_LDO4 -> 4
	LP3971_LDO5 -> 0
 Instantiate the regulators 
 Detect LP3971 
 SPDX-License-Identifier: GPL-2.0
 Device driver for regulators in Hisi IC
 Copyright (c) 2013 Linaro Ltd.
 Copyright (c) 2011 HiSilicon Ltd.
 Copyright (c) 2020-2021 Huawei Technologies Co., Ltd.
 Guodong Xu <guodong.xu@linaro.org>
 Serialize regulator enable logic 
  HI6421V600_LDO() - specify a LDO power line
  @_id: LDO id name string
  @vtable: voltage table
  @ereg: enable register
  @emask: enable mask
  @vreg: voltage select register
  @odelay: offon delay time in uS
  @etime: enable time in uS
  @ecomask: eco mode mask
  @ecoamp: eco mode load uppler limit in uA
 cannot enable more than one regulator at one time 
 Avoid powering up multiple devices at the same time 
 HI6421v600 regulators with known registers 
	
	  This driver is meant to be called by hi6421-spmi-core,
	  which should first set drvdata. If this doesn't happen, hit
	  a warn on and return.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) ST-Ericsson SA 2010
  Authors: Sundar Iyer <sundar.iyer@stericsson.com> for ST-Ericsson
           Bengt Jonsson <bengt.g.jonsson@stericsson.com> for ST-Ericsson
  Power domain regulators on DB8500
 db8500 regulator operations 
  EPOD control
  Regulator switch
  Regulator information
 assign per-regulator data 
 SPDX-License-Identifier: GPL-2.0-only
  Regulators driver for Marvell 88PM8607
  Copyright (C) 2009 Marvell International Ltd.
 	Haojian Zhuang <haojian.zhuang@marvell.com>
 There're resources in 88PM8607 regulator driver 
 There's no resource in 88PM8606 PREG regulator driver 
 i is used to check regulator ID 
 check DVC ramp slope double 
 SPDX-License-Identifier: GPL-2.0
  ROHM BD9571MWV-M and BD9574MWF-M regulator driver
  Copyright (C) 2017 Marek Vasut <marek.vasut+renesas@gmail.com>
  Based on the TPS65086 driver
  NOTE: VD09 is missing
 DDR Backup Power 
 from "rohm,ddr-backup-power" 
 Power switch type 
 Operations permitted on AVS voltage regulator 
 Operations permitted on voltage regulators 
 Operations permitted on voltage monitors 
	
	  Configure DDR Backup Mode, to change the role of the accessory power
	  switch from a power switch to a wake-up switch, or vice versa
 Save DDR Backup Mode 
 Enable DDR Backup Mode 
 Restore DDR Backup Mode 
 CONFIG_PM_SLEEP 
 BD9574MWF supports DVFS only 
		
		  Backup mode is enabled by default in pulse mode, but needs
		  explicit user setup in level mode.
 CONFIG_PM_SLEEP 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0+
 Regulator driver for DA9063 PMIC series
 Copyright 2012 Dialog Semiconductors Ltd.
 Copyright 2013 Philipp Zabel, Pengutronix
 Author: Krystian Garbaciak <krystian.garbaciak@diasemi.com>
 Definition for registering regmap bit fields using a mask 
 DA9063 and DA9063L regulator IDs 
 BUCKs 
 BCORE1 and BCORE2 in merged mode 
 BMEM and BIO in merged mode 
 When two BUCKs are merged, they cannot be reused separately 
 LDOs on both DA9063 and DA9063L 
 DA9063-only LDOs 
 Old regulator platform data 
 Regulator capabilities and registers description 
 DA9063 main register fields 
 buck mode of operation 
 DA9063 event detection bit 
 Macros for LDO 
 Macros for voltage DCDC converters (BUCKs) 
 Defines asignment of regulators info table to chip model 
 Single regulator settings 
 Encapsulates all information for the regulators driver 
 Array size to be defined during init. Keep at end. 
 BUCK modes for DA9063 
 0 
 1 
 2 
 3 
 Regulator operations 
  Current limits array (in uA) for BCORE1, BCORE2, BPRO.
  Entry indexes corresponds to register values.
  Current limits array (in uA) for BMEM, BIO, BPERI.
  Entry indexes corresponds to register values.
  Current limits array (in uA) for merged BCORE1 and BCORE2.
  Entry indexes corresponds to register values.
  Current limits array (in uA) for merged BMEM and BIO.
  Entry indexes corresponds to register values.
  Bucks use single mode register field for normal operation
  and suspend state.
  There are 3 modes to map to: FAST, NORMAL, and STANDBY.
 Sleep flag bit decides the mode 
  LDOs use sleep flags - one for normal and one for suspend state.
  There are 2 modes to map to: NORMAL and STANDBY (sleep) for each state.
	
	  When enabling overdrive, do it before changing the current limit to
	  ensure sufficient supply throughout the switch.
		
		  regulator_set_current_limit_regmap may have rejected the
		  change because of unusable min_uA andor max_uA inputs.
		  Attempt to restore original overdrive state, ignore failure-
		  on-failure.
	
	  When disabling overdrive, do it after changing the current limit to
	  ensure sufficient supply throughout the switch.
		
		  Attempt to restore original current limit, ignore failure-
		  on-failure.
 Info of regulators for DA9063 
 BCORES_MERGED uses the same register fields as BCORE1 
 BMEM_BIO_MERGED uses the same register fields as BMEM 
 The following LDOs are present only on DA9063, not on DA9063L 
 Link chip model with regulators info table 
 Regulator interrupt handlers 
  Probing and Initialisation functions
 The following LDOs are present only on DA9063, not on DA9063L 
 Find regulators set for particular device model 
 remove BCORE1, BCORE2 
 remove BCORES_MERGED 
 remove BMEM, BIO 
 remove BMEM_BIO_MERGED 
 Allocate memory required by usable regulators 
 Register all regulators declared in platform information 
 Skip regulator IDs depending on merge mode configuration 
 Initialise regulator structure 
 Register regulator 
 LDOs overcurrent event support 
 Module information 
 SPDX-License-Identifier: GPL-2.0-only
 Configure DSV mode to normal by default 
 SPDX-License-Identifier: GPL-2.0-only
  Regulators driver for Marvell 88PM800
  Copyright (C) 2012 Marvell International Ltd.
  Joseph(Yossi) Hanin <yhanin@marvell.com>
  Yi Zhang <yizhang@marvell.com>
 LDO1 with DVC[0..3] 
 VOUT1 
 BUCK1 with DVC[0..3] 
  vreg - the buck regs string.
  ereg - the string for the enable register.
  ebit - the bit number in the enable register.
  amax - the current
  Buck has 2 kinds of voltage steps. It is easy to find voltage by ranges,
  not the constant voltage table.
  n_volt - Number of available selectors
  vreg - the LDO regs string
  ereg -  the string for the enable register.
  ebit - the bit number in the enable register.
  amax - the current
  volt_table - the LDO voltage table
  For all the LDOes, there are too many ranges. Using volt_table will be
  simpler and faster.
 Ranges are sorted in ascending order. 
 BUCK 2~5 have same ranges. 
 LDO 3~17 have same voltage table. 
 LDO 18~19 have same voltage table. 
 The array is indexed by id(PM800_ID_XXX) 
 Check whether num_regulator is valid. 
 SPDX-License-Identifier: GPL-2.0
 Lochnagar regulator driver
 Copyright (c) 2017-2018 Cirrus Logic, Inc. and
                         Cirrus Logic International Semiconductor Ltd.
 Author: Charles Keepax <ckeepax@opensource.cirrus.com>
 SPDX-License-Identifier: GPL-2.0+
 pv88090-regulator.c - Regulator device driver for PV88090
 Copyright (C) 2015  Powerventure Semiconductor Ltd.
 PV88090 REGULATOR IDs 
 BUCKs 
 LDOs 
 Current limits array (in uA) for BUCK1, BUCK2, BUCK3.
   Entry indexes corresponds to register values.
  I2C driver interface functions
 SPDX-License-Identifier: GPL-2.0-or-later
  Split TWL6030 logic from twl-regulator.c:
  Copyright (C) 2008 David Brownell
  Copyright (C) 2016 Nicolae Rosia <nicolae.rosia@gmail.com>
 start of regulator's PM_RECEIVER control register bank 
 twl resource ID, for resource control state machine 
 used by regulator core 
 chip specific features 
 data passed from board for external getset voltage 
 LDO control registers ... offset is from the base of its register bank.
  The first three registers of all power resource banks help hardware to
  manage the various resource groups.
 Common offset in TWL40306030 
 TWL6030 register offsets 
 TWL6030 Misc register offsets 
 TWL6030 LDO register values for VREG_VOLTAGE 
 TWL6030 LDO register values for CFG_STATE 
 Flags for SMPS Voltage reading and LDO reading
 twl6032 SMPS EPROM values 
 generic power resource operations, which work on all regulators 
  Enabledisable regulators by joiningleaving the P1 (processor) group.
  We assume nobody else is updating the DEV_GRP registers.
 definition for 6030 family 
 secondary processor, modem, etc 
 "peripherals" 
 CPULinux 
 For 6030, set the off state for all grps enabled 
 Compose the state register settings 
 We can only set the mode through state machine commands... 
  SMPS status and control
		 Values 1..57 for vsel are linear and can be calculated
		  values 58..62 are non linear.
		 Values 1..57 for vsel are linear and can be calculated
		  values 58..62 are non linear.
----------------------------------------------------------------------
 VUSBCP is managed only by the USB subchip 
 6030 REG with base as PMC Slave Misc : 0x0030 
 Turnon-delay and remap configuration values for 6030 are not
 6025 are renamed compared to 6030 versions 
	 Constrain board-specific capabilities according to what
	  this driver and the chip itself can actually do.
	 NOTE:  many regulators support short-circuit IRQs (presentable
	  as REGULATOR_OVER_CURRENT notifications?) configured via:
	   - SC_CONFIG
	   - SC_DETECT1 (vintana2, vmmc12, vaux1234)
	   - SC_DETECT2 (vusb, vdac, vio, vdd12, vpll2)
	   - IT_CONFIG
	 NOTE: short name, to work around driver model truncation of
	  "twl_regulator.12" (and friends) to "twl_regulator.1".
 SPDX-License-Identifier: GPL-2.0+
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-or-later
 helpers.c  --  VoltageCurrent Regulator framework helper functions.
 Copyright 2007, 2008 Wolfson Microelectronics PLC.
 Copyright 2008 SlimLogic Ltd.
  regulator_is_enabled_regmap - standard is_enabled() for regmap users
  @rdev: regulator to operate on
  Regulators that use regmap for their register IO can set the
  enable_reg and enable_mask fields in their descriptor and then use
  this as their is_enabled operation, saving some code.
  regulator_enable_regmap - standard enable() for regmap users
  @rdev: regulator to operate on
  Regulators that use regmap for their register IO can set the
  enable_reg and enable_mask fields in their descriptor and then use
  this as their enable() operation, saving some code.
  regulator_disable_regmap - standard disable() for regmap users
  @rdev: regulator to operate on
  Regulators that use regmap for their register IO can set the
  enable_reg and enable_mask fields in their descriptor and then use
  this as their disable() operation, saving some code.
  regulator_get_voltage_sel_pickable_regmap - pickable range get_voltage_sel
  @rdev: regulator to operate on
  Regulators that use regmap for their register IO and use pickable
  ranges can set the vsel_reg, vsel_mask, vsel_range_reg and vsel_range_mask
  fields in their descriptor and then use this as their get_voltage_vsel
  operation, saving some code.
  regulator_set_voltage_sel_pickable_regmap - pickable range set_voltage_sel
  @rdev: regulator to operate on
  @sel: Selector to set
  Regulators that use regmap for their register IO and use pickable
  ranges can set the vsel_reg, vsel_mask, vsel_range_reg and vsel_range_mask
  fields in their descriptor and then use this as their set_voltage_vsel
  operation, saving some code.
  regulator_get_voltage_sel_regmap - standard get_voltage_sel for regmap users
  @rdev: regulator to operate on
  Regulators that use regmap for their register IO can set the
  vsel_reg and vsel_mask fields in their descriptor and then use this
  as their get_voltage_vsel operation, saving some code.
  regulator_set_voltage_sel_regmap - standard set_voltage_sel for regmap users
  @rdev: regulator to operate on
  @sel: Selector to set
  Regulators that use regmap for their register IO can set the
  vsel_reg and vsel_mask fields in their descriptor and then use this
  as their set_voltage_vsel operation, saving some code.
  regulator_map_voltage_iterate - map_voltage() based on list_voltage()
  @rdev: Regulator to operate on
  @min_uV: Lower bound for voltage
  @max_uV: Upper bound for voltage
  Drivers implementing set_voltage_sel() and list_voltage() can use
  this as their map_voltage() operation.  It will find a suitable
  voltage by calling list_voltage() until it gets something in bounds
  for the requested voltages.
	 Find the smallest voltage that falls within the specified
	  range.
  regulator_map_voltage_ascend - map_voltage() for ascendant voltage list
  @rdev: Regulator to operate on
  @min_uV: Lower bound for voltage
  @max_uV: Upper bound for voltage
  Drivers that have ascendant voltage list can use this as their
  map_voltage() operation.
  regulator_map_voltage_linear - map_voltage() for simple linear mappings
  @rdev: Regulator to operate on
  @min_uV: Lower bound for voltage
  @max_uV: Upper bound for voltage
  Drivers providing min_uV and uV_step in their regulator_desc can
  use this as their map_voltage() operation.
 Allow uV_step to be 0 for fixed voltage 
 Map back into a voltage to verify we're still in bounds 
  regulator_map_voltage_linear_range - map_voltage() for multiple linear ranges
  @rdev: Regulator to operate on
  @min_uV: Lower bound for voltage
  @max_uV: Upper bound for voltage
  Drivers providing linear_ranges in their descriptor can use this as
  their map_voltage() callback.
		
		  Map back into a voltage to verify we're still in bounds.
		  If we are not, then continue checking rest of the ranges.
  regulator_map_voltage_pickable_linear_range - map_voltage, pickable ranges
  @rdev: Regulator to operate on
  @min_uV: Lower bound for voltage
  @max_uV: Upper bound for voltage
  Drivers providing pickable linear_ranges in their descriptor can use
  this as their map_voltage() callback.
		
		  Map back into a voltage to verify we're still in bounds.
		  We may have overlapping voltage ranges. Hence we don't
		  exit but retry until we have checked all ranges.
  regulator_desc_list_voltage_linear - List voltages with simple calculation
  @desc: Regulator desc for regulator which volatges are to be listed
  @selector: Selector to convert into a voltage
  Regulators with a simple linear mapping between voltages and
  selectors can set min_uV and uV_step in the regulator descriptor
  and then use this function prior regulator registration to list
  the voltages. This is useful when voltages need to be listed during
  device-tree parsing.
  regulator_list_voltage_linear - List voltages with simple calculation
  @rdev: Regulator device
  @selector: Selector to convert into a voltage
  Regulators with a simple linear mapping between voltages and
  selectors can set min_uV and uV_step in the regulator descriptor
  and then use this function as their list_voltage() operation,
  regulator_list_voltage_pickable_linear_range - pickable range list voltages
  @rdev: Regulator device
  @selector: Selector to convert into a voltage
  list_voltage() operation, intended to be used by drivers utilizing pickable
  ranges helpers.
			
			  As we see here, pickable ranges work only as
			  long as the first selector for each pickable
			  range is 0, and the each subsequent range for
			  this 'pick' follow immediately at next unused
			  selector (Eg. there is no gaps between ranges).
			  I think this is fine but it probably should be
			  documented. OTOH, whole pickable range stuff
			  might benefit from some documentation
  regulator_desc_list_voltage_linear_range - List voltages for linear ranges
  @desc: Regulator desc for regulator which volatges are to be listed
  @selector: Selector to convert into a voltage
  Regulators with a series of simple linear mappings between voltages
  and selectors who have set linear_ranges in the regulator descriptor
  can use this function prior regulator registration to list voltages.
  This is useful when voltages need to be listed during device-tree
  parsing.
  regulator_list_voltage_linear_range - List voltages for linear ranges
  @rdev: Regulator device
  @selector: Selector to convert into a voltage
  Regulators with a series of simple linear mappings between voltages
  and selectors can set linear_ranges in the regulator descriptor and
  then use this function as their list_voltage() operation,
  regulator_list_voltage_table - List voltages with table based mapping
  @rdev: Regulator device
  @selector: Selector to convert into a voltage
  Regulators with table based mapping between voltages and
  selectors can set volt_table in the regulator descriptor
  and then use this function as their list_voltage() operation.
  regulator_set_bypass_regmap - Default set_bypass() using regmap
  @rdev: device to operate on.
  @enable: state to set.
  regulator_set_soft_start_regmap - Default set_soft_start() using regmap
  @rdev: device to operate on.
  regulator_set_pull_down_regmap - Default set_pull_down() using regmap
  @rdev: device to operate on.
  regulator_get_bypass_regmap - Default get_bypass() using regmap
  @rdev: device to operate on.
  @enable: current state.
  regulator_set_active_discharge_regmap - Default set_active_discharge()
 					   using regmap
  @rdev: device to operate on.
  @enable: state to set, 0 to disable and 1 to enable.
  regulator_set_current_limit_regmap - set_current_limit for regmap users
  @rdev: regulator to operate on
  @min_uA: Lower bound for current limit
  @max_uA: Upper bound for current limit
  Regulators that use regmap for their register IO can set curr_table,
  csel_reg and csel_mask fields in their descriptor and then use this
  as their set_current_limit operation, saving some code.
 search for closest to maximum 
  regulator_get_current_limit_regmap - get_current_limit for regmap users
  @rdev: regulator to operate on
  Regulators that use regmap for their register IO can set the
  csel_reg and csel_mask fields in their descriptor and then use this
  as their get_current_limit operation, saving some code.
  regulator_bulk_set_supply_names - initialize the 'supply' fields in an array
                                    of regulator_bulk_data structs
  @consumers: array of regulator_bulk_data entries to initialize
  @supply_names: array of supply name strings
  @num_supplies: number of supply names to initialize
  Note: the 'consumers' array must be the size of 'num_supplies'.
  regulator_is_equal - test whether two regulators are the same
  @reg1: first regulator to operate on
  @reg2: second regulator to operate on
  regulator_set_ramp_delay_regmap - set_ramp_delay() helper
  @rdev: regulator to operate on
  Regulators that use regmap for their register IO can set the ramp_reg
  and ramp_mask fields in their descriptor and then use this as their
  set_ramp_delay operation, saving some code.
 SPDX-License-Identifier: GPL-2.0+
 max77802.c - Regulator driver for the Maxim 77802
 Copyright (C) 2013-2014 Google, Inc
 Simon Glass <sjg@chromium.org>
 Copyright (C) 2012 Samsung Electronics
 Chiwoong Byun <woong.byun@samsung.com>
 Jonghwa Lee <jonghwa3.lee@samsung.com>
 This driver is based on max8997.c
 Default ramp delay in case it is not manually set 
 uVus 
 Array indexed by regulator id 
  max77802_set_suspend_disable - Disable the regulator during system suspend
  @rdev: regulator to mark as disabled
  All regulators expect LDO 1, 3, 20 and 21 support OFF by PWRREQ.
  Configure the regulator so the PMIC will turn it OFF during system suspend.
  Some LDOs support Low Power Mode while the system is running.
  LDOs 1, 3, 20, 21.
 ON in Low Power Mode 
 ON in Normal Mode 
  max77802_set_suspend_mode - set regulator opmode when the system is suspended
  @rdev: regulator to change mode
  @mode: operating mode to be set
  Will set the operating mode for the regulators during system suspend.
  This function is valid for the three different enable control logics:
  Enable Control Logic1 by PWRREQ (BUCK 2-4 and LDOs 2, 4-19, 22-35)
  Enable Control Logic2 by PWRREQ (LDOs 1, 20, 21)
  Enable Control Logic3 by PWRREQ (LDO 3)
  If setting the regulator mode fails, the function only warns but does
  not return an error code to avoid the regulator core to stop setting
  the operating mode for the remaining regulators.
	
	  If the regulator has been disabled for suspend
	  then is invalid to try setting a suspend mode.
		
		  If the regulator opmode is normal then enable
		  ON in Low Power Mode by PWRREQ. If the mode is
		  already Low Power then no action is required.
		
		  If the regulator operating mode is Low Power then
		  normal is not a valid opmode in suspend. If the
		  mode is already normal then no action is required.
  LDOs 2, 4-19, 22-35
  LDOs 1, 20, 21, 3
 BUCKS 1, 6 
 BUCKs 2-4 
 BUCKs 5, 7-10 
 LDOs 3-7, 9-14, 18-26, 28, 29, 32-34 
 LDOs 1, 2, 8, 15, 17, 27, 30, 35 
 BUCKs 1, 6 
 BUCKS 2-4 
 BUCK 5 
 BUCKs 7-10 
		
		  If the regulator is disabled and the system warm rebooted,
		  the hardware reports OFF as the regulator operating mode.
		  Default to operating mode NORMAL in that case.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2016 Gateworks Corporation, Inc. All Rights Reserved.
 LTC3676 Registers 
 DVBB register follows right after the corresponding DVBA register 
 select DVBxA 
 select DVBxB 
 LDO3 has a fixed output 
 SW1, SW2, SW3, SW4 linear 0.8V-3.3V with scalar via R1R2 feeback res 
 LDO1 always on fixed 0.8V-3.3V via scalar via R1R2 feeback res 
 LDO2, LDO3 fixed (LDO2 has external scalar via R1R2 feedback res) 
 Clear warning condition 
 LDO3 is fixed 1.8V 
 SPDX-License-Identifier: GPL-2.0
 Device driver for regulators in Hi6421V530 IC
 Copyright (c) <2017> HiSilicon Technologies Co., Ltd.
              http:
 Copyright (c) <2017> Linaro Ltd.
              https:
 Author: Wang Xiaoyin <hw.wangxiaoyin@hisilicon.com>
         Guodong Xu <guodong.xu@linaro.org>
  struct hi6421v530_regulator_info - hi6421v530 regulator information
  @desc: regulator description
  @mode_mask: ECO mode bitmask of LDOs; for BUCKs, this masks sleep
  @eco_microamp: eco mode load upper limit (in uA), valid for LDOs only
 HI6421v530 regulators 
  _id - LDO id name string
  v_table - voltage table
  vreg - voltage select register
  vmask - voltage select mask
  ereg - enable register
  emask - enable mask
  odelay - offon delay time in uS
  ecomask - eco mode mask
  ecoamp - eco mode load uppler limit in uA
 HI6421V530 regulator information 
 SPDX-License-Identifier: GPL-2.0+
 max14577.c - Regulator driver for the Maxim 1457777836
 Copyright (C) 2013,2014 Samsung Electronics
 Krzysztof Kozlowski <krzk@kernel.org>
 MBCHOSTEN and CGMBC are on 
 TODO: add .set_suspend_mode 
  Registers for regulators of max77836 use different I2C slave addresses so
  different regmaps must be used for them.
  Returns proper regmap for accessing regulator passed by id.
 MAX77836_LDO1 ... MAX77836_LDO2 
		
		  Index of supported_regulators[] is also the id and must
		  match index of pdata->regulators[].
 SPDX-License-Identifier: GPL-2.0-or-later
  dummy.c
  Copyright 2010 Wolfson Microelectronics PLC.
  Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
  This is useful for systems with mixed controllable and
  non-controllable regulators, as well as for allowing testing on
  systems with no controllable regulators.
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) STMicroelectronics 2019
 Author(s): Fabrice Gasnier <fabrice.gasnier@st.com>.
 STM32H7 SYSCFG register 
 STM32MP1 SYSCFG has set and clear registers 
 up to 50us to stabilize 
 SPDX-License-Identifier: GPL-2.0-or-later
  max8952.c - Voltage and current regulation for the Maxim 8952
  Copyright (C) 2010 Samsung Electronics
  MyungJoo Ham <myungjoo.ham@samsung.com>
 Registers 
 DVS not supported 
	
	  Do not use devm here: the regulator core takes over the
	  lifecycle management of the GPIO descriptor.
 Fetch vid0 and vid1 GPIOs if available 
 If either VID GPIO is missing just disable this 
 Make sure if we have any descriptors they get set to low 
 Disable Pulldown of EN only 
		
		  Disable Pulldown on EN, VID0, VID1 to reduce
		  leakage current of MAX8952 assuming that MAX8952
		  is turned on (EN==1). Note that without having VID01
		  properly connected, turning pulldown off can be
		  problematic. Thus, turn this off only when they are
		  controllable by GPIO.
 SPDX-License-Identifier: GPL-2.0+
 wm831x-dcdc.c  --  DC-DC buck converter driver for the WM831x series
 Copyright 2009 Wolfson Microelectronics PLC.
 Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
 Register offsets in control block 
  Shared
 First, check for errors 
 DCDC1 and DCDC2 can additionally detect high voltagecurrent 
 Is the regulator on? 
	 TODO: When we handle hardware control modes so we can report the
  BUCKV specifics
	 Should wait for DVS state change to be asserted if we have
	  a GPIO for it, for now assume the device is configured
	  for the fastest possible transition.
 If this value is already set then do a GPIO update if we can 
 Always set the ON status to the minimum voltage 
 Kick the voltage transition now 
	
	  If this VSEL is higher than the last one we've seen then
	  remember it as the DVS VSEL.  This is optimised for CPUfreq
	  usage where we want to get to the highest voltage very
	  quickly.
 Current limit options 
  Set up DVS control.  We just log errors since we can still run
  (with reduced performance) if we fail.
	 gpiolib won't let us read the GPIO status so pick the higher
	  of the two existing voltages so we take it as platform data.
	 If DVS_VSEL is set to the minimum value then raise it to ON_VSEL
	  to make bootstrapping a bit smoother.
  BUCKP specifics
  DCDC boost convertors
 First, check for errors 
 Is the regulator on? 
  External Power Enable
  These aren't actually DCDCs but look like them in hardware so share
  code.
	 For current parts this is correct; probably need to revisit
	  in future.
 Offset in DCDC registers 
 Module information 
  tps65023-regulator.c
  Supports TPS65023 Regulator
  Copyright (C) 2009 Texas Instrument Incorporated - https:www.ti.com
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any kind,
  whether express or implied; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.
 Register definitions 
 PGOODZ bitfields 
 MASK bitfields 
 REG_CTRL bitfields 
 REG_CTRL2 bitfields 
 Number of step-down converters available 
 Number of LDO voltage regulators  available 
 Number of total regulators available 
 DCDCs 
 LDOs 
 Supported voltage values for regulators 
 Supported voltage values for LDO regulators for tps65020 
 Supported voltage values for LDO regulators
 PMIC details 
 Struct passed as driver data 
 Operations permitted on VDCDCx 
 Operations permitted on LDOx 
 common for all regulators 
 Register the regulators 
 Enable setting output voltage by I2C 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2020 ROHM Semiconductors
 If voltage is set to 0 => disable 
 Some setups don't allow setting own voltage but do allow enabling 
 NOTE to next hacker - Does not support pickable ranges 
 SPDX-License-Identifier: GPL-2.0-only
  Regulator driver for RICOH RC5T583 power management chip.
  Copyright (c) 2011-2012, NVIDIA CORPORATION.  All rights reserved.
  Author: Laxman dewangan <ldewangan@nvidia.com>
  based on code
       Copyright (C) 2011 RICOH COMPANY,LTD
 Regulator register address.
 Regulator specific turn-on delay  and voltage settling time
 Used by regulator core 
		
		  Configuring external control is not a major issue,
		  just give warning.
 SPDX-License-Identifier: GPL-2.0-only
  TI LM363X Regulator Driver
  Copyright 2015 Texas Instruments
  Author: Milo Kim <milo.kim@ti.com>
 LM3631 
 LM3632 
 LM36274 
 Common 
 LM3631 
 LM3632 
 LM36274 
	
	  Check LCM_EN12_GPIO is configured.
	  Those pins are used for enabling VPOSVNEG LDOs.
	  Do not use devm here: the regulator core takes over the
	  lifecycle management of the GPIO descriptor.
	
	  LM3632 LDOs can be controlled by external pin.
	  Register update is required if the pin is used.
 SPDX-License-Identifier: GPL-2.0+
 max8997.c - Regulator driver for the Maxim 89978966
 Copyright (C) 2011 Samsung Electronics
 MyungJoo Ham <myungjoo.ham@samsung.com>
 This driver is based on max8998.c
 in mVus 
 Voltage maps in uV 
 LDO1 ~ 18, 21 all 
 Buck1, 2, 4, 5 
 Buck3, 7 
 current map in uA 
 Not controllable or not exists 
  For LDO1 ~ LDO21, BUCK1~5, BUCK7, CHARGER, CHARGER_TOPOFF
  BUCK1, 2, and 5 are available if they are not controlled by gpio
 Delay is required only if the voltage is increasing 
 No need to delay if gpio_dvs_mode 
  Assess the damage on the voltage setting of BUCK1,2,5 by the change.
  When GPIO-DVS mode is used for multiple bucks, changing the voltage value
  of one of the bucks may affect that of another buck, which is the side
  effect of the change (set_voltage). This function examines the GPIO-DVS
  configurations and checks whether such side-effect exists.
 Not affected 
 NO SIDE EFFECT! Use This! 
  For Buck 1 ~ 5 and 7. If it is not controlled by GPIO, this calls
  max8997_set_voltage_ldobuck to do the job.
 For SAFEOUT1 and SAFEOUT2 
 Reuse max8997_set_voltage_ldobuck to set current_limit. 
 Reuse max8997_list_voltage to get current_limit. 
 count the number of regulators to be supported in pmic 
 CONFIG_OF 
 For the safety, set max voltage before setting up 
 Initialize all the DVS related BUCK registers 
	
	  If buck 1, 2, and 5 do not care DVS GPIO settings, ignore them.
	  If at least one of them cares, set gpios.
 SET1 
 SET2 
 SET3 
 DVS-GPIO disabled 
 Misc Settings 
 set 10mVus, which is the default 
 SPDX-License-Identifier: GPL-2.0
 FAN53555 Fairchild Digitally Programmable TinyBuck Regulator Driver.
 Supported Part Numbers:
 FAN53555UC00X01X03X04X05X
 Copyright (c) 2012 Marvell Technology Ltd.
 Yunfan Zhang <yfzhang@marvell.com>
 Voltage setting 
 Control register 
 IC Type 
 IC mask version 
 Monitor register 
 VSEL bit definitions 
 Chip ID and Verison 
 ID1 
 ID2 
 Control bit definitions 
 Numbers of voltages 
 IC Type 
 IC mask revision 
 IC Type and Rev 
 Voltage setting register 
 Voltage range and step(linear) 
 Mode 
 Sleep voltage cache 
 Slew rate 
	 Cache the sleep voltage setting.
 Init voltage range and step 
 Init voltage range and step 
 Init voltage range and step 
 Init voltage range and step 
 For 00,01,03,05 options:
  VOUT = 0.60V + NSELx  10mV, from 0.60 to 1.23V.
  For 04 option:
  VOUT = 0.603V + NSELx  12.826mV, from 0.603 to 1.411V.
 Setup voltage control register 
 Setup mode control register 
 Setup voltage range 
 if no ramp constraint set, get the pdata ramp_delay 
 Get chip ID 
 Get chip revision 
 Device init 
 Register regulator 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2012 ARM Limited
 SPDX-License-Identifier: GPL-2.0-only
 Copyright 2014 Embest Technology Co. Ltd. Inc.
 bd71815-regulator.c ROHM BD71815 regulator driver
 Author: Tony Luo <luofc@embedinfo.com>
 Partially rewritten at 2021 by
 Matti Vaittinen <matti.vaitinen@fi.rohmeurope.com>
  Bucks 1 and 2 have two voltage selection registers where selected
  voltage can be set. Which of the registers is used can be either controlled
  by a control bit in register - or by HW state. If HW state specific voltages
  are given - then we assume HW state based control should be used.
  If volatge value is updated to currently selected register - then output
  voltage is immediately changed no matter what is set as ramp rate. Thus we
  default changing voltage by writing new value to inactive register and
  then updating the 'register selection' bit. This naturally only works when
  HW state machine is not used to select the voltage.
			
			  We are currently using voltage from _L.
			  We'd better copy it to _H and switch to it to
			  avoid shutting us down if LPSR or SUSPEND is set to
			  disabled. _L value is at reg _H + 1
		
		  DVS levels were given => use HW-state machine for voltage
		  controls. NOTE: AFAIK, This means that if voltage is changed
		  by SW the ramp-rate is not respected. Should we disable
		  SW voltage control when the HW state machine is used?
  BUCK12
  BUCK1RAMPRATE[1:0] BUCK1 DVS ramp rate setting
  00: 10.00mVusec	10mV 1uS
  01: 5.00mVusec	10mV 2uS
  10: 2.50mVusec	10mV 4uS
  11: 1.25mVusec	10mV 8uS
			
			  HW FIX: spurious led status change detected. Toggle
			  state as a workaround
	
	  If we use HW state machine based voltage reg selection - then we
	  return BD71815_REG_BUCK1_VOLT_H which is used at RUN.
	  Else we do return the BD71815_REG_BUCK1_VOLT_H or
	  BD71815_REG_BUCK1_VOLT_L depending on which is selected to be used
	  by BD71815_BUCK_DVSSEL bit
  For Buck 12.
	
	  If bucks 1 & 2 are controlled by state machine - then the RUN state
	  voltage is set to BD71815_REG_BUCK1_VOLT_H. Changing SUSPENDLPSR
	  voltages at runtime is not supported by this driver.
 Update new voltage to the register which is not selected now 
 Select the other DVS register to be used 
	
	  Let's default LDO3 to be enabled by SW. We can override ops if DT
	  says LDO3 should be enabled by HW when DCIN is connected.
 Disable to go to ship-mode 
 SPDX-License-Identifier: GPL-2.0-only
 Qualcomm PMIC VBUS output regulator driver
 Copyright (c) 2020, The Linux Foundation. All rights reserved.
 Disable HW logic for VBUS enable 
 SPDX-License-Identifier: GPL-2.0-only
  LP8755 High Performance Power Management Unit : System Interface Driver
  (based on rev. 0.26)
  Copyright 2012 Texas Instruments
  Author: Daniel(Geon Si) Jeong <daniel.jeong@ti.com>
 forced pwm mode 
 enable automatic pwmpfm mode 
 enable automatic pwmpfmlppfm mode 
 forced pwm mode 
 mode fast means forced pwm mode 
 mode idle means automatic pwmpfmlppfm mode 
 mode normal means automatic pwmpfm mode 
 read back  muti-phase configuration 
 set default data based on multi-phase config 
 read flag0 register 
 clear flag register to pull up int. pin 
 sent power fault detection event to specific regulator 
 read flag1 register 
 clear flag register to pull up int. pin 
 send OCP event to all regulator devices 
 send OVP event to all regulator devices 
 output disable 
 SPDX-License-Identifier: GPL-2.0-only
  Regulator driver for Rockchip RK805RK808RK818
  Copyright (c) 2014, Fuzhou Rockchip Electronics Co., Ltd
  Author: Chris Zhong <zyw@rock-chips.com>
  Author: Zhang Qing <zhangqing@rock-chips.com>
  Copyright (C) 2016 PHYTEC Messtechnik GmbH
  Author: Wadim Egorov <w.egorov@phytec.de>
 Field Definitions 
 Ramp rate definitions for buck1  buck2 only 
 Offset from XXX_ON_VSEL to XXX_SLP_VSEL 
 Offset from XXX_ON_VSEL to XXX_DVS_VSEL 
 Offset from XXX_EN_REG to SLEEP_SET_OFF_XXX 
 max steps for increase voltage of Buck12, equal 100mv
 RK817 RK809 
	
	  If directly modify the register to change the voltage, we will face
	  the risk of overshoot. Put it into a multi-step, can effectively
	  avoid this problem, a step is 100mv here.
		
		  i2c is 400kHz (2.5us per bit) and we must transmit _at least_
		  3 bytes (24 bits) plus start and stop so 26 bits.  So we've
		  got more than 65 us between each voltage change and thus
		  won't ramp faster than ~1500 uV  us.
	
	  When we change the voltage register directly, the ramp rate is about
	  100000uvus, wait 1us to make sure the target voltage to be stable,
	  so we needn't wait extra time after that.
 if there is no dvs12 pin, we don't need wait extra time here. 
 add write mask bit 
 Instantiate the regulators 
 SPDX-License-Identifier: GPL-2.0+
 Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
 no dynamic voltage scaling for PF3001 
 No linar case for the some switches of PFUZE3000 
 PFUZE100 
 PFUZE100 
 PFUZE200 
 PFUZE3000 
 PFUZE3001 
 Switch from default mode: APSAPS to APSOff 
		
		  Freescale misprogrammed 1-3% of parts prior to week 8 of 2013
		  as ID=8 in PFUZE100
 device id NOT match with your setting 
 use the right regulators after identify the right device 
 SW2~SW4 high bit check and modify the voltage value table 
		
		  Allow SW regulators to turn off. Checking it trough a flag is
		  a workaround to keep the backward compatibility with existing
		  old dtb's which may relay on the fact that we didn't disable
		  the switched regulator till yet.
  tps51632-regulator.c -- TI TPS51632
  Regulator driver for TPS51632 3-2-1 Phase D-Cap Step Down Driverless
  Controller with serial VID control and DVFS.
  Copyright (c) 2012, NVIDIA Corporation.
  Author: Laxman Dewangan <ldewangan@nvidia.com>
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any kind,
  whether express or implied; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
  02111-1307, USA
 Register definitions 
 TPS51632_DVFS_CONTROL_REG 
 TPS51632_POWER_STATE_REG 
 TPS51632 chip information 
		
		  TPS51632 hw behavior: VMAX register can be write only
		  once as it get locked after first write. The lock get
		  reset only when device is power-reset.
		  Write register only when lock bit is not enabled.
 Register the regulators 
 SPDX-License-Identifier: GPL-2.0+
 mp5416.c  - regulator driver for mps mp5416
 Copyright 2020 Monolithic Power Systems, Inc
 Author: Saravanan Sekar <sravanhome@gmail.com>
 values in uV 
 Current limits array (in uA)
  ILIM1 & ILIM3
 ILIM2 & ILIM4 
  DVS ramp rate BUCK1 to BUCK4
  00: 32mVus
  01: 16mVus
  10: 8mVus
  11: 4mVus
 SPDX-License-Identifier: GPL-2.0-or-later
  isl9305 - Intersil ISL9305 DCDC regulator
  Copyright 2014 Linaro Ltd
  Author: Mark Brown <broonie@kernel.org>
  Registers
  DCD_PARAMETER
  SYSTEM_PARAMETER
  DCD_SRCTL
 for backward compat., don't use 
 for backward compat., don't use 
 SPDX-License-Identifier: GPL-2.0-only
  Regulators driver for Maxim max8649
  Copyright (C) 2009-2010 Marvell International Ltd.
       Haojian Zhuang <haojian.zhuang@marvell.com>
 uV 
 uV 
 uV 
 Registers 
 Bits 
 bit[1:0] = VID1, VID0 
 get voltage 
 get rate 
 uVuS 
 enable VID0 & VID1 
 enabledisable external clock synchronization 
 set external clock frequency 
 Module information 
 SPDX-License-Identifier: GPL-2.0+
 arizona-micsupp.c  --  Microphone supply for Arizona devices
 Copyright 2012 Wolfson Microelectronics PLC.
 Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
 Default to regulated mode 
	
	  Since the chip usually supplies itself we provide some
	  default init_data for it.  This will be overridden with
	  platform data if provided.
 Module information 
SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2017 Spreadtrum Communications Inc.
  SC2731 regulator lock register
  SC2731 enable register
  SC2731 enable mask
  SC2731 vsel register
  SC2731 vsel register mask
 SPDX-License-Identifier: GPL-2.0-or-later
 core.c  --  VoltageCurrent Regulator framework.
 Copyright 2007, 2008 Wolfson Microelectronics PLC.
 Copyright 2008 SlimLogic Ltd.
 Author: Liam Girdwood <lrg@slimlogic.co.uk>
  struct regulator_map
  Used to provide symbolic supply names to devices.
 The dev_name() for the consumer 
  struct regulator_enable_gpio
  Management for shared enable GPIO pin
 a number of enabled shared GPIO 
 a number of requested shared GPIO 
  struct regulator_supply_alias
  Used to map lookups for a supply onto an alternative device.
  regulator_lock_nested - lock a single regulator
  @rdev:		regulator source
  @ww_ctx:		ww mutex acquire context
  This function can be called many times by one task on
  a single regulator and its mutex will be locked only
  once. If a task, which is calling this function is other
  than the one, which initially locked the mutex, it will
  wait on mutex.
  regulator_lock - lock a single regulator
  @rdev:		regulator source
  This function can be called many times by one task on
  a single regulator and its mutex will be locked only
  once. If a task, which is calling this function is other
  than the one, which initially locked the mutex, it will
  wait on mutex.
  regulator_unlock - unlock a single regulator
  @rdev:		regulator_source
  This function unlocks the mutex when the
  reference counter reaches 0.
 shouldn't happen 
  regulator_unlock_dependent - unlock regulator's suppliers and coupled
 				regulators
  @rdev:			regulator source
  @ww_ctx:			ww mutex acquire context
  Unlock all regulators related with rdev by coupling or supplying.
  regulator_lock_dependent - lock regulator's suppliers and coupled regulators
  @rdev:			regulator source
  @ww_ctx:			ww mutex acquire context
  This function as a wrapper on regulator_lock_recursive(), which locks
  all regulators related with rdev by coupling or supplying.
  of_get_child_regulator - get a child regulator device node
  based on supply name
  @parent: Parent device node
  @prop_name: Combination regulator supply name and "-supply"
  Traverse all child nodes.
  Extract the child regulator device node corresponding to the supply name.
  returns the device node corresponding to the regulator if found, else
  returns NULL.
  of_get_regulator - get a regulator device node based on supply name
  @dev: Device pointer for the consumer (of regulator) device
  @supply: regulator supply name
  Extract the regulator device node corresponding to the supply name.
  returns the device node corresponding to the regulator if found, else
  returns NULL.
 64 is max size of property name 
 Platform voltage constraint check 
 return 0 if the state is valid 
 Make sure we select a voltage that suits the needs of all
  regulator consumers
		
		  Assume consumers that didn't say anything are OK
		  with anything in the constraint range.
 current constraint check 
 operating mode constraint check 
	 The modes are bitmasks, the most power hungry modes having
	  the lowest values. If the requested mode isn't supported
	  try higher modes.
	 If we have no suspend mode configuration don't set anything;
	  only warn if the driver implements set_suspend_voltage or
	  set_suspend_mode callback.
 Calculate the new optimum regulator operating mode based on the new total
  consumer load. All locks held by caller
	
	  first check to see if we can set modes at all, otherwise just
	  tell the consumer everything is OK.
 calc total requested load 
 set the optimum mode for our new total regulator load 
 get output voltage 
 get input voltage 
 now get the optimum mode for our new total regulator load 
 check the new mode is allowed 
 OK if set_suspend_enable or set_suspend_disable is NULL 
 !DEBUG && !CONFIG_DYNAMIC_DEBUG 
 !DEBUG && !CONFIG_DYNAMIC_DEBUG 
 do we need to apply the constraint voltage 
 This regulator can't be read and must be initialized 
		
		  If we're below the minimum voltage move up to the
		  minimum voltage, if we're above the maximum voltage
		  then move down to the maximum.
	 constrain machine-level voltage specs to fit
	  the actual range supported by this regulator.
		 it's safe to autoconfigure fixed-voltage supplies
		  and the constraints are used by list_voltage.
 voltage constraints are optional 
 else require explicit machine-level constraints 
 no need to loop voltages if range is continuous 
 initial: [cmin..cmax] valid, [min_uV..max_uV] not 
 maybe adjust [min_uV..max_uV] 
 final: [min_uV..max_uV] valid iff constraints valid 
 use regulator's subset of machine constraints 
 Set regulator current in constraints range 
  set_machine_constraints - sets regulator constraints
  @rdev: regulator source
  Allows platform initialisation code to define and constrain
  regulator circuits e.g. valid voltagecurrent ranges, etc.  NOTE:
  Constraints must be set by platform code in order for some
  regulator operations to proceed i.e. set_voltage, set_current_limit,
  set_mode.
 do we need to setup our suspend state 
		
		  We'll only apply the initial system load if an
		  initial mode wasn't specified.
	
	  Existing logic does not warn if over_current_protection is given as
	  a constraint but driver does not support that. I think we should
	  warn about this type of issues as it is possible someone changes
	  PMIC on board to another type - and the another PMIC's driver does
	  not support setting protection. Board composer may happily believe
	  the DT limits are respected - especially if the new PMIC HW also
	  supports protection but the driver does not. I won't change the logic
	  without hearing more experienced opinion on this though.
	 
	  If warning is seen as a good idea then we can merge handling the
	  over-curret protection and detection and get rid of this special
	  handling.
	 If the constraints say the regulator should be on at this point
	  and we have control then make sure it is enabled.
		 If we want to enable this regulator, make sure that we know
		  the supplying regulator.
  set_supply - set regulator supply regulator
  @rdev: regulator name
  @supply_rdev: supply regulator name
  Called by platform initialisation code to set the supply regulator for this
  regulator. This ensures that a regulators supply will also be enabled by the
  core if it's child is enabled.
  set_consumer_device_supply - Bind a regulator to a symbolic supply
  @rdev:         regulator source
  @consumer_dev_name: dev_name() string for device supply applies to
  @supply:       symbolic name for supply
  Allows platform initialisation code to map physical regulator
  sources to symbolic names for supplies for use by devices.  Devices
  should use these symbolic names to request regulators, avoiding the
  need to provide board-specific regulator names as platform data.
 Add a link to the device sysfs entry 
 non-fatal 
	
	  Check now if the regulator is an always on regulator - if
	  it is then we don't need to do nearly so much work for
	  enabledisable calls.
  regulator_dev_lookup - lookup a regulator device.
  @dev: device for regulator "consumer".
  @supply: Supply name or regulator ID.
  If successful, returns a struct regulator_dev that corresponds to the name
  @supply and with the embedded struct device refcount incremented by one.
  The refcount must be dropped by calling put_device().
  On failure one of the following ERR-PTR-encoded values is returned:
  -ENODEV if lookup fails permanently, -EPROBE_DEFER if lookup could succeed
  in the future.
 first do a dt based lookup 
			
			  We have a node, but there is no device.
			  assume it has not registered yet.
 if not found, try doing it non-dt way 
 If the mapping has a device set up it must match 
 No supply to resolve? 
 Supply already resolved? (fast-path without locking contention) 
 Did the lookup explicitly defer for us? 
	
	  If the supply's parent device is not the same as the
	  regulator's parent device, then ensure the parent device
	  is bound before we resolve the supply, in case the parent
	  device get probe deferred and unregisters the supply.
 Recursively resolve the supply of the supply 
	
	  Recheck rdev->supply with rdev->mutex lock held to avoid a race
	  between rdev->supply null check and setting rdev->supply in
	  set_supply() from concurrent tasks.
 Supply just resolved by a concurrent task? 
	
	  In set_machine_constraints() we may have turned this regulator on
	  but we couldn't propagate to the supply if it hadn't been resolved
	  yet.  Do it now.
 Internal regulator request function 
		
		  If regulator_dev_lookup() fails with error other
		  than -ENODEV our job here is done, we simply return it.
			
			  Assume that a regulator is physically present and
			  enabled, even if it isn't hooked up, and just
			  provide a dummy.
  regulator_get - lookup and obtain a reference to a regulator.
  @dev: device for regulator "consumer"
  @id: Supply name or regulator ID.
  Returns a struct regulator corresponding to the regulator producer,
  or IS_ERR() condition containing errno.
  Use of supply names configured via set_consumer_device_supply() is
  strongly encouraged.  It is recommended that the supply name used
  should match the name used for the supply andor the relevant
  device pins in the datasheet.
  regulator_get_exclusive - obtain exclusive access to a regulator.
  @dev: device for regulator "consumer"
  @id: Supply name or regulator ID.
  Returns a struct regulator corresponding to the regulator producer,
  or IS_ERR() condition containing errno.  Other consumers will be
  unable to obtain this regulator while this reference is held and the
  use count for the regulator will be initialised to reflect the current
  state of the regulator.
  This is intended for use by consumers which cannot tolerate shared
  use of the regulator such as those which need to force the
  regulator off for correct operation of the hardware they are
  controlling.
  Use of supply names configured via set_consumer_device_supply() is
  strongly encouraged.  It is recommended that the supply name used
  should match the name used for the supply andor the relevant
  device pins in the datasheet.
  regulator_get_optional - obtain optional access to a regulator.
  @dev: device for regulator "consumer"
  @id: Supply name or regulator ID.
  Returns a struct regulator corresponding to the regulator producer,
  or IS_ERR() condition containing errno.
  This is intended for use by consumers for devices which can have
  some supplies unconnected in normal use, such as some MMC devices.
  It can allow the regulator core to provide stub supplies for other
  supplies requested using normal regulator_get() calls without
  disrupting the operation of drivers that can handle absent
  supplies.
  Use of supply names configured via set_consumer_device_supply() is
  strongly encouraged.  It is recommended that the supply name used
  should match the name used for the supply andor the relevant
  device pins in the datasheet.
 remove any sysfs entries 
 regulator_list_mutex lock held by regulator_put() 
 Docs say you must disable before calling regulator_put() 
  regulator_put - "free" the regulator source
  @regulator: regulator source
  Note: drivers must ensure that all regulator_enable calls made on this
  regulator source are balanced by regulator_disable calls prior to calling
  this function.
  regulator_register_supply_alias - Provide device alias for supply lookup
  @dev: device that will be given as the regulator "consumer"
  @id: Supply name or regulator ID
  @alias_dev: device that should be used to lookup the supply
  @alias_id: Supply name or regulator ID that should be used to lookup the
  supply
  All lookups for id on dev will instead be conducted for alias_id on
  alias_dev.
  regulator_unregister_supply_alias - Remove device alias
  @dev: device that will be given as the regulator "consumer"
  @id: Supply name or regulator ID
  Remove a lookup alias if one exists for id on dev.
  regulator_bulk_register_supply_alias - register multiple aliases
  @dev: device that will be given as the regulator "consumer"
  @id: List of supply names or regulator IDs
  @alias_dev: device that should be used to lookup the supply
  @alias_id: List of supply names or regulator IDs that should be used to
  lookup the supply
  @num_id: Number of aliases to register
  @return 0 on success, an errno on failure.
  This helper function allows drivers to register several supply
  aliases in one operation.  If any of the aliases cannot be
  registered any aliases that were registered will be removed
  before returning to the caller.
  regulator_bulk_unregister_supply_alias - unregister multiple aliases
  @dev: device that will be given as the regulator "consumer"
  @id: List of supply names or regulator IDs
  @num_id: Number of aliases to unregister
  This helper function allows drivers to unregister several supply
  aliases in one operation.
 Manage enable GPIO list. Same GPIO pin can be shared among regulators 
 Free the GPIO only in case of no use 
  regulator_ena_gpio_ctrl - balance enable_count of each GPIO and actual GPIO pin control
  @rdev: regulator_dev structure
  @enable: enable GPIO at initial use?
  GPIO is enabled in case of initial use. (enable_count is 0)
  GPIO is disabled when it is not shared any more. (enable_count <= 1)
 Enable GPIO at initial use 
 Disable GPIO if not used 
  _regulator_enable_delay - a delay helper function
  @delay: time to delay in microseconds
  Delay for the requested amount of time as per the guidelines in:
      Documentationtimerstimers-howto.rst
  The assumption here is that regulators will never be enabled in
  atomic context and therefore sleeping functions can be used.
		
		  For small enough values, handle super-millisecond
		  delays in the usleep_range() call below.
	
	  Give the scheduler some room to coalesce with any other
	  wakeup sources. For delays shorter than 10 us, don't even
	  bother setting up high-resolution timers and just busy-
	  loop.
  _regulator_check_status_enabled
  A helper function to check if the regulator status can be interpreted
  as 'regulator is enabled'.
  @rdev: the regulator device to check
  Return:
   1			- if status shows regulator is in enabled state
   0			- if not enabled state
   Error Value	- as received from ops->get_status()
 Query before enabling in case configuration dependent.  
		 if needed, keep a distance of off_on_delay from last time
		  this regulator was disabled.
	 Allow the regulator to ramp; it would be useful to extend
	  this for bulk operations so that the regulators can ramp
	  together.
	 If poll_enabled_time is set, poll upto the delay calculated
	  above, delaying poll_enabled_time uS to check if the regulator
	  actually got enabled.
	  If the regulator isn't enabled after enable_delay has
	  expired, return -ETIMEDOUT.
  _regulator_handle_consumer_enable - handle that a consumer enabled
  @regulator: regulator source
  Some things on a regulator consumer (like the contribution towards total
  load on the regulator) only have an effect when the consumer wants the
  regulator enabled.  Explained in example with two consumers of the same
  regulator:
    consumer A: set_load(100);       => total load = 0
    consumer A: regulator_enable();  => total load = 100
    consumer B: set_load(1000);      => total load = 100
    consumer B: regulator_enable();  => total load = 1100
    consumer A: regulator_disable(); => total_load = 1000
  This function (together with _regulator_handle_consumer_disable) is
  responsible for keeping track of the refcount for a given regulator consumer
  and applying  unapplying these things.
  Returns 0 upon no error; -error upon error.
  _regulator_handle_consumer_disable - handle that a consumer disabled
  @regulator: regulator source
  The opposite of _regulator_handle_consumer_enable().
  Returns 0 upon no error; -error upon error.
 locks held by regulator_enable() 
 balance only if there are regulators coupled 
		
		  The regulator may already be enabled if it's not switchable
		  or was left on
 Fallthrough on positive return values - already enabled 
  regulator_enable - enable regulator output
  @regulator: regulator source
  Request that the regulator be enabled with the regulator output at
  the predefined voltage or current value.  Calls to regulator_enable()
  must be balanced with calls to regulator_disable().
  NOTE: the output value can be set by other drivers, boot loader or may be
  hardwired in the regulator.
 locks held by regulator_disable() 
 are we the last user and permitted to disable ? 
 we are last user 
  regulator_disable - disable regulator output
  @regulator: regulator source
  Disable the regulator output voltage or current.  Calls to
  regulator_enable() must be balanced with calls to
  regulator_disable().
  NOTE: this will only disable the regulator output if no other consumer
  devices have it enabled, the regulator device supports disabling and
  machine constraints permit this operation.
 locks held by regulator_force_disable() 
  regulator_force_disable - force disable regulator output
  @regulator: regulator source
  Forcibly disable the regulator output voltage or current.
  NOTE: this will disable the regulator output even if other consumer
  devices have it enabled. This should be used for situations when device
  damage will likely occur if the regulator is not disabled (e.g. over temp).
	
	  Workqueue functions queue the new work instance while the previous
	  work instance is being processed. Cancel the queued work instance
	  as the work instance under processing does the job of the queued
	  work instance.
  regulator_disable_deferred - disable regulator output with delay
  @regulator: regulator source
  @ms: milliseconds until the regulator is disabled
  Execute regulator_disable() on the regulator after a delay.  This
  is intended for use with devices that require some time to quiesce.
  NOTE: this will only disable the regulator output if no other consumer
  devices have it enabled, the regulator device supports disabling and
  machine constraints permit this operation.
 A GPIO control always takes precedence 
 If we don't know then assume that the regulator is always on 
  regulator_is_enabled - is the regulator output enabled
  @regulator: regulator source
  Returns positive if the regulator driver backing the sourceclient
  has requested that the device be enabled, zero if it hasn't, else a
  negative errno code.
  Note that the device backing this regulator handle can have multiple
  users, so it might be enabled even if regulator_enable() was never
  called for this particular source.
  regulator_count_voltages - count regulator_list_voltage() selectors
  @regulator: regulator source
  Returns number of selectors, or negative errno.  Selectors are
  numbered starting at zero, and typically correspond to bitfields
  in hardware registers.
  regulator_list_voltage - enumerate supported voltages
  @regulator: regulator source
  @selector: identify voltage to list
  Context: can sleep
  Returns a voltage that can be passed to @regulator_set_voltage(),
  zero if this selector code can't be used on this system, or a
  negative errno.
  regulator_get_regmap - get the regulator's register map
  @regulator: regulator source
  Returns the register map for the given regulator, or an ERR_PTR value
  if the regulator doesn't use regmap.
  regulator_get_hardware_vsel_register - get the HW voltage selector register
  @regulator: regulator source
  @vsel_reg: voltage selector register, output parameter
  @vsel_mask: mask for voltage selector bitfield, output parameter
  Returns the hardware register offset and bitmask used for setting the
  regulator voltage. This might be useful when configuring voltage-scaling
  hardware or firmware that can make I2C requests behind the kernel's back,
  for example.
  On success, the output parameters @vsel_reg and @vsel_mask are filled in
  and 0 is returned, otherwise a negative errno is returned.
  regulator_list_hardware_vsel - get the HW-specific register value for a selector
  @regulator: regulator source
  @selector: identify voltage to list
  Converts the selector to a hardware-specific voltage selector that can be
  directly written to the regulator registers. The address of the voltage
  register can be determined by calling @regulator_get_hardware_vsel_register.
  On error a negative errno is returned.
  regulator_get_linear_step - return the voltage step size between VSEL values
  @regulator: regulator source
  Returns the voltage step size between VSEL values for linear
  regulators, or return 0 if the regulator isn't a linear regulator.
  regulator_is_supported_voltage - check if a voltage range can be supported
  @regulator: Regulator to check.
  @min_uV: Minimum required voltage in uV.
  @max_uV: Maximum required voltage in uV.
  Returns a boolean.
 If we can't change voltage check the current voltage 
 Any voltage within constrains range is fine? 
 Stepping is only needed if the regulator is enabled. 
 No change needed. 
 Stepping up. 
			
			  Call the callback directly instead of using
			  _regulator_call_set_voltage_sel() as we don't
			  want to notify anyone yet. Same in the branch
			  below.
 Stepping down. 
 The final selector will trigger the notifiers. 
	
	  At least try to return to the previous voltage if setting a new
	  one failed.
	
	  If we can't obtain the old selector there is not enough
	  info to call set_voltage_time_sel().
		
		  Call set_voltage_time_sel if successfully obtained
		  old_selector
 Insert any necessary delays 
	 If we're setting the same range as last time the change
	  should be a noop (some cpufreq implementations use the same
	  voltage for multiple frequencies, for example).
	 If we're trying to set a range that overlaps the current voltage,
	  return successfully even though the regulator does not support
	  changing the voltage.
 sanity check 
 constraints check 
 restore original values in case of error 
 for not coupled regulators this will just set the voltage 
 No need to fail here 
 Limit voltage change only if necessary 
 Clamp target voltage within the given step 
	
	  If there are no coupled regulators, simply set the voltage
	  demanded by consumers.
		
		  If consumers don't provide any demands, set voltage
		  to min_uV
 Find highest min desired voltage 
	
	  Let target_uV be equal to the desired one if possible.
	  If not, set it to minimum voltage, allowed by other coupled
	  regulators.
	
	  Find min and max voltages, which currently aren't violating
	  max_spread.
 There aren't any other regulators enabled 
		
		  Correct target voltage, so as it currently isn't
		  violating max_spread
 Apply max_uV_step constraint if necessary 
 Set current_uV if wasn't done earlier in the code and if necessary 
	
	  Find the best possible voltage change on each loop. Leave the loop
	  if there isn't any possible change.
		
		  Find highest difference between optimal voltage
		  and current voltage.
			
			  optimal_uV is the best voltage that can be set for
			  i-th regulator at the moment without violating
			  max_spread constraint in order to balance
			  the coupled voltages.
 Nothing to change, return successfully 
	
	  If system is in a state other than PM_SUSPEND_ON, don't check
	  other coupled regulators.
 Invoke custom balancer for customized couplers 
  regulator_set_voltage - set regulator output voltage
  @regulator: regulator source
  @min_uV: Minimum required voltage in uV
  @max_uV: Maximum acceptable voltage in uV
  Sets a voltage regulator to the desired output voltage. This can be set
  during any regulator state. IOW, regulator can be disabled or enabled.
  If the regulator is enabled then the voltage will change to the new value
  immediately otherwise if the regulator is disabled the regulator will
  output at the new voltage when enabled.
  NOTE: If the regulator is shared between several devices then the lowest
  request voltage that meets the system constraints will be used.
  Regulator system constraints must be set for this regulator before
  calling this function otherwise this call will fail.
	
	  if any consumer wants this regulator device keeping on in
	  suspend states, don't set it as disabled.
 PM_SUSPEND_ON is handled by regulator_set_voltage() 
  regulator_set_voltage_time - get raisefall time
  @regulator: regulator source
  @old_uV: starting voltage in microvolts
  @new_uV: target voltage in microvolts
  Provided with the starting and ending voltage, this function attempts to
  calculate the time in microseconds required to rise or fall to this new
  voltage.
 Currently requires operations to do this 
 We only look for exact voltage matches here 
  regulator_set_voltage_time_sel - get raisefall time
  @rdev: regulator source device
  @old_selector: selector for starting voltage
  @new_selector: selector for target voltage
  Provided with the starting and target voltage selectors, this function
  returns time in microseconds required to rise or fall to this new voltage
  Drivers providing ramp_delay in regulation_constraints can use this as their
  set_voltage_time_sel() operation.
 sanity check 
 balance only, if regulator is coupled 
  regulator_sync_voltage - re-apply last regulator output voltage
  @regulator: regulator source
  Re-apply the last configured voltage.  This is intended to be used
  where some external control source the consumer is cooperating with
  has caused the configured voltage to change.
 This is only going to work if we've had a voltage configured. 
 This should be a paranoia check... 
 balance only, if regulator is coupled 
 if bypassed the regulator must have a supply 
  regulator_get_voltage - get regulator output voltage
  @regulator: regulator source
  This returns the current regulator voltage in uV.
  NOTE: If the regulator is disabled it will return the voltage value. This
  function should not be used to determine regulator state.
  regulator_set_current_limit - set regulator output current limit
  @regulator: regulator source
  @min_uA: Minimum supported current in uA
  @max_uA: Maximum supported current in uA
  Sets current sink to the desired output current. This can be set during
  any regulator state. IOW, regulator can be disabled or enabled.
  If the regulator is enabled then the current will change to the new value
  immediately otherwise if the regulator is disabled the regulator will
  output at the new current when enabled.
  NOTE: Regulator system constraints must be set for this regulator before
  calling this function otherwise this call will fail.
 sanity check 
 constraints check 
 sanity check 
  regulator_get_current_limit - get regulator output current
  @regulator: regulator source
  This returns the current supplied by the specified current sink in uA.
  NOTE: If the regulator is disabled it will return the current value. This
  function should not be used to determine regulator state.
  regulator_set_mode - set regulator operating mode
  @regulator: regulator source
  @mode: operating mode - one of the REGULATOR_MODE constants
  Set regulator operating mode to increase regulator efficiency or improve
  regulation performance.
  NOTE: Regulator system constraints must be set for this regulator before
  calling this function otherwise this call will fail.
 sanity check 
 return if the same mode is requested 
 constraints check 
 sanity check 
  regulator_get_mode - get regulator operating mode
  @regulator: regulator source
  Get the current regulator operating mode.
  regulator_get_error_flags - get regulator error information
  @regulator: regulator source
  @flags: pointer to store error flags
  Get the current regulator error information.
  regulator_set_load - set regulator load
  @regulator: regulator source
  @uA_load: load current
  Notifies the regulator core of a new device load. This is then used by
  DRMS (if enabled by constraints) to set the most efficient regulator
  operating mode for the new regulator loading.
  Consumer devices notify their supply regulator of the maximum power
  they will require (can be taken from device datasheet in the power
  consumption tables) when they change operational status and hence power
  state. Examples of operational state changes that can affect power
  consumption are :-
     o Device is opened  closed.
     o Device IO is about to begin or has just finished.
     o Device is idling in between work.
  This information is also exported via sysfs to userspace.
  DRMS will sum the total requested load on the regulator and change
  to the most efficient operating mode if platform constraints allow.
  NOTE: when a regulator consumer requests to have a regulator
  disabled then any load that consumer requested no longer counts
  toward the total requested load.  If the regulator is re-enabled
  then the previously requested load will start counting again.
  If a regulator is an always-on regulator then an individual consumer's
  load will still be removed if that consumer is fully disabled.
  On error a negative errno is returned.
  regulator_allow_bypass - allow the regulator to go into bypass mode
  @regulator: Regulator to configure
  @enable: enable or disable bypass mode
  Allow the regulator to go into bypass mode if all other consumers
  for the regulator also enable bypass mode and the machine
  constraints allow this.  Bypass mode means that the regulator is
  simply passing the input directly to the output with no regulation.
  regulator_register_notifier - register regulator event notifier
  @regulator: regulator source
  @nb: notifier block
  Register notifier block to receive regulator events.
  regulator_unregister_notifier - unregister regulator event notifier
  @regulator: regulator source
  @nb: notifier block
  Unregister regulator event notifier block.
 notify regulator consumers and downstream regulator consumers.
  Note mutex must be held by caller.
 call rdev chain first 
  regulator_bulk_get - get multiple regulator consumers
  @dev:           Device to supply
  @num_consumers: Number of consumers to register
  @consumers:     Configuration of consumers; clients are stored here.
  @return 0 on success, an errno on failure.
  This helper function allows drivers to get several regulator
  consumers in one operation.  If any of the regulators cannot be
  acquired then any regulators that were allocated will be freed
  before returning to the caller.
  regulator_bulk_enable - enable multiple regulator consumers
  @num_consumers: Number of consumers
  @consumers:     Consumer data; clients are stored here.
  @return         0 on success, an errno on failure
  This convenience API allows consumers to enable multiple regulator
  clients in a single API call.  If any consumers cannot be enabled
  then any others that were enabled will be disabled again prior to
  return.
 If any consumer failed we need to unwind any that succeeded 
  regulator_bulk_disable - disable multiple regulator consumers
  @num_consumers: Number of consumers
  @consumers:     Consumer data; clients are stored here.
  @return         0 on success, an errno on failure
  This convenience API allows consumers to disable multiple regulator
  clients in a single API call.  If any consumers cannot be disabled
  then any others that were disabled will be enabled again prior to
  return.
  regulator_bulk_force_disable - force disable multiple regulator consumers
  @num_consumers: Number of consumers
  @consumers:     Consumer data; clients are stored here.
  @return         0 on success, an errno on failure
  This convenience API allows consumers to forcibly disable multiple regulator
  clients in a single API call.
  NOTE: This should be used for situations when device damage will
  likely occur if the regulators are not disabled (e.g. over temp).
  Although regulator_force_disable function call for some consumers can
  return error numbers, the function is called for all consumers.
 Store first error for reporting 
  regulator_bulk_free - free multiple regulator consumers
  @num_consumers: Number of consumers
  @consumers:     Consumer data; clients are stored here.
  This convenience API allows consumers to free multiple regulator
  clients in a single API call.
  regulator_notifier_call_chain - call regulator event notifier
  @rdev: regulator source
  @event: notifier block
  @data: callback-specific data.
  Called by regulator drivers to notify clients a regulator event has
  occurred.
  regulator_mode_to_status - convert a regulator mode into a status
  @mode: Mode to convert
  Convert a regulator mode into a status.
  To avoid cluttering sysfs (and memory) with useless state, only
  create attributes that can be meaningfully displayed.
 these three are always present 
 some attributes need specific methods to be displayed 
 constraints need specific supporting methods 
 Avoid duplicate debugfs directory names 
	
	  Note that regulators are appended to the list and the generic
	  coupler is registered first, hence it will be attached at last
	  if nobody cared.
 already resolved 
	
	  Every regulator should always have coupling descriptor filled with
	  at least pointer to itself.
 regulator isn't coupled 
  regulator_register - register regulator
  @regulator_desc: regulator to register
  @cfg: runtime configuration for regulator
  Called by regulator drivers to register a regulator.
  Returns a valid pointer to struct regulator_dev on success
  or an ERR_PTR() on error.
 Only one of each should be implemented 
 If we're using selectors we must implement list_voltage. 
	
	  Duplicate the config so the driver could override it after
	  parsing init data.
	
	  Sometimes not all resources are probed already so we need to take
	  that into account. This happens most the time if the ena_gpiod comes
	  from a gpio extender or something else.
	
	  We need to keep track of any GPIO descriptor coming from the
	  device tree until we have handled it over to the core. If the
	  config that was passed in to this function DOES NOT contain
	  a descriptor, and the config after this call DOES contain
	  a descriptor, we definitely got one from parsing the device
	  tree.
 preform any regulator specific init 
 The regulator core took over the GPIO descriptor 
 register with sysfs 
 set regulator constraints 
		 Regulator might be in bypass mode and so needs its supply
		  to set the constraints
		 FIXME: this currently triggers a chicken-and-egg problem
		  when creating -SUPPLY symlink in sysfs to a regulator
		  that is just being created
 add consumers devices 
 try to resolve regulators coupling since a new one was registered 
 try to resolve regulators supply since a new one was registered 
  regulator_unregister - unregister regulator
  @rdev: regulator to unregister
  Called by regulator drivers to unregister a regulator.
  regulator_suspend - prepare regulators for system wide suspend
  @dev: ``&struct device`` pointer that is passed to _regulator_suspend()
  Configure each regulator with it's suspend operating parameters for state.
 Avoid grabbing the lock if we don't need to 
 !CONFIG_SUSPEND 
 !CONFIG_SUSPEND 
  regulator_has_full_constraints - the system has fully specified constraints
  Calling this function will cause the regulator API to disable all
  regulators which have a zero use count and don't have an always_on
  constraint in a late_initcall.
  The intention is that this will become the default behaviour in a
  future kernel release so users are encouraged to use this facility
  now.
  rdev_get_drvdata - get rdev regulator driver data
  @rdev: regulator
  Get rdev regulator driver private data. This call can be used in the
  regulator driver context.
  regulator_get_drvdata - get regulator driver data
  @regulator: regulator
  Get regulator driver private data. This call can be used in the consumer
  driver context when non API regulator specific functions need to be called.
  regulator_set_drvdata - set regulator driver data
  @regulator: regulator
  @data: data
  rdev_get_id - get regulator ID
  @rdev: regulator
 CONFIG_DEBUG_FS 
 init early to allow our consumers to complete system booting 
 If we can't read the status assume it's always on. 
 But if reading the status failed, assume that it's off. 
		 We log since this may kill the system if it goes
		  wrong.
		 The intention is that in future we will
		  assume that full constraints are provided
		  so warn even if we aren't going to do
		  anything here.
	
	  Regulators may had failed to resolve their input supplies
	  when were registered, either because the input supply was
	  not registered yet or because its parent device was not
	  bound yet. So attempt to resolve the input supplies for
	  pending regulators before trying to disable unused ones.
	 If we have a full configuration then disable any regulators
	  we have permission to change the status for and which are
	  not in use or always_on.  This is effectively the default
	  for DT and ACPI as they have full constraints.
	
	  Since DT doesn't provide an idiomatic mechanism for
	  enabling full constraints and since it's much more natural
	  with DT to provide them just assume that a DT enabled
	  system has full constraints.
	
	  We punt completion for an arbitrary amount of time since
	  systems like distros will load many drivers from userspace
	  so consumers might not always be ready yet, this is
	  particularly an issue with laptops where this might bounce
	  the display off then on.  Ideally we'd get a notification
	  from userspace when this happens but we don't so just wait
	  a bit and hope we waited long enough.  It'd be better if
	  we'd only do this on systems that need it, and a kernel
	  command line option might be useful.
 SPDX-License-Identifier: GPL-2.0-or-later
  OF helpers for regulator framework
  Copyright (C) 2011 Texas Instruments, Inc.
  Rajendra Nayak <rnayak@ti.com>
 Protection limits: 
 Voltage change possible? 
 Do we have a voltage range, if so try to apply it? 
 Current change possible? 
 status change should be possible. 
 otherwise use min_uV as default suspend voltage 
  of_get_regulator_init_data - extract regulator_init_data structure info
  @dev: device requesting for regulator_init_data
  @node: regulator device node
  @desc: regulator description
  Populates regulator_init_data structure by extracting data from device
  tree node, returns a pointer to the populated structure or NULL if memory
  alloc fails.
 Out of memory? 
  of_regulator_match - extract multiple regulator init data from device tree.
  @dev: device requesting the data
  @node: parent device node of the regulators
  @matches: match table for the regulators
  @num_matches: number of entries in match table
  This function uses a match table specified by the regulator driver to
  parse regulator init data from the device tree. @node is expected to
  contain a set of child nodes, each providing the init data for one
  regulator. The data parsed from a child node will be matched to a regulator
  based on either the deprecated property regulator-compatible if present,
  or otherwise the child node's name. Note that the match table is modified
  in place and an additional of_node reference is taken for each matched
  regulator.
  Returns the number of matches found or a negative error code on failure.
			
			  'of_node_get(child)' is already performed by the
			  for_each loop.
  Returns number of regulators coupled with rdev.
 Looks for "to_find" device_node in src's "regulator-coupled-with" property 
 found 
  of_check_coupling_data - Parse rdev's coupling properties and check data
 			    consistency
  @rdev: pointer to regulator_dev whose data is checked
  Function checks if all the following conditions are met:
  - rdev's max_spread is greater than 0
  - all coupled regulators have the same max_spread
  - all coupled regulators have the same number of regulator_dev phandles
  - all regulators are linked to each other
  Returns true if all conditions are met.
 iterate over rdev's phandles 
  of_parse_coupled regulator - Get regulator_dev pointer from rdev's property
  @rdev: Pointer to regulator_dev, whose DTS is used as a source to parse
 	  "regulator-coupled-with" property
  @index: Index in phandles array
  Returns the regulator_dev pointer parsed from DTS. If it has not been yet
  registered, returns NULL
 SPDX-License-Identifier: GPL-2.0-only
 Copyright 2020 Google LLC.
	
	  This can happen when the given range [min_uV, max_uV] doesn't
	  contain any voltage that can be represented exactly in mV.
 Make sure the returned name is always a valid string 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
 Pin control enable input pins. 
 Pin control high power mode input pins. 
  Used with enable parameters to specify that hardware default register values
  should be left unaltered.
 Soft start strength of a voltage switch type regulator 
  struct spmi_regulator_init_data - spmi-regulator initialization data
  @pin_ctrl_enable:        Bit mask specifying which hardware pins should be
 				used to enable the regulator, if any
 			    Value should be an ORing of
 				SPMI_REGULATOR_PIN_CTRL_ENABLE_ constants.  If
 				the bit specified by
 				SPMI_REGULATOR_PIN_CTRL_ENABLE_HW_DEFAULT is
 				set, then pin control enable hardware registers
 				will not be modified.
  @pin_ctrl_hpm:           Bit mask specifying which hardware pins should be
 				used to force the regulator into high power
 				mode, if any
 			    Value should be an ORing of
 				SPMI_REGULATOR_PIN_CTRL_HPM_ constants.  If
 				the bit specified by
 				SPMI_REGULATOR_PIN_CTRL_HPM_HW_DEFAULT is
 				set, then pin control mode hardware registers
 				will not be modified.
  @vs_soft_start_strength: This parameter sets the soft start strength for
 				voltage switch type regulators.  Its value
 				should be one of SPMI_VS_SOFT_START_STR_.  If
 				its value is SPMI_VS_SOFT_START_STR_HW_DEFAULT,
 				then the soft start strength will be left at its
 				default hardware value.
 These types correspond to unique register layouts. 
  Second common register layout used by newer devices starting with ftsmps426
  Note that some of the registers from the first common layout remain
  unchanged and their definition is not duplicated.
 Used for indexing into ctrl_reg.  These are offets from 0x40 
 Common regulator control register layout 
 Common regulator mode register layout 
 Common regulator pull down control register layout 
 LDO regulator current limit control register layout 
 LDO regulator soft start control register layout 
 VS regulator over current protection control register layout 
 VS regulator soft start control register layout 
 Boost regulator current limit control register layout 
 Clock rate in kHz of the FTSMPS regulator reference clock. 
 Minimum voltage stepper delay for each step. 
  The ratio SPMI_FTSMPS_STEP_MARGIN_NUMSPMI_FTSMPS_STEP_MARGIN_DEN is used to
  adjust the step rate in order to account for oscillator variance.
 Clock rate in kHz of the FTSMPS426 regulator reference clock. 
 Minimum voltage stepper delay for each step. 
  The ratio SPMI_FTSMPS426_STEP_MARGIN_NUMSPMI_FTSMPS426_STEP_MARGIN_DEN is
  used to adjust the step rate in order to account for oscillator variance.
 VSET value to decide the range of ULT SMPS 
  struct spmi_voltage_range - regulator set point voltage mapping description
  @min_uV:		Minimum programmable output voltage resulting from
 			set point register value 0x00
  @max_uV:		Maximum programmable output voltage
  @step_uV:		Output voltage increase resulting from the set point
 			register value increasing by 1
  @set_point_min_uV:	Minimum allowed voltage
  @set_point_max_uV:	Maximum allowed voltage.  This may be tweaked in order
 			to pick which range should be used in the case of
 			overlapping set points.
  @n_voltages:		Number of preferred voltage set points present in this
 			range
  @range_sel:		Voltage range register value corresponding to this range
  The following relationships must be true for the values used in this struct:
  (max_uV - min_uV) % step_uV == 0
  (set_point_min_uV - min_uV) % step_uV == 0
  (set_point_max_uV - min_uV) % step_uV == 0
  n_voltages = (set_point_max_uV - set_point_min_uV)  step_uV + 1
  Note, set_point_min_uV == set_point_max_uV == 0 is allowed in order to
  specify that the voltage range has meaning, but is not preferred.
  The ranges specified in the spmi_voltage_set_points struct must be listed
  so that range[i].set_point_max_uV < range[i+1].set_point_min_uV.
  These tables contain the physically available PMIC regulator voltage setpoint
  ranges.  Where two ranges overlap in hardware, one of the ranges is trimmed
  to ensure that the setpoints available to software are monotonically
  increasing and unique.  The set_voltage callback functions expect these
  properties to hold.
 Check if request voltage is outside of physically settable range. 
 Find the range which uV is inside of. 
	
	  Force uV to be an allowed set point by applying a ceiling function to
	  the uV value.
			
			  hardware selectors between set point min and real
			  min are invalid so we ignore them
			
			  hardware selectors between set point min and real
			  min and between set point max and real max are
			  invalid so we return an error if they're
			  programmed into the hardware
 Current range doesn't support the requested voltage. 
	
	  Force uV to be an allowed set point by applying a ceiling function to
	  the uV value.
		
		  No set point in the current voltage range is within the
		  requested min_uV to max_uV range.
	
	  Favor staying in the current voltage range if possible.  This avoids
	  voltage spikes that occur when changing the voltage range.
	
	  Certain types of regulators do not have a range select register so
	  only voltage set register needs to be written.
	
	  Calculate VSET based on range
	  In case of range 0: voltage_sel is a 7 bit value, can be written
	 			witout any modification.
	  In case of range 1: voltage_sel is a 5 bit value, bits[7-5] set to
	 			[011].
	
	  Reset the OCP count if there is a large delay between switch enable
	  and when OCP triggers.  This is indicative of a hotplug event as
	  opposed to a fault.
 Wait for switch output to settle back to 0 V after OCP triggered. 
 Immediately clear the over current condition. 
 Schedule the over current clear task to run later. 
 select the band 
 If AVS is enabled, switch it off during the voltage change 
 After successful voltage change, switch the AVS back on 
 Always do the SAW register writes on the first CPU 
 Maximum possible digital major revision value 
           type subtype dig_min dig_max ltype ops setpoints hpm_min 
 slew_rate has units of uVus 
 Ensure that the slew rate is greater than 0 
 slew_rate has units of uVus 
 Ensure that the slew rate is greater than 0 
 Set up enable pin control. 
 Set up mode pin control. 
 Write back any control register values that were modified. 
 Set soft start strength and over current protection for VS. 
	
	  Initialize configuration parameters to use hardware default in case
	  no value is specified via device tree.
 These bindings are optional, so it is okay if they aren't found. 
 l4 is unaccessible on PM660 
 since there is only one range 
 SPDX-License-Identifier: GPL-2.0+
 SPDX-License-Identifier: GPL-2.0
 MP8867MP8869 regulator driver
 Copyright (C) 2020 Synaptics Incorporated
 Author: Jisheng Zhang <jszhang@kernel.org>
 SPDX-License-Identifier: GPL-2.0+
 Extension for proprietary register and mask 
 SPDX-License-Identifier: GPL-2.0-or-later
  gpio-regulator.c
  Copyright 2011 Heiko Stuebner <heiko@sntech.de>
  based on fixed.c
  Copyright 2008 Wolfson Microelectronics PLC.
  Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
  Copyright (c) 2009 Nokia Corporation
  Roger Quadros <ext-roger.quadros@nokia.com>
  This is useful for systems with mixed controllable and
  non-controllable regulators, as well as for allowing testing on
  systems with no controllable regulators.
	
	  Do not use: undocumented device tree property.
	  This is kept around solely for device tree ABI stability.
 Fetch GPIO init levels 
 Default to high per specification 
 Fetch states. 
 This is good to know 
 handle regulator type
 build initial state from gpio init data. 
	
	  The signal will be inverted by the GPIO core if flagged so in the
	  descriptor.
 SPDX-License-Identifier: GPL-2.0+
 max77693.c - Regulator driver for the Maxim 77693 and 77843
 Copyright (C) 2013-2015 Samsung Electronics
 Jonghwa Lee <jonghwa3.lee@samsung.com>
 Krzysztof Kozlowski <krzk@kernel.org>
 This driver is based on max77686.c
  ID for MAX77843 regulators.
  There is no need for such for MAX77693.
 Register differences between chargers: MAX77693 and MAX77843 
  MAX77693 CHARGER regulator - Min : 20mA, Max : 2580mA, step : 20mA
  0x00, 0x01, 0x2, 0x03	= 60 mA
  0x04 ~ 0x7E			= (60 + (X - 3)  20) mA
  Actually for MAX77693 the driver manipulates the maximum input current,
  not the fast charge current (output). This should be fixed.
  On MAX77843 the calculation formula is the same (except values).
  Fortunately it properly manipulates the fast charge current.
 the first four codes for charger current are all 60mA 
 the first four codes for charger current are all 60mA 
 end of CHARGER regulator ops 
 Returns regmap suitable for given regulator on chosen device 
 Else: TYPE_MAX77843 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) STMicroelectronics 2018
 Author: Pascal Paillet <p.paillet@st.com> for STMicroelectronics.
  struct stpmic1 regulator description: this structure is used as driver data
  @desc: regulator framework description
  @mask_reset_reg: mask reset register address
  @mask_reset_mask: mask rank and mask reset register mask
  @icc_reg: icc register address
  @icc_mask: icc register mask
 Enable time worst case is 5000mV(2250uVuS) 
 Ramp delay worst case is (2250uVuS) 
 with index 31 LDO3 is in DDR mode 
	
	  The code seems like one bit in a register controls whether OCP is
	  enabled. So we might be able to turn it off here is if that
	  was requested. I won't support this because I don't have the HW.
	  Feel free to try and implement if you have the HW and need kernel
	  to disable this.
	 
	  Also, I don't know if limit can be configured or if we support
	  errorwarning instead of protect. So I just keep existing logic
	  and assume no.
 enable switch off in case of over current 
 Send an overcurrent notification 
 set mask reset 
 setup an irq handler for over-current detection 
 SPDX-License-Identifier: GPL-2.0
 System Control and Management Interface (SCMI) based regulator driver
 Copyright (C) 2020-2021 ARM Ltd.
 Implements a regulator driver on top of the SCMI Voltage Protocol.
 The ARM SCMI Protocol aims in general to hide as much as possible all the
 underlying operational details while providing an abstracted interface for
 its users to operate upon: as a consequence the resulting operational
 capabilities and configurability of this regulator device are much more
 limited than the ones usually available on a standard physical regulator.
 The supported SCMI regulator ops are restricted to the bare minimum:
  - 'status_ops': enabledisableis_enabled
  - 'voltage_ops': get_voltage_selset_voltage_sel
		     list_voltagemap_voltage
 Each SCMI regulator instance is associated, through the means of a proper DT
 entry description, to a specific SCMI Voltage Domain.
	
	  Note that SCMI voltage domains describable by linear ranges
	  (segments) {low, high, step} are guaranteed to come in one single
	  triplet by the SCMI Voltage Domain protocol support itself.
 Rule out buggy negative-intervals answers from fw 
 Just one fixed voltage exposed by SCMI 
 One simple linear mapping. 
 Discrete non linear levels are mapped to volt_table 
	
	  Regulator framework does not fully support negative voltages
	  so we discard any voltage domain reported as supporting negative
	  voltages: as a consequence each levels_uv entry is guaranteed to
	  be non-negative from here on.
	
	  Using the scmi device here to have DT searched from Voltage
	  protocol node down.
 Store for later retrieval via rdev_get_drvdata() 
 get hold of good nodes 
 Allocate pointers array for all possible domains 
	
	  Start collecting into rinfo->sregv possibly good SCMI Regulators as
	  described by a well-formed DT entry and associated with an existing
	  plausible SCMI Voltage Domain number, all belonging to this SCMI
	  platform instance node (handle->dev->of_node).
 abort on any mem issue 
	
	  Register a regulator for each valid regulator-DT-entry that we
	  can successfully reach via SCMI and has a valid associated voltage
	  domain.
 Skip empty slots 
 Skip invalid voltage domains 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 MediaTek Inc.
 sentinel 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 five technologies GmbH
 Author: Markus Reichl <m.reichl@fivetechno.de>
 Register definitions 
3 lo Bits
8 hi Bits
  AXP20x regulators driver.
  Copyright (C) 2013 Carlo Caione <carlo@caione.org>
  This file is subject to the terms and conditions of the GNU General
  Public License. See the file "COPYING" in the main directory of this
  archive for more details.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
 Not supported for this regulator 
			
			  On some boards, the LDO3 can be overloaded when
			  turning on, causing the entire PMIC to shutdown
			  without warning. Turning it on at the minimal voltage
			  and then setting the voltage to the requested value
			  works reliably.
			
			  A small pause is needed between
			  setting the voltage and enabling the LDO to give the
			  internal state machine time to process the request.
 No quirks 
 secondary switchable output of DCDC1 
 LDO regulator internally chained to DCDC5 
	 Note the datasheet only guarantees reliable operation up to
	 Note the datasheet only guarantees reliable operation up to
 DCDC ranges shared with AXP813 
 AXP806's CLDO2 and AXP809's DLDO1 share the same range 
 secondary switchable output of DCDC1 
 secondary switchable output of DCDC1 
 LDO regulator internally chained to DCDC5 
	
	  Note the datasheet only guarantees reliable operation up to
	  3.3V, this needs to be enforced via dts provided constraints
	
	  Note the datasheet only guarantees reliable operation up to
	  3.3V, this needs to be enforced via dts provided constraints
 to do  check ... 
	
	  TODO: FLDO3 = {DCDC5, FLDOIN}  2
	 
	  This means FLDO3 effectively switches supplies at runtime,
	  something the regulator subsystem does not support.
		
		  AXP803AXP813 DCDC work frequency setting has the same
		  range and step as AXP22X, but at a different register.
		  (See includelinuxmfdaxp20x.h)
 to the check below 
		
		  AXP806 also have DCDC work frequency setting register at a
		  different position.
		
		  AXP806 DCDC regulator IDs have the same range as AXP22X.
		  (See includelinuxmfdaxp20x.h)
 to the check below 
 should not happen 
  This function checks whether a regulator is part of a poly-phase
  output setup based on the registers settings. Returns true if it is.
	
	  Currently in our supported AXP variants, only AXP803, AXP806,
	  and AXP813 have polyphase regulators.
 This only sets the dcdc freq. Ignore any errors 
		
		  If this regulator is a slave in a poly-phase setup,
		  skip it, as its controls are bound to the master
		  regulator and won't work.
 Support for AXP813's FLDO3 is not implemented 
		
		  Regulators DC1SW and DC5LDO are connected internally,
		  so we have to handle their supply names separately.
		 
		  We always register the regulators in proper sequence,
		  so the supply names are correctly read. See the last
		  part of this loop to see where we save the DT defined
		  name.
		
		  Save AXP22X DCDC1  DCDC5 regulator names for later.
 Change N_VBUSEN sense pin to DRIVEVBUS output pin 
 SPDX-License-Identifier: GPL-2.0+
 mpq7920.c  - regulator driver for mps mpq7920
 Copyright 2019 Monolithic Power Systems, Inc
 Author: Saravanan Sekar <sravanhome@gmail.com>
 LDORTC 
 Current limits array (in uA)
  ILIM1 & ILIM3
 ILIM2 & ILIM4 
 LDO4 & LDO5 
 RTCLDO not controllable, always ON 
  DVS ramp rate BUCK1 to BUCK4
  00-01: Reserved
  10: 8mVus
  11: 4mVus
 SPDX-License-Identifier: GPL-2.0+
 Copyright (c) 2019 Mantas Pucka <mantas@8devices.com>
 Copyright (c) 2019 Robert Marko <robert.marko@sartura.hr>
 Driver for IPQ4019 SDMMC controller's IO LDO voltage regulator
 SPDX-License-Identifier: GPL-2.0+
 Copyright (c) 2011 Samsung Electronics Co., Ltd
              http:
 {OFF, ON, LOWPOWER, SUSPEND} 
 LDO1 ... LDO28 
 LDO1 
 LDO5 
 LDO10 
 LDO15 
 LDO20 
 LDO25 
 LDO28 
 BUCK1 ... BUCK9 
 BUCK1 
 BUCK5 
 BUCK9 
 buck234_vol != NULL means to control buck234 voltage via DVS GPIO 
  Enable GPIO control over BUCK9 in regulator_config for that regulator.
 Check if opmode for regulator matches S5M8767_ENCTRL_USE_GPIO 
  Turn on GPIO control over BUCK9.
 count the number of regulators to be supported in pmic 
 CONFIG_OF 
 SET1 GPIO 
 SET2 GPIO 
 SET3 GPIO 
 DS2 GPIO 
 DS3 GPIO 
 DS4 GPIO 
 Initialize GPIO DVS registers 
 Assigns config.ena_gpiod 
			
			  Hand the GPIO descriptor management over to the
			  regulator core, remove it from devres management.
 Module information 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (C) 2019 ROHM Semiconductors
 bd71828-regulator.c ROHM BD71828GW-DS1 regulator driver
	
	  DVS Buck voltages can be changed by register values or via GPIO.
	  Use register accesses by default.
			
			  LPSR voltage is same as SUSPEND voltage. Allow
			  setting it so that regulator can be set enabled at
			  LPSR state
			
			  BUCK3 only supports single voltage for all states.
			  voltage can be individually enabled for each state
			  though => allow setting all states to support
			  enabling power rail on different states.
			
			  BUCK4 only supports single voltage for all states.
			  voltage can be individually enabled for each state
			  though => allow setting all states to support
			  enabling power rail on different states.
			
			  BUCK5 only supports single voltage for all states.
			  voltage can be individually enabled for each state
			  though => allow setting all states to support
			  enabling power rail on different states.
			
			  LDO1 only supports single voltage for all states.
			  voltage can be individually enabled for each state
			  though => allow setting all states to support
			  enabling power rail on different states.
			
			  LDO2 only supports single voltage for all states.
			  voltage can be individually enabled for each state
			  though => allow setting all states to support
			  enabling power rail on different states.
			
			  LDO3 only supports single voltage for all states.
			  voltage can be individually enabled for each state
			  though => allow setting all states to support
			  enabling power rail on different states.
			
			  LDO1 only supports single voltage for all states.
			  voltage can be individually enabled for each state
			  though => allow setting all states to support
			  enabling power rail on different states.
		
		  LDO5 is special. It can choose vsel settings to be configured
		  from 2 different registers (by GPIO).
		 
		  This driver supports only configuration where
		  BD71828_REG_LDO5_VOLT_L is used.
			
			  LDO6 only supports enabledisable for all states.
			  Voltage for LDO6 is fixed.
 SNVS LDO in data-sheet 
			
			  LDO7 only supports single voltage for all states.
			  voltage can be individually enabled for each state
			  though => allow setting all states to support
			  enabling power rail on different states.
 SPDX-License-Identifier: GPL-2.0-only
  Regulator driver for STw4810STw4811 VMMC regulator.
  Copyright (C) 2013 ST-Ericsson SA
  Written on behalf of Linaro for ST-Ericsson
  Author: Linus Walleij <linus.walleij@linaro.org>
 FIXME: look this up 
 First disable the external VMMC if it's active 
 Register VMMC regulator 
  Texas Instruments SoC Adaptive Body Bias(ABB) Regulator
  Copyright (C) 2011 Texas Instruments, Inc.
  Mike Turquette <mturquette@ti.com>
  Copyright (C) 2012-2013 Texas Instruments, Inc.
  Andrii Tseglytskyi <andrii.tseglytskyi@ti.com>
  Nishanth Menon <nm@ti.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  ABB LDO operating states:
  NOMINAL_OPP:	bypasses the ABB LDO
  FAST_OPP:	sets ABB LDO to Forward Body-Bias
  SLOW_OPP:	sets ABB LDO to Reverse Body-Bias
  struct ti_abb_info - ABB information per voltage setting
  @opp_sel:	one of TI_ABB macro
  @vset:	(optional) vset value that LDOVBB needs to be overriden with.
  Array of per voltage entries organized in the same order as regulator_desc's
  volt_table list. (selector is used to index from this array)
  struct ti_abb_reg - Register description for ABB block
  @setup_off:			setup register offset from base
  @control_off:		control register offset from base
  @sr2_wtcnt_value_mask:	setup register- sr2_wtcnt_value mask
  @fbb_sel_mask:		setup register- FBB sel mask
  @rbb_sel_mask:		setup register- RBB sel mask
  @sr2_en_mask:		setup register- enable mask
  @opp_change_mask:		control register - mask to trigger LDOVBB change
  @opp_sel_mask:		control register - mask for mode to operate
 Setup register fields 
 Control register fields 
  struct ti_abb - ABB instance data
  @rdesc:			regulator descriptor
  @clk:			clock(usually sysclk) supplying ABB block
  @base:			base address of ABB block
  @setup_reg:			setup register of ABB block
  @control_reg:		control register of ABB block
  @int_base:			interrupt register base address
  @efuse_base:			(optional) efuse base address for ABB modes
  @ldo_base:			(optional) LDOVBB vset override base address
  @regs:			pointer to struct ti_abb_reg for ABB block
  @txdone_mask:		mask on int_base for tranxdone interrupt
  @ldovbb_override_mask:	mask to ldo_base for overriding default LDO VBB
 				vset with value from efuse
  @ldovbb_vset_mask:		mask to ldo_base for providing the VSET override
  @info:			array to per voltage ABB configuration
  @current_info_idx:		current index to info
  @settling_time:		SoC specific settling time for LDO VBB
  ti_abb_rmw() - handy wrapper to set specific register bits
  @mask:	mask for register field
  @value:	value shifted to mask location and written
  @reg:	register address
  Return: final register value (may be unused)
  ti_abb_check_txdone() - handy wrapper to check ABB tranxdone status
  @abb:	pointer to the abb instance
  Return: true or false
  ti_abb_clear_txdone() - handy wrapper to clear ABB tranxdone status
  @abb:	pointer to the abb instance
  ti_abb_wait_tranx() - waits for ABB tranxdone event
  @dev:	device
  @abb:	pointer to the abb instance
  Return: 0 on success or -ETIMEDOUT if the event is not cleared on time.
  ti_abb_clear_all_txdone() - clears ABB tranxdone event
  @dev:	device
  @abb:	pointer to the abb instance
  Return: 0 on success or -ETIMEDOUT if the event is not cleared on time.
  ti_abb_program_ldovbb() - program LDOVBB register for override value
  @dev:	device
  @abb:	pointer to the abb instance
  @info:	ABB info to program
 clear up previous values 
  ti_abb_set_opp() - Setup ABB and LDO VBB for required bias
  @rdev:	regulator device
  @abb:	pointer to the abb instance
  @info:	ABB info to program
  Return: 0 on success or appropriate error value when fails
 program next state of ABB ldo 
	
	  program LDO VBB vset override if needed for !bypass mode
	  XXX: Do not switch sequence - for !bypass, LDO override reset must
	  be performed before switch to bias mode else VBB glitches.
 Initiate ABB ldo change 
 Wait for ABB LDO to complete transition to new Bias setting 
	
	  Reset LDO VBB vset override bypass mode
	  XXX: Do not switch sequence - for bypass, LDO override reset must
	  be performed after switch to bypass else VBB glitches.
  ti_abb_set_voltage_sel() - regulator accessor function to set ABB LDO
  @rdev:	regulator device
  @sel:	selector to index into required ABB LDO settings (maps to
 		regulator descriptor's volt_table)
  Return: 0 on success or appropriate error value when fails
 If we are in the same index as we were, nothing to do here! 
	
	  When Linux kernel is starting up, we are'nt sure of the
	  Bias configuration that bootloader has configured.
	  So, we get to know the actual setting the first time
	  we are asked to transition.
 If data is exactly the same, then just update index, no change 
  ti_abb_get_voltage_sel() - Regulator accessor to get current ABB LDO setting
  @rdev:	regulator device
  Return: 0 on success or appropriate error value when fails
  ti_abb_init_timings() - setup ABB clock timing for the current platform
  @dev:	device
  @abb:	pointer to the abb instance
  Return: 0 if timing is updated, else returns error result.
 read device tree properties 
 ABB LDO cannot be settle in 0 time 
 ABB LDO cannot be settle in 0 clock cycles 
	
	  SR2_WTCNT_VALUE is the settling time for the ABB ldo after a
	  transition and must be programmed with the correct time at boot.
	  The value programmed into the register is the number of SYS_CLK
	  clock cycles that match a given wall time profiled for the ldo.
	  This value depends on:
	  settling time of ldo in micro-seconds (varies per OMAP family)
	  # of clock cycles per SYS_CLK period (varies per OMAP family)
	  the SYS_CLK frequency in MHz (varies per board)
	  The formula is:
	 
	                       ldo settling time (in micro-seconds)
	  SR2_WTCNT_VALUE = ------------------------------------------
	                    (# system clock cycles)  (sys_clk period)
	 
	  Put another way:
	 
	  SR2_WTCNT_VALUE = settling time  (# SYS_CLK cycles  SYS_CLK rate))
	 
	  To avoid dividing by zero multiply both "# clock cycles" and
	  "settling time" by 10 such that the final result is the one we want.
 Convert SYS_CLK rate to MHz & prevent divide by zero 
 Calculate cycle rate 
 Calulate SR2_WTCNT_VALUE 
  ti_abb_init_table() - Initialize ABB table from device tree
  @dev:	device
  @abb:	pointer to the abb instance
  @rinit_data:	regulator initdata
  Return: 0 on success or appropriate error value when fails
	
	  Each abb_info is a set of n-tuple, where n is num_values, consisting
	  of voltage and a set of detection logic for ABB information for that
	  voltage to apply.
 We do not know where the OPP voltage is at the moment 
 NOTE: num_values should equal to entries picked up here 
 Find minmax for voltage set 
 Ignore invalid data, but warn to help cleanup 
 Use ABB recommendation from Efuse 
 Use recommended Vset bits from Efuse 
 Valid values 
 Setup the minmax voltage constraints from the supported list 
 Default ABB block offsets, IF this changes in future, create new one 
 WARNING: registers are wrongly documented in TRM 
  ti_abb_probe() - Initialize an ABB ldo instance
  @pdev: ABB platform device
  Initializes an individual ABB LDO for required Body-Bias. ABB is used to
  addional bias supply to SoC modules for power savings or mandatory stability
  configuration at certain Operating Performance Points(OPPs).
  Return: 0 on success or appropriate error value when fails
 We do not expect this to happen 
 Map ABB resources 
 Map Optional resources 
	
	  We may have shared efuse register offsets which are read-only
	  between domains
 IF ldo_base is set, the following are mandatory 
 init ABB opp_sel table 
 init ABB timing 
 Enable the ldo if not already done by bootloader 
 SPDX-License-Identifier: GPL-2.0-or-later
  twl-regulator.c -- support regulators in twl4030twl6030 family chips
  Copyright (C) 2008 David Brownell
  The TWL4030TW5030TPS659x0 family chips include power management, a
  USB OTG transceiver, an RTC, ADC, PWM, and lots more.  Some versions
  include an audio codec, battery charger, and more voltage regulators.
  These chips are often used in OMAP-based systems.
  This driver implements software-based resource control for various
  voltage regulators.  This is usually augmented with state machine
  based control.
 start of regulator's PM_RECEIVER control register bank 
 twl resource ID, for resource control state machine 
 voltage in mV = table[VSEL]; table_len must be a power-of-two 
 State REMAP default configuration 
 used by regulator core 
 chip specific features 
 data passed from board for external getset voltage 
 LDO control registers ... offset is from the base of its register bank.
  The first three registers of all power resource banks help hardware to
  manage the various resource groups.
 Common offset in TWL40306030 
 TWL4030 register offsets 
 LDO control 
 TWL6030 register offsets 
----------------------------------------------------------------------
 generic power resource operations, which work on all regulators 
  Enabledisable regulators by joiningleaving the P1 (processor) group.
  We assume nobody else is updating the DEV_GRP registers.
 definition for 4030 family 
 "peripherals" 
 secondary processor, modem, etc 
 CPULinux 
 definition for 6030 family 
 secondary processor, modem, etc 
 "peripherals" 
 CPULinux 
 Wait until buffer emptyready to send a word on power bus. 
 Send a word over the powerbus 
 save powerbus configuration 
 Enable i2c access to powerbus 
 Restore powerbus configuration 
 assume state != WARM_RESET; we'd not be running...  
 We can only set the mode through state machine commands... 
----------------------------------------------------------------------
  Support for adjustable-voltage LDOs uses a four bit (or less) voltage
  select field in its control register.   We use tables indexed by VSEL
  to record voltages in milliVolts.  (Accuracy is about three percent.)
  Note that VSEL values for VAUX2 changed in twl5030 and newer silicon;
  currently handled by listing two slightly different VAUX2 regulators,
  only one of which will be configured.
  VSEL values documented as "TI cannot support these values" are flagged
  in these tables as UNSUP() values; we normally won't assign them.
  VAUX3 at 3V is incorrectly listed in some TI manuals as unsupported.
  TI are revising the twl5030tps659x0 specs to support that 3.0V setting.
 600mV to 1450mV in 12.5 mV steps 
 600mV to 1450mV in 12.5 mV steps, everything above = 1500mV 
----------------------------------------------------------------------
----------------------------------------------------------------------
  We list regulators here if systems need some level of
  software control over them after boot.
 VUSBCP is managed only by the USB subchip 
	 Constrain board-specific capabilities according to what
	  this driver and the chip itself can actually do.
	 NOTE:  many regulators support short-circuit IRQs (presentable
	  as REGULATOR_OVER_CURRENT notifications?) configured via:
	   - SC_CONFIG
	   - SC_DETECT1 (vintana2, vmmc12, vaux1234)
	   - SC_DETECT2 (vusb, vdac, vio, vdd12, vpll2)
	   - IT_CONFIG
	 NOTE: short name, to work around driver model truncation of
	  "twl_regulator.12" (and friends) to "twl_regulator.1".
 SPDX-License-Identifier: GPL-2.0
 Regulator Driver for Freescale MC13xxx PMIC
 Copyright 2010 Yong Shen <yong.shen@linaro.org>
 Based on mc13783 regulator driver :
 Copyright (C) 2008 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
 Copyright 2009 Alberto Panizzo <maramaopercheseimorto@gmail.com>
 Regs infos taken from mc13xxx drivers from freescale and mc13xxx.pdf file
 from freescale
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0+
 bootloader will on, driver only reconfigure enable to all output high 
 initialize volt_sel variable 
 SPDX-License-Identifier: GPL-2.0+
 max77686.c - Regulator driver for the Maxim 77686
 Copyright (C) 2012 Samsung Electronics
 Chiwoong Byun <woong.byun@samsung.com>
 Jonghwa Lee <jonghwa3.lee@samsung.com>
 This driver is based on max8997.c
 us 
 us 
 uVus 
 uVus 
  Value for configuring buck[89] and LDO{20,21,22} as GPIO control.
  It is the same as 'off' for other regulators.
  Values used for configuring LDOs and bucks.
  Forcing low power mode: LDO1, 3-5, 9, 13, 17-26
  Onoff controlled by PWRREQ:
   - LDO2, 6-8, 10-12, 14-16
   - buck[1234]
 Low power mode controlled by PWRREQ: All LDOs 
 Forcing low power mode: buck[234] 
 Array indexed by regulator id 
 all LDOs 
  When regulator is configured for GPIO control then it
  replaces "normal" mode. Any change from low power mode to normal
  should actually change to GPIO control.
  Map normal mode to proper value for such regulators.
 Some BUCKs and LDOs supports Normal[ONOFF] mode during suspend 
 Some LDOs supports [LPMNormal]ON mode during suspend state 
 BUCK[5-9] doesn't support this feature 
 ON in LP Mode 
 ON in Normal Mode 
 Some LDOs supports LPM-ONOFFNormal-ON mode during suspend state 
 switch off 
 ON in LP Mode 
 ON in Normal Mode 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2017 MediaTek Inc.
 Author: Chenglin Xu <chenglin.xu@mediatek.com>
 PMIC Registers 
  mt6380 regulators' information
  @desc: standard fields of regulator description
  @vselon_reg: Register sections for hardware control mode of bucks
  @modeset_reg: Register for controlling the buckLDO control mode
  @modeset_mask: Mask for controlling the buckLDO control mode
 The array is indexed by id(MT6380_ID_XXX) 
 sentinel  },
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
  Regulator driver for National Semiconductors LP3972 PMIC chip
  Based on lp3971.c
 LP3972 Control Registers 
 System control register 1 initial value,
 LDO output enable mask 
	LDO voltage control registers shift:
	LP3972_LDO1 -> 0, LP3972_LDO2 -> 4
	LP3972_LDO3 -> 0, LP3972_LDO4 -> 4
	LP3972_LDO5 -> 0
	
	  LDO1 and LDO5 support voltage control by either target voltage1
	  or target voltage2 register.
	  We use target voltage1 register for LDO1 and LDO5 in this driver.
	  We need to update voltage change control register(0x20) to enable
	  LDO1 and LDO5 to change to their programmed target values.
 Instantiate the regulators 
 Detect LP3972 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015, Sony Mobile Communications AB.
  Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
 "swen" 
 "uv" 
 "ma" 
 l4 is unaccessible on PM660 
 SPDX-License-Identifier: GPL-2.0-only
  Regulator driver for Ricoh RN5T618 PMIC
  Copyright (C) 2014 Beniamino Galvani <b.galvani@gmail.com>
 DCDC 
 LDO 
 LDO RTC 
 DCDC 
 LDO 
 LDO RTC 
 DCDC 
 LDO 
 LDO RTC 
 SPDX-License-Identifier: GPL-2.0-only
  Regulators driver for Maxim max8925
  Copyright (C) 2009 Marvell International Ltd.
       Haojian Zhuang <haojian.zhuang@marvell.com>
 SDCTL1 bit5 
 SDV1 bit 6 
 bit definitions in LDO control registers 
 Power UD by i2c 
 Power UD sequence mask 
 Power UD sequence offset 
 Enable by i2c 
 Enable mask by i2c 
 Enable offset by i2c 
 SPDX-License-Identifier: GPL-2.0-or-later
 max77826-regulator.c  - regulator driver for Maxim MAX77826
 Author: Iskren Chernev <iskren.chernev@gmail.com>
 0x0E - 0x0F: Reserved 
 0x15 - 0x1F: Reserved 
 0x2F: Reserved 
 0x34 - 0x3F: Reserved 
 0x42 - 0xCE: Reserved 
 values in mV 
 for LDO1-3 
 for LDO4-15 
 for BUCK 
 for BUCKBOOST 
 sentinel  }
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
 Regulators driver for Dialog Semiconductor DA903x
 Copyright (C) 2006-2008 Marvell International Ltd.
 Copyright (C) 2008 Compulab Ltd.
 DA9030 Registers 
 DA9034 Registers 
 DA9035 Registers. DA9034 Registers are comptabile to DA9035. 
 DA9030DA9034 common operations 
 DA9030 specific operations 
 have to set UNLOCK bits 
 write twice 
 DA9034 specific operations 
 NOTE: this is dedicated for the insane DA9030 LDO14 
 NOTE: this is dedicated for the DA9030 LDO1 and LDO15 that have locks  
 NOTE: this is dedicated for the insane LDO12 
 DA9030 
 fixed @2.1V 
 DA9034 
 fixed @3.1V 
 DA9035 
 Workaround for the weird LDO12 voltage setting 
  Regulator driver for TPS6524x PMIC
  Copyright (C) 2010 Texas Instruments
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any kind,
  whether express or implied; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.
 0 = 400-800, 1 = 900-1500 
 SPDX-License-Identifier: GPL-2.0+
 Wait for I2C can be accessed 
 HW re-enable, disable cache only and sync regcache here 
 Mark the regcache as dirty and cache only before HW disabled 
 Ensure the selected setting is still in range 
 If significant bit is over 8, two byte access, others one 
 Before regmap register, configure HW enable to make I2C accessible 
 Wait for I2C can be accessed 
	
	  keep in shutdown mode to minimize the current consumption
	  and also mark regcache as dirty
 Unmask all events before IRQ registered 
	
	  When system suspend, disable irq to prevent interrupt trigger
	  during I2C bus suspend
 Enable irq after I2C bus already resume 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2014 MediaTek Inc.
 Author: Flora Fu <flora.fu@mediatek.com>
  MT6397 regulators' information
  @desc: standard fields of regulator description.
  @qi: Mask for query enable signal status of regulators
  @vselon_reg: Register sections for hardware control mode of bucks
  @vselctrl_reg: Register for controlling the buck control mode.
  @vselctrl_mask: Mask for query buck's voltage control mode.
 The array is indexed by id(MT6397_ID_XXX) 
 Query buck controller to select activated voltage register part 
 Read PMIC chip revision to update constraints and voltage table 
 sentinel  },
 sentinel  },
 SPDX-License-Identifier: GPL-2.0
 Regulator Driver for Freescale MC13783 PMIC
 Copyright 2010 Yong Shen <yong.shen@linaro.org>
 Copyright (C) 2008 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
 Copyright 2009 Alberto Panizzo <maramaopercheseimorto@gmail.com>
 Enable does not exist for SW1A 
 Enable does not exist for SW1B 
 Enable does not exist for SW2A 
 Enable does not exist for SW2B 
 Voltage Values 
 Update the stored state for Power Gates. 
 Construct the new register value 
 Overwrite the PWGTxEN with the stored version 
 Power Gate enable value is 0 
 Power Gate disable value is 1 
	 Power Gates state is stored in powermisc_pwgt_state
 SPDX-License-Identifier: GPL-2.0+
 wm8994-regulator.c  --  Regulator driver for the WM8994
 Copyright 2009 Wolfson Microelectronics PLC.
 Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
	
	  Look up LDO enable GPIO from the parent device node, we don't
	  use devm because the regulator core will free the GPIO
 Use default constraints if none set up 
	
	  At this point the GPIO descriptor is handled over to the
	  regulator core and we need not worry about it on the
	  error path.
 Module information 
 SPDX-License-Identifier: GPL-2.0-or-later
  act8865-regulator.c - Voltage regulation for active-semi ACT88xx PMUs
  http:www.active-semi.comproductspower-management-unitsact88xx
  Copyright (C) 2013 Atmel Corporation
  ACT8600 Global Register Map.
  ACT8846 Global Register Map.
  ACT8865 Global Register Map.
  Field Definitions.
 ON - [7] 
 DIS - [6] 
 VSET - [5:0] 
 ON - [6] 
 SUDCDC VSET - [7:0] 
  ACT8865 voltage number
	
	  Ask the PMIC to enabledisable this output when entering hibernate
	  mode.
 Finally register devices 
 Unlock expert registers for ACT8865. 
 SPDX-License-Identifier: GPL-2.0-or-later
  devres.c  --  VoltageCurrent Regulator framework devres implementation.
  Copyright 2013 Linaro Ltd
  devm_regulator_get - Resource managed regulator_get()
  @dev: device to supply
  @id:  supply name or regulator ID.
  Managed regulator_get(). Regulators returned from this function are
  automatically regulator_put() on driver detach. See regulator_get() for more
  information.
  devm_regulator_get_exclusive - Resource managed regulator_get_exclusive()
  @dev: device to supply
  @id:  supply name or regulator ID.
  Managed regulator_get_exclusive(). Regulators returned from this function
  are automatically regulator_put() on driver detach. See regulator_get() for
  more information.
  devm_regulator_get_optional - Resource managed regulator_get_optional()
  @dev: device to supply
  @id:  supply name or regulator ID.
  Managed regulator_get_optional(). Regulators returned from this
  function are automatically regulator_put() on driver detach. See
  regulator_get_optional() for more information.
  devm_regulator_put - Resource managed regulator_put()
  @regulator: regulator to free
  Deallocate a regulator allocated with devm_regulator_get(). Normally
  this function will not need to be called and the resource management
  code will ensure that the resource is freed.
  devm_regulator_bulk_get - managed get multiple regulator consumers
  @dev:           device to supply
  @num_consumers: number of consumers to register
  @consumers:     configuration of consumers; clients are stored here.
  @return 0 on success, an errno on failure.
  This helper function allows drivers to get several regulator
  consumers in one operation with management, the regulators will
  automatically be freed when the device is unbound.  If any of the
  regulators cannot be acquired then any regulators that were
  allocated will be freed before returning to the caller.
  devm_regulator_register - Resource managed regulator_register()
  @dev:            device to supply
  @regulator_desc: regulator to register
  @config:         runtime configuration for regulator
  Called by regulator drivers to register a regulator.  Returns a
  valid pointer to struct regulator_dev on success or an ERR_PTR() on
  error.  The regulator will automatically be released when the device
  is unbound.
  devm_regulator_register_supply_alias - Resource managed
  regulator_register_supply_alias()
  @dev:       device to supply
  @id:        supply name or regulator ID
  @alias_dev: device that should be used to lookup the supply
  @alias_id:  supply name or regulator ID that should be used to lookup the
  supply
  The supply alias will automatically be unregistered when the source
  device is unbound.
  devm_regulator_bulk_register_supply_alias - Managed register
  multiple aliases
  @dev:       device to supply
  @id:        list of supply names or regulator IDs
  @alias_dev: device that should be used to lookup the supply
  @alias_id:  list of supply names or regulator IDs that should be used to
              lookup the supply
  @num_id:    number of aliases to register
  @return 0 on success, an errno on failure.
  This helper function allows drivers to register several supply
  aliases in one operation, the aliases will be automatically
  unregisters when the source device is unbound.  If any of the
  aliases cannot be registered any aliases that were registered
  will be removed before returning to the caller.
  devm_regulator_register_notifier - Resource managed
  regulator_register_notifier
  @regulator: regulator source
  @nb:        notifier block
  The notifier will be registers under the consumer device and be
  automatically be unregistered when the source device is unbound.
  devm_regulator_unregister_notifier - Resource managed
  regulator_unregister_notifier()
  @regulator: regulator source
  @nb:        notifier block
  Unregister a notifier registered with devm_regulator_register_notifier().
  Normally this function will not need to be called and the resource
  management code will ensure that the resource is freed.
  devm_regulator_irq_helper - resource managed registration of IRQ based
  regulator eventerror notifier
  @dev:		device to which lifetime the helper's lifetime is
 			bound.
  @d:			IRQ helper descriptor.
  @irq:		IRQ used to inform eventserrors to be notified.
  @irq_flags:		Extra IRQ flags to be OR'ed with the default
 			IRQF_ONESHOT when requesting the (threaded) irq.
  @common_errs:	Errors which can be flagged by this IRQ for all rdevs.
 			When IRQ is re-enabled these errors will be cleared
 			from all associated regulators
  @per_rdev_errs:	Optional error flag array describing errors specific
 			for only some of the regulators. These errors will be
 			or'ed with common errors. If this is given the array
 			should contain rdev_amount flags. Can be set to NULL
 			if there is no regulator specific error flags for this
 			IRQ.
  @rdev:		Array of pointers to regulators associated with this
 			IRQ.
  @rdev_amount:	Amount of regulators associated with this IRQ.
  Return: handle to irq_helper or an ERR_PTR() encoded error code.
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2017 NXP
  Copyright (C) 2019 Boundary Devices
  Copyright (C) 2020 Amarula Solutions(India)
 registers 
 regulators 
 VLDOx output: 1.5V to 5.0V 
 Output: 2.1A to 4.5A 
 Output: 0.4V to 1.8V 
 Output: 1.0V to 4.1V 
 Output: 1.8V, 3.0V, or 3.3V 
  tps65218-regulator.c
  Regulator driver for TPS65218 PMIC
  Copyright (C) 2014 Texas Instruments Incorporated - https:www.ti.com
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether expressed or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License version 2 for more details.
 Set the voltage based on vsel value and write protect level is 2 
 Set GO bit for DCDC12 to initiate voltage transistion 
 Enable the regulator and password protection is level 1 
 Disable the regulator and password protection is level 1 
	
	  Certain revisions of TPS65218 will need to have DCDC3 regulator
	  enabled always, otherwise an immediate system reboot will occur
	  during poweroff.
 Operations permitted on DCDC1, DCDC2 
 Operations permitted on DCDC3, DCDC4 and LDO1 
 Operations permitted on DCDC5, DCDC6 
 Allocate memory for strobes 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
 Mark regcache as dirty and cache only before HW disabled 
 SPDX-License-Identifier: GPL-2.0+
 pv88080-regulator.c - Regulator device driver for PV88080
 Copyright (C) 2016  Powerventure Semiconductor Ltd.
 PV88080 REGULATOR IDs 
 BUCKs 
 REGS 
 MASKS 
 BUCK1, 2, 3 
 HVBUCK 
 Current limits array (in uA) for BUCK1, BUCK2, BUCK3.
  Entry indexes corresponds to register values.
 BUCK1 
 BUCK2 
 BUCK3 
 HVBUCK 
 BUCK1 
 BUCK2 
 BUCK3 
 HVBUCK 
  I2C driver interface functions
 Registeration for BUCK1, 2, 3 
 Registeration for HVBUCK 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) STMicroelectronics 2017
  Author: Fabrice Gasnier <fabrice.gasnier@st.com>
 STM32 VREFBUF registers 
 STM32 VREFBUF CSR bitfields 
 Matches resp. VRS = 000b, 001b, 010b, 011b 
	
	  Vrefbuf startup time depends on external capacitor: wait here for
	  VRR to be set. That means output has reached expected value.
	  ~650us sleep should be enough for caps up to 1.5uF. Use 10ms as
	  arbitrary timeout.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2012 Texas Instruments
  Author: Milo(Woogyom) Kim <milo.kim@ti.com>
 Registers : LP87208725 shared 
 Registers : LP8720 
 Registers : LP8725 
 Maskshift : LP8720LP8725 shared 
 Maskshift : LP8720 
 Addr 00h 
 Addr 07h 
 Addr 08h 
 Maskshift : LP8725 
 Addr 00h 
 Addr 09h, 0Bh 
 Addr 0Ch 
 Addr 0Dh 
 PWM mode 
 Default DVS Mode 
 dump registers in regmap-debugfs 
 LP8720LP8725 shared voltage table for LDOs 
 LP8720 LDO4 voltage table 
 LP8725 LILO(Low Input Low Output) voltage table 
 LP8720 BUCK voltage table 
 external resistor divider 
 LP8725 BUCK voltage table 
 LP8725 BUCK current limit 
 Always set enable GPIO high. 
 Each chip has a different enable delay. 
  Copyright (C) 2015 Texas Instruments Incorporated - https:www.ti.com
  Author: Andrew F. Davis <afd@ti.com>
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether expressed or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License version 2 for more details.
  Based on the TPS65912 driver
 Operations permitted on regulators 
 Operations permitted on load switches 
 Check for 25mV step mode 
 Check for decay mode 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020 Marek Vasut <marex@denx.de>
  Based on rpi_touchscreen.c by Eric Anholt <eric@anholt.net>
 I2C registers of the Atmel microcontroller. 
 Wait for nPWRDWN to go low to indicate poweron is done. 
	 Default to the same orientation as the closed source
	  firmware used for the panel.  Runtime rotation
	  configuration will be supported using VC4's plane
	  orientation bits.
  I2C driver interface functions
 ver 1 
 ver 2 
 SPDX-License-Identifier: GPL-2.0
 SY8824CSY8824E regulator driver
 Copyright (C) 2019 Synaptics Incorporated
 Author: Jisheng Zhang <jszhang@kernel.org>
 registers 
 Voltage range and step(linear) 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 MediaTek Inc.
  MT6359 regulators' information
  @desc: standard fields of regulator description.
  @status_reg: for query status of regulators.
  @qi: Mask for query enable signal status of regulators.
  @modeset_reg: for operating AUTOPWM mode register.
  @modeset_mask: MASK for operating modeset register.
 If HW trapping is 0, use VEMC_VOSEL_0 
 If HW trapping is 1, use VEMC_VOSEL_1 
 If HW trapping is 0, use VEMC_VOSEL_0 
 If HW trapping is 1, use VEMC_VOSEL_1 
 The array is indexed by id(MT6359_ID_XXX) 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) ST-Ericsson SA 2010
  Authors: Sundar Iyer <sundar.iyer@stericsson.com> for ST-Ericsson
           Bengt Jonsson <bengt.g.jonsson@stericsson.com> for ST-Ericsson
           Daniel Willerud <daniel.willerud@stericsson.com> for ST-Ericsson
  AB8500 peripheral regulators
  AB8500 supports the following regulators:
    VAUX123, VINTCORE, VTVOUT, VUSB, VAUDIO, VAMIC12, VDMIC, VANA
  AB8505 supports the following regulators:
    VAUX123456, VINTCORE, VADC, VUSB, VAUDIO, VAMIC12, VDMIC, VANA
 AB8500 regulators 
 AB8505 regulators 
 AB8500 registers 
 AB8505 registers 
 NOTE! PRCMU register 
 NOTE! PRCMU register 
 NOTE! PRCMU register 
 NOTE! PRCMU register 
  struct ab8500_shared_mode - is used when mode is shared between
  two regulators.
  @shared_regulator: pointer to the other sharing regulator
  @lp_mode_req: low power mode requested by this regulator
  struct ab8500_regulator_info - ab8500 regulator information
  @dev: device pointer
  @desc: regulator description
  @shared_mode: used when mode is shared between two regulators
  @load_lp_uA: maximum load in idle (low power) mode
  @update_bank: bank to control onoff
  @update_reg: register to control onoff
  @update_mask: mask to enabledisable and set mode of regulator
  @update_val: bits holding the regulator current mode
  @update_val_idle: bits to enable the regulator in idle (low power) mode
  @update_val_normal: bits to enable the regulator in normal (high power) mode
  @mode_bank: bank with location of mode register
  @mode_reg: mode register
  @mode_mask: mask for setting mode
  @mode_val_idle: mode setting for low power
  @mode_val_normal: mode setting for normal power
  @voltage_bank: bank to control regulator voltage
  @voltage_reg: register to control regulator voltage
  @voltage_mask: mask to control regulator voltage
  @expand_register: 
 voltage tables for the vauxnvintcore supplies 
 Duplicated in Vaudio and IsoUicc Control register. 
 Other regulator prevent LP mode 
 Need special handling for shared mode 
 Dedicated register for handling mode 
 Mode register same as enable register 
 set the registers for the request 
 AB8500 regulator information 
	
	  Variable Voltage Regulators
	    name, min mV, max mV,
	    update bank, reg, mask, enable val
	    volt bank, reg, mask
	
	  Fixed Voltage Regulators
	    name, fixed mV,
	    update bank, reg, mask, enable val
	
	  Regulators with fixed voltage and normalidle modes
 AB8505 regulator information 
	
	  Variable Voltage Regulators
	    name, min mV, max mV,
	    update bank, reg, mask, enable val
	    volt bank, reg, mask
 values for Vaux4Regu register 
 values for Vaux4SEL register 
 values for CtrlVaux5 register 
 values for CtrlVaux6 register 
	
	  Fixed Voltage Regulators
	    name, fixed mV,
	    update bank, reg, mask, enable val
	
	  Regulators with fixed voltage and normalidle modes
 AB8500 register init 
	
	  0x30, VanaRequestCtrl
	  0xc0, VextSupply1RequestCtrl
	
	  0x03, VextSupply2RequestCtrl
	  0x0c, VextSupply3RequestCtrl
	  0x30, Vaux1RequestCtrl
	  0xc0, Vaux2RequestCtrl
	
	  0x03, Vaux3RequestCtrl
	  0x04, SwHPReq
	
	  0x08, VanaSysClkReq1HPValid
	  0x20, Vaux1SysClkReq1HPValid
	  0x40, Vaux2SysClkReq1HPValid
	  0x80, Vaux3SysClkReq1HPValid
	
	  0x10, VextSupply1SysClkReq1HPValid
	  0x20, VextSupply2SysClkReq1HPValid
	  0x40, VextSupply3SysClkReq1HPValid
	
	  0x08, VanaHwHPReq1Valid
	  0x20, Vaux1HwHPReq1Valid
	  0x40, Vaux2HwHPReq1Valid
	  0x80, Vaux3HwHPReq1Valid
	
	  0x01, VextSupply1HwHPReq1Valid
	  0x02, VextSupply2HwHPReq1Valid
	  0x04, VextSupply3HwHPReq1Valid
	
	  0x08, VanaHwHPReq2Valid
	  0x20, Vaux1HwHPReq2Valid
	  0x40, Vaux2HwHPReq2Valid
	  0x80, Vaux3HwHPReq2Valid
	
	  0x01, VextSupply1HwHPReq2Valid
	  0x02, VextSupply2HwHPReq2Valid
	  0x04, VextSupply3HwHPReq2Valid
	
	  0x20, VanaSwHPReqValid
	  0x80, Vaux1SwHPReqValid
	
	  0x01, Vaux2SwHPReqValid
	  0x02, Vaux3SwHPReqValid
	  0x04, VextSupply1SwHPReqValid
	  0x08, VextSupply2SwHPReqValid
	  0x10, VextSupply3SwHPReqValid
	
	  0x02, SysClkReq2Valid1
	  0x04, SysClkReq3Valid1
	  0x08, SysClkReq4Valid1
	  0x10, SysClkReq5Valid1
	  0x20, SysClkReq6Valid1
	  0x40, SysClkReq7Valid1
	  0x80, SysClkReq8Valid1
	
	  0x02, SysClkReq2Valid2
	  0x04, SysClkReq3Valid2
	  0x08, SysClkReq4Valid2
	  0x10, SysClkReq5Valid2
	  0x20, SysClkReq6Valid2
	  0x40, SysClkReq7Valid2
	  0x80, SysClkReq8Valid2
	
	  0x02, VTVoutEna
	  0x04, Vintcore12Ena
	  0x38, Vintcore12Sel
	  0x40, Vintcore12LP
	  0x80, VTVoutLP
	
	  0x02, VaudioEna
	  0x04, VdmicEna
	  0x08, Vamic1Ena
	  0x10, Vamic2Ena
	
	  0x01, Vamic1_dzout
	  0x02, Vamic2_dzout
	
	  0x03, VpllRegu (NOTE! PRCMU register bits)
	  0x0c, VanaRegu
	
	  0x01, VrefDDREna
	  0x02, VrefDDRSleepMode
	
	  0x03, VextSupply1Regu
	  0x0c, VextSupply2Regu
	  0x30, VextSupply3Regu
	  0x40, ExtSupply2Bypass
	  0x80, ExtSupply3Bypass
	
	  0x03, Vaux1Regu
	  0x0c, Vaux2Regu
	
	  0x03, Vaux3Regu
	
	  0x0f, Vaux1Sel
	
	  0x0f, Vaux2Sel
	
	  0x07, Vaux3Sel
	
	  0x01, VextSupply12LP
	
	  0x04, Vaux1Disch
	  0x08, Vaux2Disch
	  0x10, Vaux3Disch
	  0x20, Vintcore12Disch
	  0x40, VTVoutDisch
	  0x80, VaudioDisch
	
	  0x02, VanaDisch
	  0x04, VdmicPullDownEna
	  0x10, VdmicDisch
 AB8505 register init 
	
	  0x03, VarmRequestCtrl
	  0x0c, VsmpsCRequestCtrl
	  0x30, VsmpsARequestCtrl
	  0xc0, VsmpsBRequestCtrl
	
	  0x03, VsafeRequestCtrl
	  0x0c, VpllRequestCtrl
	  0x30, VanaRequestCtrl
	
	  0x30, Vaux1RequestCtrl
	  0xc0, Vaux2RequestCtrl
	
	  0x03, Vaux3RequestCtrl
	  0x04, SwHPReq
	
	  0x01, VsmpsASysClkReq1HPValid
	  0x02, VsmpsBSysClkReq1HPValid
	  0x04, VsafeSysClkReq1HPValid
	  0x08, VanaSysClkReq1HPValid
	  0x10, VpllSysClkReq1HPValid
	  0x20, Vaux1SysClkReq1HPValid
	  0x40, Vaux2SysClkReq1HPValid
	  0x80, Vaux3SysClkReq1HPValid
	
	  0x01, VsmpsCSysClkReq1HPValid
	  0x02, VarmSysClkReq1HPValid
	  0x04, VbbSysClkReq1HPValid
	  0x08, VsmpsMSysClkReq1HPValid
	
	  0x01, VsmpsAHwHPReq1Valid
	  0x02, VsmpsBHwHPReq1Valid
	  0x04, VsafeHwHPReq1Valid
	  0x08, VanaHwHPReq1Valid
	  0x10, VpllHwHPReq1Valid
	  0x20, Vaux1HwHPReq1Valid
	  0x40, Vaux2HwHPReq1Valid
	  0x80, Vaux3HwHPReq1Valid
	
	  0x08, VsmpsMHwHPReq1Valid
	
	  0x01, VsmpsAHwHPReq2Valid
	  0x02, VsmpsBHwHPReq2Valid
	  0x04, VsafeHwHPReq2Valid
	  0x08, VanaHwHPReq2Valid
	  0x10, VpllHwHPReq2Valid
	  0x20, Vaux1HwHPReq2Valid
	  0x40, Vaux2HwHPReq2Valid
	  0x80, Vaux3HwHPReq2Valid
	
	  0x08, VsmpsMHwHPReq2Valid
	
	  0x01, VsmpsCSwHPReqValid
	  0x02, VarmSwHPReqValid
	  0x04, VsmpsASwHPReqValid
	  0x08, VsmpsBSwHPReqValid
	  0x10, VsafeSwHPReqValid
	  0x20, VanaSwHPReqValid
	  0x40, VpllSwHPReqValid
	  0x80, Vaux1SwHPReqValid
	
	  0x01, Vaux2SwHPReqValid
	  0x02, Vaux3SwHPReqValid
	  0x20, VsmpsMSwHPReqValid
	
	  0x02, SysClkReq2Valid1
	  0x04, SysClkReq3Valid1
	  0x08, SysClkReq4Valid1
	
	  0x02, SysClkReq2Valid2
	  0x04, SysClkReq3Valid2
	  0x08, SysClkReq4Valid2
	
	  0x01, Vaux4SwHPReqValid
	  0x02, Vaux4HwHPReq2Valid
	  0x04, Vaux4HwHPReq1Valid
	  0x08, Vaux4SysClkReq1HPValid
	
	  0x02, VadcEna
	  0x04, VintCore12Ena
	  0x38, VintCore12Sel
	  0x40, VintCore12LP
	  0x80, VadcLP
	
	  0x02, VaudioEna
	  0x04, VdmicEna
	  0x08, Vamic1Ena
	  0x10, Vamic2Ena
	
	  0x01, Vamic1_dzout
	  0x02, Vamic2_dzout
	
	  0x03, VsmpsARegu
	  0x0c, VsmpsASelCtrl
	  0x10, VsmpsAAutoMode
	  0x20, VsmpsAPWMMode
	
	  0x03, VsmpsBRegu
	  0x0c, VsmpsBSelCtrl
	  0x10, VsmpsBAutoMode
	  0x20, VsmpsBPWMMode
	
	  0x03, VsafeRegu
	  0x0c, VsafeSelCtrl
	  0x10, VsafeAutoMode
	  0x20, VsafePWMMode
	
	  0x03, VpllRegu (NOTE! PRCMU register bits)
	  0x0c, VanaRegu
	
	  0x03, VextSupply1Regu
	  0x0c, VextSupply2Regu
	  0x30, VextSupply3Regu
	  0x40, ExtSupply2Bypass
	  0x80, ExtSupply3Bypass
	
	  0x03, Vaux1Regu
	  0x0c, Vaux2Regu
	
	  0x0f, Vaux3Regu
	
	  0x3f, VsmpsASel1
	
	  0x3f, VsmpsASel2
	
	  0x3f, VsmpsASel3
	
	  0x3f, VsmpsBSel1
	
	  0x3f, VsmpsBSel2
	
	  0x3f, VsmpsBSel3
	
	  0x7f, VsafeSel1
	
	  0x3f, VsafeSel2
	
	  0x3f, VsafeSel3
	
	  0x0f, Vaux1Sel
	
	  0x0f, Vaux2Sel
	
	  0x07, Vaux3Sel
	  0x30, VRF1Sel
	
	  0x03, Vaux4RequestCtrl
	
	  0x03, Vaux4Regu
	
	  0x0f, Vaux4Sel
	
	  0x04, Vaux1Disch
	  0x08, Vaux2Disch
	  0x10, Vaux3Disch
	  0x20, Vintcore12Disch
	  0x40, VTVoutDisch
	  0x80, VaudioDisch
	
	  0x02, VanaDisch
	  0x04, VdmicPullDownEna
	  0x10, VdmicDisch
	
	  0x01, Vaux4Disch
	
	  0x07, Vaux5Sel
	  0x08, Vaux5LP
	  0x10, Vaux5Ena
	  0x20, Vaux5Disch
	  0x40, Vaux5DisSfst
	  0x80, Vaux5DisPulld
	
	  0x07, Vaux6Sel
	  0x08, Vaux6LP
	  0x10, Vaux6Ena
	  0x80, Vaux6DisPulld
 assign per-regulator data 
 fix for hardware before ab8500v2.0 
 register regulator with framework 
 SPDX-License-Identifier: GPL-2.0
  AS3711 PMIC regulator driver, using DCDC Step Down and LDO supplies
  Copyright (C) 2012 Renesas Electronics Corporation
  Author: Guennadi Liakhovetski, <g.liakhovetski@gmx.de>
  The regulator API supports 4 modes of operataion: FAST, NORMAL, IDLE and
  STANDBY. We map them in the following way to AS3711 SD1-4 DCDC modes:
  FAST:	sdX_fast=1
  NORMAL:	low_noise=1
  IDLE:	low_noise=0
 StepUp output voltage depends on supplying regulator 
  Regulator driver for LP873X PMIC
  Copyright (C) 2016 Texas Instruments Incorporated - https:www.ti.com
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether expressed or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License version 2 for more details.
 LP873X BUCK current limit 
 Operations permitted on BUCK0, BUCK1 
 Operations permitted on LDO0 and LDO1 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 MediaTek Inc.
  DVFSRC regulators' information
  @desc: standard fields of regulator description.
  @voltage_selector:  Selector used for get_voltage_sel() and
 			   set_voltage_sel() callbacks
  MTK DVFSRC regulators' init data
  @size: num of regulators
  @regulator_info: regulator info.
 sentinel 
 SPDX-License-Identifier: GPL-2.0
 Linear Technology LTC3589,LTC3589-1 regulator support
 Copyright (c) 2014 Philipp Zabel <p.zabel@pengutronix.de>, Pengutronix
 DTV2 register follows right after the corresponding DTV1 register 
 VCCR reference selects are right next to the VCCR go bits 
 Select DTV2 
 SW1, SW2, SW3, LDO2 
 BB_OUT, LDO3 
 LDO1 
 LDO4 
 Parse feedback voltage dividers. LDO3 and LDO4 don't have them 
 Clear warning condition 
 SPDX-License-Identifier: GPL-2.0-or-later
  kernel API
  Copyright (C) 2005-2009   Rodolfo Giometti <giometti@linux.it>
  Local functions
  Exported functions
 pps_register_source - add a PPS source in the system
  @info: the PPS info struct
  @default_params: the default PPS parameters of the new source
  This function is used to add a new PPS source in the system. The new
  source is described by info's fields and it will have, as default PPS
  parameters, the ones specified into default_params.
  The function returns, in case of success, the PPS device. Otherwise
  ERR_PTR(errno).
 Sanity checks 
 Allocate memory for the new PPS source struct 
	 These initializations must be done before calling idr_alloc()
	  in order to avoid reces into pps_event().
 check for default echo function 
 Create the char device 
 pps_unregister_source - remove a PPS source from the system
  @pps: the PPS source
  This function is used to remove a previously registered PPS source from
  the system.
	 don't have to kfree(pps) here because it will be done on
 pps_event - register a PPS event into the system
  @pps: the PPS device
  @ts: the event timestamp
  @event: the event type
  @data: userdef pointer
  This function is used by each PPS client in order to register a new
  PPS event into the system (it's usually called inside an IRQ handler).
  If an echo function is associated with the PPS device it will be called
  as:
 	pps->info.echo(pps, event, data);
 check event type 
 Must call the echo function? 
 Check the event 
 We have to add an offset? 
 Save the time stamp 
 We have to add an offset? 
 Save the time stamp 
 Wake up if captured something 
 SPDX-License-Identifier: GPL-2.0-or-later
  PPS core file
  Copyright (C) 2005-2009   Rodolfo Giometti <giometti@linux.it>
  Local variables
  Char device methods
 Manage the timeout 
 Check for pending signals 
 Get the current parameters 
 Check the capabilities 
 Check for supported capabilities 
 Save the new parameters 
 Restore the read only parameters 
 section 3.3 of RFC 2783 interpreted 
		
		  Clear unused fields of pps_kparams to avoid leaking
		  uninitialized data of the PPS_SETPARAMS caller via
		  PPS_GETPARAMS
 Return the fetched timestamp 
 Check the capabilities 
 Check for supported capabilities 
 Validate parameters roughly 
 Return the fetched timestamp 
  Char device stuff
 Now we can release the ID for re-use 
	
	  Get new ID for the new PPS source.  After idr_alloc() calling
	  the new source will be freely available into the kernel.
 Override the release function with our own 
  Look up a pps device by magic cookie.
  The cookie is usually a pointer to some enclosing device, but this
  code doesn't care; you should never be dereferencing it.
  This is a bit of a kludge that is currently used only by the PPS
  serial line discipline.  It may need to be tweaked when a second user
  is found.
  There is no function interface for setting the lookup_cookie field.
  It's initialized to NULL when the pps device is created, and if a
  client wants to use it, just fill it in afterward.
  The cookie is automatically set to NULL in pps_unregister_source()
  so that it will not be used again, even if the pps device cannot
  be removed from the idr due to pending references holding the minor
  number in use.
  Module stuff
 SPDX-License-Identifier: GPL-2.0-or-later
  PPS kernel consumer API
  Copyright (C) 2009-2010   Alexander Gordeev <lasaine@lvk.cs.msu.su>
  Global variables
 state variables to bind kernel consumer 
 PPS API (RFC 2783): current source and mode for kernel consumer 
 unique pointer to device 
 mode bits for kernel consumer 
 pps_kc_bind - control PPS kernel consumer binding
  @pps: the PPS source
  @bind_args: kernel consumer bind parameters
  This function is used to bind or unbind PPS kernel consumer according to
  supplied parameters. Should not be called in interrupt context.
 Check if another consumer is already bound 
 pps_kc_remove - unbind kernel consumer on PPS source removal
  @pps: the PPS source
  This function is used to disable kernel consumer on PPS source removal
  if this source was bound to PPS kernel consumer. Can be called on any
  source safely. Should not be called in interrupt context.
 pps_kc_event - call hardpps() on PPS event
  @pps: the PPS source
  @ts: PPS event timestamp
  @event: PPS event edge
  This function calls hardpps() when an event from bound PPS source occurs.
 Pass some events to kernel consumer if activated 
 SPDX-License-Identifier: GPL-2.0-or-later
  PPS sysfs support
  Copyright (C) 2007-2009   Rodolfo Giometti <giometti@linux.it>
  Attribute functions
 SPDX-License-Identifier: GPL-2.0-or-later
  pps-ldisc.c -- PPS line discipline
  Copyright (C) 2008	Rodolfo Giometti <giometti@linux.it>
	
	  This should never fail, but the ldisc locking is very
	  convoluted, so don't crash just in case.
 Now do the PPS event report 
 Now open the base class N_TTY ldisc 
  Module stuff
 Inherit the N_TTY's ops 
 Save N_TTY's open()close() methods 
 Init PPS_TTY data 
 SPDX-License-Identifier: GPL-2.0-or-later
  pps_parport.c -- kernel parallel port PPS client
  Copyright (C) 2009   Alexander Gordeev <lasaine@lvk.cs.msu.su>
  TODO:
  implement echo over SEL pin
 module parameters 
 internal per port structure 
 parport device 
 PPS device 
 port clear timeout 
 number of timeouts 
 device number 
 parport interrupt handler 
 first of all we get the time stamp... 
 clear edge capture disabled 
 try capture the clear edge 
	 We have to disable interrupts here. The idea is to prevent
	  other interrupts on the same processor to introduce random
	  lags while polling the port. Reading from IO port is known
	  to take approximately 1us while other interrupt handlers can
	  take much more potentially.
	 
	  Interrupts won't be disabled for a long time because the
	  number of polls is limited by clear_wait parameter which is
	  kept rather low. So it should never be an issue.
 check the signal (no signal means the pulse is lost this time) 
 poll the port until the signal is unset 
 timeout 
 fire assert event 
 fire assert event 
 fire clear event 
 FIXME: oooh, this is ugly! 
 not our port 
 SPDX-License-Identifier: GPL-2.0-or-later
  pps-gpio.c -- PPS client driver using GPIO
  Copyright (C) 2010 Ricardo Martins <rasm@fe.up.pt>
  Copyright (C) 2011 James Nuss <jamesnuss@nanometrics.ca>
 Info for each registered platform device 
 IRQ used as PPS source 
 PPS source device 
 PPS source information 
 GPIO port descriptors 
 timer to reset echo active state 
 PPS echo active duration 
 timer timeout value in jiffies 
  Report the PPS event
 Get the time stamp first 
 This function will only be called when an ECHO GPIO is defined 
 add_timer() needs to write into info->echo_timer 
 fire the timer 
 Timer callback to reset the echo pin to the inactive state 
 sanity check on echo_active_ms 
 allocate space for device info 
 GPIO setup 
 IRQ setup 
 initialize PPS specific parts of the bookkeeping data structure. 
 register PPS source 
 register IRQ interrupt handler 
 reset echo pin in any case 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
  pps-ktimer.c -- kernel timer test client
  Copyright (C) 2005-2006   Rodolfo Giometti <giometti@linux.it>
  Global variables
  The kernel timer
 First of all we get the time stamp... 
  The PPS info struct
  Module staff
 SPDX-License-Identifier: GPL-2.0-or-later
  pps_gen_parport.c -- kernel parallel port PPS signal generator
  Copyright (C) 2009   Alexander Gordeev <lasaine@lvk.cs.msu.su>
  TODO:
  fix issues when realtime clock is adjusted in a leap
 module parameters 
 set the hrtimer earlier for safety (ns) 
 internal per port structure 
 parport device 
 calibrated port write time (ns) 
 calibrated time between a hrtimer event and the reaction 
 the kernel hrtimer event 
	 We have to disable interrupts here. The idea is to prevent
	  other interrupts on the same processor to introduce random
	  lags while polling the clock. ktime_get_real_ts64() takes <1us on
	  most machines while other interrupt handlers can take much
	  more potentially.
	 
	  NB: approx time with blocked interrupts =
	  send_delay + 3  SAFETY_INTERVAL
 first of all we get the time stamp... 
 check if we are late 
 busy loop until the time is right for an assert edge 
 set the signal 
 busy loop until the time is right for a clear edge 
 unset the signal 
 update calibrated port write time 
 update calibrated hrtimer error 
	 If the new error value is bigger then the old, use the new
	  value, if not then slowly move towards the new value. This
	  way it should be safe in bad conditions and efficient in
	  good conditions.
 update the hrtimer expire time 
 calibrate port write time 
 we already have a port 
 not our port 
 module staff 
 SPDX-License-Identifier: GPL-2.0-only
   step_wise.c - A step-by-step Thermal throttling governor
   Copyright (C) 2012 Intel Corp
   Copyright (C) 2012 Durgadoss R <durgadoss.r@intel.com>
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  If the temperature is higher than a trip point,
     a. if the trend is THERMAL_TREND_RAISING, use higher cooling
        state for this trip point
     b. if the trend is THERMAL_TREND_DROPPING, do nothing
     c. if the trend is THERMAL_TREND_RAISE_FULL, use upper limit
        for this trip point
     d. if the trend is THERMAL_TREND_DROP_FULL, use lower limit
        for this trip point
  If the temperature is lower than a trip point,
     a. if the trend is THERMAL_TREND_RAISING, do nothing
     b. if the trend is THERMAL_TREND_DROPPING, use lower cooling
        state for this trip point, if the cooling state already
        equals lower limit, deactivate the thermal instance
     c. if the trend is THERMAL_TREND_RAISE_FULL, do nothing
     d. if the trend is THERMAL_TREND_DROP_FULL, use lower limit,
        if the cooling state already equals lower limit,
        deactivate the thermal instance
	
	  We keep this instance the way it is by default.
	  Otherwise, we use the current state of the
	  cdev in use to determine the next_target.
	
	  If value is +1, activate a passive instance.
	  If value is -1, deactivate a passive instance.
 Activate a passive thermal instance 
 Deactivate a passive thermal instance 
 cdev needs update 
  step_wise_throttle - throttles devices associated with the given zone
  @tz: thermal_zone_device
  @trip: trip point index
  Throttling Logic: This uses the trend of the thermal zone to throttle.
  If the thermal zone is 'heating up' this throttles all the cooling
  devices associated with the zone and its particular trip point, by one
  step. If the zone is 'cooling down' it brings back the performance of
  the devices by one step.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2020 Linaro Limited
  Author: Daniel Lezcano <daniel.lezcano@linaro.org>
  Generic netlink for thermal management framework
 Thermal zone 
 Governor(s) 
 Cooling devices 
 Sampling encoding 
 Event encoding 
  Generic netlink event encoding
 Command encoding 
 SPDX-License-Identifier: GPL-2.0-or-later
  db8500_thermal.c - DB8500 Thermal Management Implementation
  Copyright (C) 2012 ST-Ericsson
  Copyright (C) 2012-2019 Linaro Ltd.
  Authors: Hongbo Zhang, Linus Walleij
  db8500_thermal_points - the interpolation points that trigger
  interrupts
	
	  This is where things start to get really bad for the
	  SoC and the thermal zones should be set up to trigger
	  critical temperature at 85000 mC so we don't get above
	  this point.
 Callback to get current temperature 
	
	  TODO: There is no PRCMU interface to get temperature data currently,
	  so a pseudo temperature is returned , it works for thermal framework
	  and this will be fixed when the PRCMU interface is available.
 Callback to get temperature changing trend 
	
	  The PRCMU accept absolute temperatures in celsius so divide
	  down the millicelsius with 1000
 Meaningless for thermal management, ignoring it 
 So we roof out 1 degree over the max point 
 register of thermal sensor and get info from DT 
 Start measuring at the lowest point 
 Resume and start measuring at the lowest point 
 SPDX-License-Identifier: GPL-2.0-or-later
  Khadas MCU Controlled FAN driver
  Copyright (C) 2020 BayLibre SAS
  Author(s): Neil Armstrong <narmstrong@baylibre.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 SPDX-License-Identifier: GPL-2.0-only
  Kirkwood thermal sensor driver
  Copyright (C) 2012 Nobuhiro Iwamatsu <iwamatsu@nigauri.org>
 Kirkwood Thermal Sensor Dev Structure 
 Valid check 
	
	  Calculate temperature. According to Marvell internal
	  documentation the formula for this is:
	  Celsius = (322-reg)1.3625
 SPDX-License-Identifier: GPL-2.0
  devfreq_cooling: Thermal cooling device implementation for devices using
                   devfreq
  Copyright (C) 2014-2015 ARM Limited
  TODO:
     - If OPPs are added or removed after devfreq cooling has
       registered, the devfreq cooling won't react to it.
  struct devfreq_cooling_device - Devfreq cooling device
 		devfreq_cooling_device registered.
  @cdev:	Pointer to associated thermal cooling device.
  @devfreq:	Pointer to associated devfreq device.
  @cooling_state:	Current cooling state.
  @freq_table:	Pointer to a table with the frequencies sorted in descending
 		order.  You can index the table by cooling device state
  @max_state:	It is the last index, that is, one less than the number of the
 		OPPs
  @power_ops:	Pointer to devfreq_cooling_power, a more precised model.
  @res_util:	Resource utilization scaling factor for the power.
 		It is multiplied by 100 to minimize the error. It is used
 		for estimation of the power budget instead of using
 		'utilization' (which is	'busy_time'  'total_time').
 		The 'res_util' range is from 100 to power  100	for the
 		corresponding 'state'.
  @capped_state:	index to cooling state with in dynamic power budget
  @req_max_freq:	PM QoS request for limiting the maximum frequency
 			of the devfreq device.
  @em_pd:		Energy Model for the associated Devfreq device
  get_perf_idx() - get the performance index corresponding to a frequency
  @em_pd:	Pointer to device's Energy Model
  @freq:	frequency in kHz
  Return: the performance index associated with the @freq, or
  -EINVAL if it wasn't found.
 mV 
 Energy Model frequencies are in kHz 
 Scale power for utilization 
 It is safe to set max in this case 
 Scale for resource utilization 
 Scale dynamic power for utilization 
	
	  Find the first cooling state that is within the power
	  budget. The EM power table is sorted ascending.
  devfreq_cooling_gen_tables() - Generate frequency table.
  @dfc:	Pointer to devfreq cooling device.
  @num_opps:	Number of OPPs
  Generate frequency table which holds the frequencies in descending
  order. That way its indexed by cooling device state. This is for
  compatibility with drivers which do not register Energy Model.
  Return: 0 on success, negative error code on failure.
  of_devfreq_cooling_register_power() - Register devfreq cooling device,
                                       with OF and power information.
  @np:	Pointer to OF device_node.
  @df:	Pointer to devfreq device.
  @dfc_power:	Pointer to devfreq_cooling_power.
  Register a devfreq cooling device.  The available OPPs must be
  registered on the device.
  If @dfc_power is provided, the cooling device is registered with the
  power extensions.  For the power extensions to work correctly,
  devfreq should use the simple_ondemand governor, other governors
  are not currently supported.
 Backward compatibility for drivers which do not use IPA 
 max_state is an index, not a counter 
  of_devfreq_cooling_register() - Register devfreq cooling device,
                                 with OF information.
  @np: Pointer to OF device_node.
  @df: Pointer to devfreq device.
  devfreq_cooling_register() - Register devfreq cooling device.
  @df: Pointer to devfreq device.
  devfreq_cooling_em_register() - Register devfreq cooling device with
 		power information and automatically register Energy Model (EM)
  @df:		Pointer to devfreq device.
  @dfc_power:	Pointer to devfreq_cooling_power.
  Register a devfreq cooling device and automatically register EM. The
  available OPPs must be registered for the device.
  If @dfc_power is provided, the cooling device is registered with the
  power extensions. It is using the simple Energy Model which requires
  "dynamic-power-coefficient" a devicetree property. To not break drivers
  which miss that DT property, the function won't bail out when the EM
  registration failed. The cooling device will be registered if everything
  else is OK.
  devfreq_cooling_unregister() - Unregister devfreq cooling device.
  @cdev: Pointer to devfreq cooling device to unregister.
  Unregisters devfreq cooling device and related Energy Model if it was
  present.
 SPDX-License-Identifier: GPL-2.0-only
   fair_share.c - A simple weight based Thermal governor
   Copyright (C) 2012 Intel Corp
   Copyright (C) 2012 Durgadoss R <durgadoss.r@intel.com>
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  get_trip_level: - obtains the current trip level for a zone
  @tz:		thermal zone device
	
	  count > 0 only if temperature is greater than first trip
	  point, in which case, trip_point = count - 1
  fair_share_throttle - throttles devices associated with the given zone
  @tz: thermal_zone_device
  @trip: trip point index
  Throttling Logic: This uses three parameters to calculate the new
  throttle state of the cooling devices associated with the given zone.
  Parameters used for Throttling:
  P1. max_state: Maximum throttle state exposed by the cooling device.
  P2. percentage[i]100:
 	How 'effective' the 'i'th device is, in cooling the given zone.
  P3. cur_trip_levelmax_no_of_trips:
 	This describes the extent to which the devices should be throttled.
 	We do not want to throttle too much when we trip a lower temperature,
 	whereas the throttling is at full swing if we trip critical levels.
 	(Heavily assumes the trip points are in ascending order)
  new_state of cooling device = P3  P2  P1
 SPDX-License-Identifier: GPL-2.0-only
  Generic ADC thermal driver
  Copyright (C) 2016 NVIDIA CORPORATION. All rights reserved.
  Author: Laxman Dewangan <ldewangan@nvidia.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright 2020 NXP.
  Author: Anson Huang <Anson.Huang@nxp.com>
 TMU enable 
 TMU immediate temp 
 negative 
 disable the monitor during initialization 
 enable all the probes for V2 TMU 
 enable the monitor 
 disable TMU 
 SPDX-License-Identifier: GPL-2.0
   thermal.c - Generic Thermal Management Sysfs support.
   Copyright (C) 2008 Intel Corp
   Copyright (C) 2008 Zhang Rui <rui.zhang@intel.com>
   Copyright (C) 2008 Sujith Thomas <sujith.thomas@intel.com>
  Governor section: set of functions to handle thermal governors
  Functions to help in the life cycle of thermal governors within
  the thermal core and by the thermal governor code.
  bind_previous_governor() - bind the previous governor of the thermal zone
  @tz:		a valid pointer to a struct thermal_zone_device
  @failed_gov_name:	the name of the governor that failed to register
  Register the previous governor of the thermal zone after a new
  governor has failed to be bound.
  thermal_set_governor() - Switch to another governor
  @tz:		a valid pointer to a struct thermal_zone_device
  @new_gov:	pointer to the new governor
  Change the governor of thermal zone @tz.
  Return: 0 on success, an error if the new governor's bind_to_tz() failed.
		
		  only thermal zones with specified tz->tzp->governor_name
		  may run with tz->govenor unset
  Zone update section: main control loop applied to each zone while monitoring
  in polling mode. The monitoring is done using a workqueue.
  Same update may be done on a zone by calling thermal_zone_device_update().
  An update means:
  - Non-critical trips will invoke the governor responsible for that zone;
  - Hot trips will produce a notification to userspace;
  - Critical trip point will cause a system shutdown.
	
	  poweroff_delay_ms must be a carefully profiled positive value.
	  Its a must for forced_emergency_poweroff_work to be scheduled.
 If we have not crossed the trip_temp, we do not care. 
 Ignore disabled trip points 
	
	  Alright, we handled this trip successfully.
	  So, start monitoring again.
 do nothing if mode isn't changing 
  Device management section: cooling devices, zones devices, and binding
  Set of functions provided by the thermal core for:
  - cooling devices lifecycle: registration, unregistration,
 				binding, and unbinding.
  - thermal zone devices lifecycle: registration, unregistration,
 				     binding, and unbinding.
  thermal_zone_bind_cooling_device() - bind a cooling device to a thermal zone
  @tz:		pointer to struct thermal_zone_device
  @trip:	indicates which trip point the cooling devices is
 		associated with in this thermal zone.
  @cdev:	pointer to struct thermal_cooling_device
  @upper:	the Maximum cooling state for this trip point.
 		THERMAL_NO_LIMIT means no upper limit,
 		and the cooling device can be in max_state.
  @lower:	the Minimum cooling state can be used for this trip point.
 		THERMAL_NO_LIMIT means no lower limit,
 		and the cooling device can be in cooling state 0.
  @weight:	The weight of the cooling device to be bound to the
 		thermal zone. Use THERMAL_WEIGHT_DEFAULT for the
 		default value
  This interface function bind a thermal cooling device to the certain trip
  point of a thermal zone device.
  This function is usually called in the thermal zone device .bind callback.
  Return: 0 on success, the proper error value otherwise.
 lower default 0, upper default max_state 
  thermal_zone_unbind_cooling_device() - unbind a cooling device from a
 					  thermal zone.
  @tz:		pointer to a struct thermal_zone_device.
  @trip:	indicates which trip point the cooling devices is
 		associated with in this thermal zone.
  @cdev:	pointer to a struct thermal_cooling_device.
  This interface function unbind a thermal cooling device from the certain
  trip point of a thermal zone device.
  This function is usually called in the thermal zone device .unbind callback.
  Return: 0 on success, the proper error value otherwise.
  __thermal_cooling_device_register() - register a new thermal cooling device
  @np:		a pointer to a device tree node.
  @type:	the thermal cooling device type.
  @devdata:	device private data.
  @ops:		standard thermal cooling devices callbacks.
  This interface function adds a new thermal cooling device (fanprocessor...)
  to sysclassthermal folder as cooling_device[0-]. It tries to bind itself
  to all the thermal zone devices registered at the same time.
  It also gives the opportunity to link the cooling device to a device tree
  node, so that it can be bound to a thermal zone created out of device tree.
  Return: a pointer to the created struct thermal_cooling_device or an
  ERR_PTR. Caller must check return value with IS_ERR() helpers.
 Add 'this' new cdev to the global cdev list 
 Update binding information for 'this' new cdev 
  thermal_cooling_device_register() - register a new thermal cooling device
  @type:	the thermal cooling device type.
  @devdata:	device private data.
  @ops:		standard thermal cooling devices callbacks.
  This interface function adds a new thermal cooling device (fanprocessor...)
  to sysclassthermal folder as cooling_device[0-]. It tries to bind itself
  to all the thermal zone devices registered at the same time.
  Return: a pointer to the created struct thermal_cooling_device or an
  ERR_PTR. Caller must check return value with IS_ERR() helpers.
  thermal_of_cooling_device_register() - register an OF thermal cooling device
  @np:		a pointer to a device tree node.
  @type:	the thermal cooling device type.
  @devdata:	device private data.
  @ops:		standard thermal cooling devices callbacks.
  This function will register a cooling device with device tree node reference.
  This interface function adds a new thermal cooling device (fanprocessor...)
  to sysclassthermal folder as cooling_device[0-]. It tries to bind itself
  to all the thermal zone devices registered at the same time.
  Return: a pointer to the created struct thermal_cooling_device or an
  ERR_PTR. Caller must check return value with IS_ERR() helpers.
  devm_thermal_of_cooling_device_register() - register an OF thermal cooling
 					       device
  @dev:	a valid struct device pointer of a sensor device.
  @np:		a pointer to a device tree node.
  @type:	the thermal cooling device type.
  @devdata:	device private data.
  @ops:	standard thermal cooling devices callbacks.
  This function will register a cooling device with device tree node reference.
  This interface function adds a new thermal cooling device (fanprocessor...)
  to sysclassthermal folder as cooling_device[0-]. It tries to bind itself
  to all the thermal zone devices registered at the same time.
  Return: a pointer to the created struct thermal_cooling_device or an
  ERR_PTR. Caller must check return value with IS_ERR() helpers.
  thermal_cooling_device_unregister - removes a thermal cooling device
  @cdev:	the thermal cooling device to remove.
  thermal_cooling_device_unregister() must be called when a registered
  thermal cooling device is no longer needed.
 thermal cooling device not found 
 Unbind all thermal zones associated with 'this' cdev 
 If there is ops->bind, try to use ops->bind 
  thermal_zone_device_register() - register a new thermal zone device
  @type:	the thermal zone device type
  @trips:	the number of trip points the thermal zone support
  @mask:	a bit string indicating the writeablility of trip points
  @devdata:	private device data
  @ops:	standard thermal zone device callbacks
  @tzp:	thermal zone platform parameters
  @passive_delay: number of milliseconds to wait between polls when
 		   performing passive cooling
  @polling_delay: number of milliseconds to wait between polls when checking
 		   whether trip points have been crossed (0 for interrupt
 		   driven systems)
  This interface function adds a new thermal zone device (sensor) to
  sysclassthermal folder as thermal_zone[0-]. It tries to bind all the
  thermal cooling devices registered at the same time.
  thermal_zone_device_unregister() must be called when the device is no
  longer needed. The passive cooling depends on the .get_trend() return value.
  Return: a pointer to the created struct thermal_zone_device or an
  in case of error, an ERR_PTR. Caller must check return value with
  IS_ERR() helpers.
 sys IF 
 Add nodes that are always present via .groups 
 A new thermal zone needs to be updated anyway. 
 Update 'this' zone's governor information 
 Bind cooling devices for this zone 
 Update the new thermal zone and mark it as already updated. 
  thermal_zone_device_unregister - removes the registered thermal zone device
  @tz: the thermal zone device to remove
 thermal zone device not found 
 Unbind all cdevs associated with 'this' thermal zone 
  thermal_zone_get_zone_by_name() - search for a zone and returns its ref
  @name: thermal zone name to fetch the temperature
  When only one zone is found with the passed name, returns a reference to it.
  Return: On success returns a reference to an unique thermal zone with
  matching name equals to @name, an ERR_PTR otherwise (-EINVAL for invalid
  paramenters, -ENODEV for not found and -EEXIST for multiple matches).
 nothing has been found, thus an error code for it 
 Success only when an unique zone is found 
 SPDX-License-Identifier: GPL-2.0
   thermal.c - sysfs interface of thermal devices
   Copyright (C) 2016 Eduardo Valentin <edubezval@gmail.com>
   Highly based on original thermal_core.c
   Copyright (C) 2008 Intel Corp
   Copyright (C) 2008 Zhang Rui <rui.zhang@intel.com>
   Copyright (C) 2008 Sujith Thomas <sujith.thomas@intel.com>
 sys IF for thermal zone 
	
	  We are not doing any check on the 'temperature' value
	  here. The driver implementing 'set_trip_hyst' has to
	  take care of this.
  These are thermal zone device attributes that will always be present.
  All the attributes created for tzp (create_s32_tzp_attr) also are always
  present on the sysfs interface.
 These thermal zone device attributes are created based on conditions 
 These attributes are unconditionally added to a thermal zone 
 This is not NULL terminated as we create the group dynamically 
  create_trip_attrs() - create attributes for trip points
  @tz:		the thermal zone device
  @mask:	Writeable trip point bitmap.
  helper function to instantiate sysfs entries for every trip
  point and its properties of a struct thermal_zone_device.
  Return: 0 on success, the proper error value otherwise.
 This function works only for zones with at least one trip 
 create trip type attribute 
 create trip temp attribute 
 create Optional trip hyst attribute 
  destroy_trip_attrs() - destroy attributes for trip points
  @tz:		the thermal zone device
  helper function to free resources allocated by create_trip_attrs()
 we need one extra for trips and the NULL to terminate the array 
 This also takes care of API requirement to be NULL terminated 
 sys IF for cooling device 
 Space allocated for cooling_device_stats_attr_group 
 Total number of states is highest state + 1 
 Fill the empty slot left in cooling_device_attr_groups 
 CONFIG_THERMAL_STATISTICS 
 these helper will be used only at the time of bindig 
 SPDX-License-Identifier: GPL-2.0-or-later
  Thermal device driver for DA9062 and DA9061
  Copyright (C) 2017  Dialog Semiconductor
 When over-temperature is reached, an interrupt from the device will be
  triggered. Following this event the interrupt will be disabled and
  periodic transmission of uevents (HOT trip point) should define the
  first level of temperature supervision. It is expected that any final
  implementation of the thermal driver will include a .notify() function
  to implement these uevents to userspace.
  These uevents are intended to indicate non-invasive temperature control
  of the system, where the necessary measures for cooling are the
  responsibility of the host software. Once the temperature falls again,
  the IRQ is re-enabled so the start of a new over-temperature event can
  be detected without constant software monitoring.
 Minimum, maximum and default polling millisecond periods are provided
  here as an example. It is expected that any final implementation to also
  include a modification of these settings to match the required
  application.
 protection for da9062_thermal temperature 
 clear E_TEMP 
	 Now read E_TEMP again: it is acting like a status bit.
	  If over-temperature, then this status will be true.
	  If not over-temperature, this status will be false.
 SPDX-License-Identifier: GPL-2.0
   thermal_hwmon.c - Generic Thermal Management hwmon support.
   Code based on Intel thermal_core.c. Copyrights of the original code:
   Copyright (C) 2008 Intel Corp
   Copyright (C) 2008 Zhang Rui <rui.zhang@intel.com>
   Copyright (C) 2008 Sujith Thomas <sujith.thomas@intel.com>
   Copyright (C) 2013 Texas Instruments
   Copyright (C) 2013 Eduardo Valentin <eduardo.valentin@ti.com>
 hwmon sys IF 
 thermal zone devices with the same type share one hwmon device 
 one temperature input for each thermal zone 
 hwmon sys attr 
 hwmon sys attr 
 Find the temperature input matching a given thermal zone 
 Should never happen... 
 Should never happen... 
 SPDX-License-Identifier: GPL-2.0
   R-Car THSTSC thermal sensor driver
  Copyright (C) 2012 Renesas Solutions Corp.
  Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
 THSCR 
 THSSR 
	
	  The Gen3 chip has 3 interrupts, but this driver uses only 2
	  interrupts to detect a temperature change, rise or fall.
 		basic functions
 		zone device functions
	
	  TSC decides a value of CPTAP automatically,
	  and this is the conditions which validate interrupt.
		
		  we need to wait 300us after changing comparator offset
		  to get stable temperature.
		  see "Usage Notes" on datasheet
	
	  enable IRQ
 enable RisingFalling edge interrupt 
 Guaranteed operating range is -45C to 125C. 
 see rcar_thermal_get_temp() 
 +90 <= temp 
 see rcar_thermal_get_temp() 
 +90 <= temp 
 		interrupt
 enable RisingFalling 
	
	  check the status
 		platform functions
			
			  platform has IRQ support.
			  Then, driver uses common registers
			  rcar_has_irq_support() will be enabled
 polling delay is not needed 
 update ENR bits 
			
			  thermal_zone doesn't enable hwmon as default,
			  but, enable it here to keep compatible
 update ENR bits 
 SPDX-License-Identifier: GPL-2.0-only
   gov_bang_bang.c - A simple thermal throttling governor using hysteresis
   Copyright (C) 2014 Peter Kaestle <peter@piie.net>
   Based on step_wise.c with following Copyrights:
   Copyright (C) 2012 Intel Corp
   Copyright (C) 2012 Durgadoss R <durgadoss.r@intel.com>
 in case fan is in initial state, switch the fan off 
 in case fan is neither on nor off set the fan to active 
		
		  enable fan when temperature exceeds trip_temp and disable
		  the fan in case it falls below trip_temp minus hysteresis
 cdev needs update 
  bang_bang_control - controls devices associated with the given zone
  @tz: thermal_zone_device
  @trip: the trip point
  Regulation Logic: a two point regulation, deliver cooling state depending
  on the previous state shown in this diagram:
                 Fan:   OFF    ON
                               |
                               |
           trip_temp:    +---->+
                         |     |        ^
                         |     |        |
                         |     |   Temperature
  (trip_temp - hyst):    +<----+
                         |
                         |
                         |
     If the fan is not running and temperature exceeds trip_temp, the fan
      gets turned on.
     In case the fan is running, temperature must fall below
      (trip_temp - hyst) so that the fan gets turned off again.
 SPDX-License-Identifier: GPL-2.0-only
  Marvell EBU Armada SoCs thermal sensor driver
  Copyright (C) 2013 Marvell
 Thermal Manager Control and Status Register 
 Errata fields 
 Marvell EBU Thermal Sensor Dev Structure 
 serialize temperature readsupdates 
 Initialize the thermal IC 
 Formula coeficients: temp = (b - m  reg)  div 
 Register shift and mask to access the sensor temperature 
 Syscon access 
 One sensor is in the thermal IC, the others are in the CPUs if any 
  struct armada_thermal_sensor - hold the information of one thermal sensor
  @thermal: pointer to the local private structure
  @tzd: pointer to the thermal zone device
  @id: identifier of the thermal sensor
 Reference calibration value 
 Reset the sensor 
 Enable the sensor 
 Reference calibration value 
 Reset the sensor 
 Disable the HWSW reset 
 Set Tsen Tc Trim to correct default value (errata #132698) 
 Sample every ~2ms 
 Enable average (2 samples by default) 
 Sample every ~2ms 
 Average the output value over 2^1 = 2 samples 
 Clear DFX temperature IRQ cause 
 Enable DFX Temperature IRQ 
 Enable DFX server IRQ 
 Enable overheat interrupt 
 There is currently no board with more than one sensor per channel 
 Stop the measurements 
 Reset the mode, internal sensor will be automatically selected 
 Other channels are external and should be selected accordingly 
 Change the mode to external 
 Select the sensor 
 Actually set the modechannel 
 Re-start the measurements 
	
	  The IP has a latency of ~15ms, so after updating the selected source,
	  we must absolutely wait for the sensor validity bit to ensure we read
	  actual data.
 The most significant bit is the sign bit 
 Get formula coeficients 
 Valid check 
 Do the actual reading 
 Select the desired channel 
 Do the actual reading 
	
	  Select back the interrupt source channel from which a potential
	  critical trip point has been set.
  The documentation states:
  highlow watermark = threshold +- 0.4761  2^(hysteresis + 2)
  which is the mathematical derivation for:
  0x0 <=> 1.9°C, 0x1 <=> 3.8°C, 0x2 <=> 7.6°C, 0x3 <=> 15.2°C
	
	  We will always take the smallest possible hysteresis to avoid risking
	  the hardware integrity by enlarging the threshold by +8°C in the
	  worst case.
 Set Threshold 
 Set Hysteresis 
	
	  Disable the IRQ and continue in thread context (thermal core
	  notification and temperature monitoring).
 Notify the core in thread context 
	
	  The overheat interrupt must be cleared by reading the DFX interrupt
	  cause _after_ the temperature has fallen down to the low threshold.
	  Otherwise future interrupts might not be served.
 Notify the thermal core that the temperature is acceptable again 
 sentinel 
 First memory region points towards the status register 
	
	  Fix up from the old individual DT register specification to
	  cover all the registers.  We do this by adjusting the ioremap()
	  result, which should be fine as ioremap() deals with pages.
	  However, validate that we do not cross a page boundary while
	  making this adjustment.
		
		  When inside a system controller, the device name has the
		  form: f06f8000.system-controller:ap-thermal so stripping
		  after the ':' should give us a shorter but meaningful name.
 Save the name locally 
 Then check there are no '-' or hwmon core will complain 
  The IP can manage to trigger interrupts on overheat situation from all the
  sensors. However, the interrupt source changes along with the last selected
  source (ie. the last read sensor), which is an inconsistent behavior. Avoid
  possible glitches by always selecting back only one channel (arbitrarily: the
  first in the DT which has a critical trip point). We also disable sensor
  switch during overheat situations.
 Retrieve the critical trip point to enable the overheat interrupt 
	
	  Legacy DT bindings only described "control1" register (also referred
	  as "control MSB" on old documentation). Then, bindings moved to cover
	  "control0control LSB" and "control1control MSB" registers within
	  the same resource, which was then of size 8 instead of 4.
	 
	  The logic of defining sporadic registers is broken. For instance, it
	  blocked the addition of the overheat interrupt feature that needed
	  another resource somewhere else in the same memory area. One solution
	  is to define an overall system controller and put the thermal node
	  into it, which requires the use of regmaps across all the driver.
 Ensure device name is correct for the thermal core 
 Wait the sensors to be valid 
 The overheat interrupt feature is not mandatory 
	
	  There is one channel for the IC and one per CPU (if any), each
	  channel has one sensor.
 Register the sensor 
		
		  The first channel that has a critical trip point registered
		  in the DT will serve as interrupt source. Others possible
		  critical trip points will simply be ignored by the driver.
 Just complain if no overheat interrupt was set up 
 SPDX-License-Identifier: GPL-2.0
 Copyright 2013 Freescale Semiconductor, Inc.
 i.MX6 specific 
 Below LOW and PANIC bits are only for TEMPMON_IMX6SX 
 Below TEMPSENSE2 is only for TEMPMON_IMX6SX 
 i.MX7 specific 
 The driver supports 1 passive trip point and 1 critical trip point 
 millisecond 
 See formula in imx_init_calib() 
 Check if a measurement is currently in progress 
		
		  Every time we measure the temperature, we will power on the
		  temperature sensor, enable measurements, take a reading,
		  disable measurements, power off the temperature sensor.
	
	  According to the temp sensor designers, it may require up to ~17us
	  to complete a measurement.
 See imx_init_calib() for formula derivation 
 Update alarm value to next higher trip point for TEMPMON_IMX6Q 
 Reenable alarm IRQ if temperature below alarm temperature 
 do not allow changing critical threshold 
 do not allow passive to be set higher than critical 
	
	  On i.MX7D, we only use the calibration data at 25C to get the temp,
	  Tmeas = ( Nmeas - n1) + 25; n1 is the fuse value for 25C.
	
	  The sensor is calibrated at 25 °C (aka T1) and the value measured
	  (aka N1) at this temperature is provided in bits [31:20] in the
	  i.MX's OCOTP value ANA1.
	  To find the actual temperature T, the following formula has to be used
	  when reading value n from the sensor:
	 
	  T = T1 + (N - N1)  (0.4148468 - 0.0015423  N1) °C + 3.580661 °C
	    = [T1' - N1  (0.4148468 - 0.0015423  N1) °C] + N  (0.4148468 - 0.0015423  N1) °C
	    = [T1' + N1  (0.0015423  N1 - 0.4148468) °C] - N  (0.0015423  N1 - 0.4148468) °C
	    = c2 - c1  N
	 
	  with
	 
	   T1' = 28.580661 °C
	    c1 = 1  (0.0015423  N1 - 0.4297157) °C
	    c2 = T1' + N1  (0.0015423  N1 - 0.4148468) °C
	       = T1' + N1  c1
 use 10^7 as fixed point constant for values in formula 
 to get result in °mC 
 The maximum die temp is specified by the Temperature Grade 
 Commercial (0 to 95 °C) 
 Extended Commercial (-20 °C to 105 °C) 
 Industrial (-40 °C to 105 °C) 
 Automotive (-40 °C to 125 °C) 
	
	  Set the critical trip point at 5 °C under max
	  Set the passive trip point at 10 °C under max (changeable via sysfs)
 end  }
  Create cooling device in case no #cooling-cells property is available in
  CPU node
 make sure the IRQ flag is clear before enabling irq on i.MX6SX 
		
		  reset value of LOW ALARM is incorrect, set it to lowest
		  value to avoid false trigger of low alarm.
 Make sure sensor is in known good state for measurements 
	
	  Thermal sensor needs clk on to get correct value, normally
	  we should enable its clk before taking measurement and disable
	  clk after measurement is done, but if alarm function is enabled,
	  hardware will auto measure the temperature periodically, so we
	  need to keep the clk always on for alarm function.
 Enable measurements at ~ 10 Hz 
 10 Hz 
 Disable measurements 
	
	  Need to disable thermal sensor, otherwise, when thermal core
	  try to get temperature before thermal sensor resume, a wrong
	  temperature will be read as the thermal sensor is powered
	  down. This is done in change_mode() operation called from
	  thermal_zone_device_disable()
 Enabled thermal sensor after resume 
 SPDX-License-Identifier: GPL-2.0
   R-Car Gen3 THS thermal sensor driver
   Based on rcar_thermal.c and work from Hien Dang and Khiem Nguyen.
  Copyright (C) 2016 Renesas Electronics Corporation.
  Copyright (C) 2016 Sang Engineering
 Register offsets 
 IRQ{STR,MSK,EN} bits 
 CTSR bits 
 THCTR bits 
 THSCP bits 
 Structure for thermal temperature calculation 
  Linear approximation for temperature
  [reg] = [temp]  a + b => [temp] = ([reg] - b)  a
  The constants a and b are calculated using two triplets of int values PTAT
  and THCODE. PTAT and THCODE can either be read from hardware or use hard
  coded values from driver. The formula to calculate a and b are taken from
  BSP and sparsely documented and understood.
  Examining the linear formula and the formula used to calculate constants a
  and b while knowing that the span for PTAT and THCODE values are between
  0x000 and 0xfff the largest integer possible is 0xfff  0xfff == 0xffe001.
  Integer also needs to be signed so that leaves 7 bits for binary
  fixed point scaling.
 mili Celsius 
 no idea where these constants come from 
 TODO: Find documentation and document constant calculation formula 
	
	  Division is not scaled in BSP and if scaled it might overflow
	  the dividend (4095  4095 << 14 > INT_MAX) so keep it unscaled
 Read register and convert to mili Celsius 
 Guaranteed operating range is -40C to 125C. 
 Round value to device granularity setting 
 sentinel  }
 If fuses are not set, fallback to pseudo values. 
 Default THCODE values in case FUSEs are not set. 
	
	  Set the pseudo calibration points with fused values.
	  PTAT is shared between all TSCs but only fused for the first
	  TSC while THCODEs are fused for each TSC.
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2020 Spreadtrum Communications Inc.
 bits definitions for register THM_CTL 
 bits definitions for register THM_INT_CTL 
 bits definitions for register SPRD_THM_INTERNAL_STS1 
 thermal sensor calibration parameters 
  The conversion between ADC and temperature is based on linear relationship,
  and use idea_k to specify the slope and ideal_b to specify the offset.
  Since different Spreadtrum SoCs have different ideal_k and ideal_b,
  we should save ideal_k and ideal_b in the device data structure.
	
	  According to thermal datasheet, the default calibration offset is 64,
	  and the default ratio is 1000.
	
	  According to the ideal slope K and ideal offset B, combined with
	  calibration value of thermal from efuse, then calibrate the real
	  slope k and offset b:
	  k_cal = (k  ratio)  1000.
	  b_cal = b + (dt_offset - 64)  500.
	
	  According to the thermal datasheet, the formula of converting
	  adc value to the temperature value should be:
	  T_final = k_cal  x - b_cal.
	
	  According to the thermal datasheet, the formula of converting
	  adc value to the temperature value should be:
	  T_final = k_cal  x - b_cal.
	
	  Wait for thermal ready status before configuring thermal parameters.
 Wait for first temperature data ready before reading temperature 
	
	  Clear interrupt status, enable thermal interrupt and enable thermal.
	 
	  The SPRD thermal controller integrates a hardware interrupt signal,
	  which means if the temperature is overheat, it will generate an
	  interrupt and notify the event to PMIC automatically to shutdown the
	  system. So here we should enable the interrupt bits, though we have
	  not registered an irq handler.
 Enable the sensor' overheat temperature protection interrupt 
 Set the sensor' overheat and hot threshold temperature 
 Enable the corresponding sensor 
 Set the period of two valid temperature detection action 
 Set the sensors' monitor mode 
 Set the sensors' monitor period 
 sen_child set to NULL at this point 
 SPDX-License-Identifier: GPL-2.0-only
  SPEAr thermal driver.
  Copyright (C) 2011-2012 ST Microelectronics
  Author: Vincenzo Frascino <vincenzo.frascino@st.com>
 SPEAr Thermal Sensor Dev Structure 
 pointer to base address of the thermal sensor 
 clk structure 
 pointer to thermal flags 
	
	  Data are ready to be read after 628 usec from POWERDOWN signal
	  (PDN) = 1
 Disable SPEAr Thermal Sensor 
 Enable SPEAr Thermal Sensor 
 Enable thermal sensor 
 Disable SPEAr Thermal Sensor 
 SPDX-License-Identifier: GPL-2.0
  A power allocator to manage temperature
  Copyright (C) 2014 ARM Ltd.
  mul_frac() - multiply two fixed-point numbers
  @x:	first multiplicand
  @y:	second multiplicand
  Return: the result of multiplying two fixed-point numbers.  The
  result is also a fixed-point number.
  div_frac() - divide two fixed-point numbers
  @x:	the dividend
  @y:	the divisor
  Return: the result of dividing two fixed-point numbers.  The
  result is also a fixed-point number.
  struct power_allocator_params - parameters for the power allocator governor
  @allocated_tzp:	whether we have allocated tzp for this thermal zone and
 			it needs to be freed on unbind
  @err_integral:	accumulated error in the PID controller.
  @prev_err:	error in the previous iteration of the PID controller.
 		Used to calculate the derivative term.
  @trip_switch_on:	first passive trip point of the thermal zone.  The
 			governor switches on when this trip point is crossed.
 			If the thermal zone only has one passive trip point,
 			@trip_switch_on should be INVALID_TRIP.
  @trip_max_desired_temperature:	last passive trip point of the thermal
 					zone.  The temperature we are
 					controlling for.
  @sustainable_power:	Sustainable power (heat) that this thermal zone can
 			dissipate
  estimate_sustainable_power() - Estimate the sustainable power of a thermal zone
  @tz: thermal zone we are operating in
  For thermal zones that don't provide a sustainable_power in their
  thermal_zone_params, estimate one.  Calculate it using the minimum
  power of all the cooling devices as that gives a valid value that
  can give some degree of functionality.  For optimal performance of
  this governor, provide a sustainable_power in the thermal zone's
  thermal_zone_params.
  estimate_pid_constants() - Estimate the constants for the PID controller
  @tz:		thermal zone for which to estimate the constants
  @sustainable_power:	sustainable power for the thermal zone
  @trip_switch_on:	trip point number for the switch on temperature
  @control_temp:	target temperature for the power allocator governor
  This function is used to update the estimation of the PID
  controller constants in struct thermal_zone_parameters.
	
	  estimate_pid_constants() tries to find appropriate default
	  values for thermal zones that don't provide them. If a
	  system integrator has configured a thermal zone with two
	  passive trip points at the same temperature, that person
	  hasn't put any effort to set up the thermal zone properly
	  so just give up.
	
	  The default for k_d and integral_cutoff is 0, so we can
	  leave them as they are.
  get_sustainable_power() - Get the right sustainable power
  @tz:		thermal zone for which to estimate the constants
  @params:	parameters for the power allocator governor
  @control_temp:	target temperature for the power allocator governor
  This function is used for getting the proper sustainable power value based
  on variables which might be updated by the user sysfs interface. If that
  happen the new value is going to be estimated and updated. It is also used
  after thermal zone binding, where the initial values where set to 0.
 Check if it's init value 0 or there was update via sysfs 
 Do the estimation only once and make available in sysfs 
  pid_controller() - PID controller
  @tz:	thermal zone we are operating in
  @control_temp:	the target temperature in millicelsius
  @max_allocatable_power:	maximum allocatable power for this thermal zone
  This PID controller increases the available power budget so that the
  temperature of the thermal zone gets as close as possible to
  @control_temp and limits the power if it exceeds it.  k_po is the
  proportional term when we are overshooting, k_pu is the
  proportional term when we are undershooting.  integral_cutoff is a
  threshold below which we stop accumulating the error.  The
  accumulated error is only valid if the requested power will make
  the system warmer.  If the system is mostly idle, there's no point
  in accumulating positive error.
  Return: The power budget for the next period.
 Calculate the proportional term 
	
	  Calculate the integral term
	 
	  if the error is less than cut off allow integration (but
	  the integral is limited to max power)
	
	  Calculate the derivative term
	 
	  We do err - prev_err, so with a positive k_d, a decreasing
	  error (i.e. driving closer to the line) results in less
	  power being applied, slowing down the controller)
 feed-forward the known sustainable dissipatable power 
  power_actor_set_power() - limit the maximum power a cooling device consumes
  @cdev:	pointer to &thermal_cooling_device
  @instance:	thermal instance to update
  @power:	the power in milliwatts
  Set the cooling device to consume at most @power milliwatts. The limit is
  expected to be a cap at the maximum power consumption.
  Return: 0 on success, -EINVAL if the cooling device does not
  implement the power actor API or -E for other failures.
  divvy_up_power() - divvy the allocated power between the actors
  @req_power:	each actor's requested power
  @max_power:	each actor's maximum available power
  @num_actors:	size of the @req_power, @max_power and @granted_power's array
  @total_req_power: sum of @req_power
  @power_range:	total allocated power
  @granted_power:	output array: each actor's granted power
  @extra_actor_power:	an appropriately sized array to be used in the
 			function as temporary storage of the extra power given
 			to the actors
  This function divides the total allocated power (@power_range)
  fairly between the actors.  It first tries to give each actor a
  share of the @power_range according to how much power it requested
  compared to the rest of the actors.  For example, if only one actor
  requests power, then it receives all the @power_range.  If
  three actors each requests 1mW, each receives a third of the
  @power_range.
  If any actor received more than their maximum power, then that
  surplus is re-divvied among the actors based on how far they are
  from their respective maximums.
  Granted power for each actor is written to @granted_power, which
  should've been allocated by the calling function.
	
	  Prevent division by 0 if none of the actors request power.
	
	  Re-divvy the reclaimed extra among actors based on
	  how far they are from the max
	
	  We need to allocate five arrays of the same size:
	  req_power, max_power, granted_power, extra_actor_power and
	  weighted_req_power.  They are going to be needed until this
	  function returns.  Allocate them all in one go to simplify
	  the allocation and deallocation logic.
  get_governor_trips() - get the number of the two trip points that are key for this governor
  @tz:	thermal zone to operate on
  @params:	pointer to private data for this governor
  The power allocator governor works optimally with two trips points:
  a "switch on" trip point and a "maximum desired temperature".  These
  are defined as the first and last passive trip points.
  If there is only one trip point, then that's considered to be the
  "maximum desired temperature" trip point and the governor is always
  on.  If there are no passive or active trip points, then the
  governor won't do anything.  In fact, its throttle function
  won't be called at all.
		
		  Call for updating the cooling devices local stats and avoid
		  periods of dozen of seconds when those have not been
		  maintained.
  check_power_actors() - Check all cooling devices and warn when they are
 			not power actors
  @tz:		thermal zone to operate on
  Check all cooling devices in the @tz and warn every time they are missing
  power actor API. The warning should help to investigate the issue, which
  could be e.g. lack of Energy Model for a given device.
  Return: 0 on success, -EINVAL if any cooling device does not implement
  the power actor API.
  power_allocator_bind() - bind the power_allocator governor to a thermal zone
  @tz:	thermal zone to bind it to
  Initialize the PID controller parameters and bind it to the thermal
  zone.
  Return: 0 on success, or -ENOMEM if we ran out of memory, or -EINVAL
  when there are unsupported cooling devices in the @tz.
	
	  We get called for every trip point but we only need to do
	  our calculations once
 SPDX-License-Identifier: GPL-2.0
   Copyright (C) 2019 Linaro Limited.
   Author: Daniel Lezcano <daniel.lezcano@linaro.org>
  struct cpuidle_cooling_device - data for the idle cooling device
  @ii_dev: an atomic to keep track of the last task exiting the idle cycle
  @state: a normalized integer giving the state of the cooling device
  cpuidle_cooling_runtime - Running time computation
  @idle_duration_us: CPU idle time to inject in microseconds
  @state: a percentile based number
  The running duration is computed from the idle injection duration
  which is fixed. If we reach 100% of idle injection ratio, that
  means the running duration is zero. If we have a 50% ratio
  injection, that means we have equal duration for idle and for
  running duration.
  The formula is deduced as follows:
   running = idle x ((100  ratio) - 1)
  For precision purpose for integer math, we use the following:
   running = (idle x 100)  ratio - idle
  For example, if we have an injected duration of 50%, then we end up
  with 10ms of idle injection and 10ms of running duration.
  Return: An unsigned int for a usec based runtime duration.
  cpuidle_cooling_get_max_state - Get the maximum state
  @cdev  : the thermal cooling device
  @state : a pointer to the state variable to be filled
  The function always returns 100 as the injection ratio. It is
  percentile based for consistency accross different platforms.
  Return: The function can not fail, it is always zero
	
	  Depending on the configuration or the hardware, the running
	  cycle and the idle cycle could be different. We want to
	  unify that to an 0..100 interval, so the set state
	  interface will be the same whatever the platform is.
	 
	  The state 100% will make the cluster 100% ... idle. A 0%
	  injection ratio means no idle injection at all and 50%
	  means for 10ms of idle injection, we have 10ms of running
	  time.
  cpuidle_cooling_get_cur_state - Get the current cooling state
  @cdev: the thermal cooling device
  @state: a pointer to the state
  The function just copies  the state value from the private thermal
  cooling device structure, the mapping is 1 <-> 1.
  Return: The function can not fail, it is always zero
  cpuidle_cooling_set_cur_state - Set the current cooling state
  @cdev: the thermal cooling device
  @state: the target state
  The function checks first if we are initiating the mitigation which
  in turn wakes up all the idle injection tasks belonging to the idle
  cooling device. In any case, it updates the internal state for the
  cooling device.
  Return: The function can not fail, it is always zero
  cpuidle_cooling_ops - thermal cooling device ops
  __cpuidle_cooling_register: register the cooling device
  @drv: a cpuidle driver structure pointer
  @np: a device node structure pointer used for the thermal binding
  This function is in charge of allocating the cpuidle cooling device
  structure, the idle injection, initialize them and register the
  cooling device to the thermal framework.
  Return: zero on success, a negative value returned by one of the
  underlying subsystem in case of error
  cpuidle_cooling_register - Idle cooling device initialization function
  @drv: a cpuidle driver structure pointer
  This function is in charge of creating a cooling device per cpuidle
  driver and register it to the thermal framework.
  Return: zero on success, or negative value corresponding to the
  error detected in the underlying subsystems.
 SPDX-License-Identifier: GPL-2.0
  Thermal sensor driver for Allwinner SOC
  Copyright (C) 2019 Yangtao Li
  Based on the work of Icenowy Zheng <icenowy@aosc.io>
  Based on the work of Ondrej Jirman <megous@megous.com>
  Based on the work of Josef Gajdusek <atx@atx.name>
 millidegree celsius 
 Temp Unit: millidegree Celsius 
 ths have no data yet 
	
	  According to the original sdk, there are some platforms(rarely)
	  that add a fixed offset value after calculating the temperature
	  value. We can't simply put it on the formula for calculating the
	  temperature above, because the formula for calculating the
	  temperature above is also used when the sensor is calibrated. If
	  do this, the correct calibration formula is hard to know.
	
	  efuse layout:
	 
	 	0   11  16	 32
	 	+-------+-------+-------+
	 	|temp|  |sensor0|sensor1|
	 	+-------+-------+-------+
	 
	  The calibration data on the H6 is the ambient temperature and
	  sensor values that are filled during the factory test stage.
	 
	  The unit of stored FT temperature is 0.1 degreee celusis.
	 
	  We need to calculate a delta between measured and caluclated
	  register values and this will become a calibration offset.
		
		  Calibration data is CALIBRATE_DEFAULT - (calculated
		  temperature from sensor reading at factory temperature
		  minus actual factory temperature)  14.88 (scale from
		  temperature to register values)
			
			  Calibration value more than 12-bit, but calibration
			  register is 12-bit. In this case, ths hardware can
			  still work without calibration, although the data
			  won't be so accurate.
		
		  Even if the external calibration data stored in sid is
		  not accessible, the THS hardware can still work, although
		  the data won't be so accurate.
		 
		  The default value of calibration register is 0x800 for
		  every sensor, and the calibration value is usually 0x7xx
		  or 0x8xx, so they won't be away from the default value
		  for a lot.
		 
		  So here we do not return error if the calibration data is
		  not available, except the probe needs deferring.
 average over 4 samples 
	
	  clkin = 24MHz
	  filter_samples = 4
	  period = 0.25s
	 
	  x = period  clkin  4096  filter_samples - 1
	    = 365
	
	  T_acq = 20us
	  clkin = 24MHz
	 
	  x = T_acq  clkin - 1
	    = 479
  Without this undocumented value, the returned temperatures would
  be higher than real ones by about 20C.
	
	  T_acq = 20us
	  clkin = 24MHz
	 
	  x = T_acq  clkin - 1
	    = 479
 average over 4 samples 
	
	  clkin = 24MHz
	  filter_samples = 4
	  period = 0.25s
	 
	  x = period  clkin  4096  filter_samples - 1
	    = 365
 enable sensor 
 thermal data interrupt enable 
	
	  Avoid entering the interrupt handler, the thermal device is not
	  registered yet, we deffer the registration of the interrupt to
	  the end.
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015 MediaTek Inc.
  Author: Hanyi Wu <hanyi.wu@mediatek.com>
          Sascha Hauer <s.hauer@pengutronix.de>
          Dawei Chien <dawei.chien@mediatek.com>
          Louis Yu <louis.yu@mediatek.com>
 AUXADC Registers 
 Thermal Controller Registers 
 MT8173 thermal sensors 
 AUXADC channel 11 is used for the temperature sensors 
 The total number of temperature sensors in the MT8173 
 The number of banks in the MT8173 
 The number of sensing points per bank 
 The number of controller in the MT8173 
 The calibration coefficient of sensor  
  Layout of the fuses providing the calibration data
  These macros could be used for MT8183, MT8173, MT2701, and MT2712.
  MT8183 has 6 sensors and needs 6 VTS calibration data.
  MT8173 has 5 sensors and needs 5 VTS calibration data.
  MT2701 has 3 sensors and needs 3 VTS calibration data.
  MT2712 has 4 sensors and needs 4 VTS calibration data.
  Layout of the fuses providing the calibration data
  These macros could be used for MT7622.
 MT2701 thermal sensors 
 AUXADC channel 11 is used for the temperature sensors 
 The total number of temperature sensors in the MT2701 
 The number of sensing points per bank 
 The number of controller in the MT2701 
 The calibration coefficient of sensor  
 MT2712 thermal sensors 
 AUXADC channel 11 is used for the temperature sensors 
 The total number of temperature sensors in the MT2712 
 The number of sensing points per bank 
 The number of controller in the MT2712 
 The calibration coefficient of sensor  
 The maximum number of banks 
 The calibration coefficient of sensor  
 MT8183 thermal sensors 
 AUXADC channel  is used for the temperature sensors 
 The total number of temperature sensors in the MT8183 
 The number of banks in the MT8183 
 The number of sensing points per bank 
 The number of controller in the MT8183 
 The calibration coefficient of sensor  
 lock: for getting and putting banks 
 Calibration values 
 MT8183 thermal sensor data 
 MT8173 thermal sensor data 
 MT2701 thermal sensor data 
 MT2712 thermal sensor data 
 MT7622 thermal sensor data 
  The MT8173 thermal controller has four banks. Each bank can read up to
  four temperature sensors simultaneously. The MT8173 has a total of 5
  temperature sensors. We use each bank to measure a certain area of the
  SoC. Since TS2 is located centrally in the SoC it is influenced by multiple
  areas, hence is used in different banks.
  The thermal core only gets the maximum temperature of all banks, so
  the bank concept wouldn't be necessary here. However, the SVS (Smart
  Voltage Scaling) unit makes its decisions based on the same bank
  data, and this indeed needs the temperatures of the individual banks
  for making better decisions.
  The MT2701 thermal controller has one bank, which can read up to
  three temperature sensors simultaneously. The MT2701 has a total of 3
  temperature sensors.
  The thermal core only gets the maximum temperature of this one bank,
  so the bank concept wouldn't be necessary here. However, the SVS (Smart
  Voltage Scaling) unit makes its decisions based on the same bank
  data.
  The MT2712 thermal controller has one bank, which can read up to
  four temperature sensors simultaneously. The MT2712 has a total of 4
  temperature sensors.
  The thermal core only gets the maximum temperature of this one bank,
  so the bank concept wouldn't be necessary here. However, the SVS (Smart
  Voltage Scaling) unit makes its decisions based on the same bank
  data.
  MT7622 have only one sensing point which uses AUXADC Channel 11 for raw data
  access.
  The MT8183 thermal controller has one bank for the current SW framework.
  The MT8183 has a total of 6 temperature sensors.
  There are two thermal controller to control the six sensor.
  The first one bind 2 sensor, and the other bind 4 sensors.
  The thermal core only gets the maximum temperature of all sensor, so
  the bank concept wouldn't be necessary here. However, the SVS (Smart
  Voltage Scaling) unit makes its decisions based on the same bank
  data, and this indeed needs the temperatures of the individual banks
  for making better decisions.
  raw_to_mcelsius - convert a raw ADC value to mcelsius
  @mt:	The thermal controller
  @sensno:	sensor number
  @raw:	raw ADC value
  This converts the raw ADC value to mcelsius using the SoC specific
  calibration constants
  mtk_thermal_get_bank - get bank
  @bank:	The bank
  The bank registers are banked, we have to select a bank in the
  PTPCORESEL register to access it.
  mtk_thermal_put_bank - release bank
  @bank:	The bank
  release a bank previously taken with mtk_thermal_get_bank,
  mtk_thermal_bank_temperature - get the temperature of a bank
  @bank:	The bank
  The temperature of a bank is considered the maximum temperature of
  the sensors associated to the bank.
		
		  The first read of a sensor often contains very high bogus
		  temperature value. Filter these out so that the system does
		  not immediately shut down.
 bus clock 66M counting unit is 12  15.15ns  256 = 46.540us 
	
	  filt interval is 1  46.540us = 46.54us,
	  sen interval is 429  46.540us = 19.96ms
 poll is set to 10u 
 temperature sampling control, 1 sample 
 exceed this polling time, IRQ would be inserted 
 number of interrupts per event, 1 is enough 
	
	  The MT8173 thermal controller does not have its own ADC. Instead it
	  uses AHB bus accesses to control the AUXADC. To do this the thermal
	  controller has to be programmed with the physical addresses of the
	  AUXADC registers and with the various bit positions in the AUXADC.
	  Also the thermal controller controls a mux in the APMIXEDSYS register
	  space.
	
	  this value will be stored to TEMP_PNPMUXADDR (TEMP_SPARE0)
	  automatically by hw
 AHB address for auxadc mux selection 
 AHB address for pnp sensor mux selection 
 AHB value for auxadc enable 
 AHB address for auxadc enable (channel 0 immediate mode selected) 
 AHB address for auxadc valid bit 
 AHB address for auxadc voltage output 
 read valid & voltage are at the same register 
 indicate where the valid bit is 
 no shift 
 enable auxadc mux write transaction 
 Start with default values 
 SPDX-License-Identifier: GPL-2.0+
  Amlogic Thermal Sensor Driver
  Copyright (C) 2017 Huan Biao <huan.biao@amlogic.com>
  Copyright (C) 2019 Guillaume La Roque <glaroque@baylibre.com>
  Register value to celsius temperature formulas:
 	Read_Val	    m  U
  U = ---------, Uptat = ---------
 	2^16		  1 + n  U
  Temperature = A  ( Uptat + u_efuse  2^16 )- B
   A B m n : calibration parameters
   u_efuse : fused calibration value, it's a signed 16 bits value
  struct amlogic_thermal_soc_calib_data
  @A: calibration parameters
  @B: calibration parameters
  @m: calibration parameters
  @n: calibration parameters
  This structure is required for configuration of amlogic thermal driver.
  struct amlogic_thermal_data
  @u_efuse_off: register offset to read fused calibration value
  @calibration_parameters: calibration parameters structure pointer
  @regmap_config: regmap config for the device
  This structure is required for configuration of amlogic thermal driver.
  Calculate a temperature value from a temperature code.
  The unit of the temperature is degree milliCelsius.
 sentinel  }
  HiSilicon thermal sensor driver
  Copyright (c) 2014-2015 HiSilicon Limited.
  Copyright (c) 2014-2015 Linaro Limited.
  Xinwei Kong <kong.kongxinwei@hisilicon.com>
  Leo Yan <leo.yan@linaro.org>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
  The temperature computation on the tsensor is as follow:
 	Unit: millidegree Celsius
 	Step: 200255 (0.7843)
 	Temperature base: -60°C
  The register is programmed in temperature steps, every step is 785
  millidegree and begins at -60 000 m°C
  The temperature from the steps:
 	Temp = TempBase + (steps x 785)
  and the steps from the temperature:
 	steps = (Temp - TempBase)  785
  for Hi3660,
 	Step: 189922 (0.205)
 	Temperature base: -63.780°C
  The register is programmed in temperature steps, every step is 205
  millidegree and begins at -63 780 m°C
  The lag register contains 5 bits encoding the temperature in steps.
  Each time the temperature crosses the threshold boundary, an
  interrupt is raised. It could be when the temperature is going
  above the threshold or below. However, if the temperature is
  fluctuating around this value due to the load, we can receive
  several interrupts which may not desired.
  We can setup a temperature representing the delta between the
  threshold and the current temperature when the temperature is
  decreasing.
  For instance: the lag register is 5°C, the threshold is 65°C, when
  the temperature reaches 65°C an interrupt is raised and when the
  temperature decrease to 65°C - 5°C another interrupt is raised.
  A very short lag can lead to an interrupt storm, a long lag
  increase the latency to react to the temperature changes.  In our
  case, that is not really a problem as we are polling the
  temperature.
  [0:4] : lag register
  The temperature is coded in steps, cf. HI6220_TEMP_STEP.
  Min : 0x00 :  0.0 °C
  Max : 0x1F : 24.3 °C
  The 'value' parameter is in milliCelsius.
  [0:6] lag register
  The temperature is coded in steps, cf. HI3660_TEMP_STEP.
  Min : 0x00 :  0.0 °C
  Max : 0x7F : 26.0 °C
  Temperature configuration register - Sensor selection
  Bits [19:12]
  0x0: local sensor (default)
  0x1: remote sensor 1 (ACPU cluster 1)
  0x2: remote sensor 2 (ACPU cluster 0)
  0x3: remote sensor 3 (G3D)
  Temperature configuration register - Hdak conversion polling interval
  Bits [5:4]
  0x0 :   0.768 ms
  0x1 :   6.144 ms
  0x2 :  49.152 ms
  0x3 : 393.216 ms
 disable sensor module 
 disable sensor module 
 enable clock for tsensor 
 disable module firstly 
 select sensor id 
 setting the hdak time 
 setting lag value between current temp and the threshold 
 enable for interrupt 
 enable module 
 disable interrupt 
 setting lag value between current temp and the threshold 
 set interrupt threshold 
 enable interrupt 
 end  }
 SPDX-License-Identifier: GPL-2.0
 Copyright 2016 Freescale Semiconductor, Inc.
 Mode Register 
 Temperature measurement interval Register 
 monitor site register 
 Temperature measurement interval Register 
 Interrupt Enable Register 
 Temperature Configuration Register 
 Sensor Configuration Register 
#define REGS_TRITSR(n)	(0x100 + 16  (n))  Immediate Temperature
					     Site Register
#define REGS_V2_TMSAR(n)	(0x304 + 16  (n))	 TMU monitoring
						 site adjustment register
#define REGS_TTRnCR(n)	(0xf10 + 4  (n))  Temperature Range n
					    Control Register
#define REGS_IPBRR(n)		(0xbf8 + 4  (n))  IP Block Revision
						    Register n
  Thermal zone data
	
	  REGS_TRITSR(id) has the following layout:
	 
	  For TMU Rev1:
	  31  ... 7 6 5 4 3 2 1 0
	   V          TEMP
	 
	  Where V bit signifies if the measurement is ready and is
	  within sensor range. TEMP is an 8 bit value representing
	  temperature in Celsius.
	  For TMU Rev2:
	  31  ... 8 7 6 5 4 3 2 1 0
	   V          TEMP
	 
	  Where V bit signifies if the measurement is ready and is
	  within sensor range. TEMP is an 9 bit value representing
	  temperature in KelVin.
 Init temperature range registers 
 Disable interrupt, using polling instead 
 Set update_interval 
 Disable monitoring 
 Read only registers below 
 version register offset at: 0xbf8 on both v1 and v2 
 TMU initialization 
 TMU calibration 
 Enable monitoring 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014-2016, Fuzhou Rockchip Electronics Co., Ltd
  Caesar Wang <wxt@rock-chips.com>
  If the temperature over a period of time High,
  the resulting TSHUT gave CRU module,let it reset the entire chip,
  or via GPIO give PMIC.
  The system Temperature Sensors tshut(tshut) polarity
  the bit 8 is tshut polarity.
  0: low active, 1: high active
  The system has two Temperature Sensors.
  sensor0 is for CPU, and sensor1 is for GPU.
  The conversion table has the adc value and temperature.
  ADC_DECREMENT: the adc value is of diminishing.(e.g. rk3288_code_table)
  ADC_INCREMENT: the adc value is incremental.(e.g. rk3368_code_table)
  The max sensors is two in rockchip SoCs.
  Two sensors: CPU and GPU sensor.
  struct chip_tsadc_table - hold information about chip-specific differences
  @id: conversion table
  @length: size of conversion table
  @data_mask: mask to apply on data inputs
  @mode: sort mode of this adc variant (incrementing or decrementing)
  struct rockchip_tsadc_chip - hold the private data of tsadc chip
  @chn_id: array of sensor ids of chip corresponding to the channel
  @chn_num: the channel number of tsadc chip
  @tshut_temp: the hardware-controlled shutdown temperature value
  @tshut_mode: the hardware-controlled shutdown mode (0:CRU 1:GPIO)
  @tshut_polarity: the hardware-controlled active polarity (0:LOW 1:HIGH)
  @initialize: SoC special initialize tsadc controller method
  @irq_ack: clear the interrupt
  @control: enabledisable method for the tsadc controller
  @get_temp: get the temperature
  @set_alarm_temp: set the high temperature interrupt
  @set_tshut_temp: set the hardware-controlled shutdown temperature
  @set_tshut_mode: set the hardware-controlled shutdown mode
  @table: the chip-specific conversion table
 The sensor id of chip correspond to the ADC channel 
 The hardware-controlled tshut property 
 Chip-wide methods 
 Per-sensor methods 
 Per-table methods 
  struct rockchip_thermal_sensor - hold the information of thermal sensor
  @thermal:  pointer to the platformconfiguration data
  @tzd: pointer to a thermal zone
  @id: identifier of the thermal sensor
  struct rockchip_thermal_data - hold the private data of thermal driver
  @chip: pointer to the platformconfiguration data
  @pdev: platform device of thermal
  @reset: the reset controller of tsadc
  @sensors: array of thermal sensors
  @clk: the controller clock is divided by the exteral 24MHz
  @pclk: the advanced peripherals bus clock
  @grf: the general register file will be used to do static set by software
  @regs: the base address of tsadc controller
  @tshut_temp: the hardware-controlled shutdown temperature value
  @tshut_mode: the hardware-controlled shutdown mode (0:CRU 1:GPIO)
  @tshut_polarity: the hardware-controlled active polarity (0:LOW 1:HIGH)
  TSADC Sensor Register description:
  TSADCV2_ are used for RK3288 SoCs, the other chips can reuse it.
  TSADCV3_ are used for newer SoCs than RK3288. (e.g: RK3228, RK3399)
 250ms 
 50ms 
 2.5ms 
 2.5ms 
 2.5ms 
 2.5ms 
 13 clocks 
 97us, at least 90us 
  struct tsadc_table - code to temperature conversion table
  @code: the value of adc channel
  @temp: the temperature
  Note:
  code to temperature mapping of the temperature sensor is a piece wise linear
  curve.Any temperature, code faling between to 2 give temperatures can be
  linearly interpolated.
  Code to Temperature mapping should be updated based on manufacturer results.
 ignore the last check for table 
 Return mask code data when the temp is over table range 
	
	  The conversion code granularity provided by the table. Let's
	  assume that the relationship between temperature and
	  analog value between 2 table entries is linear and interpolate
	  to produce less granular result.
 Incorrect reading 
 Incorrect reading 
	
	  The 5C granularity provided by the table is too much. Let's
	  assume that the relationship between sensor readings and
	  temperature between 2 table entries is linear and interpolate
	  to produce less granular result.
  rk_tsadcv2_initialize - initialize TASDC Controller.
  @grf: the general register file will be used to do static set by software
  @regs: the base address of tsadc controller
  @tshut_polarity: the hardware-controlled active polarity (0:LOW 1:HIGH)
  (1) Set TSADC_V2_AUTO_PERIOD:
      Configure the interleave between every two accessing of
      TSADC in normal operation.
  (2) Set TSADCV2_AUTO_PERIOD_HT:
      Configure the interleave between every two accessing of
      TSADC after the temperature is higher than COM_SHUT or COM_INT.
  (3) Set TSADCV2_HIGH_INT_DEBOUNCE and TSADC_HIGHT_TSHUT_DEBOUNCE:
      If the temperature is higher than COMP_INT or COMP_SHUT for
      "debounce" times, TSADC controller will generate interrupt or TSHUT.
  rk_tsadcv3_initialize - initialize TASDC Controller.
  @grf: the general register file will be used to do static set by software
  @regs: the base address of tsadc controller
  @tshut_polarity: the hardware-controlled active polarity (0:LOW 1:HIGH)
  (1) The tsadc control power sequence.
  (2) Set TSADC_V2_AUTO_PERIOD:
      Configure the interleave between every two accessing of
      TSADC in normal operation.
  (2) Set TSADCV2_AUTO_PERIOD_HT:
      Configure the interleave between every two accessing of
      TSADC after the temperature is higher than COM_SHUT or COM_INT.
  (3) Set TSADCV2_HIGH_INT_DEBOUNCE and TSADC_HIGHT_TSHUT_DEBOUNCE:
      If the temperature is higher than COMP_INT or COMP_SHUT for
      "debounce" times, TSADC controller will generate interrupt or TSHUT.
 The tsadc control power sequence 
 Set interleave value to workround ic time sync issue 
 Enable the voltage common mode feature 
 The spec note says at least 15 us 
 The spec note says at least 90 us 
	
	  The general register file will is optional
	  and might not be available.
		
		  RK3568 TRM, section 18.5. requires a delay no less
		  than 10us between the rising edge of tsadc_tsen_en
		  and the rising edge of tsadc_ana_reg_012.
		
		  RK3568 TRM, section 18.5. requires a delay no less
		  than 90us after the rising edge of tsadc_ana_reg_012.
  rk_tsadcv3_control - the tsadc controller is enabled or disabled.
  @regs: the base address of tsadc controller
  @enable: boolean flag to enable the controller
  NOTE: TSADC controller works at auto mode, and some SoCs need set the
  tsadc_q_sel bit on TSADCV2_AUTO_CON[1]. The (1024 - tsadc_q) as output
  adc value if setting this bit to enable.
	
	  In some cases, some sensors didn't need the trip points, the
	  set_trips will pass {-INT_MAX, INT_MAX} to trigger tsadc alarm
	  in the end, ignore this case and disable the high temperature
	  interrupt.
 Make sure the value is valid 
 Make sure the value is valid 
 TSHUT will be valid 
 cpu sensor is channel 0 
 gpu sensor is channel 1 
 2 channels for tsadc 
 default TSHUT via CRU 
 cpu sensor is channel 0 
 one channel for tsadc 
 default TSHUT via GPIO give PMIC 
 default TSHUT LOW ACTIVE 
 cpu sensor is channel 0 
 one channel for tsadc 
 default TSHUT via GPIO give PMIC 
 default TSHUT LOW ACTIVE 
 cpu sensor is channel 1 
 gpu sensor is channel 2 
 two channels for tsadc 
 default TSHUT via GPIO give PMIC 
 default TSHUT LOW ACTIVE 
 cpu sensor is channel 0 
 one channels for tsadc 
 default TSHUT via CRU 
 cpu sensor is channel 0 
 gpu sensor is channel 1 
 two channels for tsadc 
 default TSHUT via GPIO give PMIC 
 default TSHUT LOW ACTIVE 
 cpu sensor is channel 0 
 gpu sensor is channel 1 
 two channels for tsadc 
 default TSHUT via GPIO give PMIC 
 default TSHUT LOW ACTIVE 
 cpu sensor is channel 0 
 gpu sensor is channel 1 
 two channels for tsadc 
 default TSHUT via GPIO give PMIC 
 default TSHUT LOW ACTIVE 
 cpu sensor is channel 0 
 gpu sensor is channel 1 
 two channels for tsadc 
 default TSHUT via GPIO give PMIC 
 default TSHUT LOW ACTIVE 
 end  },
	 The tsadc wont to handle the error in here since some SoCs didn't
	  need this property.
  Reset TSADC Controller, reset all tsadc registers.
  @reset: the reset controller of tsadc
 SPDX-License-Identifier: GPL-2.0
  uniphier_thermal.c - Socionext UniPhier thermal driver
  Copyright 2014      Panasonic Corporation
  Copyright 2016-2017 Socionext Inc.
  Author:
 	Kunihiko Hayashi <hayashi.kunihiko@socionext.com>
  block registers
  addresses are the offset from .block_base
  common registers
  addresses are the offset from .map_base
 SoC critical temperature 
 Max # of alert channels 
 SoC specific thermal sensor data 
 stop PVT 
	
	  Since SoC has a calibrated value that was set in advance,
	  TMODCOEF shows non-zero and PVT refers the value internally.
	 
	  If TMODCOEF shows zero, the boards don't have the calibrated
	  value, and the driver has to set default value from DT.
 look for the default values in DT 
 select temperature mode 
 set monitoring period 
 set monitor mode 
 set alert temperature 
 enable alert interrupt 
 start PVT 
 The spec note says at least 700us 
 disable alert interrupt 
 stop PVT 
 The spec note says at least 1ms 
 MSB of the TMOD field is a sign bit 
 clear alert interrupt 
 get regmap from syscon node 
 parent should be syscon node 
 get trip points 
 set alert temperatures 
 disable sensor 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  Junction temperature thermal driver for Maxim Max77620.
  Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.
  Author: Laxman Dewangan <ldewangan@nvidia.com>
 	   Mallikarjun Kasoju <mkasoju@nvidia.com>
  max77620_thermal_read_temp: Read PMIC die temperatue.
  @data:	Device specific data.
  @temp:	Temperature in millidegrees Celsius
  The actual temperature of PMIC die is not available from PMIC.
  PMIC only tells the status if it has crossed or not the threshold level
  of 120degC or 140degC.
  If threshold has not been crossed then assume die temperature as 100degC
  else 120degC or 140deG based on the PMIC die temp threshold status.
  Return 0 on success otherwise error number to show reason of failure.
	
	  The reference taken to the parent's node which will be balanced on
	  reprobe or on platform-device release.
 SPDX-License-Identifier: GPL-2.0
  TI Bandgap temperature sensor driver for K3 SoC Family
  Copyright (C) 2020 Texas Instruments Incorporated - http:www.ti.com
 common data structures 
	
	  Errata is applicable for am654 pg 1.0 silicon. There
	  is a variation of the order for 8-10 degree centigrade.
	  Work around that by getting the average of two closest
	  readings out of three readings everytime we want to
	  report temperatures.
	 
	  Errata workaround.
 Get the sensor count in the VTM 
 Register the thermal sensors 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
  Dove thermal sensor driver
  Copyright (C) 2013 Andrew Lunn <andrew@lunn.ch>
 Dove Thermal Manager Control and Status Register 
 Dove Theraml Diode Control 0 Register 
 Dove Thermal Diode Control 1 Register 
 Dove Thermal Sensor Dev Structure 
 Configure the Diode Control Register #0 
 Use average of 2 
 Reference calibration value 
 Set the high level reference for calibration 
 Reset the sensor 
 Enable the sensor 
 Poll the sensor for the first reading 
 Valid check 
	
	  Calculate temperature. According to Marvell internal
	  documentation the formula for this is:
	  Celsius = (322-reg)1.3625
 SPDX-License-Identifier: GPL-2.0-only
   user_space.c - A simple user space Thermal events notifier
   Copyright (C) 2012 Intel Corp
   Copyright (C) 2012 Durgadoss R <durgadoss.r@intel.com>
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  notify_user_space - Notifies user space about thermal events
  @tz: thermal_zone_device
  @trip: trip point index
  This function notifies the user space through UEvents.
 SPDX-License-Identifier: GPL-2.0
   linuxdriversthermalcpufreq_cooling.c
   Copyright (C) 2012	Samsung Electronics Co., Ltd(http:www.samsung.com)
   Copyright (C) 2012-2018 Linaro Limited.
   Authors:	Amit Daniel <amit.kachhap@linaro.org>
 		Viresh Kumar <viresh.kumar@linaro.org>
  Cooling state <-> CPUFreq frequency
  Cooling states are translated to frequencies throughout this driver and this
  is the relation between them.
  Highest cooling state corresponds to lowest possible frequency.
  i.e.
 	level 0 --> 1st Max Freq
 	level 1 --> 2nd Max Freq
 	...
  struct time_in_idle - Idle time stats
  @time: previous reading of the absolute time that this cpu was idle
  @timestamp: wall time of the last invocation of get_cpu_idle_time_us()
  struct cpufreq_cooling_device - data for cooling device with cpufreq
  @last_load: load measured by the latest call to cpufreq_get_requested_power()
  @cpufreq_state: integer value representing the current state of cpufreq
 	cooling	devices.
  @max_level: maximum cooling level. One less than total number of valid
 	cpufreq frequencies.
  @em: Reference on the Energy Model of the device
  @cdev: thermal_cooling_device pointer to keep track of the
 	registered cooling device.
  @policy: cpufreq policy.
  @idle_time: idle time stats
  @qos_req: PM QoS contraint to apply
  This structure is required for keeping information of each registered
  cpufreq_cooling_device.
  get_level: Find the level for a particular frequency
  @cpufreq_cdev: cpufreq_cdev for which the property is required
  @freq: Frequency
  Return: level corresponding to the frequency.
  get_load() - get load for a cpu
  @cpufreq_cdev: struct cpufreq_cooling_device for the cpu
  @cpu: cpu number
  @cpu_idx: index of the cpu in time_in_idle array
  Return: The average load of cpu @cpu in percentage since this
  function was last called.
 !CONFIG_SMP 
 CONFIG_SMP 
  get_dynamic_power() - calculate the dynamic power
  @cpufreq_cdev:	&cpufreq_cooling_device for this cdev
  @freq:	current frequency
  Return: the dynamic power consumed by the cpus described by
  @cpufreq_cdev.
  cpufreq_get_requested_power() - get the current power
  @cdev:	&thermal_cooling_device pointer
  @power:	pointer in which to store the resulting power
  Calculate the current power consumption of the cpus in milliwatts
  and store it in @power.  This function should actually calculate
  the requested power, but it's hard to get the frequency that
  cpufreq would have assigned if there were no thermal limits.
  Instead, we calculate the current power on the assumption that the
  immediate future will look like the immediate past.
  We use the current frequency and the average load since this
  function was last called.  In reality, there could have been
  multiple opps since this function was last called and that affects
  the load calculation.  While it's not perfectly accurate, this
  simplification is good enough and works.  REVISIT this, as more
  complex code may be needed if experiments show that it's not
  accurate enough.
  Return: 0 on success, -E if getting the static power failed.
  cpufreq_state2power() - convert a cpu cdev state to power consumed
  @cdev:	&thermal_cooling_device pointer
  @state:	cooling device state to be converted
  @power:	pointer in which to store the resulting power
  Convert cooling device state @state into power consumption in
  milliwatts assuming 100% load.  Store the calculated power in
  @power.
  Return: 0 on success, -EINVAL if the cooling device state could not
  be converted into a frequency or other -E if there was an error
  when calculating the static power.
 Request state should be less than max_level 
  cpufreq_power2state() - convert power to a cooling device state
  @cdev:	&thermal_cooling_device pointer
  @power:	power in milliwatts to be converted
  @state:	pointer in which to store the resulting state
  Calculate a cooling device state for the cpus described by @cdev
  that would allow them to consume at most @power mW and store it in
  @state.  Note that this calculation depends on external factors
  such as the cpu load or the current static power.  Calling this
  function with the same power as input can yield different cooling
  device states depending on those external factors.
  Return: 0 on success, -ENODEV if no cpus are online or -EINVAL if
  the calculated frequency could not be converted to a valid state.
  The latter should not happen unless the frequencies available to
  cpufreq have changed since the initialization of the cpu cooling
  device.
 CONFIG_THERMAL_GOV_POWER_ALLOCATOR 
 CONFIG_SMP 
 Use the Energy Model table if available 
 Otherwise, fallback on the CPUFreq table 
 cpufreq cooling device callback functions are defined below 
  cpufreq_get_max_state - callback function to get the max cooling state.
  @cdev: thermal cooling device pointer.
  @state: fill this variable with the max cooling state.
  Callback for the thermal cooling device to return the cpufreq
  max cooling state.
  Return: 0 on success, an error code otherwise.
  cpufreq_get_cur_state - callback function to get the current cooling state.
  @cdev: thermal cooling device pointer.
  @state: fill this variable with the current cooling state.
  Callback for the thermal cooling device to return the cpufreq
  current cooling state.
  Return: 0 on success, an error code otherwise.
  cpufreq_set_cur_state - callback function to set the current cooling state.
  @cdev: thermal cooling device pointer.
  @state: set this variable to the current cooling state.
  Callback for the thermal cooling device to change the cpufreq
  current cooling state.
  Return: 0 on success, an error code otherwise.
 Request state should be less than max_level 
 Check if the old cooling action is same as new cooling action 
 Bind cpufreq callbacks to thermal cooling device ops 
  __cpufreq_cooling_register - helper function to create cpufreq cooling device
  @np: a valid struct device_node to the cooling device device tree node
  @policy: cpufreq policy
  Normally this should be same as cpufreq policy->related_cpus.
  @em: Energy Model of the cpufreq policy
  This interface function registers the cpufreq cooling device with the name
  "thermal-cpufreq-%x". This api can support multiple instances of cpufreq
  cooling devices. It also gives the opportunity to link the cooling device
  with a device tree node, in order to bind it via the thermal DT code.
  Return: a valid struct thermal_cooling_device pointer on success,
  on failure, it returns a corresponding ERR_PTR().
 max_level is an index, not a counter 
  cpufreq_cooling_register - function to create cpufreq cooling device.
  @policy: cpufreq policy
  This interface function registers the cpufreq cooling device with the name
  "thermal-cpufreq-%x". This api can support multiple instances of cpufreq
  cooling devices.
  Return: a valid struct thermal_cooling_device pointer on success,
  on failure, it returns a corresponding ERR_PTR().
  of_cpufreq_cooling_register - function to create cpufreq cooling device.
  @policy: cpufreq policy
  This interface function registers the cpufreq cooling device with the name
  "thermal-cpufreq-%x". This api can support multiple instances of cpufreq
  cooling devices. Using this API, the cpufreq cooling device will be
  linked to the device tree node provided.
  Using this function, the cooling device will implement the power
  extensions by using a simple cpu power model.  The cpus must have
  registered their OPPs using the OPP library.
  It also takes into account, if property present in policy CPU node, the
  static power consumed by the cpu.
  Return: a valid struct thermal_cooling_device pointer on success,
  and NULL on failure.
  cpufreq_cooling_unregister - function to remove cpufreq cooling device.
  @cdev: thermal cooling device pointer.
  This interface function unregisters the "thermal-cpufreq-%x" cooling device.
 SPDX-License-Identifier: GPL-2.0
   thermal_helpers.c - helper functions to handle thermal devices
   Copyright (C) 2016 Eduardo Valentin <edubezval@gmail.com>
   Highly based on original thermal_core.c
   Copyright (C) 2008 Intel Corp
   Copyright (C) 2008 Zhang Rui <rui.zhang@intel.com>
   Copyright (C) 2008 Sujith Thomas <sujith.thomas@intel.com>
  thermal_zone_get_temp() - returns the temperature of a thermal zone
  @tz: a valid pointer to a struct thermal_zone_device
  @temp: a valid pointer to where to store the resulting temperature.
  When a valid thermal zone reference is passed, it will fetch its
  temperature and fill @temp.
  Return: On success returns 0, an error code otherwise
		
		  Only allow emulating a temperature when the real temperature
		  is below the critical temperature so that the emulation code
		  cannot hide critical conditions.
  thermal_zone_set_trips - Computes the next trip points for the driver
  @tz: a pointer to a thermal zone device structure
  The function computes the next temperature boundaries by browsing
  the trip points. The result is the closer low and high trip points
  to the current temperature. These values are passed to the backend
  driver to let it set its own notification mechanism (usually an
  interrupt).
  It does not return a value
 No need to change trip points 
	
	  Set a temperature window. When this window is left the driver
	  must inform the thermal core via thermal_zone_device_update.
 Make sure cdev enters the deepest cooling state 
  thermal_cdev_update - update cooling device state if needed
  @cdev:	pointer to struct thermal_cooling_device
  Update the cooling device state if there is a need.
  thermal_zone_get_slope - return the slope attribute of the thermal zone
  @tz: thermal zone device with the slope attribute
  Return: If the thermal zone device has a slope attribute, return it, else
  return 1.
  thermal_zone_get_offset - return the offset attribute of the thermal zone
  @tz: thermal zone device with the offset attribute
  Return: If the thermal zone device has a offset attribute, return it, else
  return 0.
 SPDX-License-Identifier: GPL-2.0
   of-thermal.c - Generic Thermal Management device tree support.
   Copyright (C) 2013 Texas Instruments
   Copyright (C) 2013 Eduardo Valentin <eduardo.valentin@ti.com>
   Private data structures to represent thermal device tree data 
  struct __thermal_cooling_bind_param - a cooling device for a trip point
  @cooling_device: a pointer to identify the referred cooling device
  @min: minimum cooling state used at this trip point
  @max: maximum cooling state used at this trip point
  struct __thermal_bind_param - a match between trip and cooling device
  @tcbp: a pointer to an array of cooling devices
  @count: number of elements in array
  @trip_id: the trip point index
  @usage: the percentage (from 0 to 100) of cooling contribution
  struct __thermal_zone - internal representation of a thermal zone
  @passive_delay: polling interval while passive cooling is activated
  @polling_delay: zone polling interval
  @slope: slope of the temperature adjustment curve
  @offset: offset of the temperature adjustment curve
  @ntrips: number of trip points
  @trips: an array of trip points (0..ntrips - 1)
  @num_tbps: number of thermal bind params
  @tbps: an array of thermal bind params (0..num_tbps - 1)
  @sensor_data: sensor private data used while reading temperature and trend
  @ops: set of callbacks to handle the thermal zone based on DT
 trip data 
 cooling binding data 
 sensor interface 
   DT thermal zone device callbacks   
  of_thermal_get_ntrips - function to export number of available trip
 			   points.
  @tz: pointer to a thermal zone
  This function is a globally visible wrapper to get number of trip points
  stored in the local struct __thermal_zone
  Return: number of available trip points, -ENODEV when data not available
  of_thermal_is_trip_valid - function to check if trip point is valid
  @tz:	pointer to a thermal zone
  @trip:	trip point to evaluate
  This function is responsible for checking if passed trip point is valid
  Return: true if trip point is valid, false otherwise
  of_thermal_get_trip_points - function to get access to a globally exported
 				trip points
  @tz:	pointer to a thermal zone
  This function provides a pointer to trip points table
  Return: pointer to trip points table, NULL otherwise
  of_thermal_set_emul_temp - function to set emulated temperature
  @tz:	pointer to a thermal zone
  @temp:	temperature to set
  This function gives the ability to set emulated value of temperature,
  which is handy for debugging
  Return: zero on success, error code otherwise
 find where to bind 
 find where to unbind 
 thermal framework should take care of data->mask & (1 << trip) 
 thermal framework should take care of data->mask & (1 << trip) 
   sensor API   
	
	  The thermal zone core will calculate the window if they have set the
	  optional set_trips pointer.
  thermal_zone_of_get_sensor_id - get sensor ID from a DT thermal zone
  @tz_np: a valid thermal zone device node.
  @sensor_np: a sensor node of a valid sensor device.
  @id: the sensor ID returned if success.
  This function will get sensor ID from a given thermal zone node and
  the sensor node must match the temperature provider @sensor_np.
  Return: 0 on success, proper error code otherwise.
  thermal_zone_of_sensor_register - registers a sensor to a DT thermal zone
  @dev: a valid struct device pointer of a sensor device. Must contain
        a valid .of_node, for the sensor node.
  @sensor_id: a sensor identifier, in case the sensor IP has more
              than one sensors
  @data: a private pointer (owned by the caller) that will be passed
         back, when a temperature reading is needed.
  @ops: struct thermal_zone_of_device_ops . Must contain at least .get_temp.
  This function will search the list of thermal zones described in device
  tree and look for the zone that refer to the sensor device pointed by
  @dev->of_node as temperature providers. For the zone pointing to the
  sensor node, the sensor will be added to the DT thermal zone device.
  The thermal zone temperature is provided by the @get_temp function
  pointer. When called, it will have the private pointer @data back.
  The thermal zone temperature trend is provided by the @get_trend function
  pointer. When called, it will have the private pointer @data back.
  TODO:
  01 - This function must enqueue the new sensor instead of using
  it as the only source of temperature values.
  02 - There must be a way to match the sensor with all thermal zones
  that refer to it.
  Return: On success returns a valid struct thermal_zone_device,
  otherwise, it returns a corresponding ERR_PTR(). Caller must
  check the return value with help of IS_ERR() helper.
 For now, thermal framework supports only 1 sensor per zone 
  thermal_zone_of_sensor_unregister - unregisters a sensor from a DT thermal zone
  @dev: a valid struct device pointer of a sensor device. Must contain
        a valid .of_node, for the sensor node.
  @tzd: a pointer to struct thermal_zone_device where the sensor is registered.
  This function removes the sensor callbacks and private data from the
  thermal zone device registered with thermal_zone_of_sensor_register()
  API. It will also silent the zone by remove the .get_temp() and .get_trend()
  thermal zone device callbacks.
  TODO: When the support to several sensors per zone is added, this
  function must search the sensor list based on @dev parameter.
 no __thermal_zone, nothing to be done 
 stop temperature polling 
  devm_thermal_zone_of_sensor_register - Resource managed version of
 				thermal_zone_of_sensor_register()
  @dev: a valid struct device pointer of a sensor device. Must contain
        a valid .of_node, for the sensor node.
  @sensor_id: a sensor identifier, in case the sensor IP has more
 	       than one sensors
  @data: a private pointer (owned by the caller) that will be passed
 	  back, when a temperature reading is needed.
  @ops: struct thermal_zone_of_device_ops . Must contain at least .get_temp.
  Refer thermal_zone_of_sensor_register() for more details.
  Return: On success returns a valid struct thermal_zone_device,
  otherwise, it returns a corresponding ERR_PTR(). Caller must
  check the return value with help of IS_ERR() helper.
  Registered thermal_zone_device device will automatically be
  released when device is unbounded.
  devm_thermal_zone_of_sensor_unregister - Resource managed version of
 				thermal_zone_of_sensor_unregister().
  @dev: Device for which which resource was allocated.
  @tzd: a pointer to struct thermal_zone_device where the sensor is registered.
  This function removes the sensor callbacks and private data from the
  thermal zone device registered with devm_thermal_zone_of_sensor_register()
  API. It will also silent the zone by remove the .get_temp() and .get_trend()
  thermal zone device callbacks.
  Normally this function will not need to be called and the resource
  management code will ensure that the resource is freed.
   functions parsing device tree nodes   
  thermal_of_populate_bind_params - parse and fill cooling map data
  @np: DT node containing a cooling-map node
  @__tbp: data structure to be filled with cooling map info
  @trips: array of thermal zone trip points
  @ntrips: number of trip points inside trips.
  This function parses a cooling-map type of node represented by
  @np parameter and fills the read data into @__tbp data structure.
  It needs the already parsed array of trip points of the thermal zone
  in consideration.
  Return: 0 on success, proper error code otherwise
 Default weight. Usage is optional 
 match using device_node 
 at least min and max 
  It maps 'enum thermal_trip_type' found in includelinuxthermal.h
  into the device tree binding of 'trip', property type.
  thermal_of_get_trip_type - Get phy mode for given device_node
  @np:	Pointer to the given device_node
  @type: Pointer to resulting trip type
  The function gets trip type string from property 'type',
  and store its index in trip_types table in @type,
  Return: 0 on success, or errno in error case.
  thermal_of_populate_trip - parse and fill one trip point data
  @np: DT node containing a trip point node
  @trip: trip point data structure to be filled up
  This function parses a trip point type of node represented by
  @np parameter and fills the read data into @trip data structure.
  Return: 0 on success, proper error code otherwise
 Required for cooling map matching 
  thermal_of_build_thermal_zone - parse and fill one thermal zone data
  @np: DT node containing a thermal zone node
  This function parses a thermal zone type of node represented by
  @np parameter and fills the read data into a __thermal_zone data structure
  and return this pointer.
  TODO: Missing properties to parse: thermal-sensor-names
  Return: On success returns a valid struct __thermal_zone,
  otherwise, it returns a corresponding ERR_PTR(). Caller must
  check the return value with help of IS_ERR() helper.
	
	  REVIST: for now, the thermal framework supports only
	  one sensor per thermal zone. Thus, we are considering
	  only the first two values as slope and offset.
 trips 
 No trips provided 
 must have at least one child 
 cooling-maps 
 cooling-maps not provided 
  of_thermal_destroy_zones - remove all zones parsed and allocated resources
  Finds all zones parsed and added to the thermal framework and remove them
  from the system, together with their resources.
  of_parse_thermal_zones - parse device tree thermal data
  Initialization function that can be called by machine initialization
  code to parse thermal data and populate the thermal framework
  with hardware thermal zones info. This function only parses thermal zones.
  Cooling devices and sensor devices nodes are supposed to be parsed
  by their respective drivers.
  Return: 0 on success, proper error code otherwise
 Run successfully on systems without thermal DT 
 No hwmon because there might be hwmon drivers registering 
 these two are left for temperature drivers to use 
 attempting to build remaining zones still 
 no memory available, so free what we have built 
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2018-2020 NXP.
 SPDX-License-Identifier: GPL-2.0+
  Broadcom AVS RO thermal sensor driver
  based on brcmstb_thermal
  Copyright (C) 2020 Stefan Wahren
 Convert a HW code to a temperature reading (millidegree celsius) 
 get regmap from syscon node 
 parent should be syscon node 
 SPDX-License-Identifier: GPL-2.0-only
  Broadcom STB AVS TMON thermal sensor driver
  Copyright (c) 2015-2017 Broadcom
 Default coefficients 
 HW related temperature constants 
 HW bit to enable the trip 
 HW field to read the trip temperature 
 Trips when temperature is below threshold 
 Trips when temperature is above threshold 
 Automatically resets chip when above threshold 
 Process specific thermal parameters used for calculations 
 Convert a HW code to a temperature reading (millidegree celsius) 
  Convert a temperature value (millidegree celsius) to a HW code
  @temp: temperature to convert
  @low: if true, round toward the low side
 Maximum code value 
 Minimum code value 
 round toward low temp for the low interrupt 
 Disable high-temp until next threshold shift 
 Disable low-temp until next threshold shift 
	
	  Notify using the interrupt temperature, in case the temperature
	  changes before it can next be read out
	
	  Disable low-temp if "low" is too small. As per thermal framework
	  API, we use -INT_MAX rather than INT_MIN.
 Disable high-temp if "high" is too big. 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2017 Rafał Miłecki <rafal@milecki.pl>
 Clear current mode selection 
 Set temp monitor mode (it's the default actually) 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018 Broadcom
  In stingray thermal IO memory,
  Total Number of available TMONs MASK is at offset 0
  temperature registers BASE is at 4 byte offset.
  Each TMON temperature register size is 4.
 Flush temperature registers 
 SPDX-License-Identifier: GPL-2.0+
  Driver for Broadcom BCM2835 SoC temperature sensor
  Copyright (C) 2016 Martin Sperl
  bandgap reference voltage in 6 mV increments
  000b = 1178 mV, 001b = 1184 mV, ... 111b = 1220 mV
  time how long the block to be asserted in reset
  which based on a clock counter (TSENS clock assumed)
  Note: as per Raspberry Foundation FAQ
  (https:www.raspberrypi.orghelpfaqs#performanceOperatingTemperature)
  the recommended temperature range for the SoC -40C to +85C
  so the trip limit is set to 80C.
  this applies to all the BCM283X SoC
 register of thermal sensor and get info from DT 
	
	  right now the FW does set up the HW-block, so we are not
	  touching the configuration registers.
	  But if the HW is not enabled, then set it up
	  using "sane" values used by the firmware right now.
		
		  For now we deal only with critical, otherwise
		  would need to iterate
 set bandgap reference voltage and enable voltage regulator 
 use the recommended reset duration 
  trip_adc value from info 
 write the value back to the register as 2 steps 
	
	  Thermal_zone doesn't enable hwmon as default,
	  enable it here
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2015, The Linux Foundation. All rights reserved.
  Copyright (c) 2018, Linaro Limited
 ----- SROT ------ 
 ----- TM ------ 
 v2.x: 8996, 8998, sdm845 
 ----- SROT ------ 
 VERSION 
 CTRL_OFF 
 ----- TM ------ 
 INTERRUPT ENABLE 
 v2 has separate enables for UPPERLOWERCRITICAL interrupts 
 TEMPERATURE THRESHOLDS 
 INTERRUPTS [CLEARSTATUSMASK] 
 WATCHDOG on v2.3 or later 
 Sn_STATUS 
 xxx_STATUS bits: 1 == threshold violated 
 TRDY: 1=ready, 0=in progress 
 Kept around for backward compatibility with old msm8996.dtsi 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2015, The Linux Foundation. All rights reserved.
 ----- SROT ------ 
 ----- TM ------ 
 eeprom layout data for 8916 
 eeprom layout data for 8939 
 eeprom layout data for 8974 
 eeprom layout data for mdm9607 
 Mapping between qfprom nvmem and calibration data 
 v0.1: 8916, 8939, 8974, 9607 
 ----- SROT ------ 
 No VERSION information 
 CTRL_OFFSET 
 ----- TM ------ 
 INTERRUPT ENABLE 
 UPPERLOWER TEMPERATURE THRESHOLDS 
 UPPERLOWER INTERRUPTS [CLEARSTATUS] 
 NO CRITICAL INTERRUPT SUPPORT on v0.1 
 Sn_STATUS 
 No VALID field on v0.1 
 xxx_STATUS bits: 1 == threshold violated 
 No CRITICAL field on v0.1 
 TRDY: 1=ready, 0=in progress 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2015, The Linux Foundation. All rights reserved.
  Copyright (c) 2019, 2020, Linaro Ltd.
  struct tsens_irq_data - IRQ status and temperature violations
  @up_viol:        upper threshold violated
  @up_thresh:      upper threshold temperature value
  @up_irq_mask:    mask register for upper threshold irqs
  @up_irq_clear:   clear register for uppper threshold irqs
  @low_viol:       lower threshold violated
  @low_thresh:     lower threshold temperature value
  @low_irq_mask:   mask register for lower threshold irqs
  @low_irq_clear:  clear register for lower threshold irqs
  @crit_viol:      critical threshold violated
  @crit_thresh:    critical threshold temperature value
  @crit_irq_mask:  mask register for critical threshold irqs
  @crit_irq_clear: clear register for critical threshold irqs
  Structure containing data about temperature threshold settings and
  irq status if they were violated.
  Use this function on devices where slope and offset calculations
  depend on calibration data read from qfprom. On others the slope
  and offset values are derived from tz->tzp->slope and tz->tzp->offset
  resp.
			
			  slope (m) = adc_code2 - adc_code1 (y2 - y1)
			 	temp_120_degc - temp_30_degc (x2 - x1)
  tsens_hw_to_mC - Return sign-extended temperature in mCelsius.
  @s:     Pointer to sensor struct
  @field: Index into regmap_field array pointing to temperature data
  This function handles temperature returned in ADC code or deciCelsius
  depending on IP version.
  Return: Temperature in milliCelsius on success, a negative errno will
  be returned in error cases
 Convert temperature from ADC code to milliCelsius 
 deciCelsius -> milliCelsius along with sign extension 
  tsens_mC_to_hw - Convert temperature to hardware register value
  @s: Pointer to sensor struct
  @temp: temperature in milliCelsius to be programmed to hardware
  This function outputs the value to be written to hardware in ADC code
  or deciCelsius depending on IP version.
  Return: ADC code or temperature in deciCelsius.
 milliC to adc code 
 milliC to deciC 
 No critical interrupts before v2 
	
	  To enable the interrupt flag for a sensor:
	     - clear the mask bit
	  To disable the interrupt flag for a sensor:
	     - Mask further interrupts for this sensor
	     - Write 1 followed by 0 to clear the interrupt
  tsens_set_interrupt - Set state of an interrupt
  @priv: Pointer to tsens controller private data
  @hw_id: Hardware ID aka. sensor number
  @irq_type: irq_type from enum tsens_irq_type
  @enable: false = disable, true = enable
  Call IP-specific function to set state of an interrupt
  Return: void
  tsens_threshold_violated - Check if a sensor temperature violated a preset threshold
  @priv: Pointer to tsens controller private data
  @hw_id: Hardware ID aka. sensor number
  @d: Pointer to irq state data
  Return: 0 if threshold was not violated, 1 if it was violated and negative
  errno in case of errors
 No mask register on older TSENS 
 v1, v0.1 don't have a irq mask register 
  tsens_critical_irq_thread() - Threaded handler for critical interrupts
  @irq: irq number
  @data: tsens controller private data
  Check FSM watchdog bark status and clear if needed.
  Check all sensors to find ones that violated their critical threshold limits.
  Clear and then re-enable the interrupt.
  The level-triggered interrupt might deassert if the temperature returned to
  within the threshold limits by the time the handler got scheduled. We
  consider the irq to have been handled in that case.
  Return: IRQ_HANDLED
 Clear WDOG interrupt 
 Fall through to handle critical interrupts if any 
 Mask critical interrupts, unused on Linux 
  tsens_irq_thread - Threaded interrupt handler for uplow interrupts
  @irq: irq number
  @data: tsens controller private data
  Check all sensors to find ones that violated their threshold limits. If the
  temperature is still outside the limits, call thermal_zone_device_update() to
  update the thresholds, else re-enable the interrupts.
  The level-triggered interrupt might deassert if the temperature returned to
  within the threshold limits by the time the handler got scheduled. We
  consider the irq to have been handled in that case.
  Return: IRQ_HANDLED
 Keep irq masked 
 Keep irq masked 
			 Constraint: There is only 1 interrupt control register for all
			  11 temperature sensor. So monitoring more than 1 sensor based
			  on interrupts will yield inconsistent result. To overcome this
			  issue we will monitor only sensor 0 which is the master sensor.
		 Pre v0.1 IP had a single register for each type of interrupt
		  and thresholds
 Write the new thresholds and clear the status 
 VER_0 doesn't have VALID bit 
	 Valid bit is 0 for 6 AHB clock cycles.
	  At 19.2MHz, 1 AHB clock is ~60ns.
	  We should enter this loop very, very rarely.
	  Wait 1 us since it's the min of poll_timeout macro.
	  Old value was 400 ns.
 Valid bit is set, OK to read the temperature 
 A directory for each instance of the TSENS IP 
 DT with separate SROT and TM address space 
 old DTs where SROT and TM were in a contiguous 2K block 
 VER_0 share the same gcc regs using a syscon 
 VER_0 have only tm_map 
 in VER_0 TSENS need to be explicitly enabled 
 This loop might need changes if enum regfield_ids is reordered 
 Loop might need changes if enum regfield_ids is reordered 
 Watchdog is present only on v2.3+ 
		
		  Watchdog is already enabled, unmask the bark.
		  Disable cycle completion monitoring
 VER_0 interrupt doesn't need to be enabled 
 For old DTs with no IRQ defined 
 VER_0 interrupt is TRIGGER_RISING, VER_0_1 and up is ONESHOT 
	 VER_0 require to set MIN and MAX THRESH
	  These 2 regs are set using the:
	  - CRIT_THRESH_0 for MAX THRESH hardcoded to 120°C
	  - CRIT_THRESH_1 for MIN THRESH hardcoded to   0°C
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2019, Linaro Limited
 ----- SROT ------ 
 ----- TM ------ 
 eeprom layout data for msm895676 (v1) 
 eeprom layout data for qcs404405 (v1) 
 This value is split over two registers, 2 bits and 4 bits 
 This value is split over two registers, 2 bits and 4 bits 
 v1.x: msm8956,8976,qcs404,405 
 ----- SROT ------ 
 VERSION 
 CTRL_OFFSET 
 ----- TM ------ 
 INTERRUPT ENABLE 
 UPPERLOWER TEMPERATURE THRESHOLDS 
 UPPERLOWER INTERRUPTS [CLEARSTATUS] 
 NO CRITICAL INTERRUPT SUPPORT on v1 
 Sn_STATUS 
 xxx_STATUS bits: 1 == threshold violated 
 No CRITICAL field on v1.x 
 TRDY: 1=ready, 0=in progress 
 Valid for both MSM8956 and MSM8976. 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2020 Linaro Limited
  Based on original driver:
  Copyright (c) 2012-2020, The Linux Foundation. All rights reserved.
  Thermal monitoring block consists of 8 (ADC_TM5_NUM_CHANNELS) channels. Each
  channel is programmed to use one of ADC channels for voltage comparison.
  Voltages are programmed using ADC codes, so we have to convert temp to
  voltage and then to ADC code value.
  Configuration of TM channels must match configuration of corresponding ADC
  channels.
 3.9ms 
 1 second 
 4 second 
  struct adc_tm5_channel - ADC Thermal Monitoring channel data.
  @channel: channel number.
  @adc_channel: corresponding ADC channel number.
  @cal_method: calibration method.
  @prescale: channel scaling performed on the input signal.
  @hw_settle_time: the time between AMUX being configured and the
 	start of conversion.
  @iio: IIO channel instance used by this channel.
  @chip: ADC TM chip instance.
  @tzd: thermal zone device used by this channel.
  struct adc_tm5_chip - ADC Thermal Monitoring properties
  @regmap: SPMI ADC5 Thermal Monitoring  peripheral register map field.
  @dev: SPMI ADC5 device.
  @data: software configuration data.
  @channels: array of ADC TM channel data.
  @nchannels: amount of channels definedallocated
  @decimation: sampling rate supported for the channel.
  @avg_samples: ability to provide single result from the ADC
 	that is an average of multiple measurements.
  @base: base address of TM registers.
 No TZD, we warned at the boot time 
 High temperature corresponds to low voltage threshold 
 Low temperature corresponds to high voltage threshold 
 Set calibration select, hw_settle delay 
	
	  We are tied to PMIC's ADC controller, which always use single
	  argument for channel number.  So don't bother parsing
	  #io-channel-cells, just enforce cell_count = 1.
 1:1 prescale is index 0 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2015, The Linux Foundation. All rights reserved.
 CONFIG_ADDR bitmasks 
 CNTL_ADDR bitmasks 
 Sensors 5-10 found on apq8064msm8960 
 Original slope - 350 to compensate mC to C inaccuracy 
	
	  Separate CONFIG restore is not needed only for 8660 as
	  config is part of CTRL Addr and its restored as such
	 HARDWARE BUG:
	  On platforms with more than 6 sensors, all remaining sensors
	  must be enabled together, otherwise undefined results are expected.
	  (Sensor 6-7 disabled, Sensor 3 disabled...) In the original driver,
	  all the sensors are enabled in one step hence this bug is not
	  triggered.
 Sensors already enabled. Skip. 
 ----- SROT ------ 
 No VERSION information 
 CNTL 
 8960 has 5 sensors, 8660 has 11, we only handle 5 
 ----- TM ------ 
 INTERRUPT ENABLE 
 NO INTERRUPT ENABLE 
 Single UPPERLOWER TEMPERATURE THRESHOLD for all sensors 
	 MIN_THRESH_0 and MAX_THRESH_0 are not present in the regfield
	  Recycle CRIT_THRESH_0 and 1 to set the required regs to hardcoded temp
	  MIN_THRESH_0 -> CRIT_THRESH_1
	  MAX_THRESH_0 -> CRIT_THRESH_0
 UPPERLOWER INTERRUPT [CLEARSTATUS] 
 1 == clear, 0 == normal operation 
 NO CRITICAL INTERRUPT SUPPORT on 8960 
 Sn_STATUS 
 No VALID field on 8960 
 TSENS_INT_STATUS bits: 1 == threshold violated 
 No CRITICAL field on 8960 
 TRDY: 1=ready, 0=in progress 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2021, Linaro Limited. All rights reserved.
 Call the cpufreq driver to handle the interrupt 
 Clear the existing interrupt 
	
	  Only sdm845 has lmh hardware currently enabled from hlos. If this is needed
	  for other platforms, revisit this to check if the <cpu-id, node-id> should be part
	  of a dt match table.
 Set default thermal trips 
 Disable the irq and let cpufreq enable it when ready to handle the interrupt 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2011-2015, 2017, 2020, The Linux Foundation. All rights reserved.
 Over-temperature trip point values in mC 
 Threshold step: 5 C 
 Temperature in Milli Celsius reported during stage 0 if no ADC is present 
 protects .thresh, .stage and chip registers 
 This array maps from GEN2 alarm state to GEN1 alarm stage 
  qpnp_tm_decode_temp() - return temperature in mC corresponding to the
 		specified over-temperature stage
  @chip:		Pointer to the qpnp_tm chip
  @stage:		Over-temperature stage
  Return: temperature in mC
  qpnp_tm_get_temp_stage() - return over-temperature stage
  @chip:		Pointer to the qpnp_tm chip
  Return: stage (GEN1) or state (GEN2) on success, or errno on failure.
  This function updates the internal temp value based on the
  current thermal stage and threshold as well as the previous stage
 increasing stage, use lower bound 
 decreasing stage, use upper bound 
	
	  Default: S2 and S3 shutdown enabled, thresholds at
	  lowest threshold set, monitoring at 25Hz
  This function initializes the internal temp value based on only the
  current thermal stage and threshold. Setup threshold control and
  disable shutdown override.
 Enable the thermal alarm PMIC module in always-on mode. 
 ADC based measurements are optional 
	
	  Register the sensor before initializing the hardware to be able to
	  read the trip points. get_temp() returns the default temperature
	  before the hardware initialization is completed.
 SPDX-License-Identifier: GPL-2.0-or-later
  exynos_tmu.c - Samsung Exynos TMU (Thermal Management Unit)
   Copyright (C) 2014 Samsung Electronics
   Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
   Lukasz Majewski <l.majewski@samsung.com>
   Copyright (C) 2011 Samsung Electronics
   Donggeun Kim <dg77.kim@samsung.com>
   Amit Daniel Kachhap <amit.kachhap@linaro.org>
 Exynos generic registers 
 Exynos3250 specific registers 
 Exynos4210 specific registers 
 Exynos5250, Exynos4412, Exynos3250 specific registers 
 Exynos5260 specific 
 Exynos4412 specific 
 Exynos5433 specific registers 
 Exynos7 specific registers 
  struct exynos_tmu_data : A structure to hold the private data of the TMU
 			    driver
  @id: identifier of the one instance of the TMU controller.
  @base: base address of the single instance of the TMU controller.
  @base_second: base address of the common registers of the TMU controller.
  @irq: irq number of the TMU controller.
  @soc: id of the SOC type.
  @irq_work: pointer to the irq work structure.
  @lock: lock to implement synchronization.
  @clk: pointer to the clock structure.
  @clk_sec: pointer to the clock structure for accessing the base_second.
  @sclk: pointer to the clock structure for accessing the tmu special clk.
  @cal_type: calibration type for temperature
  @efuse_value: SoC defined fuse value
  @min_efuse_value: minimum valid trimming data
  @max_efuse_value: maximum valid trimming data
  @temp_error1: fused value of the first point trim.
  @temp_error2: fused value of the second point trim.
  @gain: gain of amplifier in the positive-TC generator block
 	0 < gain <= 15
  @reference_voltage: reference voltage of amplifier
 	in the positive-TC generator block
 	0 < reference_voltage <= 31
  @regulator: pointer to the TMU regulator structure.
  @reg_conf: pointer to structure to register with core thermal.
  @tzd: pointer to thermal_zone_device structure
  @ntrip: number of supported trip points.
  @enabled: current status of TMU device
  @tmu_set_trip_temp: SoC specific method to set trip (rising threshold)
  @tmu_set_trip_hyst: SoC specific to set hysteresis (falling threshold)
  @tmu_initialize: SoC specific TMU initialization method
  @tmu_control: SoC specific TMU control method
  @tmu_read: SoC specific TMU temperature read method
  @tmu_set_emulation: SoC specific TMU emulation setting method
  @tmu_clear_irqs: SoC specific TMU interrupts clearing method
  TMU treats temperature as a mapped temperature code.
  The temperature is converted differently depending on the calibration type.
  Calculate a temperature value from a temperature code.
  The unit of the temperature is degree Celsius.
 FIXME 
 Write temperature code for rising and falling threshold 
 Write temperature code for rising threshold 
 Write temperature code for falling threshold 
 failing thresholds are not supported on Exynos4210 
 On exynos5420 the triminfo register is in the shared space 
 Read the temperature sensor id 
 Read the calibration mode 
		
		  Called too early, probably
		  from thermal_zone_of_sensor_register().
 CONFIG_THERMAL_EMULATION 
 "temp_code" should range between 75 and 175 
 TODO: take action based on particular interrupt 
	
	  Clear the interrupts.  Please note that the documentation for
	  Exynos3250, Exynos4412, Exynos5250 and Exynos5260 incorrectly
	  states that INTCLEAR register has a different placing of bits
	  responsible for FALL IRQs than INTSTAT register.  Exynos5420
	  and Exynos5440 documentation is correct (Exynos4210 doesn't
	  support FALL IRQs at all).
	
	  Check if the TMU shares some registers and then try to map the
	  memory of common registers.
	
	  Try enabling the regulator if found
	  TODO: Add regulator as an SOC feature, so that regulator enable
	  is a compulsory call.
	
	  data->tzd must be registered before calling exynos_tmu_initialize(),
	  requesting irq and calling exynos_tmu_control().
 SPDX-License-Identifier: GPL-2.0-only
  OMAP4 thermal driver.
  Copyright (C) 2011-2012 Texas Instruments Inc.
  Contact:
 	Eduardo Valentin <eduardo.valentin@ti.com>
  OMAP4430 has one instance of thermal sensor for MPU
  need to describe the individual bit fields
 Thresholds and limits for OMAP4430 MPU temperature sensor 
  Temperature values in milli degree celsius
  ADC code values from 13 to 107, see TRM
  "18.4.10.2.3 ADC Codes Versus Temperature".
 OMAP4430 data 
  OMAP4460 has one instance of thermal sensor for MPU
  need to describe the individual bit fields
 Thresholds and limits for OMAP4460 MPU temperature sensor 
  Temperature values in milli degree celsius
  ADC code values from 530 to 923
 OMAP4460 data 
 OMAP4470 data 
 SPDX-License-Identifier: GPL-2.0-only
  DRA752 thermal data.
  Copyright (C) 2013 Texas Instruments Inc.
  Contact:
 	Eduardo Valentin <eduardo.valentin@ti.com>
 	Tero Kristo <t-kristo@ti.com>
  This file is partially autogenerated.
  DRA752 has five instances of thermal sensor: MPU, GPU, CORE,
  IVA and DSPEVE need to describe the individual registers and
  bit fields.
  DRA752 CORE thermal sensor register offsets and bit-fields
  DRA752 IVA thermal sensor register offsets and bit-fields
  DRA752 MPU thermal sensor register offsets and bit-fields
  DRA752 DSPEVE thermal sensor register offsets and bit-fields
  DRA752 GPU thermal sensor register offsets and bit-fields
 Thresholds and limits for DRA752 MPU temperature sensor 
 Thresholds and limits for DRA752 GPU temperature sensor 
 Thresholds and limits for DRA752 CORE temperature sensor 
 Thresholds and limits for DRA752 DSPEVE temperature sensor 
 Thresholds and limits for DRA752 IVA temperature sensor 
  DRA752 : Temperature values in milli degree celsius
  ADC code values from 540 to 945
 Index 540 - 549 
 Index 550 - 559 
 Index 560 - 569 
 Index 570 - 579 
 Index 580 - 589 
 Index 590 - 599 
 Index 600 - 609 
 Index 610 - 619 
 Index 620 - 629 
 Index 630 - 639 
 Index 640 - 649 
 Index 650 - 659 
 Index 660 - 669 
 Index 670 - 679 
 Index 680 - 689 
 Index 690 - 699 
 Index 700 - 709 
 Index 710 - 719 
 Index 720 - 729 
 Index 730 - 739 
 Index 740 - 749 
 Index 750 - 759 
 Index 760 - 769 
 Index 770 - 779 
 Index 780 - 789 
 Index 790 - 799 
 Index 800 - 809 
 Index 810 - 819 
 Index 820 - 829 
 Index 830 - 839 
 Index 840 - 849 
 Index 850 - 859 
 Index 860 - 869 
 Index 870 - 879 
 Index 880 - 889 
 Index 890 - 899 
 Index 900 - 909 
 Index 910 - 919 
 Index 920 - 929 
 Index 930 - 939 
 Index 940 - 945 
 DRA752 data 
 SPDX-License-Identifier: GPL-2.0-only
  OMAP3 thermal driver.
  Copyright (C) 2011-2012 Texas Instruments Inc.
  Copyright (C) 2014 Pavel Machek <pavel@ucw.cz>
  Note
  http:www.ti.comlitersprz278fsprz278f.pdf "Advisory
  3.1.1.186 MMC OCP Clock Not Gated When Thermal Sensor Is Used"
  Also TI says:
  Just be careful when you try to make thermal policy like decisions
  based on this sensor. Placement of the sensor w.r.t the actual logic
  generating heat has to be a factor as well. If you are just looking
  for an approximation temperature (thermometerish kind), you might be
  ok with this. I am not sure we'd find any TI data around this.. just a
  heads up.
  OMAP34XX has one instance of thermal sensor for MPU
  need to describe the individual bit fields
 Thresholds and limits for OMAP34XX MPU temperature sensor 
  Temperature values in milli degree celsius
 OMAP34XX data 
  OMAP36XX has one instance of thermal sensor for MPU
  need to describe the individual bit fields
 Thresholds and limits for OMAP36XX MPU temperature sensor 
  Temperature values in milli degree celsius
 OMAP36XX data 
 SPDX-License-Identifier: GPL-2.0-only
  TI Bandgap temperature sensor driver
  Copyright (C) 2011-2012 Texas Instruments Incorporated - http:www.ti.com
  Author: J Keerthy <j-keerthy@ti.com>
  Author: Moiz Sonasath <m-sonasath@ti.com>
  Couple of fixes, DT and MFD adaptation:
    Eduardo Valentin <eduardo.valentin@ti.com>
   Helper functions to access registers and their bitfields   
  ti_bandgap_readl() - simple read helper function
  @bgp: pointer to ti_bandgap structure
  @reg: desired register (offset) to be read
  Helper function to read bandgap registers. It uses the io remapped area.
  Return: the register value.
  ti_bandgap_writel() - simple write helper function
  @bgp: pointer to ti_bandgap structure
  @val: desired register value to be written
  @reg: desired register (offset) to be written
  Helper function to write bandgap registers. It uses the io remapped area.
  DOC: macro to update bits.
  RMW_BITS() - used to read, modify and update bandgap bitfields.
             The value passed will be shifted.
   Basic helper functions   
  ti_bandgap_power() - controls the power state of a bandgap device
  @bgp: pointer to ti_bandgap structure
  @on: desired power state (1 - on, 0 - off)
  Used to power onoff a bandgap device instance. Only used on those
  that features tempsoff bit.
  Return: 0 on success, -ENOTSUPP if tempsoff is not supported.
 active on 0 
  ti_errata814_bandgap_read_temp() - helper function to read dra7 sensor temperature
  @bgp: pointer to ti_bandgap structure
  @reg: desired register (offset) to be read
  Function to read dra7 bandgap sensor temperature. This is done separately
  so as to workaround the errata "Bandgap Temperature read Dtemp can be
  corrupted" - Errata ID: i814".
  Read accesses to registers listed below can be corrupted due to incorrect
  resynchronization between clock domains.
  Read access to registers below can be corrupted :
  CTRL_CORE_DTEMP_MPUGPUCOREDSPEVEIVA_n (n = 0 to 4)
  CTRL_CORE_TEMP_SENSOR_MPUGPUCOREDSPEVEIVA_n
  Return: the register value.
 If both times we read the same value then that is right 
 if val1 and val2 are different read it third time 
  ti_bandgap_read_temp() - helper function to read sensor temperature
  @bgp: pointer to ti_bandgap structure
  @id: bandgap sensor id
  Function to concentrate the steps to read sensor temperature register.
  This function is desired because, depending on bandgap device version,
  it might be needed to freeze the bandgap state machine, before fetching
  the register value.
  Return: temperature in ADC values.
		
		  In case we cannot read from cur_dtemp  dtemp_0,
		  then we read from the last valid temp read
 read temperature 
   IRQ handlers   
  ti_bandgap_talert_irq_handler() - handles Temperature alert IRQs
  @irq: IRQ number
  @data: private data (struct ti_bandgap )
  This is the Talert handler. Use it only if bandgap device features
  HAS(TALERT). This handler goes over all sensors and checks their
  conditions and acts accordingly. In case there are events pending,
  it will reset the event mask to wait for the opposite event (next event).
  Every time there is a new event, it will be reported to thermal layer.
  Return: IRQ_HANDLED
 Read the status of t_hot 
 Read the status of t_cold 
		
		  One TALERT interrupt: Two sources
		  If the interrupt is due to t_hot then mask t_hot and
		  and unmask t_cold else mask t_cold and unmask t_hot
 report temperature to whom may concern 
  ti_bandgap_tshut_irq_handler() - handles Temperature shutdown signal
  @irq: IRQ number
  @data: private data (unused)
  This is the Tshut handler. Use it only if bandgap device features
  HAS(TSHUT). If any sensor fires the Tshut signal, we simply shutdown
  the system.
  Return: IRQ_HANDLED
   Helper functions which manipulate conversion ADC <-> mi Celsius   
  ti_bandgap_adc_to_mcelsius() - converts an ADC value to mCelsius scale
  @bgp: struct ti_bandgap pointer
  @adc_val: value in ADC representation
  @t: address where to write the resulting temperature in mCelsius
  Simple conversion from ADC representation to mCelsius. In case the ADC value
  is out of the ADC conv table range, it returns -ERANGE, 0 on success.
  The conversion table is indexed by the ADC values.
  Return: 0 if conversion was successful, else -ERANGE in case the @adc_val
  argument is out of the ADC conv table range.
 look up for temperature in the table and return the temperature 
  ti_bandgap_validate() - helper to check the sanity of a struct ti_bandgap
  @bgp: struct ti_bandgap pointer
  @id: bandgap sensor id
  Checks if the bandgap pointer is valid and if the sensor id is also
  applicable.
  Return: 0 if no errors, -EINVAL for invalid @bgp pointer or -ERANGE if
  @id cannot index @bgp sensors.
  ti_bandgap_read_counter() - read the sensor counter
  @bgp: pointer to bandgap instance
  @id: sensor id
  @interval: resulting update interval in miliseconds
  ti_bandgap_read_counter_delay() - read the sensor counter delay
  @bgp: pointer to bandgap instance
  @id: sensor id
  @interval: resulting update interval in miliseconds
  ti_bandgap_read_update_interval() - read the sensor update interval
  @bgp: pointer to bandgap instance
  @id: sensor id
  @interval: resulting update interval in miliseconds
  Return: 0 on success or the proper error code
  ti_bandgap_write_counter_delay() - set the counter_delay
  @bgp: pointer to bandgap instance
  @id: sensor id
  @interval: desired update interval in miliseconds
  Return: 0 on success or the proper error code
 Immediate conversion 
 Conversion after ever 1ms 
 Conversion after ever 10ms 
 Conversion after ever 100ms 
 Conversion after ever 250ms 
 Conversion after ever 500ms 
  ti_bandgap_write_counter() - set the bandgap sensor counter
  @bgp: pointer to bandgap instance
  @id: sensor id
  @interval: desired update interval in miliseconds
  ti_bandgap_write_update_interval() - set the update interval
  @bgp: pointer to bandgap instance
  @id: sensor id
  @interval: desired update interval in miliseconds
  Return: 0 on success or the proper error code
  ti_bandgap_read_temperature() - report current temperature
  @bgp: pointer to bandgap instance
  @id: sensor id
  @temperature: resulting temperature
  Return: 0 on success or the proper error code
  ti_bandgap_set_sensor_data() - helper function to store thermal
  framework related data.
  @bgp: pointer to bandgap instance
  @id: sensor id
  @data: thermal framework related data to be stored
  Return: 0 on success or the proper error code
  ti_bandgap_get_sensor_data() - helper function to get thermal
  framework related data.
  @bgp: pointer to bandgap instance
  @id: sensor id
  Return: data stored by set function with sensor id on success or NULL
   Helper functions used during device initialization   
  ti_bandgap_force_single_read() - executes 1 single ADC conversion
  @bgp: pointer to struct ti_bandgap
  @id: sensor id which it is desired to read 1 temperature
  Used to initialize the conversion state machine and set it to a valid
  state. Called during device initialization and context restore events.
  Return: 0
 Select continuous or single conversion mode 
 Set Start of Conversion if available 
 Wait for EOCZ going up 
 Clear Start of Conversion if available 
 Wait for EOCZ going down, always needed even if no bgap_soc_mask 
  ti_bandgap_set_continuous_mode() - One time enabling of continuous mode
  @bgp: pointer to struct ti_bandgap
  Call this function only if HAS(MODE_CONFIG) is set. As this driver may
  be used for junction temperature monitoring, it is desirable that the
  sensors are operational all the time, so that alerts are generated
  properly.
  Return: 0
 Perform a single read just before enabling continuous 
  ti_bandgap_get_trend() - To fetch the temperature trend of a sensor
  @bgp: pointer to struct ti_bandgap
  @id: id of the individual sensor
  @trend: Pointer to trend.
  This function needs to be called to fetch the temperature trend of a
  Particular sensor. The function computes the difference in temperature
  w.r.t time. For the bandgaps with built in history buffer the temperatures
  are read from the buffer and for those without the Buffer -ENOTSUPP is
  returned.
  Return: 0 if no error, else return corresponding error. If no
 		error then the trend value is passed on to trend parameter
 Freeze and read the last 2 valid readings 
 read temperature from history buffer 
 Convert from adc values to mCelsius temperature 
 Fetch the update interval 
 Set the interval to 1 ms if bandgap counter delay is not set 
  ti_bandgap_tshut_init() - setup and initialize tshut handling
  @bgp: pointer to struct ti_bandgap
  @pdev: pointer to device struct platform_device
  Call this function only in case the bandgap features HAS(TSHUT).
  In this case, the driver needs to handle the TSHUT signal as an IRQ.
  The IRQ is wired as a GPIO, and for this purpose, it is required
  to specify which GPIO line is used. TSHUT IRQ is fired anytime
  one of the bandgap sensors violates the TSHUT highhot threshold.
  And in that case, the system must go off.
  Return: 0 if no error, else error status
  ti_bandgap_talert_init() - setup and initialize talert handling
  @bgp: pointer to struct ti_bandgap
  @pdev: pointer to device struct platform_device
  Call this function only in case the bandgap features HAS(TALERT).
  In this case, the driver needs to handle the TALERT signals as an IRQs.
  TALERT is a normal IRQ and it is fired any time thresholds (hot or cold)
  are violated. In these situation, the driver must reprogram the thresholds,
  accordingly to specified policy.
  Return: 0 if no error, else return corresponding error.
  ti_bandgap_build() - parse DT and setup a struct ti_bandgap
  @pdev: pointer to device struct platform_device
  Used to read the device tree properties accordingly to the bandgap
  matching version. Based on bandgap version and its capabilities it
  will build a struct ti_bandgap out of the required DT entries.
  Return: valid bandgap structure if successful, else returns ERR_PTR
  return value must be verified with IS_ERR.
 just for the sake 
 register shadow for context save and restore 
  List of SoCs on which the CPU PM notifier can cause erros on the DTEMP
  readout.
  Enabled notifier on these machines results in erroneous, random values which
  could trigger unexpected thermal shutdown.
 sentinel  },
   Device driver call backs   
		
		  check if the efuse has a non-zero value if not
		  it is an untrimmed sample and the temperatures
		  may not be accurate
 Set default counter to 1 for now 
 Set default thresholds for alert and shutdown 
 Set initial Talert thresholds 
 Enable the alert events 
 Set initial Tshut thresholds 
 Set .250 seconds time as default counter 
 Every thing is good? Then expose the sensors 
	
	  Enable the Interrupts once everything is set. Otherwise irq handler
	  might be called as soon as it is enabled where as rest of framework
	  is still getting initialised.
 Remove sensor interfaces 
		 Force immediate temperature measurement and update
		  of the DTEMP field
 Sentinel 
 SPDX-License-Identifier: GPL-2.0-only
  OMAP5 thermal driver.
  Copyright (C) 2011-2012 Texas Instruments Inc.
  Contact:
 	Eduardo Valentin <eduardo.valentin@ti.com>
  OMAP5430 has three instances of thermal sensor for MPU, GPU & CORE,
  need to describe the individual registers and bit fields.
  OMAP5430 MPU thermal sensor register offset and bit-fields
  OMAP5430 GPU thermal sensor register offset and bit-fields
  OMAP5430 CORE thermal sensor register offset and bit-fields
 Thresholds and limits for OMAP5430 MPU temperature sensor 
 Thresholds and limits for OMAP5430 GPU temperature sensor 
 Thresholds and limits for OMAP5430 CORE temperature sensor 
  OMAP54xx ES2.0 : Temperature values in milli degree celsius
  ADC code values from 540 to 945
 Index 540 - 549 
 Index 550 - 559 
 Index 560 - 569 
 Index 570 - 579 
 Index 580 - 589 
 Index 590 - 599 
 Index 600 - 609 
 Index 610 - 619 
 Index 620 - 629 
 Index 630 - 639 
 Index 640 - 649 
 Index 650 - 659 
 Index 660 - 669 
 Index 670 - 679 
 Index 680 - 689 
 Index 690 - 699 
 Index 700 - 709 
 Index 710 - 719 
 Index 720 - 729 
 Index 730 - 739 
 Index 740 - 749 
 Index 750 - 759 
 Index 760 - 769 
 Index 770 - 779 
 Index 780 - 789 
 Index 790 - 799 
 Index 800 - 809 
 Index 810 - 819 
 Index 820 - 829 
 Index 830 - 839 
 Index 840 - 849 
 Index 850 - 859 
 Index 860 - 869 
 Index 870 - 879 
 Index 880 - 889 
 Index 890 - 899 
 Index 900 - 909 
 Index 910 - 919 
 Index 920 - 929 
 Index 930 - 939 
 Index 940 - 945 
 OMAP54xx ES2.0 data 
 SPDX-License-Identifier: GPL-2.0-only
  OMAP thermal driver interface
  Copyright (C) 2012 Texas Instruments Incorporated - http:www.ti.com
  Contact:
    Eduardo Valentin <eduardo.valentin@ti.com>
 common data structures 
  ti_thermal_hotspot_temperature - returns sensor extrapolated temperature
  @t:	omap sensor temperature
  @s:	omap sensor slope value
  @c:	omap sensor const value
 thermal zone ops 
 Get temperature callback function for thermal zone 
 Default constants 
 In case pcb zone is available, use the extrapolation rule with it 
 got a valid PCB temp 
 pcb_tz will be either valid or PTR_ERR() 
 in case this is specified by DT 
	
	  We are assuming here that if one deploys the zone
	  using DT, then it must be aware that the cooling device
	  loading has to happen via cpufreq driver.
 Register cooling device 
 SPDX-License-Identifier: GPL-2.0
   Intel menlow Driver for thermal management extension
   Copyright (C) 2008 Intel Corp
   Copyright (C) 2008 Sujith Thomas <sujith.thomas@intel.com>
   Copyright (C) 2008 Zhang Rui <rui.zhang@intel.com>
   This driver creates the sys IF for programming the sensors.
   It also implements the driver for intel menlow memory controller (hardware
   id is INT0002) which makes use of the platform specific ACPI methods
   to getset bandwidth.
  Memory controller device control
  GTHS returning 'n' would mean that [0,n-1] states are supported
  In that case max_cstate would be n-1
  GTHS returning '0' would mean that no bandwidth control states are supported
  Memory Device Management
  Sensor control on menlow platform
  sensor_get_auxtrip - get the current auxtrip value from sensor
  @name: Thermalzone name
  @auxtype : AUX0AUX1
  @buf: syfs buffer
  sensor_set_auxtrip - set the new auxtrip value to sensor
  @name: Thermalzone name
  @auxtype : AUX0AUX1
  @buf: syfs buffer
 do we need to check the return value of SAX0SAX1 ? 
Sanity check; should be a positive integer 
 BIOS can enabledisable the thermal user application in dabney platform 
 That is consistent naming :D 
 _TZ must have the AUX01 methods 
	
	  create the "dabney_enabled" attribute which means the user app
	  should be loaded or not
 Looking for the \_TZ.GSTS method 
 Looking for ACPI device MEM0 with hardware id INT0002 
 Looking for sensors in each ACPI thermal zone 
 SPDX-License-Identifier: GPL-2.0-only
  x86_pkg_temp_thermal driver
  Copyright (c) 2013, Intel Corporation.
 Rate control delay: Idea is to introduce denounce effect
 This should be long enough to avoid reduce events, when
 threshold is set to a temperature, which is constantly
 violated, but at the short enough to take any action.
 The action can be remove threshold or change it to next
 interesting setting. Based on experiments, in around
 every 5 seconds under load will give us a significant
 temperature change.
 Number of trip points in thermal zone. Currently it can't
 be more than 2. MSR can allow setting and getting notifications
 for only 2 thresholds. This define enforces this, if there
 is some wrong values returned by cpuid for number of thresholds.
 Keep track of how many zone pointers we allocated in init() 
 Array of zone pointers 
 Serializes interrupt notification, work and hotplug 
 Protects zone operation in the work function against hotplug removal 
 The dynamically assigned cpu hotplug state for module_exit() 
 Debug counters to show using debugfs 
  Protection:
  - cpu hotplug: Read serialized by cpu hotplug lock
 		  Write must hold pkg_temp_lock
  - Other callsites: Must hold pkg_temp_lock
 tj-max is is interesting because threshold is set relative to this
 temperature.
	
	 When users space sets a trip temperature == 0, which is indication
	 that, it is no longer interested in receiving notifications.
 Thermal zone callback registry 
 Enable threshold interrupt on local packagecpu 
 only enabledisable if it had valid threshold value 
 Disable threshold interrupt on local packagecpu 
	
	  If tzone is not NULL, then thermal_zone_mutex will prevent the
	  concurrent removal in the cpu offline callback.
 Work is per package, so scheduling it once is enough. 
 Store MSR value for package thermal interrupt, to restore at exit 
	
	  Remove the sysfs files, if this is the last cpu in the package
	  before doing further cleanups.
		
		  We must protect against a work function calling
		  thermal_zone_update, afterwhile unregister. We null out
		  the pointer under the zone mutex, so the worker function
		  won't try to call.
 Protect against work and interrupts 
	
	  Check whether this cpu was the current target and store the new
	  one. When we drop the lock, then the interrupt notify function
	  will see the new target.
	
	  If this is the last CPU in the package remove the package
	  reference from the array and restore the interrupt MSR. When we
	  drop the lock neither the interrupt notify function nor the
	  worker will see the package anymore.
 After this point nothing touches the MSR anymore. 
	
	  Check whether there is work scheduled and whether the work is
	  targeted at the outgoing CPU.
		
		  To cancel the work we need to drop the lock, otherwise
		  we might deadlock if the work needs to be flushed.
		
		  If this is not the last cpu in the package and the work
		  did not run after we dropped the lock above, then we
		  need to reschedule the work, otherwise the interrupt
		  stays disabled forever.
 Final cleanup if this is the last cpu 
 Paranoia check 
 If the package exists, nothing to do 
 Store the state for module exit 
 Don't care if it fails 
 SPDX-License-Identifier: GPL-2.0-only
  cooling device driver that activates the processor throttling by
  programming the TCC Offset register.
  Copyright (c) 2021, Intel Corporation.
 SPDX-License-Identifier: GPL-2.0-only
  intel_soc_dts_iosf.c
  Copyright (c) 2015, Intel Corporation.
 DTS encoding for TJ MAX temperature 
 Only 2 out of 4 is allowed for OSPM 
 Mask for two trips in status bits 
 DTS0 and DTS 1 
 Enable for CPU module 0 and module 1 
 Nothing we can do if restore fails 
 Store status to restor on exit 
 Check if the writable trip we provide is not used by BIOS 
 reset sticky bit 
 SPDX-License-Identifier: GPL-2.0-only
 intel_pch_thermal.c - Intel PCH Thermal driver
  Copyright (c) 2015, Intel Corporation.
  Authors:
      Tushar Dave <tushar.n.dave@intel.com>
 Intel PCH thermal Device IDs 
 Haswell PCH 
 Haswell PCH 
 Wildcat Point 
 Skylake PCH 
 Skylake PCH 100 series 
 CNL PCH 
 CNL-H PCH 
 CNL-LP PCH 
 CML-H PCH 
 Lewisburg PCH 
 Wildcat Point-LP  PCH Thermal registers 
 Temperature 
 Thermal Sensor Control 
 Thermal Sensor Status 
 Thermal Sensor Enable and Lock 
 Thermal Sensor Report Enable and Lock 
 Thermal Sensor SMI Control 
 Catastrophic Trip Point 
 Thermal Sensor Power Management 
 Thermal Alert High Value 
 Thermal Alert Low Value 
 Throttle Value 
 PCH Hot Level 
 PHL Control 
 Thermal Alert Status 
 PCI Interrupt Event Enables 
 General Purpose Event Enables 
  Wildcat Point-LP  PCH Thermal Register bit definitions 
 Temp TS Reading 
 Catastrophic Power-Down Enable 
 Thermal Sensor Dynamic Shutdown Status 
 GPE status 
 Enable TS 
 TSEL Policy Lock-Down Bit 
 T0 Level 
 T1 Level 
 TT Enable 
 Resolution of 12 degree C and an offset of -50C 
 Amount of time for each cooling delay, 100ms by default for now 
 Number of iterations for cooling delay, 10 counts by default for now 
  On some platforms, there is a companion ACPI device, which adds
  passive trip temperature using _PSV method. There is no specific
  passive temperature setting in MMIO interface of this PCI device.
 Check if BIOS has already enabled thermal sensor 
	
	  When TSEL's Policy Lock-Down bit is 1, TSEL become RO.
	  If so, thermal sensor cannot enable. Bail out.
 Shutdown the thermal sensor if it is not enabled by BIOS 
 Do not check temperature if it is not a S0ix capable platform 
 Do not check temperature if it is not s2idle 
 Get the PCH temperature threshold value 
 Get the PCH current temperature value 
	
	  If current PCH temperature is higher than configured PCH threshold
	  value, run some delay loop with sleep to let the current temperature
	  go down below the threshold value which helps to allow system enter
	  lower power S0ix suspend state. Even after delay loop if PCH current
	  temperature stays above threshold, notify the warning message
	  which helps to indentify the reason why S0ix entry was rejected.
 Read the PCH current temperature for next cycle. 
 dev ops for Wildcat Point 
 SPDX-License-Identifier: GPL-2.0-only
  intel_soc_dts_thermal.c
  Copyright (c) 2014, Intel Corporation.
 IRQ 86 is a fixed APIC interrupt for BYT DTS Aux threshold notifications 
 Create a zone with 2 trips with marked as read only 
		
		  Note the flags here MUST match the firmware defaults, rather
		  then the request_irq flags, otherwise we get an EBUSY error.
			
			  Do not just error out because the user space thermal
			  daemon such as DPTF may use polling instead of being
			  interrupt driven.
 SPDX-License-Identifier: GPL-2.0-only
  Thermal throttle event support code (such as syslog messaging and rate
  limiting) that was factored out from x86_64 (mce_intel.c) and i386 (p4.c).
  This allows consistent reporting of CPU thermal throttle events.
  Maintains a counter in sys that keeps track of the number of thermal
  events, such that the user knows how bad the thermal problem might be
  (since the logging to syslog is rate limited).
  Author: Dmitriy Zavin (dmitriyz@google.com)
  Credits: Adapted from Zwane Mwaikambo's original code in mce_intel.c.
           Inspired by Ross Biro's and Al Borchers' counter code.
 How long to wait between reporting thermal events 
  struct _thermal_state - Represent the current thermal event state
  @next_check:			Stores the next timestamp, when it is allowed
 				to log the next warning message.
  @last_interrupt_time:	Stores the timestamp for the last threshold
 				high event.
  @therm_work:			Delayed workqueue structure
  @count:			Stores the current running count for thermal
 				or power threshold interrupts.
  @last_count:			Stores the previous running count for thermal
 				or power threshold interrupts.
  @max_time_ms:		This shows the maximum amount of time CPU was
 				in throttled state for a single thermal
 				threshold high to low state.
  @total_time_ms:		This is a cumulative time during which CPU was
 				in the throttled state.
  @rate_control_active:	Set when a throttling message is logged.
 				This is used for the purpose of rate-control.
  @new_event:			Stores the last highlow status of the
 				THERM_STATUS_PROCHOT or
 				THERM_STATUS_POWER_LIMIT.
  @level:			Stores whether this _thermal_state instance is
 				for a CORE level or for PACKAGE level.
  @sample_index:		Index for storing the next sample in the buffer
 				temp_samples[].
  @sample_count:		Total number of samples collected in the buffer
 				temp_samples[].
  @average:			The last moving average of temperature samples
  @baseline_temp:		Temperature at which thermal threshold high
 				interrupt was generated.
  @temp_samples:		Storage for temperature samples to calculate
 				moving average.
  This structure is used to represent data related to thermal state for a CPU.
  There is a separate storage for core and package level for each CPU.
 Callback to handle core threshold interrupts 
 Callback to handle core package threshold_interrupts 
 Callback support of rate control, return true, if
 CPU hotplug 			\
 CONFIG_SYSFS 
 temperature value is offset from the max so lesser means hotter 
 There was one new thermal interrupt 
  therm_throt_process - Process thermal throttling event from interrupt
  @curr: Whether the condition is current or not (boolean), since the
         thermal interrupt normally gets called both when the thermal
         event begins and once the event has ended.
  This function is called by the thermal interrupt after the
  IRQ has been acknowledged.
  It will take care of rate limiting and printing messages to the syslog.
		
		  Ignore short temperature spike as the system is not close
		  to PROCHOT. 10C offset is large enough to ignore. It is
		  already dropped from the high threshold temperature.
 AddRemove thermal_throttle interface for CPU device: 
 Get notified when a cpu comes onoff. Be hotplug friendly. 
 Unmask the thermal vector after the above workqueues are initialized. 
 Mask the thermal vector before draining evtl. pending work 
 CONFIG_SYSFS 
 lower threshold check 
 higher threshold check 
 Rate control is implemented in callback 
 lower threshold reached 
 higher threshold reached 
	 check whether the interrupt handler is defined;
	  otherwise simply return
 lower threshold reached 
 higher threshold reached 
 Thermal transition interrupt handler 
 Check for violation of core thermal thresholds
 check violations of package thermal thresholds 
 Thermal monitoring depends on APIC, ACPI and clock modulation 
	
	  This function is only called on boot CPU. Save the init thermal
	  LVT value on BSP and use that value to restore APs' thermal LVT
	  entry BIOS programmed later
	
	  First check if its enabled already, in which case there might
	  be some SMM goo which handles it, so we can't even put a handler
	  since it might be delivered via SMI already:
	
	  The initial value of thermal LVT entries on all APs always reads
	  0x10000 because APs are woken up by BSP issuing INIT-SIPI-SIPI
	  sequence to them and LVT registers are reset to 0s except for
	  the mask bits which are set to 1s when APs receive INIT IPI.
	  If BIOS takes over the thermal interrupt and sets its interrupt
	  delivery mode to SMI (not fixed), it restores the value that the
	  BIOS has programmed on AP based on BSP's info we saved since BIOS
	  is always setting the same value for all threadscores.
 early Pentium M models use different method for enabling TM2 
 We'll mask the thermal vector in the lapic till we're ready: 
 enable thermal throttle processing 
  intel_quark_dts_thermal.c
  This file is provided under a dual BSDGPLv2 license.  When using or
  redistributing this file, you may do so under either license.
  GPL LICENSE SUMMARY
  Copyright(c) 2015 Intel Corporation.
  This program is free software; you can redistribute it andor modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.
  Contact Information:
   Ong Boon Leong <boon.leong.ong@intel.com>
   Intel Malaysia, Penang
  BSD LICENSE
  Copyright(c) 2015 Intel Corporation.
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
     Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation andor other materials provided with the
      distribution.
     Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  Quark DTS thermal driver is implemented by referencing
  intel_soc_dts_thermal.c.
 DTS reset is programmed via QRK_MBI_UNIT_SOC 
 DTS enable is programmed via QRK_MBI_UNIT_RMU 
 Temperature Register is read via QRK_MBI_UNIT_RMU 
 Programmable Trip Point Register is configured via QRK_MBI_UNIT_RMU 
 Thermal Sensor Register Lock 
 Quark DTS has 2 trip points: hot & catastrophic 
 If DTS not locked, all trip points are configurable 
 If DTS locked, all trip points are not configurable 
	
	  Thermal Sensor Programmable Trip Point Register has 8-bit
	  fields for critical (catastrophic) and hot set trip point
	  thresholds. The threshold value is always offset by its
	  temperature base (50 degree Celsius).
	
	  Protection against unsafe trip point thresdhold value.
	  As Quark X1000 data-sheet does not provide any recommendation
	  regarding the safe trip point threshold value to use, we choose
	  the safe value according to the threshold value set by UEFI BIOS.
	
	  Thermal Sensor Programmable Trip Point Register has 8-bit
	  fields for critical (catastrophic) and hot set trip point
	  thresholds. The threshold value is always offset by its
	  temperature base (50 degree Celsius).
	
	  Thermal Sensor Temperature Register has 8-bit field
	  for temperature value (offset by temperature base
	  50 degree Celsius).
 Check if DTS register is locked 
 Store DTS default state if DTS registers are not locked 
 Store DTS default enable for restore on exit 
 Store DTS default PTPS register for restore on exit 
 SPDX-License-Identifier: GPL-2.0-only
  intel_powerclamp.c - package c-state idle injection
  Copyright (c) 2012, Intel Corporation.
  Authors:
      Arjan van de Ven <arjan@linux.intel.com>
      Jacob Pan <jacob.jun.pan@linux.intel.com>
 	TODO:
            1. better handle wakeup from external interrupts, currently a fixed
               compensation is added to clamping duration when excessive amount
               of wakeups are observed during idle time. the reason is that in
               case of external interrupts without need for ack, clamping down
               cpu in non-irq context does not reduce irq. for majority of the
               cases, clamping down cpu does help reduce irq as well, we should
               be able to differentiate the two cases and give a quantitative
               solution for the irqs that we can control. perhaps based on
               get_cpu_iowait_time_us()
 	     2. synchronization with other hw blocks
 For each undisturbed clamping period (no extra wake ups during idle time),
  we increment the confidence counter for the given target ratio.
  CONFIDENCE_OK defines the level where runtime calibration results are
  valid.
 Default idle injection duration, driver adjust sleep time to meet target
  idle ratio. Similar to frequency modulation.
 user selected target 
static unsigned int control_cpu;  The cpu assigned to collect stat and update
				   control parameters. default to BSP but BSP
				   can be offlined.
static unsigned long cpu_clamping_mask;   bit map for tracking per cpu
					    clamping kthread worker
	unsigned long confidence;   used for calibration, basically a counter
				     gets incremented each time a clamping
				     period is completed without extra wakeups
				     once that counter is reached given level,
				     compensation is deemed usable.
	unsigned long steady_comp;  steady state compensation used when
				     no extra wakeups occurred.
	unsigned long dynamic_comp;  compensate excessive wakeup from idle
				      mostly from external interrupts.
 check if any one of the counter msrs exists 
 we only use compensation if all adjacent ones are good 
 REVISIT: simple penalty of double idle injection 
 do not exceed limit 
	
	  adjust compensations if confidence level has not been reached or
	  there are too many wakeups during the last idle injection period, we
	  cannot trust the data for compensation.
 filter out bad data 
 check result for the last window 
 calculate pkg cstate vs tsc ratio 
 update record 
	
	  too many external interrupts, set flag such
	  that we can take measure later.
 if we are above target+guard, skip 
 jiffies to sleep for each attempt 
	
	  make sure user selected ratio does not take effect until
	  the next round. adjust target_ratio if user has changed
	  target such that we can converge quickly.
	
	  systems may have different ability to enter package level
	  c-states, thus we need to compensate the injected idle ratio
	  to achieve the actual target reported by the HW.
 align idle time 
	
	  only elected controlling cpu can collect stats and update
	  control parameters.
  1 HZ polling while clamping is active, useful for userspace
  to monitor actual idle ratio.
 calculate pkg cstate vs tsc ratio 
 update record 
	
	  Make sure that all works that get queued after this point see
	  the clamping disabled. The counter part is not needed because
	  there is an implicit memory barrier when the queued work
	  is proceed.
	
	  The balancing work still might be queued here because
	  the handling of the "clapming" variable, cancel, and queue
	  operations are not synchronized via a lock. But it is not
	  a big deal. The balancing work is fast and destroy kthread
	  will wait for it.
 prevent cpu hotplug 
 prefer BSP 
 start one kthread worker per online cpu 
	
	  Block requeuing in all the kthread workers. They will flush and
	  stop faster.
 prefer BSP as controlling CPU 
 to save power, do not poll idle ratio while not clamping 
 indicates invalid state 
 adjust currently running  {
 make new set_target_ratio visible to other cpus 
 bind to generic thermal layer as cooling device
 The goal for idle time alignment is to achieve package cstate. 
 find the deepest mwait value 
 probe cpu features and ids here 
 set default limit, maybe adjusted during runtime based on feedback 
 SPDX-License-Identifier: GPL-2.0-only
  Intel Broxton PMIC thermal driver
  Copyright (C) 2016 Intel Corporation. All rights reserved.
 Resolve thermal irqs 
			
			  Read the irq register to resolve whether the
			  interrupt was triggered for this sensor
			
			  Read the status register to find out what
			  event occurred i.e a high or a low
 Clear the appropriate irq 
 Enable thermal interrupts 
 SPDX-License-Identifier: GPL-2.0-only
  processor thermal device mailbox driver for Workload type hints
  Copyright (c) 2020, Intel Corporation.
 Poll for rb bit == 0 
 Write command register 
 Poll for rb bit == 0 
 List of workload types 
 Check if there is a mailbox support, if fails return success 
 SPDX-License-Identifier: GPL-2.0-only
  ACPI INT3403 thermal driver
  Copyright (c) 2013, Intel Corporation.
 Preserved structure for future expandbility 
 INT3403 Cooling devices 
 TODO: add ACPI notification support 
 SPDX-License-Identifier: GPL-2.0-only
 acpi_thermal_rel.c driver for exporting ACPI thermal relationship
  Copyright (c) 2014 Intel Corp
  Two functionalities included:
  1. Export _TRT, _ART, via misc device interface to the userspace.
  2. Provide parsing result to kernel drivers
 #times opened 
 already open exclusive? 
  acpi_parse_trt - Thermal Relationship Table _TRT for passive cooling
  @handle: ACPI handle of the device contains _TRT
  @trt_count: the number of valid entries resulted from parsing _TRT
  @trtp: pointer to pointer of array of _TRT entries in parsing result
  @create_dev: whether to create platform devices for target and source
 don't count bad entries 
  acpi_parse_art - Parse Active Relationship Table _ART
  @handle: ACPI handle of the device contains _ART
  @art_count: the number of valid entries resulted from parsing _ART
  @artp: pointer to pointer of array of art entries in parsing result
  @create_dev: whether to create platform devices for target and source
 ignore p->package.elements[0], as this is _ART Revision field 
 don't count bad entries 
 get device name from acpi handle 
 now fill in user art data 
 userspace art needs device name instead of acpi reference 
 copy the rest int data in addition to source and target 
 now fill in user trt data 
 userspace trt needs device name instead of acpi reference 
 SPDX-License-Identifier: GPL-2.0-only
  INT3402 thermal driver for memory temperature reporting
  Copyright (C) 2014, Intel Corporation
  Authors: Aaron Lu <aaron.lu@intel.com>
 SPDX-License-Identifier: GPL-2.0-only
  processor thermal device RFIM control
  Copyright (c) 2020, Intel Corporation.
 These will represent sysfs attribute names 
 vco_ref_code_lo 
 vco_ref_code_hi 
 spread_spectrum_pct 
 spread_spectrum_clk_enable 
 rfi_vco_ref_code 
 fivr_fffc_rev 
 These will represent sysfs attribute names 
 rfi_restriction_run_busy 
 rfi_restriction_err_code 
 rfi_restriction_data_rate 
 rfi_restriction_data_rate_base 
 ddr_data_rate_point_0 
 ddr_data_rate_point_1 
 ddr_data_rate_point_2 
 ddr_data_rate_point_3 
 rfi_disable 
 SPDX-License-Identifier: GPL-2.0-only
  Processor thermal device for newer processors
  Copyright (c) 2020, Intel Corporation.
  To avoid sending two many messages to user space, we have 1 second delay.
  On interrupt we are disabling interrupt and enabling after 1 second.
  This workload function is delayed by 1 second.
 Enable interrupt flag 
 Disable enable interrupt flag 
 request and enable interrupt 
 SPDX-License-Identifier: GPL-2.0-only
  processor_thermal_device.c
  Copyright (c) 2014, Intel Corporation.
 since it is fixed, we can have local storage 
 there is no _TMP method, add local method 
 Do not update if saving failed 
 SPDX-License-Identifier: GPL-2.0-only
  INT3401 processor thermal device
  Copyright (c) 2020, Intel Corporation.
 SPDX-License-Identifier: GPL-2.0-only
  B0D4 processor thermal device
  Copyright (c) 2020, Intel Corporation.
		
		  Enumerate additional DTS sensors available via IOSF.
		  But we are not treating as a failure condition, if
		  there are no aux DTSs enabled or fails. This driver
		  already exposes sensors, which can be accessed via
		  ACPIMSR. So we don't want to fail for auxiliary DTSs.
 SPDX-License-Identifier: GPL-2.0-only
  int340x_thermal_zone.c
  Copyright (c) 2015, Intel Corporation.
 _TMP returns the temperature in tenths of degrees Kelvin 
 SPDX-License-Identifier: GPL-2.0-only
  INT3400 thermal driver
  Copyright (C) 2014, Intel Corporation
  Authors: Zhang Rui <rui.zhang@intel.com>
			
			  If we have a list of supported UUIDs, make sure
			  this one is supported.
 UUID must be 16 bytes 
 Ignore unknown notification codes sent to INT3400 device 
 faked temp sensor with 20C 
 Missing IDSP isn't fatal 
 SPDX-License-Identifier: GPL-2.0-only
  INT3406 thermal driver for display participant device
  Copyright (C) 2016, Intel Corporation
  Authors: Aaron Lu <aaron.lu@intel.com>
  According to the ACPI spec,
  "Each brightness level is represented by a number between 0 and 100,
  and can be thought of as a percentage. For example, 50 can be 50%
  power consumption or 50% brightness, as defined by the OEM."
  As int3406 device uses this value to communicate with the native
  graphics driver, we make the assumption that it represents
  the percentage of brightness only
	
	  There is no 1:1 mapping between the firmware interface level
	  with the raw interface level, we will have to find one that is
	  right above it.
 lower_limit and upper_limit should be always set 
 SPDX-License-Identifier: GPL-2.0-only
  processor thermal device RFIM control
  Copyright (c) 2020, Intel Corporation.
 mmio rapl supports package 0 only for now 
 SPDX-License-Identifier: GPL-2.0
  Tegra30 SoC Thermal Sensor driver
  Based on downstream HWMON driver from NVIDIA.
  Copyright (C) 2011 NVIDIA Corporation
  Author: Dmitry Osipenko <digetx@gmail.com>
  Copyright (C) 2021 GRATE-DRIVER project
	
	  Sensors are enabled after reset by default, but not gauging
	  until clock counter is programmed.
	 
	  M: number of reference clock pulses after which every
	     temperature  voltage measurement is made
	 
	  N: number of reference clock counts for which the counter runs
 apply the same configuration to both channels 
	
	  Counter will be invalid if hardware is misprogrammed or not enough
	  time passed since the time when sensor was enabled.
	
	  This shouldn't happen with a valid counter status, nevertheless
	  lets verify the value since it's in a separate (from status)
	  register.
	
	  temperature = a  counter + b
	  temperature = m  (temperature ^ 2) + n  temperature + p
	
	  TSENSOR doesn't trigger interrupt on the "low" temperature breach,
	  hence bail out if high temperature is unspecified.
 stop channel gracefully 
	
	  90C is the maximal critical temperature of all Tegra30 SoC variants,
	  use it for the default trip if unspecified in a device-tree.
 clamp hardware trips to the calibration limits 
	
	  Kernel will perform a normal system shut down if it will
	  see that critical temperature is breached, hence set the
	  hardware limit by 5C higher in order to allow system to
	  shut down gracefully before sending signal to the Power
	  Management controller.
 prevent potential racing with tegra_tsensor_set_trips() 
 program LEVEL2 counter threshold 
 program LEVEL3 counter threshold 
	
	  Enable sensor, emergency shutdown, interrupts for level 123
	  breaches and counter overflow condition.
	 
	  Disable DIV2 throttle for now since we need to figure out how
	  to integrate it properly with the thermal framework.
	 
	  Thermal levels supported by hardware:
	 
	      Level 0 = cold
	      Level 1 = passive cooling (cpufreq DVFS)
	      Level 2 = passive cooling assisted by hardware (DIV2)
	      Level 3 = emergency shutdown assisted by hardware (PMC)
	
	  We have two TSENSOR channels in a two different spots on SoC.
	  Second channel provides more accurate data on older SoC versions,
	  use it as a primary channel.
 get calibrated counter values for 25C90C thresholds 
 and calibrated temperatures corresponding to the counter values 
 all calibration coefficients are premultiplied by 1000000 
 except the coefficient of a reduced quadratic equation 
		
		  It's okay if sensor isn't assigned to any thermal zone
		  in a device-tree.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2014-2018, NVIDIA CORPORATION.  All rights reserved.
  This software is licensed under the terms of the GNU General Public
  License version 2, as published by the Free Software Foundation, and
  may be copied, distributed, and modified under those terms.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  Maskshift bits in FUSE_TSENSOR_COMMON and
  FUSE_TSENSOR_COMMON, which are described in
  tegra_soctherm_fuse.c
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2014-2018, NVIDIA CORPORATION.  All rights reserved.
  This software is licensed under the terms of the GNU General Public
  License version 2, as published by the Free Software Foundation, and
  may be copied, distributed, and modified under those terms.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  Maskshift bits in FUSE_TSENSOR_COMMON and
  FUSE_TSENSOR_COMMON, which are described in
  tegra_soctherm_fuse.c
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015-2017, NVIDIA CORPORATION.  All rights reserved.
  Author:
 	Mikko Perttunen <mperttunen@nvidia.com>
 	Aapo Vienamo	<avienamo@nvidia.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2014 - 2018, NVIDIA CORPORATION.  All rights reserved.
  Author:
 	Mikko Perttunen <mperttunen@nvidia.com>
  This software is licensed under the terms of the GNU General Public
  License version 2, as published by the Free Software Foundation, and
  may be copied, distributed, and modified under those terms.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  SENSOR_CONFIG2 is defined in soctherm.h
  because, it will be used by tegra_soctherm_fuse.c
  THERMCTL_LEVEL0_GROUP_CPU is defined in soctherm.h
  because it will be used by tegraxxx_soctherm.c
 3'b000 
 3'b001 
 3'b011 
 3'b111 
 car register offsets needed for enabling HW throttling 
 ccroc register offsets needed for enabling HW throttling for Tegra132 
 get val from register(r) mask bits(m) 
 set val(v) to mask bits(m) of register(r) 
 get dividend from the depth 
 gk20a nv_therm interface N:3 Mapping. Levels defined in tegra124-soctherm.h
  level	vector
  NONE		3'b000
  LOW		3'b001
  MED		3'b011
  HIGH		3'b111
 get THROT_PSKIP_xxx offset per LIGHTHEAVY throt and CPUGPU dev 
 get THROT_xxx_CTRL offset per LIGHTHEAVY throt 
 get CCROC_THROT_PSKIP_xxx offset per HIGHMEDLOW vect
 get THERMCTL_LEVELx offset per CPUGPUMEMTSENSE rg and LEVEL0~3 lv 
 OC5 is reserved 
 serialize OC IRQs 
  ccroc_writel() - writes a value to a CCROC register
  @ts: pointer to a struct tegra_soctherm
  @value: the value to write
  @reg: the register offset
  Writes @v to @reg.  No return value.
  ccroc_readl() - reads specified register from CCROC IP block
  @ts: pointer to a struct tegra_soctherm
  @reg: register address to be read
  Return: the value of the register
  Translate from soctherm readback format to millicelsius.
  The soctherm readback format in bits is as follows:
    TTTTTTTT H______N
  where T's contain the temperature in Celsius,
  H denotes an addition of 0.5 Celsius and N denotes negation
  of the final value.
  enforce_temp_range() - check and enforce temperature range [min, max]
  @dev: struct device  of the SOC_THERM instance
  @trip_temp: the trip temperature to check
  Checks and enforces the permitted temperature range that SOC_THERM
  HW can support This is
  done while taking care of precision.
  Return: The precision adjusted capped temperature in millicelsius.
  thermtrip_program() - Configures the hardware to shut down the
  system if a given sensor group reaches a given temperature
  @dev: ptr to the struct device for the SOC_THERM IP block
  @sg: pointer to the sensor group to set the thermtrip temperature for
  @trip_temp: the temperature in millicelsius to trigger the thermal trip at
  Sets the thermal trip threshold of the given sensor group to be the
  @trip_temp.  If this threshold is crossed, the hardware will shut
  down.
  Note that, although @trip_temp is specified in millicelsius, the
  hardware is programmed in degrees Celsius.
  Return: 0 upon success, or %-EINVAL upon failure.
  throttrip_program() - Configures the hardware to throttle the
  pulse if a given sensor group reaches a given temperature
  @dev: ptr to the struct device for the SOC_THERM IP block
  @sg: pointer to the sensor group to set the thermtrip temperature for
  @stc: pointer to the throttle need to be triggered
  @trip_temp: the temperature in millicelsius to trigger the thermal trip at
  Sets the thermal trip threshold and throttle event of the given sensor
  group. If this threshold is crossed, the hardware will trigger the
  throttle.
  Note that, although @trip_temp is specified in millicelsius, the
  hardware is programmed in degrees Celsius.
  Return: 0 upon success, or %-EINVAL upon failure.
 Hardcode LIGHT on LEVEL1 and HEAVY on LEVEL2 
		
		  If thermtrips property is set in DT,
		  doesn't need to program critical type trip to HW,
		  if not, program critical trip to HW.
 multiple zones could be handling and setting trips at once 
 multiple zones could be handling and setting trips at once 
  tegra_soctherm_set_hwtrips() - set HW trip point from DT data
  @dev: struct device  of the SOC_THERM instance
  @sg: pointer to the sensor group to set the thermtrip temperature for
  @tz: struct thermal_zone_device 
  Configure the SOC_THERM HW trip points, setting "THERMTRIP"
  "THROTTLE" trip points , using "thermtrips", "critical" or "hot"
  type trip_temp
  from thermal zone.
  After they have been configured, THERMTRIP or THROTTLE will take
  action when the configured SoC thermal sensor group reaches a
  certain temperature.
  Return: 0 upon success, or a negative error code on failure.
  "Success" does not mean that trips was enabled; it could also
  mean that no node was found in DT.
  THERMTRIP has been enabled successfully when a message similar to
  this one appears on the serial console:
  "thermtrip: will shut down when sensor group XXX reaches YYYYYY mC"
  THROTTLE has been enabled successfully when a message similar to
  this one appears on the serial console:
  ""throttrip: will throttle when sensor group XXX reaches YYYYYY mC"
 Get thermtrips. If missing, try to get critical trips. 
	 Case for no lock:
	  Although interrupts are enabled in set_trips, there is still no need
	  to lock here because the interrupts are disabled before programming
	  new trip points. Hence there cant be a interrupt on the same sensor.
	  An interrupt can however occur on a sensor while trips are being
	  programmed on a different one. This beign a LEVEL interrupt won't
	  cause a new interrupt but this is taken care of by the re-reading of
	  the STATUS register in the thread function.
  soctherm_thermal_isr_thread() - Handles a thermal interrupt request
  @irq:       The interrupt number being requested; not used
  @dev_id:    Opaque pointer to tegra_soctherm;
  Clears the interrupt status register if there are expected
  interrupt bits set.
  The interrupt(s) are then handled by updating the corresponding
  thermal zones.
  An error is logged if any unexpected interrupt bits are set.
  Disabled interrupts are re-enabled.
  Return: %IRQ_HANDLED. Interrupt was handled and no further processing
  is needed.
 deliberately clear expected interrupts handled in SW 
 deliberately ignore expected interrupts NOT handled in SW 
 Whine about any other unexpected INTR bits still set 
  soctherm_oc_intr_enable() - Enables the soctherm over-current interrupt
  @ts:		pointer to a struct tegra_soctherm
  @alarm:		The soctherm throttle id
  @enable:		Flag indicating enable the soctherm over-current
 			interrupt or disable it
  Enables a specific over-current pins @alarm to raise an interrupt if the flag
  is set and the alarm corresponds to OC1, OC2, OC3, or OC4.
  soctherm_handle_alarm() - Handles soctherm alarms
  @alarm:		The soctherm throttle id
  "Handles" over-current alarms (OC1, OC2, OC3, and OC4) by printing
  a warning or informative message.
  Return: -EINVAL for @alarm = THROTTLE_OC3, otherwise 0 (success).
  soctherm_edp_isr_thread() - log an over-current interrupt request
  @irq:	OC irq number. Currently not being used. See description
  @arg:	a void pointer for callback, currently not being used
  Over-current events are handled in hardware. This function is called to log
  and handle any OC events that happened. Additionally, it checks every
  over-current interrupt registers for registers are set but
  was not expected (i.e. any discrepancy in interrupt status) by the function,
  the discrepancy will logged.
  Return: %IRQ_HANDLED
 deliberately clear expected interrupts handled in SW 
  soctherm_edp_isr() - Disables any active interrupts
  @irq:	The interrupt request number
  @arg:	Opaque pointer to an argument
  Writes to the OC_INTR_DISABLE register the over current interrupt status,
  masking any asserted interrupts. Doing this prevents the same interrupts
  from triggering this isr repeatedly. The thread woken by this isr will
  handle asserted interrupts and subsequently unmaskre-enable them.
  The OC_INTR_DISABLE register indicates which OC interrupts
  have been disabled.
  Return: %IRQ_WAKE_THREAD, handler requests to wake the handler thread
  soctherm_oc_irq_lock() - locks the over-current interrupt request
  @data:	Interrupt request data
  Looks up the chip data from @data and locks the mutex associated with
  a particular over-current interrupt request.
  soctherm_oc_irq_sync_unlock() - Unlocks the OC interrupt request
  @data:		Interrupt request data
  Looks up the interrupt request data @data and unlocks the mutex associated
  with a particular over-current interrupt request.
  soctherm_oc_irq_enable() - Enables the SOC_THERM over-current interrupt queue
  @data:       irq_data structure of the chip
  Sets the irq_enable bit of SOC_THERM allowing SOC_THERM
  to respond to over-current interrupts.
  soctherm_oc_irq_disable() - Disables overcurrent interrupt requests
  @data:	The interrupt request information
  Clears the interrupt request enable bit of the overcurrent
  interrupt request chip data.
  Return: Nothing is returned (void)
  soctherm_oc_irq_map() - SOC_THERM interrupt request domain mapper
  @h:		Interrupt request domain
  @virq:	Virtual interrupt request number
  @hw:		Hardware interrupt request number
  Mapping callback function for SOC_THERM's irq_domain. When a SOC_THERM
  interrupt request is called, the irq_domain takes the request's virtual
  request number (much like a virtual memory address) and maps it to a
  physical hardware request number.
  When a mapping doesn't already exist for a virtual request number, the
  irq_domain calls this function to associate the virtual request number with
  a hardware request number.
  Return: 0
  soctherm_irq_domain_xlate_twocell() - xlate for soctherm interrupts
  @d:      Interrupt request domain
  @ctrlr:      Controller device tree node
  @intspec:    Array of u32s from DTs "interrupt" property
  @intsize:    Number of values inside the intspec array
  @out_hwirq:  HW IRQ value associated with this interrupt
  @out_type:   The IRQ SENSE type for this interrupt.
  This Device Tree IRQ specifier translation function will translate a
  specific "interrupt" as defined by 2 DT values where the cell values map
  the hwirq number + 1 and linux irq flags. Since the output is the hwirq
  number, this function will subtract 1 from the value listed in DT.
  Return: 0
	
	  The HW value is 1 index less than the DT IRQ values.
	  i.e. OC4 goes to HW index 3.
  soctherm_oc_int_init() - Initial enabling of the over
  current interrupts
  @np:	The devicetree node for soctherm
  @num_irqs:	The number of new interrupt requests
  Sets the over current interrupt request chip data
  Return: 0 on success or if overcurrent interrupts are not enabled,
  -ENOMEM (out of memory), or irq_base if the function failed to
  allocate the irqs
 BRIEF throttling by default, do not support STICKY 
  soctherm_init_hw_throt_cdev() - Parse the HW throttle configurations
  and register them as cooling devices.
  @pdev: Pointer to platform_device struct
  throttlectl_cpu_level_cfg() - programs CCROC NV_THERM level config
  @ts: pointer to a struct tegra_soctherm
  @level: describing the level LOWMEDHIGH of throttling
  It's necessary to set up the CPU-local CCROC NV_THERM instance with
  the MN values desired for each level. This function does this.
  This function pre-programs the CCROC NV_THERM levels in terms of
  pre-configured "Low", "Medium" or "Heavy" throttle levels which are
  mapped to THROT_LEVEL_LOW, THROT_LEVEL_MED and THROT_LEVEL_HVY.
 setup PSKIP in ccroc nv_therm registers 
  throttlectl_cpu_level_select() - program CPU pulse skipper config
  @ts: pointer to a struct tegra_soctherm
  @throt: the LIGHTHEAVY of throttle event id
  Pulse skippers are used to throttle clock frequencies.  This
  function programs the pulse skippers based on @throt and platform
  data.  This function is used on SoCs which have CPU-local pulse
  skipper control, such as T13x. It programs soctherm's interface to
  Denver:CCROC NV_THERM in terms of Low, Medium and HIGH throttling
  vectors. PSKIP_BYPASS mode is set as required per HW spec.
 Denver:CCROC NV_THERM interface N:3 Mapping 
 bypass sequencer in soc_therm as it is programmed in ccroc 
  throttlectl_cpu_mn() - program CPU pulse skipper configuration
  @ts: pointer to a struct tegra_soctherm
  @throt: the LIGHTHEAVY of throttle event id
  Pulse skippers are used to throttle clock frequencies.  This
  function programs the pulse skippers based on @throt and platform
  data.  This function is used for CPUs that have "remote" pulse
  skipper control, e.g., the CPU pulse skipper is controlled by the
  SOC_THERM IP block.  (SOC_THERM is located outside the CPU
  complex.)
  throttlectl_gpu_level_select() - selects throttling level for GPU
  @ts: pointer to a struct tegra_soctherm
  @throt: the LIGHTHEAVY of throttle event id
  This function programs soctherm's interface to GK20a NV_THERM to select
  pre-configured "Low", "Medium" or "Heavy" throttle levels.
  Return: boolean true if HW was programmed
  soctherm_throttle_program() - programs pulse skippers' configuration
  @ts: pointer to a struct tegra_soctherm
  @throt: the LIGHTHEAVY of the throttle event id.
  Pulse skippers are used to throttle clock frequencies.
  This function programs the pulse skippers.
 Setup PSKIP parameters 
 configure LOW, MED and HIGH levels for CCROC NV_THERM 
 Thermal HW throttle programming 
 initialize stats collection 
 Initialize raw sensors 
 program pdiv and hotspot offsets per THERM 
 hotspot offset from PLLX, doesn't need to configure PLLX 
 Configure hw throttle 
 calculate shared calibration data 
 calculate tsensor calibration data 
 Configure hw trip points 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014-2016, NVIDIA CORPORATION.  All rights reserved.
  Tegra210: Layout of bits in FUSE_TSENSOR_COMMON:
     3                   2                   1                   0
   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |       BASE_FT       |      BASE_CP      | SHFT_FT | SHIFT_CP  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  Tegra12x, etc:
  In chips prior to Tegra210, this fuse was incorrectly sized as 26 bits,
  and didn't hold SHIFT_CP in [31:26]. Therefore these missing six bits
  were obtained via the FUSE_SPARE_REALIGNMENT_REG register [5:0].
  FUSE_TSENSOR_COMMON:
     3                   2                   1                   0
   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |-----------| SHFT_FT |       BASE_FT       |      BASE_CP      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  FUSE_SPARE_REALIGNMENT_REG:
     3                   2                   1                   0
   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |---------------------------------------------------| SHIFT_CP  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  div64_s64_precise() - wrapper for div64_s64()
  @a:  the dividend
  @b:  the divisor
  Implements division with fairly accurate rounding instead of truncation by
  shifting the dividend to the left by 16 so that the quotient has a
  much higher precision.
  Return: the quotient of a  b.
 Scale up for increased precision division 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2014-2018, NVIDIA CORPORATION.  All rights reserved.
  This software is licensed under the terms of the GNU General Public
  License version 2, as published by the Free Software Foundation, and
  may be copied, distributed, and modified under those terms.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  Maskshift bits in FUSE_TSENSOR_COMMON and
  FUSE_TSENSOR_COMMON, which are described in
  tegra_soctherm_fuse.c
 SPDX-License-Identifier: GPL-2.0-or-later
  ST Thermal Sensor Driver for syscfg based sensors.
  Author: Ajit Pal Singh <ajitpal.singh@st.com>
  Copyright (C) 2003-2014 STMicroelectronics (R&D) Limited
 STiH415 
 STiH416 
 STiD127 
 Private OPs for System Configuration Register based thermal sensors 
 Compatible device data for stih415 sas thermal sensor 
 Compatible device data for stih415 mpe thermal sensor 
 Compatible device data for stih416 sas thermal sensor 
 Compatible device data for stid127 thermal sensor 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) STMicroelectronics 2018 - All Rights Reserved
  Author: David Hernandez Sanchez <david.hernandezsanchez@st.com> for
  STMicroelectronics.
 DTS register offsets 
 DTS_CFGR1 register mask definitions 
 DTS_T0VALR1 register mask definitions 
 DTS_RAMPVALR register mask definitions 
 DTS_ITR1 register mask definitions 
 DTS_DR register mask definitions 
 DTS_ITENR register mask definitions 
 DTS_ICIFR register mask definitions 
 Less significant bit position definitions 
 DTS_CFGR1 bit definitions 
 DTS_SR bit definitions 
 Bit definitions below are common for DTS_SR, DTS_ITENR and DTS_CIFR 
 Constants 
 30 celsius 
 130 celsius 
 Disable IT generation for low and high thresholds 
 Enable interrupts 
 Acknoledge all DTS irqs 
 Enable sensor 
	
	  The DTS block can be enabled by setting TSx_EN bit in
	  DTS_CFGRx register. It requires a startup time of
	  40μs. Use 5 ms as arbitrary timeout.
 Start continuous measuring 
 Stop measuring 
 Ensure stop is taken into account 
 Disable sensor 
 Ensure disable is taken into account 
 Figure out prescaler value for PCLK during calibration 
 Clear prescaler 
 Set prescaler. pclk_freqprescaler < 1MHz 
 Select PCLK as reference clock 
 Set maximal sampling time for better precision 
 Measure with calibration 
 select trigger 
 Fill in DTS structure with factory sensor values 
 Retrieve engineering calibration temperature 
 Retrieve fmt0 and put it on Hz 
 Retrieve ramp coefficient 
 Figure out the CLK_PTAT frequency for a given temperature 
 Figure out the threshold sample number 
 Disable temperature interrupt 
 Disable IT generation 
 Erase threshold content 
	
	  Disable low-temp if "low" is too small. As per thermal framework
	  API, we use -INT_MAX rather than INT_MIN.
 add 0.5 of hysteresis due to measurement error 
 Disable high-temp if "high" is too big. 
 Write new threshod values
 Callback to get temperature from HW 
 Retrieve the number of periods sampled 
 Figure out the CLK_PTAT frequency 
 Figure out the temperature in mili celsius 
 Registers DTS irq to be visible by GIC 
 CONFIG_PM_SLEEP 
 sentinel  }
 Populate sensor 
 Clear irq flags 
 Configure and enable HW sensor 
 Register IRQ into GIC 
	
	  Thermal_zone doesn't enable hwmon as default,
	  enable it here
 SPDX-License-Identifier: GPL-2.0-or-later
  ST Thermal Sensor Driver core routines
  Author: Ajit Pal Singh <ajitpal.singh@st.com>
  Copyright (C) 2003-2014 STMicroelectronics (R&D) Limited
 The Thermal Framework expects millidegrees 
  Function to allocate regfields which are common
  between syscfg and memory mapped based sensors
 Check if sensor calibration data is already written 
		
		  Sensor calibration value not set by bootloader,
		  default calibration data to be used
 Callback to get temperature from HW
 SPDX-License-Identifier: GPL-2.0-or-later
  ST Thermal Sensor Driver for memory mapped sensors.
  Author: Ajit Pal Singh <ajitpal.singh@st.com>
  Copyright (C) 2003-2014 STMicroelectronics (R&D) Limited
 Power control bits for the memory mapped thermal sensor 
	
	  According to the STIH416 MPE temp sensor data sheet -
	  the PDN (Power Down Bit) and SRSTN (Soft Reset Bit) need to be
	  written simultaneously for powering on and off the temperature
	  sensor. regmap_update_bits() will be used to update the register.
 Private ops for the Memory Mapped based thermal sensors 
 Set upper critical threshold 
 Compatible device data stih416 mpe thermal sensor 
 Compatible device data stih407 thermal sensor 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  Configfs interface for the NVMe target.
  Copyright (c) 2015-2016 HGST, a Western Digital Company.
  nvmet_port Generic ConfigFS definitions.
  Used in any place in the ConfigFS tree that refers to an address.
  Namespace structures & file operation functions below
 CONFIG_PCI_P2PDMA 
 CONFIG_NVME_TARGET_PASSTHRU 
 CONFIG_NVME_TARGET_PASSTHRU 
 passthru subsystems use the underlying controller's version 
 See Section 1.5 of NVMe 1.4 
	
	  The discovery NQN must be different from subsystem NQN.
  Subsystem structures & folder operation functions below
  Discovery Service subsystem definitions
  Ports definitions.
 Let inflight controllers teardown complete 
 < 0 == let the transport choose 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2016 Avago Technologies.  All rights reserved.
  Data StructuresDefines  
 for an LS RQST RCV 
 only if RS 
 tgtport->ls_rcv_list 
 for an LS RQST XMT 
 tgtport->ls_req_list 
 desired maximum for a single sequence - if sg list allows it 
 tgtport->fcp_list 
 nvmet_fc_target_list 
 dev for dma mapping 
 array of fcp_iods 
  Association and Connection IDs:
  Association ID will have random number in upper 6 bytes and zero
    in lower 2 bytes
  Connection IDs will be Association ID with QID or'd in lower 2 bytes
  note: Association ID = Connection ID for queue 0
  Globals  
  FC-NVME DMA Handling  
  The fcloop device passes in a NULL device pointer. Real LLD's will
  pass in a valid device pointer. If NULL is passed to the dma mapping
  routines, depending on the platform, it may or may not succeed, and
  may crash.
  As such:
  Wrapper all the dma routines and check the dev pointer.
  If simple mappings (return just a dma address, we'll noop them,
  returning a dma address of 0.
  On more complex mappings (dma_map_sg), a pseudo routine fills
  in the scatter list, setting all dma addresses to 0.
 pseudo dma_map_sg call 
  FC-NVME LS XMT Handling  
 don't wait for completion 
 fc-nvme target doesn't care about success or failure of cmd 
  This routine sends a FC-NVME LS to disconnect (aka terminate)
  the FC-NVME Association.  Terminating the association also
  terminates the FC-NVME connections (per queue, both admin and io
  queues) that are part of the association. E.g. things are torn
  down, and the related FC-NVME Association ID and Connection IDs
  become invalid.
  The behavior of the fc-nvme target is such that it's
  understanding of the association and connections will implicitly
  be torn down. The action is implicit as it may be due to a loss of
  connectivity with the fc-nvme host, so the target may never get a
  response even if it tried.  As such, the action of this routine
  is to asynchronously send the LS, ignore any results of the LS, and
  continue on with terminating the association. If the fc-nvme host
  is present and receives the LS, it too can tear down.
	
	  If ls_req is NULL or no hosthandle, it's an older lldd and no
	  message is normal. Otherwise, send unless the hostport has
	  already been invalidated by the lldd.
  FC-NVME Port Management  
		
		  no queue reference is taken, as it was taken by the
		  queue lookup just prior to the allocation. The iod
		  will "inherit" that reference.
	
	  put all admin cmds on hw queue id 0. All io commands go to
	  the respective hw queue based on a modulo basis
 Submit deferred IO for processing 
 release the queue lookup reference on the completed IO 
 Re-use the fod for the next pending cmd that was deferred 
 deferfcp can be reused for another IO at a later date 
 Save NVME CMD IO in fod 
 Setup new fcpreq to be processed 
 inform LLDD IO is now being processed 
	
	  Leave the queue lookup get reference taken when
	  fod was originally allocated.
 if not connected, nothing to do 
 abort outstanding io's 
			
			  only call lldd abort routine if waiting for
			  writedata. other outstanding ops should finish
			  on their own.
 Cleanup defer'ed IOs in queue 
 release the queue lookup reference 
 if LLDD not implemented, leave as NULL 
 if LLDD not implemented, leave as NULL 
	
	  take reference for what will be the newly allocated hostport if
	  we end up using a new allocation
 no new allocation - release reference 
 no new allocation - release reference 
 new allocation not needed 
 no new allocation - release reference 
 Send Disconnect now that all io has completed 
 if pending Rcv Disconnect Association LS, send rsp now 
 if already terminating, do nothing 
  called when a targetport deregisters. Breaks the relationship
  with the nvmet port, but leaves the port_entry in place so that
  re-registration can resume operation.
  called when a new targetport is registered. Looks in the
  existing nvmet port_entries to see if the nvmet layer is
  configured for the targetport's wwn's. (the targetport existed,
  nvmet configured, the lldd unregistered the tgtport, and is now
  reregistering the same targetport).  If so, set the nvmet port
  port entry on the targetport.
  nvme_fc_register_targetport - transport entry point called by an
                               LLDD to register the existence of a local
                               NVME subystem FC port.
  @pinfo:     pointer to information about the port to be registered
  @template:  LLDD entrypoints and operational parameters for the port
  @dev:       physical hardware device node port corresponds to. Will be
              used for DMA mappings
  @portptr:   pointer to a local port pointer. Upon success, the routine
              will allocate a nvme_fc_local_port structure and place its
              address in the local port pointer. Upon failure, local port
              pointer will be set to NULL.
  Returns:
  a completion status. Must be 0 upon success; a negative errno
  (ex: -ENXIO) upon failure.
 let the LLDD know we've finished tearing it down 
 already deleting - release local reference 
  nvmet_fc_invalidate_host - transport entry point called by an LLDD
                        to remove references to a hosthandle for LS's.
  The nvmet-fc layer ensures that any references to the hosthandle
  on the targetport are forgotten (set to NULL).  The LLDD will
  typically call this when a login with a remote host port has been
  lost, thus LS's for the remote host port are no longer possible.
  If an LS request is outstanding to the targetporthosthandle (or
  issued concurrently with the call to invalidate the host), the
  LLDD is responsible for terminatingaborting the LS and completing
  the LS request. It is recommended that these terminationsaborts
  occur after calling to invalidate the host handle to avoid additional
  retries by the nvmet-fc transport. The nvmet-fc transport may
  continue to reference host handle while it cleans up outstanding
  NVME associations. The nvmet-fc transport will call the
  ops->host_release() callback to notify the LLDD that all references
  are complete and the related host handle can be recovered.
  Note: if there are no references, the callback may be called before
  the invalidate host call returns.
  @target_port: pointer to the (registered) target port that a prior
               LS was received on and which supplied the transport the
               hosthandle.
  @hosthandle: the handle (pointer) that represents the host port
               that no longer has connectivity and that LS's should
               no longer be directed to.
 already deleting - release local reference 
 if there's nothing to wait for - call the callback 
  nvmet layer has called to terminate an association
 this is a bit ugly, but don't want to make locks layered 
 already deleting - release local reference 
  nvme_fc_unregister_targetport - transport entry point called by an
                               LLDD to deregisterremove a previously
                               registered a local NVME subsystem FC port.
  @target_port: pointer to the (registered) target port that is to be
                deregistered.
  Returns:
  a completion status. Must be 0 upon success; a negative errno
  (ex: -ENXIO) upon failure.
 terminate any outstanding associations 
	
	  should terminate LS's as well. However, LS's will be generated
	  at the tail end of association termination, so they likely don't
	  exist yet. And even if they did, it's worthwhile to just let
	  them finish and targetport ref counting will clean things up.
  FC-NVME LS RCV Handling  
	
	  FC-NVME spec changes. There are initiators sending different
	  lengths as padding sizes for Create Association Cmd descriptor
	  was incorrect.
	  Accept anything of "minimum" length. Assume format per 1.15
	  spec (with HOSTID reduced to 16 bytes), ignore how long the
	  trailing pad length is.
 new association w admin queue 
 best place to init value 
 format a response 
 new io queue 
 release get taken in nvmet_fc_find_target_assoc 
 best place to init value 
 format a response 
  Returns true if the LS response is to be transmit
  Returns false if the LS response is to be delayed
 match an active association - takes an assoc ref if !NULL 
 format a response 
 release get taken in nvmet_fc_find_target_assoc 
	
	  The rules for LS response says the response cannot
	  go back until ABTS's have been sent for all outstanding
	  IO and a Disconnect Association LS has been sent.
	  So... save off the Disconnect LS to send the response
	  later. If there was a prior LS already saved, replace
	  it with the newer one and send a can't perform reject
	  on the older one.
 overwrite good response with bogus failure 
 ok to use rqst, LS is same 
  NVME Ctrl Routines  
  Actual processing routine for received FC-NVME LS Requests from the LLD
 Be preventative. handlers will later set to valid length 
	
	  handlers:
	    parse request input, execute the request, and format the
	    LS response
 Creates Association and initial Admin QueueConnection 
 Creates an IO QueueConnection 
 Terminate a QueueConnection or the Association 
  Actual processing routine for received FC-NVME LS Requests from the LLD
  nvmet_fc_rcv_ls_req - transport entry point called by an LLDD
                        upon the reception of a NVME LS request.
  The nvmet-fc layer will copy payload to an internal structure for
  processing.  As such, upon completion of the routine, the LLDD may
  immediately freereuse the LS request buffer passed in the call.
  If this routine returns error, the LLDD should abort the exchange.
  @target_port: pointer to the (registered) target port the LS was
               received on.
  @hosthandle: pointer to the host specific data, gets stored in iod.
  @lsrsp:      pointer to a lsrsp structure to be used to reference
               the exchange corresponding to the LS.
  @lsreqbuf:   pointer to the buffer containing the LS Request
  @lsreqbuf_len: length, in bytes, of the received LS request
  Start of FCP handling
 note: write from initiator perspective 
 egad, this is ugly. And sqtail is just a best guess 
  Prep RSP payload.
  May be a NVMET_FCOP_RSP or NVMET_FCOP_READDATA_RSP op
	
	  check to see if we can send a 0's rsp.
	    Note: to send a 0's response, the NVME-FC host transport will
	    recreate the CQE. The host transport knows: sq id, SQHD (last
	    seen in an ersp), and command_id. Thus it will create a
	    zero-filled CQE with those known fields filled in. Transport
	    must send an ersp for any condition where the cqe won't match
	    this.
	 
	  Here are the FC-NVME mandated cases where we must send an ersp:
	   every N responses, where N=ersp_ratio
	   force fabric commands to send ersp's (not in FC-NVME but good
	     practice)
	   normal cmds: any time status is non-zero, or status is zero
	      but words 0 or 1 are non-zero.
	   the SQ is 90% or more full
	   the cmd is a fused command
	   transferred data length not equal to cmd iu length
 re-set the fields 
 data no longer needed 
	
	  if an ABTS was received or we issued the fcp_abort early
	  don't call abort routine again.
 no need to take lock - lock was taken earlier to get here 
	
	  for next sequence:
	   break at a sg element boundary
	   attempt to keep sequence length capped at
	     NVMET_FC_MAX_SEQ_LENGTH but allow sequence to
	     be longer if a single sg element is larger
	     than that amount. This is done to avoid creating
	     a new sg list to use for the tgtport api.
	
	  If the last READDATA request: check if LLDD supports
	  combined xfr with response.
		
		  should be ok to set wo lock as its in the thread of
		  execution (not an async timer routine) and doesn't
		  contend with any clearing action
 NVMET_FCOP_READDATA or NVMET_FCOP_READDATA_RSP  {
 if in the middle of an io and we need to tear down 
  actual done handler for FCP operations when completed by the lldd
 transfer the next chunk 
 data transfer complete, resume with nvmet layer 
 success 
 data no longer needed 
 transfer the next chunk 
 data transfer complete, send response 
 data no longer needed 
  actual completion handler after execution by the nvmet layer
 if we have a CQE, snoop the last sq_head value 
 if an error handling the cmd post initial parsing 
 fudge up a failed CQE status for our transport error 
 echo last cqe sqhd 
		
		  try to push the data even if the SQE status is non-zero.
		  There may be a status where data still was intended to
		  be moved
 push the data over before sending rsp 
 writes & no data - fall thru 
 data no longer needed 
  Actual processing routine for received FC-NVME IO Requests from the LLD
	
	  Fused commands are currently not supported in the linux
	  implementation.
	 
	  As such, the implementation of the FC transport does not
	  look at the fused commands and order delivery to the upper
	  layer until we have both based on csn.
 clear any response payload 
 bad SQE content or invalid ctrl state 
 nvmet layer has already called op done to send rsp. 
 keep a running counter of tail position 
 pull the data over before invoking nvmet layer 
	
	  Reads or no data:
	 
	  can invoke the nvmet_layer now. If read data, cmd completion will
	  push the data
  nvmet_fc_rcv_fcp_req - transport entry point called by an LLDD
                        upon the reception of a NVME FCP CMD IU.
  Pass a FC-NVME FCP CMD IU received from the FC link to the nvmet-fc
  layer for processing.
  The nvmet_fc layer allocates a local job structure (struct
  nvmet_fc_fcp_iod) from the queue for the io and copies the
  CMD IU buffer to the job structure. As such, on a successful
  completion (returns 0), the LLDD may immediately freereuse
  the CMD IU buffer passed in the call.
  However, in some circumstances, due to the packetized nature of FC
  and the api of the FC LLDD which may issue a hw command to send the
  response, but the LLDD may not get the hw completion for that command
  and upcall the nvmet_fc layer before a new command may be
  asynchronously received - its possible for a command to be received
  before the LLDD and nvmet_fc have recycled the job structure. It gives
  the appearance of more commands received than fits in the sq.
  To alleviate this scenario, a temporary queue is maintained in the
  transport for pending LLDD requests waiting for a queue job structure.
  In these "overrun" cases, a temporary queue element is allocated
  the LLDD request and CMD iu buffer information remembered, and the
  routine returns a -EOVERFLOW status. Subsequently, when a queue job
  structure is freed, it is immediately reallocated for anything on the
  pending request list. The LLDDs defer_rcv() callback is called,
  informing the LLDD that it may reuse the CMD IU buffer, and the io
  is then started normally with the transport.
  The LLDD, when receiving an -EOVERFLOW completion status, is to treat
  the completion as successful but must not reuse the CMD IU buffer
  until the LLDD's defer_rcv() callback has been called for the
  corresponding struct nvmefc_tgt_fcp_req pointer.
  If there is any other condition in which an error occurs, the
  transport will return a non-zero status indicating the error.
  In all cases other than -EOVERFLOW, the transport has not accepted the
  request and the LLDD should abort the exchange.
  @target_port: pointer to the (registered) target port the FCP CMD IU
               was received on.
  @fcpreq:     pointer to a fcpreq request structure to be used to reference
               the exchange corresponding to the FCP Exchange.
  @cmdiubuf:   pointer to the buffer containing the FCP CMD IU
  @cmdiubuf_len: length, in bytes, of the received FCP CMD IU
 validate iu, so the connection id can be used to find the queue 
	
	  note: reference taken by find_target_queue
	  After successful fod allocation, the fod will inherit the
	  ownership of that reference and will remove the reference
	  when the fod is freed.
 release the queue lookup reference 
 Just re-use one that was previously allocated 
 Now we need to dynamically allocate one 
 release the queue lookup reference 
 For now, use rspaddr  rsplen to save payload information 
 defer processing till a fod becomes available 
 NOTE: the queue lookup reference is still valid 
  nvmet_fc_rcv_fcp_abort - transport entry point called by an LLDD
                        upon the reception of an ABTS for a FCP command
  Notify the transport that an ABTS has been received for a FCP command
  that had been given to the transport via nvmet_fc_rcv_fcp_req(). The
  LLDD believes the command is still being worked on
  (template_ops->fcp_req_release() has not been called).
  The transport will wait for any outstanding work (an op to the LLDD,
  which the lldd should complete with error due to the ABTS; or the
  completion from the nvmet layer of the nvme command), then will
  stop processing and call the nvmet_fc_rcv_fcp_req() callback to
  return the io context to the LLDD.  The LLDD may send the BA_ACC
  to the ABTS either after return from this function (assuming any
  outstanding op work has been terminated) or upon the callback being
  called.
  @target_port: pointer to the (registered) target port the FCP CMD IU
               was received on.
  @fcpreq:     pointer to the fcpreq request structure that corresponds
               to the exchange that received the ABTS.
 job appears to have already completed, ignore abort 
		
		  mark as abort. The abort handler, invoked upon completion
		  of any work, will detect the aborted status and do the
		  callback.
  This routine validates and extracts the WWN's from the TRADDR string.
  As kernel parsers need the 0x to determine number base, universally
  build string to parse with 0x prefix before parsing name strings.
 validate if string is one of the 2 allowed formats 
 validate the address info 
 map the traddr address info to a target port 
 a FC port can only be 1 nvmet port id 
 sanity check - all lports should be removed 
 SPDX-License-Identifier: GPL-2.0
  NVMe over Fabrics RDMA target.
  Copyright (c) 2015-2016 HGST, a Western Digital Company.
  We allow at least 1 page, up to 4 SGEs, and up to 16KB of inline data
 Assume mpsmin == device_page_size == 4KB 
 NVMe command  RDMA RECV 
 NVMe CQE  RDMA SEND 
 Data In  RDMA READ 
 Data Out  RDMA WRITE 
 for WRITE_INSERTREAD_STRIP no wire domain 
 Clear the PRACT bit since HCA will generateverify the PI 
 PI is added by the HW 
 for WRITE_PASSREAD_PASS both wirememory domains exist 
		
		  we didn't setup the controller yet in case
		  of admin connect error, just disconnect and
		  cleanup the queue
	
	  Upon RDMA completion check the signature status
	  - if succeeded send good NVMe response
	  - if failed send bad NVMe response with appropriate error
 no data command? 
 no data command? 
		
		  we get here only under memory pressure,
		  silently drop and have the host retry
		  as we can't even fail it.
		
		  If SRQs aren't supported we just go ahead and use normal
		  non-shared receive queues.
	
	  Reserve CQ slots for RECV + RDMA_READRDMA_WRITE + RDMA_SEND.
 +1 for drain 
 +1 for drain 
	
	  req->hsqsize corresponds to our recv queue size plus 1
	  req->hrqsize corresponds to our send queue size
 XXX: Should we enforce some kind of max for IO queues? 
	
	  Schedules the actual release because calling rdma_destroy_id from
	  inside a CM callback would trigger a deadlock. (great API design..)
	
	  Spread the io queues across completion vectors,
	  but still keep all admin queues on vector 0.
 Let inflight controller teardown complete 
		
		  Don't destroy the cm_id in free path, as we implicitly
		  destroy the cm_id here with non-zero ret code.
  nvme_rdma_device_removal() - Handle RDMA device removal
  @cm_id:	rdma_cm id, used for nvmet port
  @queue:      nvmet rdma queue (cm id qp_context)
  DEVICE_REMOVAL event notifies us that the RDMA device is about
  to unplug. Note that this event can be generated on a normal
  queue cm_id andor a device bound listener cm_id (where in this
  case queue will be null).
  We registered an ib_client to handle device removal for queues,
  so we only need to handle the listening port cm_ids. In this case
  we nullify the priv to prevent double cm_id destruction and destroying
  the cm_id implicitely by returning a non-zero rc to the callout.
		
		  This is a queue cm_id. we have registered
		  an ib_client to handle queues removal
		  so don't interfear and just return.
	
	  This is a listener cm_id. Make sure that
	  future remove_port won't invoke a double
	  cm_id destroy. use atomic xchg to make sure
	  we don't compete with remove_port.
	
	  We need to return 1 so that the core will destroy
	  it's own ID.  What a great API design..
	
	  Destroy the remaining queues, which are not belong to any
	  controller yet. Do it here after the RDMA-CM was destroyed
	  guarantees that no new queue will be created.
	
	  Allow both IPv4 and IPv6 sockets to bind a single port
	  at the same time.
	
	  IB Device that is used by nvmet controllers is being removed,
	  delete all queues using this device.
 1 == NVMF_TRTYPE_RDMA 
 SPDX-License-Identifier: GPL-2.0
  NVMe admin command implementation.
  Copyright (c) 2015-2016 HGST, a Western Digital Company.
 NUMD is a 0's based value 
 we don't have the right data for file backed ns 
 we don't have the right data for file backed ns 
 start beyond hdr 
 copy the header last once we know the number of groups 
		
		  We only support a single firmware slot which always is
		  active, so we can zero out the whole firmware slot log and
		  still claim to fully implement this mandatory log page.
 XXX: figure out how to assign real vendors IDs. 
	
	  XXX: figure out how we can assign a IEEE OUI, but until then
	  the safest is to leave it as zeroes.
 we support multiple ports, multiples hosts and ANA: 
 Limit MDTS according to transport capability 
 XXX: figure out what to do about RTD3RRTD3 
	
	  We don't really have a practical limit on the number of abort
	  comands.  But we don't do anything useful for abort either, so
	  no point in allowing more abort commands than the spec requires.
 first slot is read-only, only one slot supported 
 We support keep-alive timeout in granularity of seconds 
 no enforcement soft-limit for maxcmd - pick arbitrary high value 
 XXX: don't report vwc if the underlying device is write through 
	
	  We can't support atomic writes bigger than a LBA without support
	  from the backend device.
 we always support SGLs 
	
	  Max command capsule size is sqe + in-capsule data size.
	  Disable in-capsule data for Metadata capable controllers.
 Max response capsule size is cqe 
 random value 
	
	  Meh, we don't really support any power state.  Fake up the same
	  values that qemu does.
 write protect and no write protect 
 return an all zeroed buffer if we can't find an active namespace 
	
	  nuse = ncap = nsze isn't always true, but we have no way to find
	  that out from the underlying device.
	
	  We just provide a single LBA format that matches what the
	  underlying device reports.
	
	  Our namespace might always be shared.  Not just with other
	  controllers, but also with any other user of the block device.
  A "minimum viable" abort implementation: the command is mandatory in the
  spec, but we are not required to do any useful work.  We couldn't really
  do a useful abort, so don't bother even with waiting for the command
  to be exectuted and return immediately telling the command to abort
  wasn't found.
	
	  These features are mandatory in the spec, but we don't
	  have a useful way to implement them.  We'll eventually
	  need to come up with some fake values for these.
 need 128-bit host identifier flag 
 SPDX-License-Identifier: GPL-2.0
  NVMe over Fabrics TCP target.
  Copyright (c) 2018 Lightbits Labs. All rights reserved.
 Define the socket priority to use for connections were it is desirable
  that the NIC consider performing optimized packet processing or filtering.
  A non-zero value being sufficient to indicate general consideration of any
  possible optimization.  Making it a module param allows for alternative
  values that may be unique for some NIC implementations.
 Define a time period (in usecs) that io_work() shall sample an activated
  queue before determining it to be idle.  This optional module behavior
  can enable NIC solutions that support socket optimized packet processing
  using advanced interrupt moderation techniques.
 send state 
 send state 
 recv state 
 digest state 
 We didn't allocate cmds yet, send 0xffff 
		
		  Wait for inline data before processing the response.
		  Avoid using helpers, this might happen before
		  nvmet_req_init is completed.
 Done with sg?
 16M arbitrary limit 
 FIXME: use path and transport errors 
 This should never happen 
 send back R2T 
 fallthru 
 fatal 
 fatal 
	
	  Requeue the worker if idle deadline period is in progress or any
	  ops activity was recorded during the do-while loop above.
 failed in connect 
 FALLTHRU 
	
	  Cleanup whatever is sitting in the TCP transmit queue on socket
	  close. This is done to prevent stale data from being sent should
	  the network connection be restored before TCP times out.
 Set socket type of service 
		
		  If the socket is already closing, don't even start
		  consuming it
	
	  Destroy the remaining queues, which are not belong to any
	  controller yet.
 Let inflight controller teardown complete 
 3 == NVMF_TRTYPE_TCP 
 SPDX-License-Identifier: GPL-2.0
  NVMe ZNS-ZBD command implementation.
  Copyright (C) 2021 Western Digital Corporation or its affiliates.
  We set the Memory Page Size Minimum (MPSMIN) for target controller to 0
  which gets added by 12 in the nvme_enable_ctrl() which results in 2^12 = 4k
  as page_shift value. When calculating the ZASL use shift by 12.
	
	  Zone Append Size Limit (zasl) is expressed as a power of 2 value
	  with the minimum memory page size (i.e. 12) as unit.
	
	  Generic zoned block devices may have a smaller last zone which is
	  not supported by ZNS. Exclude zoned drives that have such smaller
	  last zone.
	
	  ZNS does not define a conventional zone type. If the underlying
	  device has a bitmap set indicating the existence of conventional
	  zones, reject the device. Otherwise, use report zones to detect if
	  the device has conventional zones.
 leave the place for report zone header 
	
	  When partial bit is set nr_zones must indicate the number of zone
	  descriptors actually transferred.
 Scan and build bitmap of the eligible zones 
 We scanned all the zones 
 This may take a while, so be nice to others 
 this is needed to quiet compiler warning 
 when select all bit is set slba field is ignored 
 Request is completed on len mismatch in nvmet_check_transter_len() 
 SPDX-License-Identifier: GPL-2.0
  NVMe Over Fabrics Target Passthrough command implementation.
  Copyright (c) 2017-2018 Western Digital Corporation or its
  affiliates.
  Copyright (c) 2019-2020, Eideticom Inc.
  xarray to maintain one passthru subsystem per nvme controller.
	
	  Multiple command set support can only be declared if the underlying
	  controller actually supports it.
	
	  The passthru NVMe driver may have a limit on the number of segments
	  which depends on the host's memory fragementation. To solve this,
	  ensure mdts is limited to the pages equal to the number of segments.
	
	  nvmet_passthru_map_sg is limitted to using a single bio so limit
	  the mdts based on BIO_MAX_VECS as well
	
	  We export aerl limit for the fabrics controller, update this when
	  passthru based aerl support is added.
 emulate kas as most of the PCIe ctrl don't have a support for kas 
 don't support host memory buffer 
 don't support fuse commands 
 we always support SGLs 
	
	  When passsthru controller is setup using nvme-loop transport it will
	  export the passthru ctrl subsysnqn (PCIe NVMe ctrl) and will fail in
	  the nvmehostcore.c in the nvme_init_subsystem()->nvme_active_ctrl()
	  code path with duplicate ctr subsynqn. In order to prevent that we
	  mask the passthru-ctrl subsysnqn with the target ctrl subsysnqn.
 use fabric id-ctrl values 
 Support multipath connections with fabrics 
 Disable reservations, see nvmet_parse_passthru_io_cmd() 
	
	  Presently the NVMEof target code does not support sending
	  metadata, so we must disable it here. This should be updated
	  once target starts supporting metadata.
	
	  If there are effects for the command we are about to execute, or
	  an end_req function we need to use nvme_execute_passthru_rq()
	  synchronously in a work item seeing the end_req function and
	  nvme_passthru_end() can't be called in the request done callback
	  which is typically in interrupt context.
  We need to emulate set host behaviour to ensure that any requested
  behaviour of the target's host matches the requested behaviour
  of the device's host and fail otherwise.
 Reject any commands with non-sgl flags set (ie. fused commands) 
		
		  Reservations cannot be supported properly because the
		  underlying device has no way of differentiating different
		  hosts that connect via fabrics. This could potentially be
		  emulated in the future if regular targets grow support for
		  this feature.
  Only features that are emulated or specifically allowed in the list  are
  passed down to the controller. This function implements the allow list for
  both get and set features.
 There is no support for forwarding ASYNC events 
 The IRQ settings will not apply to the target controller 
		
		  Any HMB that's set will not be passed through and will
		  not work as expected
		
		  The Pre-Boot Software Load Count doesn't make much
		  sense for a target to export
 No reservations, see nvmet_parse_passthru_io_cmd() 
 Reject any commands with non-sgl flags set (ie. fused commands) 
	
	  Passthru all vendor specific commands
		
		  Most PCIe ctrls don't support keep alive cmd, we route keep
		  alive to the non-passthru mode. In future please change this
		  code when PCIe ctrls with keep alive support available.
 Reject commands not in the allowlist above 
 SPDX-License-Identifier: GPL-2.0
  NVMe Fabrics command implementation.
  Copyright (c) 2015-2016 HGST, a Western Digital Company.
 note: convert queue size from 0's-based value to 1's-based value 
 zero out initial completion result, assign values as needed 
 zero out initial completion result, assign values as needed 
 pass back cntlid for successful completion 
 SPDX-License-Identifier: GPL-2.0
  Common code for the NVMe target.
  Copyright (c) 2015-2016 HGST, a Western Digital Company.
  This readwrite semaphore is used to synchronize access to configuration
  information on a target system that will result in discovery log page
  information change for at least one host.
  The full list of resources to protected by this semaphore is:
   - subsystems list
   - per-subsystem allowed hosts list
   - allow_any_host subsystem attribute
   - nvmet_genctr
   - the nvmet_transports array
  When updating any of those listsstructures write lock should be obtained,
  while when reading (popolating discovery log page or checking host-subsystem
  link) read lock is obtained to allow concurrent reads.
	
	  If the user requested PI support and the transport isn't pi capable,
	  don't enable the port.
 If the transport didn't set inline_data_size, then disable it. 
		
		  Right now we just check that there is p2pmem available so
		  we can report an error to the user right away if there
		  is not. We'll find the actual device to use once we
		  setup the controller when the port's device is available.
  Note: ctrl->subsys->lock should be held when calling this function
	
	  Now that we removed the namespaces from the lookup list, we
	  can kill the per_cpu ref and wait for any remaining references
	  to be dropped, as well as a RCU grace period for anyone only
	  using the namepace under rcu_read_lock().  Note that we can't
	  use call_rcu here as we need to ensure the namespaces have
	  been fully destroyed before unloading the module.
 set the more bit for this request 
	
	  If this is the admin queue, complete all AERs so that our
	  queue doesn't have outstanding requests on it.
		
		  The teardown flow may take some time, and the host may not
		  send us keep-alive during this period, hence reset the
		  traffic based keep-alive timer so we don't trigger a
		  controller teardown as a result of a keep-alive expiration.
 allows reusing the queue later 
 no support for fused commands yet 
	
	  For fabrics, PSDT field shall describe metadata pointer (MPTR) that
	  contains an address of a single contiguous physical buffer that is
	  byte aligned.
 will return an error for any non-connect command: 
	
	  Only IO controllers should verify iosqes,iocqes.
	  Strictly speaking, the spec says a discovery controller
	  should verify iosqes,iocqes are zeroed, however that
	  would break backwards compatibility, so don't enforce it.
	
	  Controllers that are not yet enabled should not really enforce the
	  keep alive timeout, but we still want to track a timeout and cleanup
	  in case a host died before it enabled the controller.  Hence, simply
	  reset the keep alive timer when the controller is enabled.
 XXX: tear down queues? 
 command sets supported: NVMe command set: 
 Controller supports one or more IO Command Sets 
 CC.EN timeout in 500msec units: 
 maximum queue entries supported: 
 ctrl found 
 ctrl not found 
 allow all access to disc subsys 
  Note: ctrl->subsys->lock should be held when calling this function
  Note: ctrl->subsys->lock should be held when calling this function
	
	  Discovery controllers may use some arbitrary high value
	  in order to cleanup stale discovery sessions
 keep-alive timeout in seconds 
 generate a random serial number as our controllers are ephemeral: 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2016 Avago Technologies.  All rights reserved.
 H2T or T2H 
 fcloop_rport->ls_list 
		
		  callee may free memory containing tls_req.
		  do not reference lsreq after this.
		
		  callee may free memory containing tls_req.
		  do not reference lsreq after this.
	
	  hosthandle should be the dst.rport value.
	  hosthandle ignored as fcloop currently is
	  1:1 tgtport vs remoteport
 host handle ignored for now 
  Simulate reception of RSCN and converting it to a initiator transport
  call to rescan a remote port.
 release original io reference on tgt struct 
 fabrics opcode will have a bit set above 1st byte 
  Routine to parse io and determine if the io is to be dropped.
  Returns:
   0 if io is not obstructed
   1 if io was dropped
 remove reference taken in original abort downcall 
 call_host_done releases reference for abort downcall 
  FCP IO operation done by target completion.
  call back up initiator "done" flows.
 illegal - call while io active 
 target transport has aborted io prior 
	
	  if fcpreq is NULL, the IO has been aborted (from
	  initiator side). For the target side, act as if all is well
	  but don't actually move data.
 Fall-Thru to RSP handling 
	
	  mark aborted only in case there were 2 threads in transport
	  (one doing io, other doing abort) and only kills ops posted
	  after the abort request
	
	  nothing more to do. If io wasn't active, the transport should
	  immediately call the req_release. If it was active, the op
	  will complete, and the lldd should call req_release.
 abort has already been called 
 break initiatortarget relationship for io 
 leave the reference while the work item is scheduled 
		
		  as the io has already had the done callback made,
		  nothing more to do. So release the reference taken above
 release any threads waiting for the unreg to complete 
 sizes of additional private data for data structures 
 optional features 
 sizes of additional private data for data structures 
 everything there ? 
 success 
 free only if we're going to fail 
 everything there ? 
 success 
 success 
	 the check to drop routine uses instance + count to know when
	  to end. Thus, if dropping 1 instance, count should be 0.
	  so subtract 1 from the count.
 SPDX-License-Identifier: GPL-2.0
  Discovery service for the NVMe over Fabrics target.
  Copyright (C) 2016 Intel Corporation. All rights reserved.
 If transport can signal change, notify transport 
 we support only dynamic controllers 
  nvmet_set_disc_traddr - set a correct discovery log entry traddr
  IP based transports (e.g RDMA) can listen on "any" ipv4ipv6 addresses
  (INADDR_ANY or IN6ADDR_ANY_INIT). The discovery log page traddr reply
  must not contain that "any" IP address. If the transport implements
  .disc_traddr, use it. this callback will set the discovery traddr
  from the req->port address in case the port in question listens
  "any" IP address.
 Spec requires dword aligned offsets 
	
	  Make sure we're passing at least a buffer of response header size.
	  If host provided data len is less than the header size, only the
	  number of bytes requested by host will be sent to host.
 no limit on data transfer sizes for now 
 no enforcement soft-limit for maxcmd - pick arbitrary high value 
 we always support SGLs 
 SPDX-License-Identifier: GPL-2.0
  NVMe IO command implementation.
  Copyright (c) 2015-2016 HGST, a Western Digital Company.
 Number of logical blocks per physical block. 
 Logical blocks per physical block, 0's based. 
	
	  For NVMe 1.2 and later, bit 1 indicates that the fields NAWUN,
	  NAWUPF, and NACWU are defined for this namespace and should be
	  used by the host for this namespace instead of the AWUN, AWUPF,
	  and ACWU fields in the Identify Controller data structure. If
	  any of these fields are zero that means that the corresponding
	  field from the identify controller data structure should be used.
	
	  Bit 4 indicates that the fields NPWG, NPWA, NPDG, NPDA, and
	  NOWS are defined for this namespace and should be used by
	  the host for IO optimization.
 NPWG = Namespace Preferred Write Granularity. 0's based 
 NPWA = Namespace Preferred Write Alignment. 0's based 
 NPDG = Namespace Preferred Deallocate Granularity. 0's based 
 NPDG = Namespace Preferred Deallocate Alignment 
 NOWS = Namespace Optimal Write Size 
 Unsupported metadata type 
	
	  Right now there exists M : 1 mapping between block layer error
	  to the NVMe status code (see nvme_error_status()). For consistency,
	  when we reverse map we use most appropriate NVMe Status code from
	  the group of the NVMe staus codes used in the nvme_error_status().
 virtual start sector must be in integrity interval units 
 CONFIG_BLK_DEV_INTEGRITY 
 Not supported yet 
 SPDX-License-Identifier: GPL-2.0
  NVMe over Fabrics loopback device.
  Copyright (c) 2015-2016 HGST, a Western Digital Company.
	
	  AEN requests are special as they don't time out and can
	  survive any kind of queue freeze and often don't respond to
	  aborts.  We don't even bother to allocate a struct request
	  for them but rather special case them here.
	
	  flush_end_io() can be called recursively for us, so use our own
	  lock class key for avoiding lockdep possible recursive locking,
	  then we can remove the dynamically allocated lock class for each
	  flush queue, that way may cause horrible boot delay.
 reset stopped state for the fresh admin queue 
 state change failure for non-deleted ctrl? 
 if no transport address is specified use the first port 
 no quirks, we're perfect! );
 warn if maxcmd is lower than queue_size 
	
	  Ensure any ctrls that are in the process of being
	  deleted are in fact deleted before we return
	  and free the port. This is to prevent active
	  ctrls from using a port after it's freed.
 254 == NVMF_TRTYPE_LOOP 
 SPDX-License-Identifier: GPL-2.0
  NVM Express target device driver tracepoints
  Copyright (c) 2018 Johannes Thumshirn, SUSE Linux GmbH
	
	  XXX: We don't know the controller instance before executing the
	  connect command itself because the connect command for the admin
	  queue will not provide the cntlid which will be allocated in this
	  command.  In case of io queues, the controller instance will be
	  mapped by the extra data of the connect command.
	  If we can know the extra data of the connect command in this stage,
	  we can update this print statement later.
 SPDX-License-Identifier: GPL-2.0
  NVMe Over Fabrics Target File IO commands implementation.
  Copyright (c) 2017-2018 Western Digital Corporation or its
  affiliates.
	
	  i_blkbits can be greater than the universally accepted upper bound,
	  so make sure we export a sane namespace lba_shift.
	
	  A NULL ki_complete ask for synchronous execution, which we want
	  for the IOCB_NOWAIT case.
		
		  For file systems returning error -EOPNOTSUPP, handle
		  IOCB_NOWAIT error case separately and retry without
		  IOCB_NOWAIT.
 fallback under memory pressure 
 Not supported yet 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2011-2014, Intel Corporation.
  Copyright (c) 2017-2021 Christoph Hellwig.
 for force_successful_syscall_return 
  Convert integer values from ioctl structures to user pointers, silently
  ignoring the upper bits in the compat case to match behaviour of 32-bit
  kernels.
		
		  Protection information is strippedinserted by the
		  controller.
 COMPAT_FOR_U64_ALIGNMENT 
	
	  struct nvme_user_io can have different padding on some 32-bit ABIs.
	  Just accept the compat version as all fields that are used are the
	  same size and at the same offset.
	
	  Handle ioctls that apply to the controller instead of the namespace
	  seperately and drop the ns SRCU reference early.  This avoids a
	  deadlock when deleting namespaces using the passthrough interface.
 CONFIG_NVME_MULTIPATH 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2016 Avago Technologies.  All rights reserved.
  Data StructuresDefines  
 seconds 
#define NVME_FC_DEFAULT_RECONNECT_TMO	2	 delay between reconnects
						  when connected and a
						  connection failure.
 alignment for other things alloc'd with 
 rport->ls_req_list 
 rport->ls_rcv_list 
 alignment for other things alloc'd with 
	struct nvme_request	nreq;		
						  nvmehostcore.c
						  requires this to be
						  the 1st element in the
						  private structure
						  associated with the
						  request.
 nvme_fc_port_list 
 physical device for dma 
 alignment for other things alloc'd with 
 for lport->endp_list 
 physical device for dma 
 alignment for other things alloc'd with 
 fc_ctrl flags values - specified as bit positions 
 rport->ctrl_list 
  Globals  
  These items are short-term. They will eventually be moved into
  a generic FC class. See comments in module init.
  FC-NVME Port Management  
 remove from transport list 
			
			  fails if ref cnt already 0. If so,
			  act as if lport already deleted
 resume the lport 
  nvme_fc_register_localport - transport entry point called by an
                               LLDD to register the existence of a NVME
                               host FC port.
  @pinfo:     pointer to information about the port to be registered
  @template:  LLDD entrypoints and operational parameters for the port
  @dev:       physical hardware device node port corresponds to. Will be
              used for DMA mappings
  @portptr:   pointer to a local port pointer. Upon success, the routine
              will allocate a nvme_fc_local_port structure and place its
              address in the local port pointer. Upon failure, local port
              pointer will be set to 0.
  Returns:
  a completion status. Must be 0 upon success; a negative errno
  (ex: -ENXIO) upon failure.
	
	  look to see if there is already a localport that had been
	  deregistered and in the process of waiting for all the
	  references to fully be removed.  If the references haven't
	  expired, we can simply re-enable the localport. Remoteports
	  and controller reconnections should resume naturally.
 found an lport, but something about its state is bad 
 found existing lport, which was resumed 
 nothing found - allocate a new localport struct 
  nvme_fc_unregister_localport - transport entry point called by an
                               LLDD to deregisterremove a previously
                               registered a NVME host FC port.
  @portptr: pointer to the (registered) local port that is to be deregistered.
  Returns:
  a completion status. Must be 0 upon success; a negative errno
  (ex: -ENXIO) upon failure.
  TRADDR strings, per FC-NVME are fixed format:
    "nn-0x<16hexdigits>:pn-0x<16hexdigits>" - 43 characters
  udev event will only differ by prefix of what field is
  being specified:
     "NVMEFC_HOST_TRADDR=" or "NVMEFC_TRADDR=" - 19 max characters
   19 + 43 + null_fudge = 64 characters
 NVMEFC_HOST_TRADDR=...
 NVMEFC_TRADDR=...
 remove from lport list 
		
		  As all reconnects were suppressed, schedule a
		  connect.
		
		  Controller is already in the process of terminating the
		  association. No need to do anything further. The reconnect
		  step will naturally occur after the reset completes.
 no action to take - let it delete 
 has it been unregistered 
 means lldd called us twice 
		
		  kick off a reconnect attempt on all associations to the
		  remote port. A successful reconnects will resume io.
  nvme_fc_register_remoteport - transport entry point called by an
                               LLDD to register the existence of a NVME
                               subsystem FC port on its fabric.
  @localport: pointer to the (registered) local port that the remote
              subsystem port is connected to.
  @pinfo:     pointer to information about the port to be registered
  @portptr:   pointer to a remote port pointer. Upon success, the routine
              will allocate a nvme_fc_remote_port structure and place its
              address in the remote port pointer. Upon failure, remote port
              pointer will be set to 0.
  Returns:
  a completion status. Must be 0 upon success; a negative errno
  (ex: -ENXIO) upon failure.
	
	  look to see if there is already a remoteport that is waiting
	  for a reconnect (within dev_loss_tmo) with the same WWN's.
	  If so, transition to it and reconnect.
 found an rport, but something about its state is bad 
 found existing rport, which was resumed 
 nothing found - allocate a new remoteport struct 
		
		  Schedule a controller reset. The reset will terminate the
		  association and schedule the reconnect timer.  Reconnects
		  will be attempted until either the ctlr_loss_tmo
		  (max_retries  connect_delay) expires or the remoteport's
		  dev_loss_tmo expires.
		
		  The association has already been terminated and the
		  controller is attempting reconnects.  No need to do anything
		  futher.  Reconnects will be attempted until either the
		  ctlr_loss_tmo (max_retries  connect_delay) expires or the
		  remoteport's dev_loss_tmo expires.
		
		  Controller is already in the process of terminating the
		  association.  No need to do anything further. The reconnect
		  step will kick in naturally after the association is
		  terminated.
 no action to take - let it delete 
  nvme_fc_unregister_remoteport - transport entry point called by an
                               LLDD to deregisterremove a previously
                               registered a NVME subsystem FC port.
  @portptr: pointer to the (registered) remote port that is to be
            deregistered.
  Returns:
  a completion status. Must be 0 upon success; a negative errno
  (ex: -ENXIO) upon failure.
 if dev_loss_tmo==0, dev loss is immediate 
	
	  release the reference, which will allow, if all controllers
	  go away, which should only occur after dev_loss_tmo occurs,
	  for the rport to be torn down.
  nvme_fc_rescan_remoteport - transport entry point called by an
                               LLDD to request a nvme device rescan.
  @remoteport: pointer to the (registered) remote port that is to be
               rescanned.
  Returns: NA
 a dev_loss_tmo of 0 (immediate) is allowed to be set 
  FC-NVME DMA Handling  
  The fcloop device passes in a NULL device pointer. Real LLD's will
  pass in a valid device pointer. If NULL is passed to the dma mapping
  routines, depending on the platform, it may or may not succeed, and
  may crash.
  As such:
  Wrapper all the dma routines and check the dev pointer.
  If simple mappings (return just a dma address, we'll noop them,
  returning a dma address of 0.
  On more complex mappings (dma_map_sg), a pseudo routine fills
  in the scatter list, setting all dma addresses to 0.
 pseudo dma_map_sg call 
  FC-NVME LS Handling  
		
		  No timeoutnot interruptible as we need the struct
		  to exist until the lldd calls us back. Thus mandate
		  wait until driver calls back. lldd responsible for
		  the timeout action
 ACC or RJT payload ? 
 don't wait for completion 
 Linux supports only Dynamic controllers 
 process connect LS completion 
 validate the ACC response 
 process connect LS completion 
 validate the ACC response 
 fc-nvme initiator doesn't care about success or failure of cmd 
  This routine sends a FC-NVME LS to disconnect (aka terminate)
  the FC-NVME Association.  Terminating the association also
  terminates the FC-NVME connections (per queue, both admin and io
  queues) that are part of the association. E.g. things are torn
  down, and the related FC-NVME Association ID and Connection IDs
  become invalid.
  The behavior of the fc-nvme initiator is such that it's
  understanding of the association and connections will implicitly
  be torn down. The action is implicit as it may be due to a loss of
  connectivity with the fc-nvme target, so you may never get a
  response even if you tried.  As such, the action of this routine
  is to asynchronously send the LS, ignore any results of the LS, and
  continue on with terminating the association. If the fc-nvme target
  is present and receives the LS, it too can tear down.
 leave the ctrl get reference 
 transmit a response for anything that was pending 
 overwrite good response with bogus failure 
  returns true to mean LS handled and ls_rsp can be sent
  returns false to defer ls_rsp xmt (will be done as part of
      association termination)
 match an active association 
 format an ACCept response 
	
	  the transmit of the response will occur after the exchanges
	  for the association have been ABTS'd by
	  nvme_fc_delete_association().
 fail the association 
 release the reference taken by nvme_fc_match_disconn_ls() 
  Actual Processing routine for received FC-NVME LS Requests from the LLD
  returns true if a response should be sent afterward, false if rsp will
  be sent asynchronously.
 Be preventative. handlers will later set to valid length 
	
	  handlers:
	    parse request input, execute the request, and format the
	    LS response
  nvme_fc_rcv_ls_req - transport entry point called by an LLDD
                        upon the reception of a NVME LS request.
  The nvme-fc layer will copy payload to an internal structure for
  processing.  As such, upon completion of the routine, the LLDD may
  immediately freereuse the LS request buffer passed in the call.
  If this routine returns error, the LLDD should abort the exchange.
  @portptr:    pointer to the (registered) remote port that the LS
               was received from. The remoteport is associated with
               a specific localport.
  @lsrsp:      pointer to a nvmefc_ls_rsp response structure to be
               used to reference the exchange corresponding to the LS
               when issuing an ls response.
  @lsreqbuf:   pointer to the buffer containing the LS Request
  @lsreqbuf_len: length, in bytes, of the received LS request
 validate there's a routine to transmit a response 
  NVME Ctrl Routines  
 ensure we've initialized the ops once 
	
	  WARNING:
	  The current linux implementation of a nvme controller
	  allocates a single tag set for all io queues and sizes
	  the io queues to fully hold all possible tags. Thus, the
	  implementation does not reference or care about the sqhd
	  value as it never needs to use the sqhdsqtail pointers
	  for submission pacing.
	 
	  This affects the FC-NVME implementation in two ways:
	  1) As the value doesn't matter, we don't need to waste
	     cycles extracting it from ERSPs and stamping it in the
	     cases where the transport fabricates CQEs on successful
	     completions.
	  2) The FC-NVME implementation requires that delivery of
	     ERSP completions are to go back to the nvme layer in order
	     relative to the rsn, such that the sqhd value will always
	     be "in order" for the nvme layer. As the nvme layer in
	     linux doesn't care about sqhd, there's no need to return
	     them in order.
	 
	  Additionally:
	  As the core nvme layer in linux currently does not look at
	  every field in the cqe - in cases where the FC transport must
	  fabricate a CQE, the following fields will not be set as they
	  are not referenced:
	       cqe.sqid,  cqe.sqhd,  cqe.command_id
	 
	  Failure or error of an individual io, in a transport
	  detected fashion unrelated to the nvme completion status,
	  potentially cause the initiator and target sides to get out
	  of sync on SQ headtail (aka outstanding io count allowed).
	  Per FC-NVME spec, failure of an individual command requires
	  the connection to be terminated, which in turn requires the
	  association to be terminated.
	
	  For the linux implementation, if we have an unsuccesful
	  status, they blk-mq layer can typically be called with the
	  non-zero status and the content of the cqe isn't important.
	
	  command completed successfully relative to the wire
	  protocol. However, validate anything received and
	  extract the status and result from the cqe (create it
	  where necessary).
		
		  No response payload or 12 bytes of payload (which
		  should all be zeros) are considered successful and
		  no payload in the CQE by the transport.
		
		  The ERSP IU contains a full completion with CQE.
		  Validate ERSP IU and look at cqe.
 clear other flags 
 Note: core layer may overwrite the sqe.command_id value 
	
	  Considered whether we should allocate buffers for all SQEs
	  and CQEs and dma map them - mapping their respective entries
	  into the request structures (kernel vm addr and dma address)
	  thus the driver could use the buffersmappings directly.
	  It only makes sense if the LLDD would use them for its
	  messaging api. It's very unlikely most adapter api's would use
	  a native NVME sqecqe. More reasonable if FC-NVME IU payload
	  structures were used instead.
  This routine terminates a queue at the transport level.
  The transport has already ensured that all outstanding ios on
  the queue have been terminated.
  The transport will send a Disconnect LS request to terminate
  the queue's connection. Termination of the admin queue will also
  terminate the association at the target.
	
	  Current implementation never disconnects a single queue.
	  It always terminates a whole association. So there is never
	  a disconnect(queue) LS sent to the target.
 remove from rport list 
  All accesses from nvme core layer done - can now free the
  controller. Called after last nvme_put_ctrl() call
  This routine is used by the transport when it needs to find active
  io on a queue that is to be terminated. The transport uses
  blk_mq_tagset_busy_itr() to find the busy requests, which then invoke
  this routine to kill them on a 1 by 1 basis.
  As FC allocates FC exchange for each io, the transport must contact
  the LLDD to terminate the exchange, thus releasing the FC exchange.
  After terminating the exchange the LLDD will call the transport's
  normal io done path for the request, but it will have an aborted
  status. The done path will return the io request back to the block
  layer with an error status.
  This routine runs through all outstanding commands on the association
  and aborts them.  This routine is typically be called by the
  delete_association routine. It is also called due to an error during
  reconnect. In that scenario, it is most likely a command that initializes
  the controller, including fabric Connect commands on io queues, that
  may have timed out or failed thus the io must be killed for the connect
  thread to see the error.
	
	  if aborting io, the queues are no longer good, mark them
	  all as not live.
	
	  If io queues are present, stop them and terminate all outstanding
	  ios on them. As FC allocates FC exchange for each io, the
	  transport must contact the LLDD to terminate the exchange,
	  thus releasing the FC exchange. We use blk_mq_tagset_busy_itr()
	  to tell us what io's are busy and invoke a transport routine
	  to kill them with the LLDD.  After terminating the exchange
	  the LLDD will call the transport's normal io done path, but it
	  will have an aborted status. The done path will return the
	  io requests back to the block layer as part of normal completions
	  (but with error status).
	
	  Other transports, which don't have link-level contexts bound
	  to sqe's, would try to gracefully shutdown the controller by
	  writing the registers for shutdown and polling (call
	  nvme_shutdown_ctrl()). Given a bunch of io was potentially
	  just aborted and we will wait on those contexts, and given
	  there was no indication of how live the controlelr is on the
	  link, don't send more io to create more contexts for the
	  shutdown. Let the controller fail via keepalive failure if
	  its still present.
	
	  clean up the admin queue. Same thing as above.
	
	  if an error (io timeout, etc) while (re)connecting, the remote
	  port requested terminating of the association (disconnect_ls)
	  or an error (timeout or abort) occurred on an io while creating
	  the controller.  Abort any ios on the association and let the
	  create_association error path resolve things.
 Otherwise, only proceed if in LIVE state - e.g. on first error 
	
	  Attempt to abort the offending command. Command completion
	  will detect the aborted io and will fail the connection.
	
	  the io abort has been initiated. Have the reset timer
	  restarted and the abort completion will complete the io
	  shortly. Avoids a synchronous wait while the abort finishes.
	
	  TODO: blk_integrity_rq(rq)  for DIF
  In FC, the queue is a logical thing. At transport connect, the target
  creates its "queue" and returns a handle that is to be given to the
  target whenever it posts something to the corresponding SQ.  When an
  SQE is sent on a SQ, FC effectively considers the SQE, or rather the
  command contained within the SQE, an io, and assigns a FC exchange
  to it. The SQE and the associated SQ handle are sent in the initial
  CMD IU sents on the exchange. All transfers relative to the io occur
  as part of the exchange.  The CQE is the last thing for the io,
  which is transferred (explicitly or implicitly) with the RSP IU
  sent on the exchange. After the CQE is received, the FC exchange is
  terminaed and the Exchange may be used on a different io.
  The transport to LLDD api has the transport making a request for a
  new fcp io request to the LLDD. The LLDD then allocates a FC exchange
  resource and transfers the command. The LLDD will then process all
  steps to complete the io. Upon completion, the transport done routine
  is called.
  So - while the operation is outstanding to the LLDD, there is a link
  level FC exchange resource that is also outstanding. This must be
  considered in all cleanup operations.
	
	  before attempting to send the io, check to see if we believe
	  the target device is present
 format the FC-NVME CMD IU and fcp_req 
	
	  validate per fabric rules, set fields mandated by fabric spec
	  as well as those by FC-NVME spec.
	
	  format SQE DPTR field per FC-NVME rules:
	     type=0x5     Transport SGL Data Block Descriptor
	     subtype=0xA  Transport-specific value
	     address=0
	     length=length of the data series
		
		  If the lld fails to send the command is there an issue with
		  the csn value?  If the command that fails is the Connect,
		  no - as the connection won't be live.  If it is a command
		  post-connect, it's possible a gap in csn may be created.
		  Does this matter?  As Linux initiators don't send fused
		  commands, no.  The gap would exist, but as there's nothing
		  that depends on csn order to be delivered on the target
		  side, it shouldn't hurt.  It would be difficult for a
		  target to even detect the csn gap as it has no idea when the
		  cmd with the csn was supposed to arrive.
	
	  nvme core doesn't quite treat the rq opaquely. Commands such
	  as WRITE ZEROES will return a non-zero rq payload_bytes yet
	  there is no actual payload to be transferred.
	  To get it right, key data transmission on there being 1 or
	  more physical segments in the sg list. If there is no
	  physical segments, there is no payload.
 Call LLDD map queue functionality if defined 
 force put free routine to ignore io queues 
 check for io queues existing 
 clearing of ctrl->flags ASSOC_ACTIVE bit is in association delete 
  This routine restarts the controller on the host side, and
  on the link side, recreates the controller association.
	
	  Create the admin queue
	
	  Check controller capabilities
	 
	  todo:- add code to check if ctrl attributes changed from
	  prior connection values
 sanity checks 
 FC-NVME does not have other data in the capsule 
 FC-NVME supports normal SGL Data Block Descriptors 
 warn if maxcmd is lower than queue_size 
 warn if sqsize is lower than queue_size 
	
	  Create the io queues
 Success 
 send a Disconnect(association) LS to fc-nvme target 
  This routine stops operation of the controller on the host side.
  On the host os stack side: Admin and IO queues are stopped,
    outstanding ios on them terminated via FC ABTS.
  On the link side: the association is terminated.
 kill the aens as they are a separate path 
 wait for all io that had to be aborted 
	
	  send a Disconnect(association) LS to fc-nvme target
	  Note: could have been sent at top of process, but
	  cleaner on link traffic if after the aborts complete.
	  Note: if association doesn't exist, association_id will be 0
		
		  if a Disconnect Request was waiting for a response, send
		  now that all ABTS's have been issued (and are complete).
 re-enable the admin_q so anything new can fast fail 
 resume the io queues so that things will fast fail 
	
	  kill the association on the link side.  this will block
	  waiting for io to terminate
 will block will waiting for io to terminate 
  Fails a controller request if it matches an existing controller
  (association) with the same tuple:
  <Host NQN, Host ID, local FC port, remote FC port, SUBSYS NQN>
  The ports don't need to be compared as they are intrinsically
  already matched by the port pointers supplied.
	
	  if ctrl_loss_tmo is being enforced and the default reconnect delay
	  is being used, change to a shorter reconnect delay for FC.
 io queue count 
 +1 for admin queue 
	
	  Would have been nice to init io queues tag set as well.
	  However, we require interaction from the controller
	  for max io queue count before we can do so.
	  Defer this to the connect path.
 at this point, teardown path changes to ref counting on nvme ctrl 
 initiate nvme ctrl ref counting teardown 
 Remove core ctrl ref. 
	 as we're past the point where we transition to the ref
	  counting teardown path, if we return a bad pointer here,
	  the calling routine, thinking it's prior to the
	  transition, will do an rport put. Since the teardown
	  path also does a rport put, we do an extra get here to
	  so proper orderteardown happens.
 exit via here doesn't follow ctlr ref points 
  This routine validates and extracts the WWN's from the TRADDR string.
  As kernel parsers need the 0x to determine number base, universally
  build string to parse with 0x prefix before parsing name strings.
 validate if string is one of the 2 allowed formats 
 find the host and remote ports to connect together 
 if fail to get reference fall through. Will error 
 Arbitrary successive failures max. With lots of subsystems could be high 
				
				  This is a temporary condition. Upon restart
				  this rport will be gone from the list.
				 
				  Revert the lport put and retry.  Anything
				  added to the list already will be skipped (as
				  they are no longer list_empty).  Loops should
				  resume at rports that were not yet seen.
 signal discovery. Won't hurt if it repeats 
 Parse the cgroup id from a buf and return the length of cgrpid 
  fc_update_appid: Parse and update the appid in the blkcg associated with
  cgroupid.
  @buf: buf contains both cgrpid and appid info
  @count: size of the buffer
	
	  NOTE:
	  It is expected that in the future the kernel will combine
	  the FC-isms that are currently under scsi and now being
	  added to by NVME into a new standalone FC class. The SCSI
	  and NVME protocols and their devices would be under this
	  new FC class.
	 
	  As we need something to post FC-specific udev events to,
	  specifically for nvme probe events, start by creating the
	  new device class.  When the new standalone FC class is
	  put in place, this code will move to a more generic
	  location for the class.
	
	  Create a device for the FC-centric udev events
 SPDX-License-Identifier: GPL-2.0
  NVMe over Fabrics RDMA host code.
  Copyright (c) 2015-2016 HGST, a Western Digital Company.
 3 second 
 read only in the hot path 
 other member variables 
  Disabling this option makes small IO goes faster, but is fundamentally
  unsafe.  With it turned off we will have to register a global rkey that
  allows read and write access to all physical memory.
	
	  Bind the CQEs (post recv buffers) DMA mapping to the RDMA queue
	  lifetime. It's safe, since any chage in the underlying RDMA device
	  will issue error recovery and queue re-creation.
 +1 for drain 
 +1 for drain 
 metadata nvme_rdma_sgl struct is located after command's data SGL 
	
	  The cm_id object might have been destroyed during RDMA connection
	  establishment error flow to avoid getting other cma events, thus
	  the destruction of the QP shouldn't use rdma_cm API.
	
	  Spread IO queues completion vectors according their queue index.
	  Admin queues can always go on completion vector 0.
 Polling queues need direct cq polling context 
 MR, SEND, INV 
 + RECV 
 +1 for ib_stop_cq 
	
	  Currently we don't use SG_GAPS MR's so if the first entry is
	  misaligned we'll end up using two entries for a single data page,
	  so one additional entry is required.
		
		  separate readwrite queues
		  hand out dedicated default queues only after we have
		  sufficient read queues.
		
		  shared readwrite queues
		  either no write queues were requested, or we don't have
		  sufficient queue count to have dedicated default queues.
 map dedicated poll queues only if we have queues left 
 T10-PI support 
	
	  Bind the async event SQE DMA mapping to the admin queue lifetime.
	  It's safe, since any chage in the underlying RDMA device will issue
	  error recovery and queue re-creation.
			
			  If we timed out waiting for freeze we are likely to
			  be stuck.  Fail the controller initialization just
			  to be safe.
 If we are resettingdeleting then do nothing 
		
		  state change failure is ok if we started ctrl delete,
		  unless we're during creation of a new controller to
		  avoid races with teardown flow.
 state change failure is ok if we started ctrl delete 
	
	  Align the MR to a 4K page size to match the ctrl page size and
	  the block virtual boundary.
 for WRITE_INSERTREAD_STRIP no memory domain 
 Clear the PRACT bit since HCA will generateverify the PI 
 for WRITE_PASSREAD_PASS both wirememory domains exist 
 send and recv completions 
 the local invalidation completion will end the request 
 sanity checking for received data length 
	
	  AEN requests are special as they don't time out and can
	  survive any kind of queue freeze and often don't respond to
	  aborts.  We don't even bother to allocate a struct request
	  for them but rather special case them here.
 maximum retry count 
	
	  set the admin queue depth to the minimum size
	  specified by the Fabrics standard.
		
		  current interpretation of the fabrics spec
		  is at minimum you make hrqsize sqsize+1, or a
		  1's based representation of sqsize.
 complete cm_done regardless of successfailure 
 device removal is handled via the ib_client API 
		
		  If we are resetting, connecting or deleting we should
		  complete immediately because we may block controller
		  teardown or setup sequence
		  - ctrl disableshutdown fabrics requests
		  - connect requests
		  - initialization admin requests
		  - IO requests that entered after unquiescing and
		    the controller stopped responding
		 
		  All other requests should be cancelled by the error
		  recovery work, so it's fine that we fail it here.
	
	  LIVE state should trigger the normal error recovery which will
	  handle completing this request.
 separate readwrite queues 
 shared readwrite queues 
 map dedicated poll queues only if we have queues left 
 state change failure should never happen 
  Fails a connection request if it matches an existing controller
  (association) with the same tuple:
  <Host NQN, Host ID, local address, remote address, remote port, SUBSYS NQN>
  if local address is not specified in the request, it will match an
  existing controller with all the other parameters the same and no
  local port address specified as well.
  The ports don't need to be compared as they are intrinsically
  already matched by the port pointers supplied.
 no quirks, we're perfect! );
 Delete all controllers using this device 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2017-2018 Christoph Hellwig.
  If multipathing is enabled we need to always use the subsystem instance
  number for numbering our devices to avoid conflicts between subsystems that
  have multiple controllers and thus use the multipath-aware subsystem node
  and those that have a single controller and use the controller node
  directly.
	
	  If we got back an ANA error, we know the controller is alive but not
	  ready to serve this namespace.  Kick of a re-read of the ANA
	  information page, and just try any other available path for now.
	
	  We don't treat NVME_CTRL_DELETING as a disabled path as IO should
	  still be able to complete assuming that the controller is connected.
	  Otherwise it will fail immediately and return to the requeue list.
	
	  The loop above skips the current path for round-robin semantics.
	  Fall back to the current path if either:
	   - no other optimized path found and current is optimized,
	   - no other usable path found and current is usable.
 fallthru 
	
	  The namespace might be going away and the bio might be moved to a
	  different queue via blk_steal_bios(), so we need to use the bio_split
	  pool from the original queue to allocate the bvecs from.
 CONFIG_BLK_DEV_ZONED 
	
	  Add a multipath node if the subsystems supports multiple controllers.
	  We also do this for private namespaces as the namespace sharing data could
	  change after a rescan.
	
	  This assumes all controllers that refer to a namespace either
	  support poll queues or not.  That is not a strict guarantee,
	  but if the assumption is wrong the effect is only suboptimal
	  performance but not correctness problem.
 set to a default value of 512 until the disk is validated 
 we need to propagate up the VMC settings 
	
	  test_and_set_bit() is used because it is protecting against two nvme
	  paths simultaneously calling device_add_disk() on the same namespace
	  head.
	
	  In theory we should have an ANATT timer per group as they might enter
	  the change state at different times.  But that is a lot of overhead
	  just to protect against a target that keeps entering new changes
	  states while never finishing previous ones.  But we'll still
	  eventually time out once all groups are in change state, so this
	  isn't a big deal.
	 
	  We also double the ANATT value to provide some slack for transports
	  or AEN processing overhead.
 just break out of the loop 
 found the group desc: update 
 group desc not found: trigger a re-read 
 make sure all pending bios are cleaned up 
 check if multipath is enabled and we have the capability 
 SPDX-License-Identifier: GPL-2.0
  NVM Express hardware monitoring support
  Copyright (c) 2019, Guenter Roeck
	
	  First handle attributes which don't require us to read
	  the smart log.
 SPDX-License-Identifier: GPL-2.0
  NVMe over Fabrics TCP host.
  Copyright (c) 2018 Lightbits Labs. All rights reserved.
 Define the socket priority to use for connections were it is desirable
  that the NIC consider performing optimized packet processing or filtering.
  A non-zero value being sufficient to indicate general consideration of any
  possible optimization.  Making it a module param allows for alternative
  values that may be unique for some NIC implementations.
 send state 
 recv state 
 send state 
 read only in the hot path 
 other member variables 
 async events don't have a request 
 drain the send queue as much as we can... 
	
	  if we're the first on the send_list and we can try to send
	  directly, otherwise queue io_work. Also, only do that if we
	  are on the same cpu, so we don't introduce contention.
	
	  AEN requests are special as they don't time out and can
	  survive any kind of queue freeze and often don't respond to
	  aborts.  We don't even bother to allocate a struct request
	  for them but rather special case them here.
			
			  If we don`t have any bios it means that controller
			  sent more data than we requested, hence error
 we can read only from what is left in this bio 
		
		  update the request iterator except for the last payload send
		  in the request where we don't want to modify it as we may
		  compete with the RX path completing the request.
 fully successful last send in current PDU 
 quota is exhausted 
 single inflight r2t supported 
 no alignment constraint 
 Single syn retry 
 Set TCP no delay 
	
	  Cleanup whatever is sitting in the TCP transmit queue on socket
	  close. This is done to prevent stale data from being sent should
	  the network connection be restored before TCP times out.
 Set socket type of service 
 Set 10 seconds timeout for icresp recvmsg 
		
		  separate readwrite queues
		  hand out dedicated default queues only after we have
		  sufficient read queues.
		
		  shared readwrite queues
		  either no write queues were requested, or we don't have
		  sufficient queue count to have dedicated default queues.
 map dedicated poll queues only if we have queues left 
			
			  If we timed out waiting for freeze we are likely to
			  be stuck.  Fail the controller initialization just
			  to be safe.
 If we are resettingdeleting then do nothing 
		
		  state change failure is ok if we started ctrl delete,
		  unless we're during creation of a new controller to
		  avoid races with teardown flow.
 unquiesce to fail fast pending requests 
 state change failure is ok if we started ctrl delete 
 state change failure is ok if we started ctrl delete 
		
		  If we are resetting, connecting or deleting we should
		  complete immediately because we may block controller
		  teardown or setup sequence
		  - ctrl disableshutdown fabrics requests
		  - connect requests
		  - initialization admin requests
		  - IO requests that entered after unquiescing and
		    the controller stopped responding
		 
		  All other requests should be cancelled by the error
		  recovery work, so it's fine that we fail it here.
	
	  LIVE state should trigger the normal error recovery which will
	  handle completing this request.
 separate readwrite queues 
 shared readwrite queues 
 map dedicated poll queues only if we have queues left 
 SPDX-License-Identifier: GPL-2.0
  NVM Express device driver
  Copyright (c) 2011-2014, Intel Corporation.
  These can be higher, but we need to ensure that any command doesn't
  require an sg allocation that needs more than a page of data.
  Represents an NVM Express device.  Each nvme_dev is a PCI function.
 shadow doorbell buffer support: 
 host memory buffer support: 
  An NVM Express queue.  Each device has at least two (one for admin
  commands and one for IO commands).
 only used for poll queues: 
  The nvme_iod describes the data in an IO.
  The sg pointer contains the list of PRPSGL chunk allocations in addition
  to the actual struct scatterlist.
 In the PRP list. 0 means small pool in use 
 Used in scatterlist 
 length of single DMA segment mapping 
		
		  Clear the dbbuf memory so the driver doesn't observe stale
		  values from the previous instantiation.
 Free memory and continue on 
 Update dbbuf and return true if an MMIO is required 
		
		  Ensure that the queue is written before updating
		  the doorbell in memory
		
		  Ensure that the doorbell is updated before reading the event
		  index from memory.  The controller needs to provide similar
		  ordering to ensure the envent index is updated before reading
		  the doorbell.
  Will slightly overestimate the number of pages needed.  This is OK
  as it only leads to a small amount of wasted memory for the lifetime of
  the IO.
  Calculates the number of pages needed for the SGL segments. For example a 4k
  page can accommodate 256 SGL descriptors.
 if we have more than 1 vec, admin queue offsets us by 1 
		
		  The poll queue(s) doesn't have an IRQ (and hence IRQ
		  affinity), so use the regular blk-mq cpu mapping
  Write sq tail if we are asked to, or if the next command would wrap.
  nvme_submit_cmd() - Copy a command into a queue and ring the doorbell
  @nvmeq: The queue to use
  @cmd: The command to send
  @write_sq: whether to write to the SQ doorbell
 setting the transfer type as SGL 
  NOTE: ns is NULL when called on the admin queue.
	
	  We should not need to do this, but we're still using this to
	  ensure we can drain requests on a dying queue.
 We read the CQE phase first to check if the rest of the entry is valid 
	
	  AEN requests are special as they don't time out and can
	  survive any kind of queue freeze and often don't respond to
	  aborts.  We don't even bother to allocate a struct request
	  for them but rather special case them here.
		
		  load-load control dependency between phase and the rest of
		  the cqe requires a full read memory barrier
  Poll for completions for any interrupt driven queue
  Can be called from any context.
	
	  Note: we (ab)use the fact that the prp fields survive if no data
	  is attached to the request.
	
	  Some drives have a bug that auto-enables WRRU if MEDIUM isn't
	  set. Since URGENT priority is zeroes, it makes all queues
	  URGENT.
	
	  Note: we (ab)use the fact that the prp fields survive if no data
	  is attached to the request.
	 If true, indicates loss of adapter communication, possibly by a
	  NVMe Subsystem reset.
 If there is a resetreinit ongoing, we shouldn't reset again. 
	 We shouldn't reset unless the controller is on fatal error state
	  _or_ if we lost the communication with it.
 Read a config register to help see what died. 
	 If PCI error recovery process is happening, we cannot reset or
	  the recovery mechanism will surely fail.
	
	  Reset immediately if the controller is failed
	
	  Did we miss an interrupt?
	
	  Shutdown immediately if controller times out while starting. The
	  reset work will see the pci device disabled when it gets the forced
	  cancellation error. All outstanding requests are completed on
	  shutdown, so we return BLK_EH_DONE.
	
	  Shutdown the controller immediately and schedule a reset if the
	  command was already aborted once before and still hasn't been
	  returned to the driver, or if this is the admin queue.
	
	  The aborted req will be completed on receiving the abort req.
	  We enable the timer again. If hit twice, it'll cause a device reset,
	  as the device then is in a faulty state.
  nvme_suspend_queue - put queue into suspended state
  @nvmeq: queue to suspend
 ensure that nvme_queue_rq() sees NVMEQ_ENABLED cleared 
  Called only on a device that has been disabled and after all other threads
  that can check this device's completion queues have synced, except
  nvme_poll(). This is the last chance for the driver to see a natural
  completion before nvme_cancel_request() terminates all incomplete requests.
		
		  Ensure the reduced q_depth is above some threshold where it
		  would be better to map queues in system memory with the
		  original depth
 ensure the first interrupt sees the initialization 
  Try getting shutdown_lock while setting up IO queues.
	
	  Give up if the lock is being held by nvme_dev_disable.
	
	  Controller is in wrong state, fail early.
	
	  A queue's vector matches the queue identifier unless the controller
	  has only one vector available.
		
		  If the controller was reset during removal, it's possible
		  user requests may be waiting on a stopped queue. Start the
		  queue to flush these to completion.
	
	  Ignore failing Create SQCQ commands, we can continue with less
	  than the desired amount of queues, and even a controller without
	  IO queues can still be used to issue admin commands.  This might
	  be useful to upgrade a buggy firmware for example.
	
	  Tell the controller about the host side address mapping the CMB,
	  and enable CMB decoding for the NVMe 1.4+ scheme:
	
	  Controllers may support a CMB size larger than their BAR,
	  for example, due to being behind a bridge. Reduce the CMB to
	  the reported size of the BAR
 start big and work our way down 
	
	  If we already have a buffer allocated check if we can reuse it.
 controller must work without HMB 
  nirqs is the number of interrupts available for write and read
  queues. The core already reserved an interrupt for the admin queue.
	
	  If there is no interrupt available for queues, ensure that
	  the default queue is set to 1. The affinity set size is
	  also set to one, but the irq core ignores it for this case.
	 
	  If only one interrupt is available or 'write_queue' == 0, combine
	  write and read queues.
	 
	  If 'write_queues' > 0, ensure it leaves room for at least one read
	  queue.
	
	  Poll queues don't need interrupts, but we need at least one IO queue
	  left over for non-polled IO.
	
	  Initialize for the single interrupt case, will be updated in
	  nvme_calc_irq_sets().
	
	  We need interrupts for the admin queue and each non-polled IO queue,
	  but some Apple controllers require all queues to use the first
	  vector.
	
	  If tags are shared with admin queue (Apple bug), then
	  make sure we only use one IO queue.
	
	  Sample the module parameters once at reset time so that we have
	  stable values to work with.
	
	  Free IRQ resources as soon as NVMEQ_ENABLED bit transitions
	  from set to unset. If there is a window to it is truely freed,
	  pci_free_irq_vectors() jumping into this window will crash.
	  And take lock to avoid racing with pci_free_irq_vectors() in
	  nvme_dev_disable() path.
 Deregister the admin queue's interrupt 
	
	  If we enable msix early due to not intx, disable it again before
	  setting up the full range we need.
	
	  Should investigate if there's a performance win from allocating
	  more queues than interrupt vectors; it might allow the submission
	  path to scale better, even if the receive path is limited by the
	  number of interrupts.
 default + read 
		
		  Some Apple controllers requires tags to be unique
		  across admin and IO queue, so reserve the first 32
		  tags of the IO queue.
 Free previously allocated queues that are no longer usable 
	
	  Some devices andor platforms don't advertise or work with INTx
	  interrupts. Pre-enable a single MSIX or MSI vec for setup. We'll
	  adjust this later.
 0's based queue depth 
	
	  Some Apple controllers require a non-standard SQE size.
	  Interestingly they also seem to ignore the CC:IOSQES register
	  so we don't bother updating it here.
	
	  Temporary fix for the Apple controller found in the MacBook8,1 and
	  some MacBook7,1 to avoid controller resets and data loss.
	
	  Controllers with the shared tags quirk need the IO queue to be
	  big enough so that we get 32 tags for the admin queue
	
	  Give the controller a chance to complete all entered requests if
	  doing a safe shutdown.
	
	  The driver will not be starting up queues again if shutting down so
	  must flush all entered requests to their failed completion to avoid
	  deadlocking blk-mq hot-cpu notifier.
 Optimisation for IOs between 4k and 128k 
	
	  Set state to deleting now to avoid blocking nvme_wait_reset(), which
	  may be holding this pci_dev's device lock.
	
	  If we're called to reset a live controller first shut it down before
	  moving on.
	
	  Limit the max command size to prevent iod->sg allocations going
	  over a single page.
	
	  Don't limit the IOMMU merged segment size.
	
	  Introduce CONNECTING state from nvme-fcrdma transports to mark the
	  initializing procedure here.
	
	  We do not support an SGL for metadata (yet), so we are limited to a
	  single integrity segment for the separate metadata pointer.
	
	  Keep the controller around but remove all namespaces if we don't have
	  any working IO queue.
	
	  If only admin queue live, keep it to do further investigation or
	  recovery.
		
		  Several Samsung devices seem to drop off the PCIe bus
		  randomly when APST is on and uses the deepest sleep state.
		  This has been observed on a Samsung "SM951 NVMe SAMSUNG
		  256GB", a "PM951 NVMe SAMSUNG 512GB", and a "Samsung SSD
		  950 PRO 256GB", but it seems to be restricted to two Dell
		  laptops.
		
		  Samsung SSD 960 EVO drops off the PCIe bus after system
		  suspend on a Ryzen board, ASUS PRIME B350M-A, as well as
		  within few minutes after bootup on a Coffee Lake board -
		  ASUS PRIME Z370-A
		
		  Forcing to use host managed nvme power settings for
		  lowest idle power with quick resume latency on
		  Samsung and Toshiba SSDs based on suspend behavior
		  on Coffee Lake board for LENOVO C640
		
		  Some systems use a bios work around to ask for D3 on
		  platforms that support kernel managed suspend.
	
	  Double check that our mempool alloc size will cover the biggest
	  command we support.
	
	  We don't need to check the return value from waiting for the reset
	  state as pci_dev device lock is held, making it impossible to race
	  with ->remove().
  The driver's remove may be called on a device in a partially initialized
  state. This function must not have any dependencies on the device state in
  order to proceed.
	
	  The platform does not remove power for a kernel managed suspend so
	  use host managed nvme power settings for lowest idle power if
	  possible. This should have quicker resume latency than a full device
	  shutdown.  But if the firmware is involved after the suspend or the
	  device does not support any non-default power states, shut down the
	  device fully.
	 
	  If ASPM is not enabled for the device, shut down the device and allow
	  the PCI bus layer to put it into D3 in order to take the PCIe link
	  down, so as to allow the platform to achieve its minimum low-power
	  state (which may not be possible if the link is up).
	
	  Host memory access may not be successful in a system suspend state,
	  but the specification allows the controller to access memory in a
	  non-operational power state.
	
	  A saved state prevents pci pm from generically controlling the
	  device's power. If we're using protocol specific settings, we don't
	  want pci interfering.
 discard the saved state 
		
		  Clearing npss forces a controller reset on resume. The
		  correct value will be rediscovered then.
 CONFIG_PM_SLEEP 
	
	  A frozen channel requires a reset. When detected, this method will
	  shutdown the controller to quiesce. The controller will be restarted
	  after the slot reset through driver's slot_reset callback.
 Intel 750P3500P3600P3700 
 Intel P3520 
 Intel P4500P4600 
 Dell Express Flash P4600 
 Intel 600PP3100 
 Intel 760pPro 7600p 
 Qemu emulated controller 
 Silicon Motion unidentified 
 Seagate Nytro Flash Storage 
 HGST adapter 
 WDC SN200 adapter 
 Memblaze Pblaze4 adapter 
 Samsung PM1725 
 Samsung PM1725a 
 Phison E16 
 Lexar 256 GB SSD 
 ADATA SX6000LNP 
 ADATA SX8200PNP 512GB 
 SK Hynix PC400 
  Sandisk Skyhawk 
 SPCC 
 KINGSTON SKC2000 NVMe SSD 
 KINGSTON A2000 NVMe SSD  
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020 Western Digital Corporation or its affiliates.
 Driver requires zone append support 
 Lazily query controller append limit for the first zoned namespace 
	
	  We currently do not handle devices requiring any of the zoned
	  operation characteristics.
 SPDX-License-Identifier: GPL-2.0
  fault injection support for nvme.
  Copyright (c) 2018, Oracle andor its affiliates
 optional fault injection attributes boot time option:
  nvme_core.fail_request=<interval>,<probability>,<space>,<times>
 set default fault injection attribute 
 create debugfs directory and attribute 
 create debugfs for status code and dont_retry 
 remove debugfs directories 
 inject status code and DNR bit 
 SPDX-License-Identifier: GPL-2.0
  NVMe over Fabrics common host code.
  Copyright (c) 2015-2016 HGST, a Western Digital Company.
  nvmf_get_address() -  Get addressport
  @ctrl:	Host NVMe controller instance which we got the address
  @buf:	OUTPUT parameter that will contain the addressport
  @size:	buffer size
  nvmf_reg_read32() -  NVMe Fabrics "Property Get" API function.
  @ctrl:	Host NVMe controller instance maintaining the admin
 		queue used to submit the property read command to
 		the allocated NVMe controller resource on the target system.
  @off:	Starting offset value of the targeted property
 		register (see the fabrics section of the NVMe standard).
  @val:	OUTPUT parameter that will contain the value of
 		the property after a successful read.
  Used by the host system to retrieve a 32-bit capsule property value
  from an NVMe controller on the target system.
  ("Capsule property" is an "PCIe register concept" applied to the
  NVMe fabrics space.)
  Return:
 	0: successful read
 	> 0: NVMe error status code
 	< 0: Linux errno error code
  nvmf_reg_read64() -  NVMe Fabrics "Property Get" API function.
  @ctrl:	Host NVMe controller instance maintaining the admin
 		queue used to submit the property read command to
 		the allocated controller resource on the target system.
  @off:	Starting offset value of the targeted property
 		register (see the fabrics section of the NVMe standard).
  @val:	OUTPUT parameter that will contain the value of
 		the property after a successful read.
  Used by the host system to retrieve a 64-bit capsule property value
  from an NVMe controller on the target system.
  ("Capsule property" is an "PCIe register concept" applied to the
  NVMe fabrics space.)
  Return:
 	0: successful read
 	> 0: NVMe error status code
 	< 0: Linux errno error code
  nvmf_reg_write32() -  NVMe Fabrics "Property Write" API function.
  @ctrl:	Host NVMe controller instance maintaining the admin
 		queue used to submit the property read command to
 		the allocated NVMe controller resource on the target system.
  @off:	Starting offset value of the targeted property
 		register (see the fabrics section of the NVMe standard).
  @val:	Input parameter that contains the value to be
 		written to the property.
  Used by the NVMe host system to write a 32-bit capsule property value
  to an NVMe controller on the target system.
  ("Capsule property" is an "PCIe register concept" applied to the
  NVMe fabrics space.)
  Return:
 	0: successful write
 	> 0: NVMe error status code
 	< 0: Linux errno error code
  nvmf_log_connect_error() - Error-parsing-diagnostic print out function for
  				connect() errors.
  @ctrl:	The specific devnvmeX device that had the error.
  @errval:	Error code to be decoded in a more human-friendly
  		printout.
  @offset:	For use with the NVMe error code
  		NVME_SC_CONNECT_INVALID_PARAM.
  @cmd:	This is the SQE portion of a submission capsule.
  @data:	This is the "Data" portion of a submission capsule.
  nvmf_connect_admin_queue() - NVMe Fabrics Admin Queue "Connect"
 				API function.
  @ctrl:	Host nvme controller instance used to request
               a new NVMe controller allocation on the target
               system and  establish an NVMe Admin connection to
               that controller.
  This function enables an NVMe host device to request a new allocation of
  an NVMe controller resource on a target system as well establish a
  fabrics-protocol connection of the NVMe Admin queue between the
  host system device and the allocated NVMe controller on the
  target system via a NVMe Fabrics "Connect" command.
  Return:
 	0: success
 	> 0: NVMe error status code
 	< 0: Linux errno error code
	
	  Set keep-alive timeout in seconds granularity (ms  1000)
  nvmf_connect_io_queue() - NVMe Fabrics IO Queue "Connect"
 			     API function.
  @ctrl:	Host nvme controller instance used to establish an
 		NVMe IO queue connection to the already allocated NVMe
 		controller on the target system.
  @qid:	NVMe IO queue number for the new IO connection between
 		host and target (note qid == 0 is illegal as this is
 		the Admin queue, per NVMe standard).
  This function issues a fabrics-protocol connection
  of a NVMe IO queue (via NVMe Fabrics "Connect" command)
  between the host system device and the allocated NVMe controller
  on the target system.
  Return:
 	0: success
 	> 0: NVMe error status code
 	< 0: Linux errno error code
  nvmf_register_transport() - NVMe Fabrics Library registration function.
  @ops:	Transport ops instance to be registered to the
 		common fabrics library.
  API function that registers the type of specific transport fabric
  being implemented to the common NVMe fabrics library. Part of
  the overall init sequence of starting up a fabrics driver.
  nvmf_unregister_transport() - NVMe Fabrics Library unregistration function.
  @ops:	Transport ops instance to be unregistered from the
 		common fabrics library.
  Fabrics API function that unregisters the type of specific transport
  fabric being implemented from the common NVMe fabrics library.
  Part of the overall exit sequence of unloading the implemented driver.
 Set defaults 
 < 0 == use transport default 
 Allowed for debug 
	
	  Checking the local address is rough. In most cases, none is specified
	  and the host port is selected by the stack.
	 
	  Assume no match if:
	  -  local address is specified and address is not the same
	  -  local address is not specified but remote is, or vice versa
	     (admin using specific host_traddr when it matters).
	
	  Check the generic options first as we need a valid transport for
	  the lookup below.  Then clear the generic flags so that transport
	  drivers don't have to care about them.
	
	  The miscdevice code initializes file->private_data, but doesn't
	  make use of it later.
 SPDX-License-Identifier: GPL-2.0
  NVM Express device driver
  Copyright (c) 2011-2014, Intel Corporation.
  nvme_wq - hosts nvme related works that are not reset or delete
  nvme_reset_wq - hosts nvme reset works
  nvme_delete_wq - hosts nvme delete works
  nvme_wq will host works such as scan, aen handling, fw activation,
  keep-alive, periodic reconnects etc. nvme_reset_wq
  runs reset works which also flush works hosted on nvme_wq for
  serialization purposes. nvme_delete_wq host controller deletion
  works which flush reset works for serialization.
	
	  Only new queue scan work when admin and IO queues are both alive
  Use this function to proceed with scheduling reset_work for a controller
  that had previously been set to the resetting state. This is intended for
  code paths that can't be interrupted by other reset attempts. A hot removal
  may prevent this from succeeding.
	
	  Keep a reference until nvme_do_delete_ctrl() complete,
	  since ->delete_ctrl can free the controller.
 The mask and shift result must be <= 3 
  Called to unwind from ->queue_rq on a failed command submission so that the
  multipathing code gets called to potentially failover to another path.
  The caller needs to unwind all transport specific resource allocations and
  must return propagate the return value.
 don't abort one completed request 
  Returns true for sink states that can't ever transition back to live.
  Waits for the controller state to be resetting, or returns false if it is
  not possible to ever transition to that state.
 no queuedata implies admin queue 
 passthru commands should let the driver set the SGL flags 
  For something we're not in a state to send to the device the default action
  is to busy it and retry it after the controller state is recovered.  However,
  if the controller is deleting or if anything is marked for failfast or
  nvme multipath it is immediately failed.
  Note: commands used to initialize the controller will be marked for failfast.
  Note: nvme cliioctl commands are marked for failfast.
	
	  currently we have a problem sending passthru commands
	  on the admin_q if the controller is not LIVE because we can't
	  make sure that they are going out after the admin connect,
	  controller enable andor other commands in the initialization
	  sequence. until the controller will be LIVE, fail with
	  BLK_STS_RESOURCE so that they will be rescheduled.
		
		  Only allow commands on a live queue, except for the connect
		  command, which is require to set the queue live in the
		  appropinquate states.
  Check if 'req' has a write hint associated with it. If it does, assign
  a valid namespace stream to the write.
	
	  Some devices do not consider the DSM 'Number of Ranges' field when
	  determining how much data to DMA. Always allocate memory for maximum
	  number of segments to prevent device reading beyond end of buffer.
		
		  If we fail allocation our range, fallback to the controller
		  discard page. If that's also busy, it's safe to return
		  busy, as we know we can make progress once that's freed.
		
		  If formated with metadata, the block layer always provides a
		  metadata buffer if CONFIG_BLK_DEV_INTEGRITY is enabled.  Else
		  we enable the PRACT bit for protection information or set the
		  namespace capacity to zero to prevent any IO.
 these are setup prior to execution in nvme_init_request() 
  Return values:
  0:  success
  >0: nvme controller's cqe status response
  <0: kernel error in lieu of controller response
  Returns 0 on success.  If the result is negative, it's a Linux error code;
  if the result is positive, it's an NVM Express status code
	
	  For simplicity, IO to all namespaces is quiesced even if the command
	  effects say only one namespace is affected.
			
			  Keep alive commands interval on the host should be
			  updated when KATO is modified by Set Features
			  commands.
 nothing to be done for zero cmd effects 
  Recommended frequency for KATO commands per NVMe 1.4 section 7.12.1:
    The host should send Keep Alive commands at half of the Keep Alive Timeout
    accounting for transport roundtrip times [..].
 allocation failure, reset the controller 
  In NVMe 1.0 the CNS field was just a binary controller or namespace
  flag, thus sending any new CNS opcodes has a big chance of not working.
  Qemu unfortunately had that bug after reporting a 1.1 version compliance
  (but not for any later version).
 gcc-4.4.4 (at least) has issues with initializers and anon unions 
 Skip unknown types 
 gcc-4.4.4 (at least) has issues with initializers and anon unions 
 namespace not allocated or attached 
	
	  Degraded controllers might return an error when setting the queue
	  count.  We still want to be able to bring them online and offer
	  access to the admin queue, as that might be only way to fix them up.
 should never be called due to GENHD_FL_HIDDEN 
 some standard values 
 CONFIG_BLK_DEV_INTEGRITY 
 If discard is already enabled, don't reset queue limits 
	
	  The PI implementation requires the metadata size to be equal to the
	  t10 pi tuple size.
		
		  The NVMe over Fabrics specification only supports metadata as
		  part of the extended data LBA.  We rely on HCAHBA support to
		  remap the separate metadata buffer from the block layer.
		
		  For PCIe controllers, we can't easily remap the separate
		  metadata buffer from the block layer and thus require a
		  separate metadata buffer for block layer metadataPI support.
		  We allow extended LBAs for the passthrough interface, though.
	
	  The block layer can't support LBA sizes larger than the page size
	  yet, so catch this early and don't allow block IO.
		
		  Bit 1 indicates whether NAWUPF is defined for this namespace
		  and whether it should be used instead of AWUPF. If NAWUPF ==
		  0 then AWUPF must be used instead.
 NPWG = Namespace Preferred Write Granularity 
 NOWS = Namespace Optimal Write Size 
	
	  Linux filesystems assume writing a single physical block is
	  an atomic operation. Hence limit the physical block size to the
	  value of the Atomic Write Unit Power Fail parameter.
	
	  Register a metadata profile for PI, or the plain non-integrity NVMe
	  metadata masquerading as Type 0 if supported, otherwise reject block
	  IO to namespaces with metadata except when the namespace supports
	  PI, as it can stripinsert in that case.
 nvme_alloc_ns() scans the disk prior to adding it 
	
	  If probing fails due an unsupported feature, hide the block device,
	  but still allow other access.
 PTPL=1 
 CONFIG_BLK_SED_OPAL 
 CONFIG_BLK_DEV_ZONED 
  If the device has been passed off to us in an enabled state, just clear
  the enabled bit.  The spec says we should set the 'shutdown notification
  bits', but doing so may cause the device to complete commands to the
  admin queue ... and we don't know what memory that might be pointing at!
 Don't bother enabling the feature if retry delay is not reported 
  The function checks whether the given total (exlat + enlat) latency of
  a power state allows the latter to be used as an APST transition target.
  It does so by comparing the latency to the primary and secondary latency
  tolerances defined by module params. If there's a match, the corresponding
  timeout value is returned and the matching tolerance index (1 or 2) is
  reported.
  APST (Autonomous Power State Transition) lets us program a table of power
  state transitions that the controller will perform automatically.
  Depending on module params, one of the two supported techniques will be used:
  - If the parameters provide explicit timeouts and tolerances, they will be
    used to build a table with up to 2 non-operational states to transition to.
    The default parameter values were selected based on the values used by
    Microsoft's and Intel's NVMe drivers. Yet, since we don't implement dynamic
    regeneration of the APST table in the event of switching between external
    and battery power, the timeouts and tolerances reflect a compromise
    between values used by Microsoft for AC and battery scenarios.
  - If not, we'll configure the table with a simple heuristic: we are willing
    to spend at most 2% of the time transitioning between power states.
    Therefore, when running in any given state, we will enter the next
    lower-power non-operational state after waiting 50  (enlat + exlat)
    microseconds, as long as that state's exit latency is under the requested
    maximum latency.
  We will not autonomously enter any non-operational state for which the total
  latency exceeds ps_max_latency_us.
  Users can set ps_max_latency_us to zero to turn off APST.
	
	  If APST isn't supported or if we haven't been initialized yet,
	  then don't do anything.
 Turn off APST. 
	
	  Walk through all states from lowest- to highest-power.
	  According to the spec, lower-numbered states use more power.  NPSS,
	  despite the name, is the index of the lowest-power state, not the
	  number of states.
		
		  Don't allow transitions to the deepest state if it's quirked
		  off.
		
		  Is this state a useful non-operational state for higher-power
		  states to autonomously transition to?
		
		  This state is good. It can be used as the APST idle target
		  for higher power states.
	
	  NVMe model and firmware strings are padded with spaces.  For
	  simplicity, strings in the quirk table are padded with NULLs
	  instead.
		
		  This Toshiba device seems to die using any APST states.  See:
		  https:bugs.launchpad.netubuntu+sourcelinux+bug1678184comments11
		
		  This LiteON CL1-3D-Q11 firmware version has a race
		  condition associated with actions related to suspend to idle
		  LiteON has resolved the problem in future firmware
 match is null-terminated but idstr is space-padded. 
 Generate a "fake" NQN per Figure 254 in NVMe 1.3 + ECN 001 
	
	  Fail matches for discovery subsystems. This results
	  in each discovery controller bound to a unique subsystem.
	  This avoids issues with validating controller values
	  that can only be true when there is a single unique subsystem.
	  There may be multiple and completely independent entities
	  that provide discovery controllers.
 Versions prior to 1.4 don't necessarily report a valid type 
	
	  Even though NVMe spec explicitly states that MDTS is not applicable
	  to the write-zeroes, we are cautious and limit the size to the
	  controllers max_hw_sectors value, which is based on the MDTS field
	  and possibly other limiting factors.
		
		  Check for quirks.  Quirk can depend on firmware version,
		  so, in principle, the set of quirks present can change
		  across a reset.  As a possible future enhancement, we
		  could re-scan for quirks every time we reinitialize
		  the device, but we'd have to make sure that the driver
		  behaves intelligently if the quirks change.
 us -> s 
		
		  In fabrics we need to verify the cntlid matches the
		  admin connect
  Initialize the cached copies of the Identify data and various controller
  register in our nvme_ctrl structure.  This should be called as soon as
  the admin queue is fully up and running.
	 For backward compatibility expose the NGUID to userspace if
	  we have no UUID set
 per-path attr 
  Add the namespace to the controller list while keeping the list ordered.
	
	  Without the multipath code enabled, multiple controller per
	  subsystems are visible as devices and thus we cannot use the
	  subsystem instance.
 guarantee not available in head->list 
 wait for concurrent submissions 
	
	  Only remove the namespace if we got a fatal error back from the
	  device, otherwise ignore the error and just move on.
	 
	  TODO: we should probably schedule a delayed retry here.
 end of the list? 
	
	  We need to read the log to clear the AEN, but we don't want to rely
	  on it for the changed namespace information as userspace could have
	  raced with us in reading the log page, which could cause us to miss
	  updates.
 No tagset on a live ctrl means IO queues could not created 
  This function iterates the namespace list unlocked to allow recovery from
  controller failure. It is up to the caller to ensure the namespace list is
  not modified by scan work while this function is executing.
	
	  make sure to requeue IO to all namespaces as these
	  might result from the scan itself and must complete
	  for the scan_work to make progress
 prevent racing with ns scanning 
	
	  The dead states indicates the controller was not gracefully
	  disconnected. In that case, we won't be able to flush any data while
	  removing the namespaces' disks; fail all the queues now to avoid
	  potentially having to clean up the failed sync later.
 this is a no-op when called from the controller reset handler 
 read FW slot information to clear the AER 
		
		  We are (ab)using the RESETTING state to prevent subsequent
		  recovery actions from interfering with the controller's
		  firmware activation.
  Initialize a NVMe controller structures.  This needs to be called during
  earliest initialization so that we have the initialized structured around
  during probing.
	
	  Initialize latency tolerance controls.  The sysfs files won't
	  be visible to userspace unless the device actually supports APST.
  Prepare a queue for teardown.
  This must forcibly unquiesce queues to avoid blocking dispatch, and only set
  the capacity to 0 after that to avoid blocking dispatchers that may be
  holding bd_butex.  This will end buffered writers dirtying pages that can't
  be synced.
  nvme_kill_queues(): Ends all namespace queues
  @ctrl: the dead controller that needs to end
  Call this function when the driver determines it is unable to get the
  controller in a state capable of servicing IO.
 Forcibly unquiesce queues to avoid blocking dispatch 
  Check we didn't inadvertently grow the command structure sizes:
 SPDX-License-Identifier: GPL-2.0
  NVM Express device driver tracepoints
  Copyright (c) 2018 Johannes Thumshirn, SUSE Linux GmbH
 SPDX-License-Identifier: GPL-2.0+
 Copyright (c) 2013-2014 Freescale Semiconductor, Inc
 Copyright (c) 2017 Sysam, Angelo Dureghello  <angelo@sysam.it>
		 ColdFire is big endian, and accesses natively
		  big endian IO peripherals
		 ColdFire is big endian, and accesses natively
		  big endian IO peripherals
 Already mapped for this config? 
 calculate the total size in this desc 
 figure out the finished and calculate the residue 
	
	  TCD parameters are stored in struct fsl_edma_hw_tcd in little
	  endian format. However, we need to load the TCD registers in
	  big- or little-endian obeying the eDMA engine model endian,
	  and this is performed from specific edma_write functions
	
	  eDMA hardware SGs require the TCDs to be stored in little
	  endian format irrespective of the register endian model.
	  So we put the value in little endian in memory, waiting
	  for fsl_edma_set_tcd_regs doing the swap.
 get next sg's physical address 
 get next sg's physical address 
 To match with copy_align and max_seg_size so 1 tcd is enough 
 cannot submit due to suspend 
  On the 32 channels Vybridmpc577x edma version (here called "v1"),
  register offsets are different compared to ColdFire mcf5441x 64 channels
  edma (here called "v2").
  This function sets up register offsets as per proper declared version
  so must be called in xxx_edma_probe() just after setting the
  edma "version" and "membase" appropriately.
 SPDX-License-Identifier: GPL-2.0-only
  Topcliff PCH DMA controller driver
  Copyright (c) 2010 Intel Corporation
  Copyright (C) 2011 LAPIS Semiconductor Co., Ltd.
 ch8-->0 ch9-->1 ... ch11->3 
 ch8-->0 ch9-->1 ... ch11->3 
 clear interrupt bits in status register 
 PCI Device ID of DMA device 
 UART Video 
 PCMIF SPI 
 FPGA 
 I2S 
 UART 
 Video SPI 
 Security 
 FPGA 
 UART 
 SPI 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright(c) 2004 - 2006 Intel Corporation. All rights reserved.
  This code implements the DMA subsystem. It provides a HW-neutral interface
  for other kernel code to use asynchronous memory copy capabilities,
  if present, and allows different HW DMA drivers to register as providing
  this capability.
  Due to the fact we are accelerating what is already a relatively fast
  operation, the code goes to great lengths to avoid additional overhead,
  such as locking.
  LOCKING:
  The subsystem keeps a global list of dma_device structs it is protected by a
  mutex, dma_list_mutex.
  A subsystem can get access to a channel by calling dmaengine_get() followed
  by dma_find_channel(), or if it has need for an exclusive channel it can call
  dma_request_channel().  Once a channel is allocated a reference is taken
  against its corresponding driver to disable removal.
  Each device has a channels list, which runs unlocked but is never modified
  once the device is registered, it's just setup by the driver.
  See Documentationdriver-apidmaengine for more details
 --- debugfs implementation --- 
 syskerneldebugdmaenginesummary 
 DEBUG_FS 
 --- sysfs implementation --- 
  dev_to_dma_chan - convert a device pointer to its sysfs container object
  @dev:	device node
  Must be called under dma_list_mutex.
 --- client and device registration --- 
 enable iteration over all operation types 
  struct dma_chan_tbl_ent - tracks channel allocations per coreoperation
  @chan:	associated channel for this entry
 percpu lookup table for memory-to-memory offload providers 
	 'interrupt', 'private', and 'slave' are channel capabilities,
	  but are not associated with an operation so they do not need
	  an entry in the channel_table
  dma_chan_is_local - checks if the channel is in the same NUMA-node as the CPU
  @chan:	DMA channel to test
  @cpu:	CPU index which the channel should be close to
  Returns true if the channel is in the same NUMA-node as the CPU.
  min_chan - finds the channel with min count and in the same NUMA-node as the CPU
  @cap:	capability to match
  @cpu:	CPU index which the channel should be close to
  If some channels are close to the given CPU, the one with the lowest
  reference count is returned. Otherwise, CPU is ignored and only the
  reference count is taken into account.
  Must be called under dma_list_mutex.
  dma_channel_rebalance - redistribute the available channels
  Optimize for CPU isolation (each CPU gets a dedicated channel for an
  operation type) in the SMP case, and operation isolation (avoid
  multi-tasking channels) in the non-SMP case.
  Must be called under dma_list_mutex.
 undo the last distribution 
 don't populate the channel_table if no clients are available 
 redistribute available channels 
  balance_ref_count - catch up the channel reference count
  @chan:	channel to balance ->client_count versus dmaengine_ref_count
  Must be called under dma_list_mutex.
  dma_chan_get - try to grab a DMA channel's parent driver module
  @chan:	channel to grab
  Must be called under dma_list_mutex.
 The channel is already in use, update client count 
 allocate upon first client reference 
  dma_chan_put - drop a reference to a DMA channel's parent driver module
  @chan:	channel to release
  Must be called under dma_list_mutex.
 This channel is not in use, bail out 
 This channel is not in use anymore, free it 
 Make sure all operations have completed 
 If the channel is used via a DMA request router, free the mapping 
  dma_find_channel - find a channel to carry out the operation
  @tx_type:	transaction type
  dma_issue_pending_all - flush all pending operations across all channels
 check if the channel supports slave transactions 
	
	  Check whether it reports it uses the generic slave
	  capabilities, if not, that means it doesn't support any
	  kind of slave capabilities reporting.
	
	  DMA engine device might be configured with non-uniformly
	  distributed slave capabilities per device channels. In this
	  case the corresponding driver may provide the device_caps
	  callback to override the generic capabilities with
	  channel-specific ones.
	 devices with multiple channels need special handling as we need to
	  ensure that all channels are either private or public.
 some channels are already publicly allocated 
		 Found a suitable channel, try to grab, prep, and return it.
		  We first set DMA_PRIVATE to disable balance_ref_count as this
		  channel will not be published in the general-purpose
		  allocator
  dma_get_slave_channel - try to get specific channel exclusively
  @chan:	target channel
 lock against __dma_request_channel 
 lock against __dma_request_channel 
  __dma_request_channel - try to allocate an exclusive channel
  @mask:	capabilities that the channel must satisfy
  @fn:		optional callback to disposition available channels
  @fn_param:	opaque parameter to pass to dma_filter_fn()
  @np:		device node to look for DMA channels
  Returns pointer to appropriate DMA channel on success or NULL.
 Find a channel 
 Finds a DMA controller with matching device node 
  dma_request_chan - try to allocate an exclusive slave channel
  @dev:	pointer to client device structure
  @name:	slave channel name
  Returns pointer to appropriate DMA channel on success or an error pointer.
 If device-tree is present get slave info from here 
 If device was enumerated by ACPI get slave info from here 
 Try to find the channel via the DMA filter map(s) 
  dma_request_chan_by_mask - allocate a channel satisfying certain capabilities
  @mask:	capabilities that the channel must satisfy
  Returns pointer to appropriate DMA channel on success or an error pointer.
 drop PRIVATE cap enabled by __dma_request_channel() 
  dmaengine_get - register interest in dma_channels
 try to grab channels 
 module removed before we could use it 
	 if this is the first reference and there were channels
	  waiting we need to rebalance to get those channels
	  incorporated into the channel table
  dmaengine_put - let DMA drivers be removed when ref_count == 0
 drop channel references 
	 A device that satisfies this test has channels that will never cause
	  an async_tx channel switch event as all possible operation types can
	  be handled.
	
	  When the chan_id is a negative value, we are dynamically adding
	  the channel. Otherwise we are static enumerating.
  dma_async_device_register - registers DMA devices found
  @device:	pointer to &struct dma_device
  After calling this routine the structure should not be freed except in the
  device_release() callback which will be called after
  dma_async_device_unregister() is called and no further references are taken.
 validate device routines 
	 note: this only matters in the
	  CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH=n case
 represent channels in sysfs. Probably want devs too 
 take references on public channels 
			 if clients are already waiting for channels we need
			  to take references on their behalf
				 note we can only get here for the first
				  channel as the remaining channels are
				  guaranteed to get a reference
 Always private 
 if we never registered a channel just release the idr 
  dma_async_device_unregister - unregister a DMA device
  @device:	pointer to &struct dma_device
  This routine is called by dma driver exit routines, dmaengine holds module
  references to prevent it being called while channels are in use.
	
	  setting DMA_PRIVATE ensures the device being torn down will not
	  be used in the channel_table
  dmaenginem_async_device_register - registers DMA devices found
  @device:	pointer to &struct dma_device
  The operation is managed and will be undone on driver detach.
 Make sure that the metadata mode is not mixed 
  dma_wait_for_async_tx - spin wait for a transaction to complete
  @tx:		in-flight transaction to wait on
  dma_run_dependencies - process dependent operations on the target channel
  @tx:		transaction with dependencies
  Helper routine for DMA drivers to process (start) dependent operations
  on their target channel.
 we'll submit tx->next now, so clear the link 
	 keep submitting up until a channel switch is detected
	  in that case we will be called again as a result of
	  processing the interrupt from async_tx_channel_switch
 ->next will be submitted 
 submit current dep and terminate 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) Ericsson AB 2007-2008
  Copyright (C) ST-Ericsson SA 2008-2010
  Author: Per Forlin <per.forlin@stericsson.com> for ST-Ericsson
  Author: Jonas Aaberg <jonas.aberg@stericsson.com> for ST-Ericsson
 For masking outin 2 bit channel positions 
 Maximum iterations taken before giving up suspending a channel 
 Milliseconds 
 Hardware requirement on LCLA alignment 
 Max number of links per event group 
 Max number of logical channels per physical channel 
 Attempts before giving up to trying to get pages that are aligned 
 Bit markings for allocation map 
 Reserved event lines for memcpy only. 
 Default configuration for physical memcpy 
 Default configuration for logical memcpy 
  enum 40_command - The different commands andor statuses.
  @D40_DMA_STOP: DMA channel command STOP or status STOPPED,
  @D40_DMA_RUN: The DMA channel is RUNNING of the command RUN.
  @D40_DMA_SUSPEND_REQ: Request the DMA to SUSPEND as soon as possible.
  @D40_DMA_SUSPENDED: The DMA channel is SUSPENDED.
  enum d40_events - The different Event Enables for the event lines.
  @D40_DEACTIVATE_EVENTLINE: De-activate Event line, stopping the logical chan.
  @D40_ACTIVATE_EVENTLINE: Activate the Event line, to start a logical chan.
  @D40_SUSPEND_REQ_EVENTLINE: Requesting for suspending a event line.
  @D40_ROUND_EVENTLINE: Status check for event line.
  These are the registers that has to be saved and later restored
  when the DMA hw is powered off.
  TODO: Add saverestore of D40_DREG_GCC on dma40 v3 or later, if that works.
  since 9540 and 8540 has the same HW revision
  use v4a for 9540 or ealier
  use v4b for 8540 or later
  HW revision:
  DB8500ed has revision 0
  DB8500v1 has revision 2
  DB8500v2 has revision 3
  AP9540v1 has revision 4
  DB8540v1 has revision 4
  TODO: Check if all these registers have to be savedrestored on dma40 v4a
  struct d40_interrupt_lookup - lookup table for interrupt handler
  @src: Interrupt mask register.
  @clr: Interrupt clear register.
  @is_error: true if this is an error interrupt.
  @offset: start delta in the lookup_log_chans in d40_base. If equals to
  D40_PHY_CHAN, the lookup_phy_chans shall be used instead.
  struct d40_reg_val - simple lookup struct
  @reg: The register.
  @val: The value that belongs to the register in reg.
 Clock every part of the DMA block from start 
 Interrupts on all logical channels 
 Clock every part of the DMA block from start 
 Interrupts on all logical channels 
  struct d40_lli_pool - Structure for keeping LLIs in memory
  @base: Pointer to memory area when the pre_alloc_lli's are not large
  enough, IE bigger than the most common case, 1 dst and 1 src. NULL if
  pre_alloc_lli is used.
  @dma_addr: DMA address, if mapped
  @size: The size in bytes of the memory at base or the size of pre_alloc_lli.
  @pre_alloc_lli: Pre allocated area for the most common case of transfers,
  one buffer to one buffer.
 Space for dst and src, plus an extra for padding 
  struct d40_desc - A descriptor is one DMA job.
  @lli_phy: LLI settings for physical channel. Both src and dst=
  points into the lli_pool, to base if lli_len > 1 or to pre_alloc_lli if
  lli_len equals one.
  @lli_log: Same as above but for logical channels.
  @lli_pool: The pool with two entries pre-allocated.
  @lli_len: Number of llis of current descriptor.
  @lli_current: Number of transferred llis.
  @lcla_alloc: Number of LCLA entries allocated.
  @txd: DMA engine struct. Used for among other things for communication
  during a transfer.
  @node: List entry.
  @is_in_client_list: true if the client owns this descriptor.
  @cyclic: true if this is a cyclic job
  This descriptor is used for both logical and physical transfers.
 LLI physical 
 LLI logical 
  struct d40_lcla_pool - LCLA pool settings and data.
  @base: The virtual address of LCLA. 18 bit aligned.
  @dma_addr: DMA address, if mapped
  @base_unaligned: The orignal kmalloc pointer, if kmalloc is used.
  This pointer is only there for clean-up on error.
  @pages: The number of pages needed for all physical channels.
  Only used later for clean-up on error
  @lock: Lock to protect the content in this struct.
  @alloc_map: big map over which LCLA entry is own by which job.
  struct d40_phy_res - struct for handling eventlines mapped to physical
  channels.
  @lock: A lock protection this entity.
  @reserved: True if used by secure world or otherwise.
  @num: The physical channel number of this entity.
  @allocated_src: Bit mapped to show which src event line's are mapped to
  this physical channel. Can also be free or physically allocated.
  @allocated_dst: Same as for src but is dst.
  allocated_dst and allocated_src uses the D40_ALLOC defines as well as
  event line number.
  @use_soft_lli: To mark if the linked lists of channel are managed by SW.
  struct d40_chan - Struct that describes a channel.
  @lock: A spinlock to protect this struct.
  @log_num: The logical number, if any of this channel.
  @pending_tx: The number of pending transfers. Used between interrupt handler
  and tasklet.
  @busy: Set to true when transfer is ongoing on this channel.
  @phy_chan: Pointer to physical channel which this instance runs on. If this
  point is NULL, then the channel is not allocated.
  @chan: DMA engine handle.
  @tasklet: Tasklet that gets scheduled from interrupt context to complete a
  transfer and call client callback.
  @client: Cliented owned descriptor list.
  @pending_queue: Submitted jobs, to be issued by issue_pending()
  @active: Active descriptor.
  @done: Completed jobs
  @queue: Queued jobs.
  @prepare_queue: Prepared jobs.
  @dma_cfg: The client configuration of this dma channel.
  @slave_config: DMA slave configuration.
  @configured: whether the dma_cfg configuration is valid
  @base: Pointer to the device instance struct.
  @src_def_cfg: Default cfg register setting for src.
  @dst_def_cfg: Default cfg register setting for dst.
  @log_def: Default logical channel settings.
  @lcpa: Pointer to dst and src lcpa settings.
  @runtime_addr: runtime configured address.
  @runtime_direction: runtime configured direction.
  This struct can either "be" a logical or a physical channel.
 Default register configurations 
 Runtime reconfiguration 
  struct d40_gen_dmac - generic values to represent u8500u8540 DMA
  controller
  @backup: the pointer to the registers address array for backup
  @backup_size: the size of the registers address array for backup
  @realtime_en: the realtime enable register
  @realtime_clear: the realtime clear register
  @high_prio_en: the high priority enable register
  @high_prio_clear: the high priority clear register
  @interrupt_en: the interrupt enable register
  @interrupt_clear: the interrupt clear register
  @il: the pointer to struct d40_interrupt_lookup
  @il_size: the size of d40_interrupt_lookup array
  @init_reg: the pointer to the struct d40_reg_val
  @init_reg_size: the size of d40_reg_val array
  struct d40_base - The big global struct, one for each probe'd instance.
  @interrupt_lock: Lock used to make sure one interrupt is handle a time.
  @execmd_lock: Lock for execute command usage since several channels share
  the same physical register.
  @dev: The device structure.
  @virtbase: The virtual base address of the DMA's register.
  @rev: silicon revision detected.
  @clk: Pointer to the DMA clock structure.
  @phy_start: Physical memory start of the DMA registers.
  @phy_size: Size of the DMA register map.
  @irq: The IRQ number.
  @num_memcpy_chans: The number of channels used for memcpy (mem-to-mem
  transfers).
  @num_phy_chans: The number of physical channels. Read from HW. This
  is the number of available channels for this driver, not counting "Secure
  mode" allocated physical channels.
  @num_log_chans: The number of logical channels. Calculated from
  num_phy_chans.
  @dma_both: dma_device channels that can do both memcpy and slave transfers.
  @dma_slave: dma_device channels that can do only do slave transfers.
  @dma_memcpy: dma_device channels that can do only do memcpy transfers.
  @phy_chans: Room for all possible physical channels in system.
  @log_chans: Room for all possible logical channels in system.
  @lookup_log_chans: Used to map interrupt number to logical channel. Points
  to log_chans entries.
  @lookup_phy_chans: Used to map interrupt number to physical channel. Points
  to phy_chans entries.
  @plat_data: Pointer to provided platform_data which is the driver
  configuration.
  @lcpa_regulator: Pointer to hold the regulator for the esram bank for lcla.
  @phy_res: Vector containing all physical channels.
  @lcla_pool: lcla pool settings and data.
  @lcpa_base: The virtual mapped address of LCPA.
  @phy_lcpa: The physical address of the LCPA.
  @lcpa_size: The size of the LCPA area.
  @desc_slab: cache for descriptors.
  @reg_val_backup: Here the values of some hardware registers are stored
  before the DMA is powered off. They are restored when the power is back on.
  @reg_val_backup_v4: Backup of registers that only exits on dma40 v3 and
  later
  @reg_val_backup_chan: Backup data for standard channel parameter registers.
  @regs_interrupt: Scratch space for registers during interrupt.
  @gcc_pwr_off_mask: Mask to maintain the channels that can be turned off.
  @gen_dmac: the struct for generic registers values to represent u85008540
  DMA controller
 Physical half channels 
	
	  Allocate both src and dst at the same time, therefore the half
	  start on 1 since 0 can't be used since zero is used as end marker.
	
	  We may have partially running cyclic transfers, in case we did't get
	  enough LCLA entries.
	
	  For linkback, we need one LCLA even with only one link, because we
	  can't link back to the one in LCPA space
		
		  If the channel is expected to use only soft_lli don't
		  allocate a lcla. This is to avoid a HW issue that exists
		  in some controller during a peripheral to memory transfer
		  that uses linked lists.
	
	  For linkback, we normally load the LCPA in the loop since we need to
	  link it to the second LCLA and not the first.  However, if we
	  couldn't even get a first LCLA, then we have to run in LCPA and
	  reload manually.
 First link goes in both LCPA and LCLA 
		
		  One unused LCLA in the cyclic case if the very first
		  next_lcla fails...
		
		  Cache maintenance is not needed if lcla is
		  mapped in esram
 remove desc from current queue and add it to the pending_queue 
  The dma only supports transmitting packages up to
  STEDMA40_MAX_SEG_SIZE  data_width, where data_width is stored in Bytes.
  Calculate the total number of dma elements required to send the entire sg list.
			
			  Reduce the number of bus accesses while
			  waiting for the DMA to suspend.
 Release completed descriptors 
 Release active descriptors 
 Release queued descriptors waiting for transfer 
 Release pending descriptors 
 Release client owned descriptors 
 Release descriptors in prepare queue 
			
			  Reduce the number of bus accesses while
			  waiting for the DMA to suspend.
	
	  The hardware sometimes doesn't register the enable when src and dst
	  event lines are active on the same logical channel.  Retry to ensure
	  it does.  Usually only one retry is sufficient.
 Enable event line connected to device (or memcpy) 
 Odd addresses are even addresses + 4 
 Setup channel mode to logical or physical 
 Setup operational mode option register 
 Set default config for CFG reg 
 Set LIDX for lcla 
 Clear LNK which will be used by d40_chan_has_events() 
 If bytes left to transfer or linked tx resume job 
 Start queued jobs, if any 
 Remove from queue 
 Add to active queue 
 Initiate DMA job 
 Start dma job 
 called from interrupt context 
 Get first active entry from list 
		
		  If this was a paritially loaded list, we need to reloaded
		  it, and only when the list is completed.  We need to check
		  for done because the interrupt will hit for every link, and
		  not just the last one.
 Start dma job 
 Get first entry from the done list 
 Check if we have reached here for cyclic job 
	
	  If terminating a channel pending_tx is set to zero.
	  This prevents any finished active jobs to return to the client.
 Callback to client 
 Rescue manouver if receiving double interrupts 
 Read interrupt status of both logical and physical channels 
 No more set bits found? 
			
			  No error because this can happen if something else
			  in the system is using the channel.
 ACK interrupt 
		
		  DMAC HW supports it. Will be added to this driver,
		  in case any dma client requires it.
		
		  The DMAC hardware only supports
		  src (burst x width) == dst (burst x width)
 Physical interrupts are masked per physical full channel 
 Logical channel 
 Logical channel 
 dst event lines are used for logical memcpy 
 Find physical half channel 
 Find logical channel 
		
		  Spread logical channels across all available physical rather
		  than pack every logical channel at the first available phy
		  channels.
 Generate interrrupt at end of transfer or relink. 
 Generate interrupt on error. 
 Terminate all queued and active transfers 
	
	  add descriptor to the prepare queue in order to be able
	  to free them later in terminate_all
	
	  Due to a hardware bug, in some cases a logical channel triggered by
	  a high priority destination event line can generate extra packet
	  transactions.
	 
	  The workaround is to not set the high priority level for the
	  destination event lines that trigger logical channels.
 Destination event lines are stored in the upper halfword 
 DMA ENGINE functions 
 If no dma configuration is set use default configuration (memcpy) 
 Unmask the Global Interrupt Mask. 
	
	  Only write channel configuration to the DMA if the physical
	  resource is free. In case of multiple logical channels
	  on the same physical resource, only the first write is necessary.
 Busy means that queued jobs are already being processed 
 Runtime reconfiguration extension 
 Configure the memory side 
 Configure the memory side 
 Only valid widths are; 1, 2, 4 and 8. 
 Fill in register values 
 These settings will take precedence later 
 Initialization functions 
		
		  This controller can only access address at even
		  32bit boundaries, i.e. 2^2
 Suspend resume functionality 
 SaveRestore channel specific registers 
 SaveRestore global registers 
 SaveRestore registers only existing on dma40 v3 and later 
 Don't disableenable clocks for v1 due to HW bugs 
 Initialization functions. 
 Mark security only channels as occupied 
 Mark disabled channels as occupied 
 Mark soft_lli channels 
 Verify settings extended vs standard 
	
	  To keep things simple, Enable all clocks initially.
	  The clocks will get managed later post channel allocation.
	  The clocks for the event lines on which reserved channels exists
	  are not managed here.
 Get IO for DMAC base address 
 This is just a regular AMBA PrimeCell ID actually 
	
	  HW revision:
	  DB8500ed has revision 0
	  ? has revision 1
	  DB8500v1 has revision 2
	  DB8500v2 has revision 3
	  AP9540v1 has revision 4
	  DB8540v1 has revision 4
 The number of physical channels on this HW 
 The number of channels used for memcpy 
 Configure all our dma channels to default settings 
 Enable interrupt # 
 Clear interrupt # 
 Set channel to physical mode 
 Write which interrupt to enable 
 Write which interrupt to clear 
 These are __initdata and cannot be accessed after init 
	
	  This is somewhat ugly. We need 8192 bytes that are 18 bit aligned,
	  To full fill this hardware requirement without wasting 256 kb
	  we allocate pages until we get an aligned one.
 Calculating how many pages that are required 
		
		  After many attempts and no succees with finding the correct
		  alignment, try with allocating a big buffer.
 If absent this value will be obtained from hw. 
 Get IO for logical channel parameter address 
 We make use of ESRAM memory for this. 
 If lcla has to be located in ESRAM we don't need to allocate 
 SPDX-License-Identifier: GPL-2.0-only
  DMA Engine test module
  Copyright (C) 2007 Atmel Corporation
  Copyright (C) 2013 Intel Corporation
  struct dmatest_params - test parameters.
  @buf_size:		size of the memcpy test buffer
  @channel:		bus ID of the channel to test
  @device:		bus ID of the DMA Engine to test
  @threads_per_chan:	number of threads to start per channel
  @max_channels:	maximum number of channels to use
  @iterations:		iterations before stopping test
  @xor_sources:	number of xor source buffers
  @pq_sources:		number of p+q source buffers
  @timeout:		transfer timeout in msec, -1 for infinite timeout
  @noverify:		disable data verification
  @norandom:		disable random offset setup
  @alignment:		custom data address alignment taken as 2^alignment
  @transfer_size:	custom transfer size in bytes
  @polled:		use polling for completion instead of interrupts
  struct dmatest_info - test information.
  @params:		test parameters
  @channels:		channels under test
  @nr_channels:	number of channels under test
  @lock:		access protection to the fields of this structure
  @did_init:		module has been initialized completely
  @last_error:		test has faced configuration issues
 Test parameters 
 Internal state 
 Maximum amount of mismatched bytes in buffer to print 
  Initialization patterns. All bytes in the source buffer has bit 7
  set, all bytes in the destination buffer has bit 7 cleared.
  Bit 6 is set for all bytes which are to be copied by the DMA
  engine. Bit 5 is set for all bytes which are to be overwritten by
  the DMA engine.
  The remaining bits are the inverse of a counter which increments by
  one for each byte address.
 Fixed point arithmetic ops 
 poor man's completion - we want to use wait_event_freezable() on it 
		
		  If thread->done, it means that this callback occurred
		  after the parent thread has cleaned up. This can
		  happen in the case that driver doesn't implement
		  the terminate_all() functionality and a dma operation
		  did not occur within the timeout period
 drop precision until runtime is 32-bits 
 align to alignment restriction 
  This function repeatedly tests DMA transfers of various lengths and
  offsets for a given operation type until it is told to exit by
  kthread_stop(). There may be multiple threads running this function
  in parallel for a single channel, and there may be multiple channels
  being tested in parallel.
  Before each test, the source and destination buffer is initialized
  with a known pattern. This pattern is different depending on
  whether it's in an area which is supposed to be copied or
  overwritten, and different in the source and destination buffers.
  So if the DMA engine doesn't copy exactly what we tell it to copy,
  we'll notice.
 force odd to ensure dst = src 
 force odd to ensure dst = src 
 Check if buffer count fits into map count variable (u8) 
	
	  src and dst buffers are freed by ourselves below
 Do not alter transfer size explicitly defined by user 
 map with DMA_BIDIRECTIONAL to force writebackinvalidate 
 terminate all transfers on specified channels 
 terminate all transfers on specified channels 
 srcbuf and dstbuf are allocated by the thread itself 
 add_channel failed, punt 
 no more channels available 
 we have all we need 
 Copy test parameters 
	 we might be called early to set run=, defer running until all
	  parameters have been evaluated
			
			  We have nothing to run. This can be due to:
 1) Misconfiguration 
 2) We rely on defaults 
Clear any previously run threads 
 Reject channels that are already registered 
 Check if channel was added successfully 
		
		  if new channel was not successfully added, revert the
		  "test_channel" string to the name of the last successfully
		  added channel. exception for when users issues empty string
		  to channel parameter.
 Clear test_channel if no channels were added successfully 
	 module parameters are stable, inittime tests are started,
	  let userspace take over 'run' control
 when compiled-in wait for drivers to load first 
 SPDX-License-Identifier: GPL-2.0-only
  offload engine driver for the Intel Xscale series of io processors
  Copyright © 2006, Intel Corporation.
  This driver supports the asynchrounous DMA copy and RAID engines available
  on the Intel Xscale(R) family of IO Processors (IOP 32x, 33x, 134x)
  iop_adma_free_slots - flags descriptor slots for reuse
  @slot: Slot to free
  Caller must hold &iop_chan->lock while calling this function
		 call the callback (must not sleep or submit new
		  operations to this channel)
 run dependent operations 
	 the client is allowed to attach dependent operations
	  until 'ack' is set
	 leave the last descriptor in the chain
	  so we can append to it
	 free completed slots from the chain starting with
	  the oldest descriptor
		 do not advance past the current descriptor loaded into the
		  hardware channel, subsequent descriptors are either in
		  process or have not been submitted
		 stop the search if we reach the current descriptor and the
		  channel is busy, or if it appears that the current descriptor
		  needs to be re-read (i.e. has been appended to)
 detect the start of a group transaction 
 all the members of a group are complete 
 collect the total results 
 clean up the group 
 the group should be complete at this point 
 wait for group completion 
 write back zero sum results (single descriptor case) 
	 lockdep will flag depedency submissions as potentially
	  recursive locking, this is not the case as a dependency
	  submission will never recurse a channels submit routine.
	  There are checks in async_tx.c to prevent this.
	 start search from the last allocated descrtiptor
	  if a contiguous allocation can not be found start searching
	  from the beginning of the list
			 give up after finding the first busy slot
			  on the second pass through the list
 start the allocation if the slot is correctly aligned 
 pre-ack all but the last descriptor 
 perform direct reclaim if the allocation fails 
 fix up the hardware chain 
 flush 
 check for pre-chained descriptors 
	 increment the pending count by the number of slots
	  memcpy operations have a 1:1 (slot:operation) relation
	  other operations are heavier and will pop the threshold
	  more often.
  iop_adma_alloc_chan_resources -  returns the number of allocated descriptors
  @chan: allocate descriptor resources for this channel
  Note: We keep the slots for 1 operation on iop_chan->chain at all times.  To
  avoid deadlock, via async_xor, num_descs_in_pool must at a minimum be
  greater than 2x the number slots needed to satisfy a device->max_xor
  request.
 Allocate descriptor slots 
 initialize the channel and the chain with a null operation 
		 even if P is disabled its destination address (bits
		  [3:0]) must match Q.  It is ok if P points to an
		  invalid address, it won't be written.
		 if we are continuing a previous operation factor in
		  the old p and q values, see the comment for dma_maxpq
		  in includelinuxdmaengine.h
		 for validate operations p and q are tagged onto the
		  end of the source list
 one is ok since we left it on there on purpose 
  iop_adma_status - poll the status of an ADMA transaction
  @chan: ADMA channel handle
  @cookie: ADMA transaction identifier
  @txstate: a holder for the current state of the channel or NULL
  Perform a transaction to verify the HW works.
 Fill in src buffer 
 Start copy, using first DMA channel 
 must be <= 15 
 Fill in src buffers 
 test xor 
 skip zero sum if the capability is not present 
 zero sum the sources with the destintation page 
 test for non-zero parity sum 
 combined sources, software pq results, and extra hw pq results 
 ptr to the extra hw pq buffers defined above 
 address conversion buffers (dma_map  page_address) 
 Fill in src buffers 
 initialize the dests 
 test pq 
 test correct zero sum using the software generated pq values 
 test incorrect zero sum 
	 allocate coherent memory for hardware descriptors
	  note: writecombine gives slightly better performance, but
	  requires that we explicitly flush the writes
 discover transaction capabilites from the platform data 
 set base routines 
 set prep routines based on capability 
 clear errors before enabling interrupts 
 can not test raid6, so do not publish capability 
		 initialize the completed cookie to be less than
		  the most recently used cookie
 channel should not be busy 
 clear any prior error-status bits 
 disable operation 
 set the descriptor address 
		 1 don't add pre-chained descriptors
		  2 dummy read to flush next_desc write
 run the descriptor 
		 initialize the completed cookie to be less than
		  the most recently used cookie
 channel should not be busy 
 clear any prior error-status bits 
 disable operation 
 set the descriptor address 
		 1 don't add pre-chained descriptors
		  2 dummy read to flush next_desc write
 run the descriptor 
  Copyright (C) 2017 Spreadtrum Communications Inc.
  SPDX-License-Identifier: GPL-2.0
 DMA global registers definition 
 DMA channel registers definition 
 SPRD_DMA_GLB_2STAGE_GRP register definition 
 SPRD_DMA_CHN_INTC register definition 
 SPRD_DMA_CHN_CFG register definition 
 SPRD_DMA_CHN_REQ register definition 
 SPRD_DMA_CHN_PAUSE register definition 
 DMA_CHN_WARP_ register definition 
 SPRD_DMA_CHN_INTC register definition 
 SPRD_DMA_CHN_FRG_LEN register definition 
 SPRD_DMA_CHN_BLK_LEN register definition 
 SPRD_DMA_CHN_TRSC_LEN register definition 
 SPRD_DMA_CHN_TRSF_STEP register definition 
 SPRD DMA_SRC_BLK_STEP register definition 
 define DMA channel mode & trigger mode mask 
 define the DMA transfer step type 
 dma data width values 
 dma channel hardware configuration 
 dma request description 
 dma channel description 
 SPRD dma device 
	
	  The ashb_clk is optional and only for AGCP DMA controller, so we
	  need add one condition to check if the ashb_clk need enable.
	
	  Need to check if we need disable the optional ashb_clk for AGCP DMA.
 The DMA request id always starts from 0. 
	
	  Set 2-stage configuration if the channel starts one 2-stage
	  transfer.
	
	  Copy the DMA configuration from DMA descriptor to this hardware
	  channel.
 cyclic mode schedule callback 
 Check if the dma request descriptor is done. 
		
		  For 2-stage transfer, destination channel step can not be 0,
		  since destination device is AON IRAM.
	
	  wrap_ptr and wrap_to will save the high 4 bits source address and
	  destination address.
	
	  If the src step and dst step both are 0 or both are not 0, that means
	  we can not enable the fix mode. If one is 0 and another one is not,
	  we can enable the fix mode.
 link-list configuration 
 link-list index 
 Next link-list configuration's physical address offset 
		
		  Set the link-list pointer point to next link-list
		  configuration's physical address.
	
	  Set channel mode, interrupt mode and trigger mode for 2-stage
	  transfer.
		
		  The link-list mode needs at least 2 link-list
		  configurations. If there is only one sg, it doesn't
		  need to fill the link-list configuration.
 ashb clock is optional for AGCP DMA 
	
	  We have three DMA controllers: AP DMA, AON DMA and AGCP DMA. For AGCP
	  DMA controller, it can or do not request the irq, which will save
	  system power without resuming system by DMA interrupts if AGCP DMA
	  does not request the irq. Thus the DMA interrupts property should
	  be optional.
 get each channel's registers base address. 
 explicitly free the irq 
 SPDX-License-Identifier: GPL-2.0
  Microsemi Switchtec(tm) PCIe Management Driver
  Copyright (c) 2019, Logan Gunthorpe <logang@deltatee.com>
  Copyright (c) 2019, GigaIO Networks, Inc
 return with the lock held, it will be released in tx_submit 
	
	  Keep sparse happy by restoring an even lock count on
	  this lock.
	
	  Ensure the descriptor updates are visible to the dma device
	  before setting the valid bit.
	
	  Ensure the valid bits are visible before starting the
	  DMA engine.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2014 Emilio López
  Emilio López <emilio@elopez.com.ar>
 Common macros to normal and dedicated DMA registers 
 Normal DMA register values 
 Normal DMA sourcedestination data request type values 
 Normal DMA register layout 
 Dedicated DMA sourcedestination address mode values 
 Normal DMA configuration register layout 
 Dedicated DMA register values 
 Dedicated DMA sourcedestination address mode values 
 Dedicated DMA sourcedestination data request type values 
 Dedicated DMA register layout 
 Dedicated DMA configuration register layout 
 Dedicated DMA parameter register layout 
 DMA register offsets 
 General register offsets 
 Normal DMA register offsets 
 Dedicated DMA register offsets 
 DMA Driver 
  Normal DMA has 8 channels, and Dedicated DMA has another 8, so
  that's 16 channels. As for endpoints, there's 29 and 21
  respectively. Given that the Normal DMA endpoints (other than
  SDRAM) can be used as txrx, we need 78 vchans in total
 This set of SUN4I_DDMA timing parameters were found experimentally while
 Register base of channel 
 vchan currently being serviced 
 Is this a dedicated pchan? 
 A contract is a set of promises 
 1 -> 0, 4 -> 1, 8 -> 2 
 8 (1 byte) -> 0, 16 (2 bytes) -> 1, 32 (4 bytes) -> 2 
	
	  pchans 0-SUN4I_NDMA_NR_MAX_CHANNELS are normal, and
	  SUN4I_NDMA_NR_MAX_CHANNELS+ are dedicated ones
	
	  Configure addresses and misc parameters depending on type
	  SUN4I_DDMA has an extra field with timing parameters
  Execute pending operations on a vchan
  When given a vchan, this function will try to acquire a suitable
  pchan and, if successful, will configure it to fulfill a promise
  from the next pending contract.
  This function must be called with &vchan->vc.lock held.
 We need a pchan to do anything, so secure one if available 
	
	  Channel endpoints must not be repeated, so if this vchan
	  has already submitted some work, we can't do anything else
 Figure out which contract we're working with today 
 The contract has been completed so mark it as such 
 Now find out what we need to do 
 ... and make it reality 
  Generate a promise, to be used in a normal DMA contract.
  A NDMA promise contains all the information required to program the
  normal part of the DMA Engine and get data copied. A non-executed
  promise will live in the demands list on a contract. Once it has been
  completed, it will be moved to the completed demands list for later freeing.
  All linked promises will be freed when the corresponding contract is freed
 Source burst 
 Destination burst 
 Source bus width 
 Destination bus width 
  Generate a promise, to be used in a dedicated DMA contract.
  A DDMA promise contains all the information required to program the
  Dedicated part of the DMA Engine and get data copied. A non-executed
  promise will live in the demands list on a contract. Once it has been
  completed, it will be moved to the completed demands list for later freeing.
  All linked promises will be freed when the corresponding contract is freed
 Source burst 
 Destination burst 
 Source bus width 
 Destination bus width 
  Generate a contract
  Contracts function as DMA descriptors. As our hardware does not support
  linked lists, we need to implement SG via software. We use a contract
  to hold all the pieces of the request and process them serially one
  after another. Each piece is represented as a promise.
  Get next promise on a cyclic transfer
  Cyclic contracts contain a series of promises which are executed on a
  loop. This function returns the next promise from a cyclic contract,
  so it can be programmed into the hardware.
  Free a contract and all its associated promises
 Free all the demands and completed demands 
	
	  We can only do the copy to bus aligned addresses, so
	  choose the best one so we get decent performance. We also
	  maximize the burst size for this same reason.
 Configure memcpy mode 
 Fill the contract with our only promise 
 And add it to the vchan 
	
	  We will be using half done interrupts to make two periods
	  out of a promise, so we need to program the DMA engine less
	  often
	
	  The engine can interrupt on half-transfer, so we can use
	  this feature to program the engine half as often as if we
	  didn't use it (keep in mind the hardware doesn't support
	  linked lists).
	 
	  Say you have a set of periods (| marks the startend, I for
	  interrupt, P for programming the engine to do a new
	  transfer), the easy but slow way would be to do
	 
	   |---|---|---|---| (periods  promises)
	   P  I,P I,P I,P  I
	 
	  Using half transfer interrupts you can do
	 
	   |-------|-------| (promises as configured on hw)
	   |---|---|---|---| (periods)
	   P   I  I,P  I   I
	 
	  Which requires half the engine programming for the same
	  functionality.
 Calculate the offset in the buffer and the length needed 
 Make the promise 
 TODO: should we free everything? 
 Then add it to the contract 
 And add it to the vchan 
 Figure out addresses 
		
		  These are the magic DMA engine timings that keep SPI going.
		  I haven't seen any interface on DMAEngine to configure
		  timings, and so far they seem to work for everything we
		  support, so I've kept them here. I don't know if other
		  devices need different timings because, as usual, we only
		  have the "para" bitfield meanings, but no comment on what
		  the values should be when doing a certain operation :|
 And make a suitable promise 
 TODO: should we free everything? 
 Then add it to the contract 
	
	  Once we've got all the promises ready, add the contract
	  to the pending list on the vchan
	
	  Clearing the configuration register will halt the pchan. Interrupts
	  may still trigger, so don't forget to disable them.
 Clear these so the vchan is usable again 
 Check if type is Normal or Dedicated 
 Make sure the endpoint looks sane 
 Assign the endpoint to the vchan 
	
	  The hardware is configured to return the remaining byte
	  quantity. If possible, replace the first listed element's
	  full size with the actual remaining amount
	
	  If there are pending transactions for this vchan, push one of
	  them into the engine to get the ball rolling.
 a terminated channel may still interrupt 
		
		  Disable the IRQ and free the pchan if it's an end
		  interrupt (odd bit)
			
			  Move the promise into the completed list now that
			  we're done with it
			
			  Cyclic DMA transfers are special:
			  - There's always something we can dispatch
			  - We need to run the callback
			  - Latency is very important, as this is used by audio
			  We therefore just cycle through the list and dispatch
			  whatever we have here, reusing the pchan. There's
			  no need to run the thread after this.
			 
			  For non-cyclic transfers we need to look around,
			  so we can program some more work, or notify the
			  client that their transfers have been completed.
 Half done interrupt 
 Disable the IRQs for events we handled 
 Writing 1 to the pending field will clear the pending interrupt 
	
	  If a pchan was freed, we may be able to schedule something else,
	  so have a look around
	
	  Handle newer interrupts if some showed up, but only do it once
	  to avoid a too long a loop
	
	  [0..SUN4I_NDMA_NR_MAX_CHANNELS) are normal pchans, and
	  [SUN4I_NDMA_NR_MAX_CHANNELS..SUN4I_DMA_NR_MAX_CHANNELS) are
	  dedicated ones
	
	  Make sure the IRQs are all disabled and accounted for. The bootloader
	  likes to leave these dirty
 Disable IRQ so no more work is scheduled 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
  offload engine driver for the Marvell XOR engine
  Copyright (C) 2007, 2008, Marvell International Ltd.
 Enable end-of-descriptor interrupts only for DMA_PREP_INTERRUPT 
 writel ensures all descriptors are flushed before activation 
  mv_chan_start_new_chain - program the engine to operate on new
  chain headed by sw_desc
  Caller must hold &mv_chan->lock while calling this function
 set the hardware chain 
		 call the callback (must not sleep or submit new
		  operations to this channel)
 run dependent operations 
	 the client is allowed to attach dependent operations
	  until 'ack' is set
 move this slot to the completed_slots 
 This function must be called with the mv_xor_chan spinlock held 
	 free completed slots from the chain starting with
	  the oldest descriptor
 clean finished descriptors 
 done processing desc, clean slot 
 break if we did cleaned the current 
			
			  current descriptor cleaned and removed, run
			  from list head
				
				  descriptors are still waiting after
				  current, trigger them
				
				  some descriptors are still waiting
				  to be cleaned
 pre-ack descriptor 
 try to free some slots if the allocation fails 
 DMA engine API functions 
 fix up the hardware chain 
 if the channel is not busy 
			
			  and the curren desc is the end of the chain before
			  the append, then we need to start the channel
 returns the number of allocated descriptors 
 Allocate descriptor slots 
  Check if source or destination is an PCIeIO address (non-SDRAM) and add
  a new MBus window if necessary. Use a cache for these check so that
  the MMIO mapped registers don't have to be accessed for this check
  to speed up this process.
 Nothing needs to get done for the Armada 3700 
	
	  Loop over the cached windows to check, if the requested area
	  is already mapped. If this the case, nothing needs to be done
	  and we can return.
 Window is already mapped 
	
	  The window is not mapped, so we need to create the new mapping
 If no IO window is found that addr has to be located in SDRAM 
	
	  Mask the base addr 'addr' according to 'size' read back from the
	  MBus window. Otherwise we might end up with an address located
	  somewhere in the middle of this area here.
	
	  Reading one of both enabled register is enough, as they are always
	  programmed to the identical values
 Set 'i' to the first free window to write the new values to 
 Fill the caching variables for later use 
 Check if a new window needs to get added for 'dest' 
 Check if a new window needs to get added for 'src' 
	
	  A MEMCPY operation is identical to an XOR operation with only
	  a single source address.
	
	  We implement the DMA_INTERRUPT operation as a minimum sized
	  XOR operation with a single dummy source address.
  mv_xor_status - poll the status of an XOR transaction
  @chan: XOR channel handle
  @cookie: XOR transaction identifier
  @txstate: XOR transactions state holder (or NULL)
  Perform a transaction to verify the HW works.
 Fill in src buffer 
 must be <= 15 
 Fill in src buffers 
 test xor 
	
	  These source and destination dummy buffers are used to implement
	  a DMA_INTERRUPT operation as a minimum-sized XOR operation.
	  Hence, we only need to map the buffers at initialization-time.
	 allocate coherent memory for hardware descriptors
	  note: writecombine gives slightly better performance, but
	  requires that we explicitly flush the writes
 discover transaction capabilites from the platform data 
 set base routines 
 set prep routines based on capability 
 clear errors before enabling interrupts 
 Fill the caching variables for later use 
	
	  For Armada3700 open default 4GB Mbus window. The dram
	  related configuration are done at AXIS level.
  Since this XOR driver is basically used only for RAID5, we don't
  need to care about synchronizing ->suspend with DMA activity,
  because the DMA engine will naturally be quiet due to the block
  devices being suspended.
	
	  We need to know which type of XOR device we use before
	  setting up. In non-dt case it can only be the legacy one.
	
	  (Re-)program MBUS remapping windows if we are asked to.
	 Not all platforms can gate the clock, so it is not
	  an error if the clock does not exists.
	
	  We don't want to have more than one channel per CPU in
	  order for async_tx to perform well. So we limit the number
	  of engines and channels so that we take into account this
	  constraint. Note that we also want to use channels from
	  separate engines when possible.  For dual-CPU Armada 3700
	  SoC with single XOR engine allow using its both channels.
MODULE_AUTHOR("Saeed Bishara <saeed@marvell.com>");
MODULE_DESCRIPTION("DMA engine driver for Marvell's XOR engine");
MODULE_LICENSE("GPL");
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2012 Samsung Electronics Co., Ltd.
 		http:www.samsung.com
  Copyright (C) 2010 Samsung Electronics Co. Ltd.
 	Jaswinder Singh <jassi.brar@samsung.com>
 Noncacheable and nonbufferable 
 Bufferable only 
 Cacheable, but do not allocate 
 Cacheable and bufferable, but do not allocate 
 AWCACHE = 0x1000 
 Cacheable write-through, allocate on writes only 
 Cacheable write-back, allocate on writes only 
 Register and Bit field Definitions 
  With 256 bytes, we can do more than 2.5MB and 5MB xfers per req
  at 1byteburst for P<->M and M<->M respectively.
  For typical scenario, at 1wordburst, 10MB and 20MB xfers per req
  should be enough for P<->M and M<->M respectively.
 Use this _only_ to wait on transient states 
 The number of default descriptors 
 Delay for runtime PM autosuspend, ms 
 Populated by the PL330 core driver for DMA API driver's info 
 In number of bits 
  Request Configuration.
  The PL330 core does not modify this and uses the last
  working configuration if the request doesn't provide any.
  The Client may want to provide this info only for the
  first request and a request with new settings.
 Address Incrementing 
	
	  For now, the SRC & DST protection levels
	  and burst sizelength are assumed same.
 in power of 2 
  One cycle of DMAC operation.
  There may be more than one xfer in a request.
 Size to xfer 
 The xfer callbacks are made with one of these arguments. 
 The all xfers in the request were success. 
 If req aborted due to global error. 
 If req failed due to problem with Channel. 
 ToBeDone for tasklet 
 A DMAC Thread 
 If the channel is not yet acquired by any client 
 Parent DMAC 
 Only two at a time 
 Index of the last enqueued request 
 Index of the last submitted request or -1 if the DMA is stopped 
 In the DMAC pool 
	
	  Allocated to some channel during prep_xxx
	  Also may be sitting on the work_list.
	
	  Sitting on the work_list and already submitted
	  to the PL330 core. Not more than two descriptors
	  of a channel can be BUSY at any time.
	
	  Sitting on the channel work_list but xfer done
	  by PL330 core
 Schedule desc completion 
 DMA-Engine Channel 
 List of submitted descriptors 
 List of issued descriptors 
 List of completed descriptors 
	 Pointer to the DMAC that manages this channel,
	  NULL if the channel is available to be acquired.
	  As the parent, this DMAC also provides descriptors
	  to the channel.
 To protect channel manipulation 
	
	  Hardware channel thread of PL330 DMAC. NULL if the channel is
	  available.
 For D-to-M and M-to-D channels 
 the peripheral fifo width 
 the number of burst 
 DMA-mapped view of the FIFO; may differ if an IOMMU is present 
 for cyclic capability 
 for runtime pm tracking 
 DMA-Engine Device 
 Pool of descriptors available for the DMAC's channels 
 To protect desc_pool manipulation 
 Size of MicroCode buffers for each channel. 
 ioremap'ed address of PL330 registers. 
 Populated by the PL330 core driver during pl330_add 
 Maximum possible eventsirqs 
 BUS address of MicroCode buffer 
 CPU address of MicroCode buffer 
 List of all Channel threads 
 Pointer to the MANAGER thread 
 To handle bad news in interrupt 
 State of DMAC operation 
 Holds list of reqs with due callbacks 
 Peripheral channels connected to this DMAC 
 keep at end 
 To attach to a queue as child 
 Descriptor for the DMA Engine API 
 Xfer for PL330 core 
 The channel which currently holds this desc 
 Index of peripheral for the xfer. 
 Hook to attach to DMAC's list of reqs with due callback 
 If manager of the thread is in Non-Secure mode 
 DMAC increments by 1 internally 
 Returns Time-Out 
 Until Manager is Idle 
 If timed out due to halted state-machine 
 Channel Number 
 Get going 
 Return if nothing needs to be done 
 clear the event 
 Stop generating interrupts for SEV 
 Start doing req 'idx' of thread 'thrd' 
 Return if already ACTIVE 
 Return if no request 
 Return if req is running 
 See 'Abort Sources' point-4 at Page 2-25 
 Set to generate interrupts for SEV 
 Only manager can execute GO 
 For RESUME, nothing yet 
 check lock-up free version 
 this code should be unreachable 
 this code should be unreachable 
	
	  do FLUSHP at beginning to clear any stale dma requests before the
	  first WFP.
 this code should be unreachable 
  only the unaligned burst transfers have the dregs.
  so, still transfer dregs with a reduced size burst
  for mem-to-mem, mem-to-dev or dev-to-mem.
	
	  dregs_len = (total bytes - BURST_TO_BYTE(bursts, ccr)) 
	              BRST_SIZE(ccr)
	  the dregs len must be smaller than burst len,
	  so, for higher efficiency, we can modify CCR
	  to use a reduced size burst len for the dregs.
 this code should be unreachable 
 Returns bytes consumed and updates bursts 
 Max iterations possible in DMALP is 256 
	
	  Max bursts that we can unroll due to limit on the
	  size of backward jump that can be encoded in DMALPEND
	  which is 8-bits and hence 255
 DMAMOV SAR, x->src_addr 
 DMAMOV DAR, x->dst_addr 
 Setup Loop(s) 
  A req is a sequence of one or more xfer units.
  Returns the number of bytes taken to setup the MC for the req.
 DMAMOV CCR, ccr 
 DMASEV peripheralevent 
 DMAEND 
 We set same protection levels for Src and DST for now 
  Submit a list of xfers after which the client wants notification.
  Client is not notified after each xfer unit, just once after all
  xfer units are done or some error occurs.
 If request for non-existing peripheral 
 Prefer Secure Channel 
 First dry run to check if req is acceptable 
 Hook the request 
 If desc aborted 
 The DMAC itself gone nuts 
 Reset the manager too 
 Clear the reset flag 
 Reset all channels 
 Clear the reset flag 
 Clear the reset flag 
 Returns 1 if state was updated, 0 otherwise 
 Check which event happened i.e, thread notified 
 Event occurred 
 Clear the event 
 Aborted 
 Detach the req 
 Get going again ASAP 
 For now, just make a list of callbacks to be done 
 Now that we are in no hurry, do the callbacks 
 Reserve an event 
 Upon success, returns IdentityToken for the
  allocated channel, NULL otherwise.
 Release an event 
 If the event is valid and was held by the thread 
 Initialize the structure for PL330 configuration, that can be used
  by the client driver the make best use of the DMAC
 Allocate 1 Manager and 'chans' Channel threads 
 Init Channel threads 
 MANAGER is indexed at the end 
	
	  Alloc MicroCode buffer for 'chans' Channel threads.
	  A channel's buffer offset is (Channel_Id  MCODE_BUFF_PERCHAN)
 Check if we can handle this DMAC 
 Read the configuration of the DMAC 
 Use default MC buffer size if not provided 
 Mark all events as free 
 Allocate resources needed by the DMAC 
 Release Channel threads 
 Free memory 
 Free DMAC resources 
 forward declaration 
 If already submitted 
 QFull or DMAC Dying 
 Unacceptable request 
 Pick up ripe tomatoes 
 Try to submit a req imm. next to the last completed cookie 
 Make sure the PL330 Channel thread is active 
 If work list empty, power down 
  We need the data direction between the DMAC (the dma-mapping "device") and
  the FIFO (the dmaengine "dev"), from the FIFO's point of view. Confusing!
 Already mapped for this config? 
 Mark all desc done 
  We don't support DMA_RESUME command because of hardware
  limitations, so after pausing the channel we cannot restore
  it to active state. We have to terminate channel and setup
  DMA transfer again. This pause feature was implemented to
  allow safely read residue before channel termination.
 If DMAMOV hasn't finished yet, SARDAR can be zero 
 Check in pending list 
			
			  Busy but not running means either just enqueued,
			  or finished and not yet marked done
		
		  Warn on nothing pending. Empty submitted_list may
		  break our pm_runtime usage counter as it is
		  updated on work_list emptiness status.
  We returned the last one of the circular list of descriptor(s)
  from prep_xxx, so the argument to submit corresponds to the last
  descriptor of the list.
 Assign cookies to all nodes 
 Returns the number of descriptors added to the DMAC pool 
 Pluck one desc from the pool of DMAC 
 If the DMAC pool is empty, alloc new 
 Initialize the descriptor 
	
	  Ideally we should lookout for reqs bigger than
	  those that can be programmed with 256 bytes of
	  MC buffer, but considering a req size is seldom
	  going to be word-unaligned and more than 200MB,
	  we take it easy.
	  Also, should the limit is reached we'd rather
	  have the platform increase MC buffer size than
	  complicating this API driver.
 Call after fixing burst size 
 srcdst_burst_len can't be more than 16 
 Select max possible burst size 
	
	  Make sure we use a burst size that aligns with all the memcpy
	  parameters because our DMA programming algorithm doesn't cope with
	  transfers which straddle an entry in the DMA device's MFIFO.
	
	  If burst size is smaller than bus width then make sure we only
	  transfer one at a time to avoid a burst stradling an MFIFO entry.
 Return the last desc in the chain 
  Runtime PM callbacks are provided by ambabus.c driver.
  It is assumed here that IRQ safe runtime PM is chosen in probe and amba
  bus driver will only disableenable the clock in runtime PM callbacks.
 Allocate a new DMAC and its Channels 
 get quirk 
 Create a descriptor pool of default size 
 Initialize channel parameters 
 Add the channel to the DMAC list 
	
	  This is the limit for transfers with a buswidth of 1, larger
	  buswidths will have larger limits.
 Idle the DMAC 
 Remove the channel 
 Flush the channel 
 Idle the DMAC 
 Remove the channel 
 Flush the channel 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2019 Linaro Ltd.
 Copyright (C) 2019 Socionext Inc.
 global register 
 channel local register 
 mc->vc.lock must be held by caller 
 mc->vc.lock must be held by caller 
 Setup the channel 
 Start the channel 
 mc->vc.lock must be held by caller 
 Ack and Stop 
 Halt the channel 
	
	  Before reaching here, almost all descriptors have been freed by the
	  ->device_free_chan_resources() hook. However, each channel might
	  be still holding one descriptor that was on-flight at that moment.
	  Terminate it to make sure this hardware is no longer running. Then,
	  free the channel resources once again to avoid memory leak.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) ST-Ericsson SA 2007-2010
  Author: Per Forlin <per.forlin@stericsson.com> for ST-Ericsson
  Author: Jonas Aaberg <jonas.aberg@stericsson.com> for ST-Ericsson
 Sets up proper LCSP1 and LCSP3 register for a logical channel 
 dst 
 src 
 src is mem? -> increase address pos 
 dst is mem? -> increase address pos 
 src is hw? -> master port 1 
 dst is hw? -> master port 1 
 Set master port to 1 
 Set master port to 1 
 Interrupt on end of transfer for destination 
 Generate interrupt on error 
 PSIZE 
 Element size 
 Set the priority bit to high for the physical channel 
 Must be aligned 
 Transfer size can't be smaller than (num_elms  elem_size) 
 The number of elements. IE now many chunks 
	
	  Distance to next element sized entry.
	  Usually the size of the element unless you want gaps.
 Where the data is 
 If this scatter list entry is the last one, no next link 
 Setclear interrupt generation on this link item.
	
	  Post link - D40_SREG_LNK_PHY_PRE_POS = 0
	  Relink happens after transfer completion.
	
	  This piece may be split up based on d40_seg_size(); we only want the
	  term int on the last part.
 DMA logical lli operations 
 The number of elements to transfer 
 16 LSBs address of the current element 
 16 MSBs address of the current element 
 src or dst
 src or dst
 SPDX-License-Identifier: GPL-2.0-only
  Driver for the TXx9 SoC DMA Controller
  Copyright (C) 2009 Atsushi Nemoto
 txd.flags will be overwritten in prep funcs 
  Move a descriptor, including any children, to the free list.
  `desc' must not be on any lists.
----------------------------------------------------------------------
 Called with dc->lock held and bh disabled 
 ASSERT:  channel is idle 
 The tasklet will hopefully advance the queue... 
 All 64-bit DMAC supports SMPCHN 
 Writing a non zero value to CHAR will assert XFACT 
 Writing a non zero value to CHAR will assert XFACT 
----------------------------------------------------------------------
	
	  The API requires that no submissions are done from a
	  callback, so we don't need to drop the lock here
 Make chain-completion interrupt happen 
	
	  Submit queued descriptors ASAP, i.e. before we go through
	  the completed ones.
	
	  The descriptor currently at the head of the active list is
	  borked. Since we don't have any way to report errors, we'll
	  just have to scream loudly and try to carry on.
 Clear all error flags and try to restart the controller 
 Pretend the descriptor completed successfully 
 For dynamic chain, we should look at XFACT instead of NCHNC 
 Everything we've submitted is done 
 last descriptor of this chain 
 This one is currently in progress 
 Currently in progress 
		
		  No descriptors so far seem to be in progress, i.e.
		  this one must be done.
 Try to continue after resetting the channel... 
	
	  Just disable the interrupts. We'll turn them back on in the
	  softirq handler.
	
	  Just disable the interrupts. We'll turn them back on in the
	  softirq handler.
----------------------------------------------------------------------
		
		  Workaround for ERT-TX49H2-033, ERT-TX49H3-020,
		  ERT-TX49H4-016 (slightly conservative)
		
		  The descriptors on tx_list are not reachable from
		  the dc->queue list or dc->active_list after a
		  submit.  If we put all descriptors on active_list,
		  calling of callback on the completion will be more
		  complex.
 Trigger interrupt after last block 
 Trigger interrupt after last block 
 active_list entries will end up before queued entries 
 Flush all pending and queued descriptors 
 Restart chain DMA 
 ASSERT:  channel is idle 
 ASSERT:  channel is idle 
----------------------------------------------------------------------
 force dma off, just in case 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver For Marvell Two-channel DMA Engine
  Copyright: Marvell International Ltd.
  Two-Channel DMA registers
 Byte Count 
 Src Addr 
 Dst Addr 
 Next Desc 
 Control 
 Priority
 Current Desc 
 Int Mask 
 Int Status 
 Two-Channel DMA Control Register 
 Sample Size 
 SSP MOD 
 Channel Abort 
 Close Desc Enable 
 Pack Mode (ADMA Only) 
 Channel Active 
 Fetch Next Desc 
 Channel Enable 
 Interrupt Mode 
 Chain Mode 
 Burst Size 
 Dst Direction 
 Dst Addr Hold 
 Dst Addr Increment 
 Src Direction 
 Src Addr Hold 
 Src Addr Increment 
 Two-Channel DMA Int Mask Register 
 Two-Channel DMA Int Status Register 
  Two-Channel DMA Descriptor Struct
  NOTE: desc's buf must be aligned to 16 bytes.
 enable dma chan 
 clear irq 
 enable interrupt 
 disable interrupt 
 alloc channel 
 add the channel to tdma_chan list 
 always have couple channels 
 initialize channel parameters 
 SPDX-License-Identifier: GPL-2.0-or-later
  DMA driver for Altera mSGDMA IP core
  Copyright (C) 2017 Stefan Roese <sr@denx.de>
  Based on driversdmaxilinxzynqmp_dma.c, which is:
  Copyright (C) 2016 Xilinx, Inc. All rights reserved.
  struct msgdma_extended_desc - implements an extended descriptor
  @read_addr_lo: data buffer source address low bits
  @write_addr_lo: data buffer destination address low bits
  @len: the number of bytes to transfer per descriptor
  @burst_seq_num: bit 31:24 write burst
 		   bit 23:16 read burst
 		   bit 15:00 sequence number
  @stride: bit 31:16 write stride
 	    bit 15:00 read stride
  @read_addr_hi: data buffer source address high bits
  @write_addr_hi: data buffer destination address high bits
  @control: characteristics of the transfer
 mSGDMA descriptor control field bit definitions 
  Writing "1" the "go" bit commits the entire descriptor into the
  descriptor FIFO(s)
 Tx buffer control flags 
 mSGDMA extended descriptor stride definitions 
 mSGDMA dispatcher control and status register map 
 Read  Clear 
 Read  Write 
 31:16 - write fill level 
 15:00 - read fill level 
 response FIFO fill level 
 31:16 - write seq number 
 15:00 - read seq number 
 mSGDMA CSR status register bit definitions 
 mSGDMA CSR control register bit definitions 
 mSGDMA CSR fill level bits 
 mSGDMA response register map 
 mSGDMA response register bit definitions 
  struct msgdma_sw_desc - implements a sw descriptor
  @async_tx: support for the async_tx api
  @hw_desc: assosiated HW descriptor
  @node: node to move from the free list to the tx list
  @tx_list: transmit list node
  struct msgdma_device - DMA device structure
 mSGDMA controller 
 mSGDMA descriptors 
 mSGDMA response 
  msgdma_get_descriptor - Get the sw descriptor from the pool
  @mdev: Pointer to the Altera mSGDMA device structure
  Return: The sw descriptor
  msgdma_free_descriptor - Issue pending transactions
  @mdev: Pointer to the Altera mSGDMA device structure
  @desc: Transaction descriptor pointer
  msgdma_free_desc_list - Free descriptors list
  @mdev: Pointer to the Altera mSGDMA device structure
  @list: List to parse and delete the descriptor
  msgdma_desc_config - Configure the descriptor
  @desc: Hw descriptor pointer
  @dst: Destination buffer address
  @src: Source buffer address
  @len: Transfer length
  @stride: Readwrite stride value to set
 Set lower 32bits of src & dst addresses in the descriptor 
 Set upper 32bits of src & dst addresses in the descriptor 
 0 will result in max burst length 
	
	  Don't set interrupt on xfer end yet, this will be done later
	  for the "last" descriptor
  msgdma_desc_config_eod - Mark the descriptor as end descriptor
  @desc: Hw descriptor pointer
  msgdma_tx_submit - Submit DMA transaction
  @tx: Async transaction descriptor pointer
  Return: cookie value
  msgdma_prep_memcpy - prepare descriptors for memcpy transaction
  @dchan: DMA channel
  @dma_dst: Destination buffer address
  @dma_src: Source buffer address
  @len: Transfer length
  @flags: transfer ack flags
  Return: Async transaction descriptor on success and NULL on failure
 Allocate and populate the descriptor 
  msgdma_prep_slave_sg - prepare descriptors for a slave sg transaction
  @dchan: DMA channel
  @sgl: Destination scatter list
  @sg_len: Number of entries in destination scatter list
  @dir: DMA transfer direction
  @flags: transfer ack flags
  @context: transfer context (unused)
 Run until we are out of scatterlist entries 
 Allocate and populate the descriptor 
 Fetch the next scatterlist entry 
 Reset mSGDMA 
 Clear all status bits 
 Enable the DMA controller including interrupts 
	
	  Check if the DESC FIFO it not full. If its full, we need to wait
	  for at least one entry to become free again
	
	  The descriptor needs to get copied into the descriptor FIFO
	  of the DMA controller. The descriptor will get flushed to the
	  FIFO, once the last word (control word) is written. Since we
	  are not 100% sure that memcpy() writes all word in the "correct"
	  oder (address from low to high) on all architectures, we make
	  sure this control word is written last by single coding it and
	  adding some write-barriers here.
 Write control word last to flush this descriptor into the FIFO 
  msgdma_copy_desc_to_fifo - copy descriptor(s) into controller FIFO
  @mdev: Pointer to the Altera mSGDMA device structure
  @desc: Transaction descriptor pointer
  msgdma_start_transfer - Initiate the new transfer
  @mdev: Pointer to the Altera mSGDMA device structure
  msgdma_issue_pending - Issue pending transactions
  @chan: DMA channel pointer
  msgdma_chan_desc_cleanup - Cleanup the completed descriptors
  @mdev: Pointer to the Altera mSGDMA device structure
 Run any dependencies, then free the descriptor 
  msgdma_complete_descriptor - Mark the active descriptor as complete
  @mdev: Pointer to the Altera mSGDMA device structure
  msgdma_free_descriptors - Free channel descriptors
  @mdev: Pointer to the Altera mSGDMA device structure
  msgdma_free_chan_resources - Free channel resources
  @dchan: DMA channel pointer
  msgdma_alloc_chan_resources - Allocate channel resources
  @dchan: DMA channel
  Return: Number of descriptors on success and failure value on error
  msgdma_tasklet - Schedule completion tasklet
  @t: Pointer to the Altera sSGDMA channel structure
 Read number of responses that are available 
		
		  Read both longwords to purge this response from the FIFO
		  On Avalon-MM implementations, size and status do not
		  have any real values, like transferred bytes or error
		  bits. So we need to just drop these values.
  msgdma_irq_handler - Altera mSGDMA Interrupt handler
  @irq: IRQ number
  @data: Pointer to the Altera mSGDMA device structure
  Return: IRQ_HANDLEDIRQ_NONE
 Start next transfer if the DMA controller is idle 
 Clear interrupt in mSGDMA controller 
  msgdma_chan_remove - Channel remove function
  @mdev: Pointer to the Altera mSGDMA device structure
  msgdma_probe - Driver probe function
  @pdev: Pointer to the platform_device structure
  Return: '0' on success and failure value on error
 Map CSR space 
 Map (extended) descriptor space 
 Map response space 
 Get interrupt nr from platform data 
 Set DMA capabilities 
 Init DMA link list 
 Set base routines 
 Set DMA mask to 64 bits 
  msgdma_dma_remove - Driver remove function
  @pdev: Pointer to the platform_device structure
  Return: Always '0'
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018 Socionext Inc.
   Author: Masahiro Yamada <yamada.masahiro@socionext.com>
 registers common for all channels 
 issue DMA startabort 
 1: abort, 0: start 
 per-channel registers 
 current hw status (RO) 
 latched STAT (WOC) 
 IRQ enable mask 
 REQ & EN (RO) 
 mode of source 
 mode of destination 
 source address 
 destination address 
 transfer bytes 
 mc->vc.lock must be held by caller 
 mc->vc.lock must be held by caller 
 write 1 to clear 
 mc->vc.lock must be held by caller 
 mc->vc.lock must be held by caller 
 write 1 to clear 
	
	  Abort should be accepted soon. We poll the bit here instead of
	  waiting for the interrupt.
	
	  Some channels share a single interrupt line. If the IRQ status is 0,
	  this is probably triggered by a different channel.
 write 1 to clear 
	
	  UNIPHIER_MDMAC_CH_IRQ__DONE interrupt is asserted even when the DMA
	  is aborted. To distinguish the normal completion and the abort,
	  check mc->md. If it is NULL, we are aborting.
 Return immediately if we do not need to compute the residue. 
 residue from the on-flight chunk 
 residue from the queued chunks 
	
	  Before reaching here, almost all descriptors have been freed by the
	  ->device_free_chan_resources() hook. However, each channel might
	  be still holding one descriptor that was on-flight at that moment.
	  Terminate it to make sure this hardware is no longer running. Then,
	  free the channel resources once again to avoid memory leak.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  Virtual DMA channel support for DMAengine
  Copyright (C) 2012 Russell King
  vchan_tx_desc_free - free a reusable descriptor
  @tx: the transfer
  This function frees a previously allocated reusable descriptor. The only
  other way is to clear the DMA_CTRL_REUSE flag and submit one last time the
  transfer.
  Returns 0 upon success
  This tasklet handles the completion of a DMA descriptor by
  calling its callback and freeing it.
 SPDX-License-Identifier: GPL-2.0-or-later
  S3C24XX DMA handling
  Copyright (c) 2013 Heiko Stuebner <heiko@sntech.de>
  based on amba-pl08x.c
  Copyright (c) 2006 ARM Ltd.
  Copyright (c) 2010 ST-Ericsson SA
  Author: Peter Pearse <peter.pearse@arm.com>
  Author: Linus Walleij <linus.walleij@stericsson.com>
  The DMA controllers in S3C24XX SoCs have a varying number of DMA signals
  that can be routed to any of the 4 to 8 hardware-channels.
  Therefore on these DMA controllers the number of channels
  and the number of incoming DMA signals are two totally different things.
  It is usually not possible to theoretically handle all physical signals,
  so a multiplexing scheme with possible denial of use is necessary.
  Open items:
  - bursts
  S3C2410, S3C2440 and S3C2442 SoCs cannot select any physical channel
  for a DMA source. Instead only specific channels are valid.
  All of these SoCs have 4 physical channels and the number of request
  source bits is 3. Additionally we also need 1 bit to mark the channel
  as valid.
  Therefore we separate the chansel element of the channel data into 4
  parts of 4 bits each, to hold the information if the channel is valid
  and the hw request source to use.
  Example:
  SDI is valid on channels 0, 2 and 3 - with varying hw request sources.
  For it the chansel field would look like
  ((BIT(3) | 1) << 3  4) |  channel 3, with request source 1
  ((BIT(3) | 2) << 2  4) |  channel 2, with request source 2
  ((BIT(3) | 2) << 0  4)    channel 0, with request source 2
  struct soc_data - vendor-specific config parameters for individual SoCs
  @stride: spacing between the registers of each channel
  @has_reqsel: does the controller use the newer requestselection mechanism
  @has_clocks: are controllable dma-clocks present
  enum s3c24xx_dma_chan_state - holds the virtual channel states
  @S3C24XX_DMA_CHAN_IDLE: the channel is idle
  @S3C24XX_DMA_CHAN_RUNNING: the channel has allocated a physical transport
  channel and is running a transfer on it
  @S3C24XX_DMA_CHAN_WAITING: the channel is waiting for a physical transport
  channel to become available (only pertains to memcpy channels)
  struct s3c24xx_sg - structure containing data per sg
  @src_addr: src address of sg
  @dst_addr: dst address of sg
  @len: transfer len in bytes
  @node: node for txd's dsg_list
  struct s3c24xx_txd - wrapper for struct dma_async_tx_descriptor
  @vd: virtual DMA descriptor
  @dsg_list: list of children sg's
  @at: sg currently being transfered
  @width: transfer width
  @disrcc: value for source control register
  @didstc: value for destination control register
  @dcon: base value for dcon register
  @cyclic: indicate cyclic transfer
  struct s3c24xx_dma_phy - holder for the physical channels
  @id: physical index to this channel
  @valid: does the channel have all required elements
  @base: virtual memory base (remapped) for the this channel
  @irq: interrupt for this channel
  @clk: clock for this channel
  @lock: a lock to use when altering an instance of this struct
  @serving: virtual channel currently being served by this physicalchannel
  @host: a pointer to the host (internal use)
  struct s3c24xx_dma_chan - this structure wraps a DMA ENGINE channel
  @id: the id of the channel
  @name: name of the channel
  @vc: wrappped virtual channel
  @phy: the physical channel utilized by this channel, if there is one
  @runtime_addr: address for RXTX according to the runtime config
  @at: active transaction on this channel
  @lock: a lock for this channel data
  @host: a pointer to the host (internal use)
  @state: whether the channel is idle, running etc
  @slave: whether this channel is a device (slave) or for memcpy
  struct s3c24xx_dma_engine - the local state holder for the S3C24XX
  @pdev: the corresponding platform device
  @pdata: platform data passed in from the platformmachine
  @base: virtual memory base (remapped)
  @slave: slave engine for this instance
  @memcpy: memcpy engine for this instance
  @phy_chans: array of data for the physical channels
  Physical channel handling
  Check whether a certain channel is busy or not.
 every phy is valid for memcopy channels 
 On newer variants all phys can be used for all virtual channels 
  Allocate a physical channel for a virtual channel
  Try to locate a physical channel to be used for this transfer. If all
  are taken return NULL and the requester will have to cope by using
  some fallback PIO mode or retrying later.
 No physical channel available, cope with it 
 start the phy clock 
  Mark the physical channel as free.
  This drops the link between the physical and virtual channel.
  Stops the channel by writing the stop bit.
  This should not be used for an on-going transfer, but as a method of
  shutting down a channel (eg, when it's no longer used) or terminating a
  transfer.
  Virtual channel handling
 Reject definitely invalid configurations 
  Transfer handling
 transfer-size and -count from len and width 
 trigger the dma operation for memcpy transfers 
  Set the initial DMA register values and start first sg.
 Wait for channel inactive 
 point to the first element of the sg list 
  Try to allocate a physical channel.  When successful, assign it to
  this virtual channel, and initiate the next descriptor.  The
  virtual channel lock must be held at this point.
	
	  We do this without taking the lock; we're really only concerned
	  about whether this pointer is NULL or not, and we're guaranteed
	  that this will only be called when it _already_ is non-NULL.
  Free a physical DMA channel, potentially reallocating it to another
  virtual channel if we have any pending.
 Find a waiting virtual channel for the next transfer. 
 Ensure that the physical channel is stopped 
		
		  Eww.  We know this isn't going to deadlock
		  but lockdep probably doesn't.
 Re-check the state now that we have the lock 
 If the state changed, try to find another channel 
 No more jobs, so free up the physical channel 
	
	  Interrupts happen to notify the completion of a transfer and the
	  channel should have moved into its stop state already on its own.
	  Therefore interrupts on channels not bound to a virtual channel
	  should never happen. Nevertheless send a terminate command to the
	  channel if the unlikely case happens.
 when more sg's are in this txd, start the next one 
			
			  And start the next descriptor (if any),
			  otherwise free this channel.
 Cyclic: reset at beginning 
  The DMA ENGINE API
 Mark physical channel as free 
 Dequeue current job 
 Dequeue jobs not yet fired as well 
 Ensure all queued descriptors are freed 
	
	  There's no point calculating the residue if there's
	  no txstate to store the value.
 On the issued list, so hasn't been processed yet 
		
		  Currently running, so sum over the pending sg's and
		  the currently active one.
	
	  This cookie not complete yet
	  Get number of bytes left in the active transactions and queue
 Whether waiting or running, we're in progress 
  Initialize a descriptor to be used by memcpy submit
	
	  Determine a suitable transfer width.
	  The DMA controller cannot fetchstore information which is not
	  naturally aligned on the bus, i.e., a 4 byte fetch must start at
	  an address divisible by 4 - more generally addr % width must be 0.
	
	  Always assume our peripheral desintation is a fixed
	  address in memory.
	
	  Individual dma operations are requested by the slave,
	  so serve only single atomic operations (S3C24XX_DCON_SERV_SINGLE).
 Check last period length 
 DMA_DEV_TO_MEM 
	
	  Always assume our peripheral desintation is a fixed
	  address in memory.
	
	  Individual dma operations are requested by the slave,
	  so serve only single atomic operations (S3C24XX_DCON_SERV_SINGLE).
 DMA_DEV_TO_MEM 
  Slave transactions callback to the slave device to allow
  synchronization of slave DMA signals with the DMAC enable
  Bringup and teardown
  Initialise the DMAC memcpyslave channels.
  Make a local wrapper to hold required data
	
	  Register as many many memcpy as we have physical channels,
	  we won't always be able to use all but the code will have
	  to cope with that situation.
 s3c2410, s3c2440 and s3c2442 have a 0x40 stride without separate clocks 
 s3c2412 and s3c2413 have a 0x40 stride and dmareqsel mechanism 
 s3c2443 and following have a 0x100 stride and dmareqsel mechanism 
 Basic sanity check 
 acquire irqs and clocks for all physical channels 
 Initialize memcpy engine 
 Initialize slave engine for SoC internal dedicated peripherals 
 Register as many memcpy channels as there are physical channels 
 Register slave channels 
 SPDX-License-Identifier: GPL-2.0-only
  ADMA driver for Nvidia's Tegra210 ADMA controller.
  Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.
  struct tegra_adma_chip_data - Tegra chip specific data
  @adma_get_burst_config: Function callback used to set DMA burst size.
  @global_reg_offset: Register offset of DMA global register.
  @global_int_clear: Register offset of DMA global interrupt clear.
  @ch_req_tx_shift: Register offset for AHUB transmit channel select.
  @ch_req_rx_shift: Register offset for AHUB receive channel select.
  @ch_base_offset: Register offset of DMA channel registers.
  @ch_fifo_ctrl: Default value for channel FIFO CTRL register.
  @ch_req_mask: Mask for Tx or Rx channel select.
  @ch_req_max: Maximum number of Tx or Rx channels available.
  @ch_reg_size: Size of DMA channel register space.
  @nr_channels: Number of DMA channels available.
  @ch_fifo_size_mask: Mask for FIFO size field.
  @sreq_index_offset: Slave channel index offset.
  @has_outstanding_reqs: If DMA channel can have outstanding requests.
  struct tegra_adma_chan_regs - Tegra ADMA channel registers
  struct tegra_adma_desc - Tegra ADMA descriptor to manage transfer requests.
  struct tegra_adma_chan - Tegra ADMA channel information
 Slave channel configuration info 
 Transfer count and position info 
  struct tegra_adma - Tegra ADMA controller information
 Used to store global command register state when suspending 
 Last member of the structure 
 Clear any interrupts 
 Assert soft reset 
 Wait for reset to clear 
 Enable global ADMA registers 
 Disable ADMA 
 Clear interrupt status 
 Start ADMA 
	
	  Handle wrap around of buffer count register
	
	  'sreq_index' represents the current ADMAIF channel number and as per
	  HW recommendation its FIFO size should match with the corresponding
	  ADMA channel.
	 
	  ADMA FIFO size is set as per below (based on default ADMAIF channel
	  FIFO sizes):
	     fifo_size = 0x2 (sreq_index > sreq_index_offset)
	     fifo_size = 0x3 (sreq_index <= sreq_index_offset)
	 
 skip if channel is not active 
 skip if channel was not active earlier 
 SPDX-License-Identifier: GPL-2.0-only
  Driver for the Atmel Extensible DMA Controller (aka XDMAC on AT91 systems)
  Copyright (C) 2014 Atmel Corporation
  Author: Ludovic Desroches <ludovic.desroches@atmel.com>
 Global registers 
 Global Type Register 
 Number of Channels Minus One 
 Number of Bytes 
 Number of Peripheral Requests Minus One 
 Global Configuration Register 
 Global Weighted Arbiter Configuration Register 
 Global Interrupt Enable Register 
 Global Interrupt Disable Register 
 Global Interrupt Mask Register 
 Global Interrupt Status Register 
 Global Channel Enable Register 
 Global Channel Disable Register 
 Global Channel Status Register 
 XDMAC Version Register 
 Channel relative registers offsets 
 Channel Interrupt Enable Register 
 End of Block Interrupt Enable Bit 
 End of Linked List Interrupt Enable Bit 
 End of Disable Interrupt Enable Bit 
 End of Flush Interrupt Enable Bit 
 Read Bus Error Interrupt Enable Bit 
 Write Bus Error Interrupt Enable Bit 
 Request Overflow Interrupt Enable Bit 
 Channel Interrupt Disable Register 
 End of Block Interrupt Disable Bit 
 End of Linked List Interrupt Disable Bit 
 End of Disable Interrupt Disable Bit 
 End of Flush Interrupt Disable Bit 
 Read Bus Error Interrupt Disable Bit 
 Write Bus Error Interrupt Disable Bit 
 Request Overflow Interrupt Disable Bit 
 Channel Interrupt Mask Register 
 End of Block Interrupt Mask Bit 
 End of Linked List Interrupt Mask Bit 
 End of Disable Interrupt Mask Bit 
 End of Flush Interrupt Mask Bit 
 Read Bus Error Interrupt Mask Bit 
 Write Bus Error Interrupt Mask Bit 
 Request Overflow Interrupt Mask Bit 
 Channel Interrupt Status Register 
 End of Block Interrupt Status Bit 
 End of Linked List Interrupt Status Bit 
 End of Disable Interrupt Status Bit 
 End of Flush Interrupt Status Bit 
 Read Bus Error Interrupt Status Bit 
 Write Bus Error Interrupt Status Bit 
 Request Overflow Interrupt Status Bit 
 Channel Source Address Register 
 Channel Destination Address Register 
 Channel Next Descriptor Address Register 
 Channel x Next Descriptor Interface 
 Channel x Next Descriptor Address 
 Channel Next Descriptor Control Register 
 Channel x Next Descriptor Enable 
 Channel x Next Descriptor Source Update 
 Channel x Next Descriptor Destination Update 
 Channel x Next Descriptor View 0 
 Channel x Next Descriptor View 1 
 Channel x Next Descriptor View 2 
 Channel x Next Descriptor View 3 
 Channel Microblock Control Register 
 Channel Block Control Register 
 Channel Configuration Register 
 Channel Transfer Type 
 Memory to Memory Transfer 
 Peripheral to Memory or Memory to Peripheral Transfer 
 Channel Synchronization 
 Channel Protection 
 Channel Software Request Trigger 
 Channel Fill Block of memory 
 Channel Chunk Size 
 Channel Data Width 
 Channel Source Interface Identifier 
 Channel Destination Interface Identifier 
 Channel Source Addressing Mode 
 Channel Source Addressing Mode 
 Channel Initialization Terminated (read only) 
 Read in Progress (read only) 
 Write in Progress (read only) 
 Channel Peripheral Identifier 
 Channel Data Stride Memory Set Pattern 
 Channel Source Microblock Stride 
 Channel Destination Microblock Stride 
 Microblock control members 
 Maximum Microblock Length 
 Next Descriptor Enable 
 Next Descriptor Source Update 
 Next Descriptor Destination Update 
 Next Descriptor View 0 
 Next Descriptor View 1 
 Next Descriptor View 2 
 Next Descriptor View 3 
 16 data 
 64 bits 
 Global Channel Read Suspend Register 
 Global Write Suspend Register 
 Global Channel Read Write Suspend Register 
 Global Channel Read Write Resume Register 
 Global Channel Software Request Register 
 Global channel Software Request Status Register 
 Global Channel Software Flush Request Register 
 Channel reg base 
 SourceDestination Interface must be specified or not 
 AXI queue priority configuration supported 
 ----- Channels ----- 
 Channel Mask 
 Channel Configuration Register 
 Peripheral ID 
 Peripheral Interface 
 Memory Interface 
 ----- Controller ----- 
 ----- Descriptors ----- 
 Linked List Descriptor 
 Next Descriptor Member 
 Microblock Control Member 
 Source Address Member 
 Destination Address Member 
 Configuration Register 
 Block Control Register 
 Data Stride Register 
 Source Microblock Stride Register 
 Destination Microblock Stride Register 
 64-bit alignment needed to update CNDA and CUBC registers in an atomic way. 
 Following members are only used by the first descriptor 
 Wait that all chans are disabled. 
 Call with lock hold. 
 Set transfer as active to not try to start it again. 
 Tell xdmac where to get the first descriptor. 
	
	  When doing non cyclic transfer we need to use the next
	  descriptor view 2 since some fields of the configuration register
	  depend on transfer size and srcdest addresses.
	
	  Even if the register will be updated from the configuration in the
	  descriptor when using view 2 or higher, the PROT bit won't be set
	  properly. This bit can be modified only by using the channel
	  configuration register.
	
	  Request Overflow Error is only for peripheral synchronized transfers
	
	  There is no end of list when doing cyclic dma, we need to get
	  an interrupt after each periods.
 Call must be protected by lock. 
  Only check that maxburst and addr width values are supported by the
  the controller but not that the configuration is good to perform the
  transfer since we don't know the direction at this stage.
 Protect dma_sconfig field that can be modified by set_slave_conf. 
 Prepare descriptors. 
 Linked list descriptor setup. 
 next descriptor view 
 next descriptor dst parameter update 
 next descriptor src parameter update 
 microblock length 
 Chain lld. 
 Chain lld. 
	
	  Check address alignment to select the greater data width we
	  can use.
	 
	  Some XDMAC implementations don't provide dword transfer, in
	  this case selecting dword has the same behavior as
	  selecting word transfers.
	
	  WARNING: The channel configuration is set here since there is no
	  dmaengine_slave_config call in this case. Moreover we don't know the
	  direction, it involves we can't dynamically set the source and dest
	  interface so we have to use the same one. Only interface 0 allows EBI
	  access. Hopefully we can access DDR through both ports (at least on
	  SAMA5D4x), so we can use the same interface for source and dest,
	  that solves the fact we don't know the direction.
	  ERRATA: Even if useless for memory transfers, the PERID has to not
	  match the one of another channel. If not, it could lead to spurious
	  flag status.
	  For SAMA7G5x case, the SIF and DIF fields are no longer used.
	  Thus, no need to have the SIFDIF interfaces here.
	  For SAMA5D4x and SAMA5D2x the SIF and DIF are already configured as
	  zero.
 Chain lld. 
	
	  TODO: Handle the case where we have to repeat a chain of
	  descriptors...
 Length of the block is (BLEN+1) microblocks. 
	
	  WARNING: We don't know the direction, it involves we can't
	  dynamically set the source and dest interface so we have to use the
	  same one. Only interface 0 allows EBI access. Hopefully we can
	  access DDR through both ports (at least on SAMA5D4x), so we can use
	  the same interface for source and dest, that solves the fact we
	  don't know the direction.
	  ERRATA: Even if useless for memory transfers, the PERID has to not
	  match the one of another channel. If not, it could lead to spurious
	  flag status.
	  For SAMA7G5x case, the SIF and DIF fields are no longer used.
	  Thus, no need to have the SIFDIF interfaces here.
	  For SAMA5D4x and SAMA5D2x the SIF and DIF are already configured as
	  zero.
 Prepare descriptors. 
 Update src and dest addresses. 
 Check remaining length and change data width if needed. 
 Chain lld. 
	
	  WARNING: The channel configuration is set here since there is no
	  dmaengine_slave_config call in this case. Moreover we don't know the
	  direction, it involves we can't dynamically set the source and dest
	  interface so we have to use the same one. Only interface 0 allows EBI
	  access. Hopefully we can access DDR through both ports (at least on
	  SAMA5D4x), so we can use the same interface for source and dest,
	  that solves the fact we don't know the direction.
	  ERRATA: Even if useless for memory transfers, the PERID has to not
	  match the one of another channel. If not, it could lead to spurious
	  flag status.
	  For SAMA7G5x case, the SIF and DIF fields are no longer used.
	  Thus, no need to have the SIFDIF interfaces here.
	  For SAMA5D4x and SAMA5D2x the SIF and DIF are already configured as
	  zero.
 Prepare descriptors. 
 Update our strides 
		
		  The scatterlist API gives us only the address and
		  length of each elements.
		 
		  Unfortunately, we don't have the stride, which we
		  will need to compute.
		 
		  That make us end up in a situation like this one:
		     len    stride    len    stride    len
		  +-------+        +-------+        +-------+
		  |  N-2  |        |  N-1  |        |   N   |
		  +-------+        +-------+        +-------+
		 
		  We need all these three elements (N-2, N-1 and N)
		  to actually take the decision on whether we need to
		  queue N-1 or reuse N-2.
		 
		  We will only consider N if it is the last element.
				
				  Increment the block count of the
				  N-2 descriptor
				
				  Put back the N-1 descriptor in the
				  free descriptor list
				
				  Make our N-1 descriptor pointer
				  point to the N-2 since they were
				  actually merged.
			
			  Rule out the case where we don't have
			  pstride computed yet (our second sg
			  element)
			 
			  We also want to catch the case where there
			  would be a negative stride,
				
				  Queue the N-1 descriptor after the
				  N-2
				
				  Add the N-1 descriptor to the list
				  of the descriptors used for this
				  transfer
		
		  If we are the last element, just see if we have the
		  same size than the previous element.
		 
		  If so, we can merge it with the previous descriptor
		  since we don't care about the stride anymore.
			
			  Increment the block count of the N-1
			  descriptor
			
			  Put back the N descriptor in the free
			  descriptor list
 Update our descriptors 
 Update our scatter pointers 
	
	  If the transfer has not been started yet, don't need to compute the
	  residue, it's the transfer length.
	
	  Flush FIFO: only relevant when the transfer is source peripheral
	  synchronized. Flush is needed before reading CUBC because data in
	  the FIFO are not reported by CUBC. Reporting a residue of the
	  transfer length while we have data in FIFO can cause issue.
	  Usecase: atmel USART has a timeout which means I have received
	  characters but there is no more character received for a while. On
	  timeout, it requests the residue. If the data are in the DMA FIFO,
	  we will return a residue of the transfer length. It means no data
	  received. If an application is waiting for these data, it will hang
	  since we won't have another USART timeout without receiving new
	  data.
	
	  The easiest way to compute the residue should be to pause the DMA
	  but doing this can lead to miss some data as some devices don't
	  have FIFO.
	  We need to read several registers because:
	  - DMA is running therefore a descriptor change is possible while
	  reading these registers
	  - When the block transfer is done, the value of the CUBC register
	  is set to its initial value until the fetch of the next descriptor.
	  This value will corrupt the residue calculation so we have to skip
	  it.
	 
	  INITD --------                    ------------
	               |____________________|
	        _______________________  _______________
	  NDA       @desc2             \   @desc3
	        _______________________\_______________
	        __________  ___________  _______________
	  CUBC       0    \ MAX desc1 \  MAX desc2
	        __________\___________\_______________
	 
	  Since descriptors are aligned on 64 bits, we can assume that
	  the update of NDA and CUBC is atomic.
	  Memory barriers are used to ensure the read order of the registers.
	  A max number of retries is set because unlikely it could never ends.
	
	  Flush FIFO: only relevant when the transfer is source peripheral
	  synchronized. Another flush is needed here because CUBC is updated
	  when the controller sends the data write command. It can lead to
	  report data that are not written in the memory or the device. The
	  FIFO flush ensures that data are really written.
	
	  Remove size of all microblocks already transferred and the current
	  one. Then add the remaining size to transfer of the current
	  microblock.
 Call must be protected by lock. 
	
	  Remove the transfer from the transfer list then move the transfer
	  descriptors into the free descriptors list.
	
	  If channel is enabled, do nothing, advance_work will be triggered
	  after the interruption.
	
	  The descriptor currently at the head of the active list is
	  broken. Since we don't have any way to report errors, we'll
	  just have to scream loudly and try to continue with other
	  descriptors queued (if any).
 Channel must be disabled first as it's not done automatically 
 Print bad descriptor's details if needed 
 Then continue with usual descriptor management 
 We have to find which channel has generated the interrupt. 
 Cancel all pending transfers. 
 Not supported 
 Wait for transfer completion, except in cyclic case. 
 Clear pending interrupts. 
	
	  Read number of xdmac channels, read helper function can't be used
	  since atxdmac is not yet allocated and we need to know the number
	  of channels to do the allocation.
 Do not use dev res to prevent races with tasklet 
	
	  Without DMA_PRIVATE the driver is not able to allocate more than
	  one channel, second allocation fails in private_candidate.
 Disable all chans and interrupts. 
 Init channels. 
 Clear pending interrupts. 
 sentinel 
 SPDX-License-Identifier: GPL-2.0+
 Actions Semi Owl SoCs DMA driver
 Copyright (c) 2014 Actions Semi Inc.
 Author: David Liu <liuwei@actions-semi.com>
 Copyright (c) 2018 Linaro Ltd.
 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
 Global DMA Controller Registers 
 Channel Registers 
 OWL_DMAX_MODE Bits 
 OWL_DMAX_LINKLIST_CTL Bits 
 OWL_DMAX_INT_CTL Bits 
 OWL_DMAX_INT_STATUS Bits 
 Pack shift and newshift in a single word 
 Frame count value is fixed as 1 
  enum owl_dmadesc_offsets - Describe DMA descriptor, hardware link
  list for dma transfer
  @OWL_DMADESC_NEXT_LLI: physical address of the next link list
  @OWL_DMADESC_SADDR: source physical address
  @OWL_DMADESC_DADDR: destination physical address
  @OWL_DMADESC_FLEN: frame length
  @OWL_DMADESC_SRC_STRIDE: source stride
  @OWL_DMADESC_DST_STRIDE: destination stride
  @OWL_DMADESC_CTRLA: dma_mode and linklist ctrl config
  @OWL_DMADESC_CTRLB: interrupt config
  @OWL_DMADESC_CONST_NUM: data for constant fill
  @OWL_DMADESC_SIZE: max size of this enum
  struct owl_dma_lli - Link list for dma transfer
  @hw: hardware link list
  @phys: physical address of hardware link list
  @node: node for txd's lli_list
  struct owl_dma_txd - Wrapper for struct dma_async_tx_descriptor
  @vd: virtual DMA descriptor
  @lli_list: link list of lli nodes
  @cyclic: flag to indicate cyclic transfers
  struct owl_dma_pchan - Holder for the physical channels
  @id: physical index to this channel
  @base: virtual memory base for the dma channel
  @vchan: the virtual channel currently being served by this physical channel
  struct owl_dma_pchan - Wrapper for DMA ENGINE channel
  @vc: wrappped virtual channel
  @pchan: the physical channel utilized by this channel
  @txd: active transaction on this channel
  @cfg: slave configuration for this channel
  @drq: physical DMA request ID for this channel
  struct owl_dma - Holder for the Owl DMA controller
  @dma: dma engine for this instance
  @base: virtual memory base for the DMA controller
  @clk: clock for the DMA controller
  @lock: a lock to use when change DMA controller global register
  @lli_pool: a pool for the LLI descriptors
  @irq: interrupt ID for the DMA controller
  @nr_pchans: the number of physical channels
  @pchans: array of data for the physical channels
  @nr_vchans: the number of physical channels
  @vchans: array of data for the physical channels
  @devid: device id based on OWL SoC
	
	  Irrespective of the SoC, ctrlb value starts filling from
	  bit 18.
		
		  Hardware only supports 32bit and 8bit buswidth. Since the
		  default is 32bit, select 8bit only when requested.
		
		  Hardware only supports 32bit and 8bit buswidth. Since the
		  default is 32bit, select 8bit only when requested.
 One link list by default 
 Max frame length is 1MB 
		
		  On S700, word starts from offset 0x1C is shared between
		  frame count and ctrlb, where first 12 bits are for frame
		  count and rest of 20 bits are for ctrlb.
		
		  On S900, word starts from offset 0xC is shared between
		  frame length (max frame length is 1MB) and frame count,
		  where first 20 bits are for frame length and rest of
		  12 bits are for frame count.
 Wait for channel inactive 
 Clear IRQ status for this pchan 
 Start DMA transfer for this pchan 
 Ensure that the physical channel is stopped 
 Clear IRQ status for each pchan 
 Clear pending IRQ 
 Check missed pending IRQ 
 Dummy read to ensure OWL_DMA_IRQ_PD0 value is updated 
 Clear IRQ status for this pchan 
 Update global IRQ pending 
			
			  Start the next descriptor (if any),
			  otherwise free this channel.
 Reject definitely invalid configurations 
 Get remain count of current node in link list 
 Loop through the preceding nodes to get total remaining bytes 
 Start from the next active node 
 Process the transfer as frame by frame 
 close the cyclic list 
 Ensure all queued descriptors are freed 
 sentinel  },
	
	  Eventhough the DMA controller is capable of generating 4
	  IRQ's for DMA priority feature, we only use 1 IRQ for
	  simplification.
 Init physical channel 
 Init virtual channel 
 Create a pool of consistent memory blocks for hardware descriptors 
 Device-tree DMA controller registration 
 Mask all interrupts for this execution environment 
 Make sure we won't have any further interrupts 
 SPDX-License-Identifier: GPL-2.0+
  BCM2835 DMA engine support
  Author:      Florian Meier <florian.meier@koalo.de>
               Copyright 2013
  Based on
 	OMAP DMAengine support by Russell King
 	BCM2708 DMA Driver
 	Copyright (C) 2010 Broadcom
 	Raspberry Pi PCM I2S ALSA Driver
 	Copyright (c) by Phil Poole 2013
 	MARVELL MMP Peripheral DMA Driver
 	Copyright 2012 Marvell International Ltd.
  struct bcm2835_dmadev - BCM2835 DMA controller
  @ddev: DMA device
  @base: base address of register map
  @zero_page: bus address of zero page (to detect transactions copying from
 	zero page and avoid accessing memory if so)
 DMA CS Control and Status bits 
 activate the DMA 
 current CB has ended 
 interrupt status 
 DREQ state 
 Pause requested or not active 
 Is held by DREQ flow control 
#define BCM2835_DMA_WAITING_FOR_WRITES BIT(6)  waiting for last
					        AXI-write to ack
 AXI priority 
 panic priority 
 current value of TI.BCM2835_DMA_WAIT_RESP 
 disable debug pause signal 
 Stop current CB, go to next, WO 
 WO, self clearing 
 Transfer information bits - also bcm2835_cb.info field 
 2D-Mode 
 wait for AXI-write to be acked 
 128bit writes if set 
 enable DREQ for destination 
 ignore destination writes 
 128bit writes if set 
 enable SREQ for source 
 ignore source reads - read 0 
 REQ source 
 add DMA-wait cycles 
 no 2 beat write bursts 
 debug register bits 
 shared registers for all dma channels 
 Valid only for channels 0 - 14, 15 has its own base address 
 Base address 
 the max dma length for different channels 
 lite and normal channels have different max frame length 
 how many frames of max_len size do we need to transfer len bytes 
 set the length taking lite-channel limitations into account 
 finished if we have no period_length 
	
	  period_len means: that we need to generate
	  transfers that are terminating at every
	  multiple of period_len - this is typically
	  used to set the interrupt flag in info
	  which is required during cyclic transfers
 have we filled in period_length yet? 
 update number of bytes in this period so far 
 calculate the length that remains to reach period_length 
 reset total_length for next period 
 add extrainfo bits in info 
  bcm2835_dma_create_cb_chain - create a control block and fills data in
  @chan:           the @dma_chan for which we run this
  @direction:      the direction in which we transfer
  @cyclic:         it is a cyclic transfer
  @info:           the default info bits to apply per controlblock
  @frames:         number of controlblocks to allocate
  @src:            the src address to assign (if the S_INC bit is set
                   in @info, then it gets incremented)
  @dst:            the dst address to assign (if the D_INC bit is set
                   in @info, then it gets incremented)
  @buf_len:        the full buffer length (may also be 0)
  @period_len:     the period length when to apply @finalextrainfo
                   in addition to the last transfer
                   this will also break some control-blocks early
  @finalextrainfo: additional bits in last controlblock
                   (or when period_len is reached in case of cyclic)
  @gfp:            the GFP flag to use for allocation
 allocate and setup the descriptor. 
	
	  Iterate over all frames, create a control block
	  for each frame and link them together.
 fill in the control block 
 set up length in control_block if requested 
 calculate length honoring period_length 
 calculate new remaining length 
 link this the last controlblock 
 update src and dst and length 
 Length of total transfer 
 the last frame requires extra flags 
 detect a size missmatch 
	
	  A zero control block address means the channel is idle.
	  (The ACTIVE flag in the CS register is not a reliable indicator.)
 Write 0 to the active bit - Pause the DMA 
 Wait for any current AXI transfer to complete 
 Peripheral might be stuck and fail to signal AXI write responses 
 check the shared interrupt 
 check if the interrupt is enabled 
 if not set then we are not the reason for the irq 
	
	  Clear the INT flag to receive further interrupts. Keep the channel
	  active in case the descriptor is cyclic or in case the client has
	  already terminated the descriptor and issued a new one. (May happen
	  if this IRQ handler is threaded.) If the channel is finished, it
	  will remain idle despite the ACTIVE flag being set.
 call the cyclic callback 
	
	  Control blocks are 256 bit in length and must start at a 256 bit
	  (32 byte) aligned address (BCM2835 ARM Peripherals, sec. 4.2.1.1).
 if src, dst or len is not given return with an error 
 calculate number of frames 
 allocate the CB chain - this also fills in the pointers 
 count frames in sg list 
 allocate the CB chain 
 fill in frames with scatterlist pointers 
 Grab configuration 
	
	  warn if buf_len is not a multiple of period_len - this may leed
	  to unexpected latencies for interrupts and thus audiable clicks
 Setup DREQ channel 
 non-lite channels can write zeroes wo accessing memory 
 calculate number of frames 
 number of periods 
 number of frames per period 
	
	  allocate the CB chain
	  note that we need to use GFP_NOWAIT, as the ALSA i2s dmaengine
	  implementation calls prep_dma_cyclic with interrupts disabled.
 wrap around into a loop 
 stop DMA activity 
 check in DEBUG register if this is a LITE channel 
 Set DREQ from param 
 Request DMA channel mask from device tree 
 get irqs for each channel that we support 
 skip masked out channels 
 get the named irq 
 legacy device tree case handling 
		
		  in case of channel >= 11
		  use the 11th interrupt and that is shared
 get irqs for each channel 
 skip channels without irq 
 check if there are other channels that also use this irq 
 initialize the channel 
 Device-tree DMA controller registration 
  Copyright (C) 2017 Broadcom
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  Broadcom SBA RAID Driver
  The Broadcom stream buffer accelerator (SBA) provides offloading
  capabilities for RAID operations. The SBA offload engine is accessible
  via Broadcom SoC specific ring manager. Two or more offload engines
  can share same Broadcom SoC specific ring manager due to this Broadcom
  SoC specific ring manager driver is implemented as a mailbox controller
  driver and offload engine drivers are implemented as mallbox clients.
  Typically, Broadcom SoC specific ring manager will implement larger
  number of hardware rings over one or more SBA hardware devices. By
  design, the internal buffer size of SBA hardware device is limited
  but all offload operations supported by SBA can be broken down into
  multiple small size requests and executed parallely on multiple SBA
  hardware devices for achieving high through-put.
  The Broadcom SBA RAID driver does not require any register programming
  except submitting request to SBA hardware device via mailbox channels.
  This driver implements a DMA device with one DMA channel using a single
  mailbox channel provided by Broadcom SoC specific ring manager driver.
  For having more SBA DMA channels, we can create more SBA device nodes
  in Broadcom SoC specific DTS based on number of hardware rings supported
  by Broadcom SoC ring manager.
 ====== Driver macros and defines ===== 
 Driver helper macros 
 ===== Driver data structures ===== 
 Global state 
 Chained requests management 
 BRCM message data 
 SBA commands 
 Underlying device 
 DT configuration parameters 
 Derived configuration parameters 
 Maibox client and Mailbox channels 
 DMA device and DMA channel 
 DMA channel resources 
 DebugFS directory entries 
 ====== Command helper routines ===== 
 ====== General helper routines ===== 
		
		  We have no more free requests so, we peek
		  mailbox channels hoping few active requests
		  would have completed which will create more
		  room for new requests.
 Note: Must be called with sba->reqs_lock held 
 Note: Must be called with sba->reqs_lock held 
 Note: Must be called with sba->reqs_lock held 
 Note: Must be called with sba->reqs_lock held 
 Freeup all alloced request 
 Set all active requests as aborted 
	
	  Note: We expect that aborted request will be eventually
	  freed by sba_receive_message()
 Freeup all pending request 
 Send message for the request 
 Check error returned by mailbox controller 
 Signal txdone for mailbox channel 
 Note: Must be called with sba->reqs_lock held 
 Process few pending requests 
 Get the first pending request 
 Try to make request active 
 Send request to mailbox channel 
 Process only after all chained requests are received 
 Free all requests chained to first request 
 Free the first request 
 Process pending requests 
 ====== DMAENGINE callbacks ===== 
	
	  Channel resources are pre-alloced so we just free-up
	  whatever we can so that we can re-use pre-alloced
	  channel resources next time.
 Cleanup all pending requests 
 Process pending requests 
 Assign cookie and mark all chained requests pending 
 Type-B command to load dummy data into buf0 
 Type-A command to write buf0 to dummy location 
 Fillup brcm_message 
 Alloc new request 
	
	  Force fence so that no requests are submitted
	  until DMA callback for this request is invoked.
 Fillup request message 
 Init async_tx descriptor 
 Type-B command to load data into buf0 
 Type-A command to write buf0 
 Fillup brcm_message 
 Alloc new request 
 Fillup request message 
 Init async_tx descriptor 
 Create chained requests where each request is upto hw_buf_size 
 Type-B command to load data into buf0 
 Type-B commands to xor data with buf0 and put it back in buf0 
 Type-A command to write buf0 
 Fillup brcm_message 
 Alloc new request 
 Fillup request message 
 Init async_tx descriptor 
 Sanity checks 
 Create chained requests where each request is upto hw_buf_size 
 Type-B command to load old P into buf0 
 Type-B command to load old Q into buf1 
 Type-A command to zero all buffers 
 Type-B commands for generate P onto buf0 and Q onto buf1 
 Type-A command to write buf0 
 Type-A command to write buf1 
 Fillup brcm_message 
 Alloc new request 
 Fillup request messages 
 Init async_tx descriptor 
 Type-B command to load old P into buf0 
		
		  Type-B commands to xor data with buf0 and put it
		  back in buf0
 Type-B command to load old P into buf0 
 Type-A command to write buf0 
 Type-A command to zero all buffers 
	
	  Type-B command to generate initial Q from data
	  and store output into buf0
 Multiple Type-A command to generate final Q 
		
		  Type-A command to generate Q with buf0 and
		  buf1 store result in buf0
		
		  Type-B command to XOR previous output with
		  buf0 and write it into buf0
 Type-A command to write buf0 
 Fillup brcm_message 
 Alloc new request 
 Fillup request messages 
 Init async_tx descriptor 
 Sanity checks 
 Figure-out P and Q destination addresses 
 Create chained requests where each request is upto hw_buf_size 
 ====== Mailbox callbacks ===== 
 Error count if message has error 
 Process received request 
 ====== Debugfs callbacks ====== 
 Write stats in file 
 ====== Platform driver routines ===== 
 Initialize DMA channel cookie 
 Initialize DMA device capability mask 
	
	  Set mailbox channel device as the base device of
	  our dma_device because the actual memory accesses
	  will be done by mailbox controller
 Set base prep routines 
 Set interrupt routine 
 Set memcpy routine 
 Set xor routine and capability 
 Set pq routine and capability 
 Initialize DMA device channel list 
 Register with Linux async DMA framework
 Allocate main SBA struct 
 Number of mailbox channels should be atleast 1 
 Determine SBA version from DT compatible string 
 Derived Configuration parameters 
		
		  We can support max_pq_srcs == max_pq_coefs because
		  we are limited by number of SBA commands that we can
		  fit in one message for underlying ring manager HW.
 Setup mailbox client 
 Request mailbox channel 
 Find-out underlying mailbox device 
 Prealloc channel resource 
 Check availability of debugfs 
 Create debugfs root entry 
 Create debugfs stats entry 
 Register DMA device with Linux async framework 
 Print device info 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) Freescale Semicondutor, Inc. 2007, 2008.
  Copyright (C) Semihalf 2009
  Copyright (C) Ilya Yanok, Emcraft Systems 2010
  Copyright (C) Alexander Popov, Promcontroller 2014
  Copyright (C) Mario Six, Guntermann & Drunck GmbH, 2016
  Written by Piotr Ziecik <kosmo@semihalf.com>. Hardware description
  (defines, structures and comments) was taken from MPC5121 DMA driver
  written by Hongjun Chen <hong-jun.chen@freescale.com>.
  Approved as OSADL project by a majority of OSADL members and funded
  by OSADL membership fees in 2009;  for details see www.osadl.org.
  MPC512x and MPC8308 DMA driver. It supports memory to memory data transfers
  (tested using dmatest module) and data transfers between memory and
  peripheral IO memory by means of slave scattergather with these
  limitations:
   - chunked transfers (described by sg lists with more than one item) are
      refused as long as proper support for scattergather is missing
   - transfers on MPC8308 always start from software as this SoC does not have
      external request lines for peripheral flow control
   - memory <-> IO memory transfer chunks of sizes of 1, 2, 4, 16 (for
      MPC512x), and 32 bytes are supported, and, consequently, source
      addresses and destination addresses must be aligned accordingly;
      furthermore, for MPC512x SoCs, the transfer size must be aligned on
      (chunk size  maxburst)
 Number of DMA Transfer descriptors allocated per channel 
 Macro definitions 
  Maximum channel counts for individual hardware variants
  and the maximum channel count over all supported controllers,
  used for data structure size
 Arbitration mode of group and channel 
 Error codes 
 MPC5121 DMA engine registers 
 0x00 
 DMA control register 
 DMA error status 
 0x08 
 DMA enable request high(channels 63~32) 
 DMA enable request low(channels 31~0) 
 DMA enable error interrupt high(ch63~32) 
 DMA enable error interrupt low(ch31~0) 
 0x18 
 DMA set enable request 
 DMA clear enable request 
 DMA set enable error interrupt 
 DMA clear enable error interrupt 
 0x1c 
 DMA clear interrupt request 
 DMA clear error 
 DMA set start bit 
 DMA clear DONE status bit 
 0x20 
 DMA interrupt request high(ch63~32) 
 DMA interrupt request low(ch31~0) 
 DMA error high(ch63~32) 
 DMA error low(ch31~0) 
 0x30 
 DMA hw request status high(ch63~32) 
 DMA hardware request status low(ch31~0) 
 DMA interrupt high select AXE(ch63~32) 
 (General purpose register on MPC8308) 
 DMA interrupt low select AXE(ch31~0) 
 0x40 ~ 0xff 
 Reserved 
 0x100 
 DMA channels(0~63) priority 
 0x00 
 Source address 
 Source address modulo 
 Source data transfer size 
 Destination address modulo 
 Destination data transfer size 
 Signed source address offset 
 0x08 
 Inner "minor" byte count 
 Last source address adjustment 
 Destination address 
 0x14 
	u32 citer_elink:1;	 Enable channel-to-channel linking on
				  minor loop complete
 Link channel for minor loop complete 
 Current "major" iteration count 
 Signed destination address offset 
 0x18 
	u32 dlast_sga;		 Last Destination address adjustmentscatter
				  gather address
 0x1c 
	u32 biter_elink:1;	 Enable channel-to-channel linking on major
				  loop complete
 Beginning "major" iteration count 
 Bandwidth control 
 Link channel number 
 Channel done 
 Channel active 
	u32 major_elink:1;	 Enable channel-to-channel linking on major
				  loop complete
 Enable scattergather processing 
 Disable request 
	u32 int_half:1;		 Enable an interrupt when major counter is
				  half complete
	u32 int_maj:1;		 Enable an interrupt when major iteration
				  count completes
 Channel start 
 Settings for access to peripheral FIFO 
 Lock for this structure 
 Lock for error_status field in this structure 
 Convert struct dma_chan to struct mpc_dma_chan 
 Convert struct dma_chan to struct mpc_dma 
  Execute all queued DMA descriptors.
  Following requirements must be met while calling mpc_dma_execute():
 	a) mchan->lock is acquired,
 	b) mchan->active list is empty,
 	c) mchan->queued list contains at least one entry.
		
		  Grab either several mem-to-mem transfer descriptors
		  or one peripheral transfer descriptor,
		  don't mix mem-to-mem and peripheral transfer descriptors
		  within the same 'active' list.
 Chain descriptors into one transaction 
 Send first descriptor in chain into hardware 
 MPC8308, no request lines, software initiated start 
 Peripherals involved, start by external request signal 
 Memory to memory transfer, software initiated start 
 Handle interrupt on one half of DMA controller (32 channels) 
 Check error status 
 Execute queued descriptors 
 Interrupt handler 
 Save error status register 
 Handle interrupt on each channel 
 Schedule tasklet 
 process completed descriptors 
 Get all completed descriptors 
 Execute callbacks and run dependencies 
 Free descriptors 
 DMA Tasklet 
 Print nice error report 
 Submit descriptor to hardware 
 Move descriptor to queue 
 If channel is idle, execute all queued descriptors 
 Update cookie 
 Alloc channel resources 
 Alloc DMA memory for Transfer Control Descriptors 
 Alloc descriptors for this channel 
 Return error only if no descriptors were allocated 
 Enable Error Interrupt 
 Free channel resources 
 Channel must be idle 
 Move data 
 Free DMA memory used by descriptors 
 Free descriptors 
 Disable Error Interrupt 
 Send all pending descriptor to hardware 
	
	  We are posting descriptors to the hardware as soon as
	  they are ready, so this function does nothing.
 Check request completion status 
 Prepare descriptor for memory to memory copy 
 Get free descriptor 
 try to free completed descriptors 
 Prepare Transfer Control Descriptor for this transaction 
 MPC8308 doesn't support 16 byte transfers 
 Place descriptor in prepared list 
 Currently there is no proper support for scattergather 
 Try to free completed descriptors 
 Prepare Transfer Control Descriptor for this transaction 
 No major loops for MPC8303 
 len is too big 
 citer_linkch contains the high bits of iter 
 Place descriptor in prepared list 
 Put the descriptor back 
	
	  Software constraints:
	   - only transfers between a peripheral device and memory are
	      supported
	   - transfer chunk sizes of 1, 2, 4, 16 (for MPC512x), and 32 bytes
	      are supported, and, consequently, source addresses and
	      destination addresses; must be aligned accordingly; furthermore,
	      for MPC512x SoCs, the transfer size must be aligned on (chunk
	      size  maxburst)
	   - during the transfer, the RAM address is incremented by the size
	      of transfer chunk
	   - the peripheral port's address is constant during the transfer.
 Apply defaults 
 Disable channel requests 
	
	  Configure DMA Engine:
	  - Dynamic clock,
	  - Round-robin group arbitration,
	  - Round-robin channel arbitration.
 MPC8308 has 16 channels and lacks some registers 
 enable snooping 
 Disable error interrupts 
 Clear interrupts status 
 Disable hardware DMA requests 
 Disable error interrupts 
 Clear interrupts status 
 Route interrupts to IPIC 
 Register DMA engine 
 Register with OF helpers for DMA lookups (nonfatal) 
 SPDX-License-Identifier: GPL-2.0+
 Copyright (c) 2013-2014 Freescale Semiconductor, Inc
 Copyright (c) 2017 Sysam, Angelo Dureghello  <angelo@sysam.it>
 terminate_all called before 
 Set up drvdata for ColdFire edma 
 Enable round robin arbitration 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2019 Linaro Ltd.
 Copyright (C) 2019 Socionext Inc.
 global 
 channel 
 mc->vc.lock must be held by caller 
 mc->vc.lock must be held by caller 
 mc->vc.lock must be held by caller 
 Ack and Disable irqs 
 disable the channel 
 Return immediately if we do not need to compute the residue. 
 residue from the on-flight chunk 
 residue from the queued chunks 
	
	  Before reaching here, almost all descriptors have been freed by the
	  ->device_free_chan_resources() hook. However, each channel might
	  be still holding one descriptor that was on-flight at that moment.
	  Terminate it to make sure this hardware is no longer running. Then,
	  free the channel resources once again to avoid memory leak.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  Driver for STM32 DMA controller
  Inspired by dma-jz4740.c and tegra20-apb-dma.c
  Copyright (C) M'boumba Cedric Madianga 2015
  Author: M'boumba Cedric Madianga <cedric.madianga@gmail.com>
          Pierre-Yves Mordret <pierre-yves.mordret@st.com>
 DMA Low Int Status Reg 
 DMA High Int Status Reg 
 DMA Low Int Flag Clear Reg 
 DMA High Int Flag Clear Reg 
 Transfer Complete Interrupt 
 Half Transfer Interrupt 
 Transfer Error Interrupt 
 Direct Mode Error Interrupt 
 FIFO Error Interrupt 
 DMA Stream x Configuration Register 
 x = 0..7 
 Bufferable transfer for USARTUART 
 Target in double buffer 
 Double Buffer Mode 
 Peripheral inc offset size 
 Memory increment mode 
 Peripheral increment mode 
 Circular mode 
 Peripheral Flow Controller 
#define STM32_DMA_SCR_TCIE		BIT(4)  Transfer Complete Int Enable
 Transfer Error Int Enable 
 Direct Mode Err Int Enable 
 Stream Enable 
 DMA Stream x number of data register 
 DMA stream peripheral address register 
 DMA stream x memory 0 address register 
 DMA stream x memory 1 address register 
 DMA stream x FIFO control register 
 FIFO error interrupt enable 
 Direct mode disable 
 DMA direction 
 DMA priority level 
 DMA FIFO threshold selection 
  Valid transfer starts from @0 to @0xFFFE leading to unaligned scatter
  gather at boundary. Thus it's safer to round down this value on FIFO
  size (16 Bytes)
 FIFO is 16 bytes 
 DMA Features 
  struct stm32_dma_cfg - STM32 DMA custom configuration
  @channel_id: channel ID
  @request_line: DMA request
  @stream_config: 32bit mask specifying the DMA channel configuration
  @features: 32bit mask specifying the DMA Feature list
			
			  If number of beats fit in several whole bursts
			  this configuration is allowed.
 If FIFO direct mode, burst is not possible 
	
	  Buffer or period length has to be aligned on FIFO depth.
	  Otherwise bytes may be stuck within FIFO at buffer or period
	  length.
 Using direct mode 
 Using FIFO mode 
	
	  Read "flags" from DMA_xISR register corresponding to the selected
	  DMA channel at the correct bit offset inside that register.
	 
	  If (ch % 4) is 2 or 3, left shift the mask by 16 bits.
	  If (ch % 4) is 1 or 3, additionally left shift the mask by 6 bits.
	
	  Write "flags" to the DMA_xIFCR register corresponding to the selected
	  DMA channel at the correct bit offset inside that register.
	 
	  If (ch % 4) is 2 or 3, left shift the mask by 16 bits.
	  If (ch % 4) is 1 or 3, additionally left shift the mask by 6 bits.
 Disable interrupts 
 Disable DMA 
 Clear interrupt status if it is there 
 Clear interrupt status if it is there 
 Start DMA 
 Set device data size 
 Set device burst size 
 Set memory data size 
		
		  Set memory burst size - burst not possible if address is not aligned on
		  the address boundary equal to the size of the transfer
 Set FIFO threshold 
 Set peripheral address 
 Set device data size 
 Set device burst size 
 Set memory data size 
		
		  Set memory burst size - burst not possible if address is not aligned on
		  the address boundary equal to the size of the transfer
 Set FIFO threshold 
 Set peripheral address 
 Set DMA control register 
 Set peripheral flow controller 
	
	  We allow to take more number of requests till DMA is
	  not started. The driver will loop over all requests.
	  Once DMA is started then new requests can be queued only after
	  terminating the DMA.
  Enable Circular mode or double buffer mode 
 Clear periph ctrl if client set it 
 Compute best burst size 
  stm32_dma_is_current_sg - check that expected sg_req is currently transferred
  @chan: dma channel
  This function called when IRQ are disable, checks that the hardware has not
  switched on the next transfer in double buffer mode. The test is done by
  comparing the next_sg memory address with the hardware related register
  (based on CT bit value).
  Returns true if expected current transfer is still running or double
  buffer mode is not activated.
	
	  Calculate the residue means compute the descriptors
	  information:
	  - the sg_req currently transferred
	  - the Hardware remaining position in this sg (NDTR bits field).
	 
	  A race condition may occur if DMA is running in cyclic or double
	  buffer mode, since the DMA register are automatically reloaded at end
	  of period transfer. The hardware may have switched to the next
	  transfer (CT bit updated) just before the position (SxNDTR reg) is
	  read.
	  In this case the SxNDTR reg could (or not) correspond to the new
	  transfer position, and not the expected one.
	  The strategy implemented in the stm32 driver is to:
	   - read the SxNDTR register
	   - crosscheck that hardware is still in current transfer.
	  In case of switch, we can assume that the DMA is at the beginning of
	  the next transfer. So we approximate the residue in consequence, by
	  pointing on the beginning of next transfer.
	 
	  This race condition doesn't apply for none cyclic mode, as double
	  buffer is not used. In such situation registers are updated by the
	  software.
	
	  In cyclic mode, for the last period, residue = remaining bytes
	  from NDTR,
	  else for all other periods in cyclic mode, and in sg mode,
	  residue = remaining bytes from NDTR + remaining
	  periodssg to be transferred
 Enable Interrupts  
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2015-2016 Marvell International Ltd.
 DMA Engine Registers 
 Same flags as MV_XOR_V2_DMA_DESQ_ARATTR_OFF 
 XOR Global registers 
  Descriptors queue size. With 32 bytes descriptors, up to 2^14
  descriptors are allowed, with 128 bytes descriptors, up to 2^12
  descriptors are allowed. This driver uses 128 bytes descriptors,
  but experimentation has shown that a set of 1024 descriptors is
  sufficient to reach a good level of performance.
  Threshold values for descriptors and timeout, determined by
  experimentation as giving a good level of performance.
  struct mv_xor_v2_descriptor - DMA HW descriptor
  @desc_id: used by SW and is not affected by HW.
  @flags: error and status flags
  @crc32_result: CRC32 calculation result
  @desc_ctrl: operation mode and control flags
  @buff_size: amount of bytes to be processed
  @fill_pattern_src_addr: Fill-Pattern or Source-Address and
  AW-Attributes
  @data_buff_addr: Source (and might be RAID6 destination)
  addresses of data buffers in RAID5 and RAID6
  @reserved: reserved
 Definitions for desc_ctrl 
 Idle operation 
 Pure-DMA operation 
 Mem-Fill operation 
 Mem-Init operation 
 Mem-Compare operation 
 CRC32 calculation 
 RAID5 (XOR) operation 
 RAID6 P&Q-generation 
 RAID6 Recovery 
  struct mv_xor_v2_device - implements a xor device
  @lock: lock for the engine
  @clk: reference to the 'core' clock
  @reg_clk: reference to the 'reg' clock
  @dma_base: memory mapped DMA register base
  @glob_base: memory mapped global register base
  @irq_tasklet: tasklet used for IRQ handling call-backs
  @free_sw_desc: linked list of free SW descriptors
  @dmadev: dma device
  @dmachan: dma channel
  @hw_desq: HW descriptors queue
  @hw_desq_virt: virtual address of DESCQ
  @sw_desq: SW descriptors queue
  @desc_size: HW descriptor size
  @npendings: number of pending descriptors (for which tx_submit has
  @hw_queue_idx: HW queue index
  @msi_desc: local interrupt descriptor information
  been called, but not yet issue_pending)
  struct mv_xor_v2_sw_desc - implements a xor SW descriptor
  @idx: descriptor index
  @async_tx: support for the async_tx api
  @hw_desc: assosiated HW descriptor
  @free_list: node of the free SW descriprots list
  Fill the data buffers to a HW descriptor
	
	  Fill the buffer's addresses to the descriptor.
	 
	  The format of the buffers address for 2 sequential buffers
	  X and X + 1:
	 
	   First word:  Buffer-DX-Address-Low[31:0]
	   Second word: Buffer-DX+1-Address-Low[31:0]
	   Third word:  DX+1-Buffer-Address-High[47:32] [31:16]
	 		 DX-Buffer-Address-High[47:32] [15:0]
  notify the engine of new descriptors, and update the available index.
 write the number of new descriptors in the DESQ. 
  free HW descriptors
 write the number of new descriptors in the DESQ. 
  Set descriptor size
  Return the HW descriptor size in bytes
  Set the IMSG threshold
 Configure threshold of number of descriptors, and enable timer 
 Configure Timer Threshold 
 No descriptors to process 
 schedule a tasklet to handle descriptors callbacks 
  submit a descriptor to the DMA engine
 assign coookie 
 copy the HW descriptor from the SW descriptor to the DESQ 
  Prepare a SW descriptor
 Lock the channel 
 schedule tasklet to free some descriptors 
 Release the channel 
  Prepare a HW descriptor for a memcpy operation
 set the HW descriptor 
 save the SW descriptor ID to restore when operation is done 
 Set the MEMCPY control word 
 Set source address 
 Set Destination address 
 Set buffers size 
 return the async tx descriptor 
  Prepare a HW descriptor for a XOR operation
 set the HW descriptor 
 save the SW descriptor ID to restore when operation is done 
 Set the XOR control word 
 Set the data buffers 
 Set Destination address 
 Set buffers size 
 return the async tx descriptor 
  Prepare a HW descriptor for interrupt operation.
 set the HW descriptor 
 save the SW descriptor ID to restore when operation is done 
 Set the INTERRUPT control word 
 return the async tx descriptor 
  push pending transactions to hardware
	
	  update the engine with the number of descriptors to
	  process
 get the next pending descriptor index 
 get the number of descriptors pending handle 
  handle the descriptors after HW process
 get the pending descriptors parameters 
 loop over free descriptors 
 get the SW descriptor related to the HW descriptor 
 call the callback 
			
			  update the channel's completed cookie - no
			  lock is required the IMSG threshold provide
			  the locking
 Lock the channel 
 add the SW descriptor to the free descriptors list 
 Release the channel 
 increment the next descriptor 
 free the descriptores 
 	Set DMA Interrupt-message (IMSG) parameters
 write the DESQ size to the DMA engine 
 write the DESQ address to the DMA enngine
	
	  This is a temporary solution, until we activate the
	  SMMU. Set the attributes for reading & writing data buffers
	  & descriptors to:
	 
	   - OuterShareable - Snoops will be performed on CPU caches
	   - Enable cacheable - Bufferable, Modifiable, Other Allocate
	     and Allocate
	 BW CTRL - set values to optimize the XOR performance:
	 
	   - Set WrBurstLen & RdBurstLen - the unit will issue
	     maximum of 256B writeread transactions.
	  -  Limit the number of outstanding write & read data
	     (OBBIBB) requests to the maximal value.
 Disable the AXI timer feature 
 enable the DMA engine 
 Set this bit to disable to stop the XOR unit. 
	
	  allocate coherent memory for hardware descriptors
	  note: writecombine gives slightly better performance, but
	  requires that we explicitly flush the writes
 alloc memory for the SW descriptors 
 init the free SW descriptors list 
 add all SW descriptors to the free list 
 set DMA capabilities 
 init dma link list 
 set base routines 
 SPDX-License-Identifier: GPL-2.0-only
  ACPI helpers for DMA request  controller
  Based on of-dma.c
  Copyright (C) 2013, Intel Corporation
  Authors: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
 	    Mika Westerberg <mika.westerberg@linux.intel.com>
  acpi_dma_parse_resource_group - match device and parse resource group
  @grp:	CSRT resource group
  @adev:	ACPI device to match with
  @adma:	struct acpi_dma of the given DMA controller
  In order to match a device from DSDT table to the corresponding CSRT device
  we use MMIO address and IRQ.
  Return:
  1 on success, 0 when no information is available, or appropriate errno value
  on error.
 Consider initial zero values as resource not found 
 Match device by MMIO 
	
	  acpi_gsi_to_irq() can't be used because some platforms do not save
	  registered IRQs in the MP table. Instead we just try to register
	  the GSI, which is the core part of the above mentioned function.
 Match device by Linux vIRQ 
 Check if the request line range is available 
 Set up DMA mask based on value from CSRT 
  acpi_dma_parse_csrt - parse CSRT to exctract additional DMA resources
  @adev:	ACPI device to match with
  @adma:	struct acpi_dma of the given DMA controller
  CSRT or Core System Resources Table is a proprietary ACPI table
  introduced by Microsoft. This table can contain devices that are not in
  the system DSDT table. In particular DMA controllers might be described
  here.
  We are using this table to get the request line range of the specific DMA
  controller to be used later.
  acpi_dma_controller_register - Register a DMA controller to ACPI DMA helpers
  @dev:		struct device of DMA controller
  @acpi_dma_xlate:	translation function which converts a dma specifier
 			into a dma_chan structure
  @data:		pointer to controller specific data to be used by
 			translation function
  Allocated memory should be freed with appropriate acpi_dma_controller_free()
  call.
  Return:
  0 on success or appropriate errno value on error.
 Check if the device was enumerated by ACPI 
 Now queue acpi_dma controller structure in list 
  acpi_dma_controller_free - Remove a DMA controller from ACPI DMA helpers list
  @dev:	struct device of DMA controller
  Memory allocated by acpi_dma_controller_register() is freed here.
  Return:
  0 on success or appropriate errno value on error.
  devm_acpi_dma_controller_register - resource managed acpi_dma_controller_register()
  @dev:		device that is registering this DMA controller
  @acpi_dma_xlate:	translation function
  @data:		pointer to controller specific data
  Managed acpi_dma_controller_register(). DMA controller registered by this
  function are automatically freed on driver detach. See
  acpi_dma_controller_register() for more information.
  Return:
  0 on success or appropriate errno value on error.
  devm_acpi_dma_controller_free - resource managed acpi_dma_controller_free()
  @dev:	device that is unregistering as DMA controller
  Unregister a DMA controller registered with
  devm_acpi_dma_controller_register(). Normally this function will not need to
  be called and the resource management code will ensure that the resource is
  freed.
  acpi_dma_update_dma_spec - prepare dma specifier to pass to translation function
  @adma:	struct acpi_dma of DMA controller
  @dma_spec:	dma specifier to update
  Accordingly to ACPI 5.0 Specification Table 6-170 "Fixed DMA Resource
  Descriptor":
 	DMA Request Line bits is a platform-relative number uniquely
 	identifying the request line assigned. Request line-to-Controller
 	mapping is done in a controller-specific OS driver.
  That's why we can safely adjust slave_id when the appropriate controller is
  found.
  Return:
  0, if no information is avaiable, -1 on mismatch, and 1 otherwise.
 Set link to the DMA controller device 
 Check if the request line range is available 
 Check if slave_id falls to the range 
	
	  Here we adjust slave_id. It should be a relative number to the base
	  request line.
  acpi_dma_parse_fixed_dma - Parse FixedDMA ACPI resources to a DMA specifier
  @res:	struct acpi_resource to get FixedDMA resources from
  @data:	pointer to a helper struct acpi_dma_parser_data
 Tell the ACPI core to skip this resource 
  acpi_dma_request_slave_chan_by_index - Get the DMA slave channel
  @dev:	struct device to get DMA request from
  @index:	index of FixedDMA descriptor for @dev
  Return:
  Pointer to appropriate dma channel on success or an error pointer.
 Initial values for the request line and channel 
		
		  We are not going to call translation function if slave_id
		  doesn't fall to the request range.
		
		  Try to get a channel only from the DMA controller that
		  matches the slave_id. See acpi_dma_update_dma_spec()
		  description for the details.
  acpi_dma_request_slave_chan_by_name - Get the DMA slave channel
  @dev:	struct device to get DMA request from
  @name:	represents corresponding FixedDMA descriptor for @dev
  In order to support both Device Tree and ACPI in a single driver we
  translate the names "tx" and "rx" here based on the most common case where
  the first FixedDMA descriptor is TX and second is RX.
  If the device has "dma-names" property the FixedDMA descriptor indices
  are retrieved based on those. Otherwise the function falls back using
  hardcoded indices.
  Return:
  Pointer to appropriate dma channel on success or an error pointer.
  acpi_dma_simple_xlate - Simple ACPI DMA engine translation helper
  @dma_spec: pointer to ACPI DMA specifier
  @adma: pointer to ACPI DMA controller data
  A simple translation function for ACPI based devices. Passes &struct
  dma_spec to the DMA controller driver provided filter function.
  Return:
  Pointer to the channel if found or %NULL otherwise.
 SPDX-License-Identifier: GPL-2.0-or-later
  Ingenic JZ4780 DMA controller
  Copyright (c) 2015 Imagination Technologies
  Author: Alex Smith <alex@alex-smith.me.uk>
 Global registers. 
 Per-channel registers. 
 macros for use with jz4780_dma_soc_data.flags 
  struct jz4780_dma_hwdesc - descriptor structure read by the DMA controller.
  @dcm: value for the DCM (channel command) register
  @dsa: source address
  @dta: target address
  @dtc: transfer count (number of blocks of the transfer size specified in DCM
  to transfer) in the low 24 bits, offset of the next descriptor from the
  descriptor base address in the upper 8 bits.
 Size of allocations for hardware descriptor blocks. 
	
	  8 byte transfer sizes unsupported so fall back on 4. If it's larger
	  than the maximum, just limit it. It is perfectly safe to fall back
	  in this way since we won't exceed the maximum burst size supported
	  by the device, the only effect is reduced efficiency. This is better
	  than refusing to perform the request at all.
	
	  This calculates the maximum transfer size that can be used with the
	  given address, length, width and maximum burst size. The address
	  must be aligned to the transfer size, the total length must be
	  divisible by the transfer size, and we must not use more than the
	  maximum burst specified by the user.
 Automatically proceeed to the next descriptor. 
			
			  The upper 8 bits of the DTC field in the descriptor
			  must be set to (offset from descriptor base of next
			  descriptor >> 4).
		
		  Set the link bit to indicate that the controller should
		  automatically proceed to the next descriptor. In
		  jz4780_dma_begin(), this will be cleared if we need to issue
		  an interrupt after each period.
		
		  The upper 8 bits of the DTC field in the descriptor must be
		  set to (offset from descriptor base of next descriptor >> 4).
		  If this is the last descriptor, link it back to the first,
		  i.e. leave offset set to 0, otherwise point to the next one.
			
			  The DMA controller doesn't support triggering an
			  interrupt after processing each descriptor, only
			  after processing an entire terminated list of
			  descriptors. For a cyclic DMA setup the list of
			  descriptors is not terminated so we can never get an
			  interrupt.
			 
			  If the user requested a callback for a cyclic DMA
			  setup then we workaround this hardware limitation
			  here by degrading to a set of unlinked descriptors
			  which we will submit in sequence in response to the
			  completion of processing the previous descriptor.
		
		  There is an existing transfer, therefore this must be one
		  for which we unlinked the descriptors above. Advance to the
		  next one in the list.
 Enable the channel's clock. 
 Use 4-word descriptors. 
 Set transfer type. 
	
	  Set the transfer count. This is redundant for a descriptor-driven
	  transfer. However, there can be a delay between the transfer start
	  time and when DTCn reg contains the new transfer count. Setting
	  it explicitly ensures residue is computed correctly at all times.
 Write descriptor address and initiate descriptor fetch. 
 Enable the channel. 
 Clear the DMA status and stop the transfer. 
 Copy the reset of the slave configuration, it is used later. 
 On the issued list, so hasn't been processed yet 
 False positive - continue the transfer 
 Clear halt and address error status of all channels. 
 Clear interrupt pending status. 
 Can only select a channel marked as reserved. 
		
		  On JZ4780, if the second memory resource was not supplied,
		  assume we're using an old devicetree, and calculate the
		  offset to the control registers.
 Property is optional, if it doesn't exist the value will remain 0. 
	
	  Enable DMA controller, mark all channels as not programmable.
	  Also set the FMSC bit - it increases MSC performance, so it makes
	  little sense not to enable it.
 Register with OF DMA helpers. 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2013-2014 Renesas Electronics Europe Ltd.
  Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
 Channel Current Transaction Byte register 
 Channel Status register 
 Channel Control register 
 Channel Configuration register 
 terminal SELect: 0..7 
 REQuest Direction: DMAREQ is 0: input, 1: output 
 LOw ENable: low DMA request line is: 0: inactive, 1: active 
 HIgh ENable: high DMA request line is: 0: inactive, 1: active 
 LeVeL: DMA request line is sensed as 0: edge, 1: level 
 ACK Mode: 0: Pulse mode, 1: Level mode, b'1x: Bus Cycle 
 Source Data Size: 0: 8 bits,... , 7: 1024 bits 
 Destination Data Size: as above 
 Source ADdress counting: 0: increment, 1: fixed 
 Destination ADdress counting: 0: increment, 1: fixed 
 Transfer Mode: 0: single, 1: block TM 
 DMAEND interrupt Mask 
 DMATCO interrupt Mask 
 Sweep Buffer Enable 
 RM: Register Set sELect 
 RM: Register Select sWitch 
 RM: Register Set Enable 
 0: register mode (RM), 1: link mode (LM) 
 Link Header field 
 0: fixed priority, 1: round robin 
 DMAEND and DMAERR signalling: 0: pulse, 1: level 
  We've got 3 types of objects, used to describe DMA transfers:
  1. high-level descriptor, containing a struct dma_async_tx_descriptor object
 	in it, used to communicate with the user
  2. hardware DMA link descriptors, that we pass to DMAC for DMA transfer
 	queuing, these must be DMAable, using either the streaming DMA API or
 	allocated from coherent memory - one per SG segment
  3. one per SG segment descriptors, used to manage HW link descriptors from
 	(2). They do not have to be DMAable. They can either be (a) allocated
 	together with link descriptors as mixed (DMA  CPU) objects, or (b)
 	separately. Even if allocated separately it would be best to link them
 	to link descriptors once during channel resource allocation and always
 	use them as a single object.
  Therefore for both cases (a) and (b) at run-time objects (2) and (3) shall be
  treated as a single SG segment descriptor.
  struct nbpf_desc - DMA transfer descriptor
  @async_tx:	dmaengine object
  @user_wait:	waiting for a user ack
  @length:	total transfer length
  @chan:	associated DMAC channel
  @sg:		list of hardware descriptors, represented by struct nbpf_link_desc
  @node:	member in channel descriptor lists
 Take a wild guess: allocate 4 segments per descriptor 
  struct nbpf_channel - one DMAC channel
  @dma_chan:	standard dmaengine channel object
  @tasklet:	channel specific tasklet used for callbacks
  @base:	register address base
  @nbpf:	DMAC
  @name:	IRQ name
  @irq:	IRQ number
  @slave_src_addr:	source address for slave DMA
  @slave_src_width:	source slave data size in bytes
  @slave_src_burst:	maximum source slave burst size in bytes
  @slave_dst_addr:	destination address for slave DMA
  @slave_dst_width:	destination slave data size in bytes
  @slave_dst_burst:	maximum destination slave burst size in bytes
  @terminal:	DMA terminal, assigned to this channel
  @dmarq_cfg:	DMA request line configuration - high  low, edge  level for NBPF_CHAN_CFG
  @flags:	configuration flags from DT
  @lock:	protect descriptor lists
  @free_links:	list of free link descriptors
  @free:	list of free descriptors
  @queued:	list of queued descriptors
  @active:	list of descriptors, scheduled for processing
  @done:	list of completed descriptors, waiting post-processing
  @desc_page:	list of additionally allocated descriptor pages - if any
  @running:	linked descriptor of running transaction
  @paused:	are translations on this channel paused?
  dmaengine drivers seem to have a lot in common and instead of sharing more
  code, they reimplement those common algorithms independently. In this driver
  we try to separate the hardware-specific part from the (largely) generic
  part. This improves code readability and makes it possible in the future to
  reuse the generic code in form of a helper library. That generic code should
  be suitable for various DMA controllers, using transfer descriptors in RAM
  and pushing one SG list at a time to the DMA controller.
		Hardware-specific part		
 Stop the channel, make sure DMA has been aborted 
 Software trigger MEMCPY - only MEMCPY uses the block mode 
 Don't output DMAACK 
	
	  We assume, that only the link mode and DMA request line configuration
	  have to be set in the configuration register manually. Dynamic
	  per-transfer configuration will be loaded from transfer descriptors.
 Maximum supported bursts depend on the buffer size 
  We need a way to recognise slaves, whose data is sent "raw" over the bus,
  i.e. it isn't known in advance how many bytes will be received. Therefore
  the slave driver has to provide a "large enough" buffer and either read the
  buffer, when it is full, or detect, that some data has arrived, then wait for
  a timeout, if no more data arrives - receive what's already there. We want to
  handle such slaves in a special way to allow an optimised mode for other
  users, for whom the amount of data is known in advance. So far there's no way
  to recognise such slaves. We use a data-width check to distinguish between
  the SD host and the PL011 UART.
	
	  set config: SAD, DAD, DDS, SDS, etc.
	  Note on transfer sizes: the DMAC can perform unaligned DMA transfers,
	  but it is important to have transaction size a multiple of both
	  receiver and transmitter transfer sizes. It is also possible to use
	  different RAM and device transfer sizes, and it does work well with
	  some devices, e.g. with V08R07S01E SD host controllers, which can use
	  128 byte transfers. But this doesn't work with other devices,
	  especially when the transaction size is unknown. This is the case,
	  e.g. with serial drivers like amba-pl011.c. For reception it sets up
	  the transaction size of 4K and if fewer bytes are received, it
	  pauses DMA and reads out data received via DMA as well as those left
	  in the Rx FIFO. For this to work with the RAM side using burst
	  transfers we enable the SBE bit and terminate the transfer in our
	  .device_pause handler.
		
		  Is the slave narrower than 64 bits, i.e. isn't using the full
		  bus width and cannot use bursts?
 Device-to-RAM DMA is unreliable without REQD set 
		Generic part			
 DMA ENGINE functions 
	
	  This function cannot be called from interrupt context, so, no need to
	  save flags
  We have to allocate descriptors with the channel lock dropped. This means,
  before we re-acquire the lock buffers can be taken already, so we have to
  re-check after re-acquiring the lock and possibly retry, if buffers are gone
  again.
 No more free descriptors 
 No more free link descriptors 
 See comment in nbpf_prep_one() 
	
	  We could check config->slave_id to match chan->terminal here,
	  but with DT they would be coming from the same source, so
	  such a check would be superflous
	
	  This is a private descriptor list, and we own the descriptor. No need
	  to lock.
 The user has to return the descriptor to us ASAP via .tx_submit() 
 Clean up for if a channel is re-used for MEMCPY after slave DMA 
 Newly completed descriptor, have to process 
				
				  This descriptor was waiting for a user ACK,
				  it can be recycled now.
 This can happen if TERMINATE_ALL has been called 
		
		  With released lock we cannot dereference desc, maybe it's
		  still on the "done" list
 ack and callback completed descriptor 
 On error: abort all queued transfers, no callback 
 Add the channel to DMA device channel list 
 maximum 8 channels + error IRQ ;
 DT only 
	
	  3 IRQ resource schemes are supported:
	  1. 1 shared IRQ for error and all channels
	  2. 2 IRQs: one for error and one shared for all channels
	  3. 1 IRQ for error and an own IRQ for each channel
 Skip the error IRQ 
 2 IRQs and more than one channel 
 Create DMA Channel 
 Common and MEMCPY operations 
	
	  If we drop support for unaligned MEMCPY buffer addresses and  or
	  lengths by setting
	  dma_dev->copy_align = 4;
	  then we can set transfer length to 4 bytes in nbpf_prep_one() for
	  DMA_MEM_TO_MEM
 Compulsory for DMA_SLAVE fields 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2013-2014 Allwinner Tech Co., Ltd
  Author: Sugar <shuge@allwinnertech.com>
  Copyright (C) 2014 Maxime Ripard
  Maxime Ripard <maxime.ripard@free-electrons.com>
  Common registers
 Offset between DMA_IRQ_EN and DMA_IRQ_STAT limits number of channels 
  sun8i specific registers
  Channels specific registers
  Various hardware related defines
 forward declaration 
  Hardware channels  ports representation
  The hardware is used in several SoCs, with differing numbers
  of channels and endpoints. This structure ties those numbers
  to a certain compatible string.
	
	  In the datasheetsuser manuals of newer Allwinner SoCs, a special
	  bit (bit 2 at register 0x20) is present.
	  It's named "DMA MCLK interface circuit auto gating bit" in the
	  documents, and the footnote of this register says that this bit
	  should be set up when initializing the DMA controller.
	  Allwinner A23A33 user manuals do not have this bit documented,
	  however these SoCs really have and need this bit, as seen in the
	  BSP kernel source code.
  Hardware representation of the LLI
  The hardware will be fed the physical address of this structure,
  and read its content in order to start the transfer.
	
	  This field is not used by the DMA controller, but will be
	  used by the CPU to go through the list (mostly for dumping
	  or freeing it).
				
				  No current txd associated with this channel
 Mark this channel free 
 Remove from pending channels 
 Mark this channel allocated 
 cyclic list 
 Disable all interrupts from DMA 
 Prevent spurious interrupts from scheduling the tasklet 
 Make sure we won't have any further interrupts 
 Actually prevent the tasklet from being scheduled 
  For A31:
  There's 16 physical channels that can work in parallel.
  However we have 30 different endpoints for our requests.
  Since the channels are able to handle only an unidirectional
  transfer, we need to allocate more virtual channels so that
  everyone can grab one channel.
  Some devices can't work in both direction (mostly because it
  wouldn't make sense), so we have a bit fewer virtual channels than
  2 channels per endpoints.
  The A23 only has 8 physical channels, a maximum DRQ port id of 24,
  and a total of 37 usable source and destination endpoints.
  The H3 has 12 physical channels, a maximum DRQ port id of 27,
  and a total of 34 usable source and destination endpoints.
  It also supports additional burst lengths and bus widths,
  and the burst length fields have different offsets.
  The A64 binding uses the number of dma channels from the
  device tree node.
  TODO: Add support for more than 4g physical addressing.
  The A100 binding uses the number of dma channels from the
  device tree node.
  The H6 binding uses the number of dma channels from the
  device tree node.
  The V3s have only 8 physical channels, a maximum DRQ port id of 23,
  and a total of 24 usable source and destination endpoints.
 sentinel  }
	
	  If the number of vchans is not specified, derive it from the
	  highest port number, at most one channel per port and direction.
 SPDX-License-Identifier: GPL-2.0-only
  SA11x0 DMAengine support
  Copyright (C) 2012 Russell King
    Derived in part from archarmmach-sa1100dma.c,
    Copyright (C) 2000, 2001 by Nicolas Pitre
 0 = W, 1 = R 
 0 = LE, 1 = BE 
 0 = BS4, 1 = BS8 
 0 = 8b, 1 = 16b 
 protected by c->vc.lock 
 protected by d->lock 
 Protected by c->vc.lock 
 Don't try to load the next transfer if both buffers are started 
			
			  We have reached the end of the current descriptor.
			  Peek at the next descriptor, and if compatible with
			  the current, start processing it.
 Cyclic: reset back to beginning 
 Select buffer to load according to channel status 
 Cyclic: reset back to beginning 
 Clear reported status bits 
		
		  Now that we're holding the lock, check that the vchan
		  really is associated with this pchan before touching the
		  hardware.  This should always succeed, because we won't
		  change p->vchan or c->phy while the channel is actively
		  transferring.
 If the issued list is empty, we have no further txds to process 
 The channel should not have any transfers started 
 Clear the run and start bits before changing DDAR 
 Try to start both buffers 
 No current txd associated with this channel 
 Mark this channel free 
 Mark this channel allocated 
	
	  If the cookie is on our issue queue, then the residue is
	  its total size.
  Move pending txds to the issued list, and re-init pending list.
  If not already pending, add this channel to the list of pending
  channels and trigger the tasklet to run.
 SA11x0 channels can only operate in their native direction 
 Do not allow zero-sized txds 
			
			  Check whether the transfer will fit.  If not, try
			  to split the transfer up such that we end up with
			  equal chunks - but make sure that we preserve the
			  alignment.  This avoids small segments.
 SA11x0 channels can only operate in their native direction 
 Do not allow zero-sized txds 
 Clear the tx descriptor lists 
 vchan is assigned to a pchan - stop the channel 
 SPDX-License-Identifier: GPL-2.0-only
  DMA driver for Nvidia's Tegra20 APB DMA controller.
  Copyright (c) 2012-2013, NVIDIA CORPORATION.  All rights reserved.
 CSR register 
 STATUS register 
 AHB memory address 
 AHB sequence register 
 APB address 
 APB sequence register 
 Tegra148 specific registers 
  If any burst is in flight and DMA paused then this is the time to complete
  on-flight burst and update DMA status register.
 Channel base address offset from APBDMA base address 
  tegra_dma_chip_data Tegra chip specific DMA data
  @nr_channels: Number of channels available in the controller.
  @channel_reg_size: Channel register sizestride.
  @max_dma_count: Maximum DMA transfer count supported by DMA controller.
  @support_channel_pause: Support channel wise pause of dma.
  @support_separate_wcount_reg: Support separate word count register.
 DMA channel registers 
  tegra_dma_sg_req: DMA request details to configure hardware. This
  contains the details for one transfer to configure DMA hw.
  The client's request for data transfer can be broken into multiple
  sub-transfer as per requester details and hw support.
  This sub transfer get added in the list of transfer and point to Tegra
  DMA descriptor which manages the transfer details.
  tegra_dma_desc: Tegra DMA descriptors which manages the client requests.
  This descriptor keep track of transfer status, callbacks and request
  counts etc.
 tegra_dma_channel: Channel specific information 
 Different lists for managing the requests 
 ISR handler and tasklet for bottom half of isr handling 
 Channel-slave specific configuration 
 tegra_dma: Tegra DMA specific information 
	
	  Counter for managing global pausing of the DMA controller.
	  Only applicable for devices that don't support individual
	  channel pausing.
 Last member of the structure 
 Get DMA desc from free list, if not there then allocate it.  
 Do not allocate if desc are waiting for ack 
 Allocate DMA desc 
 Disable interrupts 
 Disable DMA 
 Clear interrupt status if it is there 
 Start DMA 
	
	  The DMA controller reloads the new configuration for next transfer
	  after last burst of current transfer completes.
	  If there is no IEC status then this makes sure that last burst
	  has not be completed. There may be case that last burst is on
	  flight and so it can complete but because DMA is paused, it
	  will not generates interrupt as well as not reload the new
	  configuration.
	  If there is already IEC status then interrupt handler need to
	  load new configuration.
	
	  If interrupt is pending then do nothing as the ISR will handle
	  the programing for new request.
 Safe to program new configuration 
 Add in cb list if it is not there. 
	
	  Check that head req on list should be in flight.
	  If it is not in flight then abort transfer as
	  looping of transfer can not continue.
 Configure next request 
 Do not start DMA if it is going to be terminate 
 if we dma for long enough the transfer count will wrap 
 Callback need to be call 
 If not last req then put at end of pending list 
 Continuous single mode: Configure next req 
			
			  Wait for 1 burst time for configure DMA for
			  next transfer.
 Pause DMA before checking the queue status 
	
	  CPU, which handles interrupt, could be busy in
	  uninterruptible state, in this case sibling CPU
	  should wait until interrupt is handled.
		
		  If wcount wasn't ever polled for this SG before, then
		  simply assume that transfer hasn't started yet.
		 
		  Otherwise it's the end of the transfer.
		 
		  The alternative would be to poll the status register
		  until EOC bit is set or wcount goes UP. That's so
		  because EOC bit is getting set only after the last
		  burst's completion and counter is less than the actual
		  transfer size by 4 bytes. The counter value wraps around
		  in a cyclic mode before EOC is set(!), so we can't easily
		  distinguish start of transfer from its end.
		
		  This case will never happen for a non-cyclic transfer.
		 
		  For a cyclic transfer, although it is possible for the
		  next transfer to have already started (resetting the word
		  count), this case should still not happen because we should
		  have detected that the EOC bit is set and hence the transfer
		  was completed.
 Check on wait_ack desc status 
 Check in pending list 
	
	  burst_size from client is in terms of the bus_width.
	  convert them into AHB memory width which is 4 byte.
 If burst size is 0 then calculate the burst size based on length 
 Make transfer requests 
	
	  Make sure that mode should not be conflicting with currently
	  configured mode.
	
	  We allow to take more number of requests till DMA is
	  not started. The driver will loop over all requests.
	  Once DMA is started then new requests can be queued only after
	  terminating the DMA.
	
	  We only support cycle transfer when buf_len is multiple of
	  period_len.
 Split transfer equal to period size 
	
	  Make sure that mode should not be conflicting with currently
	  configured mode.
 Tegra20 specific DMA controller information 
 Tegra30 specific DMA controller information 
 Tegra114 specific DMA controller information 
 Tegra148 specific DMA controller information 
 reset DMA controller 
 enable global DMA registers 
 SPDX-License-Identifier: GPL-2.0-only
  timb_dma.c timberdale FPGA DMA driver
  Copyright (c) 2010 Intel Corporation
 Supports:
  Timberdale FPGA DMA engine
 Global DMA registers 
 Channel specific registers 
 RX instances base addresses are 0x00, 0x40, 0x80 ...
  TX instances base addresses are 0x18, 0x58, 0x98 ...
 RX registers, relative the instance base 
 bytes per Row, video specific register
  which is placed after the TX registers...
 TX registers, relative the instance base 
	spinlock_t		lock;  Used to protect data structures,
					especially the lists and descriptors,
					from races between the tasklet and calls
 Descriptors to allocate 
 number of elems per descriptor 
 Must be called with the spinlock held 
 enable interrupt for this channel 
 Should be called with the spinlock held 
 length must be word aligned 
 tran, valid 
 Must be called with the spinlock held 
 descriptor address 
 Bytes per line 
 enable RX 
 address high 
 can happen if the descriptor is canceled 
 make sure to stop the transfer 
 Currently no support for stopping DMA transfers
	else
		iowrite32(0, td_chan->membase + TIMBDMA_OFFS_TX_DLAR);
	
	  The API requires that no submissions are done from a
	  callback, so we don't need to drop the lock here
 check that all descriptors are free 
 transfer ongoing 
 even channels are for RX, odd for TX 
 first the easy part, put the queue into the free list 
 now tear down the running 
 ack the interrupts 
 disable interrupts, will be re-enabled in tasklet 
 32bit addressing 
 disable and clear any interrupts 
 even channels are RX, odd are TX 
 SPDX-License-Identifier: GPL-2.0-only
  Core driver for the Intel integrated DMA 64-bit
  Copyright (C) 2015 Intel Corporation
  Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
 For now we support only two channels 
 ---------------------------------------------------------------------- 
 ---------------------------------------------------------------------- 
 ---------------------------------------------------------------------- 
 Set default burst alignment 
 Enable interrupts 
	
	  Enforce the controller to be turned on.
	 
	  The iDMA is turned off in ->probe() and looses context during system
	  suspend  resume cycle. That's why we have to enable it each time we
	  use it.
 Get the next descriptor 
 Configure the channel 
 Start the channel with a new descriptor 
 ---------------------------------------------------------------------- 
 idma64_start_transfer() updates idma64c->desc 
 Check if we have any interrupt from the DMA controller 
 ---------------------------------------------------------------------- 
 DMA_DEV_TO_MEM 
 Fill the hardware descriptors and link them to a list 
 Trigger an interrupt after the last block is transfered 
 Disable LLP transfer in the last block 
 Allocate DMA capable memory for hardware descriptor 
 The current chunk is not fully transfered yet 
 Create a pool of consistent memory blocks for hardware descriptors 
 ---------------------------------------------------------------------- 
 Turn off iDMA controller 
	
	  Explicitly call devm_request_irq() to avoid the side effects with
	  the scheduled tasklets.
 ---------------------------------------------------------------------- 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for the Cirrus Logic EP93xx DMA Controller
  Copyright (C) 2011 Mika Westerberg
  DMA M2P implementation is based on the original
  archarmmach-ep93xxdma-m2p.c which has following copyrights:
    Copyright (C) 2006 Lennert Buytenhek <buytenh@wantstofly.org>
    Copyright (C) 2006 Applied Data Systems
    Copyright (C) 2009 Ryan Mallon <rmallon@gmail.com>
  This driver is based on dw_dmac and amba-pl08x drivers.
 M2P registers 
 M2M registers 
  struct ep93xx_dma_desc - EP93xx specific transaction descriptor
  @src_addr: source address of the transaction
  @dst_addr: destination address of the transaction
  @size: size of the transaction (in bytes)
  @complete: this descriptor is completed
  @txd: dmaengine API descriptor
  @tx_list: list of linked descriptors
  @node: link used for putting this into a channel queue
  struct ep93xx_dma_chan - an EP93xx DMA M2PM2M channel
  @chan: dmaengine API channel
  @edma: pointer to to the engine device
  @regs: memory mapped registers
  @irq: interrupt number of the channel
  @clk: clock used by this channel
  @tasklet: channel specific tasklet used for callbacks
  @lock: lock protecting the fields following
  @flags: flags for the channel
  @buffer: which buffer to use next (01)
  @active: flattened chain of descriptors currently being processed
  @queue: pending descriptors which are handled next
  @free_list: list of free descriptors which can be used
  @runtime_addr: physical address currently used as destsrc (M2M only). This
                 is set via .device_config before slave operation is
                 prepared
  @runtime_ctrl: M2M runtime values for the control register.
  @slave_config: slave configuration
  As EP93xx DMA controller doesn't support real chained DMA descriptors we
  will have slightly different scheme here: @active points to a head of
  flattened DMA descriptor chain.
  @queue holds pending transactions. These are linked through the first
  descriptor in the chain. When a descriptor is moved to the @active queue,
  the first and chained descriptors are flattened into a single list.
  @chan.private holds pointer to &struct ep93xx_dma_data which contains
  necessary channel configuration information. For memcpy channels this must
  be %NULL.
 protects the fields following 
 Channel is configured for cyclic transfers 
  struct ep93xx_dma_engine - the EP93xx DMA engine instance
  @dma_dev: holds the dmaengine device
  @m2m: is this an M2M or M2P device
  @hw_setup: method which sets the channel up for operation
  @hw_synchronize: synchronizes DMA channel termination to current context
  @hw_shutdown: shuts the channel down and flushes whatever is left
  @hw_submit: pushes active descriptor(s) to the hardware
  @hw_interrupt: handle the interrupt
  @num_channels: number of channels for this instance
  @channels: array of channels
  There is one instance of this struct for the M2P channels and one for the
  M2M channels. hw_xxx() methods are used to perform operations which are
  different on M2M and M2P channels. These methods are called with channel
  lock held and interrupts disabled so they cannot sleep.
  ep93xx_dma_set_active - set new active descriptor chain
  @edmac: channel
  @desc: head of the new active descriptor chain
  Sets @desc to be the head of the new active descriptor chain. This is the
  chain which is processed next. The active list must be empty before calling
  this function.
  Called with @edmac->lock held and interrupts disabled.
 Flatten the @desc->tx_list chain into @edmac->active list 
		
		  We copy the callback parameters from the first descriptor
		  to all the chained descriptors. This way we can call the
		  callback without having to find out the first descriptor in
		  the chain. Useful for cyclic transfers.
 Called with @edmac->lock held and interrupts disabled 
  ep93xx_dma_advance_active - advances to the next active descriptor
  @edmac: channel
  Function advances active descriptor to the next in the @edmac->active and
  returns %true if we still have descriptors in the chain to process.
  Otherwise returns %false.
  When the channel is in cyclic mode always returns %true.
  Called with @edmac->lock held and interrupts disabled.
	
	  If txd.cookie is set it means that we are back in the first
	  descriptor in the chain and hence done with it.
  M2P DMA implementation
	
	  EP93xx User's Guide states that we must perform a dummy read after
	  write to the control register.
 Clear the error interrupt 
		
		  It seems that there is no easy way of reporting errors back
		  to client so we just report the error here and continue as
		  usual.
		 
		  Revisit this when there is a mechanism to report back the
		  errors.
	
	  Even latest E2 silicon revision sometimes assert STALL interrupt
	  instead of NFB. Therefore we treat them equally, basing on the
	  amount of data we still have to transfer.
 Disable interrupts 
  M2M DMA implementation
 This is memcpy channel, nothing to configure 
		
		  This was found via experimenting - anything less than 5
		  causes the channel to perform only a partial transfer which
		  leads to problems since we don't get DONE interrupt then.
		
		  This IDE part is totally untested. Values below are taken
		  from the EP93xx Users's Guide and might not be correct.
 Worst case from the UG 
 Just disable the channel 
	
	  Since we allow clients to configure PW (peripheral width) we always
	  clear PW bits here and then set them according what is given in
	  the runtime configuration.
	
	  Now we can finally enable the channel. For M2M channel this must be
	  done _after_ the BCRx registers are programmed.
		
		  For memcpy channels the software trigger must be asserted
		  in order to start the memcpy operation.
  According to EP93xx User's Guide, we should receive DONE interrupt when all
  M2M DMA controller transactions complete normally. This is not always the
  case - sometimes EP93xx M2M DMA asserts DONE interrupt when the DMA channel
  is still running (channel Buffer FSM in DMA_BUF_ON state, and channel
  Control FSM in DMA_MEM_RD state, observed at least in IDE-DMA operation).
  In effect, disabling the channel when only DONE bit is set could stop
  currently running DMA transfer. To avoid this, we use Buffer FSM and
  Control FSM to check current state of DMA channel.
 Accept only DONE and NFB interrupts 
 Clear the DONE bit 
	
	  Check whether we are done with descriptors or not. This, together
	  with DMA channel state, determines action to take in interrupt.
	
	  Use M2M DMA Buffer FSM and Control FSM to check current state of
	  DMA channel. Using DONE and NFB bits from channel status register
	  or bits from channel interrupt register is not reliable.
		
		  Two buffers are ready for update when Buffer FSM is in
		  DMA_NO_BUF state. Only one buffer can be prepared without
		  disabling the channel or polling the DONE bit.
		  To simplify things, always prepare only one buffer.
 Software trigger for memcpy channel 
	
	  Disable the channel only when Buffer FSM is in DMA_NO_BUF state
	  and Control FSM is in DMA_STALL state.
 Disable interrupts and the channel 
	
	  Nothing to do this time.
  DMA engine API implementation
 Re-initialize the descriptor 
  ep93xx_dma_advance_work - start processing the next pending transaction
  @edmac: channel
  If we have pending transactions queued and we are currently idling, this
  function takes the next queued transaction from the @edmac->queue and
  pushes it to the hardware for execution.
 Take the next descriptor from the pending queue 
 Push it to the hardware 
	
	  If dma_terminate_all() was called before we get to run, the active
	  list has become empty. If that happens we aren't supposed to do
	  anything more than call ep93xx_dma_advance_work().
 mark descriptor complete for non cyclic case only 
 Pick up the next descriptor from the queue 
 Now we can release all the chained descriptors 
  ep93xx_dma_tx_submit - set the prepared descriptor(s) to be executed
  @tx: descriptor to be executed
  Function will execute given descriptor on the hardware or if the hardware
  is busy, queue the descriptor to be executed later on. Returns cookie which
  can be used to poll the status of the descriptor.
	
	  If nothing is currently prosessed, we push this descriptor
	  directly to the hardware. Otherwise we put the descriptor
	  to the pending queue.
  ep93xx_dma_alloc_chan_resources - allocate resources for the channel
  @chan: channel to allocate resources
  Function allocates necessary resources for the given DMA channel and
  returns number of allocated descriptors for the channel. Negative errno
  is returned in case of failure.
 Sanity check the channel parameters 
  ep93xx_dma_free_chan_resources - release resources for the channel
  @chan: channel
  Function releases all the resources allocated for the given channel.
  The channel must be idle when this is called.
  ep93xx_dma_prep_dma_memcpy - prepare a memcpy DMA operation
  @chan: channel
  @dest: destination bus address
  @src: source bus address
  @len: size of the transaction
  @flags: flags for the descriptor
  Returns a valid DMA descriptor or %NULL in case of failure.
  ep93xx_dma_prep_slave_sg - prepare a slave DMA operation
  @chan: channel
  @sgl: list of buffers to transfer
  @sg_len: number of entries in @sgl
  @dir: direction of tha DMA transfer
  @flags: flags for the descriptor
  @context: operation context (ignored)
  Returns a valid DMA descriptor or %NULL in case of failure.
  ep93xx_dma_prep_dma_cyclic - prepare a cyclic DMA operation
  @chan: channel
  @dma_addr: DMA mapped address of the buffer
  @buf_len: length of the buffer (in bytes)
  @period_len: length of a single period
  @dir: direction of the operation
  @flags: tx descriptor status flags
  Prepares a descriptor for cyclic DMA operation. This means that once the
  descriptor is submitted, we will be submitting in a @period_len sized
  buffers and calling callback once the period has been elapsed. Transfer
  terminates only when client calls dmaengine_terminate_all() for this
  channel.
  Returns a valid DMA descriptor or %NULL in case of failure.
 Split the buffer into period size chunks 
  ep93xx_dma_synchronize - Synchronizes the termination of transfers to the
  current context.
  @chan: channel
  Synchronizes the DMA channel termination to the current context. When this
  function returns it is guaranteed that all transfers for previously issued
  descriptors have stopped and and it is safe to free the memory associated
  with them. Furthermore it is guaranteed that all complete callback functions
  for a previously submitted descriptor have finished running and it is safe to
  free resources accessed from within the complete callbacks.
  ep93xx_dma_terminate_all - terminate all transactions
  @chan: channel
  Stops all DMA transactions. All descriptors are put back to the
  @edmac->free_list and callbacks are _not_ called.
 First we disable and flush the DMA channel 
	
	  We then re-enable the channel. This way we can continue submitting
	  the descriptors by just calling ->hw_submit() again.
  ep93xx_dma_tx_status - check if a transaction is completed
  @chan: channel
  @cookie: transaction specific cookie
  @state: state of the transaction is stored here if given
  This function can be used to query state of a given transaction.
  ep93xx_dma_issue_pending - push pending transactions to the hardware
  @chan: channel
  When this function is called, all pending transactions are pushed to the
  hardware and executed.
 SPDX-License-Identifier: GPL-2.0-only
  Device tree helpers for DMA request  controller
  Based on of_gpio.c
  Copyright (C) 2012 Texas Instruments Incorporated - http:www.ti.com
  of_dma_find_controller - Get a DMA controller in DT DMA helpers list
  @dma_spec:	pointer to DMA specifier as found in the device tree
  Finds a DMA controller with matching device node and number for dma cells
  in a list of registered DMA controllers. If a match is found a valid pointer
  to the DMA data stored is retuned. A NULL pointer is returned if no match is
  found.
  of_dma_router_xlate - translation function for router devices
  @dma_spec:	pointer to DMA specifier as found in the device tree
  @ofdma:	pointer to DMA controller data (router information)
  The function creates new dma_spec to be passed to the router driver's
  of_dma_route_allocate() function to prepare a dma_spec which will be used
  to request channel from the real DMA controller.
 translate the request for the real DMA controller 
	
	  Need to put the node back since the ofdma->of_dma_route_allocate
	  has taken it for generating the new, translated dma_spec
  of_dma_controller_register - Register a DMA controller to DT DMA helpers
  @np:			device node of DMA controller
  @of_dma_xlate:	translation function which converts a phandle
 			arguments list into a dma_chan structure
  @data:		pointer to controller specific data to be used by
 			translation function
  Returns 0 on success or appropriate errno value on error.
  Allocated memory should be freed with appropriate of_dma_controller_free()
  call.
 Now queue of_dma controller structure in list 
  of_dma_controller_free - Remove a DMA controller from DT DMA helpers list
  @np:		device node of DMA controller
  Memory allocated by of_dma_controller_register() is freed here.
  of_dma_router_register - Register a DMA router to DT DMA helpers as a
 			    controller
  @np:				device node of DMA router
  @of_dma_route_allocate:	setup function for the router which need to
 				modify the dma_spec for the DMA controller to
 				use and to set up the requested route.
  @dma_router:			pointer to dma_router structure to be used when
 				the route need to be free up.
  Returns 0 on success or appropriate errno value on error.
  Allocated memory should be freed with appropriate of_dma_controller_free()
  call.
 Now queue of_dma controller structure in list 
  of_dma_match_channel - Check if a DMA specifier matches name
  @np:		device node to look for DMA channels
  @name:	channel name to be matched
  @index:	index of DMA specifier in list of DMA specifiers
  @dma_spec:	pointer to DMA specifier as found in the device tree
  Check if the DMA specifier pointed to by the index in a list of DMA
  specifiers, matches the name provided. Returns 0 if the name matches and
  a valid pointer to the DMA specifier is found. Otherwise returns -ENODEV.
  of_dma_request_slave_channel - Get the DMA slave channel
  @np:		device node to get DMA request from
  @name:	name of desired channel
  Returns pointer to appropriate DMA channel on success or an error pointer.
 Silently fail if there is not even the "dmas" property 
	
	  approximate an average distribution across multiple
	  entries with the same name
  of_dma_simple_xlate - Simple DMA engine translation function
  @dma_spec:	pointer to DMA specifier as found in the device tree
  @ofdma:	pointer to DMA controller data
  A simple translation function for devices that use a 32-bit value for the
  filter_param when calling the DMA engine dma_request_channel() function.
  Note that this translation function requires that #dma-cells is equal to 1
  and the argument of the dma specifier is the 32-bit filter_param. Returns
  pointer to appropriate dma channel on success or NULL on error.
  of_dma_xlate_by_chan_id - Translate dt property to DMA channel by channel id
  @dma_spec:	pointer to DMA specifier as found in the device tree
  @ofdma:	pointer to DMA controller data
  This function can be used as the of xlate callback for DMA driver which wants
  to match the channel based on the channel id. When using this xlate function
  the #dma-cells propety of the DMA controller dt node needs to be set to 1.
  The data parameter of of_dma_controller_register must be a pointer to the
  dma_device struct the function should match upon.
  Returns pointer to appropriate dma channel on success or NULL on error.
 SPDX-License-Identifier: GPL-2.0+
 driversdmaimx-dma.c
 This file contains a driver for the Freescale i.MX DMA engine
 found on i.MX12127
 Copyright 2010 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
 Copyright 2012 Javier Martin, Vista Silicon <javier.martin@vista-silicon.com>
 Control Register 
 Interrupt status Register 
 Interrupt mask Register 
 Burst timeout status Register 
 Request timeout Register 
 Transfer Error Status Register 
 Buffer overflow status Register 
 Burst timeout control Register 
 W-Size Register A 
 X-Size Register A 
 Y-Size Register A 
 W-Size Register B 
 X-Size Register B 
 Y-Size Register B 
 Source Address Registers 
 Destination Address Registers 
 Count Registers 
 Control Registers 
 Request source select Registers 
 Burst length Registers 
 Request timeout Registers 
 Bus Utilization Registers 
 Channel counter Registers 
 For memcpy and interleaved 
 For interleaved transfers 
 For slave sg and cyclic 
 sentinel 
  imxdma_sg_next - prepare next chunk for scatter-gather DMA emulation
 Tasklet watchdog error handler 
 Tasklet error handler 
				 FIXME: The timeout should probably be
				  configurable
 Tasklet progression 
 Tasklet irq 
 Configure and enable 
 Try to get a free 2D slot 
		
		  We fall-through here intentionally, since a 2D transfer is
		  similar to MEMCPY just adding the 2D slot configuration.
 Cyclic transfer is the same as slave_sg with special sg configuration. 
 Someone might have called terminate all 
	 If we are dealing with a cyclic descriptor, keep it on ld_active
	  and dont mark the descriptor as complete.
	  Only in non-cyclic cases it would be marked as complete
 Free 2D slot if it was an interleaved transfer 
 Set burst length 
 txd.flags will be overwritten in prep funcs 
 close the loop 
 reset DMA module 
 enable DMA module 
 clear all interrupts 
 disable interrupts 
 Initialize 2D global parameters 
 Initialize channel parameters 
 Add the channel to the DMAC list 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013 - 2015 Linaro Ltd.
  Copyright (c) 2013 HiSilicon Limited.
 set same priority 
 unmask irq 
 mask irq 
 Avoid losing track of  ds_run if a transaction is in flight 
		
		  fetch and remove request from vc->desc_issued
		  so vc->desc_issued only contains desc pending
 start dma 
 check new dma request of running channel in vc->desc_issued 
 No current txd associated with this channel 
 Mark this channel free 
 check new channel request in d->chan_pending 
 remove from d->chan_pending 
 Mark this channel allocated 
	
	  If the cookie is on our issue queue, then the residue is
	  its total size.
 end of lli 
 add request to vc->desc_issued 
 if new channel, add chan_pending 
 check in tasklet 
 default is memtomem, without calling device_config 
 burst = 16 
 width = 64 bit 
 end of link 
 end of link 
 descriptor asks for TC2 interrupt on completion 
 "Cyclic" == end of link points back to start of link 
 specific request line 
 Prevent this channel being scheduled 
 Clear the tx descriptor lists 
 vchan is assigned to a pchan - stop the channel 
 A DMA memory pool for LLIs, align on 32-byte boundary 
 init phy channel 
 init virtual channel 
 Enable clock before accessing registers 
 SPDX-License-Identifier: GPL-2.0
 Copyright 2011 Freescale Semiconductor, Inc. All Rights Reserved.
 Refer to driversdmaimx-sdma.c
  NOTE: The term "PIO" throughout the mxs-dma implementation means
  PIO mode of mxs apbh-dma and apbx-dma.  With this working mode,
  dma can program the controller registers of peripheral devices.
  The offset of NXTCMDAR register is different per both dma type and version,
  while stride for each channel is all the same 0x70.
  ccw bits definitions
  COMMAND:		0..1	(2)
  CHAIN:		2	(1)
  IRQ:			3	(1)
  NAND_LOCK:		4	(1) - not implemented
  NAND_WAIT4READY:	5	(1) - not implemented
  DEC_SEM:		6	(1)
  WAIT4END:		7	(1)
  HALT_ON_TERMINATE:	8	(1)
  TERMINATE_FLUSH:	9	(1)
  RESERVED:		10..11	(2)
  PIO_NUM:		12..15	(4)
 not implemented 
 sentinel  }
	
	  mxs dma channel resets can cause a channel stall. To recover from a
	  channel stall, we have to reset the whole DMA engine. To avoid this,
	  we use cyclic DMA with semaphores, that are enhanced in
	  mxs_dma_int_handler. To reset the channel, we can simply stop writing
	  into the semaphore counter.
 50ms 
		
		  On i.MX28 APBX, the DMA channel can stop working if we reset
		  the channel while it is in READ_FLUSH (0x08) state.
		  We wait here until we leave the state. Then we trigger the
		  reset. Waiting a maximum of 50ms, the kernel shouldn't crash
		  because of this.
 set cmd_addr up 
 write 1 to SEMA to kick off the channel 
		 A cyclic DMA consists of at least 2 segments, so initialize
		  the semaphore with 2 so we have enough time to add 1 to the
 freeze the channel 
 unfreeze the channel 
 completion status 
 Clear interrupt 
 error status 
	
	  error status bit is in the upper 16 bits, error irq bit in the lower
	  16 bits. We transform it into a simpler error code:
	  err: 0x00 = no error, 0x01 = TERMINATION, 0x02 = BUS_ERROR
 Clear error irq 
	
	  When both completion and error of termination bits set at the
	  same time, we do not take it as an error.  IOW, it only becomes
	  an error we need to handle here in case of either it's a bus
	  error or a termination error with no completion. 0x01 is termination
	  error, so we can subtract err & completed to get the real error case.
 schedule tasklet on this channel 
 the descriptor is ready 
  How to use the flags for ->device_prep_slave_sg() :
     [1] If there is only one DMA command in the DMA chain, the code should be:
             ......
             ->device_prep_slave_sg(DMA_CTRL_ACK);
             ......
     [2] If there are two DMA commands in the DMA chain, the code should be
             ......
             ->device_prep_slave_sg(0);
             ......
             ->device_prep_slave_sg(DMA_CTRL_ACK);
             ......
     [3] If there are more than two DMA commands in the DMA chain, the code
         should be:
             ......
             ->device_prep_slave_sg(0);                                 First
             ......
             ->device_prep_slave_sg(DMA_CTRL_ACK]);
             ......
             ->device_prep_slave_sg(DMA_CTRL_ACK);  Last
             ......
	
	  If the sg is prepared with append flag set, the sg
	  will be appended to the last prepared sg.
 enable apbh burst 
 enable irq for all the channels 
 Initialize channel parameters 
 Add the channel to mxs_chan list 
 mxs_dma gets 65535 bytes maximum sg size 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) STMicroelectronics SA 2017
  Author(s): M'boumba Cedric Madianga <cedric.madianga@gmail.com>
             Pierre-Yves Mordret <pierre-yves.mordret@st.com>
  DMA Router driver for STM32 DMA MUX
  Based on TI DMA Crossbar driver
 Number of DMA requests connected to DMAMUX 
 Number of DMA requests routed toward DMAs 
 Protects register access 
 Used DMA channel 
	u32 ccr[STM32_DMAMUX_MAX_DMA_REQUESTS];  Used to backup CCR register
						  in suspend
	u32 dma_reqs[];  Number of DMA Request per DMA masters.
			   [0] holds number of DMA Masters.
			   To be kept at very end end of this structure
 Clear dma request 
 Look for DMA Master 
 The of_node_put() will be done in of_dma_router_xlate function 
 Set dma request 
  craft DMA spec 
 Reset the dmamux 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) STMicroelectronics SA 2017
  Author(s): M'boumba Cedric Madianga <cedric.madianga@gmail.com>
             Pierre-Yves Mordret <pierre-yves.mordret@st.com>
  Driver for STM32 MDMA controller
  Inspired by stm32-dma.c and dma-jz4780.c
  MDMA Generic gettersetter 
 MDMA Int Status Reg 1 
 MDMA Int Status Reg 2 
 MDMA Channel x interruptstatus register 
 x = 0..62 
 MDMA Channel x interrupt flag clear register 
 MDMA Channel x error status register 
 MDMA Channel x control register 
 MDMA Channel x transfer configuration register 
 MDMA Channel x block number of data register 
 MDMA Channel x source address register 
 MDMA Channel x destination address register 
 MDMA Channel x block repeat address update register 
 MDMA Channel x link address register 
 MDMA Channel x trigger and bus selection register 
 MDMA Channel x mask address register 
 MDMA Channel x mask data register 
		
		  Address and buffer length both have to be aligned on
		  bus width
 Disable interrupts 
 Ensure that any ongoing transfer has been completed 
 Disable DMA 
 Clear interrupt status if it is there 
 Check if memory device is on AHB or AXI 
 Enable HW request mode 
 Set DINC, SINC, DINCOS, SINCOS, TRGM and TLEN retrieve from DT 
	
	  For buffer transfer length (TLEN) we have to set
	  the number of bytes - 1 in CTCR register
 Disable Pack Enable 
 Check burst size constraints 
	
	  Configure channel control:
	  - Clear SW request as in this case this is a HW one
	  - Clear WEX, HEX and BEX bits
	  - Set priority level
 Configure Trigger selection 
 Set device data size 
 Set device burst value 
 Set memory data size 
 Set memory burst value 
 Select bus 
 Set destination address 
 Set device data size 
 Set device burst value 
 Set memory data size 
 Set memory burst value 
 Select bus 
 Set source address 
 Enable interrupts 
	
	  Once DMA is in setup cyclic mode the channel we cannot assign this
	  channel anymore. The DMA channel needs to be aborted or terminated
	  for allowing another request.
	
	  Once DMA is in setup cyclic mode the channel we cannot assign this
	  channel anymore. The DMA channel needs to be aborted or terminated
	  for allowing another request.
 Select bus 
 Enable interrupts 
 Configure hwdesc list 
	
	  Once DMA is in setup cyclic mode the channel we cannot assign this
	  channel anymore. The DMA channel needs to be aborted or terminated
	  to allow another request
 Enable sw req, some interrupts and clear other bits 
 Enable SW request mode, destsrc inc and clear other bits 
 Reset HW request 
 Select bus 
 Clear CBNDTR registers 
 Setup a buffer transfer 
 Setup a block transfer 
 Set source best burst size 
 Set destination best burst size 
 Prepare hardware descriptor 
 Setup a LLI transfer 
 Set source best burst size 
 Set destination best burst size 
 Prepare hardware descriptor 
 Clear interrupt status if it is there 
 Start DMA 
 Set SW request in case of MEM2MEM transfer 
 Re-configure control register 
 Clear interrupt status if it is there 
 Re-start DMA 
 Set SW request in case of MEM2MEM transfer 
 Start the next transfer if this driver has a next desc 
 Find out which channel generates the interrupt 
		
		  As GISR0 provides status for channel id from 0 to 31,
		  so GISR1 provides status for channel id from 32 to 62
 Handle interrupt for the channel 
 Mask Channel ReQuest Active bit which can be set in case of MEM2MEM 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2006 ARM Ltd.
  Copyright (c) 2010 ST-Ericsson SA
  Copyirght (c) 2017 Linaro Ltd.
  Author: Peter Pearse <peter.pearse@arm.com>
  Author: Linus Walleij <linus.walleij@linaro.org>
  Documentation: ARM DDI 0196G == PL080
  Documentation: ARM DDI 0218E == PL081
  Documentation: S3C6410 User's Manual == PL080S
  PL080 & PL081 both have 16 sets of DMA signals that can be routed to any
  channel.
  The PL080 has 8 channels available for simultaneous use, and the PL081
  has only two channels. So on these DMA controllers the number of channels
  and the number of incoming DMA signals are two totally different things.
  It is usually not possible to theoretically handle all physical signals,
  so a multiplexing scheme with possible denial of use is necessary.
  The PL080 has a dual bus master, PL081 has a single master.
  PL080S is a version modified by Samsung and used in S3C64xx SoCs.
  It differs in following aspects:
  - CH_CONFIG register at different offset,
  - separate CH_CONTROL2 register for transfer size,
  - bigger maximum transfer size,
  - 8-word aligned LLI, instead of 4-word, due to extra CCTL2 word,
  - no support for peripheral flow control.
  Memory to peripheral transfer may be visualized as
 	Get data from memory to DMAC
 	Until no data left
 		On burst request from peripheral
 			Destination burst from DMAC to peripheral
 			Clear burst request
 	Raise terminal count interrupt
  For peripherals with a FIFO:
  Source      burst size == half the depth of the peripheral FIFO
  Destination burst size == the depth of the peripheral FIFO
  (Bursts are irrelevant for mem to mem transfers - there are no burst
  signals, the DMA controller will simply facilitate its AHB master.)
  ASSUMES default (little) endianness for DMA transfers
  The PL08x has two flow control settings:
   - DMAC flow control: the transfer size defines the number of transfers
     which occur for the current LLI entry, and the DMAC raises TC at the
     end of every LLI entry.  Observed behaviour shows the DMAC listening
     to both the BREQ and SREQ signals (contrary to documented),
     transferring data if either is active.  The LBREQ and LSREQ signals
     are ignored.
   - Peripheral flow control: the transfer size is ignored (and should be
     zero).  The data is transferred from the current LLI entry, until
     after the final transfer signalled by LBREQ or LSREQ.  The DMAC
     will then move to the next LLI entry. Unsupported by PL080S.
  struct vendor_data - vendor-specific config parameters for PL08x derivatives
  @config_offset: offset to the configuration register
  @channels: the number of channels available in this variant
  @signals: the number of request signals available from the hardware
  @dualmaster: whether this version supports dual AHB masters or not.
  @nomadik: whether this variant is a ST Microelectronics Nomadik, where the
 	channels have Nomadik security extension bits that need to be checked
 	for permission before use and some registers are missing
  @pl080s: whether this variant is a Samsung PL080S, which has separate
 	register and LLI word for transfer size.
  @ftdmac020: whether this variant is a Faraday Technology FTDMAC020
  @max_transfer_size: the maximum single element transfer size for this
 	PL08x variant.
  struct pl08x_bus_data - information of source or destination
  busses for a transfer
  @addr: current address
  @maxwidth: the maximum width of a transfer on this bus
  @buswidth: the width of this bus in bytes: 1, 2 or 4
  struct pl08x_phy_chan - holder for the physical channels
  @id: physical index to this channel
  @base: memory base address for this physical channel
  @reg_config: configuration address for this physical channel
  @reg_control: control address for this physical channel
  @reg_src: transfer source address register
  @reg_dst: transfer destination address register
  @reg_lli: transfer LLI address register
  @reg_busy: if the variant has a special per-channel busy register,
  this contains a pointer to it
  @lock: a lock to use when altering an instance of this struct
  @serving: the virtual channel currently being served by this physical
  channel
  @locked: channel unavailable for the system, e.g. dedicated to secure
  world
  @ftdmac020: channel is on a FTDMAC020
  @pl080s: channel is on a PL08s
  struct pl08x_sg - structure containing data per sg
  @src_addr: src address of sg
  @dst_addr: dst address of sg
  @len: transfer len in bytes
  @node: node for txd's dsg_list
  struct pl08x_txd - wrapper for struct dma_async_tx_descriptor
  @vd: virtual DMA descriptor
  @dsg_list: list of children sg's
  @llis_bus: DMA memory address (physical) start for the LLIs
  @llis_va: virtual memory address start for the LLIs
  @cctl: control reg values for current txd
  @ccfg: config reg values for current txd
  @done: this marks completed descriptors, which should not have their
    mux released.
  @cyclic: indicate cyclic transfers
 Default cctl value for LLIs 
	
	  Settings to be put into the physical channel when we
	  trigger this txd.  Other registers are in llis_va[0].
  enum pl08x_dma_chan_state - holds the PL08x specific virtual channel
  states
  @PL08X_CHAN_IDLE: the channel is idle
  @PL08X_CHAN_RUNNING: the channel has allocated a physical transport
  channel and is running a transfer on it
  @PL08X_CHAN_PAUSED: the channel has allocated a physical transport
  channel, but the transfer is currently paused
  @PL08X_CHAN_WAITING: the channel is waiting for a physical transport
  channel to become available (only pertains to memcpy channels)
  struct pl08x_dma_chan - this structure wraps a DMA ENGINE channel
  @vc: wrappped virtual channel
  @phychan: the physical channel utilized by this channel, if there is one
  @name: name of channel
  @cd: channel platform data
  @cfg: slave configuration
  @at: active transaction on this channel
  @host: a pointer to the host (internal use)
  @state: whether the channel is idle, paused, running etc
  @slave: whether this channel is a device (slave) or for memcpy
  @signal: the physical DMA request signal which this channel is using
  @mux_use: count of descriptors using this DMA request signal setting
  @waiting_at: time in jiffies when this channel moved to waiting state
  struct pl08x_driver_data - the local state holder for the PL08x
  @slave: optional slave engine for this instance
  @memcpy: memcpy engine for this instance
  @has_slave: the PL08x has a slave engine (routed signals)
  @base: virtual memory base (remapped) for the PL08x
  @adev: the corresponding AMBA (PrimeCell) bus entry
  @vd: vendor data for this PL08x variant
  @pd: platform data passed in from the platformmachine
  @phy_chans: array of data for the physical channels
  @pool: a pool for the LLI descriptors
  @lli_buses: bitmask to or in to LLI pointer selecting AHB port for LLI
  fetches
  @mem_buses: set to indicate memory transfers on AHB2.
  @lli_words: how many words are used in each LLI item for this variant
  PL08X specific defines
 The order of words in an LLI. 
 Total words in an LLI. 
  Number of LLIs in each LLI buffer allocated for one transfer
  (maximum times we call dma_pool_alloc on this pool without freeing)
  Mux handling.
  This gives us the DMA request input to the PL08x primecell which the
  peripheral described by the channel data will be routed to, possibly
  via a boardSoC specific external MUX.  One important point to note
  here is that this does not depend on the physical channel.
  Physical channel handling
 Whether a certain channel is busy or not 
 If we have a special busy register, take a shortcut 
  pl08x_write_lli() - Write an LLI into the DMA controller.
  The PL08x derivatives support linked lists, but the first item of the
  list containing the source, destination, control word and next LLI is
  ignored. Instead the driver has to write those values directly into the
  SRC, DST, LLI and control registers. On FTDMAC020 also the SIZE
  register need to be set up for the first transfer.
	
	  The FTMAC020 has a different layout in the CCTL word of the LLI
	  and the CCTL register which is split in CSR and SIZE registers.
	  Convert the LLI item CCTL into the proper values to write into
	  the CSR and SIZE registers.
 Write the transfer size (12 bits) to the size register 
		
		  Then write the control bits 28..16 to the control register
		  by shuffleing the bits around to where they are in the
		  main register. The mapping is as follows:
		  Bit 28: TC_MSK - mask on all except last LLI
		  Bit 27..25: SRC_WIDTH
		  Bit 24..22: DST_WIDTH
		  Bit 21..20: SRCAD_CTRL
		  Bit 19..17: DSTAD_CTRL
		  Bit 17: SRC_SEL
		  Bit 16: DST_SEL
		
		  Set up the bits that exist in the CSR but are not
		  part the LLI, i.e. only gets written to the control
		  register right here.
		 
		  FIXME: do not just handle memcpy, also handle slave DMA.
 Protection flags 
 We are the kernel, so we are in privileged mode 
 Bits are just identical 
 Second control word on the PL080s 
  Set the initial DMA register values i.e. those for the first LLI
  The next LLI pointer and the configuration interrupt bit have
  been set when the LLIs were constructed.  Poke them into the hardware
  and start the transfer.
 Wait for channel inactive 
 Enable the DMA channel 
 Do not access config register until channel shows as disabled 
 Do not access config register until channel shows as inactive 
  Pause the channel by setting the HALT bit.
  For M->P transfers, pause the DMAC first and then stop the peripheral -
  the FIFO can only drain if the peripheral is still requesting data.
  (note: this can still timeout if the DMAC FIFO never drains of data.)
  For P->M transfers, disable the peripheral first to stop it filling
  the DMAC FIFO, and then pause the DMAC.
 Use the enable bit on the FTDMAC020 
 Set the HALT bit and wait for the FIFO to drain 
 Wait for channel inactive 
 Use the enable bit on the FTDMAC020 
 Clear the HALT bit 
  pl08x_terminate_phy_chan() stops the channel, clears the FIFO and
  clears any pending interrupt status.  This should not be used for
  an on-going transfer, but as a method of shutting down a channel
  (eg, when it's no longer used) or terminating a transfer.
 The layout for the FTDMAC020 is different 
 Disable all interrupts 
 Abort and disable channel 
 Clear ABT and ERR interrupt flags 
 Plain PL08x 
 Plain PL08x 
 The channel should be paused when calling this 
	
	  Follow the LLIs to get the number of remaining
	  bytes in the currently active transaction.
 First get the remaining bytes in the active transfer 
	
	  Locate the next LLI - as this is an array,
	  it's simple maths to find.
		
		  A LLI pointer going backward terminates the LLI list
  Allocate a physical channel for a virtual channel
  Try to locate a physical channel to be used for this transfer. If all
  are taken return NULL and the requester will have to cope by using
  some fallback PIO mode or retrying later.
 No physical channel available, cope with it 
 Mark the physical channel as free.  Note, this write is atomic. 
  Try to allocate a physical channel.  When successful, assign it to
  this virtual channel, and initiate the next descriptor.  The
  virtual channel lock must be held at this point.
	
	  We do this without taking the lock; we're really only concerned
	  about whether this pointer is NULL or not, and we're guaranteed
	  that this will only be called when it _already_ is non-NULL.
  Free a physical DMA channel, potentially reallocating it to another
  virtual channel if we have any pending.
	
	  Find a waiting virtual channel for the next transfer.
	  To be fair, time when each channel reached waiting state is compared
	  to select channel that is waiting for the longest time.
 Ensure that the physical channel is stopped 
		
		  Eww.  We know this isn't going to deadlock
		  but lockdep probably doesn't.
 Re-check the state now that we have the lock 
 If the state changed, try to find another channel 
 No more jobs, so free up the physical channel 
  LLI handling
	
	  Remove all src, dst and transfer size bits, then set the
	  width and size according to the parameters. The bit offsets
	  are different in the FTDMAC020 so we need to accound for this.
  Autoselect a master bus to use for the transfer. Slave will be the chosen as
  victim in case src & dest are not similarly aligned. i.e. If after aligning
  masters address with width requirements of transfer (by sending few byte by
  byte data), slave is still not aligned, then its width will be reduced to
  BYTE.
  - prefers the destination bus if both available
  - prefers bus with fixed address (i.e. peripheral)
	
	  The FTDMAC020 only supports memory-to-memory transfer, so
	  source and destination always increase.
	
	  If either bus is not advancing, i.e. it is a peripheral, that
	  one becomes master
  Fills in one LLI for a certain transfer descriptor and advance the counter
 Advance the offset to next LLI. 
 FIXME: only memcpy so far so both increase 
  This fills in the table of LLIs for the transfer descriptor
  Note that we assume we never have to change the burst sizes
  Return 0 for error
 Find maximum width of the source bus 
 Find maximum width of the destination bus 
		
		  Zero length is only allowed if all these requirements are
		  met:
		  - flow controller is peripheral.
		  - src.addr is aligned to src.width
		  - dst.addr is aligned to dst.width
		 
		  sg_len == 1 should be true, as there can be two cases here:
		 
		  - Memory addresses are contiguous and are not scattered.
		    Here, Only one sg will be passed by user driver, with
		    memory address and zero length. We pass this to controller
		    and after the transfer it will receive the last burst
		    request from peripheral and so transfer finishes.
		 
		  - Memory addresses are scattered and are not contiguous.
		    Here, Obviously as DMA controller doesn't know when a lli's
		    transfer gets over, it can't load next lli. So in this
		    case, there has to be an assumption that only one lli is
		    supported. Thus, we can't have scattered addresses.
 FTDMAC020 only does memory-to-memory 
		
		  Send byte by byte for following cases
		  - Less than a bus width available
		  - until master bus is aligned
			
			  Master now aligned
			  - if slave is not then we must set its width down
			
			  Bytes transferred = tsize  src width, not
			  MIN(buswidths)
			
			  Make largest possible LLIs until less than one bus
			  width left
				
				  If enough left try to send max possible,
				  otherwise try to send the remainder
				
				  Check against maximum bus alignment:
				  Calculate actual transfer size in relation to
				  bus width an get a maximum remainder of the
				  highest bus width - 1
			
			  Send any odd bytes
 Link back to the first LLI. 
 The final LLI terminates the LLI. 
 The final LLI element shall also fire an interrupt. 
  The DMA ENGINE API
 Ensure all queued descriptors are freed 
  Code accessing dma_async_is_complete() in a tight loop may give problems.
  If slaves are relying on interrupts to signal completion this function
  must not be called with interrupts disabled.
	
	  There's no point calculating the residue if there's
	  no txstate to store the value.
 On the issued list, so hasn't been processed yet 
	
	  This cookie not complete yet
	  Get number of bytes left in the active transactions and queue
 Whether waiting or running, we're in progress 
 PrimeCell DMA extension 
  Given the source and destination available bus masks, select which
  will be routed to each port.  We try to have source and destination
  on separate ports, but always respect the allowable settings.
 The FTDMAC020 use different bits to indicate srcdst bus 
 Access the cell in privileged mode, non-bufferable, non-cacheable 
	
	  If this channel will only request single transfers, set this
	  down to ONE element.  Also select one element if no maxburst
	  is specified.
  Slave transactions callback to the slave device to allow
  synchronization of slave DMA signals with the DMAC enable
 Conjure cctl 
 Protection flags 
 We are the kernel, so we are in privileged mode 
 Both to be incremented or the code will break 
 Conjure cctl 
	
	  By default mask the TC IRQ on all LLIs, it will be unmasked on
	  the last LLI item by other code.
	
	  Both to be incremented so leave bits FTDMAC020_LLI_SRCAD_CTL
	  and FTDMAC020_LLI_DSTAD_CTL as zero
  Initialize a descriptor to be used by memcpy submit
 Writing CCFG zero ENABLES all interrupts 
	
	  Set up addresses, the PrimeCell configured address
	  will take precedence since this may configure the
	  channel target address dynamically at runtime.
 Assign the flow control signal to this channel 
 Reject definitely invalid configurations 
		
		  Mark physical channel as free and free any slave
		  signal
 Dequeue jobs and free LLIs 
 Dequeue jobs not yet fired as well 
	
	  Anything succeeds on channels with no physical allocation and
	  no queued transfers.
	
	  Anything succeeds on channels with no physical allocation and
	  no queued transfers.
 Reject channels for devices not bound to this driver 
 Check that the channel is not taken! 
  Just check that the device is there and active
  TODO: turn this bit onoff depending on the number of physical channels
  actually used, if it is zero... well shut it off. That will save some
  power. Cut the clock at the same time.
 The Nomadik variant does not have the config register 
 The FTDMAC020 variant does this in another register 
 check & clear - ERR & TC interrupts 
 Locate physical channel 
				
				  This descriptor is done, release its mux
				  reservation.
				
				  And start the next descriptor (if any),
				  otherwise free this channel.
  Initialise the DMAC memcpyslave channels.
  Make a local wrapper to hold required data
	
	  Register as many many memcpy as we have physical channels,
	  we won't always be able to use all but the code will have
	  to cope with that situation.
			
			  Some implementations have muxed signals, whereas some
			  use a mux in front of the signals and need dynamic
			  assignment of signals.
 Expose a simple debugfs interface to view all clocks 
 Trying to get a slave channel from something with no slave support 
 Augment channel data for applicable AHB buses 
 Eligible bus masters for fetching LLIs 
 Eligible bus masters for memory access 
 Parse the memcpy channel properties 
	
	  Allocate channel data for all possible slave channels (one
	  for each possible signal), channels will then be allocated
	  for a device and have it's AHB interfaces set up at
	  translation time.
			
			  chanp->periph_buses will be assigned at translation
 Ensure that we can do DMA 
 Create the driver state holder 
 Assign useful pointers to the driver state 
 Vendor data from feature register 
 Initialize memcpy engine 
	
	  Initialize slave engine, if the block has no signals, that means
	  we have no slave support.
 Get the platform data 
 By default, AHB1 only.  If dualmaster, from platform 
 A DMA memory pool for LLIs, align on 1-byte boundary 
 Turn on the PL08x 
 Clear any pending interrupts 
 This variant has error IRQs in bits 16-19 
 Attach the interrupt handler 
 Initialize physical channels 
 FTDMA020 has a special channel busy register 
		
		  Nomadik variants can have channels that are locked
		  down for the secure world only. Lock up these channels
		  by perpetually serving a dummy virtual channel.
 Register as many memcpy channels as there are physical channels 
 Register slave channels 
 PL080 has 8 channels and the PL080 have just 2 
 Samsung PL080S variant 
 PL080 
 PL081 
 Nomadik 8815 PL080 variant 
 Faraday Technology FTDMAC020 
  MOXA ART SoCs DMA Engine support.
  Copyright (C) 2013 Jonas Jensen
  Jonas Jensen <jonas.jensen@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2.  This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  Unset: APB
  Set:   AHB
  000: No increment
  001: +1 (Burst=0), +4  (Burst=1)
  010: +2 (Burst=0), +8  (Burst=1)
  011: +4 (Burst=0), +16 (Burst=1)
  101: -1 (Burst=0), -4  (Burst=1)
  110: -2 (Burst=0), -8  (Burst=1)
  111: -4 (Burst=0), -16 (Burst=1)
  Request signal select sourcedestination address for DMA hardware handshake.
  The request line number is a property of the DMA controller itself,
  e.g. MMC must always request channels where dma_slave_config->slave_id is 5.
  0:    No request  Grant signal
  1-15: Request     Grant signal
  Data width of transfer:
  00: Word
  01: Half
  10: Byte
	
	  There are 4 cycles on 64 bytes copied, i.e. one cycle copies 16
	  bytes ( when width is APB_DMAB_DATA_WIDTH_4 ).
	
	  dma_cookie_status() assigns initial residue value.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2012 Marvell International Ltd.
 Run Bit (read  write) 
 No-Descriptor Fetch (read  write) 
 Stop Interrupt Enable (read  write) 
 Request Pending (read-only) 
 Stop State (read-only) 
 End Interrupt (read  write) 
 Start Interrupt (read  write) 
 Bus Error Interrupt (read  write) 
 End of Receive Interrupt Enable (RW) 
 Jump to next descriptor on EOR 
 STOP on an EOR 
 Set Descriptor Compare Status 
 Clear Descriptor Compare Status 
 The Descriptor Compare Status 
 The end of Receive 
 Map Valid (read  write) 
 mask for Channel Number (read  write) 
 Address of next descriptor (mask) 
 Stop (read  write) 
 Source Address Increment Setting. 
 Target Address Increment Setting. 
 Flow Control by the source. 
 Flow Control by the target. 
 Start Interrupt Enable 
 End Interrupt Enable 
 Device Endian-ness. 
 8 byte burst 
 16 byte burst 
 32 byte burst 
 1 byte width 
 2 byte width (HalfWord) 
 4 byte width (Word) 
 length mask (max = 8K - 1) 
 Points to the next descriptor + flags 
 DSADR value for the current transfer 
 DTADR value for the current transfer 
 DCMD value for the current transfer 
	struct mmp_pdma_desc_sw cyclic_first;	 first desc_sw if channel
 channel's basic info 
 list for desc 
 Descriptor list lock 
 Link descriptors queue for pending 
 Link descriptors queue for running 
 channel statue machine 
 Descriptors pool 
 protect allocfree phy channels 
 clear irq 
 only handle interrupts belonging to pdma driver
 lookup free phy channel as descending priority 
	
	  dma channel priorities
	  ch 0 - 3,  16 - 19  <--> (0)
	  ch 4 - 7,  20 - 23  <--> (1)
	  ch 8 - 11, 24 - 27  <--> (2)
	  ch 12 - 15, 28 - 31  <--> (3)
 clear the channel mapping in DRCMR 
  start_pending_queue - transfer any pending transactions
  pending list ==> running list
 still in running, irq will start the pending list 
 chance to re-fetch phy channel with higher prio 
	
	  pending -> running
	  reintilize pending list
	
	  Program the descriptor's address into the DMA controller,
	  then start the DMA transaction
 desc->tx_list ==> pending list 
 softly link to pending list - desc->tx_list ==> pending list 
 each desc has submit 
  mmp_pdma_alloc_chan_resources - Allocate resources for DMA channel.
  This function will create a dma pool for descriptor allocation.
  Request irq only when channel is requested
  Return - The number of allocated descriptors.
 Allocate the link descriptor from DMA pool 
 Insert the link descriptor to the LD ring 
 client is in control of this ack 
 last desc and fire IRQ 
 allocate and populate the descriptor 
 Insert the link descriptor to the LD ring 
 update metadata 
 last desc and fire IRQ 
 the buffer length must be a multiple of period_len 
 Allocate the link descriptor from DMA pool 
 Insert the link descriptor to the LD ring 
 client is in control of this ack 
 make the cyclic link 
	 FIXME: drivers should be ported over to use the filter
	  function. Once that's done, the following two lines can
	  be removed.
	
	  If the channel does not have a phy pointer anymore, it has already
	  been completed. Therefore, its residue is 0.
		
		  'passed' will be latched once we found the descriptor which
		  lies inside the boundaries of the curr pointer. All
		  descriptors that occur in the list _after_ we found that
		  partially handled descriptor are still to be processed and
		  are hence added to the residual bytes counter.
		
		  Descriptors that have the ENDIRQEN bit set mark the end of a
		  transaction chain, and the cookie assigned with it has been
		  returned previously from mmp_pdma_tx_submit().
		 
		  In case we have multiple transactions in the running chain,
		  and the cookie does not match the one the user asked us
		  about, reset the state variables and start over.
		 
		  This logic does not apply to cyclic transactions, where all
		  descriptors have the ENDIRQEN bit set, and for which we
		  can't have multiple transactions on one channel anyway.
 We should only get here in case of cyclic transactions 
  mmp_pdma_issue_pending - Issue the DMA start command
  pending list ==> running list
  dma_do_tasklet
  Do call back
  Start pending list
 submit pending list; callback for each desc; free desc 
		
		  move the descriptors to a temporary list so we can drop
		  the lock during the entire cleanup operation
		
		  Look for the first list entry which has the ENDIRQEN flag
		  set. That is the descriptor we got an interrupt for, so
		  complete that transaction and its cookie.
	
	  The hardware is idle and ready for more when the
	  chain_running list is empty.
 Start any pending transactions automatically 
 Run the callback for each descriptor, in order 
 Remove from the list of transactions 
 Run the link descriptor callback function 
 register virt channel to dma engine 
 default 32 channel 
 all chan share one irq, demux inside 
 Device-tree DMA controller registration 
 SPDX-License-Identifier: GPL-2.0
 Copyright 2014-2015 Freescale
 Copyright 2018 NXP
  Driver for NXP Layerscape Queue Direct Memory Access Controller
  Author:
   Wen He <wen.he_1@nxp.com>
   Jiaheng Fan <jiaheng.fan@nxp.com>
 Register related definition 
 Registers for bit and genmask 
 Size related definition 
 Field definition for CMD 
 Field definition for Descriptor status 
 Field definition for Descriptor offset 
 Field definition for safe loop count
  struct fsl_qdma_format - This is the struct holding describing compound
 			    descriptor format with qDMA.
  @status:		    Command status and enqueue status notification.
  @cfg:		    Frame offset and frame format.
  @addr_lo:		    Holding the compound descriptor of the lower
 			    32-bits address in memory 40-bit address.
  @addr_hi:		    Same as above member, but point high 8-bits in
 			    memory 40-bit address.
  @__reserved1:	    Reserved field.
  @cfg8b_w1:		    Compound descriptor command queue origin produced
 			    by qDMA and dynamic debug field.
  @data:		    Pointer to the memory 40-bit address, describes DMA
 			    source information and DMA destination information.
 qDMA status notification pre information 
 Head Command Descriptor(Frame Descriptor) 
 Status notification is enqueued to status queue. 
 Compound Command Descriptor(Frame List Table) 
 It must be 32 as Compound SG Descriptor 
 This entry is the last entry. 
 Descriptor Buffer 
  Pre-request full command descriptor for enqueue.
  Request a command descriptor for enqueue.
			
			  List for queue command buffer
	
	  Buffer for queue command
 Disable the command queue and wait for idle state. 
 Disable status queue. 
		
		  clear the command queue interrupt detect register for
		  all queues.
		 The completion_status is evaluated here
		  (outside of spin lock)
 A completion error occurred! 
 Write transaction error 
 Read transaction error 
				 Commandsourcedestination
				  description error
 Clear all detected events and interrupts. 
 Try to halt the qDMA engine first. 
		
		  Clear the command queue interrupt detect register for
		  all queues.
			
			  Initialize Command Queue registers to
			  point to the first
			  command descriptor in memory.
			  Dequeue Pointer Address Registers
			  Enqueue Pointer Address Registers
 Initialize the queue mode. 
		
		  Workaround for erratum: ERR010812.
		  We must enable XOFF to avoid the enqueue rejection occurs.
		  Setting SQCCMR ENTER_WM to 0x20.
		
		  Initialize status queue registers to point to the first
		  command descriptor in memory.
		  Dequeue Pointer Address Registers
		  Enqueue Pointer Address Registers
 Initialize status queue interrupt. 
 Initialize the status queue mode. 
 Initialize controller interrupt register. 
	
	  The dma pool for queue command buffer
	
	  The dma pool for Descriptor(SDDD) buffer
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
  driversdmafsl-edma.c
  Copyright 2013-2014 Freescale Semiconductor, Inc.
  Driver for the Freescale eDMA engine with flexible channel multiplexing
  capability for DMA request sources. The eDMA block can be found on some
  Vybrid and Layerscape SoCs.
 terminate_all called before 
	
	  16 channel independent interrupts + 1 error interrupt on i.mx7ulp.
	  2 channel share one interrupt, for example, ch0ch16, ch1ch17...
	  For now, just simply request irq without IRQF_SHARED flag, since 16
	  channels are enough on i.mx7ulp whose M4 domain own some peripherals.
 The last IRQ is for eDMA err 
 sentinel  }
 on error: disable all previously enabled clks 
 on error: disable all previously enabled clks 
 on error: disable all previously enabled clks 
 Per worst case 'nbytes = 1' take CITER as the max_seg_size 
 enable round robin arbitration 
 Make sure chan is idle or will force disable. 
  eDMA provides the service to others, so it should be suspend late
  and resume early. When eDMA suspend, all of the clients should stop
  the DMA data transmission and let the channel idle.
 SPDX-License-Identifier: GPL-2.0-only
  DMA Router driver for LPC18xx43xx DMA MUX
  Copyright (C) 2015 Joachim Eastwood <manabian@gmail.com>
  Based on TI DMA Crossbar driver by:
    Copyright (C) 2015 Texas Instruments Incorporated - http:www.ti.com
    Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
 CREG register offset and macros for mux manipulation 
 The of_node_put() will be done in the core for the node 
 SPDX-License-Identifier: GPL-2.0+
 driversdmaimx-sdma.c
 This file contains a driver for the Freescale Smart DMA engine
 Copyright 2010 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
 Based on code from Freescale:
 Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
 SDMA registers 
  Buffer descriptor status values.
  Data Node descriptor status values.
  IPCV2 descriptor status values.
  Error bit set in the CCB status field by the SDMA,
  in setbd routine, in case of a transfer error
  Buffer descriptor commands.
  Change endianness indicator in the BD command field
   p_2_p watermark_level description
 	Bits		Name			Description
 	0-7		Lower WML		Lower watermark level
 	8		PS			1: Pad Swallowing
 						0: No Pad Swallowing
 	9		PA			1: Pad Adding
 						0: No Pad Adding
 	10		SPDIF			If this bit is set both source
 						and destination are on SPBA
 	11		Source Bit(SP)		1: Source on SPBA
 						0: Source on AIPS
 	12		Destination Bit(DP)	1: Destination on SPBA
 						0: Destination on AIPS
 	13-15		---------		MUST BE 0
 	16-23		Higher WML		HWML
 	24-27		N			Total number of samples after
 						which Pad addingSwallowing
 						must be done. It must be odd.
 	28		Lower WML Event(LWE)	SDMA events reg to check for
 						LWML event mask
 						0: LWE in EVENTS register
 						1: LWE in EVENTS2 register
 	29		Higher WML Event(HWE)	SDMA events reg to check for
 						HWML event mask
 						0: HWE in EVENTS register
 						1: HWE in EVENTS2 register
 	30		---------		MUST BE 0
 	31		CONT			1: Amount of samples to be
 						transferred is unknown and
 						script will keep on
 						transferring samples as long as
 						both events are detected and
 						script must be manually stopped
 						by the application
 						0: The amount of samples to be
 						transferred is equal to the
 						count field of mode word
  struct sdma_script_start_addrs - SDMA script start pointers
  start addresses of the different functions in the physical
  address space of the SDMA engine.
 End of v1 array 
 End of v2 array 
 End of v3 array 
 End of v4 array 
  ModeCount of data node descriptors - IPCv2
 size of the buffer pointed by this BD 
 E,R,I,C,W,D status bits stored here 
 command mostly used for channel 0 
  Buffer descriptor
 address of the buffer described 
 extended buffer address 
  struct sdma_channel_control - Channel control Block
  @current_bd_ptr:	current buffer descriptor processed
  @base_bd_ptr:	first element of buffer descriptor array
  @unused:		padding. The SDMA engine expects an array of 128 byte
 			control blocks
  struct sdma_state_registers - SDMA context for a channel
  @pc:		program counter
  @unused1:	unused
  @t:		test bit: status of arithmetic & test instruction
  @rpc:	return program counter
  @unused0:	unused
  @sf:		source fault while loading data
  @spc:	loop start program counter
  @unused2:	unused
  @df:		destination fault while storing data
  @epc:	loop end program counter
  @lm:		loop mode
  struct sdma_context_data - sdma context specific to a channel
  @channel_state:	channel state bits
  @gReg:		general registers
  @mda:		burst dma destination address register
  @msa:		burst dma source address register
  @ms:			burst dma status register
  @md:			burst dma data register
  @pda:		peripheral dma destination address register
  @psa:		peripheral dma source address register
  @ps:			peripheral dma status register
  @pd:			peripheral dma data register
  @ca:			CRC polynomial register
  @cs:			CRC accumulator register
  @dda:		dedicated core destination address register
  @dsa:		dedicated core source address register
  @ds:			dedicated core status register
  @dd:			dedicated core data register
  @scratch0:		1st word of dedicated ram for context switch
  @scratch1:		2nd word of dedicated ram for context switch
  @scratch2:		3rd word of dedicated ram for context switch
  @scratch3:		4th word of dedicated ram for context switch
  @scratch4:		5th word of dedicated ram for context switch
  @scratch5:		6th word of dedicated ram for context switch
  @scratch6:		7th word of dedicated ram for context switch
  @scratch7:		8th word of dedicated ram for context switch
  struct sdma_desc - descriptor structor for one transfer
  @vd:			descriptor for virt dma
  @num_bd:		number of descriptors currently handling
  @bd_phys:		physical address of bd
  @buf_tail:		ID of the buffer that was processed
  @buf_ptail:		ID of the previous buffer that was processed
  @period_len:		period length, used in cyclic.
  @chn_real_count:	the real count updated from bd->mode.count
  @chn_count:		the transfer count set
  @sdmac:		sdma_channel pointer
  @bd:			pointer of allocate bd
  struct sdma_channel - housekeeping for a SDMA channel
  @vc:			virt_dma base structure
  @desc:		sdma description including vd and other special member
  @sdma:		pointer to the SDMA engine for this channel
  @channel:		the channel number, matches dmaengine chan_id + 1
  @direction:		transfer type. Needed for setting SDMA script
  @slave_config:	Slave configuration
  @peripheral_type:	Peripheral type. Needed for setting SDMA script
  @event_id0:		aka dma request line
  @event_id1:		for channels that use 2 events
  @word_size:		peripheral access size
  @pc_from_device:	script address for those device_2_memory
  @pc_to_device:	script address for those memory_2_device
  @device_to_device:	script address for those device_2_device
  @pc_to_pc:		script address for those memory_2_memory
  @flags:		loop mode or not
  @per_address:	peripheral source or destination address in common case
                       destination address in p_2_p case
  @per_address2:	peripheral source address in p_2_p case
  @event_mask:		event mask used in p_2_p script
  @watermark_level:	value for gReg[7], some script will extend it from
 			basic watermark such as p_2_p
  @shp_addr:		value for gReg[6]
  @per_addr:		value for gReg[2]
  @status:		status of dma channel
  @context_loaded:	ensure context is only loaded once
  @data:		specific sdma interface structure
  @bd_pool:		dma_pool for bd
  @terminate_worker:	used to call back into terminate work function
  struct sdma_firmware_header - Layout of the firmware image
  @magic:		"SDMA"
  @version_major:	increased whenever layout of struct
 			sdma_script_start_addrs changes.
  @version_minor:	firmware minor version (for binary compatible changes)
  @script_addrs_start:	offset of struct sdma_script_start_addrs in this image
  @num_script_addrs:	Number of script addresses in this image
  @ram_code_start:	offset of SDMA ram image in this firmware image
  @ram_code_size:	size of SDMA ram image
  @script_addrs:	Stores the start address of the SDMA scripts
 			(in SDMA memory space)
	
	  ecspi ERR009165 fixed should be done in sdma script
	  and it has been fixed in soc from i.mx6ul.
	  please get more information from the below link:
	  https:www.nxp.comdocsenerrataIMX6DQCE.pdf
 clock ratio for AHB:SDMA core. 1:1 is 1, 2:1 is 0
 sentinel  }
 indicates if the DSPDMA is used 
 indicates if Real-Time Debug pins are enabled 
 indicates if AHB freq core freq = 2 or 1 
 indicates which context switch mode is selected
  sdma_run_channel0 - run a channel and wait till it's done
 Set bits of CONFIG register with dynamic context switching 
	
	  loop mode. Iterate over descriptors, re-setup them and
	  call callback function.
	       
		 We use bd->mode.count to calculate the residue, since contains
		 the number of bytes present in the current buffer descriptor.
		
		  The callback is called from the interrupt context in order
		  to reduce latency and to avoid the risk of altering the
		  SDMA transaction status by the time the client tasklet is
		  executed.
	
	  non loop mode. Iterate over all descriptors, collect
	  errors and call callback function
 channel 0 is special and not handled here, see run_channel0() 
  sets the pc of SDMA script according to the peripheral type
	
	  These are needed once we start to support transfers between
	  two peripherals or memory-to-memory transfers
 Use rom script mcu_2_app if ERR009165 fixed 
	 Send by context the event mask,base address for peripheral
	  and watermark level
	
	  According to NXP R&D team a delay of one BD SDMA cost time
	  (maximum is 1ms) should be added after disable of the channel
	  bit, to ensure SDMA core has really been stopped after SDMA
	  clients call .device_terminate_all.
		
		  move out current descriptor into terminated list so that
		  it could be free in sdma_channel_terminate_work alone
		  later without potential involving next descriptor raised
		  up before the last descriptor terminated.
	
	  If LWML(src_maxburst) > HWML(dst_maxburst), we need
	  swap LWML and HWML of INFO(A.3.2.5.1), also need swap
	  r0(event_mask[1]) and r1(event_mask[0]).
 Handle multiple event channels differently 
 Address 
 FIXME: M3_BASE_ADDRESS 
	
	  MEMCPY may never setup chan->private by filter function such as
	  dmatest, thus create 'struct imx_dma_data mem_data' for this case.
	  Please note in any other slave case, you have to setup chan->private
	  with 'struct imx_dma_data' in your own filter function if you want to
	  request dma channel by dma_request_channel() rather than
	  dma_request_slave_channel(). Othwise, 'MEMCPY in case?' will appear
	  to warn you to correct your filter function.
 No slave_config called in MEMCPY case, so do here 
 last bd 
 Set ENBLn earlier to make sure dma request triggered after that 
 use the default firmware in ROM if missing external firmware 
	
	  get uart_2_mcu_addruartsh_2_mcu_addr rom script specially because
	  they are now replaced by uart_2_mcu_ram_addruartsh_2_mcu_ram_addr
	  to be compatible with legacy freescalenxp sdma firmware, and they
	  are located in the bottom part of sdma_script_start_addrs which are
	  beyond the SDMA_SCRIPT_ADDRS_ARRAY_SIZE_V1.
 In this case we just use the ROM firmware. 
 download the RAM image for SDMA 
 Be sure SDMA has not started yet 
 disable all channels 
 All channels have priority 0 
 Set Command Channel (Channel Zero) 
 Set bits of CONFIG register but with static context switching 
 Initializes channel's priorities 
	
	  init dma_request2 to zero, which is not used by the dts.
	  For P2P, dma_request2 is init from dma_request_channel(),
	  chan->private will point to the imx_dma_data, and in
	  device_alloc_chan_resources(), imx_dma_data.dma_request2 will
	  be set to sdmac->event_id1.
 initially no scripts available 
 Initialize channel parameters 
		
		  Add the channel to the DMAC list. Do not add channel 0 though
		  because we need it internally in the SDMA driver. This also means
		  that channel 0 in dmaengine counting matches sdma channel 1.
	
	  Because that device tree does not encode ROM script address,
	  the RAM script in firmware is mandatory for device tree
	  probe, otherwise it fails.
 Kill the tasklet 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2015 Robert Jarzmik <robert.jarzmik@free.fr>
 Run Bit (read  write) 
 No-Descriptor Fetch (read  write) 
 Stop Interrupt Enable (RW) 
 Request Pending (read-only) 
 Stop State (read-only) 
 End Interrupt (read  write) 
 Start Interrupt (read  write) 
 Bus Error Interrupt (read  write) 
 End of Receive IRQ Enable (RW) 
 Jump to next descriptor on EOR 
 STOP on an EOR 
 Set Descriptor Compare Status 
 Clear Descriptor Compare Status 
 The Descriptor Compare Status 
 The end of Receive 
 Map Valid (read  write) 
 mask for Channel Number (read  write) 
 Address of next descriptor (mask) 
 Stop (read  write) 
 Source Address Increment Setting. 
 Target Address Increment Setting. 
 Flow Control by the source. 
 Flow Control by the target. 
 Start Interrupt Enable 
 End Interrupt Enable 
 Device Endian-ness. 
 8 byte burst 
 16 byte burst 
 32 byte burst 
 1 byte width 
 2 byte width (HalfWord) 
 4 byte width (Word) 
 length mask (max = 8K - 1) 
 Points to the next descriptor + flags 
 DSADR value for the current transfer 
 DTADR value for the current transfer 
 DCMD value for the current transfer 
 Virtual descriptor 
 Number of hw. descriptors 
 Number of bytes xfered 
 First descriptor's addr 
 At least one descriptor has an srcdst address not multiple of 8 
 Channel's used allocator 
 DMA coherent descriptors 
 Virtual channel 
 Requestor of the channel 
 Required priority of phy 
	
	  At least one desc_sw in submitted or issued transfers on this channel
	  has one address such as: addr % 8 != 0. This implies the DALGN
	  setting on the phy.
 Runtime config 
 protected by vc->lock 
 Descriptors pool 
 Phy association 
  Debug fs
 basic device status 
	
	  dma channel priorities
	  ch 0 - 3,  16 - 19  <--> (0)
	  ch 4 - 7,  20 - 23  <--> (1)
	  ch 8 - 11, 24 - 27  <--> (2)
	  ch 12 - 15, 28 - 31  <--> (3)
 clear the channel mapping in DRCMR 
	
	  Program the descriptor's address into the DMA controller,
	  then start the DMA transaction
	
	  Attempt to hot chain the tx if the phy is still running. This is
	  considered successful only if either the channel is still running
	  after the chaining, or if the chained transfer is completed after
	  having been hot chained.
	  A change of alignment is not allowed, and forbids hotchaining.
 clear irq 
	
	  Fallback to placing the tx in the submitted queue
		
		  Only chain the descriptors if no new misalignment is
		  introduced. If a new misalignment is chained, let the channel
		  stop, and be relaunched in misalign mode from the irq
		  handler.
	 FIXME: drivers should be ported over to use the filter
	  function. Once that's done, the following two lines can
	  be removed.
 the buffer length must be a multiple of period_len 
	
	  If the channel does not have a phy pointer anymore, it has already
	  been completed. Therefore, its residue is 0.
	
	  curr has to be actually read before checking descriptor
	  completion, so that a curr inside a status updater
	  descriptor implies the following test returns true, and
	  preventing reordering of curr load and the test.
		
		  'passed' will be latched once we found the descriptor
		  which lies inside the boundaries of the curr
		  pointer. All descriptors that occur in the list
		  _after_ we found that partially handled descriptor
		  are still to be processed and are hence added to the
		  residual bytes counter.
 default 32 channel 
 Device-tree DMA controller registration 
 SPDX-License-Identifier: GPL-2.0-or-later
  Applied Micro X-Gene SoC DMA engine Driver
  Copyright (c) 2015, Applied Micro Circuits Corporation
  Authors: Rameshwar Prasad Sahu <rsahu@apm.com>
 	    Loc Ho <lho@apm.com>
  NOTE: PM support is currently not available.
 X-Gene DMA ring csr registers and bit definations 
 X-Gene DMA device csr registers and bit definitions 
 X-Gene SoC EFUSE csr register and bit defination 
 X-Gene DMA Descriptor format 
 X-Gene DMA descriptor empty sw signature 
 X-Gene DMA configurable parameters defines 
 32 Bytes 
 16 KB 
 80 KB 
 X-Gene DMA descriptor error codes 
 X-Gene DMA error interrupt codes 
 X-Gene DMA flyby operation code 
 X-Gene DMA SW descriptor flags 
 Define to dump X-Gene DMA descriptor 
  struct xgene_dma_chan - internal representation of an X-Gene DMA channel
  @dma_chan: dmaengine channel object member
  @pdma: X-Gene DMA device structure reference
  @dev: struct device reference for dma mapping api
  @id: raw id of this channel
  @rx_irq: channel IRQ
  @name: name of X-Gene DMA channel
  @lock: serializes enqueuedequeue operations to the descriptor pool
  @pending: number of transaction request pushed to DMA controller for
 	execution, but still waiting for completion,
  @max_outstanding: max number of outstanding request we can push to channel
  @ld_pending: descriptors which are queued to run, but have not yet been
 	submitted to the hardware for execution
  @ld_running: descriptors which are currently being executing by the hardware
  @ld_completed: descriptors which have finished execution by the hardware.
 	These descriptors have already had their cleanup actions run. They
 	are waiting for the ACK bit to be set by the async tx API.
  @desc_pool: descriptor pool for DMA operations
  @tasklet: bottom half where all completed descriptors cleans
  @tx_ring: transmit ring descriptor that we use to prepare actual
 	descriptors for further executions
  @rx_ring: receive ring descriptor that we use to get completed DMA
 	descriptors during cleanup time
  struct xgene_dma - internal representation of an X-Gene DMA device
  @dev: reference to this device's struct device
  @clk: reference to this device's clock
  @err_irq: DMA error irq number
  @ring_num: start id number for DMA ring
  @csr_dma: base for DMA register access
  @csr_ring: base for DMA ring register access
  @csr_ring_cmd: base for DMA ring command register access
  @csr_efuse: base for efuse register access
  @dma_dev: embedded struct dma_device
  @chan: reference to X-Gene DMA channels
 Dummy 
 Dummy 
 Initialize DMA descriptor 
 Set destination address 
 We have multiple source addresses, so need to set NV bit
 Set flyby opcode 
 Set 1st to 5th source addresses 
 Update meta data 
 We need always 64B descriptor to perform xor or pq operations 
 Add this transaction list onto the tail of the pending queue 
  xgene_dma_clean_completed_descriptor - free all descriptors which
  has been completed and acked
  @chan: X-Gene DMA channel
  This function is used on all completed and acked descriptors.
 Run the callback for each descriptor, in order 
  xgene_dma_run_tx_complete_actions - cleanup a single link descriptor
  @chan: X-Gene DMA channel
  @desc: descriptor to cleanup and free
  This function is used on a descriptor which has been executed by the DMA
  controller. It will run any callbacks, submit any dependencies.
	
	  If this is not the last transaction in the group,
	  then no need to complete cookie and run any callback as
	  this is not the tx_descriptor which had been sent to caller
	  of this DMA request
 Run the link descriptor callback function 
 Run any dependencies 
  xgene_dma_clean_running_descriptor - move the completed descriptor from
  ld_running to ld_completed
  @chan: X-Gene DMA channel
  @desc: the descriptor which is completed
  Free the descriptor directly if acked by async_tx api,
  else move it to queue ld_completed.
 Remove from the list of running transactions 
	
	  the client is allowed to attach dependent operations
	  until 'ack' is set
		
		  Move this descriptor to the list of descriptors which is
		  completed, but still awaiting the 'ack' bit to be set.
 Get hw descriptor from DMA tx ring 
	
	  Increment the head count to point next
	  descriptor for next time
 Copy prepared sw descriptor data to hw descriptor 
	
	  Check if we have prepared 64B descriptor,
	  in this case we need one more hw descriptor
 Increment the pending transaction count 
 Notify the hw that we have descriptor ready for execution 
  xgene_chan_xfer_ld_pending - push any pending transactions to hw
  @chan : X-Gene DMA channel
  LOCKING: must hold chan->lock
	
	  If the list of pending descriptors is empty, then we
	  don't need to do any work at all
	
	  Move elements from the queue of pending transactions onto the list
	  of running transactions and push it to hw for further executions
		
		  Check if have pushed max number of transactions to hw
		  as capable, so let's stop here and will push remaining
		  elements from pening ld queue after completing some
		  descriptors that we have already pushed
		
		  Delete this element from ld pending queue and append it to
		  ld running queue
  xgene_dma_cleanup_descriptors - cleanup link descriptors which are completed
  and move them to ld_completed to free until flag 'ack' is set
  @chan: X-Gene DMA channel
  This function is used on descriptors which have been executed by the DMA
  controller. It will run any callbacks, submit any dependencies, then
  free these descriptors if flag 'ack' is set.
 Clean already completed and acked descriptors 
 Move all completed descriptors to ld completed queue, in order 
 Get subsequent hw descriptor from DMA rx ring 
 Check if this descriptor has been completed 
 Check if we have any error with DMA transactions 
 Print the DMA error type 
			
			  We have DMA transactions error here. Dump DMA Tx
 Notify the hw about this completed descriptor 
 Mark this hw descriptor as processed 
		
		  Decrement the pending transaction count
		  as we have processed one
		
		  Delete this node from ld running queue and append it to
		  ld completed queue for further processing
	
	  Start any pending transactions automatically
	  In the ideal case, we keep the DMA controller busy while we go
	  ahead and free the descriptors below.
 Run the callback for each descriptor, in order 
 Has this channel already been allocated? 
  xgene_dma_free_desc_list - Free all descriptors in a queue
  @chan: X-Gene DMA channel
  @list: the list to free
  LOCKING: must hold chan->lock
 Process all running descriptor 
 Clean all link descriptor queues 
 Delete this channel DMA pool 
 Allocate the link descriptor from DMA pool 
 Prepare xor DMA descriptor 
 Insert the link descriptor to the LD ring 
 client is in control of this ack 
	
	  Save source addresses on local variable, may be we have to
	  prepare two descriptor to generate P and Q if both enabled
	  in the flags by client
 Allocate the link descriptor from DMA pool 
 Insert the link descriptor to the LD ring 
		
		  Prepare DMA descriptor to generate P,
		  if DMA_PREP_PQ_DISABLE_P flag is not set
		
		  Prepare DMA descriptor to generate Q,
		  if DMA_PREP_PQ_DISABLE_Q flag is not set
 client is in control of this ack 
 Run all cleanup for descriptors which have been completed 
 Re-enable DMA channel IRQ 
	
	  Disable DMA channel IRQ until we process completed
	  descriptors
	
	  Schedule the tasklet to handle all cleanup of the current
	  transaction. It will start a new transaction if there is
	  one pending.
 Clear DMA interrupts 
 Print DMA error info 
 Clear DMA ring state 
 Set DMA ring type 
 Set recombination buffer and timeout 
 Initialize DMA ring state 
 Write DMA ring configurations 
 Set DMA ring id 
 Set DMA ring buffer 
 Set empty signature to DMA Rx ring descriptors 
 Enable DMA Rx ring interrupt 
 Disable DMA Rx ring interrupt 
 Clear DMA ring state 
 Clear DMA ring configurations 
 De-allocate DMA ring descriptor 
 Setup DMA ring descriptor variables 
 Allocate memory for DMA ring descriptor 
 Configure and enable DMA ring 
 Create DMA Rx ring descriptor 
 Create DMA Tx ring descriptor 
 Set the max outstanding request possible to this channel 
 Configure and enable DMA engine 
	
	  Mask DMA ring overflow, underflow and
	  AXI writeread error interrupts
 Mask DMA error interrupts 
	
	  Unmask DMA ring overflow, underflow and
	  AXI writeread error interrupts
 Unmask DMA error interrupts 
 Associate DMA ring to corresponding ring HW 
 Configure RAID6 polynomial control setting 
 Get DMA id and version info 
 DMA device info 
 Bring up memory 
 Force a barrier 
 reset may take up to 1ms 
 program threshold set 1 and all hysteresis 
 Enable QPcore and assign error queue 
 Bring up memory 
 Force a barrier 
 reset may take up to 1ms 
 Register DMA error irq 
 Register DMA channel rx irq 
 Free DMA device error irq 
 Initialize DMA device capability mask 
 Set DMA device capability 
	 Basically here, the X-Gene SoC DMA engine channel 0 supports XOR
	  and channel 1 supports XOR, PQ both. First thing here is we have
	  mechanism in hw to enabledisable PQXOR supports on channel 1,
	  we can make sure this by reading SoC Efuse register.
	  Second thing, we have hw errata that if we run channel 0 and
	  channel 1 simultaneously with executing XOR and PQ request,
	  suddenly DMA engine hangs, So here we enable XOR on channel 0 only
	  if XOR and PQ supports on channel 1 is disabled.
 Set base and prep routines 
 Setup dma device capabilities and prep routines 
 Initialize DMA device list head 
 Register with Linux async DMA framework
 DMA capability info 
 Get DMA csr region 
 Get DMA ring csr region 
 Get DMA ring cmd csr region 
 Get efuse csr region 
 Get DMA error interrupt 
 Get DMA Rx ring descriptor interrupts for all DMA channels 
 Enable clk before accessing registers 
 Remove DMA RAM out of shutdown 
 Initialize DMA channels software state 
 Configue DMA rings 
 Configure and enable DMA engine 
 Register DMA device with linux async framework 
 Mask interrupts and disable DMA engine 
 SPDX-License-Identifier: GPL-2.0
  External DMA controller driver for UniPhier SoCs
  Copyright 2019 Socionext Inc.
  Author: Kunihiko Hayashi <hayashi.kunihiko@socionext.com>
 cut lower bit for maintain alignment of maximum transfer size 
 xc->vc.lock must be held by caller 
 xc->vc.lock must be held by caller 
	
	  The width of MEM side must be 4 or 8 bytes, that does not
	  affect that of DEV side and transfer size.
 setup transfer factor 
 setup the channel 
 enable interrupt 
 start XDMAC 
 xc->vc.lock must be held by caller 
 disable interrupt 
 stop XDMAC 
 wait until transfer is stopped 
 xc->vc.lock must be held by caller 
 set desc to chan regardless of xd is null 
 write bits to clear 
		
		  Currently transfer that size doesn't align the unit size
		  (the number of burst words  bus-width) is not allowed,
		  because the driver does not support the way to transfer
		  residue size. As a matter of fact, in order to transfer
		  arbitrary size, 'src_maxburst' or 'dst_maxburst' of
		  dma_slave_config must be 1.
	
	  Before reaching here, almost all descriptors have been freed by the
	  ->device_free_chan_resources() hook. However, each channel might
	  be still holding one descriptor that was on-flight at that moment.
	  Terminate it to make sure this hardware is no longer running. Then,
	  free the channel resources once again to avoid memory leak.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
  DMA driver for STMicroelectronics STi FDMA controller
  Copyright (C) 2014 STMicroelectronics
  Author: Ludovic Barre <Ludovic.barre@st.com>
 	   Peter Griffin <peter.griffin@linaro.org>
	
	  dreq_mask is shared for n channels of fdma, so all accesses must be
	  atomic. if the dreq_mask is changed between ffz and set_bit,
	  we retry
 start the channel for the descriptor 
 Start the next descriptor (if available) 
 Create the dma pool for descriptor allocation 
 We only require a single descriptor 
 the buffer length must be a multiple of period_len 
 interrupt at end of last node 
 Initialise list of FDMA channels 
 Initialise the FDMA dreq (reserve 0 & 31 for FDMA use) 
 SPDX-License-Identifier: GPL-2.0-only
  Driver for the Analog Devices AXI-DMAC core
  Copyright 2013-2019 Analog Devices Inc.
   Author: Lars-Peter Clausen <lars@metafoo.de>
  The AXI-DMAC is a soft IP core that is used in FPGA designs. The core has
  various instantiation parameters which decided the exact feature set support
  by the core.
  Each channel of the core has a source interface and a destination interface.
  The number of channels and the type of the channel interfaces is selected at
  configuration time. A interface can either be a connected to a central memory
  interconnect, which allows access to system memory, or it can be connected to
  a dedicated bus which is directly connected to a data port on a peripheral.
  Given that those are configuration options of the core that are selected when
  it is instantiated this means that they can not be changed by software at
  runtime. By extension this means that each channel is uni-directional. It can
  either be device to memory or memory to device, but not both. Also since the
  device side is a dedicated data bus only connected to a single peripheral
  there is no address than can or needs to be configured for the device side.
 The maximum ID allocated by the hardware is 31 
 Not aligned 
 Not aligned 
 Queue is full, wait for the next SOT IRQ 
 Already queued in cyclic mode. Wait for it to finish 
 Start again 
	
	  If the hardware supports cyclic transfers and there is no callback to
	  call and only a single segment, enable hw cyclic mode to avoid
	  unnecessary interrupts.
 Check if we have any more partial transfers 
	
	  We get here if the last completed segment is partial, which
	  means we can compute the residue from that segment onwards
 Not yet submitted 
 wrap around 
 One or more transfers have finished 
 Space has become available in the descriptor queue 
 Split into multiple equally sized segments if necessary 
 Take care of alignment 
  The configuration stored in the devicetree matches the configuration
  parameters of the peripheral instance and allows the driver to know which
  features are implemented and how it should behave.
 We only support 1 channel for now 
 widths are stored in log2 
 SPDX-License-Identifier: GPL-2.0-only
  IMG Multi-threaded DMA Controller (MDC)
  Copyright (C) 2009,2012,2013 Imagination Technologies Ltd.
  Copyright (C) 2014 Google, Inc.
	
	  Not part of the list descriptor, but instead used by the CPU to
	  traverse the list.
		
		  Determine the number of commands that haven't been
		  processed (handled by the IRQ handler) yet.
		
		  If the command loaded event hasn't been processed yet, then
		  the difference above includes an extra command.
	
	  CMDS_DONE may have incremented between reading CMDS_PROCESSED
	  and clearing INT_ACTIVE.  Re-read CMDS_PROCESSED to ensure we
	  didn't miss a command completion.
		
		  The first interrupt in a transfer indicates that the
		  command list has been loaded, not that a command has
		  been completed.
	
	  Although transfer sizes of up to MDC_TRANSFER_SIZE_MASK + 1 bytes
	  are supported, this makes it possible for the value reported in
	  MDC_ACTIVE_TRANSFER_SIZE to be ambiguous - an active transfer size
	  of MDC_TRANSFER_SIZE_MASK may indicate either that 0 bytes or
	  MDC_TRANSFER_SIZE_MASK + 1 bytes are remaining.  To eliminate this
	  ambiguity, restrict transfer sizes to one bus-width less than the
	  actual maximum.
 Check that all channels are idle 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for the Atmel AHB DMA Controller (aka HDMA or DMAC on AT91 systems)
  Copyright (C) 2008 Atmel Corporation
  This supports the Atmel AHB DMA Controller found in several Atmel SoCs.
  The only Atmel DMA Controller that is not covered by this driver is the one
  found on AT91SAM9263.
  Glossary
  --------
  at_hdmac		: Name of the ATmel AHB DMA Controller
  at_dma_  atdma	: ATmel DMA controller entity related
  atc_	 atchan	: ATmel DMA Channel entity related
  Initial number of descriptors to allocate for each channel. This could
  be increased during dma usage.
  struct at_dma_platform_data - Controller configuration parameters
  @nr_channels: Number of channels supported by hardware (max 8)
  @cap_mask: dma_capability flags supported by the platform
  struct at_dma_slave - Controller-specific information about a slave
  @dma_dev: required DMA master device
  @cfg: Platform-specific initializer for the CFG register
 prototypes 
----------------------------------------------------------------------
  atc_alloc_descriptor - allocate and return an initialized descriptor
  @chan: the channel to allocate descriptors for
  @gfp_flags: GFP allocation flags
  Note: The ack-bit is positioned in the descriptor flag at creation time
        to make initial allocation more convenient. This bit will be cleared
        and control will be given to client at usage time (during
        preparation functions).
 txd.flags will be overwritten in prep functions 
  atc_desc_get - get an unused descriptor from free_list
  @atchan: channel we want a new descriptor for
 no more descriptor available in initial pool: create one more 
  atc_desc_put - move a descriptor, including any children, to the free list
  @atchan: channel we work on
  @desc: descriptor, at the head of a chain, to move to free list
  atc_desc_chain - build chain adding a descriptor
  @first: address of first descriptor of the chain
  @prev: address of previous descriptor of the chain
  @desc: descriptor to queue
  Called from prep_ functions
 inform the HW lli about chaining 
 insert the link descriptor to the LD ring 
  atc_dostart - starts the DMA engine for real
  @atchan: the channel we want to start
  @first: first descriptor in the list we want to begin with
  Called with atchan->lock held and bh disabled
 ASSERT:  channel is idle 
 The tasklet will hopefully advance the queue... 
  atc_get_desc_by_cookie - get the descriptor of a cookie
  @atchan: the DMA channel
  @cookie: the cookie to get the descriptor for
  atc_calc_bytes_left - calculates the number of bytes left according to the
  value read from CTRLA.
  @current_len: the number of bytes left before reading CTRLA
  @ctrla: the value of CTRLA
	
	  According to the datasheet, when reading the Control A Register
	  (ctrla), the Buffer Transfer Size (btsize) bitfield refers to the
	  number of transfers completed on the Source Interface.
	  So btsize is always a number of source width transfers.
  atc_get_bytes_left - get the number of bytes residue for a cookie
  @chan: DMA channel
  @cookie: transaction identifier to check status of
	
	  If the cookie doesn't match to the currently running transfer then
	  we can return the total length of the associated DMA transfer,
	  because it is still queued.
 cookie matches to the currently running transfer 
 hardware linked list transfer 
		
		  Calculate the residue by removing the length of the child
		  descriptors already transferred from the total length.
		  To get the current child descriptor we can use the value of
		  the channel's DSCR register and compare it against the value
		  of the hardware linked list structure of each child
		  descriptor.
		 
		  The CTRLA register provides us with the amount of data
		  already read from the source for the current child
		  descriptor. So we can compute a more accurate residue by also
		  removing the number of bytes corresponding to this amount of
		  data.
		 
		  However, the DSCR and CTRLA registers cannot be read both
		  atomically. Hence a race condition may occur: the first read
		  register may refer to one child descriptor whereas the second
		  read may refer to a later child descriptor in the list
		  because of the DMA transfer progression inbetween the two
		  reads.
		 
		  One solution could have been to pause the DMA transfer, read
		  the DSCR and CTRLA then resume the DMA transfer. Nonetheless,
		  this approach presents some drawbacks:
		  - If the DMA transfer is paused, RX overruns or TX underruns
		    are more likey to occur depending on the system latency.
		    Taking the USART driver as an example, it uses a cyclic DMA
		    transfer to read data from the Receive Holding Register
		    (RHR) to avoid RX overruns since the RHR is not protected
		    by any FIFO on most Atmel SoCs. So pausing the DMA transfer
		    to compute the residue would break the USART driver design.
		  - The atc_pause() function masks interrupts but we'd rather
		    avoid to do so for system latency purpose.
		 
		  Then we'd rather use another solution: the DSCR is read a
		  first time, the CTRLA is read in turn, next the DSCR is read
		  a second time. If the two consecutive read values of the DSCR
		  are the same then we assume both refers to the very same
		  child descriptor as well as the CTRLA value read inbetween
		  does. For cyclic tranfers, the assumption is that a full loop
		  is "not so fast".
		  If the two DSCR values are different, we read again the CTRLA
		  then the DSCR till two consecutive read values from DSCR are
		  equal or till the maxium trials is reach.
		  This algorithm is very unlikely not to find a stable value for
		  DSCR.
 ensure DSCR is read before CTRLA 
 ensure DSCR is read after CTRLA 
			
			  If the DSCR register value has not changed inside the
			  DMA controller since the previous read, we assume
			  that both the dscr and ctrla values refers to the
			  very same descriptor.
			
			  DSCR has changed inside the DMA controller, so the
			  previouly read value of CTRLA may refer to an already
			  processed descriptor hence could be outdated.
			  We need to update ctrla to match the current
			  descriptor.
 ensure DSCR is read before CTRLA 
 for the first descriptor we can be more accurate 
		
		  For the current descriptor in the chain we can calculate
		  the remaining bytes using the channel's register.
 single transfer 
  atc_chain_complete - finish work for one transaction chain
  @atchan: channel we work on
  @desc: descriptor at the head of the chain we want do complete
 mark the descriptor as complete for non cyclic cases only 
 If the transfer was a memset, free our temporary buffer 
 move children to free_list 
 move myself to free_list 
	 for cyclic transfers,
  atc_complete_all - finish work for all transactions
  @atchan: channel to complete transactions for
  Eventually submit queued descriptors if any
  Assume channel is idle while calling this function
  Called with atchan->lock held and bh disabled
	
	  Submit queued descriptors ASAP, i.e. before we go through
	  the completed ones.
 empty active_list now it is completed 
 empty queue list by moving descriptors (if any) to active_list 
  atc_advance_work - at the end of a transaction, move forward
  @atchan: channel where the transaction ended
 advance work 
  atc_handle_error - handle errors reported by DMA controller
  @atchan: channel where error occurs
	
	  The descriptor currently at the head of the active list is
	  broked. Since we don't have any way to report errors, we'll
	  just have to scream loudly and try to carry on.
	 As we are stopped, take advantage to push queued descriptors
 Try to restart the controller 
	
	  KERN_CRITICAL may seem harsh, but since this only happens
	  when someone submits a bad physical address in a
	  descriptor, we should consider ourselves lucky that the
	  controller flagged an error instead of scribbling over
	  random memory locations.
 Pretend the descriptor completed successfully 
  atc_handle_cyclic - at the end of a period, run callback function
  @atchan: channel used for cyclic operations
--  IRQ & Tasklet  ---------------------------------------------------
 Disable channel on AHB error 
 Give information to tasklet 
--  DMA Engine API  --------------------------------------------------
  atc_tx_submit - set the prepared descriptor(s) to be executed by the engine
  @tx: descriptor at the head of the transaction chain
  Queue chain if DMA engine is working already
  Cookie increment and adding to active_list or queue must be atomic
  atc_prep_dma_interleaved - prepare memory to memory interleaved operation
  @chan: the channel to prepare operation on
  @xt: Interleaved transfer template
  @flags: tx descriptor status flags
	
	  The controller can only "skip" X bytes every Y bytes, so we
	  need to make sure we are given a template that fit that
	  description, ie a template with chunks that always have the
	  same size, with the same ICGs.
 create the transfer 
 set end-of-link to the last link descriptor of list
 client is in control of this ack 
  atc_prep_dma_memcpy - prepare a memcpy operation
  @chan: the channel to prepare operation on
  @dest: operation virtual destination address
  @src: operation virtual source address
  @len: operation length
  @flags: tx descriptor status flags
	
	  We can be a lot more clever here, but this should take care
	  of the most common optimization.
 First descriptor of the chain embedds additional information 
 set end-of-link to the last link descriptor of list
 client is in control of this ack 
  atc_prep_dma_memset - prepare a memcpy operation
  @chan: the channel to prepare operation on
  @dest: operation virtual destination address
  @value: value to set memory buffer to
  @len: operation length
  @flags: tx descriptor status flags
 set end-of-link on the descriptor 
	
	  Only set the buffer pointers on the last descriptor to
	  avoid free'ing while we have our transfer still going
 set end-of-link on the descriptor 
  atc_prep_slave_sg - prepare descriptors for a DMA_SLAVE transaction
  @chan: DMA channel
  @sgl: scatterlist to transfer tofrom
  @sg_len: number of entries in @scatterlist
  @direction: DMA direction
  @flags: tx descriptor status flags
  @context: transaction context (ignored)
 set end-of-link to the last link descriptor of list
 First descriptor of the chain embedds additional information 
 first link descriptor of list is responsible of flags 
 client is in control of this ack 
  atc_dma_cyclic_check_values
  Check for too bigunaligned periods and unaligned DMA buffer
  atc_dma_cyclic_fill_desc - Fill one period descriptor
 prepare common CRTLA value 
  atc_prep_dma_cyclic - prepare the cyclic DMA transfer
  @chan: the DMA channel to prepare
  @buf_addr: physical DMA address where the buffer starts
  @buf_len: total number of bytes for the entire buffer
  @period_len: number of bytes for each period
  @direction: transfer direction, to or from device
  @flags: tx descriptor status flags
 Check for too bigunaligned periods and unaligned DMA buffer 
 build cyclic linked list 
 lets make a cyclic list 
 First descriptor of the chain embedds additional information 
 Check if it is chan is configured for slave transfers 
	
	  This is only called when something went wrong elsewhere, so
	  we don't really care about the data. Just disable the
	  channel. We still have to poll the channel enable bit due
	  to AHBHSB limitations.
 disabling channel: must also remove suspend state 
 confirm that this channel is disabled 
 active_list entries will end up before queued entries 
 Flush all pending and queued descriptors 
 if channel dedicated to cyclic operations, free it 
  atc_tx_status - poll for transaction completion
  @chan: DMA channel
  @cookie: transaction identifier to check status of
  @txstate: if not %NULL updated with transaction state
  If @txstate is passed in, upon return it reflect the driver
  internal state and can be used with dma_async_is_complete() to check
  the status of multiple cookies without re-checking hardware state.
	
	  There's no point calculating the residue if there's
	  no txstate to store the value.
  Get number of bytes left in the active transactions 
  atc_issue_pending - try to finish work
  @chan: target DMA channel
 Not needed for cyclic transfers 
  atc_alloc_chan_resources - allocate resources for DMA channel
  @chan: allocate descriptor resources for this channel
  return - the number of allocated descriptors
 ASSERT:  channel is idle 
		
		  We need controller-specific data to set up slave
		  transfers.
 if cfg configuration specified take it instead of default 
 Allocate initial pool of descriptors 
 channel parameters 
  atc_free_chan_resources - free all channel resources
  @chan: DMA channel
 ASSERT:  channel is idle 
 free link descriptor 
	
	  Free atslave allocated in at_dma_xlate()
	
	  We can fill both SRC_PER and DST_PER, one of these fields will be
	  ignored depending on DMA transfer direction.
	
	  We have to translate the value we get from the device tree since
	  the half FIFO configuration value had to be 0 to keep backward
	  compatibility.
--  Module Management  -----------------------------------------------
 cap_mask is a multi-u32 bitfield, fill it with proper C code. 
 sentinel 
 sentinel 
  at_dma_off - disable DMA controller
  @atdma: the Atmel HDAMC device
 disable all interrupts 
 confirm that all channels are disabled 
 setup platform data for each SoC 
 get DMA parameters from controller type 
 discover transaction capabilities 
 force dma off, just in case 
 create a pool of consistent memory blocks for hardware descriptors 
 word alignment , 0);
 create a pool of consistent memory blocks for memset blocks 
 clear any pending interrupt 
 initialize channels related values 
 set base routines 
 set prep routines based on capability 
 controller can do slave DMA: can trigger cyclic transfers 
	
	  Do not return an error if the dmac node is not present in order to
	  not break the existing way of requesting channel with
	  dma_request_channel().
 Disable interrupts 
 wait for transaction completion (except in cyclic case) 
	 Channel should be paused by user
 now preserve additional data for cyclic operations 
 next descriptor address in the cyclic list 
 preserve data 
 disable DMA controller 
	 restore channel status for cyclic descriptors list:
	 channel pause status should be removed by channel user
 bring back DMA controller 
 clear any pending interrupt 
 restore saved data 
 SPDX-License-Identifier: GPL-2.0-or-later
  Freescale MPC85xx, MPC83xx DMA Engine support
  Copyright (C) 2007-2010 Freescale Semiconductor, Inc. All rights reserved.
  Author:
    Zhang Wei <wei.zhang@freescale.com>, Jul 2007
    Ebony Zhu <ebony.zhu@freescale.com>, May 2007
  Description:
    DMA engine driver for Freescale MPC8540 DMA controller, which is
    also fit for MPC8560, MPC8555, MPC8548, MPC8641, and etc.
    The support for MPC8349 DMA controller is also added.
  This driver instructs the DMA controller to issue the PCI Read Multiple
  command for PCI read operations, instead of using the default PCI Read Line
  command. Please be aware that this setting may result in read pre-fetching
  on some platforms.
  Register Helpers
  Descriptor Helpers
  DMA Engine Hardware Control Helpers
 Reset the channel 
		 Set the channel to below modes:
		  EIE - Error interrupt enable
		  EOLNIE - End of links interrupt enable
		  BWC - Bandwidth sharing among channels
		 Set the channel to below modes:
		  EOTIE - End-of-transfer interrupt enable
		  PRC_RM - PCI read multiple
  Start the DMA controller
  Preconditions:
  - the CDAR register must point to the start descriptor
  - the MRn[CS] bit must be cleared
 read the mode register 
	
	  The 85xx controller supports channel abort, which will stop
	  the current transfer. On 83xx, this bit is the transfer error
	  mask bit, which should not be changed.
 stop the DMA controller 
 wait for the DMA controller to become idle 
  fsl_chan_set_src_loop_size - Set source address hold transfer size
  @chan : Freescale DMA channel
  @size     : Address loop size, 0 for disable loop
  The set source address hold transfer size. The source
  address hold or loop transfer size is when the DMA transfer
  data from source address (SA), if the loop size is 4, the DMA will
  read data from SA, SA + 1, SA + 2, SA + 3, then loop back to SA,
  SA + 1 ... and so on.
  fsl_chan_set_dst_loop_size - Set destination address hold transfer size
  @chan : Freescale DMA channel
  @size     : Address loop size, 0 for disable loop
  The set destination address hold transfer size. The destination
  address hold or loop transfer size is when the DMA transfer
  data to destination address (TA), if the loop size is 4, the DMA will
  write data to TA, TA + 1, TA + 2, TA + 3, then loop back to TA,
  TA + 1 ... and so on.
  fsl_chan_set_request_count - Set DMA Request Count for external control
  @chan : Freescale DMA channel
  @size     : Number of bytes to transfer in a single request
  The Freescale DMA channel can be controlled by the external signal DREQ#.
  The DMA request count is how many bytes are allowed to transfer before
  pausing the channel, after which a new assertion of DREQ# resumes channel
  operation.
  A size of 0 disables external pause control. The maximum size is 1024.
  fsl_chan_toggle_ext_pause - Toggle channel external pause status
  @chan : Freescale DMA channel
  @enable   : 0 is disabled, 1 is enabled.
  The Freescale DMA channel can be controlled by the external signal DREQ#.
  The DMA Request Count feature should be used in addition to this feature
  to set the number of bytes to transfer before pausing the channel.
  fsl_chan_toggle_ext_start - Toggle channel external start status
  @chan : Freescale DMA channel
  @enable   : 0 is disabled, 1 is enabled.
  If enable the external start, the channel can be started by an
  external DMA start pin. So the dma_start() does not start the
  transfer immediately. The DMA channel will wait for the
  control pin asserted.
	
	  Add the hardware descriptor to the chain of hardware descriptors
	  that already exists in memory.
	 
	  This will un-set the EOL bit of the existing transaction, and the
	  last link in this transaction will become the EOL descriptor.
	
	  Add the software descriptor and all children to the list
	  of pending transactions
	
	  assign cookies to all of the software descriptors
	  that make up this transaction
 put this transaction onto the tail of the pending queue 
  fsl_dma_free_descriptor - Free descriptor from channel's DMA pool.
  @chan : Freescale DMA channel
  @desc: descriptor to be freed
  fsl_dma_alloc_descriptor - Allocate descriptor from channel's DMA pool.
  @chan : Freescale DMA channel
  Return - The descriptor allocated. NULL for failed.
  fsldma_clean_completed_descriptor - free all descriptors which
  has been completed and acked
  @chan: Freescale DMA channel
  This function is used on all completed and acked descriptors.
  All descriptors should only be freed in this function.
 Run the callback for each descriptor, in order 
  fsldma_run_tx_complete_actions - cleanup a single link descriptor
  @chan: Freescale DMA channel
  @desc: descriptor to cleanup and free
  @cookie: Freescale DMA transaction identifier
  This function is used on a descriptor which has been executed by the DMA
  controller. It will run any callbacks, submit any dependencies.
 Run the link descriptor callback function 
 Run any dependencies 
  fsldma_clean_running_descriptor - move the completed descriptor from
  ld_running to ld_completed
  @chan: Freescale DMA channel
  @desc: the descriptor which is completed
  Free the descriptor directly if acked by async_tx api, or move it to
  queue ld_completed.
 Remove from the list of transactions 
	
	  the client is allowed to attach dependent operations
	  until 'ack' is set
		
		  Move this descriptor to the list of descriptors which is
		  completed, but still awaiting the 'ack' bit to be set.
  fsl_chan_xfer_ld_queue - transfer any pending transactions
  @chan : Freescale DMA channel
  HARDWARE STATE: idle
  LOCKING: must hold chan->desc_lock
	
	  If the list of pending descriptors is empty, then we
	  don't need to do any work at all
	
	  The DMA controller is not idle, which means that the interrupt
	  handler will start any queued transactions when it runs after
	  this transaction finishes
	
	  If there are some link descriptors which have not been
	  transferred, we need to start the controller
	
	  Move all elements from the queue of pending transactions
	  onto the list of running transactions
	
	  The 85xx DMA controller doesn't clear the channel start bit
	  automatically at the end of a transfer. Therefore we must clear
	  it in software before starting the transfer.
	
	  Program the descriptor's address into the DMA controller,
	  then start the DMA transaction
  fsldma_cleanup_descriptors - cleanup link descriptors which are completed
  and move them to ld_completed to free until flag 'ack' is set
  @chan: Freescale DMA channel
  This function is used on descriptors which have been executed by the DMA
  controller. It will run any callbacks, submit any dependencies, then
  free these descriptors if flag 'ack' is set.
 Run the callback for each descriptor, in order 
		
		  do not advance past the current descriptor loaded into the
		  hardware channel, subsequent descriptors are either in
		  process or have not been submitted
		
		  stop the search if we reach the current descriptor and the
		  channel is busy
	
	  Start any pending transactions automatically
	 
	  In the ideal case, we keep the DMA controller busy while we go
	  ahead and free the descriptors below.
  fsl_dma_alloc_chan_resources - Allocate resources for DMA channel.
  @chan : Freescale DMA channel
  This function will create a dma pool for descriptor allocation.
  Return - The number of descriptors allocated.
 Has this channel already been allocated? 
	
	  We need the descriptor to be aligned to 32bytes
	  for meeting FSL DMA specification requirement.
 there is at least one descriptor free to be allocated 
  fsldma_free_desc_list - Free all descriptors in a queue
  @chan: Freescae DMA channel
  @list: the list to free
  LOCKING: must hold chan->desc_lock
  fsl_dma_free_chan_resources - Free all resources of the channel.
  @chan : Freescale DMA channel
 Allocate the link descriptor from DMA pool 
 Insert the link descriptor to the LD ring 
 client is in control of this ack 
 Set End-of-link to the last link descriptor of new list 
 Halt the DMA engine 
 Remove and free all of the descriptors in the LD queue 
 make sure the channel supports setting burst size 
 we set the controller burst size depending on direction 
  fsl_dma_memcpy_issue_pending - Issue the DMA start command
  @chan : Freescale DMA channel
  fsl_tx_status - Determine the DMA status
  @chan : Freescale DMA channel
----------------------------------------------------------------------------
 Interrupt Handling                                                         
----------------------------------------------------------------------------
 save and clear the status register 
 check that this was really our device 
	
	  Programming Error
	  The DMA_INTERRUPT async_tx is a NULL transfer, which will
	  trigger a PE interrupt.
	
	  For MPC8349, EOCDI event need to update cookie
	  and start the next transfer if it exist.
	
	  If it current transfer is the end-of-transfer,
	  we should clear the Channel Start bit for
	  prepare next transfer.
 check that the DMA controller is really idle 
 check that we handled all of the bits 
	
	  Schedule the tasklet to handle all cleanup of the current
	  transaction. It will start a new transaction if there is
	  one pending.
 the hardware is now idle and ready for more 
 Run all cleanup for descriptors which have been completed 
 if we have a per-controller IRQ, use that 
 no per-controller IRQ, use the per-channel IRQs 
 none ; i >= 0; i--) {
----------------------------------------------------------------------------
 OpenFirmware Subsystem                                                     
----------------------------------------------------------------------------
 alloc channel 
 ioremap registers for use 
	
	  If the DMA device's feature is different than the feature
	  of its channels, report the bug
 Initialize the channel 
 Clear cdar registers 
 find the IRQ line, if it exists in the device tree 
 Add the channel to DMA device channel list 
 ioremap the registers for use 
 map the channel IRQ if it exists, but don't hookup the handler yet 
	
	  We cannot use of_platform_bus_probe() because there is no
	  of_platform_bus_remove(). Instead, we manually instantiate every DMA
	  channel object.
	
	  Hookup the IRQ handler(s)
	 
	  If we have a per-controller interrupt, we prefer that to the
	  per-channel interrupts to reduce the number of shared interrupt
	  handlers on the same IRQ line
----------------------------------------------------------------------------
 Module Init  Exit                                                         
----------------------------------------------------------------------------
  driversdmafsl_raid.c
  Freescale RAID Engine device driver
  Author:
 	Harninder Rai <harninder.rai@freescale.com>
 	Naveen Burmi <naveenburmi@freescale.com>
  Rewrite:
 	Xuelin Shi <xuelin.shi@freescale.com>
  Copyright (c) 2010-2014 Freescale Semiconductor, Inc.
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
       Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
       Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation andor other materials provided with the distribution.
       Neither the name of Freescale Semiconductor nor the
        names of its contributors may be used to endorse or promote products
        derived from this software without specific prior written permission.
  ALTERNATIVELY, this software may be distributed under the terms of the
  GNU General Public License ("GPL") as published by the Free Software
  Foundation, either version 2 of that License or (at your option) any
  later version.
  THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  Theory of operation:
  General capabilities:
 	RAID Engine (RE) block is capable of offloading XOR, memcpy and PQ
 	calculations required in RAID5 and RAID6 operations. RE driver
 	registers with Linux's ASYNC layer as dma driver. RE hardware
 	maintains strict ordering of the requests through chained
 	command queueing.
  Data flow:
 	Software RAID layer of Linux (MD layer) maintains RAID partitions,
 	strips, stripes etc. It sends requests to the underlying ASYNC layer
 	which further passes it to RE driver. ASYNC layer decides which request
 	goes to which job ring of RE hardware. For every request processed by
 	RAID Engine, driver gets an interrupt unless coalescing is set. The
 	per job ring interrupt handler checks the status register for errors,
 	clears the interrupt and leave the post interrupt processing to the irq
 	thread.
 Add descriptors into per chan software queue - submit_q 
 Copy descriptor from per chan software queue into hardware job ring 
 compare the hw dma addr to find the completed 
 Per Job Ring interrupt handler 
	
	  There's no way in upper layer (read MD layer) to recover from
	  error conditions except restart everything. In long term we
	  need to do something more than just crashing
 Clear interrupt 
 take one desc from free_q 
 Filling xor CDB 
 compute q = src0coef0^src1coef1^...,  is GF(8) mult 
 compute P, that is XOR all srcs 
 Filling frame 0 of compound frame descriptor with CDB 
 Fill CFD's 1st frame with dest buffer 
 Fill CFD's rest of the frames with source buffers 
 Setting the final bit in the last source buffer frame in CFD 
  Prep function for P parity calculation.In RAID Engine terminology,
  XOR calculation is called GenQ calculation done through GenQ command
 NULL let genq take all coef as 1 
  Prep function for PQ parity calculation.In RAID Engine terminology,
  PQ calculation is called GenQQ done through GenQQ command
	
	  RE requires at least 2 sources, if given only one source, we pass the
	  second source same as the first one.
	  With only one source, generating P is meaningless, only generate Q.
	
	  During RAID6 array creation, Linux's MD layer gets P and Q
	  calculated separately in two steps. But our RAID Engine has
	  the capability to calculate both P and Q with a single command
	  Hence to merge well with MD layer, we need to provide a hook
	  here and call re_jq_prep_dma_genq() function
 Filling GenQQ CDB 
 Init gfm_q1[] 
 Align gfm[] to 32bit 
 Init gfm_q2[] 
 Filling frame 0 of compound frame descriptor with CDB 
 Fill CFD's 1st & 2nd frame with dest buffers 
 Fill CFD's rest of the frames with source buffers 
 PQ computation continuation 
 Setting the final bit in the last source buffer frame in CFD 
  Prep function for memcpy. In RAID Engine, memcpy is done through MOVE
  command. Logic of this function will need to be modified once multipage
  support is added in Linux's MDASYNC Layer
 Filling move CDB 
 Filling frame 0 of CFD with move CDB 
 Fill CFD's 1st frame with dest buffer 
 Fill CFD's 2nd frame with src buffer 
 create platform device for chan node 
 read reg property from dts 
 read irq property from dts 
 Program the InboundOutbound ring base addresses and size 
 Read LIODN value from u-boot 
 Program the CFG reg 
 Enable RECHAN 
 Probe function for RAID Engine 
 IOMAP the entire RAID Engine region 
 Program the RE mode 
 Program Galois Field polynomial 
 Parse Device tree to find out the total number of JQs present 
 Find out the Job Rings present under each JQ 
 Cleanup chan related memory areas 
 Unregister the driver 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright(c) 2019 HiSilicon Limited. 
 update other field in sqe 
 make sure data has been updated in sqe 
 update sq tail, point to new sqe position 
 update sq_tail to trigger a new task 
 set sq, cq base 
 set sq, cq depth 
 init sq tail and cq head 
 This function enables all hw channels in a device 
 This will be freed by 'pcim_release()'. See 'pcim_enable_device()' 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018-2019 Synopsys, Inc. andor its affiliates.
  Synopsys DesignWare eDMA v0 core
  Author: Gustavo Pimentel <gustavo.pimentel@synopsys.com>
 eDMA global registers 
 eDMA interrupts registers 
 eDMA channel context grouping 
 eDMA global registers 
 eDMA interrupts registers 
 eDMA channel context grouping 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018-2019 Synopsys, Inc. andor its affiliates.
  Synopsys DesignWare eDMA v0 core
  Author: Gustavo Pimentel <gustavo.pimentel@synopsys.com>
 CONFIG_64BIT 
 CONFIG_64BIT 
 eDMA management callbacks 
 Channel control 
 Transfer size 
 SAR 
 CONFIG_64BIT 
 CONFIG_64BIT 
 DAR 
 CONFIG_64BIT 
 CONFIG_64BIT 
 Channel control 
 Linked list 
 CONFIG_64BIT 
 CONFIG_64BIT 
 Enable engine 
 Interrupt unmask - done, abort 
 Linked list error 
 Channel control 
 Linked list 
 CONFIG_64BIT 
 CONFIG_64BIT 
 Doorbell 
 MSI done addr - low, high 
 MSI abort addr - low, high 
 MSI data - low, high 
 Channel odd {1, 3, 5, 7} 
 Channel even {0, 2, 4, 6} 
 eDMA debugfs callbacks 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018-2019 Synopsys, Inc. andor its affiliates.
  Synopsys DesignWare eDMA core driver
  Author: Gustavo Pimentel <gustavo.pimentel@synopsys.com>
 Create and add new element into the linked list 
 List head 
	 Toggling change bit (CB) in each chunk, this is a mechanism to
	  inform the eDMA HW block that this is a new linked list ready
	  to be consumed.
	   - Odd chunks originate CB equal to 0
	   - Even chunks originate CB equal to 1
 Create and add new element into the linked list 
 List head 
 Remove all the list elements 
 Remove the list head 
 Remove all the list elements 
 Remove the list head 
 Do nothing 
		
		  The channel is in a false BUSY state, probably didn't
		  receive or lost an interrupt
 local DMA 
 local DMA 
 remote DMA 
				 Unlike the typical assumption by other
				  driversIPs the peripheral memory isn't
				  a FIFO memory, in this case, it's a
				  linear memory and that why the source
				  and destination addresses are increased
				  by the same portion (data length)
				 Unlike the typical assumption by other
				  driversIPs the peripheral memory isn't
				  a FIFO memory, in this case, it's a
				  linear memory and that why the source
				  and destination addresses are increased
				  by the same portion (data length)
 Set DMA channel capabilities 
 Set DMA channel callbacks 
 Register DMA device 
 Common IRQ shared among all channels 
 Distribute IRQs equally among all channels 
 Allocate channels 
 Disable eDMA, only to establish the ideal initial conditions 
 Request IRQs 
 Setup write channels 
 Setup read channels 
 Power management 
 Turn debugfs on 
 Disable eDMA 
 Free irqs 
 Power management 
 Deregister eDMA device 
 Turn debugfs off 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018-2019 Synopsys, Inc. andor its affiliates.
  Synopsys DesignWare eDMA PCIe driver
  Author: Gustavo Pimentel <gustavo.pimentel@synopsys.com>
 eDMA registers location 
 eDMA memory linked list location 
 eDMA memory data location 
 Other 
 eDMA registers location 
  4 Kbytes 
  8 Kbytes 
 eDMA memory linked list location 
 Channel 0 - BAR 2, offset 0 Mbytes, size 2 Kbytes 
 Channel 1 - BAR 2, offset 2 Mbytes, size 2 Kbytes 
 Channel 0 - BAR 2, offset 4 Mbytes, size 2 Kbytes 
 Channel 1 - BAR 2, offset 6 Mbytes, size 2 Kbytes 
 eDMA memory data location 
 Channel 0 - BAR 2, offset 8 Mbytes, size 2 Kbytes 
 Channel 1 - BAR 2, offset 9 Mbytes, size 2 Kbytes 
 Channel 0 - BAR 2, offset 10 Mbytes, size 2 Kbytes 
 Channel 1 - BAR 2, offset 11 Mbytes, size 2 Kbytes 
 Other 
 Enable PCI device 
	
	  Tries to find if exists a PCIe Vendor-Specific Extended Capability
	  for the DMA, if one exists, then reconfigures it.
 Mapping PCI BAR regions 
 DMA configuration 
 Data structure allocation 
 IRQs allocation 
 Data structure initialization 
 Debug info 
 Validating if PCI interrupts were enabled 
 Starting eDMA driver 
 Saving data structure reference 
 Stopping eDMA driver 
 Freeing IRQs 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
  Copyright (c) 2020, Linaro Limited
 TRE flags 
 SPI CONFIG0 WD0 
 CONFIG0 WD2 
 SPI GO WD0 
 GO WD2 
 I2C Config0 WD0 
 I2C GO WD0 
 DMA TRE 
 Register offsets from gpi-top 
 EV Context Array 
 mask type register 
 Mask channel control interrupt register 
 Mask event control interrupt register 
 Mask event interrupt register 
 GPII specific Global - Enable bit register 
 GPII general interrupt - Enable bit register 
 GPII Interrupt Type register 
 QOS Registers 
 Scratch registers 
 # of arguments required from client 
  @DISABLE_STATE: no register access allowed
  @CONFIG_STATE:  client has configured the channel
  @PREP_HARDWARE: register access is allowed
 		   however, no processing EVENTS
  @ACTIVE_STATE: channels are fully operational
  @PREPARE_TERMINATE: graceful termination of channels
 		       register access is allowed
  @PAUSE_STATE: channels are active, but not processing any events
ee register base address
 maximum # of gpii instances available per gpi block 
 gpii instances available for apps 
 ev ring length factor 
 points to gpi top 
 event processing tasklet 
 DB register to program 
 gpi_write_reg_field - write to specific bit field 
 configure and enable interrupts 
		
		  GPII only uses one EV ring per gpii so we can globally
		  enabledisable IEOB interrupt
 Sends gpii event or channel command 
 send opcode and wait for completion 
 confirm new ch state is correct , if the cmd is a state change cmd 
 program transfer ring DB register 
 program event ring DB register 
 process transfer completion interrupt 
 process channel control interrupt 
 clear the status 
		
		  CH_CMD_DEALLOC cmd always successful. However cmd does
		  not change hardware status. So overwriting software state
		  to default state.
		
		  Triggering complete all if ch_state is not a stop in process.
		  Stop in process is a transition state and we will wait for
		  stop interrupt before notifying.
 processing gpi general error interrupts 
 clear the status 
 Clear the register 
 processing gpi level error interrupts 
 only error interrupt should be set 
 gpii interrupt handler 
	
	  States are out of sync to receive interrupt
	  while software state is in DISABLE state, bailing out.
 global gpii error 
 transfer complete interrupt 
 event control irq 
			
			  CMD EV_CMD_DEALLOC is always successful. However
			  cmd does not change hardware status. So overwriting
			  software state to default state.
 channel control irq 
 process DMA Immediate completion data events 
	
	  If channel not active don't process event
	
	  RP pointed by Event is to last TRE processed,
	  we need to update ring rp to tre + 1
 make sure rp updates are immediately visible to all cores 
 processing transfer completion events 
 only process events on active channel 
	
	  RP pointed by Event is to last TRE processed,
	  we need to update ring rp to ev_rp + 1
 update must be visible to other cores 
 process all events 
 clear pending IEOB events 
 processing events using tasklet 
 process the events 
 enable IEOB, switching back to interrupts 
 marks all pending events for the channel as stale 
 reset sw state and issue channel reset or de-alloc 
 initialize the local ring ptrs 
 visible to other cores 
 check event ring for any stale events 
 remove all async descriptors 
 gpii CH is active now 
 allocate and configure the transfer channel 
 flush all the writes 
 allocate and configure event ring 
 program event context 
 add events to ring 
 flush all the writes 
 gpii is active now 
 calculate # of ERETRE available to queue 
 visible to other cores 
 Update the WP 
 Update the RP 
 visible to other cores 
 allocate memory for transfer and event rings 
 ring len must be power of 2 
 align the physical mem 
 update to other cores 
 copy tre into transfer ring 
 get next tre location we can copy 
 copy the tre info 
 reset and restart transfer channel 
	
	  treat both channels as a group if its protocol is not UART
	  STOP, RESET, or START needs to be in lockstep
 stop the channel 
 disable ch state so no more TRE processing 
 send command to Stop the channel 
 reset the channels (clears any pending tre) 
 reprogram channel CNTXT 
 restart the channels 
 pause dma transfer for all channels 
	
	  pauseresume are per gpii not per channel, so
	  client needs to call pause only once
 send stop command to stop the channels 
 Wait for threads to complete out 
 resume dma transfer 
 send start command to start the channels 
 first create config tre if applicable 
 create the GO tre for Tx 
 create the DMA TRE 
 first create config tre if applicable 
 create the GO tre for Tx 
 create the dma tre 
 copy tre into transfer ring 
 rx 
 calculate # of elements required & available 
 create TREs for xfer 
 set up the descriptor 
 rings transfer ring db to being transfer 
 move all submitted discriptors to issued list 
 nothing to do list is empty 
 check if both channels are configured before continue 
 protocol must be same for both channels 
 allocate memory for event ring 
 configure interrupts 
 allocate event rings 
 Allocate all channels 
 start channels  
 release all channel resources 
 disable ch state so no more TRE processing for this channel 
 attempt to do graceful hardware shutdown 
 free all allocated memory 
 if other rings are still active exit 
 deallocate EV Ring 
 wait for threads to complete out 
 send command to de allocate event ring 
 disable interrupts 
 set final state to disable 
 allocate channel resources 
 allocate memory for transfer ring 
 check if same seid is already configured for another chid 
 no channels configured with same seid, return next avail gpii 
 check if gpii is configured 
 found a free gpii 
 no gpii instance available to use 
 gpi_of_dma_xlate: open client requested channel 
 find next available gpii to use 
 setup all the supported gpii 
 set up ev cntxt register map 
 set up irq 
 set up channel specific register info 
 set up ch cntxt register map 
 vchan setup 
 clear and Set capabilities 
 configure dmaengine apis 
 register with dmaengine framework 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
  QCOM BAM DMA engine driver
  QCOM BAM DMA blocks are distributed amongst a number of the on-chip
  peripherals on the MSM 8x74.  The configuration of the channels are dependent
  on the way they are hard wired to that specific peripheral.  The peripheral
  device tree entries specify the configuration of each channel.
  The DMA controller requires the use of external memory for storage of the
  hardware descriptors for each channel.  The descriptor FIFO is accessed as a
  circular buffer and operations are managed according to the offset within the
  FIFO.  After pipechannel reset, all of the pipe registers and internal state
  are back to defaults.
  During DMA operations, we write descriptors to the FIFO, being careful to
  handle wrapping and then write the last FIFO offset to that channel's
  P_EVNT_REG register to kick off the transaction.  The P_SW_OFSTS register
  indicates the current FIFO offset that is being processed, so there is some
  indication of where the hardware is currently working.
 Buffer physical address 
 Buffer size in bytes 
 transaction flags, EOT|EOB|NWD 
 list node for the desc in the bam_chan list of descriptors 
 BAM CTRL 
 BAM REVISION 
 BAM NUM PIPES 
 BAM CNFG BITS 
 PIPE CTRL 
 BAM_DESC_CNT_TRSHLD 
 BAM_IRQ_SRCS 
 BAM_IRQ_SRCS_MSK 
 BAM_IRQ_STTS 
 BAM_IRQ_CLR 
 BAM_IRQ_EN 
 BAM_P_IRQ_EN 
 BAM_P_SW_OFSTS 
 configuration from device tree 
 runtime configuration 
 fifo storage 
 fifo markers 
 start of active descriptor entries 
 end of active descriptor entries 
 is the channel hw initialized? 
 is the channel paused? 
 new slave config? 
 list of descriptors currently processed 
 execution environment ID, from DT 
 dma start transaction tasklet 
  bam_addr - returns BAM register address
  @bdev: bam device
  @pipe: pipe instance (ignored when register doesn't have multiple instances)
  @reg:  register enum
  bam_reset() - reset and initialize BAM registers
  @bdev: bam device
 sw reset bam 
 after reset all pipes are disabled and idle 
 make sure previous stores are visible before enabling BAM 
 enable bam 
 set descriptor threshhold, start with 4 bytes 
 Enable default set of hw workarounds, ie all except BAM_FULL_PIPE 
 enable irqs for errors 
 unmask global bam interrupt 
  bam_reset_channel - Reset individual BAM DMA channel
  @bchan: bam channel
  This function resets a specific BAM channel
 reset channel 
 don't allow cpu to reorder BAM register accesses done after this 
 make sure hw is initialized when channel is used the first time  
  bam_chan_init_hw - Initialize channel hardware
  @bchan: bam channel
  @dir: DMA transfer direction
  This function resets and initializes the BAM channel
 Reset the channel to clear internal state of the FIFO 
	
	  write out 8 byte aligned address.  We have enough space for this
	  because we allocated 1 more descriptor (8 bytes) than we can use
 enable the per pipe interrupts, enable EOT, ERR, and INT irqs 
 unmask the specific pipe and EE combo 
 don't allow cpu to reorder the channel enable done below 
 set fixed direction and mode, then enable channel 
 init FIFO pointers 
  bam_alloc_chan - Allocate channel resources for DMA channel.
  @chan: specified channel
  This function allocates the FIFO descriptor memory
 allocate FIFO descriptor space, but only if necessary 
  bam_free_chan - Frees dma resources associated with specific channel
  @chan: specified channel
  Free the allocated fifo descriptor memory and channel resources
 mask irq for pipechannel 
 disable irq 
 sw reset bam 
  bam_slave_config - set slave configuration for channel
  @chan: dma channel
  @cfg: slave configuration
  Sets slave configuration for channel
  bam_prep_slave_sg - Prep slave sg transaction
  @chan: dma channel
  @sgl: scatter gather list
  @sg_len: length of sg
  @direction: DMA transfer direction
  @flags: DMA flags
  @context: transfer context (unused)
 calculate number of required entries 
 allocate enough room to accomodate the number of entries 
 fill in temporary descriptors 
  bam_dma_terminate_all - terminate all transactions on a channel
  @chan: bam dma channel
  Dequeues and frees all transactions
  No callbacks are done
 remove all transactions, including active transaction 
	
	  If we have transactions queued, then some might be committed to the
	  hardware in the desc fifo.  The only way to reset the desc fifo is
	  to do a hardware reset (either by pipe or the entire block).
	  bam_chan_init_hw() will trigger a pipe reset, and also reinit the
	  pipe.  If the pipe is left disabled (default state after pipe reset)
	  and is accessed by a connected hardware engine, a fatal error in
	  the BAM will occur.  There is a small window where this could happen
	  with bam_chan_init_hw(), but it is assumed that the caller has
	  stopped activity on any attached hardware engine.  Make sure to do
	  this first so that the BAM hardware doesn't cause memory corruption
	  by accessing freed resources.
  bam_pause - Pause DMA channel
  @chan: dma channel
  bam_resume - Resume DMA channel operations
  @chan: dma channel
  process_channel_irqs - processes the channel interrupts
  @bdev: bam controller
  This function processes the channel interrupts
 return early if no pipechannel interrupts are present 
 clear pipe irq 
 Number of bytes available to read 
 Not enough data to read 
 manage FIFO 
			
			  if complete, process cookie. Otherwise
			  push back to front of desc_issued so that
			  it gets restarted by the tasklet
  bam_dma_irq - irq handler for bam controller
  @irq: IRQ of interrupt
  @data: callback data
  IRQ handler for the bam controller
 kick off tasklet to start next dma transfer 
		
		  don't allow reorder of the various accesses to the BAM
		  registers
  bam_tx_status - returns status of transaction
  @chan: dma channel
  @cookie: transaction cookie
  @txstate: DMA transaction state
  Return status of dma transaction
  bam_apply_new_config
  @bchan: bam dma channel
  @dir: DMA direction
  bam_start_dma - start next transaction
  @bchan: bam dma channel
 on first use, initialize the channel hardware 
 apply new slave config changes, if necessary 
 set any special flags on the last descriptor 
		
		  An interrupt is generated at this desc, if
		   - FIFO is FULL.
		   - No more descriptors to add.
		   - If a callback completion was requested for this DESC,
		      In this case, BAM will deliver the completion callback
		      for this desc and continue processing the next desc.
 ensure descriptor writes and dma start not reordered 
  dma_tasklet - DMA IRQ tasklet
  @t: tasklet argument (bam controller structure)
  Sets up next DMA operation and then processes all completed transactions
 go through the channels and kick off transactions 
  bam_issue_pending - starts pending transactions
  @chan: dma channel
  Calls tasklet directly which in turn starts any pending transactions
 if work pending and idle, start a transaction 
  bam_dma_free_desc - free descriptor memory
  @vd: virtual descriptor
  bam_init
  @bdev: bam device
  Initialization helper for global bam registers
 read revision and configuration information 
 check that configured EE is within range 
 Reset BAM now if fully controlled locally 
 allocate and initialize channels 
 set max dma segment size 
 set capabilities 
 initialize dmaengine apis 
 mask all interrupts for this execution environment 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013-2015, The Linux Foundation. All rights reserved.
 ADM registers - calculated from channel number and security domain 
 channel status 
 channel result 
 channel conf 
 channel result conf 
 CRCI CTL 
 CI configuration 
 GP CTL 
 Command pointer list entry 
 Command list entry 
 parsed from DT 
 channel id 
  adm_free_chan - Frees dma resources associated with the specific channel
  @chan: dma channel
  Free all allocated descriptors associated with this channel
 free all queued descriptors 
  adm_get_blksize - Get block size from burst value
  @burst: Burst size of transaction
  adm_process_fc_descriptors - Process descriptors for flow controlled xfers
  @achan: ADM channel
  @desc: Descriptor memory pointer
  @sg: Scatterlist entry
  @crci: CRCI value
  @burst: Burst size of transaction
  @direction: DMA transfer direction
 if leftover bytes, do one single descriptor 
  adm_process_non_fc_descriptors - Process descriptors for non-fc xfers
  @achan: ADM channel
  @desc: Descriptor memory pointer
  @sg: Scatterlist entry
  @direction: DMA transfer direction
 set last command if this is the end of the whole transaction 
  adm_prep_slave_sg - Prep slave sg transaction
  @chan: dma channel
  @sgl: scatter gather list
  @sg_len: length of sg
  @direction: DMA transfer direction
  @flags: DMA flags
  @context: transfer context (unused)
	
	  get burst value from slave configuration
 if using flow control, validate burst and crci values 
 iterate through sgs and compute allocation size of structures 
 both command list entry and descriptors must be 8 byte aligned 
 init cmd list 
  adm_terminate_all - terminate all transactions on a channel
  @chan: dma channel
  Dequeues and frees all transactions, aborts current transaction
  No callbacks are done
 send flush command to terminate current transaction 
  adm_start_dma - start next transaction
  @achan: ADM dma channel
 write next command list out to the CMD FIFO 
 reset channel error 
 enable interrupts 
 set the crci block size if this transaction requires CRCI 
 make sure IRQ enable doesn't get reordered 
 write next command list out to the CMD FIFO 
  adm_dma_irq - irq handler for ADM controller
  @irq: IRQ of interrupt
  @data: callback data
  IRQ handler for the bam controller
 if no result present, skip 
 no valid results, skip 
 flag error if transaction was flushed or failed 
 kick off next DMA 
  adm_tx_status - returns status of transaction
  @chan: dma channel
  @cookie: transaction cookie
  @txstate: DMA transaction state
  Return status of dma transaction
	
	  residue is either the full length if it is in the issued list, or 0
	  if it is in progress.  We have no reliable way of determining
	  anything inbetween
  adm_issue_pending - starts pending transactions
  @chan: dma channel
  Issues all pending transactions and starts DMA
  adm_dma_free_desc - free descriptor memory
  @vd: virtual descriptor
 allocate and initialize channels 
 reset CRCIs 
 configure client interfaces 
 set capabilities 
 initialize dmaengine apis 
 mask IRQs for this channelEE pair 
 SPDX-License-Identifier: GPL-2.0-only
  Qualcomm Technologies HIDMA debug file
  Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
  hidma_chan_show: display HIDMA channel statistics
  Display the statistics for the current HIDMA virtual channel device.
  hidma_dma_show: display HIDMA device info
  Display the info for the current HIDMA device.
 walk through the virtual channel list 
 SPDX-License-Identifier: GPL-2.0-only
  Qualcomm Technologies HIDMA Management SYS interface
  Copyright (c) 2015, The Linux Foundation. All rights reserved.
 create each channel directory here 
 populate common parameters 
 populate parameters that are per channel 
 SPDX-License-Identifier: GPL-2.0-only
  Qualcomm Technologies HIDMA DMA engine low level code
  Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
 each EVRE is 16 bytes 
 need to have at least one empty spot in the queue 
 set IEOB 
  Multiple TREs may be queued and waiting in the pending queue.
 call the user if it has been read by the hardware 
	
	  Keep track of pending TREs that SW is expecting to receive
	  from HW. We got one now. Decrement our counter.
  Called to handle the interrupt for the channel.
  Return a positive number if TRE or EVRE were consumed on this run.
  Return a positive number if there are pending TREs or EVREs.
  Return 0 if there is nothing to consume or no pending TREsEVREs found.
	
	  By the time control reaches here the number of EVREs and TREs
	  may not match. Only consume the ones that hardware told us.
		
		  Read the new event descriptor written by the HW.
		  As we are processing the delivered events, other events
		  get queued to the SW for processing.
		
		  An error interrupt might have arrived while we are processing
		  the completed interrupt.
 record the last processed tre offset 
	
	  Delay 10ms after reset to allow DMA logic to quiesce.
	  Do a polled read up to 1ms and 10ms maximum.
	
	  Delay 10ms after reset to allow DMA logic to quiesce.
	  Do a polled read up to 1ms and 10ms maximum.
  The interrupt handler for HIDMA will try to consume as many pending
  EVRE from the event queue as possible. Each EVRE has an associated
  TRE that holds the user interface parameters. EVRE reports the
  result of the transaction. Hardware guarantees ordering between EVREs
  and TREs. We use last processed offset to figure out which TRE is
  associated with which EVRE. If two TREs are consumed by HW, the EVREs
  are in order in the event ring.
  This handler will do a one pass for consuming EVREs. Other EVREs may
  be delivered while we are working. It will try to consume incoming
  EVREs one more time and return.
  For unprocessed EVREs, hardware will trigger another interrupt until
  all the interrupt bits are cleared.
  Hardware guarantees that by the time interrupt is observed, all data
  transactions in flight are delivered to their respective places and
  are visible to the CPU.
  On demand paging for IOMMU is only supported for PCIe via PRI
  (Page Request Interface) not for HIDMA. All other hardware instances
  including HIDMA work on pinned DMA addresses.
  HIDMA is not aware of IOMMU presence since it follows the DMA API. All
  IOMMU latency will be built into the data movement time. By the time
  interrupt happens, IOMMU lookups + data movement has already taken place.
  While the first read in a typical PCI endpoint ISR flushes all outstanding
  requests traditionally to the destination, this concept does not apply
  here for this HW.
 Clear out pending interrupts 
 No further submissions. 
 Driver completes the txn and intimates the client.
	
	  Fine tuned for this HW...
	 
	  This ISR has been designed for this particular hardware. Relaxed
	  read and write accessors are used for performance reasons due to
	  interrupt delivery guarantees. Do not copy this code blindly and
	  expect that to work.
	 
	  Try to consume as many EVREs as possible.
		
		  Another interrupt might have arrived while we are
		  processing this one. Read the new cause.
 enable irqs 
 both channels have to be enabled before calling this function 
 copy the TRE into its location in the TRE ring 
  Note that even though we stop this channel if there is a pending transaction
  in flight it will complete and follow the callback. This request will
  prevent further requests to be made.
 The channel needs to be in working state 
	
	  Start the wait right after the suspend is confirmed.
	  Do a polled read up to 1ms and 10ms maximum.
	
	  Start the wait right after the suspend is confirmed
	  Delay up to 10ms after reset to allow DMA logic to quiesce.
 disable interrupts 
  Called during initialization and after an error condition
  to restore hardware state.
 disable interrupts 
 clear all pending interrupts 
	
	  Clear all pending interrupts again.
	  Otherwise, we observe reset complete interrupts.
 disable interrupts again after reset 
 configure interrupts 
 disable interrupts again after reset 
 support IRQ by default 
 clear all pending interrupts and enable them 
 need at least four TREs 
 need an extra space 
 the TRE ring has to be TRE_SIZE aligned 
 the EVRE ring has to be EVRE_SIZE aligned 
	
	  Clear all pending interrupts again.
	  Otherwise, we observe reset complete interrupts.
  Qualcomm Technologies HIDMA DMA engine interface
  Copyright (c) 2015-2017, The Linux Foundation. All rights reserved.
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 and
  only version 2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  Copyright (C) Freescale Semicondutor, Inc. 2007, 2008.
  Copyright (C) Semihalf 2009
  Copyright (C) Ilya Yanok, Emcraft Systems 2010
  Copyright (C) Alexander Popov, Promcontroller 2014
  Written by Piotr Ziecik <kosmo@semihalf.com>. Hardware description
  (defines, structures and comments) was taken from MPC5121 DMA driver
  written by Hongjun Chen <hong-jun.chen@freescale.com>.
  Approved as OSADL project by a majority of OSADL members and funded
  by OSADL membership fees in 2009;  for details see www.osadl.org.
  This program is free software; you can redistribute it andor modify it
  under the terms of the GNU General Public License as published by the Free
  Software Foundation; either version 2 of the License, or (at your option)
  any later version.
  This program is distributed in the hope that it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
  The full GNU General Public License is included in this distribution in the
  file called COPYING.
 Linux Foundation elects GPLv2 license only. 
  Default idle time is 2 seconds. This parameter can
  be overridden by changing the following
  sysbusplatformdevicesQCOM8061:<xy>powerautosuspend_delay_ms
  during kernel boot.
 process completed descriptors 
 Get all completed descriptors 
 Execute callbacks and run dependencies 
  Called once for each submitted descriptor.
  PM is locked once for each descriptor that is currently
  in execution.
 Delete from the active list, add to completed list 
 calculate the next running descriptor 
 PM will be released in hidma_callback function. 
  Submit descriptor to hardware.
  Lock the PM for each descriptor we are sending.
 Move descriptor to queued 
 Update cookie 
 Alloc descriptors for this channel 
 return the allocated descriptors 
 Get free descriptor 
 Place descriptor in prepared list 
 Get free descriptor 
 Place descriptor in prepared list 
 give completed requests a chance to finish 
 this suspends the existing transfer 
 return all user requests 
 move myself to free_list 
 reinitialize the hardware 
 terminate running transactions and free descriptors 
 Move data 
 Free descriptors 
	
	  All interrupts are request driven.
	  HW doesn't send an interrupt by itself.
 free allocated MSI interrupts above 
 free allocated MSI interrupts above 
 Add callback to free MSIs on teardown 
	
	  This driver only handles the channel IRQs.
	  Common IRQ is handled by the management driver.
	
	  Determine the MSI capability of the platform. Old HW doesn't
	  support MSI.
 Set DMA mask to 64 bits. 
 SPDX-License-Identifier: GPL-2.0-only
  Qualcomm Technologies HIDMA DMA engine Management interface
  Copyright (c) 2015-2017, The Linux Foundation. All rights reserved.
 weight needs to be at least one 
 start the HW 
 allocate a resource array 
		
		  It is assumed that calling of_msi_configure is safe on
		  platforms with or without MSI support.
 device tree based firmware here 
	
	  We do not check for return value here, as it is assumed that
	  platform_driver_register must not fail. The reason for this is that
	  the (potential) hidma_mgmt_of_populate_channels calls above are not
	  cleaned up if it does fail, and to do this work is quite
	  complicated. In particular, various calls of of_address_to_resource,
	  of_irq_to_resource, platform_device_register_full, of_dma_configure,
	  and of_msi_configure which then call other functions and so on, must
	  be cleaned up - this is not a trivial exercise.
	 
	  Currently, this module is not intended to be unloaded, and there is
	  no module_exit function defined which does the needed cleanup. For
	  this reason, we have to assume success here.
 SPDX-License-Identifier: GPL-2.0
 Copyright 2019 NXP
 cmd, param, offset, width, type, arg_name 
  dpdmai_open() - Open a control session for the specified object
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @dpdmai_id:	DPDMAI unique ID
  @token:	Returned token; use in subsequent API calls
  This function can be used to open a control session for an
  already created object; an object may have been declared in
  the DPL or by calling the dpdmai_create() function.
  This function returns a unique authentication token,
  associated with the specific object ID and the specific MC
  portal; this token must be used in all subsequent commands for
  this specific object.
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
 retrieve response parameters 
  dpdmai_close() - Close the control session of the object
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPDMAI object
  After this function is called, no further operations are
  allowed on the object without opening a new control session.
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dpdmai_create() - Create the DPDMAI object
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @cfg:	Configuration structure
  @token:	Returned token; use in subsequent API calls
  Create the DPDMAI object, allocate required resources and
  perform required initialization.
  The object can be created either by declaring it in the
  DPL file, or by calling this function.
  This function returns a unique authentication token,
  associated with the specific object ID and the specific MC
  portal; this token must be used in all subsequent calls to
  this specific object. For objects that are created using the
  DPL file, call dpdmai_open() function to get an authentication
  token first.
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
 retrieve response parameters 
  dpdmai_destroy() - Destroy the DPDMAI object and release all its resources.
  @mc_io:      Pointer to MC portal's IO object
  @cmd_flags:  Command flags; one or more of 'MC_CMD_FLAG_'
  @token:      Token of DPDMAI object
  Return:      '0' on Success; error code otherwise.
 prepare command 
 send command to mc
  dpdmai_enable() - Enable the DPDMAI, allow sending and receiving frames.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPDMAI object
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dpdmai_disable() - Disable the DPDMAI, stop sending and receiving frames.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPDMAI object
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dpdmai_reset() - Reset the DPDMAI, returns the object to initial state.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPDMAI object
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dpdmai_get_attributes() - Retrieve DPDMAI attributes.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPDMAI object
  @attr:	Returned object's attributes
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
 retrieve response parameters 
  dpdmai_set_rx_queue() - Set Rx queue configuration
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPDMAI object
  @priority:	Select the queue relative to number of
 		priorities configured at DPDMAI creation
  @cfg:	Rx queue configuration
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
  dpdmai_get_rx_queue() - Retrieve Rx queue attributes.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPDMAI object
  @priority:	Select the queue relative to number of
 				priorities configured at DPDMAI creation
  @attr:	Returned Rx queue attributes
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
 retrieve response parameters 
  dpdmai_get_tx_queue() - Retrieve Tx queue attributes.
  @mc_io:	Pointer to MC portal's IO object
  @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  @token:	Token of DPDMAI object
  @priority:	Select the queue relative to number of
 			priorities configured at DPDMAI creation
  @fqid:	Returned Tx queue
  Return:	'0' on Success; Error code otherwise.
 prepare command 
 send command to mc
 retrieve response parameters 
 SPDX-License-Identifier: GPL-2.0
 Copyright 2019 NXP
  Request a command descriptor for enqueue.
 fd populated 
	
	  Bypass memory translation, Frame list format, short length disable
	  we need to disable BMT if fsl-mc use iova addr
 first frame list for descriptor buffer 
 source descriptor CMD 
 dest descriptor CMD 
 first frame list to source descriptor 
 bypass memory translation 
 source and destination frame list 
 source frame list to source buffer 
 single buffer frame or scatter gather frame 
 bypass memory translation 
 destination frame list to destination buffer 
 single buffer frame or scatter gather frame 
 bypass memory translation 
 populate Frame descriptor 
 first frame list for descriptor buffer (logn format) 
 Get the handle for the DPDMAI this interface is associate with 
 obtain FD and process the error 
 obtain a MC portal 
 DPDMAI initialization 
 DPIO 
 DPDMAI binding to DPIO 
 DPDMAI enable 
 SPDX-License-Identifier: GPL-2.0
  Xilinx ZynqMP DPDMA Engine driver
  Copyright (C) 2015 - 2020 Xilinx, Inc.
  Author: Hyun Woo Kwon <hyun.kwon@xilinx.com>
 DPDMA registers 
 Channel register 
 DPDMA descriptor fields 
  struct xilinx_dpdma_hw_desc - DPDMA hardware descriptor
  @control: control configuration field
  @desc_id: descriptor ID
  @xfer_size: transfer size
  @hsize_stride: horizontal size and stride
  @timestamp_lsb: LSB of time stamp
  @timestamp_msb: MSB of time stamp
  @addr_ext: upper 16 bit of 48 bit address (next_desc and src_addr)
  @next_desc: next descriptor 32 bit address
  @src_addr: payload source address (1st page, 32 LSB)
  @addr_ext_23: payload source address (3nd and 3rd pages, 16 LSBs)
  @addr_ext_45: payload source address (4th and 5th pages, 16 LSBs)
  @src_addr2: payload source address (2nd page, 32 LSB)
  @src_addr3: payload source address (3rd page, 32 LSB)
  @src_addr4: payload source address (4th page, 32 LSB)
  @src_addr5: payload source address (5th page, 32 LSB)
  @crc: descriptor CRC
  struct xilinx_dpdma_sw_desc - DPDMA software descriptor
  @hw: DPDMA hardware descriptor
  @node: list node for software descriptors
  @dma_addr: DMA address of the software descriptor
  struct xilinx_dpdma_tx_desc - DPDMA transaction descriptor
  @vdesc: virtual DMA descriptor
  @chan: DMA channel
  @descriptors: list of software descriptors
  @error: an error has been detected with this descriptor
  struct xilinx_dpdma_chan - DPDMA channel
  @vchan: virtual DMA channel
  @reg: register base address
  @id: channel ID
  @wait_to_stop: queue to wait for outstanding transacitons before stopping
  @running: true if the channel is running
  @first_frame: flag for the first frame of stream
  @video_group: flag if multi-channel operation is needed for video channels
  @lock: lock to access struct xilinx_dpdma_chan
  @desc_pool: descriptor allocation pool
  @err_task: error IRQ bottom half handler
  @desc: References to descriptors being processed
  @desc.pending: Descriptor schedule to the hardware, pending execution
  @desc.active: Descriptor being executed by the hardware
  @xdev: DPDMA device
 lock to access struct xilinx_dpdma_chan 
  struct xilinx_dpdma_device - DPDMA device
  @common: generic dma device structure
  @reg: register base address
  @dev: generic device structure
  @irq: the interrupt number
  @axi_clk: axi clock
  @chan: DPDMA channels
  @ext_addr: flag for 64 bit system (48 bit addressing)
 -----------------------------------------------------------------------------
  DebugFS
 Match xilinx_dpdma_testcases vs dpdma_debugfs_reqs[] entry 
 Match xilinx_dpdma_testcases vs dpdma_debugfs_reqs[] entry 
 Supporting single instance of test as of now. 
 Read the testcase name from a user request. 
 -----------------------------------------------------------------------------
  IO Accessors
 -----------------------------------------------------------------------------
  Descriptor Operations
  xilinx_dpdma_sw_desc_set_dma_addrs - Set DMA addresses in the descriptor
  @xdev: DPDMA device
  @sw_desc: The software descriptor in which to set DMA addresses
  @prev: The previous descriptor
  @dma_addr: array of dma addresses
  @num_src_addr: number of addresses in @dma_addr
  Set all the DMA addresses in the hardware descriptor corresponding to @dev
  from @dma_addr. If a previous descriptor is specified in @prev, its next
  descriptor DMA address is set to the DMA address of @sw_desc. @prev may be
  identical to @sw_desc for cyclic transfers.
  xilinx_dpdma_chan_alloc_sw_desc - Allocate a software descriptor
  @chan: DPDMA channel
  Allocate a software descriptor from the channel's descriptor pool.
  Return: a software descriptor or NULL.
  xilinx_dpdma_chan_free_sw_desc - Free a software descriptor
  @chan: DPDMA channel
  @sw_desc: software descriptor to free
  Free a software descriptor from the channel's descriptor pool.
  xilinx_dpdma_chan_dump_tx_desc - Dump a tx descriptor
  @chan: DPDMA channel
  @tx_desc: tx descriptor to dump
  Dump contents of a tx descriptor
  xilinx_dpdma_chan_alloc_tx_desc - Allocate a transaction descriptor
  @chan: DPDMA channel
  Allocate a tx descriptor.
  Return: a tx descriptor or NULL.
  xilinx_dpdma_chan_free_tx_desc - Free a virtual DMA descriptor
  @vdesc: virtual DMA descriptor
  Free the virtual DMA descriptor @vdesc including its software descriptors.
  xilinx_dpdma_chan_prep_interleaved_dma - Prepare an interleaved dma
 					    descriptor
  @chan: DPDMA channel
  @xt: dma interleaved template
  Prepare a tx descriptor including internal softwarehardware descriptors
  based on @xt.
  Return: A DPDMA TX descriptor on success, or NULL.
 -----------------------------------------------------------------------------
  DPDMA Channel Operations
  xilinx_dpdma_chan_enable - Enable the channel
  @chan: DPDMA channel
  Enable the channel and its interrupts. Set the QoS values for video class.
  xilinx_dpdma_chan_disable - Disable the channel
  @chan: DPDMA channel
  Disable the channel and its interrupts.
  xilinx_dpdma_chan_pause - Pause the channel
  @chan: DPDMA channel
  Pause the channel.
  xilinx_dpdma_chan_unpause - Unpause the channel
  @chan: DPDMA channel
  Unpause the channel.
  xilinx_dpdma_chan_queue_transfer - Queue the next transfer
  @chan: DPDMA channel
  Queue the next descriptor, if any, to the hardware. If the channel is
  stopped, start it first. Otherwise retrigger it with the next descriptor.
	
	  Assign the cookie to descriptors in this transaction. Only 16 bit
	  will be used, but it should be enough.
		
		  Trigger the transfer only when all channels in the group are
		  ready.
  xilinx_dpdma_chan_ostand - Number of outstanding transactions
  @chan: DPDMA channel
  Read and return the number of outstanding transactions from register.
  Return: Number of outstanding transactions from the status register.
  xilinx_dpdma_chan_notify_no_ostand - Notify no outstanding transaction event
  @chan: DPDMA channel
  Notify waiters for no outstanding event, so waiters can stop the channel
  safely. This function is supposed to be called when 'no outstanding'
  interrupt is generated. The 'no outstanding' interrupt is disabled and
  should be re-enabled when this event is handled. If the channel status
  register still shows some number of outstanding transactions, the interrupt
  remains enabled.
  Return: 0 on success. On failure, -EWOULDBLOCK if there's still outstanding
  transaction(s).
 Disable 'no outstanding' interrupt 
  xilinx_dpdma_chan_wait_no_ostand - Wait for the no outstanding irq
  @chan: DPDMA channel
  Wait for the no outstanding transaction interrupt. This functions can sleep
  for 50ms.
  Return: 0 on success. On failure, -ETIMEOUT for time out, or the error code
  from wait_event_interruptible_timeout().
 Wait for a no outstanding transaction interrupt upto 50msec 
  xilinx_dpdma_chan_poll_no_ostand - Poll the outstanding transaction status
  @chan: DPDMA channel
  Poll the outstanding transaction status, and return when there's no
  outstanding transaction. This functions can be used in the interrupt context
  or where the atomicity is required. Calling thread may wait more than 50ms.
  Return: 0 on success, or -ETIMEDOUT.
 Poll at least for 50ms (20 fps). 
  xilinx_dpdma_chan_stop - Stop the channel
  @chan: DPDMA channel
  Stop a previously paused channel by first waiting for completion of all
  outstanding transaction and then disabling the channel.
  Return: 0 on success, or -ETIMEDOUT if the channel failed to stop.
  xilinx_dpdma_chan_done_irq - Handle hardware descriptor completion
  @chan: DPDMA channel
  Handle completion of the currently active descriptor (@chan->desc.active). As
  we currently support cyclic transfers only, this just invokes the cyclic
  callback. The descriptor will be completed at the VSYNC interrupt when a new
  descriptor replaces it.
  xilinx_dpdma_chan_vsync_irq - Handle hardware descriptor scheduling
  @chan: DPDMA channel
  At VSYNC the active descriptor may have been replaced by the pending
  descriptor. Detect this through the DESC_ID and perform appropriate
  bookkeeping.
 If the retrigger raced with vsync, retry at the next frame. 
	
	  Complete the active descriptor, if any, promote the pending
	  descriptor to active, and queue the next transfer, if any.
  xilinx_dpdma_chan_err - Detect any channel error
  @chan: DPDMA channel
  @isr: masked Interrupt Status Register
  @eisr: Error Interrupt Status Register
  Return: true if any channel error occurs, or false otherwise.
  xilinx_dpdma_chan_handle_err - DPDMA channel error handling
  @chan: DPDMA channel
  This function is called when any channel error or any global error occurs.
  The function disables the paused channel by errors and determines
  if the current active descriptor can be rescheduled depending on
  the descriptor status.
 Reschedule if there's no new descriptor 
 -----------------------------------------------------------------------------
  DMA Engine Operations
  xilinx_dpdma_alloc_chan_resources - Allocate resources for the channel
  @dchan: DMA channel
  Allocate a descriptor pool for the channel.
  Return: 0 on success, or -ENOMEM if failed to allocate a pool.
  xilinx_dpdma_free_chan_resources - Free all resources for the channel
  @dchan: DMA channel
  Free resources associated with the virtual DMA channel, and destroy the
  descriptor pool.
	
	  The destination address doesn't need to be specified as the DPDMA is
	  hardwired to the destination (the DP controller). The transfer
	  width, burst size and port window size are thus meaningless, they're
	  fixed both on the DPDMA side and on the DP controller side.
	
	  Abuse the slave_id to indicate that the channel is part of a video
	  group.
  xilinx_dpdma_terminate_all - Terminate the channel and descriptors
  @dchan: DMA channel
  Pause the channel without waiting for ongoing transfers to complete. Waiting
  for completion is performed by xilinx_dpdma_synchronize() that will disable
  the channel to complete the stop.
  All the descriptors associated with the channel that are guaranteed not to
  be touched by the hardware. The pending and active descriptor are not
  touched, and will be freed either upon completion, or by
  xilinx_dpdma_synchronize().
  Return: 0 on success, or -ETIMEDOUT if the channel failed to stop.
 Pause the channel (including the whole video group if applicable). 
 Gather all the descriptors we can free and free them. 
  xilinx_dpdma_synchronize - Synchronize callback execution
  @dchan: DMA channel
  Synchronizing callback execution ensures that all previously issued
  transfers have completed and all associated callbacks have been called and
  have returned.
  This function waits for the DMA channel to stop. It assumes it has been
  paused by a previous call to dmaengine_terminate_async(), and that no new
  pending descriptors have been issued with dma_async_issue_pending(). The
  behaviour is undefined otherwise.
 -----------------------------------------------------------------------------
  Interrupt and Tasklet Handling
  xilinx_dpdma_err - Detect any global error
  @isr: Interrupt Status Register
  @eisr: Error Interrupt Status Register
  Return: True if any global error occurs, or false otherwise.
  xilinx_dpdma_handle_err_irq - Handle DPDMA error interrupt
  @xdev: DPDMA device
  @isr: masked Interrupt Status Register
  @eisr: Error Interrupt Status Register
  Handle if any error occurs based on @isr and @eisr. This function disables
  corresponding error interrupts, and those should be re-enabled once handling
  is done.
 Disable channel error interrupts until errors are handled. 
  xilinx_dpdma_enable_irq - Enable interrupts
  @xdev: DPDMA device
  Enable interrupts.
  xilinx_dpdma_disable_irq - Disable interrupts
  @xdev: DPDMA device
  Disable interrupts.
  xilinx_dpdma_chan_err_task - Per channel tasklet for error handling
  @t: pointer to the tasklet associated with this handler
  Per channel error handling tasklet. This function waits for the outstanding
  transaction to complete and triggers error handling. After error handling,
  re-enable channel error interrupts, and restart the channel if needed.
 Proceed error handling even when polling fails. 
		
		  There's a single VSYNC interrupt that needs to be processed
		  by each running channel to update the active descriptor.
 -----------------------------------------------------------------------------
  Initialization & Cleanup
 Disable all interrupts 
 Stop all channels 
 Clear the interrupt status registers 
 TODO: Can we achieve better granularity ? 
 Start by disabling the IRQ to avoid races during cleanup. 
 end of table  },
 SPDX-License-Identifier: GPL-2.0-or-later
  DMA driver for Xilinx Video DMA Engine
  Copyright (C) 2010-2014 Xilinx, Inc. All rights reserved.
  Based on the Freescale DMA driver.
  Description:
  The AXI Video Direct Memory Access (AXI VDMA) core is a soft Xilinx IP
  core that provides high-bandwidth direct memory access between memory
  and AXI4-Stream type video target peripherals. The core provides efficient
  two dimensional DMA operations with independent asynchronous read (S2MM)
  and write (MM2S) channel operation. It can be configured to have either
  one channel or two channels. If configured as two channels, one is to
  transmit to the video device (MM2S) and another is to receive from the
  video device (S2MM). Initialization, status, interrupt and management
  registers are accessed through an AXI4-Lite slave interface.
  The AXI Direct Memory Access (AXI DMA) core is a soft Xilinx IP core that
  provides high-bandwidth one dimensional direct memory access between memory
  and AXI4-Stream target peripherals. It supports one receive and one
  transmit channel, both of them optional at synthesis time.
  The AXI CDMA, is a soft IP, which provides high-bandwidth Direct Memory
  Access (DMA) between a memory-mapped source address and a memory-mapped
  destination address.
  The AXI Multichannel Direct Memory Access (AXI MCDMA) core is a soft
  Xilinx IP that provides high-bandwidth direct memory access between
  memory and AXI4-Stream target peripherals. It provides scatter gather
  (SG) interface with multiple channels independent configuration support.
 RegisterDescriptor Offsets 
 Control Registers 
 Register Direct Mode Registers 
 HW specific definitions 
  Recoverable errors are DMA Internal error, SOF Early, EOF Early
  and SOF Late. They are only recoverable when C_FLUSH_ON_FSYNC
  is enabled in the hw system.
 Axi VDMA Flush on Fsync bits 
 Delay loop counter to prevent hardware failure 
 AXI DMA Specific RegistersOffsets 
 AXI DMA Specific MasksBit fields 
 AXI CDMA Specific RegistersOffsets 
 AXI CDMA Specific Masks 
 AXI MCDMA Specific RegistersOffsets 
 AXI MCDMA Specific MasksShifts 
  struct xilinx_vdma_desc_hw - Hardware Descriptor
  @next_desc: Next Descriptor Pointer @0x00
  @pad1: Reserved @0x04
  @buf_addr: Buffer address @0x08
  @buf_addr_msb: MSB of Buffer address @0x0C
  @vsize: Vertical Size @0x10
  @hsize: Horizontal Size @0x14
  @stride: Number of bytes between the first
 	    pixels of each horizontal line @0x18
  struct xilinx_axidma_desc_hw - Hardware Descriptor for AXI DMA
  @next_desc: Next Descriptor Pointer @0x00
  @next_desc_msb: MSB of Next Descriptor Pointer @0x04
  @buf_addr: Buffer address @0x08
  @buf_addr_msb: MSB of Buffer address @0x0C
  @reserved1: Reserved @0x10
  @reserved2: Reserved @0x14
  @control: Control field @0x18
  @status: Status field @0x1C
  @app: APP Fields @0x20 - 0x30
  struct xilinx_aximcdma_desc_hw - Hardware Descriptor for AXI MCDMA
  @next_desc: Next Descriptor Pointer @0x00
  @next_desc_msb: MSB of Next Descriptor Pointer @0x04
  @buf_addr: Buffer address @0x08
  @buf_addr_msb: MSB of Buffer address @0x0C
  @rsvd: Reserved field @0x10
  @control: Control Information field @0x14
  @status: Status field @0x18
  @sideband_status: Status of sideband signals @0x1C
  @app: APP Fields @0x20 - 0x30
  struct xilinx_cdma_desc_hw - Hardware Descriptor
  @next_desc: Next Descriptor Pointer @0x00
  @next_desc_msb: Next Descriptor Pointer MSB @0x04
  @src_addr: Source address @0x08
  @src_addr_msb: Source address MSB @0x0C
  @dest_addr: Destination address @0x10
  @dest_addr_msb: Destination address MSB @0x14
  @control: Control field @0x18
  @status: Status field @0x1C
  struct xilinx_vdma_tx_segment - Descriptor segment
  @hw: Hardware descriptor
  @node: Node in the descriptor segments list
  @phys: Physical address of segment
  struct xilinx_axidma_tx_segment - Descriptor segment
  @hw: Hardware descriptor
  @node: Node in the descriptor segments list
  @phys: Physical address of segment
  struct xilinx_aximcdma_tx_segment - Descriptor segment
  @hw: Hardware descriptor
  @node: Node in the descriptor segments list
  @phys: Physical address of segment
  struct xilinx_cdma_tx_segment - Descriptor segment
  @hw: Hardware descriptor
  @node: Node in the descriptor segments list
  @phys: Physical address of segment
  struct xilinx_dma_tx_descriptor - Per Transaction structure
  @async_tx: Async transaction descriptor
  @segments: TX segments list
  @node: Node in the channel descriptors list
  @cyclic: Check for cyclic transfers.
  @err: Whether the descriptor has an error.
  @residue: Residue of the completed descriptor
  struct xilinx_dma_chan - Driver specific DMA channel structure
  @xdev: Driver specific device structure
  @ctrl_offset: Control registers offset
  @desc_offset: TX descriptor registers offset
  @lock: Descriptor operation lock
  @pending_list: Descriptors waiting
  @active_list: Descriptors ready to submit
  @done_list: Complete descriptors
  @free_seg_list: Free descriptors
  @common: DMA common channel
  @desc_pool: Descriptors pool
  @dev: The dma device
  @irq: Channel IRQ
  @id: Channel ID
  @direction: Transfer direction
  @num_frms: Number of frames
  @has_sg: Support scatter transfers
  @cyclic: Check for cyclic transfers.
  @genlock: Support genlock mode
  @err: Channel has errors
  @idle: Check for channel idle
  @terminating: Check for channel being synchronized by user
  @tasklet: Cleanup work after irq
  @config: Device configuration info
  @flush_on_fsync: Flush on Frame sync
  @desc_pendingcount: Descriptor pending count
  @ext_addr: Indicates 64 bit addressing is supported by dma channel
  @desc_submitcount: Descriptor hw submitted count
  @seg_v: Statically allocated segments base
  @seg_mv: Statically allocated segments base for MCDMA
  @seg_p: Physical allocated segments base
  @cyclic_seg_v: Statically allocated segment base for cyclic transfers
  @cyclic_seg_p: Physical allocated segments base for cyclic dma
  @start_transfer: Differentiate bw DMA IP's transfer
  @stop_transfer: Differentiate bw DMA IP's quiesce
  @tdest: TDEST value for mcdma
  @has_vflip: S2MM vertical flip
  enum xdma_ip_type - DMA IP type.
  @XDMA_TYPE_AXIDMA: Axi dma ip.
  @XDMA_TYPE_CDMA: Axi cdma ip.
  @XDMA_TYPE_VDMA: Axi vdma ip.
  @XDMA_TYPE_AXIMCDMA: Axi MCDMA ip.
  struct xilinx_dma_device - DMA device structure
  @regs: IO mapped base address
  @dev: Device Structure
  @common: DMA device structure
  @chan: Driver specific DMA channel
  @flush_on_fsync: Flush on frame sync
  @ext_addr: Indicates 64 bit addressing is supported by dma device
  @pdev: Platform device structure pointer
  @dma_config: DMA config structure
  @axi_clk: DMA Axi4-lite interace clock
  @tx_clk: DMA mm2s clock
  @txs_clk: DMA mm2s stream clock
  @rx_clk: DMA s2mm clock
  @rxs_clk: DMA s2mm stream clock
  @s2mm_chan_id: DMA s2mm channel identifier
  @mm2s_chan_id: DMA mm2s channel identifier
  @max_buffer_len: Max buffer length
 Macros 
 IO accessors 
  vdma_desc_write_64 - 64-bit descriptor write
  @chan: Driver specific VDMA channel
  @reg: Register to write
  @value_lsb: lower address of the descriptor.
  @value_msb: upper address of the descriptor.
  Since vdma driver is trying to write to a register offset which is not a
  multiple of 64 bits(ex : 0x5c), we are writing as two separate 32 bits
  instead of a single 64 bit register write.
 Write the lsb 32 bits
 Write the msb 32 bits 
 -----------------------------------------------------------------------------
  Descriptors and segments alloc and free
  xilinx_vdma_alloc_tx_segment - Allocate transaction segment
  @chan: Driver specific DMA channel
  Return: The allocated segment on success and NULL on failure.
  xilinx_cdma_alloc_tx_segment - Allocate transaction segment
  @chan: Driver specific DMA channel
  Return: The allocated segment on success and NULL on failure.
  xilinx_axidma_alloc_tx_segment - Allocate transaction segment
  @chan: Driver specific DMA channel
  Return: The allocated segment on success and NULL on failure.
  xilinx_aximcdma_alloc_tx_segment - Allocate transaction segment
  @chan: Driver specific DMA channel
  Return: The allocated segment on success and NULL on failure.
  xilinx_dma_free_tx_segment - Free transaction segment
  @chan: Driver specific DMA channel
  @segment: DMA transaction segment
  xilinx_mcdma_free_tx_segment - Free transaction segment
  @chan: Driver specific DMA channel
  @segment: DMA transaction segment
  xilinx_cdma_free_tx_segment - Free transaction segment
  @chan: Driver specific DMA channel
  @segment: DMA transaction segment
  xilinx_vdma_free_tx_segment - Free transaction segment
  @chan: Driver specific DMA channel
  @segment: DMA transaction segment
  xilinx_dma_alloc_tx_descriptor - Allocate transaction descriptor
  @chan: Driver specific DMA channel
  Return: The allocated descriptor on success and NULL on failure.
  xilinx_dma_free_tx_descriptor - Free transaction descriptor
  @chan: Driver specific DMA channel
  @desc: DMA transaction descriptor
 Required functions 
  xilinx_dma_free_desc_list - Free descriptors list
  @chan: Driver specific DMA channel
  @list: List to parse and delete the descriptor
  xilinx_dma_free_descriptors - Free channel descriptors
  @chan: Driver specific DMA channel
  xilinx_dma_free_chan_resources - Free channel resources
  @dchan: DMA channel
 Free memory that is allocated for BD 
 Free Memory that is allocated for cyclic DMA Mode 
 Free memory that is allocated for BD 
  xilinx_dma_get_residue - Compute residue for a given descriptor
  @chan: Driver specific dma channel
  @desc: dma transaction descriptor
  Return: The number of residue bytes for the descriptor.
  xilinx_dma_chan_handle_cyclic - Cyclic dma callback
  @chan: Driver specific dma channel
  @desc: dma transaction descriptor
  @flags: flags for spin lock
  xilinx_dma_chan_desc_cleanup - Clean channel descriptors
  @chan: Driver specific DMA channel
 Remove from the list of running transactions 
 Run the link descriptor callback function 
 Run any dependencies, then free the descriptor 
		
		  While we ran a callback the user called a terminate function,
		  which takes care of cleaning up any remaining descriptors
  xilinx_dma_do_tasklet - Schedule completion tasklet
  @t: Pointer to the Xilinx DMA channel structure
  xilinx_dma_alloc_chan_resources - Allocate channel resources
  @dchan: DMA channel
  Return: '0' on success and failure value on error
 Has this channel already been allocated? 
	
	  We need the descriptor to be aligned to 64bytes
	  for meeting Xilinx VDMA specification requirement.
 Allocate the buffer descriptors. 
		
		  For cyclic DMA mode we need to program the tail Descriptor
		  register with a value which is not a part of the BD chain
		  so allocating a desc segment during channel allocation for
		  programming tail descriptor.
 Allocate the buffer descriptors. 
		 For AXI DMA resetting once channel will reset the
		  other channel as well so enable the interrupts here.
  xilinx_dma_calc_copysize - Calculate the amount of data to copy
  @chan: Driver specific DMA channel
  @size: Total data that needs to be copied
  @done: Amount of data that has been already copied
  Return: Amount of data that has to be copied
		
		  If this is not the last descriptor, make sure
		  the next one will be properly aligned
  xilinx_dma_tx_status - Get DMA transaction status
  @dchan: DMA channel
  @cookie: Transaction identifier
  @txstate: Transaction state
  Return: DMA transaction status
		
		  VDMA and simple mode do not support residue reporting, so the
		  residue field will always be 0.
  xilinx_dma_stop_transfer - Halt DMA channel
  @chan: Driver specific DMA channel
  Return: '0' on success and failure value on error
 Wait for the hardware to halt 
  xilinx_cdma_stop_transfer - Wait for the current transfer to complete
  @chan: Driver specific DMA channel
  Return: '0' on success and failure value on error
  xilinx_dma_start - Start DMA channel
  @chan: Driver specific DMA channel
 Wait for the hardware to start 
  xilinx_vdma_start_transfer - Starts VDMA transfer
  @chan: Driver specific channel struct pointer
 This function was invoked with lock held 
 Configure the hardware using info in the config structure 
 If not parking, enable circular mode 
 Start the hardware 
 Start the transfer 
 HW expects these parameters to be same for one transaction 
  xilinx_cdma_start_transfer - Starts cdma transfer
  @chan: Driver specific channel struct pointer
 Update tail ptr register which will start the transfer 
 In simple mode 
 Start the transfer 
  xilinx_dma_start_transfer - Starts DMA transfer
  @chan: Driver specific channel struct pointer
 Start the transfer 
 Start the transfer 
  xilinx_mcdma_start_transfer - Starts MCDMA transfer
  @chan: Driver specific channel struct pointer
	
	  lock has been held by calling functions, so we don't need it
	  to take it here again.
 Program current descriptor 
 Program channel enable register 
 Start the fetch of BDs for the channel 
 Start the transfer 
  xilinx_dma_issue_pending - Issue pending transactions
  @dchan: DMA channel
  xilinx_dma_device_config - Configure the DMA channel
  @dchan: DMA channel
  @config: channel configuration
  xilinx_dma_complete_descriptor - Mark the active descriptor as complete
  @chan : xilinx DMA channel
  CONTEXT: hardirq
 This function was invoked with lock held 
  xilinx_dma_reset - Reset DMA channel
  @chan: Driver specific DMA channel
  Return: '0' on success and failure value on error
 Wait for the hardware to finish reset 
  xilinx_dma_chan_reset - Reset DMA channel and enable interrupts
  @chan: Driver specific DMA channel
  Return: '0' on success and failure value on error
 Reset VDMA 
 Enable interrupts 
  xilinx_mcdma_irq_handler - MCDMA Interrupt handler
  @irq: IRQ number
  @data: Pointer to the Xilinx MCDMA channel structure
  Return: IRQ_HANDLEDIRQ_NONE
 Read the channel id raising the interrupt
 Read the status and ack the interrupts. 
		
		  Device takes too long to do the transfer when user requires
		  responsiveness.
  xilinx_dma_irq_handler - DMA Interrupt handler
  @irq: IRQ number
  @data: Pointer to the Xilinx DMA channel structure
  Return: IRQ_HANDLEDIRQ_NONE
 Read the status and ack the interrupts. 
		
		  An error occurred. If C_FLUSH_ON_FSYNC is enabled and the
		  error is recoverable, ignore it. Otherwise flag the error.
		 
		  Only recoverable errors can be cleared in the DMASR register,
		  make sure not to write to other error bits to 1.
		
		  Device takes too long to do the transfer when user requires
		  responsiveness.
  append_desc_queue - Queuing descriptor
  @chan: Driver specific dma channel
  @desc: dma transaction descriptor
	
	  Add the hardware descriptor to the chain of hardware descriptors
	  that already exists in memory.
	
	  Add the software descriptor and all children to the list
	  of pending transactions
  xilinx_dma_tx_submit - Submit DMA transaction
  @tx: Async transaction descriptor
  Return: cookie value on success and failure value on error
		
		  If reset fails, need to hard reset the system.
		  Channel is no longer functional
 Put this transaction onto the tail of the pending queue 
  xilinx_vdma_dma_prep_interleaved - prepare a descriptor for a
 	DMA_SLAVE transaction
  @dchan: DMA channel
  @xt: Interleaved template pointer
  @flags: transfer ack flags
  Return: Async transaction descriptor on success and NULL on failure
 Allocate a transaction descriptor. 
 Allocate the link descriptor from DMA pool 
 Fill in the hardware descriptor 
 Insert the segment into the descriptor segments list. 
 Link the last hardware descriptor with the first. 
  xilinx_cdma_prep_memcpy - prepare descriptors for a memcpy transaction
  @dchan: DMA channel
  @dma_dst: destination address
  @dma_src: source address
  @len: transfer length
  @flags: transfer ack flags
  Return: Async transaction descriptor on success and NULL on failure
 Allocate the link descriptor from DMA pool 
 Insert the segment into the descriptor segments list. 
  xilinx_dma_prep_slave_sg - prepare descriptors for a DMA_SLAVE transaction
  @dchan: DMA channel
  @sgl: scatterlist to transfer tofrom
  @sg_len: number of entries in @scatterlist
  @direction: DMA direction
  @flags: transfer ack flags
  @context: APP words of the descriptor
  Return: Async transaction descriptor on success and NULL on failure
 Allocate a transaction descriptor. 
 Build transactions using information in the scatter gather list 
 Loop until the entire scatterlist entry is used 
 Get a free segment 
			
			  Calculate the maximum number of bytes to transfer,
			  making sure it is less than the hw limit
 Fill in the descriptor 
			
			  Insert the segment into the descriptor segments
			  list.
 For the last DMA_MEM_TO_DEV transfer, set EOP 
  xilinx_dma_prep_dma_cyclic - prepare descriptors for a DMA_SLAVE transaction
  @dchan: DMA channel
  @buf_addr: Physical address of the buffer
  @buf_len: Total length of the cyclic buffers
  @period_len: length of individual cyclic buffer
  @direction: DMA direction
  @flags: transfer ack flags
  Return: Async transaction descriptor on success and NULL on failure
 Allocate a transaction descriptor. 
 Get a free segment 
			
			  Calculate the maximum number of bytes to transfer,
			  making sure it is less than the hw limit
			
			  Insert the segment into the descriptor segments
			  list.
 For the last DMA_MEM_TO_DEV transfer, set EOP 
  xilinx_mcdma_prep_slave_sg - prepare descriptors for a DMA_SLAVE transaction
  @dchan: DMA channel
  @sgl: scatterlist to transfer tofrom
  @sg_len: number of entries in @scatterlist
  @direction: DMA direction
  @flags: transfer ack flags
  @context: APP words of the descriptor
  Return: Async transaction descriptor on success and NULL on failure
 Allocate a transaction descriptor. 
 Build transactions using information in the scatter gather list 
 Loop until the entire scatterlist entry is used 
 Get a free segment 
			
			  Calculate the maximum number of bytes to transfer,
			  making sure it is less than the hw limit
 Fill in the descriptor 
			
			  Insert the segment into the descriptor segments
			  list.
 For the last DMA_MEM_TO_DEV transfer, set EOP 
  xilinx_dma_terminate_all - Halt the channel and free descriptors
  @dchan: Driver specific DMA Channel pointer
  Return: '0' always.
 Remove and free all of the descriptors in the lists 
  xilinx_vdma_channel_set_config - Configure VDMA channel
  Run-time configuration for Axi VDMA, supports:
  . halt the channel
  . configure interrupt coalescing and inter-packet delay threshold
  . startstop parking
  . enable genlock
  @dchan: DMA channel
  @cfg: VDMA device configuration pointer
  Return: '0' on success and failure value on error
 genlock settings 
 FSync Source selection 
 -----------------------------------------------------------------------------
  Probe and remove
  xilinx_dma_chan_remove - Per Channel remove function
  @chan: Driver specific DMA channel
 Disable all interrupts 
  xilinx_dma_chan_probe - Per Channel Probing
  It get channel features from the device tree entry and
  initialize special channel handling routines
  @xdev: Driver specific device structure
  @node: Device node
  Return: '0' on success and failure value on error
 Allocate and initialize the channel structure 
	 This variable ensures that descriptors are not
	  Submitted when dma engine is in progress. This variable is
	  Added to avoid polling for a bit in the status register to
	  Know dma state in the driver hot path.
 Retrieve the channel properties from the device tree 
 Convert bits to bytes 
 If data width is greater than 8 bytes, DRE is not in hw 
 Request the interrupt 
 check if SG is enabled (only for AXIDMA, AXIMCDMA, and CDMA) 
 Initialize the tasklet 
	
	  Initialize the DMA channel and add it to the DMA engine channels
	  list.
 Reset the channel 
  xilinx_dma_child_probe - Per child node probe
  It get number of dma-channels per child node from
  device-tree and initializes all the channels.
  @xdev: Driver specific device structure
  @node: Device node
  Return: 0 always.
  of_dma_xilinx_xlate - Translation function
  @dma_spec: Pointer to DMA specifier as found in the device tree
  @ofdma: Pointer to DMA controller data
  Return: DMA channel pointer on success and NULL on error
  xilinx_dma_probe - Driver probe function
  @pdev: Pointer to the platform_device structure
  Return: '0' on success and failure value on error
 Allocate and initialize the DMA engine structure 
 Request and map IO memory 
 Retrieve the DMA engine properties from the device tree 
 Set the dma mask bits 
 Initialize the DMA engine 
 Residue calculation is supported by only AXI DMA and CDMA 
 Residue calculation is supported by only AXI DMA and CDMA 
 Initialize the channels 
 Register the DMA engine with the core 
  xilinx_dma_remove - Driver remove function
  @pdev: Pointer to the platform_device structure
  Return: Always '0'
 SPDX-License-Identifier: GPL-2.0-or-later
  DMA driver for Xilinx ZynqMP DMA Engine
  Copyright (C) 2016 Xilinx, Inc. All rights reserved.
 Register Offsets 
 Interrupt registers bit field definitions 
 Control 0 register bit field definitions 
 Control 1 register bit field definitions 
 Data Attribute register bit field definitions 
 Descriptor Attribute register bit field definitions 
 Control register 2 bit field definitions 
 Buffer Descriptor definitions 
 Interrupt Mask specific definitions 
 Max number of descriptors per channel 
 Max transfer size per descriptor 
 Max burst lengths 
 Reset values for data attributes 
 Bus width in bits 
  struct zynqmp_dma_desc_ll - Hw linked list descriptor
  @addr: Buffer address
  @size: Size of the buffer
  @ctrl: Control word
  @nxtdscraddr: Next descriptor base address
  @rsvd: Reserved field and for Hw internal use.
  struct zynqmp_dma_desc_sw - Per Transaction structure
  @src: Source address for simple mode dma
  @dst: Destination address for simple mode dma
  @len: Transfer length for simple mode dma
  @node: Node in the channel descriptor list
  @tx_list: List head for the current transfer
  @async_tx: Async transaction descriptor
  @src_v: Virtual address of the src descriptor
  @src_p: Physical address of the src descriptor
  @dst_v: Virtual address of the dst descriptor
  @dst_p: Physical address of the dst descriptor
  struct zynqmp_dma_chan - Driver specific DMA channel structure
  @zdev: Driver specific device structure
  @regs: Control registers offset
  @lock: Descriptor operation lock
  @pending_list: Descriptors waiting
  @free_list: Descriptors free
  @active_list: Descriptors active
  @sw_desc_pool: SW descriptor pool
  @done_list: Complete descriptors
  @common: DMA common channel
  @desc_pool_v: Statically allocated descriptor base
  @desc_pool_p: Physical allocated descriptor base
  @desc_free_cnt: Descriptor available count
  @dev: The dma device
  @irq: Channel IRQ
  @is_dmacoherent: Tells whether dma operations are coherent or not
  @tasklet: Cleanup work after irq
  @idle : Channel status;
  @desc_size: Size of the low level descriptor
  @err: Channel has errors
  @bus_width: Bus width
  @src_burst_len: Source burst length
  @dst_burst_len: Dest burst length
  struct zynqmp_dma_device - DMA device structure
  @dev: Device Structure
  @common: DMA device structure
  @chan: Driver specific DMA channel
  @clk_main: Pointer to main clock
  @clk_apb: Pointer to apb clock
  zynqmp_dma_update_desc_to_ctrlr - Updates descriptor to the controller
  @chan: ZynqMP DMA DMA channel pointer
  @desc: Transaction descriptor pointer
  zynqmp_dma_desc_config_eod - Mark the descriptor as end descriptor
  @chan: ZynqMP DMA channel pointer
  @desc: Hw descriptor pointer
  zynqmp_dma_config_sg_ll_desc - Configure the linked list descriptor
  @chan: ZynqMP DMA channel pointer
  @sdesc: Hw descriptor pointer
  @src: Source buffer address
  @dst: Destination buffer address
  @len: Transfer length
  @prev: Previous hw descriptor pointer
  zynqmp_dma_init - Initialize the channel
  @chan: ZynqMP DMA channel pointer
 Clearing the interrupt account rgisters 
  zynqmp_dma_tx_submit - Submit DMA transaction
  @tx: Async transaction descriptor pointer
  Return: cookie value
  zynqmp_dma_get_descriptor - Get the sw descriptor from the pool
  @chan: ZynqMP DMA channel pointer
  Return: The sw descriptor
 Clear the src and dst descriptor memory 
  zynqmp_dma_free_descriptor - Issue pending transactions
  @chan: ZynqMP DMA channel pointer
  @sdesc: Transaction descriptor pointer
  zynqmp_dma_free_desc_list - Free descriptors list
  @chan: ZynqMP DMA channel pointer
  @list: List to parse and delete the descriptor
  zynqmp_dma_alloc_chan_resources - Allocate channel resources
  @dchan: DMA channel
  Return: Number of descriptors on success and failure value on error
  zynqmp_dma_start - Start DMA channel
  @chan: ZynqMP DMA channel pointer
  zynqmp_dma_handle_ovfl_int - Process the overflow interrupt
  @chan: ZynqMP DMA channel pointer
  @status: Interrupt status value
  zynqmp_dma_device_config - Zynqmp dma device configuration
  @dchan: DMA channel
  @config: DMA device config
  Return: 0 always
  zynqmp_dma_start_transfer - Initiate the new transfer
  @chan: ZynqMP DMA channel pointer
  zynqmp_dma_chan_desc_cleanup - Cleanup the completed descriptors
  @chan: ZynqMP DMA channel
 Run any dependencies, then free the descriptor 
  zynqmp_dma_complete_descriptor - Mark the active descriptor as complete
  @chan: ZynqMP DMA channel pointer
  zynqmp_dma_issue_pending - Issue pending transactions
  @dchan: DMA channel pointer
  zynqmp_dma_free_descriptors - Free channel descriptors
  @chan: ZynqMP DMA channel pointer
  zynqmp_dma_free_chan_resources - Free channel resources
  @dchan: DMA channel pointer
  zynqmp_dma_reset - Reset the channel
  @chan: ZynqMP DMA channel pointer
  zynqmp_dma_irq_handler - ZynqMP DMA Interrupt handler
  @irq: IRQ number
  @data: Pointer to the ZynqMP DMA channel structure
  Return: IRQ_HANDLEDIRQ_NONE
  zynqmp_dma_do_tasklet - Schedule completion tasklet
  @t: Pointer to the ZynqMP DMA channel structure
  zynqmp_dma_device_terminate_all - Aborts all transfers on a channel
  @dchan: DMA channel pointer
  Return: Always '0'
  zynqmp_dma_prep_memcpy - prepare descriptors for memcpy transaction
  @dchan: DMA channel
  @dma_dst: Destination buffer address
  @dma_src: Source buffer address
  @len: Transfer length
  @flags: transfer ack flags
  Return: Async transaction descriptor on success and NULL on failure
 Allocate and populate the descriptor 
  zynqmp_dma_chan_remove - Channel remove function
  @chan: ZynqMP DMA channel pointer
  zynqmp_dma_chan_probe - Per Channel Probing
  @zdev: Driver specific device structure
  @pdev: Pointer to the platform_device structure
  Return: '0' on success and failure value on error
  of_zynqmp_dma_xlate - Translation function
  @dma_spec: Pointer to DMA specifier as found in the device tree
  @ofdma: Pointer to DMA controller data
  Return: DMA channel pointer on success and NULL on error
  zynqmp_dma_suspend - Suspend method for the driver
  @dev:	Address of the device structure
  Put the driver into low power mode.
  Return: 0 on success and failure value on error
  zynqmp_dma_resume - Resume from suspend
  @dev:	Address of the device structure
  Resume operation after suspend.
  Return: 0 on success and failure value on error
  zynqmp_dma_runtime_suspend - Runtime suspend method for the driver
  @dev:	Address of the device structure
  Put the driver into low power mode.
  Return: 0 always
  zynqmp_dma_runtime_resume - Runtime suspend method for the driver
  @dev:	Address of the device structure
  Put the driver into low power mode.
  Return: 0 always
  zynqmp_dma_probe - Driver probe function
  @pdev: Pointer to the platform_device structure
  Return: '0' on success and failure value on error
  zynqmp_dma_remove - Driver remove function
  @pdev: Pointer to the platform_device structure
  Return: Always '0'
 SPDX-License-Identifier: GPL-2.0
  Renesas RZG2L DMA Controller Driver
  Based on imx-dma.c
  Copyright (C) 2021 Renesas Electronics Corp.
  Copyright 2010 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
  Copyright 2012 Javier Martin, Vista Silicon <javier.martin@vista-silicon.com>
 For slave sg 
  -----------------------------------------------------------------------------
  Registers
 LINK MODE DESCRIPTOR 
  -----------------------------------------------------------------------------
  Device access
  -----------------------------------------------------------------------------
  Initialization
  -----------------------------------------------------------------------------
  Descriptors preparation
 prepare descriptor 
  -----------------------------------------------------------------------------
  DMA engine operations
	
	  Place holder
	  Descriptor allocation is done during alloc_chan_resources and
	  get freed during free_chan_resources.
	  list is used to manage the descriptors and avoid any memory
	  allocationfree during DMA readwrite.
  -----------------------------------------------------------------------------
  IRQ handling
 handle DMAERR irq 
 Someone might have called terminate all 
  -----------------------------------------------------------------------------
  OF xlate and channel filter
 Only slave DMA channels can be allocated via DT 
  -----------------------------------------------------------------------------
  Probe and remove
 Request the channel interrupt. 
 Set io base address for each channel 
 Allocate descriptors 
 Initialize register for each channel 
 Request resources 
 Register interrupt handler for error 
 Initialize the channels. 
 Register the DMAC as a DMA provider for DT. 
 Register the DMA engine device. 
 Sentinel  }
 SPDX-License-Identifier: GPL-2.0
  Renesas R-Car Gen2Gen3 DMA Controller Driver
  Copyright (C) 2014-2019 Renesas Electronics Inc.
  Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  struct rcar_dmac_xfer_chunk - Descriptor for a hardware transfer
  @node: entry in the parent's chunks list
  @src_addr: device source address
  @dst_addr: device destination address
  @size: transfer size in bytes
  struct rcar_dmac_hw_desc - Hardware descriptor for a transfer chunk
  @sar: value of the SAR register (source address)
  @dar: value of the DAR register (destination address)
  @tcr: value of the TCR register (transfer count)
  struct rcar_dmac_desc - R-Car Gen2 DMA Transfer Descriptor
  @async_tx: base DMA asynchronous transaction descriptor
  @direction: direction of the DMA transfer
  @xfer_shift: log2 of the transfer size
  @chcr: value of the channel configuration register for this transfer
  @node: entry in the channel's descriptors lists
  @chunks: list of transfer chunks for this transfer
  @running: the transfer chunk being currently processed
  @nchunks: number of transfer chunks for this transfer
  @hwdescs.use: whether the transfer descriptor uses hardware descriptors
  @hwdescs.mem: hardware descriptors memory for the transfer
  @hwdescs.dma: device address of the hardware descriptors memory
  @hwdescs.size: size of the hardware descriptors in bytes
  @size: transfer size in bytes
  @cyclic: when set indicates that the DMA transfer is cyclic
  struct rcar_dmac_desc_page - One page worth of descriptors
  @node: entry in the channel's pages list
  @descs: array of DMA descriptors
  @chunks: array of transfer chunk descriptors
  struct rcar_dmac_chan_slave - Slave configuration
  @slave_addr: slave memory address
  @xfer_size: size (in bytes) of hardware transfers
  struct rcar_dmac_chan_map - Map of slave device phys to dma address
  @addr: slave dma address
  @dir: direction of mapping
  @slave: slave configuration that is mapped
  struct rcar_dmac_chan - R-Car Gen2 DMA Controller Channel
  @chan: base DMA channel object
  @iomem: channel IO memory base
  @index: index of this channel in the controller
  @irq: channel IRQ
  @src: slave memory address and size on the source side
  @dst: slave memory address and size on the destination side
  @mid_rid: hardware MIDRID for the DMA client using this channel
  @lock: protects the channel CHCR register and the desc members
  @desc.free: list of free descriptors
  @desc.pending: list of pending descriptors (submitted with tx_submit)
  @desc.active: list of active descriptors (activated with issue_pending)
  @desc.done: list of completed descriptors
  @desc.wait: list of descriptors waiting for an ack
  @desc.running: the descriptor being processed (a member of the active list)
  @desc.chunks_free: list of free transfer chunk descriptors
  @desc.pages: list of pages used by allocated descriptors
  struct rcar_dmac - R-Car Gen2 DMA Controller
  @engine: base DMA engine object
  @dev: the hardware device
  @dmac_base: remapped base register block
  @chan_base: remapped channel register block (optional)
  @n_channels: number of available channels
  @channels: array of DMAC channels
  @channels_mask: bitfield of which DMA channels are managed by this driver
  @modules: bitmask of client modules in use
  struct rcar_dmac_of_data - This driver's OF data
  @chan_offset_base: DMAC channels base offset
  @chan_offset_stride: DMAC channels offset stride
 -----------------------------------------------------------------------------
  Registers
 Not on R-Car V3U 
 For R-Car V3U 
 Hardcode the MEMCPY transfer size to 4 bytes. 
 -----------------------------------------------------------------------------
  Device access
 -----------------------------------------------------------------------------
  Initialization and configuration
		
		  Errata: When descriptor memory is accessed through an IOMMU
		  the DMADAR register isn't initialized automatically from the
		  first descriptor at beginning of transfer by the DMAC like it
		  should. Initialize it manually with the destination address
		  of the first chunk.
		
		  Program the descriptor stage interrupt to occur after the end
		  of the first stage.
		
		  If the descriptor isn't cyclic enable normal descriptor mode
		  and the transfer completion interrupt.
		
		  If the descriptor is cyclic and has a callback enable the
		  descriptor stage interrupt in infinite repeat mode.
		
		  Otherwise just select infinite repeat mode without any
		  interrupt.
 Clear all channels and enable the DMAC globally. 
 -----------------------------------------------------------------------------
  Descriptors submission
 -----------------------------------------------------------------------------
  Descriptors allocation and free
  rcar_dmac_desc_alloc - Allocate a page worth of DMA descriptors
  @chan: the DMA channel
  @gfp: allocation flags
  rcar_dmac_desc_put - Release a DMA transfer descriptor
  @chan: the DMA channel
  @desc: the descriptor
  Put the descriptor and its transfer chunk descriptors back in the channel's
  free descriptors lists. The descriptor's chunks list will be reinitialized to
  an empty list as a result.
  The descriptor must have been removed from the channel's lists before calling
  this function.
	
	  We have to temporarily move all descriptors from the wait list to a
	  local list as iterating over the wait list, even with
	  list_for_each_entry_safe, isn't safe if we release the channel lock
	  around the rcar_dmac_desc_put() call.
 Put the remaining descriptors back in the wait list. 
  rcar_dmac_desc_get - Allocate a descriptor for a DMA transfer
  @chan: the DMA channel
  Locking: This function must be called in a non-atomic context.
  Return: A pointer to the allocated descriptor or NULL if no descriptor can
  be allocated.
 Recycle acked descriptors before attempting allocation. 
		
		  No free descriptors, allocate a page worth of them and try
		  again, as someone else could race us to get the newly
		  allocated descriptors. If the allocation fails return an
		  error.
  rcar_dmac_xfer_chunk_alloc - Allocate a page worth of transfer chunks
  @chan: the DMA channel
  @gfp: allocation flags
  rcar_dmac_xfer_chunk_get - Allocate a transfer chunk for a DMA transfer
  @chan: the DMA channel
  Locking: This function must be called in a non-atomic context.
  Return: A pointer to the allocated transfer chunk descriptor or NULL if no
  descriptor can be allocated.
		
		  No free descriptors, allocate a page worth of them and try
		  again, as someone else could race us to get the newly
		  allocated descriptors. If the allocation fails return an
		  error.
	
	  dma_alloc_coherent() allocates memory in page size increments. To
	  avoid reallocating the hardware descriptors when the allocated size
	  wouldn't change align the requested size to a multiple of the page
	  size.
 -----------------------------------------------------------------------------
  Stop and reset
	
	  Ensure that the setting of the DE bit is actually 0 after
	  clearing it.
 set DE=0 and flush remaining data 
 make sure all remaining data was flushed 
 Move all non-free descriptors to the local lists. 
 Stop all channels. 
 Stop and reinitialize the channel. 
 -----------------------------------------------------------------------------
  Descriptors preparation
  rcar_dmac_chan_prep_sg - prepare transfer descriptors from an SG list
  Common routine for public (MEMCPY) and slave DMA. The MEMCPY case is also
  converted to scatter-gather to guarantee consistent locking and a correct
  list manipulation. For slave DMA direction carries the usual meaning, and,
  logically, the SG list is RAM and the addr variable contains slave address,
  e.g., the FIFO IO register. For MEMCPY direction equals DMA_MEM_TO_MEM
  and the SG list contains only one element and points at the source buffer.
	
	  Allocate and fill the transfer chunk descriptors. We own the only
	  reference to the DMA descriptor, there's no need for locking.
			
			  Prevent individual transfers from crossing 4GB
			  boundaries.
	
	  Use hardware descriptor lists if possible when more than one chunk
	  needs to be transferred (otherwise they don't make much sense).
	 
	  SourceDestination address should be located in same 4GiB region
	  in the 40bit address space when it uses Hardware descriptor,
	  and cross_boundary is checking it.
 -----------------------------------------------------------------------------
  DMA engine operations
 Preallocate descriptors. 
 Protect against ISR 
	
	  Now no new interrupts will occur, but one might already be
	  running. Wait for it to finish before freeing resources.
 The caller is holding dma_list_mutex 
 Remove slave mapping if present. 
 Reuse current map if possible. 
 Remove old mapping if present. 
 Create new slave address map. 
 Someone calling slave DMA on a generic channel? 
 Someone calling slave DMA on a generic channel? 
	
	  Allocate the sg list dynamically as it would consume too much stack
	  space.
	
	  We could lock this, but you shouldn't be configuring the
	  channel, while using it...
	
	  FIXME: No new interrupt can occur now, but the IRQ thread might still
	  be running.
	
	  If the cookie corresponds to a descriptor that has been completed
	  there is no residue. The same check has already been performed by the
	  caller but without holding the channel lock, so the descriptor could
	  now be complete.
	
	  If the cookie doesn't correspond to the currently running transfer
	  then the descriptor hasn't been processed yet, and the residue is
	  equal to the full descriptor size.
	  Also, a client driver is possible to call this function before
	  rcar_dmac_isr_channel_thread() runs. In this case, the "desc.running"
	  will be the next descriptor, and the done list will appear. So, if
	  the argument cookie matches the done list's cookie, we can assume
	  the residue is zero.
		
		  No descriptor found for the cookie, there's thus no residue.
		  This shouldn't happen if the calling driver passes a correct
		  cookie value.
	
	  We need to read two registers.
	  Make sure the control register does not skip to next chunk
	  while reading the counter.
	  Trying it 3 times should be enough: Initial read, retry, retry
	  for the paranoid.
 Still the same? 
	
	  In descriptor mode the descriptor running pointer is not maintained
	  by the interrupt handler, find the running descriptor from the
	  descriptor pointer field in the CHCRB register. In non-descriptor
	  mode just use the running descriptor pointer.
 Compute the size of all chunks still to be transferred. 
 Add the residue for the current chunk. 
 if there's no residue, the cookie is complete 
 Append the pending list to the active list. 
	
	  If no transfer is running pick the first descriptor from the active
	  list and start the transfer.
 -----------------------------------------------------------------------------
  IRQ handling
		
		  This should never happen, there should always be a running
		  cyclic descriptor when a descriptor stage end interrupt is
		  triggered. Warn and return.
 Program the interrupt pointer to the next stage. 
		
		  This should never happen, there should always be a running
		  descriptor when a transfer end interrupt is triggered. Warn
		  and return.
	
	  The transfer end interrupt isn't generated for each chunk when using
	  descriptor mode. Only update the running chunk pointer in
	  non-descriptor mode.
		
		  If we haven't completed the last transfer chunk simply move
		  to the next one. Only wake the IRQ thread if the transfer is
		  cyclic.
		
		  We've completed the last transfer chunk. If the transfer is
		  cyclic, move back to the first one.
 The descriptor is complete, move it to the done list. 
 Queue the next descriptor, if any. 
		
		  We don't need to call rcar_dmac_chan_halt()
		  because channel is already stopped in error case.
		  We need to clear register and check DE bit as recovery.
 For cyclic transfers notify the user after every chunk. 
	
	  Call the callback function for all descriptors on the done list and
	  move them to the ack wait list.
			
			  We own the only reference to this descriptor, we can
			  safely dereference it without holding the channel
			  lock.
 Recycle all acked descriptors. 
 -----------------------------------------------------------------------------
  OF xlate and channel filter
	
	  FIXME: Using a filter on OF platforms is a nonsense. The OF xlate
	  function knows from which device it wants to allocate a channel from,
	  and would be perfectly capable of selecting the channel it wants.
	  Forcing it to call dma_request_channel() and iterate through all
	  channels from all controllers is just pointless.
 Only slave DMA channels can be allocated via DT 
 -----------------------------------------------------------------------------
  Power management
	
	  TODO for system sleepresume:
	    - Wait for the current transfer to complete and stop the device,
	    - Resume transfers, if any.
 -----------------------------------------------------------------------------
  Probe and remove
 Request the channel interrupt. 
	
	  Initialize the DMA engine channel and add it to the DMA engine
	  channels list.
 The hardware and driver don't support more than 32 bits in CHCLR 
	
	  If the driver is unable to read dma-channel-mask property,
	  the driver assumes that it can use all channels.
 If the property has out-of-channel mask, this driver clears it 
	
	  A still unconfirmed hardware bug prevents the IPMMU microTLB 0 to be
	  flushed correctly, resulting in memory corruption. DMAC 0 channel 0
	  is connected to microTLB 0 on currently supported platforms, so we
	  can't use it with the IPMMU. As the IOMMU API operates at the device
	  level we can't disable it selectively, so ignore channel 0 for now if
	  the device is part of an IOMMU group.
 Request resources. 
 Enable runtime PM and initialize the device. 
 Initialize engine 
 Register the DMAC as a DMA provider for DT. 
	
	  Register the DMA engine device.
	 
	  Default transfer size of 32 bytes requires 32-byte alignment.
 Sentinel  }
 SPDX-License-Identifier: GPL-2.0
  Renesas USB DMA Controller Driver
  Copyright (C) 2015 Renesas Electronics Corporation
  based on rcar-dmac.c
  Copyright (C) 2014 Renesas Electronics Inc.
  Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  struct usb_dmac_sg - Descriptor for a hardware transfer
  @mem_addr: memory address
  @size: transfer size in bytes
  struct usb_dmac_desc - USB DMA Transfer Descriptor
  @vd: base virtual channel DMA transaction descriptor
  @direction: direction of the DMA transfer
  @sg_allocated_len: length of allocated sg
  @sg_len: length of sg
  @sg_index: index of sg
  @residue: residue after the DMAC completed a transfer
  @node: node for desc_got and desc_freed
  @done_cookie: cookie after the DMAC completed a transfer
  @sg: information for the transfer
  struct usb_dmac_chan - USB DMA Controller Channel
  @vc: base virtual DMA channel object
  @iomem: channel IO memory base
  @index: index of this channel in the controller
  @irq: irq number of this channel
  @desc: the current descriptor
  @descs_allocated: number of descriptors allocated
  @desc_got: got descriptors
  @desc_freed: freed descriptors after the DMAC completed a transfer
  struct usb_dmac - USB DMA Controller
  @engine: base DMA engine object
  @dev: the hardware device
  @iomem: remapped IO memory base
  @n_channels: number of available channels
  @channels: array of DMAC channels
 -----------------------------------------------------------------------------
  Registers
 Hardcode the xfer_shift to 5 (32bytes) 
 for descriptors 
 -----------------------------------------------------------------------------
  Device access
 -----------------------------------------------------------------------------
  Initialization and configuration
	
	  Please refer to the Figure "Example of Final Transaction Valid
	  Data Transfer Enable (EDTEN) Setting" in the data sheet.
 This function is already held by vc.lock 
 This function is already held by vc.lock 
	
	  Remove this request from vc->desc_issued. Otherwise, this driver
	  will get the previous value from vchan_next_desc() after a transfer
	  was completed.
 Clear all channels and enable the DMAC globally. 
 -----------------------------------------------------------------------------
  Descriptors allocation and free
 Get a freed descritpor 
 Allocate a new descriptor 
 If allocated the desc, it was added to tail of the list 
 -----------------------------------------------------------------------------
  Stop and reset
 Don't issue soft reset if any one of channels is busy 
 -----------------------------------------------------------------------------
  DMA engine operations
 Protect against ISR 
	
	  We cannot use USB_DMATCR to calculate residue because USB_DMATCR
	  has unsuited value to calculate.
 Compute the size of all usb_dmac_sg still to be transferred 
 Add the residue for the current sg 
 a client driver will get residue after DMA_COMPLETE 
 -----------------------------------------------------------------------------
  IRQ handling
 Restart the next transfer if this driver has a next desc 
 An interruption of TE will happen after we set FTE 
 -----------------------------------------------------------------------------
  OF xlate and channel filter
 USB-DMAC should be used with fixed usb controller's FIFO 
 Only slave DMA channels can be allocated via DT 
 -----------------------------------------------------------------------------
  Power management
 CONFIG_PM 
 -----------------------------------------------------------------------------
  Probe and remove
 Request the channel interrupt. 
 Request resources. 
 Enable runtime PM and initialize the device. 
 Initialize the channels. 
 Register the DMAC as a DMA provider for DT. 
	
	  Register the DMA engine device.
	 
	  Default transfer size of 32 bytes requires 32-byte alignment.
 Sentinel  }
 SPDX-License-Identifier: GPL-2.0
  Dmaengine driver base library for DMA controllers, found on SH-based SoCs
  extracted from shdma.c
  Copyright (C) 2011-2012 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
  Copyright (C) 2009 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
  Copyright (C) 2009 Renesas Solutions, Inc. All rights reserved.
  Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.
 DMA descriptor control 
 completed, have to call callback 
 callback called, waiting for ack  re-submit 
  For slave DMA we assume, that there is a finite number of DMA slaves in the
  system, and that each such slave can only use a finite number of channels.
  We use slave channel IDs to make sure, that no such slave channel ID is
  allocated more than once.
 A bitmask with slave_num bits 
 Called under spin_lock_irq(&schan->chan_lock") 
 DMA work check 
 Find the first not transferred descriptor 
 Mark all chunks of this descriptor as submitted, move to the queue 
		
		  All chunks are on the global ld_free, so, we have to find
		  the end of the chain ourselves
 Callback goes to the last chunk 
 Have we been reset, while waiting? 
			
			  TODO: .xfer_setup() might fail on some platforms.
			  Make it int then, on error remove chunks from the
			  queue again
		
		  Tell .device_issue_pending() not to run the queue, interrupts
		  will do it anyway
 Called with desc_lock held 
	
	  This relies on the guarantee from dmaengine that alloc_chan_resources
	  never runs concurrently with itself or free_chan_resources.
 Legacy mode: .private is set in filter 
 Normal mode: real_slave_id was set by filter 
  This is the standard shdma filter function to be used as a replacement to the
  "old" method, using the .private pointer.
  You always have to pass a valid slave id as the argument, old drivers that
  pass ERR_PTR(-EINVAL) as a filter parameter and set it up in dma_slave_config
  need to be updated so we can remove the slave_id field from dma_slave_config.
  parameter. If this filter is used, the slave driver, after calling
  dma_request_channel(), will also have to call dmaengine_slave_config() with
  .direction, and either .src_addr or .dst_addr set.
  NOTE: this filter doesn't support multiple DMAC drivers with the DMA_SLAVE
  capability! If this becomes a requirement, hardware glue drivers, using this
  services would have to provide their own filters, which first would check
  the device driver, similar to how other DMAC drivers, e.g., sa11x0-dma.c, do
  this, and only then, in case of a match, call this common filter.
  NOTE 2: This filter function is also used in the DT case by shdma_of_xlate().
  In that case the MID-RID value is used for slave channel filtering and is
  passed to this function in the "arg" parameter.
 Only support channels handled by this driver. 
	
	  For DT, the schan->slave_id field is generated by the
	  set_slave function from the slave ID that is passed in
	  from xlate. For the non-DT case, the slave ID is
	  directly passed into the filter function by the driver
 No slave requested - arbitrary channel 
 Is the "exposed" head of a chain acked? 
		
		  queue is ordered, and we use this loop to (1) clean up all
		  completed descriptors, and to (2) update descriptor flags of
		  any chunks in a (partially) completed chain
 Call callback on the last chunk 
 Remove from ld_queue list 
 reuse as cyclic 
		
		  Terminating and the loop completed normally: forgive
		  uncompleted cookies
  shdma_chan_ld_cleanup - Clean up link descriptors
  Clean up the ld_queue of DMA channel.
  shdma_free_chan_resources - Free all resources of the channel.
 Protect against ISR 
 Now no new interrupts will occur 
 Prepared and not submitted descriptors can still be on the queue 
 The caller is holding dma_list_mutex 
  shdma_add_desc - get, set up and return one transfer descriptor
  @schan:	DMA channel
  @flags:	DMA transfer flags
  @dst:	destination DMA address, incremented when direction equals
 		DMA_DEV_TO_MEM or DMA_MEM_TO_MEM
  @src:	source DMA address, incremented when direction equals
 		DMA_MEM_TO_DEV or DMA_MEM_TO_MEM
  @len:	DMA transfer length
  @first:	if NULL, set to the current descriptor and cookie set to -EBUSY
  @direction:	needed for slave DMA to decide which address to keep constant,
 		equals DMA_MEM_TO_MEM for MEMCPY
  Returns 0 or an error
  Locks: called with desc_lock held
 Allocate the link descriptor from the free list 
 First desc 
 Other desc - invisible to the user 
  shdma_prep_sg - prepare transfer descriptors from an SG list
  Common routine for public (MEMCPY) and slave DMA. The MEMCPY case is also
  converted to scatter-gather to guarantee consistent locking and a correct
  list manipulation. For slave DMA direction carries the usual meaning, and,
  logically, the SG list is RAM and the addr variable contains slave address,
  e.g., the FIFO IO register. For MEMCPY direction equals DMA_MEM_TO_MEM
  and the SG list contains only one element and points at the source buffer.
 compiler... ;
 Have to lock the whole loop to protect against concurrent release 
	
	  Chaining:
	  first descriptor is what user is dealing with in all API calls, its
	 	cookie is at first set to -EBUSY, at tx-submit to a positive
	 	number
	  if more than one chunk is needed further chunks have cookie = -EINVAL
	  the last chunk, if not equal to the first, has cookie = -ENOSPC
	  all chunks are linked onto the tx_list head with their .node heads
	 	only during this function, then they are immediately spliced
	 	back onto the free list in form of a chain
 Put them back on the free list, so, they don't get lost 
 Someone calling slave DMA on a generic channel? 
 Someone calling slave DMA on a generic channel? 
	
	  Allocate the sg list dynamically as it would consumer too much stack
	  space.
 Record partial transfer 
	
	  So far only .slave_id is used, but the slave drivers are
	  encouraged to also set a transfer direction and an address.
	
	  overriding the slave_id through dma_slave_config is deprecated,
	  but possibly some out-of-tree drivers still do it.
	
	  We could lock this, but you shouldn't be configuring the
	  channel, while using it...
	
	  If we don't find cookie on the queue, it has been aborted and we have
	  to report error
 Called from error IRQ or NMI 
 Reset all channels 
 Stop the channel 
 Complete all  
 Next desc 
 reference struct dma_device 
 Init descripter manage list 
 Add the channel to DMA device channel list 
	
	  Require all call-backs for now, they can trivially be made optional
	  later as required
 Common and MEMCPY operations 
 Compulsory for DMA_SLAVE fields 
 SPDX-License-Identifier: GPL-2.0+
  Renesas SuperH DMA Engine support
  base is driversdmaflsdma.c
  Copyright (C) 2011-2012 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
  Copyright (C) 2009 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
  Copyright (C) 2009 Renesas Solutions, Inc. All rights reserved.
  Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.
  - DMA of SuperH does not have Hardware DMA chain mode.
  - MAX DMA size is 16MB.
 DMA registers 
 Source Address Register 
 Destination Address Register 
 Transfer Count Register 
 Channel Control Register 
 DMA Operation Register 
 USB-DMAC 
 Default MEMCPY transfer size = 2^2 = 4 bytes 
  Used for write-side mutual exclusion for the global device list,
  read-side synchronization by way of RCU, and per-controller data.
  Different DMAC implementations provide different ways to clear DMA channels:
  (1) none - no CHCLR registers are available
  (2) one CHCLR register per channel - 0 has to be written to it to clear
      channel buffers
  (3) one CHCLR per several channels - 1 has to be written to the bit,
      corresponding to the specific channel to reset it
  Reset DMA controller
  SH7780 has two DMAOR register
 working 
 waiting 
	
	  Default configuration for dual address memory-memory transfer.
 If DMA is active, cannot set CHCR. TODO: remove this superfluous check 
 in the case of a missing DMARS resource use first memory window 
 Get the ld start address from ld_queue 
  Find a slave channel configuration from the contoller list by either a slave
  ID in the non-DT case, or by a MIDRID value in the DT case
 DMA stop 
 Called from error IRQ or NMI 
 halt the dma controller 
 We cannot detect, which channel caused the error, have to reset all 
 Fast path out if NMIF is not asserted for this controller 
	
	  Only concern ourselves with NMI events.
	 
	  Normally we would check the die chain value, but as this needs
	  to be architecture independent, check for NMI context instead.
		
		  Only stop if one of the controllers has NMIF asserted,
		  we do not want to interfere with regular address error
		  handling or NMI events that don't concern the DMACs.
 Run before NMI debug handler and KGDB 
 set up channel irq 
 remove from dmaengine device node 
	
	  Implicit BUG_ON(!sh_chan->config)
	  This is an exclusive slave DMA operation, may only be called after a
	  successful slave configuration.
 get platform data 
 DMARS area is optional 
	
	  IRQ resources:
	  1. there always must be at least one IRQ IO-resource. On SH4 it is
	     the error IRQ, in which case it is the only IRQ in this resource:
	     start == end. If it is the only IRQ resource, all channels also
	     use the same IRQ.
	  2. DMA channel IRQ resources can be specified one per resource or in
	     ranges (start != end)
	  3. iff all events (channels and, optionally, error) on this
	     controller use the same IRQ, only one IRQ resource can be
	     specified, otherwise there must be one IRQ per channel, even if
	     some of them are equal
	  4. if all IRQs on this controller are equal or if some specific IRQs
	     specify IORESOURCE_IRQ_SHAREABLE in their resources, they will be
	     requested with the IRQF_SHARED flag
 Default transfer size of 32 bytes requires 32-byte alignment 
 platform data 
 reset dma controller - only needed as a test 
 Special case - all multiplexed 
 Create DMA Channel 
 Wire up NMI handling 
 SPDX-License-Identifier: GPL-2.0-or-later
  SiFive FU540 Platform DMA driver
  Copyright (C) 2019 SiFive
  Based partially on:
  - driversdmafsl-edma.c
  - driversdmadw-edma
  - driversdmapxa-dma.c
  See the following sources for further documentation:
  - Chapter 12 "Platform DMA Engine (PDMA)" of
    SiFive FU540-C000 v1.0
    https:static.dev.sifive.comFU540-C000-v1.0.pdf
 fail to recover 
 retry 
 submit next trascatioin if possible 
  sf_pdma_irq_init() - Init PDMA IRQ Handlers
  @pdev: pointer of platform_device
  @pdma: pointer of PDMA engine. Caller should check NULL
  Initialize DONE and ERROR interrupt handler for 4 channels. Caller should
  make sure the pointer passed in are non-NULL. This function should be called
  only one time during the device probe.
  Context: Any context.
  Return:
   0		- OK to init all IRQ handlers
   -EINVAL	- Fail to request IRQ
  sf_pdma_setup_chans() - Init settings of each channel
  @pdma: pointer of PDMA engine. Caller should check NULL
  Initialize all data structure and register base. Caller should make sure
  the pointer passed in are non-NULL. This function should be called only
  one time during the device probe.
  Context: Any context.
  Return: none
 Setup capability 
 Setup DMA APIs 
 do early init 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2006-2009 DENX Software Engineering.
  Author: Yuri Tikhonov <yur@emcraft.com>
  Further porting to archpowerpc by
  	Anatolij Gustschin <agust@denx.de>
  This driver supports the asynchrounous DMA copy and RAID engines available
  on the AMCC PPC440SPe Processors.
  Based on the Intel Xscale(R) family of IO Processors (IOP 32x, 33x, 134x)
  ADMA driver written by D.Williams.
 The list of channels exported by ppc440spe ADMA 
 This flag is set when want to refetch the xor chain in the interrupt
  handler
 Pointer to DMA0, DMA1 CPCS FIFO 
 Pointers to last submitted to DMA0, DMA1 CDBs 
 Pointer to last linked and submitted xor CB 
 This array is used in data-check operations for storing a pattern 
 Since RXOR operations use the common register (MQ0_CF2H) for setting-up
  the block size in transactions, then we do not allow to activate more than
  only one RXOR transactions simultaneously. So use this var to store
  the information about is RXOR currently active (PPC440SPE_RXOR_RUN bit is
  set) or not (PPC440SPE_RXOR_RUN is clear).
 These are used in enable & check routines
  Command (Descriptor) Blocks low-level routines
  ppc440spe_desc_init_interrupt - initialize the descriptor for INTERRUPT
  pseudo operation
 NOP with Command Block Complete Enable 
 NOP with interrupt 
  ppc440spe_desc_init_null_xor - initialize the descriptor for NULL XOR
  pseudo operation
  ppc440spe_desc_init_xor - initialize the descriptor for XOR operation
 Enable interrupt on completion 
  ppc440spe_desc_init_dma2pq - initialize the descriptor for PQ
  operation in DMA2 controller
 Enable interrupt on completion 
  ppc440spe_desc_init_dma01pq - initialize the descriptors for PQ operation
  with DMA01
 Common initialization of a PQ descriptors chain 
	 WXOR MULTICAST if both P and Q are being computed
	  MV_SG1_SG2 if Q only
 set 'next' pointer 
			 this is the last descriptor.
			  this slot will be pasted from ADMA level
			  each time it wants to configure parameters
			  of the transaction (src, dst, ...)
 Set OPS depending on WXORRXOR type of operation 
		 This is a WXOR only chain:
		  - first descriptors are for zeroing destinations
		    if PPC440SPE_ZERO_PQ set;
		  - descriptors remained are for GF-XOR operations.
 This is either RXOR-only or mixed RXORWXOR 
		 The first 1 or 2 slots in chain are always RXOR,
		  if need to calculate P & Q, then there are two
		  RXOR slots; if only P or only Q, then there is one
 The remaining descs (if any) are WXORs 
  ppc440spe_desc_init_dma01pqzero_sum - initialize the descriptor
  for PQ_ZERO_SUM operation
	
	  Initialize starting from 2nd or 3rd descriptor dependent
	  on dst_cnt. First one or two slots are for cloning P
	  andor Q to chan->pdest andor chan->qdest as we have
	  to preserve original PQ.
 initialize each source descriptor in chain 
		 This is a ZERO_SUM operation:
		  - <src_cnt> descriptors starting from 2nd or 3rd
		    descriptor are for GF-XOR operations;
		  - remaining <dst_cnt> descriptors are for checking the result
			 MV_SG1_SG2 if only Q is being verified
			  MULTICAST if both P and Q are being verified
 DMA_CDB_OPC_DCHECK128 operation 
 set 'next' pointer 
			 this is the last descriptor.
			  this slot will be pasted from ADMA level
			  each time it wants to configure parameters
			  of the transaction (src, dst, ...)
			 always enable interrupt generation since we get
			  the status of pqzero from the handler
  ppc440spe_desc_init_memcpy - initialize the descriptor for MEMCPY operation
  ppc440spe_desc_set_src_addr - set source address into the descriptor
  ppc440spe_desc_set_src_mult - set source address mult into the descriptor
		 for RXOR operations set multiplier
		  into source cued address
		 for WXOR operations set multiplier
		  into destination cued address(es)
  ppc440spe_desc_set_dest_addr - set destination address into the descriptor
  ppc440spe_desc_set_byte_count - set number of data bytes involved
  into the operation
  ppc440spe_desc_set_rxor_block_size - set RXOR block size
	 assume that byte_count is aligned on the 512-boundary;
	  thus write it directly to the register (bits 23:31 are
	  reserved there).
  ppc440spe_desc_set_dcheck - set CHECK pattern
  ppc440spe_xor_set_link - set link address in xor CB
  ppc440spe_desc_set_link - set the address of descriptor following this
  descriptor in chain
		 If previous next is overwritten something is wrong.
		  though we may refetch from append to initiate list
		  processing; in this case - it's ok.
 do sw chaining both for DMA and XOR descriptors 
 bind descriptor to the chain 
 do not link to the last submitted CB 
  ppc440spe_desc_get_link - get the address of the descriptor that
  follows this one
  ppc440spe_desc_is_aligned - check alignment
  ppc440spe_chan_xor_slot_count - get the number of slots necessary for
  XOR operation
 each XOR descriptor provides up to 16 source operands 
  ppc440spe_dma2_pq_slot_count - get the number of slots necessary for
  DMA2 PQ operation
 direct RXOR 
 reverse RXOR 
  ADMA channel low-level routines
  ppc440spe_adma_device_clear_eot_status - interrupt ack to XOR or DMA engine
 read FIFO to ack 
			 Clear opcode to ack. This is necessary for
			  ZeroSum operations only
				 probably this is a completed RXOR op,
				  get pointer to CDB using the fact that
				  physical and virtual addresses of CDB
				  in pools have the same offsets
 this is a RXOR 
				 ZeroSum check failed
				
				  Update the status of corresponding
				  descriptor.
				
				  if cannot find the corresponding
				  slot it's a bug
 write back to clear 
 reset status bits to ack 
				 Read PLB Timeout Error.
				  Try to resubmit the CB
		  if the XORcore is idle, but there are unprocessed CBs
		  then refetch the sw chain here
  ppc440spe_chan_is_busy - get the channel status
		  if command FIFO's head and tail pointers are equal and
		  status tail is the same as command, then channel is free
		 use the special status bit for the XORcore
  ppc440spe_chan_set_first_xor_descriptor -  init XORcore chain
  ppc440spe_dma_put_desc - put DMA0,1 descriptor to FIFO.
  called with irqs disabled
  ppc440spe_chan_append - update the hw chain in the channel
 first peer 
 is there something new to append 
 flush descriptors from the sw queue to fifo 
 update hw links and refetch 
		 the last linked CDB has to generate an interrupt
		  that we'd be able to append the next lists to hw
		  regardless of the XOR engine state at the moment of
		  appending of these next lists
 XORcore is idle. Refetch now 
 XORcore is running. Refetch later in the handler 
  ppc440spe_chan_get_current_descriptor - get the currently executed descriptor
 hw descriptor chain is not initialized yet 
  ppc440spe_chan_run - enable the channel
 DMAs are always enabled, do nothing 
 drain write buffer 
 fetch descriptor pointed to in <link> 
  ADMA device level
  ppc440spe_can_rxor - check if the operands may be processed with RXOR
 Skip holes in the source list before checking 
 direct RXOR 
 reverse RXOR 
  ppc440spe_adma_device_estimate - estimate the efficiency of processing
 	the operation given on this channel. It's assumed that 'chan' is
 	capable to process 'cap' type of operation.
  @chan: channel to use
  @cap: type of transaction
  @dst_lst: array of destination pointers
  @dst_cnt: number of destination operands
  @src_lst: array of source pointers
  @src_cnt: number of source operands
  @src_sz: size of each source operand
		 If RAID-6 capabilities were not activated don't try
		  to use them
	  In the current implementation of ppc440spe ADMA driver it
	  makes sense to pick out only pq case, because it may be
	  processed:
	  (1) either using Biskup method on DMA2;
	  (2) or on DMA01.
	   Thus we give a favour to (1) if the sources are suitable;
	  else let it be processed on one of the DMA01 engines.
	   In the sum_product case where destination is also the
	  source process it on DMA01 only.
 sum_product case, process on DMA01 
 override (DMA01 + idle) 
 can't process on DMA2 if !rxor 
 channel idleness increases the priority 
		
		  should a user of the api ever pass > PAGE_SIZE requests
		  we sort out cases where temporary page-sized buffers
		  are used.
  ppc440spe_get_group_entry - get group entry with index idx
  @tdesc: is the last allocated slot in the group.
  ppc440spe_adma_free_slots - flags descriptor slots for reuse
  @slot: Slot to free
  Caller must hold &ppc440spe_chan->lock while calling this function
  ppc440spe_adma_run_tx_complete_actions - call functions to be called
  upon completion
		 call the callback (must not sleep or submit new
		  operations to this channel)
 run dependent operations 
  ppc440spe_adma_clean_slot - clean up CDB slot (if ack is set)
	 the client is allowed to attach dependent operations
	  until 'ack' is set
	 leave the last descriptor in the chain
	  so we can append to it
		 our DMA interrupt handler clears opc field of
		  each processed descriptor. For all types of
		  operations except for ZeroSum we do not actually
		  need ack from the interrupt handler. ZeroSum is a
		  special case since the result of this operation
		  is available from the handler only, so if we see
		  such type of descriptor (which is unprocessed yet)
		  then leave it in chain.
  __ppc440spe_adma_slot_cleanup - this is the common clean-up routine
 	which runs through the channel CDBs list until reach the descriptor
 	currently processed. When routine determines that all CDBs of group
 	are completed then corresponding callbacks (if any) are called and slots
 	are freed.
		  There were no transactions yet, so
		  nothing to clean
	 free completed slots from the chain starting with
	  the oldest descriptor
		 do not advance past the current descriptor loaded into the
		  hardware channel,subsequent descriptors are either in process
		  or have not been submitted
		 stop the search if we reach the current descriptor and the
		  channel is busy, or if it appears that the current descriptor
		  needs to be re-read (i.e. has been appended to)
				 not all descriptors of the group have
				  been completed; exit.
 detect the start of a group transaction 
 all the members of a group are complete 
 clean up the group 
 Should wait for ZeroSum completion 
 the group should be complete at this point 
 wait for group completion 
  ppc440spe_adma_tasklet - clean up watch-dog initiator
  ppc440spe_adma_slot_cleanup - clean up scheduled initiator
  ppc440spe_adma_alloc_slots - allocate free slots (if any)
	 start search from the last allocated descrtiptor
	  if a contiguous allocation can not be found start searching
	  from the beginning of the list
 start the allocation if the slot is correctly aligned 
 pre-ack all but the last descriptor 
 try to free some slots if the allocation fails 
  ppc440spe_adma_alloc_chan_resources -  allocate pools for CDB slots
 Allocate descriptor slots 
 initialize the channel and the chain with a null operation 
 Use WXOR for self-testing 
  ppc440spe_rxor_set_region_data -
  ppc440spe_rxor_set_src -
  ppc440spe_rxor_set_mult -
  ppc440spe_adma_check_threshold - append CDBs to hw chain if threshold
 	has been achieved
  ppc440spe_adma_tx_submit - submit new descriptor group to the channel
 	(it's not necessary that descriptors will be submitted to the hw
 	chains too right now)
 first peer 
 isn't first peer, bind CDBs to chain 
 fix up the hardware chain 
 increment the pending count by the number of operations 
  ppc440spe_adma_prep_dma_interrupt - prepare CDB for a pseudo DMA operation
  ppc440spe_adma_prep_dma_memcpy - prepare CDB for a MEMCPY operation
  ppc440spe_adma_prep_dma_xor - prepare CDB for a XOR operation
  ppc440spe_adma_init_dma2rxor_slot -
 initialize CDB 
  ppc440spe_dma01_prep_mult -
  for Q operation where destination is also the source
 use WXOR, each descriptor occupies one slot 
		 First descriptor, zero data in the destination and copy it
		  to q page using MULTICAST transfer.
 set 'next' pointer 
		
		  Second descriptor, multiply data from the q page
		  and store the result in real destination.
  ppc440spe_dma01_prep_sum_product -
  Dx = A(P+Pxy) + B(Q+Qxy) operation where destination is also
  the source.
 WXOR, each descriptor occupies one slot 
 1st descriptor, src[1] data to q page and zero destination 
		 2nd descriptor, multiply src[1] data and store the
 set 'next' pointer 
		
		  3rd descriptor, multiply src[0] data and xor it
		  with destination
	  select operations WXORRXOR depending on the
	  source addresses of operators and the number
	  of destinations (RXOR support only Q-parity calculations)
		 no active RXOR;
		  do RXOR if:
		  - there are more than 1 source,
		  - len is aligned on 512-byte boundary,
		  - source addresses fit to one of 4 possible regions.
 may do RXOR R1 R2 
 may try to enhance region of RXOR 
 do RXOR R1 R2 R3 
 do RXOR R1 R2 R4 
 do RXOR R1 R2 R5 
 do RXOR R1 R2 
 do RXOR R1 R2 
 can not do this operation with RXOR 
 can do; set block size right now 
 Number of necessary slots depends on operation type selected 
		  This is a WXOR only chain. Need descriptors for each
		  source to GF-XOR them with WXOR, and need descriptors
		  for each destination to zero them with WXOR
		  Need 12 descriptor for RXOR operation, and
		  need (src_cnt - (2 or 3)) for WXOR of sources
		  remained (if any)
		  Thus we have either RXOR only chain or
		  mixed RXORWXOR
 RXOR only chain 
 for both RXORWXOR each descriptor occupies one slot 
 setup dstsrcmult 
			 NOTE: "Multi = 0 is equivalent to = 1" as it
			  stated in 440SPSPe_RAID6_Addendum_UM_1_17.pdf
			  doesn't work for RXOR with DMA01! Instead, multi=0
			  leads to zeroing source data after RXOR.
			  So, for P case set-up mult=1 explicitly.
 Setup byte count foreach slot just allocated 
	pr_debug("%s: dst_cnt %d, src_cnt %d, len %d\n",
 depending on number of sources we have 1 or 2 RXOR chains 
 set 'next' pointer 
 this is the last descriptor. 
 fixup head descriptor 
 setup dstsrcmult 
			 handle descriptors (if dst_cnt == 2) inside
			  the ppc440spe_adma_pq_set_srcxxx() functions
  ppc440spe_adma_prep_dma_pq - prepare CDB (group) for a GF-XOR operation
 dst[1] is real destination (Q) 
 this is the page to multicast source data to 
  ppc440spe_adma_prep_dma_pqzero_sum - prepare CDB group for
  a PQ_ZERO_SUM operation
	 Always use WXOR for PQ calculations (two destinations).
	  Need 1 or 2 extra slots to verify results are zero.
	 One additional slot per destination to clone PQ
	  before calculation (we have to preserve destinations).
 Setup byte count for each slot just allocated 
 override pdest to preserve original P 
 override qdest to preserve original Q 
 Setup destinations for PQ ops 
 Setup zero QWORDs into DCHECK CDBs 
			
			  The last CDB corresponds to Q-parity check,
			  the one before last CDB corresponds
			  P-parity check
			
			  set it to zero, if check fail then result will
			  be updated
 Setup sources and mults for PQ ops 
  ppc440spe_adma_prep_dma_xor_zero_sum - prepare CDB group for
  XOR ZERO_SUM operation
 validate P, disable Q 
  ppc440spe_adma_set_dest - set destination address into descriptor
		 to do: support transfers lengths >
		  PPC440SPE_ADMA_DMAXOR_MAX_BYTE_COUNT
	  To clear destinations update the descriptor
	  (P or Q depending on index) as follows:
	  addr is destination (0 corresponds to SG2):
 ... and the addr is source: 
 addr is always SG2 then the mult is always DST1 
  ppc440spe_adma_pq_set_dest - set destination address into descriptor
  for the PQXOR operation
		 walk through the WXOR source list and set PQ-destinations
		  for each slot:
 This is WXOR-only chain; may have 12 zero descs 
 one destination 
 two destinations 
				  To clear destinations update the descriptor
				  (1st,2nd, or both depending on flags)
 This is RXOR-only or RXORWXOR mixed chain 
			 If we want to include destination into calculations,
			  then make dest addresses cued with mult=1 (XOR).
 Setup destination(s) in RXOR slot(s) 
 two destinations 
				 Setup destination(s) in remaining WXOR
				  slots
 one destination 
 two destinations 
		 DMA2 descriptors have only 1 destination, so there are
		  two chains - one for each dest.
		  If we want to include destination into calculations,
		  then make dest addresses cued with mult=1 (XOR).
 Two destinations; setup Q here 
  ppc440spe_adma_pq_zero_sum_set_dest - set destination address into descriptor
  for the PQ_ZERO_SUM operation
	 walk through the WXOR source list and set PQ-destinations
	  for each slot
 set end 
 set start 
 two destinations 
 one destination 
	  The remaining descriptors are DATACHECK. These have no need in
	  destination. Actually, these destinations are used there
	  as sources for check operation. So, set addr as source.
  ppc440spe_desc_set_xor_src_cnt - set source count into descriptor
  ppc440spe_adma_pq_set_src - set source address into descriptor
		 DMA0,1 may do: WXOR, RXOR, RXOR+WXORs chain
 RXOR-only or RXORWXOR operation 
 1st slot (RXOR) 
				 setup sources region (R1-2-3, R1-2-4,
				  or R1-2-5)
				 1st slot (RXOR)
				  shall actually set source address only once
				  instead of first <iskip>
				 2nd3d and next slots (WXOR);
				  skip first slot with RXOR
			 WXOR-only operation; skip first slots with
			  zeroing destinations
				 if we have two destinations for RXOR, then
				  setup source in the second descr too
 DMA2 may do Biskup 
 both P & Q calculations required; set P src here 
 this is for Q 
  ppc440spe_adma_memcpy_xor_set_src - set source address into descriptor
  ppc440spe_adma_dma2rxor_inc_addr  -
  ppc440spe_adma_dma2rxor_prep_src - setup RXOR types in DMA2 CDB
 direct RXOR 
 reverse RXOR 
  ppc440spe_adma_dma2rxor_set_src - set RXOR source address; it's assumed that
 	ppc440spe_adma_dma2rxor_prep_src() has already done prior this call
 get the RXOR operand which corresponds to index addr 
 reverse operand order; put last op in RXOR group 
 direct operand order; put first op in RXOR group 
  ppc440spe_adma_dma2rxor_set_mult - set RXOR multipliers; it's assumed that
 	ppc440spe_adma_dma2rxor_prep_src() has already done prior this call
 get the RXOR operand which corresponds to index mult 
 reverse order 
 direct order 
  ppc440spe_init_rxor_cursor -
  ppc440spe_adma_pq_set_src_mult - set multiplication coefficient into
  descriptor for the PQXOR operation
 RXOR multipliers 
 WXOR multiplier 
			 WXOR-only;
			  skip first slots with destinations (if ZERO_DST has
			  place)
				 if we have two destinations for RXOR, then
				  we've just set Q mult. Set-up P now.
 both P & Q calculations required; set P mult here 
 and then set Q mult 
  ppc440spe_adma_free_chan_resources - free the resources allocated
 one is ok since we left it on there on purpose 
  ppc440spe_adma_tx_status - poll the status of an ADMA transaction
  @chan: ADMA channel handle
  @cookie: ADMA transaction identifier
  @txstate: a holder for the current state of the channel
  ppc440spe_adma_eot_handler - end of transfer interrupt handler
  ppc440spe_adma_err_handler - DMA error interrupt handler;
 	do the same things as a eot handler
  ppc440spe_test_callback - called when test operation has been done
  ppc440spe_adma_issue_pending - flush all pending descriptors to hw
  ppc440spe_chan_start_null_xor - initiate the first XOR operation (DMA engines
 	use FIFOs (as opposite to chains used in XOR) so this is a XOR
 	specific operation)
		 initialize the completed cookie to be less than
		  the most recently used cookie
 channel should not be busy 
 set the descriptor address 
 run the descriptor 
  ppc440spe_test_raid6 - test are RAID-6 capabilities enabled successfully.
 	For this we just perform one WXOR operation with the same source
 	and destination addresses, the GF-multiplier is 1; so if RAID-6
 	capabilities are enabled then we'll get srcdst filled with zero.
 1 src, 1 dsr, int_ena, WXOR 
 Fill the test page with ones 
 Setup addresses 
 Now check if the test page is zeroed 
 page is zero - RAID-6 enabled 
 RAID-6 was not enabled 
 Set base routines 
 Set prep routines based on capability 
	 only DMA engines have a separate error IRQ
	  so it's Ok if err_irq < 0 in XOR engine case.
 both DMA engines share common error IRQ 
 enable XOR engine interrupts 
		 Unmask 'CS FIFO Attention' interrupts and
		  enable generating interrupts on errors
 disable XOR engine interrupts 
 disable DMAx engine interrupts 
  ppc440spe_adma_probe - probe the asynch device
		 As far as the XOR engine is concerned, it does not
		  use FIFOs but uses linked list. So there is no dependency
		  between pool size to allocate and the engine configuration.
 it is DMA0 or DMA1 
		 DMA0,1 engines use FIFO to maintain CDBs, so we
		  should allocate the pool accordingly to size of this
		  FIFO. Thus, the pool size depends on the FIFO depth:
		  how much CDBs pointers the FIFO may contain then so
		  much CDBs we should provide in the pool.
		  That is
		    CDB size = 32B;
		    CDBs number = (DMA0_FIFO_SIZE >> 3);
		    Pool size = CDBs number  CDB size =
		       = (DMA0_FIFO_SIZE >> 3) << 5 = DMA0_FIFO_SIZE << 2.
 create a device 
 allocate coherent memory for hardware descriptors 
 Reset XOR 
		 DMAx_FIFO_SIZE is defined in bytes,
		  <fsiz> - is defined in number of CDB pointers (8byte).
		  DMA FIFO Length = CSlength + CPlength, where
		  CSlength = CPlength = (fsiz + 1)  8.
 Configure DMA engine 
 Clear Status 
 create a channel 
	 allocate and map helper pages for async validation or
	  async_multasync_sum_product operations on DMA01.
  ppc440spe_adma_remove - remove the asynch device
  sys driver interface to enable hw RAID-6 capabilities
  Files created in e.g. sysdevicesplb.0400100100.dma0driver
  directory are "devices", "enable" and "poly".
  "devices" shows available engines.
  "enable" is used to enable RAID-6 capabilities or to check
  whether these has been activated.
  "poly" allows settingchecking used polynomial (for PPC440SPe only).
 Write a key 
 Verify whether it really works now 
 440SP has fixed polynomial 
 440SP uses default 0x14D polynomial only 
 e.g., 0x14D or 0x11D 
  Common initialisation for RAID engines; allocate memory for
  DMAx FIFOs, perform configuration common for all DMA engines.
  Further DMA engine specific configuration is done at probe time.
 Get I2O DCRs base 
	 Provide memory regions for DMA's FIFOs: I2O, DMA0 and DMA1 share
	  the base address of FIFO memory space.
	  Actually we need twice more physical memory than programmed in the
	  <fsiz> register (because there are two FIFOs for each DMA: CP and CS)
	
	  Configure hw
 Reset I2ODMA 
 Setup the base address of mmaped registers 
 Setup FIFO memory space base address 
	 set zero FIFO size for I2O, so the whole
	  ppc440spe_dma_fifo_buf is used by DMAs.
	  DMAx_FIFOs will be configured while probe.
	 To prepare WXORRXOR functionality we need access to
	  Memory Queue Module DCRs (finally it will be enabled
	  via sys interface of the ppc440spe ADMA driver).
 Get MQ DCRs base 
 Set HB alias 
	 Set:
	  - LL transaction passing limit to 1;
	  - Memory controller cycle limit to 1;
	  - Galois Polynomial to 0x14d (default)
 Initialization status 
 RAID-6 hw enable entry 
 GF polynomial to use 
 User will not be able to enable hw RAID-6 
 SPDX-License-Identifier: GPL-2.0
  Lightning Mountain centralized DMA controller driver
  Copyright (c) 2016 - 2020 Intel Corporation.
 Adaptive Burst Chop 
  If header mode is set in DMA descriptor,
    If bit 30 is disabled, HDR_LEN must be configured according to channel
      requirement.
    If bit 30 is enabled(checksum with heade mode), HDR_LEN has no need to
      be configured. It will enable check sum for switch
  If header mode is not set in DMA descriptor,
    This register setting doesn't matter
 DMA controller capability 
 DMA flags 
 Descriptor fields 
 back pointer 
 Channel name 
 Channel id in hardware 
 central way or channel based way 
 Virtual address 
 Number of descriptors 
 Descriptors pool 
 back pointer 
 Instance specific data 
 Fetch On Demand 
 Outstanding read count 
 channel list on this DMA or port 
 Controller register exclusive 
 Read from hardware 
 Keep the class value unchanged 
 Clear all interrupts and disabled it 
 3 bits low 
 2 bits high 
 If descriptors not configured, not allow to turn on channel 
 Higher 4 bits of 36 bit addressing 
 NB, csum disabled, hdr length must be provided 
 Only valid for RX channel 
 read back 
 DMA port initialization 
 DMA channel initialization 
 Get the next descriptor 
	
	  clear any pending work if any. In that
	  case the resource needs to be free here.
 Disable channel interrupts  
 Mask 
 Ack 
 TX and RX has the same burst length 
 sop and eop has to be handled nicely 
 Only 32 bit address supported 
 Ensure data ready before ownership change 
 Ensure ownership changed before moving forward 
 if args_count is 1 driver use default settings 
 Real channel number 
 Link controller to platform device 
 Power up and reset the dma engine, some DMAs always on?? 
 Channel initializations 
 Port Initializations 
 Channels Initializations 
  Perform this driver as device_initcall to make sure initialization happens
  before its DMA clients of some are platform specific and also to provide
  registered DMA channels and DMA capabilities to clients before their
  initialization.
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2013,2018,2020-2021 Intel Corporation
 DMA Channel ID Configuration register must be programmed first 
 Configure channel attributes 
		
		  Memory-to-Memory and Device-to-Device are ignored for now.
		 
		  For Memory-to-Memory transfers we would need to set mode
		  and disable snooping on both sides.
 Configure crossbar selection 
 DEVFN selection 
 Memory-to-Memory and Device-to-Device are ignored for now 
 Configure DMA channel low and high registers 
 Memory-to-Memory and Device-to-Device are ignored for now 
 Set default burst alignment 
 Low 4 bits of the request lines 
 Request line extension (2 bits) 
 Set default burst alignment 
 Low 4 bits of the request lines 
 Request line extension (2 bits) 
  Program FIFO size of channels.
  By default full FIFO (512 bytes) is assigned to channel 0. Here we
  slice FIFO on equal parts between channels.
 Fill FIFO_PARTITION low bits (Channels 0..1, 4..5) 
 Fill FIFO_PARTITION high bits (Channels 2..3, 6..7) 
 Program FIFO Partition registers - 64 bytes per channel 
 Channel operations 
 Device operations 
 SPDX-License-Identifier: GPL-2.0
  Platform driver for the Synopsys DesignWare DMA Controller
  Copyright (C) 2007-2008 Atmel Corporation
  Copyright (C) 2010-2011 ST Microelectronics
  Copyright (C) 2013 Intel Corporation
 TODO: there should be a simpler way to do this 
 Try deprecated property first 
 If "data_width" and "data-width" both provided use the latter one 
 SPDX-License-Identifier: GPL-2.0
  PCI driver for the Synopsys DesignWare DMA Controller
  Copyright (C) 2013 Intel Corporation
  Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
 CONFIG_PM_SLEEP 
 Medfield (GPDMA) 
 BayTrail 
 Merrifield 
 Braswell 
 Elkhart Lake iDMA 32-bit (PSE DMA) 
 Haswell 
 Broadwell 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2007-2008 Atmel Corporation
 Copyright (C) 2010-2011 ST Microelectronics
 Copyright (C) 2013,2018 Intel Corporation
 Set polarity of handshake interface 
	
	  Fix burst size according to dw_dmac. We need to convert them as:
	  1 -> 0, 4 -> 1, 8 -> 2, 16 -> 3.
 Channel operations 
 Device operations 
 SPDX-License-Identifier: GPL-2.0
  Platform driver for the Synopsys DesignWare DMA Controller
  Copyright (C) 2007-2008 Atmel Corporation
  Copyright (C) 2010-2011 ST Microelectronics
  Copyright (C) 2013 Intel Corporation
  Some parts of this driver are derived from the original dw_dmac.
	
	  We have to call do_dw_dma_disable() to stop any ongoing transfer. On
	  some platforms we can't do that since DMA device is powered off.
	  Moreover we have no possibility to check if the platform is affected
	  or not. That's why we call pm_runtime_get_sync()  pm_runtime_put()
	  unconditionally. On the other hand we can't use
	  pm_runtime_suspended() because runtime PM framework is not fully
	  used by the driver.
 Elkhart Lake iDMA 32-bit (PSE DMA) 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0
  Core driver for the Synopsys DesignWare DMA Controller
  Copyright (C) 2007-2008 Atmel Corporation
  Copyright (C) 2010-2011 ST Microelectronics
  Copyright (C) 2013 Intel Corporation
  This supports the Synopsys "DesignWare AHB Central DMA Controller",
  (DW_ahb_dmac) which is used with various AMBA 2.0 systems (not all
  of which use ARM any more).  See the "Databook" from Synopsys for
  information beyond what licensees probably provide.
  The driver has been tested with the Atmel AT32AP7000, which does not
  support descriptor writeback.
 The set of bus widths supported by the DMA controller 
----------------------------------------------------------------------
	
	  REVISIT: We should attempt to chain as many descriptors as
	  possible, perhaps even appending to those already submitted
	  for DMA. But this is hard to do in a race-free manner.
 Enable interrupts 
----------------------------------------------------------------------
----------------------------------------------------------------------
 Perform single block transfer 
	
	  Software emulation of LLP mode relies on interrupts to continue
	  multi block transfer.
 Move pointer to next descriptor 
 Called with dwc->lock held and bh disabled 
 ASSERT:  channel is idle 
 The tasklet will hopefully advance the queue... 
 Submit first block 
----------------------------------------------------------------------
 async_tx_ack 
 Try to continue after resetting the channel... 
	
	  Submit queued descriptors ASAP, i.e. before we go through
	  the completed ones.
 Returns how many bytes were already received from source 
 Everything we've submitted is done 
			
			  We are inside first active descriptor.
			  Otherwise something is really wrong.
 Update residue to reflect last sent descriptor 
 Submit next block 
 We are done here 
 Initial residue value 
 Check first descriptors addr 
 Check first descriptors llp 
 This one is currently in progress 
 Currently in progress 
		
		  No descriptors so far seem to be in progress, i.e.
		  this one must be done.
 Try to continue after resetting the channel... 
	
	  The descriptor currently at the head of the active list is
	  borked. Since we don't have any way to report errors, we'll
	  just have to scream loudly and try to carry on.
 Clear the error flag and try to restart the controller 
	
	  WARN may seem harsh, but since this only happens
	  when someone submits a bad physical address in a
	  descriptor, we should consider ourselves lucky that the
	  controller flagged an error instead of scribbling over
	  random memory locations.
 Pretend the descriptor completed successfully 
 Re-enable interrupts 
 Check if we have any interrupt from the DMAC which is not in use 
 Check if we have any interrupt from the DMAC 
	
	  Just disable the interrupts. We'll turn them back on in the
	  softirq handler.
 Try to recover 
----------------------------------------------------------------------
 Trigger interrupt after last block 
 Trigger interrupt after last block 
 permit channels in accordance with the channels mask 
 We have to copy data since dws can be temporary storage 
 timeout iterations 
 active_list entries will end up before queued entries 
 Flush all pending and queued descriptors 
----------------------------------------------------------------------
 ASSERT:  channel is idle 
	
	  NOTE: some controllers may have additional features that we
	  need to initialize here, like "scatter-gather" (which
	  doesn't mean what you think it means), and status writeback.
	
	  We need controller-specific data to set up slave transfers.
 Enable controller here if needed 
 ASSERT:  channel is idle 
 Clear custom channel configuration 
 Disable interrupts 
 Disable controller in case it was a last user 
	
	  It might be crucial for some devices to have the hardware
	  accelerated multi-block transfers supported, aka LLPs in DW DMAC
	  notation. So if LLPs are supported then max_sg_burst is set to
	  zero which means unlimited number of SG entries can be handled in a
	  single DMA transaction, otherwise it's just one SG entry.
 Reassign the platform data pointer 
 Get hardware configuration parameters 
 Fill platform data with the default values 
 Reassign the platform data pointer 
 Calculate all channel mask before DMA setup 
 Force dma off, just in case 
 Device and instance ID for IRQ and DMA pool 
 Create a pool of consistent memory blocks for hardware descriptors 
 7 is highest priority & 0 is lowest. 
 Hardware configuration 
			
			  Decode maximum block size for given channel. The
			  stored 4 bit value represents blocks from 0x00 for 3
			  up to 0x0a for 4095.
			
			  According to the DW DMA databook the true scatter-
			  gether LLPs aren't available if either multi-block
			  config is disabled (CHx_MULTI_BLK_EN == 0) or the
			  LLP register is hard-coded to zeros
			  (CHx_HC_LLP == 1).
 Clear all interrupts on all channels. 
 Set capabilities 
 DMA capabilities 
	
	  For now there is no hardware with non uniform maximum block size
	  across all of the device channels, so we set the maximum segment
	  size as the block size found for the very first channel.
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2013,2019 Intel Corporation
 SPDX-License-Identifier: GPL-2.0-only
  PCI driver for the High Speed UART DMA
  Copyright (C) 2015 Intel Corporation
  Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
  Partially based on the bits found in driversttyserialmfd.c.
	
	  On Intel Tangier B0 and Anniedale the interrupt line, disregarding
	  to have different numbers, is shared between HSU DMA and UART IPs.
	  Thus on such SoCs we are expecting that IRQ handler is called in
	  UART driver only. Instead of handling the spurious interrupt
	  from HSU DMA here and waste CPU time and delay HSU UART interrupt
	  handling, disable the interrupt entirely.
 SPDX-License-Identifier: GPL-2.0-only
  Core driver for the High Speed UART DMA
  Copyright (C) 2015 Intel Corporation
  Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
  Partially based on the bits found in driversttyserialmfd.c.
  DMA channel allocation:
  1. Even number chans are used for DMA Read (UART TX), odd chans for DMA
     Write (UART RX).
  2. 01 channel are assigned to port 0, 23 chan to port 1, 45 chan to
     port 3, and so on.
 to shut the compiler up 
 Set descriptors 
 Prepare value for DCR 
 timeout bit, see HSU Errata 1 
 Only for the last descriptor in the chain 
 Get the next descriptor 
 Start the channel with a new descriptor 
       hsu_dma_get_status() - get DMA channel status
       @chip: HSUART DMA chip
       @nr: DMA channel number
       @status: pointer for DMA Channel Status Register value
       Description:
       The function reads and clears the DMA Channel Status Register, checks
       if it was a timeout interrupt and returns a corresponding value.
       Caller should provide a valid pointer for the DMA Channel Status
       Register value that will be returned in @status.
       Return:
       1 for DMA timeout status, 0 for other DMA status, or error code for
       invalid parameters or no interrupt pending.
 Sanity check 
	
	  No matter what situation, need read clear the IRQ status
	  There is a bug, see Errata 5, HSD 2900918
 Check if any interrupt is pending 
 Timeout IRQ, need wait some time, see Errata 2 
	
	  At this point, at least one of Descriptor Time Out, Channel Error
	  or Descriptor Done bits must be set. Clear the Descriptor Time Out
	  bits and if sr is still non-zero, it must be channel error or
	  descriptor done which are higher priority than timeout and handled
	  in hsu_dma_do_irq(). Else, it must be a timeout.
       hsu_dma_do_irq() - DMA interrupt handler
       @chip: HSUART DMA chip
       @nr: DMA channel number
       @status: Channel Status Register value
       Description:
       This function handles Channel Error and Descriptor Done interrupts.
       This function should be called after determining that the DMA interrupt
       is not a normal timeout interrupt, ie. hsu_dma_get_status() returned 0.
       Return:
       0 for invalid channel number, 1 otherwise.
 Sanity check 
 desc->active = 0 by kzalloc 
 Calculate nr_channels from the IO space length 
 SPDX-License-Identifier: GPL-2.0-only
  AMD Passthru DMA device driver
  -- Based on the CCP driver
  Copyright (C) 2016,2021 Advanced Micro Devices, Inc.
  Author: Sanjay R Mehta <sanju.mehta@amd.com>
  Author: Tom Lendacky <thomas.lendacky@amd.com>
  Author: Gary R Hook <gary.hook@amd.com>
  pt_alloc_struct - allocate and initialize the pt_device struct
  @dev: device struct of the PTDMA
 Couldn't get MSI-X vectors, try MSI 
 Couldn't get MSI interrupt 
 Last entry must be zero 
 SPDX-License-Identifier: GPL-2.0-only
  AMD Passthrough DMA device driver
  -- Based on the CCP driver
  Copyright (C) 2016,2021 Advanced Micro Devices, Inc.
  Author: Sanjay R Mehta <sanju.mehta@amd.com>
  Author: Gary R Hook <gary.hook@amd.com>
 DebugFS helpers 
  Return a formatted buffer containing the current
  statistics of queue for PTDMA
 SPDX-License-Identifier: GPL-2.0-only
  AMD Passthru DMA device driver
  -- Based on the CCP driver
  Copyright (C) 2016,2021 Advanced Micro Devices, Inc.
  Author: Sanjay R Mehta <sanju.mehta@amd.com>
  Author: Gary R Hook <gary.hook@amd.com>
 Human-readable error strings 
 Turn on the run bit 
 Turn off the run bit 
 Copy 32-byte command descriptor to hw queue. 
 The data used by this command must be flushed to memory 
 Write the new tail address back to the queue register 
 Turn the queue back on using our cached control register 
	       
		 Log the error and flush the queue by
		 moving the head pointer
 On error, only save the first error value 
 Acknowledge the interrupt 
 Allocate a dma pool for the queue 
 ptdma core initialisation 
 Page alignment satisfies our needs for N <= 128 
 Preset some register values 
 Turn off the queues and disable interrupts until ready 
 Start with nothing 
 Clear the interrupt status 
 Request an irq 
 Update the device registers with queue information. 
 Register the DMA engine support 
 Set up debugfs entries 
 Unregister the DMA engine 
 Disable and clear interrupts 
 Turn off the run bit 
 Clear the interrupt status 
 Flush the cmd queue 
 Invoke the callback directly with an error code 
 SPDX-License-Identifier: GPL-2.0-only
  AMD Passthrough DMA device driver
  -- Based on the CCP driver
  Copyright (C) 2016,2021 Advanced Micro Devices, Inc.
  Author: Sanjay R Mehta <sanju.mehta@amd.com>
  Author: Gary R Hook <gary.hook@amd.com>
 Execute the command 
 Get the next DMA descriptor on the active list 
 Loop over descriptors until one is found with commands 
 No errors, keep going 
 Check for DMA descriptor completion 
 Don't submit cmd if no descriptor or DMA is paused 
 If there was nothing active, start processing 
 If there was something active, re-start 
	
	  PTDMA is intended to be used with the AMD NTB devices, hence
	  marking it as DMA_PRIVATE.
 Set base and prep routines 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2021 Intel Corporation. All rights rsvd. 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2021 Intel Corporation. All rights rsvd. 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2019 Intel Corporation. All rights rsvd. 
	
	  On host, MSIX vecotr 0 is used for misc interrupt. Therefore when we match
	  vector 1:1 to the WQ id, we need to add 1
	
	  At this point, the desc needs to be aborted is held by the completion
	  handler where it has taken it off the pending list but has not added to the
	  work list. It will be cleaned up by the interrupt handler when it sees the
	  IDXD_COMP_DESC_ABORT for completion status.
	
	  Grab the list lock so it will block the irq thread handler. This allows the
	  abort code to locate the descriptor need to be aborted.
	
	  The wmb() flushes writes to coherent DMA data before
	  possibly triggering a DMA read. The wmb() is necessary
	  even on UP because the recipient is a device.
	
	  Pending the descriptor to the lockless list for the irq_entry
	  that we designated the descriptor to.
		
		  It's not likely that we would receive queue full rejection
		  since the descriptor allocation gates at wq size. If we
		  receive a -EAGAIN, that means something went wrong such as the
		  device is not accepting descriptor at all.
 abort operation frees the descriptor 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2019 Intel Corporation. All rights rsvd. 
	
	  For dedicated WQ, this field is ignored and HW will use the WQCFG.priv
	  field instead. This field should be set to 1 for kernel descriptors.
  issue_pending() does not need to do anything since tx_submit() does the job
  already.
	
	  This pointer is protected by the refs taken by the dma_chan. It will remain valid
	  as long as there are outstanding channels.
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2019 Intel Corporation. All rights rsvd. 
 DSA ver 1.0 platforms 
 IAX ver 1.0 platforms 
	
	  We implement 1 completion list per MSI-X entry except for
	  entry 0, which is for errors and others.
 first MSI-X entry is not for wq interrupts 
			
			  The MSIX vector enumeration starts at 1 with vector 0 being the
			  misc interrupt that handles non IO completion events. The
			  interrupt handles are for IMS enumeration on guest. The misc
			  interrupt vector does not require a handle and therefore we start
			  the int_handles at index 0. Since 'i' starts at 1, the first
			  int_handles index will be 0.
 Disable error interrupt generation 
 reading generic capabilities 
 reading group capabilities 
 read engine capabilities 
 read workqueue capabilities 
 reading operation capabilities 
 If the configs are readonly, then load them from device 
	
	  When ->release() is called for the idxd->conf_dev, it frees all the memory related
	  to the idxd context. The driver still needs those bits in order to do the rest of
	  the cleanup. However, we do need to unbound the idxd sub-driver. So take a ref
	  on the device here to hold off the freeing while allowing the idxd sub-driver
	  to unbind.
	
	  If the CPU does not support MOVDIR64B or ENQCMDS, there's no point in
	  enumerating the device. We can not utilize it.
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2019 Intel Corporation. All rights rsvd. 
 IDXD engine attributes 
 Group attributes 
 IDXD work queue attribs 
 If we are changing queue type, clear the name 
	
	  This is temporarily placed here until we have SVM support for
	  dmaengine.
 IDXD device attribs 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2019 Intel Corporation. All rights rsvd. 
 Interrupt control bits 
 WQ control bits 
 Device control bits 
  This is function is only used for reset during probe and will
  poll for completion. Once the device is setup with interrupts,
  all commands will be done via interrupt completion.
	
	  After command submitted, release lock and go to sleep until
	  the command completes via interrupt.
 Wake up other pending commands 
 If the command is successful or if the device was enabled 
 If the command is successful or if the device was disabled 
 Device configuration bits 
 setup GRPWQCFG 
 setup GRPENGCFG 
 setup GRPFLAGS 
 Setup bandwidth token limit 
	
	  Instead of memset the entire shadow copy of WQCFG, copy from the hardware after
	  wq reset. This will copy back the sticky values that are present on some devices.
 byte 0-3 
 bytes 4-7 
 byte 8-11 
	
	  Here the priv bit is set depending on the WQ type. priv = 1 if the
	  WQ type is kernel to indicate privileged access. This setting only
	  matters for dedicated WQ. According to the DSA spec:
	  If the WQ is in dedicated mode, WQ PASID Enable is 1, and the
	  Privileged Mode Enable field of the PCI Express PASID capability
	  is 0, this field must be 0.
	 
	  In the case of a dedicated kernel WQ that is not able to support
	  the PASID cap, then the configuration will be rejected.
 bytes 12-15 
 TC-A 0 and TC-B 1 should be defaults 
 The driver does not support shared WQ mode in read-only config yet 
	
	  Load WQS bit fields
	  Iterate through all 256 bits 64 bits at a time
 Iterate through all 64 bits and check for wq set 
 No need to check beyond max wqs 
 Set group assignment for wq if wq bit is set 
 Iterate through all 64 bits to check engines set 
 Shared WQ checks 
		
		  Shared wq with the threshold set to 0 means the user
		  did not set the threshold or transitioned from a
		  dedicated wq but did not set threshold. A value
		  of 0 would effectively disable the shared wq. The
		  driver does not allow a value of 0 to be set for
		  threshold via sysfs.
	
	  Device should be in disabled state for the idxd_drv to load. If it's in
	  enabled state, then the device was altered outside of driver's control.
	  If the state is in halted state, then we don't want to proceed.
 Device configuration 
 Start device 
 Setup DMA device without channels 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2019 Intel Corporation. All rights rsvd. 
  ictx is an array based off of accelerator types. enum idxd_type
  is used as index
 Wait for in-flight operations to complete. 
 The wq disable in the disable pasid function will drain the wq 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2019 Intel Corporation. All rights rsvd. 
 Driver does not utilize occupancy interrupt 
			
			  If we need a software reset, we will throw the work
			  on a system workqueue in order to allow interrupts
			  for the device command completions.
			
			  Check against the original status as ABORT is software defined
			  and 0xff, which DSA_COMP_STATUS_MASK can mask out.
	
	  This lock protects list corruption from access of list outside of the irq handler
	  thread.
		
		  Check against the original status as ABORT is software defined
		  and 0xff, which DSA_COMP_STATUS_MASK can mask out.
	
	  There are two lists we are processing. The pending_llist is where
	  submmiter adds all the submitted descriptor after sending it to
	  the workqueue. It's a lockless singly linked list. The work_list
	  is the common linux double linked list. We are in a scenario of
	  multiple producers and a single consumer. The producers are all
	  the kernel submitters of descriptors, and the consumer is the
	  kernel irq handler thread for the msix vector when using threaded
	  irq. To work with the restrictions of llist to remain lockless,
	  we are doing the following steps:
	  1. Iterate through the work_list and process any completed
	     descriptor. Delete the completed entries during iteration.
	  2. llist_del_all() from the pending list.
	  3. Iterate through the llist that was deleted from the pending list
	     and process the completed entries.
	  4. If the entry is still waiting on hardware, list_add_tail() to
	     the work_list.
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2020 Intel Corporation. All rights rsvd. 
  perf userspace reads this attribute to determine which cpus to open
  counters on.  It's connected to perfmon_dsa_cpu_mask, which is
  maintained by the cpu hotplug handlers.
  These attributes specify the bits in the config word that the perf
  syscall uses to pass the event ids and categories to perfmon.
  These attributes specify the bits in the config1 word that the perf
  syscall uses to pass filter data to perfmon.
  Check whether there are enough counters to satisfy that all the
  events in the group can actually be scheduled at the same time.
  To do this, create a fake idxd_pmu object so the event collection
  and assignment functions can be used without affecting the internal
  state of the real idxd_pmu object.
 sampling not supported 
 non-group events have themselves as leader 
	
	  While updating overflowed counters, other counters behind
	  them could overflow and be missed in a given pass.
	  Normally this could happen at most n_counters times, but in
	  theory a tiny counter width could result in continual
	  overflows and endless looping.  max_loop provides a
	  failsafe in that highly unlikely case.
 Figure out which counter(s) overflowed 
 Update event->count for overflowed counter 
 Writing 1 to OVFSTATUS bit clears it 
	
	  Should never happen.  If so, it means a counter(s) looped
	  around twice while this handler was running.
 Obtain event category and event value from user space 
 Obtain filter configuration from user space 
 Read the start value 
 Set counter to eventcategory 
 Set interrupt on overflow and counter enable bits 
 remove this event from event list 
 select the first online CPU as the designated reader 
 migrate events if there is a valid target 
	
	  perfmon module initialization failed, nothing to do
	
	  If perfmon_offset or num_counters is 0, it means perfmon is
	  not supported on this hardware.
	
	  If total perf counter is 0, stop further registration.
	  This is necessary in order to support driver running on
	  guest which does not have pmon support.
 A counter width of 0 means it can't count 
 Overflow interrupt and counter freeze support must be available 
 Number of event categories cannot be 0 
	
	  We don't support per-counter capabilities for now.
 check filter capability.  If 0, then filters are not supported 
 Store the total number of counters categories, and counter width 
 SPDX-License-Identifier: GPL-2.0
  MediaTek UART APDMA driver.
  Copyright (c) 2019 MediaTek Inc.
  Author: Long Cheng <long.cheng@mediatek.com>
 The default number of virtual channel 
 rx valid size >=  vff thre 
 tx left size >= vff thre 
  interrupt trigger level for tx
  if threshold is n, no polling is required to start tx.
  otherwise need polling VFF_FLUSH.
 interrupt trigger level for rx 
 invert this bit when wrap ring head again 
 TX: the buffer size HW can read. RX: the buffer size SW can read. 
 TX: the buffer size SW can write. RX: the buffer size HW can write. 
 Let DMA start moving data 
 HW auto set to 0 when left size >= threshold 
	
	  The buffer is ring buffer. If wrap bit different,
	  represents the start of the next cycle for WPT
  dmaengine_prep_slave_single will call the function. and sglen is 1.
  8250 uart using one ring buffer, and deal with one sg.
 Now allocate and setup the descriptor 
	
	  Stop need 3 steps.
	  1. set stop to 1
	  2. wait en to 0
	  3. set stop as 0
 sentinel  },
 Device-tree DMA controller registration 
 CONFIG_PM_SLEEP 
 CONFIG_PM 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2017-2018 MediaTek Inc.
  Driver for MediaTek High-Speed DMA Controller
  Author: Sean Wang <sean.wang@mediatek.com>
 The default number of virtual channel 
 Only one physical channel supported 
 Macro for physical descriptor (PD) manipulation 
 The number of PD which must be 2 of power 
 Registers for underlying ring manipulation 
 Registers for global setup 
 Registers for reset 
 Registers for interrupt control 
 Interrupt fires when the pending number's more than the specified 
 Interrupt fires when the pending time's more than the specified in 20 us 
  struct mtk_hsdma_pdesc - This is the struct holding info describing physical
 			    descriptor (PD) and its placement must be kept at
 			    4-bytes alignment in little endian order.
  @desc1:		    | The control pad used to indicate hardware how to
  @desc2:		    | deal with the descriptor such as source and
  @desc3:		    | destination address and data length. The maximum
  @desc4:		    | data length each pdesc can handle is 0x3f80 bytes
  struct mtk_hsdma_vdesc - This is the struct holding info describing virtual
 			    descriptor (VD)
  @vd:			    An instance for struct virt_dma_desc
  @len:		    The total data size device wants to move
  @residue:		    The remaining data size device will move
  @dest:		    The destination address device wants to move to
  @src:		    The source address device wants to move from
  struct mtk_hsdma_cb - This is the struct holding extra info required for RX
 			 ring to know what relevant VD the the PD is being
 			 mapped to.
  @vd:			 Pointer to the relevant VD.
  @flag:		 Flag indicating what action should be taken when VD
 			 is completed.
  struct mtk_hsdma_ring - This struct holds info describing underlying ring
 			   space
  @txd:		   The descriptor TX ring which describes DMA source
 			   information
  @rxd:		   The descriptor RX ring which describes DMA
 			   destination information
  @cb:			   The extra information pointed at by RX ring
  @tphys:		   The physical addr of TX ring
  @rphys:		   The physical addr of RX ring
  @cur_tptr:		   Pointer to the next free descriptor used by the host
  @cur_rptr:		   Pointer to the last done descriptor by the device
  struct mtk_hsdma_pchan - This is the struct holding info describing physical
 			   channel (PC)
  @ring:		   An instance for the underlying ring
  @sz_ring:		   Total size allocated for the ring
  @nr_free:		   Total number of free rooms in the ring. It would
 			   be accessed and updated frequently between IRQ
 			   context and user context to reflect whether ring
 			   can accept requests from VD.
  struct mtk_hsdma_vchan - This is the struct holding info describing virtual
 			   channel (VC)
  @vc:			   An instance for struct virt_dma_chan
  @issue_completion:	   The wait for all issued descriptors completited
  @issue_synchronize:	   Bool indicating channel synchronization starts
  @desc_hw_processing:	   List those descriptors the hardware is processing,
 			   which is protected by vc.lock
  struct mtk_hsdma_soc - This is the struct holding differences among SoCs
  @ddone:		  Bit mask for DDONE
  @ls0:		  Bit mask for LS0
  struct mtk_hsdma_device - This is the struct holding info describing HSDMA
 			     device
  @ddev:		     An instance for struct dma_device
  @base:		     The mapped register IO base
  @clk:		     The clock that device internal is using
  @irq:		     The IRQ that device are using
  @dma_requests:	     The number of VCs the device supports to
  @vc:			     The pointer to all available VCs
  @pc:			     The pointer to the underlying PC
  @pc_refcnt:		     Track how many VCs are using the PC
  @lock:		     Lock protect agaisting multiple VCs access PC
  @soc:		     The pointer to area holding differences among
 			     vaious platform
 Lock used to protect against multiple VCs access PC 
	
	  Allocate ring space where [0 ... MTK_DMA_SIZE - 1] is for TX ring
	  and [MTK_DMA_SIZE ... 2  MTK_DMA_SIZE - 1] is for RX ring.
 Disable HSDMA and wait for the completion 
 Reset 
 Setup HSDMA initial pointer in the ring 
 Enable HSDMA 
 Setup delayed interrupt 
 Enable interrupt 
 Disable HSDMA and then wait for the completion 
 Reset pointer in the ring 
 Protect against PC is accessed by multiple VCs simultaneously 
	
	  Reserve rooms, where pc->nr_free is used to track how many free
	  rooms in the ring being updated in user and IRQ context.
 Limit size by PD capability for valid data moving 
		
		  Setup PDs using the remaining VD info mapped on those
		  reserved rooms. And since RXD is shared memory between the
		  host and the device allocated by dma_alloc_coherent call,
		  the helper macro WRITE_ONCE can ensure the data written to
		  RAM would really happens.
 Associate VD, the PD belonged to 
 Move forward the pointer of TX ring 
 Update VD with remaining data 
	
	  Tagging flag for the last PD for VD will be responsible for
	  completing VD.
 Ensure all changes indeed done before we're going on 
	
	  Updating into hardware the pointer of TX ring lets HSDMA to take
	  action for those pending PDs.
 Map VD into PC and all VCs shares a single PC 
		
		  Move VD from desc_issued to desc_hw_processing when entire
		  VD is fit into available PDs. Otherwise, the uncompleted
		  VDs would stay in list desc_issued and then restart the
		  processing as soon as possible once underlying ring space
		  got freed.
		
		  The extra list desc_hw_processing is used because
		  hardware can't provide sufficient information allowing us
		  to know what VDs are still working on the underlying ring.
		  Through the additional list, it can help us to implement
		  terminate_all, residue calculation and such thing needed
		  to know detail descriptor status on the hardware.
 Read IRQ status 
	
	  Using a fail-safe loop with iterations of up to MTK_DMA_SIZE to
	  reclaim these finished descriptors: The most number of PDs the ISR
	  can handle at one time shouldn't be more than MTK_DMA_SIZE so we
	  take it as limited count instead of just using a dangerous infinite
	  poll.
		
		  If MTK_HSDMA_DESC_DDONE is no specified, that means data
		  moving for the PD is still under going.
 Update residue of VD the associated PD belonged to 
 Complete VD until the relevant last PD is finished 
 Remove VD from list desc_hw_processing 
 Add VD into list desc_completed 
		
		  Recycle the RXD with the helper WRITE_ONCE that can ensure
		  data written into RAM would really happens.
 Release rooms 
 Ensure all changes indeed done before we're going on 
 Update CPU pointer for those completed PDs 
	
	  Acking the pending IRQ allows hardware no longer to keep the used
	  IRQ line in certain trigger state when software has completed all
	  the finished physical descriptors.
 ASAP handles pending VDs in all VCs after freeing some rooms 
 All completed PDs are cleaned up, so enable interrupt again 
	
	  Disable interrupt until all completed PDs are cleaned up in
	  mtk_hsdma_free_rooms call.
 At the point, we don't expect users put descriptor into VC again 
	
	  Once issue_synchronize is being set, which means once the hardware
	  consumes all descriptors for the channel in the ring, the
	  synchronization must be be notified immediately it is completed.
	
	  At the point, we expect that all remaining descriptors in the ring
	  for the channel should be all processing done.
 Free all descriptors in list desc_completed 
	
	  Free pending descriptors not processed yet by hardware that have
	  previously been submitted to the channel.
	
	  However, the DMA engine doesn't provide any way to stop these
	  descriptors being processed currently by hardware. The only way is
	  to just waiting until these descriptors are all processed completely
	  through mtk_hsdma_free_active_desc call.
	
	  Since HSDMA has only one PC, the resource for PC is being allocated
	  when the first VC is being created and the other VCs would run on
	  the same PC.
		
		  refcount_inc would complain increment on 0; use-after-free.
		  Thus, we need to explicitly set it as 1 initially.
 Free all descriptors in all lists on the VC 
 The resource for PC is not freed until all the VCs are destroyed 
 sentinel  }
 Kill VC task 
 Disable DMA interrupt 
 Waits for any pending IRQ handlers to complete 
 Disable hardware 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018-2019 MediaTek Inc.
  Driver for MediaTek Command-Queue DMA Controller
  Author: Shun-Chih Yu <shun-chih.yu@mediatek.com>
 The default number of virtual channel 
 The default number of physical channel 
 Registers for underlying dma manipulation 
 Registers setting 
  struct mtk_cqdma_vdesc - The struct holding info describing virtual
                          descriptor (CVD)
  @vd:                    An instance for struct virt_dma_desc
  @len:                   The total data size device wants to move
  @residue:               The remaining data size device will move
  @dest:                  The destination address device wants to move to
  @src:                   The source address device wants to move from
  @ch:                    The pointer to the corresponding dma channel
  @node:                  The lise_head struct to build link-list for VDs
  @parent:                The pointer to the parent CVD
  struct mtk_cqdma_pchan - The struct holding info describing physical
                          channel (PC)
  @queue:                 Queue for the PDs issued to this PC
  @base:                  The mapped register IO base of this PC
  @irq:                   The IRQ that this PC are using
  @refcnt:                Track how many VCs are using this PC
  @tasklet:               Tasklet for this PC
  @lock:                  Lock protect agaisting multiple VCs access PC
 lock to protect PC 
  struct mtk_cqdma_vchan - The struct holding info describing virtual
                          channel (VC)
  @vc:                    An instance for struct virt_dma_chan
  @pc:                    The pointer to the underlying PC
  @issue_completion:	   The wait for all issued descriptors completited
  @issue_synchronize:	   Bool indicating channel synchronization starts
  struct mtk_cqdma_device - The struct holding info describing CQDMA
                           device
  @ddev:                   An instance for struct dma_device
  @clk:                    The clock that device internal is using
  @dma_requests:           The number of VCs the device supports to
  @dma_channels:           The number of PCs the device supports to
  @vc:                     The pointer to all available VCs
  @pc:                     The pointer to all the underlying PCs
 wait for the previous transaction done 
 warm reset the dma engine for the new transaction 
 setup the source 
 setup the destination 
 setup the length 
 start dma engine 
 need to trigger dma engine if PC's queue is empty 
 add VD into PC's queue 
 start the dma engine 
 remove VD from list desc_issued 
  return true if this VC is active,
  meaning that there are VDs under processing by the PC
  return the pointer of the CVD that is just consumed by the PC
 consume a CVD from PC's queue 
 update residue of the parent CVD 
 delete CVD from PC's queue 
 check whether all the child CVDs completed 
 add the parent VD into list desc_completed 
 setup completion if this VC is under synchronization 
 start transaction for next CVD in the queue 
 consume the queue 
 submit the next CVD 
		
		  free child CVD after completion.
		  the parent CVD would be freeed with desc_free by user.
 re-enable interrupt before leaving tasklet 
 clear interrupt flags for each PC 
 clear interrupt 
 disable interrupt 
 schedule the tasklet to handle the transactions 
 acquire PC's lock before VS's lock for lock dependency in tasklet 
	
	  In the case that trsanction length is larger than the
	  DMA engine supports, a single memcpy transaction needs
	  to be separated into several DMA transactions.
	  Each DMA transaction would be described by a CVD,
	  and the first one is referred as the parent CVD,
	  while the others are child CVDs.
	  The parent CVD's tx descriptor is the only tx descriptor
	  returned to the DMA user, and it should not be completed
	  until all the child CVDs completed.
 setup dma channel 
 setup sourece, destination, and length 
 setup tx descriptor 
 update the src, dest, len, prev_tx for the next CVD 
	
	  set desc_allocated, desc_submitted,
	  and desc_issued as the candicates to be freed
 free descriptor lists 
 acquire PC's lock first due to lock dependency in dma ISR 
 synchronization is required if this VC is active 
 waiting for the completion of this VC 
 free all descriptors in list desc_completed 
 free descriptors not processed yet by hardware 
 free descriptors being processed by hardware 
 allocate PC with the minimun refcount 
 allocate PC when the refcount is zero 
 enable interrupt for this PC 
		
		  refcount_inc would complain increment on 0; use-after-free.
		  Thus, we need to explicitly set it as 1 initially.
 free all descriptors in all lists on the VC 
 PC is not freed until there is no VC mapped to it 
 start the flush operation and stop the engine 
 wait for the completion of flush operation 
 clear the flush bit and interrupt flag 
 disable interrupt for this PC 
 reset all PCs 
 reset all PCs 
 sentinel  }
 initialization for PCs 
 allocate IRQ resource 
 allocate resource for VCs 
 initialize tasklet for each PC 
 kill VC task 
 disable interrupt 
 Waits for any pending IRQ handlers to complete 
 disable hardware 
 SPDX-License-Identifier: GPL-2.0-only
  Bestcomm ATA task microcode
  Copyright (c) 2004 Freescale Semiconductor, Inc.
  Created based on bestcomcode_dmaimage_rtos1dma_image.hex
  The header consists of the following fields:
 	u32	magic;
 	u8	desc_size;
 	u8	var_size;
 	u8	inc_size;
 	u8	first_var;
 	u8	reserved[8];
  The size fields contain the number of 32-bit words.
 header 
 Task descriptors 
 LCD: idx0 = var3; idx0 <= var2; idx0 += inc3 
   DRD1A: var3 = var1; FN=0 MORE init=31 WS=0 RS=0 
   LCD: idx1 = idx0, idx2 = var0; idx1 < var9; idx1 += inc4, idx2 += inc4 
     DRD1A: var3 = idx0; FN=0 MORE init=0 WS=0 RS=0 
     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT init=0 WS=2 RS=2 
     DRD2B1: idx2 = EU3(); EU3(idx2,var10)  
   LCDEXT: idx1 = idx1; idx1 > var9; idx1 += inc0 
   LCDEXT: idx2 = (idx0 + var00000015); ; idx2 += inc2 
   LCD: idx3 = (idx0 + var00000019); ; idx3 += inc1 
     DRD1A: idx3 = idx2; FN=0 TFD init=31 WS=3 RS=3 
   LCD: idx1 = idx1; idx1 once var0; idx1 += inc5 
     DRD2A: EU0=0 EU1=0 EU2=0 EU3=5 INT EXT init=0 WS=0 RS=0 
     DRD2B1: idx0 = EU3(); EU3(idx1,var9)  
 NOP 
 VAR[9]-VAR[14] 
 INC[0]-INC[6] 
  Simple memory allocator for on-board SRAM
  Maintainer : Sylvain Munaut <tnt@246tNt.com>
  Copyright (C) 2005 Sylvain Munaut <tnt@246tNt.com>
  This file is licensed under the terms of the GNU General Public License
  version 2. This program is licensed "as is" without any warranty of any
  kind, whether express or implied.
 Struct keeping our 'state' 
 needed for inline functions 
 ======================================================================== 
 Public API                                                               
 ======================================================================== 
 DO NOT USE in interrupts, if needed in irq handler, we should use the
 Create our state struct 
 Get address and size of the sram 
 Request region 
 Map SRAM 
 sram is not really __iomem 
 Create an rheap (defaults to 32 bits word alignment) 
 Attach the free zones 
 Currently disabled ... for future use only 
 Attach the whole zone 
 Attach each zone independently 
 Init our spinlock 
 Free resources 
  Driver for MPC52xx processor BestComm peripheral controller
  Copyright (C) 2006-2007 Sylvain Munaut <tnt@246tNt.com>
  Copyright (C) 2005      Varma Electronics Oy,
                          ( by Andrey Volkov <avolkov@varma-el.com> )
  Copyright (C) 2003-2004 MontaVista, Software, Inc.
                          ( by Dale Farnsworth <dfarnsworth@mvista.com> )
  This file is licensed under the terms of the GNU General Public License
  version 2. This program is licensed "as is" without any warranty of any
  kind, whether express or implied.
 MPC5200 device tree match tables 
 needed for inline functions 
 ======================================================================== 
 Public and private API                                                   
 ======================================================================== 
 Private API 
 Don't try to do anything if bestcomm init failed 
 Get and reserve a task num 
 we use stop as a marker 
 dummy addr 
 Allocate our structure 
 Get IRQ of that task 
 Init the BDs, if needed 
 Stop the task 
 Clear TDT 
 Free everything 
 Safety checks 
 Initial load or reload 
 Clear & copy 
 Just setting tcr is apparently not enough due to some problem 
 with it. So we just go thru all the microcode and replace in  
 the DRD directly 
 Public API 
 ======================================================================== 
 Engine initcleanup                                                      
 ======================================================================== 
 Function Descriptor table 
 this will need to be updated if Freescale changes their task code FDT 
 FDT[48] - load_acc()	  
 FDT[49] - unload_acc() 
 FDT[50] - and()        
 FDT[51] - or()         
 FDT[52] - xor()        
 FDT[53] - andn()       
 FDT[54] - not()        
 FDT[55] - add()        
 FDT[56] - sub()        
 FDT[57] - lsh()        
 FDT[58] - rsh()        
 FDT[59] - crc8()       
 FDT[60] - crc16()      
 FDT[61] - crc32()      
 FDT[62] - endian32()   
 FDT[63] - endian16()   
 Allocate & clear SRAM zones for FDT, TDTs, contexts and varsincs 
 Copy the FDT for the EU#3 
 Initialize Task base structure 
 Init 'always' initiator 
 Disable COMM Bus Prefetch on the original 5200; it's broken 
 Init lock 
 Stop all tasks 
 Release the SRAM zones 
 ======================================================================== 
 OF platform driver                                                       
 ======================================================================== 
 Inform user we're ok so far 
 Get the bestcomm node 
 Prepare SRAM 
 Get a clean struct 
 Save the node 
 Get, reserve & map io 
 Now, do the real init 
 Done ! 
 Error path 
 Clean up the engine 
 Cleanup SRAM 
 Release regs 
 Release the node 
 Release memory 
 ======================================================================== 
 Module                                                                   
 ======================================================================== 
 If we're not a module, we must make sure everything is setup before  
 anyone tries to use us ... that's why we use subsys_initcall instead 
 of module_init. 
 SPDX-License-Identifier: GPL-2.0-only
  Bestcomm FEC RX task microcode
  Copyright (c) 2004 Freescale Semiconductor, Inc.
  Automatically created based on BestCommAPI-2.2code_dmaimage_rtos1dma_image.hex
  on Tue Mar 22 11:19:38 2005 GMT
  The header consists of the following fields:
 	u32	magic;
 	u8	desc_size;
 	u8	var_size;
 	u8	inc_size;
 	u8	first_var;
 	u8	reserved[8];
  The size fields contain the number of 32-bit words.
 header 
 Task descriptors 
 LCD: idx0 = var1, idx1 = var4; idx1 <= var3; idx0 += inc4, idx1 += inc3 
   DRD1A: var4 = var2; FN=0 MORE init=3 WS=0 RS=0 
   LCD: idx2 = idx1, idx3 = var0; idx2 < var9; idx2 += inc4, idx3 += inc4 
     DRD1A: var4 = idx1; FN=0 MORE init=0 WS=0 RS=0 
     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT init=0 WS=2 RS=2 
     DRD2B1: idx3 = EU3(); EU3(idx3,var10)  
   LCDEXT: idx2 = 0x00000000; ; 
   LCD: idx3 = (idx1 + var00000015); idx3 once var0; idx3 += inc5 
     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT init=0 WS=0 RS=0 
     DRD2B1: idx2 = EU3(); EU3(idx3,var12)  
   LCD: idx2 = idx2, idx3 = idx3; idx2 > var11; idx2 += inc6, idx3 += inc2 
     DRD1A: idx3 = idx0; FN=0 init=3 WS=1 RS=1 
   LCDEXT: idx2 = 0x00000000; ; 
   LCD: idx3 = idx3; idx3 once var0; idx3 += inc5 
     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT MORE init=0 WS=0 RS=0 
     DRD2B1: var13 = EU3(); EU3(idx1,var14)  
     DRD1A: idx2 = var13; FN=0 init=0 WS=0 RS=0 
   LCD: idx2 = idx2, idx3 = idx3; idx2 > var13; idx2 += inc0, idx3 += inc1 
     DRD1A: idx3 = idx0; FN=0 init=3 WS=3 RS=3 
   LCD: idx2 = idx2, idx3 = idx3; idx2 > var9; idx2 += inc6, idx3 += inc2 
     DRD1A: idx3 = idx0; FN=0 INT init=3 WS=1 RS=1 
   LCD: idx2 = idx0; idx2 once var0; idx2 += inc5 
     DRD1A: idx1 = idx2; FN=0 init=3 WS=0 RS=0 
   NOP 
 VAR[9]-VAR[14] 
 INC[0]-INC[6] 
 SPDX-License-Identifier: GPL-2.0-only
  Bestcomm GenBD RX task microcode
  Copyright (C) 2006 AppSpec Computer Technologies Corp.
                     Jeff Gibbons <jeff.gibbons@appspec.com>
  Copyright (c) 2004 Freescale Semiconductor, Inc.
  Based on BestCommAPI-2.2code_dmaimage_rtos1dma_image.hex
  on Tue Mar 4 10:14:12 2006 GMT
  The header consists of the following fields:
 	u32	magic;
 	u8	desc_size;
 	u8	var_size;
 	u8	inc_size;
 	u8	first_var;
 	u8	reserved[8];
  The size fields contain the number of 32-bit words.
 header 
 Task descriptors 
 LCD: idx0 = var1, idx1 = var4; idx1 <= var3; idx0 += inc3, idx1 += inc2 
   DRD1A: var4 = var2; FN=0 MORE init=31 WS=0 RS=0 
   LCD: idx2 = idx1, idx3 = var0; idx2 < var9; idx2 += inc3, idx3 += inc3 
     DRD1A: var4 = idx1; FN=0 MORE init=0 WS=0 RS=0 
     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT init=0 WS=2 RS=2 
     DRD2B1: idx3 = EU3(); EU3(idx3,var10)  
   LCDEXT: idx2 = idx2; idx2 > var9; idx2 += inc0 
   LCD: idx3 = (idx1 + var00000015); ; idx3 += inc1 
     DRD1A: idx3 = idx0; FN=0 INT init=31 WS=3 RS=3 
   LCD: idx2 = idx2; idx2 once var0; idx2 += inc4 
     DRD2A: EU0=0 EU1=0 EU2=0 EU3=5 EXT init=0 WS=0 RS=0 
     DRD2B1: idx1 = EU3(); EU3(idx2,var9)  
   NOP 
 VAR[9]-VAR[10] 
 INC[0]-INC[3] 
 SPDX-License-Identifier: GPL-2.0-only
  Driver for MPC52xx processor BestComm General Buffer Descriptor
  Copyright (C) 2007 Sylvain Munaut <tnt@246tNt.com>
  Copyright (C) 2006 AppSpec Computer Technologies Corp.
                     Jeff Gibbons <jeff.gibbons@appspec.com>
 ======================================================================== 
 Task imagevarinc                                                       
 ======================================================================== 
 gen_bd tasks images 
 rx task vars that need to be set before enabling the task 
 (u16) address of task's control register 
 (u32) address of gen_bd's fifo 
 (struct bcom_bd) beginning of ring buffer 
 (struct bcom_bd) end of ring buffer 
 (struct bcom_bd) current bd 
 size of receive buffer 
 rx task incs that need to be set before enabling the task 
 tx task vars that need to be set before enabling the task 
 (u32) address of gen_bd's fifo 
 (u16) address of task's control register 
 (struct bcom_bd) beginning of ring buffer 
 (struct bcom_bd) end of ring buffer 
 (struct bcom_bd) current bd 
 set by uCode for each packet 
 tx task incs that need to be set before enabling the task 
 private structure 
 ======================================================================== 
 Task support code                                                        
 ======================================================================== 
 Shutdown the task 
 Reset the microcode 
 Reset the BDs 
 Configure some stuff 
 Clear ints 
 Nothing special for the GenBD tasks 
 Shutdown the task 
 Reset the microcode 
 Reset the BDs 
 Configure some stuff 
 Clear ints 
 Nothing special for the GenBD tasks 
 ---------------------------------------------------------------------
  PSC support code
  bcom_psc_parameters - Bestcomm initialization value table for PSC devices
  This structure is only used internally.  It is a lookup table for PSC
  specific parameters to bestcomm tasks.
  bcom_psc_gen_bd_rx_init - Allocate a receive bcom_task for a PSC port
  @psc_num:	Number of the PSC to allocate a task for
  @queue_len:	number of buffer descriptors to allocate for the task
  @fifo:	physical address of FIFO register
  @maxbufsize:	Maximum receive data size in bytes.
  Allocate a bestcomm task structure for receiving data from a PSC.
  bcom_psc_gen_bd_tx_init - Allocate a transmit bcom_task for a PSC port
  @psc_num:	Number of the PSC to allocate a task for
  @queue_len:	number of buffer descriptors to allocate for the task
  @fifo:	physical address of FIFO register
  Allocate a bestcomm task structure for transmitting data to a PSC.
 SPDX-License-Identifier: GPL-2.0-only
  Bestcomm FEC TX task microcode
  Copyright (c) 2004 Freescale Semiconductor, Inc.
  Automatically created based on BestCommAPI-2.2code_dmaimage_rtos1dma_image.hex
  on Tue Mar 22 11:19:29 2005 GMT
  The header consists of the following fields:
 	u32	magic;
 	u8	desc_size;
 	u8	var_size;
 	u8	inc_size;
 	u8	first_var;
 	u8	reserved[8];
  The size fields contain the number of 32-bit words.
 header 
 Task descriptors 
 LCD: idx0 = var0; idx0 <= var0; idx0 += inc3 
   DRD2A: EU0=0 EU1=0 EU2=0 EU3=5 EXT init=0 WS=0 RS=0 
   DRD2B1: var7 = EU3(); EU3(idx0,var13)  
 LCD: idx0 = var1, idx1 = var5; idx1 <= var4; idx0 += inc4, idx1 += inc3 
   DRD1A: var5 = var3; FN=0 MORE init=4 WS=0 RS=0 
   LCDEXT: idx2 = idx1, idx3 = var2; idx2 < var14; idx2 += inc4, idx3 += inc4 
   LCD: idx4 = var0; ; idx4 += inc4 
     DRD1A: var5 = idx1; FN=0 MORE init=0 WS=0 RS=0 
     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT init=0 WS=2 RS=2 
     DRD2B1: idx3 = EU3(); EU3(idx3,var15)  
   LCD: idx2 = idx2, idx3 = idx4; idx2 once var0; idx2 += inc5, idx3 += inc4 
     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT MORE init=0 WS=0 RS=0 
     DRD2B1: var9 = EU3(); EU3(idx1,var13)  
     DRD2A: EU0=0 EU1=0 EU2=0 EU3=3 EXT init=0 WS=0 RS=0 
     DRD2B1: idx3 = EU3(); EU3(var9,var7)  
   LCDEXT: idx2 = 0x00000000; ; 
   LCD: idx3 = (idx1 + var0000001a); idx3 once var0; idx3 += inc5 
     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT MORE init=0 WS=0 RS=0 
     DRD2B1: idx2 = EU3(); EU3(idx3,var17)  
     DRD1A: var11 = idx2; FN=0 init=0 WS=0 RS=0 
   LCD: idx2 = idx2, idx3 = idx3; idx2 > var16; idx2 += inc6, idx3 += inc2 
     DRD1A: idx0 = idx3; FN=0 init=4 WS=1 RS=1 
   LCDEXT: idx2 = 0x00000000; ; 
   LCD: idx3 = idx3; idx3 once var0; idx3 += inc5 
     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT MORE init=0 WS=0 RS=0 
     DRD2B1: var18 = EU3(); EU3(idx1,var19)  
     DRD2A: EU0=0 EU1=0 EU2=0 EU3=8 EXT init=0 WS=0 RS=0 
     DRD2B1: idx2 = EU3(); EU3(var18,var11)  
   LCD: idx2 = idx2, idx3 = idx3; idx2 > var18; idx2 += inc0, idx3 += inc1 
     DRD1A: idx0 = idx3; FN=0 init=4 WS=3 RS=3 
   LCD: idx2 = idx2, idx3 = idx3; idx2 > var14; idx2 += inc6, idx3 += inc2 
     DRD1A: idx0 = idx3; FN=0 TFD init=4 WS=1 RS=1 
   LCD: idx2 = idx2; idx2 once var0; idx2 += inc5 
     DRD2A: EU0=0 EU1=0 EU2=0 EU3=5 EXT init=0 WS=0 RS=0 
     DRD2B1: idx1 = EU3(); EU3(idx2,var14)  
   NOP 
 VAR[13]-VAR[19] 
 INC[0]-INC[6] 
  Bestcomm ATA task driver
  Patterned after bestcommfec.c by Dale Farnsworth <dfarnsworth@mvista.com>
                                    2003-2004 (c) MontaVista, Software, Inc.
  Copyright (C) 2006-2007 Sylvain Munaut <tnt@246tNt.com>
  Copyright (C) 2006      Freescale - John Rigby
  This file is licensed under the terms of the GNU General Public License
  version 2. This program is licensed "as is" without any warranty of any
  kind, whether express or implied.
 ======================================================================== 
 Task imagevarinc                                                       
 ======================================================================== 
 ata task image 
 ata task vars that need to be set before enabling the task 
 (u16) address of task's control register 
 (struct bcom_bd) beginning of ring buffer 
 (struct bcom_bd) end of ring buffer 
 (struct bcom_bd) current bd 
 size of receive buffer 
 ata task incs that need to be set before enabling the task 
 ======================================================================== 
 Task support code                                                        
 ======================================================================== 
 Prefetch breaks ATA DMA.  Turn it off for ATA DMA 
 Configure some stuff 
 Clear ints 
 Reset all BD 
 Nothing special for the ATA tasks 
 SPDX-License-Identifier: GPL-2.0-only
  Bestcomm GenBD TX task microcode
  Copyright (C) 2006 AppSpec Computer Technologies Corp.
                     Jeff Gibbons <jeff.gibbons@appspec.com>
  Copyright (c) 2004 Freescale Semiconductor, Inc.
  Based on BestCommAPI-2.2code_dmaimage_rtos1dma_image.hex
  on Tue Mar 4 10:14:12 2006 GMT
  The header consists of the following fields:
 	u32	magic;
 	u8	desc_size;
 	u8	var_size;
 	u8	inc_size;
 	u8	first_var;
 	u8	reserved[8];
  The size fields contain the number of 32-bit words.
 header 
 Task descriptors 
 LCD: idx0 = var0, idx1 = var4; idx1 <= var3; idx0 += inc4, idx1 += inc3 
   DRD1A: var4 = var2; FN=0 MORE init=31 WS=0 RS=0 
   LCD: idx2 = idx1, idx3 = var1; idx2 < var9; idx2 += inc4, idx3 += inc4 
     DRD1A: var4 = idx1; FN=0 MORE init=0 WS=0 RS=0 
     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT init=0 WS=2 RS=2 
     DRD2B1: idx3 = EU3(); EU3(idx3,var10)  
   LCDEXT: idx2 = idx2; idx2 > var12; idx2 += inc0 
   LCD: idx3 = (idx1 + var00000015); ; idx3 += inc1 
     DRD1A: idx0 = idx3; FN=0 init=31 WS=3 RS=3 
   LCD: idx2 = idx2, idx3 = idx3; idx2 > var9; idx2 += inc5, idx3 += inc2 
     DRD1A: idx0 = idx3; FN=0 TFD INT init=31 WS=1 RS=1 
   LCD: idx2 = idx2; idx2 once var0; idx2 += inc6 
     DRD2A: EU0=0 EU1=0 EU2=0 EU3=5 EXT init=0 WS=0 RS=0 
     DRD2B1: idx1 = EU3(); EU3(idx2,var9)  
   NOP 
 VAR[9]-VAR[12] 
 INC[0]-INC[5] 
  Bestcomm FEC tasks driver
  Copyright (C) 2006-2007 Sylvain Munaut <tnt@246tNt.com>
  Copyright (C) 2003-2004 MontaVista, Software, Inc.
                          ( by Dale Farnsworth <dfarnsworth@mvista.com> )
  This file is licensed under the terms of the GNU General Public License
  version 2. This program is licensed "as is" without any warranty of any
  kind, whether express or implied.
 ======================================================================== 
 Task imagevarinc                                                       
 ======================================================================== 
 fec tasks images 
 rx task vars that need to be set before enabling the task 
 (u16) address of task's control register 
 (u32) address of fec's fifo 
 (struct bcom_bd) beginning of ring buffer 
 (struct bcom_bd) end of ring buffer 
 (struct bcom_bd) current bd 
 size of receive buffer 
 rx task incs that need to be set before enabling the task 
 tx task vars that need to be set before enabling the task 
 (u32) address of self-modified DRD 
 (u32) address of fec's fifo 
 (u16) address of task's control register 
 (struct bcom_bd) beginning of ring buffer 
 (struct bcom_bd) end of ring buffer 
 (struct bcom_bd) current bd 
 set by uCode for each packet 
 tx task incs that need to be set before enabling the task 
 private structure in the task 
 ======================================================================== 
 Task support code                                                        
 ======================================================================== 
 Shutdown the task 
 Reset the microcode 
 These should be in the   
 task image, but we stick 
 to the official ones     
 Reset the BDs 
 Configure some stuff 
 Clear ints 
 Nothing special for the FEC tasks 
 Return 2nd to last DRD 
	 This is an ugly hack, but at least it's only done
 Shutdown the task 
 Reset the microcode 
 These should be in the   
 task image, but we stick 
 to the official ones     
 Reset the BDs 
 Configure some stuff 
 Clear ints 
 Nothing special for the FEC tasks 
 SPDX-License-Identifier: GPL-2.0-only
  Intel IOAT DMA Linux driver
  Copyright(c) 2004 - 2015 Intel Corporation.
 provide a lookup table for setting the source address in the base or
  extended descriptor of an xor or pq descriptor
 we leave the channel locked to ensure in order submission 
	 we need 2x the number of descriptors to cover greater than 5
	  sources
	 completion writes from the raid engine may pass completion
	  writes from the legacy engine, so we need one extra null
	  (legacy) descriptor to ensure all completion writes arrive in
	  order.
		 save a branch by unconditionally retrieving the
		  extended descriptor xor_set_src() knows to not write
		  to it in the single descriptor case
 last xor descriptor carries the unmap parameters and fence bit 
 completion descriptor carries interrupt bit 
 we leave the channel locked to ensure in order submission 
	 the cleanup routine only sets bits on validate failure, it
	  does not clear bits on validate success... so clear it here
	 the engine requires at least two sources (we provide
	  at least 1 implied source in the DMA_PREP_CONTINUE case)
	 we need 2x the number of descriptors to cover greater than 3
	  sources (we need 1 extra source in the q-only continuation
	  case and 3 extra sources in the p+q continuation case.
	 completion writes from the raid engine may pass completion
	  writes from the legacy engine, so we need one extra null
	  (legacy) descriptor to ensure all completion writes arrive in
	  order.
		 save a branch by unconditionally retrieving the
		  extended descriptor pq_set_src() knows to not write
		  to it in the single descriptor case
 see the comment for dma_maxpq in includelinuxdmaengine.h 
 we turn on descriptor write back error status 
 last pq descriptor carries the unmap parameters and fence bit 
 completion descriptor carries interrupt bit 
 we leave the channel locked to ensure in order submission 
 this function is only called with 9-16 sources 
	
	  16 source pq is only available on cb3.3 and has no completion
	  write hw bug.
 see the comment for dma_maxpq in includelinuxdmaengine.h 
 we turn on descriptor write back error status 
 last pq descriptor carries the unmap parameters and fence bit 
 with cb3.3 we should be able to do completion wo a null desc 
 we leave the channel locked to ensure in order submission 
 specify valid address for disabled result 
	 handle the single source multiply case from the raid6
	  recovery path
 specify valid address for disabled result 
	 the cleanup routine only sets bits on validate failure, it
	  does not clear bits on validate success... so clear it here
 specify valid address for disabled result 
	 the cleanup routine only sets bits on validate failure, it
	  does not clear bits on validate success... so clear it here
 specify valid address for disabled result 
 we leave the channel locked to ensure in order submission 
 SPDX-License-Identifier: GPL-2.0-only
  Intel IOAT DMA Linux driver
  Copyright(c) 2004 - 2015 Intel Corporation.
  This driver supports an Intel IOAT DMA engine, which does asynchronous
  copy operations.
  ioat_dma_do_interrupt - handler used for single vector interrupt mode
  @irq: interrupt id
  @data: interrupt data
  ioat_dma_do_interrupt_msix - handler used for vector-per-channel interrupt mode
  @irq: interrupt id
  @data: interrupt data
	 1 stop irq from firing tasklets
	  2 stop the tasklet from re-arming irqs
 flush inflight interrupts 
 flush inflight timers 
 flush inflight tasklet runs 
 final cleanup now that everything is quiesced and can't re-arm 
  ioat_update_pending - log pending descriptors
  @ioat_chan: ioat+ channel
  Check if the number of unsubmitted descriptors has exceeded the
  watermark.  Called with prep_lock held
 set size to non-zero value (channel returns error when size is 0) 
 make sure descriptors are written before we submit 
 set the tail to be re-issued 
	 make descriptor updates visible before advancing ioat->head,
	  this is purposefully not smp_wmb() since we are also
	  publishing the descriptor updates to a dma device
 allocate the array to hold the software ring 
 link descs 
 setup descriptor pre-fetching for v3.4 
  ioat_check_space_lock - verify space and grab ring producer lock
  @ioat_chan: ioat,3 channel (ring) to operate on
  @num_descs: allocation length
	 never allow the last descriptor to be consumed, we need at
	  least one free at all times to allow for on-the-fly ring
	  resizing.
 with ioat->prep_lock held 
	 progress reclaim in the allocation failure case we may be
	  called under bh_disabled so we need to trigger the timer
	  event directly
 check if there's error written 
 need to set a chanerr var for checking to clear later 
  __cleanup - reclaim used descriptors
  @ioat_chan: channel (ring) to clean
  @phys_complete: zeroed (or not) completion address (from status)
	
	  At restart of the channel, the completion address and the
	  channel status will be 0 due to starting a new chain. Since
	  it's new chain and the first descriptor "fails", there is
	  nothing to clean up. We do not want to reap the entire submitted
	  chain due to this 0 address value and then BUG.
 set err stat if we are using dwbes 
 skip extended descriptors 
 cleanup super extended descriptors 
 finish all descriptor reads before incrementing tail 
 no active descs have written a completion? 
 microsecond delay by sysfs variable  per pending descriptor 
 set the completion address register again 
	
	  We assume that the failed descriptor has been processed.
	  Now we are just returning all the remaining submitted
	  descriptors to abort.
 we skip the failed descriptor that tail points to 
 skip extended descriptors 
 cleanup super extended descriptors 
 finish all descriptor reads before incrementing tail 
 cleanup so tail points to descriptor that caused the error 
 fault on unhandled error or spurious halt 
 cleanup the faulty descriptor since we are continuing 
 mark faulting descriptor as complete 
 we need abort all descriptors 
 clean up the channel, we could be in weird state 
	 when halted due to errors check for channel
	  programming errors before advancing the completion state
 handle the no-actives case 
 handle the missed cleanup case 
		 timer restarted in ioat_cleanup_preamble
		  and IOAT_COMPLETION_ACK cleared
	 if we haven't made progress and we have already
	  acknowledged a pending completion once, then be more
	  forceful with a restart
 handle missed issue pending case 
	 throw away whatever the channel was doing and get it
	  initialized, with ioat3 specific workarounds
 clear any pending errors 
		 Clear DMAUNCERRSTS Cfg-Reg Parity Error status bit
		  (workaround for spurious config parity error after restart)
 SPDX-License-Identifier: GPL-2.0-only
  Intel IOAT DMA Linux driver
  Copyright(c) 2004 - 2015 Intel Corporation.
 IOAT v3 platforms 
 IOAT v3.2 platforms 
 IOAT v3.3 platforms 
 IOAT v3.4 platforms 
 even though not Atom, BDX-DE has same DMA silicon 
  Perform a IOAT transaction to verify the HW works.
  ioat_dma_self_test - Perform a IOAT transaction to verify the HW works.
  @ioat_dma: dma device to be tested
 Fill in src buffer 
 Start copy, using first DMA channel 
  ioat_dma_setup_interrupts - setup interrupt handler
  @ioat_dma: ioat dma device
 The number of MSI-X vectors should equal the number of channels 
 Disable all interrupt generation 
 Disable all interrupt generation 
  ioat_enumerate_channels - find and initialize the device's channels
  @ioat_dma: the ioat dma device to be enumerated
 bits [4:0] valid 
 bits [4:0] valid 
  ioat_free_chan_resources - release all the descriptors
  @c: the channel to be cleaned
	 Before freeing channel resources first check
	  if they have been previously allocated for this channel.
 Put LTR to idle 
 ioat_alloc_chan_resources - allocateinitialize ioat descriptor ring
  @chan: channel to be initialized
 have we already been set up? 
 Setup register to interrupt and write completion status on error 
 allocate a completion writeback area 
 doing 2 32bit writes to mmio since 1 64b write doesn't work 
 Setting up LTR values for 3.4 or later 
 Select to active 
 check that we got off the ground 
 common channel initialization 
 must be <= 8 
 Fill in src buffers 
 test xor 
 skip validate if the capability is not present 
 validate the sources with the destintation page 
 test for non-zero parity sum 
	
	  if we have descriptor write back error status, we mask the
	  error interrupts
 dca is incompatible with raid operations 
 starting with CB3.3 super extended descriptors are supported 
 allocate SED DMA pool 
 disable relaxed ordering 
 clear relaxed ordering enable 
		
		  Synchronization rule for del_timer_sync():
		   - The caller must not hold locks which would prevent
		     completion of the timer's handler.
		  So prep_lock cannot be held before calling it.
 this should quiesce then reset 
 no need to reset as shutdown already did that 
 quiesce and block IO 
 initialize and bring everything back 
 SPDX-License-Identifier: GPL-2.0-only
  Intel IOAT DMA Linux driver
  Copyright(c) 2004 - 2015 Intel Corporation.
 ...taken outside the lock, no need to be precise 
 SPDX-License-Identifier: GPL-2.0-only
  Intel IOAT DMA Linux driver
  Copyright(c) 2007 - 2009 Intel Corporation.
 either a kernel change is needed, or we need something like this in kernel 
  Bit 7 of a tag map entry is the "valid" bit, if it is set then bits 0:6
  contain the bit number of the APIC ID to map into the DCA tag.  If the valid
  bit is not set, then the value must be 0 or 1 and defines the bit in the tag.
 expected tag map bytes for IOAT ver.2 
  "Legacy" DCA systems do not implement the DCA register set in the
  IOAT device.  Software needs direct support for their tag mappings.
 pack PCI BDF into a u16 
 CPUID level 9 returns DCA configuration 
 Bit 0 indicates DCA enabled by the BIOS 
 requester device 
 requester id, as used by IOAT 
 This implementation only supports PCI-Express 
 found an empty slot 
 Error, ioatdma->requester_count is out of whack 
 This implementation only supports PCI-Express 
	
	  If the tag map is not programmed by the BIOS the default is:
	  0x80 0x80 0x80 0x80 0x80 0x00 0x00 0x00
	 
	  This an invalid map and will result in only 2 possible tags
	  0x1F and 0x00.  0x00 is an invalid DCA tag so we know that
	  this entire definition is invalid.
 some bios might not know to turn these on 
 TODO version, compatibility and configuration checks 
 copy out the APIC to DCA tag map 
 SPDX-License-Identifier:  GPL-2.0
 (C) 2017-2018 Synopsys, Inc. (www.synopsys.com)
  Synopsys DesignWare AXI DMA Controller driver.
  Author: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
  The set of bus widths supported by the DMA controller. DW AXI DMAC supports
  master data bus width up to 512 bits (for both AXI master interfaces), but
  it depends on IP block configurarion.
	
	  We split one 64 bit write for two 32 bit write as some HW doesn't
	  support 64 bit access.
 Called in chan locked context 
 Select AXI0 master for LLI fetching 
 Generate 'suspend' status but don't generate interrupt 
 ASSERT: channel is idle 
 LLI address must be aligned to a 64-byte boundary 
 ASSERT: channel is idle 
	
	  An unused DMA channel has a default value of 0x3F.
	  Lock the DMA channel by assign a handshake number to the channel.
	  Unlock the DMA channel by assign 0x3F to the channel.
 Channel is already allocated, set handshake as per channel ID 
 64 bit write should handle for 8 channels 
  If DW_axi_dmac sees CHx_CTL.ShadowReg_Or_LLI_Last bit of the fetched LLI
  as 1, it understands that the current block is the final block in the
  transfer and completes the DMA transfer operation at the end of current
  block transfer.
 Select AXI0 for source master 
 Select AXI1 for source master if available 
 Select AXI0 master for LLI fetching 
		 Set end-of-link to the linked descriptor, so that cyclic
		  callback function can be triggered during interrupt.
 Managed transfer list 
 Select AXI0 master for LLI fetching 
 Set end-of-link to the last link descriptor of list 
 Managed transfer list 
 Select AXI0 master for LLI fetching 
		
		  Take care for the alignment.
		  Actually source and destination widths can be different, but
		  make them same to be simpler.
		
		  block_ts indicates the total number of data of width
		  to be transferred in a DMA block transfer.
		  BLOCK_TS register should be set to block_ts - 1
 update the length and addresses for the next loop cycle 
 Set end-of-link to the last link descriptor of list 
 Managed transfer list 
 The bad descriptor currently is in the head of vc list 
 Remove the completed descriptor from issued list 
 WARN about bad descriptor 
 Try to restart the controller 
 The completed descriptor currently is in the head of vc list 
 Remove the completed descriptor from issued list before completing 
 Submit queued descriptors after processing the completed ones 
 Disable DMAC inerrupts. We'll enable them after processing chanels 
 Poll, clear and process every chanel interrupt status 
 Re-enable interrupts 
 timeout iterations 
 Called in chan locked context 
 Priority value must be programmed within [0:nr_channels-1] range 
 axi-max-burst-len is optional property 
 Set capabilities 
 DMA capabilities 
	
	  Synopsis DesignWare AxiDMA datasheet mentioned Maximum
	  supported blocks is 1024. Device register width is 4 bytes.
	  Therefore, set constraint to 1024  4.
	
	  We can't just call pm_runtime_get here instead of
	  pm_runtime_get_noresume + axi_dma_resume because we need
	  driver to work also without Runtime PM.
 Register with OF helpers for DMA lookups 
 Enable clk before accessing to registers 
 SPDX-License-Identifier: GPL-2.0-only
  OMAP DMAengine support
 for assigning logical channels 
 Type 2 descriptor with Source or Destination address update 
 src or dst 
 number of elements (24-bit) 
 number of frames (16-bit) 
 for double indexing 
 for double indexing 
 Linked list 
 for OMAP_DMA_SYNC_PACKET  double indexing 
 for double indexing 
 CSDP_DATA_TYPE_xxx 
 CCR value 
 CLNK_CTRL value 
 CICR value 
 CSDP value 
 Linked List type123 
 Linked List type4 
 OMAP1 only 
 OMAP1 only 
 OMAP1 only 
 OMAP2+ only 
 OMAP2+ only 
 OMAP2+ only 
 OMAP1 only 
 OMAP1 only 
 OMAP1 only 
 OMAP1 only 
 OMAP1 only 
 OMAP1 only 
 OMAP1 only 
 OMAP1 only 
 OMAP1 only 
 OMAP1 only 
 OMAP1 only 
 OMAP1 only 
 OMAP1 only 
 OMAP2+ only 
 OMAP2+ only 
 OMAP2+ only 
 OMAP2+ only 
 OMAP2+ only 
 OMAP2+ only 
 Enable interrupts 
 Enable channel 
 Wait for sDMA FIFO to drain 
 disable irq 
 set the STOP_LNK bit 
	
	  This provides the necessary barrier to ensure data held in
	  DMA coherent memory is visible to the DMA engine prior to
	  the transfer starting.
 This should never happen 
 Duplicate what plat-omapdma.c does 
  OMAP 3.23.3 erratum: sometimes 0 is returned if CSACCDAC is
  read before the DMA controller finished disabling the channel.
		
		  CDAC == 0 indicates that the DMA transfer on the channel has
		  not been started (no data has been transferred so far).
		  Return the programmed source start address in this case.
		
		  CDAC == 0 indicates that the DMA transfer on the channel
		  has not been started (no data has been transferred so
		  far).  Return the programmed destination start address in
		  this case.
		
		  The channel is no longer active, set the return value
		  accordingly and mark it as completed
 Bus width translates to the element size (ES) 
 not reached 
 Now allocate and setup the descriptor. 
 When the port_window is used, one frame must cover the window 
		
		  One frame covers the port_window and by  configure
		  the source frame index to be -1  (port_window - 1)
		  we instruct the sDMA that after a frame is processed
		  it should move back to the start of the window.
	
	  Build our scatterlist entries: each contains the address,
	  the number of elements (EN) in each frame, and the number of
	  frames (FN).  Number of bytes for this entry = ES  EN  FN.
	 
	  Burst size translates to number of elements with frame sync.
	  Note: DMA engine defines burst to be the number of dev-width
	  transfers.
 Release the dma_pool entries if one allocation failed 
 Bus width translates to the element size (ES) 
 not reached 
 Now allocate and setup the descriptor. 
 Slave mode is not supported 
	
	  Stop DMA activity: we assume the callback will not be called
	  after omap_dma_stop() returns (even if it does, it will see
	  c->desc is NULL and exit.)
 Avoid stopping the dma twice 
	
	  We do not allow DMA_MEM_TO_DEV transfers to be paused.
	  From the AM572x TRM, 16.1.4.18 Disabling a Channel During Transfer:
	  "When a channel is disabled during a transfer, the channel undergoes
	  an abort, unless it is hardware-source-synchronized …".
	  A source-synchronised channel is one where the fetching of data is
	  under control of the device. In other words, a device-to-memory
	  transfer. So, a destination-synchronised channel (which would be a
	  memory-to-device transfer) undergoes an abort if the the CCR_ENABLE
	  bit is cleared.
	  From 16.1.4.20.4.6.2 Abort: "If an abort trigger occurs, the channel
	  aborts immediately after completion of current readwrite
	  transactions and then the FIFO is cleaned up." The term "cleaned up"
	  is not defined. TI recommends to check that RD_ACTIVE and WR_ACTIVE
	  are both clear _before_ disabling the channel, otherwise data loss
	  will occur.
	  The problem is that if the channel is active, then device activity
	  can result in DMA activity starting between reading those as both
	  clear and the write to DMA_CCR to clear the enable bit hitting the
	  hardware. If the DMA hardware can't drain the data in its FIFO to the
	  destination, then data loss "might" occur (say if we write to an UART
	  and the UART is not accepting any further data).
 Restore channel link register 
 Currently used by omap2 & 3 to block deeper SoC idle states 
 Currently only used for omap2. For omap1, also a check for lcd_dma is needed 
  We are using IRQENABLE_L1, and legacy DMA code was using IRQENABLE_L0.
  As the DSP may be using IRQENABLE_L2 and L3, let's not touch those for
  now. Context save seems to be only currently needed on omap3.
 Clear IRQSTATUS_L0 as legacy DMA code is no longer doing it 
 Clear dma channels 
 Currently only used for omap3 
 No need to restore context 
 Set only for omap2430 and later 
  No flags currently set for default configuration as omap1 is still
  using platform data.
 CCEN: 24bit unsigned 
 Number of DMA requests 
 Number of available logical channels 
 Mask of allowed logical channels 
 Tag channels not in mask as reserved 
 Disable all interrupts 
 Device-tree DMA controller registration 
 Disable all interrupts 
 SPDX-License-Identifier: GPL-2.0-only
 DMA engine 
 DMA scheduler 
 Queue manager 
 4 KiB of memory for descriptors, 2 for each endpoint 
 Packet Descriptor 
 Node for pending list 
 Pending queued transfers 
 Lock for pending list 
 context for suspendresume 
 USB0 ENDP 1 
 USB1 ENDP1 
 USB0 ENDP 1 
 USB1 ENDP 1 
 Usecount for chan_busy[], paired with push_desc_queue() 
 set corresponding bit for completetion Q 93 
 not set all bits for queues less than Q 93 
 now invert and keep only Q 93+ set 
			
			  This should never trigger, see the comments in
			  push_desc_queue()
	
	  We don't use writel() but __raw_writel() so we have to make sure
	  that the DMA descriptor in coherent memory made to the main memory
	  before starting the dma engine.
	
	  DMA transfers can take at least 200ms to complete with USB mass
	  storage connected. To prevent autosuspend timeouts, we must use
	  pm_runtime_getput() when chan_busy[] is modified. This will get
	  cleared in desc_to_chan() or cppi41_stop_chan() depending on the
	  outcome of the transfer.
  Caller must hold cdd->lock to prevent push_desc_queue()
  getting called out of order. We have both cppi41_dma_issue_pending()
  and cppi41_runtime_resume() call this function.
 PD3 = packet size 
 PD6 buffer size 
 We need to use more than one desc once musb supports sg 
	
	  If the TX descriptor  channel is in use, the caller needs to poke
	  his TD bit multiple times. After that he hardware releases the
	  transfer descriptor followed by TD descriptor. Waiting seems not to
	  cause any difference.
	  RX seems to be thrown out right away. However once the TearDown
	  descriptor gets through we are done. If we have seens the transfer
	  descriptor before the TD we fetch it from enqueue, it has to be
	  there waiting for us.
 Invoke the callback to do the necessary clean-up 
		
		  channels might still be in the pendling list if
		  cppi41_dma_issue_pending() is called after
		  cppi41_runtime_suspend() is called
 Usecount for chan_busy[], paired with push_desc_queue() 
	
	  The channels can only be used as TX or as RX. So we add twice
	  that much dma channels because USB can only do RX or TX.
  The param format is:
  X Y
  X: Port
  Y: 0 = RX else TX
 SPDX-License-Identifier: GPL-2.0
   Copyright (C) 2019 Texas Instruments Incorporated - http:www.ti.com
   Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
 RPSTR0 
 RPSTR0 
 RPSTR1 
 How SRCDST tag should be updated by UDMA in the descriptor's Word 3 
 Transmit ring 
 Transmit Completion ring 
 applicable only for PKTDMA 
 Free Descriptor ring 
 Receive ring 
 K3 UDMA Output Event Offset 
 BCDMA Output Event Offsets 
 PKTDMA Output Event Offsets 
 TR descriptor internal pointers 
 alignment to use for descriptors 
 Only used for cyclic in packet mode 
 pointer to provided metadata buffer (EPIP, PSdata) 
 not active, no teardown is in progress 
 Normal operation 
 channel is being terminated 
 TR or packet 
 EPIB is needed for the communication or not 
 size of Protocol Specific Data 
 (needs_epib ? 16:0) + psd_size 
 Size of a packet descriptor in packet mode 
 Suppress sending TDC packet 
 Channel Throughput Level 
 PKDMA mapped channel 
 PKTDMA default tflow or rflow for mapped channel 
 number of bytes completed since the start of the channel 
 Channel configuration parameters 
 dmapool for packet mode descriptors 
 Generic register access functions 
 TCHANRT 
 RCHANRT 
 No special handling for the channel 
 If more to purge, schedule the work again 
 RX flush packet: idx == -1 is only passed in case of DEV_TO_MEM 
 Ensure that writes are not moved over this point 
 Ensure that reads are not moved before this point 
 Teardown completion 
 Check for flush descriptor 
 make sure we are not leaking memory by stalled descriptor 
 Reset all counters 
 Hard reset: re-initialize the channel to reset 
 restore the channel configuration 
		
		  Setting forced teardown after forced reset helps recovering
		  the rchan.
		
		  UDMA only: Push all descriptors to ring for packet mode
		  cyclic or RX
		  PKTDMA supports pre-linked descriptor and cyclic is not
		  supported
 Only PDMAs have staticTR 
 Check if the staticTR configuration has changed for TX 
 Channel is already running and does not need reconfiguration 
 Make sure that we clear the teardown bit, if it is set 
 Push descriptors before we start the channel 
 Config remote TR 
 save the current staticTR configuration 
 Enable remote 
 Config remote TR 
 save the current staticTR configuration 
 Enable remote 
 Only TX towards PDMA is affected 
 Transfer is incomplete, store current residue and time stamp 
 Get previous residue and time stamp 
			
			  Get current residue and time stamp or see if
			  transfer is complete
			
			  Find the time delta and residue delta w.r.t
			  previous poll
				
				  Try to guess when we should check
				  next time by calculating rate at
				  which data is being drained at the
				  peer device
 No progress, check again in 1 second  
 Teardown completion message 
 active descriptor 
			
			  terminated descriptor, mark the descriptor as
			  completed to update the channel's cookie marker
 TODO: figure out the real amount of data 
  __udma_alloc_gp_rflow_range - alloc range of GP RX flows
  @ud: UDMA device
  @from: Start the search from this flow id number
  @cnt: Number of consecutive flow ids to allocate
  Allocate range of RX flow ids for future use, those flows can be requested
  only using explicit flow id number. if @from is set to -1 it will try to find
  first free range. if @from is positive value it will force allocation only
  of the specified range of flows.
  Returns -ENOMEM if can't find free range.
  -EEXIST if requested range is busy.
  -EINVAL if wrong input values passed.
  Returns flow id on success.
 default flows can't be allocated and accessible only by id 
	
	  Attempt to request rflow by ID can be made for any rflow
	  if not in use with assumption that caller knows what's doing.
	  TI-SCI FW will perform additional permission check ant way, it's
	  safe
 GP rflow has to be allocated first 
	
	  Use normal channels for peripherals, and highest TPL channel for
	  mem2mem
	
	  mapped_channel_id is -1 for UDMA, BCDMA and PKTDMA unmapped channels.
	  For PKTDMA mapped channels it is configured to a channel which must
	  be used to service the peripheral.
 Only PKTDMA have support for tx flows 
	
	  mapped_channel_id is -1 for UDMA, BCDMA and PKTDMA unmapped channels.
	  For PKTDMA mapped channels it is configured to a channel which must
	  be used to service the peripheral.
 Can be optimized, but let's have it like this for now 
	
	  Try to use the highest TPL channel pair for MEM_TO_MEM channels
	  Note: in UDMAP the channel TPL is symmetric between tchan and rchan
 UDMA does not use tx flows 
 For MEM_TO_MEM we don't need rflow or rings 
 Non synchronized - mem to mem type of transfer 
 wait for peer to complete the teardown for PDMAs 
 wait for peer to complete the teardown for PDMAs 
 in case of MEM_TO_MEM we have maximum of two TRs 
	
	  Make sure that the completion is in a known state:
	  No teardown, the channel is idle
 Non synchronized - mem to mem type of transfer 
 Slave transfer synchronized - mem to dev (TX) trasnfer 
 Slave transfer synchronized - dev to mem (RX) trasnfer 
 Can not happen 
 check if the channel configuration was successful 
 PSI-L pairing 
 Event from UDMA (TR events) only needed for slave TR mode channels 
 Only TR mode is supported 
	
	  Make sure that the completion is in a known state:
	  No teardown, the channel is idle
 Non synchronized - mem to mem type of transfer 
 Slave transfer synchronized - mem to dev (TX) trasnfer 
 Slave transfer synchronized - dev to mem (RX) trasnfer 
 Can not happen 
 check if the channel configuration was successful 
 PSI-L pairing 
 Event from BCDMA (TR events) only needed for slave channels 
	
	  Make sure that the completion is in a known state:
	  No teardown, the channel is idle
 Slave transfer synchronized - mem to dev (TX) trasnfer 
 Slave transfer synchronized - dev to mem (RX) trasnfer 
 Can not happen 
 check if the channel configuration was successful 
 PSI-L pairing 
 We have only one descriptor containing multiple TRs 
 Allocate memory for DMA ring descriptor 
 Start of the TR req records 
 Start address of the TR response array 
  udma_get_tr_counters - calculate TR counters for a given length
  @len: Length of the trasnfer
  @align_to: Preferred alignment
  @tr0_cnt0: First TR icnt0
  @tr0_cnt1: First TR icnt1
  @tr1_cnt0: Second (if used) TR icnt0
  For len < SZ_64K only one TR is enough, tr1_cnt0 is not updated
  For len >= SZ_64K two TRs are used in a simple way:
  First TR: SZ_64K-alignment blocks (tr0_cnt0, tr0_cnt1)
  Second TR: the remaining length (tr1_cnt0)
  Returns the number of TRs the length needs (1 or 2)
  -EINVAL if the length can not be supported
 estimate the number of TRs we will need 
 Now allocate and setup the descriptor. 
 estimate the number of TRs we will need 
 Now allocate and setup the descriptor. 
 Bus width translates to the element size (ES) 
 not reached 
	
	  PDMA must to close the packet when the channel is in packet mode.
	  For TR mode when the channel is not cyclic we also need PDMA to close
	  the packet otherwise the transfer will stall because PDMA holds on
	  the data it has received from the peripheral.
 Flow and Packed ID 
 attach the sg buffer to the descriptor 
 Attach link as host buffer descriptor 
 static TR for remote PDMA 
 Now allocate and setup the descriptor. 
 TODO: re-check this... 
 Flow and Packed ID 
 attach each period to a new descriptor 
 static TR for remote PDMA 
 If we have something pending and no active descriptor, then 
		
		  start a descriptor if the channel is NOT [marked as
		  terminating _and_ it is still running (teardown has not
		  completed yet)].
 pause the channel 
 resume the channel 
 Provide residue information for the client 
  This tasklet handles the completion of a DMA descriptor by
  calling its callback and freeing it.
 Release PSI-L pairing 
 Normal Channels 
 H Channels 
 No UH Channels 
 Normal Channels 
 H Channels 
 No UH Channels 
 Normal Channels 
 H Channels 
 UH Channels 
 MEM_TO_MEM is slow via MCU UDMA 
 Normal Channels 
 H Channels 
 No UH Channels 
 for tchan and rchan, not applicable to bchan 
 Supported via bchan 
 Normal Channels 
 No H Channels 
 No UH Channels 
 PKTDMA does not support MEM_TO_MEM 
 Normal Channels 
 No H Channels 
 No UH Channels 
 Sentinel  },
 Sentinel  },
 Sentinel  },
 sentinel  }
 Set up the throughput level start indexes 
	
	  RX flows with the same Ids as RX channels are reserved to be used
	  as default flows if remote HW can't generate flow_ids. Those
	  RX flows can be requested only explicitly by id.
 by default no GP rflows are assigned to Linux 
 Get resource ranges from tisci 
 tchan ranges 
 rchan and matching default flow ranges 
 GP rflow ranges 
 all gp flows are assigned exclusively to Linux 
 Set up the throughput level start indexes 
 BCDMA do not really have flows, but the driver expect it 
 Get resource ranges from tisci 
 bchan ranges 
 tchan ranges 
 rchan ranges 
 Set up the throughput level start indexes 
 Get resource ranges from tisci 
 tchan ranges 
 rchan ranges 
 rflow ranges 
 all rflows are assigned exclusively to Linux 
 tflow ranges 
 all tflows are assigned exclusively to Linux 
 Allocate 1K buffer for discarded data on RX channel teardown 
 Set up descriptor to be used for TR mode 
 Start of the TR req records 
 Start address of the TR response array 
 Set up descriptor to be used for packet mode 
 CONFIG_DEBUG_FS 
 Get the highest TPL level the device supports for memcpy 
 cyclic operation is not supported via PKTDMA 
 Use custom vchan completion handling 
 Configure the copy_align to the maximum burst size the device supports 
 Private interfaces to UDMA 
  TI EDMA DMA engine driver
  Copyright 2012 Texas Instruments
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 Offsets matching "struct edmacc_param" 
 Offsets for EDMA CC global channel registers and their shadows 
 64 bits 
 64 bits 
 64 bits 
 64 bits 
 64 bits 
 64 bits 
 64 bits 
 64 bits 
 64 bits 
 64 bits 
 64 bits 
 64 bits 
 64 bits 
 64 bits 
 Offsets for EDMA CC global registers 
 8 registers 
 8 registers (4 on OMAP-L1xx) 
 64 bits 
 64 bits 
 4 x 64 bits
 4 registers 
 2 x 16 registers 
 2 registers 
 global channel registers 
 4 shadow regions 
 PaRAM entries 
 64 registers 
 CCCFG register 
 bits 0-2 
 bits 4-6 
 bits 12-14 
 bits 16-18 
 bits 20-21 
 CCSTAT register 
  Max of 20 segments per channel to conserve PaRAM slots
  Also note that MAX_NR_SG should be atleast the no.of periods
  that are required for ASoC, otherwise DMA prep calls will
  fail. Today davinci-pcm is the only user of this driver and
  requires atleast 17 slots, so we setup the default to 20.
 for edma_alloc_channel() 
 for edma_alloc_slot() 
  64bit array registers are split into two 32bit registers:
  reg0: channelevent 0-31
  reg1: channelevent 32-63
  bit 5 in the channel number tells the array index (01)
  bit 0-4 (0x1f) is the bit offset within the register
 PaRAM slots are laid out like this 
 fields in edmacc_param.opt 
	
	  The following 4 elements are used for residue accounting.
	 
	  - processed_stat: the number of SG elements we have traversed
	  so far to cover accounting. This is updated directly to processed
	  during edma_callback and is always <= processed, because processed
	  refers to the number of pending transfer (programmed to EDMA
	  controller), where as processed_stat tracks number of transfers
	  accounted for so far.
	 
	  - residue: The amount of bytes we have left to transfer for this desc
	 
	  - residue_stat: The residue in bytes of data we have covered
	  so far for accounting. This is updated directly to residue
	  during callbacks to keep it current.
	 
	  - sg_len: Tracks the length of the current intermediate transfer,
	  this is required to update the residue during intermediate transfer
	  completion callback.
 eDMA3 resource information 
	
	  The slot_inuse bit for each PaRAM slot is clear unless the slot is
	  in use by Linux or if it is allocated to be used by DSP.
	
	  For tracking reserved channels used by DSP.
	  If the bit is cleared, the channel is allocated to be used by DSP
	  and Linux must not touch it.
 dummy param set used to (re)initialize parameter RAM slots 
  paRAM slot management functions
  edma_alloc_slot - allocate DMA parameter RAM
  @ecc: pointer to edma_cc struct
  @slot: specific slot to allocate; negative for "any unused slot"
  This allocates a parameter RAM slot, initializing it to hold a
  dummy transfer.  Slots allocated using this routine have not been
  mapped to a hardware DMA channel, and will normally be used by
  linking to them from a slot associated with a DMA channel.
  Normal use is to pass EDMA_SLOT_ANY as the @slot, but specific
  slots may be allocated on behalf of DSP firmware.
  Returns the number of the slot, else negative errno.
 Requesting entry paRAM slot for a HW triggered channel. 
  edma_link - link one parameter RAM slot to another
  @ecc: pointer to edma_cc struct
  @from: parameter RAM slot originating the link
  @to: parameter RAM slot which is the link target
  The originating slot should not be part of any active DMA transfer.
  edma_get_position - returns the current transfer point
  @ecc: pointer to edma_cc struct
  @slot: parameter RAM slot being examined
  @dst:  true selects the dest position, false the source
  Returns the position of the current active slot
  Channels with event associations will be triggered by their hardware
  events, and channels without such associations will be triggered by
  software.  (At this writing there is no interface for using software
  triggers except with channels that don't support hardware triggers.)
 EDMA channels without event association 
 EDMA channel with event association 
 Clear any pending event or error 
 Clear any SER 
 clear possibly pending completion interrupt 
	 REVISIT:  consider guarding against inappropriate event
	  chaining by overwriting with dummy_paramset.
  Temporarily disable EDMA hardware events on the specified channel,
  preventing them from triggering new transfers
 Re-enable EDMA hardware events on the specified channel.  
 Clear the corresponding EMR bits 
 Clear any SER 
 Move channel to a specific event queue 
 default to low priority queue 
 ensure access through shadow region 0 
 ensure no events are pending 
 ensure no events are pending 
 REVISIT should probably take out of shadow region 0 
 Dispatch a queued descriptor to the controller (caller holds lock) 
 Setup is needed for the first transfer 
 Find out how many left 
 Write descriptor PaRAM set(s) 
 Link to the previous slot if not the last set 
	
	  If this is either the last set in a set of SG-list transactions
	  then setup a link to the dummy slot, this results in all future
	  events being absorbed and that's OK because we're done
		
		  This happens due to setup times between intermediate
		  transfers in long SG lists which have to be broken up into
		  transfers of MAX_NR_SG
	
	  Stop DMA activity: we assume the callback will not be called
	  after edma_dma() returns (even if it does, it will see
	  echan->edesc is NULL and exit.)
 Move the cyclic channel back to default queue 
  A PaRAM set configuration abstraction used by other modes
  @chan: Channel who's PaRAM set we're configuring
  @pset: PaRAM set to initialize and setup.
  @src_addr: Source address of the DMA
  @dst_addr: Destination address of the DMA
  @burst: In units of dev_width, how much to send
  @dev_width: How much is the dev_width
  @dma_length: Total length of the DMA transfer
  @direction: Direction of the transfer
 srcdst_maxburst == 0 is the same case as srcdst_maxburst == 1 
	
	  If the maxburst is equal to the fifo width, use
	  A-synced transfers. This allows for large contiguous
	  buffer transfers using only one PaRAM set.
		
		  For the A-sync case, bcnt and ccnt are the remainder
		  and quotient respectively of the division of:
		  (dma_length  acnt) by (SZ_64K -1). This is so
		  that in case bcnt over flows, we have ccnt to use.
		  Note: In A-sync tranfer only, bcntrld is used, but it
		  only applies for sg_dma_len(sg) >= SZ_64K.
		  In this case, the best way adopted is- bccnt for the
		  first frame will be the remainder below. Then for
		  every successive frame, bcnt will be SZ_64K-1. This
		  is assured as bcntrld = 0xffff in end of function.
		
		  If bcnt is non-zero, we have a remainder and hence an
		  extra frame to transfer, so increment ccnt.
		
		  If maxburst is greater than the fifo address_width,
		  use AB-synced transfers where A count is the fifo
		  address_width and B count is the maxburst. In this
		  case, we are limited to transfers of C count frames
		  of (address_width  maxburst) where C count is limited
		  to SZ_64K-1. This places an upper bound on the length
		  of an SG segment that can be handled.
 Configure A or AB synchronized transfers 
	
	  Only time when (bcntrld) auto reload is required is for
	  A-sync case, and in this case, a requirement of reload value
	  of SZ_64K-1 only is assured. 'link' is initially set to NULL
	  and then later will be populated by edma_execute.
 Allocate a PaRAM slot, if needed 
 Configure PaRAM sets for each SG 
 Get address for each SG 
 Enable completion interrupt 
			
			  Enable early completion interrupt for the
			  intermediateset. In this case the driver will be
			  notified when the paRAM set is submitted to TC. This
			  will allow more time to set up the next set of slots.
 Align the array size (acnt block) with the transfer properties 
		
		  Transfer size less than 64K can be handled with one paRAM
		  slot and with one burst.
		  ACNT = length
		
		  Transfer size bigger than 64K will be handled with maximum of
		  two paRAM slots.
		  slot1: (full_length  32767) times 32767 bytes bursts.
		 	  ACNT = 32767, length1: (full_length  32767)  32767
		  slot2: the remaining amount of data after slot1.
		 	  ACNT = full_length - length1, length2 = ACNT
		 
		  When the full_length is multibple of 32767 one slot can be
		  used to complete the transfer.
 One slot is enough for lengths multiple of (SZ_32K -1) 
 Enable transfer complete interrupt if requested 
 Enable transfer complete chaining for the first slot 
 Enable transfer complete interrupt if requested 
 Slave mode is not supported 
 Enable transfer complete interrupt if requested 
	
	  Cyclic DMA users such as audio cannot tolerate delays introduced
	  by cases where the number of periods is more than the maximum
	  number of SGs the EDMA driver can handle at a time. For DMA types
	  such as Slave SGs, such delays are tolerable and synchronized,
	  but the synchronization is difficult to achieve with Cyclic and
	  cannot be guaranteed, so we error out early.
		
		  If the burst and period sizes are the same, we can put
		  the full buffer into a single period and activate
		  intermediate interrupts. This will produce interrupts
		  after each burst, which is also after each desired period.
 Allocate a PaRAM slot, if needed 
		
		  Enable period interrupt only if it is requested
 Also enable intermediate interrupts if necessary 
 Place the cyclic channel to highest priority queue 
 Update statistics for tx_status 
 eDMA interrupt handler 
 Clear the corresponding IPR bits 
	
	  Issue later based on missed flag which will be sure
	  to happen as:
	  (1) we finished transmitting an intermediate slot and
	      edma_execute is coming up.
	  (2) or we finished current transfer and issue will
	      call edma_execute.
	 
	  Important note: issuing can be dangerous here and
	  lead to some nasty recursion when we are in a NULL
	  slot. So we avoid doing so and set the missed flag.
		
		  The slot is already programmed but the event got
		  missed, so its safe to issue it here.
 eDMA error interrupt handler 
		
		  The registers indicate no pending error event but the irq
		  handler has been called.
		  Ask eDMA to re-evaluate the error registers.
 Event missed register(s) 
 Clear the corresponding EMR bits 
 Clear any SER 
 Not reported, just clear the interrupt reason. 
 Not reported, just clear the interrupt reason. 
 Alloc channel resources 
 memcpy channel 
 Set up channel -> slot mapping for the entry slot 
 Free channel resources 
 Terminate transfers 
 Free EDMA PaRAM slots 
 Set entry slot to the dummy slot 
 Free EDMA channel 
 Send pending descriptor to hardware 
  This limit exists to avoid a possible infinite loop when waiting for proof
  that a particular transfer is completed. This limit can be hit if there
  are large bursts tofrom slow devices or the CPU is never able to catch
  the DMA hardware idle. On an AM335x transfering 48 bytes from the UART
  RX-FIFO, as many as 55 loops have been seen.
	
	  We always read the dstsrc position from the first RamPar
	  pset. That's the one which is active now.
	
	  "pos" may represent a transfer request that is still being
	  processed by the EDMACC or EDMATC. We will busy wait until
	  any one of the situations occurs:
	    1. while and event is pending for the channel
	    2. a position updated
	    3. we hit the loop limit
	
	  Cyclic is simple. Just subtract pset[0].addr from pos.
	 
	  We never update edesc->residue in the cyclic case, so we
	  can tell the remaining room to the end of the circular
	  buffer.
	
	  If the position is 0, then EDMA loaded the closing dummy slot, the
	  transfer is completed
	
	  For SG operation we catch up with the last processed
	  status.
		
		  If we are inside this pset address range, we know
		  this is the active one. Get the current delta and
		  stop walking the psets.
 Otherwise mark it done and update residue_stat. 
 Check request completion status 
 Provide a dummy dma_tx_state for completion checking 
	
	  Mark the cookie completed if the residue is 0 for non cyclic
	  transfers
 CIDX: 16bit signed 
 Decode the eDMA3 configuration from CCCFG register 
 Nothing need to be done if queue priority is provided 
	
	  Configure TCqueue priority as follows:
	  Q0 - priority 0
	  Q1 - priority 1
	  Q2 - priority 2
	  ...
	  The meaning of priority numbers: 0 highest priority, 7 lowest
	  priority. So Q0 is the highest priority queue and the last queue has
	  the lowest priority.
 Default queue has the lowest priority 
 Invalidate last entry for the other user of this mess 
 Get the list of channels allocated to be used for memcpy 
 The channel is going to be used as HW synchronized 
 When booting with DT the pdev->id is -1 
 Get eDMA3 configuration from IP 
 Allocate memory based on the information we got from the IP 
 Mark all channels available initially 
 Set the reserved slots in inuse list 
 Clear channels not usable for Linux 
 Reset only unused - not reserved - paRAM slots 
 See if we have optional dma-channel-mask array 
 Event queue priority mapping 
 Init the dma device and channels 
 Do not touch reserved channels 
 Assign all channels to the default queue 
 Set entry slot to the dummy slot 
 re initialize dummy slot to dummy param set 
 Event queue priority mapping 
 ensure access through shadow region 0 
 Set up channel -> slot mapping for the entry slot 
 The channel is going to be used as HW synchronized 
 SPDX-License-Identifier: GPL-2.0
   Copyright (C) 2019 Texas Instruments Incorporated - http:www.ti.com
   Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
 Exported register access functions 
 SPDX-License-Identifier: GPL-2.0-only
   Copyright (C) 2015 Texas Instruments Incorporated - http:www.ti.com
   Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
 Crossbar on AM335xAM437x family 
 maximum number of events to select in xbar 
 number of DMA requests on eDMA 
	
	  TPCC_EVT_MUX_60_63 register layout is different than the
	  rest, in the sense, that event 63 is mapped to lowest byte
	  and event 60 is mapped to highest, handle it separately.
 The of_node_put() will be done in the core for the node 
 Reset the crossbar 
 Crossbar on DRA7xx family 
 Value to rest the crossbar lines 
 number of DMA requests connected to XBAR 
 number of DMA requests forwarded to DMA 
 The of_node_put() will be done in the core for the node 
 Reset the crossbar 
 Restore the defaults for the crossbar 
 SPDX-License-Identifier: GPL-2.0
   Copyright (C) 2019 Texas Instruments Incorporated - http:www.ti.com
   Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
 PSI-L source thread IDs, used for RX (DMA_DEV_TO_MEM) 
 SA2UL 
 PRU_ICSSG0 
 PRU_ICSSG1 
 PRU_ICSSG2 
 PDMA0 - McASPs 
 PDMA1 - SPI0-4 
 PDMA1 - USART0-2 
 CPSW0 
 MCU_PDMA0 - ADCs 
 MCU_PDMA1 - MCU_SPI0-2 
 MCU_PDMA1 - MCU_USART0 
 PSI-L destination thread IDs, used for TX (DMA_MEM_TO_DEV) 
 SA2UL 
 PRU_ICSSG0 
 PRU_ICSSG1 
 PRU_ICSSG2 
 CPSW0 
 SPDX-License-Identifier: GPL-2.0
   Copyright (C) 2020 Texas Instruments Incorporated - https:www.ti.com
   Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
 PSI-L source thread IDs, used for RX (DMA_DEV_TO_MEM) 
 SAUL 
 ICSS_G0 
 ICSS_G1 
 PDMA_MAIN0 - SPI0-3 
 PDMA_MAIN0 - USART0-1 
 PDMA_MAIN1 - SPI4 
 PDMA_MAIN1 - USART2-6 
 PDMA_MAIN1 - ADCs 
 CPSW2 
 PSI-L destination thread IDs, used for TX (DMA_MEM_TO_DEV) 
 SAUL 
 ICSS_G0 
 ICSS_G1 
 CPSW2 
 SPDX-License-Identifier: GPL-2.0
   Copyright (C) 2019 Texas Instruments Incorporated - http:www.ti.com
   Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
 sentinel  }
 check in destination thread map 
 SPDX-License-Identifier: GPL-2.0
   Copyright (C) 2019 Texas Instruments Incorporated - http:www.ti.com
   Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
 PSI-L source thread IDs, used for RX (DMA_DEV_TO_MEM) 
 SA2UL 
 PRU_ICSSG0 
 PRU_ICSSG1 
 PDMA6 (PSIL_PDMA_MCASP_G0) - McASP0-2 
 PDMA7 (PSIL_PDMA_MCASP_G1) - McASP3-11 
 PDMA8 (PDMA_MISC_G0) - SPI0-1 
 PDMA9 (PDMA_MISC_G1) - SPI2-3 
 PDMA10 (PDMA_MISC_G2) - SPI4-5 
 PDMA11 (PDMA_MISC_G3) 
 PDMA13 (PDMA_USART_G0) - UART0-1 
 PDMA14 (PDMA_USART_G1) - UART2-3 
 PDMA15 (PDMA_USART_G2) - UART4-9 
 CSI2RX 
 CPSW9 
 CPSW0 
 MCU_PDMA0 (MCU_PDMA_MISC_G0) - SPI0 
 MCU_PDMA1 (MCU_PDMA_MISC_G1) - SPI1-2 
 MCU_PDMA2 (MCU_PDMA_MISC_G2) - UART0 
 MCU_PDMA_ADC - ADC0-1 
 SA2UL 
 PSI-L destination thread IDs, used for TX (DMA_MEM_TO_DEV) 
 SA2UL 
 PRU_ICSSG0 
 PRU_ICSSG1 
 CPSW9 
 CPSW0 
 SA2UL 
 SPDX-License-Identifier: GPL-2.0
  K3 NAVSS DMA glue interface
  Copyright (C) 2019 Texas Instruments Incorporated - http:www.ti.com
 The struct containing the device is devm managed 
 get psil endpoint config 
 parse of udmap channel 
 request and cfg UDMAP TX channel 
 prepare the channel device as coherent 
 request and cfg rings 
 Set the dma_dev for the rings to be configured 
 Set the ASEL value for DMA rings of PKTDMA 
 request and cfg psi-l 
	
	  TXQ reset need to be special way as it is input for udma and its
	  state cached by udma, so:
	  1) save TXQ occ
	  2) clean up TXQ and call callback .cleanup() for each desc
	  3) reset TXQ in a special way
 reset TXCQ as it is not input for udma - expected to be empty 
	
	  TODO: we can't support rxcq_qnumRCHAN[a]_RCQ cfg with current sysfw
	  and udmax impl, so just configure it to invalid value.
	  req.rxcq_qnum = k3_ringacc_get_ring_id(rx_chn->flows[0].ringrx);
 Default flow + extra ones 
 request and cfg rings 
 Set the dma_dev for the rings to be configured 
 Set the ASEL value for DMA rings of PKTDMA 
 default rflow 
 not a GP rflows 
 Allocate range of GP rflows 
 parse of udmap channel 
 request and cfg UDMAP RX channel 
 prepare the channel device as coherent 
 Use RX channel id as flow id: target dev can't generate flow_id 
 request and cfg psi-l 
 init default RX flow only if flow_num = 1 
	
	  Remote RX channel is under control of Remote CPU core, so
	  Linux can only request and manipulate by dedicated RX flows
 parse of udmap channel 
 prepare the channel device as coherent 
 reset RXCQ as it is not input for udma - expected to be empty 
 Skip RX FDQ in case one FDQ is used for the set of flows 
	
	  RX FDQ reset need to be special way as it is input for udma and its
	  state cached by udma, so:
	  1) save RX FDQ occ
	  2) clean up RX FDQ and call callback .cleanup() for each desc
	  3) reset RX FDQ in a special way
 SPDX-License-Identifier: GPL-2.0
   Copyright (C) 2019 Texas Instruments Incorporated - http:www.ti.com
   Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
 PSI-L source thread IDs, used for RX (DMA_DEV_TO_MEM) 
 PDMA_MCASP - McASP0-2 
 PDMA_SPI_G0 - SPI0-3 
 PDMA_SPI_G1 - SPI4-7 
 PDMA_USART_G0 - UART0-1 
 PDMA_USART_G1 - UART2-3 
 PDMA_USART_G2 - UART4-9 
 CPSW5 
 CPSW0 
 MCU_PDMA_MISC_G0 - SPI0 
 MCU_PDMA_MISC_G1 - SPI1-2 
 MCU_PDMA_MISC_G2 - UART0 
 MCU_PDMA_ADC - ADC0-1 
 SA2UL 
 PSI-L destination thread IDs, used for TX (DMA_MEM_TO_DEV) 
 CPSW5 
 CPSW0 
 SA2UL 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008
  Guennadi Liakhovetski, DENX Software Engineering, <lg@denx.de>
  Copyright (C) 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  There can be only one, we could allocate it dynamically, but then we'd have
  to add an extra parameter to some functions, and use something as ugly as
 	struct ipu ipu = to_ipu(to_idmac(ichan->dma_chan.device));
  in the ISR
  IPU  IC common functions
 generic data 
 generic data 
 Enable direct write to memory by the Camera Sensor Interface 
 Called under spin_lock_irqsave(&ipu_data.lock) 
 Word 0 
 Word 1 
 Word 0 
 Word 1 
Represents 8-bit Generic data 
 SAT = use 32-bit access 
Represents 32-bit Generic data 
 SAT = use 32-bit access 
 SAT = 32-bit access 
 Red bit offset 
 Green bit offset 
 Blue bit offset 
 Alpha bit offset 
 Red bit width - 1 
 Green bit width - 1 
 Blue bit width - 1 
 24 BPP & RGB PFS 
 SAT = 32-bit access 
 Red bit offset 
 Green bit offset 
 Blue bit offset 
 Alpha bit offset 
 Red bit width - 1 
 Green bit width - 1 
 Blue bit width - 1 
 24 BPP & RGB PFS 
 SAT = 32-bit access 
 Red bit offset 
 Green bit offset 
 Blue bit offset 
 Alpha bit offset 
 Red bit width - 1 
 Green bit width - 1 
 Blue bit width - 1 
 SAT = 32-bit access 
 Red bit offset 
 Green bit offset 
 Blue bit offset 
 Alpha bit offset 
 Red bit width - 1 
 Green bit width - 1 
 Blue bit width - 1 
 Alpha bit width - 1 
 SAT = 32-bit access 
 Red bit offset 
 Green bit offset 
 Blue bit offset 
 Alpha bit offset 
 Red bit width - 1 
 Green bit width - 1 
 Blue bit width - 1 
 Alpha bit width - 1 
 SAT = 32-bit access 
 SAT = 32-bit access 
 SAT = 32-bit access 
 SAT = 32-bit access 
 set to word 0 
 increment to next row 
 Cannot downsize more than 8:1 
 compute downsizing coefficient 
	
	  compute resizing coefficient using the following formula:
	  resize_coeff = M(SI -1)(SO - 1)
	  where M = 2^13, SI - input size, SO - output size
 Setup vertical resizing 
 Setup horizontal resizing 
 Setup color space conversion 
	
	  Colourspace conversion unsupported yet - see _init_csc() in
	  Freescale sources
 Channel Parameter Memory 
  ipu_enable_channel() - enable an IPU channel.
  @idmac:	IPU DMAC context.
  @ichan:	IDMAC channel.
  @return:	0 on success or negative error code on failure.
 Reset to buffer 0 
  ipu_init_channel_buffer() - initialize a buffer for logical IPU channel.
  @ichan:	IDMAC channel.
  @pixel_fmt:	pixel format of buffer. Pixel format is a FOURCC ASCII code.
  @width:	width of buffer in pixels.
  @height:	height of buffer in pixels.
  @stride:	stride length of buffer in pixels.
  @rot_mode:	rotation mode of buffer. A rotation setting other than
 		IPU_ROTATE_VERT_FLIP should only be used for input buffers of
 		rotation channels.
  @phyaddr_0:	buffer 0 physical address.
  @phyaddr_1:	buffer 1 physical address. Setting this to a value other than
 		NULL enables double buffering mode.
  @return:	0 on success or negative error code on failure.
 IC channel's stride must be a multiple of 8 pixels 
 Build parameter memory data for DMA channel 
  ipu_select_buffer() - mark a channel's buffer as ready.
  @channel:	channel ID.
  @buffer_n:	buffer number to mark ready.
 No locking - this is a write-one-to-set register, cleared by IPU 
 Mark buffer 0 as ready. 
 Mark buffer 1 as ready. 
  ipu_update_channel_buffer() - update physical address of a channel buffer.
  @ichan:	IDMAC channel.
  @buffer_n:	buffer number to update.
 		0 or 1 are the only valid values.
  @phyaddr:	buffer physical address.
 Called under spin_lock(_irqsave)(&ichan->lock) 
 44.3.3.1.9 - Row Number 1 (WORD1, offset 0) 
 Check if double-buffering is already enabled 
 44.3.3.1.9 - Row Number 1 (WORD1, offset 1) 
 Called under spin_lock_irqsave(&ichan->lock) 
	
	  On first invocation this shouldn't be necessary, the call to
	  ipu_init_channel_buffer() above will set addresses for us, so we
	  could make it conditional on status >= IPU_CHANNEL_ENABLED, but
	  doing it again shouldn't hurt either.
 Called under spin_lock_irqsave(&ichan->lock) 
 Sanity check 
 The descriptor doesn't belong to client 
		
		  Initial buffer assignment - the first two sg-entries from
		  the descriptor will end up in the IDMAC buffers
 ipu->lock can be taken under ichan->lock, but not v.v. 
 submit_buffers() atomically verifies and fills empty sg slots 
 Called with ichan->chan_mutex held 
 No interrupts, just disable the tasklet for a moment 
  ipu_init_channel() - initialize an IPU channel.
  @idmac:	IPU DMAC context.
  @ichan:	pointer to the channel object.
  @return      0 on success or negative error code on failure.
 Enable IPU sub module 
  ipu_uninit_channel() - uninitialize an IPU channel.
  @idmac:	IPU DMAC context.
  @ichan:	pointer to the channel object.
 Reset the double buffer 
  ipu_disable_channel() - disable an IPU channel.
  @idmac:		IPU DMAC context.
  @ichan:		channel object pointer.
  @wait_for_stop:	flag to set whether to wait for channel end of frame or
 			return immediately.
  @return:		0 on success or negative error code on failure.
 This waiting always fails. Related to spurious irq problem 
 SDC BG and FG must be disabled before DMA is disabled 
 Disable IC task 
 Disable DMA channel(s) 
 next sg-element in this list 
 No more descriptors on the queue 
 Fetch next descriptor 
  We have several possibilities here:
  current BUF		next BUF
  not last sg		next not last sg
  not last sg		next last sg
  last sg		first sg from next descriptor
  last sg		NULL
  Besides, the descriptor queue might be empty or not. We process all these
  cases carefully.
 Next transfer descriptor 
 IDMAC has cleared the respective BUFx_RDY bit, we manage the buffer 
		
		  Doing this
		  ichan->sg[0] = ichan->sg[1] = NULL;
		  you can force channel re-enable on the next tx_submit(), but
		  this is dirty - think about descriptors with multiple
		  sg elements.
 Other interrupts do not interfere with this channel 
	
	  active_buffer is a software flag, it shows which buffer we are
	  currently expecting back from the hardware, IDMAC should be
	  processing the other buffer already
 Find the descriptor of sgnext 
	
	  if sgnext == NULL sg must be the last element in a scatterlist and
	  queue must be empty
 Continue to check for complete descriptor 
 Calculate and submit the next sg element 
		
		  Last element in scatterlist done, remove from the queue,
		  _init for debugging
 Flip the active buffer - even if update above failed 
 Allocate and initialise a transfer descriptor. 
 We only can handle these three channels so far 
 Re-select the current buffer and re-activate the channel 
 This is not always needed, but doesn't hurt either 
	
	  Might need to perform some parts of initialisation from
	  ipu_enable_channel(), but not all, we do not want to reset to buffer
	  0, don't need to set priority again either, but re-enabling the task
	  and the channel might be a good idea.
 Return all descriptors into "prepared" state 
 ichan->queue is modified in ISR, have to spinlock 
 Descriptor was prepared, but not submitted 
 dmaengine.c now guarantees to only offer free channels 
	
	  Important to first disable the channel, because maybe someone
	  used it before us, e.g., the bootloader
 Compulsory common fields 
 Compulsory for DMA_SLAVE fields 
  IPU common probe  remove
 Remap IPU common registers 
 Remap Image Converter and Image DMA Controller registers 
 Get IPU clock 
 Make sure IPU HSP clock is running 
 Disable all interrupts 
 Initialize DMA engine 
  We need two MEM resources - with IPU-common and Image Converter registers,
  including PF_CONF and IDMAC_ registers, and two IRQs - function and error
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008
  Guennadi Liakhovetski, DENX Software Engineering, <lg@denx.de>
  Register read  write - shall be inlined by the compiler
  IPU IRQ chip driver
 3 groups of functional interrupts 
 2 groups of error interrupts 
 Protects allocations from the above array of maps 
 Protects register accesses and individual mappings 
  ipu_irq_status() - returns the current interrupt status of the specified IRQ.
  @irq:	interrupt line to get status for.
  @return:	true if the interrupt is pendingasserted or false if the
 		interrupt is not pending.
  ipu_irq_map() - map an IPU interrupt source to an IRQ number
  @source:	interrupt source bit position (see below)
  @return:	mapped IRQ number or negative error code
  The source parameter has to be explained further. On i.MX31 IPU has 137 IRQ
  sources, they are broken down in 5 32-bit registers, like 32, 32, 24, 32, 17.
  However, the source argument of this function is not the sequence number of
  the possible IRQ, but rather its bit position. So, first interrupt in fourth
  register has source number 96, and not 88. This makes calculations easier,
  and also provides forward compatibility with any future IPU implementations
  with any interrupt bit assignments.
  ipu_irq_unmap() - unmap an IPU interrupt source
  @source:	interrupt source bit position (see ipu_irq_map())
  @return:	0 or negative error code
 Chained IRQ handler for IPU function and error interrupt 
		
		  Don't think we have to clear all interrupts here, they will
		  be acked by ->handle_irq() (handle_level_irq). However, we
		  might want to clear unhandled interrupts after the loop...
 Install the IRQ handler 
  Broadcom specific AMBA
  PCI Core in hostmode
  Copyright 2005 - 2011, Broadcom Corporation
  Copyright 2006, 2007, Michael Buesch <m@bues.ch>
  Copyright 2011, 2012, Hauke Mehrtens <hauke@hauke-m.de>
  Licensed under the GNUGPL. See COPYING for details.
 Probe a 32bit value on the bus and catch bus exceptions.
  Returns nonzero on a bus exception.
 Assume one-hot slot wiring 
	 Issue config commands only when the data link is up (atleast
	  one external pcie device is present).
 Type 0 transaction 
 Slide the PCI window to the appropriate slot 
 Calculate the address 
 we support only two functions on device 0 
		 accesses to config registers with offsets >= 256
		  requires indirect access.
 we support only two functions on device 0 
		 accesses to config registers with offsets >= 256
		  requires indirect access.
		 accesses to config registers with offsets >= 256
		  requires indirect access.
 return cap_offset if requested capability exists in the PCI config space 
 check for Header type 0 
 check if the capability pointer field exists 
 check if the capability pointer is 0x00 
	 loop thr'u the capability list and see if the requested capabilty
 found the caller requested capability 
 copy the cpability data excluding cap ID and next ptr 
 If the root port is capable of returning Config Request
  Retry Status (CRS) Completion Status to software then
  enable the feature.
 Enable CRS software visibility 
		 Initiate a configuration request to read the vendor id
		  field of the device function's config space header after
		  100 ms wait time from the end of Reset. If the device is
		  not done with its internal initialization, it must at
		  least return a completion TLP, with a completion status
		  of "Configuration Request Retry Status (CRS)". The root
		  complex must complete the request to the host by returning
		  a read-data value of 0001h for the Vendor ID field and
		  all 1s for any additional bytes included in the request.
		  Poll using the config reads for max wait time of 1 sec or
		  until we receive the successful completion status. Repeat
		  the procedure for all the devices.
 Reset RC 
	 64 MB IO access window. On 4716, use
	  sbtopcie0 to access the device registers. We
	  can't use address match 2 (1 GB window) region
	  as mips can't generate 64-bit address on the
	  backplane.
 64 MB configuration access window 
 1 GB memory access window 
	 As per PCI Express Base Spec 1.1 we need to wait for
	  at least 100 ms from the end of a reset (coldwarmhot)
	  before issuing configuration requests to PCI Express
	  devices.
 Max payload size of 512 
 MRRS 512 
 Enable PCI bridge BAR0 memory & master access 
 Enable PCI interrupts 
	 Ok, ready to run, register it to the system.
	  The following needs change, if we want to port hostmode
	 Give some time to the PCI controller to configure itself with the new
 Early PCI fixup for a device on the PCI-core bridge. 
 This is not a device on the PCI-core bridge. 
 Enable PCI bridge bus mastering and memory space 
 Enable PCI bridge BAR1 prefetch and burst 
 Early PCI fixup for all PCI-cores to set the correct memory address. 
 This is not a device on the PCI-core bridge. 
 This function is called when doing a pci_enable_device().
 This is not a device on the PCI-core bridge. 
 Fix up interrupt lines 
 PCI device IRQ mapping. 
 This is not a device on the PCI-core bridge. 
  Broadcom specific AMBA
  GBIT MAC COMMON Core
  Licensed under the GNUGPL. See COPYING for details.
  Broadcom specific AMBA
  PCI Core
  Copyright 2005, 2011, Broadcom Corporation
  Copyright 2006, 2007, Michael Buesch <m@bues.ch>
  Copyright 2011, 2012, Hauke Mehrtens <hauke@hauke-m.de>
  Licensed under the GNUGPL. See COPYING for details.
  RW ops.
 enable mdio access to SERDES 
 Wait for the device to complete the transaction 
 enable mdio access to SERDES 
 Wait for the device to complete the transaction 
  Early init.
  Apply some early fixes required before accessing SPROM.
  See also si_pci_fixcfg.
  Workarounds.
 Fix MISC config to allow coming out of L2L3-Ready state wo PRST 
 Needs to happen when coming out of 'standby''hibernate' 
  Init.
  Broadcom specific AMBA
  System on Chip (SoC) Host
  Licensed under the GNUGPL. See COPYING for details.
 CONFIG_BCMA_BLOCKIO 
	 iomap only first core. We have to read some register on this core
	  to scan the bus.
 Host specific 
 Initialize struct, detect chip 
 Scan bus and initialize it 
 Alloc 
 Map MMIO 
 Host specific 
 Initialize struct, detect chip 
 Register 
 CONFIG_OF 
  Broadcom specific AMBA
  Bus scanning
  Licensed under the GNUGPL. See COPYING for details.
 search manufacturer specific names 
 get CIs 
 parse CIs 
 check if component is a core at all 
 Some specific cores don't need wrappers 
 Not used yet: case BCMA_CORE_OOB_ROUTER: 
 get & parse master ports 
	 First Slave Address Descriptor should be port 0:
	  the main register space for the core
 Try again to see if it is a bridge 
 get & parse slave ports 
 no more entries for port _i_ 
				 pr_debug("erom: slave port %d "
 get & parse master wrappers 
 no more entries for port _i_ 
				 pr_debug("erom: master wrapper %d "
 get & parse slave wrappers 
 no more entries for port _i_ 
				 pr_debug("erom: master wrapper %d "
 Skip if bus was already scanned (e.g. during early register) 
  Broadcom specific AMBA
  ChipCommon core driver
  Copyright 2005, Broadcom Corporation
  Copyright 2006, 2007, Michael Buesch <m@bues.ch>
  Copyright 2012, Hauke Mehrtens <hauke@hauke-m.de>
  Licensed under the GNUGPL. See COPYING for details.
			 53573B0 and 53573B1 have bugged PMU watchdog. It can
			  be enabled but timer can't be bumped. Use CC one
			  instead.
			 4706 CC and PMU watchdogs are clocked at 14 of ALP
			  clock
 based on 32KHz ILP clock 
 Set chip watchdog reset timer to fire in 'ticks' backplane cycles 
 instant NMI 
  If the bit is set to 0, chipcommon controlls this GPIO,
  if the bit is set to 1, it is used by some part of the chip and not our code.
 Turn off UART clock before switching clocksource. 
 Set the override bit so we don't divide it 
 Re-enable the UART clock. 
 Determine the registers of the UARTs 
 CONFIG_BCMA_DRIVER_MIPS 
  Broadcom specific AMBA
  PCIe Gen 2 Core
  Copyright 2014, Broadcom Corporation
  Copyright 2014, Rafał Miłecki <zajec5@gmail.com>
  Licensed under the GNUGPL. See COPYING for details.
  RW ops.
  Init.
 restore back to default 
 flush 
 LTR0 
 LTR1 
 LTR2 
 force the right LTR values 
		 TODO:
		 si_core_wrapperreg(pcie2, 3, 0x60, 0x8080, 0);
 enable the LTR 
 set the LTR state to be active 
 set the LTR state to be sleep 
 TODO 
  Runtime ops.
  Broadcom specific AMBA
  ChipCommon NAND flash interface
  Licensed under the GNUGPL. See COPYING for details.
 Initialize NAND flash access 
	 Prepare platform device, but don't register it yet. It's too early,
  Broadcom specific AMBA
  Broadcom MIPS32 74K core driver
  Copyright 2009, Broadcom Corporation
  Copyright 2006, 2007, Michael Buesch <mb@bu3sch.de>
  Copyright 2010, Bernhard Loos <bernhardloos@googlemail.com>
  Copyright 2011, Hauke Mehrtens <hauke@hauke-m.de>
  Licensed under the GNUGPL. See COPYING for details.
 The 47162a0 hangs when reading MIPS DMP registers registers 
 The 5357b0 hangs when reading USB20H DMP registers 
 Get the MIPS IRQ assignment for a specified device.
  If unassigned, 0 is returned.
  If disabled, 5 is returned.
  If not supported, 6 is returned.
 clear the old irq 
 assign the new one 
			 backplane irq line is in use, find out who uses
			  it and set user to irq 0
 Determine flash type this SoC boots from 
	 Fixup the interrupts in 47164748 for i2s core (2010 Broadcom SDK)
	  (IRQ flags > 7 are ignored when setting the interrupt masks)
  Broadcom specific AMBA
  GPIO driver
  Copyright 2011, Broadcom Corporation
  Copyright 2012, Hauke Mehrtens <hauke@hauke-m.de>
  Licensed under the GNUGPL. See COPYING for details.
 clear pulldown 
 Set pullup 
 clear pullup 
 This will let us handle the parent IRQ in the driver 
	
	  Register SoC GPIO devices with absolute GPIO pin base.
	  On MIPS, we don't have Device Tree and we can't use relative (per chip)
	  GPIO numbers.
	  On some ARM devices, user space may want to access some system GPIO
	  pins directly, which is easier to do with a predictable GPIO base.
  Broadcom specific AMBA
  SPROM reading
  Copyright 2011, 2012, Hauke Mehrtens <hauke@hauke-m.de>
  Licensed under the GNUGPL. See COPYING for details.
  bcma_arch_register_fallback_sprom - Registers a method providing a
  fallback SPROM if no SPROM is found.
  @sprom_callback: The callback function.
  With this function the architecture implementation may register a
  callback handler which fills the SPROM data structure. The fallback is
  used for PCI based BCMA devices, where no valid SPROM can be found
  in the shadow registers and to provide the SPROM for SoCs where BCMA is
  to controll the system bus.
  This function is useful for weird architectures that have a half-assed
  BCMA device hardwired to their PCI bus.
  This function is available for architecture code, only. So it is not
  exported.
  RW ops.
  Validation.
 Polynomial:   x^8 + x^7 + x^6 + x^4 + x^2 + 1   
  SPROM extraction.
 If unset use 2dBm 
 Q5.2 Fractional part is stored in 0xC0 
 Extract cores power info info 
 Extract the antenna gain values. 
  Indicates the presence of external SPROM.
 older chipcommon revisions use chip status register 
  Indicates that on-chip OTP memory is present and enabled.
 for these chips OTP is always available 
  Verify OTP is filled and determine the byte
  offset where SPROM data is located.
  On error, returns 0; byte offset otherwise.
 verify OTP status 
 obtain bit offset from otplayout register 
		
		  External SPROM takes precedence so check
		  on-chip OTP only when no external SPROM
		  is present.
 determine offset 
			
			  Maybe there is no SPROM on the device?
			  Now we ask the arch code if there is some sprom
			  available for this device in some other storage.
  Broadcom specific AMBA
  ChipCommon serial flash interface
  Licensed under the GNUGPL. See COPYING for details.
 Initialize serial flash access 
	 Prepare platform device, but don't register it yet. It's too early,
  Broadcom specific AMBA
  Core ops
  Licensed under the GNUGPL. See COPYING for details.
		
		  Mask the PLL but don't wait for it to be disabled. PLL may be
		  shared between cores and will be still up if there is another
		  core using it.
  Broadcom specific AMBA
  ChipCommon Power Management Unit driver
  Copyright 2009, Michael Buesch <m@bues.ch>
  Copyright 2007, 2011, Broadcom Corporation
  Copyright 2011, 2012, Hauke Mehrtens <hauke@hauke-m.de>
  Licensed under the GNUGPL. See COPYING for details.
 pmu2_xtaltab0_adfll_485 
 Turn off PLL 
 Flush 
 TODO: Do we need to update OTP? 
 Set the resource masks. 
	
	  Add some delay; allow resources to come up and settle.
	  Delay is required for SoC (early init).
 Disable to allow reading SPROM. Don't know the adventages of enabling it. 
		
		  enable 12 mA drive strenth for 4313 and set chipControl
		  register bit 1
 Ext PA lines must be enabled for tx on BCM4331 
		
		  enable 12 mA drive strenth for 43224 and set chipControl
		  register bit 15
 always 20Mhz 
 always 25Mhz 
 Find the output of the "m" pll divider given pll controls that start with
  pllreg "pll0" i.e. 12 for main 6 for phy, 0 for misc.
 Detect failure in clock setting 
 Do calculation in Mhz 
 Return clock in Hertz 
 Get N, P1 and P2 dividers to determine CPU clock 
 Low cost bonding: Fixed reference clock 25MHz and m = 4 
 Fixed reference clock 25MHz and m = 2 
 query bus clock frequency for PMU-enabled chipcommon 
 query cpu clock frequency for PMU-enabled chipcommon 
 New PMUs can have different clock for bus and CPU 
 On old PMUs CPU has the same clock as the bus 
 5357[ab]0, 43236[ab]0, and 6362b0 
		
		  BCM5357 needs to touch PLL1_PLLCTL[02],
		  so offset PLL0_PLLCTL[02] by 6
 RMW only the P1 divider 
 RMW only the int feedback divider 
 LCNXN 
		
		  PLL Settings for spur avoidance onoff mode,
		  no on2 support for 43228A0
  Broadcom specific AMBA
  ChipCommon parallel flash
  Licensed under the GNUGPL. See COPYING for details.
  Broadcom specific AMBA
  PCI Host
  Licensed under the GNUGPL. See COPYING for details.
 Provides access to the requested core. Returns base offset that has to be
 Alloc 
 Basic PCI configuration 
	 Disable the RETRY_TIMEOUT register (0x41) to keep
 SSB needed additional powering up, do we have any AMBA PCI cards? 
 Map MMIO 
 Host specific 
 Initialize struct, detect chip 
 Scan bus to find out generation of PCIe core 
 Register 
 CONFIG_PM_SLEEP 
 CONFIG_PM_SLEEP 
 0xa8d8 
 0xa8db, BCM43217 (sic!) 
 0xa8dc 
  Runtime ops for drivers.
 See also pcicore_up 
 See also pcicore_down 
 See also si_pci_setup 
		 This bcma device is not on a PCI host-bus. So the IRQs are
		  not routed through the PCI core.
  Broadcom specific AMBA
  ChipCommon B Unit driver
  Copyright 2014, Hauke Mehrtens <hauke@hauke-m.de>
  Licensed under the GNUGPL. See COPYING for details.
  Broadcom specific AMBA
  Bus subsystem
  Licensed under the GNUGPL. See COPYING for details.
 contains the number the next bus should get. 
 bcma_buses_mutex locks the bcma_bus_next_num 
 We support that cores ourself 
 Early cores were already registered 
 Only first GMAC core on BCM4706 is connected and working 
 Now noone uses internally-handled cores, we can free them 
 Scan for devices (cores) 
 Early init CC core 
 Early init PCIE core 
 Cores providing flash access go before SPROM init 
 Try to get SPROM 
 Init CC core 
 Init CC core 
 Init MIPS core 
 Init PCIE core 
 Init PCIE core 
 Init PCIe Gen 2 core 
 Init GBIT MAC COMMON core 
 Register found cores 
  This is a special version of bus registration function designed for SoCs.
  It scans bus and performs basic initialization of main cores only.
  Please note it requires memory allocation, however it won't try to sleep.
 Scan for devices (cores) 
 Early init CC core 
 Early init MIPS core 
 Init CC core 
  If built-in, bus has to be registered early, before any driver calls
  bcma_driver_register.
  Otherwise registering driver would trigger BUG in driver_register.
 Main initialization has to be done with SPImtdNANDSPROM available 
 SPDX-License-Identifier: GPL-2.0
 uio_pci_generic - generic UIO driver for PCI 2.3 devices
  Copyright (C) 2009 Red Hat, Inc.
  Author: Michael S. Tsirkin <mst@redhat.com>
  Since the driver does not declare any device ids, you must allocate
  id and bind the device to the driver yourself.  For example:
  # echo "8086 10f5" > sysbuspcidriversuio_pci_genericnew_id
  # echo -n 0000:00:19.0 > sysbuspcidriverse1000eunbind
  # echo -n 0000:00:19.0 > sysbuspcidriversuio_pci_genericbind
  # ls -l sysbuspcidevices0000:00:19.0driver
  ...0000:00:19.0driver -> ......buspcidriversuio_pci_generic
  Driver won't bind to devices which do not support the Interrupt Disable Bit
  in the command register. All devices compliant to PCI 2.3 (circa 2002) and
  all compliant PCI Express devices should support this bit.
	
	  This driver is insecure when used with devices doing DMA, but some
	  people (mis)use it with such devices.
	  Let's at least make sure DMA isn't left enabled after the userspace
	  driver closes the fd.
	  Note that there's a non-zero chance doing this will wedge the device
	  at least until reset.
 Interrupt handler. Readmodifywrite the command register to disable
 UIO core will signal the user process. 
 only dynamic id's 
 SPDX-License-Identifier: GPL-2.0
 uio_fsl_elbc_gpcm: UIO driver for eLBCGPCM peripherals
   Copyright (C) 2014 Linutronix GmbH
     Author: John Ogness <john.ogness@linutronix.de>
   This driver provides UIO access to memory of a peripheral connected
   to the Freescale enhanced local bus controller (eLBC) interface
   using the general purpose chip-select mode (GPCM).
   Here is an example of the device tree entries:
	localbus@ffe05000 {
		ranges = <0x2 0x0 0x0 0xff810000 0x10000>;
		dpm@2,0 {
			compatible = "fsl,elbc-gpcm-uio";
			reg = <0x2 0x0 0x10000>;
			elbc-gpcm-br = <0xff810800>;
			elbc-gpcm-or = <0xffff09f7>;
			interrupt-parent = <&mpic>;
			interrupts = <4 1>;
			device_type = "netx5152";
			uio_name = "netx_custom";
			netx5152,init-win0-offset = <0x0>;
		};
	};
   Only the entries reg (to identify bank) and elbc-gpcm- (initial BROR
   values) are required. The entries interrupt, device_type, and uio_name
   are optional (as well as any type-specific options such as
   netx5152,init-win0-offset). As long as no interrupt handler is needed,
   this driver can be used without any type-specific implementation.
   The netx5152 type has been tested to work with the netX 5152 hardware
   from Hilscher using the Hilscher userspace netX stack.
   The netx5152 type should serve as a model to add new type-specific
   devices as needed.
 parse use input 
 read current values 
 not allowed to change effective base address 
 not allowed to change mode 
 write new value (force valid) 
 not allowed to change access mask 
 write new value 
 check if an interrupt is enabled and active 
 disable interrupts 
 get an optional initial win0 offset 
 disable interrupts 
 disable interrupts 
 check specified bank 
 check specified mode (BR_MS_GPCM is 0) 
 check specified mask vs. resource size 
 check specified address 
 get the memory resource 
 get the bank number 
 get BR value to set 
 get OR value to set 
 get optional peripheral type 
 get optional irq value 
 sanity check device tree data 
 get optional uio name 
 allocate private data 
 get device tree data 
 allocate UIO structure 
 get current BROR values 
 if bank already configured, make sure it matches 
 warn if behavior settings changing 
 configure the bank (force base address and GPCM) 
 map the memory resource 
 set all UIO data 
 register UIO device 
 store private data 
 SPDX-License-Identifier: GPL-2.0
  driversuiouio.c
  Copyright(C) 2005, Benedikt Spranger <b.spranger@linutronix.de>
  Copyright(C) 2005, Thomas Gleixner <tglx@linutronix.de>
  Copyright(C) 2006, Hans J. Koch <hjk@hansjkoch.de>
  Copyright(C) 2006, Greg Kroah-Hartman <greg@kroah.com>
  Userspace IO
  Base Functions
 Protect idr accesses 
  attributes
 need to NULL terminate the list of attributes 
 UIO class infrastructure 
  device functions
  uio_event_notify - trigger an interrupt event
  @info: UIO device capabilities
  uio_interrupt - hardware interrupt handler
  @irq: IRQ number, can be UIO_IRQ_CYCLIC for cyclic timer
  @dev_id: Pointer to the devices uio_device structure
	
	  We need to subtract mi because userspace uses offset = NPAGE_SIZE
	  to use mem[N].
	
	  We cannot use the vm_iomap_memory() helper here,
	  because vma->vm_pgoff is the map index we looked
	  up above in uio_find_mem_index(), rather than an
	  actual page offset into the mmap.
	 
	  So we just do the physical mmap without a page
	  offset.
 This is the first time in here, set everything up properly 
  __uio_register_device - register a new userspace IO device
  @owner:	module that creates the new device
  @parent:	parent device
  @info:	UIO device capabilities
  returns zero on success or a negative error code.
		
		  Note that we deliberately don't use devm_request_irq
		  here. The parent module can unregister the UIO device
		  and call pci_disable_msi, which requires that this
		  irq has been freed. However, the device may have open
		  FDs at the time of unregister and therefore may not be
		  freed until they are released.
  __devm_uio_register_device - Resource managed uio_register_device()
  @owner:	module that creates the new device
  @parent:	parent device
  @info:	UIO device capabilities
  returns zero on success or a negative error code.
  uio_unregister_device - unregister a industrial IO device
  @info:	UIO device capabilities
 SPDX-License-Identifier: GPL-2.0
  UIO Hilscher CIF card driver
  (C) 2007 Hans J. Koch <hjk@hansjkoch.de>
  Original code (C) 2005 Benedikt Spranger <b.spranger@linutronix.de>
 Disable interrupt 
 SPDX-License-Identifier: GPL-2.0-or-later
  UIO driver fo Humusoft MF624 DAQ card.
  Copyright (C) 2011 Rostislav Lisovy <lisovy@gmail.com>,
                     Czech Technical University in Prague
 BAR0 Interrupt controlstatus register 
 Note: Datasheet says device uses BAR0, BAR1, BAR2 -- do not trust it 
 BAR0 
 BAR2 
 BAR4 
 SPDX-License-Identifier: GPL-2.0-only
  driversuiouio_dmem_genirq.c
  Userspace IO platform driver with generic IRQ handling code.
  Copyright (C) 2012 Damian Hobson-Garcia
  Based on uio_pdrv_genirq.c by Magnus Damm
 Wait until the Runtime PM code has woken up the device 
 Tell the Runtime PM code that the device has become idle 
	 Just disable the interrupt in the interrupt controller, and
	  remember the state so we can allow user space to enable it later.
	 Allow user space to enable and disable the interrupt
	  in the interrupt controller, but keep track of the
	  state to prevent per-irq depth damage.
	 
	  Serialize this operation to support multiple tasks.
 alloc uioinfo for one device 
 interrupt is enabled to begin with 
 Multiple IRQs are not supported 
		
		  If a level interrupt, dont do lazy disable. Otherwise the
		  irq will fire again since clearing of the actual cause, on
		  device level, is done in userspace
		  irqd_is_level_type() isn't used since isn't valid until
		  irq is configured.
	 This driver requires no hardware specific kernel code to handle
	  interrupts. Instead, the interrupt handler simply disables the
	  interrupt in the interrupt controller. User space is responsible
	  for performing hardware specific acknowledge and re-enabling of
	  the interrupt in the interrupt controller.
	 
	  Interrupt sharing is not supported.
	 Enable Runtime PM for this device:
	  The device starts in suspended state to allow the hardware to be
	  turned off by default. The Runtime PM bus code should power on the
	  hardware and enable clocks at open().
	 Runtime PM callback shared between ->runtime_suspend()
	  and ->runtime_resume(). Simply returns success.
	 
	  In this driver pm_runtime_get_sync() and pm_runtime_put_sync()
	  are used at open() and release() time. This allows the
	  Runtime PM code to turn off power to the device while the
	  device is unused, ie before open() and after release().
	 
	  This Runtime PM callback does not need to save or restore
	  any registers since user space is responsbile for hardware
	  register reinitialization after open().
 empty for now  },
 SPDX-License-Identifier: GPL-2.0-only
  driversuiouio_pdrv_genirq.c
  Userspace IO platform driver with generic IRQ handling code.
  Copyright (C) 2008 Magnus Damm
  Based on uio_pdrv.c by Uwe Kleine-Koenig,
  Copyright (C) 2008 by Digi International Inc.
  All rights reserved.
 Bits in uio_pdrv_genirq_platdata.flags 
 Wait until the Runtime PM code has woken up the device 
 Tell the Runtime PM code that the device has become idle 
	 Just disable the interrupt in the interrupt controller, and
	  remember the state so we can allow user space to enable it later.
	 Allow user space to enable and disable the interrupt
	  in the interrupt controller, but keep track of the
	  state to prevent per-irq depth damage.
	 
	  Serialize this operation to support multiple tasks and concurrency
	  with irq handler on SMP systems.
 alloc uioinfo for one device 
 Multiple IRQs are not supported 
 interrupt is enabled to begin with 
		
		  If a level interrupt, dont do lazy disable. Otherwise the
		  irq will fire again since clearing of the actual cause, on
		  device level, is done in userspace
		  irqd_is_level_type() isn't used since isn't valid until
		  irq is configured.
	 This driver requires no hardware specific kernel code to handle
	  interrupts. Instead, the interrupt handler simply disables the
	  interrupt in the interrupt controller. User space is responsible
	  for performing hardware specific acknowledge and re-enabling of
	  the interrupt in the interrupt controller.
	 
	  Interrupt sharing is not supported.
	 Enable Runtime PM for this device:
	  The device starts in suspended state to allow the hardware to be
	  turned off by default. The Runtime PM bus code should power on the
	  hardware and enable clocks at open().
	 Runtime PM callback shared between ->runtime_suspend()
	  and ->runtime_resume(). Simply returns success.
	 
	  In this driver pm_runtime_get_sync() and pm_runtime_put_sync()
	  are used at open() and release() time. This allows the
	  Runtime PM code to turn off power to the device while the
	  device is unused, ie before open() and after release().
	 
	  This Runtime PM callback does not need to save or restore
	  any registers since user space is responsbile for hardware
	  register reinitialization after open().
 This is filled with module_parm  },
 Sentinel  },
 SPDX-License-Identifier: GPL-2.0
 sercos3: UIO driver for the Automata Sercos III PCI card
   Copyright (C) 2008 Linutronix GmbH
     Author: John Ogness <john.ogness@linutronix.de>
   This is a straight-forward UIO driver, where interrupts are disabled
   by the interrupt handler and re-enabled via a write to the UIO device
   by the userspace-part.
   The only part that may seem odd is the use of a logical OR when
   storing and restoring enabled interrupts. This is done because the
   userspace-part could directly modify the Interrupt Enable Register
   at any time. To reduce possible conflicts, the kernel driver uses
   a logical OR to make more controlled changes (rather than blindly
   overwriting previous values).
   Race conditions exist if the userspace-part directly modifies the
   Interrupt Enable Register while in operation. The consequences are
   that certain interrupts would fail to be enabled or disabled. For
   this reason, the userspace-part should only directly modify the
   Interrupt Enable Register at the beginning (to get things going).
   The userspace-part can safely disable interrupts at any time using
   a write to the UIO device.
 ID's for SERCOS III PCI card (PLX 9030) 
 Interrupt Enable Register 
 Interrupt Status Register 
 this function assumes ier0_cache_lock is locked! 
 add enabled interrupts to cache 
 disable interrupts 
 this function assumes ier0_cache_lock is locked! 
 restore previously enabled interrupts 
 we only need PCI BAR's 0, 2, 3, 4, 5 
 SPDX-License-Identifier: GPL-2.0
  uio_hv_generic - generic UIO driver for VMBus
  Copyright (c) 2013-2016 Brocade Communications Systems, Inc.
  Copyright (c) 2016, Microsoft Corporation.
  Since the driver does not declare any device ids, you must allocate
  id and bind the device to the driver yourself.  For example:
  Associate Network GUID with UIO device
  # echo "f8615163-df3e-46c5-913f-f2d2f965ed0e" \
     > sysbusvmbusdriversuio_hv_genericnew_id
  Then rebind
  # echo -n "ed963694-e847-4b2a-85af-bc9cfc11d6f3" \
     > sysbusvmbusdrivershv_netvscunbind
  # echo -n "ed963694-e847-4b2a-85af-bc9cfc11d6f3" \
     > sysbusvmbusdriversuio_hv_genericbind
 pages 
  List of resources to be mapped to user space
  can be extended up to MAX_UIO_MAPS(5) items
 "recv_4294967295" 
  This is the irqcontrol callback to be registered to uio_info.
  It can be used to disableenable interrupt from user space processes.
  @param info
   pointer to uio_info.
  @param irq_state
   state value. 1 to enable interrupt, 0 to disable interrupt.
  Callback from vmbus_event when something is in inbound ring.
  Callback from vmbus_event when channel is rescinded.
	
	  Turn off the interrupt file handle
	  Next read for event will return -EIO
 Wake up reader 
 Sysfs API to allow mmap of the ring buffers
  The ring buffer is allocated as contiguous memory by vmbus_open
 Callback from VMBUS subsystem when new channel created. 
 Create host communication ring 
 Disable interrupts on sub channel 
 free the reserved buffers for send and receive 
 VMBus primary channel is opened on first use 
 VMBus primary channel is closed on last close 
 Communicating with host has to be via shared memory not hypercall 
 Fill general uio info 
 mem resources 
 put Global Physical Address Label in name 
 only dynamic id's 
 SPDX-License-Identifier: GPL-2.0
  Generic DFL driver for Userspace IO devicess
  Copyright (C) 2021 Intel Corporation, Inc.
 Irq is yet to be supported 
  Programmable Real-Time Unit Sub System (PRUSS) UIO driver (uio_pruss)
  This driver exports PRUSS host event out interrupts and PRUSS, L3 RAM,
  and DDR RAM to user space for applications interacting with PRUSS firmware
  Copyright (C) 2010-11 Texas Instruments Incorporated - http:www.ti.com
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  Host event IRQ numbers from PRUSS - PRUSS can generate up to 8 interrupt
  events to AINTC of ARM host processor - which can be used for IPC bw PRUSS
  firmware and user space application, async notification from PRU firmware
  to user space application
  3	PRU_EVTOUT0
  4	PRU_EVTOUT1
  5	PRU_EVTOUT2
  6	PRU_EVTOUT3
  7	PRU_EVTOUT4
  8	PRU_EVTOUT5
  9	PRU_EVTOUT6
  10	PRU_EVTOUT7
 Is interrupt enabled and active ? 
 Disable interrupt 
 Power on PRU in case its not done as part of boot-loader 
 Register PRUSS IRQ lines 
 SPDX-License-Identifier: GPL-2.0-only
  uio_aec.c -- simple driver for Adrienne Electronics Corp time code PCI device
  Copyright (C) 2008 Brandon Philips <brandon@ifup.org>
 application writes 0x00 to 0x2F to get next interrupt 
 disable interrupts 
 read mailbox to ensure board drops irq 
 SPDX-License-Identifier: GPL-2.0
  UIO driver for Hilscher NetX based fieldbus cards (cifX, comX).
  See http:www.hilscher.com for details.
  (C) 2007 Hans J. Koch <hjk@hansjkoch.de>
  (C) 2008 Manuel Traut <manut@linutronix.de>
 Is one of our interrupts enabled and active ? 
 Disable interrupt 
 BAR0 or 2 points to the card's dual port memory 
 Make sure all interrupts are disabled 
 Disable all interrupts 
     Zorro Bus Services
     Copyright (C) 1995-2003 Geert Uytterhoeven
     This file is subject to the terms and conditions of the GNU General Public
     License.  See the file COPYING in the main directory of this archive
     for more details.
       Zorro Expansion Devices
       Zorro bus
       Find Zorro Devices
       Bitmask indicating portions of available Zorro II RAM that are unused
       by the system. Every bit represents a 64K chunk, for a maximum of 8MB
       (128 chunks, physical 0x00200000-0x009fffff).
       If you want to use (= allocate) portions of this RAM, you should clear
       the corresponding bits.
       Possible uses:
           - z2ram device
           - SCSI DMA bounce buffers
       FIXME: use the normal resource management
 Initialize the Zorro bus 
 First identify all devices ... 
 GVP quirk 
 ... then register them 
 Mark all available Zorro II memory 
 Unmark all used Zorro II memory 
   File Attributes for Zorro Devices
   Copyright (C) 2003 Geert Uytterhoeven
   Loosely based on driverspcipci-sysfs.c
   This file is subject to the terms and conditions of the GNU General Public
   License.  See the file COPYING in the main directory of this archive
   for more details.
 show configuration fields 
 Construct a ConfigDev 
 SPDX-License-Identifier: GPL-2.0
 	Zorro Device Name Tables
 	Copyright (C) 1999--2000 Geert Uytterhoeven
 	Based on the PCI version:
 	Copyright 1992--1999 Drew Eckhardt, Frederic Potter,
 	David Mosberger-Tang, Martin Mares
  This is ridiculous, but we want the strings in
  the .init section so that they don't take up
  real memory.. Parse the same file multiple times
  to get all the info.
 Couldn't find either the manufacturer nor the product 
 Ok, found the manufacturer, but unknown product 
 Full match 
 SPDX-License-Identifier: GPL-2.0
 	Generate devlist.h from the Zorro ID file.
 	(c) 2000 Geert Uytterhoeven <geert@linux-m68k.org>
 	Based on the PCI version:
 	(c) 1999--2000 Martin Mares <mj@ucw.cz>
 Too long, try cutting off long description 
   Zorro Driver Services
   Copyright (C) 2003 Geert Uytterhoeven
   Loosely based on driverspcipci-driver.c
   This file is subject to the terms and conditions of the GNU General Public
   License.  See the file COPYING in the main directory of this archive
   for more details.
       zorro_match_device - Tell if a Zorro device structure has a matching
                            Zorro device id structure
       @ids: array of Zorro device id structures to search in
       @dev: the Zorro device structure to match against
       Used by a driver to check whether a Zorro device present in the
       system is in its list of supported devices. Returns the matching
       zorro_device_id structure or %NULL if there is no match.
       zorro_register_driver - register a new Zorro driver
       @drv: the driver structure to register
       Adds the driver structure to the list of registered drivers
       Returns zero or a negative error value.
 initialize common driver fields 
 register with core 
       zorro_unregister_driver - unregister a zorro driver
       @drv: the driver structure to unregister
       Deletes the driver structure from the list of registered Zorro drivers,
       gives it a chance to clean up by calling its remove() function for
       each device it was responsible for, and marks those devices as
       driverless.
       zorro_bus_match - Tell if a Zorro device structure has a matching Zorro
                         device id structure
       @ids: array of Zorro device id structures to search in
       @dev: the Zorro device structure to match against
       Used by the driver core to check whether a Zorro device present in the
       system is in a driver's list of supported devices.  Returns 1 if
       supported, and 0 if there is no match.
 SPDX-License-Identifier: GPL-2.0
 	Procfs interface for the Zorro bus.
 	Copyright (C) 1998-2003 Geert Uytterhoeven
 	Heavily based on the procfs interface for the PCI bus, which is
 	Copyright (C) 1997, 1998 Martin Mares <mj@atrey.karlin.mff.cuni.cz>
 Construct a ConfigDev 
 SPDX-License-Identifier: GPL-2.0-only
  MEN Chameleon Bus.
  Copyright (C) 2014 MEN Mikroelektronik GmbH (www.men.de)
  Author: Andreas Werner <andreas.werner@men.de>
 SPDX-License-Identifier: GPL-2.0-only
	
	  If the BAR is missing, dev_mapbase is zero, or if the
	  device is IO mapped we just print a warning and go on with the
	  next device, instead of completely stop the gdd parser
 skip reg1 
	
	  For those devices which are not connected
	  to the PCI Bus (e.g. LPC) there is a bar
	  descriptor located directly after the
	  chameleon header. This header is comparable
	  to a PCI header.
 Extract header information 
 We only support chameleon v2 at the moment 
 SPDX-License-Identifier: GPL-2.0-only
  MEN Chameleon Bus.
  Copyright (C) 2013 MEN Mikroelektronik GmbH (www.men.de)
  Author: Johannes Thumshirn <johannes.thumshirn@men.de>
  __mcb_register_driver() - Register a @mcb_driver at the system
  @drv: The @mcb_driver
  @owner: The @mcb_driver's module
  @mod_name: The name of the @mcb_driver's module
  Register a @mcb_driver at the system. Perform some sanity checks, if
  the .probe and .remove methods are provided by the driver.
  mcb_unregister_driver() - Unregister a @mcb_driver from the system
  @drv: The @mcb_driver
  Unregister a @mcb_driver from the system.
  mcb_device_register() - Register a mcb_device
  @bus: The @mcb_bus of the device
  @dev: The @mcb_device
  Register a specific @mcb_device at a @mcb_bus and the system itself.
  mcb_alloc_bus() - Allocate a new @mcb_bus
  Allocate a new @mcb_bus.
  mcb_release_bus() - Free a @mcb_bus
  @bus: The @mcb_bus to release
  Release an allocated @mcb_bus from the system.
  mcb_bus_put() - Increment refcnt
  @bus: The @mcb_bus
  Get a @mcb_bus' ref
  mcb_bus_put() - Decrement refcnt
  @bus: The @mcb_bus
  Release a @mcb_bus' ref
  mcb_alloc_dev() - Allocate a device
  @bus: The @mcb_bus the device is part of
  Allocate a @mcb_device and add bus.
  mcb_free_dev() - Free @mcb_device
  @dev: The device to free
  Free a @mcb_device
  mcb_bus_add_devices() - Add devices in the bus' internal device list
  @bus: The @mcb_bus we add the devices
  Add devices in the bus' internal device list to the system.
  mcb_get_resource() - get a resource for a mcb device
  @dev: the mcb device
  @type: the type of resource
  mcb_request_mem() - Request memory
  @dev: The @mcb_device the memory is for
  @name: The name for the memory reference.
  Request memory for a @mcb_device. If @name is NULL the driver name will
  be used.
  mcb_release_mem() - Release memory requested by device
  @dev: The @mcb_device that requested the memory
  Release memory that was prior requested via @mcb_request_mem().
  mcb_get_irq() - Get device's IRQ number
  @dev: The @mcb_device the IRQ is for
  Get the IRQ number of a given @mcb_device.
 mcb must be initialized after PCI but before the chameleon drivers.
  That means we must use some initcall between subsys_initcall and
  device_initcall.
 SPDX-License-Identifier: GPL-2.0-only
  MEN Chameleon Bus.
  Copyright (C) 2014 MEN Mikroelektronik GmbH (www.men.de)
  Author: Johannes Thumshirn <johannes.thumshirn@men.de>
 SPDX-License-Identifier: GPL-2.0-only
  Perf support for the Statistical Profiling Extension, introduced as
  part of ARMv8.2.
  Copyright (C) 2016 ARM Limited
  Author: Will Deacon <will.deacon@arm.com>
 PPI 
 Convert a free-running index from perf into an SPE buffer offset 
 Keep track of our dynamic hotplug state 
 This sysfs gunk was really good fun to write. 
 User ABI 
 PMSCR_EL1.TS 
 PMSCR_EL1.PA 
 PMSCR_EL1.PCT 
 PMSIRR_EL1.RND 
 PMSFCR_EL1.B 
 PMSFCR_EL1.LD 
 PMSFCR_EL1.ST 
 PMSEVFR_EL1 
 PMSLATFR_EL1.MINLAT 
 Why does everything I do descend into this? 
 Convert between user ABI and register values 
	
	  The trace format isn't parseable in reverse, so clamp
	  the limit to half of the buffer size in snapshot mode
	  so that the worst case is half a buffer of records, as
	  opposed to a single record.
	
	  If we're within max_record_sz of the limit, we must
	  pad, move the head index and recompute the limit.
	
	  The head can be misaligned for two reasons:
	 
	  1. The hardware left PMBPTR pointing to the first byte after
	     a record when generating a buffer management event.
	 
	  2. We used perf_aux_output_skip to consume handle->size bytes
	     and CIRC_SPACE was used to compute the size, which always
	     leaves one entry free.
	 
	  Deal with this by padding to the next alignment boundary and
	  moving the head index. If we run out of buffer space, we'll
	  reduce handle->size to zero and end up reporting truncation.
 If we've run out of free space, then nothing more to do 
 Compute the tail and wakeup indices now that we've aligned head 
	
	  Avoid clobbering unconsumed data. We know we have space, so
	  if we see head == tail we know that the buffer is empty. If
	  head > tail, then there's nothing to clobber prior to
	  wrapping.
	
	  Wakeup may be arbitrarily far into the future. If it's not in
	  the current generation, either we'll wrap before hitting it,
	  or it's in the past and has been handled already.
	 
	  If there's a wakeup before we wrap, arrange to be woken up by
	  the page boundary following it. Keep the tail boundary if
	  that's lower.
	
	  If the head has come too close to the end of the buffer,
	  then pad to the end and recompute the limit.
 Start a new aux session 
		
		  We still need to clear the limit pointer, since the
		  profiler might only be disabled by virtue of a fault.
 Disable profiling at EL0 and EL1 
 Drain any buffered data 
 Disable the profiling buffer 
 IRQ handling 
	
	  Ensure new profiling data is visible to the CPU and any external
	  aborts have been resolved.
 Ensure hardware updates to PMBPTR_EL1 are visible 
 Service required? 
	
	  If we've lost data, disable profiling and also set the PARTIAL
	  flag to indicate that the last record is corrupted.
 Report collisions to userspace so that it can up the period 
 We only expect buffer management events 
 Handled below 
 Buffer management event 
	
	  Ensure perf callbacks have completed, which may disable the
	  profiling buffer in response to a TRUNCATION flag.
		
		  If a fatal exception occurred then leaving the profiling
		  buffer enabled is a recipe waiting to happen. Since
		  fatal faults don't always imply truncation, make sure
		  that the profiling buffer is disabled explicitly before
		  clearing the syndrome register.
		
		  We handled the fault (the buffer was full), so resume
		  profiling as long as we didn't detect truncation.
		  PMBPTR might be misaligned, but we'll burn that bridge
		  when we get to it.
 We've seen you before, but GCC has the memory of a sieve. 
 The buffer pointers are now sane, so resume profiling. 
 Return the highest version we support in default 
 Perf callbacks 
 This is, of course, deeply driver-specific 
	
	  Feedback-directed frequency throttling doesn't work when we
	  have a buffer of samples. We'd need to manually count the
	  samples in the buffer when it fills up and adjust the event
	  count to reflect that. Instead, just force the user to specify
	  a sample period.
 If we're already stopped, then nothing to do 
 Stop all trace generation 
		
		  If there's a fault pending then ensure we contain it
		  to this buffer, since we might be on the context-switch
		  path.
		
		  This may also contain ECOUNT, but nobody else should
		  be looking at period_left, since we forbid frequency
		  based sampling.
 We need at least two pages for this to work. 
	
	  We require an even number of pages for snapshot mode, so that
	  we can effectively treat the buffer as consisting of two equal
	  parts and give userspace a fighting chance of getting some
	  useful data out of it.
 Initialisation and teardown functions 
		
		  We hitch a ride on the software context here, so that
		  we can support per-task profiling (which is not possible
		  with the invalid context as it doesn't get sched callbacks).
		  This requires that userspace either uses a dummy event for
		  perf_event_open, since the aux buffer is not setup until
		  a subsequent mmap, or creates the profiling event in a
		  disabled state and explicitly PERF_EVENT_IOC_ENABLEs it
		  once the buffer has been created.
 Read PMBIDR first to determine whether or not we have access 
 Minimum alignment. If it's out-of-range, then fail the probe 
 It's now safe to read PMSIDR and figure out what we've got 
 This field has a spaced out encoding, so just use a look-up 
 Maximum record size. If it's out-of-range, then fail the probe 
	
	  This is probably overkill, as we have no idea where we're
	  draining any buffered data to...
 Reset the buffer base pointer 
 Clear any pending management interrupts 
 Make sure we probe the hardware on a relevant CPU 
 Request our PPIs (note that the IRQ is still disabled) 
	
	  Register our hotplug notifier now so we don't miss any events.
	  This will enable the IRQ for any supported CPUs that are already
	  up.
 Driver and device probing 
 Sentinel  },
	
	  If kernelspace is unmapped when running at EL0, then the SPE
	  buffer will fault and prematurely terminate the AUX session.
 SPDX-License-Identifier: GPL-2.0-only
  ARM performance counter support.
  Copyright (C) 2009 picoChip Designs, Ltd., Jamie Iles
  Copyright (C) 2010 ARM Ltd., Will Deacon <will.deacon@arm.com>
  This code is based on the sparc64 perf event code, which is in turn based
  on the x86 code.
	
	  Limit the maximum period to prevent the counter value
	  from overtaking the one we are about to program. In
	  effect we are reducing max_period to account for
	  interrupt latency (and we are being very conservative).
	
	  ARM pmu always has to update the counter, so ignore
	  PERF_EF_UPDATE, see comments in armpmu_start().
	
	  ARM pmu always has to reprogram the period, so ignore
	  PERF_EF_RELOAD, see the comment below.
	
	  Set the period again. Some counters can't be stopped, so when we
	  were stopped we simply disabled the IRQ source and the counter
	  may have been left counting. If we don't do this step then we may
	  get an interrupt too soon or way too late if the overflow has
	  happened since disabling.
 Clear the allocated counter 
 An event following a process won't be stopped earlier 
 If we don't have a space for the counter then finish early. 
	
	  If there is an event in the counter we are going to use then make
	  sure it is disabled.
 Propagate our changes to the userspace mapping. 
	
	  Reject groups spanning multiple HW PMUs (e.g. CPU + CCI). The
	  core perf code won't check that the pmu->ctx == leader->ctx
	  until after pmu->event_init(event).
	
	  Initialise the fake PMU. We only need to populate the
	  used_mask for the purposes of validation.
	
	  we request the IRQ with a (possibly percpu) struct arm_pmu, but
	  the handlers expect a struct arm_pmu. The percpu_irq framework will
	  do any necessary shifting, we just need to perform the first
	  dereference.
	
	  We don't assign an index until we actually place the event onto
	  hardware. Use -1 to signify that we haven't decided where to put it
	  yet. For SMP systems, each core has it's own PMU so we can't do any
	  clever allocation or constraints checking at this point.
	
	  Check whether we need to exclude the counter from certain modes.
	
	  Store the event encoding into the config_base field.
		
		  For non-sampling runs, limit the sample_period to half
		  of the counter width. That way, the new counter value
		  is far less likely to overtake the previous one unless
		  you have some serious IRQ latency issues.
	
	  Reject CPU-affine events for CPUs that are of a different class to
	  that which this PMU handles. Process-following events (where
	  event->cpu == -1) can be migrated between CPUs, and thus we have to
	  reject them later (in armpmu_add) if they're scheduled on a
	  different class of CPU.
 does not support taken branch sampling 
 For task-bound events we may be called on other CPUs 
 For task-bound events we may be called on other CPUs 
  In heterogeneous systems, events are specific to a particular
  microarchitecture, and aren't suitable for another. Thus, only match CPUs of
  the same microarchitecture.
 If cannot get an NMI, get a normal interrupt 
 If cannot get an NMI, get a normal interrupt 
 Per cpudevid irq was already requested by another CPU 
  PMU hardware loses all context when a CPU goes offline.
  When a CPU is hotplugged back in, since some hardware registers are
  UNKNOWN at reset, the PMU must be explicitly reset to avoid reading
  junk values out of them.
			
			  Stop and update the counter
			 
			   Restore and enable the counter.
			   armpmu_start() indirectly calls
			  
			   perf_event_update_userpage()
			  
			   that requires RCU read locking to be functional,
			   wrap the call within RCU_NONIDLE to make the
			   RCU subsystem aware this cpu is not idle from
			   an RCU perspective for the armpmu_start() call
			   duration.
	
	  Always reset the PMU registers on power-up even if
	  there are no events running.
		
		  This is a CPU PMU potentially in a heterogeneous
		  configuration (e.g. big.LITTLE). This is not an uncore PMU,
		  and we have taken ctx sharing into account (e.g. with our
		  pmu::filter_match callback and pmu::event_init group
		  validation).
 SPDX-License-Identifier: GPL-2.0
  platform_device probing code for ARM performance counters.
  Copyright (C) 2009 picoChip Designs, Ltd., Jamie Iles
  Copyright (C) 2010 ARM Ltd., Will Deacon <will.deacon@arm.com>
	
	  If we don't have an interrupt-affinity property, we guess irq
	  affinity matches our logical CPU order, as we used to assume.
	  This is fragile, so we'll warn in pmu_parse_irqs().
	
	  In this case we have no idea which CPUs are covered by the PMU.
	  To match our prior behaviour, we assume all CPUs in this case.
 arm64 systems boot only as non-secure 
 SPDX-License-Identifier: GPL-2.0-or-later
  APM X-Gene SoC PMU (Performance Monitor Unit)
  Copyright (c) 2016, Applied Micro Circuits Corporation
  Author: Hoan Tran <hotran@apm.com>
          Tai Nguyen <ttnguyen@apm.com>
 PMU registers for V3 
  sysfs format attributes
  sysfs event attributes
  sysfs cpumask attributes
  Per PMU device attribute groups of PMU v1 and v2
  Per PMU device attribute groups of PMU v3
	
	  v3 has 64-bit counter registers composed by 2 32-bit registers
	  This can be a problem if the counter increases and carries
	  out of bit [31] between 2 reads. The extra reads would help
	  to prevent this issue.
 v3 has 64-bit counter registers composed by 2 32-bit registers 
 Test the event attr type check for PMU enumeration 
	
	  SOC PMU counters are shared across all cores.
	  Therefore, it does not support per-process mode.
	  Also, it does not support event sampling mode.
	
	  Many perf core operations (eg. events rotation) operate on a
	  single CPU context. This is obvious for CPU PMUs, where one
	  expects the same sets of events being observed on all CPUs,
	  but can lead to issues for off-core PMUs, where each
	  event could be theoretically assigned to a different CPU. To
	  mitigate this, we enforce CPU assignment to one, selected
	  processor (the one described in the "cpumask" attribute).
	
	  Each bit of the config1 field represents an agent from which the
	  request of the event come. The event is counted only if it's caused
	  by a request of an agent has the bit cleared.
	  By default, the event is counted for all agents.
	
	  We must NOT create groups containing mixed PMUs, although software
	  events are acceptable
	
	  For 32 bit counter, it has a period of 2^32. To account for the
	  possibility of extreme interrupt latency we program for a period of
	  half that. Hopefully, we can handle the interrupt before another 2^31
	  events occur and the counter overtakes its previous value.
	  For 64 bit counter, we don't expect it overflow.
 Allocate an event counter 
 Update counter event pointer for Interrupt handler 
 clear the assigned counter 
 First version PMU supports only single event counter 
 Perf driver registration 
 Hardware counter init 
 Clear interrupt flag 
 Ignore if we don't have an event. 
 Get Interrupt PMU source 
 Dual MCB active 
 Probe all active MC(s) 
 Single MCB active 
 Probe all active MC(s) 
 Dual MCB active 
 Probe all active L3C(s), maximum is 8 
 Probe all active MC(s), maximum is 8 
 Single MCB active 
 Probe all active L3C(s), maximum is 4 
 Probe all active MC(s), maximum is 4 
 Dual MCB active 
 Probe all active MC(s) 
 Single MCB active 
 Probe all active MC(s) 
 A PMU device node without enable-bit-index is always enabled 
 Can't add the PMU device, skip it 
 A PMU device node without enable-bit-index is always enabled 
 Can't add the PMU device, skip it 
 Overflow interrupt also should use the same CPU 
 Overflow interrupt also should use the same CPU 
 Install a hook to update the reader CPU in case it goes offline 
 Check for active MCBs and MCUs 
 Add this instance to the list used by the hotplug callback 
 Walk through the tree for all PMU perf devices 
 Enable interrupt 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2015-2017 The Linux Foundation. All rights reserved.
  Events
  Aggregate PMU. Implements the core pmu functions and manages
  the hardware PMUs.
  The cache is made up of one or more clusters, each cluster has its own PMU.
  Each cluster is associated with one or more CPUs.
  This structure represents one of the hardware PMUs.
  Events can be envisioned as a 2-dimensional array. Each column represents
  a group of events. There are 8 groups. Only one entry from each
  group can be in use at a time.
  Events are specified as 0xCCG, where CC is 2 hex digits specifying
  the code (array row) and G specifies the group (column).
  In addition there is a cycle counter event specified by L2CYCLE_CTR_RAW_CODE
  which is outside the above scheme.
 The CPU that is used for collecting events on this cluster 
 All the CPUs associated with this cluster 
 Reset all counters 
  Hardware allows filtering of events based on the originating
  CPU. Turn this off by setting filter bits to allow events from
  all CPUS, subunits and ID independent events in this cluster.
	
	  The cycle counter is 64-bit, but all other counters are
	  32-bit, and we must handle 32-bit overflow explicitly.
	
	  We limit the max period to half the max counter value so
	  that even in the case of extreme interrupt latency the
	  counter will (hopefully) not wrap past its initial value.
 The counters are all in use. 
	
	  Check for column exclusion: event column already in use by another
	  event. This is for events which are not in the same group.
	  Conflicting events in the same group are detected in event_init.
  Implementation of abstract pmu functionality required by
  the core perf events code.
	
	  Although there is only one PMU (per socket) controlling multiple
	  physical PMUs (per cluster), because we do not support per-task mode
	  each event is associated with a CPU. Each event has pmu_enable
	  called on its CPU, so here it is only necessary to enable the
	  counters for the current CPU.
 Don't allow groups with mixed PMUs, except for sw events 
 CPU has not been initialised 
 Ensure all events in a group are on the same cpu 
	
	  Ensure all events are on the same cpu so all events are in the
	  same cpu context, to avoid races on pmu_enable etc.
 Propagate changes to the userspace mapping. 
 CCG format for perf RAW codes. 
  Generic device handlers
	
	  Read number of counters from L2PMCR and add 1
	  for the cycle counter.
	
	  This assumes that the cluster_id is in MPIDR[aff1] for
	  single-threaded cores, and MPIDR[aff2] for multi-threaded
	  cores. This logic will have to be updated if this changes.
 First time this CPU has come online 
 Only if broken firmware doesn't list every cluster 
 If another CPU is managing this cluster, we're done 
	
	  All CPUs on this cluster were down, use this one.
	  Reset to put it into sane state.
 If this CPU is not managing the cluster, we're done 
 Give up ownership of cluster 
 Any other CPU for this cluster which is still online 
 suffix is instance id for future use with multiple sockets 
 Read cluster info and initialize each cluster 
 SPDX-License-Identifier: GPL-2.0
 CCI Cache Coherent Interconnect PMU driver
 Copyright (C) 2013-2018 Arm Ltd.
 Author: Punit Agrawal <punit.agrawal@arm.com>, Suzuki Poulose <suzuki.poulose@arm.com>
 Types of interfaces that can generate events 
  struct cci_pmu_model:
  @fixed_hw_cntrs - Number of fixed event counters
  @num_hw_cntrs - Maximum number of programmable event counters
  @cntr_size - Size of an event counter mapping
 CCI400 PMU Specific definitions 
 Port ids 
  Instead of an event id to monitor CCI cycles, a dedicated counter is
  provided. Use 0xff to represent CCI cycles and hope that no future revisions
  make use of this event in hardware.
  CCI PMU event id is an 8-bit value made of two parts - bits 7:5 for one of 8
  ports and bits 4:0 are event codes. There are different event codes
  associated with each port type.
  Additionally, the range of events associated with the port types changed
  between Rev0 and Rev1.
  The constants below define the range of valid codes for each port type for
  the different revisions and are used to validate the event to be monitored.
 Slave events 
 Master events 
 Special event for cycles counter 
 Slave events 
 Master events 
 Special event for cycles counter 
 cycles event idx is fixed 
 No counters available 
 Slave Interface 
 Master Interface 
 !CONFIG_ARM_CCI400_PMU 
 CONFIG_ARM_CCI400_PMU 
  CCI5xx PMU event id is an 9-bit value made of two parts.
 	 bits [8:5] - Source for the event
 	 bits [4:0] - Event code (specific to type of interface)
 Port ids 
 Slave events 
 Master events 
 Global events 
 Global events have single fixed source code 
  CCI500 provides 8 independent event counters that can count
  any of the events available.
  CCI500 PMU event source ids
 	0x0-0x6 - Slave interfaces
 	0x8-0xD - Master interfaces
 	0xf     - Global Events
 	0x7,0xe - Reserved
  CCI550 provides 8 independent event counters that can count
  any of the events available.
  CCI550 PMU event source ids
 	0x0-0x6 - Slave interfaces
 	0x8-0xe - Master interfaces
 	0xf     - Global Events
 	0x7	- Reserved
 CONFIG_ARM_CCI5xx_PMU 
  Program the CCI PMU counters which have PERF_HES_ARCH set
  with the event period and mark them ready before we enable
  PMU.
 Leave the events which are not counting 
 Should be called with cci_pmu->hw_events->pmu_lock held 
 Enable all the PMU counters. 
 Should be called with cci_pmu->hw_events->pmu_lock held 
 Should be called with cci_pmu->hw_events->pmu_lock held 
 Disable all the PMU counters. 
 source parameter is mandatory for normal PMU events 
  For all counters on the CCI-PMU, disable any 'enabled' counters,
  saving the changed counters in the mask, so that we can restore
  it later using pmu_restore_counters. The mask is private to the
  caller. We cannot rely on the used_mask maintained by the CCI_PMU
  as it only tells us if the counter is assigned to perf_event or not.
  The state of the perf_event cannot be locked by the PMU layer, hence
  we check the individual counter status (which can be locked by
  cci_pm->hw_events->pmu_lock).
  @mask should be initialised to empty by the caller.
  Restore the status of the counters. Reversal of the pmu_save_counters().
  For each counter set in the mask, enable the counter back.
  Returns the number of programmable counters actually implemented
  by the cci
 Generic code to find an unused idx from the mask 
 No counters available 
	
	  Register all available CCI PMU interrupts. In the interrupt handler
	  we iterate over the counters checking for interrupt source (the
	  overflowing counter) and clear it.
	 
	  This should allow handling of non-unique interrupt for the counters.
  CCI-500CCI-550 has advanced power saving policies, which could gate the
  clocks to the PMU counters, which makes the writes to them ineffective.
  The only way to write to those counters is when the global counters
  are enabled and the particular counter is enabled.
  So we do the following :
  1) Disable all the PMU counters, saving their current state
  2) Enable the global PMU profiling, now that all counters are
     disabled.
  For each counter to be programmed, repeat steps 3-7:
  3) Write an invalid event code to the event control register for the
      counter, so that the counters are not modified.
  4) Enable the counter control for the counter.
  5) Set the counter value
  6) Disable the counter
  7) Restore the event in the target counter
  8) Disable the global PMU.
  9) Restore the status of the rest of the counters.
  We choose an event which for CCI-5xx is guaranteed not to count.
  We use the highest possible event code (0x1f) for the master interface 0.
	
	  Now that all the counters are disabled, we can safely turn the PMU on,
	  without syncing the status of the counters
 CONFIG_ARM_CCI5xx_PMU 
	
	  The CCI PMU counters have a period of 2^32. To account for the
	  possiblity of extreme interrupt latency we program for a period of
	  half that. Hopefully we can handle the interrupt before another 2^31
	  events occur and the counter overtakes its previous value.
	
	  CCI PMU uses PERF_HES_ARCH to keep track of the counters, whose
	  values needs to be sync-ed with the sw state before the PMU is
	  enabled.
	  Mark this counter for sync.
 Disable the PMU while we walk through the counters 
	
	  Iterate over counters and update the corresponding perf events.
	  This should work regardless of whether we have per-counter overflow
	  interrupt or a combined overflow interrupt.
 Did this counter overflow? 
 Enable the PMU and sync possibly overflowed counters 
  Check if the idx represents a non-programmable counter.
  All the fixed event counters are mapped before the programmable
  counters.
	
	  To handle interrupt latency, we always reprogram the period
	  regardlesss of PERF_EF_RELOAD.
 Configure the counter unless you are counting a fixed event 
	
	  We always reprogram the counter, so ignore PERF_EF_UPDATE. See
	  cci_pmu_start()
 If we don't have a space for the counter then finish early. 
 Propagate our changes to the userspace mapping. 
	
	  Reject groups spanning multiple HW PMUs (e.g. CPU + CCI). The
	  core perf code won't check that the pmu->ctx == leader->ctx
	  until after pmu->event_init(event).
		
		  Initialise the fake PMU. We only need to populate the
		  used_mask for the purposes of validation.
	
	  We don't assign an index until we actually place the event onto
	  hardware. Use -1 to signify that we haven't decided where to put it
	  yet.
	
	  Store the event encoding into the config_base field.
 Shared by all CPUs, no meaningful state to sample 
	
	  Following the example set by other "uncore" PMUs, we accept any CPU
	  and rewrite its affinity dynamically rather than having perf core
	  handle cpu == -1 and pid == -1 for this case.
	 
	  The perf core will pin online CPUs for the duration of this call and
	  the event being installed into its context, so the PMU's CPU can't
	  change under our feet.
 Filled in cci_pmu_init_attrs 
 Filled in cci_pmu_init_attrs 
 Cycle counter 
 Cycle counter 
	
	  All allocations are devm_ hence we don't have to free
	  them explicitly on an error, as it would end up in driver
	  detach.
	
	  CCI PMU has one overflow interrupt per counter; but some may be tied
	  together to a common interrupt.
	
	  Ensure that the device tree has as many interrupts as the number
	  of counters.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2017 NXP
  Copyright 2016 Freescale Semiconductor, Inc.
 AXI_MASKING(MSB 16bits) + AXI_ID(LSB 16bits) 
 DDR Perf hardware feature 
 support AXI ID filter 
 support enhanced AXI ID filter 
 quirks needed for different DDR Perf core 
 system PMU identifier for userspace 
 sentinel  }
	
	  Always map cycle event to counter 0
	  Cycles counter is dedicated for cycle event
	  can't used for the other events
	
	  return bytes instead of bursts from ddr transaction for
	  axid-read and axid-write event if PMU core supports enhanced
	  filter.
	
	  We must NOT create groups containing mixed PMUs, although software
	  events are acceptable (for example to create a CCN group
	  periodically read when a hrtimer aka cpu-clock leader triggers).
		
		  cycle counter is special which should firstly write 0 then
		  write 1 into CLEAR bit to clear it. Other counters only
		  need write 0 into CLEAR bit and it turns out to be 1 by
		  hardware. Below enable flow is harmless for all counters.
 Disable counter 
	
	  For legacy SoCs: event counter continue counting when overflow,
	                   no need to clear the counter.
	  For new SoCs: event counter stop counting when overflow, need
	                clear counter to let it count again.
 clear counter every time for both cycle counter and event counter 
 revert axi id masking(axi_mask) value 
 enable cycle counter if cycle is not active event list 
 all counter will stop if cycle counter disabled 
	
	  When the cycle counter overflows, all counters are stopped,
	  and an IRQ is raised. If any other counter overflows, it
	  continues counting, and no IRQ is raised. But for new SoCs,
	  such as i.MX8MP, event counter would stop when overflow, so
	  we need use cycle counter to stop overflow of event counter.
	 
	  Cycles occur at least 4 times as often as other events, so we
	  can update all events on a cycle counter overflow and not
	  lose events.
	 
 Register the pmu instance for cpu hotplug 
 Request irq 
 SPDX-License-Identifier: GPL-2.0-only
  ARM DMC-620 memory controller PMU driver
  Copyright (C) 2020 Ampere Computing LLC.
  The PMU registers start at 0xA00 in the DMC-620 memory map, and these
  offsets are relative to that base.
  Each counter has a group of controlvalue registers, and the
  DMC620_PMU_COUNTERn offsets are within a counter group.
  The counter registers groups start at 0xA10.
 Offset of the registers for a given counter, relative to 0xA00 
	
	  We put all clkdiv2 and clk counters to a same array.
	  The first DMC620_PMU_CLKDIV2_MAX_COUNTERS bits belong to
	  clkdiv2 counters, the last DMC620_PMU_CLK_MAX_COUNTERS
	  belong to clk counters.
 clkdiv2 events list 
 clk events list 
 User ABI 
 The counters are all in use. 
 We may also be called from the irq handler 
		
		  HW doesn't provide a control to atomically disable all counters.
		  To prevent race condition (overflow happens while clearing status register),
		  disable all events before continuing
 Pick one CPU to be the preferred one to use 
	
	  DMC 620 PMUs are shared across all cpus and cannot
	  support task bound and sampling events.
	
	  Many perf core operations (eg. events rotation) operate on a
	  single CPU context. This is obvious for CPU PMUs, where one
	  expects the same sets of events being observed on all CPUs,
	  but can lead to issues for off-core PMUs, where each
	  event could be theoretically assigned to a different CPU. To
	  mitigate this, we enforce CPU assignment to one, selected
	  processor.
	
	  We can't atomically disable all HW counters so only one event allowed,
	  although software events are acceptable.
 We're only reading, but this isn't the place to be involving RCU 
 Make sure device is reset before enabling interrupt 
 perf will synchronise RCU before devres can free dmc620_pmu 
 SPDX-License-Identifier: GPL-2.0-only
  ARM DynamIQ Shared Unit (DSU) PMU driver
  Copyright (C) ARM Limited, 2017.
  Based on ARM CCI-PMU, ARMv8 PMU-v3 drivers.
 PMU event codes 
  We use the index of the counters as they appear in the counter
  bit maps in the PMU registers (e.g CLUSTERPMSELR).
  i.e,
 	counter 0	- Bit 0
 	counter 1	- Bit 1
 	...
 	Cycle counter	- Bit 31
 All event counters are 32bit, with a 64bit Cycle counter 
  struct dsu_pmu	- DSU PMU descriptor
  @pmu_lock		: Protects accesses to DSU PMU register from normal vs
 			  interrupt handler contexts.
  @hw_events		: Holds the event counter state.
  @associated_cpus	: CPUs attached to the DSU.
  @active_cpu		: CPU to which the PMU is bound for accesses.
  @cpuhp_node		: Node for CPU hotplug notifier link.
  @num_counters	: Number of event counters implemented by the PMU,
 			  excluding the cycle counter.
  @irq			: Interrupt line for counter overflow.
  @cpmceid_bitmap	: Bitmap for the availability of architected common
 			  events (event_code < 0x40).
 We may also be called from the irq handler 
  dsu_pmu_set_event_period: Set the period for the counter.
  All DSU PMU event counters, except the cycle counter are 32bit
  counters. To handle cases of extreme interrupt latency, we program
  the counter with half of the max count for the counters.
 We always reprogram the counter 
 If no counters are added, skip enabling the PMU 
 Reject groups spanning multiple HW PMUs. 
  Make sure the group of events can be scheduled at once
  on the PMU.
 We don't support sampling 
 We cannot support task bound events 
	
	  Choose the current active CPU to read the events. We don't want
	  to migrate the event contexts, irq handling etc to the requested
	  CPU. As long as the requested CPU is within the same DSU, we
	  are fine.
	
	  Initialise the number of counters to -1, until we probe
	  the real number on a connected CPU.
  dsu_pmu_dt_get_cpus: Get the list of CPUs in the cluster
  from device tree.
		
		  We have to ignore the failures here and continue scanning
		  the list to handle cases where the nr_cpus could be capped
		  in the running kernel.
  dsu_pmu_acpi_get_cpus: Get the list of CPUs in the cluster
  from ACPI.
	
	  A dsu pmu node is inside a cluster parent node along with cpu nodes.
	  We need to find out all cpus that have the same parent with this pmu.
  dsu_pmu_probe_pmu: Probe the PMU details on a CPU in the cluster.
 We can only support up to 31 independent counters 
  dsu_pmu_init_pmu: Initialise the DSU PMU configurations if
  we haven't done it already.
 Reset the interrupt overflow mask 
 If the PMU is already managed, there is nothing to do 
 If there are no active CPUs in the DSU, leave IRQ disabled 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2014 ARM Limited
 RN-D = RN-I + DVM 
 Pseudotype 
 Pseudoevent 
 See DT.dbg_id.num_watchpoints 
 See DT.dbg_id.num_pmucntr 
  Bit shifts and masks in these defines must be kept in sync with
  arm_ccn_pmu_config_set() and CCN_FORMAT_ATTRs below!
  Events defined in TRM for MN, HN-I and SBSX are actually watchpoints set on
  their ports in XP they are connected to. For the sake of usability they are
  explicitly defined here (and translated into a relevant watchpoint in
  arm_ccn_pmu_event_init()) so the user can easily request them without deep
  knowledge of the flit format.
  RN-I & RN-D (RN-D = RN-I + DVM) nodes have different type ID depending
  on configuration. One of them is picked to represent the whole group,
  as they all share the same event types.
 Arguments required by an event 
 Populated in arm_ccn_init() 
  Default poll period is 10ms, which is way over the top anyway,
  as in the worst case scenario (an event every cycle), with 1GHz
  clocked bus, the smallest, 32 bit counter will overflow in
  more than 4s.
 All RN-I and RN-D nodes have identical PMUs 
 Allocate the cycle counter 
 Allocate an event counter 
 Allocate an event source or a watchpoint 
	
	  Many perf core operations (eg. events rotation) operate on a
	  single CPU context. This is obvious for CPU PMUs, where one
	  expects the same sets of events being observed on all CPUs,
	  but can lead to issues for off-core PMUs, like CCN, where each
	  event could be theoretically assigned to a different CPU. To
	  mitigate this, we enforce CPU assignment to one, selected
	  processor (the one described in the "cpumask" attribute).
 Validate nodexp vs topology 
 Validate event ID vs available for the type 
 Watchpoint-based event for a node is actually set on XP 
	
	  We must NOT create groups containing mixed PMUs, although software
	  events are acceptable (for example to create a CCN group
	  periodically read when a hrtimer aka cpu-clock leader triggers).
 40 bit counter, can do snapshot and read in two parts 
 Nothing to do for cycle counter 
 Set the DT bus input, engaging the counter 
 Disable counting, setting the DT bus to pass-through mode 
 Direction (RXTX), device (port) & virtual channel 
 Comparison values 
 Mask 
 These _event_sel regs should be identical, but let's make sure... 
 Set the event id for the pre-allocated counter 
 Cycle counter requires no setup 
 Set the DT bus "distance" register 
	
	  Pin the timer, so that the overflows are handled by the chosen
	  event->cpu (this is the same one as presented in "cpumask"
	  attribute).
 Initialize DT subsystem 
 Get a convenient sysevent_sourcedevices name 
 Perf driver registration 
 No overflow interrupt? Have to use a timer instead. 
 Pick one CPU which we will use to collect data from CCN... 
 Also make sure that the overflow interrupt is handled by this CPU 
 This should be really handled by firmware... 
 PMU overflow is a special case 
 Have to read all err_sig_vals to clear them 
 Check if we can use the interrupt 
 Can set 'disable' bits, so can acknowledge interrupts 
 Build topology 
 SPDX-License-Identifier: GPL-2.0
  CAVIUM THUNDERX2 SoC PMU UNCORE
  Copyright (C) 2018 Cavium Inc.
  Author: Ganapatrao Kulkarni <gkulkarni@cavium.com>
 Each ThunderX2(TX2) Socket has a L3C and DMC UNCORE PMU device.
  Each UNCORE PMU device consists of 4 independent programmable counters.
  Counters are 32 bit and do not support overflow interrupt,
  they need to be sampled before overflow(i.e, at every 2 seconds).
  1 byte per counter(4 counters).
   Event id is encoded in bits [5:1] of a byte,
 bits[3:0] to select counters, are indexed from 8 to 15. 
 L3C event IDs 
 DMC event IDs 
  Each socket has 3 uncore devices associated with a PMU. The DMC and
  L3C have 4 32-bit counters and the CCPI2 has 8 64-bit counters.
  sysfs event attributes
  sysfs cpumask attributes
  Per PMU device attribute groups
 counter ctrldata reg offset at 8 
 counter data reg offset at 0xc 
 event id encoded in bits [07:03] 
	 enable and start counters.
	  8 bits for each counter, bits[05:01] of a counter to set event type.
 clear event type(bits[05:01]) to stop counter 
	 Bit [09:00] to set event id.
	  Bits [10], set level to rising edge.
	  Bits [11], set type to edge sensitive.
 reset[4], enable[0] and start[1] counters 
 disable and stop counter 
 handles rollover of 32 bit counter 
 DMC event data_transfers granularity is 16 Bytes, convert it to 64 
	 L3C and DMC has 16 and 8 interleave channels respectively.
	  The sampled value is for channel 0 and multiplied with
	  prorate_factor to get the count for a device.
 Reject groups spanning multiple HW PMUs. 
  Make sure the group of events can be scheduled at once
  on the PMU.
	
	  If the group requires more counters than the HW has,
	  it cannot ever be scheduled.
 Test the event attr type check for PMU enumeration 
	
	  SOC PMU counters are shared across all cores.
	  Therefore, it does not support per-process mode.
	  Also, it does not support event sampling mode.
 store event id 
 Validate the group 
 No hrtimer needed for CCPI2, 64-bit counters 
 Start timer for first event 
 Allocate a free counter 
 set counter control and data registers base address 
 clear the assigned counter 
 Perf event registration 
 register hotplug callback for the pmu 
 Add to list 
 CCPI2 has 8 counters 
 Can't add the PMU device, abort 
	 Pick this CPU, If there is no CPUPMU association and both are
	  from same node.
 Walk through the tree for all PMU UNCORE devices 
 SPDX-License-Identifier: GPL-2.0-only
  Driver for the L3 cache PMUs in Qualcomm Technologies chips.
  The driver supports a distributed cache architecture where the overall
  cache for a socket is comprised of multiple slices each with its own PMU.
  Access to each individual PMU is provided even though all CPUs share all
  the slices. User space needs to aggregate to individual counts to provide
  a global picture.
  See Documentationadmin-guideperfqcom_l3_pmu.rst for more details.
  Copyright (c) 2015-2017, The Linux Foundation. All rights reserved.
  General constants
 Number of counters on each PMU 
 Mask for the event type field within perf_event_attr.config and EVTYPE reg 
  Bit position of the 'long counter' flag within perf_event_attr.config.
  Reserve some space between the event type and this flag to allow expansion
  in the event type field.
  Register offsets
 Perfmon registers 
 Basic counter registers 
  Bit field definitions
 L3_HML3_PM_CR 
 L3_HML3_PM_XCNTCTLL3_HML3_PM_CNTCTLx 
 L3_HML3_PM_EVTYPEx 
 Reset value for all the filter registers 
 L3_M_BC_CR 
 L3_M_BC_SATROLL_CR 
 L3_M_BC_CNTENSET 
 L3_M_BC_CNTENCLR 
 L3_M_BC_INTENSET 
 L3_M_BC_INTENCLR 
 L3_M_BC_GANG 
 L3_M_BC_OVSR 
 L3_M_BC_IRQCTL 
  Events
  Decoding of settings from perf_event_attr
  The config format for perf events is:
  - config: bits 0-7: event type
            bit  32:  HW counter size requested, 0: 32 bits, 1: 64 bits
  Main PMU, inherits from the core perf PMU type
  Type used to group hardware counter operations
  Used to implement two types of hardware counters, standard (32bits) and
  long (64bits). The hardware supports counter chaining which we use to
  implement long counters. This support is exposed via the 'lc' flag field
  in perf_event_attr.config.
 Called to start event monitoring 
 Called to stop event monitoring 
 Called to update the perf_event 
  Implementation of long counter operations
  64bit counters are implemented by chaining two of the 32bit physical
  counters. The PMU only supports chaining of adjacent evenodd pairs
  and for simplicity the driver always configures the odd counter to
  count the overflows of the lower-numbered even counter. Note that since
  the resulting hardware counter is 64bits no IRQs are required to maintain
  the software counter which is also 64bits.
 Set the odd counter to count the overflows of the even counter 
 Initialize the hardware counters and reset prev_count
	
	  Set the event types, the upper half must use zero and the lower
	  half the actual event type
 Finally, enable the counters 
 Disable the counters 
 Disable chaining 
  Implementation of standard counter operations
  32bit counters use a single physical counter and a hardware feature that
  asserts the overflow IRQ on the toggling of the most significant bit in
  the counter. This feature allows the counters to be left free-running
  without needing the usual reprogramming required to properly handle races
  during concurrent calls to update.
 Set the counter to assert the overflow IRQ on MSB toggling 
 Initialize the hardware counter and reset prev_count
 Set the event type 
 Enable interrupt generation by this counter 
 Finally, enable the counter 
 Disable the counter 
 Disable interrupt generation by this counter 
 Set the counter to not assert the overflow IRQ on MSB toggling 
 Retrieve the appropriate operations for the given event 
  Top level PMU functions.
	
	  Use writel for the first programming command to ensure the basic
	  counter unit is stopped before proceeding
	
	  Use writel here to ensure all programming commands are done
	   before proceeding
 Read the overflow status register 
 Clear the bits we read on the overflow status register 
		
		  Since the IRQ is not enabled for events using long counters
		  we should never see one of those here, however, be consistent
		  and use the ops indirections like in the other operations.
  Implementation of abstract pmu functionality required by
  the core perf events code.
 Ensure the other programming commands are observed before enabling 
 Ensure the basic counter unit is stopped before proceeding 
  We must NOT create groups containing events from multiple hardware PMUs,
  although mixing different software and hardware PMUs is allowed.
	
	  If the group requires more counters than the HW has, it
	  cannot ever be scheduled.
	
	  Is the event for this PMU?
	
	  Sampling not supported since these events are not core-attributable.
	
	  Task mode not available, we run the counters as socket counters,
	  not attributable to any CPU and therefore cannot attribute per-task.
 Validate the group 
	
	  Many perf core operations (eg. events rotation) operate on a
	  single CPU context. This is obvious for CPU PMUs, where one
	  expects the same sets of events being observed on all CPUs,
	  but can lead to issues for off-core PMUs, like this one, where
	  each event could be theoretically assigned to a different CPU.
	  To mitigate this, we enforce CPU assignment to one designated
	  processor (the one described in the "cpumask" attribute exported
	  by the PMU device). perf user space tools honor this and avoid
	  opening more than one copy of the events.
	
	  Try to allocate a counter.
 The counters are all in use. 
 Propagate changes to the userspace mapping. 
 Stop and clean up 
 Propagate changes to the userspace mapping. 
  Add sysfs attributes
  We export:
  - formats, used by perf user space and other tools to configure events
  - events, used by perf user space and other tools to create events
    symbolically, e.g.:
      perf stat -a -e l3cache_0_0event=read-miss ls
      perf stat -a -e l3cache_0_0event=0x21 ls
  - cpumask, used by perf user space and other tools to know on which CPUs
    to open the events
 formats 
 events 
 cpumask 
  Per PMU device attribute groups
  Probing functions and data.
 If there is not a CPUPMU association pick this CPU 
 Initialize the PMU data structures 
 Add this instance to the list used by the offline callback 
 Install a hook to update the reader CPU in case it goes offline 
 SPDX-License-Identifier: GPL-2.0-only
  ACPI probing code for ARM performance counters.
  Copyright (C) 2017 ARM Ltd.
	
	  Per the ACPI spec, the MADT cannot describe a PMU that doesn't
	  have an interrupt. QEMU advertises this by using a GSI of zero,
	  which is not known to be valid on any hardware despite being
	  valid per the spec. Take the pragmatic approach and reject a
	  GSI of zero for now.
	
	  Helpfully, the MADT GICC doesn't have a polarity flag for the
	  "performance interrupt". Luckily, on compliant GICs the polarity is
	  a fixed value in HW (for both SPIs and PPIs) that we cannot change
	  from SW.
	 
	  Here we pass in ACPI_ACTIVE_HIGH to keep the core code happy. This
	  may not match the real polarity, but that should not matter.
	 
	  Other interrupt controllers are not supported with ACPI.
 irq 
  For lack of a better place, hook the normal PMU MADT walk
  and create a SPE device if we detect a recent MADT with
  a homogeneous PPI mapping.
	
	  Sanity check all the GICC tables for the same interrupt number.
	  For now, we only support homogeneous ACPISPE machines.
 CONFIG_ARM_SPE_PMU 
		
		  Log and request the IRQ so the core arm_pmu code can manage
		  it. We'll have to sanity-check IRQs later when we associate
		  them with their PMUs.
		
		  Blat all copies of the IRQ so that we only unregister the
		  corresponding GSI once (e.g. when we have PPIs).
  Check whether the new IRQ is compatible with those already associated with
  the PMU (e.g. we don't have mismatched PPIs).
  This must run before the common arm_pmu hotplug logic, so that we can
  associate a CPU and its interrupt before the common code tries to manage the
  affinity and so on.
  Note that hotplug events are serialized, so we cannot race with another CPU
  coming up. The perf core won't open events while a hotplug event is in
  progress.
 If we've already probed this CPU, we have nothing to do 
	
	  Ideally, we'd probe the PMU here when we find the first matching
	  CPU. We can't do that for several reasons; see the comment in
	  arm_pmu_acpi_init().
	 
	  So for the time being, we're done.
	
	  Initialise and register the set of PMUs which we know about right
	  now. Ideally we'd do this in arm_pmu_acpi_cpu_starting() so that we
	  could handle late hotplug, but this may lead to deadlock since we
	  might try to register a hotplug notifier instance from within a
	  hotplug notifier.
	 
	  There's also the problem of having access to the right init_fn,
	  without tying this too deeply into the "real" PMU driver.
	 
	  For the moment, as with the platformDT case, we need at least one
	  of a PMU's CPUs to be online at probe time.
 PMU not handled by this driver, or not present 
 SPDX-License-Identifier: GPL-2.0
  This driver adds support for perf events to use the Performance
  Monitor Counter Groups (PMCG) associated with an SMMUv3 node
  to monitor that node.
  SMMUv3 PMCG devices are named as smmuv3_pmcg_<phys_addr_page> where
  <phys_addr_page> is the physical page address of the SMMU PMCG wrapped
  to 4K boundary. For example, the PMCG at 0xff88840000 is named
  smmuv3_pmcg_ff88840
  Filtering by stream id is done by specifying filtering parameters
  with the event. options are:
    filter_enable    - 0 = no filtering, 1 = filtering enabled
    filter_span      - 0 = exact match, 1 = pattern match
    filter_stream_id - pattern to filter against
  To match a partial StreamID where the X most-significant bits must match
  but the Y least-significant bits might differ, STREAMID is programmed
  with a value that contains:
   STREAMID[Y - 1] == 0.
   STREAMID[Y - 2:0] == 1 (where Y > 1).
  The remainder of implemented bits of STREAMID (X bits, from bit Y upwards)
  contain a value to match from the corresponding bits of event StreamID.
  Example: perf stat -e smmuv3_pmcg_ff88840transaction,filter_enable=1,
                     filter_span=1,filter_stream_id=0x42 -a netperf
  Applies filter pattern 0x42 to transaction events, which means events
  matching stream ids 0x42 and 0x43 are counted. Further filtering
  information is available in the SMMU documentation.
  SMMU events are not attributable to a CPU, so task mode and sampling
  are not supported.
 MSI config fields 
 handle overflow. 
		
		  On platforms that require this quirk, if the counter starts
		  at < half_counter value and wraps, the current logic of
		  handling the overflow may not work. It is expected that,
		  those platforms will have full 64 counter bits implemented
		  so that such a possibility is remote(eg: HiSilicon HIP08).
		
		  We limit the max period to half the max counter value
		  of the counter size, so that even in the case of extreme
		  interrupt latency the counter will (hopefully) not wrap
		  past its initial value.
	
	  Per-counter filtering, or scheduling the first globally-filtered
	  event into an empty PMU so idx == 0 and it works out equivalent.
 Otherwise, must match whatever's currently scheduled 
 The counters are all in use. 
  Implementation of abstract pmu functionality required by
  the core perf events code.
 Verify specified event is supported on this PMU 
 Don't allow groups with mixed PMUs, except for sw events 
	
	  Ensure all events are on the same cpu so all events are in the
	  same cpu context, to avoid races on pmu_enable etc.
 As the counter gets updated on _start, ignore PERF_EF_UPDATE 
 Propagate changes to the userspace mapping. 
 cpumask 
 Events 
 Formats 
  Generic device handlers
 Clear MSI address reg 
 MSI supported or not 
 Add callback to free MSIs on teardown 
 Disable counter and interrupt 
 HiSilicon Erratum 162001800 
 Determine if page 1 is present 
 Pick one CPU to be the preferred one to use 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2016-2020 Arm Limited
 CMN-600 Coherent Mesh Network PMU driver
 Common register stuff 
 The CFG node has one other useful purpose 
 PMU registers occupy the 3rd 4KB page of each node's 16KB space 
 For most nodes, this is all there is 
 DTMs live in the PMU space of XP registers 
 The DTC node is where the magic happens 
 DTC counters are paired in 64-bit registers on a 16-byte stride. Yuck 
  Even in the worst case a DTC counter can't wrap in fewer than 2^42 cycles,
  so throwing away one bit to make overflow handling easy is no big deal.
 Similarly for the 40-bit cycle counter 
 Event attributes 
 Made-up event IDs for watchpoint direction 
 r0px probably don't exist in silicon, thankfully 
 Not a real node type 
 Device node 
 DNHN-FCXHA 
 XP 
 Watchpoints aren't nodes 
 Revision-specific differences 
 Good thing there are only 3 fundamental XP events... 
	
	  DVM node events conflict with HN-I events in the equivalent PMU
	  slot, but our lazy short-cut of using the DTM counter index for
	  the PMU index as well happens to avoid that by construction.
 We treat watchpoints as a special made-up class of XP events 
 DTC events (i.e. cycles) already have everything they need 
 For watchpoints we need the actual XP node here 
 ...and we need a "real" direction 
	
	  By assuming events count in all DTC domains, we cunningly avoid
	  needing to know anything about how XPs are assigned to domains.
 Grab a free global counter first... 
 ...then the local counters to feed it. 
 Go go go! 
  We stop the PMU for both add and read, to avoid skew across DTM counters.
  In theory we could use snapshots to read without stopping, but then it
  becomes a lot trickier to deal with overlow and racing against interrupts,
  plus it seems they don't work properly on some hardware anyway :(
 We can reasonably accommodate DTCs of the same CMN sharing IRQs 
 isn't C great? 
 We do at least know that a DTC's XP must be in that DTC's domain 
 To the PMU, RN-Ds don't add anything over RN-Is, so smoosh them together 
 Pass 1: visit the XPs, enumerate their children 
 Cheeky +1 to help terminate pointer-based iteration 
 Pass 2: now we can actually populate the nodes 
		
		  Thanks to the order in which XP logical IDs seem to be
		  assigned, we can handily infer the mesh X dimension by
		  looking out for the XP at (0,1) without needing to know
		  the exact node ID format, which we can later derive.
			
			  Don't even try to touch anything external, since in general
			  we haven't a clue how to power up arbitrary CHI requesters.
			  As of CMN-600r1 these could only be RN-SAMs or CXLAs,
			  neither of which have any PMU events anyway.
			  (Actually, CXLAs do seem to have grown some events in r1p2,
			  but they don't go to regular XP DTMs, and they depend on
			  secure configuration which we can't easily deal with)
 These guys have PMU events 
 Nothing to see here 
 Something has gone horribly wrong 
 Correct for any nodes we skipped 
	
	  If mesh_x wasn't set during discovery then we never saw
	  an XP at (0,1), thus we must have an Nx1 configuration.
	
	  Note that devm_ioremap_resource() is dumb and won't let the platform
	  device claim cfg when the ACPI companion device has already claimed
	  root within it. But since they are already both claimed in the
	  appropriate name, we don't really need to do it again here anyway.
 SPDX-License-Identifier: GPL-2.0-only
  HiSilicon SoC DDRC uncore Hardware event counters support
  Copyright (C) 2017 HiSilicon Limited
  Author: Shaokun Zhang <zhangshaokun@hisilicon.com>
          Anurup M <anurup.m@huawei.com>
  This code is based on the uncore PMUs like arm-cci and arm-ccn.
 DDRC register definition in v1 
 DDRC register definition in v2 
 DDRC has 8-counters 
  For PMU v1, there are eight-events and every event has been mapped
  to fixed-purpose counters which register offset is not consistent.
  Therefore there is no write event type and we assume that event
  code (0 to 7) is equal to counter index in PMU driver.
  Select the counter register offset using the counter index.
  In PMU v1, there are no programmable counter, the count
  is read form the statistics counter register itself.
  For DDRC PMU v1, event has been mapped to fixed-purpose counter by hardware,
  so there is no need to write event type, while it is programmable counter in
  PMU v2.
 Set perf_enable in DDRC_PERF_CTRL to start event counting 
 Clear perf_enable in DDRC_PERF_CTRL to stop event counting 
 Set counter index(event code) in DDRC_EVENT_CTRL register 
 Clear counter index(event code) in DDRC_EVENT_CTRL register 
 For DDRC PMU, we use event code as counter index 
 Write 0 to enable interrupt 
 Write 1 to mask interrupt 
	
	  Use the SCCL_ID and DDRC channel ID to identify the
	  DDRC PMU, while SCCL_ID is in MPIDR[aff2].
 DDRC PMUs only share the same SCCL 
 SPDX-License-Identifier: GPL-2.0-only
  HiSilicon SoC L3C uncore Hardware event counters support
  Copyright (C) 2017 HiSilicon Limited
  Author: Anurup M <anurup.m@huawei.com>
          Shaokun Zhang <zhangshaokun@hisilicon.com>
  This code is based on the uncore PMUs like arm-cci and arm-ccn.
 L3C register definition 
  If the HW version only supports a 48-bit counter, then
  bits [63:48] are reserved, which are Read-As-Zero and
  Writes-Ignored.
 L3C has 8-counters 
 Set request-type for tracetag 
 Enable request-tracetag statistics 
 Clear request-type 
 Disable request-tracetag statistics 
	
	  Select the appropriate datasource register(L3C_DATSRC_TYPE01).
	  There are 2 datasource ctrl register for the 8 hardware counters.
	  Datasrc is 8-bits and for the former 4 hardware counters,
	  L3C_DATSRC_TYPE0 is chosen. For the latter 4 hardware counters,
	  L3C_DATSRC_TYPE1 is chosen.
 Config and enable core information 
 Enable core-tracetag statistics 
 Clear core information 
 Disable core-tracetag statistics 
  Select the counter register offset using the counter index
	
	  Select the appropriate event select register(L3C_EVENT_TYPE01).
	  There are 2 event select registers for the 8 hardware counters.
	  Event code is 8-bits and for the former 4 hardware counters,
	  L3C_EVENT_TYPE0 is chosen. For the latter 4 hardware counters,
	  L3C_EVENT_TYPE1 is chosen.
 Write event code to L3C_EVENT_TYPEx Register 
	
	  Set perf_enable bit in L3C_PERF_CTRL register to start counting
	  for all enabled counters.
	
	  Clear perf_enable bit in L3C_PERF_CTRL register to stop counting
	  for all enabled counters.
 Enable counter index in L3C_EVENT_CTRL register 
 Clear counter index in L3C_EVENT_CTRL register 
 Write 0 to enable interrupt 
 Write 1 to mask interrupt 
	
	  Use the SCCL_ID and CCL_ID to identify the L3C PMU, while
	  SCCL_ID is in MPIDR[aff2] and CCL_ID is in MPIDR[aff1].
	
	  CCL_ID is used to identify the L3C in the same SCCL which was
	  used _UID by mistake.
 SPDX-License-Identifier: GPL-2.0-only
  HiSilicon SLLC uncore Hardware event counters support
  Copyright (C) 2020 HiSilicon Limited
  Author: Shaokun Zhang <zhangshaokun@hisilicon.com>
  This code is based on the uncore PMUs like arm-cci and arm-ccn.
 SLLC register definition 
 Enable the tgtid 
 Disable the tgtid 
 Enable the srcid 
 Disable the srcid 
	
	  Select the appropriate event select register(SLLC_EVENT_TYPE01).
	  There are 2 event select registers for the 8 hardware counters.
	  Event code is 8-bits and for the former 4 hardware counters,
	  SLLC_EVENT_TYPE0 is chosen. For the latter 4 hardware counters,
	  SLLC_EVENT_TYPE1 is chosen.
 Write event code to SLLC_EVENT_TYPEx Register 
 Write 0 to enable interrupt 
 Write 1 to mask interrupt 
	
	  Use the SCCL_ID and the index ID to identify the SLLC PMU,
	  while SCCL_ID is from MPIDR_EL1 by CPU.
 SLLC PMUs only share the same SCCL 
 SPDX-License-Identifier: GPL-2.0-only
  HiSilicon PA uncore Hardware event counters support
  Copyright (C) 2020 HiSilicon Limited
  Author: Shaokun Zhang <zhangshaokun@hisilicon.com>
  This code is based on the uncore PMUs like arm-cci and arm-ccn.
 PA register definition 
	
	  Select the appropriate event select register(PA_EVENT_TYPE01).
	  There are 2 event select registers for the 8 hardware counters.
	  Event code is 8-bits and for the former 4 hardware counters,
	  PA_EVENT_TYPE0 is chosen. For the latter 4 hardware counters,
	  PA_EVENT_TYPE1 is chosen.
 Write event code to pa_EVENT_TYPEx Register 
 Enable counter index in PA_EVENT_CTRL register 
 Clear counter index in PA_EVENT_CTRL register 
 Write 0 to enable interrupt 
 Write 1 to mask interrupt 
	
	  Use the SCCL_ID and the index ID to identify the PA PMU,
	  while SCCL_ID is the nearst SCCL_ID from this SICL and
	  CPU core is chosen from this SCCL to manage this PMU.
	
	  PA is attached in SICL and the CPU core is chosen to manage this
	  PMU which is the nearest SCCL, while its SCCL_ID is greater than
	  one with the SICL_ID.
 SPDX-License-Identifier: GPL-2.0-only
  HiSilicon SoC Hardware event counters support
  Copyright (C) 2017 HiSilicon Limited
  Author: Anurup M <anurup.m@huawei.com>
          Shaokun Zhang <zhangshaokun@hisilicon.com>
  This code is based on the uncore PMUs like arm-cci and arm-ccn.
  PMU format attributes
  PMU event attributes
  sysfs cpumask attributes. For uncore PMU, we only have a single CPU to show
 Include count for the event 
		
		  We must NOT create groups containing mixed PMUs, although
		  software events are acceptable
 Increment counter for the leader 
 Increment counter for each sibling 
 The group can not count events more than the counters in the HW 
	
	  Find the counter index which overflowed if the bit was set
	  and handle it.
 Write 1 to clear the IRQ status flag 
 Get the corresponding event struct 
	
	  We do not support sampling as the counters are all
	  shared by all CPU cores in a CPU die(SCCL). Also we
	  do not support attach to a task(per-process mode)
	
	   The uncore counters not specific to any CPU, so cannot
	   support per-task
	
	  Validate if the events in group does not exceed the
	  available counters in hardware.
	
	  We don't assign an index until we actually place the event onto
	  hardware. Use -1 to signify that we haven't decided where to put it
	  yet.
 Enforce to use the same CPU for all events in this PMU 
  Set the counter to count the event that we're interested in,
  and enable interrupt and counter.
  Disable counter and interrupt.
	
	  The HiSilicon PMU counters support 32 bits or 48 bits, depending on
	  the PMU. We reduce it to 2^(counter_bits - 1) to account for the
	  extreme interrupt latency. So we could hopefully handle the overflow
	  interrupt before another 2^(counter_bits - 1) events occur and the
	  counter overtakes its previous value.
 Write start value to the hardware event counter 
 Read the count from the counter register 
	
	  compute the delta
 Read hardware counter and update the perf counter statistics 
 Get an available counter index for counting 
 Read hardware counter and update the perf counter statistics 
  The Super CPU Cluster (SCCL) and CPU Cluster (CCL) IDs can be
  determined from the MPIDR_EL1, but the encoding varies by CPU:
  - For MT variants of TSV110:
    SCCL is Aff2[7:3], CCL is Aff2[2:0]
  - For other MT parts:
    SCCL is Aff3[7:0], CCL is Aff2[7:0]
  - For non-MT parts:
    SCCL is Aff2[7:0], CCL is Aff1[7:0]
  Check whether the CPU is associated with this uncore PMU
 If CCL_ID is -1, the PMU only shares the same SCCL 
 If another CPU is already managing this PMU, simply return. 
 Use this CPU in cpumask for event counting 
 Overflow interrupt also should use the same CPU 
 Nothing to do if this CPU doesn't own the PMU 
 Give up ownership of the PMU 
 Choose a new CPU to migrate ownership of the PMU to 
 Use this CPU for event counting 
 SPDX-License-Identifier: GPL-2.0-only
  HiSilicon SoC HHA uncore Hardware event counters support
  Copyright (C) 2017 HiSilicon Limited
  Author: Shaokun Zhang <zhangshaokun@hisilicon.com>
          Anurup M <anurup.m@huawei.com>
  This code is based on the uncore PMUs like arm-cci and arm-ccn.
 HHA register definition 
  If the HW version only supports a 48-bit counter, then
  bits [63:48] are reserved, which are Read-As-Zero and
  Writes-Ignored.
 HHA PMU v1 has 16 counters and v2 only has 8 counters 
  Select the counter register offset using the counter index
  each counter is 48-bits.
 Read 64 bits and like L3C, top 16 bits are RAZ 
 Write 64 bits and like L3C, top 16 bits are WI 
	
	  Select the appropriate event select register(HHA_EVENT_TYPEx).
	  There are 4 event select registers for the 16 hardware counters.
	  Event code is 8-bits and for the first 4 hardware counters,
	  HHA_EVENT_TYPE0 is chosen. For the next 4 hardware counters,
	  HHA_EVENT_TYPE1 is chosen and so on.
 Write event code to HHA_EVENT_TYPEx register 
	
	  Set perf_enable bit in HHA_PERF_CTRL to start event
	  counting for all enabled counters.
	
	  Clear perf_enable bit in HHA_PERF_CTRL to stop event
	  counting for all enabled counters.
 Enable counter index in HHA_EVENT_CTRL register 
 Clear counter index in HHA_EVENT_CTRL register 
 Write 0 to enable interrupt 
 Write 1 to mask interrupt 
	
	  Use SCCL_ID and UID to identify the HHA PMU, while
	  SCCL_ID is in MPIDR[aff2].
	
	  Early versions of BIOS support _UID by mistake, so we support
	  both "hisilicon, idx-id" as preference, if available.
 HHA PMUs only share the same SCCL 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for BCM6358 memory-mapped LEDs, based on leds-syscon.c
  Copyright 2015 Álvaro Fernández Rojas <noltari@gmail.com>
  struct bcm6358_led - state container for bcm6358 based LEDs
  @cdev: LED class device for this LED
  @mem: memory resource
  @lock: memory lock
  @pin: LED pin number
  @active_low: LED is active low
 memory lock 
 SPDX-License-Identifier: GPL-2.0-only
  LP5521LP5523LP55231LP5562 Common Driver
  Copyright 2012 Texas Instruments
  Author: Milo(Woogyom) Kim <milo.kim@ti.com>
  Derived from leds-lp5521.c, leds-lp5523.c
 External clock rate 
 no error checking here because no ACK from the device after reset 
 handling firmware data is chip dependent 
 firmware should be released for other channel use 
 select the engine to be run 
 run or stop the selected engine 
 Keep enable down at least 1ms 
 500us abs min. 
	
	  Exact value is not available. 10 - 20ms
	  appears to be enough for reset.
 chip specific initialization 
 do not initialize channels that are not connected 
 setting led current at each channel 
 LP8501 specific 
 SPDX-License-Identifier: BSD-2-Clause OR GPL-2.0-or-later
  Dell Wyse 3020 a.k.a. "Ariel" Embedded Controller LED Driver
  Copyright (C) 2020 Lubomir Rintel
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2010, 2011, 2016 The Linux Foundation. All rights reserved.
 5 bits 
 4 bits 
 SPDX-License-Identifier: GPL-2.0-or-later
   MEN 14F021P00 Board Management Controller (BMC) LEDs Driver.
   This is the core LED driver of the MEN 14F021P00 BMC.
   There are four LEDs available which can be switched on and off.
   STATUS LED, HOT SWAP LED, USER LED 1, USER LED 2
   Copyright (C) 2014 MEN Mikro Elektronik Nuernberg GmbH
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2006 - Florian Fainelli <florian@openwrt.org>
  Control the Cobalt QubeRaQ front LED
 SPDX-License-Identifier: GPL-2.0
 Copyright 2015 Texas Instruments
 Copyright 2018 Sebastian Reichel
 Copyright 2018 Pavel Machek <pavel@ucw.cz>
 TI LMU LED common framework, based on previous work from
 Milo Kim <milo.kim@ti.com>
	
	  Brightness register update
	 
	  11 bit dimming: update LSB bits and write MSB byte.
	 		   MSB brightness should be shifted.
	   8 bit dimming: write MSB byte.
 Find an approximate index by looking up the table 
 SPDX-License-Identifier: GPL-2.0-only
 	LED driver for TI lp3952 controller
 	Copyright (C) 2016, DAQRI, LLC.
 	Author: Tony Makkiel <tony.makkiel@daqri.com>
  Using Imax to control brightness. There are 4 possible
  setting 25, 50, 75 and 100 % of Imax. Possible values are
  values 0-4. 0 meaning turn off.
 Enable the LED in case it is not enabled already 
 Disable any LEDs on from any previous conf. 
 enable rgb patter, loop 
 Update Bit 6 (Active mode), Select both Led sets, Bit [1:0] 
 Set Cmd1 for RGB intensity,cmd and transition time 
 SPDX-License-Identifier: GPL-2.0-only
  leds-lp3944.c - driver for National Semiconductor LP3944 Funlight Chip
  Copyright (C) 2009 Antonio Ospite <ospite@studenti.unina.it>
  I2C driver for National Semiconductor LP3944 Funlight Chip
  http:www.national.compfLPLP3944.html
  This helper chip can drive up to 8 leds, with two programmable DIM modes;
  it could even be used as a gpio expander but this driver assumes it is used
  as a led controller.
  The DIM modes are used to set _blink_ patterns for leds, the pattern is
  specified supplying two parameters:
    - period: from 0s to 1.6s
    - duty cycle: percentage of the period the led is on, from 0 to 100
  LP3944 can be found on Motorola A910 smartphone, where it drives the rgb
  leds, the camera flash light and the displays backlights.
 Read Only Registers 
 LEDs 0-7 InputRegister (Read Only) 
 None (Read Only) 
 Frequency Prescaler 0 (RW) 
 PWM Register 0 (RW) 
 Frequency Prescaler 1 (RW) 
 PWM Register 1 (RW) 
 LEDs 0-3 Selector (RW) 
 LEDs 4-7 Selector (RW) 
 These registers are not used to control leds in LP3944, they can store
  arbitrary values which the chip will ignore.
 period in ms 
 duty cycle is a percentage 
 Saved data 
  lp3944_dim_set_period() - Set the period for DIM status
  @client: the i2c client
  @dim: either LP3944_DIM0 or LP3944_DIM1
  @period: period of a blink, that is a onoff cycle, expressed in ms.
 Convert period to Prescaler value 
  lp3944_dim_set_dutycycle - Set the duty cycle for DIM status
  @client: the i2c client
  @dim: either LP3944_DIM0 or LP3944_DIM1
  @duty_cycle: percentage of a period during which a led is ON
 Convert duty cycle to PWM value 
  lp3944_led_set() - Set the led status
  @led: a lp3944_led_data structure
  @status: one of LP3944_LED_STATUS_OFF
                  LP3944_LED_STATUS_ON
                  LP3944_LED_STATUS_DIM0
                  LP3944_LED_STATUS_DIM1
	
	  Invert status only when it's < 2 (i.e. 0 or 1) which means it's
	  controlling the onoff state directly.
	  When, instead, status is >= 2 don't invert it because it would mean
	  to mess with the hardware blinking mode.
 set led status 
 units are in ms 
		 Special case: the leds subsystem requires a default user
		  friendly blink pattern for the LED.  Let's blink the led
		  slowly (1Hz).
 duty_cycle is the percentage of period during which the led is ON 
	 invert duty cycle for inverted leds, this has the same effect of
	  swapping delay_on and delay_off
	 NOTE: using always the first DIM mode, this means that all leds
	  will have the same blinking pattern.
	 
	  We could find a way later to have two leds blinking in hardware
	  with different patterns at the same time, falling back to software
	  control for the other ones.
 to expose the default value to userspace 
 Set the default led status 
 Let's see whether this adapter can support what we need. 
 lp3944 i2c driver struct 
 SPDX-License-Identifier: GPL-2.0-or-later
  Userspace driver for the LED subsystem
  Copyright (C) 2016 David Lechner <david@lechnology.com>
  Based on uinput.c: Aristeu Sergio Rozanski Filho <aris@cathedrallabs.org>
 SPDX-License-Identifier: GPL-2.0-only
 Simple driver for Texas Instruments LM355x LED Flash driver chip
 Copyright (C) 2012 Texas Instruments
 operation mode 
 register map info. 
 specific indicator function for lm3556 
 indicator pattern data only for lm3556 
 chip initialize 
 input and output pins configuration 
 chip control 
 brightness 0 means shutdown 
 operation mode control 
 torch 
 flash 
 indicator 
 indicator pattern only for lm3556
 module initialize 
 flash 
 torch 
 indicator 
 indicator pattern control only for LM3556 
 SPDX-License-Identifier: GPL-2.0-or-later
  leds-lm3533.c -- LM3533 LED driver
  Copyright (C) 2011-2012 Texas Instruments
  Author: Johan Hovold <jhovold@gmail.com>
 disable blink 
 Pattern generator defines (delays in us). 
 t_step = (t_max - t_min)  (v_max - v_min) 
 Delay limits for hardware accelerated blinking (in ms). 
  Returns linear map of t from [t_min,t_max] to [v_min,v_max] with a step
  size of t_step, where
 	t_step = (t_max - t_min)  (v_max - v_min)
  and updates t to reflect the mapped value.
  Returns time code corresponding to delay (in ms) and updates delay to
  reflect actual hardware delay.
  Hardware supports 256 discrete delay times, divided into three groups with
  the following ranges and step-sizes:
 	[   16,   999]	[0x00, 0x3e]	step  16 ms
 	[ 1130,  9781]	[0x3d, 0x7f]	step 131 ms
 	[10306, 76890]	[0x80, 0xff]	step 524 ms
  Note that delay group 3 is only available for delay_off.
  Set delay register base to delay (in ms) and update delay to reflect
  actual hardware delay used.
 Delay group 3 is only available for low time (delay off). 
  Pattern generator risefall times:
    0 - 2048 us (default)
    1 - 262 ms
    2 - 524 ms
    3 - 1.049 s
    4 - 2.097 s
    5 - 4.194 s
    6 - 8.389 s
    7 - 16.78 s
	 The class framework makes a callback to get brightness during
	  registration so use parent device (for error reporting) until
	  registered.
 disable blink 
 SPDX-License-Identifier: GPL-2.0-or-later
  LED Driver for Dialog DA9052 PMICs.
  Copyright(c) 2012 Dialog Semiconductor Ltd.
  Author: David Dajun Chen <dchen@diasemi.com>
 SPDX-License-Identifier: GPL-2.0-only
  LED Class Core
  Copyright (C) 2005 John Lenz <lenz@cs.wisc.edu>
  Copyright (C) 2005-2007 Richard Purdie <rpurdie@openedhand.com>
 no lock needed for this 
  led_classdev_suspend - suspend an led_classdev.
  @led_cdev: the led_classdev to suspend.
  led_classdev_resume - resume an led_classdev.
  @led_cdev: the led_classdev to resume.
  of_led_get() - request a LED device via the LED framework
  @np: device node to get the LED device from
  @index: the index of the LED
  Returns the LED device parsed from the phandle specified in the "leds"
  property of a device tree node or a negative error-code on failure.
  led_put() - release a LED device
  @led_cdev: LED device
  devm_of_led_get - Resource-managed request of a LED device
  @dev:	LED consumer
  @index:	index of the LED to obtain in the consumer
  The device node of the device is parse to find the request LED device.
  The LED device returned from this function is automatically released
  on driver detach.
  @return a pointer to a LED device or ERR_PTR(errno) on failure.
  led_classdev_register_ext - register a new object of led_classdev class
 			       with init data.
  @parent: parent of LED device
  @led_cdev: the led_classdev structure for this device.
  @init_data: LED class device initialization data
 add to the list of leds 
  led_classdev_unregister - unregisters a object of led_properties class.
  @led_cdev: the led device to unregister
  Unregisters a previously registered via led_classdev_register object.
 Stop blinking 
  devm_led_classdev_register_ext - resource managed led_classdev_register_ext()
  @parent: parent of LED device
  @led_cdev: the led_classdev structure for this device.
  @init_data: LED class device initialization data
  devm_led_classdev_unregister() - resource managed led_classdev_unregister()
  @dev: The device to unregister.
  @led_cdev: the led_classdev structure for this device.
 SPDX-License-Identifier: GPL-2.0-only
  LP5562 LED driver
  Copyright (C) 2013 Texas Instruments
  Author: Milo(Woogyom) Kim <milo.kim@ti.com>
 ENABLE Register 00h 
 Chip master enable 
 Logarithmic PWM adjustment 
 OPMODE Register 01h 
 BRIGHTNESS Registers 
 CURRENT Registers 
 CONFIG Register 08h 
 Internal clock 
 RESET Register 0Dh 
 PROGRAM ENGINE Registers 
 LEDMAP Register 70h 
 R:ENG1, G:ENG2, B:ENG3 
 W:ENG1 
 W:ENG2 
 W:ENG3 
 Program Commands 
 operation mode change needs to be longer than 153 us 
 it takes more 488 us to update ENABLE register 
 stop engine 
	
	  To run the engine,
	  operation mode and enable register should updated at the same time
 change operation mode to RUN only when each engine is loading 
 clear program memory before updating 
 separate sscanfs because length is working only for %s 
 Each instruction is 16bit long. Check that length is even 
	
	  the firmware is encoded in ascii hex character, with 2 chars
	  per byte
	
	  Program memory sequence
	   1) set engine mode to "LOAD"
	   2) write firmware data into program memory
 Set all PWMs to direct control mode 
 Update configuration for the clock setting 
 Initialize all channels PWM to zero -> leds off 
 Set LED map as register PWM by default 
 check the size of program count 
 Set LED map as RGB 
 Load engines 
 Clear program registers 
 Program engines 
 Run engines 
	 LED map
	  R ... Engine 1 (fixed)
	  G ... Engine 2 (fixed)
	  B ... Engine 3 (fixed)
	  W ... Engine 1 or 2 or 3
 Chip specific configurations 
 SPDX-License-Identifier: GPL-2.0-only
  LEDs driver for Soekris net48xx
  Copyright (C) 2006 Chris Boot <bootc@bootc.net>
  Based on leds-ams-delta.c
 small hack, but scx200_gpio doesn't set .dev if the probe fails 
 SPDX-License-Identifier: GPL-2.0-only
  leds-max8997.c - LED class driver for MAX8997 LEDs.
  Copyright (C) 2011 Samsung Electronics
  Donggeun Kim <dg77.kim@samsung.com>
 initialize mode and brightness according to platform_data 
 SPDX-License-Identifier: GPL-2.0-only
 driversledsleds-s3c24xx.c
  (c) 2006 Simtec Electronics
 	http:armlinux.simtec.co.uk
 	Ben Dooks <ben@simtec.co.uk>
  S3C24XX - LEDs GPIO driver
 our context 
 Default to off 
 register our new led device 
 SPDX-License-Identifier: GPL-2.0-only
  LEDs driver for the "User LED" on Routerboard532
  Copyright (C) 2009 Phil Sutter <n0-1@freewrt.org>
  Based on leds-cobalt-qube.c by Florian Fainelly and
  rb-diag.c (my own standalone driver for both LED and
  button of Routerboard532).
 SPDX-License-Identifier: GPL-2.0-or-later
   LEDs driver for the Cobalt Raq series.
   Copyright (C) 2007  Yoichi Yuasa <yuasa@linux-mips.org>
 SPDX-License-Identifier: GPL-2.0-only
   Copyright (C) 2011 Paul Parsons <lost.distance@yahoo.com>
 	The HTC ASIC3 LED GPIOs are inputs, not outputs.
 	Hence we turn the LEDs onoff via the TimeBase register.
 	When TimeBase is 4 the clock resolution is about 32Hz.
 	This driver supports hardware blinking with an on+off
 	period from 62ms (2 clocks) to 125s (4000 clocks).
 Fits into 12-bit Time registers 
 If both are zero then a sensible default should be chosen 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2014 Belkin Inc.
  Copyright 2015 Andrew Lunn <andrew@lunn.ch>
 LED Driver Output State, determine the source that drives LED outputs 
 Output LOW 
 Output HI-Z 
 Dimming 
 Blinking 
 SPDX-License-Identifier: GPL-2.0-only
  struct clevo_mail_led_dmi_table - List of known good models
  Contains the known good models this driver is compatible with.
  When adding a new model try to be as strict as possible. This
  makes it possible to keep the false positives (the model is
  detected as working, but in reality it is not) as low as
  possible.
 ms  && delay_off == 0 
		 Special case: the leds subsystem requested us to
		  chose one user friendly blinking of the LED, and
		  start it. Let's blink the led slowly (0.5Hz).
 ms 
 ms 
 ms  && delay_off == 500 
 blink the led with 1Hz 
 ms  && delay_off == 1000 
 blink the led with 0.5Hz 
 Check with the help of DMI if we are running on supported hardware 
sourceforge.netprojectsclevo-mailled\n");
 SPDX-License-Identifier: GPL-2.0-only
  LEDs driver for GPIOs
  Copyright (C) 2007 8D Technologies inc.
  Raphael Assenat <raph@8d.com>
  Copyright (C) 2008 Freescale Semiconductor, Inc.
		
		  Acquire gpiod from DT with uninitialized label, which
		  will be updated after LED class device is registered,
		  Only then the final LED name is known.
 Set gpiod label to match the corresponding LED name. 
	
	  This means the LED does not come from the device tree
	  or ACPI, so let's try just getting it by index from the
	  device, this will hit the board file, if any and get
	  the GPIO from there.
	
	  This is the legacy code path for platform code that
	  still uses GPIO numbers. Ultimately we would like to get
	  rid of this block completely.
 skip leds that aren't available 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2015-16 Golden Delicious Computers
  Author: Nikolaus Schaller <hns@goldelico.com>
  LED driver for the IS31FL319{0,1,3,6,9} to drive 1, 3, 6 or 9 light
  effect LEDs.
 register numbers 
 CS (Current Setting) in CONFIG2 register 
 Audio gain in CONFIG2 register 
  regmap is used as a cache of chip's register space,
  to avoid reading back brightness values from chip,
  which is known to hang.
 update PWM register 
 read current brightness of all PWM channels 
		
		  since neither cdev nor the chip can provide
		  the current setting, we read from the regmap cache
 0..2 => bit 0..2 
 3..5 => bit 4..6 
 6..8 => bit 0..2 
 update PWMs 
 enable chip from shut down 
 shut down (no need to clear CTRL12) 
 is optional 
 not supported 
 we have no readable registers 
 volatile registers are not cached 
 always write-through 
 round down to nearest supported value (range check done by caller) 
 CS encoding 
 round down to nearest supported value (range check done by caller) 
 check for write-reply from chip (we can't read any registers) 
 does not answer 
	
	  Kernel conventions require per-LED led-max-microamp property.
	  But the chip does not allow to limit individual LEDs.
	  So we take minimum from all subnodes for safety of hardware.
  i2c-core (and modalias) requires that id_table be properly filled,
  even though it is not used for DeviceTree based instantiation.
 SPDX-License-Identifier: GPL-2.0-only
  LED Driver for the Freecom FSG-3
  Copyright (c) 2008 Rod Whitby <rod@whitby.id.au>
  Author: Rod Whitby <rod@whitby.id.au>
  Based on leds-spitz.c
  Copyright 2005-2006 Openedhand Ltd.
  Author: Richard Purdie <rpurdie@openedhand.com>
 Map the LED chip select address space 
 SPDX-License-Identifier: GPL-2.0-only
  pca9532.c - 16-bit Led dimmer
  Copyright (C) 2011 Jan Weitzel
  Copyright (C) 2008 Riku Voipio
  Datasheet: http:www.nxp.comdocumentsdata_sheetPCA9532.pdf
 m =  num_leds
 We have two pwmblinkers, but 16 possible leds to drive. Additionally,
  the clever Thecus people are using one pwm to drive the beeper. So,
  as a compromise we average one pwm to the values requested by all
  leds that are not ONOFF.
 Set LED routing 
 zero led bits 
 set the new value 
 Thecus: hardcode one pwm 
 led subsystem ask us for a blink rate 
 Thecus specific: only use PSCPWM 0 
 XXX: allow different kind of beeps with pscpwm modifications 
 To use as input ensure pin is not driven 
 CONFIG_LEDS_PCA9532_GPIO 
 Use data->gpio.dev as a flag for freeing gpiochip 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2008
  Guennadi Liakhovetski, DENX Software Engineering, <lg@denx.de>
  LED driver for the DAC124S085 SPI DAC
  driversledsleds-mlxcpld.c
  Copyright (c) 2016 Mellanox Technologies. All rights reserved.
  Copyright (c) 2016 Vadim Pasternak <vadimp@mellanox.com>
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation andor other materials provided with the distribution.
  3. Neither the names of the copyright holders nor the names of its
     contributors may be used to endorse or promote products derived from
     this software without specific prior written permission.
  Alternatively, this software may be distributed under the terms of the
  GNU General Public License ("GPL") version 2 as published by the Free
  Software Foundation.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
 LPC bus access 
 Color codes for LEDs 
 Offset from solid: 3Hz blink 
 Offset from solid: 6Hz blink 
 Off 
 Solid red 
 Solid green 
 ~167 msec offon 
 ~83 msec offon 
  struct mlxcpld_param - LED access parameters:
  @offset: offset for LED access in CPLD device
  @mask: mask for LED access in CPLD device
  @base_color: base color code for LED
  struct mlxcpld_led_priv - LED private data:
  @cled: LED class device instance
  @param: LED CPLD access parameters
  struct mlxcpld_led_profile - system LED profile (defined per system class):
  @offset: offset for LED access in CPLD device
  @mask: mask for LED access in CPLD device
  @base_color: base color code
  @brightness: default brightness setting (onoff)
  @name: LED name
  struct mlxcpld_led_pdata - system LED private data
  @pdev: platform device pointer
  @pled: LED class device instance
  @profile: system configuration profile
  @num_led_instances: number of LED instances
  @lock: device access lock
 Default profile fit the next Mellanox systems:
  "msx6710", "msx6720", "msb7700", "msn2700", "msx1410",
  "msn2410", "msb7800", "msn2740"
 Profile fit the Mellanox systems based on "msn2100" 
	
	  Each LED is controlled through low or high nibble of the relevant
	  CPLD register. Register offset is specified by off parameter.
	  Parameter vset provides color code: 0x0 for off, 0x5 for solid red,
	  0x6 for 3Hz blink red, 0xd for solid green, 0xe for 3Hz blink
	  green.
	  Parameter mask specifies which nibble is used for specific LED: mask
	  0xf0 - lower nibble is to be used (bits from 0 to 3), mask 0x0f -
	  higher nibble (bits from 4 to 7).
	
	  HW supports two types of blinking: full (6Hz) and half (3Hz).
	  For delay onoff zero default setting 3Hz is used.
 SPDX-License-Identifier: GPL-2.0-only
  LED Class Core
  Copyright 2005-2006 Openedhand Ltd.
  Author: Richard Purdie <rpurdie@openedhand.com>
 Time to switch the LED on. 
		 Store the current brightness value to be able
		  to restore it when the delay_off period is over.
	 Return in next iteration if led is in one-shot mode and we are in
	  the final blink state so that the led is toggled each delay_on +
	  delay_off milliseconds in worst case.
 LED HW might have been unplugged, therefore don't warn 
 never on - just set to off 
 never off - just set to brightness 
 blink with 1 Hz as default if nothing specified 
	
	  If software blink is active, delay brightness setting
	  until the next timer tick.
		
		  If we need to disable soft blinking delegate this to the
		  work queue task to avoid problems in case we are called
		  from hard irq context.
 Use brightness_set op if available, it is guaranteed not to sleep 
 If brightness setting can sleep, delegate it to a work queue task 
 Caller must ensure led_cdev->led_access held 
 Caller must ensure led_cdev->led_access held 
	 We want to label LEDs that can produce full range of colors
		
		  If init_data.devicename is NULL, then it indicates that
		  DT label should be used as-is for LED class device name.
		  Otherwise the label is prepended with devicename to compose
		  the final LED class device name.
 SPDX-License-Identifier: GPL-2.0-or-later
  LED driver for Mediatek MT6323 PMIC
  Copyright (C) 2017 Sean Wang <sean.wang@mediatek.com>
  Register field for MT6323_TOP_CKPDN0 to enable
  32K clock common for LED device.
  Register field for MT6323_TOP_CKPDN2 to enable
  individual clock for LED device.
  Register field for MT6323_TOP_CKCON1 to select
  clock source.
  Register for MT6323_ISINK_CON0 to setup the
  duty cycle of the blink.
 Register to setup the period of the blink. 
 Register to control the brightness. 
 Register to LED channel enablement. 
  struct mt6323_led - state container for the LED device
  @id:			the identifier in MT6323 LED device
  @parent:		the pointer to MT6323 LED controller
  @cdev:		LED class device for this LED device
  @current_brightness: current state of the LED device
  struct mt6323_leds -	state container for holding LED controller
 			of the driver
  @dev:		the device pointer
  @hw:			the underlying hardware providing shared
 			bus for the register operations
  @lock:		the lock among process context
  @led:		the array that contains the state of individual
 			LED device
 protect among process context 
	
	  Setup current output for the corresponding
	  brightness level.
	
	  Setup required clock source, enable the corresponding
	  clock and channel and let work with continuous blink as
	  the default.
	
	  LED subsystem requires a default user
	  friendly blink pattern for the LED so using
	  1Hz duty cycle 50% here if without specific
	  value delay_on and delay off being assigned.
	
	  Units are in ms, if over the hardware able
	  to support, fallback into software blink
	
	  Calculate duty_hw based on the percentage of period during
	  which the led is ON.
 hardware doesn't support zero duty cycle. 
	
	  Set max_brightness as the software blink behavior
	  when no blink brightness.
	
	  leds->hw points to the underlying bus for the register
	  controlled.
 Turn the LEDs off on driver removal. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018 Spreadtrum Communications Inc.
 PMIC global control register definition 
 Breathing light controller register definition 
 Stage duration step, in milliseconds 
 Minimum and maximum duration, in milliseconds 
 Reset the rise, high, fall and low time to zero. 
	
	  Must contain 4 tuples to configure the rise time, high time, fall
	  time and low time to enable the breathing mode.
 Enable the LED breathing mode 
 SPDX-License-Identifier: GPL-2.0-or-later
  LEDs driver for Analog Devices ADP5520ADP5501 MFD PMICs
  Copyright 2009 Analog Devices Inc.
  Loosely derived from leds-da903x:
  Copyright (C) 2008 Compulab, Ltd.
 	Mike Rapoport <mike@compulab.co.il>
  Copyright (C) 2006-2008 Marvell International Ltd.
 	Eric Miao <eric.miao@marvell.com>
 SPDX-License-Identifier: GPL-2.0-only
  LEDs driver for Dialog Semiconductor DA9030DA9034
  Copyright (C) 2008 Compulab, Ltd.
 	Mike Rapoport <mike@compulab.co.il>
  Copyright (C) 2006-2008 Marvell International Ltd.
 	Eric Miao <eric.miao@marvell.com>
 Vibrator Control 
 EN bit 
 PWM<2:0> 
 EN bit 
 SPDX-License-Identifier: GPL-2.0-only
  leds-bd2802.c - RGB LED Driver
  Copyright (C) 2009 Samsung Electronics
  Kim Kyuwon <q1.kim@samsung.com>
  Datasheet: http:www.rohm.comproductsdatabookdriverpdfbd2802gu-e.pdf
 3.2mA 
 0.0mA 
  State '0' : 'off'
  State '1' : 'blink'
  State '2' : 'on'.
	
	  Making led_classdev as array is not recommended, because array
	  members prevent using 'container_of' macro. So repetitive works
	  are needed.
	
	  Advanced Configuration Function(ADF) mode:
	  In ADF mode, user can set registers of BD2802GU directly,
	  therefore BD2802GU doesn't enter reset state.
 General attributes of RGB LEDs 
--------------------------------------------------------------
	BD2802GU helper functions					
--------------------------------------------------------------
--------------------------------------------------------------
	BD2802GU core functions					
--------------------------------------------------------------
	
	  In this case, other led is turned on, and current led is turned
	  off. So set RGB LED Control register to stop the current RGB LED
	
	  Configure RESET GPIO (L: RESET, H: RESET cancel)
	 
	  We request the reset GPIO as OUT_LOW which means de-asserted,
	  board files specifying this GPIO line in a machine descriptor
	  table should take care to specify GPIO_ACTIVE_LOW for this line.
 Tacss = min 0.1ms 
 Detect BD2802GU 
 To save the power, reset BD2802 after detecting 
 Default attributes 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (c) 2017 Sebastian Reichel <sre@kernel.org>
 aux display light 
 camera privacy led 
 5 bit 
 4 bit 
 Avoid HW issue by turning off current before duty cycle 
 SPDX-License-Identifier: GPL-2.0+
		
		  There is no separate controls which can disable LEDs
		  individually, there is only RESET_LEDS command that turns
		  off both LEDs.
		 
		  RESET_LEDS turns off both LEDs, thus restore other LED if
		  it's turned ON.
 reset and turn off LEDs 
 SPDX-License-Identifier: GPL-2.0+
 Driver for Awinic AW2013 3-channel LED driver
 Reset and ID register 
 Global control register 
 LED channel enable register 
 LED channel control registers 
 Should be 0-3
 LED channel PWM registers 
 LED channel timing registers 
 Should be 0-7
 Should be 0-5
 Should be 0-7
 Should be 0-7
 Should be 0-8
 Should be 0-15
 ms 
 held when writing to registers 
 If no blink specified, default to 1 Hz. 
 Never on - just set to off 
 Never off - brightness is already set, disable blinking 
 Convert into values the HW will understand. 
 Set timings 
 Finally, enable the LED 
 5mA
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
  TI LP8501 9 channel LED Driver
  Copyright (C) 2013 Texas Instruments
  Author: Milo(Woogyom) Kim <milo.kim@ti.com>
 Registers 
 Chip startup time is 500 us, 1 - 2 ms gives some margin 
 Power selection for each output 
 stop engine 
	
	  To run the engine,
	  operation mode and enable register should updated at the same time
 change operation mode to RUN only when each engine is loading 
 clear program memory before updating 
 separate sscanfs because length is working only for %s 
 Each instruction is 16bit long. Check that length is even 
	
	  Program memory sequence
	   1) set engine mode to "LOAD"
	   2) write firmware data into program memory
 Chip specific configurations 
  Bachmann ot200 leds driver.
  Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
          Christian Gmeiner <christian.gmeiner@gmail.com>
  License: GPL as published by the FSF.
  The device has three leds on the back panel (led_err, led_init and led_run)
  and can handle up to seven leds on the front panel.
  we need to store the current led states, as it is not
  possible to read the current led state via inb().
 turn off all front leds 
 turn on init led 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2019 Sven Van Asbroeck
 This instance is not set for torch mode so bail out 
 fwnodedevicetree is optional. NULL is allowed for priv->fwnode 
 SPDX-License-Identifier: GPL-2.0-only
  lp5523.c - LP5523, LP55231 LED Driver
  Copyright (C) 2010 Nokia Corporation
  Copyright (C) 2012 Texas Instruments
  Contact: Samu Onkalo <samu.p.onkalo@nokia.com>
           Milo(Woogyom) Kim <milo.kim@ti.com>
 bytes 
 Memory is used like this:
  0x00 engine 1 program
  0x10 engine 2 program
  0x20 engine 3 program
  0x30 engine 1 muxing info
  0x40 engine 2 muxing info
  0x50 engine 3 muxing info
 Registers 
 Bit description in registers 
 Memory Page Selection 
 Program Memory Operations 
 Operation Mode Register 
 Enable Register 
 Chip startup time is 500 us, 1 - 2 ms gives some margin 
 turn on all leds 
 stop engine 
	
	  To run the engine,
	  operation mode and enable register should updated at the same time
 change operation mode to RUN only when each engine is loading 
 one pattern per engine setting LED MUX start and stop addresses 
 hardcode 32 bytes of memory for each engine from program memory 
 write LED MUX address space for each engine 
 Let the programs run for couple of ms and check the engine status 
 separate sscanfs because length is working only for %s 
 Each instruction is 16bit long. Check that length is even 
	
	  Program memory sequence
	   1) set engine mode to "LOAD"
	   2) write firmware data into program memory
 Check that ext clock is really in use if requested 
 Measure VDD (i.e. VBAT) first (channel 16 corresponds to VDD) 
 ADC conversion time is typically 2.7 ms 
 Was not ready. Wait little bit 
 There may be some fluctuation in measurement 
 Skip non-existing channels 
 Set default current 
 let current stabilize 2 - 4ms before measurements start 
 ADC conversion time is 2.7 ms typically 
 Was not ready. Wait. 
 Restore current 
 Chip specific configurations 
 SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
 Copyright (c) 2018 Mellanox Technologies. All rights reserved.
 Copyright (c) 2018 Vadim Pasternak <vadimp@mellanox.com>
 Codes for LEDs. 
 Offset from solid: 3Hz blink 
 Offset from solid: 6Hz blink 
 Off 
 Solid red 
 Solid green 
 Solid amber 
 ~167 msec offon - HW support 
 ~83 msec offon - HW support 
 Clear mask 
  struct mlxreg_led_data - led control data:
  @data: led configuration data;
  @led_cdev: led class data;
  @base_color: base led color (other colors have constant offset from base);
  @led_data: led data;
  @data_parent: pointer to private device control data of parent;
  @led_cdev_name: class device name
  struct mlxreg_led_priv_data - platform private data:
  @pdev: platform device;
  @pdata: platform data;
  @access_lock: mutex for attribute IO access;
 protect IO operations 
	
	  Each LED is controlled through low or high nibble of the relevant
	  register byte. Register offset is specified by off parameter.
	  Parameter vset provides color code: 0x0 for off, 0x5 for solid red,
	  0x6 for 3Hz blink red, 0xd for solid green, 0xe for 3Hz blink
	  green.
	  Parameter mask specifies which nibble is used for specific LED: mask
	  0xf0 - lower nibble is to be used (bits from 0 to 3), mask 0x0f -
	  higher nibble (bits from 4 to 7).
	
	  Each LED is controlled through low or high nibble of the relevant
	  register byte. Register offset is specified by off parameter.
	  Parameter vset provides color code: 0x0 for off, 0x5 for solid red,
	  0x6 for 3Hz blink red, 0xd for solid green, 0xe for 3Hz blink
	  green.
	  Parameter mask specifies which nibble is used for specific LED: mask
	  0xf0 - lower nibble is to be used (bits from 0 to 3), mask 0x0f -
	  higher nibble (bits from 4 to 7).
 Assume the LED is OFF 
	
	  HW supports two types of blinking: full (6Hz) and half (3Hz).
	  For delay onoff zero LED is setting to solid color. For others
	  combination blinking is to be controlled by the software timer.
			
			  Field "bit" can contain one capability bit in 0 byte
			  and offset bit in 1-3 bytes. Clear capability bit and
			  keep only offset bit.
 SPDX-License-Identifier: GPL-2.0
 TI LM3532 LED driver
 Copyright (C) 2019 Texas Instruments Incorporated - https:
 https:
 Control Enable 
 PWM Zone Control 
 Brightness Configuration 
 Zone Boundary Register 
  struct lm3532_als_data
  @config: value of ALS configuration register
  @als1_imp_sel: value of ALS1 resistor select register
  @als2_imp_sel: value of ALS2 resistor select register
  @als_avrg_time: ALS averaging time
  @als_input_mode: ALS input mode for brightness control
  @als_vmin: Minimum ALS voltage
  @als_vmax: Maximum ALS voltage
  @zone_lo: values of ALS lo ZB(Zone Boundary) registers
  @zone_hi: values of ALS hi ZB(Zone Boundary) registers
  struct lm3532_led
  @led_dev: led class device
  @priv: Pointer the device data structure
  @control_bank: Control bank the LED is associated to
  @mode: Mode of the LED string
  @ctrl_brt_pointer: Zone target register that controls the sink
  @num_leds: Number of LED strings are supported in this array
  @full_scale_current: The full-scale current setting for the current sink.
  @led_strings: The LED strings supported in this array
  @enabled: Enabled status
  struct lm3532_data
  @enable_gpio: Hardware enable gpio
  @regulator: regulator
  @client: i2c client
  @regmap: Devices register map
  @dev: Pointer to the devices device struct
  @lock: Lock for readingwriting the device
  @als_data: Pointer to the als data struct
  @runtime_ramp_up: Runtime ramp up setting
  @runtime_ramp_down: Runtime ramp down setting
  @leds: Array of LED strings
 Find an approximate index by looking up the table 
 Find an approximate index by looking up the table 
 Caller must take care of locking 
 Caller must take care of locking 
	
	  This could be hard coded to the default value but the control
	  brightness register may have changed during boot.
 SPDX-License-Identifier: GPL-2.0-only
  LED driver for WM831x status LEDs
  Copyright(C) 2009 Wolfson Microelectronics PLC.
 Control register 
 Control register value 
 Pick some defaults if we've not been given times 
	 We only have a limited selection of settings, see if we can
 Actually 62.5ms 
	 We cache the configuration register and read startup values
	 Set a default source if configured, otherwise leave the
	  current hardware setting.
 SPDX-License-Identifier: GPL-2.0
 LED Multicolor class interface
 Copyright (C) 2019-20 Texas Instruments Incorporated - http:
 Author: Dan Murphy <dmurphy@ti.com>
 SPDX-License-Identifier: GPL-2.0-only
  LED driver for WM8350 driven LEDS.
  Copyright(C) 2007, 2008 Wolfson Microelectronics PLC.
 Microamps 
	 This scales linearly into the index of valid current
	  settings which results in a linear scaling of perceived
	  brightness due to the non-linear current settings provided
	  by the hardware.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Crane Merchandising Systems. All rights reserved.
 Copyright (C) 2019 Oleh Kravchenko <oleg@kaa.org.ua>
  EL15203000 SPI protocol description:
  +-----+---------+
  | LED | COMMAND |
  +-----+---------+
  |  1  |    1    |
  +-----+---------+
  () LEDs MCU board expects 20 msec delay per byte.
  LEDs:
  +----------+--------------+-------------------------------------------+
  |    ID    |     NAME     |         DESCRIPTION                       |
  +----------+--------------+-------------------------------------------+
  | 'P' 0x50 |     Pipe     | Consists from 5 LEDs, controlled by board |
  +----------+--------------+-------------------------------------------+
  | 'S' 0x53 | Screen frame | Light tube around the screen              |
  +----------+--------------+-------------------------------------------+
  | 'V' 0x56 | Vending area | Highlights a cup of coffee                |
  +----------+--------------+-------------------------------------------+
  COMMAND:
  +----------+-----------------+--------------+--------------+
  |  VALUES  |       PIPE      | SCREEN FRAME | VENDING AREA |
  +----------+-----------------+--------------+--------------+
  | '0' 0x30 |                      Off                      |
  +----------+-----------------------------------------------+
  | '1' 0x31 |                      On                       |
  +----------+-----------------+--------------+--------------+
  | '2' 0x32 |     Cascade     |   Breathing  |
  +----------+-----------------+--------------+
  | '3' 0x33 | Inverse cascade |
  +----------+-----------------+
  | '4' 0x34 |     Bounce      |
  +----------+-----------------+
  | '5' 0x35 | Inverse bounce  |
  +----------+-----------------+
 EL15203000 default settings 
 for all LEDs 
 for Screen LED 
 for Pipe LED 
 to avoid SPI mistiming with firmware we should wait some time 
 SPDX-License-Identifier: GPL-2.0-only
  Driver for ISSI IS31FL32xx family of I2C LED controllers
  Copyright 2015 Allworx Corp.
  Datasheets:
    http:www.issi.comUSproduct-analog-fxled-driver.shtml
    http:www.si-en.comproduct.asp?parentid=890
 Used to indicate a device has no such register 
 Software Shutdown bit in Shutdown Register 
 IS31FL3216 has a number of unique registers 
 Software Shutdown bit in 3216 Config Register 
 1-based, max priv->cdef->channels 
  struct is31fl32xx_chipdef - chip-specific attributes
  @channels            : Number of LED channels
  @shutdown_reg        : address of Shutdown register (optional)
  @pwm_update_reg      : address of PWM Update register
  @global_control_reg  : address of Global Control register (optional)
  @reset_reg           : address of Reset register (optional)
  @pwm_register_base   : address of first PWM register
  @pwm_registers_reversed: : true if PWM registers count down instead of up
  @led_control_register_base : address of first LED control register (optional)
  @enable_bits_per_led_control_register: number of LEDs enable bits in each
  @reset_func          : pointer to reset function
  @sw_shutdown_func    : pointer to software shutdown function
  For all optional register addresses, the sentinel value %IS31FL32XX_REG_NONE
  indicates that this chip has no such register.
  If non-NULL, @reset_func will be called during probing to set all
  necessary registers to a known initialization state. This is needed
  for chips that do not have a @reset_reg.
  @enable_bits_per_led_control_register must be >=1 if
  @led_control_register_base != %IS31FL32XX_REG_NONE.
  Custom reset function for IS31FL3216 because it does not have a RESET
  register the way that the other IS31FL32xx chips do. We don't bother
  writing the GPIO and animation registers, because the registers we
  do write ensure those will have no effect.
  Custom Software-Shutdown function for IS31FL3216 because it does not have
  a SHUTDOWN register the way that the other IS31FL32xx chips do.
  We don't bother doing a readmodifywrite on the CONFIG register because
  we only ever use a value of '0' for the other fields in that register.
  NOTE: A mutex is not needed in this function because:
  - All referenced data is read-only after probe()
  - The I2C core has a mutex on to protect the bus
  - There are no readmodifywrite operations
  - Intervening operations between the write of the PWM register
    and the Update register are harmless.
  Example:
 	PWM_REG_1 write 16
 	UPDATE_REG write 0
 	PWM_REG_2 write 128
 	UPDATE_REG write 0
    vs:
 	PWM_REG_1 write 16
 	PWM_REG_2 write 128
 	UPDATE_REG write 0
 	UPDATE_REG write 0
  are equivalent. Poking the Update register merely applies all PWM
  register writes up to that point.
 NOTE: led_data->channel is 1-based 
	
	  Set enable bit for all channels.
	  We will control state with PWM registers alone.
 Detect if channel is already in use by another child 
  i2c-core (and modalias) requires that id_table be properly filled,
  even though it is not used for DeviceTree based instantiation.
 SPDX-License-Identifier: GPL-2.0-only
  LED Triggers Core
  For the HP Jornada 620660680690 handhelds
  Copyright 2008 Kristoffer Ericson <kristoffer.ericson@gmail.com>
      this driver is based on leds-spitz.c by Richard Purdie.
 SPDX-License-Identifier: GPL-2.0-only
  leds-tca6507
  The TCA6507 is a programmable LED controller that can drive 7
  separate lines either by holding them low, or by pulsing them
  with modulated width.
  The modulation can be varied in a simple pattern to produce a
  blink or double-blink.
  This driver can configure each line either as a 'GPIO' which is
  out-only (pull-up resistor required) or as an LED with variable
  brightness and hardware-assisted blinking.
  Apart from OFF and ON there are three programmable brightness
  levels which can be programmed from 0 to 15 and indicate how many
  500usec intervals in each 8msec that the led is 'on'.  The levels
  are named MASTER, BANK0 and BANK1.
  There are two different blink rates that can be programmed, each
  with separate time for rise, on, fall, off and second-off.  Thus if
  3 or more different non-trivial rates are required, software must
  be used for the extra rates. The two different blink rates must
  align with the two levels BANK0 and BANK1.  This driver does not
  support double-blink so 'second-off' always matches 'off'.
  Only 16 different times can be programmed in a roughly logarithmic
  scale from 64ms to 16320ms.  To be precise the possible times are:
     0, 64, 128, 192, 256, 384, 512, 768,
     1024, 1536, 2048, 3072, 4096, 5760, 8128, 16320
  Times that cannot be closely matched with these must be handled in
  software.  This driver allows 12.5% error in matching.
  This driver does not allow risefall rates to be set explicitly.
  When trying to match a given 'on' or 'off' period, an appropriate
  pair of 'change' and 'hold' times are chosen to get a close match.
  If the target delay is even, the 'change' number will be the
  smaller; if odd, the 'hold' number will be the smaller.
  Choosing pairs of delays with 12.5% errors allows us to match
  delays in the ranges: 56-72, 112-144, 168-216, 224-27504,
  28560-36720.
  26% of the achievable sums can be matched by multiple pairings.
  For example 1536 == 1536+0, 1024+512, or 768+768.
  This driver will always choose the pairing with the least
  maximum - 768+768 in this case.  Other pairings are not available.
  Access to the 3 levels and 2 blinks are on a first-come,
  first-served basis.  Access can be shared by multiple leds if they
  have the same level and either same blink rates, or some don't
  blink.  When a led changes, it relinquishes access and tries again,
  so it might lose access to hardware blink.
  If a blink engine cannot be allocated, software blink is used.  If
  the desired brightness cannot be allocated, the closest available
  non-zero brightness is used.  As 'full' is always available, the
  worst case would be to have two different blink rates at '1', with
  Max at '2', then other leds will have to choose between '2' and
  '16'.  Hopefully this is not likely.
  Each bank (BANK0 and BANK1) has two usage counts - LEDs using the
  brightness and LEDs using the blink.  It can only be reprogrammed
  when the appropriate counter is zero.  The MASTER level has a
  single usage count.
  Each LED has programmable 'on' and 'off' time as milliseconds.
  With each there is a flag saying if it was explicitly requested or
  defaulted.  Similarly the banks know if each time was explicit or a
  default.  Defaults are permitted to be changed freely - they are
  not recognised when matching.
 LED select registers determine the source that drives LED outputs 
 Output HI-Z (off) 
 Output HI-Z (off) - not used 
 Output LOW with Bank0 rate 
 Output LOW with Bank1 rate 
 Output LOW (on) 
 Output LOW with Master Intensity 
 Blink at Bank0 rate 
 Blink at Bank1 rate 
 PWM registers 
  0x00, 0x01, 0x02 encode the TCA6507_LS_ values, each output
  owns one bit in each register
 Convert an led.brightness level (0..255) to a TCA6507 level (0..15) 
 ...and convert back 
	int			reg_set;	 One bit per register where
						  a '1' means the register
 Bank 2 is Master Intensity and doesn't use times 
 Bank used, or -1 
 Set if hardware-blinking 
	
	  Choose two timecodes which add to 'msec' as near as
	  possible.  The first returned is the 'on' or 'off' time.
	  The second is to be used as a 'fade-on' or 'fade-off' time.
	  If 'msec' is even, the first will not be smaller than the
	  second.  If 'msec' is odd, the first will not be larger
	  than the second.
	  If we cannot get a sum within 18 of 'msec' fail with
	  -EINVAL, otherwise return the sum that was achieved, plus 1
	  if the first is smaller.
	  If two possibilities are equally good (e.g. 512+0,
	  256+256), choose the first pair so there is more
	  change-time visible (i.e. it is softer).
	 We start at '1' to ensure we never even think of choosing a
	  total time of '0'.
 This works! 
 Best yet 
 No close match 
  Update the register file with the appropriate 3-bit state for the
  given led.
 Update the register file with the appropriate 4-bit code for one
  bank or other.  This can be used for timers, for levels, or for
  initialization.
 Update brightness level. 
 Record all relevant time codes for a given bank 
 Write all needed register of tca6507 
 If led owns any resource, release it. 
	 Assign this led to a bank, configuring that bank if
		
		  Just set the brightness, choosing first usable
		  bank.  If none perfect, choose best.  Count
		  backwards so we check MASTER bank first to avoid
		  wasting a timer.
 full-on 
 Best brightness is full-on 
	
	  We have onoff time so we need to try to allocate a timing
	  bank.  First check if times are compatible with hardware
	  and give up if not.
 not in use - it is ours! 
 Incompatible level - skip 
			 FIX: if timer matches we maybe should consider
			  this anyway...
 Timer not in use, and level matches - use it 
 on time is incompatible 
 off time is incompatible 
 looks like a suitable match 
 Nothing matches - how sad 
		
		  Can only fail on timer setup.  In that case we need
		  to re-establish as steady level.
	
	  'OFF' is floating high, and 'ON' is pulled down, so it has
	  the inverse sense of 'val'.
 Configure as a gpio 
 CONFIG_GPIOLIB 
 CONFIG_GPIOLIB 
 set all registers to known state - zero 
 SPDX-License-Identifier: GPL-2.0-only
  SS4200-E Hardware API
  Copyright (c) 2009, Intel Corporation.
  Copyright IBM Corporation, 2009
  Author: Dave Hansen <dave@sr71.net>
  ICH7 LPCGPIO PCI Config register offsets
  The ICH7 GPIO register block is 64 bytes in size.
  Define register offsets within the ICH7 register block.
  PCI ID of the Intel ICH7 LPC Device within which the GPIO block lives.
 NULL entry 
  struct nas_led_whitelist - List of known good models
  Contains the known good models this driver is compatible with.
  When adding a new model try to be as strict as possible. This
  makes it possible to keep the false positives (the model is
  detected as working, but in reality it is not) as low as
  possible.
		
		  FUJITSU SIEMENS SCALEO Home ServerSS4200-E
		  BIOS V090L 12192007
  Base IO address assigned to the Power Management register block
  Base IO address assigned to the ICH7 GPIO register block
  When we successfully register a region, we are returned a resource.
  We use these to identify which regions we need to release on our way
  back out.
  gpio_bit(s) are the ICH7 GPIO bit assignments
 GPIO10 
  This protects access to the gpio ports.
  There are two gpio ports, one for blinking and the other
  for power.  @port tells us if we're doing blinking or
  power control.
  Caller must hold nasgpio_gpio_lock
  There is actual brightness control in the hardware,
  but it is via smbus commands and not implemented
  in this driver.
	
	  Hold the lock across both operations.  This ensures
	  consistency so that both the "turn off blinking"
	  and "turn light off" operations complete as a set.
	
	  LED class documentation asks that past blink state
	  be disabled when brightness is turned to zero.
	
	  These are very approximate.
  Initialize the ICH7 GPIO registers for NAS usage.  The BIOS should have
  already taken care of this, but we will do so in a non destructive manner
  so that we have what we need whether the BIOS did it or not.
	
	  We need to enable all of the GPIO lines used by the NAS box,
	  so we will read the current Use Selection and add our usage
	  to it.  This should be benign with regard to the original
	  BIOS configuration.
	
	  The LED GPIO outputs need to be configured for output, so we
	  will ensure that all LED lines are cleared for output and the
	  RECOVERY line ready for input.  This too should be benign with
	  regard to BIOS configuration.
	
	  In our final system, the BIOS will initialize the state of all
	  of the LEDs.  For now, we turn them all off (or Low).
	
	  In our final system, the BIOS will initialize the blink state of all
	  of the LEDs.  For now, we turn blink off for all of them.
	
	  At this moment, I am unsure if anything needs to happen with GPI_INV
	
	  If we were given exclusive use of the GPIO
	  IO Address range, we must return it.
  The OS has determined that the LPC of the Intel ICH7 Southbridge is present
  so we can retrive the required operational information and prepare the GPIO.
	
	  Insure that we have exclusive access to the GPIO IO address range.
	
	  Initialize the GPIO for NASHome Server Use
  pci_driver structure passed to the PCI modules
	
	  LED_OFF implies disabling future blinking
  module loadinitialization
	
	  When the system powers on, the BIOS leaves the power
	  light blue and blinking.  This will turn it solid
	  amber once the driver is loaded.
  module unload
 SPDX-License-Identifier: GPL-2.0-only
  h3xxx atmel micro companion support, notification LED subdevice
  Author : Linus Walleij <linus.walleij@linaro.org>
 LED ONOFF 0:off, 1:on                       
 LED ONOFF auto stop set 0:disable, 1:enable 
 LED Interrupt Mask 0:No mask, 1:mask         
	
	  In this message:
	  Byte 0 = LED color: 0 = yellow, 1 = green
	           yellow LED is always ~30 blinks per minute
	  Byte 1 = duration (flags?) appears to be ignored
	  Byte 2 = green ontime in 110 sec (deciseconds)
	           1 = 110 second
	           0 = 25610 second
	  Byte 3 = green offtime in 110 sec (deciseconds)
	           1 = 110 second
	           0 = 25610 seconds
 Duty cycle 256 
 Duty cycle 256 
 Maximum duty cycle in ms 25610 sec = 25600 ms 
	
	  In this message:
	  Byte 0 = LED color: 0 = yellow, 1 = green
	           yellow LED is always ~30 blinks per minute
	  Byte 1 = duration (flags?) appears to be ignored
	  Byte 2 = green ontime in 110 sec (deciseconds)
	           1 = 110 second
	           0 = 25610 second
	  Byte 3 = green offtime in 110 sec (deciseconds)
	           1 = 110 second
	           0 = 25610 seconds
 SPDX-License-Identifier: GPL-2.0-or-later
  leds-netxbig.c - Driver for the 2Big and 5Big Network series LEDs
  Copyright (C) 2010 LaCie
  Author: Simon Guinot <sguinot@lacie.com>
  GPIO extension bus.
 Enable select is done on the raising edge. 
  Class LED driver.
 Look for a LED mode with the requested timer frequency. 
 Keep 'timer' mode. 
	
	  Note that the brightness register is shared between all the
	  SATA LEDs. So, change the brightness setting for a single
	  SATA LED will affect all the others.
 Keep modes 'off' and 'timer'. 
	
	  Because the GPIO extension bus don't allow to read registers
	  value, there is no way to probe the LED initial state.
	  So, the initial sysfs LED value for the "brightness" and "sata"
	  attributes are inconsistent.
	 
	  Note that the initial LED state can't be reconfigured.
	  The reason is that the LED behaviour must stay uniform during
	  the whole boot process (bootloader+linux).
	
	  If available, expose the SATA activity blink capability through
	  a "sata" sysfs attribute.
  netxbig_gpio_ext_remove() - Clean up GPIO extension data
  @data: managed resource data to clean up
  Since we pick GPIO descriptors from another device than the device our
  driver is probing to, we need to register a specific callback to free
  these up using managed resources.
  netxbig_gpio_ext_get() - Obtain GPIO extension device data
  @dev: main LED device
  @gpio_ext_dev: the GPIO extension device
  @gpio_ext: the data structure holding the GPIO extension data
  This function walks the subdevice that only contain GPIO line
  handles in the device tree and obtains the GPIO descriptors from that
  device.
	
	  We cannot use devm_ managed resources with these GPIO descriptors
	  since they are associated with the "GPIO extension device" which
	  does not probe any driver. The device tree parser will however
	  populate a platform device for it so we can anyway obtain the
	  GPIO descriptors from the device.
 GPIO extension 
 Timers (optional) 
 LEDs 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 National Instruments Corp.
 Unlock LED register 
 Lock LED register 
 SPDX-License-Identifier: GPL-2.0-only
  LED driver for Marvell 88PM860x
  Copyright (C) 2009 Marvell International Ltd.
 	Haojian Zhuang <haojian.zhuang@marvell.com>
 unset current since no led is lighting 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Crane Merchandising Systems. All rights reserved.
 Copyright (C) 2018 Oleh Kravchenko <oleg@kaa.org.ua>
   CR0014114 SPI protocol descrtiption:
   +----+-----------------------------------+----+
   | CMD|             BRIGHTNESS            |CRC |
   +----+-----------------------------------+----+
   |    | LED0| LED1| LED2| LED3| LED4| LED5|    |
   |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |
   |    |R|G|B|R|G|B|R|G|B|R|G|B|R|G|B|R|G|B|    |
   | 1  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 1  |
   |    |1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|    |
   |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |
   |    |               18                  |    |
   +----+-----------------------------------+----+
   |                    20                       |
   +---------------------------------------------+
   PS: Boards can be connected to the chain:
       SPI -> board0 -> board1 -> board2 ..
 CR0014114 SPI commands 
 CR0014114 default settings 
 special case when CRC matches the SPI commands 
 to avoid SPI mistiming with firmware we should wait some time 
 setup recount work to workaround buggy firmware 
 SPDX-License-Identifier: GPL-2.0-or-later
  PowerNV LED Driver
  Copyright IBM Corp. 2015
  Author: Vasant Hegde <hegdevasant@linux.vnet.ibm.com>
  Author: Anshuman Khandual <khandual@linux.vnet.ibm.com>
 Map LED type to description. 
	
	  By default unload path resets all the LEDs. But on PowerNV
	  platform we want to retain LED state across reboot as these
	  are controlled by firmware. Also service processor can modify
	  the LEDs independent of OS. Hence avoid resetting LEDs in
	  unload path.
 Max supported LED type 
 glabal lock 
 PowerNV LED data 
 LED location code 
 OPAL_SLOT_LED_TYPE_ 
 Returns OPAL_SLOT_LED_TYPE_ for given led type string 
  This commits the state change of the requested LED through an OPAL call.
  This function is called from work queue task context when ever it gets
  scheduled. This function can sleep at opal_async_wait_response call.
 Prepare for the OPAL call 
 OPAL async call 
  This function fetches the LED state for a given LED type for
  mentioned LED classdev structure.
 Fetch all LED status 
 LED status available 
 LED status value 
  LED classdev 'brightness_get' function. This schedules work
  to update LED state.
 Do not modify LED in unload path 
 LED classdev 'brightness_get' function 
  This function registers classdev structure for any given type of LED on
  a given child LED device node.
 Make sure LED type is supported 
 Create the name for classdev 
 Register the classdev 
 Go through LED device tree node and register LED classdev structure 
 while end 
 Platform driver probe 
 Platform driver remove 
 Disable LED operation 
 Destroy lock 
 Platform driver property match 
 SPDX-License-Identifier: GPL-2.0-only
 leds-sunfire.c: SUNW,Ultra-Enterprise LED driver.
  Copyright (C) 2008 David S. Miller <davem@davemloft.net>
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2007-2008 Extreme Engineering Solutions, Inc.
  Author: Nate Case <ncase@xes-inc.com>
  LED driver for various PCA955x I2C LED drivers
  Supported devices:
 	Device		Description		7-bit slave address
 	------		-----------		-------------------
 	PCA9550		2-bit driver		0x60 .. 0x61
 	PCA9551		8-bit driver		0x60 .. 0x67
 	PCA9552		16-bit driver		0x60 .. 0x67
 	PCA955301	4-bit driver		0x62
 	PCA955302	4-bit driver		0x63
  Philips PCA955x LED driver chips follow a register map as shown below:
 	Control Register		Description
 	----------------		-----------
 	0x0				Input register 0
 					..
 	NUM_INPUT_REGS - 1		Last Input register X
 	NUM_INPUT_REGS			Frequency prescaler 0
 	NUM_INPUT_REGS + 1		PWM register 0
 	NUM_INPUT_REGS + 2		Frequency prescaler 1
 	NUM_INPUT_REGS + 3		PWM register 1
 	NUM_INPUT_REGS + 4		LED selector 0
 	NUM_INPUT_REGS + 4
 	    + NUM_LED_REGS - 1		Last LED selector
   where NUM_INPUT_REGS and NUM_LED_REGS vary depending on how many
   bits the chip supports.
 LED select registers determine the source that drives LED outputs 
 Output LOW 
 Output HI-Z 
 Blink at PWM0 rate 
 Blink at PWM1 rate 
 7-bit slave address mask 
 Number of bits to ignore 
 110000x  0x60,
 1100xxx  0x60,
 1100xxx  0x60,
 0110xxx  0x30,
 110001x  0x62,
 0 .. 15 potentially 
 8 bits per input register 
 4 bits per LED selector register 
  Return an LED selector register value based on an existing one, with
  the appropriate 2-bit state value set for the given LED number (0-3).
  Write to frequency prescaler register, used to program the
  period of the PWM output.  period = (PSCx + 1)  38
  Write to PWM register, which determines the duty cycle of the
  output.  LED is OFF when the count is less than the value of this
  register, and ON when it is greater.  If PWMx == 0, LED is always OFF.
  Duty cycle is (256 - PWMx)  256
  Write to LED selector register, which determines the source that
  drives the LED output.
  Read the LED selector register, which determines the source that
  drives the LED output.
 which LSx to use (0-3 potentially) 
 which set of bits within LSx to use (0-3) 
		
		  Use PWM1 for all other values.  This has the unwanted
		  side effect of making all LEDs on the chip share the
		  same brightness level if set to a value other than
		  OFF, HALF, or FULL.  But, this is probably better than
		  just turning off for all other values.
  Read the INPUT register, which contains the state of LEDs.
 There is nothing we can do about errors 
 To use as input ensure pin is not driven. 
 CONFIG_LEDS_PCA955X_GPIO 
 Make sure the slave address  chip type combo given is possible 
			
			  For default-state == "keep", let the core update the
			  brightness from the hardware, then check the
			  brightness to see if it's using PWM1. If so, PWM1
			  should not be written below.
 PWM0 is used for half brightness or 50% duty cycle 
 PWM1 is used for variable brightness, default to OFF 
 Set to fast frequency so we do not see flashing 
 Use data->gpio.dev as a flag for freeing gpiochip 
 SPDX-License-Identifier: GPL-2.0-only
  LEDs driver for Freescale MC13783MC13892MC34708
  Copyright (C) 2010 Philippe Rétornaz
  Based on leds-da903x:
  Copyright (C) 2008 Compulab, Ltd.
       Mike Rapoport <mike@compulab.co.il>
  Copyright (C) 2006-2008 Marvell International Ltd.
       Eric Miao <eric.miao@marvell.com>
 SPDX-License-Identifier: GPL-2.0-only
  LP5521 LED chip driver.
  Copyright (C) 2010 Nokia Corporation
  Copyright (C) 2012 Texas Instruments
  Contact: Samu Onkalo <samu.p.onkalo@nokia.com>
           Milo(Woogyom) Kim <milo.kim@ti.com>
 Registers 
 Base register to set LED current 
 Base register to set the brightness 
 Bits in ENABLE register 
 Chip master enable 
 Logarithmic PWM adjustment 
 CONFIG register 
 PWM: 0 = 256Hz, 1 = 558Hz 
 1 = Power save mode 
 Charge pump (CP) off 
 CP forced to bypass mode 
 CP forced to 1.5x mode 
 Automatic mode selection 
 R out: 0 = CP, 1 = Vbat 
 Internal clock 
 Status 
 default R channel current register value 
 Reset register value 
 Program Memory Operations 
 Operation Mode Register 
 Enable Register 
 operation mode change needs to be longer than 153 us 
 it takes more 488 us to update ENABLE register 
 stop engine 
	
	  To run the engine,
	  operation mode and enable register should updated at the same time
 change operation mode to RUN only when each engine is loading 
 separate sscanfs because length is working only for %s 
 Each instruction is 16bit long. Check that length is even 
	
	  Program memory sequence
	   1) set engine mode to "LOAD"
	   2) write firmware data into program memory
	
	  Make sure that the chip is reset by reading back the r channel
	  current reg. This is dummy read is required on some platforms -
	  otherwise further access to the R G B channels in the
	  LP5521_REG_ENABLE register will not have any effect - strange!
 Set all PWMs to direct control mode 
 Update configuration for the clock setting 
 Initialize all channels PWM to zero -> leds off 
 Set engines are set to run state when OP_MODE enables engines 
 Check that ext clock is really in use if requested 
 device attributes 
 Chip specific configurations 
 Three channel chip 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018 BayLibre SAS
 Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
 LED driver for MAXIM 7765077651 chargerpower-supply.
 Enable EN_LED_MSTR. 
 100% on duty 
 for backwards compatibility if `label` is not present 
  driversledsleds-apu.c
  Copyright (C) 2017 Alan Mizrahi, alan at mizrahi dot com dot ve
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation andor other materials provided with the distribution.
  3. Neither the names of the copyright holders nor the names of its
     contributors may be used to endorse or promote products derived from
     this software without specific prior written permission.
  Alternatively, this software may be distributed under the terms of the
  GNU General Public License ("GPL") version 2 as published by the Free
  Software Foundation.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
 LED access parameters 
 for ioreadiowrite 
 LED private data 
 LED profile 
 for devm_ioremap 
 PC Engines APU with factory bios "SageBios_PCEngines_APU-45" 
 PC Engines APU with "Mainline" bios >= 4.6.8 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2009,2018 Daniel Mack <daniel@zonque.org>
	
	  The LT3593 resets its internal current level register to the maximum
	  level on the first falling edge on the control pin. Each following
	  falling edge decreases the current level by 625uA. Up to 32 pulses
	  can be sent, so the maximum power reduction is 20mA.
	  After a timeout of 128us, the value is taken from the register and
	  applied is to the output driver.
 SPDX-License-Identifier: GPL-2.0
 TI LM3697 LED chip family driver
 Copyright (C) 2018 Texas Instruments Incorporated - https:
  struct lm3697_led -
  @hvled_strings: Array of LED strings associated with a control bank
  @label: LED label
  @led_dev: LED class device
  @priv: Pointer to the device struct
  @lmu_data: Register and setting values for common code
  @control_bank: Control bank the LED is associated to. 0 is control bank A
 		   1 is control bank B
  @enabled: LED brightness level (or LED_OFF)
  @num_leds: Number of LEDs available
  struct lm3697 -
  @enable_gpio: Hardware enable gpio
  @regulator: LED supply regulator pointer
  @client: Pointer to the I2C client
  @regmap: Devices register map
  @dev: Pointer to the devices device struct
  @lock: Lock for readingwriting the device
  @leds: Array of LED strings
  @bank_cfg: OUTPUT_CONFIG register values
  @num_banks: Number of control banks
 for backwards compatibility if `label` is not present 
 SPDX-License-Identifier: GPL-2.0-or-later
  Generic Syscon LEDs Driver
  Copyright (c) 2014, Linaro Limited
  Author: Linus Walleij <linus.walleij@linaro.org>
  struct syscon_led - state container for syscon based LEDs
  @cdev: LED class device for this LED
  @map: regmap to access the syscon device backing this LED
  @offset: the offset into the syscon regmap for the LED register
  @mask: the bit in the register corresponding to the LED
  @state: current state of the LED
 SPDX-License-Identifier: GPL-2.0-only
  leds-regulator.c - LED class driver for regulator driven LEDs.
  Copyright (C) 2009 Antonio Ospite <ospite@studenti.unina.it>
  Inspired by leds-wm8350 driver.
	 even if regulator can't change voltages,
	  we still assume it can change status
	  and the LED can be turned on and off.
 to handle correctly an already enabled regulator 
 to expose the default value to userspace 
 Set the default led status 
 SPDX-License-Identifier: GPL-2.0
 TI LM36274 LED chip family driver
 Copyright (C) 2019 Texas Instruments Incorporated - https:
  struct lm36274
  @pdev: platform device
  @led_dev: led class device
  @lmu_data: Register and setting values for common code
  @regmap: Devices register map
  @dev: Pointer to the devices device struct
  @led_sources: The LED strings supported in this array
  @num_leds: Number of LED strings are supported in this array
 There should only be 1 node 
 for backwards compatibility when `label` property is not present 
 SPDX-License-Identifier: GPL-2.0-only
  TI LP8860 4-Channel LED Driver
  Copyright (C) 2014 Texas Instruments
  Author: Dan Murphy <dmurphy@ti.com>
  struct lp8860_led
  @lock: Lock for readingwriting the device
  @client: Pointer to the I2C client
  @led_dev: led class device pointer
  @regmap: Devices register map
  @eeprom_regmap: EEPROM register map
  @enable_gpio: VDDIOEN gpio to enable communication interface
  @regulator: LED supply regulator pointer
 Attempt to clear any faults 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2011 Pengutronix
  Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>
  gpio_led_register_device - register a gpio-led device
  @pdata: the platform data used for the new device
  @id: platform ID
  Makes a copy of pdata and pdata->leds and registers a new leds-gpio device
  with the result. This allows to have pdata and pdata-leds in .init.rodata
  and so saves some bytes compared to a static struct platform_device with
  static platform data.
  Returns the registered device or an error pointer.
 SPDX-License-Identifier: GPL-2.0
  LED Driver for SGI Octane machines
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Christian Mauderer <oss@c-mauderer.de>
  The driver supports controllers with a very simple SPI protocol:
  - one LED is controlled by a single byte on MOSI
  - the value of the byte gives the brightness between two values (lowest to
    highest)
  - no return value is necessary (no MISO signal)
  The value for minimum and maximum brightness depends on the device
  (compatible string).
  Supported devices:
  - "ubnt,acb-spi-led": Microcontroller (SONiX 8F26E611LA) based device used
    for example in Ubiquiti airCube ISP. Reverse engineered protocol for this
    controller:
     Higher two bits set a mode. Lower six bits are a parameter.
     Mode: 00 -> set brightness between 0x00 (min) and 0x3F (max)
     Mode: 01 -> pulsing pattern (min -> max -> min) with an interval. From
      some tests, the period is about (50ms + 102ms  parameter). There is a
      slightly different pattern starting from 0x10 (longer gap between the
      pulses) but the time still follows that calculation.
     Mode: 10 -> same as 01 but with only a ramp from min to max. Again a
      slight jump in the pattern at 0x10.
     Mode: 11 -> blinking (off -> 25% -> off -> 25% -> ...) with a period of
      (105ms  parameter)
    NOTE: This driver currently only supports mode 00.
 SPI byte that will be send to switch the LED off 
 SPI byte that will be send to switch the LED to maximum brightness 
 all other cases except "off" 
 SPDX-License-Identifier: GPL-2.0
  CZ.NIC's Turris Omnia LEDs driver
  2020 by Marek Behún <kabel@kernel.org>
 put the LED into software mode 
 disable the LED 
  On the front panel of the Turris Omnia router there is also a button which
  can be used to control the intensity of all the LEDs at once, so that if they
  are too bright, user can dim them.
  The microcontroller cycles between 8 levels of this global brightness (from
  100% to 0%), but this setting can have any integer value between 0 and 100.
  It is therefore convenient to be able to change this setting from software.
  We expose this setting via a sysfs attribute file called "brightness". This
  file lives in the device directory of the LED controller, not an individual
  LED, so it should not confuse users.
 put all LEDs into default (HW triggered) mode 
 set all LEDs color to [255, 255, 255] 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2011 bct electronic GmbH
  Copyright 2013 QtechnologyAS
  Author: Peter Meerwald <p.meerwald@bct-electronic.com>
  Author: Ricardo Ribalda <ribalda@kernel.org>
  Based on leds-pca955x.c
  LED driver for the PCA9633 I2C LED driver (7-bit slave address 0x62)
  LED driver for the PCA96345 I2C LED driver (7-bit slave address set by hw.)
  Note that hardware blinking violates the leds infrastructure driver
  interface since the hardware only supports blinking all LEDs with the
  same delay_ondelay_off rates.  That is, only the LEDs that are set to
  blink will actually blink but all LEDs that are set to blink will blink
  in identical fashion.  The delay_ondelay_off values of the last LED
  that is set to blink will be used for all of the blinking LEDs.
  Hardware blinking is disabled by default but can be enabled by setting
  the 'blink_type' member in the platform_data struct to 'PCA963X_HW_BLINK'
  or by adding the 'nxp,hw-blink' property to the DTS.
 LED select registers determine the source that drives LED outputs 
 LED driver off 
 LED driver on 
 Controlled through PWM 
 Controlled through PWMGRPPWM 
 Open-drain or totem pole 
 Normal or inverted direction 
 Enable blinking 
 Total blink period in milliseconds 
 0 .. 15 potentially 
 If both zero, pick reasonable defaults of 500ms each 
 If period not supported by hardware, default to someting sane. 
	
	  From manual: duty cycle = (GDC  256) ->
	 	(time_on  period) = (GDC  256) ->
	 		GDC = ((time_on  256)  period)
	
	  From manual: period = ((GFRQ + 1)  24) in seconds.
	  So, period (in ms) = (((GFRQ + 1)  24)  1000) ->
	 		GFRQ = ((period  24  1000) - 1)
 default to open-drain unless totem pole (push-pull) is specified 
 default to non-inverted output, unless inverted is specified 
 for backwards compatibility 
 Turn off LEDs by default
 Disable LED all-call address, and power down initially 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2011 ST-Ericsson SA.
  Copyright (C) 2009 Motorola, Inc.
  Simple driver for National Semiconductor LM3530 Backlight driver chip
  Author: Shreshtha Kumar SAHU <shreshthakumar.sahu@stericsson.com>
  based on leds-lm3530.c by Dan Murphy <D.Murphy@motorola.com>
 General Control Register 
 ALS Config Register Options 
 Brightness Ramp Rate Register 
 ALS Resistor Select 
 Zone Boundary Register defaults 
 Zone Target Register defaults 
 7 bits are used for the brightness : LM3530_BRT_CTRL_REG 
  struct lm3530_data
  @led_dev: led class device
  @client: i2c client
  @pdata: LM3530 platform data
  @mode: mode of operation - manual, ALS, PWM
  @regulator: regulator
  @brightness: previous brightness value
  @enable: regulator is enabled
  struct lm3530_als_data
  @config  : value of ALS configuration register
  @imp_sel : value of ALS resistor select register
  @zone    : values of ALS ZB(Zone Boundary) registers
 n zone boundary makes n+1 zones 
 LM3530_GEN_CONFIG 
 LM3530_ALS_CONFIG 
 LM3530_BRT_RAMP_RATE 
 LM3530_ALS_IMP_SELECT 
 LM3530_BRT_CTRL_REG 
 LM3530_ALS_ZB0_REG 
 LM3530_ALS_ZB1_REG 
 LM3530_ALS_ZB2_REG 
 LM3530_ALS_ZB3_REG 
 LM3530_ALS_Z0T_REG 
 LM3530_ALS_Z1T_REG 
 LM3530_ALS_Z2T_REG 
 LM3530_ALS_Z3T_REG 
 LM3530_ALS_Z4T_REG 
 do not update brightness register when pwm mode 
 set the brightness in brightness control register
 set pwm to low if unnecessary 
 BL mode 
 SPDX-License-Identifier: GPL-2.0+
 Driver for Panasonic AN30259A 3-channel LED driver
 Copyright (c) 2018 Simon Shields <simon@lineageos.org>
 Datasheet:
 https:
 LED power registers 
 slope control registers 
 detention time control (length of each slope step) 
 ms 
 ms 
 held when writing to registers 
 slope time can only be a multiple of 500ms. 
 up to a maximum of 7500ms. 
 if no blink specified, default to 1 Hz. 
 convert into values the HW will understand. 
 duty min should be zero (=off), delay should be zero. 
 reset detention time (no "breathing" effect). 
 slope time controls onoff cycle length. 
 Finally, enable slope mode. 
 sentinel  },
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-only
  LED Flash class interface
  Copyright (C) 2015 Samsung Electronics Co., Ltd.
  Author: Jacek Anaszewski <j.anaszewski@samsung.com>
 no lock needed for this 
 no lock needed for this 
 Select the sysfs attributes to be created for the device 
 Register led class device 
 SPDX-License-Identifier: GPL-2.0-only
  linuxdriversleds-pwm.c
  simple PWM based LED control
  Copyright 2009 Luotao Fu @ Pengutronix (l.fu@pengutronix.de)
  based on leds-gpio.c by Raphael Assenat <raph@8d.com>
 init PWM state 
 set brightness 
 SPDX-License-Identifier: GPL-2.0
 TI LP50XX LED chip family driver
 Copyright (C) 2018-20 Texas Instruments Incorporated - https:
 LP5009 and LP5012 registers 
 LP5018 and LP5024 registers 
 LP5030 and LP5036 registers 
 There are 3 LED outputs per bank 
 LEDX_BRT registers are all 0xff for defaults 
 OUTX_CLR registers are all 0x0 for defaults 
 LEDX_BRT registers are all 0xff for defaults 
 OUTX_CLR registers are all 0x0 for defaults 
 LEDX_BRT registers are all 0xff for defaults 
 OUTX_CLR registers are all 0x0 for defaults 
  struct lp50xx_chip_info -
  @lp50xx_regmap_config: regmap register configuration
  @model_id: LED device model
  @max_modules: total number of supported LED modules
  @num_leds: number of LED outputs available on the device
  @led_brightness0_reg: first brightness register of the device
  @mix_out0_reg: first color mix register of the device
  @bank_brt_reg: bank brightness register
  @bank_mix_reg: color mix register
  @reset_reg: device reset register
  struct lp50xx -
  @enable_gpio: hardware enable gpio
  @regulator: LED supply regulator pointer
  @client: pointer to the I2C client
  @regmap: device register map
  @dev: pointer to the devices device struct
  @lock: lock for readingwriting the device
  @chip_info: chip specific information (ie num_leds)
  @num_of_banked_leds: holds the number of banked LEDs
  @leds: array of LED strings
 This needs to be at the end of the struct 
		
		  There are only 3 LEDs per module otherwise they should be
		  banked which also is presented as 3 LEDs.
 SPDX-License-Identifier: GPL-2.0-only
  TI LP8788 MFD - keyled driver
  Copyright 2012 Texas Instruments
  Author: Milo(Woogyom) Kim <milo.kim@ti.com>
 scale configuration 
 current configuration 
 SPDX-License-Identifier: GPL-2.0-only
  LED Triggers Core
  Copyright 2005-2007 Openedhand Ltd.
  Author: Richard Purdie <rpurdie@openedhand.com>
  Nests outside led_cdev->trigger_lock
 Used by LED Class 
 we come here only if buf matches no trigger 
  It was stupid to create 10000 cpu triggers, but we are stuck with it now.
  Don't make that mistake again. We work around it here by creating binary
  attribute, which is not limited by length. This is _not_ good design, do not
  copy it.
 Caller must ensure led_cdev->trigger_lock held 
 Remove any existing trigger 
 ensure it's no longer visible on the led_cdevs list 
 new name must be on a temporary string to prevent races 
	 this assumes that trig->name was originaly allocated to
 LED Trigger Interface 
 Make sure the trigger's name isn't already in use 
 Add to the list of led triggers 
 Register with any LEDs that have this as a default trigger 
 Remove from the list of led triggers 
 Remove anyone actively using this trigger 
 Simple LED Trigger Interface 
 SPDX-License-Identifier: GPL-2.0-or-later
  leds-ns2.c - Driver for the Network Space v2 (and parents) dual-GPIO LED
  Copyright (C) 2010 LaCie
  Author: Simon Guinot <sguinot@lacie.com>
  Based on leds-gpio.c by Raphael Assenat <raph@8d.com>
  If the size of this structure or types of its members is changed,
  the filling of array modval in function ns2_led_register must be changed
  accordingly.
  The Network Space v2 dual-GPIO LED is wired to a CPLD. Three different LED
  modes are available: off, on and SATA activity blinking. The LED modes are
  controlled through two GPIOs (command and slow): each combination of values
  for the commandslow GPIOs corresponds to a LED mode.
 True when SATA mode active. 
 Lock GPIOs. 
 Set LED initial state. 
 SPDX-License-Identifier: GPL-2.0-only
  linuxdriversledsleds-locomo.c
  Copyright (C) 2005 John Lenz <lenz@cs.wisc.edu>
 SPDX-License-Identifier: GPL-2.0-or-later
   leds-blinkm.c
   (c) Jan-Simon Möller (dl9pf@gmx.de)
 Addresses to scan - BlinkM is on 0x09 by default
 used for led class interface 
 used for "blinkm" sysfs interface 
 color red 
 color green 
 color blue 
 next values to use for transfer 
 color red 
 color green 
 color blue 
 internal use 
 set of args for transmission 
 i2c addr 
 firmware version 
 used, but not from userspace 
 HSB  hue 
 HSB  saturation 
 HSB  brightness 
 HSB  hue 
 HSB  saturation 
 HSB  brightness 
 currently unused  todo 
 fade speed     1 - 255 
 time adjust -128 - 127 
 fade on = 1, off = 0 
 rand fade mode on = 1 
 script ID 
 repeats of script 
 line to start 
 Colors 
 mapping command names to cmd chars - see datasheet 
 Length & Repeats 
 BlinkM Commands
   as extracted out of the datasheet:
   cmdchar = command (ascii)
   cmdbyte = command in hex
   nr_args = number of arguments (to send)
   nr_ret  = number of return values (to read)
   dir = direction (0 = read, 1 = write, 2 = both)
 cmdchar, cmdbyte, nr_args, nr_ret,  dir 
 if mode ... 
test 
 TODO: HSB, fade, timeadj, script ... 
 write out cmd to blinkm - always  default step 
 no args to write out 
 repeat for arglen 
 repeat for retlen 
	 the protocol is simple but non-standard:
	  e.g.  cmd 'g' (= 0x67) for "get device address"
	  - which defaults to 0x09 - would be the sequence:
	    a) write 0x67 to the device (byte write)
	    b) read the value (0x09) back right after (byte read)
	 
	  Watch out for "unfinished" sequences (i.e. not enough reads
	  or writes after a command. It will make the blinkM misbehave.
	  Sequence is key here.
 args  return are in private data struct 
	 We start hardware transfers which are not to be
 switch cmd - usually write before reads 
 end switch(cmd) 
 transfers done, unlock 
 led_brightness is 0, 127 or 255 - we just use it here as-is 
 bail out if there's no change 
 bail out if there's no change 
 bail out if there's no change 
 Return 0 if detection is successful, -ENODEV otherwise 
 Now, we do the remaining detection. Simple for now. 
 We might need more guards to protect other i2c slaves 
 make sure the blinkM is balanced (readwrites) 
 Step 1: Read BlinkM address back  -  cmd_char 'a' 
 allow a small delay 
 i2c addr  - use fake addr of 0x08 initially (real is 0x09) 
	 firmware version - use fake until we read real value
 Register sysfs hooks 
 RED = 0, GREEN = 1, BLUE = 2 
 end switch 
 end for 
 Initialize the blinkm 
 make sure no workqueue entries are pending 
 reset rgb 
 reset hsb 
 red fade to off 
 off 
 This is the driver that will be inserted 
 SPDX-License-Identifier: GPL-2.0-only
  LEDs driver for PCEngines WRAP
  Copyright (C) 2006 Kristian Kielhofner <kris@krisk.org>
  Based on leds-net48xx.c
 SPDX-License-Identifier: GPL-2.0-only
 Simple driver for Texas Instruments LM3642 LED Flash driver chip
 Copyright (C) 2012 Texas Instruments
 chip initialize 
 set enable register 
 chip control 
 brightness 0 means off-state 
 torch 
 torch pin config for lm3642 
 flash 
 strobe pin config for lm3642
 indicator 
 flash 
 torch 
 indicator 
 SPDX-License-Identifier: GPL-2.0
 TI LM3692x LED chip family driver
 Copyright (C) 2017-18 Texas Instruments Incorporated - https:
 Brightness Control Bits 
 PWM Register Bits 
 Boost Control Bits 
 Fault Control Bits 
 Fault Flag Bits 
  struct lm3692x_led
  @lock: Lock for readingwriting the device
  @client: Pointer to the I2C client
  @led_dev: LED class device pointer
  @regmap: Devices register map
  @enable_gpio: VDDIOEN gpio to enable communication interface
  @regulator: LED supply regulator pointer
  @led_enable: LED sync to be enabled
  @model_id: Current device model ID enumerated
	 The first read may clear the fault.  Check again to see if the fault
	  still exits and return that value.
	
	  For glitch free operation, the following data should
	  only be written while LEDx enable bits are 0 and the device enable
	  bit is set to 1.
	  per Section 7.5.14 of the data sheet
	 Set the brightness to 0 so when enabled the LEDs do not come
	  on with full brightness.
 see p.12 of LM36922 data sheet for brightness formula 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for BCM6328 memory-mapped LEDs, based on leds-syscon.c
  Copyright 2015 Álvaro Fernández Rojas <noltari@gmail.com>
  Copyright 2015 Jonas Gorski <jogo@openwrt.org>
  struct bcm6328_led - state container for bcm6328 based LEDs
  @cdev: LED class device for this LED
  @mem: memory resource
  @lock: memory lock
  @pin: LED pin number
  @blink_leds: blinking LEDs
  @blink_delay: blinking delay
  @active_low: LED is active low
  LEDMode 64 bits  24 LEDs
  bits [31:0] -> LEDs 8-23
  bits [47:32] -> LEDs 0-7
  bits [63:48] -> unused
 LEDs 0-7 (bits 47:32) 
 LEDs 8-23 (bits 31:0) 
 Remove LED from cached HW blinking intervals 
 Set LED onoff 
	
	  Check if any of the two configurable HW blinking intervals is
	  available:
	    1. No LEDs assigned to the HW blinking interval.
	    2. Only this LED is assigned to the HW blinking interval.
	    3. LEDs with the same delay assigned.
 Add LED to the first HW blinking interval cache 
 Remove LED from the second HW blinking interval cache 
 Cache first HW blinking interval delay 
 Update the delay for the first HW blinking interval 
 Set the LED to first HW blinking interval 
 Remove LED from the first HW blinking interval 
 Add LED to the second HW blinking interval 
 Cache second HW blinking interval delay 
 Update the delay for the second HW blinking interval 
 Set the LED to second HW blinking interval 
 Only LEDs 0-7 can be activitylink controlled 
 memory lock 
 SPDX-License-Identifier: GPL-2.0
  Intel Lightning Mountain SoC LED Serial Shift Output Controller driver
  Copyright (c) 2020 Intel Corporation.
 Fixed Divider Shift Clock 
 Driver MACRO 
 0-rising, 1-falling 
  Update Source to update the SOUTs
  SW - Software has to update the SWU bit
  GPTC - General Purpose timer is used as clock source
  FPID - Divided FSC clock (FPID) is used as clock source
 1 to 4 
 5 to 8 
 9 to 10 
 led 0 - 23 in led 32 location 
 set blink rate idx 
 select clock source 
 HW blink off 
 set freq 
 set brightness 
 enable output 
 To exclude pins from control, use "gpio-reserved-ranges" 
 Clear all duty cycles 
 4 groups for total 32 pins 
 NO HW directly controlled pin by default 
 NO BLINK for all pins 
 OUTPUT 0 by default 
 update edge 
 Set GPIO update rate 
 Register shift clock 
 unregister led 
 clear HW control bit 
 default first freq rate 
 unregister leds 
 gate clock 
 fpid clock 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2020 Luca Weiss <luca@z3ntu.xyz>
 250ms 
 300ms 
 current timeout in us 
 maximum timeout in us 
 Init flash timeout setting 
 Init flash intensity setting 
	
	  Set default timeout to FLASH_DEFAULT_TIMEOUT except if max_timeout
	  from DT is lower.
 Register in the LED subsystem 
 Create V4L2 Flash subdev 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  LED driver : leds-ktd2692.c
  Copyright (C) 2015 Samsung Electronics
  Ingi Kim <ingi2.kim@samsung.com>
 Value related the movie mode 
 Value related the flash mode 
 Macro for getting offset of flash timeout 
 Base register address 
 Set bit coding time for expresswire interface 
 KTD2692 default length of name 
 Movie  Flash Mode Control 
 default 
 maximum LED current in movie mode 
 maximum LED current in flash mode 
 maximum flash timeout 
 max LED brightness level 
 Related LED Flash class device 
 secures access to the device 
	
	  The Low Bit(0) and High Bit(1) is based on a time detection
	  algorithm between time low and time high
	  Time_(L_LB) : Low time of the Low Bit(0)
	  Time_(H_LB) : High time of the LOW Bit(0)
	  Time_(L_HB) : Low time of the High Bit(1)
	  Time_(H_HB) : High time of the High Bit(1)
	 
	  It can be simplified to:
	  Low Bit(0) : 2  Time_(H_LB) < Time_(L_LB)
	  High Bit(1) : 2  Time_(L_HB) < Time_(H_HB)
	  HIGH  ___           ____    _..     _________    ___
	           |_________|    |_..  |____|         |__|
	  LOW        <L_LB>  <H_LB>     <L_HB>  <H_HB>
	           [  Low Bit (0) ]     [  High Bit(1) ]
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-or-later
  LED driver for Richtek RT8515 flashtorch white LEDs
  found on some Samsung mobile phones.
  This is a 1.5A Boost dual channel driver produced around 2011.
  The component lacks a datasheet, but in the schematic picture
  from the LG P970 service manual you can see the connections
  from the RT8515 to the LED, with two resistors connected
  from the pins "RFS" and "RTS" to ground.
  On the LG P970:
  RFS (resistance flash setting?) is 20 kOhm
  RTS (resistance torch setting?) is 39 kOhm
  Some sleuthing finds us the RT9387A which we have a datasheet for:
  https:static5.arrow.compdfs201472782112794rtt_manual94download_ds.jspprt9387a.jspprt9387a.pdf
  This apparently works the same way so in theory this driver
  should cover RT9387A as well. This has not been tested, please
  update the compatibles if you add RT9387A support.
  Linus Walleij <linus.walleij@linaro.org>
 We can provide 15-700 mA out to the LED 
 The maximum intensity is 1-16 for flash and 1-100 for torch 
 Flash max timeout 
	
	  Toggling a GPIO line with a small delay increases the
	  brightness one step at a time.
 This is setting the torch light level 
 Off 
 Step it up to movie mode brightness using the flash pin 
 Max torch brightness requested 
 Enable LED flash mode and set brightness 
 Set timeout 
 Turn the LED off 
 After this the torch LED will be disabled 
 The timeout is stored in the led-class-flash core 
 Turn the LED off 
 Init flash timeout setting 
	
	  Set default timeout to RT8515_TIMEOUT_US except if
	  max_timeout from DT is lower.
 Configure the V2L2 flash subdevice 
	
	  Init flash intensity setting: this is a linear scale
	  capped from the device tree max intensity setting
	  1..flash_max_intensity
 Can't be 0 so 0 is undefined 
 Missing info in DT, OK go with hardware maxima 
	
	  Formula from the datasheet, this is the maximum current
	  defined by the hardware.
	
	  Calculate max intensity (linear scaling)
	  Formula is ((ua  1000)  max_ma)  100, then simplified
 ENF - Enable Flash line 
 ENT - Enable Torch line 
 Create a V4L2 Flash device if V4L2 flash is enabled 
		
		  Continue without the V4L2 flash
		  (we still have the classdev)
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
 Reset registers to make sure all off before shutdown 
 SPDX-License-Identifier: GPL-2.0
 Flash and torch driver for Texas Instruments LM3601X LED
 Flash driver chip family
 Copyright (C) 2018 Texas Instruments Incorporated - https:
 Registers 
 Enable Mode bits 
 Flag Mask 
  struct lm3601x_led -
  @fled_cdev: flash LED class device pointer
  @client: Pointer to the I2C client
  @regmap: Devices register map
  @lock: Lock for readingwriting the device
  @led_name: LED label for the Torch or IR LED
  @flash_timeout: the timeout for the flash
  @last_flag: last known flags register value
  @torch_current_max: maximum current for the torch
  @flash_current_max: maximum current for the flash
  @max_flash_timeout: maximum timeout for the flash
  @led_mode: The mode to enable either IR or Torch
 SPDX-License-Identifier: GPL-2.0-only
  driversledsleds-as3645a.c - AS3645A and LM3555 flash controllers driver
  Copyright (C) 2008-2011 Nokia Corporation
  Copyright (c) 2011, 2017 Intel Corporation.
  Based on driversmediai2cas3645a.c.
  Contact: Sakari Ailus <sakari.ailus@iki.fi>
 Register definitions 
 Read-only Design info register: Reset state: xxxx 0001 
 Read-only Version control register: Reset state: 0000 0000
  for first engineering samples
 Read  Write	(Indicator and timer register): Reset state: 0000 1111 
 Read  Write	(Current set register): Reset state: 0110 1001 
 Read  Write	(Control register): Reset state: 1011 0100 
 Read only (D3 is read  write) (Fault and info): Reset state: 0000 x000 
 Boost register 
 Password register is used to unlock boost register writing 
 W:0x60, R:0x61 
 us 
 uA 
 uA 
 uA 
 LED numbers for Devicetree 
 Return negative errno else zero on success 
 Return negative errno else a data byte received from the device. 
 -----------------------------------------------------------------------------
  Hardware configuration and trigger
  as3645a_set_current - Set flash configuration registers
  @flash: The flash
  Configure the hardware with flash, assist and indicator currents, as well as
  flash timeout.
  Return 0 on success, or a negative error code if an I2C communication error
  occurred.
  as3645a_set_control - Set flash control register
  @flash: The flash
  @mode: Desired output mode
  @on: Desired output state
  Configure the hardware with output mode and state.
  Return 0 on success, or a negative error code if an I2C communication error
  occurred.
 Configure output parameters and operation mode. 
 NOTE: reading register clears fault status 
 Register value 0 is 20 mA. 
 clear errors 
 read status 
 Verify the chip model and version. 
 Value 0 is off in LED class. 
 SPDX-License-Identifier: GPL-2.0-only
 	LED Flash class driver for the AAT1290
 	1.5A Step-Up Current Regulator for Flash LEDs
 	Copyright (C) 2015, Samsung Electronics Co., Ltd.
 	Author: Jacek Anaszewski <j.anaszewski@samsung.com>
 maximum LED current in movie mode 
 maximum LED current in flash mode 
 maximum flash timeout 
 external strobe capability 
 max LED brightness level 
 platform device data 
 secures access to the device 
 corresponding LED Flash class device 
 V4L2 Flash device 
 FLEN pin 
 EN|SET pin  
 movie mode current scale 
 device mode 
 brightness cache 
 write address 
 write data 
 LED subsystem callbacks 
	
	  To reenter movie mode after a flash event the part must be cycled
	  off and back on to reset the movie mode and reprogrammed via the
	  AS2Cwire. Therefore the brightness and movie_mode properties needs
	  to be updated here to reflect the actual state.
	
	  Don't do anything - flash timeout is cached in the led-class-flash
	  core and will be applied in the strobe_set op, as writing the
	  safety timer register spuriously turns the torch mode on.
	
	  led-max-microamp will default to 120 of flash-max-microamp
	  in case it is missing.
	
	  Init non-linear movie mode current scale basing
	  on the max flash current from led configuration.
 Init flash timeout setting 
 Initialize LED Flash class device 
 Register LED Flash class device 
 Create V4L2 Flash subdev. 
 SPDX-License-Identifier: GPL-2.0-only
  LED Flash class driver for the flash cell of max77693 mfd.
 	Copyright (C) 2015, Samsung Electronics Co., Ltd.
 	Authors: Jacek Anaszewski <j.anaszewski@samsung.com>
 		 Andrzej Hajda <a.hajda@samsung.com>
 corresponding FLED output identifier 
 corresponding LED Flash class device 
 V4L2 Flash device 
 brightness cache 
 flash timeout cache 
 flash faults that may have occurred 
 parent mfd regmap 
 platform device data 
 secures access to the device 
 sub led data 
 maximum torch current values for FLED outputs 
 maximum flash current values for FLED outputs 
 current flash timeout cache 
 ITORCH register cache 
 mode of fled outputs 
 recently strobed fled 
 bitmask of FLED outputs use state (bit 0. - FLED1, bit 1. - FLED2) 
 FLED modes that can be set 
 arrangement of current outputs 
			
			  Enable hw triggering also for torch mode, as some
			  camera sensors use torch led to fathom ambient light
			  conditions before strobing the flash.
 Reset the register only prior setting flash modes 
 Span the mode on FLED2 for joint iouts case 
	
	  FLASH_EXTERNAL mode activates FLASHEN and TORCHEN pins in the device.
	  Corresponding register bit fields interfere with SW triggered modes,
	  thus clear them to ensure proper device configuration.
	
	  Clear flash mode flag after setting the mode to avoid spurious flash
	  strobing on each subsequent torch mode setting.
 Clear mode also on FLED2 for joint iouts case 
	
	  Initialize only flash current. Torch current doesn't
	  require initialization as ITORCH register is written with
	  new value each time brightness_set op is called.
 LED subsystem callbacks 
 Boost must be enabled if both current outputs are used 
 Init flash intensity setting 
 Init flash timeout setting 
 Init flash faults config 
 Initialize LED Flash class device 
 Init flash timeout cache 
 Register in the LED subsystem 
 Register in the V4L2 subsystem. 
 Initialize LED Flash class device 
		
		  Register LED Flash class device and corresponding
		  V4L2 Flash device.
			
			  At this moment FLED1 might have been already
			  registered and it needs to be released.
 It is possible than only FLED2 was to be registered 
 SPDX-License-Identifier: GPL-2.0-only
  Activity LED trigger
  Copyright (C) 2017 Willy Tarreau <w@1wt.eu>
  Partially based on Atsushi Nemoto's ledtrig-heartbeat.c.
 full brightness in case of panic 
	 We come here every 100ms in the worst case, so that's 100M ns of
	  cumulated time. By dividing by 2^16, we get the time resolution
	  down to 16us, ensuring we won't overflow 32-bit computations below
	  even up to 3k CPUs, while keeping divides cheap on smaller systems.
	
	  Now we know the total boot_time multiplied by the number of CPUs, and
	  the total idle+wait time for all CPUs. We'll compare how they evolved
	  since last call. The % of overall CPU usage is :
	 
	       1 - delta_idle  delta_boot
	 
	  What we want is that when the CPU usage is zero, the LED must blink
	  slowly with very faint flashes that are detectable but not disturbing
	  (typically 10ms every second, or 10ms ON, 990ms OFF). Then we want
	  blinking frequency to increase up to the point where the load is
	  enough to saturate one core in multi-core systems or 50% in single
	  core systems. At this point it should reach 10 Hz with a 1090 duty
	  cycle (10ms ON, 90ms OFF). After this point, the blinking frequency
	  remains stable (10 Hz) and only the duty cycle increases to report
	  the activity, up to the point where we have 90ms ON, 10ms OFF when
	  all cores are saturated. It's important that the LED never stays in
	  a steady state so that it's easy to distinguish an idle or saturated
	  machine from a hung one.
	 
	  This gives us :
	    - a target CPU usage of min(50%, 100%#CPU) for a 10% duty cycle
	      (10ms ON, 90ms OFF)
	    - below target :
	       ON_ms  = 10
	       OFF_ms = 90 + (1 - usagetarget)  900
	    - above target :
	       ON_ms  = 10 + (usage-target)(100%-target)  80
	       OFF_ms = 90 - (usage-target)(100%-target)  80
	 
	  In order to keep a good responsiveness, we cap the sleep time to
	  100 ms and keep track of the sleep time left. This allows us to
	  quickly change it if needed.
 ON  
 OFF 
 ON  
 OFF 
 SPDX-License-Identifier: GPL-2.0-only
  LED Heartbeat Trigger
  Copyright (C) 2006 Atsushi Nemoto <anemo@mba.ocn.ne.jp>
  Based on Richard Purdie's ledtrig-timer.c and some arch's
  CONFIG_HEARTBEAT code.
 acts like an actual heart beat -- ie thump-thump-pause... 
		
		  The hyperbolic function below modifies the
		  heartbeat period length in dependency of the
		  current (1min) load. It goes through the points
		  f(0)=1260, f(1)=860, f(5)=510, f(inf)->300.
 SPDX-License-Identifier: GPL-2.0
 Copyright 2017 Ben Whitten <ben.whitten@gmail.com>
 Copyright 2007 Oliver Jowett <oliver@opencloud.com>
 LED Kernel Netdev Trigger
 Toggles the LED to reflect the link and traffic state of a named net device
 Derived from ledtrig-timer.c which is:
  Copyright 2005-2006 Openedhand Ltd.
  Author: Richard Purdie <rpurdie@openedhand.com>
  Configurable sysfs attributes:
  device_name - network device name to monitor
  interval - duration of LED blink, in milliseconds
  link -  LED's normal state reflects whether the link is up
          (has carrier) or not
  tx -  LED blinks on transmitted data
  rx -  LED blinks on receive data
		 If we are looking for RXTX start periodically
		  checking stats
 impose some basic bounds on the timer interval 
 resets timer 
 here's the real work! 
 If we dont have a device, insure we are off 
 If we are not looking for RXTX then return  
 base state is ON (link present) 
 SPDX-License-Identifier: GPL-2.0-only
  LED Kernel Default ON Trigger
  Copyright 2008 Nick Forbes <nick.forbes@incepta.com>
  Based on Richard Purdie's ledtrig-timer.c.
 SPDX-License-Identifier: GPL-2.0-only
  LED Kernel Timer Trigger
  Copyright 2005-2006 Openedhand Ltd.
  Author: Richard Purdie <rpurdie@openedhand.com>
 led_blink_set() called by caller 
		
		  Mark as initialized even on pattern_init() error because
		  any consecutive call to it would produce the same error.
	
	  If "set brightness to 0" is pending in workqueue, we don't
	  want that to be reordered after blink_set()
 Stop blinking 
 SPDX-License-Identifier: GPL-2.0-only
  Kernel Panic LED Trigger
  Copyright 2016 Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>
  This is called in a special context by the atomic panic
  notifier. This means the trigger can be changed without
  worrying about locking.
 Avoid the delayed blink path 
 SPDX-License-Identifier: GPL-2.0-only
  One-shot LED Trigger
  Copyright 2012, Fabio Baltieri <fabio.baltieri@gmail.com>
  Based on ledtrig-timer.c by Richard Purdie <rpurdie@openedhand.com>
 content is ignored 
		
		  Mark as initialized even on pattern_init() error because
		  any consecutive call to it would produce the same error.
 Stop blinking 
 SPDX-License-Identifier: GPL-2.0-only
  LED Disk Activity Trigger
  Copyright 2006 Openedhand Ltd.
  Author: Richard Purdie <rpurdie@openedhand.com>
 SPDX-License-Identifier: GPL-2.0
 LED Kernel Transient Trigger
 Transient trigger allows one shot timer activation. Please refer to
 Documentationledsledtrig-transient.rst for details
 Copyright (C) 2012 Shuah Khan <shuahkhan@gmail.com>
 Based on Richard Purdie's ledtrig-timer.c and Atsushi Nemoto's
 ledtrig-heartbeat.c
 Design and use-case input from Jonas Bonn <jonas@southpole.se> and
 Neil Brown <neilb@suse.de>
 cancel the running timer 
 start timer if there is no active timer 
	 state == 0 && transient_data->activate == 0
	 state == 1 && transient_data->activate == 1
 SPDX-License-Identifier: GPL-2.0-only
  LED MTD trigger
  Copyright 2016 Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>
  Based on LED IDE-Disk Activity Trigger
  Copyright 2006 Openedhand Ltd.
  Author: Richard Purdie <rpurdie@openedhand.com>
 SPDX-License-Identifier: GPL-2.0
  LED pattern trigger
  Idea discussed with Pavel Machek. Raphael Teysseyre implemented
  the first version, Baolin Wang simplified and improved the approach.
  When doing gradual dimming, the led brightness will be updated
  every 50 milliseconds.
	
	  If current tuple's duration is less than the dimming interval,
	  we should treat it as a step change of brightness instead of
	  doing gradual dimming.
 Step change of brightness 
 Skip the tuple with zero duration 
 Select next tuple 
 Gradual dimming 
			
			  If the accumulation time is larger than current
			  tuple's duration, we should go next one and re-check
			  if we repeated done.
 Accumulate the gradual dimming time 
 At least 2 tuples for software pattern. 
 Number 0 and negative numbers except -1 are invalid. 
 -1 means repeat indefinitely 
		
		  Mark as initialized even on pattern_init() error because
		  any consecutive call to it would produce the same error.
 SPDX-License-Identifier: GPL-2.0-only
  Camera Flash and Torch OnOff Trigger
  based on ledtrig-ide-disk.c
  Copyright 2013 Texas Instruments
  Author: Milo(Woogyom) Kim <milo.kim@ti.com>
 SPDX-License-Identifier: GPL-2.0
 exit without rescheduling 
 try to get the tty corresponding to $ttyname 
			
			  A device with this name might appear later, so keep
			  retrying.
 What to do? retry or abort 
 SPDX-License-Identifier: GPL-2.0-only
  ledtrig-gio.c - LED Trigger Based on GPIO events
  Copyright 2009 Felipe Balbi <me@felipebalbi.com>
 desired brightness when led is on 
 true when gpio is inverted 
 gpio that triggers the leds 
 After inverting, we need to update the LED. 
 After changing the GPIO, we need to update the LED. 
 SPDX-License-Identifier: GPL-2.0-only
  ledtrig-cpu.c - LED trigger based on CPU activity
  This LED trigger will be registered for first 8 CPUs and named
  as cpu0..cpu7. There's additional trigger called cpu that
  is on when any CPU is active.
  If you want support for arbitrary number of CPUs, make it one trigger,
  with additional sysfs file selecting which CPU to watch.
  It can be bound to any LED just like other triggers using either a
  board file or via sysfs interface.
  An API named ledtrig_cpu is exported for any user, who want to add CPU
  activity indication in their code.
  Copyright 2011 Linus Walleij <linus.walleij@linaro.org>
  Copyright 2011 - 2012 Bryan Wu <bryan.wu@canonical.com>
  ledtrig_cpu - emit a CPU event as a trigger
  @ledevt: CPU event to be emitted
  Emit a CPU event on a CPU core, which will trigger a
  bound LED to turn on or turn off.
 Locate the correct CPU LED 
 Will turn the LED on, max brightness 
 Will turn the LED off 
 Will leave the LED as it is 
 Update trigger state 
 Supports up to 9999 cpu cores 
	
	  Registering a trigger for all CPUs.
	
	  Registering CPU led trigger for each CPU core here
	  ignores CPU hotplug, but after this CPU hotplug works
	  fine with this trigger.
 SPDX-License-Identifier: GPL-2.0-only
  Backlight emulation LED trigger
  Copyright 2008 (C) Rodolfo Giometti <giometti@linux.it>
  Copyright 2008 (C) Eurotech S.p.A. <info@eurotech.it>
 If we aren't interested in this event, skip it immediately ... 
 After inverting, we need to update the LED. 
 SPDX-License-Identifier: GPL-2.0
 Audio Mute LED trigger
 SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
  ntb_msi_init() - Initialize the MSI context
  @ntb:	NTB device context
  This function must be called before any other ntb_msi function.
  It initializes the context for MSI operations and maps
  the peer memory windows.
  This function reserves the last N outbound memory windows (where N
  is the number of peers).
  Return: Zero on success, otherwise a negative error number.
  ntb_msi_setup_mws() - Initialize the MSI inbound memory windows
  @ntb:	NTB device context
  This function sets up the required inbound memory windows. It should be
  called from a work function after a link up event.
  Over the entire network, this function will reserves the last N
  inbound memory windows for each peer (where N is the number of peers).
  ntb_msi_init() must be called before this function.
  Return: Zero on success, otherwise a negative error number.
  ntb_msi_clear_mws() - Clear all inbound memory windows
  @ntb:	NTB device context
  This function tears down the resources used by ntb_msi_setup_mws().
  ntbm_msi_request_threaded_irq() - allocate an MSI interrupt
  @ntb:	NTB device context
  @handler:	Function to be called when the IRQ occurs
  @thread_fn:  Function to be called in a threaded interrupt context. NULL
               for clients which handle everything in @handler
  @devname:    An ascii name for the claiming device, dev_name(dev) if NULL
  @dev_id:     A cookie passed back to the handler function
  This function assigns an interrupt handler to an unused
  MSI interrupt and returns the descriptor used to trigger
  it. The descriptor can then be sent to a peer to trigger
  the interrupt.
  The interrupt resource is managed with devres so it will
  be automatically freed when the NTB device is torn down.
  If an IRQ allocated with this function needs to be freed
  separately, ntbm_free_irq() must be used.
  Return: IRQ number assigned on success, otherwise a negative error number.
  ntbm_msi_free_irq() - free an interrupt
  @ntb:	NTB device context
  @irq:	Interrupt line to free
  @dev_id:	Device identity to free
  This function should be used to manually free IRQs allocated with
  ntbm_request_[threaded_]irq().
  ntb_msi_peer_trigger() - Trigger an interrupt handler on a peer
  @ntb:	NTB device context
  @peer:	Peer index
  @desc:	MSI descriptor data which triggers the interrupt
  This function triggers an interrupt on a peer. It requires
  the descriptor structure to have been passed from that peer
  by some other means.
  Return: Zero on success, otherwise a negative error number.
  ntb_msi_peer_addr() - Get the DMA address to trigger a peer's MSI interrupt
  @ntb:	NTB device context
  @peer:	Peer index
  @desc:	MSI descriptor data which triggers the interrupt
  @msi_addr:   Physical address to trigger the interrupt
  This function allows using DMA engines to trigger an interrupt
  (for example, trigger an interrupt to process the data after
  sending it). To trigger the interrupt, write @desc.data to the address
  returned in @msi_addr
  Return: Zero on success, otherwise a negative error number.
  This file is provided under a dual BSDGPLv2 license.  When using or
    redistributing this file, you may do so under either license.
    GPL LICENSE SUMMARY
    Copyright(c) 2012 Intel Corporation. All rights reserved.
    Copyright (C) 2015 EMC Corporation. All Rights Reserved.
    This program is free software; you can redistribute it andor modify
    it under the terms of version 2 of the GNU General Public License as
    published by the Free Software Foundation.
    BSD LICENSE
    Copyright(c) 2012 Intel Corporation. All rights reserved.
    Copyright (C) 2015 EMC Corporation. All Rights Reserved.
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
       Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
       Redistributions in binary form must reproduce the above copy
        notice, this list of conditions and the following disclaimer in
        the documentation andor other materials provided with the
        distribution.
       Neither the name of Intel Corporation nor the names of its
        contributors may be used to endorse or promote products derived
        from this software without specific prior written permission.
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  PCIe NTB Transport Linux driver
  Contact Information:
  Jon Mason <jon.mason@intel.com>
 Only two-ports NTB devices are supported 
 ntb_queue list reference 
 pointers to data to be transferred 
 Only 64 QP's are allowed.  0-63 
 ntb_rx_q_lock: synchronize access to rx_XXXX_q 
 Stats 
  ntb_transport_unregister_client_dev - Unregister NTB client device
  @device_name: Name of NTB client device
  Unregister an NTB client device with the NTB transport layer
  ntb_transport_register_client_dev - Register NTB client device
  @device_name: Name of NTB client device
  Register an NTB client device with the NTB transport layer
 setup and register client devices 
  ntb_transport_register_client - Register NTB client driver
  @drv: NTB client driver to be registered
  Register an NTB client driver with the NTB transport layer
  RETURNS: An appropriate -ERRNO error value on error, or zero for success.
  ntb_transport_unregister_client - Unregister NTB client driver
  @drv: NTB client driver to be unregistered
  Unregister an NTB client driver with the NTB transport layer
  RETURNS: An appropriate -ERRNO error value on error, or zero for success.
 Due to housekeeping, there must be atleast 2 buffs 
	
	  Checking to see if we have more entries than the default.
	  We should add additional entries if that is the case so we
	  can be in sync with the transport frames.
 setup the hdr offsets with 0's 
	
	  we must ensure that the memory address allocated is BAR size
	  aligned in order for the XLAT register to take the value. This
	  is a requirement of the hardware. It is recommended to setup CMA
	  for BAR sizes equal or greater than 4MB.
 No need to re-setup 
 Alloc memory for receiving data.  Must be aligned 
 Notify HW the memory location of the receive buffer 
 Pass along the info to any clients 
	 The scratchpad registers keep the values if the remote side
	  goes down, blast them now to give them a sane value the next
	  time they are accessed
 send the local info, in the opposite order of the way we read it 
 Query the remote side for its info 
 if there's an actual failure, we should just bail 
 query remote spad for qp ready bits 
 See if the remote side is up 
 Due to housekeeping, there must be atleast 2 buffs 
	
	  If we are using MSI, and have at least one extra memory window,
	  we will reserve the last MW for the MSI window.
 Limit the MW's based on the availability of scratchpads 
 verify that all the qp's are freed 
 we need to check DMA results if we are using DMA 
 Ensure that the data is fully copied out before clearing the flag 
	 Limit the number of packets processed in a single interrupt to
	  provide fairness to others
 there is more work to do 
 the doorbell bit is set: clear it 
 ntb_db_read ensures ntb_db_clear write is committed 
		 an interrupt may have arrived between finishing
		  ntb_process_rxc and clearing the doorbell bit:
		  there might be some more work to do.
 we need to check DMA results if we are using DMA 
 resubmit via CPU 
	 The entry length can only be zero if the packet is intended to be a
	  "link down" or similar.  Since no payload is being sent in these
	  cases, there is nothing to add to the completion queue.
	
	  Using non-temporal mov to improve performance on non-cached
	  writes, even though we aren't actually copying from user space.
 Ensure that the data is fully copied out before setting the flags 
  ntb_transport_create_queue - Create a new NTB transport layer queue
  @rx_handler: receive callback function
  @tx_handler: transmit callback function
  @event_handler: event callback function
  Create a new NTB transport layer queue and provide the queue with a callback
  routine for both transmit and receive.  The receive callback routine will be
  used to pass up data when the transport has received it on the queue.   The
  transmit callback routine will be called when the transport has completed the
  transmission of the data on the queue and the data is ready to be freed.
  RETURNS: pointer to newly created ntb_queue, NULL on error.
 decrement free_queue to make it zero based 
  ntb_transport_free_queue - Frees NTB transport queue
  @qp: NTB queue to be freed
  Frees NTB transport queue
		 Putting the dma_chan to NULL will force any new traffic to be
		  processed by the CPU instead of the DAM engine
		 Try to be nice and wait for any queued DMA engine
		  transactions to process before smashing it with a rock
		 Putting the dma_chan to NULL will force any new traffic to be
		  processed by the CPU instead of the DAM engine
		 Try to be nice and wait for any queued DMA engine
		  transactions to process before smashing it with a rock
  ntb_transport_rx_remove - Dequeues enqueued rx packet
  @qp: NTB queue to be freed
  @len: pointer to variable to write enqueued buffers length
  Dequeues unused buffers from receive queue.  Should only be used during
  shutdown of qp.
  RETURNS: NULL error value on error, or void for success.
  ntb_transport_rx_enqueue - Enqueue a new NTB queue entry
  @qp: NTB transport layer queue the entry is to be enqueued on
  @cb: per buffer pointer for callback function to use
  @data: pointer to data buffer that incoming packets will be copied into
  @len: length of the data buffer
  Enqueue a new receive buffer onto the transport queue into which a NTB
  payload can be received into.
  RETURNS: An appropriate -ERRNO error value on error, or zero for success.
  ntb_transport_tx_enqueue - Enqueue a new NTB queue entry
  @qp: NTB transport layer queue the entry is to be enqueued on
  @cb: per buffer pointer for callback function to use
  @data: pointer to data buffer that will be sent
  @len: length of the data buffer
  Enqueue a new transmit buffer onto the transport queue from which a NTB
  payload will be transmitted.  This assumes that a lock is being held to
  serialize access to the qp.
  RETURNS: An appropriate -ERRNO error value on error, or zero for success.
  ntb_transport_link_up - Notify NTB transport of client readiness to use queue
  @qp: NTB transport layer queue to be enabled
  Notify NTB transport layer of client readiness to use queue
  ntb_transport_link_down - Notify NTB transport to no longer enqueue data
  @qp: NTB transport layer queue to be disabled
  Notify NTB transport layer of client's desire to no longer receive data on
  transport queue specified.  It is the client's responsibility to ensure all
  entries on queue are purged or otherwise handled appropriately.
  ntb_transport_link_query - Query transport link state
  @qp: NTB transport layer queue to be queried
  Query connectivity to the remote system of the NTB transport queue
  RETURNS: true for link up or false for link down
  ntb_transport_qp_num - Query the qp number
  @qp: NTB transport layer queue to be queried
  Query qp number of the NTB transport queue
  RETURNS: a zero based number specifying the qp number
  ntb_transport_max_size - Query the max payload size of a qp
  @qp: NTB transport layer queue to be queried
  Query the maximum payload size permissible on the given qp
  RETURNS: the max payload size of a qp
 If DMA engine usage is possible, try to find the max size for that 
  This file is provided under a dual BSDGPLv2 license.  When using or
    redistributing this file, you may do so under either license.
    GPL LICENSE SUMMARY
    Copyright (C) 2015 EMC Corporation. All Rights Reserved.
    Copyright (C) 2016 T-Platforms. All Rights Reserved.
    This program is free software; you can redistribute it andor modify
    it under the terms of version 2 of the GNU General Public License as
    published by the Free Software Foundation.
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
    BSD LICENSE
    Copyright (C) 2015 EMC Corporation. All Rights Reserved.
    Copyright (C) 2016 T-Platforms. All Rights Reserved.
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
       Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
       Redistributions in binary form must reproduce the above copy
        notice, this list of conditions and the following disclaimer in
        the documentation andor other materials provided with the
        distribution.
       Neither the name of Intel Corporation nor the names of its
        contributors may be used to endorse or promote products derived
        from this software without specific prior written permission.
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  PCIe NTB Linux driver
  Contact Information:
  Allen Hubbe <Allen.Hubbe@emc.com>
    This file is provided under a dual BSDGPLv2 license.  When using or
    redistributing this file, you may do so under either license.
    GPL LICENSE SUMMARY
    Copyright (C) 2015 EMC Corporation. All Rights Reserved.
    Copyright (C) 2017 T-Platforms. All Rights Reserved.
    This program is free software; you can redistribute it andor modify
    it under the terms of version 2 of the GNU General Public License as
    published by the Free Software Foundation.
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
    BSD LICENSE
    Copyright (C) 2015 EMC Corporation. All Rights Reserved.
    Copyright (C) 2017 T-Platforms. All Rights Reserved.
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
       Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
       Redistributions in binary form must reproduce the above copy
        notice, this list of conditions and the following disclaimer in
        the documentation andor other materials provided with the
        distribution.
       Neither the name of Intel Corporation nor the names of its
        contributors may be used to endorse or promote products derived
        from this software without specific prior written permission.
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  PCIe NTB Pingpong Linux driver
  How to use this tool, by example.
  Assuming $DBG_DIR is something like:
  'syskerneldebugntb_perf0000:00:03.0'
  Suppose aside from local device there is at least one remote device
  connected to NTB with index 0.
 -----------------------------------------------------------------------------
  Eg: install driver with specified delay between doorbell event and response
  root@self# insmod ntb_pingpong.ko delay_ms=1000
 -----------------------------------------------------------------------------
  Eg: get number of ping-pong cycles performed
  root@self# cat $DBG_DIRcount
 Find next available peer 
 Read pong data 
	
	  Scratchpad and message data may differ, since message register can't
	  be rewritten unless status is cleared. Additionally either of them
	  might be unsupported
 Find global port index 
 Skip message events masking if unsupported 
 Might be not necessary 
 SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
  This file is provided under a dual BSDGPLv2 license.  When using or
    redistributing this file, you may do so under either license.
    GPL LICENSE SUMMARY
    Copyright (C) 2015 EMC Corporation. All Rights Reserved.
    Copyright (C) 2017 T-Platforms All Rights Reserved.
    This program is free software; you can redistribute it andor modify
    it under the terms of version 2 of the GNU General Public License as
    published by the Free Software Foundation.
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
    BSD LICENSE
    Copyright (C) 2015 EMC Corporation. All Rights Reserved.
    Copyright (C) 2017 T-Platforms All Rights Reserved.
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
       Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
       Redistributions in binary form must reproduce the above copy
        notice, this list of conditions and the following disclaimer in
        the documentation andor other materials provided with the
        distribution.
       Neither the name of Intel Corporation nor the names of its
        contributors may be used to endorse or promote products derived
        from this software without specific prior written permission.
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  PCIe NTB Debugging Tool Linux driver
  How to use this tool, by example.
  Assuming $DBG_DIR is something like:
  'syskerneldebugntb_tool0000:00:03.0'
  Suppose aside from local device there is at least one remote device
  connected to NTB with index 0.
 -----------------------------------------------------------------------------
  Eg: check localpeer device information.
  # Get local device port number
  root@self# cat $DBG_DIRport
  # Check local device functionality
  root@self# ls $DBG_DIR
  db            msg1          msg_sts     peer4        port
  db_event      msg2          peer0      peer5        spad0
  db_mask       msg3          peer1      peer_db       spad1
  link          msg_event     peer2      peer_db_mask  spad2
  msg0          msg_mask      peer3      peer_spad     spad3
  # As one can see it supports:
  # 1) four inbound message registers
  # 2) four inbound scratchpads
  # 3) up to six peer devices
  # Check peer device port number
  root@self# cat $DBG_DIRpeer0port
  # Check peer device(s) functionality to be used
  root@self# ls $DBG_DIRpeer0
  link             mw_trans0       mw_trans6        port
  link_event       mw_trans1       mw_trans7        spad0
  msg0             mw_trans2       peer_mw_trans0   spad1
  msg1             mw_trans3       peer_mw_trans1   spad2
  msg2             mw_trans4       peer_mw_trans2   spad3
  msg3             mw_trans5       peer_mw_trans3
  # As one can see we got:
  # 1) four outbound message registers
  # 2) four outbound scratchpads
  # 3) eight inbound memory windows
  # 4) four outbound memory windows
 -----------------------------------------------------------------------------
  Eg: NTB link tests
  # Set local link updown
  root@self# echo Y > $DBG_DIRlink
  root@self# echo N > $DBG_DIRlink
  # Check if link with peer device is updown:
  root@self# cat $DBG_DIRpeer0link
  # Block until the link is updown
  root@self# echo Y > $DBG_DIRpeer0link_event
  root@self# echo N > $DBG_DIRpeer0link_event
 -----------------------------------------------------------------------------
  Eg: Doorbell registers tests (some functionality might be absent)
  # Setclearget local doorbell
  root@self# echo 's 1' > $DBG_DIRdb
  root@self# echo 'c 1' > $DBG_DIRdb
  root@self# cat  $DBG_DIRdb
  # Setclearget local doorbell mask
  root@self# echo 's 1' > $DBG_DIRdb_mask
  root@self# echo 'c 1' > $DBG_DIRdb_mask
  root@self# cat $DBG_DIRdb_mask
  # Ringclearget peer doorbell
  root@peer# echo 's 1' > $DBG_DIRpeer_db
  root@peer# echo 'c 1' > $DBG_DIRpeer_db
  root@peer# cat $DBG_DIRpeer_db
  # Setclearget peer doorbell mask
  root@self# echo 's 1' > $DBG_DIRpeer_db_mask
  root@self# echo 'c 1' > $DBG_DIRpeer_db_mask
  root@self# cat $DBG_DIRpeer_db_mask
  # Block until local doorbell is set with specified value
  root@self# echo 1 > $DBG_DIRdb_event
 -----------------------------------------------------------------------------
  Eg: Message registers tests (functionality might be absent)
  # Setclearget inout message registers status
  root@self# echo 's 1' > $DBG_DIRmsg_sts
  root@self# echo 'c 1' > $DBG_DIRmsg_sts
  root@self# cat $DBG_DIRmsg_sts
  # Setclear inout message registers mask
  root@self# echo 's 1' > $DBG_DIRmsg_mask
  root@self# echo 'c 1' > $DBG_DIRmsg_mask
  # Get inbound message register #0 value and source of port index
  root@self# cat  $DBG_DIRmsg0
  # Send some data to peer over outbound message register #0
  root@self# echo 0x01020304 > $DBG_DIRpeer0msg0
 -----------------------------------------------------------------------------
  Eg: Scratchpad registers tests (functionality might be absent)
  # Writeread tofrom local scratchpad register #0
  root@peer# echo 0x01020304 > $DBG_DIRspad0
  root@peer# cat $DBG_DIRspad0
  # Writeread tofrom peer scratchpad register #0
  root@peer# echo 0x01020304 > $DBG_DIRpeer0spad0
  root@peer# cat $DBG_DIRpeer0spad0
 -----------------------------------------------------------------------------
  Eg: Memory windows tests
  # Create inbound memory window buffer of specified sizeget its base address
  root@peer# echo 16384 > $DBG_DIRpeer0mw_trans0
  root@peer# cat $DBG_DIRpeer0mw_trans0
  # Writeread data tofrom inbound memory window
  root@peer# echo Hello > $DBG_DIRpeer0mw0
  root@peer# head -c 7 $DBG_DIRpeer0mw0
  # Map outbound memory windowcheck it settings (on peer device)
  root@peer# echo 0xADD0BA5E:16384 > $DBG_DIRpeer0peer_mw_trans0
  root@peer# cat $DBG_DIRpeer0peer_mw_trans0
  # Writeread data tofrom outbound memory window (on peer device)
  root@peer# echo olleH > $DBG_DIRpeer0peer_mw0
  root@peer# head -c 7 $DBG_DIRpeer0peer_mw0
  Inbound and outbound memory windows descriptor. Union members selection
  depends on the MW type the structure describes. mm_basedma_base are the
  virtual and DMA address of an inbound MW. io_basetr_base are the MMIO
  mapped virtual and xlat addresses of an outbound MW respectively.
  Wrapper structure is used to distinguish the outbound MW peers reference
  within the corresponding DebugFS directory IO operation.
==============================================================================
                                NTB events handlers
 ==============================================================================
==============================================================================
                         Common readwrite methods
 ==============================================================================
==============================================================================
                             Port readwrite methods
 ==============================================================================
==============================================================================
                        Link state readwrite methods
 ==============================================================================
==============================================================================
                   Memory windows readwritesetting methods
 ==============================================================================
 Initialize outbound memory windows 
 Initialize inbound memory windows and outbound MWs wrapper 
 Free outbound memory windows 
 Free outbound memory windows 
==============================================================================
                        Doorbell readwrite methods
 ==============================================================================
==============================================================================
                        Scratchpads readwrite methods
 ==============================================================================
 Initialize inbound scratchpad structures 
 Initialize outbound scratchpad structures 
==============================================================================
                        Messages readwrite methods
 ==============================================================================
 Initialize inbound message structures 
 Initialize outbound message structures 
==============================================================================
                           Initialization methods
 ==============================================================================
 This modules is useless without dbgfs... 
  This file is provided under a dual BSDGPLv2 license.  When using or
    redistributing this file, you may do so under either license.
    GPL LICENSE SUMMARY
    Copyright(c) 2015 Intel Corporation. All rights reserved.
    Copyright(c) 2017 T-Platforms. All Rights Reserved.
    This program is free software; you can redistribute it andor modify
    it under the terms of version 2 of the GNU General Public License as
    published by the Free Software Foundation.
    BSD LICENSE
    Copyright(c) 2015 Intel Corporation. All rights reserved.
    Copyright(c) 2017 T-Platforms. All Rights Reserved.
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
       Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
       Redistributions in binary form must reproduce the above copy
        notice, this list of conditions and the following disclaimer in
        the documentation andor other materials provided with the
        distribution.
       Neither the name of Intel Corporation nor the names of its
        contributors may be used to endorse or promote products derived
        from this software without specific prior written permission.
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  PCIe NTB Perf Linux driver
  How to use this tool, by example.
  Assuming $DBG_DIR is something like:
  'syskerneldebugntb_perf0000:00:03.0'
  Suppose aside from local device there is at least one remote device
  connected to NTB with index 0.
 -----------------------------------------------------------------------------
  Eg: install driver with specified chunktotal orders and dma-enabled flag
  root@self# insmod ntb_perf.ko chunk_order=19 total_order=28 use_dma
 -----------------------------------------------------------------------------
  Eg: check NTB ports (index) and MW mapping information
  root@self# cat $DBG_DIRinfo
 -----------------------------------------------------------------------------
  Eg: start performance test with peer (index 0) and get the test metrics
  root@self# echo 0 > $DBG_DIRrun
  root@self# cat $DBG_DIRrun
 no larger than 1M 
 512K 
 1G 
 default to 0 
==============================================================================
                          Perf driver data definition
 ==============================================================================
 invalid spad command 
 send out buffer size 
 recv in  buffer size 
 send in  buffer xlat 
 recv out buffer xlat 
 clear allocated memory 
 init is done 
 link up state flag 
 Outbound MW params 
 Inbound MW params 
 NTB connection setup service 
 DMA-based test sync parameters 
 Data source and measured statistics 
 Global device index and peers descriptors 
 Performance measuring work-threads interface 
 ScratchpadMessage IO operations 
  Scratchpads-base commands interface
  Messages-base commands interface
==============================================================================
                            Static data declarations
 ==============================================================================
==============================================================================
                   NTB cross-link commands execution service
 ==============================================================================
	
	  Perform predefined number of attempts before give up.
	  We are sending the data to the port specific scratchpad, so
	  to prevent a multi-port access race-condition. Additionally
	  there is no need in local locking since only thread-safe
	  service work is using this method.
	
	  We start scanning all over, since cleared DB may have been set
	  by any peer. Yes, it makes peer with smaller index being
	  serviced with greater priority, but it's convenient for spad
	  and message code unification and simplicity.
 Next command can be retrieved from now 
	
	  Perform predefined number of attempts before give up. Message
	  registers are free of race-condition problem when accessed
	  from different ports, so we don't need splitting registers
	  by global device index. We also won't have local locking,
	  since the method is used from service work only.
 This call shall trigger peer message event 
 Next command can be retrieved from now 
 No need of memory barrier, since bit ops have invernal lock 
 Return 0 if no data left to process, otherwise an error 
 Just receive all available commands 
 Messages are only sent one-by-one 
 Outbuf size can be unaligned due to custom max_mw_size 
 Initialization is finally done 
 Get inbound MW parameters 
	
	  We submit inbuf xlat transmission cmd for execution here to follow
	  the code architecture, even though this method is called from service
	  work itself so the command will be executed right after it returns.
 Might be not necessary 
==============================================================================
                       Performance measuring work-thread
 ==============================================================================
 Copied field is cleared on test launch stage 
 Give up CPU to give a chance for other threads to use it 
	
	  If test finished without errors, termination isn't needed.
	  We call it anyway just to be sure of the transfers completion.
	
	  Perform stages in compliance with use_dma flag value.
	  Test status is changed only if error happened, otherwise
	  status -ENODATA is kept while test is on-fly. Results
	  synchronization is performed only if test fininshed
	  without an error or interruption.
==============================================================================
                                DebugFS nodes
 ==============================================================================
 They are made read-only for test exec safety and integrity 
==============================================================================
                         Basic driver initialization
 ==============================================================================
 Get outbound MW parameters and map it 
	
	  Hardware with only two ports may not have unique port
	  numbers. In this case, the gidxs should all be zero.
 SPDX-License-Identifier: GPL-2.0
  Host side endpoint driver to implement Non-Transparent Bridge functionality
  Copyright (C) 2020 Texas Instruments
  Author: Kishon Vijay Abraham I <kishon@ti.com>
 1 Sec 
 Mutex to protect providing commands to NTB EPF 
 BAR that contains both control region and self spad region 
 BAR that contains peer spad region 
 BAR that contains Doorbell region and Memory window '1' 
 One Link interrupt and rest doorbell interrupt 
    This file is provided under a GPLv2 license.  When using or
    redistributing this file, you may do so under that license.
    GPL LICENSE SUMMARY
    Copyright (C) 2016-2018 T-Platforms JSC All Rights Reserved.
    This program is free software; you can redistribute it andor modify it
    under the terms and conditions of the GNU General Public License,
    version 2, as published by the Free Software Foundation.
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
    Public License for more details.
    You should have received a copy of the GNU General Public License along
    with this program; if not, one can be found http:www.gnu.orglicenses.
    The full GNU General Public License is included in this distribution in
    the file called "COPYING".
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  IDT PCIe-switch NTB Linux driver
  Contact Information:
  Serge Semin <fancer.lancer@gmail.com>, <Sergey.Semin@t-platforms.ru>
  NT Endpoint registers table simplifying a loop access to the functionally
  related registers
  NT Endpoint ports data table with the corresponding pcie command, link
  status, control and BAR-related registers
0	{ IDT_SW_NTP0_PCIECMDSTS,	IDT_SW_NTP0_PCIELCTLSTS,
1	{0},
2	{ IDT_SW_NTP2_PCIECMDSTS,	IDT_SW_NTP2_PCIELCTLSTS,
3	{0},
4	{ IDT_SW_NTP4_PCIECMDSTS,	IDT_SW_NTP4_PCIELCTLSTS,
5	{0},
6	{ IDT_SW_NTP6_PCIECMDSTS,	IDT_SW_NTP6_PCIELCTLSTS,
7	{0},
8	{ IDT_SW_NTP8_PCIECMDSTS,	IDT_SW_NTP8_PCIELCTLSTS,
9	{0},
10	{0},
11	{0},
12	{ IDT_SW_NTP12_PCIECMDSTS,	IDT_SW_NTP12_PCIELCTLSTS,
13	{0},
14	{0},
15	{0},
16	{ IDT_SW_NTP16_PCIECMDSTS,	IDT_SW_NTP16_PCIELCTLSTS,
17	{0},
18	{0},
19	{0},
20	{ IDT_SW_NTP20_PCIECMDSTS,	IDT_SW_NTP20_PCIELCTLSTS,
21	{0},
22	{0},
23	{0}
  IDT PCIe-switch partitions table with the corresponding control, status
  and messages control registers
0	{ IDT_SW_SWPART0CTL,	IDT_SW_SWPART0STS,
1	{ IDT_SW_SWPART1CTL,	IDT_SW_SWPART1STS,
2	{ IDT_SW_SWPART2CTL,	IDT_SW_SWPART2STS,
3	{ IDT_SW_SWPART3CTL,	IDT_SW_SWPART3STS,
4	{ IDT_SW_SWPART4CTL,	IDT_SW_SWPART4STS,
5	{ IDT_SW_SWPART5CTL,	IDT_SW_SWPART5STS,
6	{ IDT_SW_SWPART6CTL,	IDT_SW_SWPART6STS,
7	{ IDT_SW_SWPART7CTL,	IDT_SW_SWPART7STS,
  DebugFS directory to place the driver debug file
=============================================================================
                 1. IDT PCIe-switch registers IO-functions
     Beside ordinary configuration space registers IDT PCIe-switch expose
  global configuration registers, which are used to determine state of other
  device ports as well as being notified of some switch-related events.
  Additionally all the configuration space registers of all the IDT
  PCIe-switch functions are mapped to the Global Address space, so each
  function can determine a configuration of any other PCI-function.
     Functions declared in this chapter are created to encapsulate access
  to configuration and global registers, so the driver code just need to
  provide IDT NTB hardware descriptor and a register address.
 =============================================================================
  idt_nt_write() - PCI configuration space registers write method
  @ndev:	IDT NTB hardware driver descriptor
  @reg:	Register to write data to
  @data:	Value to write to the register
  IDT PCIe-switch registers are all Little endian.
	
	  It's obvious bug to request a register exceeding the maximum possible
	  value as well as to have it unaligned.
 Just write the value to the specified register 
  idt_nt_read() - PCI configuration space registers read method
  @ndev:	IDT NTB hardware driver descriptor
  @reg:	Register to write data to
  IDT PCIe-switch Global configuration registers are all Little endian.
  Return: register value
	
	  It's obvious bug to request a register exceeding the maximum possible
	  value as well as to have it unaligned.
 Just read the value from the specified register 
  idt_sw_write() - Global registers write method
  @ndev:	IDT NTB hardware driver descriptor
  @reg:	Register to write data to
  @data:	Value to write to the register
  IDT PCIe-switch Global configuration registers are all Little endian.
	
	  It's obvious bug to request a register exceeding the maximum possible
	  value as well as to have it unaligned.
 Lock GASA registers operations 
 Set the global register address 
 Put the new value of the register 
 Unlock GASA registers operations 
  idt_sw_read() - Global registers read method
  @ndev:	IDT NTB hardware driver descriptor
  @reg:	Register to write data to
  IDT PCIe-switch Global configuration registers are all Little endian.
  Return: register value
	
	  It's obvious bug to request a register exceeding the maximum possible
	  value as well as to have it unaligned.
 Lock GASA registers operations 
 Set the global register address 
 Get the data of the register (read ops acts as MMIO barrier) 
 Unlock GASA registers operations 
  idt_reg_set_bits() - set bits of a passed register
  @ndev:	IDT NTB hardware driver descriptor
  @reg:	Register to change bits of
  @reg_lock:	Register access spin lock
  @valid_mask:	Mask of valid bits
  @set_bits:	Bitmask to set
  Helper method to check whether a passed bitfield is valid and set
  corresponding bits of a register.
  WARNING! Make sure the passed register isn't accessed over plane
  idt_nt_write() method (read method is ok to be used concurrently).
  Return: zero on success, negative error on invalid bitmask.
 Lock access to the register unless the change is written back 
 Unlock the register 
  idt_reg_clear_bits() - clear bits of a passed register
  @ndev:	IDT NTB hardware driver descriptor
  @reg:	Register to change bits of
  @reg_lock:	Register access spin lock
  @set_bits:	Bitmask to clear
  Helper method to check whether a passed bitfield is valid and clear
  corresponding bits of a register.
  NOTE! Invalid bits are always considered cleared so it's not an error
  to clear them over.
  WARNING! Make sure the passed register isn't accessed over plane
  idt_nt_write() method (read method is ok to use concurrently).
 Lock access to the register unless the change is written back 
 Unlock the register 
===========================================================================
                            2. Ports operations
     IDT PCIe-switches can have from 3 up to 8 ports with possible
  NT-functions enabled. So all the possible ports need to be scanned looking
  for NTB activated. NTB API will have enumerated only the ports with NTB.
 ===========================================================================
  idt_scan_ports() - scan IDT PCIe-switch ports collecting info in the tables
  @ndev:	Pointer to the PCI device descriptor
  Return: zero on success, otherwise a negative error number.
 Retrieve the local port number 
 Retrieve the local partition number 
 Initialize portpartition -> index tables with invalid values 
	
	  Walk over all the possible ports checking whether any of them has
	  NT-function activated
 Skip local port 
 Read the port status register to get it partition 
 Retrieve the partition status 
 Check if partition state is active and port has NTB 
 Save the port and partition numbers 
 Fill in the portpartition -> index tables 
 It's useless to have this driver loaded if there is no any peer 
  idt_ntb_port_number() - get the local port number
  @ntb:	NTB device context.
  Return: the local port number
  idt_ntb_peer_port_count() - get the number of peer ports
  @ntb:	NTB device context.
  Return the count of detected peer NT-functions.
  Return: number of peer ports
  idt_ntb_peer_port_number() - get peer port by given index
  @ntb:	NTB device context.
  @pidx:	Peer port index.
  Return: peer port or negative error
 Return the detected NT-function port number 
  idt_ntb_peer_port_idx() - get peer port index by given port number
  @ntb:	NTB device context.
  @port:	Peer port number.
  Internal port -> index table is pre-initialized with -EINVAL values,
  so we just need to return it value
  Return: peer NT-function port index or negative error
===========================================================================
                          3. Link status operations
     There is no any ready-to-use method to have peer ports notified if NTB
  link is set up or got down. Instead global signal can be used instead.
  In case if any one of ports changes local NTB link state, it sends
  global signal and clears corresponding global state bit. Then all the ports
  receive a notification of that, so to make client driver being aware of
  possible NTB link change.
     Additionally each of active NT-functions is subscribed to PCIe-link
  state changes of peer ports.
 ===========================================================================
  idt_init_link() - Initialize NTB link state notification subsystem
  @ndev:	IDT NTB hardware driver descriptor
  Function performs the basic initialization of some global registers
  needed to enable IRQ-based notifications of PCIe Link UpDown and
  Global Signal events.
  NOTE Since it's not possible to determine when all the NTB peer drivers are
  unloaded as well as have those registers accessed concurrently, we must
  preinitialize them with the same value and leave it uncleared on local
  driver unload.
 Initialize spin locker of Mapping Table access registers 
 Walk over all detected peers collecting port and partition masks 
 Clean the Link UpDown and GLobal Signal status registers 
 Unmask NT-activated partitions to receive Global Switch events 
 Enable PCIe Link Up events of NT-activated ports 
 Enable PCIe Link Down events of NT-activated ports 
 Unmask NT-activated partitions to receive Global Signal events 
 Unmask Link UpDown and Global Switch Events 
  idt_deinit_link() - deinitialize link subsystem
  @ndev:	IDT NTB hardware driver descriptor
  Just disable the link back.
 Disable the link 
  idt_se_isr() - switch events ISR
  @ndev:	IDT NTB hardware driver descriptor
  @ntint_sts:	NT-function interrupt status
  This driver doesn't support IDT PCIe-switch dynamic reconfigurations,
  Failover capability, etc, so switch events are utilized to notify of
  PCIe and NTB link events.
  The method is called from PCIe ISR bottom-half routine.
 Read Switch Events status 
 Clean the Link UpDown and Global Signal status registers 
 Clean the corresponding interrupt bit 
 Notify the client driver of possible link state change 
  idt_ntb_local_link_enable() - enable the local NTB link.
  @ndev:	IDT NTB hardware driver descriptor
  In order to enable the NTB link we need:
  - enable Completion TLPs translation
  - initialize mapping table to enable the Request ID translation
  - notify peers of NTB link state change
 Enable the ID protection and Completion TLPs translation 
 Retrieve the current Requester ID (Bus:Device:Function) 
	
	  Set the corresponding NT Mapping table entry of port partition index
	  with the data to perform the Request ID translation
 Notify the peers by setting and clearing the global signal bit 
  idt_ntb_local_link_disable() - disable the local NTB link.
  @ndev:	IDT NTB hardware driver descriptor
  In order to enable the NTB link we need:
  - disable Completion TLPs translation
  - clear corresponding mapping table entry
  - notify peers of NTB link state change
 Disable Completion TLPs translation 
 Clear the corresponding NT Mapping table entry 
 Notify the peers by setting and clearing the global signal bit 
  idt_ntb_local_link_is_up() - test wethter local NTB link is up
  @ndev:	IDT NTB hardware driver descriptor
  Local link is up under the following conditions:
  - Bus mastering is enabled
  - NTCTL has Completion TLPs translation enabled
  - Mapping table permits Request TLPs translation
  NOTE: We don't need to check PCIe link state since it's obviously
  up while we are able to communicate with IDT PCIe-switch
  Return: true if link is up, otherwise false
 Read the local Bus Master Enable status 
 Read the local Completion TLPs translation enable status 
 Read Mapping table entry corresponding to the local partition 
  idt_ntb_peer_link_is_up() - test whether peer NTB link is up
  @ndev:	IDT NTB hardware driver descriptor
  @pidx:	Peer port index
  Peer link is up under the following conditions:
  - PCIe link is up
  - Bus mastering is enabled
  - NTCTL has Completion TLPs translation enabled
  - Mapping table permits Request TLPs translation
  Return: true if link is up, otherwise false
 Retrieve the device port number 
 Check whether PCIe link is up 
 Check whether bus mastering is enabled on the peer port 
 Check if Completion TLPs translation is enabled on the peer port 
 Read Mapping table entry corresponding to the peer partition 
  idt_ntb_link_is_up() - get the current ntb link state (NTB API callback)
  @ntb:	NTB device context.
  @speed:	OUT - The link speed expressed as PCIe generation number.
  @width:	OUT - The link width expressed as the number of PCIe lanes.
  Get the bitfield of NTB link states for all peer ports
  Return: bitfield of indexed ports link state: bit is setcleared if the
          link is updown respectively.
 Retrieve the local link speed and width 
 If local NTB link isn't up then all the links are considered down 
 Collect all the peer ports link states into the bitfield 
  idt_ntb_link_enable() - enable local port ntb link (NTB API callback)
  @ntb:	NTB device context.
  @max_speed:	The maximum link speed expressed as PCIe generation number.
  @max_width:	The maximum link width expressed as the number of PCIe lanes.
  Enable just local NTB link. PCIe link parameters are ignored.
  Return: always zero.
 Just enable the local NTB link 
  idt_ntb_link_disable() - disable local port ntb link (NTB API callback)
  @ntb:	NTB device context.
  Disable just local NTB link.
  Return: always zero.
 Just disable the local NTB link 
=============================================================================
                          4. Memory Window operations
     IDT PCIe-switches have two types of memory windows: MWs with direct
  address translation and MWs with LUT based translation. The first type of
  MWs is simple map of corresponding BAR address space to a memory space
  of specified target port. So it implemets just ont-to-one mapping. Lookup
  table in its turn can map one BAR address space to up to 24 different
  memory spaces of different ports.
     NT-functions BARs can be turned on to implement either direct or lookup
  table based address translations, so:
  BAR0 - NT configuration registers spacedirect address translation
  BAR1 - direct address translationupper address of BAR0x64
  BAR2 - direct address translationLookup table with either 12 or 24 entries
  BAR3 - direct address translationupper address of BAR2x64
  BAR4 - direct address translationLookup table with either 12 or 24 entries
  BAR5 - direct address translationupper address of BAR4x64
     Additionally BAR2 and BAR4 can't have 24-entries LUT enabled at the same
  time. Since the BARs setup can be rather complicated this driver implements
  a scanning algorithm to have all the possible memory windows configuration
  covered.
  NOTE 1 BAR setup must be done before Linux kernel enumerated NT-function
  of any port, so this driver would have memory windows configurations fixed.
  In this way all initializations must be performed either by platform BIOS
  or using EEPROM connected to IDT PCIe-switch master SMBus.
  NOTE 2 This driver expects BAR0 mapping NT-function configuration space.
  Easy calculation can give us an upper boundary of 29 possible memory windows
  per each NT-function if all the BARs are of 32bit type.
 =============================================================================
  idt_get_mw_count() - get memory window count
  @mw_type:	Memory window type
  Return: number of memory windows with respect to the BAR type
  idt_get_mw_name() - get memory window name
  @mw_type:	Memory window type
  Return: pointer to a string with name
  idt_scan_mws() - scan memory windows of the port
  @ndev:	IDT NTB hardware driver descriptor
  @port:	Port to get number of memory windows for
  @mw_cnt:	Out - number of memory windows
  It walks over BAR setup registers of the specified port and determines
  the memory windows parameters if any activated.
  Return: array of memory windows
 Retrieve the array of the BARs registers 
 Scan all the BARs belonging to the port 
 Read BARSETUP register value 
 Skip disabled BARs 
 Skip next BARSETUP if current one has 64bit addressing 
 Skip configuration space mapping BARs 
 Retrieve MW typeentries count and aperture size 
 Save configurations of all available memory windows 
			
			  IDT can expose a limited number of MWs, so it's bug
			  to have more than the driver expects
 Save basic MW info 
 It's always DWORD aligned 
 DIR and LUT approachs differently configure MWs 
 Allocate memory for memory window descriptors 
 Copy the info of detected memory windows 
  idt_init_mws() - initialize memory windows subsystem
  @ndev:	IDT NTB hardware driver descriptor
  Scan BAR setup registers of local and peer ports to determine the
  outbound and inbound memory windows parameters
  Return: zero on success, otherwise a negative error number
 Scan memory windows of the local port 
 Scan memory windows of the peer ports 
 Initialize spin locker of the LUT registers 
  idt_ntb_mw_count() - number of inbound memory windows (NTB API callback)
  @ntb:	NTB device context.
  @pidx:	Port index of peer device.
  The value is returned for the specified peer, so generally speaking it can
  be different for different port depending on the IDT PCIe-switch
  initialization.
  Return: the number of memory windows.
  idt_ntb_mw_get_align() - inbound memory window parameters (NTB API callback)
  @ntb:	NTB device context.
  @pidx:	Port index of peer device.
  @widx:	Memory window index.
  @addr_align:	OUT - the base alignment for translating the memory window
  @size_align:	OUT - the size alignment for translating the memory window
  @size_max:	OUT - the maximum size of the memory window
  The peer memory window parameters have already been determined, so just
  return the corresponding values, which mustn't change within session.
  Return: Zero on success, otherwise a negative error number.
  idt_ntb_peer_mw_count() - number of outbound memory windows
 			     (NTB API callback)
  @ntb:	NTB device context.
  Outbound memory windows parameters have been determined based on the
  BAR setup registers value, which are mostly constants within one session.
  Return: the number of memory windows.
  idt_ntb_peer_mw_get_addr() - get map address of an outbound memory window
 				(NTB API callback)
  @ntb:	NTB device context.
  @widx:	Memory window index (within ntb_peer_mw_count() return value).
  @base:	OUT - the base address of mapping region.
  @size:	OUT - the size of mapping region.
  Return just parameters of BAR resources mapping. Size reflects just the size
  of the resource
  Return: Zero on success, otherwise a negative error number.
 Mapping address is just properly shifted BAR resource start 
 Mapping size has already been calculated at MWs scanning 
  idt_ntb_peer_mw_set_trans() - set a translation address of a memory window
 				 (NTB API callback)
  @ntb:	NTB device context.
  @pidx:	Port index of peer device the translation address received from.
  @widx:	Memory window index.
  @addr:	The dma address of the shared memory to access.
  @size:	The size of the shared memory to access.
  The Direct address translation and LUT base translation is initialized a
  bit differenet. Although the parameters restriction are now determined by
  the same code.
  Return: Zero on success, otherwise an error number.
	
	  Retrieve the memory window config to make sure the passed arguments
	  fit it restrictions
 DIR and LUT based translations are initialized differently 
 Set destination partition of translation 
 Set translation base address 
 Set the custom BAR aperture limit 
 Initialize corresponding LUT entry 
 Limit address isn't specified since size is fixed for LUT 
  idt_ntb_peer_mw_clear_trans() - clear the outbound MW translation address
 				   (NTB API callback)
  @ntb:	NTB device context.
  @pidx:	Port index of peer device.
  @widx:	Memory window index.
  It effectively disables the translation over the specified outbound MW.
  Return: Zero on success, otherwise an error number.
 DIR and LUT based translations are initialized differently 
 Read BARSETUP to check BAR type 
 Disable translation by specifying zero BAR limit 
 Clear the corresponding LUT entry up 
=============================================================================
                           5. Doorbell operations
     Doorbell functionality of IDT PCIe-switches is pretty unusual. First of
  all there is global doorbell register which state can be changed by any
  NT-function of the IDT device in accordance with global permissions. These
  permissions configs are not supported by NTB API, so it must be done by
  either BIOS or EEPROM settings. In the same way the state of the global
  doorbell is reflected to the NT-functions local inbound doorbell registers.
  It can lead to situations when client driver sets some peer doorbell bits
  and get them bounced back to local inbound doorbell if permissions are
  granted.
     Secondly there is just one IRQ vector for Doorbell, Message, Temperature
  and Switch events, so if client driver left any of Doorbell bits set and
  some other event occurred, the driver will be notified of Doorbell event
  again.
 =============================================================================
  idt_db_isr() - doorbell event ISR
  @ndev:	IDT NTB hardware driver descriptor
  @ntint_sts:	NT-function interrupt status
  Doorbell event happans when DBELL bit of NTINTSTS switches from 0 to 1.
  It happens only when unmasked doorbell bits are set to ones on completely
  zeroed doorbell register.
  The method is called from PCIe ISR bottom-half routine.
	
	  Doorbell IRQ status will be cleaned only when client
	  driver unsets all the doorbell bits.
 Notify the client driver of possible doorbell state change 
  idt_ntb_db_valid_mask() - get a mask of doorbell bits supported by the ntb
 			     (NTB API callback)
  @ntb:	NTB device context.
  IDT PCIe-switches expose just one Doorbell register of DWORD size.
  Return: A mask of doorbell bits supported by the ntb.
  idt_ntb_db_read() - read the local doorbell register (NTB API callback)
  @ntb:	NTB device context.
  There is just on inbound doorbell register of each NT-function, so
  this method return it value.
  Return: The bits currently set in the local doorbell register.
  idt_ntb_db_clear() - clear bits in the local doorbell register
 			(NTB API callback)
  @ntb:	NTB device context.
  @db_bits:	Doorbell bits to clear.
  Clear bits of inbound doorbell register by writing ones to it.
  NOTE! Invalid bits are always considered cleared so it's not an error
  to clear them over.
  Return: always zero as success.
  idt_ntb_db_read_mask() - read the local doorbell mask (NTB API callback)
  @ntb:	NTB device context.
  Each inbound doorbell bit can be masked from generating IRQ by setting
  the corresponding bit in inbound doorbell mask. So this method returns
  the value of the register.
  Return: The bits currently set in the local doorbell mask register.
  idt_ntb_db_set_mask() - set bits in the local doorbell mask
 			   (NTB API callback)
  @ntb:	NTB device context.
  @db_bits:	Doorbell mask bits to set.
  The inbound doorbell register mask value must be read, then OR'ed with
  passed field and only then set back.
  Return: zero on success, negative error if invalid argument passed.
  idt_ntb_db_clear_mask() - clear bits in the local doorbell mask
 			     (NTB API callback)
  @ntb:	NTB device context.
  @db_bits:	Doorbell bits to clear.
  The method just clears the set bits up in accordance with the passed
  bitfield. IDT PCIe-switch shall generate an interrupt if there hasn't
  been any unmasked bit set before current unmasking. Otherwise IRQ won't
  be generated since there is only one IRQ vector for all doorbells.
  Return: always zero as success
  idt_ntb_peer_db_set() - set bits in the peer doorbell register
 			   (NTB API callback)
  @ntb:	NTB device context.
  @db_bits:	Doorbell bits to set.
  IDT PCIe-switches exposes local outbound doorbell register to change peer
  inbound doorbell register state.
  Return: zero on success, negative error if invalid argument passed.
=============================================================================
                           6. Messaging operations
     Each NT-function of IDT PCIe-switch has four inbound and four outbound
  message registers. Each outbound message register can be connected to one or
  even more than one peer inbound message registers by setting global
  configurations. Since NTB API permits one-on-one message registers mapping
  only, the driver acts in according with that restriction.
 =============================================================================
  idt_init_msg() - initialize messaging interface
  @ndev:	IDT NTB hardware driver descriptor
  Just initialize the message registers routing tables locker.
 Init the messages routing table lockers 
  idt_msg_isr() - message event ISR
  @ndev:	IDT NTB hardware driver descriptor
  @ntint_sts:	NT-function interrupt status
  Message event happens when MSG bit of NTINTSTS switches from 0 to 1.
  It happens only when unmasked message status bits are set to ones on
  completely zeroed message status register.
  The method is called from PCIe ISR bottom-half routine.
	
	  Message IRQ status will be cleaned only when client
	  driver unsets all the message status bits.
 Notify the client driver of possible message status change 
  idt_ntb_msg_count() - get the number of message registers (NTB API callback)
  @ntb:	NTB device context.
  IDT PCIe-switches support four message registers.
  Return: the number of message registers.
  idt_ntb_msg_inbits() - get a bitfield of inbound message registers status
 			  (NTB API callback)
  @ntb:	NTB device context.
  NT message status register is shared between inbound and outbound message
  registers status
  Return: bitfield of inbound message registers.
  idt_ntb_msg_outbits() - get a bitfield of outbound message registers status
 			  (NTB API callback)
  @ntb:	NTB device context.
  NT message status register is shared between inbound and outbound message
  registers status
  Return: bitfield of outbound message registers.
  idt_ntb_msg_read_sts() - read the message registers status (NTB API callback)
  @ntb:	NTB device context.
  IDT PCIe-switches expose message status registers to notify drivers of
  incoming data and failures in case if peer message register isn't freed.
  Return: status bits of message registers
  idt_ntb_msg_clear_sts() - clear status bits of message registers
 			     (NTB API callback)
  @ntb:	NTB device context.
  @sts_bits:	Status bits to clear.
  Clear bits in the status register by writing ones.
  NOTE! Invalid bits are always considered cleared so it's not an error
  to clear them over.
  Return: always zero as success.
  idt_ntb_msg_set_mask() - set mask of message register status bits
 			    (NTB API callback)
  @ntb:	NTB device context.
  @mask_bits:	Mask bits.
  Mask the message status bits from raising an IRQ.
  Return: zero on success, negative error if invalid argument passed.
  idt_ntb_msg_clear_mask() - clear message registers mask
 			      (NTB API callback)
  @ntb:	NTB device context.
  @mask_bits:	Mask bits.
  Clear mask of message status bits IRQs.
  Return: always zero as success.
  idt_ntb_msg_read() - read message register with specified index
 			(NTB API callback)
  @ntb:	NTB device context.
  @pidx:	OUT - Port index of peer device a message retrieved from
  @midx:	Message register index
  Read data from the specified message register and source register.
  Return: inbound message register value.
 Retrieve source port index of the message 
 Sanity check partition index (for initial case) 
 Retrieve data of the corresponding message register 
  idt_ntb_peer_msg_write() - write data to the specified message register
 			      (NTB API callback)
  @ntb:	NTB device context.
  @pidx:	Port index of peer device a message being sent to
  @midx:	Message register index
  @msg:	Data to send
  Just try to send data to a peer. Message status register should be
  checked by client driver.
  Return: zero on success, negative error if invalid argument passed.
 Collect the routing information 
 Lock the messages routing table of the specified register 
 Set the route and send the data 
 Unlock the messages routing table 
 Client driver shall check the status register 
=============================================================================
                       7. Temperature sensor operations
     IDT PCIe-switch has an embedded temperature sensor, which can be used to
  check current chip core temperature. Since a workload environment can be
  different on different platforms, an offset and ADCfilter settings can be
  specified. Although the offset configuration is only exposed to the sysfs
  hwmon interface at the moment. The rest of the settings can be adjusted
  for instance by the BIOSEEPROM firmware.
 =============================================================================
  idt_get_deg() - convert millidegree Celsius value to just degree
  @mdegC:	IN - millidegree Celsius value
  Return: Degree corresponding to the passed millidegree value
  idt_get_frac() - retrieve 00.5 fraction of the millidegree Celsius value
  @mdegC:	IN - millidegree Celsius value
  Return: 00.5 degree fraction of the passed millidegree value
  idt_get_temp_fmt() - convert millidegree Celsius value to 0:7:1 format
  @mdegC:	IN - millidegree Celsius value
  Return: 0:7:1 format acceptable by the IDT temperature sensor
  idt_get_temp_sval() - convert temp sample to signed millidegree Celsius
  @data:	IN - shifted to LSB 8-bits temperature sample
  Return: signed millidegree Celsius
  idt_get_temp_sval() - convert temp sample to unsigned millidegree Celsius
  @data:	IN - shifted to LSB 8-bits temperature sample
  Return: unsigned millidegree Celsius
  idt_read_temp() - read temperature from chip sensor
  @ntb:	NTB device context.
  @type:	IN - type of the temperature value to read
  @val:	OUT - integer value of temperature in millidegree Celsius
 Alter the temperature field in accordance with the passed type 
 This is the only field with signed 0:7:1 format 
 The rest of the fields accept unsigned 0:7:1 format 
  idt_write_temp() - write temperature to the chip sensor register
  @ntb:	NTB device context.
  @type:	IN - type of the temperature value to change
  @val:	IN - integer value of temperature in millidegree Celsius
 Retrieve the properly formatted temperature value 
  idt_sysfs_show_temp() - printout corresponding temperature value
  @dev:	Pointer to the NTB device structure
  @da:		Sensor device attribute structure
  @buf:	Buffer to print temperature out
  Return: Number of written symbols or negative error
  idt_sysfs_set_temp() - set corresponding temperature value
  @dev:	Pointer to the NTB device structure
  @da:		Sensor device attribute structure
  @buf:	Buffer to print temperature out
  @count:	Size of the passed buffer
  Return: Number of written symbols or negative error
 Clamp the passed value in accordance with the type 
  idt_sysfs_reset_hist() - reset temperature history
  @dev:	Pointer to the NTB device structure
  @da:		Sensor device attribute structure
  @buf:	Buffer to print temperature out
  @count:	Size of the passed buffer
  Return: Number of written symbols or negative error
	 Just set the maximal value to the lowest temperature field and
	  minimal value to the highest temperature field
  Hwmon IDT sysfs attributes
  Hwmon IDT sysfs attributes group
  idt_init_temp() - initialize temperature sensor interface
  @ndev:	IDT NTB hardware driver descriptor
  Simple sensor initializarion method is responsible for device switching
  on and resource management based hwmon interface registration. Note, that
  since the device is shared we won't disable it on remove, but leave it
  working until the system is powered off.
 Enable sensor if it hasn't been already 
 Initialize hwmon interface fields 
=============================================================================
                            8. ISRs related operations
     IDT PCIe-switch has strangely developed IRQ system. There is just one
  interrupt vector for doorbell and message registers. So the hardware driver
  can't determine actual source of IRQ if, for example, message event happened
  while any of unmasked doorbell is still set. The similar situation may be if
  switch or temperature sensor events pop up. The difference is that SEVENT
  and TMPSENSOR bits of NT interrupt status register can be cleaned by
  IRQ handler so a next interrupt request won't have false handling of
  corresponding events.
     The hardware driver has only bottom-half handler of the IRQ, since if any
  of events happened the device won't raise it again before the last one is
  handled by clearing of corresponding NTINTSTS bit.
 =============================================================================
  idt_init_isr() - initialize PCIe interrupt handler
  @ndev:	IDT NTB hardware driver descriptor
  Return: zero on success, otherwise a negative error number.
 Allocate just one interrupt vector for the ISR 
 Retrieve the IRQ vector 
 Set the IRQ handler 
 Unmask MessageDoorbellSE interrupts 
 From now on the interrupts are enabled 
  idt_deinit_ist() - deinitialize PCIe interrupt handler
  @ndev:	IDT NTB hardware driver descriptor
  Disable corresponding interrupts and free allocated IRQ vectors.
 Mask interrupts back 
 Manually free IRQ otherwise PCI free irq vectors will fail 
 Free allocated IRQ vectors 
  idt_thread_isr() - NT function interrupts handler
  @irq:	IRQ number
  @devid:	Custom buffer
  It reads current NT interrupts state register and handles all the event
  it declares.
  The method is bottom-half routine of actual default PCIe IRQ handler.
 Read the NT interrupts status register 
 Handle messaging interrupts 
 Handle doorbell interrupts 
 Handle switch event interrupts 
===========================================================================
                      9. NTB hardware driver initialization
 ===========================================================================
  NTB API operations
  idt_register_device() - register IDT NTB device
  @ndev:	IDT NTB hardware driver descriptor
  Return: zero on success, otherwise a negative error number.
 Initialize the rest of NTB device structure and register it 
  idt_unregister_device() - unregister IDT NTB device
  @ndev:	IDT NTB hardware driver descriptor
 Just unregister the NTB device 
=============================================================================
                         10. DebugFS node initialization
 =============================================================================
  Driver DebugFS info file operations
  idt_dbgfs_info_read() - DebugFS read info node callback
  @file:	File node descriptor.
  @ubuf:	User-space buffer to put data to
  @count:	Size of the buffer
  @offp:	Offset within the buffer
 Lets limit the buffer size the way the IntelAMD drivers do 
 Allocate the memory for the buffer 
 Put the data into the string buffer 
 General local device configurations 
 Peer ports information 
 Links status 
 Mapping table entries 
 Print valid entries only 
 Outbound memory windows information 
 Print Memory Window information 
 Inbound memory windows information 
 Print Memory Windows information 
 Doorbell information 
 Messaging information 
 Current temperature 
 Copy the buffer to the User Space 
  idt_init_dbgfs() - initialize DebugFS node
  @ndev:	IDT NTB hardware driver descriptor
  Return: zero on success, otherwise a negative error number.
 If the top directory is not created then do nothing 
 Create the info file node 
  idt_deinit_dbgfs() - deinitialize DebugFS node
  @ndev:	IDT NTB hardware driver descriptor
  Just discard the info node from DebugFS
=============================================================================
                      11. Basic PCIe device initialization
 =============================================================================
  idt_check_setup() - Check whether the IDT PCIe-swtich is properly
 		       pre-initialized
  @pdev:	Pointer to the PCI device descriptor
  Return: zero on success, otherwise a negative error number.
 Read the BARSETUP0 
 Check whether the BAR0 register is enabled to be of config space 
 Configuration space BAR0 must have certain size 
  Create the IDT PCIe-switch driver descriptor
  @pdev:	Pointer to the PCI device descriptor
  @id:		IDT PCIe-device configuration
  It just allocates a memory for IDT PCIe-switch device structure and
  initializes some commonly used fields.
  No need of release method, since managed device resource is used for
  memory allocation.
  Return: pointer to the descriptor, otherwise a negative error number.
 Allocate memory for the IDT PCIe-device descriptor 
 Save the IDT PCIe-switch ports configuration 
 Save the PCI-device pointer inside the NTB device structure 
 Initialize spin locker of Doorbell, Message and GASA registers 
  idt_init_pci() - initialize the basic PCI-related subsystem
  @ndev:	Pointer to the IDT PCIe-switch driver descriptor
  Managed device resources will be freed automatically in case of failure or
  driver detachment.
  Return: zero on success, otherwise negative error number.
 Initialize the bit mask of PCINTB DMA 
	
	  Enable the device advanced error reporting. It's not critical to
	  have AER disabled in the kernel.
 Cleanup nonfatal error status before getting to init 
 First enable the PCI device 
	
	  Enable the bus mastering, which effectively enables MSI IRQs and
	  Request TLPs translation
 Request all BARs resources and map BAR0 only 
 Retrieve virtual address of BAR0 - PCI configuration space 
 Put the IDT driver data pointer to the PCI-device private pointer 
  idt_deinit_pci() - deinitialize the basic PCI-related subsystem
  @ndev:	Pointer to the IDT PCIe-switch driver descriptor
  Managed resources will be freed on the driver detachment
 Clean up the PCI-device private data pointer 
 Clear the bus master disabling the Request TLPs translation 
 Disable the AER capability 
===========================================================================
                        12. PCI bus callback functions
 ===========================================================================
  idt_pci_probe() - PCI device probe callback
  @pdev:	Pointer to PCI device structure
  @id:		PCIe device custom descriptor
  Return: zero on success, otherwise negative error number
 Check whether IDT PCIe-switch is properly pre-initialized 
 Allocate the memory for IDT NTB device data 
 Initialize the basic PCI subsystem of the device 
 Scan ports of the IDT PCIe-switch 
 Initialize NTB link events subsystem 
 Initialize MWs subsystem 
 Initialize Messaging subsystem 
 Initialize hwmon interface 
 Initialize IDT interrupts handler 
 Register IDT NTB devices on the NTB bus 
 Initialize DebugFS info node 
 IDT PCIe-switch NTB driver is finally initialized 
 May the force be with us... 
  idt_pci_probe() - PCI device remove callback
  @pdev:	Pointer to PCI device structure
 Deinit the DebugFS node 
 Unregister NTB device 
 Stop the interrupts handling 
 Deinitialize link event subsystem 
 Deinit basic PCI subsystem 
 IDT PCIe-switch NTB driver is finally initialized 
 Sayonara... 
  IDT PCIe-switch models ports configuration structures
  PCI-ids table of the supported IDT PCIe-switch devices
  IDT PCIe-switch NT-function device driver structure definition
 Create the top DebugFS directory if the FS is initialized 
 Register the NTB hardware driver to handle the PCI device 
 Unregister the NTB hardware driver 
 Discard the top DebugFS directory 
 SPDX-License-Identifier: GPL-2.0-only
  Microsemi Switchtec(tm) PCIe Management Driver
  Copyright (c) 2017, Microsemi Corporation
 synchronize rmw access of db_mask and hw reg 
		
		  In certain circumstances we can get a buffer that is
		  not aligned to its size. (Most of the time
		  dma_alloc_coherent ensures this). This can happen when
		  using large buffers allocated by the CMA
		  (see CMA_CONFIG_ALIGNMENT)
		
		  This is the direct BAR shared with the LUTs
		  which means the actual window will be offset
		  by the size of all the LUT entries.
  In crosslink configuration there is a virtual partition in the
  middle of the two switches. The BARs in this partition have to be
  enumerated and assigned addresses.
  There are 64 doorbells in the switch hardware but this is
  shared among all partitions. So we must split them in half
  (32 for each partition). However, the message interrupts are
  also shared with the top 4 doorbells so we just limit this to
  28 doorbells per partition.
  In crosslink mode, each side has it's own dbmsg register so
  they can each use all 60 of the available doorbells.
	
	  Root Complex Requester ID (which is 0:00.0)
	
	  Host Bridge Requester ID (as read from the mmap address)
	
	  If this host crashed, the other host may think the link is
	  still up. Tell them to force it down (it will go back up
	  once we register the ntb device).
 SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
 Copyright(c) 2020 Intel Corporation. All rights reserved. 
	
	  We need to write to DLLSCS bit in the SLOTSTS before we
	  can clear the hardware link interrupt on ICX NTB.
	
	  The MSIX vectors and the interrupt status bits are not lined up
	  on Gen3 (Skylake) and Gen4. By default the link status bit is bit
	  32, however it is by default MSIX vector0. We need to fixup to
	  line them up. The vectors at reset is 1-32,0. We need to reprogram
	  to 0-32.
 setup incoming bar limits == base addrs (zero length windows) 
 zero incoming translation addrs 
, ppd0;
 init link setup 
 hardware requires that addr is aligned to bar size 
 make sure the range fits in the usable mw size 
 Set the limit if supported, if size is not mw_size 
 set and verify setting the translation address 
 set and verify setting the limit 
 Setup active snoop LTR values 
 Setup active non-snoop values 
 Setup idle snoop LTR values 
 Setup idle non-snoop values 
 setup PCIe LTR to active 
 start link training in PPD0 
 make sure link training has started 
 clear the snoop bits 
 set LTR to idle 
  This file is provided under a dual BSDGPLv2 license.  When using or
    redistributing this file, you may do so under either license.
    GPL LICENSE SUMMARY
    Copyright(c) 2017 Intel Corporation. All rights reserved.
    This program is free software; you can redistribute it andor modify
    it under the terms of version 2 of the GNU General Public License as
    published by the Free Software Foundation.
    BSD LICENSE
    Copyright(c) 2017 Intel Corporation. All rights reserved.
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
       Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
       Redistributions in binary form must reproduce the above copy
        notice, this list of conditions and the following disclaimer in
        the documentation andor other materials provided with the
        distribution.
       Neither the name of Intel Corporation nor the names of its
        contributors may be used to endorse or promote products derived
        from this software without specific prior written permission.
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  Intel PCIe GEN3 NTB Linux driver
	.bar0_base		= GEN3_EMBAR0_OFFSET, 
	
	  The MSIX vectors and the interrupt status bits are not lined up
	  on Skylake. By default the link status bit is bit 32, however it
	  is by default MSIX vector0. We need to fixup to line them up.
	  The vectors at reset is 1-32,0. We need to reprogram to 0-32.
 move link status down one as workaround 
 setup incoming bar limits == base addrs (zero length windows) 
 zero incoming translation addrs 
 DB fixup for using 31 right now 
 Enable Bus Master and Memory Space on the secondary side 
 hardware requires that addr is aligned to bar size 
 make sure the range fits in the usable mw size 
 Set the limit if supported, if size is not mw_size 
 set and verify setting the translation address 
 set and verify setting the limit 
 setup the EP 
 set and verify setting the limit 
  This file is provided under a dual BSDGPLv2 license.  When using or
    redistributing this file, you may do so under either license.
    GPL LICENSE SUMMARY
    Copyright(c) 2012 Intel Corporation. All rights reserved.
    Copyright (C) 2015 EMC Corporation. All Rights Reserved.
    Copyright (C) 2016 T-Platforms. All Rights Reserved.
    This program is free software; you can redistribute it andor modify
    it under the terms of version 2 of the GNU General Public License as
    published by the Free Software Foundation.
    BSD LICENSE
    Copyright(c) 2012 Intel Corporation. All rights reserved.
    Copyright (C) 2015 EMC Corporation. All Rights Reserved.
    Copyright (C) 2016 T-Platforms. All Rights Reserved.
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
       Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
       Redistributions in binary form must reproduce the above copy
        notice, this list of conditions and the following disclaimer in
        the documentation andor other materials provided with the
        distribution.
       Neither the name of Intel Corporation nor the names of its
        contributors may be used to endorse or promote products derived
        from this software without specific prior written permission.
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  Intel PCIe NTB Linux driver
 Only B2B has a workaround to avoid SDOORBELL 
 No low level workaround to avoid SB01BASE 
 Mask all doorbell interrupts 
 Try to set up msix irq 
 Try to set up msi irq 
 Try to set up intx irq 
 Mask all doorbell interrupts 
 hardware requires that addr is aligned to bar size 
 make sure the range fits in the usable mw size 
 Set the limit if supported, if size is not mw_size 
 set and verify setting the translation address 
 set and verify setting the limit 
 split bar addr range must all be 32 bit 
 Set the limit if supported, if size is not mw_size 
 set and verify setting the translation address 
 set and verify setting the limit 
		 TODO MAYBE: is it possible to observe the link speed and
 Bring NTB link down 
 Numbers of inbound and outbound memory windows match 
 accept bogus PRI_DSD 
 accept bogus SEC_DSD 
	 Reset the secondary bar sizes to match the primary bar sizes,
	  except disable or halve the size of the b2b secondary bar.
	 
	  Note: code for each specific bar size register, because the register
	  offsets are not in a consistent order (bar5sz comes after ppd, odd).
 SBAR01 hit by first part of the b2b bar 
	 Other SBAR are normally hit by the PBAR xlat, except for b2b bar.
	  The b2b bar is either disabled above, or configured half-size, and
	  it starts at the PBAR xlat + offset.
 setup incoming bar limits == base addrs (zero length windows) 
 zero incoming translation addrs 
 zero outgoing translation limits (whole bar size windows) 
 set outgoing translation offsets 
 set the translation offset for b2b registers 
 B2B_XLAT_OFFSET is 64bit, but can only take 32bit writes 
 map peer ntb mmio config space registers 
 enable link to allow secondary side device to appear 
 use half the spads for the peer 
 use half the spads for the peer 
 Enable Bus Master and Memory Space on the secondary side 
	 There is a Xeon hardware errata related to writes to SDOORBELL or
	  B2BDOORBELL in conjunction with inbound access to NTB MMIO Space,
	  which may hang the system.  To workaround this use the second memory
	  window to access the interrupt and scratch pad registers on the
	  remote system.
	 There is a hardware errata related to accessing any register in
	  SB01BASE in the presence of bidirectional traffic crossing the NTB.
	 HW Errata on bit 14 of b2bdoorbell register.  Writes will not be
	  mirrored to the remote system.  Shrink the number of bits by one,
	  since bit 14 is the last bit.
		 This is a way for transparent BAR to figure out if we are
		  doing split BAR or not. There is no way for the hw on the
		  transparent side to know and set the PPD.
 second half of the scratchpads 
	 Note: no primary .bar0_base visible to the secondary side.
	 
	  The secondary side cannot get the base address stored in primary
	  bars.  The base address is necessary to set the limit register to
	  any value other than zero, or unlimited.
	 
	  WITHOUT THE BASE ADDRESS, THE SECONDARY SIDE CANNOT DISABLE the
	  window by setting the limit equal to base, nor can it limit the size
	  of the memory window by setting the limit to base + size.
 operations for primary side of local ntb 
 GEN1 
 GEN3 
 GEN4 
  This file is provided under a dual BSDGPLv2 license.  When using or
    redistributing this file, you may do so under either license.
    GPL LICENSE SUMMARY
    Copyright (C) 2016 Advanced Micro Devices, Inc. All Rights Reserved.
    Copyright (C) 2016 T-Platforms. All Rights Reserved.
    This program is free software; you can redistribute it andor modify
    it under the terms of version 2 of the GNU General Public License as
    published by the Free Software Foundation.
    BSD LICENSE
    Copyright (C) 2016 Advanced Micro Devices, Inc. All Rights Reserved.
    Copyright (C) 2016 T-Platforms. All Rights Reserved.
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
       Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
       Redistributions in binary form must reproduce the above copy
        notice, this list of conditions and the following disclaimer in
        the documentation andor other materials provided with the
        distribution.
       Neither the name of AMD Corporation nor the names of its
        contributors may be used to endorse or promote products derived
        from this software without specific prior written permission.
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  AMD PCIe NTB Linux driver
  Contact Information:
  Xiangliang Yu <Xiangliang.Yu@amd.com>
 make sure the range fits in the usable mw size 
 Set the limit if supported 
 set and verify setting the translation address 
 set and verify setting the limit 
 Set the limit if supported 
 set and verify setting the translation address 
 set and verify setting the limit 
 Locate the pointer to Downstream Switch for this device 
			
			  Locate the pointer to Upstream Switch for
			  the Downstream Switch.
		
		  For NTB primary, we simply read the Link Status and control
		  register of the NTB device itself.
 Catch all for everything else 
	
	  We consider the link to be up under two conditions:
	 
	    - When a link-up event is received. This is indicated by
	      AMD_LINK_UP_EVENT set in peer_sta.
	    - When driver on both sides of the link have been loaded.
	      This is indicated by bit 1 being set in the peer
	      SIDEINFO register.
	 
	  This function should return 1 when the latter of the above
	  two conditions is true.
	 
	  Now consider the sequence of events - Link-Up event occurs,
	  then the peer side driver loads. In this case, we would have
	  received LINK_UP event and bit 1 of peer SIDEINFO is also
	  set. What happens now if the link goes down? Bit 1 of
	  peer SIDEINFO remains set, but LINK_DOWN bit is set in
	  peer_sta. So we should return 0 from this function. Not only
	  that, we clear bit 1 of peer SIDEINFO to 0, since the peer
	  side driver did not even get a chance to clear it before
	  the link went down. This can be the case of surprise link
	  removal.
	 
	  LINK_UP event will always occur before the peer side driver
	  gets loaded the very first time. So there can be a case when
	  the LINK_UP event has occurred, but the peer side driver hasn't
	  yet loaded. We return 0 in that case.
	 
	  There is also a special case when the primary side driver is
	  unloaded and then loaded again. Since there is no change in
	  the status of NTB secondary in this case, there is no Link-Up
	  or Link-Down notification received. We recognize this condition
	  with peer_sta being set to 0.
	 
	  If bit 1 of peer SIDEINFO register is not set, then we
	  simply return 0 irrespective of the link up or down status
	  set in peer_sta.
		
		  We need to check the below only for NTB primary. For NTB
		  secondary, simply checking the result of PSIDE_INFO
		  register will suffice.
 Clear peer sideinfo register 
 NTB_TOPO_SEC 
 Enable event interrupt 
 Disable event interrupt 
 The same as for inbound MWs 
 link down first 
 polling peer status 
 link down 
 check if this is WAKEUP event 
 start a timer to poll link status 
 Clear the interrupt status 
	
	  Since we had reserved highest order bit of DB for signaling peer of
	  a special event, this is the only status bit we should be concerned
	  here now.
 send link down event notification 
		
		  If we are here, that means the peer has signalled a special
		  event which notifies that the peer driver has been
		  un-loaded for some reason. Since there is a chance that the
		  peer will load its driver again sometime, we schedule link
		  polling routine.
 Try to set up msix irq 
	 NOTE: Disable MSIX if msix count is less than 16 because of
	  hardware limitation.
 Try to set up msi irq 
 Try to set up intx irq 
 Mask all doorbell interrupts 
 Mask event interrupts 
	
	  We reserve the highest order bit of the DB register which will
	  be used to notify peer when the driver on this side is being
	  un-loaded.
	
	  Since now there is one less bit to account for, the DB count
	  and DB mask should be adjusted accordingly.
 Enable Link-Up and Link-Down event interrupts 
 write side info 
	
	  Clear the READY bit in SIDEINFO register before sending DB event
	  to the peer. This will make sure that when the peer handles the
	  DB event, it correctly reads this bit as being 0.
 Send link down notification 
 for device 145b 
 for device 148b 
 SPDX-License-Identifier: GPL-2.0-only
  vhost transport for vsock
  Copyright (C) 2013-2015 Red Hat, Inc.
  Author: Asias He <asias@redhat.com>
          Stefan Hajnoczi <stefanha@redhat.com>
 Max number of bytes transferred before requeueing the job.
 Max number of packets transferred before requeueing the job.
  Using this limit prevents one virtqueue from starving others with
  small pkts.
 Used to track all the vhost_vsock instances on the system. 
 Link to global vhost_vsock_hash, writes use vhost_vsock_mutex 
 host->guest pending packets 
 Callers that dereference the return value must hold vhost_vsock_mutex or the
  RCU read lock.
 Skip instances that have no CID yet 
 Avoid further vmexits, we're already processing the virtqueue 
			 We cannot finish yet if more buffers snuck in while
			  re-enabling notify.
		 If the packet is greater than the space available in the
		  buffer, we split it using multiple buffers.
			 As we are copying pieces of large packet's buffer to
			  small rx buffers, headers of packets in rx queue are
			  created dynamically and are initialized with header
			  of current packet(except length). But in case of
			  SOCK_SEQPACKET, we also must clear message delimeter
			  bit (VIRTIO_VSOCK_SEQ_EOM) and MSG_EOR bit
			  (VIRTIO_VSOCK_SEQ_EOR) if set. Otherwise,
			  there will be sequence of packets with these
			  bits set. After initialized header will be copied to
			  rx buffer, these required bits will be restored.
 Set the correct length in the header 
		 Deliver to monitoring devices all packets that we
		  will transmit.
		 If we didn't send all the payload we can requeue the packet
		  to send it with the next available buffer.
			 We are queueing the same virtio_vsock_pkt to handle
			  the remaining bytes, and we want to deliver it
			  to monitoring devices in the next iteration.
				 Do we have resources to resume tx
				  processing?
 Find the vhost_vsock according to guest context id  
 Find the vhost_vsock according to guest context id  
 No payload 
 The pkt is too big 
 Is there space left for replies to rx packets? 
 paired with atomic_inc() and atomic_dec_return() 
			 Stop tx until the device processes already
			  pending replies.  Leave tx virtqueue
			  callbacks disabled.
 Deliver to monitoring devices all received packets 
 Only accept correctly addressed packets 
	 Some packets may have been queued before the device was started,
	  let's kick the send worker to send them.
	 This struct is large and allocation could fail, fall back to vmalloc
	  if there is no other way.
 no CID assigned yet 
	 vmci_transport.c doesn't take sk_lock here either.  At least we're
	  under vsock_table_lock so the sock cannot disappear while we're
	  executing.
 If the peer is still valid, no need to reset connection 
	 If the close timeout is pending, let it expire.  This avoids races
	  with the timeout callback.
 Wait for other CPUs to finish using vsock 
	 Iterating over all connections for all CIDs to find orphans is
 Refuse reserved CIDs 
 64-bit CIDs are not yet supported 
	 Refuse if CID is assigned to the guest->host transport (i.e. nested
	  VM), to make the loopback work.
 Refuse if CID is already in use 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (C) 2020 Red Hat, Inc.
  Author: Jason Wang <jasowang@redhat.com>
  IOTLB implementation for vhost.
  vhost_iotlb_map_free - remove a map node and free it
  @iotlb: the IOTLB
  @map: the map that want to be remove and freed
  vhost_iotlb_add_range_ctx - add a new range to vhost IOTLB
  @iotlb: the IOTLB
  @start: start of the IOVA range
  @last: last of IOVA range
  @addr: the address that is mapped to @start
  @perm: access permission of this range
  @opaque: the opaque pointer for the new mapping
  Returns an error last is smaller than start or memory allocation
  fails
  vhost_iotlb_del_range - delete overlapped ranges from vhost IOTLB
  @iotlb: the IOTLB
  @start: start of the IOVA range
  @last: last of IOVA range
  vhost_iotlb_alloc - add a new vhost IOTLB
  @limit: maximum number of IOTLB entries
  @flags: VHOST_IOTLB_FLAG_XXX
  Returns an error is memory allocation fails
  vhost_iotlb_reset - reset vhost IOTLB (free all IOTLB entries)
  @iotlb: the IOTLB to be reset
  vhost_iotlb_free - reset and free vhost IOTLB
  @iotlb: the IOTLB to be freed
  vhost_iotlb_itree_first - return the first overlapped range
  @iotlb: the IOTLB
  @start: start of IOVA range
  @last: last byte in IOVA range
  vhost_iotlb_itree_next - return the next overlapped range
  @map: the starting map node
  @start: start of IOVA range
  @last: last byte IOVA range
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (C) 2009 Red Hat, Inc.
  Author: Michael S. Tsirkin <mst@redhat.com>
  virtio-net server in host kernel.
 Max number of bytes transferred before requeueing the job.
 Max number of packets transferred before requeueing the job.
  Using this limit prevents one virtqueue from starving others with small
  pkts.
 MAX number of TX used buffers for outstanding zerocopy 
  For transmit, used buffer len is unused; we override it to track buffer
  status internally; used for zerocopy tx only.
 Lower device DMA failed 
 Lower device DMA done 
 Lower device DMA in progress 
 Buffer unused 
	 refcount follows semantics similar to kref:
	   0: object is released
	   1: no outstanding ubufs
	  >1: outstanding ubufs
 vhost zerocopy support fields below: 
 last used idx for outstanding DMA zerocopy buffers 
	 For TX, first used idx for DMA done zerocopy buffers
	  For RX, number of batched heads
 Number of XDP frames batched 
 an array of userspace buffers info 
	 Reference counting for outstanding ubufs.
 Batched XDP buffs 
	 Number of TX recently submitted.
	 Number of times zerocopy TX recently failed.
 Flush in progress. Protected by tx vq lock. 
 Private page frag 
 Refcount bias of page frag 
 No zero copy backend? Nothing to count. 
	 TX flush waits for outstanding DMAs to be done.
	  Don't start new DMAs.
 In case of DMA done not in order in lower device driver for some reason.
  upend_idx is used to track end of used idx, done_idx is used to track head
  of used idx. Once lower device DMA done contiguously, we will signal KVM
  guest used idx.
 set len to mark this desc buffers done DMA 
	
	  Trigger polling thread if guest stopped submitting new buffers:
	  in this case, the refcount after decrement will eventually reach 1.
	  We also trigger polling periodically after each 16 packets
	  (the value 16 here is more or less arbitrary, it's tuned to trigger
	  less than 10% of times).
		 free pages owned by XDP; since this is an unlikely error path,
		  keep it simple and avoid more complex bulk update for the
		  used pages
	 Try to hold the vq mutex of the paired virtqueue. We can't
	  use mutex_lock() here since we could not guarantee a
	  consistenet lock ordering.
 On tx here, sock has no rx data. 
 Flush batched packets first 
 Skip header. TODO: support TSO. 
 Sanity check 
 Avoid direct reclaim but allow kswapd to wake 
 On error, stop handling until the next kick. 
 Nothing new?  Wait for eventfd to tell us they refilled. 
		 For simplicity, TX batching is only enabled if
		  sndbuf is unlimited.
			 We can't build XDP buff, go for single
			  packet path but let's flush batched
			  packets.
 Release DMAs done buffers first 
 On error, stop handling until the next kick. 
 Nothing new?  Wait for eventfd to tell us they refilled. 
 use msg_control to pass vhost zerocopy ubuf info to skb 
 Expects to be always run from workqueue - which acts as
 Flush batched heads first 
 Both tx vq and rx socket were polled here 
 This is a multi-buffer version of vhost_get_desc, that works if
 	vq has read descriptors only.
  @vq		- the relevant virtqueue
  @datalen	- data length we'll be reading
  @iovcount	- returned count of io vectors we fill
  @log		- vhost log
  @log_num	- log offset
  @quota       - headcount quota, 1 for big buffer
 	returns number of buffer heads allocated, negative on error
	 len is always initialized before use since we are always called with
	  datalen > 0.
 Detect overrun 
 Expects to be always run from workqueue - which acts as
 FIXME: get and handle RX aux data. 
 On error, stop handling until the next kick. 
 OK, now we need to know about added descriptors. 
				 They have slipped one in as we were
			 Nothing new?  Wait for eventfd to tell us
 On overrun, truncate and discard 
 We don't need to be notified again. 
			 We will supply the header ourselves
			  TODO: support TSO.
		 Userspace might have consumed the packet meanwhile:
		  it's not supposed to do this usually, but might be hard
 Supply virtio_net_hdr if VHOST_NET_F_VIRTIO_NET_HDR 
			 Header came from socket; we'll need to patch
			  ->num_buffers over if VIRTIO_NET_F_MRG_RXBUF
 TODO: Should check and handle checksum. 
 Wait for all lower device DMAs done. 
 Make sure no callbacks are outstanding 
	 We do an extra flush before freeing memory,
 Parameter checking 
 special case to disable backend 
 Verify that ring has been setup correctly. 
 start polling new socket 
 vhost provides vnet_hdr 
 socket provides vnet_hdr 
 SPDX-License-Identifier: GPL-2.0-only
  Helpers for the host side of a virtio ring.
  Since these may be in userspace, we use (inline) accessors.
 Returns vring->num if empty, -ve on error. 
 Only get avail ring entries after they have been exposed by guest. 
  vringh_kiov_advance - skip bytes from vring_kiov
  @iov: an iov passed to vringh_getdesc_() (updated as we consume)
  @len: the maximum length to advance
 Fix up old iov element then increment. 
 Copy some bytes tofrom the iovec.  Returns num copied. 
 May reduce len if range is shorter. 
 To end of memory? 
 Otherwise, don't wrap. 
 No reason for this code to be inline. 
 Indirect tables can't have indirect. 
 We will check this when we follow it! 
 Now, start at the first indirect. 
 We start traversing vring's descriptor table. 
 You must want something! 
 Make sure it's OK, and get offset. 
 We need to save this range to use offset 
 Make sure it's OK, and get offset. 
 Just in case we need to finish traversing above. 
 Compiler knows num_used == 1 sometimes, hence extra check 
 Make sure buffer is written before we update index. 
	 Flush out used index update. This is paired with the
	  barrier that the Guest executes when enabling
 Old-style, without event indices. 
 Modern: we know when other side wants to know. 
 Just in case we added so many that we wrap. 
 Old-school; update flags. 
	 They could have slipped one in as we were doing that: make
	 This is unlikely, so we just leave notifications enabled
	  (if we're using event_indices, we'll only get one
 Old-school; update flags. 
 Userspace access helpers: in this case, addresses are really userspace. 
  vringh_init_user - initialize a vringh for a userspace vring.
  @vrh: the vringh to initialize.
  @features: the feature bits for this ring.
  @num: the number of elements.
  @weak_barriers: true if we only need memory barriers, not IO.
  @desc: the userpace descriptor pointer.
  @avail: the userpace avail pointer.
  @used: the userpace used pointer.
  Returns an error if num is invalid: you should check pointers
  yourself!
 Sane power of 2 please! 
 vring expects kernel addresses, but only used via accessors. 
  vringh_getdesc_user - get next available descriptor from userspace ring.
  @vrh: the userspace vring.
  @riov: where to put the readable descriptors (or NULL)
  @wiov: where to put the writable descriptors (or NULL)
  @getrange: function to call to check ranges.
  @head: head index we received, for passing to vringh_complete_user().
  Returns 0 if there was no descriptor, 1 if there was, or -errno.
  Note that on error return, you can tell the difference between an
  invalid ring and a single invalid descriptor: in the former case,
  head will be vrh->vring.num.  You may be able to ignore an invalid
  descriptor, but there's not much you can do with an invalid ring.
  Note that you can reuse riov and wiov with subsequent calls. Content is
  overwritten and memory reallocated if more space is needed.
  When you don't have to use riov and wiov anymore, you should clean up them
  calling vringh_iov_cleanup() to release the memory, even on error!
 Empty... 
 We need the layouts to be the identical for this to work 
  vringh_iov_pull_user - copy bytes from vring_iov.
  @riov: the riov as passed to vringh_getdesc_user() (updated as we consume)
  @dst: the place to copy.
  @len: the maximum length to copy.
  Returns the bytes copied <= len or a negative errno.
  vringh_iov_push_user - copy bytes into vring_iov.
  @wiov: the wiov as passed to vringh_getdesc_user() (updated as we consume)
  @src: the place to copy from.
  @len: the maximum length to copy.
  Returns the bytes copied <= len or a negative errno.
  vringh_abandon_user - we've decided not to handle the descriptor(s).
  @vrh: the vring.
  @num: the number of descriptors to put back (ie. num
 	 vringh_get_user() to undo).
  The next vringh_get_user() will return the old descriptor(s) again.
	 We only update vring_avail_event(vr) when we want to be notified,
  vringh_complete_user - we've finished with descriptor, publish it.
  @vrh: the vring.
  @head: the head as filled in by vringh_getdesc_user.
  @len: the length of data we have written.
  You should check vringh_need_notify_user() after one or more calls
  to this function.
  vringh_complete_multi_user - we've finished with many descriptors.
  @vrh: the vring.
  @used: the head, length pairs.
  @num_used: the number of used elements.
  You should check vringh_need_notify_user() after one or more calls
  to this function.
  vringh_notify_enable_user - we want to know if something changes.
  @vrh: the vring.
  This always enables notifications, but returns false if there are
  now more buffers available in the vring.
  vringh_notify_disable_user - don't tell us if something changes.
  @vrh: the vring.
  This is our normal running state: we disable and then only enable when
  we're going to sleep.
  vringh_need_notify_user - must we tell the other side about used buffers?
  @vrh: the vring we've called vringh_complete_user() on.
  Returns -errno or 0 if we don't need to tell the other side, 1 if we do.
 Kernelspace access helpers. 
  vringh_init_kern - initialize a vringh for a kernelspace vring.
  @vrh: the vringh to initialize.
  @features: the feature bits for this ring.
  @num: the number of elements.
  @weak_barriers: true if we only need memory barriers, not IO.
  @desc: the userpace descriptor pointer.
  @avail: the userpace avail pointer.
  @used: the userpace used pointer.
  Returns an error if num is invalid.
 Sane power of 2 please! 
  vringh_getdesc_kern - get next available descriptor from kernelspace ring.
  @vrh: the kernelspace vring.
  @riov: where to put the readable descriptors (or NULL)
  @wiov: where to put the writable descriptors (or NULL)
  @head: head index we received, for passing to vringh_complete_kern().
  @gfp: flags for allocating larger riovwiov.
  Returns 0 if there was no descriptor, 1 if there was, or -errno.
  Note that on error return, you can tell the difference between an
  invalid ring and a single invalid descriptor: in the former case,
  head will be vrh->vring.num.  You may be able to ignore an invalid
  descriptor, but there's not much you can do with an invalid ring.
  Note that you can reuse riov and wiov with subsequent calls. Content is
  overwritten and memory reallocated if more space is needed.
  When you don't have to use riov and wiov anymore, you should clean up them
  calling vringh_kiov_cleanup() to release the memory, even on error!
 Empty... 
  vringh_iov_pull_kern - copy bytes from vring_iov.
  @riov: the riov as passed to vringh_getdesc_kern() (updated as we consume)
  @dst: the place to copy.
  @len: the maximum length to copy.
  Returns the bytes copied <= len or a negative errno.
  vringh_iov_push_kern - copy bytes into vring_iov.
  @wiov: the wiov as passed to vringh_getdesc_kern() (updated as we consume)
  @src: the place to copy from.
  @len: the maximum length to copy.
  Returns the bytes copied <= len or a negative errno.
  vringh_abandon_kern - we've decided not to handle the descriptor(s).
  @vrh: the vring.
  @num: the number of descriptors to put back (ie. num
 	 vringh_get_kern() to undo).
  The next vringh_get_kern() will return the old descriptor(s) again.
	 We only update vring_avail_event(vr) when we want to be notified,
  vringh_complete_kern - we've finished with descriptor, publish it.
  @vrh: the vring.
  @head: the head as filled in by vringh_getdesc_kern.
  @len: the length of data we have written.
  You should check vringh_need_notify_kern() after one or more calls
  to this function.
  vringh_notify_enable_kern - we want to know if something changes.
  @vrh: the vring.
  This always enables notifications, but returns false if there are
  now more buffers available in the vring.
  vringh_notify_disable_kern - don't tell us if something changes.
  @vrh: the vring.
  This is our normal running state: we disable and then only enable when
  we're going to sleep.
  vringh_need_notify_kern - must we tell the other side about used buffers?
  @vrh: the vring we've called vringh_complete_kern() on.
  Returns -errno or 0 if we don't need to tell the other side, 1 if we do.
 Atomic read is needed for getu16 
 Atomic write is needed for putu16 
  vringh_init_iotlb - initialize a vringh for a ring with IOTLB.
  @vrh: the vringh to initialize.
  @features: the feature bits for this ring.
  @num: the number of elements.
  @weak_barriers: true if we only need memory barriers, not IO.
  @desc: the userpace descriptor pointer.
  @avail: the userpace avail pointer.
  @used: the userpace used pointer.
  Returns an error if num is invalid.
  vringh_set_iotlb - initialize a vringh for a ring with IOTLB.
  @vrh: the vring
  @iotlb: iotlb associated with this vring
  @iotlb_lock: spinlock to synchronize the iotlb accesses
  vringh_getdesc_iotlb - get next available descriptor from ring with
  IOTLB.
  @vrh: the kernelspace vring.
  @riov: where to put the readable descriptors (or NULL)
  @wiov: where to put the writable descriptors (or NULL)
  @head: head index we received, for passing to vringh_complete_iotlb().
  @gfp: flags for allocating larger riovwiov.
  Returns 0 if there was no descriptor, 1 if there was, or -errno.
  Note that on error return, you can tell the difference between an
  invalid ring and a single invalid descriptor: in the former case,
  head will be vrh->vring.num.  You may be able to ignore an invalid
  descriptor, but there's not much you can do with an invalid ring.
  Note that you can reuse riov and wiov with subsequent calls. Content is
  overwritten and memory reallocated if more space is needed.
  When you don't have to use riov and wiov anymore, you should clean up them
  calling vringh_kiov_cleanup() to release the memory, even on error!
 Empty... 
  vringh_iov_pull_iotlb - copy bytes from vring_iov.
  @vrh: the vring.
  @riov: the riov as passed to vringh_getdesc_iotlb() (updated as we consume)
  @dst: the place to copy.
  @len: the maximum length to copy.
  Returns the bytes copied <= len or a negative errno.
  vringh_iov_push_iotlb - copy bytes into vring_iov.
  @vrh: the vring.
  @wiov: the wiov as passed to vringh_getdesc_iotlb() (updated as we consume)
  @src: the place to copy from.
  @len: the maximum length to copy.
  Returns the bytes copied <= len or a negative errno.
  vringh_abandon_iotlb - we've decided not to handle the descriptor(s).
  @vrh: the vring.
  @num: the number of descriptors to put back (ie. num
 	 vringh_get_iotlb() to undo).
  The next vringh_get_iotlb() will return the old descriptor(s) again.
	 We only update vring_avail_event(vr) when we want to be notified,
	  so we haven't changed that yet.
  vringh_complete_iotlb - we've finished with descriptor, publish it.
  @vrh: the vring.
  @head: the head as filled in by vringh_getdesc_iotlb.
  @len: the length of data we have written.
  You should check vringh_need_notify_iotlb() after one or more calls
  to this function.
  vringh_notify_enable_iotlb - we want to know if something changes.
  @vrh: the vring.
  This always enables notifications, but returns false if there are
  now more buffers available in the vring.
  vringh_notify_disable_iotlb - don't tell us if something changes.
  @vrh: the vring.
  This is our normal running state: we disable and then only enable when
  we're going to sleep.
  vringh_need_notify_iotlb - must we tell the other side about used buffers?
  @vrh: the vring we've called vringh_complete_iotlb() on.
  Returns -errno or 0 if we don't need to tell the other side, 1 if we do.
 SPDX-License-Identifier: GPL-2.0+
  Vhost kernel TCM fabric driver for virtio SCSI initiators
  (C) Copyright 2010-2013 Datera, Inc.
  (C) Copyright 2010-2012 IBM Corp.
  Authors: Nicholas A. Bellinger <nab@daterainc.com>
           Stefan Hajnoczi <stefanha@linux.vnet.ibm.com>
 Max number of requests before requeueing the job.
  Using this limit prevents one virtqueue from starving others with
  request.
 Wait for the flush operation to finish 
 Refcount for the inflight reqs 
 Descriptor from vhost_get_vq_desc() for virt_queue segment 
 virtio-scsi initiator task attribute 
 virtio-scsi response incoming iovecs 
 virtio-scsi initiator data direction 
 Expected data transfer length from virtio-scsi header 
 The Tag from includelinuxvirtio_scsi.h:struct virtio_scsi_cmd_req 
 The number of scatterlists associated with this cmd 
 Saved unpacked SCSI LUN for vhost_scsi_target_queue_cmd() 
 Pointer to the SGL formatted memory from virtio-scsi 
 Pointer to response header iovec 
 Pointer to vhost_scsi for our device 
 Pointer to vhost_virtqueue for the cmd 
 Pointer to vhost nexus memory 
 The TCM IO descriptor that is accessed via container_of() 
 Copy of the incoming SCSI command descriptor block (CDB) 
 Sense buffer that will be mapped into outgoing status 
 Completed commands list, serviced from vhost worker thread 
 Used to track inflight cmd 
 Pointer to TCM session for I_T Nexus 
 Vhost port target portal group tag for TCM 
 Used to track number of TPG PortLun Links wrt to explict I_T Nexus shutdown 
 Used for vhost_scsi device reference to tpg_nexus, protected by tv_tpg_mutex 
 Used for enabling T10-PI with legacy devices 
 list for vhost_scsi_list 
 Used to protect access for tpg_nexus 
 Pointer to the TCM VHost I_T Nexus for this TPG endpoint 
 Pointer back to vhost_scsi_tport 
 Returned by vhost_scsi_make_tpg() 
 Pointer back to vhost_scsi, protected by tv_tpg_mutex 
 SCSI protocol the tport is providing 
 Binary World Wide unique Port Name for Vhost Target port 
 ASCII formatted WWPN for Vhost Target port 
 Returned by vhost_scsi_make_tport() 
 event to be sent to guest 
 event list, serviced from vhost worker thread 
 Note: can't set VIRTIO_F_VERSION_1 yet, since that implies ANY_LAYOUT. 
	
	  Reference counting for inflight reqs, used for flush operation. At
	  each time, one reference tracks new commands submitted, while we
	  wait for another one to reach 0.
	
	  Indicate current inflight in use, protected by vq->mutex.
	  Writers must also take dev mutex and flush under it.
 Protected by vhost_scsi->dev.mutex 
 cmd completion work item 
 cmd completion queue 
 evt injection work item 
 evt injection queue 
 any missed events, protected by vq->mutex 
 num of pending events, protected by vq->mutex 
  Context for processing request and control queue operations.
 Global spinlock to protect vhost_scsi TPG list for vhost IOCTL access 
 store old infight 
 setup new infight 
 Go ahead and process the write immediately 
 Fill in status and signal that we are done processing this command
  This is scheduled in the vhost work queue so we are called with the owner
  process mm and can access the vring.
 TODO is status_qualifier field needed? 
  Map a user memory range into a scatterlist
  Returns the number of scatterlist entries used or -errno on error.
 No pages were pinned 
 FIXME: BIDI operation 
 On error, stop handling until the next kick. 
 Nothing new?  Wait for eventfd to tell us they refilled. 
	
	  Get the size of request and response buffers.
	  FIXME: Not correct for BIDI operation
	
	  Copy over the virtio-scsi request header, which for a
	  ANY_LAYOUT enabled guest may span multiple iovecs, or a
	  single iovec may contain both the header + outgoing
	  WRITE payloads.
	 
	  copy_from_iter() will advance out_iter, so that it will
	  point at the start of the outgoing WRITE payload, if
	  DMA_TO_DEVICE is set.
 virtio-scsi spec requires byte 0 of the lun to be 1 
 validated at handler entry 
	
	  We can handle the vq only after the endpoint is setup by calling the
	  VHOST_SCSI_SET_ENDPOINT ioctl.
		
		  Setup pointers and values based upon different virtio-scsi
		  request header if T10_PI is enabled in KVM guest.
		
		  Validate the size of request and response buffers.
		  Check for a sane response buffer so we can report
		  early errors back to the guest.
 bad target on any error from here on 
		
		  Determine data_direction by calculating the total outgoing
		  iovec sizes + incoming iovec sizes vs. virtio-scsi request +
		  response headers respectively.
		 
		  For DMA_TO_DEVICE this is out_iter, which is already pointing
		  to the right place.
		 
		  For DMA_FROM_DEVICE, the iovec will be just past the end
		  of the virtio-scsi response header in either the same
		  or immediately following iovec.
		 
		  Any associated T10_PI bytes for the outgoing  incoming
		  payloads are included in calculation of exp_data_len here.
		
		  If T10_PI header + payload is present, setup prot_iter values
		  and recalculate data_iter for vhost_scsi_mapal() mapping to
		  host scatterlists via get_user_pages_fast().
			
			  Set prot_iter to data_iter and truncate it to
			  prot_bytes, and advance data_iter past any
			  preceeding prot_bytes that may be present.
			 
			  Also fix up the exp_data_len to reflect only the
			  actual data payload length.
		
		  Check that the received CDB size does not exceeded our
		  hardcoded max for vhost-scsi, then get a pre-allocated
		  cmd descriptor for the new virtio-scsi tag.
		 
		  TODO what if cdb was too small for varlen cdb header?
		
		  Save the descriptor from vhost_get_vq_desc() to be used to
		  complete the virtio-scsi request in TCM callback context via
		  vhost_scsi_queue_data_in() and vhost_scsi_queue_status()
		
		  ENXIO:  No more requests, or read error, wait for next kick
		  EINVAL: Invalid response buffer, drop the request
		  EIO:    Respond with bad target
		  EAGAIN: Pending request
 event_actual = 0 
	
	  We can handle the vq only after the endpoint is setup by calling the
	  VHOST_SCSI_SET_ENDPOINT ioctl.
		
		  Get the request type first in order to setup
		  other parameters dependent on the type.
			
			  The size of the response buffer depends on the
			  request type and must be validated against it.
			  Since the request type is not known, don't send
			  a response.
		
		  Validate the size of request and response buffers.
		  Check for a sane response buffer so we can report
		  early errors back to the guest.
		
		  Get the rest of the request now that its size is known.
		
		  ENXIO:  No more requests, or read error, wait for next kick
		  EINVAL: Invalid response buffer, drop the request
		  EIO:    Respond with bad target
		  EAGAIN: Pending request
 TODO: share lun setup code with virtio-scsi.ko 
		
		  Note: evt->event is zeroed when we allocate it and
		  lun[4-7] need to be zero according to virtio-scsi spec.
 Callers must hold dev mutex 
 Init new inflight and remember the old inflight 
	
	  The inflight->kref was initialized to 1. We decrement it here to
	  indicate the start of the flush operation so that it will reach 0
	  when all the reqs are finished.
 Flush both the vhost poll and vhost work 
 Wait for all reqs issued before the flush to be finished 
  Called from vhost_scsi_ioctl() context to walk the list of available
  vhost_scsi_tpg with an active struct vhost_scsi_nexus
   The lock nesting rule is:
     vhost_scsi_mutex -> vs->dev.mutex -> tpg->tv_tpg_mutex -> vq->mutex
 Verify that ring has been setup correctly. 
 Verify that ring has been setup correctly. 
			
			  In order to ensure individual vhost-scsi configfs
			  groups cannot be removed while in use by vhost ioctl,
			  go ahead and take an explicit se_tpg->tpg_group.cg_item
			  dependency now.
	
	  Act as synchronize_rcu to make sure access to
	  old vs->vs_tpg is finished.
 Verify that ring has been setup correctly. 
		
		  Release se_tpg->tpg_group.cg_item configfs dependency now
		  to allow vhost-scsi WWPN se_tpg->tpg_group shutdown to occur.
 Make sure cmds are not running before tearing them down. 
	
	  Act as synchronize_rcu to make sure access to
	  old vs->vs_tpg is finished.
 Jobs can re-queue themselves in evt kick handler. Do extra flush. 
 TODO: flush backend after dev ioctl. 
	
	  Since we are running in 'demo mode' this call with generate a
	  struct se_node_acl for the vhost_scsi struct se_portal_group with
	  the SCSI Initiator port name of the passed configfs group 'name'.
	
	  Release the SCSI I_T Nexus to the emulated vhost Target Port
	
	  Shutdown the active I_T nexus if 'NULL' is passed..
	
	  Otherwise make sure the passed virtual Initiator port WWN matches
	  the fabric protocol_id set in vhost_scsi_make_tport(), and call
	  vhost_scsi_make_nexus().
 Skip over "fc." 
	
	  Clear any trailing newline for the NAA WWN
	
	  Release the virtual I_T Nexus for this vhost TPG
	
	  Deregister the se_tpg from TCM..
	 if (vhost_scsi_parse_wwn(name, &wwpn, 1) < 0)
	
	  Determine the emulated Protocol Identifier and Target Port Name
	  based on the incoming configfs directory name.
 Skip over "fc." 
	
	  Setup callers for generic logic in target_core_fabric_configfs.c
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (C) 2009 Red Hat, Inc.
  Author: Michael S. Tsirkin <mst@redhat.com>
  test virtio server in host kernel.
 Max number of bytes transferred before requeueing the job.
 Max number of packets transferred before requeueing the job.
  Using this limit prevents one virtqueue from starving others with
  pkts.
 Expects to be always run from workqueue - which acts as
 On error, stop handling until the next kick. 
 Nothing new?  Wait for eventfd to tell us they refilled. 
 Sanity check 
	 We do an extra flush before freeing memory,
 Verify that ring has been setup correctly. 
 start polling new socket 
 Verify that ring has been setup correctly. 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018-2020 Intel Corporation.
  Copyright (C) 2020 Red Hat, Inc.
  Author: Tiwei Bie <tiwei.bie@intel.com>
          Jason Wang <jasowang@redhat.com>
  Thanks Michael S. Tsirkin for the valuable comments and
  suggestions.  And thanks to Cunming Liang and Zhihong Wang for all
  their supports.
	
	  Userspace shouldn't remove status bits unless reset the
	  status to 0.
	
	  It's not allowed to change the features after they have
	  been negotiated.
 Limit the use of memory for bookkeeping 
 Pin a contiguous chunk of memory 
					
					  Unpin the pages that are left unmapped
					  from this point on in the current
					  page_list. The remaining outstanding
					  ones which may stride across several
					  chunks will be covered in the common
					  error path subsequently.
 Pin the rest chunk 
			
			  Unpin the outstanding pages which are yet to be
			  mapped but haven't due to vdpa_map() or
			  pin_user_pages() failure.
			 
			  Mapped pages are accounted in vdpa_map(), hence
			  the corresponding unpinning will be handled by
			  vdpa_unmap().
 Device want to do DMA by itself 
	 To be safe and easily modelled by userspace, We only
	  support the doorbell which sits on the page boundary and
	  does not share the page with other registers.
 CONFIG_MMU 
 CONFIG_MMU 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (C) 2009 Red Hat, Inc.
  Copyright (C) 2006 Rusty Russell IBM Corporation
  Author: Michael S. Tsirkin <mst@redhat.com>
  Inspiration, some code, and most witty comments come from
  Documentationvirtuallguestlguest.c, by Rusty Russell
  Generic code for virtio server in host kernel.
	 Note for legacy virtio: user_be is initialized at reset time
	  according to the host endianness. If userspace does not set an
	  explicit endianness, the default behavior is native endian, as
	  expected by legacy virtio.
 CONFIG_VHOST_CROSS_ENDIAN_LEGACY 
 Init poll structure 
 Start polling a file. We add ourselves to file's wait queue. The caller must
 Stop polling a file. After this function returns, it becomes safe to drop the
 Flush any work that has been scheduled. When calling this, don't hold any
		 We can only add the work to the list after we're
		  sure it was not in the list.
		  test_and_set_bit() implies a memory barrier.
 A lockless hint for busy polling code to exit the loop 
 mb paired w kthread_stop 
 make sure flag is seen after deletion 
 Helper to allocate iovec buffers for all vqs. 
 Caller should have device mutex 
 Are you the owner? If not, I don't think you mean to do that 
 Caller should have device mutex 
 No owner, become one 
		 vDPA device does not use worker thead, so there's
		  no need to hold the address space for mm. This help
		  to avoid deadlock in the case of mmap() which may
		  held the refcnt of the file and depends on release
		  method to remove vma.
 Caller should have device mutex 
 Is there an owner already? 
 avoid contributing to loadavg 
 Caller should have device mutex 
	 We don't need VQ locks below since vhost_dev_cleanup makes sure
	  VQs aren't running.
 No one will access memory at this point 
 Make sure 64 bit math will not overflow. 
 Make sure 64 bit math will not overflow. 
 Caller should have vq mutex and device mutex. 
 Can we switch to this memory table? 
 Caller should have device mutex but not vq mutex 
 If ring is inactive, will check when it's enabled. 
		 This function should be called after iotlb
		  prefetch, which means we're sure that all vq
		  could be access through iotlb. So -EAGAIN should
		  not happen in this case.
		 This function should be called after iotlb
		  prefetch, which means we're sure that vq
		  could be access through iotlb. So -EAGAIN should
		  not happen in this case.
 This function should be called after iotlb
  prefetch, which means we're sure that vq
  could be access through iotlb. So -EAGAIN should
  not happen in this case.
 Make sure 64 bit math will not overflow. 
		 There maybe a hole after type for V1 message type,
		  so skip it here.
	 If an IOTLB device is present, the vring addresses are
			 Report the possible access violation by
			  request another translation from userspace.
 Can we log writes? 
 Caller should have device mutex but not vq mutex 
	 If an IOTLB device is present, log_addr is a GIOVA that
 Verify access for write logging. 
 Caller should have vq mutex and device mutex 
 Can we start vq? 
 Caller should have vq mutex and device mutex 
 All memory accesses are done under some VQ mutex. 
	 Resizing ring with an active backend?
	 For 32bit, verify that the top 32bits of the user
 Make sure it's safe to cast pointers to vring types. 
	 We only verify access here if backend is configured.
	  If it is not, we don't as size might not have been setup.
 Also validate log access for used ring if enabled. 
		 Moving base with an active backend?
 Forget the cached index value. 
 Caller must have device mutex 
 If you are not the owner, you can become one 
 You must be the owner to do anything else 
 If ring is inactive, will check when it's enabled. 
 TODO: This is really inefficient.  We need something like get_user()
  (instruction directly accesses the data, with an exception table entry
  returning -EFAULT). See Documentationx86exception-tables.rst.
		 More than one GPAs can be mapped into a single HVA. So
		  iterate all possible umems here to be safe.
 Make sure data written is seen before log. 
 Length written exceeds what we have stored. This is a bug. 
 Make sure the flag is seen before log. 
 Log used flag write. 
 Make sure the event is seen before log. 
 Log avail event write 
 Each buffer in the virtqueues is actually a chain of descriptors.  This
  function returns the next descriptor in the chain,
 If this descriptor says it doesn't chain, we're done. 
 Check they're not leading us off end of descriptors. 
 Sanity check 
	 Buffers are chained via a 16 bit next field, so
 If this is an input descriptor, increment that count. 
			 If it's an output descriptor, they're all supposed
 This looks in the virtqueue and for the first available buffer, and converts
  it to an iovec for convenient access.  Since descriptors consist of some
  number of output then some number of input descriptors, it's actually two
  iovecs, but we pack them into one and note how many of each there were.
  This function returns the descriptor number found, or vq->num (which is
  never a valid descriptor number) if none was found.  A negative code is
 Check it isn't doing very strange things with descriptor numbers. 
		 If there's nothing new since last we looked, return
		  invalid.
		 Only get avail ring entries after they have been
		  exposed by guest.
	 Grab the next descriptor number they're advertising, and increment
 If their number is silly, that's an error. 
 When we start there are none of either input nor output. 
			 If this is an input descriptor,
			 If it's an output descriptor, they're all supposed
 On success, increment avail index. 
	 Assume notifications from guest are disabled at this point,
 Reverse the effect of vhost_get_vq_desc. Useful for error handling. 
 After we've used one of their buffers, we tell them about it.  We'll then
 Make sure data is seen before log. 
 Log used ring entry write. 
	 If the driver never bothers to signal in a very long while,
	  used index might wrap around. If that happens, invalidate
	  signalled_used index we stored. TODO: make sure driver
 After we've used one of their buffers, we tell them about it.  We'll then
 Make sure buffer is written before we update index. 
 Make sure used idx is seen before log. 
 Log used index update. 
	 Flush out used index updates. This is paired
	  with the barrier that the Guest executes when enabling
 This actually signals the guest, using eventfd. 
 Signal the Guest tell them we used something up. 
 And here's the combo meal deal.  Supersize me! 
 multi-buffer version of vhost_add_used_and_signal 
 return true if we're sure that avaiable ring is empty 
 OK, now we need to know about added descriptors. 
	 They could have slipped one in as we were doing that: make
 We don't need to be notified again. 
 Create a new message. 
 Make sure all padding within the structure is initialized. 
  Intel X38 Memory Controller kernel module
  Copyright (C) 2008 Cluster Computing, Inc.
  This file may be distributed under the terms of the
  GNU General Public License.
  This file is based on i3200_edac.c
 Intel X38 register addresses - device 0 function 0 - DRAM Controller 
 MCH Memory Mapped Register BAR 
 bits 35:14 
#define X38_TOM	0xa0	 Top of Memory (16b)
				 
				  15:10 reserved
				   9:0  total populated physical memory
 bits 9:0 
 64MiB grain 
#define X38_ERRSTS	0xc8	 Error Status Register (16b)
				 
				  15    reserved
				  14    Isochronous TBWRR Run Behind FIFO Full
				        (ITCV)
				  13    Isochronous TBWRR Run Behind FIFO Put
				        (ITSTV)
				  12    reserved
				  11    MCH Thermal Sensor Event
				        for SMISCISERR (GTSE)
				  10    reserved
				   9    LOCK to non-DRAM Memory Flag (LCKF)
				   8    reserved
				   7    DRAM Throttle Flag (DTF)
				   6:2  reserved
				   1    Multi-bit DRAM ECC Error Flag (DMERR)
				   0    Single-bit DRAM ECC Error Flag (DSERR)
 Intel  MMIO register space - device 0 function 0 - MMR space 
#define X38_C0DRB	0x200	 Channel 0 DRAM Rank Boundary (16b x 4)
				 
				  15:10 reserved
				   9:0  Channel 0 DRAM Rank Boundary Address
 Channel 1 DRAM Rank Boundary (16b x 4) 
 bits 9:0 
 64MiB grain 
#define X38_C0ECCERRLOG 0x280	 Channel 0 ECC Error Log (64b)
				 
				  63:48 Error Column Address (ERRCOL)
				  47:32 Error Row Address (ERRROW)
				  31:29 Error Bank Address (ERRBANK)
				  28:27 Error Rank Address (ERRRANK)
				  26:24 reserved
				  23:16 Error Syndrome (ERRSYND)
				  15: 2 reserved
				     1  Multiple Bit Error Status (MERRSTS)
				     0  Correctable Error Status (CERRSTS)
 Channel 1 ECC Error Log (64b) 
 see P.94 of spec for details 
 8th byte of CAPID0 
 check DCD: Dual Channel Disable 
	
	  Clear any error bits.
	  (Yes, we really clear bits by writing 1 to them.)
	
	  This is a mess because there is no atomic way to read all the
	  registers at once and the registers can transition from CE being
	  overwritten by UE.
	
	  If the error is the same for both reads then the first set
	  of reads is valid.  If there is a change then there is a CE
	  with no info and the second set of reads is valid and
	  should be UE info.
 FIXME: unconventional pvt_info usage 
	
	  The dram rank boundary (DRB) reg values are boundary addresses
	  for each DRAM rank with a granularity of 64MB.  DRB regs are
	  cumulative; the last one will contain the total memory
	  contained in all ranks.
 get this far and it's successful 
 0 terminated list. 
 Ensure that the OPSTATE is set correctly for POLL or NMI 
 SPDX-License-Identifier: GPL-2.0-only
  Driver for Pondicherry2 memory controller.
  Copyright (c) 2016, Intel Corporation.
  [Derived from sb_edac.c]
  Translation of system physical addresses to DIMM addresses
  is a two stage process:
  First the Pondicherry 2 memory controller handles slice and channel interleaving
  in "sys2pmi()". This is (almost) completley common between platforms.
  Then a platform specific dunit (DIMM unit) completes the process to provide DIMM,
  rank, bank, row and column using the appropriate "dunit_ops" functionsparameters.
 Max DIMMs per channel 
 All requests go to PMI CH0 on each slice (CH1 disabled) 
  System address space is divided into multiple regions with
  different interleave rules in each. The as0as1 regions
  have no interleaving at all. The as2 region is interleaved
  between two channels. The mot region is magic and may overlap
  other regions, with its interleave rules taking precedence.
  Addresses not in any of these regions are interleaved across
  all four channels.
 Debug macros 
  On Apollo Lake we access memory controller registers via a
  side-band mailbox style interface in a hidden PCI device
  configuration space.
 Unhide the P2SB device, if it's hidden 
 Hide the P2SB device, if it was hidden before 
 Unhide the P2SB device, if it's hidden 
 Hide the P2SB device, if it was hidden before 
 MMIO via memory controller hub base address 
 MMIO via sideband register base address 
 Both PMI channels in one slice enabled 
 Apollo Lake dunit 
  Validated on board with just two DIMMs in the [0] and [2] positions
  in this array. Other port number matches documentation, but caution
  advised.
 Denverton dunit 
	
	  RD_REGP() will fail for unpopulated or non-existent
	  DIMM slots. Return success if we find at least one DIMM.
  Read all the hw config registers once here (they don't
  change at run time. Figure out which address ranges have
  which interleave characteristics.
 PMI channel idx (always 0) for asymmetric region 
 PMI channel bitmap (always 1) for symmetric region 
 Get a contiguous memory address (remove the MMIO gap) 
 Squeeze out one address bit, shift upper part down to fill gap 
 XOR all the bits from addr specified in mask 
  First stage decode. Take the system address and figure out which
  second stage will deal with it based on interleave modes.
 Determine if address is in the MOT region. 
 Calculate the number of symmetric regions enabled. 
	
	  The amount we need to shift the asym base can be determined by the
	  number of enabled symmetric channels.
	  NOTE: This can only work because symmetric memory is not supposed
	  to do a 3-way interleave.
 Give up if address is out of range, or in MMIO gap 
 Get a contiguous memory address (remove the MMIO gap) 
 Otherwise we're in normal, boring symmetric mode. 
 Remove the chan_selector bit first 
 Remove the slice bit (we remove it second because it must be lower 
 Translate PMI address to memory (rank, row, bank, column) 
 column 
 bank 
 row 
 rank 
 addrdec values 
 dden values 
 dwid values 
 Second stage decode. Compute rank, bank, row & column. 
		
		  On single rank DIMMs ignore the rank select bit
		  and shift remainder of "bits[]" down one place.
 Pluck bit "in" from pmiaddr and return value shifted to bit "out" 
 Rank 0 or 1 
 Rank 2 or 3 
	
	  Normally ranks 0,1 are DIMM0, and 2,3 are DIMM1, but we
	  flip them if DIMM1 is larger than DIMM0.
 6472 bit dram channel width 
 3240 bit dram channel width 
 Check dramtype and ECC mode for each present DIMM 
 pmi channel idx to dimm channel idx 
	
	  According with Table 15-9 of the Intel Architecture spec vol 3A,
	  memory errors should fit in this mask:
	 	000f 0000 1mmm cccc (binary)
	  where:
	 	f = Correction Report Filtering Bit. If 1, subsequent errors
	 	    won't be shown
	 	mmm = error type
	 	cccc = channel
	  If the mask doesn't match, report an error to the parsing logic
 Only decode errors with an valid address (ADDRV) 
 Call the helper to output message 
 DIMM0 is present if rank0 andor rank1 is enabled 
 DIMM1 is present if rank2 andor rank3 is enabled 
 Allocate a new MC control structure 
 Get dimm basic config and the memory layout 
 Remove MC sysfs nodes 
  Callback function registered with core kernel mce code.
  Called once for each logged error.
	
	  Just let mcelog handle it if the error is
	  outside the memory controller. A memory error
	  is indicated by bit 7 = 1 and bits = 8-11,13-15 = 0.
	  bit 12 has an special meaning.
 Advice mcelog that the error were handled 
  Write an address to this file to exercise the address decode
  logic in this driver.
 ADDRV + MemRd + Unknown channel 
 CONFIG_EDAC_DEBUG 
 Ensure that the OPSTATE is set correctly for POLL or NMI 
  Intel 5000(PVX) class Memory Controllers kernel module
  This file may be distributed under the terms of the
  GNU General Public License.
  Written by Douglas Thompson Linux Networx (http:lnxi.com)
 	norsk5@xmission.com
  This module is based on the following document:
  Intel 5000X Chipset Memory Controller Hub (MCH) - Datasheet
  	http:developer.intel.comdesignchipsetsdatashts313070.htm
  Alter this version for the I5000 module when modifications are made
 Device 16,
  Function 0: System Address
  Function 1: Memory Branch Map, Control, Errors Register
  Function 2: FSB Error Registers
  All 3 functions of Device 16 (0,1,2) share the SAME DID
 OFFSETS for Function 0 
 OFFSETS for Function 1 
 Thermal and SPD or BFD errors 
 Correctable errors 
 Non-Retry or redundant Retry errors 
 Uncorrectable errors 
 OFFSETS for Function 2 
  Device 21,
  Function 0: Memory Map Branch 0
  Device 22,
  Function 0: Memory Map Branch 1
 Defines to extract the various fields from the
 	MTRx - Memory Technology Registers
 enables the report of miscellaneous messages as CE errors - default off 
 Enumeration of supported devices 
 future 
 future 
 Device name and register DID (Device ID) 
 name for this device 
 DID for the branchmap,control 
 Table of devices attributes supported by this driver 
 size, 0 means not present  
 max possible channels 
 max possible csrows per channel 
 driver private data structure 
 16.0 
 16.1 
 16.2 
 21.0 
 22.0 
 top of low memory 
 AMB BAR 
 Memory Technlogy Reg 
 Branch 0, Channel 0 
 Brnach 0, Channel 1 
 Memory Technlogy Reg 
 Branch 1, Channel 8 
 Branch 1, Channel 1 
 DIMM information matrix, allocating architecture maximums 
 Actual values for this controller 
 Max channels 
 Max DIMMs per channel 
 I5000 MCH error information retrieved from Hardware 
 These registers are always read from the MC 
 First Errors Fatal 
 Next Errors Fatal 
 First Errors Non-Fatal 
 Next Errors Non-Fatal 
 These registers are input ONLY if there was a Recoverable  Error 
 Recoverable Mem Data Error log B 
 Recoverable Mem Error log A 
 Recoverable Mem Error log B 
	 These registers are input ONLY if there was a
 Non-Recoverable Mem log A 
 Non-Recoverable Mem log B 
 	i5000_get_error_info	Retrieve the hardware error information from
 				the hardware and cache it in the 'info'
 				structure
 read in the 1st FATAL error register 
	 Mask only the bits that the doc says are valid
 If there is an error, then read in the 
 NEXT FATAL error register and the Memory Error Log Register A 
 harvest the various error data we need 
 Clear the error bits, by writing them back 
 read in the 1st NON-FATAL error register 
	 If there is an error, then read in the 1st NON-FATAL error
 harvest the various error data we need 
 Clear the error bits, by writing them back 
  i5000_process_fatal_error_info(struct mem_ctl_info mci,
  					struct i5000_error_info info,
  					int handle_errors);
 	handle the Intel FATAL errors, if any
 mask off the Error bits that are possible 
 if no error, return now 
 Use the NON-Recoverable macros to extract data 
 Only 1 bit will be on 
		
		  This error is generated to inform that the intelligent
		  throttling is disabled and the temperature passed the
		  specified middle point. Since this is something the BIOS
		  should take care of, we'll warn only once to avoid
		  worthlessly flooding the log.
 Form out message 
 Call the helper to output message 
  i5000_process_fatal_error_info(struct mem_ctl_info mci,
  				struct i5000_error_info info,
  				int handle_errors);
 	handle the Intel NON-FATAL errors, if any
 mask off the Error bits that are possible 
 if no error, return now 
 ONLY ONE of the possible error bits will be set, as per the docs 
		
		  According with i5000 datasheet, bit 28 has no significance
		  for errors M4Err-M12Err and M17Err-M21Err, on FERR_NF_FBD
 Form out message 
 Call the helper to output message 
 Check correctable errors 
		 Convert channel to be based from zero, instead of
 Form out message 
 Call the helper to output message 
 Form out message 
 Call the helper to output message 
 	i5000_process_error_info	Process the error info that is
 	in the 'info' structure, previously retrieved from hardware
 First handle any fatal errors that occurred 
 now handle any non-fatal errors that occurred 
 	i5000_clear_error	Retrieve any error from the hardware
 				but do NOT process that error.
 				Used for 'clearing' out of previous errors
 				Called by the Core module.
 	i5000_check_error	Retrieve and process errors reported by the
 				hardware. Called by the Core module.
 	i5000_get_devices	Find and perform 'get' operation on the MCH's
 			devicefunctions we want to reference for this driver
 			Need to 'get' device 16 func 1 and func 2
const struct i5000_dev_info i5000_dev = &i5000_devs[dev_idx];
 Attempt to 'get' the MCH register we want 
 End of list, leave 
 Scan for device 16 func 1 
 Attempt to 'get' the MCH register we want 
 Scan for device 16 func 1 
	 If this device claims to have more than 2 channels then
	  fetch Branch 1's information
 	i5000_put_devices	'put' all the devices that we have
 				reserved via 'get'
 FUNC 1 
 FUNC 2 
 DEV 21 
 Only if more than 2 channels do we release the second branch 
 DEV 22 
 	determine_amb_resent
 		the information is contained in NUM_MTRS different registers
 		determineing which of the NUM_MTRS requires knowing
 		which channel is in question
 	2 branches, each with 2 channels
 		b0_ambpresent0 for channel '0'
 		b0_ambpresent1 for channel '1'
 		b1_ambpresent0 for channel '2'
 		b1_ambpresent1 for channel '3'
  determine_mtr(pvt, csrow, channel)
 	return the proper MTR register as determine by the csrow and channel desired
 Determine if there is a DIMM present in this DIMM slot 
			 Start with the number of bits for a Bank
 Add the number of ROW bits 
 add the number of COLUMN bits 
 Dual-rank memories have twice the size 
 add 64 bits per DIMM 
 divide by 2^^20 
 8 bits per bytes 
 	calculate_dimm_size
 	also will output a DIMM matrix map, if debug is enabled, for viewing
 	how the DIMMs are populated
 ================= Generate some debug output ================= 
	 Scan all the actual slots
	  and calculate the information for each DIMM
	  Start with the highest slot first, to display it first
	  and work toward the 0th slot
		 on an odd slot, first output a 'boundary' marker,
 Output the last bottom 'boundary' marker 
 now output the 'channel' labels 
 output the last message and free buffer 
 	i5000_get_mc_regs	read in the necessary registers and
 				cache locally
 			Fills in the private data members
 Get the Branch Map regs 
 Get the MIR[0-2] regs 
 Get the MTR[0-3] regs 
 Read and dump branch 0's MTRs 
 Only if we have 2 branchs (4 channels) 
 Read and dump  branch 1's MTRs 
	 Go and determine the size of each DIMM and place in an
 	i5000_init_csrows	Initialize the 'csrows' table within
 				the mci control	structure with the
 				addressing of memory.
 	return:
 		0	success
 		1	no actual memory found on this MC
 Assume NO memory 
	
	  FIXME: The memory layout used to map slotchannel into the
	  real memory architecture is weird: branch+slot are "csrows"
	  and channel is channel. That required an extra array (dimm_info)
	  to map the dimms. A good cleanup would be to remove this array,
	  and do a loop here with branch, channel, slot
 Assume DDR2 for now 
 ask what device type on this row 
 	i5000_enable_error_reporting
 			Turn on the memory reporting features of the hardware
 Read the FBD Error Mask Register 
 Enable with a '0' 
  i5000_get_dimm_and_channel_counts(pdev, &nr_csrows, &num_channels)
 	ask the device how many channels are present and how many CSROWS
 	 as well
	 Need to retrieve just how many channels and dimms per channel are
	  supported on this memory controller
 	i5000_probe1	Probe for ONE instance of device to see if it is
 			present.
 	return:
 		0 for FOUND a device
 		< 0 for error code
 We only are looking for func 0 of the set 
	 Ask the devices for the number of CSROWS and CHANNELS so
	  that we can calculate the memory resources, etc
	 
	  The Chipset will report what it can handle which will be greater
	  or equal to what the motherboard manufacturer will implement.
	 
	  As we don't have a motherboard identification routine to determine
	  actual number of slotsdimms per channel, we thus utilize the
	  resource as specified by the chipset. Thus, we might have
	  have more DIMMs per channel than actually on the mobo, but this
	  allows the driver to support up to the chipset max, without
	  some fancy mobo determination.
 allocate a new MC control structure 
 record ptr  to the generic device 
 Record this device in our private 
 'get' the pci devices we want to reserve for our use 
 Time to get serious 
 retrieve the hardware registers 
 Set the function pointer to an actual operation function 
	 initialize the MC control structure 'csrows' table
 no csrows found 
 add this new MC control structure to EDAC's list of MCs 
		 FIXME: perhaps some code should go here that disables error
		  reporting if we just enabled it
 allocating generic PCI control info 
 Error exit unwinding stack 
 	i5000_init_one	constructor for one instance of device
  	returns:
 		negative on error
 		count (>= 0)
 wake up device 
 now probe and enable the device 
 	i5000_remove_one	destructor for one instance of device
 retrieve references to resources, and free those resources 
 	pci_device_id	table for which devices we are looking for
 	The "E500P" device is the first device supported.
 0 terminated list. 
 	i5000_driver	pci_driver structure for this module
 	i5000_init		Module entry function
 			Try to initialize this module for its devices
 Ensure that the OPSTATE is set correctly for POLL or NMI 
 	i5000_exit()	Module exit function
 			Unregister the driver
lnxi.com) Doug Thompson <norsk5@xmission.com>");
  AMD 76x Memory Controller kernel module
  (C) 2003 Linux Networx (http:lnxi.com)
  This file may be distributed under the terms of the
  GNU General Public License.
  Written by Thayne Harbaugh
  Based on work by Dan Hollis <goemon at anime dot net> and others.
 	http:www.anime.net~goemonlinux-ecc
  $Id: edac_amd76x.c,v 1.4.2.5 20051005 00:43:44 dsp_llnl Exp $
 AMD 76x register addresses - device 0 function 0 - PCI bridge 
#define AMD76X_ECC_MODE_STATUS	0x48	 Mode and status of ECC (32b)
					 
					  31:16 reserved
					  15:14 SERR enabled: x1=ue 1x=ce
					  13    reserved
					  12    diag: disabled, enabled
					  11:10 mode: dis, EC, ECC, ECC+scrub
					   9:8  status: x1=ue 1x=ce
					   7:4  UE cs row
					   3:0  CE cs row
#define AMD76X_DRAM_MODE_STATUS	0x58	 DRAM Mode and status (32b)
					 
					  31:26 clock disable 5 - 0
					  25    SDRAM init
					  24    reserved
					  23    mode register service
					  22:21 suspend to RAM
					  20    burst refresh enable
					  19    refresh disable
					  18    reserved
					  17:16 cycles-per-refresh
					  15:8  reserved
					   7:0  x4 mode enable 7 - 0
#define AMD76X_MEM_BASE_ADDR	0xC0	 Memory base address (8 x 32b)
					 
					  31:23 chip-select base
					  22:16 reserved
					  15:7  chip-select mask
					   6:3  reserved
					   2:1  address mode
					   0    chip-select enable
 	amd76x_get_error_info	-	fetch error information
 	@mci: Memory controller
 	@info: Info to fill in
 	Fetch and store the AMD76x ECC status. Clear pending status
 	on the chip so that further errors will be reported
 	amd76x_process_error_info	-	Error check
 	@mci: Memory controller
 	@info: Previously fetched information from chip
 	@handle_errors: 1 if we should do recovery
 	Process the chip state and decide if an error has occurred.
 	A return of 1 indicates an error. Also if handle_errors is true
 	then attempt to handle and clean up after the error
	
	       Check for an uncorrectable error
	
	       Check for a correctable error
 	amd76x_check	-	Poll the controller
 	@mci: Memory controller
 	Called by the poll handlers this function reads the status
 	from the controller and checks for errors.
 find the DRAM Chip Select Base address and mask 
 	amd76x_probe1	-	Perform set up for detected device
 	@pdev; PCI device detected
 	@dev_idx: Device type index
 	We have found an AMD76x and now need to set up the memory
 	controller status reporting. We configure and set up the
 	memory controller reporting and claim the device.
 clear counters 
	 Here we assume that we will never see multiple instances of this
	  type of memory controller.  The ID is therefore hardcoded to 0.
 allocating generic PCI control info 
 get this far and it's successful 
 returns count (>= 0), or negative on error 
 don't need to call pci_enable_device() 
 	amd76x_remove_one	-	driver shutdown
 	@pdev: PCI device being handed back
 	Called when the driver is unloaded. Find the matching mci
 	structure for the device then delete the mci and free the
 	resources.
 0 terminated list. 
 Ensure that the OPSTATE is set correctly for POLL or NMI 
lnxi.com) Thayne Harbaugh");
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2011-2012 Calxeda, Inc.
 DDR Ctrlr Error Registers 
 DDR Ctrlr Interrupt Registers 
 Read the interrupt status register 
 clear the error, clears the interrupt 
 Only a single 4GB DIMM is supported 
 SPDX-License-Identifier: GPL-2.0-only
  Intel E3-1200
  Copyright (C) 2014 Jason Baron <jbaron@akamai.com>
  Support for the E3-1200 processor family. Heavily based on previous
  Intel EDAC drivers.
  Since the DRAM controller is on the cpu chip, we can use its PCI device
  id to identify these processors.
  PCI DRAM controller device ids (Taken from The PCI ID Repository - https:pci-ids.ucw.cz)
  0108: Xeon E3-1200 Processor Family DRAM Controller
  010c: Xeon E3-12002nd Generation Core Processor Family DRAM Controller
  0150: Xeon E3-1200 v23rd Gen Core processor DRAM Controller
  0158: Xeon E3-1200 v2Ivy Bridge DRAM Controller
  015c: Xeon E3-1200 v23rd Gen Core processor DRAM Controller
  0c04: Xeon E3-1200 v34th Gen Core Processor DRAM Controller
  0c08: Xeon E3-1200 v3 Processor DRAM Controller
  1918: Xeon E3-1200 v5 Skylake Host BridgeDRAM Registers
  5918: Xeon E3-1200 Xeon E3-1200 v67th Gen Core Processor Host BridgeDRAM Registers
  3e..: 8th9th Gen Core Processor Host BridgeDRAM Registers
  Based on Intel specification:
  https:www.intel.comcontentdamwwwpublicusendocumentsdatasheetsxeon-e3-1200v3-vol-2-datasheet.pdf
  http:www.intel.comcontentwwwusenprocessorsxeonxeon-e3-1200-family-vol-2-datasheet.html
  https:www.intel.comcontentwwwusenprocessorscore7th-gen-core-family-mobile-h-processor-lines-datasheet-vol-2.html
  https:www.intel.comcontentwwwusenproductsdocsprocessorscore8th-gen-core-family-datasheet-vol-2.html
  According to the above datasheet (p.16):
  "
  6. Software must not access B0D0F0 32-bit memory-mapped registers with
  requests that cross a DW boundary.
  "
  Thus, we make use of the explicit: lo_hi_readq(), which breaks the readq into
  2 readl() calls. This restriction may be lifted in subsequent chip releases,
  but lo_hi_readq() ensures that we are safe across all e3-1200 processors.
 Coffee Lake-S 
 Test if HB is for Skylake or later. 
 Intel IE31200 register addresses - device 0 function 0 - DRAM Controller 
  Error Status Register (16b)
  15    reserved
  14    Isochronous TBWRR Run Behind FIFO Full
        (ITCV)
  13    Isochronous TBWRR Run Behind FIFO Put
        (ITSTV)
  12    reserved
  11    MCH Thermal Sensor Event
        for SMISCISERR (GTSE)
  10    reserved
   9    LOCK to non-DRAM Memory Flag (LCKF)
   8    reserved
   7    DRAM Throttle Flag (DTF)
   6:2  reserved
   1    Multi-bit DRAM ECC Error Flag (DMERR)
   0    Single-bit DRAM ECC Error Flag (DSERR)
  Channel 0 ECC Error Log (64b)
  63:48 Error Column Address (ERRCOL)
  47:32 Error Row Address (ERRROW)
  31:29 Error Bank Address (ERRBANK)
  28:27 Error Rank Address (ERRRANK)
  26:24 reserved
  23:16 Error Syndrome (ERRSYND)
  15: 2 reserved
     1  Multiple Bit Error Status (MERRSTS)
     0  Correctable Error Status (CERRSTS)
 Skylake reports 1GB increments, everything else is 256MB 
 in multiples of 256MB, except Skylake is 1GB 
 0 means x8 width 
 2nd byte of CAPID0 
 check PDCD: Dual Channel Disable 
 check DDPCD - check if both channels are filled 
 4th byte of CAPID0 
	
	  Clear any error bits.
	  (Yes, we really clear bits by writing 1 to them.)
	
	  This is a mess because there is no atomic way to read all the
	  registers at once and the registers can transition from CE being
	  overwritten by UE.
	
	  If the error is the same for both reads then the first set
	  of reads is valid.  If there is a change then there is a CE
	  with no info and the second set of reads is valid and
	  should be UE info.
	
	  Kaby Lake, Coffee Lake seem to work like Skylake. Please re-visit
	  this logic when adding new CPU support.
 populate DIMM info 
	
	  The dram rank boundary (DRB) reg values are boundary addresses
	  for each DRAM rank with a granularity of 64MB.  DRB regs are
	  cumulative; the last one will contain the total memory
	  contained in all ranks.
 just a guess 
 same guess 
 get this far and it's successful 
 0 terminated list. 
 Ensure that the OPSTATE is set correctly for POLL or NMI 
 SPDX-License-Identifier: GPL-2.0
  Driver for Intel(R) 10nm server memory controller.
  Copyright (c) 2019, Intel Corporation.
 Debug macros 
 Save default configurations 
 Restore default configurations 
 Clear status bits 
  Debug feature.
  Exercise the address decode logic by writing an address to
  syskerneldebugedaci10nm_testaddr.
 ADDRV + MemRd + Unknown channel 
 One corrected error 
CONFIG_EDAC_DEBUG
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: GPL-2.0
  Driver for Intel client SoC with integrated memory controller using IBECC
  Copyright (C) 2020 Intel Corporation
  The In-Band ECC (IBECC) IP provides ECC protection to all or specific
  regions of the physical memory space. It's used for memory controllers
  that don't support the out-of-band ECC which often needs an additional
  storage device to each channel for storing ECC data.
 Debug macros 
 Max memory controllers 
 Max channels 
 Max DIMMs per channel 
 Size of physical memory 
 Top of low usable DRAM 
 Capability register C 
 Capability register E 
 Error Status 
 Error Command 
 IBECC MMIO base address 
 IBECC error log 
 Host MMIO base address 
 Parameters for the channel decode stage 
 Parameters for DRAM decode stage 
 DIMM characteristics 
 Hash for memory controller selection 
 Hash for channel selection 
 Hash for enhanced channel selection 
 Parameters for memory slice decode stage 
 Convert error address logged in IBECC to system physical address 
 Convert error address logged in IBECC to integrated memory controller address 
 The top of low usable DRAM 
 The size of physical memory 
  In the NMI handler, the driver uses the lock-less memory allocator
  to allocate memory to store the IBECC error logs and links the logs
  to the lock-less list. Delay printk() and the work of error reporting
  to EDAC core in a worker.
 Compute die IDs for Elkhart Lake with IBECC 
 Compute die IDs for ICL-NNPI with IBECC 
 Compute die IDs for Tiger Lake with IBECC 
 Compute die IDs for Alder Lake with IBECC 
 Remove the interleave bit and shift upper part down to fill gap 
 Decode channel 
 Decode sub-channelDIMM 
  Either the memory-mapped IO status register ECC_ERROR_LOG or the PCI
  configuration space status register ERRSTS can indicate whether a
  correctable error or an uncorrectable error occurred. We only use the
  ECC_ERROR_LOG register to check error type, but need to clear both
  registers to enable future error events.
 Clear CEUE bits by writing 1s 
 Clear CEUE bits by writing 1s 
 errsts_clear() isn't NMI-safe. Delay it in the IRQ context 
	
	  Both In-Band ECC correctable error and uncorrectable error are
	  reported by SERR# NMI. The NMI generic code (see pci_serr_error())
	  doesn't clear the bit NMI_REASON_CLEAR_SERR (in port 0x61) to
	  re-enable the SERR# NMI after NMI handling. So clear this bit here
	  to re-enable SERR# NMI for receiving future In-Band ECC errors.
	
	  Ignore unless this is a memory related error.
	  We don't check the bit MCI_STATUS_ADDRV of MCi_STATUS here,
	  since this bit isn't set on some CPU (e.g., Tiger Lake UP3).
	
	  We just use the Machine Check for the memory error notification.
	  Each memory controller is associated with an IBECC instance.
	  Directly read and clear the error information(error address and
	  error type) on all the IBECC instances so that we know on which
	  memory controller the memory error(s) occurred.
 Top of upper usable DRAM 
	
	  EDAC core uses mci->pdev(pointer of structure device) as
	  memory controller ID. The client SoCs attach one or more
	  memory controllers to single pci_dev (single pci_dev->dev
	  can be for multiple memory controllers).
	 
	  To make mci->pdev unique, assign pci_dev->dev to mci->pdev
	  for the first memory controller and assign a unique imc->dev
	  to mci->pdev for each non-first memory controller.
 Check if any pending errors before registering the NMI handler 
 Enable error reporting 
  Intel 5100 Memory Controllers kernel module
  This file may be distributed under the terms of the
  GNU General Public License.
  This module is based on the following document:
  Intel 5100X Chipset Memory Controller Hub (MCH) - Datasheet
       http:download.intel.comdesignchipsetsdatashts318378.pdf
  The intel 5100 has two independent channels. EDAC core currently
  can not reflect this configuration so instead the chip-select
  rows for each respective channel are laid out one after another,
  the first half belonging to channel 0, the second half belonging
  to channel 1.
  This driver is for DDR2 DIMMs, and it uses chip select to select among the
  several ranks. However, instead of showing memories as ranks, it outputs
  them as DIMM's. An internal table creates the association between ranks
  and DIMM's.
 register addresses 
 device 16, func 1 
 Memory Control Register 
 Memory Status Register 
 Serial Presence Detect Status Reg 
 Serial Presence Detect Command Reg 
 Top of Low Memory 
 Memory Interleave Range 0 
 Memory Interleave Range 1 
 Adjusted Memory Interleave Range 0 
 Adjusted Memory Interleave Range 1 
 MC First Non Fatal Errors 
 MC Next Non-Fatal Errors 
 MC Error Mask Register 
 Injection Mask0 Register Channel 0 
 Injection Mask0 Register Channel 1 
 Injection Mask1 Register Channel 0 
 Injection Mask1 Register Channel 1 
 Device 19, Function 0 
 device 21 and 22, func 0 
 Memory Technology Registers 0-3 
 DIMM Interleave Range 
 Valid Log Markers 
 Non-Recoverable Memory Error Log Reg A 
 Non-Recoverable Memory Error Log Reg B 
 Recoverable Memory Data Error Log Reg A 
 Recoverable Memory Data Error Log Reg B 
 Recoverable Memory Error Log Reg A 
 Recoverable Memory Error Log Reg B 
 Memory Technology Registers 4,5 
 bit field accessors 
 some generic limits 
 64 bits  8 bits per byte 
 ranks on each dimm -- 0 maps to not present -- obtained via SPD 
	
	  mainboard chip select map -- maps i5100 chip selects to
	  DIMM slot chip selects.  In the case of only 4 ranks per
	  channel, the mapping is fairly obvious but not unique.
	  we map -1 -> NC and assume both channels use the same
	  map...
	 
 memory interleave range 
 adjusted memory interleave range register 
 dimm interleave range 
 memory technology registers... 
 0 or 1 
 0 or 1 
 4 or 8 bits  
 2 or 3 lines 
 13 .. 16 lines 
 11 .. 12 lines 
 top of low memory in bytes 
 number of ranks per channel 
 device 16 func 1 
 device 19 func 0 
 device 21 func 0 
 device 22 func 0 
 Error injection 
 map a rankchan to a slot number on the mainboard 
 0 
 1 
 2 
 3 
 4 
 5 
 6 
 7 
 8 
 9 
 10 
 11 
 12 
 13 
 14 
 15 
 16 
 17 
 18 
 19 
 20 
 21 
 convert csrow index into a rank (per channel -- 0..5) 
 convert csrow index into a channel (0..1) 
 Form out message 
 Form out message 
		 FIXME:  not really sure if this is what merr is...
		 FIXME:  not really sure if this is what merr is...
 The i5100 chipset will scrub the entire memory once, then
  set a done bit. Continuous scrubbing is achieved by enqueing
  delayed work to a workqueue, checking every few minutes if
  the scrubbing has completed and if so reinitiating it.
  The bandwidth is based on experimentation, feel free to refine it.
 dimm present? 
  FIXME: make this into a real i2c adapter (so that dimm-decode
  will work)?
 wait up to 100ms 
  fill dimm chip select map
  FIXME:
    o not the only way to may chip selects to dimm slots
    o investigate if there is some way to obtain this map from the bios
 default NC 
 only 2 chip selects per slot... 
                        Error injection routines
	 MEM[1:0]EINJMSK0
	  31    - ADDRMATCHEN
	  29:28 - HLINESEL
	          00 Reserved
	          01 Lower half of cache line
	          10 Upper half of cache line
	          11 Both upper and lower parts of cache line
	  27    - EINJEN
	  25:19 - XORMASK1 for deviceptr1
	  9:5   - SEC2RAM for deviceptr2
	  4:0   - FIR2RAM for deviceptr1
	 MEM[1:0]EINJMSK1
	  15:0  - XORMASK2 for deviceptr2
	 Error Injection Response Function
	  Intel 5100 Memory Controller Hub Chipset (318378) datasheet
	  hints about this register but carry no data about them. All
	  data regarding device 19 is based on experimentation and the
	  Intel 7300 Chipset Memory Controller Hub (318082) datasheet
	  which appears to be accurate for the i5100 in this area.
	 
	  The injection code don't work without setting this register.
	  The register needs to be flipped off then on else the hardware
	  will only preform the first injection.
	 
	  Stop condition bits 7:4
	  1010 - Stop after one injection
	  1011 - Never stop injecting faults
	 
	  Start condition bits 3:0
	  1010 - Never start
	  1011 - Start immediately
 ECC enabled? 
 figure out how many ranks, from strapped state of 48GB_Mode input 
 enable error reporting... 
 device 21, func 0, Channel 0 Memory Map, Error FlagMask, etc... 
 device 22, func 0, Channel 1 Memory Map, Error FlagMask, etc... 
 device 19, func 0, Error injection 
 If scrubbing was already enabled by the bios, start maintaining it 
 this strange construction seems to be in every driver, dunno why 
 Device 16, Function 0, Channel 0 Memory Map, Error FlagMask, ... 
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  Copyright (C) 2009 Wind River Systems,
    written by Ralf Baechle <ralf@linux-mips.org>
  Copyright (c) 2013 by Cisco Systems, Inc.
  All rights reserved.
 Done, re-arm 
 Done, re-arm 
 Done, re-arm 
 Done, re-arm 
 MC SYSFS parts 
 Only a couple naming differences per template, so very similar 
 We poll 
 OCTEON II 
 We poll 
  Freescale Memory Controller kernel module
  Author: York Sun <york.sun@nxp.com>
  Copyright 2016 NXP Semiconductor
  Derived from mpc85xx_edac.c
  Author: Dave Jiang <djiang@mvista.com>
  2006-2007 (c) MontaVista Software, Inc. This file is licensed under
  the terms of the GNU General Public License version 2. This program
  is licensed "as is" without any warranty of any kind, whether express
  or implied.
 make sure error reporting method is sane 
  Intel e7xxx Memory Controller kernel module
  (C) 2003 Linux Networx (http:lnxi.com)
  This file may be distributed under the terms of the
  GNU General Public License.
  See "enum e7xxx_chips" below for supported chipsets
  Written by Thayne Harbaugh
  Based on work by Dan Hollis <goemon at anime dot net> and others.
 	http:www.anime.net~goemonlinux-ecc
  Datasheet:
 	http:www.intel.comcontentwwwusenchipsetse7501-chipset-memory-controller-hub-datasheet.html
  Contributors:
 	Eric Biederman (Linux Networx)
 	Tom Zimmerman (Linux Networx)
 	Jim Garlick (Lawrence Livermore National Labs)
 	Dave Peterson (Lawrence Livermore National Labs)
 	That One Guy (Some other place)
 	Wang Zhenyu (intel.com)
  $Id: edac_e7xxx.c,v 1.5.2.9 20051005 00:43:44 dsp_llnl Exp $
 PCI_DEVICE_ID_INTEL_7205_0 
 PCI_DEVICE_ID_INTEL_7205_1_ERR 
 PCI_DEVICE_ID_INTEL_7500_0 
 PCI_DEVICE_ID_INTEL_7500_1_ERR 
 PCI_DEVICE_ID_INTEL_7501_0 
 PCI_DEVICE_ID_INTEL_7501_1_ERR 
 PCI_DEVICE_ID_INTEL_7505_0 
 PCI_DEVICE_ID_INTEL_7505_1_ERR 
 number of csrows 
 2 channels, 4 dimmschannel 
 E7XXX register addresses - device 0 function 0 
 DRAM row boundary register (8b) 
 DRAM row attribute register (8b) 
					
					  31   Device width row 7 0=x8 1=x4
					  27   Device width row 6
					  23   Device width row 5
					  19   Device width row 4
					  15   Device width row 3
					  11   Device width row 2
					   7   Device width row 1
					   3   Device width row 0
 DRAM controller mode reg (32b) 
					
					  22    Number channels 0=1,1=2
					  19:18 DRB Granularity 3264MB
 DRAM top of low memory reg (16b) 
 DRAM remap base address reg (16b) 
 DRAM remap limit address reg (16b) 
 E7XXX register addresses - device 0 function 1 
 DRAM first error register (8b) 
 DRAM next error register (8b) 
 DRAM first correctable memory 
     error address register (32b) 
					
					  31:28 Reserved
					  27:6  CE address (4k block 33:12)
					   5:0  Reserved
 DRAM first uncorrectable memory 
     error address register (32b) 
					
					  31:28 Reserved
					  27:6  CE address (4k block 33:12)
					   5:0  Reserved
 DRAM first correctable memory 
     error syndrome register (16b) 
 FIXME - is this valid for both SECDED and S4ECD4ED? 
 read the error address 
 FIXME - should use PAGE_SHIFT 
 convert the address to 4k page 
 read the syndrome 
 FIXME - check for -1 
 convert syndrome to channel 
 read the error address 
 FIXME - should use PAGE_SHIFT 
 convert to 4k address 
 decode and report errors 
 check first error correctable 
 check first error uncorrectable 
 check next error correctable 
 check next error uncorrectable 
 Return 1 if dual channel mode is active.  Else return 0. 
 Return DRB granularity (0=32mb, 1=64mb). 
 only e7501 can be single channel 
	 The dram row boundary (DRB) reg values are boundary address
	  for each DRAM row with a granularity of 32 or 64MB (singledual
	  channel operation).  DRB regs are cumulative; therefore DRB7 will
	  contain the total memory contained in all eight rows.
 mem_dev 0=x8, 1=x4 
 convert a 64 or 32 MiB DRB to a page size. 
 not populated 
		
		 if single channel or x8 devices then SECDED
		 if dual channel and x4 then S4ECD4ED
 4KiB - resolution of CELOG 
 only one type supported 
	
	  According with the datasheet, this device has a maximum of
	  4 DIMMS per channel, either single-rank or dual-rank. So, the
	  total amount of dimms is 8 (E7XXX_NR_DIMMS).
	  That means that the DIMM is mapped as CSROWs, and the channel
	  will map the rank. So, an error to either channel should be
	  attributed to the same dimm.
 FIXME - what if different memory types are in different csrows? 
 load the top of low memory, remap base, and remap limit vars 
 clear any pending errors, or initial state bits 
	 Here we assume that we will never see multiple instances of this
	  type of memory controller.  The ID is therefore hardcoded to 0.
 allocating generic PCI control info 
 get this far and it's successful 
 returns count (>= 0), or negative on error 
 wake up and enable device 
 0 terminated list. 
 Ensure that the OPSTATE is set correctly for POLL or NMI 
lnxi.com) Thayne Harbaugh et al\n"
 SPDX-License-Identifier: GPL-2.0-only
  cpc925_edac.c, EDAC driver for IBM CPC925 Bridge and Memory Controller.
  Copyright (c) 2008 Wind River Systems, Inc.
  Authors:	Cao Qingtao <qingtao.cao@windriver.com>
  CPC925 registers are of 32 bits with bit0 defined at the
  most significant bit and bit31 at that of least significant.
  EDAC device names for the error detections of
  CPU Interface and Hypertransport Link.
 Suppose DDR Refresh cycle is 15.6 microsecond 
 bytes 
  All registers and bits definitions are taken from
  "CPC925 Bridge and Memory Controller User Manual, SA14-2761-02".
  CPU and Memory Controller Registers
 	Processor Interface Exception Mask Register (APIMASK)
 DART Exception 
 Handshake Error on PI0_ADI 
 Handshake Error on PI1_ADI 
 Status Exception 
 Data Error Exception 
 Addressing Exception on PI0 
 Addressing Exception on PI1 
 BIT(7) Reserved 
 UECC upper 
 CECC upper 
 UECC lower 
 CECC lower 
 	Processor Interface Exception Register (APIEXCP)
 DART Exception 
 Handshake Error on PI0_ADI 
 Handshake Error on PI1_ADI 
 Status Exception 
 Data Error Exception 
 Addressing Exception on PI0 
 Addressing Exception on PI1 
 BIT(7) Reserved 
 UECC upper 
 CECC upper 
 UECC lower 
 CECC lower 
 	Memory Bus Configuration Register (MBCR)
 	Memory Bank Mode Register (MBMR)
 	Memory Bank Boundary Address Register (MBBAR)
 	Memory Scrub Control Register (MSCR)
 scrub_mod - bit0:1
 01 
 si - bit8:15
 	Memory Scrub Range Start Register (MSRSR)
 	Memory Scrub Range End Register (MSRER)
 	Memory Scrub Pattern Register (MSPR)
 	Memory Check Control Register (MCCR)
 ECC high and low check 
 	Memory Check Range End Register (MCRER)
 	Memory Error Address Register (MEAR)
 	Memory Error Syndrome Register (MESR)
 	Memory Mode Control Register (MMCR)
  HyperTransport Link Registers
   Error HandlingEnumeration Scratch Pad Register (ERRCTRL)
 nonfatal interrupts for 
 system error 
 CRC error 
 Response error 
 End-Of-Chain error 
 Overflow error 
 Protocol error 
 Response error received 
 Sync flooding detected 
   Link Configuration and Link Control Register (LINKCTRL)
   Link FreqCapErrorFreqRevision ID Register (LINKERR)
 End-Of-Chain error 
 Receive Buffer Overflow 
 Protocol error 
 	Bridge Control Register (BRGCTRL)
 SERR on Secondary Bus 
 Secondary Bus Reset 
 Private structure for edac memory controller 
 Private structure for common edac device 
 Get total memory size from Open Firmware DTB 
 not populated 
 256M 
 Single channel 
 four-beat burst of 32 bytes 
 Dual channel 
 four-beat burst of 64 bytes 
 0110, no way to differentiate X8 VS X16 
 0101 
 1000 
 0111 
 1001 
 Enable memory controller ECC detection 
 Enable various ECC error exceptions 
 Enable ECC detection 
 Disable memory controller ECC detection 
	
	  WARNING:
	  We are supposed to clear the ECC error detection bits,
	  and it will be no problem to do so. However, once they
	  are cleared here if we want to re-install CPC925 EDAC
	  module later, setting them up in cpc925_mc_init() will
	  trigger machine check exception.
	  Also, it's ok to leave ECC error detection bits enabled,
	  since they are reset to 1 by default or by boot loader.
  Revert DDR columnrowbank addresses into page frame number and
  offset in page.
  Suppose memory mode is 0x0111(128-bit mode, identical DIMM pairs),
  physical address(PA) bits to column address(CA) bits mappings are:
  CA	0   1   2   3   4   5   6   7   8   9   10
  PA	59  58  57  56  55  54  53  52  51  50  49
  physical address(PA) bits to bank address(BA) bits mappings are:
  BA	0   1
  PA	43  44
  physical address(PA) bits to row address(RA) bits mappings are:
  RA	0   1   2   3   4   5   6   7   8   9   10   11   12
  PA	36  35  34  48  47  46  45  40  41  42  39   38   37
 Revert csrow number 
 Revert column address 
 Revert bank address 
 Revert row address, in 4 steps 
 Check memory controller registers for ECC errors 
 APIEXCP is cleared when read 
 Revert columnrow addresses into page frame number, etc 
 CPU err device
 use cached value if available 
		 We assume that each CPU sits on it's own PI and that
		  for present CPUs the reg property equals to the PI
 Enable CPU Errors detection 
 Disable CPU Errors detection 
	
	  WARNING:
	  We are supposed to clear the CPU error detection bits,
	  and it will be no problem to do so. However, once they
	  are cleared here if we want to re-install CPC925 EDAC
	  module later, setting them up in cpc925_cpu_init() will
	  trigger machine check exception.
	  Also, it's ok to leave CPU error detection bits enabled,
	  since they are reset to 1 by default.
 Check for CPU Errors 
 APIEXCP is cleared when read 
 HT Link err device
 Enable HyperTransport Link Error detection 
 Disable HyperTransport Link Error detection 
 Check for HyperTransport Link errors 
 Clear by write 1 
 Initiate Secondary Bus Reset to clear the chain failure 
  Add CPU Err detection and HyperTransport Link Err detection
  as common "edac_device", they have no corresponding device
  nodes in the Open Firmware DTB and we have to add platform
  devices for them. Also, they will share the MMIO with that
  of memory controller.
		
		  Don't have to allocate private structure but
		  make use of cpc925_devs[] instead.
  Delete the common "edac_device" for CPU Err Detection
  and HyperTransport Link Err Detection
 Convert current back-ground scrub rate into bytesec bandwidth 
 Return 0 for single channel; 1 for dual channel 
	
	  Dual channel only when 128-bit wide physical bus
	  and 128-bit configuration.
 Setup memory controller registers 
 get this far and it's successful 
	
	  Delete common edac devices before edac mc, because
	  the former share the MMIO of the latter.
 Only support POLL mode so far 
 SPDX-License-Identifier: GPL-2.0-only
  GHESEDAC Linux driver
  Copyright (c) 2013 by Mauro Carvalho Chehab
  Red Hat Inc. https:www.redhat.com
 Buffers for the error handling routine 
  Access to ghes_pvt must be protected by ghes_lock. The spinlock
  also provides the necessary (implicit) memory barrier for the SMP
  case to make the pointer visible on another CPU.
  This driver's representation of the system hardware, as collected
  from DMI.
 GHES registration mutex 
  Sync with other, potentially concurrent callers of
  ghes_edac_report_mem_error(). We don't know what the
  "inventive" firmware would do.
 "ghes_edac.force_load=1" skips the platform check 
 Memory Device - Type 17 of SMBIOS spec 
 both strings must be non-zero 
 Unknown 
	
	  Actually, we can only detect if the memory has bits for
	  checksum or not
 Likely, worse case 
 Enlarge the array with additional 16 
	
	  We can do the locking below because GHES defers error processing
	  from NMI to IRQ context. Whenever that changes, we'd at least
	  know.
 Cleans the error report buffer 
 Error type, mapped on e->msg 
 Error address 
 Error grain 
 Memory error location, mapped on e->location 
 All other fields are mapped on e->other_detail 
  Known systems that are safe to enable this module.
 End 
 Check if safe to enable on this system 
 finish another registrationunregistration instance first 
	
	  We have only one logical memory controller to which all DIMMs belong.
 Check if we've got a bogus BIOS 
			
			  If no src->label, preserve default label assigned
			  from EDAC core.
 only set on success 
 Not needed anymore 
	
	  Wait for the irq handler being finished.
  Cavium ThunderX memory controller kernel module
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  Copyright Cavium, Inc. (C) 2015-2017. All rights reserved.
  To get an ECC error injected, the following steps are needed:
  - Setup the ECC injection by writing the appropriate parameters:
 	echo <bit mask value> > syskerneldebug<device number>ecc_mask0
 	echo <bit mask value> > syskerneldebug<device number>ecc_mask2
 	echo 0x802 > syskerneldebug<device number>ecc_parity_test
  - Do the actual injection:
 	echo 1 > syskerneldebug<device number>inject_ecc
 Trigger the interrupt 
		
		  Flush L1 cachelines to the PoC (L2).
		  This will cause cacheline eviction to the L2.
		
		  Flush L2 cachelines to the DRAM.
		  This will cause cacheline eviction to the DRAM
		  and ECC corruption according to the masks set.
		
		  Invalidate L2 cachelines.
		  The subsequent load will cause cacheline fetch
		  from the DRAM and an error interrupt
		
		  Invalidate L1 cachelines.
		  The subsequent load will cause cacheline fetch
		  from the L2 andor DRAM
			
			  Do a load from the previously rigged location
			  This should generate an error interrupt.
 Clear the interrupt 
---------------------- OCX driver ---------------------------------
 This handler is threaded 
---------------------- L2C driver ---------------------------------
Should never ever get here
  Radisys 82600 Embedded chipset Memory Controller kernel module
  (C) 2005 EADS Astrium
  This file may be distributed under the terms of the
  GNU General Public License.
  Written by Tim Small <tim@buttersideup.com>, based on work by Thayne
  Harbaugh, Dan Hollis <goemon at anime dot net> and others.
  $Id: edac_r82600.c,v 1.1.2.6 20051005 00:43:44 dsp_llnl Exp $
  Written with reference to 82600 High Integration Dual PCI System
  Controller Data Book:
  www.radisys.comfilessupport_downloads007-01277-0002.82600DataBook.pdf
  references to this document given in []
 Radisys say "The 82600 integrates a main memory SDRAM controller that
  supports up to four banks of memory. The four banks can support a mix of
  sizes of 64 bit wide (72 bits with ECC) Synchronous DRAM (SDRAM) DIMMs,
  each of which can be any size from 16MB to 512MB. Both registered (control
  signals buffered) and unbuffered DIMM types are supported. Mixing of
  registered and unbuffered DIMMs as well as mixing of ECC and non-ECC DIMMs
  is not allowed. The 82600 SDRAM interface operates at the same frequency as
  the CPU bus, 66MHz, 100MHz or 133MHz."
 Radisys 82600 register addresses - device 0 function 0 - PCI bridge 
#define R82600_DRAMC	0x57	 Various SDRAM related control bits
				  all bits are RW
				 
				  7    SDRAM ISA Hole Enable
				  6    Flash Page Mode Enable
				  5    ECC Enable: 1=ECC 0=noECC
				  4    DRAM DIMM Type: 1=
				  3    BIOS Alias Disable
				  2    SDRAM BIOS Flash Write Enable
				  1:0  SDRAM Refresh Rate: 00=Disabled
				           01=7.8usec (256Mbit SDRAMs)
				           10=15.6us 11=125usec
#define R82600_SDRAMC	0x76	 "SDRAM Control Register"
				  More SDRAM related control bits
				  all bits are RW
				 
				  15:8 Reserved.
				 
				  7:5  Special SDRAM Mode Select
				 
				  4    Force ECC
				 
				         1=Drive ECC bits to 0 during
				           write cycles (i.e. ECC test mode)
				 
				         0=Normal ECC functioning
				 
				  3    Enhanced Paging Enable
				 
				  2    CAS# Latency 0=3clks 1=2clks
				 
				  1    RAS# to CAS# Delay 0=3 1=2
				 
				  0    RAS# Precharge     0=3 1=2
#define R82600_EAP	0x80	 ECC Error Address Pointer Register
				 
				  31    Disable Hardware Scrubbing (RW)
				         0=Scrub on corrected read
				         1=Don't scrub on corrected read
				 
				  30:12 Error Address Pointer (RO)
				         Upper 19 bits of error address
				 
				  11:4  Syndrome Bits (RO)
				 
				  3     BSERR# on multibit error (RW)
				         1=enable 0=disable
				 
				  2     NMI on Single Bit Eror (RW)
				         1=NMI triggered by SBE n.b. other
				           prerequeists
				         0=NMI not triggered
				 
				  1     MBE (RWC)
				         read 1=MBE at EAP (see above)
				         read 0=no MBE, or SBE occurred first
				         write 1=Clear MBE status (must also
				           clear SBE)
				         write 0=NOP
				 
				  1     SBE (RWC)
				         read 1=SBE at EAP (see above)
				         read 0=no SBE, or MBE occurred first
				         write 1=Clear SBE status (must also
				           clear MBE)
				         write 0=NOP
#define R82600_DRBA	0x60	 + 0x60..0x63 SDRAM Row Boundary Address
				   Registers
				 
				  7:0  Address lines 30:24 - upper limit of
				  each row [p57]
 Clear error to allow next error to be reported [p.62] 
 Clear error to allow next error to be reported [p.62] 
 bits 30:12 store the upper 19 bits of the 32 bit error address 
 Syndrome in bits 11:4 [p.62]       
	 the R82600 reports at less than page 
 CE? 
 UE? 
 82600 doesn't give enough info 
 SDRAM Row Boundary Address Register 
 find the DRAM Chip Select Base address and mask 
		row_high_limit = ((u32)drbar << 24) | 0xffffffUL; 
 Empty row [p.57] 
		 Error address is top 19 bits - so granularity is      
 FIXME - check that this is unknowable with this chipset 
 Mode is global on 82600 
	 FIXME try to work out if the chip leads have been used for COM2
	  instead on this board? [MA6?] MAYBE:
	 On the R82600, the pins for memory bits 72:65 - i.e. the   
	  EC bits are shared with the pins for COM2 (!), so if COM2  
	  is enabled, we assume COM2 is wired up, and thus no EDAC   
 clear counters 
	 Here we assume that we will never see multiple instances of this
	  type of memory controller.  The ID is therefore hardcoded to 0.
 get this far and it's successful 
 allocating generic PCI control info 
 returns count (>= 0), or negative on error 
 don't need to call pci_enable_device() 
 0 terminated list. 
 Ensure that the OPSTATE is set correctly for POLL or NMI 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2017 Texas Instruments Incorporated - https:www.ti.com
  Texas Instruments DDR3 ECC error correction and detection driver
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
  You should have received a copy of the GNU General Public License along with
  this program.  If not, see <http:www.gnu.orglicenses>.
 EMIF controller registers 
 Bit definitions for EMIF_SDRAM_CONFIG 
 IRQ bit definitions 
 Bit 31 enables ECC and 28 enables RMW 
 Allocate ID number for our EMIF controller 
 Setup memory layout 
 add EMIF ECC error handler 
 Generate an interrupt with each 1b error 
 Enable interrupts 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2011-2012 Calxeda, Inc.
  Intel 82975X Memory Controller kernel module
  (C) 2007 aCarLab (India) Pvt. Ltd. (http:acarlab.com)
  (C) 2007 jetzbroadband (http:jetzbroadband.com)
  This file may be distributed under the terms of the
  GNU General Public License.
  Written by Arvind R.
    Copied from i82875p_edac.c source:
 PCI_DEVICE_ID_INTEL_82975_0 
 Intel 82975X register addresses - device 0 function 0 - DRAM Controller 
#define I82975X_EAP		0x58	 Dram Error Address Pointer (32b)
					 
					  31:7  128 byte cache-line address
					  6:1   reserved
					  0     0: CH0; 1: CH1
#define I82975X_DERRSYN		0x5c	 Dram Error SYNdrome (8b)
					 
					   7:0  DRAM ECC Syndrome
#define I82975X_DES		0x5d	 Dram ERRor DeSTination (8b)
					  0h:    Processor Memory Reads
					  1h:7h  reserved
					  More - See Page 65 of Intel DocSheet.
#define I82975X_ERRSTS		0xc8	 Error Status Register (16b)
					 
					  15:12 reserved
					  11    Thermal Sensor Event
					  10    reserved
					   9    non-DRAM lock error (ndlock)
					   8    Refresh Timeout
					   7:2  reserved
					   1    ECC UE (multibit DRAM error)
					   0    ECC CE (singlebit DRAM error)
 Error Reporting is supported by 3 mechanisms:
  1. DMI SERR generation  ( ERRCMD )
  2. SMI DMI  generation  ( SMICMD )
  3. SCI DMI  generation  ( SCICMD )
NOTE: Only ONE of the three must be enabled
#define I82975X_ERRCMD		0xca	 Error Command (16b)
					 
					  15:12 reserved
					  11    Thermal Sensor Event
					  10    reserved
					   9    non-DRAM lock error (ndlock)
					   8    Refresh Timeout
					   7:2  reserved
					   1    ECC UE (multibit DRAM error)
					   0    ECC CE (singlebit DRAM error)
#define I82975X_SMICMD		0xcc	 Error Command (16b)
					 
					  15:2  reserved
					   1    ECC UE (multibit DRAM error)
					   0    ECC CE (singlebit DRAM error)
#define I82975X_SCICMD		0xce	 Error Command (16b)
					 
					  15:2  reserved
					   1    ECC UE (multibit DRAM error)
					   0    ECC CE (singlebit DRAM error)
#define I82975X_XEAP	0xfc	 Extended Dram Error Address Pointer (8b)
					 
					  7:1   reserved
					  0     Bit32 of the Dram Error Address
#define I82975X_MCHBAR		0x44	
					 
					  31:14 Base Addr of 16K memory-mapped
					 	configuration space
					  13:1  reserved
					   0    mem-mapped config space enable
 NOTE: Following addresses have to indexed using MCHBAR offset (44h, 32b) 
 Intel 82975x memory mapped register space 
 fixed 32MiB grain 
#define I82975X_DRB		0x100	 DRAM Row Boundary (8b x 8)
					 
					  7   set to 1 in highest DRB of
					 	channel if 4GB in ch.
					  6:2 upper boundary of rank in
					 	32MB grains
					  1:0 set to 0
#define I82975X_DRA		0x108	 DRAM Row Attribute (4b x 8)
					   defines the PAGE SIZE to be used
					 	for the rank
					   7    reserved
					   6:4  row attr of odd rank, i.e. 1
					   3    reserved
					   2:0  row attr of even rank, i.e. 0
					 
					  000 = unpopulated
					  001 = reserved
					  010 = 4KiB
					  011 = 8KiB
					  100 = 16KiB
					  others = reserved
#define I82975X_BNKARC	0x10e  Type of device in each rank - Bank Arch (16b)
					 
					  15:8  reserved
					  7:6  Rank 3 architecture
					  5:4  Rank 2 architecture
					  3:2  Rank 1 architecture
					  1:0  Rank 0 architecture
					 
					  00 => 4 banks
					  01 => 8 banks
#define I82975X_DRC		0x120  DRAM Controller Mode0 (32b)
					 
					  31:30 reserved
					  29    init complete
					  28:11 reserved, according to Intel
					     22:21 number of channels
					 		00=1 01=2 in 82875
					 		seems to be ECC mode
					 		bits in 82975 in Asus
					 		P5W
					 	 19:18 Data Integ Mode
					 		00=none 01=ECC in 82875
					  10:8  refresh mode
					   7    reserved
					   6:4  mode select
					   3:2  reserved
					   1:0  DRAM type 10=Second Revision
					 		DDR2 SDRAM
					          00, 01, 11 reserved
#define I82975X_DRC_M1	0x124  DRAM Controller Mode1 (32b)
					  31	0=Standard Address Map
					 	1=Enhanced Address Map
					  30:0	reserved
 the channel is bit 0 of EAP 
 extended eap bit 
static struct pci_dev mci_pdev;	 init dev: in case that AGP code has
					  already registered driver
	
	  This is a mess because there is no atomic way to read all the
	  registers at once and the registers can transition from CE being
	  overwritten by UE.
	
	  If the error is the same then we can for both reads then
	  the first set of reads is valid.  If there is a change then
	  there is a CE no info and the second set of reads is valid
	  and should be UE info.
 Return 1 if dual channel mode is active.  Else return 0. 
	
	  We treat interleaved-symmetric configuration as dual-channel - EAP's
	  bit-0 giving the channel of the error location.
	 
	  All other configurations are treated as single channel - the EAP's
	  bit-0 will resolve ok in symmetric area of mixed
	  (symmetricasymmetric) configurations
	
	  82875 comment:
	  The dram row boundary (DRB) reg values are boundary address
	  for each DRAM row with a granularity of 32 or 64MB (singledual
	  channel operation).  DRB regs are cumulative; therefore DRB7 will
	  contain the total memory contained in all rows.
	 
		
		  Adjust cumul_size w.r.t number of channels
		 
		
		  Initialise dram labels
		  index values:
		    [0-7] for single-channel; i.e. csrow->nr_channels = 1
		    [0-3] for dual-channel; i.e. csrow->nr_channels = 2
 128Byte cache-line resolution 
 ECC is possible on i92975x ONLY with DEV_X8.  
 I82975x supports only DDR2 
 only supported 
 #define  i82975x_DEBUG_IOMEM 
	
	  The register meanings are from Intel specs;
	  (shows 13-5-5-5 for 800-DDR2)
	  Asus P5W Bios reports 15-5-4-4
	  What's your religion?
 bits 31:14 used for 16K window 
 assuming only one controller, index thus is 0 
 clear counters 
 finalize this instance of memory controller with edac core 
 get this far and it's successful 
 returns count (>= 0), or negative on error 
 0 terminated list. 
 Ensure that the OPSTATE is set correctly for POLL or NMI 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018, The Linux Foundation. All rights reserved.
 Single & double bit syndrome register offsets 
 Error register offsets 
 TRP, DRP interrupt register offsets 
 Mask and shift macros 
 Config registers offsets
 Tag RAM, Data RAM interrupt register offsets 
	
	  Configure interrupt enable registers such that Tag, Data RAM related
	  interrupts are propagated to interrupt controller for servicing
 Clear the error interrupt and counter registers 
 Dump Syndrome registers data for Tag RAM, Data RAM bit errors
 Iterate over the banks and look for Tag RAM or Data RAM errors 
 Allocate edac control info 
 Request for ecc irq 
 SPDX-License-Identifier: GPL-2.0-or-later
  APM X-Gene SoC EDAC (error detection and correction)
  Copyright (c) 2015, Applied Micro Circuits Corporation
  Author: Feng Kan <fkan@apm.com>
          Loc Ho <lho@apm.com>
 Global error configuration status registers (CSR) 
 Memory controller error CSR 
 Detect uncorrectable memory error 
 Detected uncorrectable memory error 
 Detect correctable memory error 
 Clear all error registers 
 Detect memory controller error 
	
	  As there is only single bit for enable error and interrupt mask,
	  we must only enable top level interrupt after all MCUs are
	  registered. Otherwise, if there is an error and the corresponding
	  MCU has not registered, the interrupt will never get cleared. To
	  determine all MCU have registered, we will keep track of active
	  MCUs and registered MCUs.
 Set registered MCU bit 
 Enable interrupt after all active MCU registered 
 Enable memory controller top level interrupt 
 Enable MCU interrupt and error reporting 
 Disable MCU interrupt 
 Disable memory controller top level interrupt 
 Clear registered MCU bit 
		
		  Dual MCB active - Determine if all 4 active or just MCU0
		  and MCU2 active
		
		  Single MCB active - Determine if MCU0MCU1 or just MCU0
		  active
 Save active MC mask if hasn't set already 
 Ignore non-active MCU 
 Copy over resource value 
 CPU L1L2 error CSR 
  Processor Module Domain (PMD) context - Context for a pair of processsors.
  Each PMD consists of 2 CPUs and a shared L2 cache. Each CPU consists of
  its own L1 cache.
 Clear any HW errors 
 Clear any HW errors 
 Clear any HW errors 
 Check L2 
 Clear any HW errors 
 Check if any memory request timed out on L2 cache 
 Check CPU L1 error 
 Check CPU L2 error 
	
	  Enable CPU memory error:
	   MEMERR_CPU_ICFESRA, MEMERR_CPU_LSUESRA, and MEMERR_CPU_MMUESRA
 Enable PMD memory error - MEMERR_L2C_L2ECR and L2C_L2RTOCR 
 Configure L2C HW request time out feature if supported 
 Enable PMD error interrupt 
 Two CPUs per a PMD 
 Determine if this PMD is disabled 
 L3 Error device 
  Version 1 of the L3 controller has broken single bit correctable logic for
  certain error syndromes. Log them as uncorrectable in that case.
	
	  NOTE: Address [41:38] in L3C_ELR_PADDRHIGH(l3celr).
	        Address [37:6] in l3caelr. Lower 6 bits are zero.
 Clear L3C error interrupt 
 On disable, we just disable interrupt but keep error enabled 
 Enabledisable L3 error top level interrupt 
 Generate all errors 
 SoC error device 
 IO Bus Registers 
 GIC transaction error interrupt 
 IOB memory error 
 If the register bus resource isn't available, just skip it 
	
	  Check RB access errors
	  1. Out of range
	  2. Un-implemented page
	  3. Un-aligned access
	  4. Offline slave IP
 IOB Bridge agent transaction error interrupt 
 IOB Processing agent transaction error interrupt 
 IOB AXI0 Error 
 IOB AXI1 Error 
 Enable SoC IP error interrupt 
	
	  NOTE: The register bus resource is optional for compatibility
	  reason.
 Make sure error reporting method is sane 
  (C) 2005, 2006 Linux Networx (http:lnxi.com)
  This file may be distributed under the terms of the
  GNU General Public License.
  Written Doug Thompson <norsk5@xmission.com>
 data variables exported via sysfs 
 default NO check PCI parity 
 default NO panic on PCI Parity 
 log PCI parity errors 
 log PCI non-parity error errors 
 one second workq period 
 getter functions for the data variables 
 EDAC PCI sysfs instance 
 DEVICE instance kobject release() function 
 Form pointer to containing struct, the pci control struct 
 decrement reference count on top main kobj 
 Free the control struct 
 instance specific attribute structure 
 Function to 'show' fields from the edac_pci 'instance' structure 
 Function to 'store' fields into the edac_pci 'instance' structure 
 fs_ops table 
 pci instance attributes 
 the ktype for a pci instance 
  edac_pci_create_instance_kobj
 	construct one EDAC PCI instance's kobject for use
	 First bump the ref count on the top main kobj, which will
	  track the number of PCI instances we have, and thus nest
	  properly on keeping the module loaded
 And now register this new kobject under the main kobj 
 Error unwind statck 
  edac_pci_unregister_sysfs_instance_kobj
 	unregister the kobj for the EDAC PCI instance
	 Unregister the instance kobject and allow its release
	  function release the main reference count and then
	  kfree the memory
 EDAC PCI sysfs root 
 simple showstore functions for attributes 
 Set of showstore abstract level functions for PCI Parity object 
 PCI Parity control files 
 Base Attributes of the memory ECC object 
  edac_pci_release_main_kobj
 	This release function is called when the reference count to the
 	passed kobj goes to zero.
 	This kobj is the 'main' kobject that EDAC PCI instances
 	link to, and thus provide for proper nesting counts
	 last reference to top EDAC PCI kobject has been removed,
	  NOW release our ref count on the core module
 ktype struct for the EDAC PCI main kobj 
  edac_pci_main_kobj_setup: Setup the sysfs for EDAC PCI attributes.
 check and count if we have already created the main kobject 
	 First time, so create the main kobject and its
	  controls and attributes
	 Bump the reference count on this module to ensure the
	  modules isn't unloaded until we deconstruct the top
	  level main kobj for EDAC PCI
 Instanstiate the pci object 
	 At this point, to 'release' the top level kobject
	  for EDAC PCI, then edac_pci_main_kobj_teardown()
	  must be used, for resources to be cleaned up properly
 Error unwind statck 
 if are on this error exit, nothing to tear down 
  edac_pci_main_kobj_teardown()
 	if no longer linked (needed) remove the top level EDAC PCI
 	kobject with its controls and attributes
	 Decrement the count and only if no more controller instances
	  are connected perform the unregisteration of the top level
	  main kobj
 create the top main EDAC PCI kobject, IF needed 
 Create this instance's kobject under the MAIN kobject 
 Error unwind stack 
 Remove the symlink 
 remove this PCI instance's sysfs entries 
	 Call the main unregister function, which will determine
	  if this 'pci' is the last instance.
	  If it is, the main kobject will be unregistered as a result
 PCI error handling 
	 If we get back 0xFFFF then we must suspect that the card has been
	  pulled but the Linux PCI layer has not yet finished cleaning up.
	  We don't want to report on such devices
 reset only the bits we are interested in 
 Clear any PCI parity errors logged by this device. 
 read the device TYPE, looking for bridges 
   PCI Parity polling
 	Function to retrieve the current parity status
 	and decode it
 stop any interrupts until we can acquire the status 
 read the STATUS register on this device 
 read the device TYPE, looking for bridges 
	 check the status reg for errors on boards NOT marked as broken
	  if broken, we cannot trust any of the status bits
 On bridges, need to examine secondary status register  
		 check the secondary status reg for errors,
		  on NOT broken boards
 reduce some complexity in definition of the iterator 
  pci_dev parity list iterator
 	Scan the PCI device list looking for SERRORs, Master Parity ERRORS or
 	Parity ERRORs on primary or secondary devices.
  edac_pci_do_parity_check
 	performs the actual PCI parity check operation
 if policy has PCI check off, leave now 
	 scan all PCI devices looking for a Parity Error on devices and
	  bridges.
	  The iterator calls pci_get_device() which might sleep, thus
	  we cannot disable interrupts in this scan.
 Only if operator has selected panic on PCI Error 
 If the count is different 'after' from 'before' 
  edac_pci_clear_parity_errors
 	function to perform an iteration over the PCI devices
 	and clearn their current status
	 Clear any PCI bus parity errors that devices initially have logged
	  in their registers.
  edac_pci_handle_pe
 	Called to handle a PARITY ERROR event
 global PE counter incremented by edac_pci_do_parity_check() 
	
	  poke all PCI devices and see which one is the troublemaker
	  panic() is called if set
  edac_pci_handle_npe
 	Called to handle a NON-PARITY ERROR event
 global NPE counter incremented by edac_pci_do_parity_check() 
	
	  poke all PCI devices and see which one is the troublemaker
	  panic() is called if set
  Define the PCI parameter to the module
  Intel 82443BXGX (440BXGX chipset) Memory Controller EDAC kernel
  module (C) 2006 Tim Small
  This file may be distributed under the terms of the GNU General
  Public License.
  Written by Tim Small <tim@buttersideup.com>, based on work by Linux
  Networx, Thayne Harbaugh, Dan Hollis <goemon at anime dot net> and
  others.
  440GX fix by Jason Uhlenkott <juhlenko@akamai.com>.
  Written with reference to 82443BX Host Bridge Datasheet:
  http:download.intel.comdesignchipsetsdatashts29063301.pdf
  references to this document given in [].
  This module doesn't support the 440LX, but it may be possible to
  make it do so (the 440LX's register definitions are different, but
  not completely so - I haven't studied them in enough detail to know
  how easy this would be).
 The 82443BX supports SDRAM, or EDO (EDO for mobile only), "Memory
  Size: 8 MB to 512 MB (1GB with Registered DIMMs) with eight memory
  rows" "The 82443BX supports multiple-bit error detection and
  single-bit error correction when ECC mode is enabled and
  singlemulti-bit error detection when correction is disabled.
  During writes to the DRAM, the 82443BX generates ECC for the data
  on a QWord basis. Partial QWord writes require a read-modify-write
  cycle when ECC is enabled."
 "Additionally, the 82443BX ensures that the data is corrected in
  main memory so that accumulation of errors is prevented. Another
  error within the same QWord would result in a double-bit error
  which is unrecoverable. This is known as hardware scrubbing since
  it requires no software intervention to correct the data in memory."
 [Also see page 100 (section 4.3), "DRAM Interface"]
  [Also see page 112 (section 4.6.1.4), ECC]
 82443 PCI Device 0 
#define I82443BXGX_NBXCFG 0x50	 32bit register starting at this PCI
#define I82443BXGX_NBXCFG_OFFSET_NON_ECCROW 24	 Array of bits, zero if
 2 bits,00=100MHz,10=66 MHz 
 2 bits:       
 00 = Non-ECC 
 01 = EC (only) 
 10 = ECC 
 11 = ECC + HW Scrub 
 82443 PCI Device 0 
#define I82443BXGX_EAP   0x80	 32bit register starting at this PCI
				  config space offset, Error Address
 High 20 bits of error address 
 Err at EAP was multi-bit (W1TC) 
 Err at EAP was single-bit (W1TC) 
#define I82443BXGX_ERRCMD  0x90	 8bit register starting at this PCI
 1 = enable 
 1 = enable 
#define I82443BXGX_ERRSTS  0x91	 16bit register starting at this PCI
 3 bits - first err row multibit 
 1 = MBE occurred 
 3 bits - first err row singlebit 
 1 = SBE occurred 
#define I82443BXGX_DRAMC 0x57	 8bit register starting at this PCI
 2 bits, DRAM Type 
 00 = EDO 
 01 = SDRAM 
 10 = Registered SDRAM 
#define I82443BXGX_DRB 0x60	 8x 8bit registers starting at this PCI
 FIXME - don't poll when ECC disabled? 
static struct pci_dev mci_pdev;	 init dev: in case that AGP code has
					  already registered driver
 Clear error to allow next error to be reported [p.61] 
 Clear error to allow next error to be reported [p.61] 
	 bits 30:12 hold the 4kb block in which the error occurred
 find the DRAM Chip Select Base address and mask 
 440GX goes to 2GB, represented with a DRB of 0. 
 This row is empty [p.49] 
 EAP reports in 4kilobyte granularity [61] 
 I don't think 440BX can tell you device type? FIXME? 
 Mode is global to all rows on 440BX 
	 Something is really hosed if PCI config space reads from
	  the MC aren't working.
	 Many BIOSes don't clear error flags on boot, so do this
	  here, or we get "phantom" errors occurring at module-load
 allocating generic PCI control info 
 returns count (>= 0), or negative on error 
 don't need to call pci_enable_device() 
 0 terminated list. 
 Ensure that the OPSTATE is set correctly for POLL or NMI 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2006-2007 PA Semi, Inc
  Author: Egor Martovetsky <egor@pasemi.com>
  Maintained by: Olof Johansson <olof@lixom.net>
  Driver for the PWRficient onchip memory controllers
 uncorrectablemulti-bit errors 
 correctablesingle-bit errors 
	
	  We should think about enabling other error detection later on
	
	  Clear status
 get this far and it's successful 
 Ensure that the OPSTATE is set correctly for POLL or NMI 
 SPDX-License-Identifier: GPL-2.0-only
  amd8131_edac.c, AMD8131 hypertransport chip EDAC kernel module
  Copyright (c) 2008 Wind River Systems, Inc.
  Authors:	Cao Qingtao <qingtao.cao@windriver.com>
  		Benjamin Walsh <benjamin.walsh@windriver.com>
  		Hu Yongqi <yongqi.hu@windriver.com>
 Wrapper functions for accessing PCI configuration space 
 Support up to two AMD8131 chipsets on a platform 
 First clear error detection flags 
 Clear Discard Timer Timedout flag 
 Clear CRC Error flag on link side A 
 Clear CRC Error flag on link side B 
	
	  Then enable all error detections.
	 
	  Setup Discard Timer Sync Flood Enable,
	  System Error Enable and Parity Error Enable.
 Enable overall SERR Error detection 
 Setup CRC Flood Enable for link side A 
 Setup CRC Flood Enable for link side B 
 Disable SERR, PERR and DTSE Error detection 
 Disable overall System Error detection 
 Disable CRC Sync Flood on link side A 
 Disable CRC Sync Flood on link side B 
 Check PCI-X Bridge Memory Base-Limit Register for errors 
 Check if Discard Timer timed out 
 Check if CRC error happens on link side A 
 Check if CRC error happens on link side B 
  There are 4 PCIX Bridges on ATCA-6101 that share the same PCI Device ID,
  so amd8131_probe() would be called by kernel 4 times, with different
  address of pci_dev for each of them each time.
 should never happen 
	
	  We can't call pci_get_device() as we are used to do because
	  there are 4 of them but pci_dev_get() instead.
	
	  we do not allocate extra private structure for
	  edac_pci_ctl_info, but make use of existing
	  one instead.
 should never happen 
 table is NULL-terminated 
 Only POLL mode supported so far 
 SPDX-License-Identifier: GPL-2.0
  SiFive Platform EDAC Driver
  Copyright (C) 2018-2019 SiFive, Inc.
  This driver is partially based on octeon_edac-pc.c
  EDAC error callback
  @event: non-zero if unrecoverable.
  Intel 5400 class Memory Controllers kernel module (Seaburg)
  This file may be distributed under the terms of the
  GNU General Public License.
  Copyright (c) 2008 by:
 	 Ben Woodard <woodard@redhat.com>
 	 Mauro Carvalho Chehab
  Red Hat Inc. https:www.redhat.com
  Forked and adapted from the i5000_edac driver which was
  written by Douglas Thompson Linux Networx <norsk5@xmission.com>
  This module is based on the following document:
  Intel 5400 Chipset Memory Controller Hub (MCH) - Datasheet
  	http:developer.intel.comdesignchipsetsdatashts313070.htm
  This Memory Controller manages DDR2 FB-DIMMs. It has 2 branches, each with
  2 channels operating in lockstep no-mirror mode. Each channel can have up to
  4 dimm's, each with up to 8GB.
  Alter this version for the I5400 module when modifications are made
 Limits for i5400 
 Device 16,
  Function 0: System Address
  Function 1: Memory Branch Map, Control, Errors Register
  Function 2: FSB Error Registers
  All 3 functions of Device 16 (0,1,2) share the SAME DID and
  uses PCI_DEVICE_ID_INTEL_5400_ERR for device 16 (0,1,2),
  PCI_DEVICE_ID_INTEL_5400_FBD0 and PCI_DEVICE_ID_INTEL_5400_FBD1
  for device 21 (0,1).
 OFFSETS for Function 0 
 AMB Mem Mapped Reg Region Base 
 Max Channel Number 
 Max DIMM PER Channel Number 
 OFFSETS for Function 1 
 bits [17:9] indicate ODD, [8:0]  indicate EVEN 
 Fatal error registers 
 also called as FERR_FAT_FB_DIMM at datasheet 
 channel index where the highest-order error occurred 
 also called as FERR_NFAT_FB_DIMM at datasheet 
 Non-fatal error register 
 Enable error mask 
 No OFFSETS for Device 16 Function 2 
  Device 21,
  Function 0: Memory Map Branch 0
  Device 22,
  Function 0: Memory Map Branch 1
 OFFSETS for Function 0 
 OFFSETS for Function 1 
  Error indicator bits and masks
  Error masks are according with Table 5-17 of i5400 datasheet
 Memory Write error on non-redundant retry 
 Memory or FB-DIMM configuration CRC read error 
 Reserved 
 Uncorrectable Data ECC on Replay 
 Aliased Uncorrectable Non-Mirrored Demand Data ECC 
 Unsupported on i5400 
 Aliased Uncorrectable Resilver- or Spare-Copy Data ECC 
 Aliased Uncorrectable Patrol Data ECC 
 Non-Aliased Uncorrectable Non-Mirrored Demand Data ECC 
 Unsupported on i5400 
 Non-Aliased Uncorrectable Resilver- or Spare-Copy Data ECC  
 Non-Aliased Uncorrectable Patrol Data ECC 
 Memory Write error on first attempt 
 FB-DIMM Configuration Write error on first attempt 
 Memory or FB-DIMM configuration CRC read error 
 Channel Failed-Over Occurred 
 Correctable Non-Mirrored Demand Data ECC 
 Unsupported on i5400 
 Correctable Resilver- or Spare-Copy Data ECC 
 Correctable Patrol Data ECC 
 FB-DIMM Northbound parity error on FB-DIMM Sync Status 
 SPD protocol Error 
 Non-Redundant Fast Reset Timeout 
 Refresh error 
 Memory Write error on redundant retry 
 Redundant Fast Reset Timeout 
 Correctable Counter Threshold Exceeded 
 DIMM-Spare Copy Completed 
 DIMM-Isolation Completed 
  Names to translate bit error into something useful
 Reserved 
 M6 Unsupported on i5400 
 M10 Unsupported on i5400 
 M18 Unsupported on i5400 
 Fatal errors 
 Correctable errors 
 Recoverable errors 
 uncorrectable errors 
 mask to all non-fatal errors 
  Define error masks for the several registers
 Enable all fatal and non fatal errors 
 mask for fatal error registers 
 masks for non-fatal error register 
 Bit 28 
 Bits 0 to 27 
 Defines to extract the vaious fields from the
 	MTRx - Memory Technology Registers
 This applies to FERR_NF_FB-DIMM as well as FERR_FAT_FB-DIMM 
 Device name and register DID (Device ID) 
 name for this device 
 DID for the branchmap,control 
 Table of devices attributes supported by this driver 
 size, 0 means not present  
 driver private data structure 
 16.0 
 16.1 
 16.2 
 21.0 
 22.0 
 top of low memory 
 AMB BAR 
 Memory Technlogy Reg 
 Branch 0, Channel 0 
 Brnach 0, Channel 1 
 Memory Technlogy Reg 
 Branch 1, Channel 8 
 Branch 1, Channel 1 
 DIMM information matrix, allocating architecture maximums 
 Actual values for this controller 
 Max channels 
 Max DIMMs per channel 
 I5400 MCH error information retrieved from Hardware 
 These registers are always read from the MC 
 First Errors Fatal 
 Next Errors Fatal 
 First Errors Non-Fatal 
 Next Errors Non-Fatal 
 These registers are input ONLY if there was a Recoverable Error 
 Recoverable Mem Data Error log B 
 Recoverable Mem Error log A 
 Recoverable Mem Error log B 
 These registers are input ONLY if there was a Non-Rec Error 
 Non-Recoverable Mem log A 
 Non-Recoverable Mem log B 
 note that nrec_rdwr changed from NRECMEMA to NRECMEMB between the 5000 and
 This applies to both NREC and REC string so it can be used with nrec_rdwr
 	i5400_get_error_info	Retrieve the hardware error information from
 				the hardware and cache it in the 'info'
 				structure
 read in the 1st FATAL error register 
	 Mask only the bits that the doc says are valid
	 If there is an error, then read in the
	   NEXT FATAL error register and the Memory Error Log Register A
 harvest the various error data we need 
 Clear the error bits, by writing them back 
 read in the 1st NON-FATAL error register 
	 If there is an error, then read in the 1st NON-FATAL error
 harvest the various error data we need 
 Clear the error bits, by writing them back 
  i5400_proccess_non_recoverable_info(struct mem_ctl_info mci,
  					struct i5400_error_info info,
  					int handle_errors);
 	handle the Intel FATAL and unrecoverable errors, if any
 if no error, return now 
 ONLY ONE of the possible error bits will be set, as per the docs 
 Use the NON-Recoverable macros to extract data 
 Only 1 bit will be on 
 Form out message 
  i5400_process_fatal_error_info(struct mem_ctl_info mci,
  				struct i5400_error_info info,
  				int handle_errors);
 	handle the Intel NON-FATAL errors, if any
 mask off the Error bits that are possible 
 if no error, return now 
 ONLY ONE of the possible error bits will be set, as per the docs 
 Correctable errors 
		 Convert channel to be based from zero, instead of
 Only 1 bit will be on 
 Form out message 
 Miscellaneous errors 
 	i5400_process_error_info	Process the error info that is
 	in the 'info' structure, previously retrieved from hardware
 First handle any fatal errors that occurred 
 now handle any non-fatal errors that occurred 
 	i5400_clear_error	Retrieve any error from the hardware
 				but do NOT process that error.
 				Used for 'clearing' out of previous errors
 				Called by the Core module.
 	i5400_check_error	Retrieve and process errors reported by the
 				hardware. Called by the Core module.
 	i5400_put_devices	'put' all the devices that we have
 				reserved via 'get'
 Decrement usage count for devices 
 	i5400_get_devices	Find and perform 'get' operation on the MCH's
 			devicefunctions we want to reference for this driver
 			Need to 'get' device 16 func 1 and func 2
 Attempt to 'get' the MCH register we want 
 End of list, leave 
 Store device 16 func 1 
 End of list, leave 
 Store device 16 func 2 
	 If this device claims to have more than 2 channels then
	  fetch Branch 1's information
 	determine_amb_present
 		the information is contained in DIMMS_PER_CHANNEL different
 		registers determining which of the DIMMS_PER_CHANNEL requires
               knowing which channel is in question
 	2 branches, each with 2 channels
 		b0_ambpresent0 for channel '0'
 		b0_ambpresent1 for channel '1'
 		b1_ambpresent0 for channel '2'
 		b1_ambpresent1 for channel '3'
  determine_mtr(pvt, dimm, channel)
  return the proper MTR register as determine by the dimm and desired channel
	 There is one MTR for each slot pair of FB-DIMMs,
	   Each slot pair may be at branch 0 or branch 1.
 Determine if there is a DIMM present in this DIMM slot 
			 Start with the number of bits for a Bank
 Add thenumber of ROW bits 
 add the number of COLUMN bits 
 add the number of RANK bits 
 add 64 bits per DIMM 
 divide by 2^^20 
 8 bits per bytes 
 	calculate_dimm_size
 	also will output a DIMM matrix map, if debug is enabled, for viewing
 	how the DIMMs are populated
 ================= Generate some debug output ================= 
	 Scan all the actual DIMMS
	  and calculate the information for each DIMM
	  Start with the highest dimm first, to display it first
	  and work toward the 0th dimm
		 on an odd dimm, first output a 'boundary' marker,
 Output the last bottom 'boundary' marker 
 now output the 'channel' labels 
 output the last message and free buffer 
 	i5400_get_mc_regs	read in the necessary registers and
 				cache locally
 			Fills in the private data members
 Get the Branch Map regs 
 Get the MIR[0-1] regs 
 Get the set of MTR[0-3] regs by each branch 
 Branch 0 set of MTR registers 
 Branch 1 set of MTR registers 
 Read and dump branch 0's MTRs 
 Only if we have 2 branchs (4 channels) 
 Read and dump  branch 1's MTRs 
	 Go and determine the size of each DIMM and place in an
 	i5400_init_dimms	Initialize the 'dimms' table within
 				the mci control	structure with the
 				addressing of memory.
 	return:
 		0	success
 		1	no actual memory found on this MC
	
	  FIXME: remove  pvt->dimm_info[slot][channel] and use the 3
	  layers here.
 if no DIMMS on this slot, continue 
			
			  The eccc mechanism is SDDC (aka SECC), with
			  is similar to Chipkill.
	
	  When just one memory is provided, it should be at location (0,0,0).
	  With such single-DIMM mode, the SDCC algorithm degrades to SECDEC+.
 	i5400_enable_error_reporting
 			Turn on the memory reporting features of the hardware
 Read the FBD Error Mask Register 
 Enable with a '0' 
 	i5400_probe1	Probe for ONE instance of device to see if it is
 			present.
 	return:
 		0 for FOUND a device
 		< 0 for error code
 We only are looking for func 0 of the set 
	
	  allocate a new MC control structure
	 
	  This drivers uses the DIMM slot as "csrow" and the rest as "channel".
 record ptr  to the generic device 
 Record this device in our private 
 'get' the pci devices we want to reserve for our use 
 Time to get serious 
 retrieve the hardware registers 
 Set the function pointer to an actual operation function 
	 initialize the MC control structure 'dimms' table
 no dimms found 
 add this new MC control structure to EDAC's list of MCs 
		 FIXME: perhaps some code should go here that disables error
		  reporting if we just enabled it
 allocating generic PCI control info 
 Error exit unwinding stack 
 	i5400_init_one	constructor for one instance of device
  	returns:
 		negative on error
 		count (>= 0)
 wake up device 
 now probe and enable the device 
 	i5400_remove_one	destructor for one instance of device
 retrieve references to resources, and free those resources 
 	pci_device_id	table for which devices we are looking for
 	The "E500P" device is the first device supported.
 0 terminated list. 
 	i5400_driver	pci_driver structure for this module
 	i5400_init		Module entry function
 			Try to initialize this module for its devices
 Ensure that the OPSTATE is set correctly for POLL or NMI 
 	i5400_exit()	Module exit function
 			Unregister the driver
www.redhat.com)");
 SPDX-License-Identifier: GPL-2.0
  Bluefield-specific EDAC driver.
  Copyright (c) 2019 Mellanox Technologies.
  Mellanox BlueField EMI (External Memory Interface) register definitions.
  Request MLNX_SIP_GET_DIMM_INFO
  Retrieve information about DIMM on a certain slot.
  Call register usage:
  a0: MLNX_SIP_GET_DIMM_INFO
  a1: (Memory controller index) << 16 | (Dimm index in memory controller)
  a2-7: not used.
  Return status:
  a0: MLXBF_DIMM_INFO defined below describing the DIMM.
  a1-3: not used.
 Format for the SMC response about the memory information 
  Gather the ECC information from the External Memory Interface registers
  and report it to the edac handler.
	
	  Tell the External Memory Interface to populate the relevant
	  registers with information about the last ECC error occurrence.
	
	  Verify that the ECC reported info in the registers is of the
	  same type as the one asked to report. If not, just report the
	  error without the detailed information.
	
	  The memory controller might not be initialized by the firmware
	  when there isn't memory, which may lead to bad register readings.
 Write to clear reported errors. 
 Initialize the DIMMs information for the given memory controller. 
 Mem controller for BlueField only supports x4, x8 and x16 
 Read the MSS (Memory SubSystem) index from ACPI table. 
 Read the DIMMs per MC from ACPI table. 
 Initialize mci with the actual populated DIMM information. 
 Register with EDAC core 
 Only POLL mode supported so far. 
 SPDX-License-Identifier: GPL-2.0-only
  amd8111_edac.c, AMD8111 Hyper Transport chip EDAC kernel module
  Copyright (c) 2008 Wind River Systems, Inc.
  Authors:	Cao Qingtao <qingtao.cao@windriver.com>
  		Benjamin Walsh <benjamin.walsh@windriver.com>
  		Hu Yongqi <yongqi.hu@windriver.com>
 Wrapper functions for accessing PCI configuration space 
  device-specific methods for amd8111 PCI Bridge Controller
  Error Reporting and Handling for amd8111 chipset could be found
  in its datasheet 3.1.2 section, P37
 First clear error detection flags on the host interface 
 Clear SSESMASTA flags in the global status register
 Clear CRC and Link Fail flags in HT Link Control reg 
 Second clear all fault on the secondary interface 
 Clear error flags in the memory-base limit reg. 
 Clear Discard Timer Expired flag in InterruptBridge Control reg 
 Last enable error detections 
 Enable System Error reporting in global status register 
 Enable CRC Sync flood packets to HyperTransport Link 
 Enable SSE reporting etc in Interrupt control reg 
 Disable System Error reporting 
 Disable CRC flood packets 
 Disable DTSERRENMARSPSERREN in Interrupt Control reg 
 Check out PCI Bridge Status and Command Register 
 Check out HyperTransport Link Control Register 
 Check out PCI Interrupt and Bridge Control Register 
 Check out PCI Bridge Memory Base-Limit Register 
 device-specific methods for amd8111 LPC Bridge device 
 First clear REG_AT_COMPAT[SERR, IOCHK] if necessary 
 buggy port 
 Second clear error flags on LPC bridge 
 General devices represented by edac_device_ctl_info 
 PCI controllers represented by edac_pci_ctl_info 
	
	  we do not allocate extra private structure for
	  edac_device_ctl_info, but make use of existing
	  one instead.
 should never happen 
	
	  we do not allocate extra private structure for
	  edac_pci_ctl_info, but make use of existing
	  one instead.
 should never happen 
 PCI Device ID talbe for general EDAC device 
 table is NULL-terminated 
 PCI Device ID table for EDAC PCI controller 
 table is NULL-terminated 
 Only POLL mode supported so far 
 SPDX-License-Identifier: GPL-2.0
  EDAC driver for DMC-520 memory controller.
  The driver supports 10 interrupt lines,
  though only dram_ecc_errc and dram_ecc_errd are currently handled.
  Authors:	Rui Zhao <ruizhao@microsoft.com>
 		Lei Wang <lewan@microsoft.com>
 		Shiping Ji <shji@microsoft.com>
 DMC-520 registers 
 DMC-520 types, masks and bitfields 
 Driver settings 
  The max-length message would be: "rank:7 bank:15 row:262143 col:1023".
  Max length is 34. Using a 40-size buffer is enough.
 the data bus width for the attached memory chips. 
 memory type 
 memory device width 
 The interrupt config 
 The interrupt mappings 
  The EDAC driver private data.
  error_lock is to protect concurrent writes to the mci->error_desc through
  edac_mc_handle_error().
 Each rank's error counter takes one byte. 
 Reset error counters 
 Get the memory data bus width, in number of bytes. 
 Parse the device node 
 Initialize dmc520 edac 
 Clear interrupts, not affecting other unrelated interrupts 
 Reset DRAM CEUE counters 
 Enable interrupts, not affecting other unrelated interrupts 
 Disable interrupts 
 free irq's 
 end of table  }
  file for managing the edac_device subsystem of devices for EDAC
  (C) 2007 SoftwareBitMaker
  This file may be distributed under the terms of the
  GNU General Public License.
  Written Doug Thompson <norsk5@xmission.com>
  Set of edac_device_ctl_info attribute storeshow functions
 'log_ue' 
 if parameter is zero, turn off flag, if non-zero turn on flag 
 'log_ce' 
 if parameter is zero, turn off flag, if non-zero turn on flag 
 'panic_on_ue' 
 if parameter is zero, turn off flag, if non-zero turn on flag 
 'poll_msec' show and store functions
	 get the value and enforce that it is non-zero, must be at least
	  one millisecond for the delay period, between scans
	  Then cancel last outstanding delay for the work request
	  and set a new one.
 edac_device_ctl_info specific attribute structure 
 Function to 'show' fields from the edac_dev 'ctl_info' structure 
 Function to 'store' fields into the edac_dev 'ctl_info' structure 
 edac_dev file operations for an 'ctl_info' 
 Declare the various ctl_info attributes here and their respective ops 
 Base Attributes of the EDAC_DEVICE ECC object 
  edac_device_ctrl_master_release
 	called when the reference count for the 'main' kobj
 	for a edac_device control struct reaches zero
 	Reference count model:
 		One 'main' kobject for each control structure allocated.
 		That main kobj is initially set to one AND
 		the reference count for the EDAC 'core' module is
 		bumped by one, thus added 'keep in memory' dependency.
 		Each new internal kobj (in instances and blocks) then
 		bumps the 'main' kobject.
 		When they are released their release functions decrement
 		the 'main' kobj.
 		When the main kobj reaches zero (0) then THIS function
 		is called which then decrements the EDAC 'core' module.
 		When the module reference count reaches zero then the
 		module no longer has dependency on keeping the release
 		function code in memory and module can be unloaded.
 		This will support several control objects as well, each
 		with its own 'main' kobj.
 decrement the EDAC CORE module ref count 
	 free the control struct containing the 'main' kobj
	  passed in to this routine
 ktype for the main (master) kobject 
  edac_device_register_sysfs_main_kobj
 	perform the high level setup for the new edac_device instance
  Return:  0 SUCCESS
          !0 FAILURE
 get the sysdevicessystemedac reference 
 Point to the 'edac_subsys' this instance 'reports' to 
 Init the devices's kobject 
	 Record which module 'owns' this control structure
	  and bump the ref count of the module
 register 
	 At this point, to 'free' the control struct,
	  edac_device_unregister_sysfs_main_kobj() must be used
 Error exit stack 
  edac_device_unregister_sysfs_main_kobj:
 	the '....edac<name>' kobject
	
	  Unregister the edac device's kobject and
	  allow for reference count to reach 0 at which point
	  the callback will be called to:
	    a) module_put() this module
	    b) 'kfree' the memory
 edac_dev -> instance information 
  Set of low-level instance attribute show functions
 DEVICE instance kobject release() function 
	 map from this kobj to the main control struct
	  and then dec the main kobj count
 instance specific attribute structure 
 Function to 'show' fields from the edac_dev 'instance' structure 
 Function to 'store' fields into the edac_dev 'instance' structure 
 edac_dev file operations for an 'instance' 
  Define attributes visible for the edac_device instance object
 	Each contains a pointer to a show and an optional set
 	function pointer that does the low level outputinput
 list of edac_dev 'instance' attributes 
 The 'ktype' for each edac_dev 'instance' 
 edac_dev -> instance -> block information 
  Set of low-level block attribute show functions
 DEVICE block kobject release() function 
 get the container of the kobj 
	 map from 'block kobj' to 'block->instance->controller->main_kobj'
	  now 'release' the block kobject
 Function to 'show' fields from the edac_dev 'block' structure 
 Function to 'store' fields into the edac_dev 'block' structure 
 edac_dev file operations for a 'block' 
 list of edac_dev 'block' attributes 
 The 'ktype' for each edac_dev 'block' 
 block ctordtor  code 
  edac_device_create_block
 init this block's kobject 
	 bump the main kobject's reference count for this controller
	  and this instance is dependent on the main
 Add this block's kobject 
	 If there are driver level block attributes, then added them
	  to the block kobject
 Create each block_attribute file 
 Error unwind stack 
  edac_device_delete_block(edac_dev,block);
	 if this block has 'attributes' then we need to iterate over the list
	  and 'remove' the attributes on this block
 remove each block_attrib file 
	 unregister this block's kobject, SEE:
	 	edac_device_ctrl_block_release() callback operation
 instance ctordtor code 
  edac_device_create_instance
 	create just one instance of an edac_device 'instance'
 Init the instance's kobject 
	 bump the main kobject's reference count for this controller
	  and this instance is dependent on the main
 Formally register this instance's kobject under the edac_device 
 register all blocks of this instance 
 If any fail, remove all previous ones 
 error unwind stack 
  edac_device_remove_instance
 	remove an edac_device instance
 unregister all blocks in this instance 
	 unregister this instance's kobject, SEE:
	 	edac_device_ctrl_instance_release() for callback operation
  edac_device_create_instances
 	create the first level of 'instances' for this device
 	(ie  'cache' might have 'cache0', 'cache1', 'cache2', etc
 iterate over creation of the instances 
 unwind previous instances on error 
  edac_device_delete_instances(edac_dev);
 	unregister all the kobjects of the instances
 iterate over creation of the instances 
 edac_dev sysfs ctordtor  code 
  edac_device_add_main_sysfs_attributes
 	add some attributes to this instance's main kobject
		 iterate over the array and create an attribute for each
		  entry in the list
  edac_device_remove_main_sysfs_attributes
 	remove any attributes to this instance's main kobject
	 if there are main attributes, defined, remove them. First,
	  point to the start of the array and iterate over it
	  removing each attribute listed from this device's instance's kobject
  edac_device_create_sysfs() Constructor
  accept a created edac_device control structure
  and 'export' it to sysfs. The 'main' kobj should already have been
  created. 'instance' and 'block' kobjects should be registered
  along with any 'block' attributes from the low driver. In addition,
  the main attributes (if any) are connected to the main kobject of
  the control structure.
  Return:
 	0	Success
 	!0	Failure
  go create any main attributes callers wants 
	 create a symlink from the edac device
	  to the platform 'device' being used for this
	 Create the first level instance directories
	  In turn, the nested blocks beneath the instances will
	  be registered as well
 Error unwind stack 
 remove the sym link 
  edac_device_remove_sysfs() destructor
  given an edac_device struct, tear down the kobject resources
 remove any main attributes for this device 
 remove the device sym link 
 walk the instanceblock kobject tree, deconstructing it 
  Cell MIC driver for ECC counting
  Copyright 2007 Benjamin Herrenschmidt, IBM Corp.
                 <benh@kernel.crashing.org>
  This file may be distributed under the terms of the
  GNU General Public License.
 Address decoding is likely a bit bogus, to dbl check 
 TODO: Decoding of the error address 
 Address decoding is likely a bit bogus, to dbl check 
 TODO: Decoding of the error address 
 The procedure for clearing FIR bits is a bit ... weird 
 sync up 
		 We "know" that the Cell firmware only creates one entry
		  in the "memory" nodes. If that changes, this code will
		  need to be adapted.
 Get channel population 
 Allocate & init EDAC MC data structure 
 Register with EDAC core 
 Sanity check registers data structure 
 SPDX-License-Identifier: GPL-2.0-only
 Create a toplevel dir under EDAC's debugfs hierarchy 
 Create a toplevel dir under EDAC's debugfs hierarchy with parent @parent 
  Create a file under EDAC's hierarchy or a sub-hierarchy:
  @name: file name
  @mode: file permissions
  @parent: parent dentry. If NULL, it becomes the toplevel EDAC dir
  @data: private data of caller
  @fops: file operations of this file
 Wrapper for debugfs_create_x8() 
 Wrapper for debugfs_create_x16() 
 Wrapper for debugfs_create_x32() 
 SPDX-License-Identifier: GPL-2.0
  Shared code by both skx_edac and i10nm_edac. Originally split out
  from the skx_edac driver.
  This file is linked into both skx_edac and i10nm_edac drivers. In
  order to avoid link errors, this file must be like a pure library
  without including symbols and defines which would otherwise conflict,
  when linked once into a module and into a built-in object, at the
  same time. For example, __this_module symbol references when that
  file is being linked into a built-in object.
  Copyright (c) 2018, Intel Corporation.
  We use the per-socket device @cfg->did to count how many sockets are present,
  and to detemine which PCI buses are associated with each socket. Allocate
  and build the full list of all the skx_dev structures that we need here.
	
	  Compute size in 8-byte (2^3) words, then shift to MiB (2^20)
 likely better than this 
 likely better than this 
 Allocate a new MC control structure 
 Associate skx_dev and mci for future usage 
 Record ptr to the generic device 
 Add this new MC control structure to EDAC's list of MCs 
 Remove MC sysfs nodes 
	
	  According to Intel Architecture spec vol 3B,
	  Table 15-10 "IA32_MCi_Status [15:0] Compound Error Code Encoding"
	  memory errors should fit one of these masks:
	 	000f 0000 1mmm cccc (binary)
	 	000f 0010 1mmm cccc (binary)	[RAM used as cache]
	  where:
	 	f = Correction Report Filtering Bit. If 1, subsequent errors
	 	    won't be shown
	 	mmm = error type
	 	cccc = channel
	  If the mask doesn't match, report an error to the parsing logic
 Call the helper to output message 
 ignore unless this is memory related with an address 
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  Copyright (C) 2012 Cavium, Inc.
  Copyright (C) 2009 Wind River Systems,
    written by Ralf Baechle <ralf@linux-mips.org>
 Detected parity error 
 Reset  
 Reset 
 Reset 
 Reset 
 Reset 
 Reset 
  Intel e752x Memory Controller kernel module
  (C) 2004 Linux Networx (http:lnxi.com)
  This file may be distributed under the terms of the
  GNU General Public License.
  Implement support for the e7520, E7525, e7320 and i3100 memory controllers.
  Datasheets:
 	https:www.intel.incontentwwwinenchipsetse7525-memory-controller-hub-datasheet.html
 	ftp:download.intel.comdesignintarchdatashts31345803.pdf
  Written by Tom Zimmerman
  Contributors:
  	Thayne Harbaugh at realmsys.com (?)
  	Wang Zhenyu at intel.com
  	Dave Jiang at mvista.com
 PCI_DEVICE_ID_INTEL_7520_0      
 PCI_DEVICE_ID_INTEL_7520_1_ERR  
 PCI_DEVICE_ID_INTEL_7525_0      
 PCI_DEVICE_ID_INTEL_7525_1_ERR  
 PCI_DEVICE_ID_INTEL_7320_0 
 PCI_DEVICE_ID_INTEL_7320_1_ERR 
 PCI_DEVICE_ID_INTEL_3100_0 
 PCI_DEVICE_ID_INTEL_3100_1_ERR 
 number of csrows 
 E752X register addresses - device 0 function 0 
 Memory Scrub register (16b) 
					
					  6:5     Scrub Completion Count
					  3:2     Scrub Rate (i3100 only)
					       01=fast 10=normal
					  1:0     Scrub Mode enable
					       00=off 10=on
 DRAM row boundary register (8b) 
 DRAM row attribute register (8b) 
					
					  31:30   Device width row 7
					       01=x8 10=x4 11=x8 DDR2
					  27:26   Device width row 6
					  23:22   Device width row 5
					  19:20   Device width row 4
					  15:14   Device width row 3
					  11:10   Device width row 2
					   7:6    Device width row 1
					   3:2    Device width row 0
 DRAM controller mode reg (32b) 
 FIXME:IS THIS RIGHT? 
					
					  22    Number channels 0=1,1=2
					  19:18 DRB Granularity 3264MB
 Dimm mapping register 
 DDR control and status reg (16b) 
					
					  14:12 1 single A, 2 single B, 3 dual
 DRAM top of low memory reg (16b) 
 DRAM remap base address reg (16b) 
 DRAM remap limit address reg (16b) 
 DRAM remap limit offset reg (16b) 
 E752X register addresses - device 0 function 1 
 Global first error register (32b) 
 Global next error register (32b) 
 Hub interface first error reg (8b) 
 Hub interface next error reg (8b) 
 Hub interface error mask reg (8b) 
 Hub interface SMI command reg (8b) 
 System buss first error reg (16b) 
 System buss next error reg (16b) 
 System buss error mask reg (16b) 
 System buss SMI command reg (16b) 
 Memory buffer first error reg (8b) 
 Memory buffer next error reg (8b) 
 Memory buffer error mask reg (8b) 
 Memory buffer SMI cmd reg (8b) 
 DRAM first error register (16b) 
 DRAM next error register (16b) 
 DRAM error mask register (8b) 
 DRAM SMI command register (8b) 
 DRAM Retry address register (32b) 
 DRAM first correctable memory 
     error address register (32b) 
					
					  31    Reserved
					  30:2  CE address (64 byte block 34:6
					  1     Reserved
					  0     HiLoCS
 DRAM first correctable memory 
     error address register (32b) 
					
					  31    Reserved
					  30:2  CE address (64 byte block 34:6)
					  1     Reserved
					  0     HiLoCS
 DRAM first uncorrectable memory 
     error address register (32b) 
					
					  31    Reserved
					  30:2  CE address (64 byte block 34:6)
					  1     Reserved
					  0     HiLoCS
 DRAM 1st uncorrectable scrub mem 
     error address register (32b) 
					
					  31    Reserved
					  30:2  CE address (64 byte block 34:6
					  1     Reserved
					  0     HiLoCS
 DRAM first correctable memory 
     error syndrome register (16b) 
 DRAM second correctable memory 
     error syndrome register (16b) 
 Device Present 1 register (8b) 
 3100 IMCH specific register addresses - device 0 function 1 
 NSI first error reg (32b) 
 NSI next error reg (32b) 
 NSI SMI command register (32b) 
 NSI error mask register (32b) 
 ICH5R register addresses - device 30 function 0 
 PCI status register (16b) 
 PCI status secondary reg (16b) 
 PCI bridge control register (16b) 
  Those chips Support single-rank and dual-rank memories only.
  On e752x chips, the odd rows are present only on dual-rank memories.
  Dividing the rank by two will provide the dimm#
  i3100 MC has a different mapping: it supports only 4 ranks.
  The mapping is (from 1 to n):
 	slot	   single-ranked	double-ranked
 	dimm #1 -> rank #4		NA
 	dimm #2 -> rank #3		NA
 	dimm #3 -> rank #2		Ranks 2 and 3
 	dimm #4 -> rank $1		Ranks 1 and 4
  FIXME: The current mapping for i3100 considers that it supports up to 8
 	  rankschanel, but datasheet says that the MC supports only 4 ranks.
 3100 only 
 3100 only 
 all but 3100 
 all but 3100 
 Valid scrub rates for the e752x3100 hardware memory scrubber. We
  map the scrubbing bandwidth to a hardware register value. The 'set'
  operation finds the 'matching or higher value'.  Note that scrubbing
  on the e752x can only be enableddisabled.  The 3100 supports
  a normal and fast mode.
 bandwidth consumed by scrubbing in bytessec 
 register value for scrub rate 
 Rate below assumes same performance as i3100 using PC3200 DDR2 in
  normal mode.  e752x bridges don't support choosing normal or fast mode,
  so the scrubbing bandwidth value isn't all that important - scrubbing is
  either on or off.
 Scrubbing Off 
 Scrubbing On 
 End of Table 
 Fast mode: 2 GByte PC3200 DDR2 scrubbed in 33s = 63161283 bytess
  Normal mode: 125 (32000  256) times slower than fast mode.
 Scrubbing Off 
 Normal mode - 32k clocks 
 Fast mode - 256 clocks 
 End of Table 
 convert the addr to 4k page 
 FIXME - check for -1 
 chip select are bits 14 & 13 
 test for channel remapping 
 0 = channel A, 1 = channel B 
 e752x mc reads 34:6 of the DRAM linear address 
 convert to 4k address 
 chip select are bits 14 & 13 
 e752x mc reads 34:6 of the DRAM linear address 
 convert to 4k address 
 chip select are bits 14 & 13 
 e752x mc reads 34:6 of the DRAM linear address 
 convert the addr to 4k page 
 chip select are bits 14 & 13 
 9th entry 
			 If the error is from DRAM Controller OR
			  we are to report ALL errors, then
			  report the error
 NSI_FERRNSI_NERR bit 0, fatal error 
 reserved 
 bit 2, non-fatal 
 reserved 
 reserved 
 bit 5, non-fatal 
 bit 6, non-fatal 
 bit 7, fatal 
 reserved 
 bit 9, non-fatal 
 reserved 
 bit 11, non-fatal 
 bit 12, non-fatal 
 bit 13, non-fatal 
 reserved 
 bit 15, non-fatal 
 reserved 
 reserved 
 reserved 
 bit 19, fatal 
 reserved 
 bit 21, non-fatal 
 reserved 
 bit 23, non-fatal 
 bit 24, non-fatal 
 bit 25, non-fatal 
 bit 26, fatal 
 bit 27, fatal 
 reserved 
 bit 29, non-fatal 
pci_read_config_byte(dev,E752X_HI_FERR,&stat8);
 Error, so process 
pci_read_config_byte(dev,E752X_HI_NERR,&stat8);
 Error, so process 
 Error, so process 
 check for fatal errors 
 check for non-fatal ones 
pci_read_config_dword(dev,E752X_SYSBUS_FERR,&stat32);
 no errors 
 Error, so process 
 Error, so process 
 decode and report errors 
 check first error correctable 
 check next error correctable 
 ignore the reserved bits just in case 
 Program bytesec bandwidth scrub rate to hardware 
	 Translate the desired scrub rate to a e752x3100 register value.
	  Search for the bandwidth that is equal or greater than the
	  desired rate and program the cooresponding register value.
 Convert current scrub rate value into bytesec bandwidth 
 Find the bandwidth matching the memory scrubber configuration 
 Return 1 if dual channel mode is active.  Else return 0. 
 Remap csrow index numbers if map_type is "reverse"
 DRB granularity 0=64mb, 1=128mb 
 DRAM Data Integrity Mode 0=none, 2=edac 
 128 in dual mode, 64 in single 
	 The dram row boundary (DRB) reg values are boundary address for
	  each DRAM row with a granularity of 64 or 128MB (singledual
	  channel operation).  DRB regs are cumulative; therefore DRB7 will
	  contain the total memory contained in all eight rows.
 mem_dev 0=x8, 1=x4 
 convert a 128 or 64 MiB DRB to a page size. 
 not populated 
		
		 if single channel or x8 devices then SECDED
		 if dual channel and x4 then S4ECD4ED
 4KiB - resolution of CELOG 
 only one type supported 
 test if there is a dimm in this slot 
 no dimm in the slot, so flag it as empty 
 there is a dimm in the slot 
			 test the next value to see if the dimm is double
			  sided
 the dimm is single sided, so flag as empty 
 this is a double sided dimm to save the next row #
 Return 0 on success or 1 on failure. 
 Setup system bus parity mask register.
  Sysbus parity supported on:
  e7320e7520e7525 + Xeon
 Allow module parameter override, else see if CPU supports parity 
 Turn off error disable & SMI in case the BIOS turned it on 
 Number of channels 0=1chan,1=2chan 
	 check to see if device 0 function 1 is enabled; if it isn't, we
	  assume the BIOS has reserved it for a reason and is expecting
	  exclusive access, we take care not to violate that assumption and
 FIXME: should check >>12 or 0xf, true for all? 
 Dual channel = 1, Single channel = 0 
 3100 IMCH supports SECDEC only 
 FIXME - what if different memory types are in different csrows? 
	 set the map type.  1 = normal, 0 = reversed
	  Must be set before e752x_init_csrows in case csrow mapping
	  is reversed.
 the only mode supported 
 load the top of low memory, remap base, and remap limit vars 
	 Here we assume that we will never see multiple instances of this
	  type of memory controller.  The ID is therefore hardcoded to 0.
 clear other MCH errors 
 allocating generic PCI control info 
 get this far and it's successful 
 returns count (>= 0), or negative on error 
 wake up and enable device 
 0 terminated list. 
 Ensure that the OPSTATE is set correctly for POLL or NMI 
lnxi.com) Tom Zimmerman\n");
  Freescale MPC85xx Memory Controller kernel module
  Parts Copyrighted (c) 2013 by Freescale Semiconductor, Inc.
  Author: Dave Jiang <djiang@mvista.com>
  2006-2007 (c) MontaVista Software, Inc. This file is licensed under
  the terms of the GNU General Public License version 2. This program
  is licensed "as is" without any warranty of any kind, whether express
  or implied.
  PCI Err defines
 PCI Err device 
 master aborts can happen during PCI config cycles 
 clear error bits 
 clear error bits 
 reset error capture 
 make sure error reporting method is sane 
 we only need the error registers 
 PCI master abort is expected during config cycles 
 disable master abort reporting 
 clear error bits 
 reset error capture 
		
		  Enable all PCIe error interrupt & error detect except invalid
		  PEX_CONFIG_ADDRPEX_CONFIG_DATA access interrupt generation
		  enable bit and invalid PEX_CONFIG_ADDRPEX_CONFIG_DATA access
		  detection enable bit. Because PCIe bus code to initialize and
		  configure these PCIe devices on booting will use some invalid
		  PEX_CONFIG_ADDRPEX_CONFIG_DATA, edac driver prints the much
		  notice information. So disable this detect to fix ugly print.
 CONFIG_PCI 
 L2 Err device 
 L2 SYSFS parts 
 End of list 
 L2 ops 
 clear error detect register 
 we only need the error registers 
 clear the err_dis 
 deprecate the fsl,85.. forms in the future, 2.6.30? 
 deprecate the fsl,85.. forms in the future, 2.6.30? 
 make sure error reporting method is sane 
 SPDX-License-Identifier: GPL-2.0-only
  Set by command line parameter. If BIOS has enabled the ECC, this override is
  cleared to prevent re-enabling the hardware by this driver.
 Per-node stuff 
 Device for the PCI component 
  Valid scrub rates for the K8 hardware memory scrubber. We map the scrubbing
  bandwidth to a valid bit pattern. The 'set' operation finds the 'matching-
  or higher value'.
 FIXME: Produce a better mappinglinearisation.
 bit pattern for scrub rate 
 bandwidth consumed (bytessec) 
 scrubbing off 
  Select DCT to which PCI cfg accesses are routed
  Depending on the family, F2 DCT reads need special handling:
  K8: has a single DCT only and no address offsets >= 0x100
  F10h: each DCT has its own set of regs
 	DCT0 -> F2x040..
 	DCT1 -> F2x140..
  F16h: has only 1 DCT
  F15h: we select which DCT we access using F1x10C[DctCfgSel]
			
			  Note: If ganging is enabled, barring the regs
			  F2x[1,0]98 and F2x[1,0]9C; reads reads to F2x1xx
			  return 0. (cf. Section 2.8.1 F10h BKDG)
		
		  F15h: F2x1xx addresses do not map explicitly to DCT1.
		  We should select which DCT we access using F1x10C[DctCfgSel]
  Memory scrubber control interface. For K8, memory scrubbing is handled by
  hardware and can involve L2 cache, dcache as well as the main memory. With
  F10, this is extended to L3 cache scrubbing on CPU models sporting that
  functionality.
  This causes the "units" for the scrubbing speed to vary from 64 byte blocks
  (dram) over to cache lines. This is nasty, so we will use bandwidth in
  bytessec for the setting.
  Currently, we only do dram scrubbing. If the scrubbing is done in software on
  other archs, we might not have access to the caches directly.
	
	  Fam17h supports scrub values between 0x5 and 0x14. Also, the values
	  are shifted down by 0x5, so scrubval 0x5 is written to the register
	  as 0x0, scrubval 0x6 as 0x1, etc.
  Scan the scrub rate mapping table for a close or matching bandwidth value to
  issue. If requested is too big, then use last maximum value found.
	
	  map the configured rate (new_bw) to a value specific to the AMD64
	  memory controller and apply to register. Search for the first
	  bandwidth entry that is greater or equal than the setting requested
	  and program that. If at last entry, turn off DRAM scrubbing.
	 
	  If no suitable bandwidth is found, turn off DRAM scrubbing entirely
	  by falling back to the last element in scrubrates[].
		
		  skip scrub rates which aren't recommended
		  (see F10 BKDG, F3x58)
 Erratum #505 
 Erratum #505 
  returns true if the SysAddr given by sys_addr matches the
  DRAM baselimit associated with node_id
	 The K8 treats this as a 40-bit value.  However, bits 63-40 will be
	  all ones if the most significant implemented address bit is 1.
	  Here we discard bits 63-40.  See section 3.4.2 of AMD publication
	  24592: AMD x86-64 Architecture Programmer's Manual Volume 1
	  Application Programming.
  Attempt to map a SysAddr to a node. On success, return a pointer to the
  mem_ctl_info structure for the node that the SysAddr maps to.
  On failure, return NULL.
	
	  Here we use the DRAM Base (section 3.4.4.1) and DRAM Limit (section
	  3.4.4.2) registers to map the SysAddr to a node ID.
	
	  The value of this field should be the same for all DRAM Base
	  registers.  Therefore we arbitrarily choose to read it from the
	  register for node 0.
 intlv_sel field matches 
 sanity test for sys_addr 
  compute the CS base address of the @csrow on the DRAM controller @dct.
  For details see F2x[5C:40] in the processor's BKDG
	
	  F16h and F15h, models 30h and later need two addr_shift values:
	  8 for high and 6 for low (cf. F16h BKDG).
 poke holes for the csmask 
 poke holes for the csmask 
 OR them in 
  @input_addr is an InputAddr associated with the node given by mci. Return the
  csrow that input_addr maps to, or -1 on failure (no csrow claims input_addr).
  Obtain info from the DRAM Hole Address Register (section 3.4.8, pub #26094)
  for the node represented by mci. Info is passed back in hole_base,
  hole_offset, and hole_size.  Function returns 0 if info is valid or 1 if
  info is invalid. Info may be invalid for either of the following reasons:
  - The revision of the node is not E or greater.  In this case, the DRAM Hole
    Address Register does not exist.
  - The DramHoleValid bit is cleared in the DRAM Hole Address Register,
    indicating that its contents are not valid.
  The values passed back in hole_base, hole_offset, and hole_size are
  complete 32-bit values despite the fact that the bitfields in the DHAR
  only represent bits 31-24 of the base and offset values.
 only revE and later have the DRAM Hole Address Register 
 valid for Fam10h and above 
 This node has Memory Hoisting 
	 +------------------+--------------------+--------------------+-----
	  | memory           | DRAM hole          | relocated          |
	  | [0, (x - 1)]     | [x, 0xffffffff]    | addresses from     |
	  |                  |                    | DRAM hole          |
	  |                  |                    | [0x100000000,      |
	  |                  |                    |  (0x100000000+     |
	  |                  |                    |   (0xffffffff-x))] |
	  +------------------+--------------------+--------------------+-----
	 
	  Above is a diagram of physical memory showing the DRAM hole and the
	  relocated addresses from the DRAM hole.  As shown, the DRAM hole
	  starts at address x (the base address) and extends through address
	  0xffffffff.  The DRAM Hole Address Register (DHAR) relocates the
	  addresses in the hole so that they start at 0x100000000.
  update NUM_DBG_ATTRS in case you add new members
  store error injection section value which refers to one of 4 16-byte sections
  within a 64-byte cacheline
  range: 0..3
  store error injection word value which refers to one of 9 16-bit word of the
  16-byte (128-bit + ECC bits) section
  range: 0..8
  store 16 bit error injection vector which enables injecting errors to the
  corresponding bit within the error injection word above. When used during a
  DRAM ECC read, it holds the contents of the of the DRAM ECC bits.
  Do a DRAM ECC read. Assemble staged values in the pvt area, format into
  fields needed by the injection registers and read the NB Array Data Port.
 Form value to choose 16-byte section of cacheline 
 Issue 'word' and 'bit' along with the READ request 
  Do a DRAM ECC write. Assemble staged values in the pvt area and format into
  fields needed by the injection registers.
 Form value to choose 16-byte section of cacheline 
 Issue 'word' and 'bit' along with the READ request 
 wait until injection happens 
  update NUM_INJ_ATTRS in case you add new members
 Families which have that injection hw 
 CONFIG_EDAC_DEBUG 
  Return the DramAddr that the SysAddr given by @sys_addr maps to.  It is
  assumed that sys_addr maps to the node given by mci.
  The first part of section 3.4.4 (p. 70) shows how the DRAM Base (section
  3.4.4.1) and DRAM Limit (section 3.4.4.2) registers are used to translate a
  SysAddr to a DramAddr. If the DRAM Hole Address Register (DHAR) is enabled,
  then it is also involved in translating a SysAddr to a DramAddr. Sections
  3.4.8 and 3.5.8.2 describe the DHAR and how it is used for memory hoisting.
  These parts of the documentation are unclear. I interpret them as follows:
  When node n receives a SysAddr, it processes the SysAddr as follows:
  1. It extracts the DRAMBase and DRAMLimit values from the DRAM Base and DRAM
     Limit registers for node n. If the SysAddr is not within the range
     specified by the base and limit values, then node n ignores the Sysaddr
     (since it does not map to node n). Otherwise continue to step 2 below.
  2. If the DramHoleValid bit of the DHAR for node n is clear, the DHAR is
     disabled so skip to step 3 below. Otherwise see if the SysAddr is within
     the range of relocated addresses (starting at 0x100000000) from the DRAM
     hole. If not, skip to step 3 below. Else get the value of the
     DramHoleOffset field from the DHAR. To obtain the DramAddr, subtract the
     offset defined by this value from the SysAddr.
  3. Obtain the base address for node n from the DRAMBase field of the DRAM
     Base register for node n. To obtain the DramAddr, subtract the base
     address from the SysAddr, as shown near the start of section 3.4.4 (p.70).
 use DHAR to translate SysAddr to DramAddr 
	
	  Translate the SysAddr to a DramAddr as shown near the start of
	  section 3.4.4 (p. 70).  Although sys_addr is a 64-bit value, the k8
	  only deals with 40-bit values.  Therefore we discard bits 63-40 of
	  sys_addr below.  If bit 39 of sys_addr is 1 then the bits we
	  discard are all 1s.  Otherwise the bits we discard are all 0s.  See
	  section 3.4.2 of AMD publication 24592: AMD x86-64 Architecture
	  Programmer's Manual Volume 1 Application Programming.
  @intlv_en is the value of the IntlvEn field from a DRAM Base register
  (section 3.4.4.1).  Return the number of bits from a SysAddr that are used
  for node interleaving.
 Translate the DramAddr given by @dram_addr to an InputAddr. 
	
	  See the start of section 3.4.4 (p. 70, BKDG #26094, K8, revA-E)
	  concerning translating a DramAddr to an InputAddr.
  Translate the SysAddr represented by @sys_addr to an InputAddr.  It is
  assumed that @sys_addr maps to the node given by mci.
 Map the Error address to a PAGE and PAGE OFFSET. 
  @sys_addr is an error address (a SysAddr) extracted from the MCA NB Address
  Low (section 3.6.4.5) and MCA NB Address High (section 3.6.4.6) registers
  of a node that detected an ECC memory error.  mci represents the node that
  the error address maps to (possibly different from the node that detected
  the error).  Return the number of the csrow that sys_addr maps to, or -1 on
  error.
  Determine if the DIMMs have ECC enabled. ECC is enabled ONLY if all the DIMMs
  are ECC capable.
 UMC Configuration bit 12 (DimmEccEn) 
		
		  It's assumed all LRDIMMs in a DCT are going to be of
		  same 'type' until proven otherwise. So, use a cs
		  value of '0' here to get dcsm value.
 Asymmetric dual-rank DIMM support. 
	
	  3 Rank inteleaving support.
	  There should be only three bases enabled and their two masks should
	  be equal.
 Display and decode various NB registers for debug purposes. 
 everything below this point is Fam10h and above 
 Only if NOT ganged does dclr1 have valid info 
 Display and decode various NB registers for debug purposes. 
  See BKDG, F2x[1,0][5C:40], F2[1,0][6C:60]
  Function 2 Offset F10_DCSB0; read in the DCS Base and DCS Mask registers
		
		  Model 0x60h needs special handling:
		 
		  We use a Chip Select value of '0' to obtain dcsm.
		  Theoretically, it is possible to populate LRDIMMs of different
		  'Rank' value on a DCT. But this is not the common case. So,
		  it's reasonable to assume all DIMMs are going to be of same
		  'type' until proven otherwise.
 Get the number of DCT channels the memory controller is using. 
 RevF (NPT) and later 
 RevE and earlier 
 not used 
 On F10h and later ErrAddr is MC4_ADDR[47:1] 
	
	  Erratum 637 workaround
 add [47:27] + 3 trailing bits 
 reverse and add DramIntlvEn 
 pin at [47:24] 
 faster log2 
 OR DramIntlvSel into bits [14:12] 
 add remaining [11:0] bits from original MC4_ADDR 
 F15h: factor in CC6 save area by reading dst node's limit reg 
 {[39:27],111b} 
 [47:40] 
	
	  Find out which node the error address belongs to. This may be
	  different from the node that detected the error.
 Now map the sys_addr to a CSROW 
 CHIPKILL enabled 
			
			  Syndrome didn't map, so we don't know which of the
			  2 DIMMs is in error. So we need to ID 'both' of them
			  as suspect.
		
		  non-chipkill ecc mode
		 
		  The k8 documentation is unclear about how to determine the
		  channel number when using non-chipkill memory.  This method
		  was obtained from email communication with someone at AMD.
		  (Wish the email was placed in this comment - norsk)
		
		  the below calculation, besides trying to win an obfuscated C
		  contest, maps cs_mode values to DIMM chip select sizes. The
		  mappings are:
		 
		  cs_mode	CS size (mb)
		  =======	============
		  0		32
		  1		64
		  2		128
		  3		128
		  4		256
		  5		512
		  6		256
		  7		512
		  8		1024
		  9		1024
		  10		2048
		 
		  Basically, it calculates a value with which to shift the
		  smallest CS size of 32MB.
		 
		  ddr[23]_cs_size have a similar purpose.
  Get the number of DCT channels in use.
  Return:
 	number of Memory Channels in operation
  Pass back:
 	contents of the DCL0_LOW register
 On F10h, if we are in 128 bit mode, then we are using 2 channels 
	
	  Need to check if in unganged mode: In such, there are 2 channels,
	  but they are not in 128 bit mode and thus the above 'dclr0' status
	  bit will be OFF.
	 
	  Need to check DCT0[0] and DCT1[0] to see if only one of them has
	  their CSEnable bit on. If so, then SINGLE DIMM case.
	
	  Check DRAM Bank Address Mapping values for each DIMM to see if there
	  is more than just one DIMM present in unganged mode. Need to check
	  both controllers since DIMMs can be placed in either one.
 SDP Control bit 31 (SdpInit) is clear for unused UMC channels 
 Min cs_size = 1G 
  F15h supports only 64bit DCT interfaces
 F15h M60h supports DDR4 mapping as well.. 
 Minimum cs size is 512mb for F15hM60h
  F16h and F15h model 30h have only limited cs_modes.
 No Chip Selects are enabled. 
 Requested size of an even CS but none are enabled. 
 Requested size of an odd CS but none are enabled. 
	
	  There is one mask per DIMM, and two Chip Selects per DIMM.
	 	CS0 and CS1 -> DIMM0
	 	CS2 and CS3 -> DIMM1
 Asymmetric dual-rank DIMM support. 
	
	  The number of zero bits in the mask is equal to the number of bits
	  in a full mask minus the number of bits in the current mask.
	 
	  The MSB is the number of bits in the full mask because BIT[0] is
	  always 0.
	 
	  In the special 3 Rank interleaving case, a single bit is flipped
	  without swapping with the most significant bit. This can be handled
	  by keeping the MSB where it is and ignoring the single zero bit.
 Take the number of zero bits off from the top of the mask. 
 Register [31:1] = Address [39:9]. Size is in kBs here. 
 Return size in MBs. 
  Determine channel (DCT) based on the interleaving mode (see F15h M30h BKDG,
  2.10.12 Memory Interleaving Modes).
  Determine channel (DCT) based on the interleaving mode: F10h BKDG, 2.8.9 Memory
  Interleaving Modes.
	
	  see F2x110[DctSelIntLvAddr] - channel interleave mode
 return DCT select function: 0=DCT0, 1=DCT1 
 Convert the sys_addr to the normalized DCT address 
		
		  if
		  base address of high range is below 4Gb
		  (bits [47:27] at [31:11])
		  DRAM address space on this DCT is hoisted above 4Gb	&&
		  sys_addr > 4Gb
		 
		 	remove hole offset from sys_addr
		  else
		 	remove high range offset from sys_addr
		
		  if
		  we have a valid hole		&&
		  sys_addr > 4Gb
		 
		 	remove hole
		  else
		 	remove dram base to normalize to DCT address
  checks if the csrow passed in is marked as SPARED, if so returns the new
  spare row
  Iterate over the DRAM DCT "base" and "mask" registers looking for a
  SystemAddr match on the specified 'ChannelSelect' and 'NodeID'
  Return:
 	-EINVAL:  NOT FOUND
 	0..csrow = Chip-Select Row
  See F2x10C. Non-interleaved graphics framebuffer memory under the 16G is
  swapped with a region located at the bottom of memory so that the GPU can use
  the interleaved region and thus two channels.
 only revC3 and revE have that feature 
 For a given @dram_range, check if @sys_addr falls within it. 
	
	  check whether addresses >= DctSelBaseAddr[47:27] are to be used to
	  select between DCT0 and DCT1.
 Remove node interleaving, see F1x120 
 remove channel interleave 
 hash 9 
 A[6] or hash 6 
 A[12] 
 Verify sys_addr is within DCT Range. 
 Verify number of dct's that participate in channel interleaving. 
 Verify we stay within the MAX number of channels allowed 
 Get normalized DCT addr 
 remove channel interleave 
	
	  Find Chip select:
	  if channel = 3, then alias it to 1. This is because, in F15 M30h,
	  there is support for 4 DCT's, but only 2 are currently functional.
	  They are DCT0 and DCT3. But we have read all registers of DCT3 into
	  pvt->csels[1]. So we need to use '1' here to get correct info.
	  Refer F15 M30h BKDG Section 2.10 and 2.10.3 for clarifications.
  For reference see "2.8.5 Routing DRAM Requests" in F10 BKDG. This code maps
  a @sys_addr to NodeID, DCT (channel) and chip select (CSROW).
  The @sys_addr is usually an error address received from the hardware
  (MCX_ADDR).
	
	  We need the syndromes for channel detection only when we're
	  ganged. Otherwise @chan should already contain the channel at
	  this point.
  debug routine to display the memory sizes of all logical DIMMs and its
  CSROWs
 K8 families < revF not supported yet 
 Dump memory sizes for DIMM and its CSROWs 
			
			  For F15m60h, we need multiplier for LRDIMM cs_size
			  calculation. We pass dimm value to the dbam_to_cs
			  mapper so we can find the multiplier from the
			  corresponding DCSM.
  These are tables of eigenvectors (one per line) which can be used for the
  construction of the syndrome tables. The modified syndrome search algorithm
  uses those to find the symbol in error and thus the DIMM.
  Algorithm courtesy of Ross LaFetra from AMD.
 walk over all 16 bits of the syndrome 
 if bit is set in that eigenvector... 
 ... and bit set in the modified syndrome, 
 remove it. 
 can't get to zero, move to next symbol 
 x8 symbols 
 imaginary bits not in a DIMM 
 Bail out early if this was an 'observed' error 
 Do only ECC errors 
  To find the UMC channel represented by this bank we need to match on its
  instance_id. The instance_id of a bank is held in the lower 32 bits of its
  IPID.
  Currently, we can derive the channel number by looking at the 6th nibble in
  the instance_id. For example, instance_id=0xYXXXXX where Y is the channel
  number.
  Use pvt->F3 which contains the F3 CPU PCI device to get the related
  F1 (AddrMap) and F2 (Dct) devices. Return negative value on error.
  Reserve F0 and F6 on systems with a UMC.
 Reserve the ADDRESS MAP Device 
 Reserve the DCT Device 
 Check enabled channels only: 
 F16h has only DCT0, so no need to read dbam1. 
 F10h, revD and later can do x8 ECC too. 
  Retrieve the hardware registers of the memory controller.
 Read registers from each UMC 
  Retrieve the hardware registers of the memory controller (this includes the
  'Address Map' and 'Misc' device regs)
	
	  Retrieve TOP_MEM and TOP_MEM2; no masking off of reserved bits since
	  those are Read-As-Zero.
 Check first whether TOP_MEM2 is enabled: 
 read settings for this DRAM range 
  NOTE: CPU Revision Dependent code
  Input:
 	@csrow_nr ChipSelect Row Number (0..NUM_CHIPSELECTS-1)
 	k8 private pointer to -->
 			DRAM Bank Address mapping register
 			node_id
 			DCL register where dual_channel_active is
  The DBAM register consists of 4 sets of 4 bits each definitions:
  Bits:	CSROWs
  0-3		CSROWs 0 and 1
  4-7		CSROWs 2 and 3
  8-11		CSROWs 4 and 5
  12-15	CSROWs 6 and 7
  Values range from: 0 to 15
  The meaning of the values depends on CPU revision and dual-channel state,
  see relevant BKDG more info.
  The memory controller provides for total of only 8 CSROWs in its current
  architecture. Each "pair" of CSROWs normally represents just one DIMM in
  single channel or two (2) DIMMs in dual channel mode.
  The following code logic collapses the various tables for CSROW based on CPU
  revision.
  Returns:
 	The number of PAGE_SIZE pages on the specified CSROW number it
 	encompasses
  Initialize the array of csrow attribute instances, based on the values
  from pci config hardware registers.
	
	  We iterate over DCT0 here but we look at DCT1 in parallel, if needed.
 K8 has only one DCT 
 Determine DIMM ECC mode: 
 get all cores on this DCT 
 check MCG_CTL on all the cpus on this node 
			
			  Turn off NB MCE reporting only when it was off before
 UECCCECC enable 
 Attempt to turn on DRAM ECC Enable 
 UECCCECC enable 
 restore previous BIOS DRAM ECC "off" setting we force-enabled 
 restore the NB Enable MCGCTL bit 
 Only check enabled UMCs. 
 Check whether at least one UMC is enabled: 
 Assume UMC MCA banks are enabled. 
 Set chipkill only if ECC is enabled: 
 memory scrubber interface 
  returns a pointer to the family descriptor on success, NULL otherwise.
 Richland is only client 
	
	  We need to determine how many memory channels there are. Then use
	  that information for calculating the size of the dynamic instance
	  tables in the 'mci' structure.
	
	  Always allocate two channels since we can have setups with DIMMs on
	  only one channel. Also, this simplifies handling later for the price
	  of a couple of KBs tops.
 Remove from EDAC CORE tracking list 
 Free the EDAC CORE resources 
 unwind properly 
 register stuff with EDAC MCE 
 unregister from EDAC MCE 
  edac_module.c
  (C) 2007 www.softwarebitmaker.com
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  Author: Doug Thompson <dougthompson@xmission.com>
 Values of 0 to 4 will generate output 
  edac_op_state_to_string()
  sysfs object: sysdevicessystemedac
 	need to export to other files
 create the sysdevicessystemedac directory 
 return pointer to the 'edac' node in sysfs 
  edac_init
       module initialization entry point
	
	  Harvest and clear any bootinitialization PCI parity errors
	 
	  FIXME: This only clears errors logged by devices present at time of
	       module initialization.  We should also do an initial clear
	       of each newly hotplugged device.
  edac_exit()
       module exittermination function
 tear down the various subsystems 
  Inform the kernel of our entry and exit points
  Intel 30003010 Memory Controller kernel module
  Copyright (C) 2007 Akamai Technologies, Inc.
  Shamelessly copied from:
  	Intel D82875P Memory Controller kernel module
  	(C) 2003 Linux Networx (http:lnxi.com)
  This file may be distributed under the terms of the
  GNU General Public License.
 Intel 3000 register addresses - device 0 function 0 - DRAM Controller 
 MCH Memory Mapped Register BAR 
#define I3000_EDEAP	0x70	 Extended DRAM Error Address Pointer (8b)
				 
				  7:1   reserved
				  0     bit 32 of address
#define I3000_DEAP	0x58	 DRAM Error Address Pointer (32b)
				 
				  31:7  address
				  6:1   reserved
				  0     Error channel 01
  Helper functions to decode the DEAPEDEAP hardware registers.
  The type promotion here is deliberate; we're deriving an
  unsigned long pfn and offset from hardware regs which are u8u32.
#define I3000_DERRSYN	0x5c	 DRAM Error Syndrome (8b)
				 
				   7:0  DRAM ECC Syndrome
#define I3000_ERRSTS	0xc8	 Error Status Register (16b)
				 
				  15:12 reserved
				  11    MCH Thermal Sensor Event
				          for SMISCISERR
				  10    reserved
				   9    LOCK to non-DRAM Memory Flag (LCKF)
				   8    Received Refresh Timeout Flag (RRTOF)
				   7:2  reserved
				   1    Multi-bit DRAM ECC Error Flag (DMERR)
				   0    Single-bit DRAM ECC Error Flag (DSERR)
 bits which indicate errors 
#define I3000_ERRCMD	0xca	 Error Command (16b)
				 
				  15:12 reserved
				  11    SERR on MCH Thermal Sensor Event
				          (TSESERR)
				  10    reserved
				   9    SERR on LOCK to non-DRAM Memory
				          (LCKERR)
				   8    SERR on DRAM Refresh Timeout
				          (DRTOERR)
				   7:2  reserved
				   1    SERR Multi-Bit DRAM ECC Error
				          (DMERR)
				   0    SERR on Single-Bit ECC Error
				          (DSERR)
 Intel  MMIO register space - device 0 function 0 - MMR space 
 32MiB grain 
#define I3000_C0DRB	0x100	 Channel 0 DRAM Rank Boundary (8b x 4)
				 
				  7:0   Channel 0 DRAM Rank Boundary Address
#define I3000_C1DRB	0x180	 Channel 1 DRAM Rank Boundary (8b x 4)
				 
				  7:0   Channel 1 DRAM Rank Boundary Address
#define I3000_C0DRA	0x108	 Channel 0 DRAM Rank Attribute (8b x 2)
				 
				  7     reserved
				  6:4   DRAM odd Rank Attribute
				  3     reserved
				  2:0   DRAM even Rank Attribute
				 
				  Each attribute defines the page
				  size of the corresponding rank:
				      000: unpopulated
				      001: reserved
				      010: 4 KB
				      011: 8 KB
				      100: 16 KB
				      Others: reserved
 Channel 1 DRAM Rank Attribute (8b x 2) 
#define I3000_C0DRC0	0x120	 DRAM Controller Mode 0 (32b)
				 
				  31:30 reserved
				  29    Initialization Complete (IC)
				  28:11 reserved
				  10:8  Refresh Mode Select (RMS)
				  7     reserved
				  6:4   Mode Select (SMS)
				  3:2   reserved
				  1:0   DRAM Type (DT)
#define I3000_C0DRC1	0x124	 DRAM Controller Mode 1 (32b)
				 
				  31    Enhanced Addressing Enable (ENHADE)
				  30:0  reserved
	
	  This is a mess because there is no atomic way to read all the
	  registers at once and the registers can transition from CE being
	  overwritten by UE.
	
	  If the error is the same for both reads then the first set
	  of reads is valid.  If there is a change then there is a CE
	  with no info and the second set of reads is valid and
	  should be UE info.
	
	  Clear any error bits.
	  (Yes, we really clear bits by writing 1 to them.)
	
	  If the channels aren't populated identically then
	  we're not interleaved.
	
	  If the rank boundaries for the two channels are different
	  then we're not interleaved.
 ranks 0,1 
 ranks 2,3 
 ranks 0,1 
 ranks 2,3 
	
	  Figure out how many channels we have.
	 
	  If we have what the datasheet calls "asymmetric channels"
	  (essentially the same as what was called "virtual single
	  channel mode" in the i82875) then it's a single channel as
	  far as EDAC is concerned.
	
	  The dram rank boundary (DRB) reg values are boundary addresses
	  for each DRAM rank with a granularity of 32MB.  DRB regs are
	  cumulative; the last one will contain the total memory
	  contained in all ranks.
	 
	  If we're in interleaved mode then we're only walking through
	  the ranks of controller 0, so we double all the values we see.
	
	  Clear any error bits.
	  (Yes, we really clear bits by writing 1 to them.)
 allocating generic PCI control info 
 get this far and it's successful 
 returns count (>= 0), or negative on error 
 0 terminated list. 
 Ensure that the OPSTATE is set correctly for POLL or NMI 
 SPDX-License-Identifier: GPL-2.0-only
  string representation for the different MCA reported error types, see F3x48
  or MSR0000_0411.
 transaction type 
 cache level 
 memory transaction type 
 participating processor 
 request timeout 
 memory or io 
 internal error type 
 xec = 0xd 
 xec = 010 
 xec = 0x4 
 xec = 0x10 
 xec = 0x1c 
 Scalable MCA error strings 
 TLB error signatures are the same across families 
 special handling for DRAM ECCs 
 no ECCs on F11h 
 Decode errors according to Scalable MCA specification 
 Only print the decode of valid error codes 
 do the two bits[14:13] together 
 F15h, bank4, bit 43 is part of McaStatSubCache. 
 Doesn't matter which member to test. 
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  Copyright (C) 2012 Cavium, Inc.
  Copyright (C) 2009 Wind River Systems,
    written by Ralf Baechle <ralf@linux-mips.org>
  EDAC CPU cache error callback
  @event: non-zero if unrecoverable.
 Clear the error indication 
 SPDX-License-Identifier: GPL-2.0
   Copyright (C) 2017-2018, Intel Corporation. All rights reserved
   Copyright Altera Corporation (C) 2014-2016. All rights reserved.
   Copyright 2011-2012 Calxeda, Inc.
 EDAC Memory Controller Functions 
 The SDRAM controller uses the EDAC Memory Controller framework.       
 Clear IRQ to resume 
	 Error are injected by writing a word while the SBE or DBE
	  bit in the CTLCFG register is set. Reading the word will
	  trigger the SBE or DBE error and the corresponding IRQ.
 Clear the error injection bits 
 Ensure it has been written out 
	
	  To trigger the error, we need to read the data back
	  (the data was written with errors above).
	  The READ_ONCE macros and printk are used to prevent the
	  the compiler optimizing these reads out.
 Force Read 
 Get total memory size from Open Firmware DTB 
 Grab the register range from the sdr controller in device tree 
 Check specific dependencies for the module 
 Validate the SDRAM controller has ECC enabled 
 Grab memory size from device tree. 
 Ensure the SDRAM Interrupt is disabled 
 Toggle to clear the SDRAM Error count 
 Arria10 has a 2nd IRQ 
 Only the Arria10 has separate IRQs 
 Arria10 specific initialization 
 Infrastructure ready - enable the IRQ 
  If you want to suspend, need to disable EDAC by removing it
  from the device tree or defconfig.
 CONFIG_EDAC_ALTERA_SDRAM 
 EDAC Parent Probe 
 EDAC Device Functions 
  EDAC Device Functions (shared between various IPs).
  The discrete memories use the EDAC Device framework. The probe
  and error handling functions are very similar between memories
  so they are shared. The memory allocation and freeing for EDAC
  trigger testing are different for each memory.
	
	  Note that generic_ptr is initialized to the device  but in
	  some alloc_functions, this is overridden and returns data.
 write ECC corrupted data out. 
 Read data so we're in the correct state 
 Toggle Error bit (it is latched), leave ECC enabled 
 Ensure it has been written out 
 Read out written data. ECC error caused here 
  altr_edac_device_probe()
 	This is a generic EDAC device driver that will support
 	various Altera memory devices such as the L2 cache ECC and
 	OCRAM ECC as well as the memories for other peripherals.
 	Module specific initialization is done by passing the
 	function index in the device tree.
 Get driver specific data for this EDAC device 
 Check specific dependencies for the module 
 Arria10 Device ECC Shared Functions 
   Test for memory's ECC dependencies upon entry because platform specific
   startup should have initialized the memory and enabled the ECC.
   Can't turn on ECC here because accessing un-initialized memory will
   cause CEUE errors possibly causing an ABORT.
 Arria10 Memory Buffer Functions 
  This function uses the memory initialization block in the Arria10 ECC
  controller to initializeclear the entire memory data and ECC data.
 Clear any pending ECC interrupts 
 Get the ECC Manager - parent of the device EDACs 
 Map the ECC Block 
 Disable ECC 
 Ensure all writes complete 
 Use HW initialization block to initialize memory for ECC 
 Interrupt mode set to every SBERR 
 Enable ECC 
 Ensure all writes complete 
 Get matching node and check for valid result 
 Validate private data pointer before dereferencing 
 SDRAM EDAC Device Functions 
 CONFIG_EDAC_ALTERA_SDRAM 
 OCRAM EDAC Device Functions 
 Ensure data is written out 
 Remember this handle for freeing  later 
 Verify OCRAM has been initialized 
 Enable IRQ on Single Bit Error 
 Ensure all writes complete 
	
	  OCRAM panic on uncorrectable error because sleepresume
	  functions and FPGA contents are stored in OCRAM. Prefer
	  a kernel panic over executingloading corrupted data.
 CONFIG_EDAC_ALTERA_OCRAM 
 L2 Cache EDAC Device Functions 
 Make sure everything is written out 
	
	  Clean all cache levels up to LoC (includes L2)
	  This ensures the corrupted data is written into
	  L2 cache for readback test (which causes ECC error).
  altr_l2_check_deps()
 	Test for L2 cache ECC dependencies upon entry because
 	platform specific startup should have initialized the L2
 	memory and enabled the ECC.
 	Bail if ECC is not enabled.
 	Note that L2 Cache Enable is forced at build time.
 CONFIG_EDAC_ALTERA_L2C 
 Ethernet Device Functions 
 CONFIG_EDAC_ALTERA_ETHERNET 
 NAND Device Functions 
 CONFIG_EDAC_ALTERA_NAND 
 DMA Device Functions 
 CONFIG_EDAC_ALTERA_DMA 
 USB Device Functions 
 CONFIG_EDAC_ALTERA_USB 
 QSPI Device Functions 
 CONFIG_EDAC_ALTERA_QSPI 
 SDMMC Device Functions 
 Create the PortB EDAC device 
 Initialize the PortB EDAC device structure from PortA structure 
 Update PortB specific values 
	
	  Update the PortB IRQs - A10 has 4, S10 has 2, Index accordingly
	 
	  FIXME: Instead of ifdefs with different architectures the driver
	         should properly use compatibles.
 Use IRQ to determine SError origin instead of assigning IRQ 
 Init portB 
 Setup portB 
 CONFIG_EDAC_ALTERA_SDMMC 
 Arria10 EDAC Device Functions 
  The Arria10 EDAC Device Functions differ from the Cyclone5Arria5
  because 2 IRQs are shared among the all ECC peripherals. The ECC
  manager manages the IRQs and the children.
  Based on xgene_edac.c peripheral code.
 Ensure the interrupt test bits are set 
  The Stratix10 EDAC Error Injection Functions differ from Arria10
  slightly. A few Arria10 peripherals can use this injection function.
  Inject the error into the memory and then readback to trigger the IRQ.
 Setup readwrite of 4 bytes 
 Setup Address to 0 
 Setup accctrl to read & ecc & data override 
 Kick it. 
 Setup write for single bit change 
 Copy Read ECC to Write ECC 
 Setup accctrl to write & ecc override & data override 
 Kick it. 
 Setup accctrl to read & ecc overwrite & data overwrite 
 Kick it. 
 Ensure the interrupt test bits are set 
 SDRAM must be present for Linux (implied parent) 
 Ensure parent device is enabled if parent node exists 
 Get matching node and check for valid result 
 Get driver specific data for this EDAC device 
 Check specific dependencies for the module 
 Use IRQ to determine SError origin instead of assigning IRQ 
 Stratix 10 EDAC Double Bit Error Handler 
 panic routine issues reboot on non-zero panic_timeout 
  The double bit error is handled through SError which is fatal. This is
  called as a panic notifier to printout ECC error info as part of the panic.
 Find the matching DBE in the list of devices 
 Notify the System through SMC. Reboot delay = 1 second 
 Arria 10 EDAC Probe Function 
 Printout a message if uncorrectable error previously. 
 Reset the sticky registers 
  edac_device.c
  (C) 2007 www.douglaskthompson.com
  This file may be distributed under the terms of the
  GNU General Public License.
  Written by Doug Thompson <norsk5@xmission.com>
  edac_device API implementation
  19 Jan 2007
 lock for the list: 'edac_device_list', manipulation of this list
  is protected by the 'device_ctls_mutex' lock
 CONFIG_EDAC_DEBUG 
 zero, 1, or other based offset 
	 Calculate the size of memory we need to allocate AND
	  determine the offsets of the various item arrays
	  (instance,block,attrib) from the start of an  allocated structure.
	  We want the alignment of each item  (instance,block,attrib)
	  to be at least as stringent as what the compiler would
	  provide if we could simply hardcode everything into a single struct.
	 Calc the 'end' offset past end of ONE ctl_info structure
	  which will become the start of the 'instance' array
	 Calc the 'end' offset past the instance array within the ctl_info
	  which will become the start of the block array
	 Calc the 'end' offset past the dev_blk array
	  which will become the start of the attrib array, if any.
 calc how many nr_attrib we need 
 Calc the 'end' offset past the attributes array 
	 'pvt' now points to where the private data area is.
	  At this point 'pvt' (like dev_inst,dev_blk and dev_attrib)
	  is baselined at ZERO
 Allocate the amount of memory for the set of control structures 
	 Adjust pointers so they point within the actual memory we
	  just allocated rather than an imaginary chunk of memory
	  located at address 0.
	  'dev_ctl' points to REAL memory, while the others are
	  ZERO based and thus need to be adjusted to point within
	  the allocated memory.
 Begin storing the information into the control info structure 
 Default logging of CEs and UEs 
 Name of this edac device 
 Initialize every Instance 
 name of this instance 
 Initialize every block in each instance 
			 if there are NO attributes OR no attribute pointer
			  then continue on to next block iteration
 setup the attribute array for this block 
			 Initialize every user specified attribute in this
			  block with the data the caller passed in
			  Each block gets its own copy of pointers,
			  and its unique 'value'
				 populate the unique per attrib
				  with the code pointers and info
 up link 
 Mark this instance as merely ALLOCATED 
	
	  Initialize the 'root' kobj for the edac_device controller
	 at this point, the root kobj is valid, and in order to
	  'free' the object, then the function:
	 	edac_device_unregister_sysfs_main_kobj() must be called
	  which will perform kobj unregistration and the actual free
	  will occur during the kobject callback operation
  find_edac_device_by_dev
 	scans the edac_device list for a specific 'struct device '
 	lock to be held prior to call:	device_ctls_mutex
 	Return:
 		pointer to control structure managing 'dev'
 		NULL if not found on list
  add_edac_dev_to_global_list
 	Before calling this function, caller must
 	assign a unique value to edac_dev->dev_idx.
 	lock to be held prior to call:	device_ctls_mutex
 	Return:
 		0 on success
 		1 on failure.
 Determine if already on the list 
 Insert in ascending order by 'dev_idx', so find position 
  del_edac_device_from_global_list
	 these are for safe removal of devices from global list while
	  NMI handlers may be traversing list
  edac_device_workq_function
 	performs the operation scheduled by a workq request
 	this workq is embedded within an edac_device_ctl_info
 	structure, that needs to be polled for possible error events.
 	This operation is to acquire the list mutex lock
 	(thus preventing insertation or deletion)
 	and then call the device's poll function IFF this device is
 	running polled and there is a poll function defined.
 If we are being removed, bail out immediately 
 Only poll controllers that are running polled and have a check 
	 Reschedule the workq for the next time period to start again
	  if the number of msec is for 1 sec, then adjust to the next
	  whole one second to save timers firing all over the period
	  between integral seconds
  edac_device_workq_setup
 	initialize a workq item for this edac_device instance
 	passing in the new delay period in msec
	 take the arg 'msec' and set it into the control structure
	  to used in the time period calculation
	  then calc the number of jiffies that represents
	 optimize here for the 1 second case, which will be normal value, to
	  fire ON the 1 second time event. This helps reduce all sorts of
	  timers firing on sub-second basis, while they are happy
	  to fire together on the 1 second exactly
  edac_device_workq_teardown
 	stop the workq processing on this edac_dev
  edac_device_reset_delay_period
 	need to stop any outstanding workq queued up at this time
 	because we will be resetting the sleep time.
 	Then restart the workq on the new delay
 set load time so that error rate can be tracked 
 create this instance's sysfs entries 
 If there IS a check routine, then we are running POLLED 
 This instance is NOW RUNNING 
		
		  enable workq processing on this instance,
		  default = 1000 msec
 Report action taken 
 Some error, so remove the entry from the lsit 
 Find the structure on the list, if not there, then leave 
 mark this instance as OFFLINE 
 deregister from global list 
 clear workq processing on this instance 
 Tear down the sysfs entries for this instance 
 Propagate the count up the 'totals' tree 
 Propagate the count up the 'totals' tree 
 SPDX-License-Identifier: GPL-2.0-only
 Intel Sandy Bridge -EN-EP-EX Memory Controller kernel module
  This driver supports the memory controllers found on the Intel
  processor family Sandy Bridge.
  Copyright (c) 2011 by:
 	 Mauro Carvalho Chehab
 Static vars 
  Alter this version for the module when modifications are made
  Debug macros
  Get a bit field at register value <v>, from bit <lo> to bit <hi>
 Devices 12 Function 6, Offsets 0x80 to 0xcc 
 0-4 
 5-9 
 10-14 
 15-19 
 20-23 
 0-4 
 5-9 
 10-14 
 15-19 
 20-23 
 Devices 12 Function 7 
 Device 13 Function 6 
 Device 14 function 0 
 Device 15, function 0 
 Device 15, function 1 
 Device 15, functions 2-5 
 Device 16, functions 2-7 
  FIXME: Implement the error count reads directly
 Currently unused
 Device 17, function 0 
  sbridge structs
 Max channels per MC 
 Max DIMMS per channel 
 KNL max num. of Cache Home Agents 
 KNL max num. of PCI channels 
 Embedded DRAM controllers 
 Intel IA32 SDM 15-14 
 tolm, tohm 
 Devices per socket 
 Devices per memory controller 
 Memory type detection 
 Memory description 
 Processor Home Agent 
 Memory controller 
 System Address Decoder 
 Broadcast Registers 
 0 terminated list. 
 This changes depending if 1HA or 2HA:
  1HA:
 	0x0eb8 (17.0) is DDRIO0
  2HA:
 	0x0ebc (17.4) is DDRIO0
 pci ids 
 Processor Home Agent 
 Memory controller 
 Optional, mode 2HA 
 System Address Decoder 
 Broadcast Registers 
 0 terminated list. 
 Haswell support 
 EN processor:
 	- 1 IMC
 	- 3 DDR3 channels, 2 DPC per channel
  EP processor:
 	- 1 or 2 IMC
 	- 4 DDR4 channels, 3 DPC per channel
  EP 4S processor:
 	- 2 IMC
 	- 4 DDR4 channels, 3 DPC per channel
  EX processor:
 	- 2 IMC
 	- each IMC interfaces with a SMI 2 channel
 	- each SMI channel interfaces with a scalable memory buffer
 	- each scalable memory buffer supports 4 DDR3DDR4 channels, 3 DPC
 Ditto on Broadwell 
 first item must be the HA 
 0 terminated list. 
 Knight's Landing Support 
  KNL's memory channels are swizzled between memory controllers.
  MC0 is mapped to CH3,4,5 and MC1 is mapped to CH0,1,2
 Memory controller, TAD tables, error injection - 2-8-0, 2-9-0 (2 of these) 
 DRAM channel stuff; bank addrs, dimmmtr, etc.. 2-8-2 - 2-9-4 (6 of these) 
 kdrwdbu TAD limitsoffsets, MCMTR - 2-10-1, 2-11-1 (2 of these) 
 CHA broadcast registers, dram rules - 1-29-0 (1 of these) 
 SAD target - 1-29-1 (1 of these) 
 Caching  Home Agent 
 Device with TOLM and TOHM, 0-5-0 (1 of these) 
  KNL differs from SB, IB, and Haswell in that it has multiple
  instances of the same device with the same device ID, so we handle that
  by creating as many copies in the table as we expect to find.
  (Like device ID must be grouped together.)
  Broadwell support
  DE processor:
 	- 1 IMC
 	- 2 DDR3 channels, 2 DPC per channel
  EP processor:
 	- 1 or 2 IMC
 	- 4 DDR4 channels, 3 DPC per channel
  EP 4S processor:
 	- 2 IMC
 	- 4 DDR4 channels, 3 DPC per channel
  EX processor:
 	- 2 IMC
 	- each IMC interfaces with a SMI 2 channel
 	- each SMI channel interfaces with a scalable memory buffer
 	- each scalable memory buffer supports 4 DDR3DDR4 channels, 3 DPC
 first item must be the HA 
 0 terminated list. 
			Ancillary status routines
	
	  If we have devices scattered across several busses that pertain
	  to the same memory controller, we'll lump them all together.
 Address range is 32:28 
 FIXME: Can also be LRDIMM 
 Is_Rdimm 
 for KNL value is fixed 
 there's no way to figure out 
	
	  ddr3_width on the documentation but also valid for DDR4 on
	  Haswell
 ddr3_width on the documentation but also valid for DDR4 
 DDR4 RDIMMS and LRDIMMS are supported 
  Use the reporting bank number to determine which memory
  controller (also known as "ha" for "home agent"). Sandy
  Bridge only has one memory controller per socket, so the
  answer is always zero.
  On Ivy Bridge, Haswell and Broadwell the error may be in a
  home agent bank (7, 8), or one of the per-channel memory
  controller banks (9 .. 16).
 Not used, but included for safetysymmetry 
 on Ivy Bridge, nodeID is SASS, where A is HA and S is node id 
	
	  XOR even bits from 12:26 to bit0 of idx,
	      odd bits from 13:27 to bit1
 Low bits of TAD limit, and some metadata. 
 Low bits of TAD offset. 
 High 16 bits of TAD limit and offset. 
 Number of ways a tad entry is interleaved. 
  Retrieve the n'th Target Address Decode table entry
  from the memory controller's TAD table.
  @pvt:	driver private data
  @entry:	which entry you want to retrieve
  @mc:		which memory controller (0 or 1)
  @offset:	output tad range offset
  @limit:	output address of first byte above tad range
  @ways:	output number of interleave ways
  The offset value has curious semantics.  It's a sort of running total
  of the sizes of all the memory regions that aren't mapped in this
  tad table.
 Is this TAD entry enabled? 
	
	  The least significant 6 bits of base and limit are truncated.
	  For limit, we fill the missing bits with 1s.
 Determine which memory controller is responsible for a given channel. 
  Get the Nth entry from EDC_ROUTE_TABLE register.
  (This is the per-tile mapping of logical interleave targets to
   physical EDC modules.)
  entry 0: 0:2
        1: 3:5
        2: 6:8
        3: 9:11
        4: 12:14
        5: 15:17
        6: 18:20
        7: 21:23
  reserved: 24:31
  Get the Nth entry from MC_ROUTE_TABLE register.
  (This is the per-tile mapping of logical interleave targets to
   physical DRAM channels modules.)
  entry 0: mc 0:2   channel 18:19
        1: mc 3:5   channel 20:21
        2: mc 6:8   channel 22:23
        3: mc 9:11  channel 24:25
        4: mc 12:14 channel 26:27
        5: mc 15:17 channel 28:29
  reserved: 30:31
  Though we have 3 bits to identify the MC, we should only see
  the values 0 or 1.
  Render the EDC_ROUTE register in human-readable form.
  Output string s should be at least KNL_MAX_EDCS2 bytes.
  Render the MC_ROUTE register in human-readable form.
  Output string s should be at least KNL_MAX_CHANNELS2 bytes.
 Is this dram rule backed by regular DRAM in flat mode? 
 Is this dram rule cached? 
 Is this rule backed by edc ? 
 Is this rule backed by DRAM, cacheable in EDRAM? 
 Is this rule mod3? 
  Figure out how big our RAM modules are.
  The DIMMMTR register in KNL doesn't tell us the size of the DIMMs, so we
  have to figure this out from the SAD rules, interleave lists, route tables,
  and TAD rules.
  SAD rules can have holes in them (e.g. the 3G-4G hole), so we have to
  inspect the TAD rules to figure out how large the SAD regions really are.
  When we know the real size of a SAD region and how many ways it's
  interleaved, we know the individual contribution of each channel to
  TAD is sizeways.
  Finally, we have to check whether each channel participates in each SAD
  region.
  Fortunately, KNL only supports one DIMM per channel, so once we know how
  much memory the channel uses, we know the DIMM is at least that large.
  (The BIOS might possibly choose not to map all available memory, in which
  case we will underreport the size of the DIMM.)
  In theory, we could try to determine the EDC sizes as well, but that would
  only work in flat mode, not in cache mode.
  @mc_sizes: Output sizes of channels (must have space for KNL_MAX_CHANNELS
             elements)
 sad size accounting for holes, per mc 
 Read the EDC route table in each CHA. 
 Read the MC route table in each CHA. 
 Process DRAM rules 
 previous limit becomes the new base 
		
		  Find out how many ways this dram rule is interleaved.
		  We stop when we see the first channel again.
				
				  0 bit means memory is non-local,
				  which KNL doesn't support
		
		  Find out how big the SAD region really is by iterating
		  over TAD tables (SAD regions may contain holes).
		  Each memory controller might have a different TAD table, so
		  we have to look at both.
		 
		  Livespace is the memory that's mapped in this TAD table,
		  deadspace is the holes (this could be the MMIO hole, or it
		  could be memory that's mapped by the other TAD table but
		  not this one).
 TAD region is completely inside SAD region 
 Ignore EDRAM rule 
 Figure out which channels participate in interleave. 
		 For each channel, does at least one CHA have
		  this channel mapped to the given target?
 For DDR4, this is fixed. 
	 KNL doesn't support mirroring or lockstep,
	  and is always closed page
	
	  Step 1) Get TOLMTOHM ranges
 Address range is already 45:25 
	
	  Step 2) Get SAD range and SAD Interleave list
	  TAD registers contain the interleave wayness. However, it
	  seems simpler to just discover it indirectly, with the
	  algorithm bellow.
 SAD_LIMIT Address range is 45:26 
	
	  Step 3) Get TAD range
	
	  Step 4) Get TAD offsets, per each channel
	
	  Step 6) Get RIR WaynessLimit, per each channel
	
	  Step 0) Check if the address is at special memory ranges
	  The check bellow is probably enough to fill all cases where
	  the error is not inside a memory, except for the legacy
	  range (e. g. VGA addresses). It is unlikely, however, that the
	  memory controller would generate an error on that range.
	
	  Step 1) Get socket
 A7 mode swaps P9 with P6 
 interleave mode will XOR {8,7,6} with {18,17,16} 
 MCChanShiftUpEnable 
 Ivy Bridge's SAD mode doesn't support XOR interleave mode 
	
	  Move to the proper node structure, in order to access the
	  right PCI registers
	
	  Step 2) Get memory channel
	
	  FIXME: Shouldn't we use CHN_IDX_OFFSET() here, when ch_way == 3 ???
 Calculate channel address 
 Remove the TAD offset 
	
	  Step 3) Decode rank
 FIXME: Datasheet says to shift by 15 
	Device initialization routines: putget, initexit
 	sbridge_put_all_devices	'put' all the devices that we have
 				reserved via 'get'
 if the HA wasn't found 
 End of list, leave 
 If the HA1 wasn't found, don't create EDAC second memory controller 
 pdev belongs to more than one IMC, do extra gets 
 Be sure that the device is enabled 
	
	  As stated on driverspcisearch.c, the reference count for
	  @from is always decremented if it is not %NULL. So, as we need
	  to get all devices up to null, we need to do a get for the device
  sbridge_get_all_devices - Find and perform 'get' operation on the MCH's
 			     devices we want to reference for this driver.
  @num_mc: pointer to the memory controllers count, to be incremented in case
 	    of success.
  @table: model specific table
  returns 0 in case of success or error code
  Device IDs for {SBRIDGE,IBRIDGE,HASWELL,BROADWELL}_IMC_HA0_TAD0 are in
  the format: XXXa. So we can convert from a device to the corresponding
  channel like this
 Check if everything were registered 
 Check if everything were registered 
 -EN-EX 
 -EP 
 there's only one device per system; not tied to any bus 
 result will be checked later 
 Check if everything were registered 
 -EN-EX 
 -EP 
 there's only one device per system; not tied to any bus 
 result will be checked later 
 Check if everything were registered 
 -EN-EX 
 -EP 
 Extract PCI device and function. 
			 There are one of these per tile, and range from
			  1.14.0 to 1.18.5.
			
			   MC0 channels 0-2 are device 9 function 2-4,
			   MC1 channels 3-5 are device 8 function 2-4.
			Error check routines
  While Sandy Bridge has error count registers, SMI BIOS read values from
  and resets the counters. So, they are not reliable for the OS to read
  from them. So, we have no option but to just trust on whatever MCE is
  telling us about the errors.
	
	  Bits 5-0 of MCi_MISC give the least significant bit that is valid.
	  A value 6 is for cache line aligned address, a value 12 is for page
	  aligned address reported by patrol scrubber.
	
	  According with Table 15-9 of the Intel Architecture spec vol 3A,
	  memory errors should fit in this mask:
	 	000f 0000 1mmm cccc (binary)
	  where:
	 	f = Correction Report Filtering Bit. If 1, subsequent errors
	 	    won't be shown
	 	mmm = error type
	 	cccc = channel
	  If the mask doesn't match, report an error to the parsing logic
			
			  Reported channel is in range 0-2, so we can't map it
			  back to mc. To figure out mc we check machine check
			  bank register that reported this error.
			  bank15 means mc0 and bank16 means mc1.
	
	  FIXME: On some memory configurations (mirror, lockstep), the
	  Memory Controller can't point the error to a single DIMM. The
	  EDAC core should be handling the channel mask, in order to point
	  to the group of dimm's where the error may be happening.
 FIXME: need support for channel mask 
 Call the helper to output message 
  Check that logging is enabled and that this is the right type
  of error for us to handle.
	
	  Just let mcelog handle it if the error is
	  outside the memory controller. A memory error
	  is indicated by bit 7 = 1 and bits = 8-11,13-15 = 0.
	  bit 12 has an special meaning.
 Check ADDRV bit in STATUS 
 Check MISCV bit in STATUS 
 Check address type in MISC (physical address only) 
 Advice mcelog that the error were handled 
			EDAC registerunregister logic
 Remove MC sysfs nodes 
 allocate a new MC control structure 
 Associate sbridge_dev and mci for future usage 
 Store pci devices at mci for faster access 
 Store pci devices at mci for faster access 
 rankcfgr isn't used 
 Store pci devices at mci for faster access 
 rankcfgr isn't used 
 Store pci devices at mci for faster access 
 pvt->info.rankcfgr == ??? 
 Get dimm basic config and the memory layout 
 record ptr to the generic device 
 add this new MC control structure to EDAC's list of MCs 
 	sbridge_probe	Get all devices and register memory controllers
 			present.
 	return:
 		0 for FOUND a device
 		< 0 for error code
 get the pci devices we want to reserve for our use 
 	sbridge_remove	cleanup
 Release PCI resources 
 	sbridge_init		Module entry function
 			Try to initialize this module for its devices
 Ensure that the OPSTATE is set correctly for POLL or NMI 
 	sbridge_exit()	Module exit function
 			Unregister the driver
www.redhat.com)");
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2017 Pengutronix, Jan Luebbe <kernel@pengutronix.de>
 EDAC MC (DDR RAM) 
 width in bytes 
 bank interleaving 
 derived from "DRAM Address Multiplexing" in the ARMADA XP Functional Spec 
 64 bit 
 bank interleaved 
 32 bit 
 bank interleaved 
 16 bit 
 bank interleaved 
 clear cause registers 
 clear error counter registers 
 report earlier errors 
 error count 
 pfn, offset, syndrome 
 top, mid, low layer 
 error count 
 pfn, offset, syndrome 
 top, mid, low layer 
 report details for most recent error 
 11 chars 
  9 chars 
 11 chars 
  4 chars 
 error count 
 top, mid, low layer 
 error count 
 top, mid, low layer 
 64 bit 
 32 bit 
 2GBit 
 256MBit 
 512MBit 
 1GBit 
 4GBit 
 8GBit 
 These SoCs have a reduced width bus 
 configure SBE threshold 
 it seems that SBEs are not captured otherwise 
 clear cause registers 
 clear counter registers 
 EDAC Device (L2 Cache) 
 error injection via debugfs 
 clear error counter registers 
 clear error capture registers 
 UnCorrECC or TagParity 
 report remaining errors 
 clear registers 
 Driver registration 
 only polling is supported 
 SPDX-License-Identifier: GPL-2.0+
  Copyright 2018, 2019 Cisco Systems
 protection key register 
 configuration register 
 interrupt controlstatus register 
 address of first un-recoverable error 
 address of last recoverable error 
 enable write to MCR register set 
 disable write to MCR register set 
 report first few errors (if there are) 
 note: no addresses are recorded 
 page, offset and syndrome are not available 
 report last error 
 note: rec_addr is the last recoverable error addr 
 syndrome is not available 
 report 1. error 
 note: un_rec_addr is the first unrecoverable error addr 
 syndrome is not available 
 report further errors (if there are) 
 note: no addresses are recorded 
 page, offset and syndrome are not available 
 collect data about recoverable and unrecoverable errors 
 clear interrupt flags and error counters: 
 process recoverable and unrecoverable errors 
 register interrupt handler 
 enable interrupts 
 retrieve info about physical memory from device tree 
 bail out if ECC mode is not configured 
 allocate & init EDAC MC data structure 
 register with edac core 
 register interrupt handler and enable interrupts 
 disable interrupts 
 free resources 
  Synopsys DDR ECC Driver
  This driver is based on ppc4xx_edac.c drivers
  Copyright (C) 2012 - 2014 Xilinx, Inc.
  This program is free software: you can redistribute it andor modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 2 of the License, or
  (at your option) any later version.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details
 Number of cs_rows needed per memory controller 
 Number of channels per memory controller 
 Granularity of reported error in bytes 
 Synopsys DDR memory controller registers that are relevant to ECC 
 ECC control register 
 ECC log register 
 ECC address register 
 ECC data[31:0] register 
 Uncorrectable error info registers 
 Control register bit field definitions 
 ZQ register bit field definitions 
 ECC control register bit field definitions 
 ECC correctableuncorrectable error log register definitions 
 ECC correctableuncorrectable error address register definitions 
 ECC statistic register definitions 
 ECC scrub register definitions 
 DDR ECC Quirks 
 ZynqMP Enhanced DDR memory controller registers that are relevant to ECC 
 ECC Configuration Registers 
 ECC Status Register 
 ECC Clear Register 
 ECC Error count Register 
 ECC Corrected Error Address Register 
 ECC Syndrome Registers 
 ECC Bit Mask0 Address Register 
 ECC UnCorrected Error Address Register 
 ECC Syndrome Registers 
 ECC Poison Address Reg 
 Control register bitfield definitions 
 DDR Control Register width definitions  
 ECC status register definitions 
 DDR QOS Interrupt register definitions 
 ECC Corrected Error Register Mask and Shifts
 ECC Poison register shifts 
 DDR Memory type defines 
 DDRC Software control register 
 DDRC ECC CE & UE poison mask 
 DDRC Device config masks 
  struct ecc_error_info - ECC error log information.
  @row:	Row number.
  @col:	Column number.
  @bank:	Bank number.
  @bitpos:	Bit position.
  @data:	Data causing the error.
  @bankgrpnr:	Bank group number.
  @blknr:	Block number.
  struct synps_ecc_status - ECC status information to report.
  @ce_cnt:	Correctable error count.
  @ue_cnt:	Uncorrectable error count.
  @ceinfo:	Correctable error log information.
  @ueinfo:	Uncorrectable error log information.
  struct synps_edac_priv - DDR memory controller private instance data.
  @baseaddr:		Base address of the DDR controller.
  @message:		Buffer for framing the event specific info.
  @stat:		ECC status information.
  @p_data:		Platform data.
  @ce_cnt:		Correctable Error count.
  @ue_cnt:		Uncorrectable Error count.
  @poison_addr:	Data poison address.
  @row_shift:		Bit shifts for row bit.
  @col_shift:		Bit shifts for column bit.
  @bank_shift:		Bit shifts for bank bit.
  @bankgrp_shift:	Bit shifts for bank group bit.
  @rank_shift:		Bit shifts for rank bit.
  struct synps_platform_data -  synps platform data structure.
  @get_error_info:	Get EDAC error info.
  @get_mtype:		Get mtype.
  @get_dtype:		Get dtype.
  @get_ecc_state:	Get ECC state.
  @quirks:		To differentiate IPs.
  zynq_get_error_info - Get the current ECC error info.
  @priv:	DDR memory controller private instance data.
  Return: one if there is no error, otherwise zero.
  zynqmp_get_error_info - Get the current ECC error info.
  @priv:	DDR memory controller private instance data.
  Return: one if there is no error otherwise returns zero.
  handle_error - Handle Correctable and Uncorrectable errors.
  @mci:	EDAC memory controller instance.
  @p:		Synopsys ECC status structure.
  Handles ECC correctable and uncorrectable errors.
  intr_handler - Interrupt Handler for ECC interrupts.
  @irq:        IRQ number.
  @dev_id:     Device ID.
  Return: IRQ_NONE, if interrupt not set or IRQ_HANDLED otherwise.
  check_errors - Check controller for ECC errors.
  @mci:	EDAC memory controller instance.
  Check and post ECC errors. Called by the polling thread.
  zynq_get_dtype - Return the controller memory width.
  @base:	DDR memory controller base address.
  Get the EDAC device type width appropriate for the current controller
  configuration.
  Return: a device type width enumeration.
  zynqmp_get_dtype - Return the controller memory width.
  @base:	DDR memory controller base address.
  Get the EDAC device type width appropriate for the current controller
  configuration.
  Return: a device type width enumeration.
  zynq_get_ecc_state - Return the controller ECC enabledisable status.
  @base:	DDR memory controller base address.
  Get the ECC enabledisable status of the controller.
  Return: true if enabled, otherwise false.
  zynqmp_get_ecc_state - Return the controller ECC enabledisable status.
  @base:	DDR memory controller base address.
  Get the ECC enabledisable status for the controller.
  Return: a ECC status boolean i.e truefalse - enableddisabled.
  get_memsize - Read the size of the attached memory device.
  Return: the memory size in bytes.
  zynq_get_mtype - Return the controller memory type.
  @base:	Synopsys ECC status structure.
  Get the EDAC memory type appropriate for the current controller
  configuration.
  Return: a memory type enumeration.
  zynqmp_get_mtype - Returns controller memory type.
  @base:	Synopsys ECC status structure.
  Get the EDAC memory type appropriate for the current controller
  configuration.
  Return: a memory type enumeration.
  init_csrows - Initialize the csrow data.
  @mci:	EDAC memory controller instance.
  Initialize the chip select rows associated with the EDAC memory
  controller instance.
  mc_init - Initialize one driver instance.
  @mci:	EDAC memory controller instance.
  @pdev:	platform device.
  Perform initialization of the EDAC memory controller instance and
  related driver-private data associated with the memory controller the
  instance is bound to.
 Initialize controller capabilities and configuration 
 Enable UECE Interrupts 
 Disable UECE Interrupts 
 end of table 
  ddr_poison_setup -	Update poison registers.
  @priv:		DDR memory controller private instance data.
  Update poison registers as per DDR mapping.
  Return: none.
  setup_address_map -	Set Address Map by querying ADDRMAP registers.
  @priv:		DDR memory controller private instance data.
  Set Address Map by querying ADDRMAP registers.
  Return: none.
 CONFIG_EDAC_DEBUG 
  mc_probe - Check controller and bind driver.
  @pdev:	platform device.
  Probe a specific controller instance for binding with the driver.
  Return: 0 if the controller instance was successfully bound to the
  driver; otherwise, < 0 on error.
	
	  Start capturing the correctable and uncorrectable errors. A write of
	  0 starts the counters.
  mc_remove - Unbind driver from controller.
  @pdev:	Platform device.
  Return: Unconditionally 0
  edac_mc kernel module
  (C) 2005, 2006 Linux Networx (http:lnxi.com)
  This file may be distributed under the terms of the
  GNU General Public License.
  Written by Thayne Harbaugh
  Based on work by Dan Hollis <goemon at anime dot net> and others.
 	http:www.anime.net~goemonlinux-ecc
  Modified by Dave Peterson and Doug Thompson
 lock to memory controller's control array 
  Used to lock EDAC MC to just one module, avoiding two drivers e. g.
 	apeighes and i7core_edac to be used at the same time.
 CONFIG_EDAC_DEBUG 
  edac_align_ptr - Prepares the pointer offsets for a single-shot allocation
  @p:		pointer to a pointer with the memory offset to be used. At
 		return, this will be incremented to point to the next offset
  @size:	Size of the data structure to be reserved
  @n_elems:	Number of elements that should be reserved
  If 'size' is a constant, the compiler will optimize this whole function
  down to either a no-op or the addition of a constant to the value of 'p'.
  The 'p' pointer is absolutely needed to keep the proper advancing
  further in memory to the proper offsets when allocating the struct along
  with its embedded structs, as edac_device_alloc_ctl_info() does it
  above, for example.
  At return, the pointer 'p' will be incremented to be used on a next call
  to this function.
	
	  'p' can possibly be an unaligned item X such that sizeof(X) is
	  'size'.  Adjust 'p' so that its alignment is at least as
	  stringent as what the compiler would provide for X and return
	  the aligned result.
	  Here we assume that the alignment of a "long long" is the most
	  stringent alignment that the compiler will ever provide by default.
	  As far as I know, this is a reasonable assumption.
	
	  Alocate and fill the csrowchannels structs
	
	  Allocate and fill the dimm structs
		
		  Copy DIMM location and initialize it.
 Link it to the csrows old API data 
 Increment csrow location 
 Increment dimm location 
	
	  Calculate the total amount of dimms and csrowscschannels while
	  in the old API emulation mode
	 Figure out the offsets of the various items from the start of an mc
	  structure.  We want the alignment of each item to be at least as
	  stringent as what the compiler would provide if we could simply
	  hardcode everything into a single struct.
	 Adjust pointers so they point within the memory we just allocated
	  rather than an imaginary chunk of memory located at address 0.
 setup index and various internal pointers 
 Caller must hold mem_ctls_mutex 
  find_mci_by_dev
 	scan list of controllers looking for the one that manages
 	the 'dev' device
  @dev: pointer to a struct device related with the MCI
  edac_mc_workq_function
 	performs the operation scheduled by a workq request
 Queue ourselves again. 
  edac_mc_reset_delay_period(unsigned long value)
 	user space has updated our poll period value, need to
 	reset our workq delays
 Return 0 on success, 1 on failure.
  Before calling this function, caller must
  assign a unique value to mci->mc_idx.
 	locking model:
 		called with the mem_ctls_mutex lock held
	 these are for safe removal of devices from global list while
	  NMI handlers may be traversing list
 FIXME - should a warning be printed if no error detection? correction? 
 set load time so that error rate can be tracked 
 Report action taken 
 find the requested mci struct in the global list 
 mark MCI offline: 
 remove from sysfs 
 ECC error page was not in our memory. Ignore it. 
 Find the actual page structure then map it and fix 
 Perform architecture specific atomic scrub operation 
 Unmap and complete 
 FIXME - should return -1 
		
			 Some memory controllers (called MCs below) can remap
			 memory so that it is still available at a different
			 address when PCI devices map into memory.
			 MC's that can't do this, lose the memory where PCI
			 devices are mapped. This mapping is MC-dependent
			 and so we call back into the MC driver for it to
			 map the MC page to a physical (CPU) page which can
			 then be mapped to a virtual page - which can then
			 be scrubbed.
 Sanity-check driver-supplied grain value. 
 Report the error via the trace interface 
 Fills the error report buffer 
 need valid strings here for both: 
	
	  Check if the event report is consistent and if the memory location is
	  known. If it is, the DIMM(s) label info will be filled and the DIMM's
	  error counters will be incremented.
			
			  Instead of just returning it, let's use what's
			  known about the error. The increment routines and
			  the DIMM filter logic will do the right thing by
			  pointing the likely damaged DIMMs.
	
	  Get the dimm labelgrain that applies to the match criteria.
	  As the error algorithm may not be able to point to just one memory
	  stick, the logic here will get all possible labels that could
	  pottentially be affected by the error.
	  On FB-DIMM memory controllers, for uncorrected errors, it is common
	  to have only the MC channel and the MC dimm (also called "branch")
	  but the channel is not known, as the memory is arranged in pairs,
	  where each memory belongs to a separate channel within the same
	  branch.
 get the max grain, over the error match range 
		
		  If the error is memory-controller wide, there's no need to
		  seek for the affected DIMMs because the whole channelmemory
		  controller... may be affected. Also, don't show errors for
		  empty DIMM slots.
		
		  get csrowchannel of the DIMM, in order to allow
		  incrementing the compat API counters
 Fill the RAM location data 
  Intel 32003210 Memory Controller kernel module
  Copyright (C) 2008-2009 Akamai Technologies, Inc.
  Portions by Hitoshi Mitake <h.mitake@gmail.com>.
  This file may be distributed under the terms of the
  GNU General Public License.
 Intel 3200 register addresses - device 0 function 0 - DRAM Controller 
 MCH Memory Mapped Register BAR 
 bits 35:14 
#define I3200_TOM		0xa0	 Top of Memory (16b)
		 
		  15:10 reserved
		   9:0  total populated physical memory
 bits 9:0 
 64MiB grain 
#define I3200_ERRSTS		0xc8	 Error Status Register (16b)
		 
		  15    reserved
		  14    Isochronous TBWRR Run Behind FIFO Full
		        (ITCV)
		  13    Isochronous TBWRR Run Behind FIFO Put
		        (ITSTV)
		  12    reserved
		  11    MCH Thermal Sensor Event
		        for SMISCISERR (GTSE)
		  10    reserved
		   9    LOCK to non-DRAM Memory Flag (LCKF)
		   8    reserved
		   7    DRAM Throttle Flag (DTF)
		   6:2  reserved
		   1    Multi-bit DRAM ECC Error Flag (DMERR)
		   0    Single-bit DRAM ECC Error Flag (DSERR)
 Intel  MMIO register space - device 0 function 0 - MMR space 
#define I3200_C0DRB	0x200	 Channel 0 DRAM Rank Boundary (16b x 4)
		 
		  15:10 reserved
		   9:0  Channel 0 DRAM Rank Boundary Address
 Channel 1 DRAM Rank Boundary (16b x 4) 
 bits 9:0 
 64MiB grain 
#define I3200_C0ECCERRLOG	0x280	 Channel 0 ECC Error Log (64b)
		 
		  63:48 Error Column Address (ERRCOL)
		  47:32 Error Row Address (ERRROW)
		  31:29 Error Bank Address (ERRBANK)
		  28:27 Error Rank Address (ERRRANK)
		  26:24 reserved
		  23:16 Error Syndrome (ERRSYND)
		  15: 2 reserved
		     1  Multiple Bit Error Status (MERRSTS)
		     0  Correctable Error Status (CERRSTS)
 Chan 1 ECC Error Log (64b) 
 P.95 of spec for details 
 8th byte of CAPID0 
 check DCD: Dual Channel Disable 
 check if both channels are filled 
	
	  Clear any error bits.
	  (Yes, we really clear bits by writing 1 to them.)
	
	  This is a mess because there is no atomic way to read all the
	  registers at once and the registers can transition from CE being
	  overwritten by UE.
	
	  If the error is the same for both reads then the first set
	  of reads is valid.  If there is a change then there is a CE
	  with no info and the second set of reads is valid and
	  should be UE info.
	
	  The dram rank boundary (DRB) reg values are boundary addresses
	  for each DRAM rank with a granularity of 64MB.  DRB regs are
	  cumulative; the last one will contain the total memory
	  contained in all ranks.
 get this far and it's successful 
 0 terminated list. 
 Ensure that the OPSTATE is set correctly for POLL or NMI 
  edac_mc kernel module
  (C) 2005-2007 Linux Networx (http:lnxi.com)
  This file may be distributed under the terms of the
  GNU General Public License.
  Written Doug Thompson <norsk5@xmission.com> www.softwarebitmaker.com
  (c) 2012-2013 - Mauro Carvalho Chehab
 	The entire API were re-written, and ported to use struct device
 MC EDAC Controls, setable by module parameter, and sysfs 
 Getter functions for above 
 this is temporary 
 notify edac_mc engine to reset the poll period 
 Parameter declarations for above 
  various constants for Memory Controllers
  EDAC sysfs CSROW data structures and methods
  We need it to avoid namespace conflicts between the legacy API
  and the per-dimmper-rank one
 Set of more default csrow<id> attribute showstore functions 
 showstore functions for DIMM Label attributes 
 if field has not been initialized, there is nothing to send 
 show function for dynamic chX_ce_count attribute 
 cwrow<id>attribute files 
 default attributes of the CSROW<id> object 
  possible dynamic channel DIMM Label attribute files
 Total possible dynamic DIMM Label attribute file table 
 possible dynamic channel ce_count attribute files 
 Total possible dynamic ce_count attribute file table 
 Only expose populated DIMMs 
	
	  Nothing to do, just unregister sysfs here. The mci
	  device owns the data and will also release it.
 Create a CSROW object under specifed edac_mc_device 
 Create a CSROW object under specifed edac_mc_device 
  Per-dimm (or per-rank) devices
 showstore functions for DIMM Label attributes 
 if field has not been initialized, there is nothing to send 
 dimmrank attribute files 
 attributes of the dimm<id>rank<id> object 
	
	  Nothing to do, just unregister sysfs here. The mci
	  device owns the data and will also release it.
 Create a DIMM object under specifed memory controller device 
  Memory controller device
 Memory scrubbing interface:
  A MC driver can limit the scrubbing bandwidth based on the CPU type.
  Therefore, ->set_sdram_scrub_rate should be made to return the actual
  bandwidth that is accepted or 0 when scrubbing is to be disabled.
  Negative value still means that an error has occurred while setting
  the scrub rate.
  ->get_sdram_scrub_rate() return value semantics same as above.
 default attribute files for the MCI object 
 default Control file 
 default Attribute files 
 memory scrubber attribute file 
 umode set later in is_visible 
  Create a new Memory Controller kobject instance,
 	mc<id> under the 'mc' directory
  Return:
 	0	Success
 	!0	Failure
 get the sysdevicessystemedac subsys reference 
 no put_device() here, free mci with _edac_mc_free() 
	
	  Create the dimmrank devices
 Only expose populated DIMMs 
  remove a Memory Controller instance
 only remove the device, but keep mci 
	
	  There's no container structure here, as this is just the mci
	  parent device, used to create the sysdevicesmc sysfs node.
	  So, there are no attributes on it.
  Initexit code for the module. Basically, createsremoves sysclassrc
 SPDX-License-Identifier: GPL-2.0
  EDAC driver for Intel(R) Xeon(R) Skylake processors
  Copyright (c) 2016, Intel Corporation.
  Debug macros
 Mask for 2^26 
 Mask for 2^29 
  List of PCI device ids that we need together with some device
  number and function numbers to tell which memory controller the
  device belongs to.
 Be sure that the device is enabled 
			
			  one of these devices per core, including cores
			  that don't exist on this SKU. Ignore any that
			  read a route table of zero, make sure all the
			  non-zero values match.
 Only the mcmtr on the first channel is effective 
 Simple sanity check for IO space or out of range 
 If point to another node, find it and start over 
 which bit used for both socket and channel interleave 
 Must handle channel first, then socket 
 Handle socket then channel. Preserve low bits from original address 
 C10 is autoprecharge, always set 
  Debug feature.
  Exercise the address decode logic by writing an address to
  syskerneldebugedacskx_testaddr.
 ADDRV + MemRd + Unknown channel 
 One corrected error 
CONFIG_EDAC_DEBUG
  skx_init:
 	make sure we are running on the correct cpu model
 	search for all the devices we need
 	check which DIMMs are present.
 Ensure that the OPSTATE is set correctly for POLL or NMI 
  Intel D82875P Memory Controller kernel module
  (C) 2003 Linux Networx (http:lnxi.com)
  This file may be distributed under the terms of the
  GNU General Public License.
  Written by Thayne Harbaugh
  Contributors:
 	Wang Zhenyu at intel.com
  $Id: edac_i82875p.c,v 1.5.2.11 20051005 00:43:44 dsp_llnl Exp $
  Note: E7210 appears same as D82875P - zhenyu.z.wang at intel.com
 PCI_DEVICE_ID_INTEL_82875_0 
 PCI_DEVICE_ID_INTEL_82875_6 
 four csrows in dual channel, eight in single channel 
 Intel 82875p register addresses - device 0 function 0 - DRAM Controller 
#define I82875P_EAP		0x58	 Error Address Pointer (32b)
					 
					  31:12 block address
					  11:0  reserved
#define I82875P_DERRSYN		0x5c	 DRAM Error Syndrome (8b)
					 
					   7:0  DRAM ECC Syndrome
#define I82875P_DES		0x5d	 DRAM Error Status (8b)
					 
					   7:1  reserved
					   0    Error channel 01
#define I82875P_ERRSTS		0xc8	 Error Status Register (16b)
					 
					  15:10 reserved
					   9    non-DRAM lock error (ndlock)
					   8    Sftwr Generated SMI
					   7    ECC UE
					   6    reserved
					   5    MCH detects unimplemented cycle
					   4    AGP access outside GA
					   3    Invalid AGP access
					   2    Invalid GA translation table
					   1    Unsupported AGP command
					   0    ECC CE
#define I82875P_ERRCMD		0xca	 Error Command (16b)
					 
					  15:10 reserved
					   9    SERR on non-DRAM lock
					   8    SERR on ECC UE
					   7    SERR on ECC CE
					   6    target abort on high exception
					   5    detect unimplemented cyc
					   4    AGP access outside of GA
					   3    SERR on invalid AGP access
					   2    invalid translation table
					   1    SERR on unsupported AGP command
					   0    reserved
 Intel 82875p register addresses - device 6 function 0 - DRAM Controller 
#define I82875P_PCICMD6		0x04	 PCI Command Register (16b)
					 
					  15:10 reserved
					   9    fast back-to-back - ro 0
					   8    SERR enable - ro 0
					   7    addrdata stepping - ro 0
					   6    parity err enable - ro 0
					   5    VGA palette snoop - ro 0
					   4    mem wr & invalidate - ro 0
					   3    special cycle - ro 0
					   2    bus master - ro 0
					   1    mem access dev6 - 0(dis),1(en)
					   0    IO access dev3 - 0(dis),1(en)
#define I82875P_BAR6		0x10	 Mem Delays Base ADDR Reg (32b)
					 
					  31:12 mem base addr [31:12]
					  11:4  address mask - ro 0
					   3    prefetchable - ro 0(non),1(pre)
					   2:1  mem type - ro 0
					   0    mem space - ro 0
 Intel 82875p MMIO register space - device 0 function 0 - MMR space 
 64MiB grain 
#define I82875P_DRB		0x00	 DRAM Row Boundary (8b x 8)
					 
					   7    reserved
					   6:0  64MiB row boundary addr
#define I82875P_DRA		0x10	 DRAM Row Attribute (4b x 8)
					 
					   7    reserved
					   6:4  row attr row 1
					   3    reserved
					   2:0  row attr row 0
					 
					  000 =  4KiB
					  001 =  8KiB
					  010 = 16KiB
					  011 = 32KiB
#define I82875P_DRC		0x68	 DRAM Controller Mode (32b)
					 
					  31:30 reserved
					  29    init complete
					  28:23 reserved
					  22:21 nr chan 00=1,01=2
					  20    reserved
					  19:18 Data Integ Mode 00=none,01=ecc
					  17:11 reserved
					  10:8  refresh mode
					   7    reserved
					   6:4  mode select
					   3:2  reserved
					   1:0  DRAM type 01=DDR
static struct pci_dev mci_pdev;	 init dev: in case that AGP code has
					  already registered driver
	
	  This is a mess because there is no atomic way to read all the
	  registers at once and the registers can transition from CE being
	  overwritten by UE.
	
	  If the error is the same then we can for both reads then
	  the first set of reads is valid.  If there is a change then
	  there is a CE no info and the second set of reads is valid
	  and should be UE info.
 Return 0 on success or 1 on failure. 
		 Intel tells BIOS developers to hide device 6 which
		  configures the overflow device access containing
		  the DRBs - this is where we expose device 6.
		  http:www.x86-secret.comarticlestweakpatpatsecrets-2.htm
 cache is irrelevant for PCI bus readswrites 
 NOTE: the ovrfl proc entry and pci_dev are intentionally left 
 Return 1 if dual channel mode is active.  Else return 0. 
 DRAM Data Integrity Mode 0=none,2=edac 
	 The dram row boundary (DRB) reg values are boundary address
	  for each DRAM row with a granularity of 32 or 64MB (singledual
	  channel operation).  DRB regs are cumulative; therefore DRB7 will
	  contain the total memory contained in all eight rows.
 not populated 
 I82875P_EAP has 4KiB reolution 
 clear counters 
	 Here we assume that we will never see multiple instances of this
	  type of memory controller.  The ID is therefore hardcoded to 0.
 allocating generic PCI control info 
 get this far and it's successful 
 NOTE: the ovrfl proc entry and pci_dev are intentionally left 
 returns count (>= 0), or negative on error 
CORRECT_BIOS 
 0 terminated list. 
 Ensure that the OPSTATE is set correctly for POLL or NMI 
lnxi.com) Thayne Harbaugh");
 SPDX-License-Identifier: GPL-2.0-only
 Intel i7 coreNehalem Memory Controller kernel module
  This driver supports the memory controllers found on the Intel
  processor families i7core, i7core 7xx8xx, i5core, Xeon 35xx,
  Xeon 55xx and Xeon 56xx also known as Nehalem, Nehalem-EP, Lynnfield
  and Westmere-EP.
  Copyright (c) 2009-2010 by:
 	 Mauro Carvalho Chehab
  Red Hat Inc. https:www.redhat.com
  Forked and adapted from the i5400_edac driver
  Based on the following public Intel datasheets:
  Intel Core i7 Processor Extreme Edition and Intel Core i7 Processor
  Datasheet, Volume 2:
 	http:download.intel.comdesignprocessordatashts320835.pdf
  Intel Xeon Processor 5500 Series Datasheet Volume 2
 	http:www.intel.comAssetsPDFdatasheet321322.pdf
  also available at:
  	http:www.arrownac.commanufacturersintelsnehalem5500-datasheet-v2.pdf
 Static vars 
  This is used for Nehalem-EP and Nehalem-EX devices, where the non-core
  registers start at bus 255, and are not reported by BIOS.
  We currently find devices with only 2 sockets. In order to support more QPI
  Quick Path Interconnect, just increment this number.
  Alter this version for the module when modifications are made
  Debug macros
  i7core Memory Controller Registers
 OFFSETS for Device 0 Function 0 
 OFFSETS for Device 3 Function 0 
  OFFSETS for Device 3 Function 4, as indicated on Xeon 5500 datasheet:
  http:www.arrownac.commanufacturersintelsnehalem5500-datasheet-v2.pdf
 OFFSETS for Device 3 Function 2, as indicated on Xeon 5500 datasheet 
 OFFSETS for Devices 4,5 and 6 Function 0 
 OFFSETS for Devices 4,5 and 6 Function 1 
  i7core structs
 Max DIMMS per channel 
 Error address mask 
 ECC corrected errors counts per udimm 
 ECC corrected errors counts per rdimm 
 DCLK Frequency used for computing scrub rate 
 Struct to control EDAC polling 
 Memory controller 
 Exists only for RDIMM 
 Channel 0 
 Channel 1 
 Channel 2 
 Generic Non-core registers 
	
	  This is the PCI device on i7core and on Xeon 35xx (8086:2c41)
	  On Xeon 55xx, however, it has a different id (8086:2c40). So,
	  the probing code needs to test for the other address in case of
	  failure of this one
	
	  This is the PCI device has an alternate address on some
	  processors like Core i7 860
 Memory controller 
 Exists only for RDIMM 
 Channel 0 
 Channel 1 
 Channel 2 
 Generic Non-core registers 
 0 terminated list. 
 	pci_device_id	table for which devices we are looking for
 0 terminated list. 
			Ancillary status routines
 MC_CONTROL bits 
 MC_STATUS bits 
 MC_MAX_DOD read functions 
			Memory check routines
 Get data from the MC register, function 0 
 Device 3 function 0 reads 
 FIXME: need to handle the error codes 
 Devices 4-6 function 0 
 Devices 4-6 function 1 
 DDR3 has 8 IO banks 
			Error insertion routines
 The i7core has independent error injection features per channel.
   However, to have a simpler code, we don't allow enabling error injection
   on more than one channel.
   Also, since a change at an inject parameter will be applied only at enable,
   we're disabling error injection on all write calls to the sysfs nodes that
   controls the error code injection.
  i7core inject inject.section
 	accept and store error injection inject.section value
 	bit 0 - refers to the lower 32-byte half cacheline
 	bit 1 - refers to the upper 32-byte half cacheline
  i7core inject.type
 	accept and store error injection inject.section value
 	bit 0 - repeat enable - Enable error repetition
 	bit 1 - inject ECC error
 	bit 2 - inject parity error
  i7core_inject_inject.eccmask_store
  The type of error (UECE) will depend on the inject.eccmask value:
    Any bits set to a 1 will flip the corresponding ECC bit
    Correctable errors can be injected by flipping 1 bit or the bits within
    a symbol pair (2 consecutive aligned 8-bit pairs - i.e. 7:0 and 15:8 or
    23:16 and 31:24). Flipping bits in two symbol pairs will cause an
    uncorrectable error to be injected.
  i7core_addrmatch
  The type of error (UECE) will depend on the inject.eccmask value:
    Any bits set to a 1 will flip the corresponding ECC bit
    Correctable errors can be injected by flipping 1 bit or the bits within
    a symbol pair (2 consecutive aligned 8-bit pairs - i.e. 7:0 and 15:8 or
    23:16 and 31:24). Flipping bits in two symbol pairs will cause an
    uncorrectable error to be injected.
  This routine prepares the Memory Controller for error injection.
  The error will be injected when some process tries to write to the
  memory that matches the given criteria.
  The criteria can be set in terms of a mask where dimm, rank, bank, page
  and col can be specified.
  A -1 value for any of the mask items will make the MCU to ignore
  that matching criteria for error injection.
  It should be noticed that the error will only happen after a write operation
  on a memory that matches the condition. if REPEAT_EN is not enabled at
  inject mask, then it will produce just one error. Otherwise, it will repeat
  until the injectmask would be cleaned.
  FIXME: This routine assumes that MAXNUMDIMMS value of MC_MAX_DOD
     is reliable enough to check if the MC is using the
     three channels. However, this is not clear at the datasheet.
 Sets pvt->inject.dimm mask 
 Sets pvt->inject.rank mask 
 Sets pvt->inject.bank mask 
 Sets pvt->inject.page mask 
 Sets pvt->inject.column mask 
	
	  bit    0: REPEAT_EN
	  bits 1-2: MASK_HALF_CACHELINE
	  bit    3: INJECT_ECC
	  bit    4: INJECT_ADDR_PARITY
 Unlock writes to registers - this register is write only 
	
	  This is something undocumented, based on my tests
	  Without writing 8 to this register, errors aren't injected. Not sure
	  why.
  inject_addrmatch device sysfs struct
  all_channel_counts sysfs struct
  inject sysfs attributes
	Device initialization routines: putget, initexit
 	i7core_put_all_devices	'put' all the devices that we have
 				reserved via 'get'
	
	  On Xeon 55xx, the Intel Quick Path Arch Generic Non-core pci buses
	  aren't announced by acpi. So, we need to use a legacy scan probing
	  to detect them
 	i7core_get_all_devices	Find and perform 'get' operation on the MCH's
 			devicefunctions we want to reference for this driver
 			Need to 'get' device 16 func 1 and func 2
	
	  On Xeon 55xx, the Intel QuickPath Arch Generic Non-core regs
	  is at addr 8086:2c40, instead of 8086:2c41. So, we need
	  to probe for the alternate address in case of failure
 pci_get_device will put it 
 pci_get_device will put it 
 End of list, leave 
 Sanity check 
 Be sure that the device is enabled 
	
	  As stated on driverspcisearch.c, the reference count for
	  @from is always decremented if it is not %NULL. So, as we need
	  to get all devices up to null, we need to do a get for the device
 Detect the processor family 
			Error check routines
 Updates CE counters if it is not the first time here 
 Updates CE counters 
 Store the new values 
updated the edac core 
Read DEV 3: FUN 2:  MC_COR_ECC_CNT regs directly
if the channel has 3 dimms
 This function is based on the device 3 function 4 registers as described on:
  Intel Xeon Processor 5500 Series Datasheet Volume 2
 	http:www.intel.comAssetsPDFdatasheet321322.pdf
  also available at:
  	http:www.arrownac.commanufacturersintelsnehalem5500-datasheet-v2.pdf
 Corrected test errors 
 Store the new values 
 Updates CE counters if it is not the first time here 
 Updates CE counters 
 Store the new values 
  According with tables E-11 and E-12 of chapter E.3.3 of Intel 64 and IA-32
  Architectures Software Developer’s Manual Volume 3B.
  Nehalem are defined as family 0x06, model 0x1a
  The MCA registers used here are the following ones:
      struct mce field	MCA Register
      m->status	MSR_IA32_MC8_STATUS
      m->addr		MSR_IA32_MC8_ADDR
      m->misc		MSR_IA32_MC8_MISC
  In the case of Nehalem, the error information is masked at .status and .misc
  fields
	
	  Call the helper to output message
	  FIXME: what to do if core_err_cnt > 1? Currently, it generates
	  only one event
 	i7core_check_error	Retrieve and process errors reported by the
 				hardware. Called by the Core module.
	
	  Now, let's increment CE error counts
  Check that logging is enabled and that this is the right type
  of error for us to handle.
	
	  Just let mcelog handle it if the error is
	  outside the memory controller
 Bank 8 registers are the only ones that we know how to handle 
 Advise mcelog that the errors were handled 
  Decode the DRAM Clock Frequency, be paranoid, make sure that all
  memory devices show the same speed, and if they don't then consider
  all speeds to be invalid.
 Check that a DIMM is present 
		
		  Pick the configured speed if it's available, otherwise
		  pick the DIMM speed, or we don't have a speed.
 First pass, speed was 0 
 Set speed if a valid speed is read 
 Otherwise we don't have a valid speed 
			
			  If we have a speed, check that all DIMMS are the same
			  speed, otherwise set the speed as invalid.
  The default DCLK frequency is used as a fallback if we
  fail to find anything reliable in the DMI. The value
  is taken straight from the datasheet.
  set_sdram_scrub_rate		This routine sets bytesec bandwidth scrub rate
 				to hardware according to SCRUBINTERVAL formula
 				found in datasheet.
 Get data from the MC register, function 2 
 Prepare to disable petrol scrub 
 Stop the patrol scrub engine 
 Get current status of scrub rate and set bit to disable 
		
		  Translate the desired scrub rate to a register value and
		  program the corresponding register value.
 Start the patrol scrub engine 
 Get current status of scrub rate and set bit to enable 
 Disable or enable scrubbing 
  get_sdram_scrub_rate		This routine convert current scrub rate value
 				into bytesec bandwidth according to
 				SCRUBINTERVAL formula found in datasheet.
 Get data from the MC register, function 2 
 Get current scrub control data 
 Mask highest 8-bits to 0 
 Calculate scrub rate value into bytesec bandwidth 
 Unlock writes to pci registers 
 Lock writes to pci registers 
 Disable scrubrate setting 
 Disable EDAC polling 
 Remove MC sysfs nodes 
 allocate a new MC control structure 
 Associates i7core_dev and mci for future usage 
	
	  FIXME: how to handle RDDR3 at MCI level? It is possible to have
	  Mixed RDDR3UDDR3 with Nehalem, provided that they are on different
	  memory channels
 Store pci devices at mci for faster access 
 Get dimm basic config 
 record ptr to the generic device 
 Enable scrubrate setting 
 add this new MC control structure to EDAC's list of MCs 
		 FIXME: perhaps some code should go here that disables error
		  reporting if we just enabled it
 Default error mask is any memory 
 allocating generic PCI control info 
 DCLK for scrub rate setting 
 	i7core_probe	Probe for ONE instance of device to see if it is
 			present.
 	return:
 		0 for FOUND a device
 		< 0 for error code
 get the pci devices we want to reserve for our use 
	
	  All memory controllers are allocated at the first pass.
	
	  Nehalem-EX uses a different memory controller. However, as the
	  memory controller is not visible on some NehalemNehalem-EP, we
	  need to indirectly probe via a X58 PCI device. The same devices
	  are found on (some) Nehalem-EX. So, on those machines, the
	  probe routine needs to return -ENODEV, as the actual Memory
	  Controller registers won't be detected.
 	i7core_remove	destructor for one instance of device
	
	  we have a trouble here: pdev value for removal will be wrong, since
	  it will point to the X58 register used to detect that the machine
	  is a Nehalem or upper design. However, due to the way several PCI
	  devices are grouped together to provide MC functionality, we need
	  to use a different method for releasing the devices
 Release PCI resources 
 	i7core_driver	pci_driver structure for this module
 	i7core_init		Module entry function
 			Try to initialize this module for its devices
 Ensure that the OPSTATE is set correctly for POLL or NMI 
 	i7core_exit()	Module exit function
 			Unregister the driver
www.redhat.com)");
 SPDX-License-Identifier: GPL-2.0
  Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 Registers Offset 
 Registers Fields 
	
	  In case both interrupts (uece) are to be found, use interrupt mode.
	  In case none of the interrupt are foud, use polling mode.
	  In case only one interrupt is found, use interrupt mode for it but
	  keep polling mode enable for the other.
  Freescale Memory Controller kernel module
  Support Power-based SoCs including MPC85xx, MPC86xx, MPC83xx and
  ARM-based Layerscape SoCs including LS2xxx and LS1021A. Originally
  split out from mpc85xx_edac EDAC driver.
  Parts Copyrighted (c) 2013 by Freescale Semiconductor, Inc.
  Author: Dave Jiang <djiang@mvista.com>
  2006-2007 (c) MontaVista Software, Inc. This file is licensed under
  the terms of the GNU General Public License version 2. This program
  is licensed "as is" without any warranty of any kind, whether express
  or implied.
 MC SYSFS parts 
 CONFIG_EDAC_DEBUG 
 MC Err device 
  Taken from table 8-55 in the MPC8641 User's Manual andor 9-61 in the
  MPC8572 User's Manual.  Each line represents a syndrome bit column as a
  64-bit value, but split into an upper and lower 32-bit chunk.  The labels
  below correspond to Freescale's manuals.
 MSB           LSB 
 [0:31]    [32:63] 
 Syndrome bit 7 
 Syndrome bit 0 
  Calculate the correct ECC value for a 64-bit value specified by high:low
  Create the syndrome code which is generated if the data line specified by
  'bit' failed.  Eg generate an 8-bit codes seen in Table 8-55 in the MPC8641
  User's Manual and 9-61 in the MPC8572 User's Manual.
	
	  Cycle through the upper or lower 32-bit portion of each value in
	  ecc_table depending on if 'bit' is in the upper or lower half of
	  64-bit data.
  Decode data and ecc syndrome to determine what went wrong
  Note: This can only decode single-bit errors
	
	  Calculate the ECC of the captured data and XOR it with the captured
	  ECC to find an ECC syndrome value we can search for
 Check if a data line is stuck... 
 If data is correct, check ECC bits for errors... 
 no more processing if not ECC bit errors 
 Mask off appropriate bits of syndrome based on bus width 
	
	  Analyze single-bit errors on 64-bit wide buses
	  TODO: Add support for 32-bit wide buses
 we are out of range 
 not populated 
	
	  Get the endianness of DDR controller registers.
	  Default is big endian.
 no ECC 
 store the original error disable bits 
 clear all error bits 
 store the original error management threshold 
 set threshold to 1 error per interrupt 
 register interrupts 
  EDAC PCI component
  Author: Dave Jiang <djiang@mvista.com>
  2007 (c) MontaVista Software, Inc. This file is licensed under
  the terms of the GNU General Public License version 2. This program
  is licensed "as is" without any warranty of any kind, whether express
  or implied.
 Alloc the needed control struct memory 
 Now much private space 
  find_edac_pci_by_dev()
  	scans the edac_pci list for a specific 'struct device '
 	return NULL if not found, or return control struct pointer
  add_edac_pci_to_global_list
  	Before calling this function, caller must assign a unique value to
  	edac_dev->pci_idx.
  	Return:
  		0 on success
  		1 on failure
 Determine if already on the list 
 Insert in ascending order by 'pci_idx', so find position 
  del_edac_pci_from_global_list
 	remove the PCI control struct from the global list
	 these are for safe removal of devices from global list while
	  NMI handlers may be traversing list
  edac_pci_workq_function()
  	periodic function that performs the operation
 	scheduled by a workq request, for a given PCI control struct
 if we are on a one second period, then use round 
 error unwind stack 
	 ensure the control struct is on the global list
	  if not, then leave
  edac_pci_generic_check
 	a Generic parity check API
 free running instance index counter 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2008 Nuovation System Designs, LLC
    Grant Erickson <gerickson@nuovations.com>
  This file implements a driver for monitoring and handling events
  associated with the IMB DDR2 ECC controller found in the AMCCIBM
  405EX[r], 440SP, 440SPe, 460EX, 460GT and 460SX.
  As realized in the 405EX[r], this controller features:
    - Support for registered- and non-registered DDR1 and DDR2 memory.
    - 32-bit or 16-bit memory interface with optional ECC.
      o ECC support includes:
        - 4-bit SECDED
        - Aligned-nibble error detect
        - Bypass mode
    - Two (2) memory banksranks.
    - Up to 1 GiB per bankrank in 32-bit mode and up to 512 MiB per
      bankrank in 16-bit mode.
  As realized in the 440SP and 440SPe, this controller changesadds:
    - 64-bit or 32-bit memory interface with optional ECC.
      o ECC support includes:
        - 8-bit SECDED
        - Aligned-nibble error detect
        - Bypass mode
    - Up to 4 GiB per bankrank in 64-bit mode and up to 2 GiB
      per bankrank in 32-bit mode.
  As realized in the 460EX and 460GT, this controller changesadds:
    - 64-bit or 32-bit memory interface with optional ECC.
      o ECC support includes:
        - 8-bit SECDED
        - Aligned-nibble error detect
        - Bypass mode
    - Four (4) memory banksranks.
    - Up to 16 GiB per bankrank in 64-bit mode and up to 8 GiB
      per bankrank in 32-bit mode.
  At present, this driver has ONLY been tested against the controller
  realization in the 405EX[r] on the AMCC Kilauea and Haleakala
  boards (256 MiB wo ECC memory soldered onto the board) and a
  proprietary board based on those designs (128 MiB ECC memory, also
  soldered onto the board).
  Dynamic feature detection and handling needs to be added for the
  other realizations of this controller listed above.
  Eventually, this driver will likely be adapted to the above variant
  realizations of this controller as well as broken apart to handle
  the other known ECC-capable controllers prevalent in other 4xx
  processors:
    - IBM SDRAM (405GP, 405CR and 405EP) "ibm,sdram-4xx"
    - IBM DDR1 (440GP, 440GX, 440EP and 440GR) "ibm,sdram-4xx-ddr"
    - Denali DDR1DDR2 (440EPX and 440GRX) "denali,sdram-4xx-ddr2"
  For this controller, unfortunately, correctable errors report
  nothing more than the beatcycle and bytelane the correction
  occurred on and the check bit group that covered the error.
  In contrast, uncorrectable errors also report the failing address,
  the bus master and the transaction direction (i.e. read or write)
  Regardless of whether the error is a CE or a UE, we report the
  following pieces of information in the driver-unique message to the
  EDAC subsystem:
    - Device tree path
    - Bank(s)
    - Check bit error group
    - Beat(s)lane(s)
 Preprocessor Definitions 
  Kernel logging without an EDAC instance
  Kernel logging with an EDAC instance
  Macros to convert bank configuration size enumerations into MiB and
  page values.
  The ibm,sdram-4xx-ddr2 Device Control Registers (DCRs) are
  indirectly accessed and have a base and length defined by the
  device tree. The base can be anything; however, we expect the
  length to be precisely two registers, the first for the address
  window and the second for the data window.
  Device tree interrupt indices
 Double-bit Error Detect 
 Single-bit Error Correct 
 Type Definitions 
  PPC4xx SDRAM memory controller private instance data
 Indirect DCR addressdata window mapping 
 Single-bit correctable error IRQ assigned 
 Double-bit detectable error IRQ assigned 
  Various status data gathered and manipulated when checking and
  reporting ECC status.
 Function Prototypes 
 Global Variables 
  Device tree node type and compatible tuples this driver can match
  on.
  TODO: The row and channel parameters likely need to be dynamically
  set based on the aforementioned variant controller realizations.
  Strings associated with PLB master IDs capable of being posted in
  SDRAM_BESR or SDRAM_WMIRQ on uncorrectable ECC errors.
  mfsdram - read and return controller register data
  @dcr_host: A pointer to the DCR mapping.
  @idcr_n: The indirect DCR register to read.
  This routine reads and returns the data associated with the
  controller's specified indirect DCR register.
  Returns the read data.
  mtsdram - write controller register data
  @dcr_host: A pointer to the DCR mapping.
  @idcr_n: The indirect DCR register to write.
  @value: The data to write.
  This routine writes the provided data to the controller's specified
  indirect DCR register.
  ppc4xx_edac_check_bank_error - check a bank for an ECC bank error
  @status: A pointer to the ECC status structure to check for an
           ECC bank error.
  @bank: The bank to check for an ECC error.
  This routine determines whether the specified bank has an ECC
  error.
  Returns true if the specified bank has an ECC error; otherwise,
  false.
  ppc4xx_edac_generate_bank_message - generate interpretted bank status message
  @mci: A pointer to the EDAC memory controller instance associated
        with the bank message being generated.
  @status: A pointer to the ECC status structure to generate the
           message from.
  @buffer: A pointer to the buffer in which to generate the
           message.
  @size: The size, in bytes, of space available in buffer.
  This routine generates to the provided buffer the portion of the
  driver-unique report message associated with the ECCESS[BKNER]
  field of the specified ECC status.
  Returns the number of characters generated on success; otherwise, <
  0 on error.
  ppc4xx_edac_generate_checkbit_message - generate interpretted checkbit message
  @mci: A pointer to the EDAC memory controller instance associated
        with the checkbit message being generated.
  @status: A pointer to the ECC status structure to generate the
           message from.
  @buffer: A pointer to the buffer in which to generate the
           message.
  @size: The size, in bytes, of space available in buffer.
  This routine generates to the provided buffer the portion of the
  driver-unique report message associated with the ECCESS[CKBER]
  field of the specified ECC status.
  Returns the number of characters generated on success; otherwise, <
  0 on error.
  ppc4xx_edac_generate_lane_message - generate interpretted byte lane message
  @mci: A pointer to the EDAC memory controller instance associated
        with the byte lane message being generated.
  @status: A pointer to the ECC status structure to generate the
           message from.
  @buffer: A pointer to the buffer in which to generate the
           message.
  @size: The size, in bytes, of space available in buffer.
  This routine generates to the provided buffer the portion of the
  driver-unique report message associated with the ECCESS[BNCE]
  field of the specified ECC status.
  Returns the number of characters generated on success; otherwise, <
  0 on error.
  ppc4xx_edac_generate_ecc_message - generate interpretted ECC status message
  @mci: A pointer to the EDAC memory controller instance associated
        with the ECCES message being generated.
  @status: A pointer to the ECC status structure to generate the
           message from.
  @buffer: A pointer to the buffer in which to generate the
           message.
  @size: The size, in bytes, of space available in buffer.
  This routine generates to the provided buffer the portion of the
  driver-unique report message associated with the ECCESS register of
  the specified ECC status.
  Returns the number of characters generated on success; otherwise, <
  0 on error.
  ppc4xx_edac_generate_plb_message - generate interpretted PLB status message
  @mci: A pointer to the EDAC memory controller instance associated
        with the PLB message being generated.
  @status: A pointer to the ECC status structure to generate the
           message from.
  @buffer: A pointer to the buffer in which to generate the
           message.
  @size: The size, in bytes, of space available in buffer.
  This routine generates to the provided buffer the portion of the
  driver-unique report message associated with the PLB-related BESR
  andor WMIRQ registers of the specified ECC status.
  Returns the number of characters generated on success; otherwise, <
  0 on error.
  ppc4xx_edac_generate_message - generate interpretted status message
  @mci: A pointer to the EDAC memory controller instance associated
        with the driver-unique message being generated.
  @status: A pointer to the ECC status structure to generate the
           message from.
  @buffer: A pointer to the buffer in which to generate the
           message.
  @size: The size, in bytes, of space available in buffer.
  This routine generates to the provided buffer the driver-unique
  EDAC report message from the specified ECC status.
  ppc4xx_ecc_dump_status - dump controller ECC status registers
  @mci: A pointer to the EDAC memory controller instance
        associated with the status being dumped.
  @status: A pointer to the ECC status structure to generate the
           dump from.
  This routine dumps to the kernel log buffer the raw and
  interpretted specified ECC status.
 DEBUG 
  ppc4xx_ecc_get_status - get controller ECC status
  @mci: A pointer to the EDAC memory controller instance
        associated with the status being retrieved.
  @status: A pointer to the ECC status structure to populate the
           ECC status with.
  This routine reads and masks, as appropriate, all the relevant
  status registers that deal with ibm,sdram-4xx-ddr2 ECC errors.
  While we read all of them, for correctable errors, we only expect
  to deal with ECCES. For uncorrectable errors, we expect to deal
  with all of them.
  ppc4xx_ecc_clear_status - clear controller ECC status
  @mci: A pointer to the EDAC memory controller instance
        associated with the status being cleared.
  @status: A pointer to the ECC status structure containing the
           values to write to clear the ECC status.
  This routine clears--by writing the masked (as appropriate) status
  values back to--the status registers that deal with
  ibm,sdram-4xx-ddr2 ECC errors.
  ppc4xx_edac_handle_ce - handle controller correctable ECC error (CE)
  @mci: A pointer to the EDAC memory controller instance
        associated with the correctable error being handled and reported.
  @status: A pointer to the ECC status structure associated with
           the correctable error being handled and reported.
  This routine handles an ibm,sdram-4xx-ddr2 controller ECC
  correctable error. Per the aforementioned discussion, there's not
  enough status available to use the full EDAC correctable error
  interface, so we just pass driver-unique message to the "no info"
  interface.
  ppc4xx_edac_handle_ue - handle controller uncorrectable ECC error (UE)
  @mci: A pointer to the EDAC memory controller instance
        associated with the uncorrectable error being handled and
        reported.
  @status: A pointer to the ECC status structure associated with
           the uncorrectable error being handled and reported.
  This routine handles an ibm,sdram-4xx-ddr2 controller ECC
  uncorrectable error.
  ppc4xx_edac_check - check controller for ECC errors
  @mci: A pointer to the EDAC memory controller instance
        associated with the ibm,sdram-4xx-ddr2 controller being
        checked.
  This routine is used to check and post ECC errors and is called by
  both the EDAC polling thread and this driver's CE and UE interrupt
  handler.
  ppc4xx_edac_isr - SEC (CE) and DED (UE) interrupt service routine
  @irq:    The virtual interrupt number being serviced.
  @dev_id: A pointer to the EDAC memory controller instance
           associated with the interrupt being handled.
  This routine implements the interrupt handler for both correctable
  (CE) and uncorrectable (UE) ECC errors for the ibm,sdram-4xx-ddr2
  controller. It simply calls through to the same routine used during
  polling to check, report and clear the ECC status.
  Unconditionally returns IRQ_HANDLED.
  ppc4xx_edac_get_dtype - return the controller memory width
  @mcopt1: The 32-bit Memory Controller Option 1 register value
           currently set for the controller, from which the width
           is derived.
  This routine returns the EDAC device type width appropriate for the
  current controller configuration.
  TODO: This needs to be conditioned dynamically through feature
  flags or some such when other controller variants are supported as
  the 405EX[r] is 16-32-bit and the others are 32-64-bit with the
  16- and 64-bit field definitionvalueenumeration (b1) overloaded
  among them.
  Returns a device type width enumeration.
  ppc4xx_edac_get_mtype - return controller memory type
  @mcopt1: The 32-bit Memory Controller Option 1 register value
           currently set for the controller, from which the memory type
           is derived.
  This routine returns the EDAC memory type appropriate for the
  current controller configuration.
  Returns a memory type enumeration.
  ppc4xx_edac_init_csrows - initialize driver instance rows
  @mci: A pointer to the EDAC memory controller instance
        associated with the ibm,sdram-4xx-ddr2 controller for which
        the csrows (i.e. banksranks) are being initialized.
  @mcopt1: The 32-bit Memory Controller Option 1 register value
           currently set for the controller, from which bank width
           and memory typ information is derived.
  This routine initializes the virtual "chip select rows" associated
  with the EDAC memory controller instance. An ibm,sdram-4xx-ddr2
  controller bankrank is mapped to a row.
  Returns 0 if OK; otherwise, -EINVAL if the memory bank size
  configuration cannot be determined.
 Establish the memory type and width 
 Establish EDAC mode 
	
	  Initialize each chip select row structure which correspond
	  1:1 with a controller bankrank.
		
		  Get the configuration settings for this
		  rowbankrank and skip disabled banks.
 Map the bank configuration size setting to pages. 
		
		  It's unclear exactly what grain should be set to
		  here. The SDRAM_ECCES register allows resolution of
		  an error down to a nibble which would potentially
		  argue for a grain of '1' byte, even though we only
		  know the associated address for uncorrectable
		  errors. This value is not used at present for
		  anything other than error reporting so getting it
		  wrong should be of little consequence. Other
		  possible values would be the PLB width (16), the
		  page size (PAGE_SIZE) or the memory width (2 or 4).
  ppc4xx_edac_mc_init - initialize driver instance
  @mci: A pointer to the EDAC memory controller instance being
        initialized.
  @op: A pointer to the OpenFirmware device tree node associated
       with the controller this EDAC instance is bound to.
  @dcr_host: A pointer to the DCR data containing the DCR mapping
             for this controller instance.
  @mcopt1: The 32-bit Memory Controller Option 1 register value
           currently set for the controller, from which ECC capabilities
           and scrub mode are derived.
  This routine performs initialization of the EDAC memory controller
  instance and related driver-private data associated with the
  ibm,sdram-4xx-ddr2 memory controller the instance is bound to.
  Returns 0 if OK; otherwise, < 0 on error.
 Initial driver pointers and private data 
 Initialize controller capabilities and configuration 
	
	  Update the actual capabilites based on the MCOPT1[MCHK]
	  settings. Scrubbing is only useful if reporting is enabled.
 Initialize strings 
 Initialize callbacks 
 Initialize chip select rows 
  ppc4xx_edac_register_irq - setup and register controller interrupts
  @op: A pointer to the OpenFirmware device tree node associated
       with the controller this EDAC instance is bound to.
  @mci: A pointer to the EDAC memory controller instance
        associated with the ibm,sdram-4xx-ddr2 controller for which
        interrupts are being registered.
  This routine parses the correctable (CE) and uncorrectable error (UE)
  interrupts from the device tree node and maps and assigns them to
  the associated EDAC memory controller instance.
  Returns 0 if OK; otherwise, -ENODEV if the interrupts could not be
  mapped and assigned.
  ppc4xx_edac_map_dcrs - locate and map controller registers
  @np: A pointer to the device tree node containing the DCR
       resources to map.
  @dcr_host: A pointer to the DCR data to populate with the
             DCR mapping.
  This routine attempts to locate in the device tree and map the DCR
  register resources associated with the controller's indirect DCR
  address and data windows.
  Returns 0 if the DCRs were successfully mapped; otherwise, < 0 on
  error.
 Get the DCR resource extent and sanity check the values. 
  Attempt to map the DCR extent. 
  ppc4xx_edac_probe - check controller and bind driver
  @op: A pointer to the OpenFirmware device tree node associated
       with the controller being probed for driver binding.
  This routine probes a specific ibm,sdram-4xx-ddr2 controller
  instance for binding with the driver.
  Returns 0 if the controller instance was successfully bound to the
  driver; otherwise, < 0 on error.
	
	  At this point, we only support the controller realized on
	  the AMCC PPC 405EX[r]. Reject anything else.
	
	  Next, get the DCR property and attempt to map it so that we
	  can probe the controller.
	
	  First determine whether ECC is enabled at all. If not,
	  there is no useful checking or monitoring that can be done
	  for this controller.
	
	  At this point, we know ECC is enabled, allocate an EDAC
	  controller instance and perform the appropriate
	  initialization.
	
	  We have a valid, initialized EDAC instance bound to the
	  controller. Attempt to register it with the EDAC subsystem
	  and, if necessary, register interrupts.
  ppc4xx_edac_remove - unbind driver from controller
  @op: A pointer to the OpenFirmware device tree node associated
       with the controller this EDAC instance is to be unboundremoved
       from.
  This routine unbinds the EDAC memory controller instance associated
  with the specified ibm,sdram-4xx-ddr2 controller described by the
  OpenFirmware device tree node passed as a parameter.
  Unconditionally returns 0.
  ppc4xx_edac_opstate_init - initialize EDAC reporting method
  This routine ensures that the EDAC memory controller reporting
  method is mapped to a sane value as the EDAC core defines the value
  to EDAC_OPSTATE_INVAL by default. We don't call the global
  opstate_init as that defaults to polling and we want interrupt as
  the default.
  ppc4xx_edac_init - drivermodule insertion entry point
  This routine is the drivermodule insertion entry point. It
  initializes the EDAC memory controller reporting state and
  registers the driver as an OpenFirmware device tree platform
  driver.
  ppc4xx_edac_exit - drivermodule removal entry point
  This routine is the drivermodule removal entry point. It
  unregisters the driver as an OpenFirmware device tree platform
  driver.
  Intel 82860 Memory Controller kernel module
  (C) 2005 Red Hat (http:www.redhat.com)
  This file may be distributed under the terms of the
  GNU General Public License.
  Written by Ben Woodard <woodard@redhat.com>
  shamelessly copied from and based upon the edac_i82875 driver
  by Thayne Harbaugh of Linux Networx. (http:lnxi.com)
 PCI_DEVICE_ID_INTEL_82860_0 
static struct pci_dev mci_pdev;	 init dev: in case that AGP code
					  has already registered driver
	
	  This is a mess because there is no atomic way to read all the
	  registers at once and the registers can transition from CE being
	  overwritten by UE.
	
	  If the error is the same for both reads then the first set of reads
	  is valid.  If there is a change then there is a CE no info and the
	  second set of reads is valid and should be UE info.
 DRAM Data Integrity Mode 0=none, 2=edac 
	 The group row boundary (GRA) reg values are boundary address
	  for each DRAM row with a granularity of 16MB.  GRA regs are
	  cumulative; therefore GRA15 will contain the total memory contained
	  in all eight rows.
 not populated 
 I82860_EAP has 4KiB reolution 
	
	  RDRAM has channels but these don't map onto the csrow abstraction.
	  According with the datasheet, there are 2 Rambus channels, supporting
	  up to 16 direct RDRAM devices.
	  The device groups from the GRA registers seem to map reasonably
	  well onto the notion of a chip select row.
	  There are 16 GRA registers and since the name is associated with
	  the channel and the GRA registers map to physical devices so we are
	  going to make 1 channel for group.
 I"m not sure about this but I think that all RDRAM is SECDED 
 clear counters 
	 Here we assume that we will never see multiple instances of this
	  type of memory controller.  The ID is therefore hardcoded to 0.
 allocating generic PCI control info 
 get this far and it's successful 
 returns count (>= 0), or negative on error 
 0 terminated list. 
 Ensure that the OPSTATE is set correctly for POLL or NMI 
www.redhat.com) "
 SPDX-License-Identifier: GPL-2.0-only
  Intel 7300 class Memory Controllers kernel module (Clarksboro)
  Copyright (c) 2010 by:
 	 Mauro Carvalho Chehab
  Red Hat Inc. https:www.redhat.com
  Intel 7300 Chipset Memory Controller Hub (MCH) - Datasheet
 	http:www.intel.comAssetsPDFdatasheet318082.pdf
  TODO: The chipset allow checking for PCI Express errors also. Currently,
 	 the driver covers only memory error errors
  This driver uses "csrows" EDAC attribute to represent DIMM slot#
  Alter this version for the I7300 module when modifications are made
  i7300 Limit constants Structs and static vars
  Memory topology is organized as:
 	Branch 0 - 2 channels: channels 0 and 1 (FDB0 PCI dev 21.0)
 	Branch 1 - 2 channels: channels 2 and 3 (FDB1 PCI dev 22.0)
  Each channel can have to 8 DIMM sets (called as SLOTS)
  Slots should generally be filled in pairs
 	Except on Single Channel mode of operation
 		just slot 0channel0 filled on this mode
 	On normal operation mode, the two channels on a branch should be
 		filled together for the same SLOT#
  When in mirrored mode, Branch 1 replicate memory at Branch 0, so, the four
 		channels on both branches should be filled
 Limits for i7300 
 Device name and register DID (Device ID) 
 name for this device 
 DID for the branchmap,control 
 Table of devices attributes supported by this driver 
 size, 0 means not present  
 driver private data structure 
 16.0 
 16.1 
 16.2 
 21.0  and 22.0 
 top of low memory 
 AMB BAR 
 Report several settings 
 Memory Interleave Reg
 Memory Technlogy Reg 
 AMB present regs 
 DIMM information matrix, allocating architecture maximums 
 Temporary buffer for use when preparing error messages 
 FIXME: Why do we need to have this static? 
  i7300 Register definitions for memory enumeration
  Device 16,
  Function 0: System Address (not documented)
  Function 1: Memory Branch Map, Control, Errors Register
 OFFSETS for Function 0 
 AMB Mem Mapped Reg Region Base 
 Max Channel Number 
 Max DIMM PER Channel Number 
 OFFSETS for Function 1 
  Note: Other Intel EDAC drivers use AMBPRESENT to identify if the available
  memory. From datasheet item 7.3.1 (FB-DIMM technology & organization), it
  seems that we cannot use this information directly for the same usage.
  Each memory slot may have up to 2 AMB interfaces, one for income and another
  for outcome interface to the next slot.
  For now, the driver just stores the AMB present registers, but rely only at
  the MTR info to detect memory.
  Datasheet is also not clear about how to map each AMBPRESENT registers to
  one of the 4 available channels.
  Defines to extract the vaious fields from the
 	MTRx - Memory Technology Registers
  i7300 Register definitions for error detection
  Device 16.1: FBD Error Registers
  Device 16.2: Global Error Registers
  i7300 Functions related to error detection
  get_err_from_table() - Gets the error message from a table
  @table:	table name (array of char )
  @size:	number of elements at the table
  @pos:	position of the element to be returned
  This is a small routine that gets the pos-th element of a table. If the
  element doesn't exist (or it is empty), it returns "reserved".
  Instead of calling it directly, the better is to call via the macro
  GET_ERR_FROM_TABLE(), that automatically checks the table size via
  ARRAY_SIZE() macro
  i7300_process_error_global() - Retrieve the hardware error information from
 				  the hardware global error registers and
 				  sends it to dmesg
  @mci: struct mem_ctl_info pointer
 read in the 1st FATAL error register 
 Clear the error bit 
 Clear the error bit 
  i7300_process_fbd_error() - Retrieve the hardware error information from
 			       the FBD error registers and sends it via
 			       EDAC error API calls
  @mci: struct mem_ctl_info pointer
 read in the 1st FATAL error register 
 Clean the error register 
 read in the 1st NON-FATAL error register 
 Second channel ? 
 Clear the error bit 
 Form out message 
  i7300_check_error() - Calls the error checking subroutines
  @mci: struct mem_ctl_info pointer
  i7300_clear_error() - Clears the error registers
  @mci: struct mem_ctl_info pointer
	
	  All error values are RWC - we need to read and write 1 to the
	  bit that we want to cleanup
 Clear global error registers 
 Clear FBD error registers 
  i7300_enable_error_reporting() - Enable the memory reporting logic at the
 				    hardware
  @mci: struct mem_ctl_info pointer
 Read the FBD Error Mask Register 
 Enable with a '0' 
  i7300 Functions related to memory enumberation
  decode_mtr() - Decodes the MTR descriptor, filling the edac structs
  @pvt: pointer to the private data struct used by i7300 driver
  @slot: DIMM slot (0 to 7)
  @ch: Channel number within the branch (0 or 1)
  @branch: Branch number (0 or 1)
  @dinfo: Pointer to DIMM info where dimm size is stored
  @dimm: Pointer to the struct dimm_info that corresponds to that element
 Determine if there is a DIMM present in this DIMM slot 
	 Start with the number of bits for a Bank
 Add thenumber of ROW bits 
 add the number of COLUMN bits 
 add the number of RANK bits 
 add 64 bits per DIMM 
 divide by 2^^20 
 8 bits per bytes 
	
	  The type of error detection actually depends of the
	  mode of operation. When it is just one single memory chip, at
	  socket 0, channel 0, it uses 8-byte-over-32-byte SECDED+ code.
	  In normal or mirrored mode, it uses Lockstep mode,
	  with the possibility of using an extended algorithm for x8 memories
	  See datasheet Sections 7.3.6 to 7.3.8
 ask what device type on this row 
  print_dimm_size() - Prints dump of the memory organization
  @pvt: pointer to the private data struct used by i7300 driver
  Useful for debug. If debug is disabled, this routine do nothing
  i7300_init_csrows() - Initialize the 'csrows' table within
 			 the mci control structure with the
 			 addressing of memory.
  @mci: struct mem_ctl_info pointer
 Get the AMB present registers for the four channels 
 Read and dump branch 0's MTRs 
 Get the set of MTR[0-7] regs by each branch 
 if no DIMMS on this row, continue 
  decode_mir() - Decodes Memory Interleave Register (MIR) info
  @mir_no: number of the MIR register to decode
  @mir: array with the MIR data cached on the driver
  i7300_get_mc_regs() - Get the contents of the MC enumeration registers
  @mci: struct mem_ctl_info pointer
  Data read is cached internally for its usage when needed
 Get the Branch Map regs 
 Get memory controller settings 
 Get Memory Interleave Range registers 
 Decode the MIR regs 
	 Go and determine the size of each DIMM and place in an
  i7300 Functions related to device proberelease
  i7300_put_devices() - Release the PCI devices
  @mci: struct mem_ctl_info pointer
 Decrement usage count for devices 
  i7300_get_devices() - Find and perform 'get' operation on the MCH's
 			 devicefunctions we want to reference for this driver
  @mci: struct mem_ctl_info pointer
  Access and prepare the several devices for usage:
  I7300 devices used by this driver:
     Device 16, functions 0,1 and 2:	PCI_DEVICE_ID_INTEL_I7300_MCH_ERR
     Device 21 function 0:		PCI_DEVICE_ID_INTEL_I7300_MCH_FB0
     Device 22 function 0:		PCI_DEVICE_ID_INTEL_I7300_MCH_FB1
 Attempt to 'get' the MCH register we want 
 Store device 16 funcs 1 and 2 
 At least one device was not found 
  i7300_init_one() - Probe for one instance of the device
  @pdev: struct pci_dev pointer
  @id: struct pci_device_id pointer - currently unused
 wake up device 
 We only are looking for func 0 of the set 
 allocate a new MC control structure 
 record ptr  to the generic device 
 Record this device in our private 
 'get' the pci devices we want to reserve for our use 
 Set the function pointer to an actual operation function 
	 initialize the MC control structure 'csrows' table
 no csrows found 
 add this new MC control structure to EDAC's list of MCs 
		 FIXME: perhaps some code should go here that disables error
		  reporting if we just enabled it
 allocating generic PCI control info 
 Error exit unwinding stack 
  i7300_remove_one() - Remove the driver
  @pdev: struct pci_dev pointer
 retrieve references to resources, and free those resources 
  pci_device_id: table for which devices we are looking for
  Has only 8086:360c PCI ID
 0 terminated list. 
  i7300_driver: pci_driver structure for this module
  i7300_init() - Registers the driver
 Ensure that the OPSTATE is set correctly for POLL or NMI 
  i7300_init() - Unregisters the driver
www.redhat.com)");
