  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  Copyright (C) 2012 Cavium, Inc.
  Copyright (C) 2009 Wind River Systems,
    written by Ralf Baechle <ralf@linux-mips.org>
 'Tags' are block 0, 'Data' is block 1
 We poll 
 We poll 
 OCTEON II 
 SPDX-License-Identifier: GPL-2.0-only
  HID Sensors Driver
  Copyright (c) 2012, Intel Corporation.
  struct sensor_hub_data - Hold a instance data for a HID hub device
  @mutex:		Mutex to serialize synchronous request.
  @lock:		Spin lock to protect pending request structure.
  @dyn_callback_list:	Holds callback function
  @dyn_callback_lock:	spin lock to protect callback list
  @hid_sensor_hub_client_devs:	Stores all MFD cells for a hub instance.
  @hid_sensor_client_cnt: Number of MFD cells, (no of sensors attached).
  @ref_cnt:		Number of MFD clients have opened this device
  struct hid_sensor_hub_callbacks_list - Stores callback list
  @list:		list head.
  @usage_id:		usage id for a physical device.
  @hsdev:		Stored hid instance for current hub device.
  @usage_callback:	Stores registered callback functions.
  @priv:		Private data for a physical device.
	
	  If there is a handler registered for the collection type, then
	  it will handle all reports for sensors in this collection. If
	  there is also an individual sensor handler registration, then
	  we want to make sure that the reports are directed to collection
	  handler, as this may be a fusion sensor. So add collection handlers
	  to the beginning of the list, so that they are matched first.
 calculate number of bytes required to read this field 
 Initialize with defaults 
  Handle raw report as sent by device
 Skip report id 
	
	  Checks if the report descriptor of Thinkpad Helix 2 has a logical
	  minimum for magnetic flux axis greater than the maximum.
 Sets negative logical minimum for mag x, y and z 
 SPDX-License-Identifier: GPL-2.0-or-later
  HID driver for Holtek keyboard
  Copyright (c) 2012 Tom Harwood
 Holtek based keyboards (USB ID 04d9:a055) have the following issues:
  - The report descriptor specifies an excessively large number of consumer
    usages (2^15), which is more than HID_MAX_USAGES. This prevents proper
    parsing of the report descriptor.
  - The report descriptor reports on capsscrollnum lock key presses, but
    doesn't have an LED output usage block.
  The replacement descriptor below fixes the number of consumer usages,
  and provides an LED output usage block. LED output events are redirected
  to the boot interface.
 Original report descriptor, with reduced number of consumer usages 
  Usage Page (Desktop),                         
  Usage (Sys Control),                          
  Collection (Application),                     
      Report ID (1),                            
      Usage Minimum (Sys Power Down),           
      Usage Maximum (Sys Wake Up),              
      Logical Minimum (0),                      
      Logical Maximum (1),                      
      Report Count (3),                         
      Report Size (1),                          
      Input (Variable),                         
      Report Count (1),                         
      Report Size (5),                          
      Input (Constant),                         
  End Collection,                               
  Usage Page (Consumer),                        
  Usage (Consumer Control),                     
  Collection (Application),                     
      Report ID (2),                            
      Usage Minimum (00h),                      
      Usage Maximum (0x2FFF), previously 0x7FFF 
      Logical Minimum (0),                      
      Logical Maximum (0x2FFF),previously 0x7FFF
      Report Count (1),                         
      Report Size (16),                         
      Input,                                    
  End Collection,                               
  Usage Page (Desktop),                         
  Usage (Keyboard),                             
  Collection (Application),                     
      Report ID (3),                            
      Report Count (56),                        
      Report Size (1),                          
      Logical Minimum (0),                      
      Logical Maximum (1),                      
      Usage Page (Keyboard),                    
      Usage Minimum (KB Leftcontrol),           
      Usage Maximum (KB Right GUI),             
      Usage Minimum (None),                     
      Usage Maximum (KB Lboxbracket And Lbrace),
      Input (Variable),                         
  End Collection,                               
  Usage Page (Desktop),                         
  Usage (Keyboard),                             
  Collection (Application),                     
      Report ID (4),                            
      Report Count (56),                        
      Report Size (1),                          
      Logical Minimum (0),                      
      Logical Maximum (1),                      
      Usage Page (Keyboard),                    
      Usage Minimum (KB Rboxbracket And Rbrace),
      Usage Maximum (KP Equals),                
      Input (Variable),                         
  End Collection                                
 LED usage for the boot protocol interface 
  Usage Page (Desktop),                         
  Usage (Keyboard),                             
  Collection (Application),                     
      Usage Page (LED),                         
      Usage Minimum (01h),                      
      Usage Maximum (03h),                      
      Logical Minimum (0),                      
      Logical Maximum (1),                      
      Report Size (1),                          
      Report Count (3),                         
      Output (Variable),                        
      Report Count (5),                         
      Output (Constant),                        
  End Collection                                
 Locate the boot interface, to receive the LED change events 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for PenMount touchscreens
   Copyright (c) 2014 Christian Gmeiner <christian.gmeiner <at> gmail.com>
   based on hid-penmount copyrighted by
     PenMount Touch Solutions <penmount <at> seed.net.tw>
 SPDX-License-Identifier: GPL-2.0-or-later
  Roccat Arvo driver for Linux
  Copyright (c) 2011 Stefan Achatz <erazor_de@users.sourceforge.net>
  Roccat Arvo is a gamer keyboard with 5 macro keys that can be configured in
  5 profiles.
 retval is 1-5 on success, < 0 on error 
 SPDX-License-Identifier: GPL-2.0
  HID driver for Xiaomi Mi Dual Mode Wireless Mouse Silent Edition
  Copyright (c) 2021 Ilya Skriblovsky
 Fixed Mi Silent Mouse report descriptor 
 Button's Usage Maximum changed from 3 to 5 to make side buttons work 
  Usage Page (Desktop),               
  Usage (Mouse),                      
  Collection (Application),           
      Report ID (3),                  
      Usage (Pointer),                
      Collection (Physical),          
          Usage Page (Button),        
          Usage Minimum (01h),        
 X  
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Size (1),            
          Report Count (5),           
          Input (Variable),           
          Report Size (3),            
          Report Count (1),           
          Input (Constant),           
          Usage Page (Desktop),       
          Usage (X),                  
          Usage (Y),                  
          Logical Minimum (-127),     
          Logical Maximum (127),      
          Report Size (8),            
          Report Count (2),           
          Input (Variable, Relative), 
          Usage (Wheel),              
          Logical Minimum (-127),     
          Logical Maximum (127),      
          Report Size (8),            
          Report Count (1),           
          Input (Variable, Relative), 
      End Collection,                 
  End Collection,                     
  Usage Page (FF01h),                 
  Usage (01h),                        
  Collection (Application),           
      Report ID (5),                  
      Usage (05h),                    
      Logical Minimum (0),            
      Logical Maximum (255),          
      Report Size (8),                
      Report Count (4),               
      Feature (Variable),             
  End Collection                      
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for some ezkey "special" devices
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2006-2007 Jiri Kosina
   Copyright (c) 2008 Jiri Slaby
	
	  this keyboard has a scrollwheel implemented in
	  totally broken way. We map this usage temporarily
	  to HWHEEL and handle it in the event quirk handler
 handle the temporary quirky mapping to HWHEEL 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for the Prodikeys PC-MIDI Keyboard
   providing midi & extra multimedia keys functionality
   Copyright (c) 2009 Don Prince <dhprince.devel@yahoo.co.uk>
   Controls for Octave Shift UpDown, Channel, and
   Sustain Duration available via sysfs.
 pcmidi device context 
 Output routine for the sysfs channel file 
 Input routine for the sysfs channel file 
 Output routine for the sysfs sustain file 
 Input routine for the sysfs sustain file 
 Output routine for the sysfs octave file 
 Input routine for the sysfs octave file 
 should never get here 
KEY_MAIL or octave down
 octave down 
KEY_WWW or sustain
 sustain onoff
 continue key processing 
 note on 
 1001nnnn 
 force note on 
 note off 
 1000nnnn 
 break keys 
 make keys 
 Fn lock
 midi launcher..send a key (qwerty) or not? 
 KEY_MESSENGER or octave up 
 midi keys (qwerty)
 midi keyboard (musical)
 multimediamidi keys (qwerty)
	 reassigned functionality for NA keys
		MY PICTURES =>	KEY_WORDPROCESSOR
		MY MUSIC=>	KEY_SPREADSHEET
 only set up ONCE for interace 1 
 only set up ONCE for interace 1 
 only set up midi device ONCE for interace 1 
 Setup sound card 
 Setup sound device 
 Set up rawmidi 
 create sysfs variables 
 register it 
  PC-MIDI report descriptor for report id is wrong.
 report 4: was 0x10 report count 
 midi keys (qwerty)
 midi keyboard (musical)
 extramidi keys (qwerty)
 hid_parse cleared all the quirks 
 SPDX-License-Identifier: GPL-2.0-or-later
  MSI GT683R led driver
  Copyright (c) 2014 Janne Kanniainen <janne.kanniainen@gmail.com>
  GT683R_LED_OFF: all LEDs are off
  GT683R_LED_AUDIO: LEDs brightness depends on sound level
  GT683R_LED_BREATHING: LEDs brightness varies at human breathing rate
  GT683R_LED_NORMAL: LEDs are fully on when enabled
 SPDX-License-Identifier: GPL-2.0-or-later
  Roccat Savu driver for Linux
  Copyright (c) 2012 Stefan Achatz <erazor_de@users.sourceforge.net>
 Roccat Savu is a gamer mouse with macro keys that can be configured in
  5 profiles.
 SPDX-License-Identifier: GPL-2.0-or-later
  Roccat common functions for device specific drivers
  Copyright (c) 2011 Stefan Achatz <erazor_de@users.sourceforge.net>
 SPDX-License-Identifier: GPL-2.0-or-later
   Force feedback support for GreenAsia (Product ID 0x12) based devices
   The devices are distributed under various names and the same USB device ID
   can be used in many game controllers.
   0e8f:0012 "GreenAsia Inc.    USB Joystick     "
    - tested with MANTA Warior MM816 and SpeedLink Strike2 SL-6635.
   Copyright (c) 2008 Lukasz Lubojanski <lukasz@lubojanski.info>
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for various devices which are apparently based on the same chipset
   from certain vendor which produces chips that contain wrong LogicalMaximum
   value in their HID report descriptor. Currently supported devices are:
     Ortek PKB-1700
     Ortek WKB-2000
     iHome IMAC-A210S
     Skycable wireless presenter
   Copyright (c) 2010 Johnathon Harris <jmharris@gmail.com>
   Copyright (c) 2011 Jiri Kosina
 SPDX-License-Identifier: GPL-2.0-or-later
  Roccat driver for Linux
  Copyright (c) 2010 Stefan Achatz <erazor_de@users.sourceforge.net>
  Module roccat is a char device used to report special events of roccat
  hardware to userland. These events include requests for on-screen-display of
  profile or dpi settings or requests for execution of macro sequences that are
  not stored in device. The information in these events depends on hid device
  implementation and contains data that is not available in a single hid event
  or else hidraw could have been used.
  It is inspired by hidraw, but uses only one circular buffer for all readers.
 should be a power of 2 for performance reason 
 protects modifications of readers list 
	
	  circular_buffer has one writer and multiple readers with their own
	  read pointers
 protects modifications of devices array 
 no data? 
 wait for data 
 here we either have data or a reason to return if retval is set 
	
	  If report is larger than requested amount of data, rest of report
	  is lost!
 power on device on adding first reader 
 new reader doesn't get old events 
 removing last reader 
  roccat_report_event() - output data to readers
  @minor: minor device number returned by roccat_connect()
  @data: pointer to data
  Return value is zero on success, a negative error code on failure.
  This is called from interrupt handler.
 passing NULL is safe 
		
		  As we already inserted one element, the buffer can't be
		  empty. If start and end are equal, buffer is full and we
		  increase start, so that slow reader misses one event, but
		  gets the newer ones in the right order.
  roccat_connect() - create a char device for special event output
  @class: the class thats used to create the device. Meant to hold device
  specific sysfs attributes.
  @hid: the hid device the char device should be connected to.
  @report_size: size of reports
  Return value is minor device number in Range [0, ROCCAT_MAX_DEVICES] on
  success, a negative error code on failure.
 roccat_disconnect() - remove char device from hid device
  @minor: the minor device number returned by roccat_connect()
 TODO exist maybe not needed 
 SPDX-License-Identifier: GPL-2.0-or-later
  HID driver for zydacron remote control
  Copyright (c) 2010 Don Prince <dhprince.devel@yahoo.co.uk>
 Zydacron remote control has an invalid HID report descriptor,
 that needs fixing before we can parse it.
 report 2 
 report 3 
 report 4 
 break keys 
 SPDX-License-Identifier: GPL-2.0+
   LED & force feedback support for BigBen Interactive
   0x146b:0x0902 "Bigben Interactive Bigben Game Pad"
   "Kid-friendly Wired Controller" PS3OFMINIPAD SONY
   sold for use with the PS3
   Copyright (c) 2018 Hanno Zulla <kontakt@hanno.de>
  The original descriptor for 0x146b:0x0902
    0x05, 0x01,         Usage Page (Generic Desktop Ctrls)
    0x09, 0x05,         Usage (Game Pad)
    0xA1, 0x01,         Collection (Application)
    0x15, 0x00,           Logical Minimum (0)
    0x25, 0x01,           Logical Maximum (1)
    0x35, 0x00,           Physical Minimum (0)
    0x45, 0x01,           Physical Maximum (1)
    0x75, 0x01,           Report Size (1)
    0x95, 0x0D,           Report Count (13)
    0x05, 0x09,           Usage Page (Button)
    0x19, 0x01,           Usage Minimum (0x01)
    0x29, 0x0D,           Usage Maximum (0x0D)
    0x81, 0x02,           Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
    0x95, 0x03,           Report Count (3)
    0x81, 0x01,           Input (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)
    0x05, 0x01,           Usage Page (Generic Desktop Ctrls)
    0x25, 0x07,           Logical Maximum (7)
    0x46, 0x3B, 0x01,     Physical Maximum (315)
    0x75, 0x04,           Report Size (4)
    0x95, 0x01,           Report Count (1)
    0x65, 0x14,           Unit (System: English Rotation, Length: Centimeter)
    0x09, 0x39,           Usage (Hat switch)
    0x81, 0x42,           Input (Data,Var,Abs,No Wrap,Linear,Preferred State,Null State)
    0x65, 0x00,           Unit (None)
    0x95, 0x01,           Report Count (1)
    0x81, 0x01,           Input (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)
    0x26, 0xFF, 0x00,     Logical Maximum (255)
    0x46, 0xFF, 0x00,     Physical Maximum (255)
    0x09, 0x30,           Usage (X)
    0x09, 0x31,           Usage (Y)
    0x09, 0x32,           Usage (Z)
    0x09, 0x35,           Usage (Rz)
    0x75, 0x08,           Report Size (8)
    0x95, 0x04,           Report Count (4)
    0x81, 0x02,           Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
    0x06, 0x00, 0xFF,     Usage Page (Vendor Defined 0xFF00)
    0x09, 0x20,           Usage (0x20)
    0x09, 0x21,           Usage (0x21)
    0x09, 0x22,           Usage (0x22)
    0x09, 0x23,           Usage (0x23)
    0x09, 0x24,           Usage (0x24)
    0x09, 0x25,           Usage (0x25)
    0x09, 0x26,           Usage (0x26)
    0x09, 0x27,           Usage (0x27)
    0x09, 0x28,           Usage (0x28)
    0x09, 0x29,           Usage (0x29)
    0x09, 0x2A,           Usage (0x2A)
    0x09, 0x2B,           Usage (0x2B)
    0x95, 0x0C,           Report Count (12)
    0x81, 0x02,           Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
    0x0A, 0x21, 0x26,     Usage (0x2621)
    0x95, 0x08,           Report Count (8)
    0xB1, 0x02,           Feature (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile)
    0x0A, 0x21, 0x26,     Usage (0x2621)
    0x91, 0x02,           Output (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile)
    0x26, 0xFF, 0x03,     Logical Maximum (1023)
    0x46, 0xFF, 0x03,     Physical Maximum (1023)
    0x09, 0x2C,           Usage (0x2C)
    0x09, 0x2D,           Usage (0x2D)
    0x09, 0x2E,           Usage (0x2E)
    0x09, 0x2F,           Usage (0x2F)
    0x75, 0x10,           Report Size (16)
    0x95, 0x04,           Report Count (4)
    0x81, 0x02,           Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
    0xC0,               End Collection
  The fixed descriptor for 0x146b:0x0902
  - map buttons according to gamepad.rst
  - assign right stick from ZRz to RxRy
  - map previously unused analog trigger data to ZRZ
  - simplify feature and output descriptor
 Usage Page (Generic Desktop Ctrls) 
 Usage (Game Pad) 
 Collection (Application) 
   Logical Minimum (0) 
   Logical Maximum (1) 
   Physical Minimum (0) 
   Physical Maximum (1) 
   Report Size (1) 
   Report Count (13) 
   Usage Page (Button) 
   Usage (BTN_WEST) 
   Usage (BTN_SOUTH) 
   Usage (BTN_EAST) 
   Usage (BTN_NORTH) 
   Usage (BTN_TL) 
   Usage (BTN_TR) 
   Usage (BTN_TL2) 
   Usage (BTN_TR2) 
   Usage (BTN_SELECT) 
   Usage (BTN_START) 
   Usage (BTN_THUMBL) 
   Usage (BTN_THUMBR) 
   Usage (BTN_MODE) 
   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position) 
   Report Size (1) 
   Report Count (3) 
   Input (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position) 
   Usage Page (Generic Desktop Ctrls) 
   Logical Maximum (7) 
   Physical Maximum (315) 
   Report Size (4) 
   Report Count (1) 
   Unit (System: English Rotation, Length: Centimeter) 
   Usage (Hat switch) 
   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,Null State) 
   Unit (None) 
   Report Count (1) 
   Input (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position) 
   Logical Maximum (255) 
   Physical Maximum (255) 
   Usage (X) 
   Usage (Y) 
   Usage (Rx) 
   Usage (Ry) 
   Report Size (8) 
   Report Count (4) 
   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position) 
   Report Count (10) 
   Input (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position) 
   Usage Page (Generic Desktop Ctrls) 
   Logical Maximum (255) 
   Physical Maximum (255) 
   Usage (Z) 
   Usage (Rz) 
   Report Count (2) 
   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position) 
   Report Count (8) 
   Input (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position) 
   Usage Page (Vendor Defined 0xFF00) 
   Feature (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile) 
   Usage (0x2621) 
   Report Count (8) 
   Output (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile) 
   Usage (0x2621) 
   Report Count (8) 
   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position) 
 End Collection 
 LED1 = 1 .. LED4 = 8 
 right motor offon 01 
 left motor force 0-255 
 1 = led message 
 reserved value, always 8 
 padding 
 padding 
 padding 
 padding 
 padding 
 2 = rumble effect message 
 reserved value, always 8 
 duration 0-254 (255 = nonstop) 
 padding 
 padding 
 padding 
 initial state: LED1 is on, no rumble effect 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID support for Linux
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2007-2008 Oliver Neukum
   Copyright (c) 2006-2012 Jiri Kosina
   Copyright (c) 2012 Henrik Rydberg
	
	  If any other driver wants the device, leave the device to this other
	  driver.
 SPDX-License-Identifier: GPL-2.0
  HID support for Vivaldi Keyboard
  Copyright 2020 Google LLC.
  Author: Sean O'Brien <seobrien@chromium.org>
 SPDX-License-Identifier: GPL-2.0-or-later
  Roccat Pyra driver for Linux
  Copyright (c) 2010 Stefan Achatz <erazor_de@users.sourceforge.net>
  Roccat Pyra is a mobile gamer mouse which comes in wired and wireless
  variant. Wireless variant is not tested.
  Userland tools can be found at http:sourceforge.netprojectsroccat
 pyra_class is used for creating sysfs attributes via roccat char device 
			
			  pyra reports profile numbers with range 1-5.
			  Keeping this behaviour.
 class name has to be same as driver name 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) 2000-2001 Vojtech Pavlik
   Copyright (c) 2006-2010 Jiri Kosina
   HID to Linux Input mapping
  Should you need to contact me, the author, you can do so either by
  e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
  Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
	
	  We should exclude unmapped usages when doing lookup by keycode.
		
		  Set the keybit for the old keycode if the old keycode is used
		  by another key
  hidinput_calc_abs_res - calculate an absolute axis resolution
  @field: the HID report field to calculate resolution for
  @code: axis code
  The formula is:
                          (logical_maximum - logical_minimum)
  resolution = ----------------------------------------------------------
               (physical_maximum - physical_minimum)  10 ^ unit_exponent
  as seen in the HID specification v1.11 6.2.2.7 Global Items.
  Only exponent 1 length units are processed. Centimeters and inches are
  converted to millimeters. Degrees are converted to radians.
 Check if the extents are sane 
	
	  Verify and convert units.
	  See HID specification v1.11 6.2.2.7 Global Items for unit decoding
 If centimeters 
 Convert to millimeters 
 If inches 
 Convert to millimeters 
 If degrees 
 Convert to radians 
 If not radians 
 Apply negative unit exponent 
 Apply positive unit exponent 
 Calculate resolution 
 always reports percent 
 ask for feature report 
 completely ignore the battery 
 already initialized? 
	
	  Stylus is normally not connected to the device and thus we
	  can't query the device and get meaningful battery strength.
	  We have to wait for the device to report it on its own.
 !CONFIG_HID_BATTERY_STRENGTH 
 CONFIG_HID_BATTERY_STRENGTH 
 Ignore if report count is out of bounds. 
 only LED usages are supported in output fields 
 SystemControl 
 SC - Display 
		
		  Some lazy vendors declare 255 usages for System Control,
		  leading to the creation of ABS_X|Y axis and too many others.
		  It wouldn't be a problem if joydev doesn't consider the
		  device as a joystick then.
 D-pad 
 These usage IDs map directly to the usage codes. 
 MS wireless radio ctl extension, also check CA 
 We need to simulate the btn release 
 HID-Value:                   
   "Num Lock"                 
   "Caps Lock"                
   "Scroll Lock"              
   "Compose"                  
   "Kana"                     
   "Stand-By"                 
   "System Suspend"           
   "Mute"                     
   "Generic Indicator"        
   "Message Waiting"          
   "External Power Connected" 
 Digitizer 
 Pen 
 Undefined 
 TipPressure 
 InRange 
 Battery Strength 
 Invert 
 X Tilt 
 Y Tilt 
 Touch 
 TipSwitch 
 TipSwitch2 
 BarrelSwitch 
 ERASER 
			
			  This event is reported when eraser tip touches the surface.
			  Actual eraser (BTN_TOOL_RUBBER) is set by Invert usage when
			  tool gets in proximity.
 TabletPick 
 SecondaryBarrelSwitch 
 TransducerSerialNumber 
 TransducerSerialNumber2 
 USB HUT v1.12, pages 75-84 
 Menu 
 Menu Pick 
 Menu Up 
 Menu Down 
 Menu Left 
 Menu Right 
 Menu Escape 
 Menu Value Increase 
 Menu Value Decrease 
 Data On Screen 
 Closed Caption 
 VCRTV 
 Snapshot 
 AC Pan 
 Reported on a Dutch layout HP5308 
 Reported on Logitech and Apple USB keyboards 
 intentional fallback 
 intentional fallback 
 Mapping failed, bail out 
		
		  The driver indicated that no further generic handling
		  of the usage is desired.
	
	  This part is really controversial:
	  - HID aims at being generic so we should do our best to export
	    all incoming events
	  - HID describes what events are, so there is no reason for ABS_X
	    to be mapped to ABS_Y
	  - HID is using _MISC+N as a default value, but nothing prevents
	    _MISC+N to overwrite a legitimate even, which confuses userspace
	    (for instance ABS_MISC + 7 is ABS_MT_SLOT, which has a different
	    processing)
	 
	  If devices still want to use this (at their own risk), they will
	  have to use the quirk HID_QUIRK_INCREMENT_USAGE_ON_DUPLICATE, but
	  the default should be a reliable mapping.
 use a larger default input buffer for MT devices 
	 for those devices which produce Consumer volume usage as relative,
	  we emulate pressing volumeupvolumedown appropriate number of times
	  in hidinput_hid_event()
	
	  Windows reports one wheel click as value 120. Where a high-res
	  scroll wheel is present, a fraction of 120 is reported instead.
	  Our REL_WHEEL_HI_RES axis does the same because all HW must
	  adhere to the 120 expectation.
 Simultaneous Effects Max 
 Key 0 is "unassigned", not KEY_UNKNOWN 
	
	  Ignore out-of-range values as per HID specification,
	  section 5.10 and 6.2.25, when NULL state bit is present.
	  When it's not, clamp the value to match Microsoft's input
	  driver as mentioned in "Required HID usages for digitizers":
	  https:msdn.microsoft.comen-uslibrarywindowshardwaredn672278(v=vs.85).asp
	 
	  The logical_minimum < logical_maximum check is done so that we
	  don't unintentionally discard values sent by devices which
	  don't specify logical min and max.
	
	  Ignore reports for absolute data if the data didn't change. This is
	  not only an optimization but also fixes 'dead' key reports. Some
	  RollOver implementations for localized keys (like BACKSLASHPIPE; HID
	  0x31 and 0x32) report multiple keys, even though a localized keyboard
	  can only have one of them physically available. The 'dead' keys
	  report constant 0. As all map to the same keycode, they'd confuse
	  the input layer. If we filter the 'dead' keys on the HID level, we
	  skip the keycode translation and only forward real events.
 report the usage code as scancode if the key status has changed 
	
	  field->report is accessed unlocked regarding HID core. So there might
	  be another incoming SET-LED request from user-space, which changes
	  the LED state while we assemble our outgoing buffer. However, this
	  doesn't matter as hid_output_report() correctly converts it into a
	  boolean value no matter what information is currently set on the LED
	  field (even garbage). So the remote device will always get a valid
	  request.
	  And in case we send a wrong value, a next led worker is spawned
	  for every SET-LED request so the following worker will send the
	  correct value, guaranteed!
 use custom SET_REPORT request if possible (asynchronous) 
 fall back to generic raw-output-report 
 synchronous output report 
		 There is no good reason for a Resolution
		  Multiplier to have a count other than 1.
		  Ignore that case.
			
			  If we have more than one feature within this
			  report we need to fill in the bits from the
			  others before we can overwrite the ones for the
			  Resolution Multiplier.
			 
			  But if we're not allowed to read from the device,
			  we just bail. Such a device should not exist
			  anyway.
 refresh our structs 
 Ignore if report count is out of bounds. 
 Verify if Battery Strength feature is available 
		
		  Keep SystemControl and ConsumerControl applications together
		  with the main keyboard, if present.
  Register the input device; print a message.
  Configure the input layer interface
  Read all reports and initialize the absolute field values.
			
			  Find the previous hidinput report attached
			  to this report id.
 no need to register an input device not populated 
 unwind the ones we already registered 
	 led_work is spawned by input_dev callbacks, but doesn't access the
	  parent input_dev at all. Once all input devices are removed, we
	  know that led_work will never get restarted, so we can cancel it
 SPDX-License-Identifier: GPL-2.0-only
  HID driver for primax and similar keyboards with in-band modifiers
  Copyright 2011 Google Inc. All Rights Reserved
  Author:
 	Terry Lambert <tlambert@google.com>
 keyboard input 
		
		  Convert in-band modifier key values into out of band
		  modifier bits and pull the key strokes from the report.
		  Thus a report data set which looked like:
		 
		  [00][00][E0][30][00][00][00][00]
		  (no modifier bits + "Left Shift" key + "1" key)
		 
		  Would be converted to:
		 
		  [01][00][00][30][00][00][00][00]
		  (Left Shift modifier bit + "1" key)
		 
		  As long as it's in the size range, the upper level
		  drivers don't particularly care if there are in-band
		  0-valued keys, so they don't stop parsing.
 unknown report 
 Unknown report type; pass upstream 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for some microsoft "special" devices
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2006-2007 Jiri Kosina
   Copyright (c) 2008 Jiri Slaby
	
	  Microsoft Wireless Desktop Receiver (Model 1028) has
	  'Usage MinMax' where it ought to have 'Physical MinMax'
		
		  Microsoft uses these 2 reserved usage ids for 2 keys on
		  the MS office kb labelled "Office Home" and "Task Pane".
 Special keypad keys 
 Scroll wheel 
		
		  This byte contains a copy of the modifier keys byte of a
		  standard hid keyboard report, as send by interface 0
		  (this usage is found on interface 1).
		 
		  This byte only gets send when another key in the same report
		  changes state, and as such is useless, ignore it.
 ignore those axis 
 ignore those axis 
 Handling MS keyboards special buttons 
 Special keypad keys 
 Scroll wheel 
	
	  Specifying maximum duration and maximum loop count should
	  cover maximum duration of a single effect, which is 65536
	  ms
 left actuator 
 right actuator 
	
	  Magnitude is 0..100 so scale the 16-bit input here
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for ELECOM devices:
   - BM084 Bluetooth Mouse
   - EX-G Trackballs (M-XT3DRBK, M-XT3URBK, M-XT4DRBK)
   - DEFT Trackballs (M-DT1DRBK, M-DT1URBK, M-DT2DRBK, M-DT2URBK)
   - HUGE Trackballs (M-HT1DRBK, M-HT1URBK)
   Copyright (c) 2010 Richard Nauber <Richard.Nauber@gmail.com>
   Copyright (c) 2016 Yuxuan Shui <yshuiv7@gmail.com>
   Copyright (c) 2017 Diego Elio Petten√≤ <flameeyes@flameeyes.eu>
   Copyright (c) 2017 Alex Manoussakis <amanou@gnu.org>
   Copyright (c) 2017 Tomasz Kramkowski <tk@the-tk.com>
   Copyright (c) 2020 YOSHIOKA Takuma <lo48576@hard-wi.red>
  Certain ELECOM mice misreport their button count meaning that they only work
  correctly with the ELECOM mouse assistant software which is unavailable for
  Linux. A four extra INPUT reports and a FEATURE report are described by the
  report descriptor but it does not appear that these enable software to
  control what the extra buttons map to. The only simple and straightforward
  solution seems to involve fixing up the report descriptor.
		 The BM084 Bluetooth mouse includes a non-existing horizontal
		
		  Report descriptor format:
		  20: button bit count
		  28: padding bit count
		  22: button report size
		  14: button usage maximum
		
		  Report descriptor format:
		  12: button bit count
		  30: padding bit count
		  14: button report size
		  20: button usage maximum
		
		  Report descriptor format:
		  12: button bit count
		  30: padding bit count
		  14: button report size
		  20: button usage maximum
 SPDX-License-Identifier: GPL-2.0-only
  hid-sensor-custom.c
  Copyright (c) 2015, Intel Corporation.
 Header for each sample to user space via dev interface 
	
	  It is possible that the powerreport state ids are not present.
	  In this case this function will return success. But if the
	  ids are present, then it will return error if set fails.
 If any error occurs in a sample, rest of the fields are ignored 
 Create sysfs attributes 
 For power or report field store indexes 
 We essentially have single reader and writer 
 luid defined in FW (e.g. ISH).  Maybe used to identify sensor. 
 get manufacturer info 
 convert from wide char to char 
 ensure it's ISH sensor 
 get real usage id 
 convert from wide char to char 
 get table index with luid (not matching 'LUID: ' in luid) 
 copy real usage id 
 usage id are all lowcase 
 HID-SENSOR-INT-REAL_USAGE_ID 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  HID driver for some ITE "special" devices
  Copyright (c) 2017 Hans de Goede <hdegoede@redhat.com>
 For Acer Aspire Switch 10 SW5-012 keyboard-dock 
 For Acer One S1002S1003 keyboard-dock 
 For Acer Aspire Switch 10E (SW3-016) keyboard-dock 
 Touchpad on, userspace expects F22 for this 
 Touchpad off, userspace expects F23 for this 
	
	  The ITE8595 always reports 0 as value for the rfkill button. Luckily
	  it is the only button in its report, and it sends a report on
	  release only, so receiving a report means the button was pressed.
 ITE8595 USB kbd ctlr, with Synaptics touchpad connected to it. 
 ITE8910 USB kbd ctlr, with Synaptics touchpad connected to it. 
 ITE8910 USB kbd ctlr, with Synaptics touchpad connected to it. 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for Kensigton Slimblade Trackball
   Copyright (c) 2009 Jiri Kosina
 SPDX-License-Identifier: GPL-2.0-only
   HID driver for Aureal Cy se W-01RN USB_V3.1 devices
   Copyright (c) 2010 Franco Catrin <fcatrin@gmail.com>
   Copyright (c) 2010 Ben Cropley <bcropley@internode.on.net>
   Based on HID sunplus driver by
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2006-2007 Jiri Kosina
   Copyright (c) 2008 Jiri Slaby
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for some gyration "special" devices
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2008 Jiri Slaby
   Copyright (c) 2006-2008 Jiri Kosina
 Reported on Gyration MCE Remote 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for some sunplus "special" devices
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2006-2007 Jiri Kosina
   Copyright (c) 2008 Jiri Slaby
 SPDX-License-Identifier: GPL-2.0-only
  Simple USB RGB LED driver
  Copyright 2016 Heiner Kallweit <hkallweit1@gmail.com>
  Based on drivershidhid-thingm.c and
  driversusbmiscusbled.c
 R+2G+4B -> riso kagaku color index 
 black   
 red     
 green   
 yellow  
 blue    
 magenta 
 cyan    
 white   
	
	  buffer provided to hid_hw_raw_request must not be on the stack
	  and must not be part of a data structure
 reading data is supported for report type RAW_REQUEST only 
 Dream Cheeky magic 
 Check for firmware major version 1 
	
	  enable LED
	  We can't do this in the init function already because the device
	  is internally reset later.
	
	  Several Delcom devices share the same USB VIDPID
	  Check for family id 2 for Visual Signal Indicator
 Register the red diode 
 Register the green diode 
 Register the blue diode 
 SPDX-License-Identifier: GPL-2.0+
   HID driver for UC-Logic devices not fully compliant with HID standard
   - tablet initialization and parameter retrieval
   Copyright (c) 2018 Nikolai Kondrashov
  This program is free software; you can redistribute it andor modify it
  under the terms of the GNU General Public License as published by the Free
  Software Foundation; either version 2 of the License, or (at your option)
  any later version.
  uclogic_params_pen_inrange_to_str() - Convert a pen in-range reporting type
                                        to a string.
  @inrange:	The in-range reporting type to convert.
  Returns:
 	The string representing the type, or NULL if the type is unknown.
  uclogic_params_get_str_desc - retrieve a string descriptor from a HID
  device interface, putting it into a kmalloc-allocated buffer as is, without
  character encoding conversion.
  @pbuf:	Location for the kmalloc-allocated buffer pointer containing
 		the retrieved descriptor. Not modified in case of error.
 		Can be NULL to have retrieved descriptor discarded.
  @hdev:	The HID device of the tablet interface to retrieve the string
 		descriptor from. Cannot be NULL.
  @idx:	Index of the string descriptor to request from the device.
  @len:	Length of the buffer to allocate and the data to retrieve.
  Returns:
 	number of bytes retrieved (<= len),
 	-EPIPE, if the descriptor was not found, or
 	another negative errno code in case of other error.
 Check arguments 
  uclogic_params_pen_cleanup - free resources used by struct
  uclogic_params_pen (tablet interface's pen input parameters).
  Can be called repeatedly.
  @pen:	Pen input parameters to cleanup. Cannot be NULL.
  uclogic_params_pen_init_v1() - initialize tablet interface pen
  input and retrieve its parameters from the device, using v1 protocol.
  @pen:	Pointer to the pen parameters to initialize (to be
 		cleaned up with uclogic_params_pen_cleanup()). Not modified in
 		case of error, or if parameters are not found. Cannot be NULL.
  @pfound:	Location for a flag which is set to true if the parameters
 		were found, and to false if not (e.g. device was
 		incompatible). Not modified in case of error. Cannot be NULL.
  @hdev:	The HID device of the tablet interface to initialize and get
 		parameters from. Cannot be NULL.
  Returns:
 	Zero, if successful. A negative errno code on error.
 Buffer for (part of) the string descriptor 
 Minimum descriptor length required, maximum seen so far is 18 
 Pen report descriptor template parameters 
 Check arguments 
	
	  Read string descriptor containing pen input parameters.
	  The specific string descriptor and data were discovered by sniffing
	  the Windows driver traffic.
	  NOTE: This enables fully-functional tablet mode.
	
	  Fill report descriptor parameters from the string descriptor
	
	  Generate pen report descriptor
	
	  Fill-in the parameters
  uclogic_params_get_le24() - get a 24-bit little-endian number from a
  buffer.
  @p:	The pointer to the number buffer.
  Returns:
 	The retrieved number
  uclogic_params_pen_init_v2() - initialize tablet interface pen
  input and retrieve its parameters from the device, using v2 protocol.
  @pen:	Pointer to the pen parameters to initialize (to be
 		cleaned up with uclogic_params_pen_cleanup()). Not modified in
 		case of error, or if parameters are not found. Cannot be NULL.
  @pfound:	Location for a flag which is set to true if the parameters
 		were found, and to false if not (e.g. device was
 		incompatible). Not modified in case of error. Cannot be NULL.
  @hdev:	The HID device of the tablet interface to initialize and get
 		parameters from. Cannot be NULL.
  Returns:
 	Zero, if successful. A negative errno code on error.
 Buffer for (part of) the string descriptor 
 Descriptor length required 
 Pen report descriptor template parameters 
 Check arguments 
	
	  Read string descriptor containing pen input parameters.
	  The specific string descriptor and data were discovered by sniffing
	  the Windows driver traffic.
	  NOTE: This enables fully-functional tablet mode.
		
		  Check it's not just a catch-all UTF-16LE-encoded ASCII
		  string (such as the model name) some tablets put into all
		  unknown string descriptors.
	
	  Fill report descriptor parameters from the string descriptor
	
	  Generate pen report descriptor
	
	  Fill-in the parameters
  uclogic_params_frame_cleanup - free resources used by struct
  uclogic_params_frame (tablet interface's frame controls input parameters).
  Can be called repeatedly.
  @frame:	Frame controls input parameters to cleanup. Cannot be NULL.
  uclogic_params_frame_init_with_desc() - initialize tablet's frame control
  parameters with a static report descriptor.
  @frame:	Pointer to the frame parameters to initialize (to be cleaned
 		up with uclogic_params_frame_cleanup()). Not modified in case
 		of error. Cannot be NULL.
  @desc_ptr:	Report descriptor pointer. Can be NULL, if desc_size is zero.
  @desc_size:	Report descriptor size.
  @id:		Report ID used for frame reports, if they should be tweaked,
 		zero if not.
  Returns:
 	Zero, if successful. A negative errno code on error.
  uclogic_params_frame_init_v1_buttonpad() - initialize abstract buttonpad
  on a v1 tablet interface.
  @frame:	Pointer to the frame parameters to initialize (to be cleaned
 		up with uclogic_params_frame_cleanup()). Not modified in case
 		of error, or if parameters are not found. Cannot be NULL.
  @pfound:	Location for a flag which is set to true if the parameters
 		were found, and to false if not (e.g. device was
 		incompatible). Not modified in case of error. Cannot be NULL.
  @hdev:	The HID device of the tablet interface to initialize and get
 		parameters from. Cannot be NULL.
  Returns:
 	Zero, if successful. A negative errno code on error.
 Check arguments 
	
	  Enable generic button mode
  uclogic_params_cleanup - free resources used by struct uclogic_params
  (tablet interface's parameters).
  Can be called repeatedly.
  @params:	Input parameters to cleanup. Cannot be NULL.
  uclogic_params_get_desc() - Get a replacement report descriptor for a
                              tablet's interface.
  @params:	The parameters of a tablet interface to get report
 		descriptor for. Cannot be NULL.
  @pdesc:	Location for the resulting, kmalloc-allocated report
 		descriptor pointer, or for NULL, if there's no replacement
 		report descriptor. Not modified in case of error. Cannot be
 		NULL.
  @psize:	Location for the resulting report descriptor size, not set if
 		there's no replacement report descriptor. Not modified in case
 		of error. Cannot be NULL.
  Returns:
 	Zero, if successful.
 	-EINVAL, if invalid arguments are supplied.
 	-ENOMEM, if failed to allocate memory.
 Check arguments 
  uclogic_params_init_invalid() - initialize tablet interface parameters,
  specifying the interface is invalid.
  @params:		Parameters to initialize (to be cleaned with
 			uclogic_params_cleanup()). Cannot be NULL.
  uclogic_params_init_with_opt_desc() - initialize tablet interface
  parameters with an optional replacement report descriptor. Only modify
  report descriptor, if the original report descriptor matches the expected
  size.
  @params:		Parameters to initialize (to be cleaned with
 			uclogic_params_cleanup()). Not modified in case of
 			error. Cannot be NULL.
  @hdev:		The HID device of the tablet interface create the
 			parameters for. Cannot be NULL.
  @orig_desc_size:	Expected size of the original report descriptor to
 			be replaced.
  @desc_ptr:		Pointer to the replacement report descriptor.
 			Can be NULL, if desc_size is zero.
  @desc_size:		Size of the replacement report descriptor.
  Returns:
 	Zero, if successful. -EINVAL if an invalid argument was passed.
 	-ENOMEM, if failed to allocate memory.
 Check arguments 
 Replace report descriptor, if it matches 
 Output parameters 
  uclogic_params_init_with_pen_unused() - initialize tablet interface
  parameters preserving original reports and generic HID processing, but
  disabling pen usage.
  @params:		Parameters to initialize (to be cleaned with
 			uclogic_params_cleanup()). Not modified in case of
 			error. Cannot be NULL.
  uclogic_params_huion_init() - initialize a Huion tablet interface and discover
  its parameters.
  @params:	Parameters to fill in (to be cleaned with
 		uclogic_params_cleanup()). Not modified in case of error.
 		Cannot be NULL.
  @hdev:	The HID device of the tablet interface to initialize and get
 		parameters from. Cannot be NULL.
  Returns:
 	Zero, if successful. A negative errno code on error.
 The resulting parameters (noop) 
 Check arguments 
 If it's not a pen interface 
 TODO: Consider marking the interface invalid 
 Try to get firmware version 
 If this is a transition firmware 
 Try to probe v2 pen parameters 
 Create v2 buttonpad parameters 
 Set bitmask marking frame reports in pen reports 
 Try to probe v1 pen parameters 
 Try to probe v1 buttonpad 
 Set bitmask marking frame reports 
 Output parameters 
  uclogic_params_init() - initialize a tablet interface and discover its
  parameters.
  @params:	Parameters to fill in (to be cleaned with
 		uclogic_params_cleanup()). Not modified in case of error.
 		Cannot be NULL.
  @hdev:	The HID device of the tablet interface to initialize and get
 		parameters from. Cannot be NULL. Must be using the USB low-level
 		driver, i.e. be an actual USB tablet.
  Returns:
 	Zero, if successful. A negative errno code on error.
 The resulting parameters (noop) 
 Check arguments 
	
	  Set replacement report descriptor if the original matches the
	  specified size. Otherwise keep interface unchanged.
	
	  Handle specific interfaces for specific tablets.
	 
	  Observe the following logic:
	 
	  If the interface is recognized as producing certain useful input:
	 	Mark interface as valid.
	 	Output interface parameters.
	  Else, if the interface is recognized as not producing any useful
	  input:
	 	Mark interface as invalid.
	  Else:
	 	Mark interface as valid.
	 	Output noop parameters.
	 
	  Rule of thumb: it is better to disable a broken interface than let
	 		  it spew garbage input.
 Try to probe v1 pen parameters 
		
		  If it is not a three-interface version, which is known to
		  respond to initialization.
 If this is the pen interface 
 Probe v1 pen parameters 
 TODO: Consider marking the interface invalid 
 If this is the pen and frame interface 
 Probe v1 pen parameters 
 Initialize frame parameters 
 TODO: Consider marking the interface invalid 
 Ignore non-pen interfaces 
 Ignore non-pen interfaces 
 Output parameters 
 SPDX-License-Identifier: GPL-2.0-or-later
  Device Modules for Nintendo Wii  Wii U HID Driver
  Copyright (c) 2011-2013 David Herrmann <dh.herrmann@gmail.com>
  Wiimote Modules
  Nintendo devices provide different peripherals and many new devices lack
  initial features like the IR camera. Therefore, each peripheral device is
  implemented as an independent module and we probe on each device only the
  modules for the hardware that really is available.
  Module registration is sequential. Unregistration is done in reverse order.
  After device detection, the needed modules are loaded. Users can trigger
  re-detection which causes all modules to be unloaded and then reload the
  modules for the new detected device.
  wdata->input is a shared input device. It is always initialized prior to
  module registration. If at least one registered module is marked as
  WIIMOD_FLAG_INPUT, then the input device will get registered after all
  modules were registered.
  Please note that it is unregistered _before_ the "remove" callbacks are
  called. This guarantees that no input interaction is done, anymore. However,
  the wiimote core keeps a reference to the input device so it is freed only
  after all modules were removed. It is safe to send events to unregistered
  input devices.
  Keys
  The initial Wii Remote provided a bunch of buttons that are reported as
  part of the core protocol. Many later devices dropped these and report
  invalid data in the core button reports. Load this only on devices which
  correctly send button reports.
  It uses the shared input device.
 WIIPROTO_KEY_LEFT 
 WIIPROTO_KEY_RIGHT 
 WIIPROTO_KEY_UP 
 WIIPROTO_KEY_DOWN 
 WIIPROTO_KEY_PLUS 
 WIIPROTO_KEY_MINUS 
 WIIPROTO_KEY_ONE 
 WIIPROTO_KEY_TWO 
 WIIPROTO_KEY_A 
 WIIPROTO_KEY_B 
 WIIPROTO_KEY_HOME 
  Rumble
  Nearly all devices provide a rumble feature. A small motor for
  force-feedback effects. We provide an FF_RUMBLE memless ff device on the
  shared input device if this module is loaded.
  The rumble motor is controlled via a flag on almost every output report so
  the wiimote core handles the rumble flag. But if a device doesn't provide
  the rumble motor, this flag shouldn't be set.
 used by wiimod_rumble and wiipro_rumble 
	
	  The wiimote supports only a single rumble motor so if any magnitude
	  is set to non-zero then we start the rumble motor. If both are set to
	  zero, we stop the rumble motor.
	 Locking state.lock here might deadlock with input_event() calls.
  Battery
  1 byte of battery capacity information is sent along every protocol status
  report. The wiimote core caches it but we try to update it on every
  user-space request.
  This is supported by nearly every device so it's almost always enabled.
  LED
  0 to 4 player LEDs are supported by devices. The "arg" field of the
  wiimod_ops structure specifies which LED this module controls. This allows
  to register a limited number of LEDs.
  State is managed by wiimote core.
 enable LED1 to stop initial LED-blinking 
  Accelerometer
  3 axis accelerometer data is part of nearly all DRMs. If not supported by a
  device, it's mostly cleared to 0. This module parses this data and provides
  it via a separate input device.
	
	  payload is: BB BB XX YY ZZ
	  Accelerometer data is encoded into 3 10bit values. XX, YY and ZZ
	  contain the upper 8 bits of each value. The lower 2 bits are
	  contained in the buttons data BB BB.
	  Bits 6 and 7 of the first buttons byte BB is the lower 2 bits of the
	  X accel value. Bit 5 of the second buttons byte is the 2nd bit of Y
	  accel value and bit 6 is the second bit of the Z value.
	  The first bit of Y and Z values is not available and always set to 0.
	  0x200 is returned on no movement.
  IR Cam
  Up to 4 IR sources can be tracked by a normal Wii Remote. The IR cam needs
  to be initialized with a fairly complex procedure and consumes a lot of
  power. Therefore, as long as no application uses the IR input device, it is
  kept offline.
  Nearly no other device than the normal Wii Remotes supports the IR cam so
  you can disable this module for these devices.
	
	  Basic IR data is encoded into 3 bytes. The first two bytes are the
	  lower 8 bit of the XY data, the 3rd byte contains the upper 2 bits
	  of both.
	  If data is packed, then the 3rd byte is put first and slightly
	  reordered. This allows to interleave packed and non-packed data to
	  have two IR sets in 5 bytes instead of 6.
	  The resulting 10bit XY values are passed to the ABS_HAT? input dev.
 send PIXEL CLOCK ENABLE cmd first 
 enable IR LOGIC 
 enable IR cam but do not make it send data, yet 
 write first sensitivity block 
 write second sensitivity block 
 put IR cam into desired state 
 make IR cam send data 
 request new DRM mode compatible to IR mode 
  Nunchuk Extension
  The Nintendo Wii Nunchuk was the first official extension published by
  Nintendo. It provides two additional keys and a separate accelerometer. It
  can be hotplugged to standard Wii Remotes.
 WIIMOD_NUNCHUK_KEY_C 
 WIIMOD_NUNCHUK_KEY_Z 
	   Byte |   8    7 |  6    5 |  4    3 |  2 |  1  |
	    -----+----------+---------+---------+----+-----+
	     1   |              Button X <7:0>             |
	     2   |              Button Y <7:0>             |
	    -----+----------+---------+---------+----+-----+
	     3   |               Speed X <9:2>             |
	     4   |               Speed Y <9:2>             |
	     5   |               Speed Z <9:2>             |
	    -----+----------+---------+---------+----+-----+
	     6   | Z <1:0>  | Y <1:0> | X <1:0> | BC | BZ  |
	    -----+----------+---------+---------+----+-----+
	  Button XY is the analog stick. Speed X, Y and Z are the
	  accelerometer data in the same format as the wiimote's accelerometer.
	  The 6th byte contains the LSBs of the accelerometer data.
	  BC and BZ are the C and Z buttons: 0 means pressed
	 
	  If reported interleaved with motionp, then the layout changes. The
	  5th and 6th byte changes to:
	    -----+-----------------------------------+-----+
	     5   |            Speed Z <9:3>          | EXT |
	    -----+--------+-----+-----+----+----+----+-----+
	     6   |Z <2:1> |Y <1>|X <1>| BC | BZ | 0  |  0  |
	    -----+--------+-----+-----+----+----+----+-----+
	  All three accelerometer values lose their LSB. The other data is
	  still available but slightly moved.
	 
	  Center data for button values is 128. Center value for accelerometer
	  values it 512  0x200
  Classic Controller
  Another official extension from Nintendo. It provides a classic
  gamecube-like controller that can be hotplugged on the Wii Remote.
  It has several hardware buttons and switches that are all reported via
  a normal extension device.
 WIIMOD_CLASSIC_KEY_A 
 WIIMOD_CLASSIC_KEY_B 
 WIIMOD_CLASSIC_KEY_X 
 WIIMOD_CLASSIC_KEY_Y 
 WIIMOD_CLASSIC_KEY_ZL 
 WIIMOD_CLASSIC_KEY_ZR 
 WIIMOD_CLASSIC_KEY_PLUS 
 WIIMOD_CLASSIC_KEY_MINUS 
 WIIMOD_CLASSIC_KEY_HOME 
 WIIMOD_CLASSIC_KEY_LEFT 
 WIIMOD_CLASSIC_KEY_RIGHT 
 WIIMOD_CLASSIC_KEY_UP 
 WIIMOD_CLASSIC_KEY_DOWN 
 WIIMOD_CLASSIC_KEY_LT 
 WIIMOD_CLASSIC_KEY_RT 
	   Byte |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     1   | RX <5:4>  |              LX <5:0>             |
	     2   | RX <3:2>  |              LY <5:0>             |
	    -----+-----+-----+-----+-----------------------------+
	     3   |RX<1>| LT <5:4>  |         RY <5:1>            |
	    -----+-----+-----------+-----------------------------+
	     4   |     LT <3:1>    |         RT <5:1>            |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     5   | BDR | BDD | BLT | B-  | BH  | B+  | BRT |  1  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     6   | BZL | BB  | BY  | BA  | BX  | BZR | BDL | BDU |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	  All buttons are 0 if pressed
	  RX and RY are right analog stick
	  LX and LY are left analog stick
	  LT is left trigger, RT is right trigger
	  BLT is 0 if left trigger is fully pressed
	  BRT is 0 if right trigger is fully pressed
	  BDR, BDD, BDL, BDU form the D-Pad with right, down, left, up buttons
	  BZL is left Z button and BZR is right Z button
	  B-, BH, B+ are +, HOME and - buttons
	  BB, BY, BA, BX are A, B, X, Y buttons
	  LSB of RX, RY, LT, and RT are not transmitted and always 0.
	 
	  With motionp enabled it changes slightly to this:
	    Byte |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     1   | RX <5:4>  |          LX <5:1>           | BDU |
	     2   | RX <3:2>  |          LY <5:1>           | BDL |
	    -----+-----+-----+-----+-----------------------+-----+
	     3   |RX<1>| LT <5:4>  |         RY <5:1>            |
	    -----+-----+-----------+-----------------------------+
	     4   |     LT <3:1>    |         RT <5:1>            |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     5   | BDR | BDD | BLT | B-  | BH  | B+  | BRT | EXT |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     6   | BZL | BB  | BY  | BA  | BX  | BZR |  0  |  0  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	  Only the LSBs of LX and LY are lost. BDU and BDL are moved, the rest
	  is the same as before.
  Balance Board Extension
  The Nintendo Wii Balance Board provides four hardware weight sensor plus a
  single push button. No other peripherals are available. However, the
  balance-board data is sent via a standard Wii Remote extension. All other
  data for non-present hardware is zeroed out.
  Some 3rd party devices react allergic if we try to access normal Wii Remote
  hardware, so this extension module should be the only module that is loaded
  on balance boards.
  The balance board needs 8 bytes extension data instead of basic 6 bytes so
  it needs the WIIMOD_FLAG_EXT8 flag.
	
	  Balance board data layout:
	 
	    Byte |  8  7  6  5  4  3  2  1  |
	    -----+--------------------------+
	     1   |    Top Right <15:8>      |
	     2   |    Top Right  <7:0>      |
	    -----+--------------------------+
	     3   | Bottom Right <15:8>      |
	     4   | Bottom Right  <7:0>      |
	    -----+--------------------------+
	     5   |     Top Left <15:8>      |
	     6   |     Top Left  <7:0>      |
	    -----+--------------------------+
	     7   |  Bottom Left <15:8>      |
	     8   |  Bottom Left  <7:0>      |
	    -----+--------------------------+
	 
	  These values represent the weight-measurements of the Wii-balance
	  board with 16bit precision.
	 
	  The balance-board is never reported interleaved with motionp.
 apply calibration data 
  Pro Controller
  Released with the Wii U was the Nintendo Wii U Pro Controller. It does not
  work together with the classic Wii, but only with the new Wii U. However, it
  uses the same protocol and provides a builtin "classic controller pro"
  extension, few standard buttons, a rumble motor, 4 LEDs and a battery.
  We provide all these via a standard extension device as the device doesn't
  feature an extension port.
 WIIMOD_PRO_KEY_A 
 WIIMOD_PRO_KEY_B 
 WIIMOD_PRO_KEY_X 
 WIIMOD_PRO_KEY_Y 
 WIIMOD_PRO_KEY_PLUS 
 WIIMOD_PRO_KEY_MINUS 
 WIIMOD_PRO_KEY_HOME 
 WIIMOD_PRO_KEY_LEFT 
 WIIMOD_PRO_KEY_RIGHT 
 WIIMOD_PRO_KEY_UP 
 WIIMOD_PRO_KEY_DOWN 
 WIIMOD_PRO_KEY_TL 
 WIIMOD_PRO_KEY_TR 
 WIIMOD_PRO_KEY_ZL 
 WIIMOD_PRO_KEY_ZR 
 WIIMOD_PRO_KEY_THUMBL 
 WIIMOD_PRO_KEY_THUMBR 
	   Byte |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     1   |                   LX <7:0>                    |
	    -----+-----------------------+-----------------------+
	     2   |  0     0     0     0  |       LX <11:8>       |
	    -----+-----------------------+-----------------------+
	     3   |                   RX <7:0>                    |
	    -----+-----------------------+-----------------------+
	     4   |  0     0     0     0  |       RX <11:8>       |
	    -----+-----------------------+-----------------------+
	     5   |                   LY <7:0>                    |
	    -----+-----------------------+-----------------------+
	     6   |  0     0     0     0  |       LY <11:8>       |
	    -----+-----------------------+-----------------------+
	     7   |                   RY <7:0>                    |
	    -----+-----------------------+-----------------------+
	     8   |  0     0     0     0  |       RY <11:8>       |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     9   | BDR | BDD | BLT | B-  | BH  | B+  | BRT |  1  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	    10   | BZL | BB  | BY  | BA  | BX  | BZR | BDL | BDU |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	    11   |  1  |     BATTERY     | USB |CHARG|LTHUM|RTHUM|
	    -----+-----+-----------------+-----------+-----+-----+
	  All buttons are low-active (0 if pressed)
	  RX and RY are right analog stick
	  LX and LY are left analog stick
	  BLT is left trigger, BRT is right trigger.
	  BDR, BDD, BDL, BDU form the D-Pad with right, down, left, up buttons
	  BZL is left Z button and BZR is right Z button
	  B-, BH, B+ are +, HOME and - buttons
	  BB, BY, BA, BX are A, B, X, Y buttons
	 
	  Bits marked as 01 are unknown and never changed during tests.
	 
	  Not entirely verified:
	    CHARG: 1 if uncharging, 0 if charging
	    USB: 1 if not connected, 0 if connected
	    BATTERY: battery capacity from 000 (empty) to 100 (full)
 zero-point offsets 
	 Trivial automatic calibration. We don't know any calibration data
	  in the EEPROM so we must use the first report to calibrate the
	  null-position of the analog sticks. Users can retrigger calibration
	  via sysfs, or set it explicitly. If data is off more than abs(500),
 apply calibration data 
	
	  The wiimote supports only a single rumble motor so if any magnitude
	  is set to non-zero then we start the rumble motor. If both are set to
	  zero, we stop the rumble motor.
	 Locking state.lock here might deadlock with input_event() calls.
  Drums
  Guitar-Hero, Rock-Band and other games came bundled with drums which can
  be plugged as extension to a Wiimote. Drum-reports are still not entirely
  figured out, but the most important information is known.
  We create a separate device for drums and report all information via this
  input device.
	   Byte |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     1   |  0  |  0  |              SX <5:0>             |
	     2   |  0  |  0  |              SY <5:0>             |
	    -----+-----+-----+-----------------------------+-----+
	     3   | HPP | NON |         WHICH <5:1>         |  ?  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     4   |   SOFT <7:5>    |  0  |  1  |  1  |  0  |  ?  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     5   |  ?  |  1  |  1  | B-  |  1  | B+  |  1  |  ?  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     6   |  O  |  R  |  Y  |  G  |  B  | BSS |  1  |  1  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	  All buttons are 0 if pressed
	 
	  With Motion+ enabled, the following bits will get invalid:
	    Byte |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     1   |  0  |  0  |              SX <5:1>       |XXXXX|
	     2   |  0  |  0  |              SY <5:1>       |XXXXX|
	    -----+-----+-----+-----------------------------+-----+
	     3   | HPP | NON |         WHICH <5:1>         |  ?  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     4   |   SOFT <7:5>    |  0  |  1  |  1  |  0  |  ?  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     5   |  ?  |  1  |  1  | B-  |  1  | B+  |  1  |XXXXX|
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     6   |  O  |  R  |  Y  |  G  |  B  | BSS |XXXXX|XXXXX|
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
 Bass shares pressure with hi-hat (set via hhp) 
 Hi-hat has no onoff values, just pressure. Force to off0. 
  Guitar
  Guitar-Hero, Rock-Band and other games came bundled with guitars which can
  be plugged as extension to a Wiimote.
  We create a separate device for guitars and report all information via this
  input device.
 WIIMOD_GUITAR_KEY_G 
 WIIMOD_GUITAR_KEY_R 
 WIIMOD_GUITAR_KEY_Y 
 WIIMOD_GUITAR_KEY_B 
 WIIMOD_GUITAR_KEY_O 
 WIIMOD_GUITAR_KEY_UP 
 WIIMOD_GUITAR_KEY_DOWN 
 WIIMOD_GUITAR_KEY_PLUS 
 WIIMOD_GUITAR_KEY_MINUS 
	   Byte |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     1   |  0  |  0  |              SX <5:0>             |
	     2   |  0  |  0  |              SY <5:0>             |
	    -----+-----+-----+-----+-----------------------------+
	     3   |  0  |  0  |  0  |      TB <4:0>               |
	    -----+-----+-----+-----+-----------------------------+
	     4   |  0  |  0  |  0  |      WB <4:0>               |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     5   |  1  | BD  |  1  | B-  |  1  | B+  |  1  |  1  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     6   | BO  | BR  | BB  | BG  | BY  |  1  |  1  | BU  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	  All buttons are 0 if pressed
	 
	  With Motion+ enabled, it will look like this:
	    Byte |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     1   |  0  |  0  |              SX <5:1>       | BU  |
	     2   |  0  |  0  |              SY <5:1>       |  1  |
	    -----+-----+-----+-----+-----------------------+-----+
	     3   |  0  |  0  |  0  |      TB <4:0>               |
	    -----+-----+-----+-----+-----------------------------+
	     4   |  0  |  0  |  0  |      WB <4:0>               |
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     5   |  1  | BD  |  1  | B-  |  1  | B+  |  1  |XXXXX|
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
	     6   | BO  | BR  | BB  | BG  | BY  |  1  |XXXXX|XXXXX|
	    -----+-----+-----+-----+-----+-----+-----+-----+-----+
  Builtin Motion Plus
  This module simply sets the WIIPROTO_FLAG_BUILTIN_MP protocol flag which
  disables polling for Motion-Plus. This should be set only for devices which
  don't allow MP hotplugging.
  No Motion Plus
  This module simply sets the WIIPROTO_FLAG_NO_MP protocol flag which
  disables motion-plus. This is needed for devices that advertise this but we
  don't know how to use it (or whether it is actually present).
  Motion Plus
  The Motion Plus extension provides rotation sensors (gyro) as a small
  extension device for Wii Remotes. Many devices have them built-in so
  you cannot see them from the outside.
  Motion Plus extensions are special because they are on a separate extension
  port and allow other extensions to be used simultaneously. This is all
  handled by the Wiimote Core so we don't have to deal with it.
	        |   8    7    6    5    4    3 |  2  |  1  |
	    -----+------------------------------+-----+-----+
	     1   |               Yaw Speed <7:0>            |
	     2   |              Roll Speed <7:0>            |
	     3   |             Pitch Speed <7:0>            |
	    -----+------------------------------+-----+-----+
	     4   |       Yaw Speed <13:8>       | Yaw |Pitch|
	    -----+------------------------------+-----+-----+
	     5   |      Roll Speed <13:8>       |Roll | Ext |
	    -----+------------------------------+-----+-----+
	     6   |     Pitch Speed <13:8>       |  1  |  0  |
	    -----+------------------------------+-----+-----+
	  The single bits Yaw, Roll, Pitch in the lower right corner specify
	  whether the wiimote is rotating fast (0) or slow (1). Speed for slow
	  roation is 8192440 units  degs and for fast rotation 81922000
	  units  degs. To get a linear scale for fast rotation we multiply
	  by 2000440 = ~4.5454 and scale both fast and slow by 9 to match the
	  previous scale reported by this driver.
	  This leaves a linear scale with 81929440 (~167.564) units  degs.
	  If the wiimote is not rotating the sensor reports 2^13 = 8192.
	  Ext specifies whether an extension is connected to the motionp.
	  which is parsed by wiimote-core.
 module table 
 SPDX-License-Identifier: GPL-2.0-only
  HID driver for ELO usb touchscreen 40004500
  Copyright (c) 2013 Jiri Slaby
  Data parsing taken from elousb driver by Vojtech Pavlik.
 msec 
 Elo SmartSet commands 
 Flush all pending smartset responses 
 Send a smartset command 
 Get a smartset response 
 Diagnostics command 
	
	  ELO devices have one Button usage in GenDesk field, which makes
	  hid-input map it to BTN_LEFT; that confuses userspace, which then
	  considers the device to be a mousetouchpad instead of touchscreen.
 Mandatory ELO packet marker 
 unknown report 
 Unknown report type; pass upstream 
 send Diagnostics command 
 get the result 
 read the ack 
  Not all Elo devices need the periodic HID descriptor reads.
  Only firmware version M needs this.
 iterate sibling devices of the touch controller 
		
		  If one of the devices below is present attached as a sibling of 
		  the touch controller then  this is a newer IBM 4820 monitor that 
		  does not need the IBM-requested workaround if fw level is
		  0x010d - aka 'M'.
		  No other HW can have this combination.
 4820 21x Video 
 4820 51x Video 
 4820 2Lx Video 
 4820 5Lx Video 
 SPDX-License-Identifier: GPL-2.0-only
    Copyright (C) 2010-2012 by Bruno Pr√©mont <bonbons@linux-vserver.org>  
    Based on Logitech G13 driver (v0.4)                                   
      Copyright (C) 2009 by Rick L. Vinyard, Jr. <rvinyard@cs.nmsu.edu>   
 SPDX-License-Identifier: GPL-2.0-or-later
   USB HID quirks support for Network Technologies, Inc. "USB-SUN" USB
   adapter for pre-USB Sun keyboards
   Copyright (c) 2011 Google, Inc.
  Based on HID apple driver by
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2006-2007 Jiri Kosina
   Copyright (c) 2008 Jiri Slaby <jirislaby@gmail.com>
  NTI Sun keyboard adapter has wrong logical maximum in report descriptor
 SPDX-License-Identifier: GPL-2.0+
   HID driver for Cougar 500k Gaming Keyboard
   Copyright (c) 2018 Daniel M. Lambea <dmlambea@gmail.com>
 Default key mappings. The special key COUGAR_KEY_G6 is defined first
  because it is more frequent to use the spacebar rather than any other
  special keys. Depending on the value of the parameter 'g6_is_space',
  the mapping will be updated in the probe function.
 The following keys are handled by the hardware itself, so no special
  treatment is required:
	{ COUGAR_KEY_FN, KEY_RESERVED },
	{ COUGAR_KEY_MR, KEY_RESERVED },
	{ COUGAR_KEY_M1, KEY_RESERVED },
	{ COUGAR_KEY_M2, KEY_RESERVED },
	{ COUGAR_KEY_M3, KEY_RESERVED },
	{ COUGAR_KEY_LEDS, KEY_RESERVED },
  cougar_fix_g6_mapping - configure the mapping for key G6Spacebar
  Constant-friendly rdesc fixup for mouse interface
 Try to find an already-probed interface from the same device 
  Bind the device group's shared data to this cougar struct.
  If no shared data exists for this group, create and initialize it.
	 The custom vendor interface will use the hid_input registered
	  for the keyboard interface, in order to send translated key codes
	  to it.
 Preinit the mapping table 
  Convert events from vendor intf to input key events
 Avoid warnings on the same unmapped key twice 
 Stop the vendor intf to process more events 
 SPDX-License-Identifier: GPL-2.0+
   HID driver for Google Hammer device.
   Copyright (c) 2017 Google Inc.
   Author: Wei-Ning Huang <wnhuang@google.com>
  This program is free software; you can redistribute it andor modify it
  under the terms of the GNU General Public License as published by the Free
  Software Foundation; either version 2 of the License, or (at your option)
  any later version.
  C(hrome)B(ase)A(ttached)S(witch) - switch exported by Chrome EC and reporting
  state of the "Whiskers" base - attached or detached. Whiskers USB device also
  reports position of the keyboard - folded or not. Combining base state and
  position allows us to generate proper "Tablet mode" events.
 The platform device (EC) 
			
			  While input layer dedupes the events, we do not want
			  to disrupt the state reported by the base by
			  overriding it with state reported by the LID. Only
			  report changes, as we assume that on attach the base
			  is not folded.
		
		  Only report if base is disconnected. If base is connected,
		  it will resend its state on resume, and we'll update it
		  in hammer_event().
 Take the lock so hammer_event() does not race with us here 
 Seed the state 
	
	  Request USB HID device to be in Full On mode, so that sending
	  hardware output report and hardware raw request won't fail.
 Request USB HID device back to Normal Mode. 
 Set backlight to 0% initially. 
 HID usage for keyboard backlight (Alphanumeric display brightness) 
		
		  We do not want to have this usage mapped as it will get
		  mixed in with "base attached" signal and delivered over
		  separate input device for tablet switch mode.
	
	  If we are getting events from Whiskers that means that it
	  is attached to the lid.
 We handled this event 
	
	  We always want to poll for, and handle tablet mode events from
	  devices that have folded usage, even when nobody has opened the input
	  device. This also prevents the hid core from dropping early tablet
	  mode events from the device.
		
		  If we are disconnecting then most likely Whiskers is
		  being removed. Even if it is not removed, without proper
		  keyboard we should not stay in clamshell mode.
		 
		  The reason for doing it here and not waiting for signal
		  from EC, is that on some devices there are high leakage
		  on Whiskers pins and we do not detect disconnect reliably,
		  resulting in devices being stuck in clamshell mode.
 SPDX-License-Identifier: GPL-2.0-or-later
  HID driver for Holtek gaming mice
  Copyright (c) 2013 Christian Ohm
  Heavily inspired by various other HID drivers that adjust the report
  descriptor.
  The report descriptor of some Holtek based gaming mice specifies an
  excessively large number of consumer usages (2^15), which is more than
  HID_MAX_USAGES. This prevents proper parsing of the report descriptor.
  This driver fixes the report descriptor for:
  - USB ID 04d9:a067, sold as Sharkoon Drakonia and Perixx MX-2000
  - USB ID 04d9:a04a, sold as Tracer Sniper TRM-503, NOVA Gaming Slider X200
    and Zalman ZM-GM1
  - USB ID 04d9:a081, sold as SHARKOON DarkGlider Gaming mouse
  - USB ID 04d9:a072, sold as LEETGION Hellion Gaming Mouse
  - USB ID 04d9:a0c2, sold as ETEKCITY Scroll T-140 Gaming Mouse
		 Change usage maximum and logical maximum from 0x7fff to
 SPDX-License-Identifier: GPL-2.0-or-later
  HID driver for Corsair devices
  Supported devices:
   - Vengeance K70 Keyboard
   - K70 RAPIDFIRE Keyboard
   - Vengeance K90 Keyboard
   - Scimitar PRO RGB Gaming Mouse
  Copyright (c) 2015 Clement Vuchener
  Copyright (c) 2017 Oscar Campos
  Copyright (c) 2017 Aaron Bottegal
 G1 (0xd0) to G16 (0xdf) 
 G17 (0xe8) to G18 (0xe9) 
 USB control protocol 
  LED class devices
  Keyboard attributes
  Driver functions
 Init LED device for record LED 
 Init attributes 
  The report descriptor of some of the Corsair gaming mice is
  non parseable as they define two consecutive Logical Minimum for
  the Usage Page (Consumer) in rdescs bytes 75 and 77 being 77 0x16
  that should be obviousy 0x26 for Logical Magimum of 16 bits. This
  prevents poper parsing of the report descriptor due Logical
  Minimum being larger than Logical Maximum.
  This driver fixes the report descriptor for:
  - USB ID 1b1c:1b34, sold as GLAIVE RGB Gaming mouse
  - USB ID 1b1c:1b3e, sold as Scimitar RGB Pro Gaming mouse
		
		  Corsair GLAIVE RGB and Scimitar RGB Pro report descriptor is
		  broken and defines two different Logical Minimum for the
		  Consumer Application. The byte 77 should be a 0x26 defining
		  a 16 bits integer for the Logical Maximum but it is a 0x16
		  instead (Logical Minimum)
	
	  Vengeance K70 and K70 RAPIDFIRE share product IDs.
 Original K90 driver author 
 Scimitar PRO RGB driver author 
 SPDX-License-Identifier: GPL-2.0-or-later
  HID driver for Google Fiber TV Box remote controls
  Copyright (c) 2014-2015 Google Inc.
  Author: Petri Gynther <pgynther@google.com>
 Google Fiber GFRM100 (Bluetooth classic) 
 Google Fiber GFRM200 (Bluetooth LE) 
 Consumer.0004 -> KEY_INFO 
 Consumer.0041 -> KEY_OK 
	
	  Convert GFRM100 Search key reports into Consumer.0221 (Key.Search)
	  reports. Ignore audio data.
	
	  Enable software autorepeat with:
	  - repeat delay: 400 msec
	  - repeat period: 100 msec
		
		  GFRM100 HID Report Descriptor does not describe the Search
		  key reports. Thus, we need to add it manually here, so that
		  those reports reach gfrm_raw_event() from hid_input_report().
 SPDX-License-Identifier: GPL-2.0-or-later
   (c) 1999 Andreas Gal		<gal@cs.uni-magdeburg.de>
   (c) 2000-2001 Vojtech Pavlik	<vojtech@ucw.cz>
   (c) 2007-2009 Jiri Kosina
   HID debugging support
  Should you need to contact me, the author, you can do so either by
  e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
  Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
 pages 0xff00 to 0xffff are vendor-specific 
 Either output directly into simple seq_file, or (if f == NULL)
  allocate a separate buffer that will then be passed to the 'events'
  ringbuffer.
  This is because these functions can be called both for "one-shot"
  "rdesc" while resolving, or for blocking "events".
  This holds both for resolv_usage_page() and hid_resolv_usage().
 First nibble tells us which system we're in. 
 This is a _signed_ nibble(!) 
 enqueue string to 'events' ring buffer 
 dump the report 
 dump HID report descriptor 
 dump parsed data and input mappings 
			 if list->hdev is NULL we cannot remove_wait_queue().
			  if list->hdev->debug is 0 then hid_debug_unregister()
			  was already called and list->hdev is being destroyed.
			  if we add remove_wait_queue() here we can hit a race.
 allow O_NONBLOCK from other threads 
	 pass the fifo content to userspace, locking is not needed with only
	  one concurrent reader and one concurrent writer
 SPDX-License-Identifier: GPL-2.0-or-later
    Apple "Magic" Wireless Mouse driver
    Copyright (c) 2010 Michael Poole <mdpoole@troilus.org>
    Copyright (c) 2010 Chase Douglas <chase.douglas@canonical.com>
 These definitions are not precise, but they're close enough.  (Bits
  0x03 seem to indicate the aspect ratio of the touch, bits 0x70 seem
  to be some kind of bit mask -- 0x20 may be a near-field reading,
  and 0x40 is actual contact, and 0x10 may be a startstop or change
  indication.)
 Number of high-resolution events for each low-resolution detent. 
 units 
 Touch surface information. Dimension is in hundredths of a mm, min and max
  struct magicmouse_sc - Tracks Magic Mouse-specific data.
  @input: Input device through which we report events.
  @quirks: Currently unused.
  @ntouches: Number of touches in most recent touch report.
  @scroll_accel: Number of consecutive scroll motions.
  @scroll_jiffies: Time of last scroll motion.
  @touches: Most recent data for a touch, indexed by tracking ID.
  @tracking_ids: Mapping of current touch input data to @touches.
	 If there is only one "firm" touch, set touch to its
	  tracking ID.
 Ignore this touch. 
		 If some button was pressed before, keep it held
		  down.  Otherwise, if there's exactly one firm
		  touch, use that to override the mouse's guess.
 The button was released. 
 else: we keep the mouse's guess 
 USB_DEVICE_ID_APPLE_MAGICTRACKPAD 
 Store tracking ID and other fields. 
	 If requested, emulate a scroll wheel by detecting small
	  vertical touch motions.
 Calculate and apply the scroll motion. 
 Reset acceleration after half a second. 
 Generate the input events for this touch. 
 Expect four bytes of prefix, and N9 bytes of touch data. 
		 The following bits provide a device specific timestamp. They
		  are unused here.
		 
		  ts = data[1] >> 6 | data[2] << 2 | data[3] << 10;
 Expect twelve bytes of prefix and N9 bytes of touch data. 
 Expect six bytes of prefix, and N8 bytes of touch data. 
		 When emulating three-button mode, it is important
		  to have the current touch information before
		  generating a click event.
		 The following bits provide a device specific timestamp. They
		  are unused here.
		 
		  ts = data[3] >> 6 | data[4] << 2 | data[5] << 10;
 Size is either 8 or (14 + 8  N) 
		 When emulating three-button mode, it is important
		  to have the current touch information before
		  generating a click event.
		 The following bits provide a device specific timestamp. They
		  are unused here.
		 
		  ts = data[11] >> 6 | data[12] << 2 | data[13] << 10;
		 Sometimes the trackpad sends two touch reports in one
		  packet.
 USB_DEVICE_ID_APPLE_MAGICTRACKPAD 
		
		  magic_mouse_raw_event has done all the work. Skip hidinput.
		 
		  Specifically, hidinput may modify BTN_LEFT and BTN_RIGHT,
		  breaking emulate_3button.
		 setting the device name to ensure the same driver settings
		  get loaded, whether connected through bluetooth or USB
 USB_DEVICE_ID_APPLE_MAGICTRACKPAD 
		 input->keybit is initialized with incorrect button info
		  for Magic Trackpad. There really is only one physical
		  button (BTN_LEFT == BTN_MOUSE). Make sure we don't
		  advertise buttons that don't exist...
	 Note: Touch Y position from the device is inverted relative
	  to how pointer motion is reported (and relative to how USB
	  HID recommends the coordinates work).  This driver keeps
	  the origin at the same position, and just uses the additive
	  inverse of the reported Y.
 USB_DEVICE_ID_APPLE_MAGICTRACKPAD 
	
	  hid-input may mark device as using autorepeat, but neither
	  the trackpad, nor the mouse actually want it.
 Magic Trackpad does not give relative data after switching to MT 
 clean msc->input to notify probe() of the failure 
 USB_VENDOR_ID_APPLE 
 USB_VENDOR_ID_APPLE 
 USB_DEVICE_ID_APPLE_MAGICTRACKPAD 
	
	  Some devices repond with 'invalid report id' when feature
	  report switching it into multitouch mode is sent to it.
	 
	  This results in -EIO from the _raw low-level transport callback,
	  but there seems to be no other way of switching the mode.
	  Thus the super-ugly hacky success check below.
 SPDX-License-Identifier: GPL-2.0-or-later
   Force feedback support for Betop based devices
   The devices are distributed under various names and the same USB device ID
   can be used in both adapters and actual game controllers.
   0x11c2:0x2208 "BTP2185 BFM mode Joystick"
    - tested with BTP2185 BFM Mode.
   0x11C0:0x5506 "BTP2185 PC mode Joystick"
    - tested with BTP2185 PC Mode.
   0x8380:0x1850 "BTP2185 V2 PC mode USB Gamepad"
    - tested with BTP2185 PC Mode with another version.
   0x20bc:0x5500 "BTP2185 V2 BFM mode Joystick"
    - tested with BTP2171s.
   Copyright (c) 2014 Huang Bo <huangbobupt@163.com>
	
	  Actually there are 4 fields for 4 Bytes as below:
	  -----------------------------------------
	  Byte0  Byte1  Byte2	  Byte3
	  0x00   0x00   left_motor right_motor
	  -----------------------------------------
	  Do init them with default value.
 SPDX-License-Identifier: GPL-2.0-or-later
  Roccat Isku driver for Linux
  Copyright (c) 2011 Stefan Achatz <erazor_de@users.sourceforge.net>
  Roccat Isku is a gamer keyboard with macro keys that can be configured in
  5 profiles.
 SPDX-License-Identifier: GPL-2.0-only
  HID driver for THQ PS3 uDraw tablet
  Copyright (C) 2016 Red Hat Inc. All Rights Reserved
  Protocol information from:
  https:brandonw.netudraw
  and the source code of:
  https:vvvv.orgcontributionudraw-hid
  The device is setup with multiple input devices:
  - the touch area which works as a touchpad
  - the tablet area which works as a touchpaddrawing tablet
  - a joypad with a d-pad, and 7 buttons
  - an accelerometer device
  Accelerometer minmax values
  in order, X, Y and Z
 resolution in pixels 
 size in mm 
	
	  The device's two-finger support is pretty unreliable, as
	  the device could report a single touch when the two fingers
	  are too close together, and the distance between fingers, even
	  though reported is not in the same unit as the touches.
	 
	  We'll make do without it, and try to report the first touch
	  as reliably as possible.
 joypad 
 For pen and touchpad 
 Save the last one-finger touch 
		
		  We have a problem because xy is the one for the
		  second finger but we want the first finger given
		  to user-space otherwise it'll look as if it jumped.
		 
		  See the udraw struct definition for why this was
		  implemented this way.
 Save the position of the 2nd finger 
			
			  Offset the 2-finger coords using the
			  saved data from the first finger
 touchpad 
 pen 
 accel 
 let hidraw and hiddev handle the report 
 1G accel is reported as ~256, so clamp to 2G 
 SPDX-License-Identifier: GPL-2.0-or-later
  driversinputtabletwacom_sys.c
   USB Wacom tablet support - system specific code
 Queue events which have invalid tool type or serial number 
 If we go out of range, we need to flush the queue ASAP 
	
	  wacom->hdev should never be null, but surprisingly, I had the case
	  once while unplugging the Wacom Wireless Receiver.
  Calculate the resolution of the X or Y axis using hidinput_calc_abs_res.
	
	  The Dell Canvas 27 needs to be switched to its vendor-defined
	  report to provide the best resolution.
	
	  ISDv4 devices which predate HID's adoption of the
	  HID_DG_BARELSWITCH2 usage use 0x000D0000 in its
	  position instead. We can accurately detect if a
	  usage with that value should be HID_DG_BARRELSWITCH2
	  based on the surrounding usages, which have remained
	  constant across generations.
	
	  Wacom's AES devices use different vendor-defined usages to
	  report serial number information compared to their branded
	  hardware. The usages are also sometimes ill-defined and do
	  not have the correct logical minmax values set. Lets patch
	  the descriptor to use the branded usage convention and fix
	  the errors.
 2nd-generation Intuos Pro Large has incorrect Y maximum 
 leave touch_max as is if predefined 
 read manually 
 Ignore if value index is out of bounds. 
 read manually 
  Interface Descriptor of wacom devices can be incomplete and
  inconsistent so wacom_features table is used to store stylus
  device's packet lengths, various maximum values, and tablet
  resolution based on product ID's.
  For devices that contain 2 interfaces, wacom_features table is
  inaccurate for the touch interface.  Since the Interface Descriptor
  for touch interfaces has pretty complete data, this function exists
  to query tablet for this missing information instead of hard coding in
  an additional table.
  A typical Interface Descriptor for a stylus will contain a
  boot mouse application collection that is not of interest and this
  function will ignore it.
  It also contains a digitizer application collection that also is not
  of interest since any information it contains would be duplicate
  of what is in wacom_features. Usually it defines a report of an array
  of bytes that could be used as max length of the stylus packet returned.
  If it happens to define a Digitizer-Stylus Physical Collection then
  the X and Y logical values contain valid data but it is ignored.
  A typical Interface Descriptor for a touch interface will contain a
  Digitizer-Finger Physical Collection which will define both logical
  XY maximum as well as the physical size of tablet. Since touch
  interfaces haven't supported pressure or distance, this is enough
  information to override invalid values in the wacom_features table.
  Intuos5 touch interface and 3rd gen Bamboo Touch do not contain useful
  data. We deal with them after returning from this function.
	
	 Requiring Stylus Usage will ignore boot mouse
	 XY values and some cases of invalid Digitizer XY
	 values commonly reported.
 Any last-minute generic device setup 
 check features first 
 Ignore if report count is out of bounds. 
 now check the input usages 
		
		  Note that if the raw queries fail, it's not a hard failure
		  and it is safe to continue
  Switch the tablet into its most-capable mode. Wacom tablets are
  typically configured to power-up in a mode which sends mouse-like
  reports to the OS. To get absolute position, pressure data, etc.
  from the tablet, it is necessary to switch the tablet out of this
  mode and into one which sends the full range of tablet data.
 MT Tablet PC touch 
 default features 
	
	  The wireless device HID is basic and layout conflicts with
	  other tablets (monitor and touch interface can look like pen).
	  Skip the query for this type and modify defaults based on
	  interface number.
 The defined oVidoPid must match that of the sibling 
	
	  Devices with the same VIDPID must share the same physical
	  device path, while those with different VIDPID must share
	  the same physical parent device path.
 Skip the remaining heuristics unless you are a HID_GENERIC device 
	
	  Direct-input devices may not be siblings of indirect-input
	  devices.
	
	  Indirect-input devices may not be siblings of direct-input
	  devices.
 Pen devices may only be siblings of touch devices 
 Touch devices may only be siblings of pen devices 
	
	  No reason could be found for these two devices to NOT be
	  siblings, so there's a good chance they ARE siblings
 Try to find an already-probed interface from the same device 
 Fallback to finding devices that appear to be "siblings" 
 wireless connected 
		
		  Touch Ring and crop mark LED luminance may take on
		  one of four values:
		     0 = Low; 1 = Medium; 2 = High; 3 = Off
 Power Connection LED (ORANGE)
 BT Connection LED (BLUE)
 Paper Mode (RED?)
 Paper Mode (GREEN?)
 Paper Mode (BLUE?)
 4 chunks are needed to be sent 
 Send 'start' command 
 Send 'stop' 
 device doesn't support brightness tuning 
	
	  There is a bug (?) in devm_led_classdev_register() in which its
	  increments the refcount of the parent. If the parent is an input
	  device, that means the ref count never reaches 0 when
	  devm_input_device_release() gets called.
	  This means that the LEDs are still there after disconnect.
	  Manually force the release of the group so that the leds are released
	  once we are done using them.
  wacom_led_next: gives the next available led with a wacom trigger.
  returns the next available struct wacom_led which has its default trigger
  or the current one if none is available.
 Initialize default values 
 no pen in use on this interface 
 no touch in use on this interface 
 no pad in use on this interface 
  Not all devices report physical dimensions from HID.
  Compute the default from hardcoded logical dimension
  and resolution before driver overwrites them.
 set unit to "100th of a mm" for devices not reported by HID 
 Leave some room for suffixes 
 Generic devices name unspecified 
 strip out excess whitespaces 
 shift everything including the terminator 
 get rid of trailing whitespace 
 Append the device type to the name 
		 Hardware touch switch may be off. Wait until
		  we know the switch state to decide is_touch_on.
		  Softkey state should be initialized to "on" to
		  match historic default.
	
	  Bamboo Pad has a generic hid handling for the Pen, and we switch it
	  into debug mode for the touch part.
	  We ignore the other interfaces.
 set the default size in case we do not get them from hid 
 Retrieve the physical and logical size for touch devices 
 pen only Bamboo neither support touch nor pad 
 Regular HID work starts now 
 Note that if query fails it is not a hard failure 
 touch only Bamboo doesn't support pen 
	
	  Regardless if this is a disconnect or a new tablet,
	  remove any existing input and battery devices.
 Stylus interface 
 Touch interface 
 Stylus interface 
 Touch interface 
	 A remote can pair more than once with an EKR,
	  check to make sure this serial isn't already paired.
 hid-core sets this quirk for the boot interface 
 ask for the report descriptor to be loaded by HID 
 make sure we don't trigger the LEDs 
 switch to wacom mode first 
 CONFIG_PM 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for Retrode 2 controller adapter and plug-in extensions
   Copyright (c) 2017 Bastien Nocera <hadess@hadess.net>
 Has no effect on the mouse device 
 SPDX-License-Identifier: GPL-2.0+
  HID driver for Valve Steam Controller
  Copyright (c) 2018 Rodrigo Rivas Costa <rodrigorivascosta@gmail.com>
  Supports both the wired and wireless interfaces.
  This controller has a builtin emulation of mouse and keyboard: the right pad
  can be used as a mouse, the shoulder buttons are mouse buttons, A and B
  buttons are ENTER and ESCAPE, and so on. This is implemented as additional
  HID interfaces.
  This is known as the "lizard mode", because apparently lizards like to use
  the computer from the coach, without a proper mouse and keyboard.
  This driver will disable the lizard mode when the input device is opened
  and re-enable it when the input device is closed, so as not to break user
  mode behaviour. The lizard_mode parameter can be used to change that.
  There are a few user space applications (notably Steam Client) that use
  the hidraw interface directly to create input devices (XTest, uinput...).
  In order to avoid breaking them this driver creates a layered hidraw device,
  so it can detect when the client is running and then:
   - it will not send any command to the controller.
   - this input device will be removed, to avoid double input of the same
     user action.
  When the client is closed, this input device will be created again.
  For additional functions, such as changing the right-pad margin or switching
  the led, you can use the user-space tool at:
    https:github.comrodrigorcsteamctrl
 Touch pads are 40 mm in diameter and 65535 units 
 Trigger runs are about 5 mm and 256 units 
 Joystick runs are about 5 mm and 256 units 
  Commands that can be sent in a feature report.
  Thanks to Valve for some valuable hints.
 Some useful register ids 
 Raw event identifiers 
 Values for GYRO_MODE (bitmask) 
 Other random constants 
	
	  The report ID is always 0, so strip the first byte from the output.
	  hid_report_len() is not counting the report ID, so +1 to the length
	  or else we get a EOVERFLOW. We are safe from a buffer overflow
	  because hid_alloc_report_buf() allocates +7 bytes.
 The report ID is always 0 
	
	  Sometimes the wireless controller fails with EPIPE
	  when sending a feature report.
	  Doing a HID_REQ_GET_REPORT and waiting for a while
	  seems to fix that.
 u8 reg, u16 val ...)
 Send: 0x87 len (reg valLo valHi) 
	
	  Send: 0xae 0x15 0x01
	  Recv: 0xae 0x15 0x01 serialnumber (10 chars)
  This command requests the wireless adaptor to post an event
  with the connection status. Useful if this driver is loaded when
  the controller is already connected.
 enable esc, enter, cursors 
 enable mouse 
 enable margin 
 disable esc, enter, cursor 
 disable mouse 
 disable margin 
 mV -> uV 
 avoid the warning of 0% battery while waiting for the first info 
	
	  This function can be called several times in a row with the
	  wireless adaptor, without steam_unregister() between them, because
	  another client send a get_connection_status command, for example.
	  The battery and serial number are set just once per device.
		
		  Unlikely, but getting the serial could fail, and it is not so
		  important, so make up a serial number and go on.
 ignore battery errors, we can live without it 
	
	  The wired device creates 3 interfaces:
	   0: emulated mouse.
	   1: emulated keyboard.
	   2: the real game pad.
	  The wireless device creates 5 interfaces:
	   0: emulated keyboard.
	   1-4: slots where up to 4 real game pads will be connected to.
	  We know which one is the real gamepad interface because they are the
	  only ones with a feature report.
	
	  Since we use the same device info than the real interface to
	  trick userspace, we will be calling steam_probe recursively.
	  We need to recognize the client interface somehow.
	
	  The virtual client_dev is only used for hidraw.
	  Also avoid the recursive probe.
	
	  The non-valve interfaces (mouse and keyboard emulation) are
	  connected without changes.
	
	  With the real steam controller interface, do not connect hidraw.
	  Instead, create the client_hid and connect that.
 If using a wireless adaptor ask for connection status 
 A wired connection is always present 
  Some input data in the protocol has the opposite sign.
  Clamp the values to 32767..-32767 so that the range is
  symmetrical and can be negated safely.
  The size for this message payload is 60.
  The known values are:
   ( values are not sent through wireless)
   ( acceleratorgyro is disabled by default)
   Offset| Type  | Mapped to |Meaning
  -------+-------+-----------+--------------------------
   4-7   | u32   | --        | sequence number
   8-10  | 24bit | see below | buttons
   11    | u8    | ABS_HAT2Y | left trigger
   12    | u8    | ABS_HAT2X | right trigger
   13-15 | --    | --        | always 0
   16-17 | s16   | ABS_XABS_HAT0X     | X value
   18-19 | s16   | ABS_YABS_HAT0Y     | Y value
   20-21 | s16   | ABS_RX    | right-pad X value
   22-23 | s16   | ABS_RY    | right-pad Y value
   24-25 | s16   | --        |  left trigger
   26-27 | s16   | --        |  right trigger
   28-29 | s16   | --        |  accelerometer X value
   30-31 | s16   | --        |  accelerometer Y value
   32-33 | s16   | --        |  accelerometer Z value
   34-35 | s16   | --        | gyro X value
   36-36 | s16   | --        | gyro Y value
   38-39 | s16   | --        | gyro Z value
   40-41 | s16   | --        | quaternion W value
   42-43 | s16   | --        | quaternion X value
   44-45 | s16   | --        | quaternion Y value
   46-47 | s16   | --        | quaternion Z value
   48-49 | --    | --        | always 0
   50-51 | s16   | --        |  left trigger (uncalibrated)
   52-53 | s16   | --        |  right trigger (uncalibrated)
   54-55 | s16   | --        |  joystick X value (uncalibrated)
   56-57 | s16   | --        |  joystick Y value (uncalibrated)
   58-59 | s16   | --        |  left-pad X value
   60-61 | s16   | --        |  left-pad Y value
   62-63 | u16   | --        |  battery voltage
  The buttons are:
   Bit  | Mapped to  | Description
  ------+------------+--------------------------------
   8.0  | BTN_TR2    | right trigger fully pressed
   8.1  | BTN_TL2    | left trigger fully pressed
   8.2  | BTN_TR     | right shoulder
   8.3  | BTN_TL     | left shoulder
   8.4  | BTN_Y      | button Y
   8.5  | BTN_B      | button B
   8.6  | BTN_X      | button X
   8.7  | BTN_A      | button A
   9.0  | BTN_DPAD_UP    | lef-pad up
   9.1  | BTN_DPAD_RIGHT | lef-pad right
   9.2  | BTN_DPAD_LEFT  | lef-pad left
   9.3  | BTN_DPAD_DOWN  | lef-pad down
   9.4  | BTN_SELECT | menu left
   9.5  | BTN_MODE   | steam logo
   9.6  | BTN_START  | menu right
   9.7  | BTN_GEAR_DOWN | left back lever
  10.0  | BTN_GEAR_UP   | right back lever
  10.1  | --         | left-pad clicked
  10.2  | BTN_THUMBR | right-pad clicked
  10.3  | BTN_THUMB  | left-pad touched (but see explanation below)
  10.4  | BTN_THUMB2 | right-pad touched
  10.5  | --         | unknown
  10.6  | BTN_THUMBL | joystick clicked
  10.7  | --         | lpad_and_joy
 24 bits of buttons 
	
	  These two bits tells how to interpret the values X and Y.
	  lpad_and_joy tells that the joystick and the lpad are used at the
	  same time.
	  lpad_touched tells whether XY are to be read as lpad coord or
	  joystick values.
	  (lpad_touched || lpad_and_joy) tells if the lpad is really touched.
 Check if joystick is centered 
 Check if lpad is untouched 
  The size for this message payload is 11.
  The known values are:
   Offset| Type  | Meaning
  -------+-------+---------------------------
   4-7   | u32   | sequence number
   8-11  | --    | always 0
   12-13 | u16   | voltage (mV)
   14    | u8    | battery percent
 Creating the battery may have failed 
	
	  All messages are size=64, all values little-endian.
	  The format is:
	   Offset| Meaning
	  -------+--------------------------------------------
	   0-1   | always 0x01, 0x00, maybe protocol version?
	   2     | type of message
	   3     | length of the real payload (not checked)
	   4-n   | payload data, depends on the type
	 
	  There are these known types of message:
	   0x01: input data (60 bytes)
	   0x03: wireless connectdisconnect (1 byte)
	   0x04: battery status (11 bytes)
		
		  The payload of this event is a single byte:
		   0x01: disconnected.
		   0x02: connected.
 Wired Steam Controller 
 Wireless Steam Controller 
 SPDX-License-Identifier: GPL-2.0+
  HID driver for Nintendo Switch Joy-Cons and Pro Controllers
  Copyright (c) 2019-2021 Daniel J. Ogorchock <djogorchock@gmail.com>
  The following resourcesprojects were referenced for this driver:
    https:github.comdekuNukemNintendo_Switch_Reverse_Engineering
    https:gitlab.compjrankijoycon-linux-kernel (Peter Rankin)
    https:github.comFrotBotSwitchProConLinuxUSB
    https:github.comMTCKCProconXInput
    https:github.comDavidobotBetterJoyForCemu
    hid-wiimote kernel hid driver
    hid-logitech-hidpp driver
    hid-sony driver
  This driver supports the Nintendo Switch Joy-Cons and Pro Controllers. The
  Pro Controllers can either be used over USB or Bluetooth.
  The driver will retrieve the factory calibration info from the controllers,
  so little to no user calibration should be required.
  Reference the url below for the following HID report defines:
  https:github.comdekuNukemNintendo_Switch_Reverse_Engineering
 Output Reports 
 Subcommand IDs 
 Input Reports 
 Feature Reports 
 USB Commands 
 Magic value denoting presence of user calibration 
 SPI storage addresses of user calibration data 
 SPI storage addresses of factory calibration data 
 SPI storage addresses of IMU factory calibration data 
 SPI storage addresses of IMU user calibration data 
 The raw analog joystick values will be mapped in terms of this magnitude 
 Hat values for pro controller's d-pad 
 Under most circumstances IMU reports are pushed every 15ms; use as default 
 How many samples to sum before calculating average IMU report delta 
 Controls how many dropped IMU packets at once trigger a warning message 
  The controller's accelerometer has a sensor resolution of 16bits and is
  configured with a range of +-8000 milliGs. Therefore, the resolution can be
  calculated thus: (2^16-1)(8000  2) = 4.096 digits per milliG
  Resolution per G (rather than per millliG): 4.096  1000 = 4096 digits per G
  Alternatively: 14096 = .0002441 Gs per digit
  The controller's gyroscope has a sensor resolution of 16bits and is
  configured with a range of +-2000 degreessecond.
  Digits per dps: (2^16 -1)(20002) = 16.38375
  dps per digit: 16.38375E-1 = .0610
  STMicro recommends in the datasheet to add 15% to the dpsdigit. This allows
  the full sensitivity range to be saturated without clipping. This yields more
  accurate results, so it's the technique this driver uses.
  dps per digit (corrected): .0610  1.15 = .0702
  digits per dps (corrected): .0702E-1 = 14.247
  Now, 14.247 truncating to 14 loses a lot of precision, so we rescale the
  minmax range by 1000.
 Note: change mag and res_per_dps if prec_range_scale is ever altered 
 (2^16-1)1000 
 (14.2471000) 
 frequencyamplitude tables for rumble 
 Hz
  These tables are from
  https:github.comdekuNukemNintendo_Switch_Reverse_Engineeringblobmasterrumble_data_table.md
 high, low, freq 
 high, low, amp 
 States for controller state machine 
 Controller type received as part of device info 
  All the controller's button values are stored in a u32.
  They can be accessed with bitwise ANDs.
 capture button 
 must be 0x01 for subcommand, 0x10 for rumble only 
 incremented every send 
 length depends on the subcommand 
 MSB 1 for ACK, 0 for NACK 
 id of requested subcmd 
 will be at most 35 bytes 
 battery and connection info 
 IMU input reports contain 3 samples 
 Each physical controller is associated with a joycon_ctlr struct 
 player leds 
 The following members are used for synchronous sendsreceives 
 factory calibration data 
 prevents needlessly recalculating these divisors every sample 
 power supply data 
 rumble 
 imu 
 helps in initiating timestamp 
 timestamp we report to userspace 
 used to calc imu report delta 
 the following are used to track the average imu report time delta 
 Helper macros for checking controller type 
 Does this controller have inputs associated with left joycon? 
 Does this controller have inputs associated with right joycon? 
	
	  If we are in the proper reporting mode, wait for an input
	  report prior to sending the subcommand. This improves
	  reliability considerably.
 We will still proceed, even with a timeout here 
  Sending subcommands andor rumble data at too high a rate can cause bluetooth
  controller disconnections.
	
	  The controller occasionally seems to drop subcommands. In testing,
	  doing one retry after a timeout appears to always work.
	
	  If the controller has been removed, just return ENODEV so the LED
	  subsystem doesn't print invalid errors on removal.
 Supply nibbles for flash and on. Ones correspond to active 
 The read data starts at the 6th byte 
  User calibration's presence is denoted with a magic byte preceding it.
  returns 0 if magic val is present, 1 if not present, < 0 on error
 stick calibration parsing: note the order differs based on stick 
 check if user stick calibrations are present 
 read the left stick calibration data 
 read the right stick calibration data 
  These divisors are calculated once rather than for each sample. They are only
  dependent on the IMU calibration values. They are used when processing the
  IMU input reports.
= 0;
= 0;
 check if user calibration exists 
 request IMU calibration data 
 IMU calibration parsing 
 standard, full report mode 
 note: 0x00 would disable 
 note: 0x00 would disable 
 point to next imu sample 
 3 reports per packet 
	
	  There are complexities surrounding how we determine the timestamps we
	  associate with the samples we pass to userspace. The IMU input
	  reports do not provide us with a good timestamp. There's a quickly
	  incrementing 8-bit counter per input report, but it is not very
	  useful for this purpose (it is not entirely clear what rate it
	  increments at or if it varies based on packet push rate - more on
	  the push rate below...).
	 
	  The reverse engineering work done on the joy-cons and pro controllers
	  by the community seems to indicate the following:
	  - The controller samples the IMU every 1.35ms. It then does some of
	    its own processing, probably averaging the samples out.
	  - Each imu input report contains 3 IMU samples, (usually 5ms apart).
	  - In the standard reporting mode (which this driver uses exclusively)
	    input reports are pushed from the controller as follows:
	        joy-con (bluetooth): every 15 ms
	        joy-cons (in charging grip via USB): every 15 ms
	        pro controller (USB): every 15 ms
	        pro controller (bluetooth): every 8 ms (this is the wildcard)
	 
	  Further complicating matters is that some bluetooth stacks are known
	  to alter the controller's packet rate by hardcoding the bluetooth
	  SSR for the switch controllers (android's stack currently sets the
	  SSR to 11ms for both the joy-cons and pro controllers).
	 
	  In my own testing, I've discovered that my pro controller either
	  reports IMU sample batches every 11ms or every 15ms. This rate is
	  stable after connecting. It isn't 100% clear what determines this
	  rate. Importantly, even when sending every 11ms, none of the samples
	  are duplicates. This seems to indicate that the time deltas between
	  reported samples can vary based on the input report rate.
	 
	  The solution employed in this driver is to keep track of the average
	  time delta between IMU input reports. In testing, this value has
	  proven to be stable, staying at 15ms or 11ms, though other hardware
	  configurations and bluetooth stacks could potentially see other rates
	  (hopefully this will become more clear as more people use the
	  driver).
	 
	  Keeping track of the average report delta allows us to submit our
	  timestamps to userspace based on that. Each report contains 3
	  samples, so the IMU sampling rate should be avg_time_delta3. We can
	  also use this average to detect events where we have dropped a
	  packet. The userspace timestamp for the samples will be adjusted
	  accordingly to prevent unwanted behvaior.
 avg imu report delta housekeeping 
 don't ever want divide by zero shenanigans 
 useful for debugging IMU sample rate 
 check if any packets have been dropped 
 Each IMU input report contains three samples 
		
		  These calculations (which use the controller's calibration
		  settings to improve the final values) are based on those
		  found in the community's reverse-engineering repo (linked at
		  top of driver). For hid-nintendo, we make sure that the final
		  value given to userspace is always in terms of the axis
		  resolution we provided.
		 
		  Currently only the gyro calculations subtract the calibration
		  offsets from the raw value itself. In testing, doing the same
		  for the accelerometer raw values decreased accuracy.
		 
		  Note that the gyro values are multiplied by the
		  precision-saving scaling factor to prevent large inaccuracies
		  due to truncation of the resolution value which would
		  otherwise occur. To prevent overflow (without resorting to 64
		  bit integer math), the mult_frac macro is used.
		
		  The right joy-con has 2 axes negated, Y and Z. This is due to
		  the orientation of the IMU in the controller. We negate those
		  axes' values in order to be consistent with the left joy-con
		  and the pro controller:
		    X: positive is pointing toward the triggers
		    Y: positive is pointing to the left
		    Z: positive is pointing up (out of the buttonssticks)
		  The axes follow the right-hand rule.
 negate all but x axis 
 convert to micros and divide by 3 (3 samples per report). 
		
		  When this value reaches 0, we know we've sent multiple
		  packets to the controller instructing it to disable rumble.
		  We can safely stop sending periodic rumble packets until the
		  next ff effect.
 Parse the battery status 
 empty 
 low 
 medium 
 high 
 full 
 Parse the buttons and sticks 
 get raw stick values 
 map the stick values 
 report sticks 
 report buttons 
 Report the S buttons as the non-existent triggers 
 Report d-pad as digital buttons for the joy-cons 
 d-pad x 
 d-pad y 
 get raw stick values 
 map stick values 
 report sticks 
 report buttons 
 Report the S buttons as the non-existent triggers 
	
	  Immediately after receiving a report is the most reliable time to
	  send a subcommand to the controller. Wake any subcommand senders
	  waiting for a report.
 parse IMU data if present 
	
	  If the controller has been removed, just return ENODEV so the LED
	  subsystem doesn't print invalid errors on removal.
 -ENODEV means the controller was just unplugged 
 limit number of silent rumble packets to reduce traffic 
 right joy-con 
 left joy-con 
 don't wait for the periodic send (reduces latency) 
 IS_ENABLED(CONFIG_NINTENDO_FF) 
 0 signals end of array 
 0 signals end of array 
 We report joy-con d-pad inputs as buttons and pro controller as a hat. 
 Should be impossible 
 set up sticks and buttons 
 configure d-pad differently for joy-con vs pro controller 
 Let's report joy-con S triggers separately 
 set up rumble 
 configure the imu input device 
 configure imu axes 
 determine which player led this is 
 Set the default controller player leds based on controller number 
 configure the player LEDs 
 configure the home LED 
 Set the home LED to 0 as default state 
 Set initially to unknown before receiving first input report 
 Configure the battery's description 
 Retrieve the type so we can distinguish for charging grip 
 Common handler for parsing inputs 
 make sure it contains the input report 
 This message has been handled 
	
	  Patch the hw version of pro controllerjoycons, so applications can
	  distinguish between the default HID mappings and the mappings defined
	  by the Linux game controller spec. This is important for the SDL2
	  library, which has a game controller database, which uses device ids
	  in combination with version as a key.
 Initialize the controller 
 if handshake command fails, assume ble pro controller 
 set baudrate for improved latency 
 handshake 
		
		  Set no timeout (to keep controller in USB mode).
		  This doesn't send a response, so ignore the timeout.
 get controller calibration data, and parse it 
		
		  We can function with default calibration, but it may be
		  inaccurate. Provide a warning, and continue on.
 get IMU calibration data, and parse it 
		
		  We can function with default calibration, but it may be
		  inaccurate. Provide a warning, and continue on.
 Set the reporting mode to 0x30, which is the full report mode 
 Enable rumble 
 Enable the IMU 
 Initialize the leds 
 Initialize the battery power supply 
 Prevent further attempts at sending subcommands. 
 SPDX-License-Identifier: GPL-2.0+
   HID driver for gaming keys on Logitech gaming keyboards (such as the G15)
   Copyright (c) 2019 Hans de Goede <hdegoede@redhat.com>
 Must be first for proper dma alignment 
 Protects the transfer_buf and led brightness 
 G15 and G15 v2 LED functions 
 Ignore LED off on unregister  keyboard unplug 
 Success 
 G510 LED functions 
 Must be called with g15->mutex locked 
 Success 
 Ignore LED off on unregister  keyboard unplug 
 Ignore LED off on unregister  keyboard unplug 
 Success 
 Generic LED functions 
		
		  Getting the LCD backlight brightness is not supported.
		  Reading Feature(2) fails with -EPIPE and this crashes
		  the LCD and touch keys part of the speakers.
 Never reached 
 Input functions 
 On the G15 Mark I Logitech has been quite creative with which bit is what 
 Most left (rounddisplay) button below the LCD 
 4 other buttons below the LCD 
 G1 - G6 
 G7 - G12 
 G13 - G17 
 G18 
 M1 - M3 
 MR 
 Backlight cycle button pressed? 
 G1 - G6 
 M1 - M3 + MR 
 Round button to the left of the LCD 
 4 buttons below the LCD 
 Backlight cycle button pressed? 
 G1 - G18 
 Game mode onoff slider 
 M1 - M3 
 MR 
 LCD menu keys 
 Headphone Mute 
 Microphone Mute 
	
	  The G510 ignores backlight updates when the backlight is turned off
	  through the light toggle button on the keyboard, to work around this
	  we queue a workitem to sync values when the backlight is turned on.
			
			  The G510 does not have a separate LCD brightness,
			  but it does have a separate power-on (reset) value.
 Common input device init code shared between keyboards and Z-10 speaker handling 
 Keys below the LCD, intended for controlling a menu on the LCD 
	
	  Some models have multiple interfaces, we want the interface with
	  with the f000.0000 application input report.
		
		  The G15 and G15 v2 use a separate usb-device (on a builtin
		  hub) which emulates a keyboard for the F1 - F12 emulation
		  on the G-keys, which we disable, rendering the emulated kbd
		  non-functional, so we do not let hid-input connect.
 Tell the keyboard to stop sending F1-F12 + 1-6 for G1 - G18 
		
		  The kbd ignores our output report if we do not queue
		  an URB on the USB input endpoint first...
 Get initial brightness levels 
 All done 
 Setup and register input device 
 G-keys 
 M1 - M3 and MR keys 
	
	  On the G510 only report headphone and mic mute keys when not using
	  the builtin USB audio device. When the builtin audio is used these
	  keys directly toggle mute (and the LEDs) onoff.
 Userspace expects F20 for micmute 
 Register LED devices 
 The G11 is a G15 without the LCD, treat it as a G15 
 G510 without a headset plugged in 
 G510 with headset plugged in  with extra USB audio interface 
 Z-10 speakers 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for Waltop devices not fully compliant with HID standard
   Copyright (c) 2010 Nikolai Kondrashov
  There exists an official driver on the manufacturer's website, which
  wasn't submitted to the kernel, for some reason. The official driver
  doesn't seem to support extra features of some tablets, like wheels.
  It shows that the feature report ID 2 could be used to control any waltop
  tablet input mode, switching it between "default", "tablet" and "ink".
  This driver only uses "default" mode for all the supported tablets. This
  mode tries to be HID-compatible (not very successfully), but cripples the
  resolution of some tablets.
  The "tablet" mode uses some proprietary, yet decipherable protocol, which
  represents the correct resolution, but is possibly HID-incompatible (i.e.
  indescribable by a report descriptor).
  The purpose of the "ink" mode is unknown.
  The feature reports needed for switching to each mode are these:
  02 16 00     default
  02 16 01     tablet
  02 16 02     ink
 Size of the original report descriptor of Slim Tablet 5.8 inch 
 Fixed Slim Tablet 5.8 inch descriptor 
  Usage Page (Digitizer),             
  Usage (Pen),                        
  Collection (Application),           
      Report ID (16),                 
      Usage (Stylus),                 
      Collection (Physical),          
          Usage (Tip Switch),         
          Usage (Barrel Switch),      
          Usage (Tablet Pick),        
          Logical Minimum (1),        
          Logical Maximum (3),        
          Report Size (4),            
          Report Count (1),           
          Input,                      
          Usage (In Range),           
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Size (1),            
          Report Count (1),           
          Input (Variable),           
          Report Count (3),           
          Input (Constant, Variable), 
          Report Size (16),           
          Report Count (1),           
          Logical Minimum (0),        
          Push,                       
          Usage Page (Desktop),       
          Unit (Inch),                
          Unit Exponent (-3),         
          Physical Minimum (0),       
          Usage (X),                  
          Physical Maximum (5000),    
          Logical Maximum (10000),    
          Input (Variable),           
          Usage (Y),                  
          Physical Maximum (3000),    
          Logical Maximum (6000),     
          Input (Variable),           
          Pop,                        
          Usage (Tip Pressure),       
          Logical Maximum (1023),     
          Input (Variable),           
      End Collection,                 
  End Collection                      
 Size of the original report descriptor of Slim Tablet 12.1 inch 
 Fixed Slim Tablet 12.1 inch descriptor 
  Usage Page (Digitizer),             
  Usage (Pen),                        
  Collection (Application),           
      Report ID (16),                 
      Usage (Stylus),                 
      Collection (Physical),          
          Usage (Tip Switch),         
          Usage (Barrel Switch),      
          Usage (Tablet Pick),        
          Logical Minimum (1),        
          Logical Maximum (3),        
          Report Size (4),            
          Report Count (1),           
          Input,                      
          Usage (In Range),           
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Size (1),            
          Report Count (1),           
          Input (Variable),           
          Report Count (3),           
          Input (Constant, Variable), 
          Report Size (16),           
          Report Count (1),           
          Logical Minimum (0),        
          Push,                       
          Usage Page (Desktop),       
          Unit (Inch),                
          Unit Exponent (-3),         
          Physical Minimum (0),       
          Usage (X),                  
          Physical Maximum (10000),   
          Logical Maximum (20000),    
          Input (Variable),           
          Usage (Y),                  
          Physical Maximum (6250),    
          Logical Maximum (12500),    
          Input (Variable),           
          Pop,                        
          Usage (Tip Pressure),       
          Logical Maximum (1023),     
          Input (Variable),           
      End Collection,                 
  End Collection                      
 Size of the original report descriptor of Q Pad 
 Fixed Q Pad descriptor 
  Usage Page (Digitizer),             
  Usage (Pen),                        
  Collection (Application),           
      Report ID (16),                 
      Usage (Stylus),                 
      Collection (Physical),          
          Usage (Tip Switch),         
          Usage (Barrel Switch),      
          Usage (Tablet Pick),        
          Logical Minimum (1),        
          Logical Maximum (3),        
          Report Size (4),            
          Report Count (1),           
          Input,                      
          Usage (In Range),           
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Size (1),            
          Report Count (1),           
          Input (Variable),           
          Report Count (3),           
          Input (Constant, Variable), 
          Report Size (16),           
          Report Count (1),           
          Logical Minimum (0),        
          Push,                       
          Usage Page (Desktop),       
          Unit (Inch),                
          Unit Exponent (-3),         
          Physical Minimum (0),       
          Usage (X),                  
          Physical Maximum (6000),    
          Logical Maximum (12288),    
          Input (Variable),           
          Usage (Y),                  
          Physical Maximum (4500),    
          Logical Maximum (9216),     
          Input (Variable),           
          Pop,                        
          Usage (Tip Pressure),       
          Logical Maximum (1023),     
          Input (Variable),           
      End Collection,                 
  End Collection                      
 Size of the original report descriptor of tablet with PID 0038 
  Fixed report descriptor for tablet with PID 0038.
  Usage Page (Digitizer),             
  Usage (Pen),                        
  Collection (Application),           
      Report ID (16),                 
      Usage (Stylus),                 
      Collection (Physical),          
          Usage (Tip Switch),         
          Usage (Barrel Switch),      
          Usage (Tablet Pick),        
          Logical Minimum (1),        
          Logical Maximum (3),        
          Report Size (4),            
          Report Count (1),           
          Input,                      
          Usage (In Range),           
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Size (1),            
          Report Count (1),           
          Input (Variable),           
          Report Count (3),           
          Input (Constant, Variable), 
          Report Size (16),           
          Report Count (1),           
          Logical Minimum (0),        
          Push,                       
          Usage Page (Desktop),       
          Unit (Inch),                
          Unit Exponent (-3),         
          Physical Minimum (0),       
          Usage (X),                  
          Physical Maximum (8750),    
          Logical Maximum (17920),    
          Input (Variable),           
          Usage (Y),                  
          Physical Maximum (5250),    
          Logical Maximum (10752),    
          Input (Variable),           
          Pop,                        
          Usage (Tip Pressure),       
          Logical Maximum (1023),     
          Input (Variable),           
      End Collection,                 
  End Collection                      
 Size of the original report descriptor of Media Tablet 10.6 inch 
 Fixed Media Tablet 10.6 inch descriptor 
  Usage Page (Digitizer),             
  Usage (Pen),                        
  Collection (Application),           
      Report ID (16),                 
      Usage (Stylus),                 
      Collection (Physical),          
          Usage (Tip Switch),         
          Usage (Barrel Switch),      
          Usage (Tablet Pick),        
          Logical Minimum (1),        
          Logical Maximum (3),        
          Report Size (4),            
          Report Count (1),           
          Input,                      
          Report Size (1),            
          Usage (In Range),           
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Count (1),           
          Input (Variable),           
          Report Count (3),           
          Input (Constant, Variable), 
          Report Size (16),           
          Report Count (1),           
          Logical Minimum (0),        
          Push,                       
          Usage Page (Desktop),       
          Unit (Inch),                
          Unit Exponent (-3),         
          Physical Minimum (0),       
          Usage (X),                  
          Physical Maximum (9000),    
          Logical Maximum (18000),    
          Input (Variable),           
          Usage (Y),                  
          Physical Maximum (5500),    
          Logical Maximum (11000),    
          Input (Variable),           
          Pop,                        
          Usage (Tip Pressure),       
          Logical Maximum (1023),     
          Input (Variable),           
      End Collection,                 
  End Collection,                     
  Usage Page (Desktop),               
  Usage (Mouse),                      
  Collection (Application),           
      Report ID (1),                  
      Usage (Pointer),                
      Collection (Physical),          
          Report Size (8),            
          Report Count (3),           
          Input (Constant, Variable), 
          Report Count (2),           
          Logical Minimum (-1),       
          Logical Maximum (1),        
          Usage (Wheel),              
          Usage (Consumer AC Pan),    
          Input (Variable, Relative), 
          Report Count (2),           
          Input (Constant, Variable), 
      End Collection,                 
  End Collection,                     
  Usage Page (Consumer),              
  Usage (Consumer Control),           
  Collection (Application),           
      Report ID (13),                 
      Report Count (1),               
      Report Size (16),               
      Input (Constant, Variable),     
      Usage (AC Zoom),                
      Usage (AC Zoom Out),            
      Usage (AC Zoom In),             
      Usage (Scan Previous Track),    
      Usage (Scan Next Track),        
      Usage (00h),                    
      Usage (00h),                    
      Usage (00h),                    
      Usage (00h),                    
      Usage (00h),                    
      Usage (AC Zoom Out),            
      Usage (AC Zoom In),             
      Logical Minimum (12),           
      Logical Maximum (23),           
      Report Size (5),                
      Input,                          
      Report Size (3),                
      Input (Constant, Variable),     
      Report Size (32),               
      Input (Constant, Variable),     
  End Collection,                     
  Usage (Consumer Control),           
  Collection (Application),           
      Report ID (12),                 
      Report Size (1),                
      Usage (Volume Inc),             
      Usage (Volume Dec),             
      Usage (Mute),                   
      Logical Minimum (0),            
      Logical Maximum (1),            
      Report Count (3),               
      Input (Variable, Relative),     
      Report Count (53),              
      Input (Constant, Variable),     
  End Collection                      
 Size of the original report descriptor of Media Tablet 14.1 inch 
 Fixed Media Tablet 14.1 inch descriptor 
  Usage Page (Digitizer),             
  Usage (Pen),                        
  Collection (Application),           
      Report ID (16),                 
      Usage (Stylus),                 
      Collection (Physical),          
          Usage (Tip Switch),         
          Usage (Barrel Switch),      
          Usage (Tablet Pick),        
          Logical Minimum (1),        
          Logical Maximum (3),        
          Report Size (4),            
          Report Count (1),           
          Input,                      
          Report Size (1),            
          Usage (In Range),           
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Count (1),           
          Input (Variable),           
          Report Count (3),           
          Input (Constant, Variable), 
          Report Size (16),           
          Report Count (1),           
          Logical Minimum (0),        
          Push,                       
          Usage Page (Desktop),       
          Unit (Inch),                
          Unit Exponent (-3),         
          Physical Minimum (0),       
          Usage (X),                  
          Physical Maximum (12000),   
          Logical Maximum (16383),    
          Input (Variable),           
          Usage (Y),                  
          Physical Maximum (7250),    
          Logical Maximum (16383),    
          Input (Variable),           
          Pop,                        
          Usage (Tip Pressure),       
          Logical Maximum (1023),     
          Input (Variable),           
      End Collection,                 
  End Collection,                     
  Usage Page (Desktop),               
  Usage (Mouse),                      
  Collection (Application),           
      Report ID (1),                  
      Usage (Pointer),                
      Collection (Physical),          
          Report Size (8),            
          Report Count (3),           
          Input (Constant, Variable), 
          Report Count (2),           
          Logical Minimum (-1),       
          Logical Maximum (1),        
          Usage (Wheel),              
          Usage (Consumer AC Pan),    
          Input (Variable, Relative), 
      End Collection,                 
  End Collection,                     
  Usage Page (Consumer),              
  Usage (Consumer Control),           
  Collection (Application),           
      Report ID (13),                 
      Report Count (1),               
      Report Size (16),               
      Input (Constant, Variable),     
      Usage (AC Zoom),                
      Usage (AC Zoom Out),            
      Usage (AC Zoom In),             
      Usage (Scan Previous Track),    
      Usage (Scan Next Track),        
      Usage (00h),                    
      Usage (00h),                    
      Usage (00h),                    
      Usage (00h),                    
      Usage (00h),                    
      Usage (AC Zoom Out),            
      Usage (AC Zoom In),             
      Logical Minimum (12),           
      Logical Maximum (23),           
      Report Size (5),                
      Input,                          
      Report Size (3),                
      Input (Constant, Variable),     
      Report Size (32),               
      Input (Constant, Variable),     
  End Collection,                     
  Usage (Consumer Control),           
  Collection (Application),           
      Report ID (12),                 
      Report Size (1),                
      Usage (Volume Inc),             
      Usage (Volume Dec),             
      Usage (Mute),                   
      Logical Minimum (0),            
      Logical Maximum (1),            
      Report Count (3),               
      Input (Variable, Relative),     
      Report Size (5),                
      Input (Constant, Variable),     
  End Collection                      
 Size of the original report descriptor of Sirius Battery Free Tablet 
 Fixed Sirius Battery Free Tablet descriptor 
  Usage Page (Digitizer),             
  Usage (Pen),                        
  Collection (Application),           
      Report ID (16),                 
      Usage (Stylus),                 
      Collection (Physical),          
          Report Count (1),           
          Logical Minimum (1),        
          Logical Maximum (3),        
          Report Size (2),            
          Usage (Tip Switch),         
          Usage (Barrel Switch),      
          Usage (Tablet Pick),        
          Input,                      
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Size (1),            
          Usage (Invert),             
          Input (Variable),           
          Input (Constant, Variable), 
          Usage (In Range),           
          Input (Variable),           
          Report Count (3),           
          Input (Constant, Variable), 
          Push,                       
          Usage Page (Desktop),       
          Unit Exponent (-3),         
          Unit (Inch),                
          Physical Minimum (0),       
          Logical Minimum (0),        
          Report Size (16),           
          Report Count (1),           
          Physical Maximum (10000),   
          Logical Maximum (20000),    
          Usage (X),                  
          Input (Variable),           
          Physical Maximum (6000),    
          Logical Maximum (12000),    
          Usage (Y),                  
          Input (Variable),           
          Pop,                        
          Report Size (16),           
          Report Count (1),           
          Logical Minimum (0),        
          Logical Maximum (1023),     
          Usage (Tip Pressure),       
          Input (Variable),           
          Push,                       
          Unit Exponent (-2),         
          Unit (Radians),             
          Physical Minimum (-105),    
          Physical Maximum (105),     
          Logical Minimum (-105),     
          Logical Maximum (105),      
          Report Size (8),            
          Report Count (2),           
          Usage (X Tilt),             
          Usage (Y Tilt),             
          Input (Variable),           
          Pop,                        
      End Collection,                 
  End Collection,                     
  Usage Page (Desktop),               
  Usage (Mouse),                      
  Collection (Application),           
      Report ID (1),                  
      Usage (Pointer),                
      Collection (Physical),          
          Report Size (8),            
          Report Count (3),           
          Input (Constant, Variable), 
          Usage (Wheel),              
          Logical Minimum (-1),       
          Logical Maximum (1),        
          Report Size (8),            
          Report Count (1),           
          Input (Variable, Relative), 
          Report Size (8),            
          Report Count (3),           
          Input (Constant, Variable), 
      End Collection,                 
  End Collection,                     
  Usage Page (Desktop),               
  Usage (Keyboard),                   
  Collection (Application),           
      Report ID (13),                 
      Usage Page (Keyboard),          
      Usage Minimum (KB Leftcontrol), 
      Usage Maximum (KB Right GUI),   
      Logical Minimum (0),            
      Logical Maximum (1),            
      Report Size (1),                
      Report Count (8),               
      Input (Variable),               
      Report Size (8),                
      Report Count (1),               
      Input (Constant),               
      Usage Minimum (None),           
      Usage Maximum (KB Application), 
      Logical Minimum (0),            
      Logical Maximum (101),          
      Report Size (8),                
      Report Count (5),               
      Input,                          
  End Collection,                     
  Usage Page (Consumer),              
  Usage (Consumer Control),           
  Collection (Application),           
      Report ID (12),                 
      Usage (Volume Inc),             
      Usage (Volume Dec),             
      Logical Minimum (0),            
      Logical Maximum (1),            
      Report Size (1),                
      Report Count (2),               
      Input (Variable),               
      Report Size (6),                
      Report Count (1),               
      Input (Constant, Variable),     
      Report Size (16),               
      Report Count (3),               
      Input (Constant, Variable),     
  End Collection                      
 If this is a pen input report 
		
		  Ignore reported pressure when a barrel button is pressed,
		  because it is rarely correct.
 If a barrel button is pressed 
 Report zero pressure 
 If this is a pen input report of Sirius Battery Free Tablet 
		
		  The tablet reports tilt as roughly sin(a)21 (18 means 60
		  degrees).
		 
		  This array stores angles as radians  100, corresponding to
		  reported values up to 60 degrees, as expected by userspace.
		
		  Reverse the Y Tilt direction to match the HID standard and
		  userspace expectations. See HID Usage Tables v1.12 16.3.2
		  Tilt Orientation.
		
		  This effectively clamps reported tilt to 60 degrees - the
		  range expected by userspace
 SPDX-License-Identifier: GPL-2.0-only
  HID driver for the apple ir device
  Original driver written by James McKenzie
  Ported to recent 2.6 kernel versions by Greg Kroah-Hartman <gregkh@suse.de>
  Updated to support newer remotes by Bastien Nocera <hadess@hadess.net>
  Ported to HID subsystem by Benjamin Tissoires <benjamin.tissoires@gmail.com>
  Copyright (C) 2006 James McKenzie
  Copyright (C) 2008 Greg Kroah-Hartman <greg@kroah.com>
  Copyright (C) 2008 Novell Inc.
  Copyright (C) 2010, 2012 Bastien Nocera <hadess@hadess.net>
  Copyright (C) 2013 Benjamin Tissoires <benjamin.tissoires@gmail.com>
  Copyright (C) 2013 Red Hat Inc. All Rights Reserved
  James McKenzie has two devices both of which report the following
  25 87 ee 83 0a	+
  25 87 ee 83 0c	-
  25 87 ee 83 09	<<
  25 87 ee 83 06	>>
  25 87 ee 83 05	>"
  25 87 ee 83 03	menu
  26 00 00 00 00	for key repeat
  Thomas Glanzmann reports the following responses
  25 87 ee ca 0b	+
  25 87 ee ca 0d	-
  25 87 ee ca 08	<<
  25 87 ee ca 07	>>
  25 87 ee ca 04	>"
  25 87 ee ca 02	menu
  26 00 00 00 00       for key repeat
  He also observes the following event sometimes
  sent after a key is release, which I interpret
  as a flat battery message
  25 87 e0 ca 06	flat battery
  Alexandre Karpenko reports the following responses for Device ID 0x8242
  25 87 ee 47 0b	+
  25 87 ee 47 0d	-
  25 87 ee 47 08	<<
  25 87 ee 47 07	>>
  25 87 ee 47 04	>"
  25 87 ee 47 02	menu
  26 87 ee 47 	for key repeat ( is the code of the key being held)
  Bastien Nocera's remote
  25 87 ee 91 5f	followed by
  25 87 ee 91 05	gives you >"
  25 87 ee 91 5c	followed by
  25 87 ee 91 05	gives you the middle button
  Fabien Andre's remote
  25 87 ee a3 5e	followed by
  25 87 ee a3 04	gives you >"
  25 87 ee a3 5d	followed by
  25 87 ee a3 04	gives you the middle button
 timer for key up 
 protects .current_key 
 the currently pressed key 
 key index in a 2 packets message 
	
	  The key is coded accross bits 2..9:
	 
	  0x00 or 0x01 (        )	key:  0		-> KEY_RESERVED
	  0x02 or 0x03 (  menu  )	key:  1		-> KEY_MENU
	  0x04 or 0x05 (   >"   )	key:  2		-> KEY_PLAYPAUSE
	  0x06 or 0x07 (   >>   )	key:  3		-> KEY_FORWARD
	  0x08 or 0x09 (   <<   )	key:  4		-> KEY_BACK
	  0x0a or 0x0b (    +   )	key:  5		-> KEY_VOLUMEUP
	  0x0c or 0x0d (    -   )	key:  6		-> KEY_VOLUMEDOWN
	  0x0e or 0x0f (        )	key:  7		-> KEY_RESERVED
	  0x50 or 0x51 (        )	key:  8		-> KEY_RESERVED
	  0x52 or 0x53 (        )	key:  9		-> KEY_RESERVED
	  0x54 or 0x55 (        )	key: 10		-> KEY_RESERVED
	  0x56 or 0x57 (        )	key: 11		-> KEY_RESERVED
	  0x58 or 0x59 (        )	key: 12		-> KEY_RESERVED
	  0x5a or 0x5b (        )	key: 13		-> KEY_RESERVED
	  0x5c or 0x5d ( middle )	key: 14		-> KEY_ENTER
	  0x5e or 0x5f (   >"   )	key: 15		-> KEY_PLAYPAUSE
	 
	  Packets starting with 0x5 are part of a two-packets message,
	  we notify the caller by sending a negative value.
 Part of a 2 packets-command 
		
		  If we already have a key down, take it up before marking
		  this one down
 Handle dual packet commands 
			
			  Remote doesn't do key up, either pull them up, in
			  the test above, or here set a timer which pulls
			  them up after 18 s
 Remember key for next packet 
		
		  Remote doesn't do key up, either pull them up, in the test
		  above, or here set a timer which pulls them up after 18 s
 Fall through 
 let hidraw and hiddev handle the report 
 force input as some remotes bypass the input registration 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for Lenovo:
   - ThinkPad USB Keyboard with TrackPoint (tpkbd)
   - ThinkPad Compact Bluetooth Keyboard with TrackPoint (cptkbd)
   - ThinkPad Compact USB Keyboard with TrackPoint (cptkbd)
   Copyright (c) 2012 Bernhard Seibold
   Copyright (c) 2014 Jamie Lentin <jm@lentin.co.uk>
  Linux IBMLenovo Scrollpoint mouse driver:
  - IBM Scrollpoint III
  - IBM Scrollpoint Pro
  - IBM Scrollpoint Optical
  - IBM Scrollpoint Optical 800dpi
  - IBM Scrollpoint Optical 800dpi Pro
  - Lenovo Scrollpoint Optical
   Copyright (c) 2012 Peter De Wachter <pdewacht@gmail.com>
   Copyright (c) 2018 Peter Ganzhorn <peter.ganzhorn@gmail.com>
 Userspace expects F20 for mic-mute KEY_MICMUTE does not work 
 Must be first for proper alignment 
 0:Up, 1:Down (undecided), 2:Scrolling 
 Usage Page (Vendor Usage Page 0x88)	
 Usage (Vendor Usage 0x01)		
 Collection (Application)		
  Report ID (4)			
  Usage Minimum (0)			
  Usage Maximum (65535)		
		 the fixups that need to be done:
		    - get a reasonable usage max for the vendor collection
		      0x8801 from the report ID 4
 This sub-device contains trackpoint, mark it 
 HID_UP_LNVENDOR = USB, HID_UP_MSVENDOR = BT 
 Fn-F4: Mic mute 
 Fn-F5: Brightness down 
 Fn-F6: Brightness up 
 Fn-F7: External display (projector) 
 Fn-F8: Wireless 
 Fn-F9: Control panel 
 Fn-F11: View open applications (3 boxes) 
 Fn-F12: Open My computer (6 boxes) USB-only 
 NB: This mapping is invented in raw_event below 
 Fn-Esc: Fn-lock toggle 
 Middle mouse button (in native mode) 
 Compatibility middlewheel mappings should be ignored 
 Map wheel emulation reports: 0xffa1 = USB, 0xff10 = BT 
	
	  The ThinkPad 10 Ultrabook Keyboard uses 0x000c0001 usage for
	  a bunch of keys which have no standard consumer page code.
 Fn-Esc: Fn-lock toggle 
 Fn-F4: Mic mute 
 Fn-F7: Control panel 
 Fn-F8: Search (magnifier glass) 
 Fn-F10: Open My computer (6 boxes) 
	
	  The Ultrabook Keyboard sends a spurious F23 key-press when resuming
	  from suspend and it does not actually have a F23 key, ignore it.
	
	  The ThinkPad X1 Tablet Thin Keyboard uses 0x000c0001 usage for
	  a bunch of keys which have no standard consumer page code.
 Fn-F10: Enabledisable bluetooth 
 Fn-F11: Keyboard settings 
 Fn-F12: User function  Cortana 
 Fn-PrtSc: Snipping tool 
 Fn-Esc: Fn-lock toggle 
 Fn-F4: Muteunmute microphone 
 Fn-F9: Settings 
 Fn-F7: Manage external displays 
 Fn-F8: Enabledisable wifi 
 Send a config command to the keyboard 
 BT returns 0, USB returns sizeof(buf) 
	
	  Compact USB keyboard's Fn-F12 report holds down many other keys, and
	  its own key is outside the usage page range. Remove extra
	  keypresses and remap to inside usage page.
		
		  The user has toggled the Fn-lock state. Toggle our own
		  cached value of it and sync our value to the keyboard to
		  ensure things are in sync (the sycning should be a no-op).
 "wheel" scroll events 
 Scroll events disable middle-click event 
 Middle click events 
 No scrolling inbetween, send middle-click 
 unknown setting, imitate windows driver
	
	  Only register extra settings against subdevice where input_mapping
	  set drvdata to 1, i.e. the trackpoint.
 Validate required reports. 
 set same default values as windows driver
 All the custom action happens on the USBMOUSE device for USB 
	
	  Tell the keyboard a driver understands it, and turn F7, F9, F11 into
	  regular keys
 Switch middle button to native mode 
 Set keyboard settings to known state 
	
	  The LEDs and the Fn-lock functionality use output report 9,
	  with an application of 0xffa0001, add the LEDs on the interface
	  with this output report.
	
	  The Thinkpad 10 ultrabook USB kbd dock's Fn-lock defaults to on.
	  We cannot read the state, only set it, so we force it to on here
	  (which should be a no-op) to make sure that our state matches the
	  keyboard's FN-lock state. This is the same as what Windows does.
	
	  Only the trackpoint half of the keyboard has drvdata and stuff that
	  needs unregistering.
 set only for trackpoint device 
	
	  Note bind to the HID_GROUP_GENERIC group, so that we only bind to the keyboard
	  part, while letting hid-multitouch.c handle the touchpad and trackpoint.
 SPDX-License-Identifier: GPL-2.0-or-later
  HID driver for Nintendo Wii  Wii U peripherals
  Copyright (c) 2011-2013 David Herrmann <dh.herrmann@gmail.com>
 output queue handling 
	
	  Copy new request into our output queue and check whether the
	  queue is full. If it is full, discard this request.
	  If it is empty we need to start a new worker that will
	  send out the buffer to the hid device.
	  If the queue is not empty, then there must be a worker
	  that is currently sending out our buffer and this worker
	  will reschedule itself until the queue is empty.
  This sets the rumble bit on the given output report if rumble is
  currently enabled.
  \cmd1 must point to the second byte in the output report => &cmd[1]
  This must be called on nearly every output report before passing it
  into the output queue!
  Check what peripherals of the wiimote are currently
  active and select a proper DRM that supports all of
  the requested data inputs.
  Not all combinations are actually supported. The following
  combinations work only with limitations:
   - IR cam in extended or full mode disables any data transmission
     of extension controllers. There is no DRM mode that supports
     extension bytes plus extendedfull IR.
   - IR cam with accelerometer and extension _EXT8 is not supported.
     However, all extensions that need _EXT8 are devices that don't
     support IR cameras. Hence, this shouldn't happen under normal
     operation.
   - _EXT16 is only supported in combination with buttons and
     accelerometer. No IR or similar can be active simultaneously. As
     above, all modules that require it are mutually exclusive with
     IRetc. so this doesn't matter.
 some 3rd-party balance-boards are hard-coded to KEE, sigh 
			 GEN10 and ealier devices bind IR formats to DRMs.
			  Hence, we cannot use DRM_KAI here as it might be
			  bound to IR_EXT. Use DRM_KAIE unconditionally so we
			  work with all devices and our parsers can use the
 requries the cmd-mutex to be held 
 requries the cmd-mutex to be held 
 requires the cmd-mutex to be held 
 initialize extension 
 disable default encryption 
 requires the cmd-mutex to be held 
 read extension ID 
 requires the cmd-mutex to be held 
 initialize MP 
 disable default encryption 
 requires the cmd-mutex to be held 
 map MP with correct pass-through mode 
 requires the cmd-mutex to be held 
 read motion plus ID 
 requires the cmd-mutex to be held 
 read motion plus ID 
 device module handling 
 find end of list 
 empty  ;
 device extension handling 
 device (re-)initialization and detection 
 Try to guess the device type based on all collected information. We
  first try to detect by static extension types, then VIDPID and the
  device name. If we cannot detect the device, we use
 schedule MP timer 
  MP hotplug events are not generated by the wiimote. Therefore, we need
  polling to detect it. We use a 4s interval for polling MP registers. This
  seems reasonable considering applications can trigger it manually via
  sysfs requests.
 loadunload MP module if it changed 
  Check whether the wiimote is in the expected state. The extension registers
  may change during hotplug and initialization so we might get hotplug events
  that we caused by remapping some memory.
  We use some heuristics here to check known states. If the wiimote is in the
  expected state, we can ignore the hotplug event.
  Returns "true" if the device is in expected state, "false" if we should
  redo hotplug handling and extension initialization.
	 If MP is used and active, but the extension is not, we expect:
	    read_mp_mapped() == WIIMOTE_MP_SINGLE
	    state.flags == !EXT_ACTIVE && !MP_PLUGGED && MP_ACTIVE
	  We do not check EXT_PLUGGED because it might change during
	  initialization of MP without extensions.
	   - If MP is unpluggedreplugged, read_mp_mapped() fails
 while MP is mapped, we get EXT_PLUGGED events 
	 If MP is unused, but the extension port is used, we expect:
	    read_ext == state.exttype
	    state.flags == !MP_ACTIVE && EXT_ACTIVE
	  - If MP is pluggedunplugged, our timer detects it
 poll MP for hotplug events 
	 If neither MP nor an extension are used, we expect:
	    read_ext() == WIIMOTE_EXT_NONE
	    state.flags == !MP_ACTIVE && !EXT_ACTIVE && !EXT_PLUGGED
	  No need to perform any action in this case as everything is
	  disabled already.
	  - If MP is pluggedunplugged, our timer detects it
 poll MP for hotplug events 
	 The trickiest part is if both EXT and MP are active. We cannot read
	  the EXT ID, anymore, because MP is mapped over it. However, we use
	  a handy trick here:
	    - EXT_ACTIVE is unset whenever !MP_PLUGGED is sent
	  MP_PLUGGED might be re-sent again before we are scheduled, but
	  EXT_ACTIVE will stay unset.
	  So it is enough to check for mp_mapped() and MP_ACTIVE and
 while MP is mapped, we get EXT_PLUGGED events 
 unknown state 
 only poll for MP if requested and if state didn't change 
  Handle hotplug events
  If we receive an hotplug event and the device-check failed, we deinitialize
  the extension ports, re-read all extension IDs and set the device into
  the desired state. This involves mapping MP into the main extension
  registers, setting up extension passthrough modes and initializing the
  requested extensions.
 get state snapshot that we will then work on 
 disable event forwarding temporarily 
 init extension and MP (deactivates current extension or MP) 
 loadunload extension module if it changed 
 unload previous extension 
 try loading new extension 
 loadunload MP module if it changed 
 if MP is not used, do not map or activate it 
 map MP into main extension registers if used 
 delete MP hotplug timer 
 reschedule MP hotplug timer 
 enable data forwarding again and set expected hotplug state 
 request status report for hotplug state updates 
 protocol handlers 
 if MP is active, track MP slot hotplugging 
 this bit is set for invalid events (eg. during hotplug) 
 detect MP data that is sent interleaved with EXT data 
 ignore EXT events if no extension is active 
 try forwarding to extension handler, first 
 try forwarding to MP handler 
 try forwarding to loaded modules 
 reduced status report with "BB BB" key data only 
 on status reports the drm is reset so we need to resend the drm 
 extended status report with "BB BB LF 00 00 VV" data 
 update extension status 
 reduced generic report with "BB BB" key data only 
 prevent init_worker from being scheduled again 
 schedule device detection 
 SPDX-License-Identifier: GPL-2.0-or-later
   Force feedback support for Zeroplus based devices
   Copyright (c) 2005, 2006 Anssi Hannula <anssi.hannula@gmail.com>
	
	  The following is specified the other way around in the Zeroplus
	  datasheet but the order below is correct for the XFX Executioner;
	  however it is possible that the XFX Executioner is an exception
 SPDX-License-Identifier: GPL-2.0-or-later
  Force feedback support for hid-compliant for some of the devices from
  Logitech, namely:
  - WingMan Cordless RumblePad
  - WingMan Force 3D
   Copyright (c) 2002-2004 Johann Deneux
   Copyright (c) 2006 Anssi Hannula <anssi.hannula@gmail.com>
  Should you need to contact me, the author, you can do so by
  e-mail - mail your message to <johann.deneux@it.uu.se>
 0x7f is center 
 clockwise strength 
 counter-clockwise strength 
 Check that the report looks ok 
 SPDX-License-Identifier: GPL-2.0-or-later
  Roccat Lua driver for Linux
  Copyright (c) 2012 Stefan Achatz <erazor_de@users.sourceforge.net>
  Roccat Lua is a gamer mouse which cpi, button and light settings can be
  configured.
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for Gembird Joypad, "PC Game Controller"
   Copyright (c) 2015 Red Hat, Inc
   Copyright (c) 2015 Benjamin Tissoires
   Report Size (8)		
   Report Count (5)		
   Logical Minimum (0)	
   Logical Maximum (255)	
   Physical Minimum (0)	
   Physical Maximum (255)	
   Usage (X)			
   Usage (Y)			
   Usage (Z)			
   Usage (Z)			
   Usage (Rz)			
   Input (Data,Var,Abs)	
  we fix the report descriptor by:
  - marking the first Z axis as constant (so it is ignored by HID)
  - assign the original second Z to Rx
  - assign the original Rz to Ry
   Report Size (8)		
   Report Count (2)		
   Logical Minimum (0)	
   Logical Maximum (255)	
   Physical Minimum (0)	
   Physical Maximum (255)	
   Usage (X)			
   Usage (Y)			
   Input (Data,Var,Abs)	
   Report Count (1)		
   Usage (Z)			
   Input (Cnst,Arr,Abs)	
   Report Count (2)		
   Usage (Rx)			
   Usage (Ry)			
   Input (Data,Var,Abs)	
 delta_size is > 0 
 start by copying the end of the rdesc 
 add the correct beginning 
 replace the faulty part with the fixed one 
 SPDX-License-Identifier: GPL-2.0-only
  HID driver for TwinHan IR remote control
  Based on hid-gyration.c
  Copyright (c) 2009 Bruno Pr√©mont <bonbons@linux-vserver.org>
	Remote control key layout + listing:
  	Full Screen                              Power
 	KEY_SCREEN                          KEY_POWER2
 	1                     2                      3
 	KEY_NUMERIC_1   KEY_NUMERIC_2    KEY_NUMERIC_3
 	4                     5                      6
 	KEY_NUMERIC_4   KEY_NUMERIC_5    KEY_NUMERIC_6
 	7                     8                      9
 	KEY_NUMERIC_7   KEY_NUMERIC_8    KEY_NUMERIC_9
 	REC                   0               Favorite
 	KEY_RECORD      KEY_NUMERIC_0    KEY_FAVORITES
 	Rewind                                 Forward
 	KEY_REWIND           CH+           KEY_FORWARD
 	               KEY_CHANNELUP
 	VOL-                  >                   VOL+
 	KEY_VOLUMEDOWN    KEY_PLAY        KEY_VOLUMEUP
 	                     CH-
 	              KEY_CHANNELDOWN
 	Recall                                    Stop
 	KEY_RESTART                           KEY_STOP
 	TimeshiftPause     Mute                Cancel
 	KEY_PAUSE         KEY_MUTE          KEY_CANCEL
 	Capture            Preview                 EPG
 	KEY_PRINT        KEY_PROGRAM           KEY_EPG
 	Record List          Tab              Teletext
 	KEY_LIST            KEY_TAB           KEY_TEXT
 Map all keys from Twinhan Remote 
 Power       = 0x0e0 + 0x0e1 + 0x0e2 + 0x03f 
 Volume down = 0x0e1 + 0x051                 
 Volume up   = 0x0e1 + 0x052                 
	 Kill the extra keys used for multi-key "power" and "volume" keys
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) 2016 Masaki Ota <masaki.ota@jp.alps.com>
 ALPS Device Product ID 
 Mouse data ReportID 
 Absolute data ReportID 
 FW-PTP Absolute data ReportID 
 Feature ReportID 
 Feature ReportID 
 Feature Report Length 
 SP Support 
  struct alps_dev
  @input: pointer to the kernel input device
  @input2: pointer to the kernel input2 device
  @hdev: pointer to the struct hid_device
  @dev_type: device type
  @max_fingers: total number of fingers
  @has_sp: boolean of sp existense
  @sp_btn_info: button information
  @x_active_len_mm: active area length of X (mm)
  @y_active_len_mm: active area length of Y (mm)
  @x_max: maximum x coordinate value
  @y_max: maximum y coordinate value
  @x_min: minimum x coordinate value
  @y_min: minimum y coordinate value
  @btn_cnt: number of buttons
  @sp_btn_cnt: number of stick buttons
 Calculate the checksum 
 Calculate the checksum 
 Device initialization 
 Button pad 
 Check StickPointer device 
 Allow incoming hid reports 
 Stick device initialization 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for Semitek keyboards
   Copyright (c) 2021 Benjamin Moody
	 In the report descriptor for interface 2, fix the incorrect
	   description of report ID 0x04 (the report contains a
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for Speedlink Vicious and Divine Cezanne (USB mouse).
   Fixes "jumpy" cursor and removes nonexistent keyboard LEDS from
   the HID descriptor.
   Copyright (c) 2011, 2013 Stefan Kriwanek <dev@stefankriwanek.de>
	
	  The Cezanne mouse has a second "keyboard" USB endpoint for it is
	  able to map keyboard events to the button presses.
	  It sends a standard keyboard report descriptor, though, whose
	  LEDs we ignore.
 No other conditions due to usage_table. 
	 This fixes the "jumpy" cursor occuring due to invalid events sent
	  by the device. Some devices only send them with value==+256, others
	  don't. However, catching abs(value)>=256 is restrictive enough not
	  to interfere with devices that were bug-free (has been tested).
 Drop useless distance 0 events (on button clicks etc.) as well 
 SPDX-License-Identifier: GPL-2.0-only
    Copyright (C) 2010-2012 by Bruno Pr√©mont <bonbons@linux-vserver.org>  
    Based on Logitech G13 driver (v0.4)                                   
      Copyright (C) 2009 by Rick L. Vinyard, Jr. <rvinyard@cs.nmsu.edu>   
 ignore if rc_dev is NULL or status is shunned 
	 PicoLCD USB packets contain 16-bit intervals in network order,
	  with value negated for pulse. Intervals are in microseconds.
	 
	  Note: some userspace LIRC code for PicoLCD says negated values
	  for space - is it a matter of IR chip? (pulse for my TSOP2236)
	 
	  In addition, the first interval seems to be around 15000 + base
	  interval for non-first report of IR data - thus the quirk below
	  to get RC_CODE to understand Sony and JVC remotes I have at hand
 Quirk!! - see above 
 initialize CIR input device 
 SPDX-License-Identifier: GPL-2.0-or-later
   Force feedback support for Logitech Gaming Wheels
   Including G27, G25, DFP, DFGT, FFEX, Momo, Momo2 &
   Speed Force Wireless (WiiWheel)
   Copyright (c) 2010 Simon Wood <simon@mungewell.org>
 Protect output HID report 
 Number of commands to send 
 Multimode wheel identificators 
 Multimode wheel identification checklists 
 Compatibility mode switching commands 
 EXT_CMD9 - Understood by G27 and DFGT 
 Revert mode upon USB reset 
 Switch mode to DF-EX with detach 
 Revert mode upon USB reset 
 Switch mode to DFP with detach 
 Revert mode upon USB reset 
 Switch mode to G25 with detach 
 Revert mode upon USB reset 
 Switch mode to DFGT with detach 
 Revert mode upon USB reset 
 Switch mode to G27 with detach 
 Revert mode upon USB reset 
 Switch mode to G29 with detach 
 EXT_CMD1 - Understood by DFP, G25, G27 and DFGT 
 EXT_CMD16 - Understood by G25 and G27 
 Recalculates X axis value accordingly to currently selected range 
 adjust HID report present combined pedals data 
 Compute a combined axis when wheel does not supply it 
 0x80 is no force 
 De-activate force in slot-1
 Slot 1 
 Sends default autocentering command compatible with
 De-activate Auto-Center 
 Adjust for non-MOMO wheels 
 Activate Auto-Center 
 Sends autocentering command compatible with Formula Force EX 
 Sends command to set range compatible with G25G27Driving Force GT 
 Sends commands to set range compatible with Driving Force Pro wheel 
 Prepare "coarse" limit command 
 Set later 
 Prepare "fine" limit command 
 Do not apply any fine limit 
 Construct fine limit command 
 DFP can only be switched to its native mode 
 G25 can only be switched to DFP mode or its native mode 
 G27 can only be switched to DF-EX, DFP, G25 or its native mode 
 G29 can only be switched to DF-EX, DFP, DFGT, G25, G27 or its native mode 
 DFGT can only be switched to DF-EX, DFP or its native mode 
 No other wheels have multiple modes 
 Print tag and full name 
 Mark the currently active mode with an asterisk 
 Allow \n at the end of the input parameter 
 Not needed anymore 
 Nothing to do 
 Automatic switching has to be disabled for the switch to DF-EX mode to work correctly 
 Take care of hardware limitations 
 Export the currently set range of the wheel 
 Set range to user specified value, call appropriate function
	 Check if the wheel supports range setting
 Real ID is a read-only value 
 identify current mode from USB PID 
	 No match found. This is either Driving Force or an unknown
 Probed wheel is not a multimode wheel 
	 Switch from "Driving Force" mode to native mode automatically.
			 Wheel could not have been switched to native mode,
 Check that the report looks ok 
	 Check if a multimode wheel has been connected and
	 Wheel has been told to switch to native mode. There is no point in going on
	  with the initialization as the wheel will do a USB reset when it switches mode
 Check what wheel has been connected 
 Set supported force feedback capabilities 
 Initialize device properties 
	 Check if autocentering is available and
 Formula Force EX expects different autocentering command 
 Create sysfs interface 
 Set the maximum range to start with 
 register led subsystem - G27G29 only 
 Deregister LEDs (if any) 
 Let the driver continue without LEDs 
 Nothing more to do 
 Multimode devices will have at least the "MODE_NATIVE" bit set 
 Deregister LEDs (if any) 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for some monterey "special" devices
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2006-2007 Jiri Kosina
   Copyright (c) 2008 Jiri Slaby
 SPDX-License-Identifier: GPL-2.0-only
  HID raw devices, giving access to raw HID events.
  In comparison to hiddev, this device does not process the
  hid events at all (no parsing, no lookups). This lets applications
  to work on raw hid events as they want to, and avoids a need to
  use a transport-specific userspace libhidlibusb libraries.
   Copyright (c) 2007-2014 Jiri Kosina
 allow O_NONBLOCK to work well from other threads 
  The first byte of the report buffer is expected to be a report number.
		
		  compatibility with old implementation of USB-HID and I2C-HID:
		  if the device does not support receiving output reports,
		  on an interrupt endpoint, fallback to SET_REPORT HID command.
  This function performs a Get_Report transfer over the control endpoint
  per section 7.2.1 of the HID specification, version 1.1.  The first byte
  of buffer is the report number to request, or 0x0 if the device does not
  use numbered reports. The report_type parameter can be HID_FEATURE_REPORT
  or HID_INPUT_REPORT.
	
	  Read the first byte from the user. This is the report number,
	  which is passed to hid_hw_raw_request().
 hidraw is always writable 
 close device for last reader 
 Begin Read-only ioctls. 
 we accept any HID device, all applications 
 SPDX-License-Identifier: GPL-2.0-only
  MCP2221A - Microchip USB to I2C Host Protocol Bridge
  Copyright (c) 2020, Rishi Gupta <gupt21@gmail.com>
  Datasheet: https:ww1.microchip.comdownloadsenDeviceDoc20005565B.pdf
 Commands codes in a raw output report 
 Response codes in a raw input report 
 MCP GPIO direction encoding 
 MCP GPIO set command layout 
 MCP GPIO get command layout 
  There is no way to distinguish responses. Therefore next command
  is sent only after response to previous has been received. Mutex
  lock is used for this purpose mainly.
  Default i2c bus clock frequency 400 kHz. Modify this if you
  want to set some other frequency (min 50 kHz - max 400 kHz).
 Synchronously send output report to the device 
 mcp2221 uses interrupt endpoint for out reports 
  Send op report to the device and wait for ip report to be
  received from the device. If the device does not respond,
  we timeout.
 Check passfail for actual communication with i2c slave 
 Cancels last command releasing i2c bus just in case occupied 
 Small delay is needed here 
  An output report can contain minimum 1 and maximum 60 user data
  bytes. If the number of data bytes is more then 60, we send it
  in chunks of 60 bytes. Last chunk may contain exactly 60 or less
  bytes. Total number of bytes is informed in very first report to
  mcp2221, from that point onwards it first collect all the data
  from host and then send to i2c slave device.
		
		  Testing shows delay is needed between successive writes
		  otherwise next write fails on first-try from i2c core.
		  This value is obtained through automated stress testing.
  Device reads all data (0 - 65535 bytes) from i2c slave device and
  stores it in device itself. This data is read back from device to
  host in multiples of 60 bytes using input reports.
 Setting speed before every transaction is required for mcp2221 
 Ex transaction; send reg address and read its contents 
 1 is due to command byte itself 
 Can't configure as output, bailout early 
 Gives current state of i2c engine inside mcp2221 
  MCP2221 uses interrupt endpoint for input reports. This function
  is called by HID layer when it receives ip report from mcp2221,
  which is actually a response to the previously sent command.
  MCP2221A firmware specific return codes are parsed and 0 or
  appropriate negative error code is returned. Delayed response
  results in timeout error and stray reponses results in -EIO.
 Set I2C bus clock diviser 
 Setup GPIO chip 
 Register with HID core 
 SPDX-License-Identifier: GPL-2.0-or-later
  HID Driver for ELAN Touchpad
  Currently only supports touchpad found on HP Pavilion X2 10
  Copyright (c) 2016 Alexandrov Stanislav <neko@nya.ai>
	
	  (value from firmware)  10 + 790 = dpi
	  dpi  10  254 = dotsmm
	
	  There is 3 types of reports: for single touch,
	  for multitouch - first finger and for multitouch - second finger
	 
	  packet structure for ELAN_SINGLE_FINGER and ELAN_MT_FIRST_FINGER:
	 
	  byte 1: 1   0   0   0   0   0   0   1   0x81 or 0x82
	  byte 2: 0   0   0   0   0   0   0   0   looks like unused
	  byte 3: f5  f4  f3  f2  f1  0   0   L
	  byte 4: x12 x11 x10 x9  0?  y11 y10 y9
	  byte 5: x8  x7  x6  x5  x4  x3  x2  x1
	  byte 6: y8  y7  y6  y5  y4  y3  y2  y1
	  byte 7: sy4 sy3 sy2 sy1 sx4 sx3 sx2 sx1
	  byte 8: p8  p7  p6  p5  p4  p3  p2  p1
	 
	  packet structure for ELAN_MT_SECOND_FINGER:
	 
	  byte 1: 1   0   0   0   0   0   1   1   0x83
	  byte 2: x12 x11 x10 x9  0   y11 y10 y9
	  byte 3: x8  x7  x6  x5  x4  x3  x2  x1
	  byte 4: y8  y7  y6  y5  y4  y3  y2  y1
	  byte 5: sy4 sy3 sy2 sy1 sx4 sx3 sx2 sx1
	  byte 6: p8  p7  p6  p5  p4  p3  p2  p1
	  byte 7: 0   0   0   0   0   0   0   0
	  byte 8: 0   0   0   0   0   0   0   0
	 
	  f5-f1: finger touch bits
	  L: clickpad button
	  sy  sx: finger width  height expressed in traces, the total number
	           of traces can be queried by doing a HID_REQ_SET_REPORT
	           { 0x0d, 0x05, 0x03, 0x05, 0x01 } followed by a GET, in the
	           returned buf, buf[3]=no-x-traces, buf[4]=no-y-traces.
	  p: pressure
	
	  When touched with two fingers Elan touchpad will emit two HID reports
	  first is ELAN_MT_FIRST_FINGER and second is ELAN_MT_SECOND_FINGER
	  we will save ELAN_MT_FIRST_FINGER report and wait for
	  ELAN_MT_SECOND_FINGER to finish multitouch
	
	  Elan MT touchpads in i2c mode send finger data in the same format
	  as in USB mode, but then with all fingers in a single packet.
	 
	  packet structure for ELAN_MT_I2C:
	 
	  byte     1: 1   0   0   1   1   1   0   1    0x5d
	  byte     2: f5  f4  f3  f2  f1  0   0   L
	  byte     3: x12 x11 x10 x9  0?  y11 y10 y9
	  byte     4: x8  x7  x6  x5  x4  x3  x2  x1
	  byte     5: y8  y7  y6  y5  y4  y3  y2  y1
	  byte     6: sy4 sy3 sy2 sy1 sx4 sx3 sx2 sx1
	  byte     7: p8  p7  p6  p5  p4  p3  p2  p1
	  byte  8-12: Same as byte 3-7 for second finger down
	  byte 13-17: Same as byte 3-7 for third finger down
	  byte 18-22: Same as byte 3-7 for fourth finger down
	  byte 23-27: Same as byte 3-7 for fifth finger down
	
	  This byte sequence will enable multitouch mode and disable
	  mouse emulation
 SPDX-License-Identifier: GPL-2.0
  When connected to the machine, the Thrustmaster wheels appear as
  a ¬´generic¬ª hid gamepad called "Thrustmaster FFB Wheel".
  When in this mode not every functionality of the wheel, like the force feedback,
  are available. To enable all functionalities of a Thrustmaster wheel we have to send
  to it a specific USB CONTROL request with a code different for each wheel.
  This driver tries to understand which model of Thrustmaster wheel the generic
  "Thrustmaster FFB Wheel" really is and then sends the appropriate control code.
  Copyright (c) 2020-2021 Dario Pagani <dario.pagani.146+linuxk@gmail.com>
  Copyright (c) 2020-2021 Kim Kuparinen <kimi.h.kuparinen@gmail.com>
  These interrupts are used to prevent a nasty crash when initializing the
  T300RS. Used in thrustmaster_interrupts().
  This struct contains for each type of
  Thrustmaster wheel
  Note: The values are stored in the CPU
  endianness, the USB protocols always use
  little endian; the macro cpu_to_le[BIT]()
  must be used when preparing USB packets
  and vice-versa
	
	  See when the USB control out packet is prepared...
	  @TODO The TMX seems to require multiple control codes to switch.
  Known wheels.
  Note: TMX does not work as it requires 2 control packets
{0x0407, 0x0001, "Thrustmaster TMX"}
  This structs contains (in little endian) the response data
  of the wheel to the request 73
  A sufficient research to understand what each field does is not
  beign conducted yet. The position and meaning of fields are a
  just a very optimistic guess based on instinct....
	
	  Seems to be the type of packet
	  - 0x0049 if is data.a (15 bytes)
	  - 0x0047 if is data.b (7 bytes)
			
			  Seems to be the model code of the wheel
			  Read table thrustmaster_wheels to values
 The control packet to send to wheel 
 Will be filled by the driver
  On some setups initializing the T300RS crashes the kernel,
  these interrupts fix that particular issue. So far they haven't caused any
  adverse effects in other wheels.
 The wheel seems to kill himself before answering the host and therefore is violating the USB protocol...
  Called by the USB subsystem when the wheel responses to our request
  to get [what it seems to be] the wheel's model.
  If the model id is recognized then we send an opportune USB CONTROL REQUEST
  to switch the wheel to its full capabilities
 We do not expect any response from the wheel
  Function called by HID when a hid Thrustmaster FFB wheel is connected to the host.
  This function starts the hid dev, tries to allocate the tm_wheel data structure and
  finally send an USB CONTROL REQUEST to the wheel to get [what it seems to be] its
  model type.
 Now we allocate the tm_wheel
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for multitouch panels
   Copyright (c) 2010-2012 Stephane Chatty <chatty@enac.fr>
   Copyright (c) 2010-2013 Benjamin Tissoires <benjamin.tissoires@gmail.com>
   Copyright (c) 2010-2012 Ecole Nationale de l'Aviation Civile, France
   Copyright (c) 2012-2013 Red Hat, Inc
   This code is partly based on hid-egalax.c:
   Copyright (c) 2010 Stephane Chatty <chatty@enac.fr>
   Copyright (c) 2010 Henrik Rydberg <rydberg@euromail.se>
   Copyright (c) 2010 Canonical, Ltd.
   This code is partly based on hid-3m-pct.c:
   Copyright (c) 2009-2010 Stephane Chatty <chatty@enac.fr>
   Copyright (c) 2010      Henrik Rydberg <rydberg@euromail.se>
   Copyright (c) 2010      Canonical, Ltd.
  This driver is regularly tested thanks to the test suite in hid-tools[1].
  Please run these regression tests before patching this module so that
  your patch won't break existing known devices.
  [1] https:gitlab.freedesktop.orglibevdevhid-tools
 quirks to control the device 
 default for true 
 default for false 
 default for 0 
 the device ContactID assigned to this slot 
 is the touch valid? 
 is the finger in proximity of the sensor? 
 is the touch made by a finger? 
 mt usages list 
 scantime reported 
 max value for raw scantime 
 contact count in the report 
 left button state 
 flags to pass to input-mt 
	unsigned long pending_palm_slots;	 slots where we reported palm
 how many contacts we received 
 expected last contact index 
 number of physical buttons per touchpad 
	__u8 touches_by_report;	 how many touches are present in one report:
				  1 means we should use a serial protocol
				  > 1 means hybrid (multitouch) protocol
 the scan time provided by the device 
 the frame's jiffies 
 the timestamp to be sent 
 scantime reported previously 
 MT_CLS 
 Signalnoise ratio for move events 
 Signalnoise ratio for width events 
 Signalnoise ratio for height events 
 Signalnoise ratio for pressure events 
 true for touchpads 
 do not ignore mouse, keyboards, etc... 
 our mt device class 
 to release sticky fingers 
 hid_device we're attached to 
 mt flags (MT_IO_FLAGS_) 
 InputMode HID feature value 
 is this device a button pad? 
 need to check for serial protocol 
 classes of device behavior 
 reserved					0x0008 
 reserved					0x0010 
 reserved					0x0011 
 reserved					0x0014 
 vendor specific classes 
 reserved					0x0102 
  Resync device and local timestamps after that many microseconds without
  receiving data.
  these device-dependent functions determine what slot corresponds
  to a valid contact that was just read.
	
	  vendor specific classes
	
	  Do not fetch the feature report if the device has been explicitly
	  marked as non-capable.
 check if the maxcontacts is given by the class 
 Retrieve the Win8 blob once to enable some devices 
 set some defaults so we do not need to check for null pointers 
	
	  Model touchscreens providing buttons as touchpads.
 the value has already been filled, create a new slot 
	
	  Model touchscreens providing buttons as touchpads.
 count the buttons on touchpads 
			
			  A system multi-axis that exports X and Y has a high
			  chance of being used directly on a surface
				
				  Only set ABS_MT_ORIENTATION if it is not
				  already set by the HID_DG_AZIMUTH usage.
			
			  Azimuth has the range of [0, MAX) representing a full
			  revolution. Set ABS_MT_ORIENTATION to a quarter of
			  MAX according the definition of ABS_MT_ORIENTATION
 contact max are global to the report 
			 Legacy devices use TIPSWITCH and not TOUCH.
 let hid-input decide for the others 
		
		  MS PTP spec says that external buttons left and right have
		  usages 2 and 3.
 we do not want to map these: no input-oriented meaning 
  this function is called when a whole packet has been received and processed,
  so that it can decide what to send to the input layer.
 HID_DG_SCANTIME is expressed in 100us, we want it in us. 
 No data received for a while, resync the timestamp. 
 we will handle the hidinput part later, now remains hiddev 
			
			  The non-confidence was reported for
			  previously valid contact that is also no
			  longer valid. We can't simply report
			  lift-off as userspace will not be aware
			  of non-confidence, so we need to split
			  it into 2 events: active MT_TOOL_PALM
			  and a separate liftoff.
 this finger is in proximity of the sensor 
			
			  Azimuth is counter-clockwise and ranges from [0, MAX)
			  (a full revolution). Convert it to clockwise ranging
			  [-MAX2, MAX2].
			 
			  Note that ABS_MT_ORIENTATION require us to report
			  the limit of [-MAX4, MAX4], but the value can go
			  out of range to [-MAX2, MAX2] to report an upside
			  down ellipsis.
			
			  divided by two to match visual scale of touch
			  for devices with this quirk
		
		  For Win8 PTP touchpads we should only look at
		  non fingertouch events in the first_packet of a
		  (possible) multi-packet frame.
		
		  For Win8 PTP touchpads we map both the clickpad click
		  and any "external" left buttons to BTN_LEFT if a
		  device claims to have both we need to report 1 for
		  BTN_LEFT if either is pressed, so we or all values
		  together and report the result in mt_sync_frame().
 sticky fingers release in progress, abort 
	
	  Includes multi-packet support where subsequent
	  packets are sent with zero contactcount.
		
		  For Win8 PTPs the first packet (td->num_received == 0) may
		  have a contactcount of 0 if there only is a button event.
		  We double check that this is not a continuation packet
		  of a possible multi-packet frame be checking that the
		  timestamp has changed.
 A non 0 contact count always indicates a first packet 
	
	  Windows 8 specs says 2 things:
	  - once a contact has been reported, it has to be reported in each
	    subsequent report
	  - the report rate when fingers are present has to be at least
	    the refresh rate of the screen, 60 or 120 Hz
	 
	  I interprete this that the specification forces a report rate of
	  at least 60 Hz for a touchscreen to be certified.
	  Which means that if we do not get a report whithin 16 ms, either
	  something wrong happens, either the touchscreen forgets to send
	  a release. Taking a reasonable margin allows to remove issues
	  with USB communication or the load of the machine.
	 
	  Given that Win 8 devices are forced to send a release, this will
	  only affect laggish machines and the ones that have a firmware
	  defect.
 check for clickpads 
	
	  If mtclass.export_all_inputs is not set, only map fields from
	  TouchScreen or TouchPad collections. We need to ignore fields
	  that belong to other collections such as Mouse that might have
	  the same GenericDesktop usages.
	
	  Some Asus keyboard+touchpad devices have the hotkeys defined in the
	  touchpad report descriptor. We need to treat these as an array to
	  map usages to input keys.
	
	  some egalax touchscreens have "application == DG_TOUCHSCREEN"
	  for the stylus. Overwrite the hid_input application
 let hid-core decide for the others 
 We own these mappings, tell hid-input to ignore them 
 let hid-core decide for the others 
		
		  Some elan panels wrongly declare 2 input mode features,
		  and silently ignore when we set the value in the second
		  field. Skip the second feature and hope for the best.
 no need to update the report 
 Ignore if report count is out of bounds. 
 unknown serial device needs special quirks 
 already handled by hid core 
 we do not set suffix = "Touchscreen" 
 force BTN_STYLUS to allow tablet matching in udev 
	
	  An input report came in just before we release the sticky fingers,
	  it will take care of the sticky fingers.
 MT_CLS_DEFAULT 
	 This allows the driver to correctly support devices
	  that emit events over several HID messages.
	
	  This allows the driver to handle different input sensors
	  that emits events through different applications on the same HID
	  device.
 High latency is desirable for power savings during S3S0ix 
	 Some Elan legacy devices require SET_IDLE to be set on resume.
	  It should be safe to send it to other devices too.
  This list contains only:
  - VIDPID of products not working with the default multitouch handling
  - 2 generic rules.
  So there is no point in adding here any device with MT_CLS_DEFAULT.
 3M panels 
 Anton devices 
 Asus T101HA 
 Asus T304UA 
 Atmel panels 
 Baanto multitouch devices 
 Cando panels 
 Chunghwa Telecom touch panels 
 CJTouch panels 
 CVTouch panels 
 eGalax devices (resistive) 
 eGalax devices (capacitive) 
 Elan devices 
 Elitegroup panel 
 Flatfrog Panels 
 FocalTech Panels 
 GeneralTouch panel 
 Gametel game controller 
 GoodTouch panels 
 Hanvon panels 
 Ilitek dual touch panel 
 LG Melfas panel 
 Lenovo X1 TAB Gen 2 
 Lenovo X1 TAB Gen 3 
 MosArt panels 
 Novatek Panel 
 Ntrig Panel 
 Panasonic panels 
 PixArt optical touch screen 
 PixCir-based panels 
 Quanta-based panels 
 Razer touchpads 
 Smart Tech panels 
 Stantum panels 
 Synaptics devices 
 TopSeed panels 
 Touch International panels 
 Unitec panels 
 VTL panels 
 Winbond Electronics Corp. 
 Wistron panels 
 XAT 
 Xiroku 
 Google MT devices 
 Generic MT device 
 Generic Win 8 certified MT device 
 SPDX-License-Identifier: GPL-2.0-or-later
   USB HID driver for Glorious PC Gaming Race
   Glorious Model O, O- and D mice.
   Copyright (c) 2020 Samuel ƒåavoj <sammko@sammserver.com>
  Glorious Model O and O- specify the const flag in the consumer input
  report descriptor, which leads to inputs being ignored. Fix this
  by patching the descriptor.
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for Sony DualSense(TM) controller.
   Copyright (c) 2020 Sony Interactive Entertainment
 List of connected playstation devices. 
 Base class for playstation devices. 
 Name of primary input device. 
 Note: stored in little endian order. 
 Calibration data for playstation motion sensors. 
 Seed values for DualShock4  DualSense CRC32 for different report types. 
 Button masks for DualSense input report. 
 Status field of DualSense input report. 
  Status of a DualSense touch point contact.
  Contact IDs, with highest bit set are 'inactive'
  and any associated data is then invalid.
 Magic value required in tag field of Bluetooth output report. 
 Flags for DualSense output report. 
 DualSense hardware limits 
 Calibration data for accelerometer and gyroscope. 
 Timestamp for sensor data 
 Compatible rumble state 
 RGB lightbar 
 Microphone 
 Player leds 
 Sequence number for output report. 
 Main DualSense input report excluding any BTUSB specific headers. 
 Motion sensors 
 x, y, z 
 x, y, z 
 Touchpad 
 Common input report size shared equals the size of the USB report minus 1 byte for ReportID. 
 Common data between DualSense BTUSB main output report. 
 For DualShock 4 compatibility mode. 
 Audio controls 
 LEDs and lightbar 
 0x31 
 0x02 
  The DualSense has a main output report used to control most features. It is
  largely the same between Bluetooth and USB except for different headers and CRC.
  This structure hide the differences between the two to simplify sending output reports.
 Start of data 
 Size of output report 
 Points to Bluetooth data payload in case for a Bluetooth report else NULL. 
 Points to USB data payload in case for a USB report else NULL. 
 Points to common section of report, so past any headers. 
  Common gamepad buttons across DualShock 3  4 and DualSense.
  Note: for device with a touchpad, touchpad button is not included
         as it will be part of the touchpad device.
 Square 
 Triangle 
 Circle 
 Cross 
 L1 
 R1 
 L2 
 R2 
 Create (PS5)  Share (PS4) 
 Option 
 L3 
 R3 
 PS Home 
  Add a new ps_device to ps_devices if it doesn't exist.
  Return error on duplicate device, which can happen if the same
  device is connected using both Bluetooth and USB.
 Compute crc32 of HID data and compare against expected CRC. 
 Last 4 bytes contains crc32. 
 Register a DualSenseDualShock4 RGB lightbar represented by a multicolor LED. 
 Accelerometer 
 Gyroscope 
 Map button underneath touchpad to BTN_LEFT. 
	
	  Set gyroscope calibration and normalization parameters.
	  Data values will be normalized to 1DS_GYRO_RES_PER_DEG_S degrees.
	
	  Set accelerometer calibration and normalization parameters.
	  Data values will be normalized to 1DS_ACC_RES_PER_G g.
 Tag must be set. Exact meaning is unclear. 
		
		  Highest 4-bit is a sequence number, which needs to be increased
		  every report. Lowest 4-bit is tag and can be zero for now.
 USB 
  Helper function to send DualSense output reports. Applies a CRC at the end of a report
  for Bluetooth reports.
 Bluetooth packets need to be signed with a CRC in the last 4 bytes. 
 Select classic rumble style haptics and enable it. 
 Disable microphone 
 Enable microphone 
	
	  DualSense in USB uses the full HID report for reportID 1, but
	  Bluetooth uses a minimal HID report for reportID 1 and reports
	  the full report using reportID 49.
 Last 4 bytes of input report contain crc32 
 center 
	
	  The DualSense has an internal microphone, which can be muted through a mute button
	  on the device. The driver is expected to read the button state and program the device
	  to muteunmute audio at the hardware level.
 toggle 
 Schedule updating of microphone state at hardware level. 
 Parse and calibrate gyroscope data. 
 Parse and calibrate accelerometer data. 
 Convert timestamp (in 0.33us unit) to timestamp_us 
		
		  Each unit of battery data corresponds to 10%
		  0 = 0-9%, 1 = 10-19%, .. and 10 = 100%
 voltage or temperature out of range 
 temperature error 
 charging error 
	
	  On Bluetooth the DualSense outputs an animation on the lightbar
	  during startup and maintains a color afterwards. We need to explicitly
	  reconfigure the lightbar before we can do any programming later on.
	  In USB the lightbar is not on by default, but redoing the setup there
	  doesn't hurt.
 Fade light out. 
	
	  The DualSense controller has a row of 5 LEDs used for player ids.
	  Behavior on the PlayStation 5 console is to center the player id
	  across the LEDs, so e.g. player 1 would be "--x--" with x being 'on'.
	  Follow a similar mapping here.
	
	  Patch version to allow userspace to distinguish between
	  hid-generic vs hid-playstation axis and button mapping.
 initial value until parse_report. 
 Use gamepad input device name as primary device name for e.g. LEDs 
	
	  The hardware may have control over the LEDs (e.g. in Bluetooth on startup).
	  Reset the LEDs (lightbar, mute, player leds), so we can control them
	  from software.
 Set default lightbar color. 
 blue 
 Set player LEDs to our player id. 
	
	  Reporting hardware and firmware is important as there are frequent updates, which
	  can change behavior.
 SPDX-License-Identifier: GPL-2.0-only
    Copyright (C) 2010-2012 by Bruno Pr√©mont <bonbons@linux-vserver.org>  
    Based on Logitech G13 driver (v0.4)                                   
      Copyright (C) 2009 by Rick L. Vinyard, Jr. <rvinyard@cs.nmsu.edu>   
  lcd class device
 SPDX-License-Identifier: GPL-2.0-only
  hid-cp2112.c - Silicon Labs HID USB to SMBus master bridge
  Copyright (c) 2013,2014 Uplogix, Inc.
  David Barksdale <dbarksdale@uplogix.com>
  The Silicon Labs CP2112 chip is a USB HID device which provides an
  SMBus controller for talking to slave devices and 8 GPIO pins. The
  host communicates with the CP2112 via raw HID reports.
  Data Sheet:
    https:www.silabs.comSupport%20DocumentsTechnicalDocsCP2112.pdf
  Programming Interface Specification:
    https:www.silabs.comdocumentspublicapplication-notesan495-cp2112-interface-specification.pdf
 CP2112_SMBUS_CONFIG 
 Hz 
 Stored in the upper 7 bits 
 1 = enabled, 0 = disabled 
 ms, 0 = no timeout 
 ms, 0 = no timeout 
 1 = enabled, 0 = disabled 
 # of retries, 0 = no limit 
 CP2112_USB_CONFIG 
 Vendor ID 
 Product ID 
 Power requested in 2mA units 
	u8 power_mode;	 0x00 = bus powered
			   0x01 = self powered & regulator off
 What fields to program 
 CP2112_DATA_READ_REQUEST 
 CP2112_DATA_WRITE_READ_REQUEST 
 CP2112_DATA_WRITE_REQUEST 
 CP2112_DATA_READ_FORCE_SEND 
 CP2112_TRANSFER_STATUS_RESPONSE 
 STATUS0_ 
 STATUS1_ 
 force .string to be aligned 
 CP2112__STRING 
 length in bytes of everything after .report 
 USB_DT_STRING 
 UTF16_LITTLE_ENDIAN string 
 Number of times to request transfer status before giving up waiting for a
   transfer to complete. This may need to be changed if SMBUS clock, retries,
 Time in ms to wait for a CP2112_DATA_READ_RESPONSE or
	
	  Set gpio value when output direction is already set,
	  as specified in AN495, Rev. 0.2, cpt. 4.4
	 We have sent either a CP2112_TRANSFER_STATUS_REQUEST or a
	  CP2112_DATA_READ_FORCE_SEND and we are waiting for the response to
	  come in cp2112_raw_event or timeout. There will only be one of these
	  in flight at any one time. The timeout is extremely large and is a
	  last resort if the CP2112 has died. If we do timeout we don't expect
	  to receive the response which would cause data races, it's not like
	  we can do anything about it anyway.
 no repeated start in rev 1 
			
			  The hardware returned too much data.
			  This is mostly harmless because cp2112_read()
			  has a limit check so didn't overrun our
			  buffer.  Nevertheless, we return an error
			  because something is seriously wrong and
			  it shouldn't go unnoticed.
 return the number of transferred messages 
 Chmoding our sysfs attributes is simply a way to expose which fields in the
  PROM have already been programmed. We do not depend on this preventing
  writing to these attributes since the CP2112 will simply ignore writes to
  already-programmed fields. This is why there is no sense in fixing this
  racy behaviour.
 the hardware has been disconnected 
 Level High 
 Level Low 
 The event comes from the outside so no parent handler 
	 i2c_del_adapter has finished removing all i2c devices from our
	  adapter. Well behaved devices should no longer call our cp2112_xfer
	  and should have waited for any pending calls to finish. It has also
	  waited for device_unregister(&adap->dev) to complete. Therefore we
	  can safely free our struct cp2112_device.
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for some belkin "special" devices
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2006-2007 Jiri Kosina
   Copyright (c) 2008 Jiri Slaby
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for some a4tech "special" devices
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2006-2007 Jiri Kosina
   Copyright (c) 2008 Jiri Slaby
		
		  We do not want to have this usage mapped to anything as it's
		  nonstandard and doesn't really behave like an HID report.
		  It's only selecting the orientation (verticalhorizontal) of
		  the previous mouse wheel report. The input_events will be
		  generated once both reports are recorded in a4_event().
 SPDX-License-Identifier: GPL-2.0-or-later
  Roccat Kova[+] driver for Linux
  Copyright (c) 2011 Stefan Achatz <erazor_de@users.sourceforge.net>
  Roccat Kova[+] is a bigger version of the Pyra with two more side buttons.
 retval is 0-4 on success, < 0 on error 
 device will freeze with just 60 
 SPDX-License-Identifier: GPL-2.0-or-later
  Roccat Kone[+] driver for Linux
  Copyright (c) 2010 Stefan Achatz <erazor_de@users.sourceforge.net>
  Roccat Kone[+] is an updatedimproved version of the Kone with more memory
  and functionality and without the non-standard behaviours the Kone had.
  KoneXTD has same capabilities but updated sensor.
 retval is 0-4 on success, < 0 on error 
 class name has to be same as driver name 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for some samsung "special" devices
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2006-2007 Jiri Kosina
   Copyright (c) 2008 Jiri Slaby
   Copyright (c) 2010 Don Prince <dhprince.devel@yahoo.co.uk>
   This driver supports several HID devices:
   [0419:0001] Samsung IrDA remote controller (reports as Cypress USB Mouse).
 	various hid report fixups for different variants.
   [0419:0600] Creative Desktop Wireless 6000 keyboardmouse combo
 	several key mappings used from the consumer usage page
 	deviate from the USB HUT 1.12 standard.
  There are several variants for 0419:0001:
  1. 184 byte report descriptor
  Vendor specific report #4 has a size of 48 bit,
  and therefore is not accepted when inspecting the descriptors.
  As a workaround we reinterpret the report as:
    Variable type, count 6, size 8 bit, log. maximum 255
  The burden to reconstruct the data is moved into user space.
  2. 203 byte report descriptor
  Report #4 has an array field with logical range 0..18 instead of 1..15.
  3. 135 byte report descriptor
  Report #4 has an array field with logical range 0..17 instead of 1..14.
  4. 171 byte report descriptor
  Report #3 has an array field with logical range 0..1 instead of 1..3.
 report 2 
 disable hidinput, force hiddev 
 SPDX-License-Identifier: GPL-2.0-or-later
  Force feedback support for DragonRise Inc. game controllers
  From what I have gathered, these devices are mass produced in China and are
  distributed under several vendors. They often share the same design as
  the original PlayStation DualShock controller.
  0079:0006 "DragonRise Inc.   Generic   USB  Joystick  "
   - tested with a Tesun USB-703 game controller.
  Copyright (c) 2009 Richard Walmsley <richwalm@gmail.com>
		 While reverse engineering this device, I found that when
		   this value is set, it causes the strong rumble to function
  The original descriptor of joystick with PID 0x0011, represented by DVTech PC
  JS19. It seems both copied from another device and a result of confusion
  either about the specification or about the program used to create the
  descriptor. In any case, it's a wonder it works on Windows.
   Usage Page (Desktop),             ; Generic desktop controls (01h)
   Usage (Joystick),                 ; Joystick (04h, application collection)
   Collection (Application),
     Collection (Logical),
       Report Size (8),
       Report Count (5),
       Logical Minimum (0),
       Logical Maximum (255),
       Physical Minimum (0),
       Physical Maximum (255),
       Usage (X),                    ; X (30h, dynamic value)
       Usage (X),                    ; X (30h, dynamic value)
       Usage (X),                    ; X (30h, dynamic value)
       Usage (X),                    ; X (30h, dynamic value)
       Usage (Y),                    ; Y (31h, dynamic value)
       Input (Variable),
       Report Size (4),
       Report Count (1),
       Logical Maximum (7),
       Physical Maximum (315),
       Unit (Degrees),
       Usage (00h),
       Input (Variable, Null State),
       Unit,
       Report Size (1),
       Report Count (10),
       Logical Maximum (1),
       Physical Maximum (1),
       Usage Page (Button),          ; Button (09h)
       Usage Minimum (01h),
       Usage Maximum (0Ah),
       Input (Variable),
       Usage Page (FF00h),           ; FF00h, vendor-defined
       Report Size (1),
       Report Count (10),
       Logical Maximum (1),
       Physical Maximum (1),
       Usage (01h),
       Input (Variable),
     End Collection,
     Collection (Logical),
       Report Size (8),
       Report Count (4),
       Physical Maximum (255),
       Logical Maximum (255),
       Usage (02h),
       Output (Variable),
     End Collection,
   End Collection
 Size of the original descriptor of the PID 0x0011 joystick 
 Fixed report descriptor for PID 0x011 joystick 
  Usage Page (Desktop),           
  Usage (Joystick),               
  Collection (Application),       
      Collection (Logical),       
          Logical Minimum (0),    
          Report Size (8),        
          Report Count (3),       
          Input (Constant),       
          Logical Maximum (255),  
          Report Count (2),       
          Usage (X),              
          Usage (Y),              
          Input (Variable),       
          Report Size (1),        
          Report Count (4),       
          Input (Constant),       
          Logical Maximum (1),    
          Report Count (10),      
          Usage Page (Button),    
          Usage Minimum (01h),    
          Usage Maximum (0Ah),    
          Input (Variable),       
          Report Count (10),      
          Input (Constant),       
      End Collection,             
  End Collection                  
	
	  revert to the old hid-input behavior where axes
	  can be randomly assigned when hid->usage is reused.
 SPDX-License-Identifier: GPL-2.0-or-later
  HID driver for Elo Accutouch touchscreens
  Copyright (c) 2016, Collabora Ltd.
  Copyright (c) 2016, General Electric Company
  based on hid-penmount.c
   Copyright (c) 2014 Christian Gmeiner <christian.gmeiner <at> gmail.com>
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) 2013 Andrew Duggan <aduggan@synaptics.com>
   Copyright (c) 2013 Synaptics Incorporated
   Copyright (c) 2014 Benjamin Tissoires <benjamin.tissoires@gmail.com>
   Copyright (c) 2014 Red Hat, Inc
 Mouse emulation Report 
 Output Report 
 Output Report 
 Input Report 
 Input Report 
 Feature Report 
 flags 
 device flags 
  retrieve the ctrl registers
  the ctrl register has a size of 20 but a fw bug split it into 16 + 4,
  and there is no way to know if the first 20 bytes are here or not.
  We use only the first 12 bytes, so get only them.
  struct rmi_data - stores information for hid communication
  @page_mutex: Locks current page to avoid changing pages in unexpected ways.
  @page: Keeps track of the current virtual page
  @xport: transport device to be registered with the RMI4 core.
  @wait: Used for waiting for read data
  @writeReport: output buffer when writing RMI registers
  @readReport: input buffer when reading RMI registers
  @input_report_size: size of an input report (advertised by HID)
  @output_report_size: size of an output report (advertised by HID)
  @flags: flags for the current device (started, reading, etc...)
  @reset_work: worker which will be called in case of a mouse report
  @hdev: pointer to the struct hid_device
  @device_flags: flags which describe the device
  @domain: the IRQ domain allocated for this RMI4 device
  @rmi_irq: the irq that will be used to generate events to rmi-core
  rmi_set_page - Set RMI page
  @hdev: The pointer to the hid_device struct
  @page: The new page address.
  RMI devices have 16-bit addressing, but some of the physical
  implementations (like SMBus) only have 8-bit addressing. So RMI implements
  a page address at 0xff of every page so we can reliable page addresses
  every 256 registers.
  The page_mutex lock must be held when this function is entered.
  Returns zero on success, non-zero on failure.
		
		  Talk to device by using SET_REPORT requests instead.
 old 1 byte read count 
 switch the device to RMI if we receive a generic mouse report 
	
	  On the Dell XPS 13 9333, the bus sometimes get confused and fills
	  the report with a sentinel value "ff". Synaptics told us that such
	  behavior does not comes from the touchpad itself, so we filter out
	  such reports here.
 Make sure the HID device is ready to receive events 
 CONFIG_PM 
 Allow incoming hid reports 
	
	  we want to make HID ignore the advertised HID collection
	  for RMI deivces
	
	  Check for the RMI specific report ids. If they are misisng
	  simply return and let the events be processed by hid-input
 SPDX-License-Identifier: GPL-2.0-or-later
   USB HID quirks support for Linux
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2006-2007 Jiri Kosina
   Copyright (c) 2008 Jiri Slaby <jirislaby@gmail.com>
 0x0008 reserved, was: APPLE_HIDDEV 
 0x0080 reserved, was: APPLE_IGNORE_HIDINPUT 
 Look for the translation 
 should never happen 
  MacBook JIS keyboard has wrong logical maximum
  Magic Keyboard JIS has wrong logical maximum
 Enable all needed keys 
 The fn key on Apple USB keyboards 
 we want the hid layer to go through standard path (set and ignore) 
 SPDX-License-Identifier: GPL-2.0-only
  hid-ft260.c - FTDI FT260 USB HID to I2C host bridge
  Copyright (c) 2021, Michael Zaidman <michaelz@xsightlabs.com>
  Data Sheet:
    https:www.ftdichip.comSupportDocumentsDataSheetsICsDS_FT260.pdf
  The input report format assigns 62 bytes for the data payload, but ft260
  returns 60 and 2 in two separate transactions. To minimize transfer time
  in reading chunks mode, set the maximum read payload length to 60 bytes.
  Device interface configuration.
  The FT260 has 2 interfaces that are controlled by DCNF0 and DCNF1 pins.
  First implementes USB HID to I2C bridge function and
  second - USB HID to UART bridge function.
 Control pipe 
 Report IDs  Feature In 
 Feature Out 
 Response codes in I2C status report 
 I2C Conditions flags 
 Feature In reports 
 FT260_CHIP_VERSION 
 FTDI chip identification code 
 FT260_SYSTEM_SETTINGS 
 DCNF0 and DCNF1 status, bits 0-1 
 0 - 12MHz, 1 - 24MHz, 2 - 48MHz 
 0 - not suspended, 1 - suspended 
 0 - FT260 is not ready, 1 - ready 
 0 - disabled, 1 - enabled 
 0 - OFF; 1 - RTS_CTS, 2 - DTR_DSR, 
 3 - XON_XOFF, 4 - No flow control 
 0 - disabled, 1 - enabled 
 0 - GPIO,  1 - SUSPOUT, 
 2 - PWREN, 4 - TX_LED 
 0 - GPIO, 3 - TX_ACTIVE, 4 - TX_LED 
 0 - GPIO, 2 - PWREN, 
 5 - RX_LED, 6 - BCD_DET 
 0 - active-high, 1 - active-low 
 0 - disabled, 1 - enabled 
 Interrupt trigger conditions 
 0 - disabled, 1 - enabled 
 FT260_I2C_STATUS 
 I2C bus status 
 I2C bus clock in range 60-3400 KHz 
 Feature Out reports 
 FT260_SYSTEM_SETTINGS 
 FT260_SET_CLOCK 
 0 - 12MHz, 1 - 24MHz, 2 - 48MHz 
 FT260_SYSTEM_SETTINGS 
 FT260_SET_I2C_MODE 
 0 - disabled, 1 - enabled 
 FT260_SYSTEM_SETTINGS 
 FT260_SET_UART_MODE 
 0 - OFF; 1 - RTS_CTS, 2 - DTR_DSR, 
 3 - XON_XOFF, 4 - No flow control 
 FT260_SYSTEM_SETTINGS 
 FT260_SET_I2C_RESET 
 FT260_SYSTEM_SETTINGS 
 FT260_SET_I2C_CLOCK_SPEED 
 I2C bus clock in range 60-3400 KHz 
 Data transfer reports 
 FT260_I2C_REPORT 
 7-bit I2C address 
 I2C transaction condition 
 data payload length 
 data payload 
 FT260_I2C_READ_REQ 
 7-bit I2C address 
 I2C transaction condition 
 data payload length 
 FT260_I2C_REPORT 
 data payload length 
 data payload 
 END OF LIST  }
 transfer time = 1  clock(KHz)  10 bits  bytes 
  A random read operation is implemented as a dummy write operation, followed
  by a current address read operation. The dummy write operation is used to
  load the target byte address into the current byte address counter, from
  which the subsequent current address read operation then reads.
 Combined write then read message 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for Keytouch devices not fully compliant with HID standard
   Copyright (c) 2011 Jiri Kosina
 Replace the broken report descriptor of this device with rather
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for some chicony "special" devices
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2006-2007 Jiri Kosina
   Copyright (c) 2007 Paul Walmsley
   Copyright (c) 2008 Jiri Slaby
		 Change usage maximum and logical maximum from 0x7fff to
 SPDX-License-Identifier: GPL-2.0+
   HID driver for UC-Logic devices not fully compliant with HID standard
   - original and fixed report descriptors
   Copyright (c) 2010-2017 Nikolai Kondrashov
   Copyright (c) 2013 Martin Rusko
  This program is free software; you can redistribute it andor modify it
  under the terms of the GNU General Public License as published by the Free
  Software Foundation; either version 2 of the License, or (at your option)
  any later version.
 Fixed WP4030U report descriptor 
  Usage Page (Digitizer),             
  Usage (Pen),                        
  Collection (Application),           
      Report ID (9),                  
      Usage (Stylus),                 
      Collection (Physical),          
          Report Size (1),            
          Usage (Tip Switch),         
          Usage (Barrel Switch),      
          Usage (Tablet Pick),        
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Count (3),           
          Input (Variable),           
          Report Count (5),           
          Input (Constant),           
          Report Size (16),           
          Report Count (1),           
          Logical Minimum (0),        
          Push,                       
          Usage Page (Desktop),       
          Unit Exponent (-3),         
          Unit (Inch),                
          Physical Minimum (0),       
          Usage (X),                  
          Physical Maximum (4000),    
          Logical Maximum (32767),    
          Input (Variable),           
          Usage (Y),                  
          Physical Maximum (3000),    
          Logical Maximum (32767),    
          Input (Variable),           
          Pop,                        
          Usage (Tip Pressure),       
          Logical Maximum (1023),     
          Input (Variable),           
      End Collection,                 
  End Collection                      
 Fixed WP5540U report descriptor 
  Usage Page (Digitizer),             
  Usage (Pen),                        
  Collection (Application),           
      Report ID (9),                  
      Usage (Stylus),                 
      Collection (Physical),          
          Report Size (1),            
          Usage (Tip Switch),         
          Usage (Barrel Switch),      
          Usage (Tablet Pick),        
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Count (3),           
          Input (Variable),           
          Report Count (5),           
          Input (Constant),           
          Report Size (16),           
          Report Count (1),           
          Logical Minimum (0),        
          Push,                       
          Usage Page (Desktop),       
          Unit Exponent (-3),         
          Unit (Inch),                
          Physical Minimum (0),       
          Usage (X),                  
          Physical Maximum (5500),    
          Logical Maximum (32767),    
          Input (Variable),           
          Usage (Y),                  
          Physical Maximum (4000),    
          Logical Maximum (32767),    
          Input (Variable),           
          Pop,                        
          Usage (Tip Pressure),       
          Logical Maximum (1023),     
          Input (Variable),           
      End Collection,                 
  End Collection,                     
  Usage Page (Desktop),               
  Usage (Mouse),                      
  Collection (Application),           
      Report ID (8),                  
      Usage (Pointer),                
      Collection (Physical),          
          Report Size (1),            
          Usage Page (Button),        
          Usage Minimum (01h),        
          Usage Maximum (03h),        
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Count (3),           
          Input (Variable),           
          Report Count (5),           
          Input (Constant),           
          Usage Page (Desktop),       
          Report Size (8),            
          Usage (X),                  
          Usage (Y),                  
          Logical Minimum (-127),     
          Logical Maximum (127),      
          Report Count (2),           
          Input (Variable, Relative), 
          Usage (Wheel),              
          Logical Minimum (-1),       
          Logical Maximum (1),        
          Report Count (1),           
          Input (Variable, Relative), 
          Input (Constant),           
      End Collection,                 
  End Collection                      
 Fixed WP8060U report descriptor 
  Usage Page (Digitizer),             
  Usage (Pen),                        
  Collection (Application),           
      Report ID (9),                  
      Usage (Stylus),                 
      Collection (Physical),          
          Report Size (1),            
          Usage (Tip Switch),         
          Usage (Barrel Switch),      
          Usage (Tablet Pick),        
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Count (3),           
          Input (Variable),           
          Report Count (5),           
          Input (Constant),           
          Report Size (16),           
          Report Count (1),           
          Logical Minimum (0),        
          Push,                       
          Usage Page (Desktop),       
          Unit Exponent (-3),         
          Unit (Inch),                
          Physical Minimum (0),       
          Usage (X),                  
          Physical Maximum (8000),    
          Logical Maximum (32767),    
          Input (Variable),           
          Usage (Y),                  
          Physical Maximum (6000),    
          Logical Maximum (32767),    
          Input (Variable),           
          Pop,                        
          Usage (Tip Pressure),       
          Logical Maximum (1023),     
          Input (Variable),           
      End Collection,                 
  End Collection,                     
  Usage Page (Desktop),               
  Usage (Mouse),                      
  Collection (Application),           
      Report ID (8),                  
      Usage (Pointer),                
      Collection (Physical),          
          Report Size (1),            
          Usage Page (Button),        
          Usage Minimum (01h),        
          Usage Maximum (03h),        
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Count (3),           
          Input (Variable),           
          Report Count (5),           
          Input (Constant),           
          Usage Page (Desktop),       
          Report Size (8),            
          Usage (X),                  
          Usage (Y),                  
          Logical Minimum (-127),     
          Logical Maximum (127),      
          Report Count (2),           
          Input (Variable, Relative), 
          Usage (Wheel),              
          Logical Minimum (-1),       
          Logical Maximum (1),        
          Report Count (1),           
          Input (Variable, Relative), 
          Input (Constant),           
      End Collection,                 
  End Collection                      
 Fixed WP1062 report descriptor 
  Usage Page (Digitizer),             
  Usage (Pen),                        
  Collection (Application),           
      Report ID (9),                  
      Usage (Stylus),                 
      Collection (Physical),          
          Report Size (1),            
          Usage (Tip Switch),         
          Usage (Barrel Switch),      
          Usage (Tablet Pick),        
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Count (3),           
          Input (Variable),           
          Report Count (4),           
          Input (Constant),           
          Usage (In Range),           
          Report Count (1),           
          Input (Variable),           
          Report Size (16),           
          Report Count (1),           
          Logical Minimum (0),        
          Push,                       
          Usage Page (Desktop),       
          Unit Exponent (-3),         
          Unit (Inch),                
          Physical Minimum (0),       
          Usage (X),                  
          Physical Maximum (10000),   
          Logical Maximum (20000),    
          Input (Variable),           
          Usage (Y),                  
          Physical Maximum (6583),    
          Logical Maximum (13166),    
          Input (Variable),           
          Pop,                        
          Usage (Tip Pressure),       
          Logical Maximum (1023),     
          Input (Variable),           
      End Collection,                 
  End Collection                      
 Fixed PF1209 report descriptor 
  Usage Page (Digitizer),             
  Usage (Pen),                        
  Collection (Application),           
      Report ID (9),                  
      Usage (Stylus),                 
      Collection (Physical),          
          Report Size (1),            
          Usage (Tip Switch),         
          Usage (Barrel Switch),      
          Usage (Tablet Pick),        
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Count (3),           
          Input (Variable),           
          Report Count (5),           
          Input (Constant),           
          Report Size (16),           
          Report Count (1),           
          Logical Minimum (0),        
          Push,                       
          Usage Page (Desktop),       
          Unit Exponent (-3),         
          Unit (Inch),                
          Physical Minimum (0),       
          Usage (X),                  
          Physical Maximum (12000),   
          Logical Maximum (32767),    
          Input (Variable),           
          Usage (Y),                  
          Physical Maximum (9000),    
          Logical Maximum (32767),    
          Input (Variable),           
          Pop,                        
          Usage (Tip Pressure),       
          Logical Maximum (1023),     
          Input (Variable),           
      End Collection,                 
  End Collection,                     
  Usage Page (Desktop),               
  Usage (Mouse),                      
  Collection (Application),           
      Report ID (8),                  
      Usage (Pointer),                
      Collection (Physical),          
          Report Size (1),            
          Usage Page (Button),        
          Usage Minimum (01h),        
          Usage Maximum (03h),        
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Count (3),           
          Input (Variable),           
          Report Count (5),           
          Input (Constant),           
          Usage Page (Desktop),       
          Report Size (8),            
          Usage (X),                  
          Usage (Y),                  
          Logical Minimum (-127),     
          Logical Maximum (127),      
          Report Count (2),           
          Input (Variable, Relative), 
          Usage (Wheel),              
          Logical Minimum (-1),       
          Logical Maximum (1),        
          Report Count (1),           
          Input (Variable, Relative), 
          Input (Constant),           
      End Collection,                 
  End Collection                      
 Fixed PID 0522 tablet report descriptor, interface 0 (stylus) 
  Usage Page (Digitizer),             
  Usage (Pen),                        
  Collection (Application),           
      Report ID (9),                  
      Usage (Stylus),                 
      Collection (Physical),          
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Size (1),            
          Report Count (3),           
          Usage (Tip Switch),         
          Usage (Barrel Switch),      
          Usage (Tablet Pick),        
          Input (Variable),           
          Input (Constant, Variable), 
          Report Count (1),           
          Usage (In Range),           
          Input (Variable),           
          Input (Constant, Variable), 
          Report Size (16),           
          Push,                       
          Usage Page (Desktop),       
          Unit (Inch),                
          Unit Exponent (-3),         
          Physical Minimum (0),       
          Usage (X),                  
          Physical Maximum (8000),    
          Logical Maximum (32000),    
          Input (Variable),           
          Usage (Y),                  
          Physical Maximum (5000),    
          Logical Maximum (20000),    
          Input (Variable),           
          Pop,                        
          Usage (Tip Pressure),       
          Logical Maximum (1023),     
          Input (Variable),           
      End Collection,                 
  End Collection                      
 Fixed PID 0522 tablet report descriptor, interface 1 (mouse) 
  Usage Page (Desktop),               
  Usage (Mouse),                      
  Collection (Application),           
      Report ID (1),                  
      Usage (Pointer),                
      Collection (Physical),          
          Usage Page (Button),        
          Report Size (1),            
          Report Count (3),           
          Usage Minimum (01h),        
          Usage Maximum (03h),        
          Logical Minimum (0),        
          Logical Maximum (1),        
          Input (Variable),           
          Report Count (5),           
          Input (Constant, Variable), 
          Usage Page (Desktop),       
          Usage (X),                  
          Usage (Y),                  
          Logical Minimum (-32768),   
          Logical Maximum (32767),    
          Report Size (16),           
          Report Count (2),           
          Input (Variable, Relative), 
          Usage (Wheel),              
          Logical Minimum (-1),       
          Logical Maximum (1),        
          Report Count (1),           
          Report Size (8),            
          Input (Variable, Relative), 
          Input (Constant, Variable), 
      End Collection,                 
  End Collection                      
 Fixed PID 0522 tablet report descriptor, interface 2 (frame buttons) 
  Usage Page (Desktop),               
  Usage (Keyboard),                   
  Collection (Application),           
      Report ID (3),                  
      Usage Page (Keyboard),          
      Logical Minimum (0),            
      Usage Minimum (KB Leftcontrol), 
      Usage Maximum (KB Right GUI),   
      Logical Maximum (1),            
      Report Size (1),                
      Report Count (8),               
      Input (Variable),               
      Usage Minimum (None),           
      Usage Maximum (FFh),            
      Logical Maximum (255),          
      Report Size (8),                
      Report Count (6),               
      Input,                          
  End Collection                      
 Fixed TWHA60 report descriptor, interface 0 (stylus) 
  Usage Page (Digitizer),             
  Usage (Pen),                        
  Collection (Application),           
      Report ID (9),                  
      Usage (Stylus),                 
      Collection (Physical),          
          Report Size (1),            
          Usage (Tip Switch),         
          Usage (Barrel Switch),      
          Usage (Tablet Pick),        
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Count (3),           
          Input (Variable),           
          Report Count (4),           
          Input (Constant),           
          Usage (In Range),           
          Report Count (1),           
          Input (Variable),           
          Report Size (16),           
          Report Count (1),           
          Logical Minimum (0),        
          Push,                       
          Usage Page (Desktop),       
          Unit Exponent (-3),         
          Unit (Inch),                
          Physical Minimum (0),       
          Usage (X),                  
          Physical Maximum (10000),   
          Logical Maximum (39999),    
          Input (Variable),           
          Usage (Y),                  
          Physical Maximum (6250),    
          Logical Maximum (24999),    
          Input (Variable),           
          Pop,                        
          Usage (Tip Pressure),       
          Logical Maximum (1023),     
          Input (Variable),           
      End Collection,                 
  End Collection                      
 Fixed TWHA60 report descriptor, interface 1 (frame buttons) 
  Usage Page (Desktop),       
  Usage (Keyboard),           
  Collection (Application),   
      Report ID (5),          
      Usage Page (Keyboard),  
      Logical Minimum (0),    
      Logical Maximum (1),    
      Report Size (1),        
      Report Count (8),       
      Input (Constant),       
      Report Count (12),      
      Usage Minimum (KB F1),  
      Usage Maximum (KB F12), 
      Input (Variable),       
      Report Count (12),      
      Usage Minimum (KB F13), 
      Usage Maximum (KB F24), 
      Input (Variable),       
      Report Count (8),       
      Input (Constant),       
  End Collection              
 Fixed report descriptor template for (tweaked) v1 pen reports 
  Usage Page (Digitizer),                 
  Usage (Pen),                            
  Collection (Application),               
      Report ID (7),                      
      Usage (Stylus),                     
      Collection (Physical),              
          Logical Minimum (0),            
          Logical Maximum (1),            
          Report Size (1),                
          Usage (Tip Switch),             
          Usage (Barrel Switch),          
          Usage (Tablet Pick),            
          Report Count (3),               
          Input (Variable),               
          Report Count (3),               
          Input (Constant, Variable),     
          Usage (In Range),               
          Report Count (1),               
          Input (Variable),               
          Report Count (1),               
          Input (Constant, Variable),     
          Report Size (16),               
          Report Count (1),               
          Push,                           
          Usage Page (Desktop),           
          Unit (Inch),                    
          Unit Exponent (-3),             
          Physical Minimum (0),           
          Usage (X),                      
          Logical Maximum (PLACEHOLDER),  
          Physical Maximum (PLACEHOLDER), 
          Input (Variable),               
          Usage (Y),                      
          Logical Maximum (PLACEHOLDER),  
          Physical Maximum (PLACEHOLDER), 
          Input (Variable),               
          Pop,                            
          Usage (Tip Pressure),           
          Logical Maximum (PLACEHOLDER),  
          Input (Variable),               
      End Collection,                     
  End Collection                          
 Fixed report descriptor template for (tweaked) v2 pen reports 
  Usage Page (Digitizer),                 
  Usage (Pen),                            
  Collection (Application),               
      Report ID (8),                      
      Usage (Stylus),                     
      Collection (Physical),              
          Logical Minimum (0),            
          Logical Maximum (1),            
          Report Size (1),                
          Usage (Tip Switch),             
          Usage (Barrel Switch),          
          Usage (Tablet Pick),            
          Report Count (3),               
          Input (Variable),               
          Report Count (3),               
          Input (Constant, Variable),     
          Usage (In Range),               
          Report Count (1),               
          Input (Variable),               
          Report Count (1),               
          Input (Constant, Variable),     
          Report Count (1),               
          Push,                           
          Usage Page (Desktop),           
          Unit (Inch),                    
          Unit Exponent (-3),             
          Report Size (24),               
          Physical Minimum (0),           
          Usage (X),                      
          Logical Maximum (PLACEHOLDER),  
          Physical Maximum (PLACEHOLDER), 
          Input (Variable),               
          Usage (Y),                      
          Logical Maximum (PLACEHOLDER),  
          Physical Maximum (PLACEHOLDER), 
          Input (Variable),               
          Pop,                            
          Usage (Tip Pressure),           
          Report Size (16),               
          Logical Maximum (PLACEHOLDER),  
          Input (Variable),               
          Input (Constant, Variable),     
      End Collection,                     
  End Collection                          
  Expand to the contents of a generic buttonpad report descriptor.
  @_padding:	Padding from the end of button bits at bit 44, until
 		the end of the report, in bits.
  Usage Page (Desktop),                \
  Usage (Keypad),                      \
  Collection (Application),            \
      Report ID (247),                 \
      Logical Minimum (0),             \
      Logical Maximum (1),             \
      Report Size (1),                 \
      Usage Page (Digitizer),          \
      Usage (Tablet Function Keys),    \
      Collection (Physical),           \
          Usage (Barrel Switch),       \
          Report Count (1),            \
          Input (Variable),            \
          Usage Page (Desktop),        \
          Usage (X),                   \
          Usage (Y),                   \
          Report Count (2),            \
          Input (Variable),            \
          Report Count (21),           \
          Input (Constant),            \
          Usage Page (Button),         \
          Usage Minimum (01h),         \
          Usage Maximum (0Ah),         \
          Report Count (10),           \
          Input (Variable),            \
      End Collection,                  \
      Usage Page (Desktop),            \
      Usage (Gamepad),                 \
      Collection (Physical),           \
          Usage Page (Button),         \
          Usage Minimum (01h),         \
          Usage Maximum (02h),         \
          Report Count (2),            \
          Input (Variable),            \
          Report Count (_padding),     \
          Input (Constant),            \
      End Collection,                  \
  End Collection                      
 Fixed report descriptor for (tweaked) v1 buttonpad reports 
 Fixed report descriptor for (tweaked) v2 buttonpad reports 
 Fixed report descriptor for Ugee EX07 buttonpad 
  Usage Page (Desktop),                   
  Usage (Keypad),                         
  Collection (Application),               
      Report ID (6),                      
      Usage Page (Digitizer),             
      Usage (Tablet Function Keys),       
      Collection (Physical),              
          Usage Page (Button),            
          Report Size (1),                
          Usage Minimum (03h),            
          Usage Maximum (06h),            
          Report Count (4),               
          Input (Variable),               
          Report Count (26),              
          Input (Constant, Variable),     
          Usage Minimum (01h),            
          Usage Maximum (02h),            
          Report Count (2),               
          Input (Variable),               
      End Collection,                     
  End Collection                          
 Fixed report descriptor for Ugee G5 frame controls 
  Usage Page (Desktop),               
  Usage (Keypad),                     
  Collection (Application),           
      Report ID (6),                  
      Usage Page (Digitizer),         
      Usage (Tablet Function Keys),   
      Collection (Physical),          
          Logical Minimum (0),        
          Logical Maximum (1),        
          Usage Page (Desktop),       
          Usage Page (Button),        
          Usage Minimum (01h),        
          Usage Maximum (05h),        
          Report Size (1),            
          Report Count (5),           
          Input (Variable),           
          Report Size (1),            
          Report Count (3),           
          Input (Constant),           
          Usage Page (Digitizer),     
          Usage (FFFFh),              
          Logical Maximum (255),      
          Report Size (8),            
          Report Count (1),           
          Input (Variable),           
          Logical Maximum (1),        
          Usage (Barrel Switch),      
          Report Size (1),            
          Report Count (1),           
          Input (Variable),           
          Usage Page (Desktop),       
          Usage (X),                  
          Usage (Y),                  
          Report Size (1),            
          Report Count (2),           
          Input (Variable),           
          Report Size (1),            
          Report Count (11),          
          Input (Constant),           
          Usage Page (Desktop),       
          Usage (Wheel),              
          Logical Minimum (-1),       
          Logical Maximum (1),        
          Report Size (2),            
          Report Count (1),           
          Input (Variable, Relative), 
      End Collection,                 
  End Collection                      
 Fixed report descriptor for XP-Pen Deco 01 frame controls 
  Usage Page (Desktop),               
  Usage (Keypad),                     
  Collection (Application),           
      Report ID (6),                  
      Logical Minimum (0),            
      Logical Maximum (1),            
      Report Size (1),                
      Usage Page (Digitizer),         
      Usage (Tablet Function Keys),   
      Collection (Physical),          
          Usage Page (Button),        
          Usage Minimum (01h),        
          Usage Maximum (08h),        
          Report Count (8),           
          Input (Variable),           
          Usage Page (Digitizer),     
          Usage (Barrel Switch),      
          Report Count (1),           
          Input (Variable),           
          Usage Page (Desktop),       
          Usage (X),                  
          Usage (Y),                  
          Report Count (2),           
          Input (Variable),           
          Report Count (21),          
          Input (Constant),           
      End Collection,                 
  End Collection                      
  uclogic_rdesc_template_apply() - apply report descriptor parameters to a
  report descriptor template, creating a report descriptor. Copies the
  template over to the new report descriptor and replaces every occurrence of
  UCLOGIC_RDESC_PH_HEAD, followed by an index byte, with the value from the
  parameter list at that index.
  @template_ptr:	Pointer to the template buffer.
  @template_size:	Size of the template buffer.
  @param_list:		List of template parameters.
  @param_num:		Number of parameters in the list.
  Returns:
 	Kmalloc-allocated pointer to the created report descriptor,
 	or NULL if allocation failed.
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for TiVo Slide Bluetooth remote
   Copyright (c) 2011 Jarod Wilson <jarod@redhat.com>
   based on the hid-topseed driver, which is in turn, based on hid-cherry...
 TiVo button 
 Live TV 
 Red thumbs down 
 Green thumbs up 
 EnterLast (default mapping: KEY_LAST) 
 Info (default mapping: KEY_PROPS) 
	 This means we found a matching mapping here, else, look in the
 TiVo Slide Bluetooth remote, pairs with a Broadcom dongle 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for LC Power Model RC1000MCE
   Copyright (c) 2011 Chris Schlund 
   based on hid-topseed module
 SPDX-License-Identifier: GPL-2.0-or-later
  driversinputtabletwacom_wac.c
   USB Wacom tablet support - Wacom specific code
 resolution for penabled devices 
 Newer Cintiq and DTU have an offset between tablet and screen areas 
  Scale factor relating reported contact size to logical contact area.
  2^14pi is a good approximation on Intuos5 and 3rd-gen Bamboo
  Percent of battery capacity for Graphire.
  8th value means AC online and show 100% capacity.
  Percent of battery capacity for Intuos4 WL, AC has a separate bit.
 report tool id 
 report tool id 
 report tool id 
	 If the eraser is in prox, STYLUS2 is always set. If we
	  mis-detected the type and notice that STYLUS2 isn't set
	  then force the eraser out of prox and let the pen in.
 Only allow the stylus2 button to be reported for the pen tool. 
 report tool id 
 Going into proximity select tool 
 out-prox 
 Rubber 
 Pen 
 out-prox 
 Pen 
 Rubber 
 Mouse with wheel 
 Mouse without wheel 
 Compute distance between mouse and tablet 
 Mouse with wheel 
 report tool id 
 sync last event 
 send pad data 
 Store current battery capacity and power supply state 
 pad packets. Works as a second tool and is always in prox 
		
		  Three "buttons" are available on the 24HD which are
		  physically implemented as a touchstrip. Each button
		  is approximately 3 bits wide with a 2 bit spacing.
		  The raw touchstrip bits are stored at:
		     ((data[3] & 0x1f) << 8) | data[4])
		
		  Do not send hardware buttons under Android. They
		  are already sent to the system through GPIO (and
		  have different meaning).
		 
		  d-pad right  -> data[4] & 0x10
		  d-pad up     -> data[4] & 0x20
		  d-pad left   -> data[4] & 0x40
		  d-pad down   -> data[4] & 0x80
		  d-pad center -> data[3] & 0x01
		 d-pad right  -> data[2] & 0x10
		  d-pad up     -> data[2] & 0x20
		  d-pad left   -> data[2] & 0x40
		  d-pad down   -> data[2] & 0x80
		  d-pad center -> data[1] & 0x01
		
		  ExpressKeys on Intuos5Intuos Pro have a capacitive sensor in
		  addition to the mechanical switch. Switch data is
		  stored in data[4], capacitive data in data[5].
		 
		  Touch ring mode switch (data[3]) has no capacitive sensor
 Inking pen 
 Intuos3 Inking pen 
 Intuos45 Inking Pen 
 Pen 
 Intuos3 Grip Pen 
 Intuos3 Classic Pen 
 Intuos3 Marker Pen 
 Intuos45 13HD24HD General Pen 
 Intuos45 13HD24HD Marker Pen 
 IntuosHT2 pen 
 Intuos45 13HD24HD Art Pen 
 MobileStudio Pro Pro Pen slim 
 Intuos45 13HD24HD Classic Pen 
 Cintiq 13HD Pro Pen 
 DTH2242 Pen 
 Intuos45 13HD24HD General Pen 
 Stroke pen 
 Mouse 4D and 2D 
 Intuos3 2D Mouse 
 Intuos4 Mouse 
 Lens cursor 
 Intuos3 Lens cursor 
 Intuos4 Lens cursor 
 Eraser 
 Intuos3 Grip Pen Eraser 
 Intuos3 Classic Pen Eraser 
 Intuos3 Airbrush Eraser 
 Intuos45 13HD24HD Marker Pen Eraser 
 Intuos45 13HD24HD General Pen Eraser 
 Intuos45 13HD24HD Airbrush Eraser 
 Intuos45 13HD24HD Classic Pen Eraser 
 Intuos45 13HD24HD Airbrush Eraser 
 Intuos45 13HD24HD Art Pen Eraser 
 MobileStudio Pro Pro Pen slim Eraser 
 Cintiq 13HD Pro Pen Eraser 
 DTH2242 Eraser 
 Intuos45 13HD24HD General Pen Eraser 
 Intuos3 Airbrush 
 Intuos45 13HD24HD Airbrush 
 Intuos45 13HD24HD Airbrush 
 Unknown tool 
	
	  Reset all states otherwise we lose the initial states
	  when in-prox next time
 reset tool id 
 in prox 
 in range 
 out prox 
 Enter report 
 serial number of the tool 
 in Range 
 in Range while exiting 
 Exit report 
 don't report exit if we don't know the ID 
 don't report events if we don't know the tool ID 
 but reschedule a read of the current tool 
	
	  don't report events for invalid data
 older I4 styli don't work with new Cintiqs 
 Only large Intuos support Lense Cursor 
 Cintiq doesn't send data when RDY bit isn't set 
 general pen packet 
 airbrush second packet 
 Rotation packet 
 I3 marker pen rotation 
 4D mouse 2nd packet 
 4D mouse 1st packet 
 I4 mouse 
 2D mouse packet 
 I3 2D mouse side buttons 
 Lens cursor packets 
 unhandled 
 report tool id 
 process pad events 
 process inout prox events 
 process general packets 
Which mode select (LED light) is currently on?
 Add back in missing bits of ID for non-USI pens 
 first in range 
 Going into range select tool 
 Fix rotation alignment: userspace expects zero at left 
 report tool id 
		
		  First packet resets the counter since only the first
		  packet in series will have non-zero current_num_contacts.
 Be careful that we don't accidentally call input_sync with
 only a partial set of fingers of processed
 Fix touchring data: userspace expects 0 at left and increasing clockwise 
 maximum contacts per packet 
	
	  First packet resets the counter since only the first
	  packet in series will have non-zero current_num_contacts.
 MTTPC does not support Height and Width 
	
	  First packet resets the counter since only the first
	  packet in series will have non-zero current_num_contacts.
 There are at most 5 contacts per packet 
 keep touch state for pen event 
 keep touch state for pen events 
 first in prox 
 Going into proximity select tool 
 keep pen state for touch events 
	 send pen events only when touch is up or forced out
	  or touch arbitration is off
 softkey touch switch 
		
		  These two usages, which are used to mute touch events, come
		  from the pad packet, but are reported on the touch
		  interface. Because the touch interface may not have
		  been created yet, we cannot call wacom_map_usage(). In
		  order to process the usages when we receive them, we set
		  the usage type and code directly.
		
		  Only set up typecode association. Completely mapping
		  this usage may overwrite the axis resolution and range.
 do not overwrite previous data 
	
	  Avoid reporting this event and setting inrange_state if this usage
	  hasn't been mapped.
		
		  Userspace expects touchrings to increase in value with
		  clockwise gestures and have their zero point at the
		  tablet's left. HID events "should" be clockwise-
		  increasing and zero at top, though the MobileStudio
		  Pro and 2nd-gen Intuos Pro don't do this...
 MobileStudio Pro 
 Intuos Pro 2 
 Intuos Pro 2 
 MobileStudio Pro 
 MobileStudio Pro 
 report prox for expresskey events 
		
		  HID_GD_Z "should increase as the control's position is
		  moved from high to low", while ABS_DISTANCE instead
		  increases in value as the tool moves from low to high.
		
		  Userspace expects pen twist to have its zero point when
		  the buttonsfinger is on the tablet's left. HID values
		  are zero when buttons are toward the top.
			
			  Non-USI EMR devices may contain additional tool type
			  information here. See WACOM_HID_WD_TOOLTYPE case for
			  more details.
		
		  Some devices (MobileStudio Pro, and possibly later
		  devices as well) do not return the complete tool
		  type in their WACOM_HID_WD_TOOLTYPE usage. Use a
		  bitwise OR so the complete value can be built
		  up over time :(
	 send pen events only when touch is up or forced out
	  or touch arbitration is off
 send pen events only when the pen is in range 
 first in range 
 Going into range select tool 
 keep pen state for touch events 
		
		  Non-USI EMR tools should have their IDs mangled to
		  match the legacy behavior of wacom_intuos_general
		
		  To ensure compatibility with xf86-input-wacom, we should
		  report the BTN_TOOL_ event prior to the ABS_MISC or
		  MSC_SERIAL events.
			
			  The HID descriptor for G11 sensors leaves logical
			  maximum set to '1' despite it being a multitouch
			  device. Override to a sensible number.
 No data to send for this slot; short-circuit
 if there was nothing to process, don't send an empty sync 
	 If more packets of data are expected, give us a chance to
	  process them rather than immediately syncing a partial
	  update.
 keep touch state for pen event 
 usage tests must precede field tests 
 usage tests must precede field tests 
	
	  Non-input reports may be sent prior to the device being
	  completely initialized. Since only their events need
	  to be processed, exit after 'wacom_report_events' has
	  been called to prevent potential crashes in the report-
	  processing functions.
			
			  "a" is a scaled-down area which we assume is
			  roughly circular and which can be described as:
			  a=(pir^2)C.
 data has up to 7 fixed sized 8-byte messages starting at data[2] 
 only update touch if we actually have a touchpad and touch data changed 
		
		  Convert distance from out prox to distance from tablet.
		  distance will be greater than distance_max once
		  touching and applying pressure; do not report negative
		  distance.
 PEN or RUBBER 
 TOOL ID 
	
	  We need to reroute the event from the debug interface to the
	  pen interface.
	  We need to add the report ID to the actual pen report, so we
	  temporary overwrite the first byte to prevent having to kzallockfree
	  and memcpy the report.
	
	  actually reroute the event.
	  No need to check if wacom->shared->pen is valid, hid_input_report()
	  will check for us.
 keep touch state for pen event 
 disconnected while previously connected 
 wireless module is attached 
 The pen and pad share the same interface on most devices 
 touch device found but size is not defined. use default 
	
	  Intuos5Pro and Bamboo 3rd gen have no useful data about its
	  touch interface in its HID descriptor. If this is the touch
	  interface (PacketSize of WACOM_PKGLEN_BBTOUCH3), override the
	  tablet values.
	
	  Hack for the Bamboo One:
	  the device presents a PADTouch interface as most Bamboos and even
	  sends ghosts PAD data on it. However, later, we must disable this
	  ghost interface, and we can not detect it unless we set it here
	  to WACOM_DEVICETYPE_PAD or WACOM_DEVICETYPE_TOUCH.
	
	  Raw Wacom-mode pen and touch events both come from interface
	  0, whose HID descriptor has an application usage of 0xFF0D
	  (i.e., WACOM_HID_WD_DIGITIZER). We route pen packets back
	  out through the HID_GENERIC device created for interface 1,
	  so rewrite this one to be of type WACOM_DEVICETYPE_TOUCH.
 quirk for bamboo touch with 2 low res touches 
	 HID descriptor for DTK-2451  DTH-2452 claims to report lots
	  of things it shouldn't. Lets fix up the damage...
 setup has already been done 
 penabled devices have fixed resolution for each model 
 setup has already been done 
	
	  24HD has LED group 1 to the left and LED group 0 to the right.
	  So group 0 matches the second half of the buttons and thus the mask
	  needs to be shifted.
	
	  21UX2 has LED group 1 to the left and LED group 0
	  to the right. We need to reverse the group to match this
	  historical behavior.
 kept for making legacy xf86-input-wacom working with the wheels 
 kept for making legacy xf86-input-wacom accepting the pad 
 kept for making udev and libwacom accepting the pad 
 pointsg 
		
		  For Bluetooth devices, the udev rule does not work correctly
		  for pads unless we add a stylus capability, which forces
		  ID_INPUT_TABLET to be set.
 no pad supported 
 Pen 
 Touch 
 Touch 
 Pen 
 Touch 
 Pen-only 
 Pen-only 
 Pen-only 
 Pen-only 
 Pen-only 
 Touch 
 Touch 
 Touch 
 Touch 
 Touch 
 SPDX-License-Identifier: GPL-2.0+
   HID driver for quirky Macally devices
   Copyright (c) 2019 Alex Henrie <alexhenrie24@gmail.com>
  The Macally ikey keyboard says that its logical and usage maximums are both
  101, but the power key is 102 and the equals key is 103
 SPDX-License-Identifier: GPL-2.0-or-later
   Plantronics USB HID Driver
   Copyright (c) 2014 JD Cole <jd.cole@plantronics.com>
   Copyright (c) 2015-2018 Terry Junge <terry.junge@plantronics.com>
 ms 
 special case for PTT products 
 handle volume updown mapping 
 non-standard types or multi-HID interfaces - plt_type is PID 
 handle standard types - plt_type is 0xffa0uuuu or 0xffa2uuuu 
 'basic telephony compliant' - allow default consumer page map 
 not 'basic telephony' - apply legacy mapping 
 only map if the field is in the device's primary vendor page 
  Future mapping of call control or other usages,
  if and when keys are defined would go here
  otherwise, ignore everything else that was not mapped
 Usages are filtered in plantronics_usages. 
 Handle key presses only. 
 Ignore the repeated key. 
 multi-HID interfaces? - plt_type is PID 
 determine primary vendor page 
 SPDX-License-Identifier: GPL-2.0-or-later
   Force feedback support for Logitech RumblePad and Rumblepad 2
   Copyright (c) 2008 Anssi Hannula <anssi.hannula@gmail.com>
 Check that the report looks ok 
 SPDX-License-Identifier: GPL-2.0-or-later
  Roccat KonePure driver for Linux
  Copyright (c) 2012 Stefan Achatz <erazor_de@users.sourceforge.net>
  Roccat KonePure is a smaller version of KoneXTD with less buttons and lights.
 always KONEPURE_MOUSE_REPORT_NUMBER_BUTTON 
 SPDX-License-Identifier: GPL-2.0-only
    Copyright (C) 2010-2012 by Bruno Pr√©mont <bonbons@linux-vserver.org>  
    Based on Logitech G13 driver (v0.4)                                   
      Copyright (C) 2009 by Rick L. Vinyard, Jr. <rvinyard@cs.nmsu.edu>   
  The "eeprom" file
 prepare buffer with info about what we want to read (addr & len) 
 successful read :) 
 anything else is some kind of IO error 
 check if written data matches 
  Notes:
  - readwrite happens in chunks of at most 20 bytes, it's up to userspace
    to loop in order to get more data.
  - on write errors on otherwise correct write request the bytes
    that should have been written are in undefined state.
  The "flash" file
 record a flash address to buf (bounds check to be done by caller) 
 read a given size of data (bounds check to be done by caller) 
 erase block aligned to 64bytes boundary 
 write a given size of data (bounds check to be done by caller) 
  Notes:
  - concurrent writing is prevented by mutex and all writes must be
    n64 bytes and 64-byte aligned, each write being preceded by an
    ERASE which erases a 64byte block.
    If less than requested was written or an error is returned for an
    otherwise correct write request the next 64-byte block which should
    have been written is in undefined state (mostly: original, erased,
    (half-)written with write error)
  - reading can happen without special restriction
  Helper code for HID report level dumpingdebugging
 Avoid unnecessary overhead if debugfs is disabled 
 1 data byte with GPO state 
 1 data byte with brightness 
 1 data byte with contrast 
 2 data bytes with reset duration in ms 
 63 data bytes with LCD commands 
 TODO: format decoding 
 63 data bytes with LCD data 
 TODO: format decoding 
 63 data bytes with LCD commands and data 
 TODO: format decoding 
 3 data bytes with read area description 
 3+1..20 data bytes with write area description 
 3 data bytes with pointer inside erase block 
 4 data bytes with read area description 
 4+1..32 data bytes with write adrea description 
 TODO 
 Avoid unnecessary overhead if debugfs is disabled 
 2 data bytes with affected report and error code 
 2 data bytes with key state 
 Up to 20 byes of IR scancode data 
 Data buffer in response to REPORT_EE_READ or REPORT_EE_WRITE 
 Data buffer in response to REPORT_READ_MEMORY or REPORT_WRITE_MEMORY 
 TODO 
 TODO 
 TODO 
 reset 
 eeprom 
 flash 
 SPDX-License-Identifier: GPL-2.0-or-later
  Force feedback support for various HID compliant devices by ThrustMaster:
     ThrustMaster FireStorm Dual Power 2
  and possibly others whose device ids haven't been added.
   Modified to support ThrustMaster devices by Zinx Verituse
   on 2003-01-25 from the Logitech force feedback driver,
   which is by Johann Deneux.
   Copyright (c) 2003 Zinx Verituse <zinx@epicsol.org>
   Copyright (c) 2002 Johann Deneux
 Usages for thrustmaster devices I know about 
 Changes values from 0 to 0xffff into values from minimum to maximum 
 Changes values from -0x80 to 0x7f into values from minimum to maximum 
 Rumbling 
 2-in-1 strong motor is left 
 Find the report to use 
 FireStorm Dual Power 2 (and 3) 
 Dual Trigger 2-in-1 
 Dual Trigger 3-in-1 (PC Mode) 
 Dual Trigger 3-in-1 (PS3 Mode) 
 NASCAR PRO FF2 Wheel 
 FGT Rumble Force Wheel 
 RGT Force Feedback CLUTCH Raging Wheel 
 FGT Force Feedback Wheel 
 F430 Force Feedback Wheel 
 SPDX-License-Identifier: GPL-2.0-or-later
   ION iCade input driver
   Copyright (c) 2012 Bastien Nocera <hadess@hadess.net>
   Copyright (c) 2012 Benjamin Tissoires <benjamin.tissoires@gmail.com>
    ‚Üë      A C Y L
   ‚Üê ‚Üí
    ‚Üì      B X Z R
   UP ON,OFF  = w,e
   RT ON,OFF  = d,c
   DN ON,OFF  = x,z
   LT ON,OFF  = a,q
   A  ON,OFF  = y,t
   B  ON,OFF  = h,r
   C  ON,OFF  = u,f
   X  ON,OFF  = j,n
   Y  ON,OFF  = i,m
   Z  ON,OFF  = k,p
   L  ON,OFF  = o,g
   R  ON,OFF  = l,v
 The translation code uses HID usage instead of input layer
  keys. This code generates a lookup table that makes
  translation quick.
  #include <linuxinput.h>
  #include <stdio.h>
  #include <assert.h>
  #define unk     KEY_UNKNOWN
  < copy of hid_keyboard[] from hid-input.c >
  struct icade_key_translation {
      int         from;
      const char to;
      int         press;
  };
  static const struct icade_key_translation icade_keys[] = {
     { KEY_W,        "KEY_UP",         1 },
     { KEY_E,        "KEY_UP",         0 },
     { KEY_D,        "KEY_RIGHT",      1 },
     { KEY_C,        "KEY_RIGHT",      0 },
     { KEY_X,        "KEY_DOWN",       1 },
     { KEY_Z,        "KEY_DOWN",       0 },
     { KEY_A,        "KEY_LEFT",       1 },
     { KEY_Q,        "KEY_LEFT",       0 },
     { KEY_Y,        "BTN_A",          1 },
     { KEY_T,        "BTN_A",          0 },
     { KEY_H,        "BTN_B",          1 },
     { KEY_R,        "BTN_B",          0 },
     { KEY_U,        "BTN_C",          1 },
     { KEY_F,        "BTN_C",          0 },
     { KEY_J,        "BTN_X",          1 },
     { KEY_N,        "BTN_X",          0 },
     { KEY_I,        "BTN_Y",          1 },
     { KEY_M,        "BTN_Y",          0 },
     { KEY_K,        "BTN_Z",          1 },
     { KEY_P,        "BTN_Z",          0 },
     { KEY_O,        "BTN_THUMBL",     1 },
     { KEY_G,        "BTN_THUMBL",     0 },
     { KEY_L,        "BTN_THUMBR",     1 },
     { KEY_V,        "BTN_THUMBR",     0 },
     { }
  };
  static int
  usage_for_key (int key)
  {
      int i;
      for (i = 0; i < 256; i++) {
      if (hid_keyboard[i] == key)
          return i;
      }
      assert(0);
  }
  int main (int argc, char argv)
  {
      const struct icade_key_translation trans;
      int max_usage = 0;
      for (trans = icade_keys; trans->from; trans++) {
          int usage = usage_for_key (trans->from);
          max_usage = usage > max_usage ? usage : max_usage;
      }
      printf ("#define ICADE_MAX_USAGE %d\n\n", max_usage);
      printf ("struct icade_key {\n");
      printf ("\tu16 to;\n");
      printf ("\tu8 press:1;\n");
      printf ("};\n\n");
      printf ("static const struct icade_key "
              "icade_usage_table[%d] = {\n", max_usage + 1);
      for (trans = icade_keys; trans->from; trans++) {
          printf ("\t[%d] = { %s, %d },\n",
                  usage_for_key (trans->from), trans->to, trans->press);
      }
      printf ("};\n");
      return 0;
  }
 We ignore the fake key up, and act only on key down 
 ignore others 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for Steelseries SRW-S1
   Copyright (c) 2013 Simon Wood
 the last element is used for setting all leds simultaneously 
 Fixed report descriptor for Steelseries SRW-S1 wheel controller
  The original descriptor hides the sensitivity and assists dials
  a custom vendor usage page. This inserts a patch to make them
  appear in the 'Generic Desktop' usage.
  Usage Page (Desktop)                
  Usage (MultiAxis), Changed          
  Collection (Application),           
      Collection (Logical),           
          Report Count (1),           
 Changed  Usage Page (Desktop),       
 Changed  Usage (X),                  
          Logical Minimum (-1800),    
          Logical Maximum (1800),     
          Unit (Degrees),             
          Unit Exponent (15),         
          Report Size (16),           
          Input (Variable),           
 Changed  Usage (Y),                  
          Logical Minimum (0),        
          Logical Maximum (1023),     
          Report Size (12),           
          Input (Variable),           
 Changed  Usage (Z),                  
          Logical Minimum (0),        
          Logical Maximum (1023),     
          Report Size (12),           
          Input (Variable),           
          Usage Page (Desktop),       
          Usage (Hat Switch),         
          Logical Maximum (7),        
          Physical Minimum (0),       
          Physical Maximum (315),     
          Unit (Degrees),             
          Report Size (4),            
          Report Count (1),           
          Input (Variable),           
          Logical Maximum (1),        
          Physical Maximum (1),       
          Unit,                       
          Report Size (1),            
          Report Count (3),           
          Input (Constant),           
          Usage Page (Button),        
          Usage Minimum (01h),        
          Usage Maximum (11h),        
          Report Count (17),          
          Input (Variable),           
   ---- Dial patch starts here ----   
          Usage Page (Desktop),       
          Usage (RX),                 
          Report Size (4),            
          Report Count (2),           
          Logical Minimum (0),        
          Logical Maximum (b),        
          Input (Variable),           
          Usage (RZ),                 
          Report Size (4),            
          Report Count (1),           
          Logical Maximum (3),        
          Input (Variable),           
    ---- Dial patch ends here ----    
          Usage Page (FF00h),         
          Usage (01h),                
 Changed  Report Size (4),            
 Changed  Report Count (13),          
          Input (Variable),           
      End Collection,                 
      Collection (Logical),           
          Usage (02h),                
          Report Size (8),            
          Report Count (16),          
          Output (Variable),          
      End Collection,                 
  End Collection                      
 Note: LED change does not show on device until the device is readpolled 
 register led subsystem 
 'ALL', for setting all LEDs simultaneously 
 Each individual LED 
 Deregister all LEDs (if any) 
 but let the driver continue without LEDs 
 Deregister LEDs (if any) 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for some petalynx "special" devices
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2006-2007 Jiri Kosina
   Copyright (c) 2008 Jiri Slaby
 Petalynx Maxter Remote has maximum for consumer page set too low 
 SPDX-License-Identifier: GPL-2.0-or-later
  User-space IO driver support for HID subsystem
  Copyright (c) 2012 David Herrmann
 blocking GET_REPORT support; state changes protected by qlock 
 must be called with report_lock held 
 id for old report; drop it silently 
 this _always_ takes ownership of @ev 
 this _always_ takes ownership of @ev 
 Apparently we haven't stepped on these rakes enough times yet. 
			
			  This is our messed up request with compat pointer.
			  It is largish (more than 256 bytes) so we better
			  allocate it from the heap.
 Shuffle the data over to proper structure 
 All others can be copied directly 
 @hid is zero-initialized, strncpy() is correct, strlcpy() not 
	 Adding of a HID device is done through a worker, to allow HID drivers
	  which use feature requests during .probe to work, without they would
	  be blocked on devlock, which is held by uhid_char_write.
 they need at least the "type" member of uhid_event 
 we need at least the "type" member of uhid_event 
		
		  'struct uhid_create_req' contains a __user pointer which is
		  copied from, so it's unsafe to allow this with elevated
		  privileges (e.g. from a setuid binary) or via kernel_write().
 return "count" not "len" to not confuse the caller 
 uhid is always writable 
 SPDX-License-Identifier: GPL-2.0
  U2F Zero LED and RNG driver
  Copyright 2018 Andrej Shadura <andrew@shadura.me>
  Loosely based on drivershidhid-led.c
               and driversusbmiscchaoskey.c
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation, version 2.
 We only use broadcast (CID-less) messages 
 URB for the RNG data 
 Embedded struct for led 
 Embedded struct for hwrng 
 valid packets must have a correct header 
 ignore errors or packets without data 
 only take the minimum amount of data it is safe to take 
 SPDX-License-Identifier: GPL-2.0-or-later
  Force feedback support for ACRUX game controllers
  From what I have gathered, these devices are mass produced in China
  by several vendors. They often share the same design as the original
  Xbox 360 controller.
  1a34:0802 "ACRUX USB GAMEPAD 8116"
   - tested with an EXEQ EQ-PCU-02090 game controller.
  Copyright (c) 2010 Sergei Kolzun <x0r@dv-life.ru>
		
		  Do not fail device initialization completely as device
		  may still be partially operable, just warn.
	
	  We need to start polling device right away, otherwise
	  it will go into a coma.
 SPDX-License-Identifier: GPL-2.0-only
   Copyright (c) 2009, Citrix Systems, Inc.
   Copyright (c) 2010, Microsoft Corporation.
   Copyright (c) 2011, Novell Inc.
 The maximum size of a synthetic input message. 
  Current version
  History:
  Beta, RC < 2008122        1,0
  RC > 2008122              2,0
  Message types in the synthetic input protocol
  Basic message structures.
 Enclosed message 
  Protocol messages
  Represents an mousevsc device
 Synchronize the requestresponse if needed 
 The pointer is not NULL when we resume from hibernation 
 The pointer is not NULL when we resume from hibernation 
 Send the ack 
		
		  While it will be impossible for us to protect against
		  maliciousbuggy hypervisorhost, add a check here to
		  ensure we don't corrupt memory.
		
		  Parse out the device info into device attr,
		  hid desc and report desc
	
	  We should have gotten the device attr, hid desc and report
	  desc at this point
 workaround SA-167 
 Mouse guid 
 SPDX-License-Identifier: GPL-2.0-only
   HID driver for Logitech receivers
   Copyright (c) 2011 Logitech
 For to_usb_interface for kvm extra intf check 
 Command Switch to DJ mode 
 Command to Get the list of Paired devices 
 Device Paired Notification 
 Device Un-Paired Notification 
 Connection Status Notification 
 Error Notification 
 supported DJ HID && RF report types 
 RF Report types bitfield 
 Fake (bitnr > NUMBER_OF_HID_REPORTS) bit to track HID++ capability 
 HID++ Device Connected Notification 
 in jiffies 
 WORKITEM_TYPE_ 
 Keyboard descriptor (1) 
 USAGE_PAGE (generic Desktop)     
 USAGE (Keyboard)         
 COLLECTION (Application)     
 REPORT_ID (1)            
   REPORT_COUNT (8)           
   REPORT_SIZE (1)            
   LOGICAL_MINIMUM (0)        
   LOGICAL_MAXIMUM (1)        
   USAGE_PAGE (Keyboard)      
   USAGE_MINIMUM (Left Control)   
   USAGE_MAXIMUM (Right GUI)      
   INPUT (Data,Var,Abs)       
   REPORT_COUNT (6)           
   REPORT_SIZE (8)            
   LOGICAL_MINIMUM (0)        
   LOGICAL_MAXIMUM (255)      
   USAGE_PAGE (Keyboard)      
   USAGE_MINIMUM (no event)       
   USAGE_MAXIMUM (reserved)       
   INPUT (Data,Ary,Abs)       
 REPORT_ID (14)               
   USAGE PAGE (LED page)      
   REPORT COUNT (5)           
   REPORT SIZE (1)            
   LOGICAL_MINIMUM (0)        
   LOGICAL_MAXIMUM (1)        
   USAGE MINIMUM (1)          
   USAGE MAXIMUM (5)          
   OUTPUT (Data, Variable, Absolute)  
   REPORT COUNT (1)           
   REPORT SIZE (3)            
   OUTPUT (Constant)          
 Mouse descriptor (2)     
  USAGE_PAGE (Generic Desktop)        
  USAGE (Mouse)                       
  COLLECTION (Application)            
    REPORT_ID = 2                     
    USAGE (pointer)                   
    COLLECTION (physical)             
      USAGE_PAGE (buttons)            
      USAGE_MIN (1)                   
      USAGE_MAX (16)                  
      LOGICAL_MIN (0)                 
      LOGICAL_MAX (1)                 
      REPORT_COUNT (16)               
      REPORT_SIZE (1)                 
      INPUT (data var abs)            
      USAGE_PAGE (generic desktop)    
      LOGICAL_MIN (-2047)             
      LOGICAL_MAX (2047)              
      REPORT_SIZE (12)                
      REPORT_COUNT (2)                
      USAGE (X)                       
      USAGE (Y)                       
      INPUT                           
      LOGICAL_MIN (-127)              
      LOGICAL_MAX (127)               
      REPORT_SIZE (8)                 
      REPORT_COUNT (1)                
      USAGE (wheel)                   
      INPUT                           
      USAGE_PAGE(consumer)            
      USAGE(AC Pan)                   
      REPORT_COUNT (1)                
      INPUT                           
    END_COLLECTION                    
  END_COLLECTION                      
 Mouse descriptor (2) for 27 MHz receiver, only 8 buttons 
  USAGE_PAGE (Generic Desktop)        
  USAGE (Mouse)                       
  COLLECTION (Application)            
    REPORT_ID = 2                     
    USAGE (pointer)                   
    COLLECTION (physical)             
      USAGE_PAGE (buttons)            
      USAGE_MIN (1)                   
      USAGE_MAX (8)                   
      LOGICAL_MIN (0)                 
      LOGICAL_MAX (1)                 
      REPORT_COUNT (8)                
      REPORT_SIZE (1)                 
      INPUT (data var abs)            
      USAGE_PAGE (generic desktop)    
      LOGICAL_MIN (-2047)             
      LOGICAL_MAX (2047)              
      REPORT_SIZE (12)                
      REPORT_COUNT (2)                
      USAGE (X)                       
      USAGE (Y)                       
      INPUT                           
      LOGICAL_MIN (-127)              
      LOGICAL_MAX (127)               
      REPORT_SIZE (8)                 
      REPORT_COUNT (1)                
      USAGE (wheel)                   
      INPUT                           
      USAGE_PAGE(consumer)            
      USAGE(AC Pan)                   
      REPORT_COUNT (1)                
      INPUT                           
    END_COLLECTION                    
  END_COLLECTION                      
 Mouse descriptor (2) for Bluetooth receiver, low-res hwheel, 12 buttons 
  USAGE_PAGE (Generic Desktop)        
  USAGE (Mouse)                       
  COLLECTION (Application)            
    REPORT_ID = 2                     
    USAGE (pointer)                   
    COLLECTION (physical)             
      USAGE_PAGE (buttons)            
      USAGE_MIN (1)                   
      USAGE_MAX (8)                   
      LOGICAL_MIN (0)                 
      LOGICAL_MAX (1)                 
      REPORT_COUNT (8)                
      REPORT_SIZE (1)                 
      INPUT (data var abs)            
      USAGE_PAGE (generic desktop)    
      LOGICAL_MIN (-2047)             
      LOGICAL_MAX (2047)              
      REPORT_SIZE (12)                
      REPORT_COUNT (2)                
      USAGE (X)                       
      USAGE (Y)                       
      INPUT                           
      LOGICAL_MIN (-127)              
      LOGICAL_MAX (127)               
      REPORT_SIZE (8)                 
      REPORT_COUNT (1)                
      USAGE (wheel)                   
      INPUT                           
      USAGE_PAGE(consumer)            
      USAGE(AC Pan)                   
      LOGICAL_MIN (-7)                
      LOGICAL_MAX (7)                 
      REPORT_SIZE (4)                 
      REPORT_COUNT (1)                
      INPUT                           
      USAGE_PAGE (buttons)            
      USAGE_MIN (9)                   
      USAGE_MAX (12)                  
      LOGICAL_MIN (0)                 
      LOGICAL_MAX (1)                 
      REPORT_SIZE (1)                 
      REPORT_COUNT (4)                
      INPUT (Data,Var,Abs)            
    END_COLLECTION                    
  END_COLLECTION                      
 Mouse descriptor (5) for Bluetooth receiver, normal-res hwheel, 8 buttons 
  USAGE_PAGE (Generic Desktop)        
  Usage (Mouse)                       
  Collection (Application)            
   Report ID (5)                      
   Usage (Pointer)                    
   Collection (Physical)              
    Usage Page (Button)               
    Usage Minimum (1)                 
    Usage Maximum (8)                 
    Logical Minimum (0)               
    Logical Maximum (1)               
    Report Count (8)                  
    Report Size (1)                   
    Input (Data,Var,Abs)              
    Usage Page (Generic Desktop)      
    Logical Minimum (-2047)           
    Logical Maximum (2047)            
    Report Size (12)                  
    Report Count (2)                  
    Usage (X)                         
    Usage (Y)                         
    Input (Data,Var,Rel)              
    Logical Minimum (-127)            
    Logical Maximum (127)             
    Report Size (8)                   
    Report Count (1)                  
    Usage (Wheel)                     
    Input (Data,Var,Rel)              
    Usage Page (Consumer Devices)     
    Usage (AC Pan)                    
    Logical Minimum (-127)            
    Logical Maximum (127)             
    Report Size (8)                   
    Report Count (1)                  
    Input (Data,Var,Rel)              
   End Collection                     
  End Collection                      
 Gaming Mouse descriptor (2) 
  USAGE_PAGE (Generic Desktop)        
  USAGE (Mouse)                       
  COLLECTION (Application)            
    REPORT_ID = 2                     
    USAGE (pointer)                   
    COLLECTION (physical)             
      USAGE_PAGE (buttons)            
      USAGE_MIN (1)                   
      USAGE_MAX (16)                  
      LOGICAL_MIN (0)                 
      LOGICAL_MAX (1)                 
      REPORT_COUNT (16)               
      REPORT_SIZE (1)                 
      INPUT (data var abs)            
      USAGE_PAGE (generic desktop)    
      LOGICAL_MIN (-32767)            
      LOGICAL_MAX (32767)             
      REPORT_SIZE (16)                
      REPORT_COUNT (2)                
      USAGE (X)                       
      USAGE (Y)                       
      INPUT                           
      LOGICAL_MIN (-127)              
      LOGICAL_MAX (127)               
      REPORT_SIZE (8)                 
      REPORT_COUNT (1)                
      USAGE (wheel)                   
      INPUT                           
      USAGE_PAGE(consumer)            
      USAGE(AC Pan)                   
      REPORT_COUNT (1)                
      INPUT                           
    END_COLLECTION                    
  END_COLLECTION                      
 Consumer Control descriptor (3) 
 USAGE_PAGE (Consumer Devices)       
 USAGE (Consumer Control)            
 COLLECTION (Application)            
 REPORT_ID = 3                       
 REPORT_SIZE (16)                    
 REPORT_COUNT (2)                    
 LOGICAL_MIN (1)                     
 LOGICAL_MAX (767)                   
 USAGE_MIN (1)                       
 USAGE_MAX (767)                     
 INPUT (Data Ary Abs)                
 END_COLLECTION                      
 System control descriptor (4) 
   USAGE_PAGE (Generic Desktop)      
   USAGE (System Control)            
   COLLECTION (Application)          
   REPORT_ID = 4                     
   REPORT_SIZE (2)                   
   REPORT_COUNT (1)                  
   LOGICAL_MIN (1)                   
   LOGICAL_MAX (3)                   
   USAGE (System Sleep)              
   USAGE (System Power Down)         
   USAGE (System Wake Up)            
   INPUT (Data Ary Abs NPrf Null)    
   REPORT_SIZE (6)                   
   INPUT (Cnst Var Abs)              
   END_COLLECTION                    
 Media descriptor (8) 
 Usage Page 0xffbc                   
 Usage 0x0088                        
 BeginCollection                     
   Report ID 8                       
   Usage Min 0x0001                  
   Usage Max 0x00ff                  
   Logical Min 1                     
   Logical Max 255                   
   Report Size 8                     
   Report Count 1                    
   Input                             
 EndCollection                       
 HIDPP descriptor 
 Usage Page (Vendor Defined Page 1)  
 Usage (Vendor Usage 1)              
 Collection (Application)            
   Report ID (16)                    
   Report Size (8)                   
   Report Count (6)                  
   Logical Minimum (0)               
   Logical Maximum (255)             
   Usage (Vendor Usage 1)            
   Input (Data,Arr,Abs)              
   Usage (Vendor Usage 1)            
   Output (Data,Arr,Abs)             
 End Collection                      
 Usage Page (Vendor Defined Page 1)  
 Usage (Vendor Usage 2)              
 Collection (Application)            
   Report ID (17)                    
   Report Size (8)                   
   Report Count (19)                 
   Logical Minimum (0)               
   Logical Maximum (255)             
   Usage (Vendor Usage 2)            
   Input (Data,Arr,Abs)              
   Usage (Vendor Usage 2)            
   Output (Data,Arr,Abs)             
 End Collection                      
 Usage Page (Vendor Defined Page 1)  
 Usage (Vendor Usage 0x04)           
 Collection (Application)            
   Report ID (32)                    
   Report Size (8)                   
   Report Count (14)                 
   Logical Minimum (0)               
   Logical Maximum (255)             
   Usage (Vendor Usage 0x41)         
   Input (Data,Arr,Abs)              
   Usage (Vendor Usage 0x41)         
   Output (Data,Arr,Abs)             
   Report ID (33)                    
   Report Count (31)                 
   Logical Minimum (0)               
   Logical Maximum (255)             
   Usage (Vendor Usage 0x42)         
   Input (Data,Arr,Abs)              
   Usage (Vendor Usage 0x42)         
   Output (Data,Arr,Abs)             
 End Collection                      
 Maximum size of all defined hid reports in bytes (including report id) 
 Make sure all descriptors are present here 
 Number of possible hid report types that can be created by this driver.
  Right now, RF report types have the same report types (or report id's)
  than the hid report created from those RF reports. In the future
  this doesnt have to be true.
  For instance, RF report type 0x01 which has a size of 8 bytes, corresponds
  to hid report id 0x01, this is standard keyboard. Same thing applies to mice
  reports and consumer control, etc. If a new RF report is created, it doesn't
  has to have the same report id as its corresponding hid report, so an
  translation may have to take place for future report types.
 Standard keyboard 
 Standard mouse 
 Consumer control 
 System control 
 Media Center 
  djHID++ receivers are really a single logical entity, but for BIOSWindows
  compatibility they have multiple USB interfaces. On HID++ receivers we need
  to listen for input reports on both interfaces. The functions below are used
  to create a single struct dj_receiver_dev for all interfaces belonging to
  a single USB-device  receiver.
	
	  The bluetooth receiver contains a built-in hub and has separate
	  USB-devices for the keyboard and mouse interfaces.
 Try to find an already-probed interface from the same device 
 Called in delayed work context 
 Called in delayed work context 
	 Device index goes from 1 to 6, we need 3 bytes to store the
	  semicolon, the index, and a null terminator
 We are the only one ever adding a device, no need to lock 
 The device is already known. No need to reallocate it. 
	
	  Since we attach to multiple interfaces, we may get scheduled before
	  we are bound to the HID++ interface, catch this.
  Sometimes we receive reports for which we do not have a paired dj_device
  associated with the device_index or report-type to forward the report to.
  This means that the original "device paired" notification corresponding
  to the dj_device never arrived to this driver. Possible reasons for this are:
  1) hid-core discards all packets coming from a device during probe().
  2) if the receiver is plugged into a KVM switch then the pairing reports
  are only forwarded to it if the focus is on this PC.
  This function deals with this by re-asking the receiver for the list of
  connected devices in the delayed work callback.
  This function MUST be called with djrcv->lock held.
 Rate limit queries done because of unhandled reports to 2sec 
 We are called from atomic context (tasklet && djrcv->lock held) 
  Some quadbluetooth keyboards have a builtin touchpad in this case we see
  only 1 paired device with a device_type of REPORT_TYPE_KEYBOARD. For the
  touchpad to work we must also forward mouse input reports to the dj_hiddev
  created for the keyboard (instead of forwarding them to a second paired
  device with a device_type of REPORT_TYPE_MOUSE as we normally would).
  On Dinovo receivers the keyboard's touchpad and an optional paired actual
  mouse send separate input reports, INPUT(2) aka STD_MOUSE for the mouse
  and INPUT(5) aka KBD_MOUSE for the keyboard's touchpad.
  On MX5x00 receivers (which can also be paired with a Dinovo keyboard)
  INPUT(2) is used for both an optional paired actual mouse and for the
  keyboard's touchpad.
 Dinovo Edge 
 Dinovo Mini 
 Index 1 is always a mouse 
 Index 2 is always a mouse 
 Index 3 is always the keyboard 
gitlab.freedesktop.orgjwrdegoedelogitech-27mhz-keyboard-encryption-setup\n");
 Index 4 is used for an optional separate numpad 
 We are called from atomic context (tasklet && djrcv->lock held) 
 Bluetooth connect packet contents is the same as (e)QUAD 
 custom receiver device (eg. powerplay) 
 We are called from atomic context (tasklet && djrcv->lock held) 
 We are called from atomic context (tasklet && djrcv->lock held) 
 We are called from atomic context (tasklet && djrcv->lock held) 
		
		  Ugly sleep to work around a USB 3.0 bug when the receiver is
		  still processing the "switch-to-dj" command while we send an
		  other command.
		  50 msec should gives enough time to the receiver to be ready.
	
	  Magical bits to set up hidpp notifications when the dj devices
	  are connecteddisconnected.
	 
	  We can reuse dj_report because HIDPP_REPORT_SHORT_LENGTH is smaller
	  than DJREPORT_SHORT_LENGTH.
  Register 0xB5 is "pairing information". It is solely intended for the
  receiver, so do not overwrite the device index.
		 special case where we should not overwrite
 usbhid overrides the report ID and ignores the first byte 
	
	  Here we receive all data coming from iface 2, there are 3 cases:
	 
	  1) Data is intended for this driver i. e. data contains arrival,
	  departure, etc notifications, in which case we queue them for delayed
	  processing by the work queue. We return 1 to hid-core as no further
	  processing is required from it.
	 
	  2) Data informs a connection change, if the change means rf link
	  loss, then we must send a null report to the upper layer to discard
	  potentially pressed keys that may be repeated forever by the input
	  layer. Return 1 to hid-core as no further processing is required.
	 
	  3) Data is an actual input event from a paired DJ device in which
	  case we forward it to the correct hid device (via hid_input_report()
	  ) and return 1 so hid-core does not anything else with it.
		
		  Device index is wrong, bail out.
		  This driver can ignore safely the receiver notifications,
		  so ignore those reports too.
 received an event for an unknown device, bail out 
 pairing notifications are handled above the switch 
		 special case were the device wants to know its unifying
	
	  Data is from the HID++ collection, in this case, we forward the
	  data to the corresponding child dj device and return 0 to hid-core
	  so he data also goes to the hidraw device of the receiver. This
	  allows a user space application to implement the full HID++ routing
	  via the receiver.
		
		  Device index is wrong, bail out.
		  This driver can ignore safely the receiver notifications,
		  so ignore those reports too.
	
	  With 27 MHz receivers, we do not get an explicit unpair event,
	  remove the old device if the user has paired a different device.
 logi_hidpp_recv_queue_notif will queue the work 
			
			  For the keyboard, we can reuse the same report by
			  using the second byte which is constant in the USB
			  HID report descriptor.
 restore previous state 
		
		  Mouse-only receivers send unnumbered mouse data. The 27 MHz
		  receiver uses 6 byte packets, the nano receiver 8 bytes.
 Prepend report id 
	
	  Call to usbhid to fetch the HID descriptors of the current
	  interface subsequently call to the hidhid-core to parse the
	  fetched descriptors.
	
	  Some KVMs add an extra interface for e.g. mouse emulation. If we
	  treat these as logitech-dj interfaces then this causes input events
	  reported through this extra interface to not be reported correctly.
	  To avoid this, we treat these as generic-hid devices.
 no input reports, bail out 
	
	  Check for the HID++ application.
	  Note: we should theoretically check for HID++ and DJ
	  collections, but this will do.
	
	  Ignore interfaces without DJHID++ collection, they will not carry
	  any data, dont create any hid_device for them.
 get the current application attached to the node 
	 Starts the usb device and connects to upper interfaces hiddev and
 This is enabling the polling urb on the IN endpoint 
 Allow incoming packets to arrive: 
			
			  This can happen with a KVM, let the probe succeed,
			  logi_dj_recv_queue_unknown_work will retry later.
	
	  This ensures that if the work gets requeued from another
	  interface of the same receiver it will be a no-op.
	
	  For proper operation we need access to all interfaces, so we destroy
	  the paired devices when we're unbound from any interface.
	 
	  Note we may still be bound to other interfaces, sharing the same
	  djrcv_dev, so we need locking here.
 Logitech unifying receiver (0xc52b) 
 Logitech unifying receiver (0xc532) 
 Logitech Nano mouse only receiver (0xc52f) 
 Logitech Nano (non DJ) receiver (0xc534) 
 Logitech G700(s) receiver (0xc531) 
 Logitech G602 receiver (0xc537) 
 Logitech lightspeed receiver (0xc539) 
 Logitech powerplay receiver (0xc53a) 
 Logitech lightspeed receiver (0xc53f) 
 Logitech 27 MHz HID++ 1.0 receiver (0xc513) 
 Logitech 27 MHz HID++ 1.0 receiver (0xc517) 
 Logitech 27 MHz HID++ 1.0 mouse-only receiver (0xc51b) 
 Logitech MX5000 HID++  bluetooth receiver keyboard intf. (0xc70e) 
 Logitech MX5000 HID++  bluetooth receiver mouse intf. (0xc70a) 
 Logitech MX5500 HID++  bluetooth receiver keyboard intf. (0xc71b) 
 Logitech MX5500 HID++  bluetooth receiver mouse intf. (0xc71c) 
 Logitech Dinovo Edge HID++  bluetooth receiver keyboard intf. (0xc713) 
 Logitech Dinovo Edge HID++  bluetooth receiver mouse intf. (0xc714) 
 Logitech DiNovo Mini HID++  bluetooth receiver mouse intf. (0xc71e) 
 Logitech DiNovo Mini HID++  bluetooth receiver keyboard intf. (0xc71f) 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for Asus notebook built-in keyboard.
   Fixes small logical maximum to match usage maximum.
   Currently supported devices are:
     EeeBook X205TA
     VivoBook E200HA
   Copyright (c) 2016 Yusuke Fujimaki <usk.fujimaki@gmail.com>
   This module based on hid-ortek by
   Copyright (c) 2010 Johnathon Harris <jmharris@gmail.com>
   Copyright (c) 2011 Jiri Kosina
   This module has been updated to add support for Asus i2c touchpad.
   Copyright (c) 2016 Brendan McGrath <redmcg@redmandi.dyndns.org>
   Copyright (c) 2016 Victor Vlasenko <victor.vlasenko@sysgears.com>
   Copyright (c) 2016 Frederik Wenigwieser <frederik.wenigwieser@gmail.com>
 For to_usb_interface for T100 touchpad intf check 
 2 byte header + 5  5 + 1 byte footer ,
 unitsmm 
 unitsmm 
 2 byte header + 5  5 + 1 byte footer ,
 unitsmm 
 unitsmm 
 2 byte header + 5  5 + 1 byte footer ,
 unitsmm 
 unitsmm 
 2 byte header + 5  5 + 1 byte footer ,
 unitsmm 
 unitsmm 
 2 byte header + 3  4 + 1 byte footer ,
 unitsmm 
 unitsmm 
 2 byte header + 5  5 + 5 byte footer ,
 Required for Synaptics Palm Detection 
 Handle broken mute key which only sends press events 
 Handle custom touchpad toggle key which only sends press events 
		
		  Skip these report ID, the device emits a continuous stream associated
		  with the AURA mode it is in which looks like an 'echo'.
 Additional report filtering 
			
			  G14 and G15 send these codes on some keypresses with no
			  discernable reason for doing so. We'll filter them out to avoid
			  unmapped warning messages later.
			
			  G713 and G733 send these codes on some keypresses, depending on
			  the key pressed it can trigger a shutdown event if not caught.
		
		  CLAYMORE II keyboard sends this packet when it goes to sleep
		  this causes the whole system to go into suspend.
	
	  The report ID should be set from the incoming buffer due to LED and key
	  interfaces having different pages
 The first message is an init start 
 Followed by a string 
 Followed by a string 
 begin second report ID with same data 
 WMI-based keyboard backlight LED control (via asus-wmi driver) takes
  precedence. We only activate HID-based backlight control when the
  WMI control is not available.
 Initialize keyboard 
 Get keyboard functions 
 Check for backlight support 
 No need to have this still around 
  [0]       REPORT_ID (same value defined in report descriptor)
  [1]	     rest battery level. range [0..255]
  [2]..[7]  Bluetooth hardware address (MAC address)
  [8]       charging status
             = 0 : AC offline  discharging
             = 1 : AC online   charging
             = 2 : AC online   fully charged
 notify only the autonomous event by device 
 60[sec] 
 T100CHI uses MULTI_INPUT, bind the touchpad to the mouse hid_input 
 Handle MULTI_INPUT on E1239T mousetouchpad USB interface 
 Touchpad report, handled below 
 Ignore other reports 
		 Don't map anything from the HID report.
		  We do it all manually in asus_input_configured
	
	  Ignore a bunch of bogus collections in the T100CHI descriptor.
	  This avoids a bunch of non-functional hid_input devices getting
	  created because of the T100CHI using HID_QUIRK_MULTI_INPUT.
 ASUS-specific keyboard hotkeys and led backlight 
 ASUS touchpad toggle 
 ROG key 
 Fn+C ASUS Splendid 
 Fn+Space Power4Gear Hybrid 
 Fn+F5 "fan" symbol on FX503VD 
 Fn+F5 "fan" symbol on N-Key keyboard 
 Fn+Ret "Calc" symbol on N-Key keyboard 
 Fn+Left Aura mode previous on N-Key keyboard 
 Fn+Right Aura mode next on N-Key keyboard 
			 ASUS lazily declares 256 usages, ignore the rest,
		
		  Check and enable backlight only on devices with UsagePage ==
		  0xff31 to avoid initializing the keyboard firmware multiple
		  times on devices with multiple HID descriptors but same
		  PIDVID.
 Mute 
 Volume up 
 Volume down 
			 Ignore dummy Consumer usages which make the
			  keyboard incorrectly appear as a pointer device.
	
	  The mute button is broken and only sends press events, we
	  deal with this in our raw_event handler, so do not map it.
	
	  T90CHI's keyboard dock returns same ID values as T100CHI's dock.
	  Thus, identify T90CHI dock with product name string.
			
			  The T100HA uses the same USB-ids as the T100TAF and
			  the T200TA uses the same USB-ids as the T100TA, while
			  both have different max xy values as the T100TA[F].
		
		  All functionality is on a single HID interface and for
		  userspace the touchpad must be a separate input_dev.
 For separate input-devs for tp and tp toggle key 
   Usage Minimum (0x00)       
   Usage Maximum (0xFF)       
 For the T100TAT200TA keyboard dock 
 For the T100CHIT90CHI keyboard dock 
		
		  Change Usage (76h) to Usage Minimum (00h), Usage Maximum
		  (FFh) and clear the flags in the Input() byte.
		  Note the descriptor has a bogus 0 byte at the end so we
		  only need 1 extra byte.
 report is missing usage mninum and maximum 
 copy the valid part 
 insert missing part 
 copy remaining data 
	
	  Note bind to the HID_GROUP_GENERIC group, so that we only bind to the keyboard
	  part, while letting hid-multitouch.c handle the touchpad.
 SPDX-License-Identifier: GPL-2.0-or-later
   Jabra USB HID Driver
   Copyright (c) 2017 Niels Skou Olsen <nolsen@jabra.com>
 Ignore vendor defined usages, default map standard usages 
 SPDX-License-Identifier: GPL-2.0
  HID driver for the Creative SB0540 receiver
  Copyright (C) 2019 Red Hat Inc. All Rights Reserved
 text: 24bit 
 24bit wheel up 
 24bit wheel down 
 text: CMSS 
 CMSS wheel Up 
 CMSS wheel Down 
 text: EAX 
 EAX wheel up 
 EAX wheel down 
 text: 3D Midi 
 3D Midi wheel up 
 3D Midi wheel down 
 text: Return, symbol: Jump to 
 text: Start 
 text: Cancel 
 text: Display 
  Codes and keys from lirc's
  remotescreativelircd.conf.alsa_usb
  order and size must match creative_sb0540_key_table[] above
 From daemonshw_hiddev.c sb0540_rec() in lirc 
	
	  Flip to get values in the same format as
	  remotescreativelircd.conf.alsa_usb in lirc
 let hidraw and hiddev handle the report 
	
	  We are remapping the keys ourselves, so ignore the hid-input
	  keymap processing.
 force input as some remotes bypass the input registration 
 SPDX-License-Identifier: GPL-2.0-or-later
   Force feedback support for PantherLordGreenAsia based devices
   The devices are distributed under various names and the same USB device ID
   can be used in both adapters and actual game controllers.
   0810:0001 "Twin USB Joystick"
    - tested with PantherLord USBPS2 2in1 Adapter
    - contains two reports, one for each port (HID_QUIRK_MULTI_INPUT)
   0e8f:0003 "GreenAsia Inc.    USB Joystick     "
    - tested with K√∂nig Gaming gamepad
   0e8f:0003 "GASIA USB Gamepad"
    - another version of the K√∂nig gamepad
   0f30:0111 "Saitek Color Rumble Pad"
   Copyright (c) 2007, 2009 Anssi Hannula <anssi.hannula@gmail.com>
 #define DEBUG 
	 The device contains one output report per physical device, all
	   containing 1 field, which contains 4 ff00.0002 usages and 4 16bit
	   absolute values.
	   The input reports also contain a field which contains
	   8 ff00.0001 usages and 8 boolean values. Their meaning is
	   currently unknown.
	   
	   A version of the 0e8f:0003 exists that has all the values in
	   separate fields and misses the extra input field, thus resembling
	   Zeroplus (hid-zpff) devices.
 Twin USB Joystick 
 Twin USB Joystick 
 SPDX-License-Identifier: GPL-2.0-or-later
  Roccat Ryos driver for Linux
  Copyright (c) 2013 Stefan Achatz <erazor_de@users.sourceforge.net>
 RYOS_REPORT_NUMBER_SPECIAL 
   HID driver for Redragon keyboards
   Copyright (c) 2017 Robert Munteanu
   SPDX-License-Identifier: GPL-2.0+
  This program is free software; you can redistribute it andor modify it
  under the terms of the GNU General Public License as published by the Free
  Software Foundation; either version 2 of the License, or (at your option)
  any later version.
  The Redragon Asura keyboard sends an incorrect HID descriptor.
  At byte 100 it contains
    0x81, 0x00
  which is Input (Data, Arr, Abs), but it should be
    0x81, 0x02
  which is Input (Data, Var, Abs), which is consistent with the way
  key codes are generated.
 SPDX-License-Identifier: GPL-2.0-or-later
  Roccat Kone driver for Linux
  Copyright (c) 2010 Stefan Achatz <erazor_de@users.sourceforge.net>
  Roccat Kone is a gamer mouse which consists of a mouse part and a keyboard
  part. The keyboard part enables the mouse to execute stored macros with mixed
  key- and button-events.
  TODO implement on-the-fly polling-rate change
       The windows driver has the ability to change the polling rate of the
       device on the press of a mousebutton.
       Is it possible to remove and reinstall the urb in raw-event- or any
       other handler, or to defer this action to be executed somewhere else?
  TODO is it possible to overwrite group for sysfs attributes via udev?
 kone_class is used for creating sysfs attributes via roccat char device 
  Checks success after writing data to mouse
  On success returns 0
  On failure returns errno
		
		  Mouse needs 50 msecs until it says ok, but there are
		  30 more msecs needed for next write to work.
		
		  value of 3 seems to mean something like
		  "not finished yet, but it looks good"
		  So check again after a moment.
 everything alright 
 unknown answer 
  Reads settings from mouse and stores it in @buf
  On success returns 0
  On failure returns errno
  Writes settings from @buf to mouse
  On success returns 0
  On failure returns errno
  Reads profile data from mouse and stores it in @buf
  @number: profile number to read
  On success returns 0
  On failure returns errno
  Writes profile data to mouse.
  @number: profile number to write
  On success returns 0
  On failure returns errno
  Reads value of "fast-clip-weight" and stores it in @result
  On success returns 0
  On failure returns errno
  Reads firmware_version of mouse and stores it in @result
  On success returns 0
  On failure returns errno
  Writing settings automatically activates startup_profile.
  This function keeps values in kone_device up to date and assumes that in
  case of error the old data is still valid
 I need to get my data in one piece 
 Writes data only if different to stored data 
 I need to get my data in one piece 
 weight is read each time, since we don't get informed when it's changed 
  Calibrating the tcu is the only action that changes settings data inside the
  mouse, so this data needs to be reread
 state activate 
 tcu needs this time for calibration 
		
		  Kone needs this time to settle things.
		  Reading settings too early will result in invalid data.
		  Roccat's driver waits 1 sec, maybe this time could be
		  shortened.
 calibration changes values in settings, so reread 
 only write settings back if activation state is different 
			
			  try to reread valid settings into buffer overwriting
			  first error code
 calibration resets profile 
 changing the startup profile immediately activates this profile 
	
	  Read actual dpi settings.
	  Returns raw value for further processing. Refer to enum
	  kone_polling_rates to get real value.
	
	  The mouse can be equipped with one of four supplied weights from 5
	  to 20 grams which are recognized and its value can be read out.
	  This returns the raw value reported by the mouse for easy evaluation
	  by software. Refer to enum kone_weights to get corresponding real
	  weight.
	
	  Prints firmware version stored in mouse as integer.
	  The raw value reported by the mouse is returned for easy evaluation,
	  to get the real version number the decimal point has to be shifted 2
	  positions to the left. E.g. a value of 138 means 1.38.
	
	  Prints state of Tracking Control Unit as number where 0 = off and
	  1 = on. Writing 0 deactivates tcu and writing 1 calibrates and
	  activates the tcu
 Prints and takes the number of the profile the mouse starts with 
  Since IGNORE_MOUSE quirk moved to hid-apple, there is no way to bind only to
  mousepart if usb_hid is compiled into the kernel and kone is compiled as
  module.
  Secial behaviour is bound only to mousepart since only mouseevents contain
  additional notifications.
 be tolerant about not getting chrdev 
 handle special events and keep actual profile and dpi values up to date 
  Is called for keyboard- and mousepart.
  Only mousepart gets informations about special events in its extended event
  structure.
 keyboard events are always processed by default handler 
	
	  Firmware 1.38 introduced new behaviour for tilt and special buttons.
	  Pressed button is reported in each movement event.
	  Workaround sends only one event per press.
 always do further processing 
 class name has to be same as driver name 
 SPDX-License-Identifier: GPL-2.0-or-later
   Force feedback support for SmartJoy PLUS PS2->USB adapter
   Copyright (c) 2009 Jussi Kivilinna <jussi.kivilinna@mbnet.fi>
   Based of hid-pl.c and hid-gaff.c
    Copyright (c) 2007, 2009 Anssi Hannula <anssi.hannula@gmail.com>
    Copyright (c) 2008 Lukasz Lubojanski <lukasz@lubojanski.info>
 #define DEBUG 
 onoff only 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for some cypress "special" devices
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2006-2007 Jiri Kosina
   Copyright (c) 2008 Jiri Slaby
  Some USB barcode readers from cypress have usage min and usage max in
  the wrong order
	
	  Varmilo VA104M (with VID Cypress and device ID 07B1) incorrectly
	  reports Logical Minimum of its Consumer Control device as 572
	  (0x02 0x3c). Fix this by setting its Logical Minimum to zero.
 SPDX-License-Identifier: GPL-2.0-only
    Copyright (C) 2010-2012 by Bruno Pr√©mont <bonbons@linux-vserver.org>  
    Based on Logitech G13 driver (v0.4)                                   
      Copyright (C) 2009 by Rick L. Vinyard, Jr. <rvinyard@cs.nmsu.edu>   
 Input device
  The PicoLCD has an IR receiver header, a built-in keypad with 5 keys
  and header for 4x4 key matrix. The built-in keys are part of the matrix.
 none 
 col 4 + row 1 
 col 3 + row 1 
 col 2 + row 1 
 col 1 + row 1 
 col 4 + row 2 
 col 3 + row 2 
 col 2 + row 2 
 col 1 + row 2 
 col 4 + row 3 
 col 3 + row 3 
 col 2 + row 3 
 col 1 + row 3 
 col 4 + row 4 
 col 3 + row 4 
 col 2 + row 4 
 col 1 + row 4 
 Find a given report 
 Submit a report and wait for a reply from device - if device fades away
  input class device
	
	  Keypad event
	  First and second data bytes list currently pressed keys,
	  0x00 means no key and at most 2 keys may be pressed at same time
 determine newly pressed keys 
 determine newly released keys 
  Reset our device and wait for answer to VERSION request
 perform the reset 
  The "operation_mode" sysfs attribute
  The "operation_mode_delay" sysfs attribute
  Handle raw report as sent by device
		
		  We let the caller of picolcd_send_and_wait() check if the
		  report we got is one of the expected ones or not.
 initialize keypad input device 
 Setup keypad input device 
 Setup CIR input device 
 Set up the framebuffer device 
 Setup lcd class device 
 Setup backlight class device 
 Setup the LED class devices 
	
	  Let's allocate the picolcd data structure, set some reasonable
	  defaults, and associate it with the device
 Parse the device reports and start it up 
 Shortcut potential pending reply that will never arrive 
 Cleanup LED 
 Clean up the framebuffer 
 Cleanup input 
 Finally, clean up the picolcd data itself 
 SPDX-License-Identifier: GPL-2.0+
   HID driver for ViewSonic devices not fully compliant with HID standard
   Copyright (c) 2017 Nikolai Kondrashov
  This program is free software; you can redistribute it andor modify it
  under the terms of the GNU General Public License as published by the Free
  Software Foundation; either version 2 of the License, or (at your option)
  any later version.
 Size of the original descriptor of PD1011 signature pad 
 Fixed report descriptor of PD1011 signature pad 
  Usage Page (Digitizer),             
  Usage (Pen),                        
  Collection (Application),           
      Report ID (2),                  
      Usage (Stylus),                 
      Collection (Physical),          
          Report Size (16),           
          Report Count (1),           
          Push,                       
          Usage Page (Desktop),       
          Unit (Inch),                
          Unit Exponent (-3),         
          Physical Minimum (0),       
          Usage (X),                  
          Physical Maximum (8541),    
          Logical Maximum (43392),    
          Input (Variable),           
          Usage (Y),                  
          Physical Maximum (5338),    
          Logical Maximum (27120),    
          Input (Variable),           
          Pop,                        
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Size (1),            
          Report Count (1),           
          Input (Constant, Variable), 
          Usage (In Range),           
          Usage (Tip Switch),         
          Report Count (2),           
          Input (Variable),           
          Report Count (5),           
          Input (Constant, Variable), 
          Report Size (16),           
          Report Count (1),           
          Usage (Tip Pressure),       
          Logical Minimum (5),        
          Logical Maximum (2047),     
          Input (Variable),           
          Report Size (16),           
          Report Count (1),           
          Input (Constant, Variable), 
      End Collection,                 
  End Collection                      
 SPDX-License-Identifier: GPL-2.0-or-later
  Force feedback support for Mayflash game controller adapters.
  These devices are manufactured by Mayflash but identify themselves
  using the vendor ID of DragonRise Inc.
  Tested with:
  0079:1801 "DragonRise Inc. Mayflash PS3 Game Controller Adapter"
  0079:1803 "DragonRise Inc. Mayflash Wireless Sensor DolphinBar"
  0079:1843 "DragonRise Inc. Mayflash GameCube Game Controller Adapter"
  0079:1844 "DragonRise Inc. Mayflash GameCube Game Controller Adapter (v04)"
  The following adapters probably work too, but need to be tested:
  0079:1800 "DragonRise Inc. Mayflash WIIU Game Controller Adapter"
  Copyright (c) 2016-2017 Marcel Hasler <mahasler@gmail.com>
 Setup each of the four inputs 
 Apply quirks as needed 
 No quirk required 
 SPDX-License-Identifier: GPL-2.0-or-later
   Force feedback support for EMS Trio Linker Plus II
   Copyright (c) 2010 Ignaz Forster <ignaz.forster@gmx.de>
 SPDX-License-Identifier: GPL-2.0-or-later
   Force feedback support for Holtek On Line Grip based gamepads
   These include at least a Brazilian "Clone Joypad Super Power Fire"
   which uses vendor ID 0x1241 and identifies as "HOLTEK On Line Grip".
   Copyright (c) 2011 Anssi Hannula <anssi.hannula@iki.fi>
  These commands and parameters are currently known:
  byte 0: command id:
  	01  set effect parameters
  	02  play specified effect
  	03  stop specified effect
  	04  stop all effects
  	06  stop all effects
  	(the difference between 04 and 06 isn't known; win driver
  	 sends 06,04 on application init, and 06 otherwise)
  Commands 01 and 02 need to be sent as pairs, i.e. you need to send 01
  before each 02.
  The rest of the bytes are parameters. Command 01 takes all of them, and
  commands 02,03 take only the effect id.
  byte 1:
 	bits 0-3: effect id:
  		1: very strong rumble
  		2: periodic rumble, short intervals
  		3: very strong rumble
  		4: periodic rumble, long intervals
  		5: weak periodic rumble, long intervals
  		6: weak periodic rumble, short intervals
  		7: periodic rumble, short intervals
  		8: strong periodic rumble, short intervals
  		9: very strong rumble
  		a: causes an error
  		b: very strong periodic rumble, very short intervals
  		c-f: nothing
 	bit 6: right (weak) motor enabled
 	bit 7: left (strong) motor enabled
  bytes 2-3:  time in milliseconds, big-endian
  bytes 5-6:  unknown (win driver seems to use at least 10e0 with effect 1
  		       and 0014 with effect 6)
  byte 7:
 	bits 0-3: effect magnitude
 effect type 1, length 65535 msec 
 The device takes a single magnitude, so we just sum them up. 
 initialize the same way as win driver does 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for some logitech "special" devices
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2006-2007 Jiri Kosina
   Copyright (c) 2008 Jiri Slaby
   Copyright (c) 2010 Hendrik Iben
 Size of the original descriptors of the Driving Force (and Pro) wheels 
 Fixed report descriptors for Logitech Driving Force (and Pro)
  wheel controllers
  The original descriptors hide the separate throttle and brake axes in
  a custom vendor usage page, providing only a combined value as
  GenericDesktop.Y.
  These descriptors remove the combined Y axis and instead report
  separate throttle (Y) and brake (RZ).
  Usage Page (Desktop),                   
  Usage (Joystick),                       
  Collection (Application),               
      Collection (Logical),               
          Report Count (1),               
          Report Size (10),               
          Logical Minimum (0),            
          Logical Maximum (1023),         
          Physical Minimum (0),           
          Physical Maximum (1023),        
          Usage (X),                      
          Input (Variable),               
          Report Count (12),              
          Report Size (1),                
          Logical Maximum (1),            
          Physical Maximum (1),           
          Usage (Buttons),                
          Usage Minimum (1),              
          Usage Maximum (12),             
          Input (Variable),               
          Report Count (2),               
          Usage Page (Vendor: 65280),     
          Usage (?: 1),                   
          Input (Variable),               
          Usage Page (Desktop),           
          Logical Maximum (255),          
          Physical Maximum (255),         
          Report Count (1),               
          Report Size (8),                
          Input (Variable),               
          Logical Maximum (7),            
          Physical Maximum (315),         
          Report Size (4),                
          Unit (Degrees),                 
          Usage (Hat Switch),             
          Input (Variable, Null State),   
          Report Size (1),                
          Report Count (4),               
          Unit (none),                    
          Usage Page (Vendor: 65280),     
          Usage (?: 1),                   
          Logical Maximum (1),            
          Physical Maximum (1),           
          Input (Variable),               
          Usage Page (Desktop),           
          Report Count (1),               
          Report Size (8),                
          Logical Maximum (255),          
          Physical Maximum (255),         
          Usage (Y),                      
          Input (Variable),               
          Usage (Rz),                     
          Input (Variable),               
      End Collection,                     
      Collection (Logical),               
          Logical Maximum (255),          
          Physical Maximum (255),         
          Report Count (7),               
          Report Size (8),                
          Usage (?: 3),                   
          Output (Variable),              
      End Collection,                     
  End Collection                          
  Usage Page (Desktop),                   
  Usage (Joystick),                       
  Collection (Application),               
      Collection (Logical),               
          Report Count (1),               
          Report Size (14),               
          Logical Minimum (0),            
          Logical Maximum (16383),        
          Physical Minimum (0),           
          Physical Maximum (16383),       
          Usage (X),                      
          Input (Variable),               
          Report Count (14),              
          Report Size (1),                
          Logical Maximum (1),            
          Physical Maximum (1),           
          Usage Page (Button),            
          Usage Minimum (01h),            
          Usage Maximum (0Eh),            
          Input (Variable),               
          Usage Page (Desktop),           
          Report Count (1),               
          Report Size (4),                
          Logical Maximum (7),            
          Physical Maximum (315),         
          Unit (Degrees),                 
          Usage (Hat Switch),             
          Input (Variable, Nullstate),    
          Unit,                           
          Logical Maximum (255),          
          Physical Maximum (255),         
          Report Size (8),                
          Input (Constant),               
          Usage (Y),                      
          Input (Variable),               
          Usage (Rz),                     
          Input (Variable),               
          Input (Constant),               
      End Collection,                     
      Collection (Logical),               
          Usage (02h),                    
          Report Count (7),               
          Output (Variable),              
      End Collection,                     
  End Collection                          
  Usage Page (Desktop),                   
  Usage (Joystick),                       
  Collection (Application),               
      Collection (Logical),               
          Report Count (1),               
          Report Size (10),               
          Logical Minimum (0),            
          Logical Maximum (1023),         
          Physical Minimum (0),           
          Physical Maximum (1023),        
          Usage (X),                      
          Input (Variable),               
          Report Count (12),              
          Report Size (1),                
          Logical Maximum (1),            
          Physical Maximum (1),           
          Usage Page (Button),            
          Usage Minimum (01h),            
          Usage Maximum (0Ch),            
          Input (Variable),               
          Report Count (2),               
          Usage Page (FF00h),             
          Usage (01h),                    
          Input (Variable),               
          Usage (02h),                    
          Logical Maximum (255),          
          Physical Maximum (255),         
          Report Count (1),               
          Report Size (8),                
          Input (Variable),               
          Usage Page (Desktop),           
          Logical Maximum (7),            
          Physical Maximum (315),         
          Report Size (4),                
          Unit (Degrees),                 
          Usage (Hat Switch),             
          Input (Variable, Null State),   
          Report Size (1),                
          Report Count (4),               
          Unit,                           
          Usage Page (FF00h),             
          Usage (01h),                    
          Logical Maximum (1),            
          Physical Maximum (1),           
          Input (Variable),               
          Usage Page (Desktop),           
          Report Count (1),               
          Report Size (8),                
          Logical Maximum (255),          
          Physical Maximum (255),         
          Usage (Y),                      
          Input (Variable),               
          Usage (Z),                      
          Input (Variable),               
      End Collection,                     
      Collection (Logical),               
          Logical Maximum (255),          
          Physical Maximum (255),         
          Report Count (7),               
          Report Size (8),                
          Usage (03h),                    
          Output (Variable),              
      End Collection,                     
  End Collection                          
  Usage Page (Desktop),               
  Usage (Joystick),                   
  Collection (Application),           
      Collection (Logical),           
          Report Count (1),           
          Report Size (10),           
          Logical Minimum (0),        
          Logical Maximum (1023),     
          Physical Minimum (0),       
          Physical Maximum (1023),    
          Usage (X),                  
          Input (Variable),           
          Report Count (8),           
          Report Size (1),            
          Logical Maximum (1),        
          Physical Maximum (1),       
          Usage Page (Button),        
          Usage Minimum (01h),        
          Usage Maximum (08h),        
          Input (Variable),           
          Usage Page (FF00h),         
          Report Size (14),           
          Report Count (1),           
          Logical Maximum (255),      
          Physical Maximum (255),     
          Usage (00h),                
          Input (Variable),           
          Usage Page (Desktop),       
          Report Size (8),            
          Usage (Y),                  
          Input (Variable),           
          Usage (Z),                  
          Input (Variable),           
          Usage Page (FF00h),         
          Usage (01h),                
          Input (Variable),           
      End Collection,                 
      Collection (Logical),           
          Usage (02h),                
          Report Count (7),           
          Output (Variable),          
      End Collection,                 
  End Collection                      
  Usage Page (Desktop),               
  Usage (Joystick),                   
  Collection (Application),           
      Collection (Logical),           
          Report Count (1),           
          Report Size (10),           
          Logical Minimum (0),        
          Logical Maximum (1023),     
          Physical Minimum (0),       
          Physical Maximum (1023),    
          Usage (X),                  
          Input (Variable),           
          Report Count (10),          
          Report Size (1),            
          Logical Maximum (1),        
          Physical Maximum (1),       
          Usage Page (Button),        
          Usage Minimum (01h),        
          Usage Maximum (0Ah),        
          Input (Variable),           
          Usage Page (FF00h),         
          Usage (00h),                
          Report Count (4),           
          Input (Variable),           
          Report Count (1),           
          Report Size (8),            
          Logical Maximum (255),      
          Physical Maximum (255),     
          Usage (01h),                
          Input (Variable),           
          Usage Page (Desktop),       
          Usage (Y),                  
          Input (Variable),           
          Usage (Z),                  
          Input (Variable),           
          Usage Page (FF00h),         
          Usage (00h),                
          Input (Variable),           
      End Collection,                 
      Collection (Logical),           
          Usage (02h),                
          Report Count (7),           
          Output (Variable),          
      End Collection,                 
  End Collection                      
  Usage Page (Desktop),               
  Usage (Joystik),                    
  Collection (Application),           
      Collection (Logical),           
          Report Count (1),           
          Report Size (10),           
          Logical Minimum (0),        
          Logical Maximum (1023),     
          Physical Minimum (0),       
          Physical Maximum (1023),    
          Usage (X),                  
          Input (Variable),           
          Report Count (6),           
          Report Size (1),            
          Logical Maximum (1),        
          Physical Maximum (1),       
          Usage Page (Button),        
          Usage Minimum (01h),        
          Usage Maximum (06h),        
          Input (Variable),           
          Report Count (1),           
          Report Size (8),            
          Logical Maximum (255),      
          Physical Maximum (255),     
          Usage Page (FF00h),         
          Usage (01h),                
          Input (Variable),           
          Usage Page (Desktop),       
          Input (Constant),           
          Usage (Y),                  
          Input (Variable),           
          Usage (Z),                  
          Input (Variable),           
          Usage Page (FF00h),         
          Usage (01h),                
          Input (Variable),           
      End Collection,                 
      Collection (Logical),           
          Usage (02h),                
          Report Count (7),           
          Output (Variable),          
      End Collection,                 
  End Collection                      
  Usage Page (Desktop),               
  Usage (Joystik),                    
  Collection (Application),           
      Collection (Logical),           
          Logical Minimum (0),        
          Logical Maximum (255),      
          Physical Minimum (0),       
          Physical Maximum (255),     
          Report Size (8),            
          Report Count (1),           
          Usage (X),                  
          Input (Variable),           
  Push,                               
          Logical Maximum (1),        
          Physical Maximum (1),       
          Report Size (1),            
          Report Count (2),           
          Input (Constant),           
          Report Count (6),           
          Usage Page (Button),        
          Usage Minimum (01h),        
          Usage Maximum (06h),        
          Input (Variable),           
          Usage Page (Desktop),       
  Pop,                                
          Input (Constant),           
          Usage (Y),                  
          Input (Variable),           
          Usage (Z),                  
          Input (Variable),           
      End Collection,                 
      Collection (Logical),           
          Logical Maximum (255),      
          Physical Maximum (255),     
          Report Size (8),            
          Report Count (4),           
          Usage (02h),                
          Feature (Variable),         
      End Collection,                 
  End Collection,                     
  Certain Logitech keyboards send in report #3 keys which are far
  above the logical maximum described in descriptor. This extends
  the original value of 0x28c of logical maximum to 0x104d
 Several wheels report as this id when operating in emulation mode. 
 Reported on Logitech Ultra X Media Remote 
 The following two entries are Playlist 1 and 2 on the MX3200 
 this one is marked as 'Rotate' 
	 The following two are 'Startanswer call' and 'Endreject call'
	 extended mapping for certain Logitech hardware (Logitech cordless
 Special handling for Logitech Cordless Desktop 
 Ensure that Logitech wheels are not given a default fuzzflat value 
 G29 only work with the 1st interface 
 Setup wireless link with Logitech Wii wheel 
 insert a little delay of 10 jiffies ~ 40ms 
 Select random Address 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for some cherry "special" devices
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2006-2007 Jiri Kosina
   Copyright (c) 2008 Jiri Slaby
  Cherry Cymotion keyboard have an invalid HID report descriptor,
  that needs fixing before we can parse it.
 SPDX-License-Identifier: GPL-2.0-or-later
   Force feedback support for Logitech Flight System G940
   Copyright (c) 2009 Gary Stein <LordCnidarian@gmail.com>
  G940 Theory of Operation (from experimentation)
  There are 63 fields (only 3 of them currently used)
  0 - seems to be command field
  1 - 30 deal with the x axis
  31 -60 deal with the y axis
  Field 1 is x axis constant force
  Field 31 is y axis constant force
  other interesting fields 1,2,3,4 on x axis
  (same for 31,32,33,34 on y axis)
  0 0 127 127 makes the joystick autocenter hard
  127 0 127 127 makes the joystick loose on the right,
  but stops all movemnt left
  -127 0 -127 -127 makes the joystick loose on the left,
  but stops all movement right
  0 0 -127 -127 makes the joystick rattle very hard
  I'm sure these are effects that I don't know enough about them
  Available values in the field should always be 63, but we only use up to
  35. Instead, clear the entire area, however big it is.
  Already clamped in ff_memless
  0 is center (different then other logitech)
 send command byte 
  Sign backwards from other Force3d pro
  which get recast here in two's complement 8 bits
  Auto Centering probed from device
  NOTE: deadman's switch on G940 must be covered
  for effects to work
 Check that the report looks ok 
 Assume single fixed device G940 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for Xin-Mo devices, currently only the Dual Arcade controller.
   Fixes the negative axis event values (the devices sends -2) to match the
   logical axis minimum of the HID report descriptor (the report announces
   -1). It is needed because hid-input discards out of bounds values.
   (This module is based on "hid-saitek" and "hid-lg".)
   Copyright (c) 2013 Olivier Scherler
  Fix negative events that are out of bounds.
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for Sony  PS2  PS3  PS4 BD devices.
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2008 Jiri Slaby
   Copyright (c) 2012 David Dillow <dave@thedillows.org>
   Copyright (c) 2006-2013 Jiri Kosina
   Copyright (c) 2013 Colin Leitner <colin.leitner@gmail.com>
   Copyright (c) 2014-2016 Frank Praznik <frank.praznik@gmail.com>
   Copyright (c) 2018 Todd Kelner
   Copyright (c) 2020-2021 Pascal Giard <pascal.giard@etsmtl.ca>
   Copyright (c) 2020 Sanjay Govind <sanjay.govind9@gmail.com>
   Copyright (c) 2021 Daniel Nguyen <daniel.nguyen.1@ens.etsmtl.ca>
  NOTE: in order for the Sony PS3 BD Remote Control to be found by
  a Bluetooth host, the key combination Start+Enter has to be kept pressed
  for about 7 seconds with the Bluetooth Host Controller in discovering mode.
  There will be no PIN request from the device.
 The PS3Wii U dongles require a poke every 10 seconds, but the PS4
  requires one every 8 seconds. Using 8 seconds for all for simplicity.
 In seconds 
 Magic data taken from GHLtarUtility:
  https:github.comghlreGHLtarUtilityblobmasterPS3Guitar.cs
  Note: The Wii U and PS3 dongles happen to share the same!
 Magic data for the PS4 dongles sniffed with a USB protocol
  analyzer.
 PS3 Motion controller 
  Usage Page (Desktop),               
  Usage (Joystick),                   
  Collection (Application),           
      Collection (Logical),           
          Report ID (1),              
          Report Size (1),            
          Report Count (21),          
          Logical Minimum (0),        
          Logical Maximum (1),        
          Physical Minimum (0),       
          Physical Maximum (1),       
          Usage Page (Button),        
          Usage Minimum (01h),        
          Usage Maximum (15h),        
          Input (Variable),            Buttons 
          Report Count (11),          
          Usage Page (FF00h),         
          Input (Constant, Variable),  Padding 
          Logical Minimum (0),        
          Logical Maximum (255),      
          Usage Page (Desktop),       
          Collection (Physical),      
              Report Size (8),        
              Report Count (1),       
              Physical Minimum (0),   
              Physical Maximum (255), 
              Usage (X),              
              Input (Variable),        Trigger 
          End Collection,             
          Usage Page (FF00h),         
          Report Size (8),            
          Report Count (7),            skip 7 bytes 
          Input (Variable),           
          Usage Page (Desktop),       
          Report Size (16),           
          Physical Maximum (65535),   
      Logical Maximum (65535),    
          Report Count (3),            3x Accels 
              Usage (rX),             
              Usage (rY),             
              Usage (rZ),             
          Input (Variable),           
          Usage Page (FF00h),         
          Report Count (3),            Skip Accels 2nd frame 
          Input (Variable),           
          Usage Page (Desktop),       
          Usage (Pointer),            
          Report Count (3),            3x Gyros 
          Input (Variable),           
          Usage Page (FF00h),         
          Report Count (3),            Skip Gyros 2nd frame 
          Input (Variable),           
          Report Size (12),           
          Physical Maximum (4095),    
          Logical Maximum (4095),     
          Report Count (4),            Skip Temp and Magnetometers 
          Input (Variable),           
          Report Size (8),            
          Physical Maximum (255),     
          Logical Maximum (255),      
          Report Count (6),            Skip Timestamp and Extension Bytes 
          Input (Variable),           
          Report Size (8),            
          Report Count (48),          
          Usage (Pointer),            
          Output (Variable),          
          Report Size (8),            
          Report Count (48),          
          Usage (Pointer),            
          Feature (Variable),         
      End Collection,                 
      Collection (Logical),           
          Report ID (2),              
          Report Size (8),            
          Report Count (48),          
          Usage (Pointer),            
          Feature (Variable),         
      End Collection,                 
      Collection (Logical),           
          Report ID (238),            
          Report Size (8),            
          Report Count (48),          
          Usage (Pointer),            
          Feature (Variable),         
      End Collection,                 
      Collection (Logical),           
          Report ID (239),            
          Report Size (8),            
          Report Count (48),          
          Usage (Pointer),            
          Feature (Variable),         
      End Collection,                 
  End Collection                      
 GUsagePage Generic Desktop 
 LUsage 0x05 [Game Pad] 
 MCollection Application (mouse, keyboard) 
 Use collection 1 for joypad buttons 
 MCollection Logical (interrelated data) 
	  
	    Ignore the 1st byte, maybe it is used for a controller
	    number but it's not needed for correct operation
 GReportSize 0x08 [8] 
 GReportCount 0x01 [1] 
 MInput 0x01 (Const[0] Arr[1] Abs[2]) 
	  
	    Bytes from 2nd to 4th are a bitmap for joypad buttons, for these
	    buttons multiple keypresses are allowed
 GUsagePage Button 
 LUsageMinimum 0x01 [Button 1 (primarytrigger)] 
 LUsageMaximum 0x18 [Button 24] 
 GLogicalMinimum [0] 
 GLogicalMaximum 0x01 [1] 
 GReportSize 0x01 [1] 
 GReportCount 0x18 [24] 
 MInput 0x02 (Data[0] Var[1] Abs[2]) 
 MEndCollection 
 Use collection 2 for remote control buttons 
 MCollection Logical (interrelated data) 
 5th byte is used for remote control buttons 
 GUsagePage Button 
 LUsageMinimum [No button pressed] 
 LUsageMaximum 0xFE [Button 254] 
 GLogicalMinimum [0] 
 GLogicalMaximum 0x00FE [254] 
 GReportSize 0x08 [8] 
 GReportCount 0x01 [1] 
 MInput  
	  
	    Ignore bytes from 6th to 11th, 6th to 10th are always constant at
	    0xff and 11th is for press indication
 GReportSize 0x08 [8] 
 GReportCount 0x06 [6] 
 MInput 0x01 (Const[0] Arr[1] Abs[2]) 
 12th byte is for battery strength 
 GUsagePage Generic Device Controls 
 LUsage 0x20 [Battery Strength] 
 GLogicalMinimum [0] 
 GLogicalMaximum 0x05 [5] 
 GReportSize 0x08 [8] 
 GReportCount 0x01 [1] 
 MInput 0x02 (Data[0] Var[1] Abs[2]) 
 MEndCollection 
 MEndCollection [Game Pad] 
 L3 
 R3 
 L2 
 R2 
 L1 
 R1 
 optionstriangle 
 backcircle 
 cross 
 viewsquare 
 PS button 
 return 
 top menu 
 scan back 
 scan forward 
 pop upmenu 
 slowstep back 
 slowstep forward 
 display 
	
	  The controller has 4 remote buzzers, each with one LED and 5
	  buttons.
	 
	  We use the mapping chosen by the controller, which is:
	 
	  Key          Offset
	  -------------------
	  Buzz              1
	  Blue              5
	  Orange            4
	  Green             3
	  Yellow            2
	 
	  So, for example, the orange button on the third buzzer is mapped to
	  BTN_TRIGGER_HAPPY14
 The Navigation controller is a partial DS3 and uses the same HID report
  and hence the same keymap indices, however not not all axesbuttons
  are physically present. We use the same axis and button mapping as
  the DS3, which uses the Linux gamepad spec.
 L2 
 Buttons not physically available on the device, but still available
  in the reports are explicitly set to 0 for documentation purposes.
 Select 
 L3 
 R3 
 Start 
 Up 
 Right 
 Down 
 Left 
 L2 
 R2 
 L1 
 R1 
 Triangle 
 Circle 
 Cross 
 Square 
 PS 
 right stick X 
 right stick Y 
 Select 
 L3 
 R3 
 Start 
 Up 
 Right 
 Down 
 Left 
 L2 
 R2 
 L1 
 R1 
 Triangle 
 Circle 
 Cross 
 Square 
 PS 
 right stick X 
 L2 
 R2 
 right stick Y 
 Square 
 Cross 
 Circle 
 Triangle 
 L1 
 R1 
 L2 
 R2 
 Share 
 Options 
 L3 
 R3 
 PS 
 the total time the led is active (0xff means forever) 
 how long a cycle is in deciseconds (0 means "really fast") 
 % of duty_length the led is off (0xff means 100%) 
 % of duty_length the led is on (0xff mean 100%) 
 Right motor duration (0xff means forever) 
 Right (small) motor onoff, only supports values of 0 or 1 (offon) 
 Left motor duration (0xff means forever) 
 left (large) motor, supports force values from 0 to 255 
 bitmap of enabled LEDs: LED_1 = 0x02, LED_2 = 0x04, ... 
 LEDx at (4 - x) 
 LED5, not actually soldered 
 Offsets relative to USB input report (0x1). Bluetooth (0x11) requires an
  additional +2.
 Default to 4ms poll interval, which is same as USB (not adjustable). 
 Used for calibration of DS4 accelerometer and gyro. 
	 Calibration requires scaling against a sensitivity value, which is a
	  float. Store sensitivity as a fraction to limit floating point
	  calculations until final calibration.
 DS4 calibration data 
 GH Live 
		 See comment in sixaxis_mapping, basically the L2 (and R2)
		  triggers are reported through GD Pointer.
		  In addition we ignore any analog button 'axes' and only
		  support digital buttons.
 L2 
		 The DS3 provides analog values for most buttons and even
		  for HAT axes through GD Pointer. L2 and R2 are reported
		  among these as well instead of as GD Z  RZ. Remap L2
		  and R2 and ignore other analog 'button axes' as there is
		  no good way for reporting them.
 L2 
 R2 
 Let the HID parser deal with the HAT. 
	
	  Some Sony RF receivers wrongly declare the mouse pointer as a
	  a constant non-data variable.
 usage page: generic desktop controls 
 rdesc[0] == 0x05 && rdesc[1] == 0x01 && 
 usage: mouse 
 input (usage page for x,y axes): constant, variable, relative 
 input: data, variable, relative 
	
	  Some knock-off USB dongles incorrectly report their button count
	  as 13 instead of 16 causing three non-functional buttons.
 Report Count (13) 
 Usage Maximum (13) 
 Report Count (3) 
	
	  The sixaxis is charging if the battery value is 0xee
	  and it is fully charged if the value is 0xef.
	  It does not report the actual level while charging so it
	  is set to 100% while charging is in progress.
 Y and Z are swapped and inversed 
 When using Bluetooth the header is 2 bytes longer, so skip these. 
 Second bit of third button byte is for the touchpad button. 
	
	  The default behavior of the Dualshock 4 is to send reports using
	  report type 1 when running over Bluetooth. However, when feature
	  report 2 is requested during the controller initialization it starts
	  sending input reports in report 17. Since report 17 is undefined
	  in the default HID descriptor, the HID layer won't generate events.
	  While it is possible (and this was done before) to fixup the HID
	  descriptor to add this mapping, it was better to do this manually.
	  The reason is there were various pieces software both open and closed
	  source, relying on the descriptors to be the same across various
	  operating systems. If the descriptors wouldn't match some
	  applications e.g. games on Wine would not be able to function due
	  to different descriptors, which such applications are not parsing.
 Center 0, 0 
 Convert timestamp (in 5.33us unit) to timestamp_us 
 Store data in int for more precision during mult_frac. 
		 High precision is needed during calibration, but the
		  calibrated values are within 32-bit.
		  Note: we swap numerator 'x' and 'numer' in mult_frac for
		        precision reasons so we don't need 64-bit.
	
	  The lower 4 bits of byte 30 (or 32 for BT) contain the battery level
	  and the 5th bit contains the USB cable state.
	
	  Interpretation of the battery_capacity data depends on the cable state.
	  When no cable is connected (bit4 is 0):
	  - 0:10: percentage in units of 10%.
	  When a cable is plugged in:
	  - 0-10: percentage in units of 10%.
	  - 11: battery is full
	  - 14: not charging due to Voltage or temperature error
	  - 15: charge error
			 Take the mid-point for each battery capacity value,
			  because on the hardware side 0 = 0-9%, 1=10-19%, etc.
			  This matches official platform behavior, which does
			  the same.
 14, 15 and undefined values 
 10 
	
	  The Dualshock 4 multi-touch trackpad data starts at offset 33 on USB
	  and 35 on Bluetooth.
	  The first byte indicates the number of touch data in the report.
	  Trackpad data starts 2 bytes later (e.g. 35 for USB).
 Skip past timestamp 
		
		  The first 7 bits of the first byte is a counter and bit 8 is
		  a touch indicator that is 0 when pressed and 1 when not
		  pressed.
		  The next 3 bytes are two 12 bit touch coordinates, X and Y.
		  The data for the second touch is in the same format and
		  immediately follows the data for the first.
	
	  The NSG-MRxU multi-touch trackpad data starts at offset 1 and
	    the touch-related data starts at offset 2.
	  For the first byte, bit 0 is set when touchpad button is pressed.
	  Bit 2 is set when a touch is active and the drag (Fn) key is pressed.
	  This drag key is mapped to BTN_LEFT.  It is operational only when a 
	    touch point is active.
	  Bit 4 is set when only the first touch point is active.
	  Bit 6 is set when only the second touch point is active.
	  Bits 5 and 7 are set when both touch points are active.
	  The next 3 bytes are two 12 bit XY coordinates for the first touch.
	  The following byte, offset 5, has the touch width and length.
	    Bits 0-4=X (width), bits 5-7=Y (length).
	  A signed relative X coordinate is at offset 6.
	  The bytes at offset 7-9 are the second touch XY coordinates.
	  Offset 10 has the second touch width and length.
	  Offset 11 has the relative Y coordinate.
			
			  The relative coordinates belong to the first touch
			  point, when present, or to the second touch point
			  when the first is not active.
	
	  Sixaxis HID report has acclerometersgyro with MSByte first, this
	  has to be BYTE_SWAPPED before passing up to joystick interface
		
		  When connected via Bluetooth the Sixaxis occasionally sends
		  a report with the second byte 0xff and the rest zeroed.
		 
		  This report does not reflect the actual state of the
		  controller must be ignored to avoid generating false input
		  events.
 CRC check 
		
		  In the case of a DS4 USB dongle, bit[2] of byte 31 indicates
		  if a DS4 is actually connected (indicated by '0').
		  For non-dongle, this bit is always 0 (connected).
		
		  The dongle always sends input reports even when no
		  DS4 is attached. When a DS4 is connected, we need to
		  obtain calibration data before we can use it.
		  The code below tracks dongle state and kicks of
		  calibration when needed and only allows us to process
		  input if a DS4 is actually connected.
			 Don't process the report since we don't have
			  calibration data, but let hidraw have it anyway.
 Return 0, so hidraw can get the report. 
 Return 0, so hidraw can get the report. 
 Let hid-core decide for the others 
	 Append a suffix to the controller name as there are various
	  DS4 compatible non-Sony devices with different names.
 We map the button underneath the touchpad to BTN_LEFT. 
	 Append a suffix to the controller name as there are various
	  DS4 compatible non-Sony devices with different names.
		 For the DS3 we only support the accelerometer, which works
		  quite well even without calibration. The device also has
		  a 1-axis gyro, but it is very difficult to manage from within
		  the driver even to get data, the sensor is inaccurate and
		  the behavior is very different between hardware revisions.
  Sending HID_REQ_GET_REPORT changes the operation mode of the ps3 controller
  to "operational".  Without this, the ps3 controller will not report any
  events.
	
	  Some compatible controllers like the Speedlink Strike FX and
	  Gasia need another query plus an USB interrupt to get operational.
	
	  But the USB interrupt would cause SHANWAN controllers to
	  start rumbling non-stop, so skip step 3 for these controllers.
  Request DS4 calibration data for the motion sensors.
  For Bluetooth this also affects the operating mode (see below).
	 For Bluetooth we use a different request, which supports CRC.
	  Note: in Bluetooth mode feature report 0x02 also changes the state
	  of the controller, so that it sends input reports of type 0x11.
		 We should normally receive the feature report data we asked
		  for, but hidraw applications such as Steam can issue feature
		  reports as well. In particular for Dongle reconnects, Steam
		  and this function are competing resulting in often receiving
		  data for a different HID report, so retry a few times.
 CRC check 
 BT + Dongle 
	 Set gyroscope calibration and normalization parameters.
	  Data values will be normalized to 1DS4_GYRO_RES_PER_DEG_S degrees.
	 Set accelerometer calibration and normalization parameters.
	  Data values will be normalized to 1DS4_ACC_RES_PER_G G.
		 This call is very unlikely to fail for the dongle. When it
		  fails we are probably in a very bad state, so mark the
		  dongle as disabled. We will re-enable the dongle if a new
		  DS4 hotplug is detect from sony_raw_event as any issues
		  are likely resolved then (the dongle is quite stupid).
 The first 4 colorindex entries match what the PS4 assigns 
 Blue   	{ 0x00, 0x00, 0x40 },
 Red	  	{ 0x40, 0x00, 0x00 },
 Green  	{ 0x00, 0x40, 0x00 },
 Pink   	{ 0x20, 0x00, 0x20 },
 Orange 	{ 0x02, 0x01, 0x00 },
 Teal   	{ 0x00, 0x01, 0x01 },
 White  	{ 0x01, 0x01, 0x01 }
	
	  The Sixaxis on USB will override any LED settings sent to it
	  and keep flashing all of the LEDs until the PS button is pressed.
	  Updates, even if redundant, must be always be sent to the
	  controller to avoid having to toggle the state of an LED just to
	  stop the flashing later on.
 Setting the brightness stops the blinking 
 Max delay is 255 deciseconds or 2550 milliseconds 
 Blink at 1 Hz if both values are zero 
 This LED is not registered on this device 
 Don't schedule work if the values didn't change 
 Validate expected report characteristics. 
	
	  Clear LEDs as we have no way of reading their initial state. This is
	  only relevant if the driver is loaded after somebody actively set the
	  LEDs to on
 Initialize the report with default values 
 Set flag for all leds off, required for 3rd party INTEC controller 
	
	  The LEDs in the report are indexed in reverse order to their
	  corresponding light on the controller.
	  Index 0 = LED 4, index 1 = LED 3, etc...
	 
	  In the case of both delay values being zero (blinking disabled) the
	  default report values should be used or the controller LED will be
	  always off.
 SHANWAN controllers require output reports via intr channel 
	
	  NOTE: The lower 6 bits of buf[1] field of the Bluetooth report
	  control the interval at which Dualshock 4 reports data:
	  0x00 - 1ms
	  0x01 - 1ms
	  0x02 - 2ms
	  0x3E - 62ms
	  0x3F - disabled
 blink + LEDs + motor 
 HID + CRC  | sc->ds4_bt_poll_interval;
 blink + LEDs + motor 
 LED 3 is the global control 
 If both delay values are zero the DualShock 4 disables blinking. 
 CRC generation 
 set leds 
	
	  Set the default battery level to 100% to avoid low battery warnings
	  if the battery is polled before the first device report is received.
  If a controller is plugged in via USB while already connected via Bluetooth
  it will show up as two devices. A global list of connected controllers and
  their MAC addresses is maintained to ensure that a device is only connected
  once.
  Some USB-only devices masquerade as Sixaxis controllers and all have the
  same dummy Bluetooth address, so a comparison of the connection type is
  required.  Devices are only rejected in the case where two devices have
  matching Bluetooth addresses on different bus types.
 HIDP stores the device MAC address as a string in the uniq field. 
		
		  sony_get_bt_devaddr() attempts to parse the Bluetooth MAC
		  address from the uniq string where HIDP stores it.
		  As uniq cannot be guaranteed to be a MAC address in all cases
		  a failure of this function should not prevent the connection.
		
		  The MAC address of a DS4 controller connected via USB can be
		  retrieved with feature report 0x81. The address begins at
		  offset 1.
		
		  The MAC address of a Sixaxis controller connected via USB can
		  be retrieved with feature report 0xf2. The address begins at
		  offset 4.
		
		  The Sixaxis device MAC in the report is big-endian and must
		  be byte-swapped.
	
	  Only DualShock 4 or Sixaxis controllers get an id.
	  All others are set to -1.
		
		  The Sony Sixaxis does not handle HID Output Reports on the
		  Interrupt EP like it could, so we need to force HID Output
		  Reports to use HID_REQ_SET_REPORT on the Control EP.
		 
		  There is also another issue about HID Output Reports via USB,
		  the Sixaxis does not want the report_id as part of the data
		  packet, so we have to discard buf[0] when sending the actual
		  control message, even for numbered reports, humpf!
		 
		  Additionally, the Sixaxis on USB isn't properly initialized
		  until the PS logo button is pressed and as such won't retain
		  any state set by an output report, so the initial
		  configuration report is deferred until the first input
		  report arrives.
		
		  The Navigation controller wants output reports sent on the ctrl
		  endpoint when connected via Bluetooth.
		
		  The Sony Sixaxis does not handle HID Output Reports on the
		  Interrupt EP and the device only becomes active when the
		  PS button is pressed. See comment for Navigation controller
		  above for more details.
		
		  The Sixaxis wants output reports sent on the ctrl endpoint
		  when connected via Bluetooth.
		
		  The Dualshock 4 touchpad supports 2 touches and has a
		  resolution of 1920x942 (44.86 dotsmm).
		
		  The NSG-MRxU touchpad supports 2 touches and has a
		  resolution of 1667x1868
 Open the device to receive reports with battery info 
	 Piggy back on the default ds4_bt_ poll_interval to determine
	  if we need to remove the file as we don't know for sure if we
	  executed that logic.
	 Patch the hw version on DS34 compatible devices, so applications can
	  distinguish between the default HID mappings and the mappings defined
	  by the Linux game controller spec. This is important for the SDL2
	  library, which has a game controller database, which uses device ids
	  in combination with version as a key.
	 sony_input_configured can fail, but this doesn't result
	  in hid_hw_start failures (intended). Check whether
	  the HID layer claimed the device else fail.
	  We don't know the actual reason for the failure, most
	  likely it is due to EEXIST in case of double connection
	  of USB and Bluetooth, but could have been due to ENOMEM
	  or other reasons as well.
 On suspend stop any running force-feedback events 
	
	  The Sixaxis and navigation controllers on USB need to be
	  reinitialized on resume or they won't behave properly.
	
	  Wired Buzz Controller. Reported as Sony Hub from its USB ID and as
	  Logitech joystick from the device descriptor.
 PS3 BD Remote Control 
 Logitech Harmony Adapter for PS3 
 SMK-Link PS3 BD Remote Control 
 Sony Dualshock 4 controllers for PS4 
 Nyko Core Controller for PS3 
 SMK-Link NSG-MR5U Remote Control 
 SMK-Link NSG-MR7U Remote Control 
 Guitar Hero Live PS3 and Wii U guitar dongles 
 Guitar Hero PC Guitar Dongle 
 Guitar Hero PS3 World Tour Guitar Dongle 
 Guitar Hero Live PS4 guitar dongles 
 SPDX-License-Identifier: GPL-2.0+
   HID driver for UC-Logic devices not fully compliant with HID standard
   Copyright (c) 2010-2014 Nikolai Kondrashov
   Copyright (c) 2013 Martin Rusko
  This program is free software; you can redistribute it andor modify it
  under the terms of the GNU General Public License as published by the Free
  Software Foundation; either version 2 of the License, or (at your option)
  any later version.
 Driver data 
 Interface parameters 
 Pointer to the replacement report descriptor. NULL if none. 
	
	  Size of the replacement report descriptor.
	  Only valid if desc_ptr is not NULL
 Pen input device 
 In-range timer 
 Last rotary encoder state, or U8_MAX for none 
  uclogic_inrange_timeout - handle pen in-range state timeout.
  Emulate input events normally generated when pen goes out of range for
  tablets which don't report that.
  @t:	The timer the timeout handler is attached to, stored in a struct
 	uclogic_drvdata.
 If BTN_TOUCH state is changing 
 Digitizer Tip Switch usage 
 discard the unused pen interface 
 let hid-core decide what to do 
 no report associated (HID_QUIRK_MULTI_INPUT not set) 
	
	  If this is the input corresponding to the pen report
	  in need of tweaking.
 Remember the input device so we can simulate events 
	
	  libinput requires the pad interface to be on a different node
	  than the pen, so use QUIRK_MULTI_INPUT for all tablets.
 Allocate and assign driver data 
 Initialize the device and retrieve interface parameters 
 Generate replacement report descriptor 
 Assume "remove" might not be called if "probe" failed 
 Re-initialize the device, but discard parameters 
 Tweak pen reports, if necessary 
 If it's the "virtual" frame controls report 
 Change to virtual frame controls report ID 
 If in-range reports are inverted 
 Invert the in-range bit 
		
		  If report contains fragmented high-resolution pen
		  coordinates
 Lift pressure bytes 
			
			  Move Y coord to make space for high-order X
			  coord byte
 Move high-order X coord byte 
 Move high-order Y coord byte 
 Place pressure bytes 
 If we need to emulate in-range detection 
 Set in-range bit 
 (Re-)start in-range timeout 
 Tweak frame control reports, if necessary 
 If need to, and can, set pad device ID for Wacom drivers 
 If need to, and can, read rotary encoder state change 
 Read Gray-coded state 
 Encode state change into 2-bit signed integer 
 Write change 
 Remember state 
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for KyeGenius devices not fully compliant with HID standard
   Copyright (c) 2009 Jiri Kosina
   Copyright (c) 2009 Tomas Hanak
   Copyright (c) 2012 Nikolai Kondrashov
 Original EasyPen i405X report descriptor size 
 Fixed EasyPen i405X report descriptor 
  Usage Page (FF00h),             
  Usage (01h),                    
  Collection (Application),       
    Report ID (5),                
    Usage (01h),                  
    Logical Minimum (-128),       
    Logical Maximum (127),        
    Report Size (8),              
    Report Count (7),             
    Feature (Variable),           
  End Collection,                 
  Usage Page (Digitizer),         
  Usage (Pen),                    
  Collection (Application),       
    Report ID (16),               
    Usage (Stylus),               
    Collection (Physical),        
      Logical Minimum (0),        
      Logical Maximum (1),        
      Report Size (1),            
      Usage (Tip Switch),         
      Usage (Barrel Switch),      
      Usage (Tablet Pick),        
      Report Count (3),           
      Input (Variable),           
      Report Count (4),           
      Input (Constant, Variable), 
      Usage (In Range),           
      Report Count (1),           
      Input (Variable),           
      Report Size (16),           
      Report Count (1),           
      Push,                       
      Usage Page (Desktop),       
      Unit Exponent (-3),         
      Unit (Inch),                
      Physical Minimum (0),       
      Usage (X),                  
      Physical Maximum (5500),    
      Logical Maximum (14080),    
      Input (Variable),           
      Usage (Y),                  
      Physical Maximum (4000),    
      Logical Maximum (10240),    
      Input (Variable),           
      Pop,                        
      Usage (Tip Pressure),       
      Logical Maximum (1023),     
      Input (Variable),           
    End Collection,               
  End Collection                  
 Original MousePen i608X report descriptor size 
 Fixed MousePen i608X report descriptor 
  Usage Page (FF00h),             
  Usage (01h),                    
  Collection (Application),       
    Report ID (5),                
    Usage (01h),                  
    Logical Minimum (-128),       
    Logical Maximum (127),        
    Report Size (8),              
    Report Count (7),             
    Feature (Variable),           
  End Collection,                 
  Usage Page (Digitizer),         
  Usage (Pen),                    
  Collection (Application),       
    Report ID (16),               
    Usage (Stylus),               
    Collection (Physical),        
      Logical Minimum (0),        
      Logical Maximum (1),        
      Report Size (1),            
      Usage (Tip Switch),         
      Usage (Barrel Switch),      
      Usage (Tablet Pick),        
      Report Count (3),           
      Input (Variable),           
      Report Count (4),           
      Input (Constant, Variable), 
      Usage (In Range),           
      Report Count (1),           
      Input (Variable),           
      Report Size (16),           
      Report Count (1),           
      Push,                       
      Usage Page (Desktop),       
      Unit Exponent (-3),         
      Unit (Inch),                
      Physical Minimum (0),       
      Usage (X),                  
      Physical Maximum (8000),    
      Logical Maximum (20480),    
      Input (Variable),           
      Usage (Y),                  
      Physical Maximum (6000),    
      Logical Maximum (15360),    
      Input (Variable),           
      Pop,                        
      Usage (Tip Pressure),       
      Logical Maximum (1023),     
      Input (Variable),           
    End Collection,               
  End Collection,                 
  Usage Page (Desktop),           
  Usage (Mouse),                  
  Collection (Application),       
    Report ID (17),               
    Usage (Pointer),              
    Collection (Physical),        
      Logical Minimum (0),        
      Push,                       
      Usage Page (Button),        
      Report Size (1),            
      Usage Minimum (01h),        
      Usage Maximum (03h),        
      Logical Maximum (1),        
      Report Count (3),           
      Input (Variable),           
      Report Count (5),           
      Input (Constant),           
      Pop,                        
      Report Count (1),           
      Push,                       
      Unit Exponent (-3),         
      Unit (Inch),                
      Physical Minimum (0),       
      Report Size (16),           
      Usage (X),                  
      Physical Maximum (8000),    
      Logical Maximum (20480),    
      Input (Variable),           
      Usage (Y),                  
      Physical Maximum (6000),    
      Logical Maximum (15360),    
      Input (Variable),           
      Pop,                        
      Report Size (8),            
      Usage (Wheel),              
      Logical Minimum (-1),       
      Logical Maximum (1),        
      Input (Variable, Relative), 
      Input (Constant),           
    End Collection,               
  End Collection                  
 Original MousePen i608X v2 report descriptor size 
 Fixed MousePen i608X v2 report descriptor 
  Usage Page (FF00h),             
  Usage (01h),                    
  Collection (Application),       
    Report ID (5),                
    Usage (01h),                  
    Logical Minimum (-128),       
    Logical Maximum (127),        
    Report Size (8),              
    Report Count (7),             
    Feature (Variable),           
  End Collection,                 
  Usage Page (Digitizer),         
  Usage (Pen),                    
  Collection (Application),       
    Report ID (16),               
    Usage (Stylus),               
    Collection (Physical),        
      Logical Minimum (0),        
      Logical Maximum (1),        
      Report Size (1),            
      Usage (Tip Switch),         
      Usage (Barrel Switch),      
      Usage (Tablet Pick),        
      Report Count (3),           
      Input (Variable),           
      Report Count (4),           
      Input (Constant, Variable), 
      Usage (In Range),           
      Report Count (1),           
      Input (Variable),           
      Report Size (16),           
      Report Count (1),           
      Push,                       
      Usage Page (Desktop),       
      Unit Exponent (-3),         
      Unit (Inch),                
      Physical Minimum (0),       
      Usage (X),                  
      Physical Maximum (8000),    
      Logical Maximum (40960),    
      Input (Variable),           
      Usage (Y),                  
      Physical Maximum (6000),    
      Logical Maximum (30720),    
      Input (Variable),           
      Pop,                        
      Usage (Tip Pressure),       
      Logical Maximum (2047),     
      Input (Variable),           
    End Collection,               
  End Collection,                 
  Usage Page (Desktop),           
  Usage (Mouse),                  
  Collection (Application),       
    Report ID (17),               
    Usage (Pointer),              
    Collection (Physical),        
      Logical Minimum (0),        
      Push,                       
      Usage Page (Button),        
      Report Size (1),            
      Usage Minimum (01h),        
      Usage Maximum (03h),        
      Logical Maximum (1),        
      Report Count (3),           
      Input (Variable),           
      Report Count (5),           
      Input (Constant),           
      Pop,                        
      Report Count (1),           
      Push,                       
      Unit Exponent (-3),         
      Unit (Inch),                
      Physical Minimum (0),       
      Report Size (16),           
      Usage (X),                  
      Physical Maximum (8000),    
      Logical Maximum (40960),    
      Input (Variable),           
      Usage (Y),                  
      Physical Maximum (6000),    
      Logical Maximum (30720),    
      Input (Variable),           
      Pop,                        
      Report Size (8),            
      Usage (Wheel),              
      Logical Minimum (-1),       
      Logical Maximum (1),        
      Input (Variable, Relative), 
      Input (Constant),           
    End Collection,               
  End Collection                  
 Original EasyPen M610X report descriptor size 
 Fixed EasyPen M610X report descriptor 
  Usage Page (FF00h),             
  Usage (01h),                    
  Collection (Application),       
    Report ID (5),                
    Usage (01h),                  
    Logical Minimum (-128),       
    Logical Maximum (127),        
    Report Size (8),              
    Report Count (7),             
    Feature (Variable),           
  End Collection,                 
  Usage Page (Digitizer),         
  Usage (Pen),                    
  Collection (Application),       
    Report ID (16),               
    Usage (Stylus),               
    Collection (Physical),        
      Logical Minimum (0),        
      Logical Maximum (1),        
      Report Size (1),            
      Usage (Tip Switch),         
      Usage (Barrel Switch),      
      Usage (Tablet Pick),        
      Report Count (3),           
      Input (Variable),           
      Report Count (4),           
      Input (Constant, Variable), 
      Usage (In Range),           
      Report Count (1),           
      Input (Variable),           
      Report Size (16),           
      Report Count (1),           
      Push,                       
      Usage Page (Desktop),       
      Unit Exponent (-3),         
      Unit (Inch),                
      Physical Minimum (0),       
      Usage (X),                  
      Physical Maximum (10000),   
      Logical Maximum (40960),    
      Input (Variable),           
      Usage (Y),                  
      Physical Maximum (6250),    
      Logical Maximum (25600),    
      Input (Variable),           
      Pop,                        
      Usage (Tip Pressure),       
      Logical Maximum (1023),     
      Input (Variable),           
    End Collection,               
  End Collection,                 
  Usage Page (Consumer),          
  Usage (Consumer Control),       
  Collection (Application),       
    Report ID (18),               
    Logical Minimum (0),          
    Logical Maximum (1),          
    Report Size (1),              
    Report Count (4),             
    Usage (AC Undo),              
    Usage (AC Redo Or Repeat),    
    Usage (AC Zoom In),           
    Usage (AC Zoom Out),          
    Input (Variable),             
    Report Count (1),             
    Report Size (20),             
    Input (Constant, Variable),   
    Report Size (32),             
    Input (Constant, Variable),   
  End Collection                  
 Original PenSketch M912 report descriptor size 
 Fixed PenSketch M912 report descriptor 
  Usage Page (Desktop),           
  Usage (00h),                    
  Collection (Application),       
    Report ID (5),                
    Usage Page (FF00h),           
    Usage (01h),                  
    Logical Minimum (-127),       
    Logical Maximum (127),        
    Report Size (8),              
    Report Count (7),             
    Feature (Variable),           
  End Collection,                 
  Usage Page (Digitizer),         
  Usage (Pen),                    
  Collection (Application),       
    Report ID (16),               
    Usage (Stylus),               
    Collection (Physical),        
      Usage (Tip Switch),         
      Usage (Barrel Switch),      
      Usage (Tablet Pick),        
      Logical Minimum (0),        
      Logical Maximum (1),        
      Report Size (1),            
      Report Count (3),           
      Input (Variable),           
      Report Count (4),           
      Input (Constant, Variable), 
      Usage (In Range),           
      Report Count (1),           
      Input (Variable),           
      Report Size (16),           
      Report Count (1),           
      Push,                       
      Usage Page (Desktop),       
      Unit Exponent (-3),         
      Unit (Inch),                
      Logical Minimum (0),        
      Physical Minimum (0),       
      Usage (X),                  
      Logical Maximum (61440),    
      Physical Maximum (12000),   
      Input (Variable),           
      Usage (Y),                  
      Logical Maximum (46080),    
      Physical Maximum (9000),    
      Input (Variable),           
      Pop,                        
      Usage (Tip Pressure),       
      Logical Minimum (0),        
      Logical Maximum (2047),     
      Input (Variable),           
    End Collection,               
  End Collection,                 
  Usage Page (Digitizer),         
  Usage (Puck),                   
  Collection (Application),       
    Report ID (17),               
    Usage (Puck),                 
    Collection (Physical),        
      Usage Page (Button),        
      Report Size (1),            
      Usage Minimum (01h),        
      Usage Maximum (03h),        
      Logical Minimum (0),        
      Logical Maximum (1),        
      Report Count (3),           
      Input (Variable),           
      Report Count (4),           
      Input (Constant),           
      Report Count (1),           
      Usage (Digitizer In Range), 
      Logical Minimum (0),        
      Logical Maximum (1),        
      Input (Variable),           
      Push,                       
      Usage Page (Desktop),       
      Report Size (16),           
      Report Count (1),           
      Unit Exponent (-3),         
      Unit (Inch),                
      Logical Minimum (0),        
      Physical Minimum (0),       
      Usage (X),                  
      Logical Maximum (61440),    
      Physical Maximum (12000),   
      Input (Variable),           
      Usage (Y),                  
      Logical Maximum (46080),    
      Physical Maximum (9000),    
      Input (Variable),           
      Usage (Wheel),              
      Report Size (8),            
      Report Count (1),           
      Logical Minimum (-1),       
      Logical Maximum (1),        
      Physical Minimum (0),       
      Physical Maximum (0),       
      Input (Variable, Relative), 
      Pop,                        
    End Collection,               
  End Collection,                 
  Usage Page (Consumer),          
  Usage (Consumer Control),       
  Collection (Application),       
    Report ID (18),               
    Logical Minimum (0),          
    Logical Maximum (1),          
    Report Size (1),              
    Report Count (8),             
    Usage Page (Consumer),        
    Usage (AC Delete),            
    Usage (AC Undo),              
    Usage (AC New),               
    Usage (AC Zoom),              
    Usage (AC Forward),           
    Usage (AC Back),              
    Usage (AC Zoom In),           
    Usage (AC Zoom Out),          
    Input (Variable),             
    Report Count (48),            
    Input (Constant, Variable),   
  End Collection                  
 Original EasyPen M406XE report descriptor size 
 Fixed EasyPen M406XE  report descriptor 
  Usage Page (Desktop),               
  Usage (01h),                        
  Collection (Application),           
      Report ID (5),                  
      Usage (01h),                    
      Logical Minimum (-128),         
      Logical Maximum (127),          
      Report Size (8),                
      Report Count (7),               
      Feature (Variable),             
  End Collection,                     
  Usage Page (Digitizer),             
  Usage (Pen),                        
  Collection (Application),           
      Report ID (16),                 
      Usage (Stylus),                 
      Collection (Physical),          
          Logical Minimum (0),        
          Logical Maximum (1),        
          Report Size (1),            
          Usage (Tip Switch),         
          Usage (Barrel Switch),      
          Usage (Tablet Pick),        
          Report Count (3),           
          Input (Variable),           
          Report Count (4),           
          Input (Constant, Variable), 
          Usage (In Range),           
          Report Count (1),           
          Input (Variable),           
          Report Size (16),           
          Report Count (1),           
          Push,                       
          Usage Page (Desktop),       
          Unit Exponent (-3),         
          Unit (Inch),                
          Physical Minimum (0),       
          Usage (X),                  
          Physical Maximum (6000),    
          Logical Maximum (15360),    
          Input (Variable),           
          Usage (Y),                  
          Physical Maximum (4000),    
          Logical Maximum (10240),    
          Input (Variable),           
          Pop,                        
          Usage (Tip Pressure),       
          Logical Maximum (1023),     
          Input (Variable),           
      End Collection,                 
  End Collection                      
  Usage Page (Consumer),              
  Usage (Consumer Control),           
  Collection (Application),           
      Report ID (18),                 
      Logical Minimum (0),            
      Logical Maximum (1),            
      Report Size (1),                
      Report Count (4),               
      Usage (AC Redo Or Repeat),      
      Usage (AC Undo),                
      Usage (AC Zoom In),             
      Usage (AC Zoom Out),            
      Input (Variable),               
      Report Count (52),              
      Input (Constant, Variable),     
  End Collection                      
	
	  the fixup that need to be done:
	    - change Usage Maximum in the Consumer Control
	      (report ID 3) to a reasonable value
 Usage Page (Consumer Devices) 
 Usage (Consumer Control) 
   Usage Maximum > 12287 
		 the fixups that need to be done:
		    - change led usage page to button for extra buttons
		    - report size 8 count 1 must be size 1 count 8 for button
		      bitfield
		    - change the button usage range to 4-7 for the extra
		      buttons
  kye_tablet_enable() - Enable fully-functional tablet mode by setting a special feature report.
  @hdev:	HID device
  The specific report ID and data were discovered by sniffing the
  Windows driver traffic.
		
		  The manticore keyboard needs to have all the interfaces
		  opened at least once to be fully functional.
 SPDX-License-Identifier: GPL-2.0-only
   HIDPP protocol for Logitech receivers
   Copyright (c) 2011 Logitech (c)
   Copyright (c) 2012-2013 Google (c)
   Copyright (c) 2013-2014 Red Hat Inc.
 bits 2..20 are reserved for classes 
 #define HIDPP_QUIRK_CONNECT_EVENTS		BIT(21) disabled 
 These are just aliases for now 
 Convenience constant to check for any high-res support. 
  There are two hidpp protocols in use, the first version hidpp10 is known
  as register access protocol or RAP, the second version hidpp20 is known as
  feature access protocol or FAP
  Most older devices (including the Unifying usb receiver) use the RAP protocol
  where as most newer devices use the FAP protocol. Both protocols are
  compatible with the underlying transport, which could be usb, Unifiying, or
  bluetooth. The message lengths are defined by the hid vendor specific report
  descriptor for the HIDPP_SHORT report type (total message lenth 7 bytes) and
  the HIDPP_LONG report type (total message length 20 bytes)
  The RAP protocol uses both report types, whereas the FAP only uses HIDPP_LONG
  messages. The Unifying receiver itself responds to RAP messages (device index
  is 0xFF for the receiver), and all messages (short or long) with a device
  index between 1 and 6 are passed untouched to the corresponding paired
  Unifying device.
  The paired device can be RAP or FAP, it will receive the message untouched
  from the Unifiying receiver.
  struct hidpp_scroll_counter - Utility class for processing high-resolution
                              scroll events.
  @dev: the input device for which events should be reported.
  @wheel_multiplier: the scalar multiplier to be applied to each wheel event
  @remainder: counts the number of high-resolution units moved since the last
              low-resolution event (REL_WHEEL or REL_HWHEEL) was sent. Should
              only be used by class methods.
  @direction: direction of last movement (1 or -1)
  @last_time: last event time, used to reset remainder after inactivity
 will never be NULL and should not be freed 
 HID++ 1.0 error codes 
 HID++ 2.0 error codes 
	
	  set the device_index as the receiver, it will be overwritten by
	  hid_hw_request if needed
  hidpp_send_message_sync() returns 0 in case of success, and something else
  in case of a failure.
  - If ' something else' is positive, that means that an error has been raised
    by the protocol itself.
  - If ' something else' is negative, that means that we had a classic error
    (-ENOMEM, -EPIPE, etc...)
	
	  So that we can later validate the answer when it arrives
	  in hidpp_raw_event
 Send as long report if short reports are not supported. 
  hidpp_prefix_name() prefixes the current given name with "Logitech ".
 "Logitech " 
 The prefix has is already in the name 
  hidpp_scroll_counter_handle_scroll() - Send high- and low-resolution scroll
                                         events given a high-resolution wheel
                                         movement.
  @input_dev: Pointer to the input device
  @counter: a hid_scroll_counter struct describing the wheel.
  @hi_res_value: the movement of the wheel, in the mouse's high-resolution
                 units.
  Given a high-resolution movement, this function converts the movement into
  fractions of 120 and emits high-resolution scroll events for the input
  device. It also uses the multiplier from &struct hid_scroll_counter to
  emit low-resolution scroll events when appropriate for
  backwards-compatibility with userspace input libraries.
	
	  Reset the remainder after a period of inactivity or when the
	  direction changes. This prevents the REL_WHEEL emulation point
	  from sliding for devices that don't always provide the same
	  number of movements per detent.
	 Some wheels will rest 78ths of a detent from the previous detent
	  after slow movement, so we want the threshold for low-res events to
	  be in the middle between two detents (e.g. after 48ths) as
	  opposed to on the detents themselves (88ths).
		 Add (or subtract) 1 because we want to trigger when the wheel
		  is half-way to the next detent (i.e. scroll 1 detent after a
		  12 detent movement, 2 detents after a 1 12 detent movement,
		  etc.).
 -------------------------------------------------------------------------- 
 HIDP++ 1.0 commands                                                        
 -------------------------------------------------------------------------- 
  hidpp10_set_register - Modify a HID++ 1.0 register.
  @hidpp_dev: the device to set the register on.
  @register_address: the address of the register to modify.
  @byte: the byte of the register to modify. Should be less than 3.
  @mask: mask of the bits to modify
  @value: new values for the bits in mask
  Return: 0 if successful, otherwise a negative error code.
 On HID++ 1.0 devices, high-res scroll was called "scrolling acceleration". 
 discharging (in use) 
 (standard) charging 
 fast charging 
 slow charging 
 topping charge 
 charge complete 
 unknown 
	
	  0x01...0x1F = reserved (not charging)
	  0x23 = charging error
	  0x27..0xff = reserved
 the capacity is only available when discharging or full 
 discharging (in use) 
 charging 
 charge complete 
	
	  0x03 = charging error
 the capacity is only available when discharging or full 
 the capacity is only available when discharging or full 
 logitech devices are usually at least Xddd 
 include the terminating '\0' 
	
	  We don't care about LE or BE, we will output it as a string
	  with %4phD, so we need to keep the order.
 -------------------------------------------------------------------------- 
 0x0000: Root                                                               
 -------------------------------------------------------------------------- 
 the device might not be connected 
 -------------------------------------------------------------------------- 
 0x0005: GetDeviceNameType                                                  
 -------------------------------------------------------------------------- 
 include the terminating '\0' 
 -------------------------------------------------------------------------- 
 0x1000: Battery level status                                               
 -------------------------------------------------------------------------- 
	
	  The spec says this should be < 31 but some devices report 30
	  with brand new batteries and Windows reports 30 as "Good".
	 When discharging, we can rely on the device reported capacity.
	  For all other states the device reports 0 (unknown).
 discharging (in use) 
 recharging 
 charge in final stage 
 charge complete 
 recharging below optimal speed 
		 5 = invalid battery type
		   6 = thermal error
 Ignore these intermittent errors 
 the capacity is only available when discharging or full 
 the capacity is only available when discharging or full 
 -------------------------------------------------------------------------- 
 0x1001: Battery voltage                                                    
 -------------------------------------------------------------------------- 
	 NB: This voltage curve doesn't necessarily map perfectly to all
	  devices that implement the BATTERY_VOLTAGE feature. This is because
	  there are a few devices that use different battery technology.
 -------------------------------------------------------------------------- 
 0x1004: Unified battery                                                    
 -------------------------------------------------------------------------- 
 we have already set the device capabilities, so let's skip 
 Ignore these intermittent errors 
	
	  If the device supports state of charge (battery percentage) we won't
	  export the battery level information. there are 4 possible battery
	  levels and they all are optional, this means that the device might
	  not support any of them, we are just better off with the battery
	  percentage.
 discharging 
 charging 
 charging slow 
 complete 
 error 
 cler unsupported level bits 
 Ignore these intermittent errors 
 -------------------------------------------------------------------------- 
 Battery feature helpers                                                    
 -------------------------------------------------------------------------- 
 placeholder for POWER_SUPPLY_PROP_CAPACITY, 
 placeholder for POWER_SUPPLY_PROP_CAPACITY_LEVEL, 
 placeholder for POWER_SUPPLY_PROP_VOLTAGE_NOW, 
 hardware reports voltage in in mV. sysfs expects uV 
 -------------------------------------------------------------------------- 
 0x1d4b: Wireless device status                                             
 -------------------------------------------------------------------------- 
 -------------------------------------------------------------------------- 
 0x2120: Hi-resolution scrolling                                            
 -------------------------------------------------------------------------- 
 -------------------------------------------------------------------------- 
 0x2121: HiRes Wheel                                                        
 -------------------------------------------------------------------------- 
 -------------------------------------------------------------------------- 
 0x4301: Solar Keyboard                                                     
 -------------------------------------------------------------------------- 
 -------------------------------------------------------------------------- 
 0x6010: Touchpad FW items                                                  
 -------------------------------------------------------------------------- 
  send a set state command to the device by reading the current items->state
  field. items is then filled with the current state.
 -------------------------------------------------------------------------- 
 0x6100: TouchPadRawXY                                                      
 -------------------------------------------------------------------------- 
 res is given in unit per inch 
	
	  Params:
	    bit 0 - enable raw
	    bit 1 - 16bit Z, no area
	    bit 2 - enhanced sensitivity
	    bit 3 - width, height (4 bits each) instead of area
	    bit 4 - send raw + gestures (degrades smoothness)
	    remaining bits - reserved
 -------------------------------------------------------------------------- 
 0x8123: Force feedback support                                             
 -------------------------------------------------------------------------- 
 add slot number if needed 
 leave slot as zero 
 find current slot for effect 
 send command and wait for reply 
 parse return data 
 regular effect uploaded 
 autocenter spring uploaded 
 regular effect destroyed 
 autocenter spring destoyed 
 no action needed 
 warn about excessive queue size 
 set common parameters 
 start a standard spring effect 
 zero delay and duration 
 set coeff to 25% of saturation 
 zero deadband and center 
 no boost 
 Get firmware release 
 Set supported force feedback capabilities 
	
	  Create a copy of passed data, so we can transfer memory
	  ownership to FF core
 Create sysfs interface 
 init the hardware command queue 
 Device Support                                                             
 -------------------------------------------------------------------------- 
 Touchpad HID++ devices                                                     
 -------------------------------------------------------------------------- 
 Max pressure is not given by the devices, pick one 
 no actual data 
 size is already checked in hidpp_raw_event. 
 means that the device is not powered up 
 ------------------------------------------------------------------------- 
 Logitech M560 devices                                                     
 ------------------------------------------------------------------------- 
  Logitech M560 protocol overview
  The Logitech M560 mouse, is designed for windows 8. When the middle andor
  the sides buttons are pressed, it sends some keyboard keys events
  instead of buttons ones.
  To complicate things further, the middle button keys sequence
  is different from the odd press and the even press.
  forward button -> Super_R
  backward button -> Super_L+'d' (press only)
  middle button -> 1st time: Alt_L+SuperL+XF86TouchpadOff (press only)
                   2nd time: left-click (press only)
  NB: press-only means that when the button is pressed, the
  KeyPressButtonPress and KeyReleaseButtonRelease events are generated
  together sequentially; instead when the button is released, no event is
  generated !
  With the command
 	10<xx>0a 3500af03 (where <xx> is the mouse id),
  the mouse reacts differently:
  - it never sends a keyboard key event
  - for the three mouse button it sends:
 	middle button               press   11<xx>0a 3500af00...
 	side 1 button (forward)     press   11<xx>0a 3500b000...
 	side 2 button (backward)    press   11<xx>0a 3500ae00...
 	middleside1side2 button   release 11<xx>0a 35000000...
 how buttons are mapped in the report 
 sanity check 
		
		  m560 mouse report for middle, forward and backward button
		 
		  data[0] = 0x11
		  data[1] = device-id
		  data[2] = 0x0a
		  data[5] = 0xaf -> middle
		 	     0xb0 -> forward
		 	     0xae -> backward
		 	     0x00 -> release all
		  data[6] = 0x00
		
		  Logitech M560 mouse report
		 
		  data[0] = type (0x02)
		  data[1..2] = buttons
		  data[3..5] = xy
		  data[6] = wheel
 ------------------------------------------------------------------------- 
 Logitech K400 devices                                                     
 ------------------------------------------------------------------------- 
  The Logitech K400 keyboard has an embedded touchpad which is seen
  as a mouse from the OS point of view. There is a hardware shortcut to disable
  tap-to-click but the setting is not remembered accross reset, annoying some
  users.
  We can toggle this feature from the host by using the feature 0x6010:
  Touchpad FW items
 means that the device is not powered up 
 ------------------------------------------------------------------------- 
 Logitech G920 Driving Force Racing Wheel for Xbox One                     
 ------------------------------------------------------------------------- 
 initialize with zero autocenter to get wheel in usable state 
 Find feature and store for later use 
 Read number of slots available in device 
 reset all forces 
 Read the current gain values 
 ignore boost value at response.fap.params[2] 
 -------------------------------------------------------------------------- 
 Logitech Dinovo Mini keyboard with builtin touchpad                        
 -------------------------------------------------------------------------- 
 -------------------------------------------------------------------------- 
 HID++1.0 devices which use HID++ reports for their wheels                  
 -------------------------------------------------------------------------- 
 -------------------------------------------------------------------------- 
 HID++1.0 mice which use HID++ reports for extra mouse buttons              
 -------------------------------------------------------------------------- 
	
	  Buttons are either delivered through the regular mouse report or
	  through the extra buttons report. At least for button 6 how it is
	  delivered differs per receiver firmware version. Even receivers with
	  the same usb-id show different behavior, so we handle both cases.
 Some mice report events on button 9+, use BTN_MISC 
 BTN_MOUSE - BTN_MOUSE+7 are set already by the descriptor 
 -------------------------------------------------------------------------- 
 HID++1.0 kbds which only report 0x10xx consumer usages through sub-id 0x03 
 -------------------------------------------------------------------------- 
 Find the consumer-page input report desc and change Maximums to 0x107f 
 Note 0 terminated so we can use strnstr to search for this. 
 USAGE_PAGE (Consumer Devices)       
 USAGE (Consumer Control)            
 COLLECTION (Application)            
 REPORT_ID = 3                       
 REPORT_SIZE (16)                    
 REPORT_COUNT (2)                    
 LOGICAL_MIN (1)                     
 LOGICAL_MAX (...                    
	
	  Build a normal consumer report (3) out of the data, this detour
	  is necessary to get some keyboards to report their 0x10xx usages.
 We are called from atomic context 
 -------------------------------------------------------------------------- 
 High-resolution scroll wheels                                              
 -------------------------------------------------------------------------- 
 if (hidpp->quirks & HIDPP_QUIRK_HI_RES_SCROLL_1P0)  {
 -------------------------------------------------------------------------- 
 Generic HID++ devices                                                      
 -------------------------------------------------------------------------- 
 For 27 MHz keyboards the quirk gets set after hid_parse. 
 Ensure that Logitech G920 is not given a default fuzzflat value 
	
	  If the mutex is locked then we have a pending answer from a
	  previously sent command.
		
		  Check for a correct hidpp20 answer or the corresponding
		  error
			
			  This was an answer to a command that this driver sent
			  We return 1 to hid-core to avoid forwarding the
			  command upstream as it has been treated by the driver
gitlab.freedesktop.orgjwrdegoedelogitech-27mhz-keyboard-encryption-setup\n");
 Generic HID++ processing. 
	 If no report is available for further processing, skip calling
	 This function will only be called for scroll events, due to the
	  restriction imposed in hidpp_usages.
	 A scroll event may occur before the multiplier has been retrieved or
	  the input device set, or high-res scroll enabling may fail. In such
	  cases we must return early (falling back to default behaviour) to
	  avoid a crash in hidpp_scroll_counter_handle_scroll.
			 we only support one battery feature right now, so let's
			   first check the ones that support battery level first
	 the device is already connected, we can ask for its name and
 forward current battery state 
 if the input nodes are already created, we can stop now 
 report_fixup needs drvdata to be set before we call hid_parse 
	
	  Make sure the device is HID++ capable, otherwise treat as generic HID
 indicates we are handling the battery properties in the kernel 
	
	  Plain USB connections need to actually call start and open
	  on the transport driver to allow incoming data.
 Allow incoming packets 
 Reset the HID node state 
 Now export the actual inputs and hidraw nodes to the world 
 wireless touchpad 
 wireless touchpad T650 
 wireless touchpad T651 
 Mouse Logitech Anywhere MX 
 Mouse Logitech Cube 
 Mouse Logitech M335 
 Mouse Logitech M515 
 Mouse logitech M560 
 Mouse Logitech M705 (firmware RQM17) 
 Mouse Logitech M705 (firmware RQM67) 
 Mouse Logitech M720 
 Mouse Logitech MX Anywhere 2 
 Mouse Logitech MX Anywhere 2S 
 Mouse Logitech MX Master 
 Mouse Logitech MX Master 2S 
 Mouse Logitech MX Master 3 
 Mouse Logitech Performance MX 
 Keyboard logitech K400 
 Solar Keyboard Logitech K750 
 Keyboard MX5000 (Bluetooth-receiver in HID proxy mode) 
 Dinovo Edge (Bluetooth-receiver in HID proxy mode) 
 Keyboard MX5500 (Bluetooth-receiver in HID proxy mode) 
 Keyboard LX501 (Y-RR53) 
 Keyboard MX3000 (Y-RAM74) 
 Keyboard MX3200 (Y-RAV80) 
 S510 Media Remote 
 Logitech G403 Wireless Gaming Mouse over USB 
 Logitech G703 Gaming Mouse over USB 
 Logitech G703 Hero Gaming Mouse over USB 
 Logitech G900 Gaming Mouse over USB 
 Logitech G903 Gaming Mouse over USB 
 Logitech G903 Hero Gaming Mouse over USB 
 Logitech G920 Wheel over USB 
 Logitech G Pro Gaming Mouse over USB 
 MX5000 keyboard over Bluetooth 
 Dinovo Edge keyboard over Bluetooth 
 MX5500 keyboard over Bluetooth 
 M-RCQ142 V470 Cordless Laser Mouse over Bluetooth 
 MX Master mouse over Bluetooth 
 MX Ergo trackball over Bluetooth 
 MX Master 3 mouse over Bluetooth 
 SPDX-License-Identifier: GPL-2.0-or-later
  Debug support for HID Nintendo Wii  Wii U peripherals
  Copyright (c) 2011-2013 David Herrmann <dh.herrmann@gmail.com>
 SPDX-License-Identifier: GPL-2.0-only
  HID driver for CMedia CM6533 audio jack controls
  and HS100B mute buttons
  Copyright (C) 2015 Ben Chen <ben_chen@bizlinktech.com>
  Copyright (C) 2021 Thomas Wei√üschuh <linux@weissschuh.net>
 Fixed report descriptor of HS-100B audio chip
  Bit 4 is an abolute Microphone mute usage instead of being unassigned.
  Usage Page (Consumer),          
  Usage (Consumer Control),       
  Collection (Application),       
      Logical Minimum (0),        
      Logical Maximum (1),        
      Usage (Volume Inc),         
      Usage (Volume Dec),         
      Report Size (1),            
      Report Count (2),           
      Input (Variable),           
      Usage (Mute),               
      Report Count (1),           
      Input (Variable, Relative), 
      Usage Page (Telephony),     
      Usage (2Fh),                
      Input (Variable),           
      Usage (20h),                
      Input (Variable, Relative), 
      Usage Page (Consumer),      
      Usage (00h),                
      Report Count (3),           
      Input (Variable),           
      Logical Maximum (255),      
      Usage (00h),                
      Report Size (8),            
      Report Count (3),           
      Input (Variable),           
      Usage (00h),                
      Report Count (4),           
      Output (Variable),          
  End Collection                  
CM6533 audio jack HID raw events:
Plug in:
01000600 002083xx 080008c0 10000000
about 3 seconds later...
01000a00 002083xx 08000380 10000000
01000600 002083xx 08000380 10000000
Plug out:
01000400 002083xx 080008c0 x0000000
 SPDX-License-Identifier: GPL-2.0-only
    Copyright (C) 2010-2012 by Bruno Pr√©mont <bonbons@linux-vserver.org>  
    Based on Logitech G13 driver (v0.4)                                   
      Copyright (C) 2009 by Rick L. Vinyard, Jr. <rvinyard@cs.nmsu.edu>   
 Framebuffer
  The PicoLCD use a Topway LCD module of 256x64 pixel
  This display area is tiled over 4 controllers with 8 tiles
  each. Each tile has 8x64 pixel, each data byte representing
  a 1-bit wide vertical line of the tile.
  The display can be updated at a tile granularity.
        Chip 1           Chip 2           Chip 3           Chip 4
  +----------------+----------------+----------------+----------------+
  |     Tile 1     |     Tile 1     |     Tile 1     |     Tile 1     |
  +----------------+----------------+----------------+----------------+
  |     Tile 2     |     Tile 2     |     Tile 2     |     Tile 2     |
  +----------------+----------------+----------------+----------------+
                                   ...
  +----------------+----------------+----------------+----------------+
  |     Tile 8     |     Tile 8     |     Tile 8     |     Tile 8     |
  +----------------+----------------+----------------+----------------+
 Framebuffer visual structures 
 Send a given tile to PicoLCD 
 Translate a single tile
 Oops, we should never get here! 
 Reconfigure LCD display 
 schedule first output of framebuffer 
 Update fb_vbitmap from the screen_base and send changed tiles to device 
	
	  Translate the framebuffer into the format needed by the PicoLCD.
	  See display layout above.
	  Do this one tile after the other and push those tiles that changed.
	 
	  Wait for our IO to complete as otherwise we might flood the queue!
 Stub to call the system default and update the image on the picoLCD 
 Stub to call the system default and update the image on the picoLCD 
 Stub to call the system default and update the image on the picoLCD 
  this is the slow path from userspace. they can seek and write to
  the fb. it's inefficient to do anything less than a full screen draw
 We let fb notification do this for us via lcdbacklight device 
 make sure no work is deferred 
 No thridparty should ever unregister our framebuffer! 
 only allow 18 bit depth (8-bit is grayscale) 
 switch between 18 bit depths 
 translate FB content to new bits-per-pixel 
 Callback from deferred IO workqueue 
  The "fb_update_rate" sysfs attribute
 initialize Framebuffer device 
	 The extra memory is:
	  - 256u32 for pseudo_palette
	  - struct fb_deferred_io
 disconnect framebuffer from HID dev 
	 make sure there is no running update - thus that fbdata->picolcd
	  once obtained under lock is guaranteed not to get free() under
 SPDX-License-Identifier: GPL-2.0-or-later
   HID support for Linux
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2006-2012 Jiri Kosina
  Version Information
  Register a new report for a device.
  Register a new field for this report.
  Open a collection. The typeusage is pushed on the stack.
  Close a collection.
  Climb up the stack, search for the specified collection type
  and return the usage.
 we know nothing about this usage type 
  Concatenate usage which defines 16 bits or less with the
  currently defined usage page to form a 32 bit usage
  Add a usage to the temporary parser table.
	
	  If Usage item only includes usage id, concatenate it with
	  currently defined usage page
  Register a new field for this report.
 Handle both signed and unsigned cases properly 
 Total size check: Allow for possible report index byte 
 Ignore padding fields 
 Duplicate the last usage we parsed if we have excess values 
  Read data value from item.
  Process a global item.
		 Many devices provide unit exponent as a two's complement
		  nibble due to the common misunderstanding of HID
		  specification 1.11, 6.2.2.7 Global Items. Attempt to handle
  Process a local item.
			
			  We treat items before the first delimiter
			  as global to all usage sets (branch 0).
			  In the moment we process only these global
			  items and the first delimiter set.
			
			  We do not warn if the name is not set, we are
			  actually pre-scanning the device.
  Concatenate Usage Pages into Usages where relevant:
  As per specification, 6.2.2.8: "When the parser encounters a main item it
  concatenates the last declared Usage Page with a Usage to form a complete
  usage value."
	
	  Concatenate usage page again only if last declared Usage Page
	  has not been already used in previous usages concatenation
 Ignore extended usages 
  Process a main item.
 Reset the local parser environment 
  Process a reserved item.
  Free a report and all registered fields. The field->usage and
  field->value table's are allocated behind the field, so we need
  only to free(field) itself.
  Close report. This function returns the device
  state to the point prior to hid_open_report().
  Free a device structure, all reports, and all fields.
  Fetch a report description item from the data stream. We support long
  items, though they are not used yet.
 ignore constant inputs, they will be ignored by hid-input 
 Reset the local parser environment 
  Scan a report descriptor before the device is added to the bus.
  Sets device groups and other properties that determine what driver
  to load.
	
	  The parsing is simpler than the one in hid_open_report() as we should
	  be robust against hid errors. Those errors will be raised by
	  hid_open_report() anyway.
	
	  Handle special flags set during scanning.
	
	  Vendor specific handlings
				
				  hid-rmi should take care of them,
				  not hid-generic
  hid_parse_report - parse device report
  @hid: hid device
  @start: report start
  @size: report size
  Allocate the device report as read by the bus driver. This function should
  only be called from parse() in ll drivers.
  hid_validate_values - validate existing device report's value indexes
  @hid: hid device
  @type: which report type to examine
  @id: which report ID to examine (0 for first)
  @field_index: which report field to examine
  @report_counts: expected number of values
  Validate the number of values in a given field of a given report, after
  parsing.
	
	  Explicitly not using hid_get_report() here since it depends on
	  ->numbered being checked, which may not always be the case when
	  drivers go to access report values.
		
		  Validating on id 0 means we should examine the first
		  report in the list.
	
	  "Because OS implementations will generally divide the control's
	  reported count by the Effective Resolution Multiplier, designers
	  should take care not to establish a potential Effective
	  Resolution Multiplier of zero."
	  HID Usage Table, v1.12, Section 4.3.1, p31
	
	  Handling the unit exponent is left as an exercise to whoever
	  finds a device where that exponent is not 0.
 There are no devices with an effective multiplier > 255 
	
	  If multiplier_collection is NULL, the multiplier applies
	  to all fields in the report.
	  Otherwise, it is the Logical Collection the multiplier applies to
	  but our field may be in a subcollection of that collection.
	
	  "The Resolution Multiplier control must be contained in the same
	  Logical Collection as the control(s) to which it is to be applied.
	  If no Resolution Multiplier is defined, then the Resolution
	  Multiplier defaults to 1.  If more than one control exists in a
	  Logical Collection, the Resolution Multiplier is associated with
	  all controls in the collection. If no Logical Collection is
	  defined, the Resolution Multiplier is associated with all
	  controls in the report."
	  HID Usage Table, v1.12, Section 4.3.1, p30
	 
	  Thus, search from the current collection upwards until we find a
	  logical collection. Then search all fields for that same parent
	  collection. Those are the fields the multiplier applies to.
	 
	  If we have more than one multiplier, it will overwrite the
	  applicable fields later.
  hid_setup_resolution_multiplier - set up all resolution multipliers
  @device: hid device
  Search for all Resolution Multiplier Feature Reports and apply their
  value to all matching Input items. This only updates the internal struct
  fields.
  The Resolution Multiplier is applied by the hardware. If the multiplier
  is anything other than 1, the hardware will send pre-multiplied events
  so that the same physical interaction generates an accumulated
 	accumulated_value = value   multiplier
  This may be achieved by sending
  - "value  multiplier" for each event, or
  - "value" but "multiplier" times as frequently, or
  - a combination of the above
  The only guarantee is that the same physical interaction always generates
  an accumulated 'value  multiplier'.
  This function must be called before any event processing and after
  any SetRequest to the Resolution Multiplier.
 Ignore if report count is out of bounds. 
  hid_open_report - open a driver-specific device report
  @device: hid device
  Parse a report description into a hid_device structure. Reports are
  enumerated, fields are attached to these reports.
  0 returned on success, otherwise nonzero error value.
  This function (or the equivalent hid_parse() macro) should only be
  called from probe() in drivers, before starting the device.
			
			  fetch initial values in case the device's
			  default multiplier isn't the recommended 1
  Convert a signed n-bit integer to signed 32-bit integer. Common
  cases are done through the compiler, the screwed things has to be
  done by hand.
  Convert a signed 32-bit integer to a signed n-bit integer.
  Extractimplement a data field fromto a little endian report (bit array).
  Code sort-of follows HID spec:
      http:www.usb.orgdevelopershidpageHID1_11.pdf
  While the USB HID spec allows unlimited length bit fields in "report
  descriptors", most devices never use more than 16 bits.
  One model of UPS is claimed to report "LINEV" as a 32-bit field.
  Search linux-kernel and linux-usb-devel archives for "hid-core extract".
  "implement" : set bits in a little endian bit stream.
  Same concepts as "extract" (see comments above).
  The data mangled in the bit stream remains in little endian
  order the whole time. It make more sense to talk about
  endianness of register values by considering a register
  a "cached" copy of the little endian bit stream.
 last nibble 
  Search an array for a value.
  hid_match_report - check if driver's raw_event should be called
  @hid: hid device
  @report: hid report to match against
  compare hid->driver->report_table->report_type to report->type
 NULL means all 
  hid_match_usage - check if driver's event should be called
  @hid: hid device
  @usage: usage to match against
  compare hid->driver->usage_table->usage_{type,code} to
  usage->usage_{type,code}
 NULL means all 
  Analyse a received field, and fetch the data from it. The field
  content is stored for next report processing (we do differential
  reporting to the layer).
 Ignore report if ErrorRollOver 
  Output the field into the report.
 signed values 
 unsigned values 
  Compute the size of a report.
  Create a report. 'data' has to be allocated using
  hid_alloc_report_buf() so that it has proper size.
  Allocator for buffer that is going to be passed to hid_output_report()
	
	  7 extra bytes are necessary to achieve proper functionality
	  of implement() working on 8 byte chunks
  Set a field value. The report this field belongs to has to be
  created and transferred to the device, to set this value in the
  device.
 Normally report number is 0 
 Device uses numbered reports, data[0] is report number 
  Implement a generic .request() callback, using .raw_request()
  DO NOT USE in hid drivers directly, but through hid_hw_request instead.
  hid_input_report - report data from lower layer (usb, bt...)
  @hid: hid device
  @type: HID report type (HID__REPORT)
  @data: report contents
  @size: size of data parameter
  @interrupt: distinguish between interrupt and control transfers
  This is data entry for lower layers.
 Avoid unnecessary overhead if debugfs is disabled 
	 Drivers with the ->raw_event callback set are not required to connect
  hid_hw_start - start underlying HW
  @hdev: hid device
  @connect_mask: which outputs to connect, see HID_CONNECT_
  Call this in probe function after hid_parse. This will setup HW
  buffers and start the device (if not defeirred to device open).
  hid_hw_stop must be called if this was successful.
  hid_hw_stop - stop underlying HW
  @hdev: hid device
  This is usually called from remove function or from probe when something
  failed and hid_hw_start was called already.
  hid_hw_open - signal underlying HW to start delivering events
  @hdev: hid device
  Tell underlying HW to start delivering events from the device.
  This function should be called sometime after successful call
  to hid_hw_start().
  hid_hw_close - signal underlaying HW to stop delivering events
  @hdev: hid device
  This function indicates that we are not interested in the events
  from this device anymore. Delivery of events may or may not stop,
  depending on the number of users still outstanding.
  new_id_store - add a new HID device ID to this driver and re-probe devices
  @drv: target device driver
  @buf: buffer for scanning device ID data
  @count: input size
  Adds a new dynamic hid device ID to this driver,
  and causes the driver to probe for all devices again.
  hid_compare_device_paths - check if both devices share the same path
  @hdev_a: hid device
  @hdev_b: hid device
  @separator: char to use as separator
  Check if two devices share the same path up to the last occurrence of
  the separator char. Both paths must exist (i.e., zero-length paths
  don't match).
			
			  hid-generic implements .match(), so if
			  hid_ignore_special_drivers is set, we can safely
			  return.
 reset the quirks that has been previously set 
 default probe 
 default remove 
	 we need to kill them here, otherwise they will stay allocated to
	
	  Check for the mandatory transport channel.
	
	  Read the device report descriptor once and use as template
	  for the driver-specific modifications.
	
	  Scan generic devices for group information
	 XXX hack, any other cleaner solution after the driver core
  hid_allocate_device - allocate new hid device descriptor
  Allocate and initialize hid device, so that hid_destroy_device might be
  used to free it.
  New hid_device pointer is returned on success, otherwise ERR_PTR encoded
  error value.
  hid_destroy_device - free previously allocated device
  @hdev: hid device
  If you allocate hid_device through hid_allocate_device, you should ever
  free by this function.
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for Saitek devices.
   PS1000 (USB gamepad):
   Fixes the HID report descriptor by removing a non-existent axis and
   clearing the constant bit on the input reports for buttons and d-pad.
   (This module is based on "hid-ortek".)
   Copyright (c) 2012 Andreas H√ºbner
   R.A.T.7, R.A.T.9, M.M.O.7 (USB gaming mice):
   Fixes the mode button which cycles through three constantly pressed
   buttons. All three press events are mapped to one button and the
   missing release event is generated immediately.
 convert spurious axis to a "noop" Logical Minimum (0) 
 clear constant bit on buttons and d-pad 
 R.A.T.7 uses bits 13, 14, 15 for the mode 
 clear mode bits 
 use bit 13 as the mode button 
 M.M.O.7 uses bits 8, 22, 23 for the mode 
 clear mode bits 
				 use bit 8 as the mode button, bits 22
				  and 23 do not represent buttons
				  according to the HID report descriptor
 report missing release event 
 SPDX-License-Identifier: GPL-2.0
  HID driver for Maltron L90
  Copyright (c) 1999 Andreas Gal
  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
  Copyright (c) 2008 Jiri Slaby
  Copyright (c) 2012 David Dillow <dave@thedillows.org>
  Copyright (c) 2006-2013 Jiri Kosina
  Copyright (c) 2013 Colin Leitner <colin.leitner@gmail.com>
  Copyright (c) 2014-2016 Frank Praznik <frank.praznik@gmail.com>
  Copyright (c) 2010 Richard Nauber <Richard.Nauber@gmail.com>
  Copyright (c) 2016 Yuxuan Shui <yshuiv7@gmail.com>
  Copyright (c) 2018 William Whistler <wtbw@wtbw.co.uk>
 The original buggy USB descriptor 
 Usage Page (Generic Desktop Ctrls) 
 Usage (Sys Control)                
 Collection (Application)           
   Report ID (2)                    
   Report Size (1)                  
   Report Count (1)                 
   Logical Minimum (0)              
   Logical Maximum (1)              
   Usage (Sys Sleep)                
   Input (Data,Var,Rel)             
   Usage (Sys Sleep)                
   Input (Data,Var,Rel)             
   Usage (Sys Wake Up)              
   Input (Data,Var,Rel)             
   Report Size (5)                  
   Input (Const,Array,Abs)          
 End Collection                     
 Usage Page (Consumer)              
 Usage (Consumer Control)           
 Collection (Application)           
   Report ID (3)                    
   Report Count (1)                 
   Report Size (16)                 
   Usage Minimum (Unassigned)       
   Usage Maximum (0x7FFF)           
   Input (Data,Array,Abs)           
 End Collection                     
 Usage Page (Vendor Defined 0xFF7F) 
 Usage (0x01)                       
 Collection (Application)           
   Report ID (4)                    
   Report Count (1)                 
   Report Size (16)                 
   Usage Minimum (0x00)             
   Usage Maximum (0x7FFF)           
   Input (Data,Array,Abs)           
   Report Size (2)                  
   Logical Maximum (2)              
   Usage (0x90)                     
   Feature (Data,Var,Abs)           
   Report Size (6)                  
   Feature (Const,Array,Abs)        
   Report Size (1)                  
   Logical Maximum (1)              
   Usage Page (LEDs)                
   Usage (On-Line)                  
   Output (Data,Var,Abs)            
   Usage (Generic Indicator)        
   Output (Data,Var,Abs)            
   Report Size (6)                  
   Report Count (1)                 
   Output (Const,Array,Abs)         
 End Collection                     
 The patched descriptor, allowing media key events to be accepted as valid 
 Usage Page (Generic Desktop Ctrls) 
 Usage (Sys Control)                
 Collection (Application)           
   Report ID (2)                    
   Report Size (1)                  
   Report Count (1)                 
   Logical Minimum (0)              
   Logical Maximum (1)              
   Usage (Sys Sleep)                
   Input (Data,Var,Rel)             
   Usage (Sys Sleep)                
   Input (Data,Var,Rel)             
   Usage (Sys Wake Up)              
   Input (Data,Var,Rel)             
   Report Size (5)                  
   Input (Const,Array,Abs)          
 End Collection                     
 Usage Page (Consumer)              
 Usage (Consumer Control)           
 Collection (Application)           
   Report ID (3)                    
   Logical Minimum (0)              - changed 
   Logical Maximum (32767)          - changed 
   Report Count (1)                 
   Report Size (16)                 
   Usage Minimum (Unassigned)       
   Usage Maximum (0x7FFF)           
   Input (Data,Array,Abs)           
 End Collection                     
 Usage Page (Vendor Defined 0xFF7F) 
 Usage (0x01)                       
 Collection (Application)           
   Report ID (4)                    
   Report Count (1)                 
   Report Size (16)                 
   Usage Minimum (0x00)             
   Usage Maximum (0x7FFF)           
   Input (Data,Array,Abs)           
   Report Size (2)                  
   Logical Maximum (2)              
   Usage (0x90)                     
   Feature (Data,Var,Abs)           
   Report Size (6)                  
   Feature (Const,Array,Abs)        
   Report Size (1)                  
   Logical Maximum (1)              
   Usage Page (LEDs)                
   Usage (On-Line)                  
   Output (Data,Var,Abs)            
   Usage (Generic Indicator)        
   Output (Data,Var,Abs)            
   Report Size (6)                  
   Report Count (1)                 
   Output (Const,Array,Abs)         
 End Collection                     
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for TopSeed Cyberlink remote
   Copyright (c) 2008 Lev Babiev
   based on hid-cherry driver
   Modified to also support BTC "Emprex 3009URF III Vista MCE Remote" by
   Wayne Thomas 2010.
   Modified to support Conceptronic CLLRCMCE by
   Kees Bakker 2010.
 SPDX-License-Identifier: GPL-2.0-or-later
   HID driver for N-Trig touchscreens
   Copyright (c) 2008-2010 Rafi Rubin
   Copyright (c) 2009-2010 Stephane Chatty
 Incoming raw values for a single contact 
 The current activation state. 
 Empty frames to ignore before recognizing the end of activity 
 Frames to ignore before acknowledging the start of activity 
 Minimum size contact to accept 
 Threshold to override activation slack 
  This function converts the 4 byte raw firmware code into
  a string containing 5 comma separated numbers.
	
	  As yet unmapped bits:
	  0b11000000 0b11110001 0b00011000 0b00011000
	
	  No more than 8 terminal frames have been observed so far
	  and higher slack is highly likely to leave the single
	  touch emulation stuck down.
  this driver is aimed at two firmware versions in circulation:
   - dual penfinger single touch
   - finger multitouch, pen not working
 No special mappings needed for the pen and single touch 
 we do not want to map these for now 
 Not trustworthy, squelch for now 
 widthheight mapped on TouchMajorTouchMinorOrientation 
 we do not want to map these: no input-oriented meaning 
 No special mappings needed for the pen and single touch 
  this function is called upon all reports
  so that we can filter contact point information,
  decide whether we are in multi or single touch mode
  and call input_mt_sync after each point if necessary
 Skip processing if not a claimed input 
	 This function is being called before the structures are fully
 No special handling needed for the pen 
 Tag indicating the start of a multitouch group 
 Prevent emission of touch until validated 
 Clear the contact footer 
		
		  when in single touch mode, this is the last
		  report received in a finger event. We want
		  to emit a normal (X, Y) position
			
			  TipSwitch indicates the presence of a
			  finger in single touch mode.
		
		  we receive this when the device is in multitouch
		  mode. The first of the three values tagged with
		  this usage tells if the contact point is real
		  or a placeholder
 Shouldn't get more than 4 footer packets, so skip 
 if the footer isn't complete break 
 Pen activity signal. 
			
			  When the pen deactivates touch, we see a
			  bogus frame with ContactCount > 0.
			  We can
			  save a bit of work by ensuring act_state < 0
			  even if deactivation slack is turned off.
		
		  The first footer value indicates the presence of a
		  finger.
			
			  We do not want to process contacts under
			  the size threshold, but do not want to
			  ignore them for activation state
			
			  Contact meets the activation size threshold
					
					  first contact, activate now
					
					  avoid corrupting this frame
					  but ensure next frame will
					  be active
				
				  Defer adjusting the activation state
				  until the end of the frame.
 Discarding this contact 
 emit a normal (X, Y) for the first point only 
			
			  TipSwitch is superfluous in multitouch
			  mode.  The footer events tell us
			  if there is a finger on the screen or
			  not.
 Emit MT events 
		
		  Translate from height and width to size
		  and orientation.
 End of a multitouch group 
 Just to be sure 
		
		  Activation state machine logic:
		 
		  Fundamental states:
		 	state >  0: Inactive
		 	state <= 0: Active
		 	state <  -deactivate_slack:
		 		 Pen termination of touch
		 
		  Specific values of interest
		 	state == activate_slack
		 		 no valid input since the last reset
		 
		 	state == 0
		 		 general operational state
		 
		 	state == -deactivate_slack
		 		 read sufficient empty frames to accept
		 		 the end of input and reset
 Currently inactive 
				
				  Consider each live contact as
				  evidence of intentional activity.
				
				  Empty frame before we hit the
				  activity threshold, reset.
			
			  Entered this block inactive and no
			  coordinates sent this frame, so hold off
			  on button state.
 Currently active 
				
				  Live point: clear accumulated
				  deactivation count.
				
				  We've consumed the deactivation
				  slack, time to deactivate and reset.
 Move towards deactivation 
			
			  Check to see if we're ready to start
			  emitting touch events.
			 
			  Note: activation slack will decrease over
			  the course of the frame, and it will be
			  inconsistent from the start to the end of
			  the frame.  However if the frame starts
			  with slack, first_contact_touch will still
			  be 0 and we will not get to this point.
 fall-back to the generic hidinput handling 
 we have handled the hidinput part, now remains hiddev 
		 These keys are redundant for fingers, clear them
		
		  The physical touchscreen (single touch)
		  input has a value for physical, whereas
		  the multitouch only has logical input
		  fields.
 This is needed for devices with more recent firmware versions 
		 Let the device settle to ensure the wakeup message gets
		
		  Sanity check: if the current mode is invalid reset it to
		  something reasonable.
 SPDX-License-Identifier: GPL-2.0-or-later
   HID quirks support for Linux
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2006-2007 Jiri Kosina
   Copyright (c) 2007 Paul Walmsley
  Alphabetically sorted by vendor then product.
  A list of devices for which there is a specialized driver on HID bus.
  Please note that for multitouch devices (driven by hid-multitouch driver),
  there is a proper autodetection and autoloading in place (based on presence
  of HID_DG_CONTACTID), so those devices don't need to be added to this list,
  as we are doing the right thing in hid_scan_usage().
  Autodetection for (USB) HID sensor hubs exists too. If a collection of type
  physical is found inside a usage page of type sensor, hid-sensor-hub will be
  used as a driver. See hid_scan_report().
 a list of devices that shouldn't be handled by HID core at all 
  hid_mouse_ignore_list - mouse devices which should not be handled by the hid layer
  There are composite devices for which we want to ignore only a certain
  interface. This is a list of devices for which only the mouse interface will
  be ignored. This allows a dedicated driver to take care of the interface.
 appletouch driver 
 ignore all Code Mercenaries IOWarrior devices 
		
		  The Keene FM transmitter USB device has the same USB ID as
		  the Logitech AudioHub Speaker, but it should ignore the hid.
		  Check if the name is that of the Keene device.
		  For reference: the name of the AudioHub is
		  "HOLTEK  AudioHub Speaker".
 These are not HID devices.  They are handled by comedi. 
		 Masterkit MA901 usb radio based on Atmel tiny85 chip and
		  it has the same USB ID as many Atmel V-USB devices. This
		  usb radio is handled by radio-ma901.c driver so we want
		  ignore the hid. Check the name, bus, product and ignore
		  if we have MA901 usb radio.
		
		  Blacklist of everything that gets handled by the elan_i2c
		  input driver.  This avoids disabling valid touchpads and
		  other ELAN devices.
 Dynamic HID quirks list - specified at runtime 
 Runtime ("dynamic") quirks manipulation functions 
  hid_exists_dquirk - find any dynamic quirks for a HID device
  @hdev: the HID device to match
  Description:
          Scans dquirks_list for a matching dynamic quirk and returns
          the pointer to the relevant struct hid_device_id if found.
          Must be called with a read lock held on dquirks_lock.
  Return: NULL if no quirk found, struct hid_device_id  if found.
  hid_modify_dquirk - addreplace a HID quirk
  @id: the HID device to match
  @quirks: the unsigned long quirks value to addreplace
  Description:
          If an dynamic quirk exists in memory for this device, replace its
          quirks value with what was provided.  Otherwise, add the quirk
          to the dynamic quirks list.
  Return: 0 OK, -error on failure.
  hid_remove_all_dquirks - remove all runtime HID quirks from memory
  @bus: bus to match against. Use HID_BUS_ANY if all need to be removed.
  Description:
          Free all memory associated with dynamic quirks - called before
          module unload.
  hid_quirks_init - apply HID quirks specified at module load time
  @quirks_param: array of quirks strings (vendor:product:quirks)
  @bus: bus type
  @count: number of quirks to check
  hid_quirks_exit - release memory associated with dynamic_quirks
  @bus: a bus to match against
  Description:
      Release all memory associated with dynamic quirks for a given bus.
      Called upon module unload.
      Use HID_BUS_ANY to remove all dynamic quirks.
  Returns: nothing
  hid_gets_squirk - return any static quirks for a HID device
  @hdev: the HID device to match
  Description:
      Given a HID device, return a pointer to the quirked hid_device_id entry
      associated with that device.
  Return: the quirks.
  hid_lookup_quirk - return any quirks associated with a HID device
  @hdev: the HID device to look for
  Description:
      Given a HID device, return any quirks associated with that device.
  Return: an unsigned long quirks value.
 NCR devices must not be queried for reports 
 These devices must be ignored if version (bcdDevice) is too old 
 SPDX-License-Identifier: GPL-2.0-only
    Copyright (C) 2010-2012 by Bruno Pr√©mont <bonbons@linux-vserver.org>  
    Based on Logitech G13 driver (v0.4)                                   
      Copyright (C) 2009 by Rick L. Vinyard, Jr. <rvinyard@cs.nmsu.edu>   
 CONFIG_PM 
 SPDX-License-Identifier: GPL-2.0+
  Surface System Aggregator Module (SSAM) HID transport driver for the legacy
  keyboard interface (KBDTC=0x08 subsystem). Provides support for the
  integrated HID keyboard on Surface Laptops 1 and 2.
  Copyright (C) 2019-2021 Maximilian Luz <luzmaximilian@gmail.com>
 -- SAM interface (KBD). -------------------------------------------------- 
 6 + report ID 
	
	  Check against device UID manually, as registry and device target
	  category doesn't line up.
 -- Transport driver (KBD). ----------------------------------------------- 
 Get LED field. 
 Check if we got the correct report. 
 Get caps lock LED index. 
 Extract value. 
 Only caps LED output reports are supported. 
	
	  The keyboard only has a single hard-coded read-only feature report
	  of size KBD_FEATURE_REPORT_SIZE. Try to load it and compare its
	  report ID against the requested one.
 Not supported. See skbd_get_feature_report() for details. 
 -- Driver setup. --------------------------------------------------------- 
 Add device link to EC. 
 SPDX-License-Identifier: GPL-2.0+
  Surface System Aggregator Module (SSAM) HID transport driver for the
  generic HID interface (HIDTC=0x15 subsystem). Provides support for
  integrated HID devices on Surface Laptop 3, Book 3, and later.
  Copyright (C) 2019-2021 Bla≈æ Hrastnik <blaz@mxxn.io>,
                          Maximilian Luz <luzmaximilian@gmail.com>
 -- SAM interface. -------------------------------------------------------- 
	
	  Note: The 0x76 above has been chosen because that's what's used by
	  the Windows driver. Together with the header, this leads to a 128
	  byte payload in total.
 Don't mess stuff up in case we receive garbage. 
 -- Transport driver. ----------------------------------------------------- 
 -- Driver setup. --------------------------------------------------------- 
 SPDX-License-Identifier: GPL-2.0+
  Commoncore components for the Surface System Aggregator Module (SSAM) HID
  transport driver. Provides support for integrated HID devices on Microsoft
  Surface models.
  Copyright (C) 2019-2021 Maximilian Luz <luzmaximilian@gmail.com>
 -- Device descriptor access. --------------------------------------------- 
 -- Transport driver (common). -------------------------------------------- 
 Note: This call will log errors for us, so ignore them here. 
 -- Common device setup. -------------------------------------------------- 
 -- PM ops. --------------------------------------------------------------- 
 CONFIG_PM_SLEEP 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-only
  ISHTP client driver for HID (ISH)
  Copyright (c) 2014-2016, Intel Corporation.
 ISH Transport protocol (ISHTP in short) GUID 
 Rx ring buffer pool size 
  report_bad_packet() - Report bad packets
  @hid_ishtp_cl:	Client instance to get stats
  @recv_buf:		Raw received host interface message
  @cur_pos:		Current position index in payload
  @payload_len:	Length of payload expected
  Dumps error in case bad packet is received
  process_recv() - Received and parse incoming packet
  @hid_ishtp_cl:	Client instance to get stats
  @recv_buf:		Raw received host interface message
  @data_len:		length of the message
  Parse the incoming packet. If it is a response packet then it will update
  per instance flags and wake up the caller waiting to for the response.
 Sanity checks 
 Get index of device that matches this id 
 Get index of device that matches this id 
  ish_cl_event_cb() - bus driver callback for incoming messagepacket
  @device:	Pointer to the the ishtp client device for which this message
 		is targeted
  Remove the packet from the list and process the message by calling
  process_recv
 decide what to do with received data 
  hid_ishtp_set_feature() - send request to ISH FW to set a feature request
  @hid:	hid device instance for this request
  @buf:	feature buffer
  @len:	Length of feature buffer
  @report_id:	Report id for the feature set request
  This is called from hid core .request() callback. This function doesn't wait
  for response.
  hid_ishtp_get_report() - request to get featureinput report
  @hid:	hid device instance for this request
  @report_id:	Report id for the get request
  @report_type:	Report type for the this request
  This is called from hid core .request() callback. This function will send
  request to FW and return without waiting for response.
  ishtp_hid_link_ready_wait() - Wait for link ready
  @client_data:	client data instance
  If the transport link started suspend process, then wait, till either
  resumed or timeout
  Return: 0 on success, non zero on error
  ishtp_enum_enum_devices() - Enumerate hid devices
  @hid_ishtp_cl:	client instance
  Helper function to send request to firmware to enumerate HID devices
  Return: 0 on success, non zero on error
 Send HOSTIF_DM_ENUM_DEVICES 
 Send HOSTIF_DM_ENUM_DEVICES 
  ishtp_get_hid_descriptor() - Get hid descriptor
  @hid_ishtp_cl:	client instance
  @index:		Index into the hid_descr array
  Helper function to send request to firmware get HID descriptor of a device
  Return: 0 on success, non zero on error
 Get HID descriptor 
  ishtp_get_report_descriptor() - Get report descriptor
  @hid_ishtp_cl:	client instance
  @index:		Index into the hid_descr array
  Helper function to send request to firmware get HID report descriptor of
  a device
  Return: 0 on success, non zero on error
 Get report descriptor 
  hid_ishtp_cl_init() - Init function for ISHTP client
  @hid_ishtp_cl:	ISHTP client instance
  @reset:		true if called for init after reset
  This function complete the initializtion of the client. The summary of
  processing:
  - Send request to enumerate the hid clients
 	Get the HID descriptor for each enumearated device
 	Get report description of each device
 	Register each device wik hid core by calling ishtp_hid_probe
  Return: 0 on success, non zero on error
 Connect to FW client 
 Register read callback 
 for() on all hid devices 
  hid_ishtp_cl_deinit() - Deinit function for ISHTP client
  @hid_ishtp_cl:	ISHTP client instance
  Unlink and free hid client
 disband and free all Tx and Rx client-level rings 
  hid_ishtp_cl_probe() - ISHTP client driver probe
  @cl_device:		ISHTP client device instance
  This function gets called on device create on ISHTP bus
  Return: 0 on success, non zero on error
  hid_ishtp_cl_remove() - ISHTP client driver remove
  @cl_device:		ISHTP client device instance
  This function gets called on device remove on ISHTP bus
  Return: 0
  hid_ishtp_cl_reset() - ISHTP client driver reset
  @cl_device:		ISHTP client device instance
  This function gets called on device reset on ISHTP bus
  Return: 0
  hid_ishtp_cl_suspend() - ISHTP client driver suspend
  @device:	device instance
  This function gets called on system suspend
  Return: 0
  hid_ishtp_cl_resume() - ISHTP client driver resume
  @device:	device instance
  This function gets called on system resume
  Return: 0
 Register ISHTP client device driver with ISHTP Bus 
 Primary author 
  Several modification for multi instance support
  suspendresume and clean up
 SPDX-License-Identifier: GPL-2.0-only
  ISHTP-HID glue driver.
  Copyright (c) 2012-2016, Intel Corporation.
  ishtp_hid_parse() - hid-core .parse() callback
  @hid:	hid device instance
  This function gets called during call to hid_add_device
  Return: 0 on success and non zero on error
 Empty callbacks with success return code 
		
		  Spare 7 bytes for 64b accesses through
		  getput_unaligned_le64()
  ishtp_hid_request() - hid-core .request() callback
  @hid:	hid device instance
  @rep:	pointer to hid_report
  @reqtype:	type of req. [GET|SET]_REPORT
  This function is used to setget feaureinput report.
 the specific report length, just HID part of it 
		
		  Spare 7 bytes for 64b accesses through
		  getput_unaligned_le64()
  ishtp_wait_for_response() - hid-core .wait() callback
  @hid:	hid device instance
  This function is used to wait after get feaureinput report.
  Return: 0 on success and non zero on error
  ishtp_hid_wakeup() - Wakeup caller
  @hid:	hid device instance
  This function will wakeup caller waiting for GetSet feature report
  ishtp_hid_probe() - hid register ll driver
  @cur_hid_dev:	Index of hid device calling to register
  @client_data:	Client data pointer
  This function is used to allocate and add HID device.
  Return: 0 on success, non zero on error
  ishtp_hid_remove() - Remove registered hid device
  @client_data:	client data pointer
  This function is used to destroy allocatd HID device.
 SPDX-License-Identifier: GPL-2.0
  ISH-TP client driver for ISH firmware loading
  Copyright (c) 2019, Intel Corporation.
 Number of times we attempt to load the firmware before giving up 
 ISH TXRX ring buffer pool size 
  ISH Shim firmware loader reserves 4 Kb buffer in SRAM. The buffer is
  used to temporarily hold the data transferred from host to Shim
  firmware loader. Reason for the odd size of 3968 bytes? Each IPC
  transfer is 128 bytes (= 4 bytes header + 124 bytes payload). So the
  4 Kb buffer can hold maximum of 32 IPC transfers, which means we can
  have a max payload of 3968 bytes (= 32 x 124 payload).
  enum ish_loader_commands -	ISH loader host commands.
  @LOADER_CMD_XFER_QUERY:	Query the Shim firmware loader for
 				capabilities
  @LOADER_CMD_XFER_FRAGMENT:	Transfer one firmware image fragment at a
 				time. The command may be executed
 				multiple times until the entire firmware
 				image is downloaded to SRAM.
  @LOADER_CMD_START:		Start executing the main firmware.
 Command bit mask 
  ISH firmware max delay for one transmit failure is 1 Hz,
  and firmware will retry 2 times, so 3 Hz is used for timeout.
  Loader transfer modes:
  LOADER_XFER_MODE_ISHTP mode uses the existing ISH-TP mechanism to
  transfer data. This may use IPC or DMA if supported in firmware.
  The buffer size is limited to 4 Kb by the IPCISH-TP protocol for
  both IPC & DMA (legacy).
  LOADER_XFER_MODE_DIRECT_DMA - firmware loading is a bit different
  from the sensor data streaming. Here we download a large (300+ Kb)
  image directly to ISH SRAM memory. There is limited benefit of
  DMA'ing 300 Kb image in 4 Kb chucks limit. Hence, we introduce
  this "direct dma" mode, where we do not use ISH-TP for DMA, but
  instead manage the DMA directly in kernel driver and Shim firmware
  loader (allocate buffer, break in chucks and transfer). This allows
  to overcome 4 Kb limit, and optimize the data flow path in firmware.
 ISH Transport Loader client unique GUID 
  The firmware loading latency will be minimum if we can DMA the
  entire ISH firmware image in one go. This requires that we allocate
  a large DMA buffer in kernel, which could be problematic on some
  platforms. So here we limit the DMA buffer size via a module_param.
  We default to 4 pages, but a customer can set it to higher limit if
  deemed appropriate for his platform.
  struct loader_msg_hdr - Header for ISH Loader commands.
  @command:		LOADER_CMD commands. Bit 7 is the response.
  @reserved:		Reserved space
  @status:		Command response status. Non 0, is error
 			condition.
  This structure is used as header for every commanddata sentreceived
  between Host driver and ISH Shim firmware loader.
 only for dma mode, multiples of cacheline 
 variable length payload here 
  struct response_info - Encapsulate firmware response related
 			information for passing between function
 			loader_cl_send() and process_recv() callback.
  @data:		Copy the data received from firmware here.
  @max_size:		Max size allocated for the @data buffer. If the
 			received data exceeds this value, we log an
 			error.
  @size:		Actual size of data received from firmware.
  @error:		Returns 0 for success, negative error code for a
 			failure in function process_recv().
  @received:		Set to true on receiving a valid firmware
 			response to host command
  @wait_queue:		Wait queue for Host firmware loading where the
 			client sends message to ISH firmware and waits
 			for response
  struct ishtp_cl_data - Encapsulate per ISH-TP Client Data.
  @work_ishtp_reset:	Work queue for reset handling.
  @work_fw_load:	Work queue for host firmware loading.
  @flag_retry:		Flag for indicating host firmware loading should
 			be retried.
  @retry_count:	Count the number of retries.
  This structure is used to store data per client.
	
	  Used for passing firmware response information between
	  loader_cl_send() and process_recv() callback.
	
	  In certain failure scenrios, it makes sense to reset the ISH
	  subsystem and retry Host firmware loading (e.g. bad message
	  packet, ENOMEM, etc.). On the other hand, failures due to
	  protocol mismatch, etc., are not recoverable. We do not
	  retry them.
	 
	  If set, the flag indicates that we should re-try the
	  particular failure.
  get_firmware_variant() - Gets the filename of firmware image to be
 			loaded based on platform variant.
  @client_data:	Client data instance.
  @filename:		Returns firmware filename.
  Queries the firmware-name device property string.
  Return: 0 for success, negative error code for failure.
  loader_cl_send()	Send message from host to firmware
  @client_data:	Client data instance
  @out_msg:		Message buffer to be sent to firmware
  @out_size:		Size of out going message
  @in_msg:		Message buffer where the incoming data copied.
 			This buffer is allocated by calling
  @in_size:		Max size of incoming message
  Return: Number of bytes copied in the in_msg on success, negative
  error code on failure.
 Setup in coming buffer & size 
  process_recv() -	Receive and parse incoming packet
  @loader_ishtp_cl:	Client instance to get stats
  @rb_in_proc:		ISH received message buffer
  Parse the incoming packet. If it is a response packet then it will
  update received and wake up the caller waiting to for the response.
 Sanity check 
	
	  All firmware messages have a header. Check buffer size
	  before accessing elements inside.
 We expect only "response" messages from firmware 
 Update the actual received buffer size 
	
	  Copy the buffer received in firmware response for the
	  calling thread.
 Set flag before waking up the caller 
 Free the buffer 
 Wake the calling thread 
  loader_cl_event_cb() - bus driver callback for incoming message
  @cl_device:		Pointer to the ishtp client device for which this
 			message is targeted
  Remove the packet from the list and process the message by calling
  process_recv
 Process the data packet from firmware 
  ish_query_loader_prop() -  Query ISH Shim firmware loader
  @client_data:	Client data instance
  @fw:			Pointer to firmware data struct in host memory
  @fw_info:		Loader firmware properties
  This function queries the ISH Shim firmware loader for capabilities.
  Return: 0 for success, negative error code for failure.
 On success, the return value is the received buffer size 
 Save fw_info for use outside this function 
 Loader firmware properties 
 Sanity checks 
 For DMA the buffer size should be multiple of cacheline size 
  ish_fw_xfer_ishtp() - Loads ISH firmware using ishtp interface
  @client_data:	Client data instance
  @fw:			Pointer to firmware data struct in host memory
  This function uses ISH-TP to transfer ISH firmware from host to
  ISH SRAM. Lower layers may use IPC or DMA depending on firmware
  support.
  Return: 0 for success, negative error code for failure.
 Break the firmware image into fragments and send as ISH-TP payload 
 Free ISH buffer if not done already, in error case 
  ish_fw_xfer_direct_dma() - Loads ISH firmware using direct dma
  @client_data:	Client data instance
  @fw:			Pointer to firmware data struct in host memory
  @fw_info:		Loader firmware properties
  Host firmware load is a unique case where we need to download
  a large firmware image (200+ Kb). This function implements
  direct DMA transfer in kernel and ISH firmware. This allows
  us to overcome the ISH-TP 4 Kb limit, and allows us to DMA
  directly to ISH UMA at location of choice.
  Function depends on corresponding support in ISH firmware.
  Return: 0 for success, negative error code for failure.
	
	  payload_max_size should be set to minimum of
	   (1) Size of firmware to be loaded,
	   (2) Max DMA buffer size supported by Shim firmware,
	   (3) DMA buffer size limit set by boot_param dma_buf_size_limit.
	
	  Buffer size should be multiple of cacheline size
	  if it's not, select the previous cacheline boundary.
 Send the firmware image in chucks of payload_max_size 
		
		  Flush cache here because the dma_sync_single_for_device()
		  does not do for x86.
 Free ISH buffer if not done already, in error case 
  ish_fw_start() -	Start executing ISH main firmware
  @client_data:	client data instance
  This function sends message to Shim firmware loader to start
  the execution of ISH main firmware.
  Return: 0 for success, negative error code for failure.
  load_fw_from_host() - Loads ISH firmware from host
  @client_data:	Client data instance
  This function loads the ISH firmware to ISH SRAM and starts execution
  Return: 0 for success, negative error code for failure.
 Get filename of the ISH firmware to be loaded 
 Step 1: Query Shim firmware loader properties 
 Step 2: Send the main firmware image to be loaded, to ISH SRAM 
 Step 3: Start ISH main firmware exeuction 
 Keep a count of retries, and give up after 3 attempts 
  loader_init() -	Init function for ISH-TP client
  @loader_ishtp_cl:	ISH-TP client instance
  @reset:		true if called for init after reset
  Return: 0 for success, negative error code for failure
 Connect to firmware client 
 Disband and free all Tx and Rx client-level rings 
 Unlink, flush queues & start again 
 ISH firmware loading from host 
  loader_ishtp_cl_probe() - ISH-TP client driver probe
  @cl_device:		ISH-TP client device instance
  This function gets called on device create on ISH-TP bus
  Return: 0 for success, negative error code for failure
 ISH firmware loading from host 
  loader_ishtp_cl_remove() - ISH-TP client driver remove
  @cl_device:		ISH-TP client device instance
  This function gets called on device remove on ISH-TP bus
  Return: 0
	
	  The sequence of the following two cancel_work_sync() is
	  important. The work_fw_load can in turn schedue
	  work_ishtp_reset, so first cancel work_fw_load then
	  cancel work_ishtp_reset.
  loader_ishtp_cl_reset() - ISH-TP client driver reset
  @cl_device:		ISH-TP client device instance
  This function gets called on device reset on ISH-TP bus
  Return: 0
 SPDX-License-Identifier: GPL-2.0-only
  PCI glue for ISHTP provider device (ISH) driver
  Copyright (c) 2014-2016, Intel Corporation.
  ish_event_tracer() - Callback function to dump trace messages
  @dev:	ishtp device
  @format:	printf style format
  Callback to direct log messages to Linux trace buffers
  ish_init() - Init function
  @dev:	ishtp device
  This function initialize wait queues for suspendresume and call
  calls hadware initialization function. This will initiate
  startup sequence
  Return: 0 for success or error code for failure
 Set the state of ISH HW to start 
 Start the inter process communication to ISH processor 
 Mehlow platform special pci ids 
  ish_probe() - PCI driver probe callback
  @pdev:	pci device
  @ent:	pci device id
  Initialize PCI function, setup interrupt and call for ISH initialization
  Return: 0 for success or error code for failure
 Check for invalid platforms for ISH support 
 enable pci dev 
 set PCI host mastering 
 pci request regions for ISH driver 
 allocates and initializes the ISH dev structure 
 mapping IO device memory 
 request and enable interrupt 
 Enable PME for EHL 
  ish_remove() - PCI driver remove callback
  @pdev:	pci device
  This function does cleanup of ISH on pci remove callback
 50ms to get resume response 
  ish_resume_handler() - Work function to complete resume
  @work:	work struct
  The resume work function to complete resume function asynchronously.
  There are two resume paths, one where ISH is not powered off,
  in that case a simple resume message is enough, others we need
  a reset sequence.
 Waiting to get resume response 
		
		  If the flag is not cleared, something is wrong with ISH FW.
		  So on resume, need to go through init sequence again.
		
		  Resume from the D3, full reboot of ISH processor will happen,
		  so need to go through init sequence again.
  ish_suspend() - ISH suspend callback
  @device:	device pointer
  ISH suspend callback
  Return: 0 to the pm core
		
		  If previous suspend hasn't been asnwered then ISH is likely
		  dead, don't attempt nested notification
 25 ms should be enough for live ISH to flush all IPC buf 
			
			  It looks like FW halt, clear the DMA bit, and put
			  ISH into D3, and FW would reset on resume.
			
			  Save state so PCI core will keep the device at D0,
			  the ISH would enter D0i3
		
		  Clear the DMA bit before putting ISH into D3,
		  or ISH FW would reset automatically.
  ish_resume() - ISH resume callback
  @device:	device pointer
  ISH resume callback
  Return: 0 to the pm core
 add this to finish power flow for EHL 
 Original author 
 Adoption to upstream Linux kernel 
 SPDX-License-Identifier: GPL-2.0-only
  HW layer of ISHTP provider device (ISH)
  Copyright (c) 2014-2016, Intel Corporation.
 For FW reset flow 
  ish_reg_read() - Read register
  @dev: ISHTP device pointer
  @offset: Register offset
  Read 32 bit register at a given offset
  Return: Read register value
  ish_reg_write() - Write register
  @dev: ISHTP device pointer
  @offset: Register offset
  @value: Value to write
  Writes 32 bit register at a give offset
  _ish_read_fw_sts_reg() - Read FW status register
  @dev: ISHTP device pointer
  Read FW status register
  Return: Read register value
  check_generated_interrupt() - Check if ISH interrupt
  @dev: ISHTP device pointer
  Check if an interrupt was generated for ISH
  Return: Read true or false
 only busy-clear bit is RW, others are RO 
  ish_is_input_ready() - Check if FW ready for RX
  @dev: ISHTP device pointer
  Check if ISH FW is ready for receiving data
  Return: Read true or false
  set_host_ready() - Indicate host ready
  @dev: ISHTP device pointer
  Set host ready indication to FW
			
			  disable interrupt generated instead of
			  RX_complete_msg
  ishtp_fw_is_ready() - Check if FW ready
  @dev: ISHTP device pointer
  Check if ISH FW is ready
  Return: Read true or false
  ish_set_host_rdy() - Indicate host ready
  @dev: ISHTP device pointer
  Set host ready indication to FW
  ish_clr_host_rdy() - Indicate host not ready
  @dev: ISHTP device pointer
  Send host not ready indication to FW
  ish_set_host_ready() - reconfig ipc host registers
  @dev: ishtp device pointer
  Set host to ready state
  This API is called in some case:
     fw is still on, but ipc is powered down.
     such as OOB case.
  Return: 0 for success else error fault code
  _ishtp_read_hdr() - Read message header
  @dev: ISHTP device pointer
  Read header of 32bit length
  Return: Read register value
  _ishtp_read - Read message
  @dev: ISHTP device pointer
  @buffer: message buffer
  @buffer_length: length of message buffer
  Read message from FW
  Return: Always 0
  write_ipc_from_queue() - try to write ipc msg from Tx queue to device
  @dev: ishtp device pointer
  Check if DRBL is cleared. if it is - write the first IPC msg,  then call
  the callback function (unless it's NULL)
  Return: 0 for success else failure code
	
	  if tx send list is empty - return 0;
	  may happen, as RX_COMPLETE handler doesn't check list emptiness.
 first 4 bytes of the data is the doorbell value (IPC header) 
 If sending MNG_SYNC_FW_CLOCK, update clock again 
 Flush writes to msg registers and doorbell 
 Update IPC counters 
	
	  callback will be called out of spinlock,
	  after ipc_link returned to free list
  write_ipc_to_queue() - write ipc msg to Tx queue
  @dev: ishtp device instance
  @ipc_send_compl: Send complete callback
  @ipc_send_compl_prm:	Parameter to send in complete callback
  @msg: Pointer to message
  @length: Length of message
  Recived msg with IPC (and upper protocol) header  and add it to the device
   Tx-to-write list then try to send the first IPC waiting msg
   (if DRBL is cleared)
  This function returns negative value for failure (means free list
   is empty, or msg too long) and 0 for success.
  Return: 0 for success else failure code
  ipc_send_mng_msg() - Send management message
  @dev: ishtp device instance
  @msg_code: Message code
  @msg: Pointer to message
  @size: Length of message
  Send management message to FW
  Return: 0 for success else failure code
  timed_wait_for_timeout() - wait special event with timeout
  @dev: ISHTP device pointer
  @condition: indicate the condition for waiting
  @timeinc: time slice for every wait cycle, in ms
  @timeout: time in ms for timeout
  This function will check special event to be ready in a loop, the loop
  period is specificd in timeinc. Wait timeout will causes failure.
  Return: 0 for success else failure code
  ish_fw_reset_handler() - FW reset handler
  @dev: ishtp device pointer
  Handle FW reset
  Return: 0 for success else failure code
 Read reset ID 
 Clear IPC output queue 
 ISHTP notification in IPC_RESET 
 ISH FW is dead 
	
	  Set HOST2ISH.ILUP. Apparently we need this BEFORE sending
	  RESET_NOTIFY_ACK - FW will be checking for it
 Send RESET_NOTIFY_ACK (with reset_id) 
 Wait for ISH FW'es ILUP and ISHTP_READY 
 ISH FW is dead 
  fw_reset_work_fn() - FW reset worker function
  @unused: not used
  Call ish_fw_reset_handler to complete FW reset
 ISH is ILUP & ISHTP-ready. Restart ISHTP 
 ISHTP notification in IPC_RESET sequence completion 
  _ish_sync_fw_clock() -Sync FW clock with the OS clock
  @dev: ishtp device pointer
  Sync FW and OS time
  recv_ipc() - Receive and process IPC management messages
  @dev: ishtp device instance
  @doorbell_val: doorbell value
  This function runs in ISR context.
  NOTE: Any other mng command than reset_notify and reset_notify_ack
  won't wake BH handler
  ish_irq_handler() - ISH IRQ handler
  @irq: irq number
  @dev_id: ishtp device pointer
  ISH IRQ handler. If interrupt is generated and is for ISH it will process
  the interrupt.
 Check that it's interrupt from ISH (may be shared) 
 Sanity check: IPC dgram length in header 
 Update IPC counters 
 Flush write to doorbell 
  ish_disable_dma() - disable dma communication between host and ISHFW
  @dev: ishtp device pointer
  Clear the dma enable bit and wait for dma inactive.
  Return: 0 for success else error code.
 Clear the dma enable bit 
 wait for dma inactive 
  ish_wakeup() - wakeup ishfw from waiting-for-host state
  @dev: ishtp device pointer
  Set the dma enable bit and send a void message to FW,
  it wil wakeup FW from waiting-for-host state.
 Set dma enable bit 
	
	  Send 0 IPC message so that ISH FW wakes up if it was already
	  asleep.
 Flush writes to doorbell and REMAP2 
  _ish_hw_reset() - HW reset
  @dev: ishtp device pointer
  Reset ISH HW to recover if any error
  Return: 0 for success else error fault code
 Disable dma communication between FW and host 
 Now we can enable ISH DMA operation and wakeup ISHFW 
  _ish_ipc_reset() - IPC reset
  @dev: ishtp device pointer
  Resets host and fw IPC and upper layers
  Return: 0 for success else error fault code
 Clear the incoming doorbell 
 Flush write to doorbell 
 send message 
  ish_hw_start() -Start ISH HW
  @dev: ishtp device pointer
  Set host to ready state and wait for FW reset
  Return: 0 for success else error fault code
 After that we can enable ISH DMA operation and wakeup ISHFW 
 wait for FW-initiated reset flow 
  ish_ipc_get_header() -Get doorbell value
  @dev: ishtp device pointer
  @length: length of message
  @busy: busy status
  Get door bell value from message header
  Return: door bell value
  _dma_no_cache_snooping()
  Check on current platform, DMA supports cache snooping or not.
  This callback is used to notify uplayer driver if manully cache
  flush is needed when do DMA operation.
  Please pay attention to this callback implementation, if declare
  having cache snooping on a cache snooping not supported platform
  will cause uplayer driver receiving mismatched data; and if
  declare no cache snooping on a cache snooping supported platform
  will cause cache be flushed twice and performance hit.
  @dev: ishtp device pointer
  Return: false - has cache snooping capability
          true - no cache snooping, need manually cache flush
  ish_dev_init() -Initialize ISH devoce
  @pdev: PCI device
  Allocate ISHTP device and initialize IPC processing
  Return: ISHTP device instance on success else NULL
 Init IPC processing and free lists 
			
			  IPC buffers may be limited or not available
			  at all - although this shouldn't happen
  ish_device_disable() - Disable ISH device
  @dev: ISHTP device pointer
  Disable ISH by clearing host ready to inform firmware.
 Disable dma communication between FW and host 
 Put ISH to D3hot state for power saving 
 SPDX-License-Identifier: GPL-2.0-only
  ISHTP bus driver
  Copyright (c) 2012-2016, Intel Corporation.
  ishtp_recv() - process ishtp message
  @dev: ishtp device
  If a message with valid header and size is received, then
  this function calls appropriate handler. The host or firmware
  address is zero, then they are host bus management message,
  otherwise they are message fo clients.
 Read ISHTP header dword 
 Sanity check: ISHTP frag. length in header 
 ISHTP bus message 
 ISHTP fixed-client message 
 ISHTP client message 
  ishtp_send_msg() - Send ishtp message
  @dev: ishtp device
  @hdr: Message header
  @msg: Message contents
  @ipc_send_compl: completion callback
  @ipc_send_compl_prm: completion callback parameter
  Send a multi fragment message via IPC. After sending the first fragment
  the completion callback is called to schedule transmit of next fragment.
  Return: This returns IPC send message status.
  ishtp_write_message() - Send ishtp single fragment message
  @dev: ishtp device
  @hdr: Message header
  @buf: message data
  Send a single fragment message via IPC.  This returns IPC send message
  status.
  Return: This returns IPC send message status.
  ishtp_fw_cl_by_uuid() - locate index of fw client
  @dev: ishtp device
  @uuid: uuid of the client to search
  Search firmware client using UUID.
  Return: fw client index or -ENOENT if not found
  ishtp_fw_cl_get_client() - return client information to client
  @dev: the ishtp device structure
  @uuid: uuid of the client to search
  Search firmware client using UUID and reture related client information.
  Return: pointer of client information on success, NULL on failure.
  ishtp_get_fw_client_id() - Get fw client id
  @fw_client:	firmware client used to fetch the ID
  This interface is used to reset HW get FW client id.
  Return: firmware client id.
  ishtp_fw_cl_by_id() - return index to fw_clients for client_id
  @dev: the ishtp device structure
  @client_id: fw client id to search
  Search firmware client using client id.
  Return: index on success, -ENOENT on failure.
  ishtp_cl_device_probe() - Bus probe() callback
  @dev: the device structure
  This is a bus probe callback and calls the drive probe function.
  Return: Return value from driver probe() call.
  ishtp_cl_bus_match() - Bus match() callback
  @dev: the device structure
  @drv: the driver structure
  This is a bus match callback, called when a new ishtp_cl_device is
  registered during ishtp bus client enumeration. Use the guid_t in
  drv and dev to decide whether they match or not.
  Return: 1 if dev & drv matches, 0 otherwise.
  ishtp_cl_device_remove() - Bus remove() callback
  @dev: the device structure
  This is a bus remove callback and calls the drive remove function.
  Since the ISH driver model supports only built in, this is
  primarily can be called during pci driver init failure.
  Return: Return value from driver remove() call.
  ishtp_cl_device_suspend() - Bus suspend callback
  @dev:	device
  Called during device suspend process.
  Return: Return value from driver suspend() call.
  ishtp_cl_device_resume() - Bus resume callback
  @dev:	device
  Called during device resume process.
  Return: Return value from driver resume() call.
  ishtp_cl_device_reset() - Reset callback
  @device:	ishtp client device instance
  This is a callback when HW reset is done and the device need
  reinit.
  Return: Return value from driver reset() call.
 Suspend callbacks 
 Hibernate callbacks 
  ishtp_bus_add_device() - Function to create device on bus
  @dev:	ishtp device
  @uuid:	uuid of the client
  @name:	Name of the client
  Allocate ISHTP bus client device, attach it to uuid
  and register with ISHTP bus.
  Return: ishtp_cl_device pointer or NULL on failure
  ishtp_bus_remove_device() - Function to relase device on bus
  @device:	client device instance
  This is a counterpart of ishtp_bus_add_device.
  Device is unregistered.
  the device structure is freed in 'ishtp_cl_dev_release' function
  Called only during error in pci driver init path.
  ishtp_cl_driver_register() - Client driver register
  @driver:	the client driver instance
  @owner:	Owner of this driver module
  Once a client driver is probed, it created a client
  instance and registers with the bus.
  Return: Return value of driver_register or -ENODEV if not ready
  ishtp_cl_driver_unregister() - Client driver unregister
  @driver:	the client driver instance
  Unregister client during device removal process.
  ishtp_bus_event_work() - event work function
  @work:	work struct pointer
  Once an event is received for a client this work
  function is called. If the device has registered a
  callback then the callback is called.
  ishtp_cl_bus_rx_event() - schedule event work
  @device:	client device instance
  Once an event is received for a client this schedules
  a work function to process.
  ishtp_register_event_cb() - Register callback
  @device:	client device instance
  @event_cb:	Event processor for an client
  Register a callback for events, called from client driver
  Return: Return 0 or -EALREADY if already registered
  ishtp_get_device() - update usage count for the device
  @cl_device:	client device instance
  Increment the usage count. The device can't be deleted
  ishtp_put_device() - decrement usage count for the device
  @cl_device:	client device instance
  Decrement the usage count. The device can be deleted is count = 0
  ishtp_set_drvdata() - set client driver data
  @cl_device:	client device instance
  @data:	driver data need to be set
  Set client driver data to cl_device->driver_data.
  ishtp_get_drvdata() - get client driver data
  @cl_device:	client device instance
  Get client driver data from cl_device->driver_data.
  Return: pointer of driver data
  ishtp_dev_to_cl_device() - get ishtp_cl_device instance from device instance
  @device: device instance
  Get ish_cl_device instance which embeds device instance in it.
  Return: pointer to ishtp_cl_device instance
  ishtp_bus_new_client() - Create a new client
  @dev:	ISHTP device instance
  Once bus protocol enumerates a client, this is called
  to add a device for the client.
  Return: 0 on success or error code on failure
	
	  For all reported clients, create an unconnected client and add its
	  device to ISHTP bus.
	  If appropriate driver has loaded, this will trigger its probe().
	  Otherwise, probe() will be called when driver is loaded
  ishtp_cl_device_bind() - bind a device
  @cl:		ishtp client device
  Binds connected ishtp_cl to ISHTP bus device
  Return: 0 on success or fault code
  ishtp_bus_remove_all_clients() - Remove all clients
  @ishtp_dev:		ishtp device
  @warm_reset:		Reset due to FW reset dure to errors or S3 suspend
  This is part of resetremove flow. This function the main processing
  only targets error processing, if the FW has forced reset or
  error to remove connected clients. When warm reset the client devices are
  not removed.
		
		  Wake any pending process. The waiter would check dev->state
		  and determine that it's not enabled already,
		  and will return error to its caller
 Disband any pending readwrite requests and free rb 
 Remove all free and in_process rings, both Rx and Tx 
		
		  Free client and ISHTP bus client device structures
		  don't free host client because it is part of the OS fd
		  structure
 Release DMA buffers for client messages 
 remove bus clients 
 Free all client structures 
  ishtp_reset_handler() - IPC reset handler
  @dev:	ishtp device
  ISHTP Handler for IPC_RESET notification
 Handle FW-initiated reset 
 Clear BH processing queue - no further HBMs 
 Handle ISH FW reset against upper layers 
  ishtp_reset_compl_handler() - Reset completion handler
  @dev:	ishtp device
  ISHTP handler for IPC_RESET sequence completion to start
  host message bus start protocol sequence.
  ishtp_use_dma_transfer() - Function to use DMA
  This interface is used to enable usage of DMA
  Return non zero if DMA can be enabled
  ishtp_device() - Return device pointer
  @device: ISH-TP client device instance
  This interface is used to return device pointer from ishtp_cl_device
  instance.
  Return: device .
  ishtp_wait_resume() - Wait for IPC resume
  Wait for IPC resume
  Return: resume complete or not
 50ms to get resume response 
 Waiting to get resume response 
  ishtp_get_pci_device() - Return PCI device dev pointer
  This interface is used to return PCI device pointer
  from ishtp_cl_device instance.
  @device: ISH-TP client device instance
  Return: device .
  ishtp_trace_callback() - Return trace callback
  @cl_device: ISH-TP client device instance
  This interface is used to return trace callback function pointer.
  Return: ishtp_print_log()
  ish_hw_reset() - Call HW reset IPC callback
  @dev:	ISHTP device instance
  This interface is used to reset HW in case of error.
  Return: value from IPC hw_reset callback
  ishtp_bus_register() - Function to register bus
  This register ishtp bus
  Return: Return output of bus_register
  ishtp_bus_unregister() - Function to unregister bus
  This unregister ishtp bus
 SPDX-License-Identifier: GPL-2.0-only
  ISHTP client logic
  Copyright (c) 2003-2016, Intel Corporation.
  ishtp_read_list_flush() - Flush read queue
  @cl: ishtp client instance
  Used to remove all entries from read queue for a client
  ishtp_cl_flush_queues() - Flush all queues for a client
  @cl: ishtp client instance
  Used to remove all queues for a client. This is called when a client device
  needs reset due to error, S3 resume or during module removal
  Return: 0 on success else -EINVAL if device is NULL
  ishtp_cl_init() - Initialize all fields of a client device
  @cl: ishtp client instance
  @dev: ishtp device
  Initializes a client device fields: Init spinlocks, init queues etc.
  This function is called during new client creation
 dma 
  ishtp_cl_allocate() - allocates client structure and sets it up.
  @cl_device: ishtp client device
  Allocate memory for new client device and call to initialize each field.
  Return: The allocated client instance or NULL on failure
  ishtp_cl_free() - Frees a client device
  @cl: client device instance
  Frees a client device
  ishtp_cl_link() - Reserve a host id and link the client instance
  @cl: client device instance
  This allocates a single bit in the hostmap. This function will make sure
  that not many client sessions are opened at the same time. Once allocated
  the client device instance is added to the ishtp device in the current
  client list
  Return: 0 or error code on failure
  ishtp_cl_unlink() - remove fw_cl from the client device list
  @cl: client device instance
  Remove a previously linked device to a ishtp device
 don't shout on error exit path 
	
	  This checks that 'cl' is actually linked into device's structure,
	  before attempting 'list_del'
  ishtp_cl_disconnect() - Send disconnect request to firmware
  @cl: client device instance
  Send a disconnect request for a client to firmware.
  Return: 0 if successful disconnect response from the firmware or error
  code on failure
	
	  If FW reset arrived, this will happen. Don't check cl->,
	  as 'cl' may be freed already
  ishtp_cl_is_other_connecting() - Check other client is connecting
  @cl: client device instance
  Checks if other client with the same fw client id is connecting
  Return: true if other client is connected else false
  ishtp_cl_connect() - Send connect request to firmware
  @cl: client device instance
  Send a connect request for a client to firmware. If successful it will
  RX and TX ring buffers
  Return: 0 if successful connect response from the firmware and able
  to bind and allocate ring buffers or error code on failure
	
	  If FW reset arrived, this will happen. Don't check cl->,
	  as 'cl' may be freed already
 if failed allocation, disconnect 
 if failed allocation, disconnect 
 Upon successful connection and allocation, emit flow-control 
  ishtp_cl_read_start() - Prepare to read client message
  @cl: client device instance
  Get a free buffer from pool of free read buffers and add to read buffer
  pool to add contents. Send a flow control request to firmware to be able
  send next message.
  Return: 0 if successful or error code on failure
 The current rb is the head of the free rb list 
	
	  This must be BEFORE sending flow control -
	  response in ISR may come too fast...
 if ishtp_hbm_cl_flow_control_req failed, return rb to free list 
  ishtp_cl_send() - Send a message to firmware
  @cl: client device instance
  @buf: message buffer
  @length: length of message
  If the client is correct state to send message, this function gets a buffer
  from tx ring buffers, copy the message data and call to send the message
  using ishtp_cl_send_msg()
  Return: 0 if successful or error code on failure
 Check if we have fw client device 
 No free bufs 
 Should not happen, as free list is pre-allocated 
	
	  This is safe, as 'length' is already checked for not exceeding
	  max ISHTP message size per client
  ishtp_cl_read_complete() - read complete
  @rb: Pointer to client request block
  If the message is completely received call ishtp_cl_bus_rx_event()
  to process message
	
	  if in-process list is empty, then need to schedule
	  the processing thread
  ipc_tx_callback() - IPC tx callback function
  @prm: Pointer to client device instance
  Send message over IPC either first time or on callback on previous message
  completion
	
	  Other conditions if some critical error has
	  occurred before this callback is called
 Must be before write 
 Submit to IPC queue with no callback 
 Send IPC fragment 
  ishtp_cl_send_msg_ipc() -Send message using IPC
  @dev: ISHTP device instance
  @cl: Pointer to client device instance
  Send message over IPC not using DMA
 If last DMA message wasn't acked yet, leave this one in Tx queue 
  ishtp_cl_send_msg_dma() -Send message using DMA
  @dev: ISHTP device instance
  @cl: Pointer to client device instance
  Send message using DMA
 If last IPC message wasn't acked yet, leave this one in Tx queue 
 Must be before write 
 write msg to dma buf 
	
	  if current fw don't support cache snooping, driver have to
	  flush the cache manually.
 send dma_xfer hbm msg 
  ishtp_cl_send_msg() -Send message using DMA or IPC
  @dev: ISHTP device instance
  @cl: Pointer to client device instance
  Send message using DMA or IPC based on transfer_path
  recv_ishtp_cl_msg() -Receive client message
  @dev: ISHTP device instance
  @ishtp_hdr: Pointer to message header
  Receive and dispatch ISHTP client messages. This function executes in ISR
  or work queue context
 If no Rx buffer is allocated, disband the rb 
		
		  If message buffer overflown (exceeds max. client msg
		  size, drop message and return to free buffer.
		  Do we need to disconnect such a client? (We don't send
		  back FC, so communication will be stuck anyway)
 Last fragment in message - it's complete 
			
			  the whole msg arrived, send a new FC, and add a new
			  rb buffer for the next coming msg
 One more fragment in message (even if this was last) 
		
		  We can safely break here (and in BH too),
		  a single input message can go only to a single request!
 If it's nobody's message, just read and discard it 
  recv_ishtp_cl_msg_dma() -Receive client message
  @dev: ISHTP device instance
  @msg: message pointer
  @hbm: hbm buffer
  Receive and dispatch ISHTP client messages using DMA. This function executes
  in ISR or work queue context
		
		  If no Rx buffer is allocated, disband the rb
		
		  If message buffer overflown (exceeds max. client msg
		  size, drop message and return to free buffer.
		  Do we need to disconnect such a client? (We don't send
		  back FC, so communication will be stuck anyway)
		
		  if current fw don't support cache snooping, driver have to
		  flush the cache manually.
 Last fragment in message - it's complete 
		
		  the whole msg arrived, send a new FC, and add a new
		  rb buffer for the next coming msg
 One more fragment in message (this is always last) 
		
		  We can safely break here (and in BH too),
		  a single input message can go only to a single request!
 If it's nobody's message, just read and discard it 
 SPDX-License-Identifier: GPL-2.0-only
  Initialization protocol for ISHTP driver
  Copyright (c) 2003-2016, Intel Corporation.
  ishtp_dev_state_str() -Convert to string format
  @state: state to convert
  Convert state to string for prints
  Return: character pointer to converted string
  ishtp_device_init() - ishtp device init
  @dev: ISHTP device instance
  After ISHTP device is alloacted, this function is used to initialize
  each field which includes spin lock, work struct and lists
	
	  Reserving client ID 0 for ISHTP Bus Message communications
  ishtp_start() - Start ISH processing
  @dev: ISHTP device instance
  Start ISHTP processing by sending query subscriber message
  Return: 0 on success else -ENODEV
 suspend & resume notification - send QUERY_SUBSCRIBERS msg 
 SPDX-License-Identifier: GPL-2.0-only
  ISHTP DMA IF functions
  Copyright (c) 2003-2016, Intel Corporation.
  ishtp_cl_alloc_dma_buf() - Allocate DMA RX and TX buffer
  @dev: ishtp device
  Allocate RX and TX DMA buffer once during bus setup.
  It allocates 1MB, RX and TX DMA buffer, which are divided
  into slots.
 Allocate Tx buffer and init usage bitmap 
 Allocate Rx buffer 
  ishtp_cl_free_dma_buf() - Free DMA RX and TX buffer
  @dev: ishtp device
  Free DMA buffer when all clients are released. This is
  only happens during error path in ISH built in driver
  model
  ishtp_cl_get_dma_send_buf() - Get a DMA memory slot
  @dev:	ishtp device
  @size:	Size of memory to get
  Find and return free address of "size" bytes in dma tx buffer.
  the function will mark this address as "in-used" memory.
  Return: NULL when no free buffer else a buffer to copy
 additional slot is needed if there is rem 
 mark memory as "caught" 
  ishtp_cl_release_dma_acked_mem() - Release DMA memory slot
  @dev:	ishtp device
  @msg_addr:	message address of slot
  @size:	Size of memory to get
  Release_dma_acked_mem - returnes the acked memory to free list.
  (from msg_addr, size bytes long)
 no such slot, or memory is already free 
 SPDX-License-Identifier: GPL-2.0-only
  ISHTP bus layer messages handling
  Copyright (c) 2003-2016, Intel Corporation.
  ishtp_hbm_fw_cl_allocate() - Allocate FW clients
  @dev: ISHTP device instance
  Allocates storage for fw clients
 count how many ISH clients we have 
 allocate storage for fw clients representation 
  ishtp_hbm_cl_hdr() - construct client hbm header
  @cl: client
  @hbm_cmd: host bus message command
  @buf: buffer for cl header
  @len: buffer length
  Initialize HBM buffer
  ishtp_hbm_cl_addr_equal() - Compare client address
  @cl: client
  @buf: Client command buffer
  Compare client address with the address in command buffer
  Return: True if they have the same address
  ishtp_hbm_start_wait() - Wait for HBM start message
  @dev: ISHTP device instance
  Wait for HBM start message from firmware
  Return: 0 if HBM start iswas received else timeout error
  ishtp_hbm_start_req() - Send HBM start message
  @dev: ISHTP device instance
  Send HBM start message to firmware
  Return: 0 if success else error code
 host start message 
	
	  (!) Response to HBM start may be so quick that this thread would get
	  preempted BEFORE managing to set hbm_state = ISHTP_HBM_START.
	  So set it at first, change back to ISHTP_HBM_IDLE upon failure
  ishtp_hbm_enum_clients_req() - Send client enum req
  @dev: ISHTP device instance
  Send enumeration client request message
  Return: 0 if success else error code
 enumerate clients 
  ishtp_hbm_prop_req() - Request property
  @dev: ISHTP device instance
  Request property for a single client
  Return: 0 if success else error code
 We got all client properties 
 Add new client device 
  ishtp_hbm_stop_req() - Send HBM stop
  @dev: ISHTP device instance
  Send stop request message
  ishtp_hbm_cl_flow_control_req() - Send flow control request
  @dev: ISHTP device instance
  @cl: ISHTP client instance
  Send flow control request
  Return: 0 if success else error code
	
	  Sync possible race when RB recycle and packet receive paths
	  both try to send an out FC
  ishtp_hbm_cl_disconnect_req() - Send disconnect request
  @dev: ISHTP device instance
  @cl: ISHTP client instance
  Send disconnect message to fw
  Return: 0 if success else error code
  ishtp_hbm_cl_disconnect_res() - Get disconnect response
  @dev: ISHTP device instance
  @rs: Response message
  Received disconnect response from fw
  ishtp_hbm_cl_connect_req() - Send connect request
  @dev: ISHTP device instance
  @cl: client device instance
  Send connection request to specific fw client
  Return: 0 if success else error code
  ishtp_hbm_cl_connect_res() - Get connect response
  @dev: ISHTP device instance
  @rs: Response message
  Received connect response from fw
  ishtp_hbm_fw_disconnect_req() - Receive disconnect request
  @dev: ISHTP device instance
  @disconnect_req: disconnect request structure
  Disconnect request bus message from the fw. Send disconnect response.
 All HBM messages are 4 bytes 
 send disconnect response 
  ishtp_hbm_dma_xfer_ack() - Receive transfer ACK
  @dev: ISHTP device instance
  @dma_xfer: HBM transfer message
  Receive ack for ISHTP-over-DMA client message
 logical address of the acked mem 
				
				  in case that a single ack may be sent
				  over several dma transfers, and the last msg
				  addr was inside the acked memory, but not in
				  its start
						
						  start sending the first msg
  ishtp_hbm_dma_xfer() - Receive DMA transfer message
  @dev: ISHTP device instance
  @dma_xfer: HBM transfer message
  Receive ISHTP-over-DMA client message
 Prepare for response 
 Send DMA_XFER_ACK [...] 
  ishtp_hbm_dispatch() - HBM dispatch function
  @dev: ISHTP device instance
  @hdr: bus message
  Bottom half read routine after ISR to handle the read bus message cmd
  processing
 BUG: why do we arrive here? 
 request property for the next client 
 first property request 
 search for client 
  bh_hbm_work_fn() - HBM work function
  @work: work struct
  Bottom half processing work function (instead of thread handler)
  for processing hbm messages
  recv_hbm() - Receive HBM message
  @dev: ISHTP device instance
  @ishtp_hdr: received bus message
  Receive and process ISHTP bus messages in ISR context. This will schedule
  work function to process message
 Flow control - handle in place 
				
				  NOTE: It's valid only for counting
				  flow-control implementation to receive a
				  FC in the middle of sending. Meanwhile not
				  supported
						
						  start sending the first msg
						 	= the callback function
	
	  Some messages that are safe for ISR processing and important
	  to be done "quickly" and in-order, go here
	
	  All other HBMs go here.
	  We schedule HBMs for processing serially by using system wq,
	  possibly there will be multiple HBMs scheduled at the same time.
  recv_fixed_cl_msg() - Receive fixed client message
  @dev: ISHTP device instance
  @ishtp_hdr: received bus message
  Receive and process ISHTP fixed client messages (address == 0)
  in ISR context
 if FW request arrived here, the system is not suspended 
  fix_cl_hdr() - Initialize fixed client header
  @hdr: message header
  @length: length of message
  @cl_addr: Client address
  Initialize message header for fixed client
 Suspend and resume notification 
  ishtp_send_suspend() - Send suspend message to FW
  @dev: ISHTP device instance
  Send suspend message to FW. This is useful for system freeze (non S3) case
  ishtp_send_resume() - Send resume message to FW
  @dev: ISHTP device instance
  Send resume message to FW. This is useful for system freeze (non S3) case
  ishtp_query_subscribers() - Send query subscribers message
  @dev: ISHTP device instance
  Send message to query subscribers
 SPDX-License-Identifier: GPL-2.0-only
  ISHTP Ring Buffers
  Copyright (c) 2003-2016, Intel Corporation.
  ishtp_cl_alloc_rx_ring() - Allocate RX ring buffers
  @cl: client device instance
  Allocate and initialize RX ring buffers
  Return: 0 on success else -ENOMEM
  ishtp_cl_alloc_tx_ring() - Allocate TX ring buffers
  @cl: client device instance
  Allocate and initialize TX ring buffers
  Return: 0 on success else -ENOMEM
 Allocate pool to free Tx bufs 
  ishtp_cl_free_rx_ring() - Free RX ring buffers
  @cl: client device instance
  Free RX ring buffers
 release allocated memory - pass over free_rb_list 
 release allocated memory - pass over in_process_list 
  ishtp_cl_free_tx_ring() - Free TX ring buffers
  @cl: client device instance
  Free TX ring buffers
 release allocated memory - pass over tx_free_list 
 release allocated memory - pass over tx_list 
  ishtp_io_rb_free() - Free IO request block
  @rb: IO request block
  Free io request block memory
  ishtp_io_rb_init() - Allocate and init IO request block
  @cl: client device instance
  Allocate and initialize request block
  Return: Allocted IO request block pointer
  ishtp_io_rb_alloc_buf() - Allocate and init response buffer
  @rb: IO request block
  @length: length of response buffer
  Allocate respose buffer
  Return: 0 on success else -ENOMEM
  ishtp_cl_io_rb_recycle() - Recycle IO request blocks
  @rb: IO request block
  Re-append rb to its client's free list and send flow control if needed
  Return: 0 on success else -EFAULT
	
	  If we returned the first buffer to empty 'free' list,
	  send flow control
  ishtp_cl_tx_empty() -test whether client device tx buffer is empty
  @cl: Pointer to client device instance
  Look client device tx buffer list, and check whether this list is empty
  Return: true if client tx buffer list is empty else false
  ishtp_cl_rx_get_rb() -Get a rb from client device rx buffer list
  @cl: Pointer to client device instance
  Check client device in-processing buffer list and get a rb from it.
  Return: rb pointer if buffer list isn't empty else NULL
  HID over I2C protocol implementation
  Copyright (c) 2012 Benjamin Tissoires <benjamin.tissoires@gmail.com>
  Copyright (c) 2012 Ecole Nationale de l'Aviation Civile, France
  Copyright (c) 2012 Red Hat, Inc
  This code is partly based on "USB HID support for Linux":
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2007-2008 Oliver Neukum
   Copyright (c) 2006-2010 Jiri Kosina
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file COPYING in the main directory of this archive for
  more details.
 quirks to control the device 
 flags 
 debug option 
 fetch HID descriptor 
 fetch report descriptors 
 commands 
  These definitions are not used here, but are defined by the spec.
  Keeping them here for documentation purposes.
  static const struct i2c_hid_cmd hid_get_idle_cmd = { I2C_HID_CMD(0x04) };
  static const struct i2c_hid_cmd hid_set_idle_cmd = { I2C_HID_CMD(0x05) };
  static const struct i2c_hid_cmd hid_get_protocol_cmd = { I2C_HID_CMD(0x06) };
  static const struct i2c_hid_cmd hid_set_protocol_cmd = { I2C_HID_CMD(0x07) };
 The main device structure 
 i2c client 
 pointer to corresponding HID dev 
 the HID Descriptor 
	__le16			wHIDDescRegister;  location of the i2c
						    register of the HID
 i2c buffer size 
 Input buffer 
 Raw Input buffer 
 Command buffer 
 Command arguments buffer 
 device flags 
 Various quirks 
 For waiting the interrupt 
	
	  Sending the wakeup after reset actually break ELAN touchscreen controller
  i2c_hid_lookup_quirk: return any quirks associated with a I2C HID device
  @idVendor: the 16-bit vendor ID
  @idProduct: the 16-bit product ID
  Returns: a u32 quirks value.
 special case for hid_descr_cmd 
  i2c_hid_set_or_send_report: forward an incoming report to the device
  @client: the i2c_client of the device
  @reportType: 0x03 for HID_FEATURE_REPORT ; 0x02 for HID_OUTPUT_REPORT
  @reportID: the report ID
  @buf: the actual data to transfer, without the report ID
  @data_len: size of buf
  @use_data: true: use SET_REPORT HID command, false: send plain OUTPUT report
 size  +
 reportID  +
 buf ;
 optional third byte  +
 dataRegister  +
 args ;
	
	  use the data register for feature reports or if the device does not
	  support the output register
	
	  Some devices require to send a command to wakeup before power on.
	  The call will get a return value (EREMOTEIO) but device will be
	  triggered and activated. After that, it goes like a normal device.
 Device was already activated 
	
	  The HID over I2C specification states that if a DEVICE needs time
	  after the PWR_ON request, it should utilise CLOCK stretching.
	  However, it has been observered that the Windows driver provides a
	  1ms sleep between the PWR_ON and RESET requests.
	  According to Goodix Windows even waits 60 ms after (other?)
	  PWR_ON requests. Testing has confirmed that several devices
	  will not work properly without a delay after a PWR_ON request.
	
	  This prevents sending feature reports while the device is
	  being reset. Otherwise we may lose the reset complete
	  interrupt.
 At least some SIS devices need this after reset 
 host or device initiated RESET completed 
  Traverse the supplied list of reports and find the longest
	 We should not rely on wMaxInputLength, as some devices may set it to
	 the worst case is computed from the set_report command with a
 ReportID 
 optional ReportID byte 
 data register 
 size of the report 
 report 
 +2 bytes to include the size of the reply in the query buffer 
 The query buffer contains the size, dropping it in the reply 
 add report_id to the number of transfered bytes 
 i2c hid fetch using a fixed descriptor size (30 bytes) 
	 Validate the length of HID descriptor, the 4 first bytes:
	  bytes 0-1 -> length
 check bcdVersion == 1.0 
 Descriptor length should be 30 bytes as per the specification 
	 we need to allocate the command buffer without knowing the maximum
	  size of the reports. Let's use HID_MIN_BUFFER_SIZE, then we do the
 Make sure there is something at this address 
 Save some power 
	 Instead of resetting device, simply powers the device on. This
	  solves "incomplete reports" on Raydium devices 2386:3118 and
	  2386:4B33 and fixes various SIS touchscreens no longer sending
	  data after a suspendresume.
	 
	  However some ALPS touchpads generate IRQ storm without reset, so
	  let's still reset them here.
 SPDX-License-Identifier: GPL-2.0
  Driver for Goodix touchscreens that use the i2c-hid protocol.
  Copyright 2020 Google LLC
 Start out with reset asserted 
	
	  We need to control the "reset" line in lockstep with the regulator
	  actually turning on an off instead of just when we make the request.
	  This matters if the regulator is shared with another consumer.
	  - If the regulator is off then we must assert reset. The reset
	    line is active low and on some boards it could cause a current
	    leak if left high.
	  - If the regulator is on then we don't want reset asserted for very
	    long. Holding the controller in reset apparently draws extra
	    power.
	
	  If someone else is holding the regulator on (or the regulator is
	  an always-on one) we might never be told to deassert reset. Do it
	  now. Here we'll assume that someone else might have _just
	  barely_ turned the regulator on so we'll do the full
	  "post_power_delay" just in case.
  HID over I2C Open Firmware Subclass
  Copyright (c) 2012 Benjamin Tissoires <benjamin.tissoires@gmail.com>
  Copyright (c) 2012 Ecole Nationale de l'Aviation Civile, France
  Copyright (c) 2012 Red Hat, Inc
  This code was forked out of the core code, which was partly based on
  "USB HID support for Linux":
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2007-2008 Oliver Neukum
   Copyright (c) 2006-2010 Jiri Kosina
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file COPYING in the main directory of this archive for
  more details.
  HID over I2C ACPI Subclass
  Copyright (c) 2012 Benjamin Tissoires <benjamin.tissoires@gmail.com>
  Copyright (c) 2012 Ecole Nationale de l'Aviation Civile, France
  Copyright (c) 2012 Red Hat, Inc
  This code was forked out of the core code, which was partly based on
  "USB HID support for Linux":
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2007-2008 Oliver Neukum
   Copyright (c) 2006-2010 Jiri Kosina
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file COPYING in the main directory of this archive for
  more details.
	
	  The CHPN0001 ACPI device, which is used to describe the Chipone
	  ICN8505 controller, has a _CID of PNP0C50 but is not HID compatible.
 HID I¬≤C Device: 3cdff6f7-4267-4555-ad05-b30a3d8938de 
 SPDX-License-Identifier: GPL-2.0+
  Quirks for I2C-HID devices that do not supply proper descriptors
  Copyright (c) 2018 Julian Sax <jsbc@gmx.de>
  descriptors for the SIPODEV SP1064 touchpad
  This device does not supply any descriptors and on windows a filter
  driver operates between the i2c-hid layer and the device and injects
  these descriptors when the device is prompted. The descriptors were
  extracted by listening to the i2c-hid traffic that occurs between the
  windows filter driver and the windows i2c-hid driver.
 Length of descriptor                 
 Version of descriptor                
 Length of report descriptor          
 Location of report descriptor        
 Location of input report             
 Max input report length              
 Location of output report            
 Max output report length             
 Location of command register         
 Location of data register            
 Vendor ID                            
 Product ID                           
 Version ID                           
 Reserved                             
 Usage Page (Desktop),                
 Usage (Mouse),                       
 Collection (Application),            
     Report ID (1),                   
     Usage (Pointer),                 
     Collection (Physical),           
         Usage Page (Button),         
         Usage Minimum (01h),         
         Usage Maximum (02h),         
         Logical Maximum (1),         
         Report Size (1),             
         Report Count (2),            
         Input (Variable),            
         Report Count (6),            
         Input (Constant),            
         Usage Page (Desktop),        
         Usage (X),                   
         Usage (Y),                   
         Logical Minimum (-127),      
         Logical Maximum (127),       
         Report Size (8),             
         Report Count (2),            
         Input (Variable, Relative),  
     End Collection,                  
 End Collection,                      
 Usage Page (Digitizer),              
 Usage (Touchpad),                    
 Collection (Application),            
     Report ID (4),                   
     Usage Page (Digitizer),          
     Usage (Finger),                  
     Collection (Logical),            
         Logical Minimum (0),         
         Logical Maximum (1),         
         Usage (Touch Valid),         
         Usage (Tip Switch),          
         Report Count (2),            
         Report Size (1),             
         Input (Variable),            
         Report Count (1),            
         Report Size (3),             
         Logical Maximum (5),         
         Usage (Contact Identifier),  
         Input (Variable),            
         Report Size (1),             
         Report Count (3),            
         Input (Constant, Variable),  
         Usage Page (Desktop),        
         Logical Maximum (2628),      
         Report Size (16),            
         Unit Exponent (14),          
         Unit (Centimeter),           
         Usage (X),                   
         Physical Maximum (1050),     
         Report Count (1),            
         Input (Variable),            
         Physical Maximum (700),      
         Logical Maximum (1332),      
         Usage (Y),                   
         Input (Variable),            
     End Collection,                  
     Usage Page (Digitizer),          
     Usage (Finger),                  
     Collection (Logical),            
         Logical Maximum (1),         
         Usage (Touch Valid),         
         Usage (Tip Switch),          
         Report Count (2),            
         Report Size (1),             
         Input (Variable),            
         Report Count (1),            
         Report Size (3),             
         Logical Maximum (5),         
         Usage (Contact Identifier),  
         Input (Variable),            
         Report Size (1),             
         Report Count (3),            
         Input (Constant, Variable),  
         Usage Page (Desktop),        
         Logical Maximum (2628),      
         Report Size (16),            
         Usage (X),                   
         Physical Maximum (1050),     
         Report Count (1),            
         Input (Variable),            
         Physical Maximum (700),      
         Logical Maximum (1332),      
         Usage (Y),                   
         Input (Variable),            
     End Collection,                  
     Usage Page (Digitizer),          
     Usage (Finger),                  
     Collection (Logical),            
         Logical Maximum (1),         
         Usage (Touch Valid),         
         Usage (Tip Switch),          
         Report Count (2),            
         Report Size (1),             
         Input (Variable),            
         Report Count (1),            
         Report Size (3),             
         Logical Maximum (5),         
         Usage (Contact Identifier),  
         Input (Variable),            
         Report Size (1),             
         Report Count (3),            
         Input (Constant, Variable),  
         Usage Page (Desktop),        
         Logical Maximum (2628),      
         Report Size (16),            
         Usage (X),                   
         Physical Maximum (1050),     
         Report Count (1),            
         Input (Variable),            
         Physical Maximum (700),      
         Logical Maximum (1332),      
         Usage (Y),                   
         Input (Variable),            
     End Collection,                  
     Usage Page (Digitizer),          
     Usage (Finger),                  
     Collection (Logical),            
         Logical Maximum (1),         
         Usage (Touch Valid),         
         Usage (Tip Switch),          
         Report Count (2),            
         Report Size (1),             
         Input (Variable),            
         Report Count (1),            
         Report Size (3),             
         Logical Maximum (5),         
         Usage (Contact Identifier),  
         Input (Variable),            
         Report Size (1),             
         Report Count (3),            
         Input (Constant, Variable),  
         Usage Page (Desktop),        
         Logical Maximum (2628),      
         Report Size (16),            
         Usage (X),                   
         Physical Maximum (1050),     
         Report Count (1),            
         Input (Variable),            
         Physical Maximum (700),      
         Logical Maximum (1332),      
         Usage (Y),                   
         Input (Variable),            
     End Collection,                  
     Usage Page (Digitizer),          
     Unit Exponent (12),              
     Unit (Seconds),                  
     Physical Maximum (65535),        
     Logical Maximum (65535),         
     Report Size (16),                
     Report Count (1),                
     Usage (Scan Time),               
     Input (Variable),                
     Usage (Contact Count),           
     Logical Maximum (127),           
     Report Size (8),                 
     Input (Variable),                
     Usage Page (Button),             
     Usage (01h),                     
     Logical Maximum (1),             
     Report Size (1),                 
     Report Count (1),                
     Input (Variable),                
     Report Count (7),                
     Input (Constant, Variable),      
     Usage Page (Digitizer),          
     Report ID (2),                   
     Usage (Contact Count Maximum),   
     Usage (59h),                     
     Report Size (4),                 
     Report Count (2),                
     Logical Maximum (15),            
     Feature (Variable),              
     Usage Page (Digitizer),          
     Report ID (7),                   
     Usage (60h),                     
     Report Size (1),                 
     Report Count (1),                
     Logical Maximum (1),             
     Feature (Variable),              
     Report Count (7),                
     Feature (Constant, Variable),    
     Report ID (6),                   
     Usage Page (FF00h),              
     Usage (C5h),                     
     Logical Maximum (255),           
     Report Size (8),                 
     Report Count (256),              
     Feature (Variable),              
 End Collection,                      
 Usage Page (FF00h),                  
 Usage (01h),                         
 Collection (Application),            
     Report ID (13),                  
     Logical Maximum (255),           
     Usage Minimum (01h),             
     Usage Maximum (02h),             
     Report Size (8),                 
     Report Count (2),                
     Feature (Variable),              
 End Collection,                      
 Usage Page (Digitizer),              
 Usage (Configuration),               
 Collection (Application),            
     Report ID (3),                   
     Usage (Finger),                  
     Collection (Logical),            
         Usage (Device Mode),         
         Logical Maximum (10),        
         Report Count (1),            
         Feature (Variable),          
     End Collection,                  
     Usage (Finger),                  
     Collection (Physical),           
         Report ID (5),               
         Usage (57h),                 
         Usage (58h),                 
         Report Size (1),             
         Report Count (2),            
         Logical Maximum (1),         
         Feature (Variable),          
         Report Count (6),            
         Feature (Constant, Variable),
     End Collection,                  
 End Collection                       
		
		  There are at least 2 Primebook C11B versions, the older
		  version has a product-name of "Primebook C11B", and a
		  bios version  release  firmware revision of:
		  V2.1.2  05032018  18.2
		  The new version has "PRIMEBOOK C11B" as product-name and a
		  bios version  release  firmware revision of:
		  CFALKSW05_BIOS_V1.1.2  11192018  19.2
		  Only the older version needs this quirk, note the newer
		  version will not match as it has a different product-name.
 Terminate list 
 SPDX-License-Identifier: GPL-2.0-or-later
  AMD MP2 PCIe communication driver
  Copyright 2020-2021 Advanced Micro Devices, Inc.
  Authors: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
 	    Sandeep Singh <Sandeep.singh@amd.com>
 	    Basavaraj Natikar <Basavaraj.Natikar@amd.com>
 Get response with status within a max of 800 ms timeout 
 fill up command register 
 fill up command param register 
 fill up command register 
 fill up command register 
 SPDX-License-Identifier: GPL-2.0-or-later
   AMD SFH Client Layer
   Copyright 2020-2021 Advanced Micro Devices, Inc.
   Authors: Nehal Bakulchandra Shah <Nehal-Bakulchandra.Shah@amd.com>
 	     Sandeep Singh <Sandeep.singh@amd.com>
 	     Basavaraj Natikar <Basavaraj.Natikar@amd.com>
 SPDX-License-Identifier: GPL-2.0-or-later
  AMD MP2 Sensors transport driver
  Copyright 2020-2021 Advanced Micro Devices, Inc.
  Authors: Nehal Bakulchandra Shah <Nehal-bakulchandra.shah@amd.com>
 	    Sandeep Singh <sandeep.singh@amd.com>
 	    Basavaraj Natikar <Basavaraj.Natikar@amd.com>
  amdtp_hid_parse() - hid-core .parse() callback
  @hid:	hid device instance
  This function gets called during call to hid_add_device
  Return: 0 on success and non zero on error
 Empty callbacks with success return code 
 SPDX-License-Identifier: GPL-2.0-or-later
   AMD SFH Report Descriptor generator
   Copyright 2020-2021 Advanced Micro Devices, Inc.
   Authors: Nehal Bakulchandra Shah <Nehal-Bakulchandra.Shah@amd.com>
 	     Sandeep Singh <sandeep.singh@amd.com>
 	     Basavaraj Natikar <Basavaraj.Natikar@amd.com>
 state enums 
 accel 
 gyro 
 Magnetometer 
 ambient light sensor 
 HPD sensor 
 accel 
 gyro 
 Magnetometer 
 ambient light sensor 
 human presence detection sensor 
 accel 
 gyro 
 Magnetometer 
 Als 
 For ALS ,V2 Platforms uses C2P_MSG5 register instead of DRAM access method 
 hpd 
 SPDX-License-Identifier: GPL-2.0-or-later
   Force feedback driver for USB HID PID compliant devices
   Copyright (c) 2005, 2006 Anssi Hannula <anssi.hannula@gmail.com>
 #define DEBUG 
 Report usage table used to put reports into an array 
 device_control is really 0x95, but 0x96 specified as it is the usage of
 Value usage tables used to put fields and values into arrays 
 Special field key tables used to put special field keys into arrays 
	 Special field is a field that is not composed of
 Special field in create_new_effect 
 Special fields in set_effect 
 Special field in device_control 
 Special field in block_load 
 Special field in effect_operation 
  Scale an unsigned value with range 0..max for the given field
  Scale a signed value in range -0x8000..0x7fff for the given field
  Send envelope report to the device
  Test if the new envelope differs from old one
  Send constant force report to the device
  Test if the constant parameters have changed between effects
  Send set effect report to the device
  Test if the values used in set_effect have changed
  Send periodic effect report to the device
  Test if periodic effect parameters have changed
  Send condition effect reports to the device
  Test if condition effect parameters have changed
  Send ramp force report to the device
  Test if ramp force parameters have changed
  Send a request for effect upload to the device
  Returns 0 if device reported success, -ENOSPC if the device reported memory
  is full. Upon unknown response the function will retry for 60 times, if
  still unsuccessful -EIO is returned.
  Play the effect with PID id n times
  Play the effect with effect id @effect_id for @value times
  Erase effect with PID id
  Stop and erase effect with effect_id
	 Wait for the queue to clear. We do not want a full fifo to
  Effect upload handler
  set_gain() handler
  pidff_set_autocenter() handler
  Find fields from a report and fill a pidff_usage
  Return index into pidff_reports for the given usage
  Find the reports and fill pidff->reports[]
  report_type specifies either OUTPUT or FEATURE reports
		
		  Sometimes logical collections are stacked to indicate
		  different usages for the report and the field, in which
		  case we want the usage of the parent. However, Linux HID
		  implementation hides this fact, so we have to dig it up
		  ourselves
  Test if the required reports have been found
  Find a field with a specific usage within a report
  Fill a pidff->_id struct table
  Find and check the special fields
  Find the implemented effect types
  Fill and check the pidff_usages
  Reset the device
 We reset twice as sometimes hid_wait_io isn't waiting long enough 
 pool report is sometimes messed up, refetch it 
  Test if autocenter modification is using the supported method
	
	  Let's find out if autocenter modification is supported
	  Specification doesn't specify anything, so we request an
	  effect upload and cancel it immediately. If the approved
	  effect id was one above the minimum, then we assume the first
	  effect id is a built-in spring type effect used for autocenter
  Check if the device is PID and initialize it
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) 1999-2001 Vojtech Pavlik
   USB HIDBP Keyboard support
  Should you need to contact me, the author, you can do so either by
  e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
  Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
  Version Information
  struct usb_kbd - state of each attached keyboard
  @dev:	input device associated with this keyboard
  @usbdev:	usb device associated with this keyboard
  @old:	data received in the past from the @irq URB representing which
 		keys were pressed. By comparing with the current list of keys
 		that are pressed, we are able to see key releases.
  @irq:	URB for receiving a list of keys that are pressed when a
 		new key is pressed or a key that was pressed is released.
  @led:	URB for sending LEDs (e.g. numlock, ...)
  @newleds:	data that will be sent with the @led URB representing which LEDs
 		should be on
  @name:	Name of the keyboard. @dev's name field points to this buffer
  @phys:	Physical path of the keyboard. @dev's phys field points to this
 		buffer
  @new:	Buffer for the @irq URB
  @cr:		Control request for @led URB
  @leds:	Buffer for the @led URB
  @new_dma:	DMA address for @irq URB
  @leds_dma:	DMA address for @led URB
  @leds_lock:	spinlock that protects @leds, @newleds, and @led_urb_submitted
  @led_urb_submitted: indicates whether @led is in progress, i.e. it has been
 		submitted and its completion handler has not returned yet
 		without	resubmitting @led
 success 
 unlink 
 -EPIPE:  should clear the halt 
 error 
 Terminating entry 
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) 2001 Paul Stewart
   Copyright (c) 2001 Vojtech Pavlik
   HID char devices, giving access to raw HID device events.
  Should you need to contact me, the author, you can do so either by
  e-mail - mail your message to Paul Stewart <stewart@wetlogic.net>
  Find a report, given the report's type and ID.  The ID can be specified
  indirectly by REPORT_ID_FIRST (which returns the first report of the given
  type) or by (REPORT_ID_NEXT | old_id), which returns the next report of the
  given type which follows old_id.
 Nothing to do -- report_id is already set correctly 
  Perform an exhaustive search of the report table for a usage, given its
  type and usage id.
  This is where hid.c calls into hiddev to pass an event that occurred over
  the interrupt pipe
  fasync file op
  release file op
  open file op
  "write" file op
  "read" file op
 lock against other threads 
 let O_NONBLOCK tasks run 
  "poll" file op
  No kernel lock - fine
  "ioctl" file op
 Called without BKL by compat methods so no BKL taken 
  This is where hid.c calls us to connect a hid device to the hiddev driver
	
	  If HID_QUIRK_NO_INIT_REPORTS is set, make sure we don't initialize
	  the reports.
  This is where hid.c calls us to disconnect a hiddev device from the
  corresponding hid device (usually because the usb device has disconnected)
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (c) 1999-2001 Vojtech Pavlik
   USB HIDBP Mouse support
  Should you need to contact me, the author, you can do so either by
  e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
  Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
 for apple IDs 
  Version Information
 success 
 unlink 
 -EPIPE:  should clear the halt 
 error 
 Terminating entry 
 SPDX-License-Identifier: GPL-2.0-or-later
   USB HID support for Linux
   Copyright (c) 1999 Andreas Gal
   Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   Copyright (c) 2007-2008 Oliver Neukum
   Copyright (c) 2006-2010 Jiri Kosina
  Version Information
  Module parameters.
 Quirks specified at module load time 
  Input submission and IO error handler.
 Start up the input URB 
 IO retry timer routine 
 Workqueue routine to reset the device or clear a halt 
 Main IO error handler 
 Stop when disconnected 
	 If it has been a while since the last error, we'll assume
 When an error occurs, retry at increasing intervals 
 Then 26, 52, 104, 104, ... 
 Retries failed, so do a port reset unless we lack bandwidth
 Try to wake up from autosuspend... 
		
		  If still suspended, don't submit.  Submission will
		  occur ifwhen resume drains the queue.
 Asynchronously flush queue. 
 Try to wake up from autosuspend... 
		
		  If still suspended, don't submit.  Submission will
		  occur ifwhen resume drains the queue.
 Asynchronously flush queue. 
  Input interrupt completion handler.
 success 
			
			  autosuspend refused while keys are pressed
			  because most keyboards don't wake up when
			  a key is released
 stall 
 unlink 
 unplug 
 protocol error or unplug 
 protocol error or unplug 
 protocol error or unplug 
 Should never happen, but... 
 error 
 Don't allow 0-length reports 
  Output interrupt completion handler.
 success 
 unplug 
 protocol error or unplug 
 protocol error or unplug 
 unlink 
 error 
 Successfully submitted next urb in queue 
  Control pipe completion handler.
 success 
 unplug 
 protocol error or unplug 
 protocol error or unplug 
 unlink 
 report not available 
 error 
 Successfully submitted next urb in queue 
 If the queue isn't running, restart it 
 Otherwise see if an earlier request has timed out 
 Prevent autosuspend following the unlink 
			
			  Prevent resubmission in case the URB completes
			  before we can unlink it.  We don't want to cancel
			  the wrong transfer!
 Drop lock to avoid deadlock if the callback runs 
 Unlink might have stopped the queue 
 Now we can allow autosuspend again 
 If the queue isn't running, restart it 
 Otherwise see if an earlier request has timed out 
 Prevent autosuspend following the unlink 
		
		  Prevent resubmission in case the URB completes
		  before we can unlink it.  We don't want to cancel
		  the wrong transfer!
 Drop lock to avoid deadlock if the callback runs 
 Unlink might have stopped the queue 
 Now we can allow autosuspend again 
 the device must be awake to reliably request remote wakeup 
 no use opening if resources are insufficient 
	
	  In case events are generated while nobody was listening,
	  some are released when the device is re-opened.
	  Wait 50 msec for the queue to empty before allowing events
	  to go through hid.
	
	  Make sure we don't restart data acquisition due to
	  a resumption we no longer care about by avoiding racing
	  with hid_start_in().
  Initialize all reports
  Reset LEDs which BIOS might have left on. For now, just NumLock (0x01).
  Traverse the supplied list of reports and find the longest
 Byte 0 is the report number. Report data starts at byte 1.
		 Offset the return buffer by 1, so that the report ID
 count also the report id 
 Byte 0 is the report number. Report data starts at byte 1.
 Don't send the Report ID 
 count also the report id, if this was a numbered report. 
 Don't send the Report ID 
 return the number of bytes transferred 
 count also the report id 
	 Many keyboards and mice don't like to be polled for reports,
 Some vendors give fullspeed interval on highspeed devides 
		 Change the polling interval of mice, joysticks
		  and keyboards.
	 Some keyboards don't work until their LEDs have been set.
	  Since BIOSes do set the LEDs, it must be safe for any device
	  that supports the keyboard boot protocol.
	  In addition, enable remote wakeup by default for all keyboard
	  devices supporting the boot protocol.
 Sync with error and led handlers 
 don't mess up next start 
 Sync with error and led handlers 
 Treat USB reset pretty much the same as suspendresume 
 Same routine used for post_reset and reset_resume 
	 Fetch and examine the HID report descriptor. If this
	  has changed, then rebind. Since usbcore's check of the
	  configuration descriptors passed, we already know that
	  the size of the HID report descriptor has not changed.
 No need to do another reset or clear a halted endpoint 
 Sync with error handler 
 TODO: resume() might need to handle suspend failure 
 lost race against keypresses 
 CONFIG_PM 
 Terminating entry 
 SPDX-License-Identifier: GPL-2.0-only
 binder_alloc_selftest.c
  Android IPC Subsystem
  Copyright (C) 2017 Google, Inc.
  enum buf_end_align_type - Page alignment of a buffer
  end with regard to the end of the previous buffer.
  In the pictures below, buf2 refers to the buffer we
  are aligning. buf1 refers to previous buffer by addr.
  Symbol [ means the start of a buffer, ] means the end
  of a buffer, and | means page boundaries.
	
	  @SAME_PAGE_UNALIGNED: The end of this buffer is on
	  the same page as the end of the previous buffer and
	  is not page aligned. Examples:
	  buf1 ][ buf2 ][ ...
	  buf1 ]|[ buf2 ][ ...
	
	  @SAME_PAGE_ALIGNED: When the end of the previous buffer
	  is not page aligned, the end of this buffer is on the
	  same page as the end of the previous buffer and is page
	  aligned. When the previous buffer is page aligned, the
	  end of this buffer is aligned to the next page boundary.
	  Examples:
	  buf1 ][ buf2 ]| ...
	  buf1 ]|[ buf2 ]| ...
	
	  @NEXT_PAGE_UNALIGNED: The end of this buffer is on
	  the page next to the end of the previous buffer and
	  is not page aligned. Examples:
	  buf1 ][ buf2 | buf2 ][ ...
	  buf1 ]|[ buf2 | buf2 ][ ...
	
	  @NEXT_PAGE_ALIGNED: The end of this buffer is on
	  the page next to the end of the previous buffer and
	  is page aligned. Examples:
	  buf1 ][ buf2 | buf2 ]| ...
	  buf1 ]|[ buf2 | buf2 ]| ...
	
	  @NEXT_NEXT_UNALIGNED: The end of this buffer is on
	  the page that follows the page after the end of the
	  previous buffer and is not page aligned. Examples:
	  buf1 ][ buf2 | buf2 | buf2 ][ ...
	  buf1 ]|[ buf2 | buf2 | buf2 ][ ...
		
		  Error message on a free page can be false positive
		  if binder shrinker ran during binder_alloc_free_buf
		  calls above.
 Allocate from lru. 
 Generate BUFFER_NUM factorial free orders. 
	
	  Buffers share the first or last few pages.
	  Only BUFFER_NUM - 1 buffer sizes are adjustable since
	  we need one giant buffer before getting to the last page.
  binder_selftest_alloc() - Test alloc and free of buffer pages.
  @alloc: Pointer to alloc struct.
  Allocate BUFFER_NUM buffers to cover all page alignment cases,
  then free them in all orders possible. Check that pages are
  correctly allocated, put onto lru when buffers are freed, and
  are freed when binder_alloc_free_page is called.
 SPDX-License-Identifier: GPL-2.0-only
 binder.c
  Android IPC Subsystem
  Copyright (C) 2007-2008 Google, Inc.
  Locking overview
  There are 3 main spinlocks which must be acquired in the
  order shown:
  1) proc->outer_lock : protects binder_ref
     binder_proc_lock() and binder_proc_unlock() are
     used to acqrel.
  2) node->lock : protects most fields of binder_node.
     binder_node_lock() and binder_node_unlock() are
     used to acqrel
  3) proc->inner_lock : protects the thread and node lists
     (proc->threads, proc->waiting_threads, proc->nodes)
     and all todo lists associated with the binder_proc
     (proc->todo, thread->todo, proc->delivered_death and
     node->async_todo), as well as thread->transaction_stack
     binder_inner_proc_lock() and binder_inner_proc_unlock()
     are used to acqrel
  Any lock under procA must never be nested under any lock at the same
  level or below on procB.
  Functions that require a lock held on entry indicate which lock
  in the suffix of the function name:
  foo_olocked() : requires node->outer_lock
  foo_nlocked() : requires node->lock
  foo_ilocked() : requires proc->inner_lock
  foo_oilocked(): requires proc->outer_lock and proc->inner_lock
  foo_nilocked(): requires node->lock and proc->inner_lock
  ...
	
	  write-barrier to synchronize access to e->debug_id_done.
	  We make sure the initialized 0 value is seen before
	  memset() other fields are zeroed by memset.
  binder_proc_lock() - Acquire outer lock for given binder_proc
  @proc:         struct binder_proc to acquire
  Acquires proc->outer_lock. Used to protect binder_ref
  structures associated with the given proc.
  binder_proc_unlock() - Release spinlock for given binder_proc
  @proc:         struct binder_proc to acquire
  Release lock acquired via binder_proc_lock()
  binder_inner_proc_lock() - Acquire inner lock for given binder_proc
  @proc:         struct binder_proc to acquire
  Acquires proc->inner_lock. Used to protect todo lists
  binder_inner_proc_unlock() - Release inner lock for given binder_proc
  @proc:         struct binder_proc to acquire
  Release lock acquired via binder_inner_proc_lock()
  binder_node_lock() - Acquire spinlock for given binder_node
  @node:         struct binder_node to acquire
  Acquires node->lock. Used to protect binder_node fields
  binder_node_unlock() - Release spinlock for given binder_proc
  @node:         struct binder_node to acquire
  Release lock acquired via binder_node_lock()
  binder_node_inner_lock() - Acquire node and inner locks
  @node:         struct binder_node to acquire
  Acquires node->lock. If node->proc also acquires
  proc->inner_lock. Used to protect binder_node fields
 annotation for sparse 
  binder_node_unlock() - Release node and inner locks
  @node:         struct binder_node to acquire
  Release lock acquired via binder_node_lock()
 annotation for sparse 
  binder_worklist_empty() - Check if no items on the work list
  @proc:       binder_proc associated with list
  @list:	list to check
  Return: true if there are no items on list, else false
  binder_enqueue_work_ilocked() - Add an item to the work list
  @work:         struct binder_work to add to list
  @target_list:  list to add work to
  Adds the work to the specified list. Asserts that work
  is not already on a list.
  Requires the proc->inner_lock to be held.
  binder_enqueue_deferred_thread_work_ilocked() - Add deferred thread work
  @thread:       thread to queue work to
  @work:         struct binder_work to add to list
  Adds the work to the todo list of the thread. Doesn't set the process_todo
  flag, which means that (if it wasn't already set) the thread will go to
  sleep without handling this work when it calls read.
  Requires the proc->inner_lock to be held.
  binder_enqueue_thread_work_ilocked() - Add an item to the thread work list
  @thread:       thread to queue work to
  @work:         struct binder_work to add to list
  Adds the work to the todo list of the thread, and enables processing
  of the todo queue.
  Requires the proc->inner_lock to be held.
  binder_enqueue_thread_work() - Add an item to the thread work list
  @thread:       thread to queue work to
  @work:         struct binder_work to add to list
  Adds the work to the todo list of the thread, and enables processing
  of the todo queue.
  binder_dequeue_work() - Removes an item from the work list
  @proc:         binder_proc associated with list
  @work:         struct binder_work to remove from list
  Removes the specified work item from whatever list it is on.
  Can safely be called if work is not on any list.
  binder_select_thread_ilocked() - selects a thread for doing proc work.
  @proc:	process to select a thread from
  Note that calling this function moves the thread off the waiting_threads
  list, so it can only be woken up by the caller of this function, or a
  signal. Therefore, callers should always wake up the thread this function
  returns.
  Return:	If there's a thread currently waiting for process work,
 		returns that thread. Otherwise returns NULL.
  binder_wakeup_thread_ilocked() - wakes up a thread for doing proc work.
  @proc:	process to wake up a thread in
  @thread:	specific thread to wake-up (may be NULL)
  @sync:	whether to do a synchronous wake-up
  This function wakes up a thread in the @proc process.
  The caller may provide a specific thread to wake-up in
  the @thread parameter. If @thread is NULL, this function
  will wake up threads that have called poll().
  Note that for this function to work as expected, callers
  should first call binder_select_thread() to find a thread
  to handle the work (if they don't have a thread already),
  and pass the result into the @thread parameter.
	 Didn't find a thread waiting for proc work; this can happen
	  in two scenarios:
	  1. All threads are busy handling transactions
	     In that case, one of those threads should call back into
	     the kernel driver soon and pick up this work.
	  2. Threads are using the (e)poll interface, in which case
	     they may be blocked on the waitqueue without having been
	     added to waiting_threads. For this case, we just iterate
	     over all threads not handling transaction work, and
	     wake them all up. We wake all because we don't know whether
	     a thread that called into (e)poll is handling non-binder
	     work currently.
 sync = false);
			
			  take an implicit weak reference
			  to ensure node stays alive until
			  call to binder_put_node()
			
			  A matching node is already in
			  the rb tree. Abandon the init
			  and return it.
		
		  The node was already added by another thread
			
			  See comment above
				
				  tmp_refs could have changed so
				  check it again
	
	  No call to binder_inc_node() is needed since we
	  don't need to inform userspace of any changes to
	  tmp_refs
  binder_inc_node_tmpref() - take a temporary reference on node
  @node:	node to reference
  Take reference on node to prevent the node from being freed
  while referenced only by a local variable. The inner lock is
  needed to serialize with the node work on the queue (which
  isn't needed after the node is dead). If the node is dead
  (node->proc is NULL), use binder_dead_nodes_lock to protect
  node->tmp_refs against dead-node-only cases where the node
  lock cannot be acquired (eg traversing the dead node list to
  print nodes)
  binder_dec_node_tmpref() - remove a temporary reference on node
  @node:	node to reference
  Release temporary reference on node taken via binder_inc_node_tmpref()
	
	  Call binder_dec_node() to check if all refcounts are 0
	  and cleanup is needed. Calling with strong=0 and internal=1
	  causes no actual reference to be released in binder_dec_node().
	  If that changes, a change is needed here too.
  binder_get_ref_for_node_olocked() - get the ref associated with given node
  @proc:	binder_proc that owns the ref
  @node:	binder_node of target
  @new_ref:	newly allocated binder_ref to be initialized or %NULL
  Look up the ref for the given node and return it if it exists
  If it doesn't exist and the caller provides a newly allocated
  ref, initialize the fields of the newly allocated ref and insert
  into the given proc rb_trees and node refs list.
  Return:	the ref for node. It is possible that another thread
 		allocatedinitialized the ref first in which case the
 		returned ref would be different than the passed-in
 		new_ref. new_ref must be kfree'd by the caller in
 		this case.
	
	  Clear ref->node unless we want the caller to free the node
		
		  The caller uses ref->node to determine
		  whether the node needs to be freed. Clear
		  it since the node is still alive.
  binder_inc_ref_olocked() - increment the ref for given handle
  @ref:         ref to be incremented
  @strong:      if true, strong increment, else weak
  @target_list: list to queue node work on
  Increment the ref. @ref->proc->outer_lock must be held on entry
  Return: 0, if successful, else errno
  binder_dec_ref() - dec the ref for given handle
  @ref:	ref to be decremented
  @strong:	if true, strong decrement, else weak
  Decrement the ref.
  Return: true if ref is cleaned up and ready to be freed
  binder_get_node_from_ref() - get the node from the given procdesc
  @proc:	proc containing the ref
  @desc:	the handle associated with the ref
  @need_strong_ref: if true, only return node if ref is strong
  @rdata:	the idrefcount data for the ref
  Given a proc and ref handle, return the associated binder_node
  Return: a binder_node or NULL if not found or not strong when strong required
	
	  Take an implicit reference on the node to ensure
	  it stays alive until the call to binder_put_node()
  binder_free_ref() - free the binder_ref
  @ref:	ref to free
  Free the binder_ref. Free the binder_node indicated by ref->node
  (if non-NULL) and the binder_ref_death indicated by ref->death.
  binder_update_ref_for_handle() - incdec the ref for given handle
  @proc:	proc containing the ref
  @desc:	the handle associated with the ref
  @increment:	true=inc reference, false=dec reference
  @strong:	true=strong reference, false=weak reference
  @rdata:	the idrefcount data for the ref
  Given a proc and ref handle, increment or decrement the ref
  according to "increment" arg.
  Return: 0 if successful, else errno
  binder_dec_ref_for_handle() - dec the ref for given handle
  @proc:	proc containing the ref
  @desc:	the handle associated with the ref
  @strong:	true=strong reference, false=weak reference
  @rdata:	the idrefcount data for the ref
  Just calls binder_update_ref_for_handle() to decrement the ref.
  Return: 0 if successful, else errno
  binder_inc_ref_for_node() - increment the ref for given procnode
  @proc:	 proc containing the ref
  @node:	 target node
  @strong:	 true=strong reference, false=weak reference
  @target_list: worklist to use if node is incremented
  @rdata:	 the idrefcount data for the ref
  Given a proc and node, increment the ref. Create the ref if it
  doesn't already exist
  Return: 0 if successful, else errno
		
		  Another thread created the ref first so
		  free the one we allocated
  binder_thread_dec_tmpref() - decrement thread->tmp_ref
  @thread:	thread to decrement
  A thread needs to be kept alive while being used to create or
  handle a transaction. binder_get_txn_from() is used to safely
  extract t->from from a binder_transaction and keep the thread
  indicated by t->from from being freed. When done with that
  binder_thread, this function is called to decrement the
  tmp_ref and free if appropriate (thread has been released
  and no transaction being processed by the driver)
	
	  atomic is used to protect the counter value while
	  it cannot reach zero or thread->is_dead is false
  binder_proc_dec_tmpref() - decrement proc->tmp_ref
  @proc:	proc to decrement
  A binder_proc needs to be kept alive while being used to create or
  handle a transaction. proc->tmp_ref is incremented when
  creating a new transaction or the binder_proc is currently in-use
  by threads that are being released. When done with the binder_proc,
  this function is called to decrement the counter and free the
  proc if appropriate (proc has been released, all threads have
  been released and not currenly in-use to process a transaction).
  binder_get_txn_from() - safely extract the "from" thread in transaction
  @t:	binder transaction for t->from
  Atomically return the "from" thread and increment the tmp_ref
  count for the thread to ensure it stays alive until
  binder_thread_dec_tmpref() is called.
  Return: the value of t->from
  binder_get_txn_from_and_acq_inner() - get t->from and acquire inner lock
  @t:	binder transaction for t->from
  Same as binder_get_txn_from() except it also acquires the proc->inner_lock
  to guarantee that the thread cannot be released while operating on it.
  The caller must call binder_inner_proc_unlock() to release the inner lock
  as well as call binder_dec_thread_txn() to release the reference.
  Return: the value of t->from
  binder_free_txn_fixups() - free unprocessed fd fixups
  @t:	binder transaction for t->from
  If the transaction is being torn down prior to being
  processed by the target process, free all of the
  fd fixups and fput the file structs. It is safe to
  call this function after the fixups have been
  processed -- in that case, the list will be empty.
	
	  If the transaction has no target_proc, then
	  t->buffer->transaction has already been cleared.
				
				  Cannot get here for normal operation, but
				  we can if multiple synchronous transactions
				  are sent without blocking for responses.
				  Just ignore the 2nd error in this case.
  binder_cleanup_transaction() - cleans up undelivered transaction
  @t:		transaction that needs to be cleaned up
  @reason:	reason the transaction wasn't delivered
  @error_code:	error to return to caller (if synchronous call)
  binder_get_object() - gets object and checks for valid metadata
  @proc:	binder_proc owning the buffer
  @buffer:	binder_buffer that we're parsing.
  @offset:	offset in the @buffer at which to validate an object.
  @object:	struct binder_object to read into
  Return:	If there's a valid metadata object at @offset in @buffer, the
 		size of that object. Otherwise, it returns zero. The object
 		is read into the struct binder_object pointed to by @object.
 Ok, now see if we read a complete object. 
  binder_validate_ptr() - validates binder_buffer_object in a binder_buffer.
  @proc:	binder_proc owning the buffer
  @b:		binder_buffer containing the object
  @object:	struct binder_object to read into
  @index:	index in offset array at which the binder_buffer_object is
 		located
  @start_offset: points to the start of the offset array
  @object_offsetp: offset of @object read from @b
  @num_valid:	the number of valid offsets in the offset array
  Return:	If @index is within the valid range of the offset array
 		described by @start and @num_valid, and if there's a valid
 		binder_buffer_object at the offset found in index @index
 		of the offset array, that object is returned. Otherwise,
 		%NULL is returned.
 		Note that the offset found in index @index itself is not
 		verified; this function assumes that @num_valid elements
 		from @start were previously verified to have valid offsets.
 		If @object_offsetp is non-NULL, then the offset within
 		@b is written to it.
  binder_validate_fixup() - validates pointerfd fixups happen in order.
  @proc:		binder_proc owning the buffer
  @b:			transaction buffer
  @objects_start_offset: offset to start of objects buffer
  @buffer_obj_offset:	offset to binder_buffer_object in which to fix up
  @fixup_offset:	start offset in @buffer to fix up
  @last_obj_offset:	offset to last binder_buffer_object that we fixed
  @last_min_offset:	minimum fixup offset in object at @last_obj_offset
  Return:		%true if a fixup in buffer @buffer at offset @offset is
 			allowed.
  For safety reasons, we only allow fixups inside a buffer to happen
  at increasing offsets; additionally, we only allow fixup on the last
  buffer object that was verified, or one of its parents.
  Example of what is allowed:
  A
    B (parent = A, offset = 0)
    C (parent = A, offset = 16)
      D (parent = C, offset = 0)
    E (parent = A, offset = 32)  min_offset is 16 (C.parent_offset)
  Examples of what is not allowed:
  Decreasing offsets within the same parent:
  A
    C (parent = A, offset = 16)
    B (parent = A, offset = 0)  decreasing offset within A
  Referring to a parent that wasn't the last object or any of its parents:
  A
    B (parent = A, offset = 0)
    C (parent = A, offset = 0)
    C (parent = A, offset = 16)
      D (parent = B, offset = 0)  B is not A or any of A's parents
 Nothing to fix up in 
		
		  Safe to retrieve the parent of last_obj, since it
		  was already previously verified by the driver.
  struct binder_task_work_cb - for deferred close
  @twork:                callback_head for task work
  @fd:                   fd to close
  Structure to pass task work to be handled after
  returning from binder_ioctl() via task_work_add().
  binder_do_fd_close() - close list of file descriptors
  @twork:	callback head for task work
  It is not safe to call ksys_close() during the binder_ioctl()
  function if there is a chance that binder's own file descriptor
  might be closed. This is to meet the requirements for using
  fdget() (see comments for __fget_light()). Therefore use
  task_work_add() to schedule the close operation once we have
  returned from binder_ioctl(). This function is a callback
  for that mechanism and does the actual ksys_close() on the
  given file descriptor.
  binder_deferred_fd_close() - schedule a close for the given file-descriptor
  @fd:		file-descriptor to close
  See comments in binder_do_fd_close(). This function is used to schedule
  a file-descriptor to be closed after returning from binder_ioctl().
			
			  No need to close the file here since user-space
			  closes it for for successfully delivered
			  transactions. For transactions that weren't
			  delivered, the new fd was never allocated so
			  there is no need to close and the fput on the
			  file is done when the transaction is torn
			  down.
			
			  Nothing to do here, this will get cleaned up when the
			  transaction buffer gets freed
				
				  The fd fixups have not been applied so no
				  fds need to be closed.
 No space for all file descriptors here. 
			
			  the source data for binder_buffer_object is visible
			  to user-space and the @buffer element is the user
			  pointer to the buffer_object containing the fd_array.
			  Convert the address to an offset relative to
			  the base of the transaction buffer.
					
					  Need to make sure the thread goes
					  back to userspace to complete the
					  deferred close
	
	  Add fixup record for this transaction. The allocation
	  of the fd in the target needs to be done from a
	  target thread.
 No space for all file descriptors here. 
	
	  the source data for binder_buffer_object is visible
	  to user-space and the @buffer element is the user
	  pointer to the buffer_object containing the fd_array.
	  Convert the address to an offset relative to
	  the base of the transaction buffer.
 No space for a pointer here! 
  binder_proc_transaction() - sends a transaction to a process and wakes it up
  @t:		transaction to send
  @proc:	process to send the transaction to
  @thread:	thread in @proc to send the transaction to (may be NULL)
  This function queues a transaction to the specified process. It will try
  to find a thread in the target process to handle the transaction and
  wake it up. If no thread is found, the work is queued to the proc
  waitqueue.
  If the @thread parameter is not NULL, the transaction is always queued
  to the waitlist of that specific thread.
  Return:	0 if the transaction was successfully queued
 		BR_DEAD_REPLY if the target process or thread is dead
 		BR_FROZEN_REPLY if the target process or thread is frozen
 sync );
  binder_get_node_refs_for_txn() - Get required refs on node for txn
  @node:         struct binder_node for which to get refs
  @proc:         returns @node->proc if valid
  @error:        if no @proc then returns BR_DEAD_REPLY
  User-space normally keeps the node alive when creating a transaction
  since it has a reference to the target. The local strong ref keeps it
  alive if the sending process dies before the target process processes
  the transaction. If the source process is malicious or has a reference
  counting bug, relying on the local strong ref can fail.
  Since user-space can cause the local strong ref to go away, we also take
  a tmpref on the node to ensure it survives while we are constructing
  the transaction. We also need a tmpref on the proc while we are
  constructing the transaction, so we take that here as well.
  Return: The target_node with refs taken or NULL if no @node->proc is NULL.
  Also sets @proc if valid. If the @node->proc is NULL indicating that the
  target proc has died, @error is set to BR_DEAD_REPLY
 annotation for sparse 
			
			  There must already be a strong ref
			  on this node. If so, do a strong
			  increment on the node to ensure it
			  stays alive until the transaction is
			  done.
			
			  return_error is set above
			
			  Do not allow new outgoing transaction from a
			  thread that has a transaction at the head of
			  its todo list. Only need to check the head
			  because binder_select_thread_ilocked picks a
			  thread from proc->waiting_threads to enqueue
			  the transaction, and nothing is queued to the
			  todo list while the thread is on waiting_threads.
 TODO: reuse incoming transaction for reply 
 integer overflow of extra_buffers_size 
		
		  -ESRCH indicates VMA cleared. The target is dying.
 Fixup buffer pointer to target proc address space 
		
		  Defer the TRANSACTION_COMPLETE, so we don't return to
		  userspace immediately; this allows the target process to
		  immediately start processing this transaction, reducing
		  latency. We will then return the TRANSACTION_COMPLETE when
		  the target replies (or there is an error).
	
	  write barrier to synchronize with initialization
	  of log entry
		
		  write barrier to synchronize with initialization
		  of log entry
  binder_free_buf() - free the specified buffer
  @proc:	binder proc that owns buffer
  @buffer:	buffer to be freed
  @is_failure:	failed to send transaction
  If buffer for an async transaction, enqueue the next async
  transaction from the node.
  Cleanup buffer and free it.
				
				  Allocate memory for death notification
				  before taking lock
  binder_apply_fd_fixups() - finish fd translation
  @proc:         binder_proc associated @t->buffer
  @t:	binder transaction with list of fd fixups
  Now that we are in the context of the transaction target
  process, we can allocate and install fds. Process the
  list of fds to translate and fixup the buffer with the
  new fds.
  If we fail to allocate an fd, then free the resources by
  fput'ing files that have not been processed and ksys_close'ing
  any fds that have already been allocated.
 no data added 
				
				  Acquire the node lock before freeing the
				  node to serialize with other threads that
				  may have been holding the node lock while
				  decrementing this node (avoids race where
				  this thread frees while the other thread
				  is unlocking the node after the final
				  decrement)
 DEAD_BINDER notifications can cause transactions 
 the user-space code fails to 
spawn a new thread if we leave this out ) {
	
	  take a ref on the proc so it survives
	  after we remove this thread from proc->threads.
	  The corresponding dec is when we actually
	  free the thread in binder_free_thread()
	
	  take a ref on this thread to ensure it
	  survives while we are releasing it
 annotation for sparse, lock not acquired in last iteration above 
	
	  If this thread used poll, make sure we remove the waitqueue
	  from any epoll data structures holding it with POLLFREE.
	  waitqueue_active() is safe to use here because we're holding
	  the inner lock.
	
	  This is needed to avoid races between wake_up_poll() above and
	  and ep_remove_waitqueue() called for other reasons (eg the epoll file
	  descriptor being closed); ep_remove_waitqueue() holds an RCU read
	  lock, so we can be sure it's done after calling synchronize_rcu().
 This ioctl may only be used by the context manager 
	
	  Freezing the target. Prevent new transactions by
	  setting frozen state. If timeout specified, wait
	  for transactions to drain.
 Check pending transactions that wait for reply 
	pr_info("binder_ioctl: %d:%d %x %lx\n",
 binderfs stashes devices in i_private 
		
		  proc debug entries are shared between contexts.
		  Only create for the first PID to avoid debugfs log spamming
		  The printing code will anyway print all contexts for a given
		  PID so this is not a problem.
		
		  Similar to debugfs, the process specific log file is shared
		  between contexts. Only create for the first PID.
		  This is ok since same as debugfs, the log file will contain
		  information on all contexts of a given PID.
	
	  The caller must have taken a temporary ref on the node,
		
		  Need the node lock to synchronize
		  with new notification requests and the
		  inner lock to synchronize with queued
		  death notifications.
	
	  Make sure proc stays alive after we
	  remove all the threads
		
		  take a temporary ref on the node before
		  calling binder_node_release() which will either
		  kfree() the node or call binder_put_node()
 frees proc 
		
		  Can only safely deref buffer if we are holding the
		  correct proc inner lock for this node
		
		  take a temporary reference on the node so it
		  survives and isn't removed from the tree
		  while we print it.
 Need to drop inner lock to take node lock 
		
		  take a temporary reference on the node so it
		  survives and isn't removed from the list
		  while we print it.
	
	  read barrier to guarantee debug_id_done read before
	  we print the log values
	
	  read-barrier to guarantee read of debug_id_done after
	  done printing the fields of the entry
		
		 Copy the module_parameter string, because we don't want to
		 tokenize it in-place.
 SPDX-License-Identifier: GPL-2.0
 Ensure that the initial ipc namespace always has devices available. 
  binderfs_binder_device_create - allocate inode from super block of a
                                  binderfs mount
  @ref_inode: inode from wich the super block will be taken
  @userp:     buffer to copy information about new device for userspace to
  @req:       struct binderfs_device as copied from userspace
  This function allocates a new binder_device and reserves a new minor
  number for it.
  Minor numbers are limited and tracked globally in binderfs_minors. The
  function will stash a struct binder_device for the specific binder
  device in i_private of the inode.
  It will go on to allocate a new inode from the super block of the
  filesystem mount, stash a struct binder_device in its i_private field
  and attach a dentry to that inode.
  Return: 0 on success, negative errno on failure
 Reserve new minor number for the new device. 
 NUL-terminate 
 Make sure to include terminating NUL byte 
 look it up 
 already exists 
  binderfs_ctl_ioctl - handle binder device node allocation requests
  The request handler for the binder-control device. All requests operate on
  the binderfs mount the binder-control device resides in:
  - BINDER_CTL_ADD
    Allocate a new binder device.
  Return: 0 on success, negative errno on failure
  binderfs_binder_ctl_create - create a new binder-control device
  @sb: super block of the binderfs mount
  This function creates a new binder-control device node in the binderfs mount
  referred to by @sb.
  Return: 0 on success, negative errno on failure
 If we have already created a binder-control node, return. 
 Reserve a new minor number for the new device. 
 Return error if the filedir already exists. 
	
	  The binderfs filesystem can be mounted by userns root in a
	  non-initial userns. By default such mounts have the SB_I_NODEV flag
	  set in s_iflags to prevent security issues where userns root can
	  just create random device nodes via mknod() since it owns the
	  filesystem mount. But binderfs does not allow to create any files
	  including devices nodes. The only way to create binder devices nodes
	  is through the binder-control device which userns root is explicitly
	  allowed to do. So removing the SB_I_NODEV flag from s_iflags is both
	  necessary and safe.
 Verify that the default binderfs device names are valid. 
 Allocate new major number for binderfs. 
 SPDX-License-Identifier: GPL-2.0-only
 binder_alloc.c
  Android IPC Subsystem
  Copyright (C) 2007-2017 Google, Inc.
			
			  Guard against user threads attempting to
			  free the buffer when in use by kernel or
			  after it's already been freed.
  binder_alloc_prepare_to_free() - get buffer given user ptr
  @alloc:	binder_alloc for this proc
  @user_ptr:	User pointer to buffer data
  Validate userspace pointer to buffer data and return buffer corresponding to
  that user pointer. Search the rb tree for buffer that matches user data
  pointer.
  Return:	Pointer to buffer or NULL
	
	  If we see alloc->vma is not NULL, buffer data structures set up
	  completely. Look at smp_rmb side binder_alloc_get_vma.
	  We also want to guarantee new alloc->vma_vm_mm is always visible
	  if alloc->vma is set.
 Look at description in binder_alloc_set_vma 
	
	  Find the amount and size of buffers allocated by the current caller;
	  The idea is that once we cross the threshold, whoever is responsible
	  for the low async space is likely to try to send another async txn,
	  and at some point we'll catch them in the act. This is more efficient
	  than keeping a map per pid.
	
	  Warn if this pid has more than 50 transactions, or more than 50% of
	  async space (which is 25% of total buffer size). Oneway spam is only
	  detected when the threshold is exceeded.
 Pad 0-size buffers so they get assigned unique addresses 
			
			  Start detecting spammers once we have less than 20%
			  of async space left (which is less than 10% of total
			  buffer size).
  binder_alloc_new_buf() - Allocate a new binder buffer
  @alloc:              binder_alloc for this proc
  @data_size:          size of user data buffer
  @offsets_size:       user specified buffer offset
  @extra_buffers_size: size of extra space for meta-data (eg, security context)
  @is_async:           buffer for async transaction
  @pid:				pid to attribute allocation to (used for debugging)
  Allocate a new buffer given the requested sizes. Returns
  the kernel version of the buffer pointer. The size allocated
  is the sum of the three given sizes (each rounded up to
  pointer-sized boundary)
  Return:	The allocated buffer or %NULL if error
  binder_alloc_free_buf() - free a binder buffer
  @alloc:	binder_alloc for this proc
  @buffer:	kernel pointer to buffer
  Free the buffer allocated via binder_alloc_new_buf()
	
	  We could eliminate the call to binder_alloc_clear_buf()
	  from binder_alloc_deferred_release() by moving this to
	  binder_alloc_free_buf_locked(). However, that could
	  increase contention for the alloc mutex if clear_on_free
	  is used frequently for large buffers. The mutex is not
	  needed for correctness here.
  binder_alloc_mmap_handler() - map virtual address space for proc
  @alloc:	alloc structure for this proc
  @vma:	vma passed to mmap()
  Called by binder_mmap() to initialize the space specified in
  vma for allocating binder buffers
  Return:
       0 = success
       -EBUSY = address space already mapped
       -ENOMEM = failed to map memory to given address space
 Transaction should already have been freed 
  binder_alloc_print_allocated() - print buffer info
  @m:     seq_file for output via seq_printf()
  @alloc: binder_alloc for this proc
  Prints information about every buffer associated with
  the binder_alloc state to the given seq_file
  binder_alloc_print_pages() - print page usage
  @m:     seq_file for output via seq_printf()
  @alloc: binder_alloc for this proc
	
	  Make sure the binder_alloc is fully initialized, otherwise we might
	  read inconsistent state.
  binder_alloc_get_allocated_count() - return count of buffers
  @alloc: binder_alloc for this proc
  Return: count of allocated buffers
  binder_alloc_vma_close() - invalidate address space
  @alloc: binder_alloc for this proc
  Called from binder_vma_close() when releasing address space.
  Clears alloc->vma to prevent new incoming transactions from
  allocating more buffers.
  binder_alloc_free_page() - shrinker callback to free pages
  @item:   item to free
  @lock:   lock protecting the item
  @cb_arg: callback argument
  Called from list_lru_walk() in binder_shrink_scan() to free
  up pages when the system is under memory pressure.
  binder_alloc_init() - called by binder_open() for per-proc initialization
  @alloc: binder_alloc for this proc
  Called from binder_open() to initialize binder_alloc fields for
  new binder proc
  check_buffer() - verify that bufferoffset is safe to access
  @alloc: binder_alloc for this proc
  @buffer: binder buffer to be accessed
  @offset: offset into @buffer data
  @bytes: bytes to access from offset
  Check that the @offset@bytes are within the size of the given
  @buffer and that the buffer is currently active and not freeable.
  Offsets must also be multiples of sizeof(u32). The kernel is
  allowed to touch the buffer in two cases:
  1) when the buffer is being created:
      (buffer->free == 0 && buffer->allow_user_free == 0)
  2) when the buffer is being torn down:
      (buffer->free == 0 && buffer->transaction == NULL).
  Return: true if the buffer is safe to access
  binder_alloc_get_page() - get kernel pointer for given buffer offset
  @alloc: binder_alloc for this proc
  @buffer: binder buffer to be accessed
  @buffer_offset: offset into @buffer data
  @pgoffp: address to copy final page offset to
  Lookup the struct page corresponding to the address
  at @buffer_offset into @buffer->user_data. If @pgoffp is not
  NULL, the byte-offset into the page is written there.
  The caller is responsible to ensure that the offset points
  to a valid address within the @buffer and that @buffer is
  not freeable by the user. Since it can't be freed, we are
  guaranteed that the corresponding elements of @alloc->pages[]
  cannot change.
  Return: struct page
  binder_alloc_clear_buf() - zero out buffer
  @alloc: binder_alloc for this proc
  @buffer: binder buffer to be cleared
  memset the given buffer to 0
  binder_alloc_copy_user_to_buffer() - copy src user to tgt user
  @alloc: binder_alloc for this proc
  @buffer: binder buffer to be accessed
  @buffer_offset: offset into @buffer data
  @from: userspace pointer to source buffer
  @bytes: bytes to copy
  Copy bytes from source userspace to target buffer.
  Return: bytes remaining to be copied
 All copies must be 32-bit aligned and 32-bit size 
		
		  kunmap_atomic() takes care of flushing the cache
		  if this device has VIVT cache arch
 SPDX-License-Identifier: GPL-2.0-only
  Driver for the CS5535CS5536 Multi-Function General Purpose Timers (MFGPT)
  Copyright (C) 2006, Advanced Micro Devices, Inc.
  Copyright (C) 2007  Andres Salomon <dilinger@debian.org>
  Copyright (C) 2009  Andres Salomon <dilinger@collabora.co.uk>
  The MFGPTs are documented in AMD Geode CS5536 Companion Device Data Book.
	
	  The register maps for these are described in sections 6.17.1.x of
	  the AMD Geode CS5536 Companion Device Data Book.
		
		  XXX: According to the docs, we cannot reset timers above
		  6; that is, resets for 7 and 8 will be ignored.  Is this
		  a problem?   -dilinger
	
	  Unfortunately, MFGPTs come in pairs sharing their IRQ lines. If VSA
	  is using the same CMP of the timer's Siamese twin, the IRQ is set to
	  2, and we mustn't use nor change it.
	  XXX: Likewise, 2 Linux drivers might clash if the 2nd overwrites the
	  IRQ of the 1st. This can only happen if forcing an IRQ, calling this
	  with irq==0 is safe. Currently there _are_ no 2 drivers.
 Choose IRQ: if none supplied, keep IRQ already set or use default 
 Can't use IRQ if it's 0 (=disabled), 2, or routed to LPC 
 All chosen and checked - go for it 
 only allocate timers from the working domain if requested 
 programmer error.  silly programmers! 
 try to find any available timer 
 set timer_nr to -1 if no timers available 
 check if the requested timer's available 
 if timer_nr is not -1, it's an available timer 
 aw hell 
  XXX: This frees the timer memory, but never resets the actual hardware
  timer.  The old geode_mfgpt code did this; it would be good to figure
  out a way to actually release the hardware timer.  See comments below.
 timer can be made available again only if never set up 
  This is a sledgehammer that resets all MFGPT timers. This is required by
  some broken BIOSes which leave the system in an unstable state
  (TinyBIOS 0.98, for example; fixed in 0.99).  It's uncertain as to
  whether or not this secret MSR can be used to release individual timers.
  Jordan tells me that he and Mitch once played w it, but it's unclear
  what the results of that were (and they experienced some instability).
 The following undocumented bit resets the MFGPT timers 
  This is another sledgehammer to reset all MFGPT timers.
  Instead of using the undocumented bit method it clears
  IRQ, NMI and RESET settings.
  Check whether any MFGPTs are available for the kernel to use.  In most
  cases, firmware that uses AMD's VSA code will claim all timers during
  bootup; we certainly don't want to take them if they're already in use.
  In other cases (such as with VSAless OpenFirmware), the system firmware
  leaves timers available for us to use.
 bios workaround 
 just to be safe, protect this section w lock 
	 There are two ways to get the MFGPT base address; one is by
	  fetching it from MSR_LBAR_MFGPT, the other is by reading the
	  PCI BAR info.  The latter method is easier (especially across
	  different architectures), so we'll stick with that for now.  If
	  it turns out to be unreliable in the face of crappy BIOSes, we
 set up the driver-specific struct 
 detect the available timers 
 SPDX-License-Identifier: GPL-2.0-only
  kgdbts is a test suite for kgdb for the sole purpose of validating
  that key pieces of the kgdb internals are working properly such as
  HWSW breakpoints, single stepping, and NMI.
  Created by: Jason Wessel <jason.wessel@windriver.com>
  Copyright (c) 2008 Wind River Systems, Inc.
 Information about the kgdb test suite.
  -------------------------------------
  The kgdb test suite is designed as a KGDB IO module which
  simulates the communications that a debugger would have with kgdb.
  The tests are broken up in to a line by line and referenced here as
  a "get" which is kgdb requesting input and "put" which is kgdb
  sending a response.
  The kgdb suite can be invoked from the kernel command line
  arguments system or executed dynamically at run time.  The test
  suite uses the variable "kgdbts" to obtain the information about
  which tests to run and to configure the verbosity level.  The
  following are the various characters you can use with the kgdbts=
  line:
  When using the "kgdbts=" you only choose one of the following core
  test types:
  A = Run all the core tests silently
  V1 = Run all the core tests with minimal output
  V2 = Run all the core tests in debug mode
  You can also specify optional tests:
  N## = Go to sleep with interrupts of for ## seconds
        to test the HW NMI watchdog
  F## = Break at kernel_clone for ## iterations
  S## = Break at sys_open for ## iterations
  I## = Run the single step test ## iterations
  NOTE: that the kernel_clone and sys_open tests are mutually exclusive.
  To invoke the kgdb test suite from boot you use a kernel start
  argument as follows:
  	kgdbts=V1 kgdbwait
  Or if you wanted to perform the NMI test for 6 seconds and kernel_clone
  test for 100 forks, you could use:
  	kgdbts=V1N6F100 kgdbwait
  The test suite can also be invoked at run time with:
 	echo kgdbts=V1N6F100 > sysmodulekgdbtsparameterskgdbts
  Or as another example:
 	echo kgdbts=V2 > sysmodulekgdbtsparameterskgdbts
  When developing a new kgdb arch specific implementation or
  using these tests for the purpose of regression testing,
  several invocations are required.
  1) Boot with the test suite enabled by using the kernel arguments
        "kgdbts=V1F100 kgdbwait"
     ## If kgdb arch specific implementation has NMI use
        "kgdbts=V1N6F100
  2) After the system boot run the basic test.
  echo kgdbts=V1 > sysmodulekgdbtsparameterskgdbts
  3) Run the concurrency tests.  It is best to use n+1
     while loops where n is the number of cpus you have
     in your system.  The example below uses only two
     loops.
  ## This tests break points on sys_open
  while [ 1 ] ; do find  > devnull 2>&1 ; done &
  while [ 1 ] ; do find  > devnull 2>&1 ; done &
  echo kgdbts=V1S10000 > sysmodulekgdbtsparameterskgdbts
  fg # and hit control-c
  fg # and hit control-c
  ## This tests break points on kernel_clone
  while [ 1 ] ; do date > devnull ; done &
  while [ 1 ] ; do date > devnull ; done &
  echo kgdbts=V1F1000 > sysmodulekgdbtsparameterskgdbts
  fg # and hit control-c
 Storage for the registers, in GDB format. 
 -1 = init not run yet, 0 = unconfigured, 1 = configured. 
	 Wait until the tests are complete and then ungresiter the IO
	  driver.
 Pause for any other threads to exit after final ack. 
 This is noinline such that it can be used for a single location to
  place a breakpoint
  This is a cached wrapper for kallsyms_lookup_name().
  The cache is a big win for several tests. For example it more the doubles
  the cycles per second during the sys_open test. This is not theoretic,
  the performance improvement shows up at human scale, especially when
  testing using emulators.
  Obviously neither re-entrant nor thread-safe but that is OK since it
  can only be called from the debug trap (and therefore all other CPUs
  are halted).
 On some arches, a breakpoint stop requires it to be decremented 
 This is special case for emulated single step 
 Readjust the instruction pointer if needed 
	
	  From an arch indepent point of view the instruction pointer
	  should be on a different instruction
		
		  Ensure we stopped in the same thread id as before, else the
		  debugger should continue until the original thread that was
		  single stepped is scheduled again, emulating gdb's behavior.
 Always send detach because the test is completed at this point 
 This is at the end of the test and we catch any and all input 
 Start by looking at the current PC 
 set breakpoint 
 Continue 
 Clear breakpoint 
 validate the "g" packet to get the IP 
 Want to stop at IP + break instruction size by default 
 Single step is complete so continue on! 
 Continue on the same test line until emulation is complete 
  Test to plant a breakpoint and detach, which should clear out the
  breakpoint and restore the original instruction.
 Clear break points 
 set sw breakpoint 
 Detach 
  Simple test to write in a software breakpoint, check for the
  correct stop location and detach.
 Clear break points 
 set sw breakpoint 
 Continue 
remove breakpoint 
 Detach 
 On success we made it here 
  Test a known bad memory read location to test the fault handler and
  read bytes 1-8 at the bad address
 Clear break points 
 read 1 byte at address 1 
 read 1 byte at address 2 
 read 1 byte at address 3 
 read 1 byte at address 4 
 read 1 byte at address 5 
 read 1 byte at address 6 
 read 1 byte at address 7 
 read 1 byte at address 8 
 Detach which removes all breakpoints and continues 
  Test for hitting a breakpoint, remove it, single step, plant it
  again and detach.
 Clear break points 
 set sw breakpoint 
 Continue 
remove breakpoint 
 Write registers 
 Single step 
 set sw breakpoint 
 Continue 
 Write registers 
 Remove all breakpoints and continues 
  Test for hitting a breakpoint at kernel_clone for what ever the number
  of iterations required by the variable repeat_test.
 Clear break points 
 set sw breakpoint 
 Continue 
remove breakpoint 
 check location 
 Write registers 
 Single step 
 set sw breakpoint 
 Loop based on repeat_test 
 detach and unregister IO 
 Test for hitting a breakpoint at sys_open for what ever the number
  of iterations required by the variable repeat_test.
 Clear break points 
 set sw breakpoint 
 Continue 
remove breakpoint 
 check location 
 Write registers 
 Single step 
 set sw breakpoint 
 Loop based on repeat_test 
 detach and unregister IO 
  Test for hitting a simple hw breakpoint
 Clear break points 
 set hw breakpoint 
 Continue 
remove breakpoint 
 Detach 
 On success we made it here 
  Test for hitting a hw write breakpoint
 Clear break points 
 set hw breakpoint 
 Continue 
remove breakpoint 
 Detach 
 On success we made it here 
  Test for hitting a hw access breakpoint
 Clear break points 
 set hw breakpoint 
 Continue 
remove breakpoint 
 Detach 
 On success we made it here 
  Test for hitting a hw access breakpoint
 Clear break points 
 Continue 
 Detach 
 On success we made it here 
		 If someone does a  to match the rest of the string, allow
		  it, or stop if the received string is complete.
		 Send an ACK on the get if a prior put completed and set the
		  send ack variable
		 On the first get char, fill the transmit buffer and then
		  take from the get_string.
	 This callback is a put char which is when kgdb sends data to
	  this IO module.
 Ignore everything until the first valid packet start '$' 
 End of packet == #XX so look for the '#' 
 Trigger check here 
 Activate test with initial breakpoint 
 complete the detach test 
 Activate test with initial breakpoint 
 run code with the break point in it 
 Activate test with initial breakpoint 
 Activate test with initial breakpoint 
 Activate test with initial breakpoint 
 Activate test with initial breakpoint 
 Activate test with initial breakpoint 
 Activate test with initial breakpoint 
 All HW break point tests 
 required internal KGDB tests 
 ===Optional tests=== 
	 If the kernel_clone test is run it will be the last test that is
	  executed because a kernel thread will be spawned at the very
	  end to unregister the debug hooks.
	 If the sys_open test is run it will be the last test that is
	  executed because a kernel thread will be spawned at the very
	  end to unregister the debug hooks.
 Shutdown and unregister 
 Already configured? 
 Only copy in the string if the init function has not run yet 
 Chop out \n char as a result of echo 
 Go and configure with the new params. 
 Increment the module count when the debugger is active 
 decrement the module count when the debugger detaches 
  not really modular, but the easiest way to keep compat with existing
  bootargs behaviour is to continue using module_param here.
 SPDX-License-Identifier: GPL-2.0-only
   tifm_7xx1.c - TI FlashMedia driver
   Copyright (C) 2006 Alex Dubov <oakad@yahoo.com>
 xd needs some extra time before power on 
 wait for power to stabilize 
 tifm_alloc_device will check if media_id is valid
 Maximum number of entries is 4 
 xx21 - the one I have 
 SPDX-License-Identifier: GPL-2.0-only
  Dallas Semiconductor DS1682 Elapsed Time Recorder device driver
  Written by: Grant Likely <grant.likely@secretlab.ca>
  Copyright (C) 2007 Secret Lab Technologies Ltd.
  The DS1682 elapsed timer recorder is a simple device that implements
  one elapsed time counter, one event counter, an alarm signal and 10
  bytes of general purpose EEPROM.
  This driver provides access to the DS1682 counters and user data via
  the sysfs.  The following attributes are added to the device node:
      elapsed_time (u32): Total elapsed event time in ms resolution
      alarm_time (u32): When elapsed time exceeds the value in alarm_time,
                        then the alarm pin is asserted.
      event_count (u16): number of times the event pin has gone low.
      eeprom (u8[10]): general purpose EEPROM
  Counter registers and user data are both readwrite unless the device
  has been write protected.  This driver does not support turning off write
  protection.  Once write protection is turned on, it is impossible to
  turn it off again, so I have left the feature out of this driver to avoid
  accidental enabling, but it is trivial to add write protect support.
 Device registers 
  Generic counter attributes
 Read the register 
 Detect and retry when a tick occurs mid-read 
	 Format the output string and return # of bytes
	  Special case: the 32 bit regs are time values with 14s
	  resolution, scale them up to milliseconds
 Decode input 
	 Special case: the 32 bit regs are time values with 14s
 write out the value 
  Simple register attributes
  User data attribute
 Write out to the device 
  Called when a ds1682 device is matched with this driver
 SPDX-License-Identifier: GPL-2.0
  Driver for the HP iLO management processor.
  Copyright (C) 2008 Hewlett-Packard Development Company, L.P.
 	David Altobelli <david.altobelli@hpe.com>
 auxiliary iLO 
 CL 
  FIFO queues, shared with hardware.
  If a queue has empty slots, an entry is added to the queue tail,
  and that entry is marked as occupied.
  Entries can be dequeued from the head of the list, when the device
  has marked the entry as consumed.
  Returns true on successful queuedequeue, false on failure.
 for simplicity, use the same parameters for send and recv ctrls 
 size of a fifo is determined by the number of entries it contains 
 set up an empty fifo 
 complicated dance to tell the hw we are stopping 
 give iLO some time to process stop request 
 clear the hw ccb 
 free resources used to back sendrecv queues 
	
	  Create two ccb's, one with virt addrs, one with phys addrs.
	  Copy the phys addr ccb to device shared mem.
 hw ccb's doorbell is not used 
 copy the ccb with physical addrs to device memory 
 put packets on the send and receive queues 
 the ccb is ready to use 
 make sure iLO is really handling requests 
 check for this particular channel needing a reset 
 set a flag indicating this channel needs a reset 
 check for global reset condition 
 clear the device (reset bits, pending channel entries) 
	
	  Mapped memory is zeroed on ilo reset, so set a per ccb flag
	  to indicate that this ccb needs to be closed and reopened.
		
		  If the device has been reset, applications
		  need to close and reopen all ccbs.
	
	  This function is to be called when data is expected
	  in the channel, and will return an error if no packet is found
	  during the loop below.  The sleepretry logic is to allow
	  applications to call read() immediately post write(),
	  and give iLO some time to process the sent packet.
 look for a received packet 
 only copy the length of the received packet 
 return the received packet to the queue 
 get a packet to send the user command 
 limit the length to the length of the packet 
 on failure, set the len to 0 to return empty packet to the device 
 send the packet 
 new ccb allocation 
 each fd private_data holds swhw view of ccb 
 create a channel control block for this minor 
 write the ccb to hw 
 make sure the channel is functional 
			
			  The channel exists, and either this open
			  or a previous open of this channel wants
			  exclusive access.
 check for ccbs which have data 
 wake up all ccbs if the device was reset 
 clear the device of the channels that have been handled 
 map the memory mapped io registers 
 map the adapter shared memory region 
 Last 8k is reserved for CCBs 
 map the doorbell aperture 
	
	  pci_disable_device(pdev) used to be here. But this PCI device has
	  two functions with interrupt lines connected to a single pin. The
	  other one is a USB host controller. So when we disable the PIN here
	  e.g. by rmmod hpilo, the controller stops working. It is because
	  the interrupt link is disabled in ACPI since it is not refcounted
	  yet. See acpi_pci_link_free_irq called from acpi_pci_irq_disable.
 find a free range for device files 
 track global allocations for this device 
	pci_disable_device(pdev);  see comment in ilo_remove 
 SPDX-License-Identifier: GPL-2.0
  Support for usb functionality of Hikey series boards
  based on Hisilicon Kirin Soc.
  Copyright (C) 2017-2018 Hilisicon Electronics Co., Ltd.
 		http:www.huawei.com
  Authors: Yu Chen <chenyu56@huawei.com>
 SPDX-License-Identifier: GPL-2.0-only
  Host side test driver to test endpoint functionality
  Copyright (C) 2017 Texas Instruments
  Author: Kishon Vijay Abraham I <kishon@ti.com>
 mutex to protect the ioctls 
 SPDX-License-Identifier: GPL-2.0-only
  Enclosure Services
  Copyright (C) 2008 James Bottomley <James.Bottomley@HansenPartnership.com>
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
  enclosure_find - find an enclosure given a parent device
  @dev:	the parent to match against
  @start:	Optional enclosure device to start from (NULL if none)
  Looks through the list of registered enclosures to find all those
  with @dev as a parent.  Returns NULL if no enclosure is
  found. @start can be used as a starting point to obtain multiple
  enclosures per parent (should begin with NULL and then be set to
  each returned enclosure device). Obtains a reference to the
  enclosure class device which must be released with device_put().
  If @start is not NULL, a reference must be taken on it which is
  released before returning (this allows a loop through all
  enclosures to exit with only the reference on the enclosure of
  interest held).  Note that the @dev may correspond to the actual
  device housing the enclosure, in which case no iteration via @start
  is required.
		 parent might not be immediate, so iterate up to
  enclosure_for_each_device - calls a function for each enclosure
  @fn:		the function to call
  @data:	the data to pass to each call
  Loops over all the enclosures calling the function.
  Note, this function uses a mutex which will be held across calls to
  @fn, so it must have non atomic context, and @fn may (although it
  should not) sleep or otherwise cause the mutex to be held for
  indefinite periods
  enclosure_register - register device as an enclosure
  @dev:	device containing the enclosure
  @name:	chosen device name
  @components:	number of components in the enclosure
  @cb:         platform call-backs
  This sets up the device for being an enclosure.  Note that @dev does
  not have to be a dedicated enclosure device.  It may be some other type
  of device that additionally responds to enclosure services
  enclosure_unregister - remove an enclosure
  @edev:	the registered enclosure to remove;
 prevent any callbacks into service user 
	
	  In odd circumstances, like multipath devices, something else may
	  already have removed the links, so check for this condition first.
  enclosure_component_alloc - prepare a new enclosure component
  @edev:	the enclosure to add the component
  @number:	the device number
  @type:	the type of component being added
  @name:	an optional name to appear in sysfs (leave NULL if none)
  The name is optional for enclosures that give their components a unique
  name.  If not, leave the field NULL and a name will be assigned.
  Returns a pointer to the enclosure component or an error.
		 Some hardware (e.g. enclosure in RX300 S6) has components
		  with non unique names. Registering duplicates in sysfs
		  will lead to warnings during bootup. So make the names
  enclosure_component_register - publishes an initialized enclosure component
  @ecomp:	component to add
  Returns 0 on successful registration, releases the component otherwise
  enclosure_add_device - add a device as being part of an enclosure
  @edev:	the enclosure device being added to.
  @component:	the number of the component
  @dev:	the device being added
  Declares a real device to reside in slot (or identifier) @num of an
  enclosure.  This will cause the relevant sysfs links to appear.
  This function may also be used to change a device associated with
  an enclosure without having to call enclosure_remove_device() in
  between.
  Returns zero on success or an error.
  enclosure_remove_device - remove a device from an enclosure
  @edev:	the enclosure device
  @dev:	device to removeput
  Returns zero on success or an error.
  sysfs pieces below
 If still uninitialized, the callback failed or does not exist. 
 if the enclosure does not override then use 'number' as a stand-in 
 SPDX-License-Identifier: GPL-2.0-only
   tifm_core.c - TI FlashMedia driver
   Copyright (C) 2006 Alex Dubov <oakad@yahoo.com>
 CONFIG_PM 
 SPDX-License-Identifier: GPL-2.0-or-later
  Generic on-chip SRAM allocation driver
  Copyright (C) 2012 Philipp Zabel, Pengutronix
	
	  We need an additional block to mark the end of the memory region
	  after the reserved blocks from the dt are processed.
 the last chunk marks the end of the region 
 can only happen if sections overlap 
 current start is in a reserved block, so continue after it 
		
		  allocate the space between the current starting
		  address and the following reserved block, or the
		  end of the region.
 next allocation after this reserved block 
  SYSRAM contains areas that are not accessible by the
  kernel, such as the first 256K that is reserved for TZ.
  Accesses to those areas (including speculative accesses)
  trigger SErrors. As such we must map only the areas of
  SYSRAM specified in the device tree.
 SPDX-License-Identifier: GPL-2.0-only
  This file is part of the APDS990x sensor driver.
  Chip is combined proximity and ambient light sensor.
  Copyright (C) 2010 Nokia Corporation andor its subsidiary(-ies).
  Contact: Samu Onkalo <samu.p.onkalo@nokia.com>
 Register map 
 Enable of states and interrupts 
 ALS ADC time  
 Proximity ADC time  
 Wait time  
 ALS interrupt low threshold low byte 
 ALS interrupt low threshold hi byte 
 ALS interrupt hi threshold low byte 
 ALS interrupt hi threshold hi byte 
 Proximity interrupt low threshold low byte 
 Proximity interrupt low threshold hi byte 
 Proximity interrupt hi threshold low byte 
 Proximity interrupt hi threshold hi byte 
 Interrupt persistence filters 
 Configuration 
 Proximity pulse count 
 Gain control register 
 Revision Number 
 Device ID 
 Device status 
 Clear ADC low data register 
 Clear ADC high data register 
 IR ADC low data register 
 IR ADC high data register 
 Proximity ADC low data register 
 Proximity ADC high data register 
 Control 
 Enable register 
 Status register 
 I2C access types 
 Repeated byte 
 Auto increment 
 Special function 
 Interrupt ack commands 
 ptime 
 Recommended conversion time 2.7ms
 wtime 
 ~50ms wait time 
 One timetick as ADC count value 
 Persistence 
 Supported ID:s 
 pgain and pdiode settings 
 Reverse chip factors for threshold calculation 
 avoid parallel access 
 Chip parameters 
 als integration time 
 als reporting rate 
 Max possible ADC value with current atime 
 Gain used in last measurement 
 Next calculated gain 
 us 
 2.7ms is about 87  32 
 tolerates 5060Hz ripple 
 ALS gain steps 
 Following two tables must match i.e 10Hz rate means 1 as persistence value 
 Regulators 
 ALS is mandatory, proximity optional 
	
	  Reported LUX value is a combination of the IR and CLEAR channel
	  values. However, interrupt threshold is only for clear channel.
	  This function approximates needed HW threshold value for a given
	  LUX value in the current lightning type.
	  IR level compared to visible light varies heavily depending on the
	  source of the light
	 
	  Calculate threshold value for the next measurement period.
	  Math: threshold = lux  cpl where
	  cpl = atime  again  (glass_attenuation  device_factor)
	  (count-per-lux)
	 
	  First remove calibration. Division by four is to avoid overflow
 Multiplication by 64 is to increase accuracy 
	
	  Convert IR light from the latest result to match with
	  new gain step. This helps to adapt with the current
	  source of light.
	
	  Compensate count with IR light impact
	  IAC1 > IAC2 (see apds990x_get_lux for formulas)
 Formula is specified in the data sheet 
 Calculate max ADC value for given integration time 
 Called always with mutex locked 
 If the chip is not in use, don't try to access it 
 Called always with mutex locked 
 If the chip is not in use, don't try to access it 
 Called always with mutex locked 
 This will force ALS interrupt after the next measurement. 
 Called always with mutex locked 
 This will force proximity interrupt after the next measurement. 
 Called always with mutex locked 
 Calculate suitable als gain 
 ALS saturated. Decrease gain by 2 steps 
 Too dark. Increase gain by 2 steps 
 Limit gain to available range 
 Let's check can we trust the measured result 
 Result can be totally garbage due to saturation 
		
		  Gain is changed and measurement result is very small.
		  Result can be totally garbage due to underflow
	
	  Error means bad result -> re-measurement is needed. The forced
	  refresh uses fastest possible persistence setting to get result
	  as soon as possible.
 Called always with mutex locked 
 IR adjusted counts 
 Lux per count 
	 Formulas:
	  iac1 = CF1  CLEAR_CH - IRF1  IR_CH
	  iac2 = CF2  CLEAR_CH - IRF2  IR_CH
 Store used gain for calculations 
 Result is valid 
			
			  If ALS channel is saturated at min gain,
			  proximity gives false posivite values.
			  Just ignore them.
 It is recommended to use disabled mode during these operations 
 conversion and wait times for different state machince states 
 Persistence levels 
 Start with relatively small gain 
 Refresh all configs in case of regulators were off 
 Pick up corresponding persistence value 
 If the chip is not in use, don't try to access it 
 Persistence levels 
	
	  Don't update values in HW if we are still waiting for
	  first interrupt to come after device handle open call.
 set uncovered sensor default parameters 
 0.48  APDS_PARAM_SCALE 
 1.00  APDS_PARAM_SCALE 
 2.23  APDS_PARAM_SCALE 
 0.70  APDS_PARAM_SCALE 
 1.42  APDS_PARAM_SCALE 
 precalculate inverse chip factors for threshold control 
 Set something to start with 
	
	  If we were enabled at suspend time, it is expected
	  everything works nice and smoothly. Chip_on is enough
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2011-2018, The Linux Foundation. All rights reserved.
 Copyright (c) 2018, Linaro Limited
 adsp, mdsp, slpi, cdsp
12 compute, 1 cpz
 Retrives number of input buffers from the scalars parameter 
 Retrives number of output buffers from the scalars parameter 
 Retrives number of input handles from the scalars parameter 
 Retrives number of output handles from the scalars parameter 
 Remote Method id table 
 Protection Domain(PD) ids 
 also GUEST_OS PD? 
 physical address 
 size of contiguous region 
 number of contiguous regions 
 index to start of contiguous region 
 process group id 
 thread id 
 invoke caller context 
 handle to invoke 
 scalars structure describing the data 
 physical address 
 size of contiguous region 
 invoke caller context 
 invoke return value 
 Lock for dma buf attachments 
 mmap support 
 list of user requested mmaps 
 list of ctxs 
 Lock for lists 
 lock for allocations 
 sort with lowest starting buffer first 
 sort with highest ending buffer first 
 Falling inside previous range 
 Released in fastrpc_context_put() 
  Fastrpc payload buffer with metadata looks like:
  >>>>>>  START of METADATA <<<<<<<<<
  +---------------------------------+
  |           Arguments             |
  | type:(struct fastrpc_remote_arg)|
  |             (0 - N)             |
  +---------------------------------+
  |         Invoke Buffer list      |
  | type:(struct fastrpc_invoke_buf)|
  |           (0 - N)               |
  +---------------------------------+
  |         Page info list          |
  | type:(struct fastrpc_phy_page)  |
  |             (0 - N)             |
  +---------------------------------+
  |         Optional info           |
  |(can be specific to SoCFirmware)|
  +---------------------------------+
  >>>>>>>>  END of METADATA <<<<<<<<<
  +---------------------------------+
  |         Inline ARGS             |
  |            (0-N)                |
  +---------------------------------+
 Make sure reserved field is set to 0 
 make sure that all CPU memory writes are seen by DSP 
 Send invoke buffer to remote dsp 
 Check the response from remote dsp 
 make sure that all memory writes by DSP are seen by CPU 
 populate all the output buffers with results 
 We are done with this compute context 
 Released in fastrpc_device_release() 
 nscalars is truncated here to max supported value 
 update the buffer to be able to deallocate the memory on the DSP 
 let the client know the address to use 
 unmap the memory and release the buffer 
	
	  The DMA buffer associated with the context cannot be freed in
	  interrupt context so schedule it through a worker thread to
	  avoid a kernel BUG.
 SPDX-License-Identifier: GPL-2.0-only
  Atmel SSC driver
  Copyright (C) 2007 Atmel Corporation
 Serialize access to ssc_list and user count 
 sentinel 
 sentinel 
 disable all interrupts 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2020 Synopsys, Inc. andor its affiliates.
  Synopsys DesignWare xData driver
  Author: Gustavo Pimentel <gustavo.pimentel@synopsys.com>
 0x000 
 0x004 
 0x008 
 0x00c 
 0x010 
 0x014 
 0x018 
 0x01c 
 0x020..0x054 
 0x058 
 0x05c..0x0fc 
 0x100 
 0x104 
 0x108 
 0x10c 
 physical address 
 virtual address 
 registers 
 max wr xfer len 
 max rd xfer len 
 Stop first if xfer in progress 
 Clear status register 
 Burst count register set for continuous until stopped 
 Pattern register 
 Control register 
	
	  The xData HW block needs about 100 ms to initiate the traffic
	  generation according this HW block datasheet.
 First acquisition of current count frames 
	
	  Wait 100ms between the 1st count frame acquisition and the 2nd
	  count frame acquisition, in order to calculate the speed later
 Second acquisition of current count frames 
	
	  Speed calculation
	 
	  rate = (2nd count frames - 1st count frames)  (time elapsed)
 Enable PCI device 
 Mapping PCI BAR regions 
 Allocate memory 
 Data structure initialization 
 Saving data structure reference 
 Register misc device 
 SPDX-License-Identifier: GPL-2.0-only
  apds9802als.c - apds9802  ALS Driver
  Copyright (C) 2009 Intel Corp
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Protect against parallel reads 
 clear EOC interrupt status 
 start measurement 
 LSB data 
 MSB data 
	 Make sure nobody else readsmodifieswrites 0x81 while we
 Reset the bits before setting them 
 Setting detection range up to 4k LUX 
 Setting detection range up to 64k LUX
 All OK 
 Write the command and then switch on 
 detection range: 1~64K Lux, maunal measurement 
	  We always get 0 for the 1st measurement after system power on,
	   so make sure it is finished before user asks for data.
 CONFIG_PM 
 CONFIG_PM 
 SPDX-License-Identifier: GPL-2.0-or-later
   isl29003.c - Linux kernel module for
  	Intersil ISL29003 ambient light sensor
   See file:Documentationmisc-devicesisl29003.rst
   Copyright (c) 2009 Daniel Mack <daniel@caiaq.de>
   Based on code written by
   	Rodolfo Giometti <giometti@linux.it>
   	Eurotech S.p.A. <info@eurotech.it>
  register access helpers
  internally used functions
 range 
 resolution 
 mode 
 power_state 
  sysfs layer
 range 
 resolution 
 mode 
 power state 
 lux 
 No LUX data if not operational 
	 read all the registers once to fill the cache.
 set defaults 
  I2C layer
 initialize the ISL29003 chip 
 register sysfs hooks 
 restore registers from cache 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-only
  hmc6352.c - Honeywell Compass Driver
  Copyright (C) 2009 Intel Corp
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 sending 'A' cmd we need to wait for 7-10 millisecs 
 SPDX-License-Identifier: GPL-2.0-or-later
  A driver for the Integrated Circuits ICS932S401
  Copyright (C) 2008 IBM
  Author: Darrick J. Wong <darrick.wong@oracle.com>
 Addresses to scan 
 ICS932S401 registers 
 Base clock is 14.318MHz 
 How often do we reread sensors values? (In jiffies) 
 How often do we reread sensor limit values? (In jiffies) 
 In jiffies 
	
	  Each register must be read as a word and then right shifted 8 bits.
	  Not really sure why this is; setting the "byte count programming"
	  register to 1 does not fix this problem.
 bit to cpu khz map 
 clock divisor map 
 Calculate CPU frequency from the MN registers. 
 Pull in bits 8 & 9 from the M register 
 Freq is neatly wrapped up for us 
 Calculate SRC frequency from the MN registers. 
 Pull in bits 8 & 9 from the M register 
 Freq is neatly wrapped up for us 
 Calculate PCI frequency from the SRC MN registers. 
 Pull in bits 8 & 9 from the M register 
 Scale 0..2^14 to -0.5. 
 Return 0 if detection is successful, -ENODEV otherwise 
 Register sysfs hooks 
 IBM IntelliStation Z30 
 IBM x3650x3550 
 SPDX-License-Identifier: GPL-2.0+
  IBM Power Systems Virtual Management Channel Support.
  Copyright (c) 2004, 2018 IBM Corp.
    Dave Engebretsen engebret@us.ibm.com
    Steven Royer seroyer@linux.vnet.ibm.com
    Adam Reznechek adreznec@linux.vnet.ibm.com
    Bryant G. Ly <bryantly@linux.vnet.ibm.com>
  Static global variables
 Ensure all writes to source memory are visible before hcall 
  h_request_vmc: - request a hypervisor virtual management channel device
  @vmc_index: drc index of the vmc device created
  Requests the hypervisor create a new virtual management channel device,
  allowing this partition to send hypervisor virtualization control
  commands.
  Return:
 	0 - Success
 	Non-zero - Failure
 Call to request the VMC device from phyp 
 routines for managing a commandresponse queue 
  ibmvmc_handle_event: - Interrupt handler for crq events
  @irq:        number of irq to handle, not used
  @dev_instance: crq_server_adapter that received interrupt
  Disables interrupts and schedules ibmvmc_task
  Always returns IRQ_HANDLED
  ibmvmc_release_crq_queue - Release CRQ Queue
  @adapter:	crq_server_adapter struct
  Return:
 	0 - Success
 	Non-Zero - Failure
  ibmvmc_reset_crq_queue - Reset CRQ Queue
  @adapter:	crq_server_adapter struct
  This function calls h_free_crq and then calls H_REG_CRQ and does all the
  bookkeeping to get us back to where we can communicate.
  Return:
 	0 - Success
 	Non-Zero - Failure
 Close the CRQ 
 Clean out the queue 
 And re-open it again 
 Adapter is good, but other end is not ready 
  crq_queue_next_crq: - Returns the next entry in message queue
  @queue:      crq_queue to use
  Returns pointer to next entry in queue, or NULL if there are no new
  entried in the CRQ.
		 Ensure the read of the valid bit occurs before reading any
		  other bits of the CRQ entry
  ibmvmc_send_crq - Send CRQ
  @adapter:	crq_server_adapter struct
  @word1:	Word1 Data field
  @word2:	Word2 Data field
  Return:
 	0 - Success
 	Non-Zero - Failure
	
	  Ensure the command buffer is flushed to memory before handing it
	  over to the other side to prevent it from fetching any stale data.
  alloc_dma_buffer - Create DMA Buffer
  @vdev:	vio_dev struct
  @size:	Size field
  @dma_handle:	DMA address field
  Allocates memory for the command queue and maps remote memory into an
  ioba.
  Returns a pointer to the buffer
 allocate memory 
 DMA map 
  free_dma_buffer - Free DMA Buffer
  @vdev:	vio_dev struct
  @size:	Size field
  @vaddr:	Address field
  @dma_handle:	DMA address field
  Releases memory for a command queue and unmaps mapped remote memory.
 DMA unmap 
 deallocate memory 
  ibmvmc_get_valid_hmc_buffer - Retrieve Valid HMC Buffer
  @hmc_index:	HMC Index Field
  Return:
 	Pointer to ibmvmc_buffer
  ibmvmc_get_free_hmc_buffer - Get Free HMC Buffer
  @adapter:	crq_server_adapter struct
  @hmc_index:	Hmc Index field
  Return:
 	Pointer to ibmvmc_buffer
  ibmvmc_free_hmc_buffer - Free an HMC Buffer
  @hmc:	ibmvmc_hmc struct
  @buffer:	ibmvmc_buffer struct
  ibmvmc_count_hmc_buffers - Count HMC Buffers
  @hmc_index:	HMC Index field
  @valid:	Valid number of buffers field
  @free:	Free number of buffers field
  ibmvmc_get_free_hmc - Get Free HMC
  Return:
 	Pointer to an available HMC Connection
 	Null otherwise
	
	  Find an available HMC connection.
  ibmvmc_return_hmc - Return an HMC Connection
  @hmc:		ibmvmc_hmc struct
  @release_readers:	Number of readers connected to session
  This function releases the HMC connections back into the pool.
  Return:
 	0 - Success
 	Non-zero - Failure
  ibmvmc_send_open - Interface Open
  @buffer: Pointer to ibmvmc_buffer struct
  @hmc: Pointer to ibmvmc_hmc struct
  This command is sent by the management partition as the result of a
  management partition device request. It causes the hypervisor to
  prepare a set of data buffers for the management application connection
  indicated HMC idx. A unique HMC Idx would be used if multiple management
  applications running concurrently were desired. Before responding to this
  command, the hypervisor must provide the management partition with at
  least one of these new buffers via the Add Buffer. This indicates whether
  the messages are inbound or outbound from the hypervisor.
  Return:
 	0 - Success
 	Non-zero - Failure
  ibmvmc_send_close - Interface Close
  @hmc: Pointer to ibmvmc_hmc struct
  This command is sent by the management partition to terminate a
  management application to hypervisor connection. When this command is
  sent, the management partition has quiesced all IO operations to all
  buffers associated with this management application connection, and
  has freed any storage for these buffers.
  Return:
 	0 - Success
 	Non-zero - Failure
  ibmvmc_send_capabilities - Send VMC Capabilities
  @adapter:	crq_server_adapter struct
  The capabilities message is an administrative message sent after the CRQ
  initialization sequence of messages and is used to exchange VMC capabilities
  between the management partition and the hypervisor. The management
  partition must send this message and the hypervisor must respond with VMC
  capabilities Response message before HMC interface message can begin. Any
  HMC interface messages received before the exchange of capabilities has
  complete are dropped.
  Return:
 	0 - Success
  ibmvmc_send_add_buffer_resp - Add Buffer Response
  @adapter:	crq_server_adapter struct
  @status:	Status field
  @hmc_session: HMC Session field
  @hmc_index:	HMC Index field
  @buffer_id:	Buffer Id field
  This command is sent by the management partition to the hypervisor in
  response to the Add Buffer message. The Status field indicates the result of
  the command.
  Return:
 	0 - Success
  ibmvmc_send_rem_buffer_resp - Remove Buffer Response
  @adapter:	crq_server_adapter struct
  @status:	Status field
  @hmc_session: HMC Session field
  @hmc_index:	HMC Index field
  @buffer_id:	Buffer Id field
  This command is sent by the management partition to the hypervisor in
  response to the Remove Buffer message. The Buffer ID field indicates
  which buffer the management partition selected to remove. The Status
  field indicates the result of the command.
  Return:
 	0 - Success
  ibmvmc_send_msg - Signal Message
  @adapter:	crq_server_adapter struct
  @buffer:	ibmvmc_buffer struct
  @hmc:	ibmvmc_hmc struct
  @msg_len:	message length field
  This command is sent between the management partition and the hypervisor
  in order to signal the arrival of an HMC protocol message. The command
  can be sent by both the management partition and the hypervisor. It is
  used for all traffic between the management application and the hypervisor,
  regardless of who initiated the communication.
  There is no response to this message.
  Return:
 	0 - Success
 	Non-zero - Failure
  ibmvmc_open - Open Session
  @inode:	inode struct
  @file:	file struct
  Return:
 	0 - Success
 	Non-zero - Failure
  ibmvmc_close - Close Session
  @inode:	inode struct
  @file:	file struct
  Return:
 	0 - Success
 	Non-zero - Failure
  ibmvmc_read - Read
  @file:	file struct
  @buf:	Character buffer
  @nbytes:	Size in bytes
  @ppos:	Offset
  Return:
 	0 - Success
 	Non-zero - Failure
 Data is available 
  ibmvmc_poll - Poll
  @file:	file struct
  @wait:	Poll Table
  Return:
 	poll.h return values
  ibmvmc_write - Write
  @file:	file struct
  @buffer:	Character buffer
  @count:	Count field
  @ppos:	Offset
  Return:
 	0 - Success
 	Non-zero - Failure
 HMC connection is not valid (possibly was reset under us). 
 Waiting for the open resp message to the ioctl(1) - retry 
	 Make sure the ioctl() was called & the open msg sent, and that
	  the HMC connection has not failed.
		 No buffer available for the msg send, or we have not yet
		  completed the openopen_resp sequence.  Retry until this is
		  complete.
  ibmvmc_setup_hmc - Setup the HMC
  @session:	ibmvmc_file_session struct
  Return:
 	0 - Success
 	Non-zero - Failure
	 Device is busy until capabilities have been exchanged and we
	  have a generic buffer for each possible HMC connection.
 Get an hmc object, and transition to ibmhmc_state_initial 
  ibmvmc_ioctl_sethmcid - IOCTL Set HMC ID
  @session:	ibmvmc_file_session struct
  @new_hmc_id:	HMC id field
  IOCTL command to setup the hmc id
  Return:
 	0 - Success
 	Non-zero - Failure
 Reserve HMC session 
 Send Open Session command 
 Make sure buffer is NULL terminated before trying to print it 
 RDMA over ID, send open msg, change state to ibmhmc_state_opening 
  ibmvmc_ioctl_query - IOCTL Query
  @session:	ibmvmc_file_session struct
  @ret_struct:	ibmvmc_query_struct
  Return:
 	0 - Success
 	Non-zero - Failure
  ibmvmc_ioctl_requestvmc - IOCTL Request VMC
  @session:	ibmvmc_file_session struct
  @ret_vmc_index:	VMC Index
  Return:
 	0 - Success
 	Non-zero - Failure
 TODO: (adreznec) Add locking to control multiple process access 
 Call to request the VMC device from phyp
 Success, set the vmc index in global struct 
  ibmvmc_ioctl - IOCTL
  @file:	file information
  @cmd:	cmd field
  @arg:	Argument field
  Return:
 	0 - Success
 	Non-zero - Failure
  ibmvmc_add_buffer - Add Buffer
  @adapter: crq_server_adapter struct
  @crq:	ibmvmc_crq_msg struct
  This message transfers a buffer from hypervisor ownership to management
  partition ownership. The LIOBA is obtained from the virtual TCE table
  associated with the hypervisor side of the VMC device, and points to a
  buffer of size MTU (as established in the capabilities exchange).
  Typical flow for ading buffers:
  1. A new management application connection is opened by the management
 	partition.
  2. The hypervisor assigns new buffers for the traffic associated with
 	that connection.
  3. The hypervisor sends VMC Add Buffer messages to the management
 	partition, informing it of the new buffers.
  4. The hypervisor sends an HMC protocol message (to the management
 	application) notifying it of the new buffers. This informs the
 	application that it has buffers available for sending HMC
 	commands.
  Return:
 	0 - Success
 	Non-zero - Failure
 Must ensure valid==1 is observable only after all other fields are 
  ibmvmc_rem_buffer - Remove Buffer
  @adapter: crq_server_adapter struct
  @crq:	ibmvmc_crq_msg struct
  This message requests an HMC buffer to be transferred from management
  partition ownership to hypervisor ownership. The management partition may
  not be able to satisfy the request at a particular point in time if all its
  buffers are in use. The management partition requires a depth of at least
  one inbound buffer to allow management application commands to flow to the
  hypervisor. It is, therefore, an interface error for the hypervisor to
  attempt to remove the management partition's last buffer.
  The hypervisor is expected to manage buffer usage with the management
  application directly and inform the management partition when buffers may be
  removed. The typical flow for removing buffers:
  1. The management application no longer needs a communication path to a
 	particular hypervisor function. That function is closed.
  2. The hypervisor and the management application quiesce all traffic to that
 	function. The hypervisor requests a reduction in buffer pool size.
  3. The management application acknowledges the reduction in buffer pool size.
  4. The hypervisor sends a Remove Buffer message to the management partition,
 	informing it of the reduction in buffers.
  5. The management partition verifies it can remove the buffer. This is
 	possible if buffers have been quiesced.
  Return:
 	0 - Success
 	Non-zero - Failure
  The hypervisor requested that we pick an unused buffer, and return it.
  Before sending the buffer back, we free any storage associated with the
  buffer.
 Hypervisor writes CRQs directly into our memory in big endian 
 HMC connection is not valid (possibly was reset under us). 
 RDMA the data into the partition. 
 Must be locked because read operates on the same data 
  ibmvmc_process_capabilities - Process Capabilities
  @adapter:	crq_server_adapter struct
  @crqp:	ibmvmc_crq_msg struct
  ibmvmc_validate_hmc_session - Validate HMC Session
  @adapter:	crq_server_adapter struct
  @crq:	ibmvmc_crq_msg struct
  Return:
 	0 - Success
 	Non-zero - Failure
  ibmvmc_reset - Reset
  @adapter:	crq_server_adapter struct
  @xport_event:	export_event field
  Closes all HMC sessions and conditionally schedules a CRQ reset.
  @xport_event: If true, the partner closed their CRQ; we don't need to reset.
                If false, we need to schedule a CRQ reset.
			 CRQ was closed by the partner.  We don't need to do
			  anything except set ourself to the correct state to
			  handle init msgs.
			 The partner did not close their CRQ - instead, we're
			  closing the CRQ on our end. Need to schedule this
			  for process context, because CRQ reset may require a
			  sleep.
			 
			  Setting ibmvmc.state here immediately prevents
			  ibmvmc_open from completing until the reset
			  completes in process context.
  ibmvmc_reset_task - Reset Task
  @data:	Data field
  Performs a CRQ reset of the VMC device in process context.
  NOTE: This function should not be called directly, use ibmvmc_reset.
  ibmvmc_process_open_resp - Process Open Response
  @crq: ibmvmc_crq_msg struct
  @adapter:    crq_server_adapter struct
  This command is sent by the hypervisor in response to the Interface
  Open message. When this message is received, the indicated buffer is
  again available for management partition use.
 Why would PHYP give an index > max negotiated? 
  ibmvmc_process_close_resp - Process Close Response
  @crq: ibmvmc_crq_msg struct
  @adapter:    crq_server_adapter struct
  This command is sent by the hypervisor in response to the managemant
  application Interface Close message.
  If the close fails, simply reset the entire driver as the state of the VMC
  must be in tough shape.
  ibmvmc_crq_process - Process CRQ
  @adapter:    crq_server_adapter struct
  @crq:	ibmvmc_crq_msg struct
  Process the CRQ message based upon the type of message received.
  ibmvmc_handle_crq_init - Handle CRQ Init
  @crq:	ibmvmc_crq_msg struct
  @adapter:	crq_server_adapter struct
  Handle the type of crq initialization based on whether
  it is a message or a response.
 Initialization message 
 Send back a response 
 Initialization response 
  ibmvmc_handle_crq - Handle CRQ
  @crq:	ibmvmc_crq_msg struct
  @adapter:	crq_server_adapter struct
  Read the command elements from the command queue and execute the
  requests based upon the type of crq message.
 initialization 
 Hypervisor telling us the connection is closed 
 real payload 
 Pull all the valid messages off the CRQ 
			 CRQ reset was requested, stop processing CRQs.
			  Interrupts will be re-enabled by the reset task.
			 CRQ reset was requested, stop processing CRQs.
			  Interrupts will be re-enabled by the reset task.
  ibmvmc_init_crq_queue - Init CRQ Queue
  @adapter:	crq_server_adapter struct
  Return:
 	0 - Success
 	Non-zero - Failure
	 Cannot have any work since we either never got our IRQ registered,
	  or never got interrupts enabled
 Fill in the liobn and riobn fields on the adapter 
	 TODO Using of_parse_dma_window would be better, but it doesn't give
	  a way to read multiple windows without already knowing the size of
	  a window or the number of windows
 dma_window should point to the second window now 
	 Try to send an initialization message.  Note that this is allowed
	  to fail if the other end is not acive.  In that case we just wait
	  for the other side to initialize.
 Initialize data structures 
 Sanity check module parms 
	
	  Initialize some reasonable values.  Might be negotiated smaller
	  values during the capabilities exchange.
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (C) 2005-2007 Jiri Slaby <jirislaby@gmail.com>
   You need a userspace library to cooperate with this driver. It (and other
   info) may be obtained here:
   http:www.fi.muni.cz~xslabyphantom.html
   or alternatively, you might use OpenHaptics provided by Sensable.
 irq control in caddr space 
 used in NOT_OH mode 
 PCI posting 
 PCI posting 
  File ops
 preserve amp bit (don't allow to change it when in NOT_OH) 
 PCI posting 
 PCI posting 
 PCI posting 
  Init and deinit driver
 PCI posting 
 PCI posting 
 PCI posting 
 SPDX-License-Identifier: GPL-2.0-only
  datasheet: https:www.nxp.comdocsendata-sheetK20P144M120SF3.pdf
  Copyright (C) 2018-2021 Collabora
  Copyright (C) 2018-2021 GE Healthcare
 avoid concurrent device access 
 flash section program 
 read status register 
 write enable 
 flash read data at high speed 
 reset chip 
 bulk erase 
 sector erase 
 write in progress 
 write enable 
 bulk erase disable 
 FlexRAM mode 
 write error flag 
 flash security 
 assert chip select 
 reset with asserted chip select to switch into programming mode 
 release chip select 
 reset without asserted chip select to return into normal mode 
 FAST_READ receives one dummy byte before the real data 
 allow missing FW verfication in secure mode 
  ezport_flash - flash device firmware
  @spi: SPI device for NXP EzPort interface
  @reset: the gpio connected to the device reset pin
  @fwname: filename of the firmware that should be flashed
  Context: can sleep
  Return: 0 on success; negative errno on failure
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for the Analog Devices digital potentiometers (I2C bus)
  Copyright (C) 2010-2011 Michael Hennerich, Analog Devices Inc.
 I2C bus functions 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2011 LAPIS Semiconductor Co., Ltd.
 Status Register offset 
 Control Register offset 
 Time out value for Status Register 
 Enabling for writing ROM 
 Disabling for writing ROM 
#define PCH_PHUB_MAC_START_ADDR_EG20T 0x14   MAC data area start address
#define PCH_PHUB_MAC_START_ADDR_ML7223 0x20C   MAC data area start address
#define PCH_PHUB_ROM_START_ADDR_EG20T 0x80  ROM data area start address offset
#define PCH_PHUB_ROM_START_ADDR_ML7213 0x400  ROM data area start address
						offset(LAPIS Semicon ML7213)
#define PCH_PHUB_ROM_START_ADDR_ML7223 0x400  ROM data area start address
						offset(LAPIS Semicon ML7223)
 MAX number of INT_REDUCE_CONTROL registers 
 CM-iTC 
 Macros for ML7213 
 Macros for ML7223 
 for Bus-m 
 for Bus-n 
 Macros for ML7831 
 SROM ACCESS Macro 
 Registers address offset 
  struct pch_phub_reg - PHUB register structure
  @phub_id_reg:			PHUB_ID register val
  @q_pri_val_reg:			QUEUE_PRI_VAL register val
  @rc_q_maxsize_reg:			RC_QUEUE_MAXSIZE register val
  @bri_q_maxsize_reg:			BRI_QUEUE_MAXSIZE register val
  @comp_resp_timeout_reg:		COMP_RESP_TIMEOUT register val
  @bus_slave_control_reg:		BUS_SLAVE_CONTROL_REG register val
  @deadlock_avoid_type_reg:		DEADLOCK_AVOID_TYPE register val
  @intpin_reg_wpermit_reg0:		INTPIN_REG_WPERMIT register 0 val
  @intpin_reg_wpermit_reg1:		INTPIN_REG_WPERMIT register 1 val
  @intpin_reg_wpermit_reg2:		INTPIN_REG_WPERMIT register 2 val
  @intpin_reg_wpermit_reg3:		INTPIN_REG_WPERMIT register 3 val
  @int_reduce_control_reg:		INT_REDUCE_CONTROL registers val
  @clkcfg_reg:				CLK CFG register val
  @funcsel_reg:			Function select register value
  @pch_phub_base_address:		Register base address
  @pch_phub_extrom_base_address:	external rom base address
  @pch_mac_start_address:		MAC address area start address
  @pch_opt_rom_start_address:		Option ROM start address
  @ioh_type:				Save IOH type
  @pdev:				pointer to pci device struct
 SROM SPEC for MAC address assignment offset 
  pch_phub_read_modify_write_reg() - Reading modifying and writing register
  @chip:		Pointer to the PHUB register structure
  @reg_addr_offset:	Register offset address value.
  @data:		Writing value.
  @mask:		Mask value.
 pch_phub_save_reg_conf - saves register configuration 
 pch_phub_restore_reg_conf - restore register configuration 
  pch_phub_read_serial_rom() - Reading Serial ROM
  @chip:		Pointer to the PHUB register structure
  @offset_address:	Serial ROM offset address to read.
  @data:		Read buffer for specified Serial ROM value.
  pch_phub_write_serial_rom() - Writing Serial ROM
  @chip:		Pointer to the PHUB register structure
  @offset_address:	Serial ROM offset address.
  @data:		Serial ROM value to write.
  pch_phub_read_serial_rom_val() - Read Serial ROM value
  @chip:		Pointer to the PHUB register structure
  @offset_address:	Serial ROM address offset value.
  @data:		Serial ROM value to read.
  pch_phub_write_serial_rom_val() - writing Serial ROM value
  @chip:		Pointer to the PHUB register structure
  @offset_address:	Serial ROM address offset value.
  @data:		Serial ROM value.
 pch_phub_gbe_serial_rom_conf - makes Serial ROM header format configuration
  for Gigabit Ethernet MAC address
 pch_phub_gbe_serial_rom_conf_mp - makes SerialROM header format configuration
  for Gigabit Ethernet MAC address
  pch_phub_read_gbe_mac_addr() - Read Gigabit Ethernet MAC address
  @chip:		Pointer to the PHUB register structure
  @data:		Buffer of the Gigabit Ethernet MAC address value.
  pch_phub_write_gbe_mac_addr() - Write MAC address
  @chip:		Pointer to the PHUB register structure
  @data:		Gigabit Ethernet MAC address value.
 EG20T or ML7831
 ML7223 
 Get Rom signature 
 Save pci device struct 
 EG20T PCH 
 quirk for CM-iTC board 
 set the prefech value 
 set the interrupt delay value 
 quirk for MIPS Boston platform 
 ML7213 IOH 
		 set the prefech value
		  Device2(USB OHCI #1 USB EHCI #1 USB Device):a
		  Device4(SDIO #0,1,2):f
		  Device6(SATA 2):f
		  Device8(USB OHCI #0 USB EHCI #0):a
 ML7223 IOH Bus-m
		 set the prefech value
		  Device8(GbE)
 set the interrupt delay value 
 ML7223 IOH Bus-n
		 set the prefech value
		  Device2(USB OHCI #0,1,2,3 USB EHCI #0):a
		  Device4(SDIO #0,1):f
		  Device6(SATA 2):f
 ML7831 
 set the prefech value 
 set the interrupt delay value 
 SPDX-License-Identifier: GPL-2.0
  VMware Balloon driver.
  Copyright (C) 2000-2018, VMware, Inc. All Rights Reserved.
  This is VMware physical memory management driver for Linux. The driver
  acts like a "balloon" that can be inflated to reclaim physical pages by
  reserving them in the guest and invalidating them in the monitor,
  freeing up the underlying machine pages so they can be allocated to
  other guests.  The balloon can also be deflated to allow the guest to
  use more physical memory. Higher level policies can control the sizes
  of balloons in VMs in order to manage physical memory resources.
#define DEBUG
 Delay in seconds after shrink before inflation. 
 Maximum number of refused pages we accumulate during inflation cycle 
 Magic number for the balloon mount-point 
  Hypervisor communication port definitions.
 Linux 
	
	  Bit 0 is reserved and not associated to any capability.
  64-bit targets are only supported in 64-bit
  enum vmballoon_cmd_type - backdoor commands.
  Availability of the commands is as followed:
  %VMW_BALLOON_CMD_START, %VMW_BALLOON_CMD_GET_TARGET and
  %VMW_BALLOON_CMD_GUEST_ID are always available.
  If the host reports %VMW_BALLOON_BASIC_CMDS are supported then
  %VMW_BALLOON_CMD_LOCK and %VMW_BALLOON_CMD_UNLOCK commands are available.
  If the host reports %VMW_BALLOON_BATCHED_CMDS are supported then
  %VMW_BALLOON_CMD_BATCHED_LOCK and VMW_BALLOON_CMD_BATCHED_UNLOCK commands
  are available.
  If the host reports %VMW_BALLOON_BATCHED_2M_CMDS are supported then
  %VMW_BALLOON_CMD_BATCHED_2M_LOCK and %VMW_BALLOON_CMD_BATCHED_2M_UNLOCK
  are supported.
  If the host reports  VMW_BALLOON_SIGNALLED_WAKEUP_CMD is supported then
  VMW_BALLOON_CMD_VMCI_DOORBELL_SET command is supported.
  @VMW_BALLOON_CMD_START: Communicating supported version with the hypervisor.
  @VMW_BALLOON_CMD_GET_TARGET: Gets the balloon target size.
  @VMW_BALLOON_CMD_LOCK: Informs the hypervisor about a ballooned page.
  @VMW_BALLOON_CMD_UNLOCK: Informs the hypervisor about a page that is about
 			    to be deflated from the balloon.
  @VMW_BALLOON_CMD_GUEST_ID: Informs the hypervisor about the type of OS that
 			      runs in the VM.
  @VMW_BALLOON_CMD_BATCHED_LOCK: Inform the hypervisor about a batch of
 				  ballooned pages (up to 512).
  @VMW_BALLOON_CMD_BATCHED_UNLOCK: Inform the hypervisor about a batch of
 				  pages that are about to be deflated from the
 				  balloon (up to 512).
  @VMW_BALLOON_CMD_BATCHED_2M_LOCK: Similar to @VMW_BALLOON_CMD_BATCHED_LOCK
 				     for 2MB pages.
  @VMW_BALLOON_CMD_BATCHED_2M_UNLOCK: Similar to
 				       @VMW_BALLOON_CMD_BATCHED_UNLOCK for 2MB
 				       pages.
  @VMW_BALLOON_CMD_VMCI_DOORBELL_SET: A command to set doorbell notification
 				       that would be invoked when the balloon
 				       size changes.
  @VMW_BALLOON_CMD_LAST: Value of the last command.
 No command 5 
  struct vmballoon_batch_entry - a batch entry for lock or unlock.
  @status: the status of the operation, which is written by the hypervisor.
  @reserved: reserved for future use. Must be set to zero.
  @pfn: the physical frame number of the page to be locked or unlocked.
	
	  @max_page_size: maximum supported page size for ballooning.
	 
	  Protected by @conf_sem
	
	  @size: balloon actual size in basic page size (frames).
	 
	  While we currently do not support size which is bigger than 32-bit,
	  in preparation for future support, use 64-bits.
	
	  @target: balloon target size in basic page size (frames).
	 
	  We do not protect the target under the assumption that setting the
	  value is always done through a single write. If this assumption ever
	  breaks, we would have to use X_ONCE for accesses, and suffer the less
	  optimized code. Although we may read stale target value if multiple
	  accesses happen at once, the performance impact should be minor.
	
	  @reset_required: reset flag
	 
	  Setting this flag may introduce races, but the code is expected to
	  handle them gracefully. In the worst case, another operation will
	  fail as reset did not take place. Clearing the flag is done while
	  holding @conf_sem for write.
	
	  @capabilities: hypervisor balloon capabilities.
	 
	  Protected by @conf_sem.
	
	  @batch_page: pointer to communication batch page.
	 
	  When batching is used, batch_page points to a page, which holds up to
	  %VMW_BALLOON_BATCH_MAX_PAGES entries for locking or unlocking.
	
	  @batch_max_pages: maximum pages that can be lockedunlocked.
	 
	  Indicates the number of pages that the hypervisor can lock or unlock
	  at once, according to whether batching is enabled. If batching is
	  disabled, only a single page can be lockedunlock on each operation.
	 
	  Protected by @conf_sem.
	
	  @page: page to be lockedunlocked by the hypervisor
	 
	  @page is only used when batching is disabled and a single page is
	  reclaimed on each iteration.
	 
	  Protected by @comm_lock.
	
	  @shrink_timeout: timeout until the next inflation.
	 
	  After an shrink event, indicates the time in jiffies after which
	  inflation is allowed again. Can be written concurrently with reads,
	  so must use READ_ONCEWRITE_ONCE when accessing.
 statistics 
	
	  @b_dev_info: balloon device information descriptor.
	
	  @huge_pages - list of the inflated 2MB pages.
	 
	  Protected by @b_dev_info.pages_lock .
	
	  @vmci_doorbell.
	 
	  Protected by @conf_sem.
	
	  @conf_sem: semaphore to protect the configuration and the statistics.
	
	  @comm_lock: lock to protect the communication with the host.
	 
	  Lock ordering: @conf_sem -> @comm_lock .
	
	  @shrinker: shrinker interface that is used to avoid over-inflation.
	
	  @shrinker_registered: whether the shrinker was registered.
	 
	  The shrinker interface does not handle gracefully the removal of
	  shrinker that was not registered before. This indication allows to
	  simplify the unregistration process.
 timer  doorbell operations 
 allocation statistics for huge and small pages 
 Monitor operations: total operations, and failures 
 update the result if needed 
 update target when applicable 
 mark reset required accordingly 
  Send "start" command to the host, communicating supported version
  of the protocol.
	
	  2MB pages are only supported with batching. If batching is for some
	  reason disabled, do not use 2MB pages, since otherwise the legacy
	  mechanism is used with 2MB pages, causing a failure.
  vmballoon_send_guest_id - communicate guest type to the host.
  @b: pointer to the balloon.
  Communicate guest type to the host so that it can adjust ballooning
  algorithm to the one most appropriate for the guest. This command
  is normally issued after sending "start" command and is part of
  standard reset sequence.
  Return: zero on success or appropriate error code.
  vmballoon_page_order() - return the order of the page
  @page_size: the size of the page.
  Return: the allocation order.
  vmballoon_page_in_frames() - returns the number of frames in a page.
  @page_size: the size of the page.
  Return: the number of 4k frames.
  vmballoon_mark_page_offline() - mark a page as offline
  @page: pointer for the page.
  @page_size: the size of the page.
  vmballoon_mark_page_online() - mark a page as online
  @page: pointer for the page.
  @page_size: the size of the page.
  vmballoon_send_get_target() - Retrieve desired balloon size from the host.
  @b: pointer to the balloon.
  Return: zero on success, EINVAL if limit does not fit in 32-bit, as required
  by the host-guest protocol and EIO if an error occurred in communicating with
  the host.
 Ensure limit fits in 32-bits if 64-bit targets are not supported 
  vmballoon_alloc_page_list - allocates a list of pages.
  @b: pointer to the balloon.
  @ctl: pointer for the %struct vmballoon_ctl, which defines the operation.
  @req_n_pages: the number of requested pages.
  Tries to allocate @req_n_pages. Add them to the list of balloon pages in
  @ctl.pages and updates @ctl.n_pages to reflect the number of pages.
  Return: zero on success or error code otherwise.
		
		  First check if we happen to have pages that were allocated
		  before. This happens when 2MB page rejected during inflation
		  by the hypervisor, and then split into 4KB pages.
 Success. Add the page to the list and continue. 
 Allocation failed. Update statistics and stop. 
  vmballoon_handle_one_result - Handle lockunlock result for a single page.
  @b: pointer for %struct vmballoon.
  @page: pointer for the page whose result should be handled.
  @page_size: size of the page.
  @status: status of the operation as provided by the hypervisor.
 On success do nothing. The page is already on the balloon list. 
 Error occurred 
  vmballoon_status_page - returns the status of (un)lock operation
  @b: pointer to the balloon.
  @idx: index for the page for which the operation is performed.
  @p: pointer to where the page struct is returned.
  Following a lock or unlock operation, returns the status of the operation for
  an individual page. Provides the page that the operation was performed on on
  the @page argument.
  Returns: The status of a lock or unlock operation for an individual page.
 batching mode 
 non-batching mode 
	
	  If a failure occurs, the indication will be provided in the status
	  of the entire operation, which is considered before the individual
	  page status. So for non-batching mode, the indication is always of
	  success.
  vmballoon_lock_op - notifies the host about inflateddeflated pages.
  @b: pointer to the balloon.
  @num_pages: number of inflateddeflated pages.
  @page_size: size of the page.
  @op: the type of operation (lock or unlock).
  Notify the host about page(s) that were ballooned (or removed from the
  balloon) so that host can use it without fear that guest will need it (or
  stop using them since the VM does). Host may reject some pages, we need to
  check the return value and maybe submit a different page. The pages that are
  inflateddeflated are pointed by @b->page.
  Return: result as provided by the hypervisor.
 In non-batching mode, PFNs must fit in 32-bit 
  vmballoon_add_page - adds a page towards lockunlock operation.
  @b: pointer to the balloon.
  @idx: index of the page to be ballooned in this batch.
  @p: pointer to the page that is about to be ballooned.
  Adds the page to be ballooned. Must be called while holding @comm_lock.
  vmballoon_lock - lock or unlock a batch of pages.
  @b: pointer to the balloon.
  @ctl: pointer for the %struct vmballoon_ctl, which defines the operation.
  Notifies the host of about ballooned pages (after inflation or deflation,
  according to @ctl). If the host rejects the page put it on the
  @ctl refuse list. These refused page are then released when moving to the
  next size of pages.
  Note that we neither free any @page here nor put them back on the ballooned
  pages list. Instead we queue it for later processing. We do that for several
  reasons. First, we do not want to free the page under the lock. Second, it
  allows us to unify the handling of lock and unlock. In the inflate case, the
  caller will check if there are too many refused pages and release them.
  Although it is not identical to the past behavior, it should not affect
  performance.
 communication with the host is done under the communication lock 
	
	  Iterate over the pages in the provided list. Since we are changing
	  @ctl->n_pages we are saving the original value in @num_pages and
	  use this value to bound the loop.
		
		  Failure of the whole batch overrides a single operation
		  results.
 Continue if no error happened 
		
		  Error happened. Move the pages to the refused list and update
		  the pages number.
  vmballoon_release_page_list() - Releases a page list
  @page_list: list of pages to release.
  @n_pages: pointer to the number of pages.
  @page_size: whether the pages in the list are 2MB (or else 4KB).
  Releases the list of pages and zeros the number of pages.
  Release pages that were allocated while attempting to inflate the
  balloon but were refused by the host for one reason or another.
  vmballoon_change - retrieve the required balloon change
  @b: pointer for the balloon.
  Return: the required change for the balloon size. A positive number
  indicates inflation, a negative number indicates a deflation.
	
	  We must cast first because of int sizes
	  Otherwise we might get huge positives instead of negatives
 consider a 2MB slack on deflate, unless the balloon is emptied 
 If an out-of-memory recently occurred, inflation is disallowed. 
  vmballoon_enqueue_page_list() - Enqueues list of pages after inflation.
  @b: pointer to balloon.
  @pages: list of pages to enqueue.
  @n_pages: pointer to number of pages in list. The value is zeroed.
  @page_size: whether the pages are 2MB or 4KB pages.
  Enqueues the provides list of pages in the ballooned page list, clears the
  list and zeroes the number of pages that was provided.
		
		  Keep the huge pages in a local list which is not available
		  for the balloon compaction mechanism.
  vmballoon_dequeue_page_list() - Dequeues page lists for deflation.
  @b: pointer to balloon.
  @pages: list of pages to enqueue.
  @n_pages: pointer to number of pages in list. The value is zeroed.
  @page_size: whether the pages are 2MB or 4KB pages.
  @n_req_pages: the number of requested pages.
  Dequeues the number of requested pages from the balloon for deflation. The
  number of dequeued pages may be lower, if not enough pages in the requested
  size are available.
 In the case of 4k pages, use the compaction infrastructure 
 2MB pages 
  vmballoon_split_refused_pages() - Split the 2MB refused pages to 4k.
  If inflation of 2MB pages was denied by the hypervisor, it is likely to be
  due to one or few 4KB pages. These 2MB pages may keep being allocated and
  then being refused. To prevent this case, this function splits the refused
  pages into 4KB pages and adds them into @prealloc_pages list.
  @ctl: pointer for the %struct vmballoon_ctl, which defines the operation.
  vmballoon_inflate() - Inflate the balloon towards its target size.
  @b: pointer to the balloon.
 Start by allocating 
 Actually lock the pages by telling the hypervisor 
		
		  If an error indicates that something serious went wrong,
		  stop the inflation.
 Update the balloon size 
		
		  If allocation failed or the number of refused pages exceeds
		  the maximum allowed, move to the next page size.
			
			  Split the refused pages to 4k. This will also empty
			  the refused pages list.
	
	  Release pages that were allocated while attempting to inflate the
	  balloon but were refused by the host for one reason or another,
	  and update the statistics.
  vmballoon_deflate() - Decrease the size of the balloon.
  @b: pointer to the balloon
  @n_frames: the number of frames to deflate. If zero, automatically
  calculated according to the target size.
  @coordinated: whether to coordinate with the host
  Decrease the size of the balloon allowing guest to use more memory.
  Return: The number of deflated frames (i.e., basic page size units)
 free pages to reach target 
		
		  If we were requested a specific number of frames, we try to
		  deflate this number of frames. Otherwise, deflation is
		  performed according to the target and balloon size.
 break if no work to do 
		
		  Calculate the number of frames based on current page size,
		  but limit the deflated frames to a single chunk
 First take the pages from the balloon pages. 
		
		  Before pages are moving to the refused list, count their
		  frames as frames that we tried to deflate.
		
		  Unlock the pages by communicating with the hypervisor if the
		  communication is coordinated (i.e., not pop). We ignore the
		  return code. Instead we check if all the pages we manage to
		  unlock all the pages. If we failed, we will move to the next
		  page size, and would eventually try again later.
		
		  Check if we deflated enough. We will move to the next page
		  size if we did not manage to do so. This calculation takes
		  place now, as once the pages are released, the number of
		  pages is zeroed.
 Update local and global counters 
 free the ballooned pages 
 Return the refused pages to the ballooned list. 
 If we failed to unlock all the pages, move to next size. 
  vmballoon_deinit_batching - disables batching mode.
  @b: pointer to &struct vmballoon.
  Disables batching, by deallocating the page for communication with the
  hypervisor and disabling the static key to indicate that batching is off.
  vmballoon_init_batching - enable batching mode.
  @b: pointer to &struct vmballoon.
  Enables batching, by allocating a page for communication with the hypervisor
  and enabling the static_key to use batching.
  Return: zero on success or an appropriate error-code.
  Receive notification and resize balloon
  Clean up vmci doorbell
  vmballoon_vmci_init - Initialize vmci doorbell.
  @b: pointer to the balloon.
  Return: zero on success or when wakeup command not supported. Error-code
  otherwise.
  Initialize vmci doorbell, to get notified as soon as balloon changes.
  vmballoon_pop - Quickly release all pages allocate for the balloon.
  @b: pointer to the balloon.
  This function is called when host decides to "reset" balloon for one reason
  or another. Unlike normal "deflate" we do not (shall not) notify host of the
  pages being released.
  Perform standard reset sequence by popping the balloon (in case it
  is not  empty) and then restarting protocol. This operation normally
  happens when host responds with VMW_BALLOON_ERROR_RESET to a command.
 free all pages, skipping monitor unlock 
			
			  We failed to initialize batching, inform the monitor
			  about it by sending a null capability.
			 
			  The guest will retry in one second.
  vmballoon_work - periodic balloon worker for reset, inflation and deflation.
  @work: pointer to the &work_struct which is provided by the workqueue.
  Resets the protocol if needed, gets the new size and adjusts balloon as
  needed. Repeat in 1 sec.
	
	  Update the stats while holding the semaphore to ensure that
	  @stats_enabled is consistent with whether the stats are actually
	  enabled
 (change < 0) 
	
	  We are using a freezable workqueue so that balloon operations are
	  stopped while the system transitions tofrom sleephibernation.
  vmballoon_shrinker_scan() - deflate the balloon due to memory pressure.
  @shrinker: pointer to the balloon shrinker.
  @sc: page reclaim information.
  Returns: number of pages that were freed during deflation.
	
	  If the lock is also contended for read, we cannot easily reclaim and
	  we bail out.
	
	  Delay future inflation for some time to mitigate the situations in
	  which balloon continuously grows and shrinks. Use WRITE_ONCE() since
	  the access is asynchronous.
  vmballoon_shrinker_count() - return the number of ballooned pages.
  @shrinker: pointer to the balloon shrinker.
  @sc: page reclaim information.
  Returns: number of 4k pages that are allocated for the balloon and can
 	    therefore be reclaimed under pressure.
 Do nothing if the shrinker is not enabled 
  DEBUGFS Interface
 did we somehow race with another reader which enabled stats? 
 allocation failed 
  vmballoon_debug_show - shows statistics of balloon operations.
  @f: pointer to the &struct seq_file.
  @offset: ignored.
  Provides the statistics that can be accessed in vmmemctl in the debugfs.
  To avoid the overhead - mainly that of memory - of collecting the statistics,
  we only collect statistics after the first time the counters are read.
  Return: zero on success or an error code.
 enables stats if they are disabled 
 format capabilities info 
 format size info 
 CONFIG_DEBUG_FS 
  vmballoon_migratepage() - migrates a balloon page.
  @b_dev_info: balloon device information descriptor.
  @newpage: the page to which @page should be migrated.
  @page: a ballooned page that should be migrated.
  @mode: migration mode, ignored.
  This function is really open-coded, but that is according to the interface
  that balloon_compaction provides.
  Return: zero on success, -EAGAIN when migration cannot be performed
 	   momentarily, and -EBUSY if migration failed and should be retried
 	   with that specific page.
	
	  If the semaphore is taken, there is ongoing configuration change
	  (i.e., balloon reset), so try again.
	
	  We must start by deflating and not inflating, as otherwise the
	  hypervisor may tell us that it has enough memory and the new page is
	  not needed. Since the old page is isolated, we cannot use the list
	  interface to unlock it, as the LRU field is used for isolation.
	  Instead, we use the native interface directly.
	
	  If a failure happened, let the migration mechanism know that it
	  should not retry.
	
	  The page is isolated, so it is safe to delete it without holding
	  @pages_lock . We keep holding @comm_lock since we will need it in a
	  second.
 Inflate 
		
		  A failure happened. While we can deflate the page we just
		  inflated, this deflation can also encounter an error. Instead
		  we will decrease the size of the balloon to reflect the
		  change and report failure.
		
		  Success. Take a reference for the page, and we will add it to
		  the list after acquiring the lock.
 Update the balloon list under the @pages_lock 
	
	  On inflation success, we already took a reference for the @newpage.
	  If we succeed just insert it to the list and update the statistics
	  under the lock.
	
	  We deflated successfully, so regardless to the inflation success, we
	  need to reduce the number of isolated_pages.
  vmballoon_compaction_deinit() - removes compaction related data.
  @b: pointer to the balloon.
  vmballoon_compaction_init() - initialized compaction for the balloon.
  @b: pointer to the balloon.
  If during the initialization a failure occurred, this function does not
  perform cleanup. The caller must call vmballoon_compaction_deinit() in this
  case.
  Return: zero on success or error code on failure.
 CONFIG_BALLOON_COMPACTION 
 CONFIG_BALLOON_COMPACTION 
	
	  Check if we are running on VMware's hypervisor and bail out
	  if we are not.
	
	  Initialization of compaction must be done after the call to
	  balloon_devinfo_init() .
  Using late_initcall() instead of module_init() allows the balloon to use the
  VMCI doorbell even when the balloon is built into the kernel. Otherwise the
  VMCI is probed only after the balloon is initialized. If the balloon is used
  as a module, late_initcall() is equivalent to module_init().
	
	  Deallocate all reserved memory, and reset connection with monitor.
	  Reset connection before deallocating memory to avoid potential for
	  additional spurious resets from guest touching deallocated pages.
 Only once we popped the balloon, compaction can be deinit 
 SPDX-License-Identifier: GPL-2.0-or-later
  ad525x_dpot: Driver for the Analog Devices digital potentiometers
  Copyright (c) 2009-2010 Analog Devices, Inc.
  Author: Michael Hennerich <michael.hennerich@analog.com>
  DEVID		#Wipers		#Positions	Resistor Options (kOhm)
  AD5258		1		64		1, 10, 50, 100
  AD5259		1		256		5, 10, 50, 100
  AD5251		2		64		1, 10, 50, 100
  AD5252		2		256		1, 10, 50, 100
  AD5255		3		512		25, 250
  AD5253		4		64		1, 10, 50, 100
  AD5254		4		256		1, 10, 50, 100
  AD5160		1		256		5, 10, 50, 100
  AD5161		1		256		5, 10, 50, 100
  AD5162		2		256		2.5, 10, 50, 100
  AD5165		1		256		100
  AD5200		1		256		10, 50
  AD5201		1		33		10, 50
  AD5203		4		64		10, 100
  AD5204		4		256		10, 50, 100
  AD5206		6		256		10, 50, 100
  AD5207		2		256		10, 50, 100
  AD5231		1		1024		10, 50, 100
  AD5232		2		256		10, 50, 100
  AD5233		4		64		10, 50, 100
  AD5235		2		1024		25, 250
  AD5260		1		256		20, 50, 200
  AD5262		2		256		20, 50, 200
  AD5263		4		256		20, 50, 200
  AD5290		1		256		10, 50, 100
  AD5291		1		256		20, 50, 100  (20-TP)
  AD5292		1		1024		20, 50, 100  (20-TP)
  AD5293		1		1024		20, 50, 100
  AD7376		1		128		10, 50, 100, 1M
  AD8400		1		256		1, 10, 50, 100
  AD8402		2		256		1, 10, 50, 100
  AD8403		4		256		1, 10, 50, 100
  ADN2850		3		512		25, 250
  AD5241		1		256		10, 100, 1M
  AD5246		1		128		5, 10, 50, 100
  AD5247		1		128		5, 10, 50, 100
  AD5245		1		256		5, 10, 50, 100
  AD5243		2		256		2.5, 10, 50, 100
  AD5248		2		256		2.5, 10, 50, 100
  AD5242		2		256		20, 50, 200
  AD5280		1		256		20, 50, 200
  AD5282		2		256		20, 50, 200
  ADN2860		3		512		25, 250
  AD5273		1		64		1, 10, 50, 100 (OTP)
  AD5171		1		64		5, 10, 50, 100 (OTP)
  AD5170		1		256		2.5, 10, 50, 100 (OTP)
  AD5172		2		256		2.5, 10, 50, 100 (OTP)
  AD5173		2		256		2.5, 10, 50, 100 (OTP)
  AD5270		1		1024		20, 50, 100 (50-TP)
  AD5271		1		256		20, 50, 100 (50-TP)
  AD5272		1		1024		20, 50, 100 (50-TP)
  AD5274		1		256		20, 50, 100 (50-TP)
  See Documentationmisc-devicesad525x_dpot.rst for more info.
  derived from ad5258.c
  Copyright (c) 2009 Cyber Switching, Inc.
  Author: Chris Verges <chrisv@cyberswitching.com>
  derived from ad5252.c
  Copyright (c) 2006-2011 Michael Hennerich <michael.hennerich@analog.com>
  Client data (each client gets its own)
		
		  AD5272AD5274 returns high byte first, however
		  underling smbus expects low byte first.
 Only write the instruction byte for certain commands 
 Ready to Program? 
 Ready to Program? 
 Ready to Program? 
 All other registers require instruction + data bytes 
 sysfs functions 
	
	  Let someone else deal with converting this ...
	  the tolerance is a two-byte value where the MSB
	  is a sign + integer value, and the LSB is a
	  decimal value.  See page 18 of the AD5258
	  datasheet (Rev. A) for more details.
 Sleep while the EEPROM updates 
 Sleep while the OTP updates 
 ------------------------------------------------------------------------- 
 ------------------------------------------------------------------------- 
 power-up midscale 
 SPDX-License-Identifier: GPL-2.0-only
  isl29020.c - Intersil  ALS Driver
  Copyright (C) 2008 Intel Corp
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Data sheet at: http:www.intersil.comdatafnfn6505.pdf
 MSB data 
 LSB data 
 Pick the smallest sensor range that will meet our requirements 
reset the bit before setting them 
 CONFIG_PM 
 CONFIG_PM 
  SRAM protect-exec region helper functions
  Copyright (C) 2017 Texas Instruments Incorporated - https:www.ti.com
 	Dave Gerlach
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  sram_exec_copy - copy data to a protected executable region of sram
  @pool: struct gen_pool retrieved that is part of this sram
  @dst: Destination address for the copy, that must be inside pool
  @src: Source address for the data to copy
  @size: Size of copy to perform, which starting from dst, must reside in pool
  Return: Address for copied data that can safely be called through function
 	   pointer, or NULL if problem.
  This helper function allows sram driver to act as central control location
  of 'protect-exec' pools which are normal sram pools but are always set
  read-only and executable except when copying data to them, at which point
  they are set to read-write non-executable, to make sure no memory is
  writeable and executable at the same time. This region must be page-aligned
  and is checked during probe, otherwise page attribute manipulation would
  not be possible. Care must be taken to only call the returned address as
  dst address is not guaranteed to be safely callable.
  NOTE: This function uses the fncpy macro to move code to the executable
  region. Some architectures have strict requirements for relocating
  executable code, so fncpy is a macro that must be defined by any arch
  making use of this functionality that guarantees a safe copy of exec
  data and returns a safe address that can be called as a C function
  pointer.
 SPDX-License-Identifier: GPL-2.0
  Device driver for irqs in HISI PMIC IC
  Copyright (c) 2013 Linaro Ltd.
  Copyright (c) 2011 Hisilicon.
  Copyright (c) 2020-2021 Huawei Technologies Co., Ltd.
 Protect IRQ mask changes 
  IRQ number for the power key button and mask for both UP and DOWN IRQs
  Registers for IRQ address and IRQ mask bits
  Please notice that we need to regmap a larger region, as other
  registers are used by the irqs.
  See driversirqhi6421-irq.c.
  The IRQs are mapped as:
 	======================  =============   ============	=====
 	IRQ			MASK REGISTER	IRQ REGISTER	BIT
 	======================  =============   ============	=====
 	OTMP			0x0202		0x212		bit 0
 	VBUS_CONNECT		0x0202		0x212		bit 1
 	VBUS_DISCONNECT		0x0202		0x212		bit 2
 	ALARMON_R		0x0202		0x212		bit 3
 	HOLD_6S			0x0202		0x212		bit 4
 	HOLD_1S			0x0202		0x212		bit 5
 	POWERKEY_UP		0x0202		0x212		bit 6
 	POWERKEY_DOWN		0x0202		0x212		bit 7
 	OCP_SCP_R		0x0203		0x213		bit 0
 	COUL_R			0x0203		0x213		bit 1
 	SIM0_HPD_R		0x0203		0x213		bit 2
 	SIM0_HPD_F		0x0203		0x213		bit 3
 	SIM1_HPD_R		0x0203		0x213		bit 4
 	SIM1_HPD_F		0x0203		0x213		bit 5
 	======================  =============   ============	=====
  Each mask register contains 8 bits. The ancillary macros below
  convert a number from 0 to 14 into a register address and a bit mask
 Mark pending IRQs as handled 
			
			  If both powerkey down and up IRQs are received,
			  handle them at the right order
 Mask all IRQs 
 Mark all IRQs as handled 
	
	  This driver is meant to be called by hi6421-spmi-core,
	  which should first set drvdata. If this doesn't happen, hit
	  a warn on and return.
 SPDX-License-Identifier: GPL-2.0
  Xilinx SDFEC
  Copyright (C) 2019 Xilinx, Inc.
  Description:
  This driver is developed for SDFEC16 (Soft Decision FEC 16nm)
  IP. It exposes a char device which supports file operations
  like  open(), close() and ioctl().
 Xilinx SDFEC Register Map 
 CODE_WRI_PROTECT Register 
 ACTIVE Register 
 AXIS_WIDTH Register 
 AXIS_ENABLE Register 
 FEC_CODE Register 
 ORDER Register Map 
 Interrupt Status Register 
 Interrupt Status Register Bit Mask 
 Write Only - Interrupt Enable Register 
 Write Only - Interrupt Disable Register 
 Read Only - Interrupt Mask Register 
 ECC Interrupt Status Register 
 Single Bit Errors 
 PL Initialize Single Bit Errors 
 Multi Bit Errors 
 PL Initialize Multi Bit Errors 
 Multi Bit Error to Event Shift 
 PL Initialize Multi Bit Error to Event Shift 
 ECC Interrupt Status Bit Mask 
 ECC Interrupt Status PL Initialize Bit Mask 
 ECC Interrupt Status All Bit Mask 
 ECC Interrupt Status Single Bit Errors Mask 
 ECC Interrupt Status Multi Bit Errors Mask 
 Write Only - ECC Interrupt Enable Register 
 Write Only - ECC Interrupt Disable Register 
 Read Only - ECC Interrupt Mask Register 
 BYPASS Register 
 Turbo Code Register 
 REG0 Register 
 REG1 Register 
 REG2 Register 
 REG3 Register 
 The maximum number of pinned pages 
  struct xsdfec_clks - For managing SD-FEC clocks
  @core_clk: Main processing clock for core
  @axi_clk: AXI4-Lite memory-mapped clock
  @din_words_clk: DIN Words AXI4-Stream Slave clock
  @din_clk: DIN AXI4-Stream Slave clock
  @dout_clk: DOUT Words AXI4-Stream Slave clock
  @dout_words_clk: DOUT AXI4-Stream Slave clock
  @ctrl_clk: Control AXI4-Stream Slave clock
  @status_clk: Status AXI4-Stream Slave clock
  struct xsdfec_dev - Driver data for SDFEC
  @miscdev: Misc device handle
  @clks: Clocks managed by the SDFEC driver
  @waitq: Driver wait queue
  @config: Configuration of the SDFEC device
  @dev_name: Device name
  @flags: spinlock flags
  @regs: device physical base address
  @dev: pointer to device struct
  @state: State of the SDFEC device
  @error_data_lock: Error counter and states spinlock
  @dev_id: Device ID
  @isr_err_count: Count of ISR errors
  @cecc_count: Count of Correctable ECC errors (SBE)
  @uecc_count: Count of Uncorrectable ECC errors (MBE)
  @irq: IRQ number
  @state_updated: indicates State updated by interrupt handler
  @stats_updated: indicates Stats updated by interrupt handler
  @intr_enabled: indicates IRQ enabled
  This structure contains necessary state for SDFEC driver to operate
 Spinlock to protect state_updated and stats_updated 
 Update the Order 
 Bit Number, maybe change to mask 
 Bit Number 
 Enable 
 Disable 
 Enable 
 Disable 
 Setup tlast related IRQ 
 Setup ECC related IRQ 
 Check to see what device tree says about the FEC codes 
	
	  Writes that go beyond the length of
	  Shared Scale(SC) table should fail
 Verify Device has not started 
 Write Reg 0 
 Write Reg 1 
 Write Reg 2 
 Write Reg 3 
 Write Shared Codes 
 Verify Device has not started 
 Verify Device has not started 
 using a double ! operator instead of casting 
 translate config info to register values 
 Set AXIS enable 
 Done 
 Disable AXIS_ENABLE Input interfaces only 
 Stop 
 Ensure registers are aligned with core configuration 
 In failed state allow only reset and get status IOCTLs 
 XSDFEC ISR detected an error 
 Fall through and set for valid values 
 Fall through and set for valid values 
 Write LDPC to CODE Register 
 Mask Interrupts 
 Read ISR 
 Clear the interrupts 
 Count uncorrectable 2-bit errors 
 Count all ECC errors 
 Number of correctable 1-bit ECC error 
 Count ISR errors 
 Add new errors to a 2-bits counter 
 Add new errors to a 1-bits counter 
 Add new errors to a ISR counter 
 Update statestats flag 
 Enable another polling 
 Unmask Interrupts 
 Save driver private data 
 Register IRQ thread 
 end of table  }
 SPDX-License-Identifier: GPL-2.0-or-later
   tsl2550.c - Linux kernel modules for ambient light sensor
   Copyright (C) 2007 Rodolfo Giometti <giometti@linux.it>
   Copyright (C) 2007 Eurotech S.p.A. <info@eurotech.it>
  Defines
  Structs
  Global data
  Management functions
 On power up we should reset operating mode also... 
 remove the "valid" bit 
  LUX calculation
  This function is described into Taos TSL2550 Designer's Notebook
  pages 2, 3.
 Look up count from channel values 
 Avoid division by 0 and count 1 cannot be greater than count 0 
			
			  Calculate ratio.
			  Note: the "128" is a scaling factor
 Calculate LUX 
 LUX range check 
  SysFS support
 Do the job 
 No LUX data if not operational 
  Initialization function
	
	  Probe the chip. To do so we try to power up the device and then to
	  read back the 0x03 code
 Set the default operating mode 
  I2C initprobingexit functions
 Check platform data 
 default mode is standard 
 Initialize the TSL2550 chip 
 Register sysfs hooks 
 Power down the device 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for the Analog Devices digital potentiometers (SPI bus)
  Copyright (C) 2010-2011 Michael Hennerich, Analog Devices Inc.
 SPI bus functions 
 SPDX-License-Identifier: GPL-2.0-only
  Dummy IRQ handler driver.
  This module only registers itself as a handler that is specified to it
  by the 'irq' parameter.
  The sole purpose of this module is to help with debugging of systems on
  which spurious IRQs would happen on disabled IRQ vector.
  Copyright (C) 2013 Jiri Kosina
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2012 Stefan Roese <sr@denx.de>
  The JTAG ID's of the supported FPGA's. The ID is 32bit wide
  reversed as noted in the manual.
 FPGA commands 
 plus 24 bits 
 plus 24 bits 
 plus 2 bits 
 plus 8 bits 
 plus 0 bits 
  The status register is 32bit revered, DONE is bit 17 from the TN1222.pdf
  (LatticeECP3 Slave SPI Port User's Guide)
 max. 5000ms for FPGA clear 
 Fill dummy data (24 stuffing bits for commands) 
 Trying to speak with the FPGA via SPI... 
	
	  Insert WRITE_INC command into stream (one SPI frame)
	
	  Wait for FPGA memory to become cleared
 Check result 
	
	  Don't forget to release the firmware again
 SPDX-License-Identifier: GPL-2.0-only
  This file is part of the ROHM BH1770GLC  OSRAM SFH7770 sensor driver.
  Chip is combined proximity and ambient light sensor.
  Copyright (C) 2010 Nokia Corporation andor its subsidiary(-ies).
  Contact: Samu Onkalo <samu.p.onkalo@nokia.com>
 ALS operation mode control 
 PS operation mode control 
 active LED and LED1, LED2 current 
 LED3 current setting 
 Forced mode trigger 
 PS meas. rate at stand alone mode 
 ALS meas. rate at stand alone mode 
 Part number and revision ID 
 Manufacturerer ID 
 ALS DATA low byte 
 ALS DATA high byte 
 Measurement data and int status 
 PS data from LED1 
 PS data from LED2 
 PS data from LED3 
 Interrupt setting 
 PS interrupt threshold for LED1 
 PS interrupt threshold for LED2 
 PS interrupt threshold for LED3 
 ALS upper threshold low byte 
 ALS upper threshold high byte 
 ALS lower threshold low byte 
 ALS lower threshold high byte 
 MANUFACT_ID 
 PART_ID 
 Operating modes for both 
 Interrupt control 
 0 = latched 
 1 = active high 
 Interrupt status 
 Led channels 
 Index to lux rate table 
 Direct HW value =~ 50Hz 
 Direct HW value =~ 5 Hz 
 Timeout in 2.1 seconds 
 CF ChipFactor 
 avoid parallel access 
 Chip specific factor 
  Supported stand alone rates in ms from chip data sheet
  {10, 20, 30, 40, 70, 100, 200, 500, 1000, 2000};
  Supported stand alone rates in ms from chip data sheet
  {100, 200, 500, 1000, 2000};
  interrupt control functions are called while keeping chip->mutex
  excluding module probe  remove
 Set interrupt modes, interrupt active low, latched 
 chip->mutex is always kept here 
 sysfs may call this when the chip is powered off 
 Proper proximity response needs fastest lux rate (100ms) 
 InfraredLED is controlled by the chip during proximity scanning 
 LED cfg, current for leds 1 and 2 
  Following two functions converts raw ps values from HW to normalized
  values. Purpose is to compensate differences between different sensor
  versions and variants so that result means about the same between
  versions.
  Following two functions converts raw lux values from HW to normalized
  values. Purpose is to compensate differences between different sensor
  versions and variants so that result means about the same between
  versions. Chip->mutex is kept when this is called.
 sysfs may call this when the chip is powered off 
 chip->mutex is kept when this is called 
 sysfs may call this when the chip is powered off 
	
	  Compensate threshold values with the correction factors if not
	  set to minimum or maximum.
	  Min & max values disables interrupts.
 Calculate correction value which contains chip and device specific parts 
 Impact of glass attenuation correction 
 Impact of chip factor correction 
 Impact of Device specific calibration correction 
  Chip on  off functions are called while keeping mutex except probe
  or remove phase
 Reset the chip 
	
	  ALS is started always since proximity needs als results
	  for realibility estimation.
	  Let's assume dark until the first ALS measurement is ready.
 Assume reset defaults 
 chip->mutex is kept when this is called 
 Force immediate update 
 chip->mutex is kept when this is called 
	
	  when ALS levels goes above limit, proximity result may be
	  false proximity. Thus ignore the result. With real proximity
	  there is a shadow causing low als levels.
 Strong proximity level or force mode requires immediate response 
 Persistence filttering to reduce false proximity events 
 Set proximity detection rate based on above or below value 
 Values selected by comparing different versions 
 0.8  BH1770_COEF_SCALER 
  This work is re-scheduled at every proximity interrupt.
  If this work is running, it means that there hasn't been any
  proximity interrupt in time. Situation is handled as no-proximity.
  It would be nice to have low-threshold interrupt or interrupt
  when measurement and hi-threshold are both 0. But neither of those exists.
  This is a workaroud for missing HW feature.
 This is threaded irq handler 
 Acknowledge interrupt by reading this register 
	
	  Check if there is fresh data available for als.
	  If this is the very first data, update thresholds after that.
 Disable interrupt logic to guarantee acknowledgement 
 Re-enable interrupt logic 
	
	  Can't cancel work while keeping mutex since the work uses the
	  same mutex.
		
		  Simulate missing no-proximity interrupt 50ms after the
		  next expected interrupt time.
 This causes interrupt after the next measurement cycle 
 Inform that we are waiting for a result from ALS 
 Chip is not enabled at all 
 Assume no proximity. Sensor will tell real state soon 
 Run control only when chip is powered on 
 Refresh thresholds on HW after changing correction value 
	
	  Don't update values in HW if we are still waiting for
	  first interrupt to come after device handle open call.
 Start chip 
	
	  Chip needs level triggered interrupt to work. However,
	  level triggering doesn't work always correctly with power
	  management. Select both
		
		  If we were enabled at suspend time, it is expected
		  everything works nice and smoothly
 This causes interrupt after the next measurement cycle 
 Inform that we are waiting for a result from ALS 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2013, The Linux Foundation. All rights reserved.
  Copyright (c) 2015, Sony Mobile Communications Inc.
 NOTE: for pm8921 and others, voltage of 2500 is 16 (10000b), not 0 
 if enable==0, rset and vset are ignored 
 if disabling, just do that and skip other operations 
 find index for current-limiting resistor 
 find index for charge voltage 
		
		  This is mainly to flag a bad base_addr (reg) from dts.
		  Other failures writing to the registers should be
		  extremely rare, or indicative of problems that
		  should be reported elsewhere (eg. spmi failure).
 set 'enable' register 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2021 HabanaLabs, Ltd.
  All Rights Reserved.
  hl_format_as_binary - helper function, format an integer as binary
                        using supplied scratch buffer
  @buf: the buffer to use
  @buf_len: buffer capacity
  @n: number to format
  Returns pointer to buffer
 Remove 3 characters from length for '0b' and '\0' termination 
		 Writing bit calculation in one line would cause a false
		  positive static code analysis error, so splitting.
  resize_to_fit - helper function, resize buffer to fit given amount of data
  @buf: destination buffer double pointer
  @size: pointer to the size container
  @desired_size: size the buffer must contain
  Returns 0 on success or error code on failure.
  On success, the size of buffer is at least desired_size. Buffer is allocated
  via vmalloc and must be freed with vfree.
 Not enough space to print all, have to resize 
  hl_snprintf_resize() - print formatted data to buffer, resize as needed
  @buf: buffer double pointer, to be written to and resized, must be either
        NULL or allocated with vmalloc.
  @size: current size of the buffer
  @offset: current offset to write to
  @format: format of the data
  This function will write formatted data into the buffer. If buffer is not
  large enough, it will be resized using vmalloc. Size may be modified if the
  buffer was resized, offset will be advanced by the number of bytes written
  not including the terminating character
  Returns 0 on success or error code on failure
  Note that the buffer has to be manually released using vfree.
 Resize was needed, write again 
  hl_sync_engine_to_string - convert engine type enum to string literal
  @engine_type: engine type (TPCMMEDMA)
  Return the resolved string literal
  hl_print_resize_sync_engine - helper function, format engine name and ID
  using hl_snprintf_resize
  @buf: destination buffer double pointer to be used with hl_snprintf_resize
  @size: pointer to the size container
  @offset: pointer to the offset container
  @engine_type: engine type (TPCMMEDMA)
  @engine_id: engine numerical id
  Returns 0 on success or error code on failure
  hl_state_dump_get_sync_name - transform sync object id to name if available
  @hdev: pointer to the device
  @sync_id: sync object id
  Returns a name literal or NULL if not resolved.
  Note: returning NULL shall not be considered as a failure, as not all
  sync objects are named.
  hl_state_dump_get_monitor_name - transform monitor object dump to monitor
  name if available
  @hdev: pointer to the device
  @mon: monitor state dump
  Returns a name literal or NULL if not resolved.
  Note: returning NULL shall not be considered as a failure, as not all
  monitors are named.
  hl_state_dump_free_sync_to_engine_map - free sync object to engine map
  @map: sync object to engine map
  Note: generic free implementation, the allocation is implemented per ASIC.
  hl_state_dump_get_sync_to_engine - transform sync_id to
  hl_sync_to_engine_map_entry if available for current id
  @map: sync object to engine map
  @sync_id: sync object id
  Returns the translation entry if found or NULL if not.
  Note, returned NULL shall not be considered as a failure as the map
  does not cover all possible, it is a best effort sync ids.
  hl_state_dump_read_sync_objects - read sync objects array
  @hdev: pointer to the device
  @index: sync manager block index starting with E_N
  Returns array of size SP_SYNC_OBJ_AMOUNT on success or NULL on failure
 Base addr can be negative 
  hl_state_dump_free_sync_objects - free sync objects array allocated by
  hl_state_dump_read_sync_objects
  @sync_objects: sync objects array
  hl_state_dump_print_syncs_single_block - print active sync objects on a
  single block
  @hdev: pointer to the device
  @index: sync manager block index starting with E_N
  @buf: destination buffer double pointer to be used with hl_snprintf_resize
  @size: pointer to the size container
  @offset: pointer to the offset container
  @map: sync engines names map
  Returns 0 on success or error code on failure
 Append engine string 
  hl_state_dump_print_syncs - print active sync objects
  @hdev: pointer to the device
  @buf: destination buffer double pointer to be used with hl_snprintf_resize
  @size: pointer to the size container
  @offset: pointer to the offset container
  Returns 0 on success or error code on failure
  hl_state_dump_alloc_read_sm_block_monitors - read monitors for a specific
  block
  @hdev: pointer to the device
  @index: sync manager block index starting with E_N
  Returns an array of monitor data of size SP_MONITORS_AMOUNT or NULL
  on error
 Base addr can be negative 
  hl_state_dump_free_monitors - free the monitors structure
  @monitors: monitors array created with
             hl_state_dump_alloc_read_sm_block_monitors
  hl_state_dump_print_monitors_single_block - print active monitors on a
  single block
  @hdev: pointer to the device
  @index: sync manager block index starting with E_N
  @buf: destination buffer double pointer to be used with hl_snprintf_resize
  @size: pointer to the size container
  @offset: pointer to the offset container
  Returns 0 on success or error code on failure
 Monitor is valid, dump it 
  hl_state_dump_print_monitors - print active monitors
  @hdev: pointer to the device
  @buf: destination buffer double pointer to be used with hl_snprintf_resize
  @size: pointer to the size container
  @offset: pointer to the offset container
  Returns 0 on success or error code on failure
  hl_state_dump_print_engine_fences - print active fences for a specific
  engine
  @hdev: pointer to the device
  @engine_type: engine type to use
  @buf: destination buffer double pointer to be used with hl_snprintf_resize
  @size: pointer to the size container
  @offset: pointer to the offset container
  hl_state_dump_print_fences - print active fences
  @hdev: pointer to the device
  @buf: destination buffer double pointer to be used with hl_snprintf_resize
  @size: pointer to the size container
  @offset: pointer to the offset container
  hl_state_dump() - dump system state
  @hdev: pointer to device structure
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
	 if we're here, then there was a signals reservation but cs with
	  encaps signals wasn't submitted, so need to put refcount
	  to hw_sob taken at the reservation.
	 Release all allocated HW block mapped list entries and destroy
	  the mutex.
	
	  If we arrived here, there are no jobs waiting for this context
	  on its queues so we can safely remove it.
	  This is because for each CS, we increment the ref count and for
	  every CS that was finished we decrement it and we won't arrive
	  to this function unless the ref count is 0
		 The engines are stopped as there is no executing CS, but the
		  Coresight might be still working by accessing addresses
		  related to the stopped engines. Hence stop it explicitly.
		  Stop only if this is the compute context, as there can be
		  only one compute context
 Scrub both SRAM and DRAM 
 TODO: remove for multiple contexts per process 
 TODO: remove the following line for multiple process support 
 Kernel driver gets ASID 0 
  hl_ctx_get_fence_locked - get CS fence under CS lock
  @ctx: pointer to the context structure.
  @seq: CS sequences number
  @return valid fence pointer on success, NULL if fence is gone, otherwise
          error pointer.
  NOTE: this function shall be called with cs_lock locked
  hl_ctx_get_fences - get multiple CS fences under the same CS lock
  @ctx: pointer to the context structure.
  @seq_arr: array of CS sequences to wait for
  @fence: fence array to store the CS fences
  @arr_len: length of seq_arr and fence_arr
  @return 0 on success, otherwise non 0 error code
  hl_ctx_mgr_init - initialize the context manager
  @mgr: pointer to context manager structure
  This manager is an object inside the hpriv object of the user process.
  The function is called when a user process opens the FD.
  hl_ctx_mgr_fini - finalize the context manager
  @hdev: pointer to device structure
  @mgr: pointer to context manager structure
  This function goes over all the contexts in the manager and frees them.
  It is called when a process closes the FD.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
  hl_queue_add_ptr - add to pi or ci and checks if it wraps around
  @ptr: the current pici value
  @val: the amount to add
  Add val to ptr. It can go until twice the queue length.
 There are no internal queues if HW queues are being used 
	 We must increment CI for every queue that will never get a
	  completion, there are 2 scenarios this can happen:
	  1. All queues of a non completion CS will never get a completion.
	  2. Internal queues never gets completion.
  hl_hw_queue_submit_bd() - Submit a buffer descriptor to an external or a
                                 HW queue.
  @hdev: pointer to habanalabs device structure
  @q: pointer to habanalabs queue structure
  @ctl: BD's control word
  @len: BD's length
  @ptr: BD's pointer
  This function assumes there is enough space on the queue to submit a new
  BD to it. It initializes the next BD and calls the device specific
  function to set the pi (and doorbell)
  This function must be called when the scheduler mutex is taken
  ext_queue_sanity_checks - perform some sanity checks on external queue
  @hdev              : pointer to hl_device structure
  @q                 :	pointer to hl_hw_queue structure
  @num_of_entries    : how many entries to check for space
  @reserve_cq_entry  :	whether to reserve an entry in the cq
  HW queues spinlock should be taken before calling this function
  Perform the following:
  - Make sure we have enough space in the hw queue
  - Make sure we have enough space in the completion queue
  - Reserve space in the completion queue (needs to be reversed if there
    is a failure down the road before the actual submission of work). Only
    do this action if reserve_cq_entry is true
 Check we have enough space in the queue 
		
		  Check we have enough space in the completion queue
		  Add -1 to counter (decrement) unless counter was already 0
		  In that case, CQ is full so we can't submit a new CB because
		  we won't get ack on its completion
		  atomic_add_unless will return 0 if counter was already 0
  int_queue_sanity_checks - perform some sanity checks on internal queue
  @hdev              : pointer to hl_device structure
  @q                 :	pointer to hl_hw_queue structure
  @num_of_entries    : how many entries to check for space
  HW queues spinlock should be taken before calling this function
  Perform the following:
  - Make sure we have enough space in the hw queue
 Check we have enough space in the queue 
  hw_queue_sanity_checks() - Make sure we have enough space in the hw queue
  @hdev: Pointer to hl_device structure.
  @q: Pointer to hl_hw_queue structure.
  @num_of_entries: How many entries to check for space.
  Notice: We do not reserve queue entries so this function mustn't be called
          more than once per CS for the same queue
 Check we have enough space in the queue 
  hl_hw_queue_send_cb_no_cmpl - send a single CB (not a JOB) without completion
  @hdev: pointer to hl_device structure
  @hw_queue_id: Queue's type
  @cb_size: size of CB
  @cb_ptr: pointer to CB location
  This function sends a single CB, that must NOT generate a completion entry.
  Sending CPU messages can be done instead via 'hl_hw_queue_submit_bd()'
	
	  hl_hw_queue_send_cb_no_cmpl() is called for queues of a HW queue
	  type only on init phase, when the queues are empty and being tested,
	  so there is no need for sanity checks.
  ext_queue_schedule_job - submit a JOB to an external queue
  @job: pointer to the job that needs to be submitted to the queue
  This function must be called when the scheduler mutex is taken
	
	  Update the JOB ID inside the BD CTL so the device would know what
	  to write in the completion queue
 Skip completion flow in case this is a non completion CS 
	
	  No need to protect pi_offset because scheduling to the
	  HW queues is done under the scheduler mutex
	 
	  No need to check if CQ is full because it was already
	  checked in ext_queue_sanity_checks
  int_queue_schedule_job - submit a JOB to an internal queue
  @job: pointer to the job that needs to be submitted to the queue
  This function must be called when the scheduler mutex is taken
		 bus_address is actually a mmu mapped address
		  allocated from an internal pool
  hw_queue_schedule_job - submit a JOB to a HW queue
  @job: pointer to the job that needs to be submitted to the queue
  This function must be called when the scheduler mutex is taken
	
	  Upon PQE completion, COMP_DATA is used as the write data to the
	  completion queue (QMAN HBW message), and COMP_OFFSET is used as the
	  write address offset in the SM block (QMAN LBW message).
	  The write address offset is calculated as "COMP_OFFSET << 2".
	
	  A patched CB is created only if a user CB was allocated by driver and
	  MMU is disabled. If MMU is enabled, the user CB should be used
	  instead. If the user CB wasn't allocated by driver, assume that it
	  holds an address.
	 we set an EB since we must make sure all oeprations are done
	  when sending the signal
	 Note that encaps_sig_wait_offset was validated earlier in the flow
	  for offset value which exceeds the max reserved signal count.
	  always decrement 1 of the offset since when the user
	  set offset 1 for example he mean to wait only for the first
	  signal only, which will be pre_sob_val, and if he set offset 2
	  then the value required is (pre_sob_val + 1) and so on...
	  if user set wait offset to 0, then treat it as legacy wait cs,
	  wait for the next signal.
		 use the encaps signal handle stored earlier in the flow
		  and set the SOB information from the encaps
		  signals handle
 Copy the SOB id and value of the signal CS 
	 check again if the signal cs already completed.
	  if yes then don't send any wait cs since the hw_sob
	  could be in reset already. if signal is not completed
	  then get refcount to hw_sob to prevent resetting the sob
	  while wait cs is not submitted.
	  note that this check is protected by two locks,
	  hw queue lock and completion object lock,
	  and the same completion object lock also protects
	  the hw_sob reset handler function.
	  The hw_queue lock prevent out of sync of hw_sob
	  refcount value, changed by signalwait flows.
  init_signal_wait_cs - initialize a signalwait CS
  @cs: pointer to the signalwait CS
  HW queues spinlock should be taken before calling this function
 There is only one job in a signalwait CS 
		
		  Set handler CS sequence,
		  the CS which contains the encapsulated signals.
		 store the handle and set encaps signal indication,
		  to be used later in cs_do_release to put the last
		  reference to encaps signals handlers.
		 set hw_sob pointer in completion object
		  since it's used in cs_do_release flow to put
		  refcount to sob
  hl_hw_queue_schedule_cs - schedule a command submission
  @cs: pointer to the CS
 Verify staged CS exists and add to the staged list 
 update stream map of the first CS 
 Queue TDR if the CS is the first entry and if timeout is wanted 
  hl_hw_queue_inc_ci_kernel - increment ci for kernel's queue
  @hdev: pointer to hl_device structure
  @hw_queue_id: which queue to increment its ci
 Make sure readwrite pointers are initialized to start of queue 
 Make sure readwrite pointers are initialized to start of queue 
	 We use 'collective_mon_idx' as a running index in order to reserve
	  monitors for collective masterslave queues.
	  collective master queue gets 2 reserved monitors
	  collective slave queue gets 1 reserved monitor
 reserve the first monitor for collective master queue 
 reserve the second monitor for collective master queue 
 reserve a monitor for collective slave queue 
	
	  In case we got here due to a stuck CS, the refcnt might be bigger
	  than 1 and therefore we reset it.
  queue_init - main initialization function for HW queue object
  @hdev: pointer to hl_device device structure
  @q: pointer to hl_hw_queue queue structure
  @hw_queue_id: The id of the HW queue
  Allocate dma-able memory for the queue and initialize fields
  Returns 0 on success
  hw_queue_fini - destroy queue
  @hdev: pointer to hl_device device structure
  @q: pointer to hl_hw_queue queue structure
  Free the queue memory
	
	  If we arrived here, there are no jobs waiting on this queue
	  so we can safely remove it.
	  This is because this function can only called when:
	  1. Either a context is deleted, which only can occur if all its
	     jobs were finished
	  2. A context wasn't able to be created due to failure or timeout,
	     which means there are no jobs on the queue yet
	 
	  The only exception are the queues of the kernel context, but
	  if they are being destroyed, it means that the entire module is
	  being removed. If the module is removed, it means there is no open
	  user context. It also means that if a job was submitted by
	  the kernel driver (e.g. context creation), the job itself was
	  released by the kernel driver when a timeout occurred on its
	  Completion. Thus, we don't need to release it again.
 Initialize the HW queues 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
	
	  We use of GFP_ATOMIC here because this function can be called from
	  the latency-sensitive code path for command submission. Due to HW
	  limitations in some of the ASICs, the kernel must copy the user CB
	  that is designated for an external queue and actually enqueue
	  the kernel's copy. Hence, we must never sleep in this code section
	  and must use GFP_ATOMIC for all memory allocations.
	
	  Can't use generic function to check this because of special case
	  where we create a CB as part of the reset process
 Minimum allocation must be PAGE SIZE 
	
	  idr is 32-bit so we can safely OR it with a mask that is above
	  32 bit
	
	  handle was given to user to do mmap, I need to shift it back to
	  how the idr module gave it to me
	 The CB handle was given to user to do mmap, so need to shift it back
	  to the value which was allocated by the IDR module.
	 We use the page offset to hold the idr and thus we need to clear
	  it before doing the mmap itself
 reference was taken here 
 Validation check 
	
	  Note: We're transferring the cb reference to
	  vma->vm_private_data here.
 hl_cb_get should never fail here 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2019-2021 HabanaLabs, Ltd.
  All Rights Reserved.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2021 HabanaLabs, Ltd.
  All Rights Reserved.
 maximum size of 20MB 
 Skip the fw- part 
 Copy until the next whitespace 
  hl_release_firmware() - release FW
  @fw: fw descriptor
  note: this inline function added to serve as a comprehensive mirror for the
        hl_request_fw function.
  hl_fw_copy_fw_to_device() - copy FW to device
  @hdev: pointer to hl_device structure.
  @fw: fw descriptor
  @dst: IO memory mapped address space to copy firmware to
  @src_offset: offset in src FW to copy from
  @size: amount of bytes to copy (0 to copy the whole binary)
  actual copy of FW binary data to device, shared by static and dynamic loaders
 size 0 indicates to copy the whole file 
  hl_fw_copy_msg_to_device() - copy message to device
  @hdev: pointer to hl_device structure.
  @msg: message
  @dst: IO memory mapped address space to copy firmware to
  @src_offset: offset in src message to copy from
  @size: amount of bytes to copy (0 to copy the whole binary)
  actual copy of message data to device.
 size 0 indicates to copy the whole file 
  hl_fw_load_fw_to_device() - Load FW code to device's memory.
  @hdev: pointer to hl_device structure.
  @fw_name: the firmware image name
  @dst: IO memory mapped address space to copy firmware to
  @src_offset: offset in src FW to copy from
  @size: amount of bytes to copy (0 to copy the whole binary)
  Copy fw code from firmware file to device memory.
  Return: 0 on success, non-zero for failure.
 set fence to a non valid value 
	
	  The CPU queue is a synchronous queue with an effective depth of
	  a single entry (although it is allocated with room for multiple
	  entries). We lock on it using 'send_cpu_message_lock' which
	  serializes accesses to the CPU queue.
	  Which means that we don't need to lock the access to the entire HW
	  queues module when submitting a JOB to the CPU queue.
 data should be aligned to 8 bytes in order to CPU-CP to copy it 
 total_pkt_size is casted to u16 later on 
		 This is a warning so we don't want it to disable the
		  device
			 This is an info so we don't want it to disable the
			  device
		 This is a warning so we don't want it to disable the
		  device as we have a secondary preboot image
 Ignore this bit, don't prevent driver loading 
 return error only if it's in the predefined mask 
 placeholder for ERR1 as no errors defined there yet 
	
	  keep this variable to preserve the logic of the function.
	  this way it would require less modifications when error will be
	  added to DEV_ERR1
 return error only if it's in the predefined mask 
	 Some of the firmware status codes are deprecated in newer fw
	  versions. In those versions, the errors are reported
	  in different registers. Therefore, we need to check those
	  registers and print the exact errors. Moreover, there
	  may be multiple errors, so we need to report on each error
	  separately. Some of the error codes might indicate a state
	  that is not an error per-se, but it is an error in production
	  environment
 assume EQ code doesn't need to check eqe index 
 Read FW application security bits again 
 skip sending this info for unsupported ASICs 
 data should be aligned to 8 bytes in order to CPU-CP to copy it 
 total_pkt_size is casted to u16 later on 
	
	  in case packet result is invalid it means that FW does not support
	  this feature and will use defaulthard coded MSI values. no reason
	  to stop the boot
 result contains the actual size 
 Fetch PCI rx counter 
 Fetch PCI tx counter 
 Fetch PCI replay counter 
		
		  in case we are working with legacy FW (each asic has unique
		  PLL numbering) use the driver based index as they are
		  aligned with fw legacy numbering
	 retrieve a FW compatible PLL index based on
	  ASIC specific user request
 PLL map is a u8 array 
 Stop device CPU to make sure nothing bad happens 
		 Must clear this register in order to prevent preboot
		  from reading WFE after reboot
	 Some of the status codes below are deprecated in newer fw
	  versions but we keep them here for backward compatibility
	 Need to check two possible scenarios:
	 
	  CPU_BOOT_STATUS_WAITING_FOR_BOOT_FIT - for newer firmwares where
	  the preboot is waiting for the boot fit
	 
	  All other status values - for older firmwares where the uboot was
	  loaded from the FLASH
		 If we read all FF, then something is totally wrong, no point
		  of reading specific errors
	
	  the registers DEV_STS contain FW capabilitiesfeatures.
	  We can rely on this registers only if bit CPU_BOOT_DEV_STS_ENABLED
	  is set.
	  In the first read of this register we store the value of this
	  register ONLY if the register is enabled (which will be propagated
	  to next stages) and also mark the register as valid.
	  In case it is not enabled the stored value will be left 0- all
	  capsfeatures are off
 initialize FW loader once we know what load protocol is used 
  hl_fw_preboot_update_state - update internal data structures during
                               handshake with preboot
  @hdev: pointer to the habanalabs device structure
  @return 0 on success, otherwise non-zero error code
	 We read boot_dev_sts registers multiple times during boot:
	  1. preboot - a. Check whether the security status bits are valid
	               b. Check whether fw security is enabled
	               c. Check whether hard reset is done by preboot
	  2. boot cpu - a. Fetch boot cpu security status
	                b. Check whether hard reset is done by boot cpu
	  3. FW application - a. Fetch fw application security status
	                      b. Check whether hard reset is done by fw app
	 pldm was added for cases in which we use preboot on pldm and want
	  to load boot fit, but we can't wait for preboot because it runs
	  very slowly
	
	  In order to determine boot method (static VS dymanic) we need to
	  read the boot caps register
 no need to read preboot status in dynamic load 
 associate string with COMM status 
  hl_fw_dynamic_report_error_status - report error status
  @hdev: pointer to the habanalabs device structure
  @status: value of FW status register
  @expected_status: the expected status
  hl_fw_dynamic_send_cmd - send LKD to FW cmd
  @hdev: pointer to the habanalabs device structure
  @fw_loader: managing structure for loading device's FW
  @cmd: LKD to FW cmd code
  @size: size of next FW component to be loaded (0 if not necessary)
  LDK to FW exact command layout is defined at struct comms_command.
  note: the size argument is used only when the next FW component should be
        loaded, otherwise it shall be 0. the size is used by the FW in later
        protocol stages and when sending only indicating the amount of memory
        to be allocated by the FW to receive the next boot component.
  hl_fw_dynamic_extract_fw_response - update the FW response
  @hdev: pointer to the habanalabs device structure
  @fw_loader: managing structure for loading device's FW
  @response: FW response
  @status: the status read from CPU status register
  @return 0 on success, otherwise non-zero error code
  hl_fw_dynamic_wait_for_status - wait for status in dynamic FW load
  @hdev: pointer to the habanalabs device structure
  @fw_loader: managing structure for loading device's FW
  @expected_status: expected status to wait for
  @timeout: timeout for status wait
  @return 0 on success, otherwise non-zero error code
  waiting for status from FW include polling the FW status register until
  expected status is received or timeout occurs (whatever occurs first).
 Wait for expected status 
	
	  skip storing FW response for NOOP to preserve the actual desired
	  FW status
  hl_fw_dynamic_send_clear_cmd - send clear command to FW
  @hdev: pointer to the habanalabs device structure
  @fw_loader: managing structure for loading device's FW
  @return 0 on success, otherwise non-zero error code
  after command cycle between LKD to FW CPU (i.e. LKD got an expected status
  from FW) we need to clear the CPU status register in order to avoid garbage
  between command cycles.
  This is done by sending clear command and polling the CPU to LKD status
  register to hold the status NOOP
  hl_fw_dynamic_send_protocol_cmd - send LKD to FW cmd and wait for ACK
  @hdev: pointer to the habanalabs device structure
  @fw_loader: managing structure for loading device's FW
  @cmd: LKD to FW cmd code
  @size: size of next FW component to be loaded (0 if not necessary)
  @wait_ok: if true also wait for OK response from FW
  @timeout: timeout for status wait
  @return 0 on success, otherwise non-zero error code
  brief:
  when sending protocol command we have the following steps:
  - send clear (clear command and verify clear status register)
  - send the actual protocol command
  - wait for ACK on the protocol command
  - send clear
  - send NOOP
  if, in addition, the specific protocol command should wait for OK then:
  - wait for OK
  - send clear
  - send NOOP
  NOTES:
  send clear: this is necessary in order to clear the status register to avoid
              leftovers between command
  NOOP command: necessary to avoid loop on the clear command by the FW
 first send clear command to clean former commands 
 send the actual command 
 wait for ACK for the command 
 clear command to prepare for NOOP command 
 send the actual NOOP command 
 clear command to prepare for NOOP command 
 send the actual NOOP command 
  hl_fw_compat_crc32 - CRC compatible with FW
  @data: pointer to the data
  @size: size of the data
  @return the CRC32 result
  NOTE: kernel's CRC32 differ's from standard CRC32 calculation.
        in order to be aligned we need to flip the bits of both the input
        initial CRC and kernel's CRC32 result.
        in addition both sides use initial CRC of 0,
  hl_fw_dynamic_validate_memory_bound - validate memory bounds for memory
                                         transfer (image or descriptor) between
                                         host and FW
  @hdev: pointer to the habanalabs device structure
  @addr: device address of memory transfer
  @size: memory transter size
  @region: PCI memory region
  @return 0 on success, otherwise non-zero error code
 now make sure that the memory transfer is within region's bounds 
	
	  now make sure memory transfer is within predefined BAR bounds.
	  this is to make sure we do not need to set the bar (e.g. for DRAM
	  memory transfers)
  hl_fw_dynamic_validate_descriptor - validate FW descriptor
  @hdev: pointer to the habanalabs device structure
  @fw_loader: managing structure for loading device's FW
  @fw_desc: the descriptor form FW
  @return 0 on success, otherwise non-zero error code
	
	  calc CRC32 of data without header.
	  note that no alignmentstride address issues here as all structures
	  are 64 bit padded
 find memory region to which to copy the image 
 store the region for the copy stage 
	
	  here we know that the start address is valid, now make sure that the
	  image is within region's bounds
	
	  validate that the descriptor is within region's bounds
	  Note that as the start address was supplied according to the RAM
	  type- testing only the end address is enough
  hl_fw_dynamic_read_and_validate_descriptor - read and validate FW descriptor
  @hdev: pointer to the habanalabs device structure
  @fw_loader: managing structure for loading device's FW
  @return 0 on success, otherwise non-zero error code
 extract address copy the descriptor from 
  hl_fw_dynamic_request_descriptor - handshake with CPU to get FW descriptor
  @hdev: pointer to the habanalabs device structure
  @fw_loader: managing structure for loading device's FW
  @next_image_size: size to allocate for next FW component
  @return 0 on success, otherwise non-zero error code
  hl_fw_dynamic_read_device_fw_version - read FW version to exposed properties
  @hdev: pointer to the habanalabs device structure
  @fwc: the firmware component
  @fw_version: fw component's version string
  hl_fw_dynamic_copy_image - copy image to memory allocated by the FW
  @hdev: pointer to the habanalabs device structure
  @fw: fw descriptor
  @fw_loader: managing structure for loading device's FW
 find memory region to which to copy the image 
  hl_fw_dynamic_copy_msg - copy msg to memory allocated by the FW
  @hdev: pointer to the habanalabs device structure
  @msg: message
  @fw_loader: managing structure for loading device's FW
 find memory region to which to copy the image 
  hl_fw_boot_fit_update_state - update internal data structures after boot-fit
                                is loaded
  @hdev: pointer to the habanalabs device structure
  @cpu_boot_dev_sts0_reg: register holding CPU boot dev status 0
  @cpu_boot_dev_sts1_reg: register holding CPU boot dev status 1
  @return 0 on success, otherwise non-zero error code
 Clear reset status since we need to read it again from boot CPU 
 Read boot_cpu status bits 
	 Check whether all 3 interrupt interfaces are set, if not use a
	  single interface
  hl_fw_dynamic_load_image - load FW image using dynamic protocol
  @hdev: pointer to the habanalabs device structure
  @fw_loader: managing structure for loading device's FW
  @load_fwc: the FW component to be loaded
  @img_ld_timeout: image load timeout
  @return 0 on success, otherwise non-zero error code
	
	  when loading image we have one of 2 scenarios:
	  1. current FW component is preboot and we want to load boot-fit
	  2. current FW component is boot-fit and we want to load linux
 request FW in order to communicate to FW the size to be allocated 
 store the image size for future validation 
 read preboot version 
 update state according to boot stage 
 copy boot fit to space allocated by FW 
 Make sure CPU boot-loader is running 
 Make sure CPU boot-loader is running 
  hl_fw_linux_update_state -	update internal data structures after Linux
 				is loaded.
 				Note: Linux initialization is comprised mainly
 				of two stages - loading kernel (SRAM_AVAIL)
 				& loading ARMCP.
 				Therefore reading boot device status in any of
 				these stages might result in different values.
  @hdev: pointer to the habanalabs device structure
  @cpu_boot_dev_sts0_reg: register holding CPU boot dev status 0
  @cpu_boot_dev_sts1_reg: register holding CPU boot dev status 1
  @return 0 on success, otherwise non-zero error code
 Clear reset status since we need to read again from app 
 Read FW application security bits 
  hl_fw_dynamic_send_msg - send a COMMS message with attached data
  @hdev: pointer to the habanalabs device structure
  @fw_loader: managing structure for loading device's FW
  @msg_type: message type
  @data: data to be sent
  @return 0 on success, otherwise non-zero error code
 create message to be sent 
 copy message to space allocated by FW 
  hl_fw_dynamic_init_cpu - initialize the device CPU using dynamic protocol
  @hdev: pointer to the habanalabs device structure
  @fw_loader: managing structure for loading device's FW
  @return 0 on success, otherwise non-zero error code
  brief: the dynamic protocol is master (LKD) slave (FW CPU) protocol.
  the communication is done using registers:
  - LKD command register
  - FW status register
  the protocol is race free. this goal is achieved by splitting the requests
  and response to known synchronization points between the LKD and the FW.
  each response to LKD request is known and bound to a predefined timeout.
  in case of timeout expiration without the desired status from FW- the
  protocol (and hence the boot) will fail.
	
	  In this stage, "cpu_dyn_regs" contains only LKD's hard coded values!
	  It will be updated from FW after hl_fw_dynamic_request_descriptor().
 Clear current reset cause 
 read preboot version 
 load boot fit to FW 
	 Enable DRAM scrambling before Linux boot and after successful
	   UBoot
 load Linux image to FW 
  hl_fw_static_init_cpu - initialize the device CPU using static protocol
  @hdev: pointer to the habanalabs device structure
  @fw_loader: managing structure for loading device's FW
  @return 0 on success, otherwise non-zero error code
 init common loader parameters 
 init static loader parameters 
 Wait for boot FIT request 
 Clear device CPU message status 
 Signal device CPU that boot loader is ready 
 Poll for CPU device ack 
 Clear message 
 Make sure CPU boot-loader is running 
 Read U-Boot version now in case we will later fail 
 update state according to boot stage 
	 Enable DRAM scrambling before Linux boot and after successful
	   UBoot
 Clear message 
  hl_fw_init_cpu - initialize the device CPU
  @hdev: pointer to the habanalabs device structure
  @return 0 on success, otherwise non-zero error code
  perform necessary initializations for device's CPU. takes into account if
  init protocol is static or dynamic.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
 ASID 0 is reserved for the kernel driver and device CPU 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
  get_asic_type - translate device id to asic type
  @device: id of the PCI device
  Translate device id to asic type.
  In case of unidentified device, return -1
  hl_device_open - open function for habanalabs device
  @inode: pointer to inode structure
  @filp: pointer to file structure
  Called when process opens an habanalabs device.
	 Device is IDLE at this point so it is legal to change PLLs.
	  There is no need to check anything because if the PLL is
	  already HIGH, the set function will return without doing
	  anything
	 Prevent other routines from reading partial hpriv data by
	  initializing hpriv fields before inserting it to the list
  create_hdev - create habanalabs device instance
  @dev: will hold the pointer to the new habanalabs device structure
  @pdev: pointer to the pci device
  @asic_type: in case of simulator device, which device is it
  @minor: in case of simulator device, the minor of the device
  Allocate memory for habanalabs device and initialize basic fields
  Identify the ASIC type
  Allocate ID (minor) for the device (only for real devices)
	 First, we must find out which ASIC are we handling. This is needed
	  to configure the behavior of the driver (kernel parameters)
 Assign status description string 
 can be NULL in case of simulator device 
 Set default DMA mask to 32 bits 
	 Always save 2 numbers, 1 for main device and 1 for control.
	  They must be consecutive
  destroy_hdev - destroy habanalabs device instance
  @dev: pointer to the habanalabs device structure
 Remove device from the device list 
  hl_pci_probe - probe PCI habanalabs devices
  @pdev: pointer to pci device
  @id: pointer to pci device id structure
  Standard PCI probe function for habanalabs device.
  Create a new habanalabs device and initialize it according to the
  device's type
  hl_pci_remove - remove PCI habanalabs devices
  @pdev: pointer to pci device
  Standard PCI remove function for habanalabs device
  hl_pci_err_detected - a PCI bus error detected on this device
  @pdev: pointer to pci device
  @state: PCI error type
  Called by the PCI subsystem whenever a non-correctable
  PCI bus error is detected
  hl_pci_err_resume - resume after a PCI slot reset
  @pdev: pointer to pci device
  hl_pci_err_slot_reset - a PCI slot reset has just happened
  @pdev: pointer to pci device
  Determine if the driver can recover from the PCI slot reset
  hl_init - Initialize the habanalabs kernel driver
  hl_exit - Release all resources of the habanalabs kernel driver
	
	  Removing debugfs must be after all devices or simulator devices
	  have been removed because otherwise we get a bug in the
	  debugfs module for referencing NULL objects
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
 Verify address is mapped 
 Free the previous allocation, if there was any 
 don't allow partial writes 
  hl_debugfs_set_state_dump - register state dump making it accessible via
                              debugfs
  @hdev: pointer to the device structure
  @data: the actual dump data
  @length: the length of the data
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
	
	  Information is returned for the following opcodes even if the device
	  is disabled or in reset.
 Do not trust userspace, use our own definition 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
 use uppercase for backward compatibility 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
	 We need to remove the user from the list to make sure the reset process won't
	  try to kill the user process. Because, if we got here, it means there are no
	  more driverdevice resources that the user process is occupying so there is
	  no need to kill it
	 
	  However, we can't set the compute_ctx to NULL at this stage. This is to prevent
	  a race between the release and opening the device again. We don't want to let
	  a user open the device while there a reset is about to happen.
	 Now we can mark the compute_ctx as empty. Even if a reset is running in a different
	  thread, we don't care because the in_reset is marked so if a user will try to open
	  the device it will fail on that, even if compute_ctx is NULL.
  hl_device_release - release function for habanalabs device
  @inode: pointer to inode structure
  @filp: pointer to file structure
  Called when process closes an habanalabs device
	 Each pending user interrupt holds the user's context, hence we
	  must release them all before calling hl_ctx_mgr_fini().
  hl_mmap - mmap function for habanalabs device
  @filp: pointer to file structure
  @vma: pointer to vm_area_struct of the process
  Called when process does an mmap on habanalabs device. Call the device's mmap
  function at the end of the common code.
  device_init_cdev - Initialize cdev and device for habanalabs device
  @hdev: pointer to habanalabs device structure
  @hclass: pointer to the class object of the device
  @minor: minor number of the specific device
  @fpos: file operations to install for this device
  @name: name of the device as it will appear in the filesystem
  @cdev: pointer to the char device object that will be initialized
  @dev: pointer to the device object that will be initialized
  Initialize a cdev and a Linux device for habanalabs's device.
 hl_sysfs_init() must be done after adding the device to the system 
  device_early_init - do some early initialization for the habanalabs device
  @hdev: pointer to habanalabs device structure
  Install the relevant function pointers and call the early_init function,
  if such a function exists
  device_early_fini - finalize all that was done in device_early_init
  @hdev: pointer to habanalabs device structure
	
	  prev_reset_trigger tracks consecutive fatal hw errors until first
	  heartbeat immediately post reset.
	  If control reached here, then at least one heartbeat work has been
	  scheduled since last resetinit cycle.
	  So if the device is not already in reset cycle, reset the flag
	  prev_reset_trigger as no reset occurred with HL_RESET_FW_FATAL_ERR
	  status for at least one heartbeat. From this point driver restarts
	  tracking future consecutive fatal errors.
  device_late_init - do late stuff initialization for the habanalabs device
  @hdev: pointer to habanalabs device structure
  Do stuff that either needs the device HW queues to be active or needs
  to happen after all the rest of the initialization is finished
 force setting to low frequency 
  device_late_fini - finalize all that was done in device_late_init
  @hdev: pointer to habanalabs device structure
  hl_device_set_frequency - set the frequency of the device
  @hdev: pointer to habanalabs device structure
  @freq: the new frequency value
  Change the frequency if needed. This function has no protection against
  concurrency, therefore it is assumed that the calling function has protected
  itself against the case of calling this function from multiple threads with
  different values
  Returns 0 if no change was done, otherwise returns 1
	 Flush anyone that is inside the critical section of enqueue
	  jobs to the HW
 Flush processes that are sending message to CPU 
 Flush anyone that is inside device open 
	
	  Halt the engines and disable interrupts so we won't get any more
	  completions from HW and we won't have any accesses from the
	  HW to the host machine
 Go over all the queues, release all CS and their jobs 
	 Release all pending user interrupts, each pending user interrupt
	  holds a reference to user context
  hl_device_suspend - initiate device suspend
  @hdev: pointer to habanalabs device structure
  Puts the hw in the suspend state (all asics).
  Returns 0 for success or an error on failure.
  Called at driver suspend.
 Block future CSVMJOB completion operations 
 This blocks all other stuff that is not blocked by in_reset 
 Shut down the device 
  hl_device_resume - initiate device resume
  @hdev: pointer to habanalabs device structure
  Bring the hw back to operating state (all asics).
  Returns 0 for success or an error on failure.
  Called at driver resume.
	 Giving time for user to close FD, and for processes that are inside
	  hl_device_open to finish
 Processes have been already killed 
 Wait a small period after process kill 
	 This section must be protected because we are dereferencing
	  pointers that are freed if the process exits
	
	  We killed the open users, but that doesn't mean they are closed.
	  It could be that they are running a long cleanup phase in the driver
	  e.g. MMU unmappings, or running other long teardown flow even before
	  our cleanup.
	  Therefore we need to wait again to make sure they are closed before
	  continuing with the reset.
 All processes exited successfully 
 Give up waiting for processes to exit 
	
	  'reset cause' is being updated here, because getting here
	  means that it's the 1st time and the last time we're here
	  ('in_reset' makes sure of it). This makes sure that
	  'reset_cause' will continue holding its 1st recorded reason!
	
	  If reset cause is same twice, then reset_trigger_repeated
	  is set and if this reset is due to a fatal FW error
	  device is set to an unstable state.
	 If reset is due to heartbeat, device CPU is no responsive in
	  which case no point sending PCI disable message to it.
	 
	  If FW is performing the reset, no need to send it a message to disable
	  PCI access
		 Disable PCI access from device FW so he won't send
		  us additional interrupts. We disable MSIMSI-X at
		  the halt_engines function and we can't have the FW
		  sending us interrupts after that. We need to disable
		  the access here because if the device is marked
		  disable, the message won't be send. Also, in case
		  of heartbeat, the device CPU is marked as disable
		  so this message won't be sent
  hl_device_reset - reset the device
  @hdev: pointer to habanalabs device structure
  @flags: reset flags.
  Block future CS and wait for pending CS to be enqueued
  Call ASIC HW fini
  Flush all completions
  Re-initialize all internal data structures
  Call ASIC HW init, late_init
  Test queues
  Enable device
  Returns 0 for success or an error on failure.
 Re-entry of reset thread 
	
	  Prevent concurrency in this function - only one reset should be
	  done at any given time. Only need to perform this if we didn't
	  get from the dedicated hard reset thread
 Block future CSVMJOB completion operations 
 This also blocks future CSVMJOB completion operations 
		
		  Because the reset function can't run from heartbeat work,
		  we need to call the reset function from a dedicated work.
		 Kill processes here after CS rollback. This is because the
		  process can't really exit until all its CSs are done, which
		  is what we do in cs rollback
 signal reset thread to reschedule 
		 Flush the Event queue workers to make sure no other thread is
		  reading or writing to registers during the reset
 Reset the HW. It will be in idle state after this returns 
 Release kernel context 
 Re-initialize PI,CI to 0 in all queues (hw queue, cq) 
 Make sure the context switch phase will run again 
 Finished tear-down, starting to re-initialize 
			 if there 2 back to back resets from FW,
			  ensure driver puts the driver in a unusable state
 Allocate the kernel context 
	 Device is now enabled as part of the initialization requires
	  communication with the device firmware to get information that
	  is required for the initialization itself
 If device is not idle fail the reset process 
 Check that the communication with the device is working 
		 After reset is done, we are ready to receive events from
		  the FW. We can't do it before because we will ignore events
		  and if those events are fatal, we won't know about it and
		  the device will be operational although it shouldn't be
  hl_device_init - main initialization function for habanalabs device
  @hdev: pointer to habanalabs device structure
  Allocate an id for the device, do early initialization and then call the
  ASIC specific initialization functions. Finally, create the cdev and the
  Linux device to expose it to the user
 Initialize cdev and device structures 
 Initialize cdev and device structures for control device 
 Initialize ASIC function pointers and perform early init 
	
	  Start calling ASIC initialization. First SW then HW and finally
	  late init
 initialize completion structure for multi CS wait 
	
	  Initialize the HW queues. Must be done before hw_init, because
	  there the addresses of the kernel queue are being written to the
	  registers of the device
	
	  Initialize the completion queues. Must be done before hw_init,
	  because there the addresses of the completion queues are being
	  passed as arguments to request_irq
	
	  Initialize the event queue. Must be done before hw_init,
	  because there the address of the event queue is being
	  passed as argument to request_irq
 MMU SW must be initialized before kernel context is created 
 Allocate the kernel context 
	 debugfs nodes are created in hl_ctx_init so it must be called after
	  hl_debugfs_add_device.
	
	  From this point, override rc (=0) in case of an error to allow
	  debugging (by adding char devices and create sysfs nodes as part of
	  the error flow).
	 Device is now enabled as part of the initialization requires
	  communication with the device firmware to get information that
	  is required for the initialization itself
 Check that the communication with the device is working 
	
	  Expose devices and sysfs nodes to user.
	  From here there is no need to add char devices and create sysfs nodes
	  in case of an error.
	 Need to call this again because the max power might change,
	  depending on card type for certain ASICs
	
	  hl_hwmon_init() must be called after device_late_init(), because only
	  there we get the information from the device about which
	  hwmon-related sensors the device supports.
	  Furthermore, it must be done after adding the device to the system.
	 After initialization is done, we are ready to receive events from
	  the FW. We can't do it before because we will ignore events and if
	  those events are fatal, we won't know about it and the device will
	  be operational although it shouldn't be
  hl_device_fini - main tear-down function for habanalabs device
  @hdev: pointer to habanalabs device structure
  Destroy the device, call ASIC fini functions and release the id
	
	  This function is competing with the reset function, so try to
	  take the reset atomic and if we are already in middle of reset,
	  wait until reset function is finished. Reset function is designed
	  to always finish. However, in Gaudi, because of all the network
	  ports, the hard reset could take between 10-30 seconds
	 Disable PCI access from device FW so it won't send us additional
	  interrupts. We disable MSIMSI-X at the halt_engines function and we
	  can't have the FW sending us interrupts after that. We need to
	  disable the access here because if the device is marked disable, the
	  message won't be send. Also, in case of heartbeat, the device CPU is
	  marked as disable so this message won't be sent
 Mark device as disabled 
	 Kill processes here after CS rollback. This is because the process
	  can't really exit until all its CSs are done, which is what we
	  do in cs rollback
 Reset the HW. It will be in idle state after this returns 
 Release kernel context 
 Call ASIC SW finalize function 
 Hide devices and sysfs nodes from user 
  MMIO register access helper functions.
  hl_rreg - Read an MMIO register
  @hdev: pointer to habanalabs device structure
  @reg: MMIO register offset (in bytes)
  Returns the value of the MMIO register we are asked to read
  hl_wreg - Write to an MMIO register
  @hdev: pointer to habanalabs device structure
  @reg: MMIO register offset (in bytes)
  @val: 32-bit value
  Writes the 32-bit value into the MMIO register
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
  enum hl_cs_wait_status - cs wait status
  @CS_WAIT_STATUS_BUSY: cs was not completed yet
  @CS_WAIT_STATUS_COMPLETED: cs completed
  @CS_WAIT_STATUS_GONE: cs completed but fence is already gone
  hl_gen_sob_mask() - Generates a sob mask to be used in a monitor arm packet
  @sob_base: sob base id
  @sob_mask: sob user mask, each bit represents a sob offset from sob base
  @mask: generated mask
  Return: 0 if given parameters are valid
 find msb in order to verify sob range is valid 
	 In case this is a staged CS, only the last CS in sequence should
	  get a completion, any non staged CS will always get a completion
	 In case this is a staged CS, only the first CS in sequence should
	  get a timeout, any non staged CS will always get a timeout
	
	  Patched CB is created for external queues jobs, and for HW queues
	  jobs if the user CB was allocated by driver and MMU is disabled.
  cs_parser - parse the user command submission
  @hpriv	: pointer to the private data of the fd
  @job        : pointer to the job that holds the command submission info
  The function parses the command submission of the user. It calls the
  ASIC specific parser, which returns a list of memory blocks to send
  to the device as different command buffers
		
		  Whether the parsing worked or not, we don't need the
		  original CB anymore because it was already parsed and
		  won't be accessed again for this CS
		
		  We might arrive here from rollback and patched CB wasn't
		  created, so we need to check it's not NULL
	 For HW queue jobs, if a user CB was allocated by driver and MMU is
	  enabled, the user CB isn't released in cs_parser() and thus should be
	  released here.
	  This is also true for INT queues jobs which were allocated by driver
	
	  This is the only place where there can be multiple threads
	  modifying the list at the same time
	 We decrement reference only for a CS that gets completion
	  because the reference was incremented only for this kind of CS
	  right before it was scheduled.
	 
	  In staged submission, only the last CS marked as 'staged_last'
	  gets completion, hence its release function will be called from here.
	  As for all the rest CS's in the staged submission which do not get
	  completion, their CS reference will be decremented by the
	  'staged_last' CS during the CS release flow.
	  All relevant PQ CI counters will be incremented during the CS release
	  flow by calling 'hl_hw_queue_update_ci'.
  hl_staged_cs_find_first - locate the first CS in this staged submission
  @hdev: pointer to device structure
  @cs_seq: staged submission sequence number
  @note: This function must be called under 'hdev->cs_mirror_lock'
  Find and return a CS pointer with the given sequence
  is_staged_cs_last_exists - returns true if the last CS in sequence exists
  @hdev: pointer to device structure
  @cs: staged submission member
  staged_cs_get - get CS reference if this CS is a part of a staged CS
  @hdev: pointer to device structure
  @cs: current CS
  @cs_seq: staged submission sequence number
  Increment CS reference for every CS in this staged submission except for
  the CS which get completion.
	 Only the last CS in this staged submission will get a completion.
	  We must increment the reference for all other CS's in this
	  staged submission.
	  Once we get a completion we will release the whole staged submission.
  staged_cs_put - put a CS in case it is part of staged submission
  @hdev: pointer to device structure
  @cs: CS to put
  This function decrements a CS reference (for a non completion CS)
	 We release all CS's in a staged submission except the last
	  CS which we have never incremented its reference.
	 We need to handle tdr only once for the complete staged submission.
	  Hence, we choose the CS that reaches this function first which is
	  the CS marked as 'staged_last'.
	  In case single staged cs was submitted which has both first and last
	  indications, then "cs_find_first" below will return NULL, since we
	  removed the cs node from the list before getting here,
	  in such cases just continue with the cs to cancel it's TDR work.
	 Don't cancel TDR in case this CS was timedout because we might be
	  running from the TDR context
 queue TDR for next CS 
  force_complete_multi_cs - complete all contexts that wait on multi-CS
  @hdev: pointer to habanalabs device structure
		 when calling force complete no context should be waiting on
		  multi-cS.
		  We are calling the function as a protection for such case
		  to free any pending context and print error message
  complete_multi_cs - complete all waiting entities on multi-CS
  @hdev: pointer to habanalabs device structure
  @cs: CS structure
  The function signals a waiting entity that has an overlapping stream masters
  with the completed CS.
  For example:
  - a completed CS worked on stream master QID 4, multi CS completion
    is actively waiting on stream master QIDs 3, 5. don't send signal as no
    common stream master QID
  - a completed CS worked on stream master QID 4, multi CS completion
    is actively waiting on stream master QIDs 3, 4. send signal as stream
    master QID 4 is common
 in case of multi CS check for completion only for the first CS 
		
		  complete if:
		  1. still waiting for completion
		  2. the completed CS has at least one overlapping stream
		     master with the stream masters in the completion
 extract the timestamp only of first completed CS 
			
			  Setting mcs_handling_done inside the lock ensures
			  at least one fence have mcs_handling_done set to
			  true before wait for mcs finish. This ensures at
			  least one CS will be set as completed when polling
			  mcs fences.
 In case CS completed without mcs completion initialized 
	 Skip this handler if the cs wasn't submitted, to avoid putting
	  the hw_sob twice, since this case already handled at this point,
	  also skip if the hw_sob pointer wasn't set.
	
	  we get refcount upon reservation of signals or signalwait cs for the
	  hw_sob object, and need to put it when the first staged cs
	  (which cotains the encaps signals) or cs signalwait is completed.
	
	  Although if we reached here it means that all external jobs have
	  finished, because each one of them took refcnt to CS, we still
	  need to go over the internal jobs and complete them. Otherwise, we
	  will have leaked memory and what's worse, the CS object (and
	  potentially the CTX object) could be released, while the JOB
	  still holds a pointer to them (but no reference).
		
		  In case the wait for signal CS was submitted, the fence put
		  occurs in init_signal_wait_cs() or collective_wait_init_cs()
		  right before hanging on the PQ.
 Need to update CI for all queue jobs that does not get completion 
 remove CS from CS mirror list 
		 the completion CS decrements reference for the entire
		  staged submission
		 A staged CS will be a member in the list only after it
		  was submitted. We used 'cs_mirror_lock' when inserting
		  it to list so we will use it again when removing it
		 decrement refcount to handle when first staged cs
		  with encaps signals is completed.
	 Must be called before hl_ctx_put because inside we use ctx to get
	  the device
	 We need to mark an error for not submitted because in that case
	  the hl fence release flow is different. Mainly, we don't need
	  to handle hw_sob for signalwait
 Mark the CS is timed out so we won't try to cancel its TDR 
 increment refcnt for context 
		 If the following statement is true, it means we have reached
		  a point in which only part of the staged submission was
		  submitted and we don't have enough room in the 'cs_pending'
		  array for the rest of the submission.
		  This causes a deadlock because this CS will never be
		  completed as it depends on future CS's for completion.
 init hl_fence 
	 flush all completions before iterating over the CS mirror list in
	  order to avoid a race with the release functions
 Make sure we don't have leftovers in the CS mirror list 
	 We iterate through the user interrupt requests and waking up all
	  user threads waiting for interrupt completion. We iterate the
	  list under a lock, this is why all user threads, once awake,
	  will wait on the same lock and will release the waiting object upon
	  unlock.
 job is no longer needed 
	 This must be checked here to prevent out-of-bounds access to
	  hw_queues_props array
	 When hw queue type isn't QUEUE_TYPE_HW,
	  USER_ALLOC_CB flag shall be referred as "don't care".
 Staged CS sequence is the first CS sequence 
		 User sequence will be validated in 'hl_hw_queue_schedule_cs'
		  under the cs_mirror_lock
 Increment CS reference if needed 
	 If this is a staged submission we must return the staged sequence
	  rather than the internal CS sequence
 Validate ALL the CS chunks before submitting the CS 
			
			  store which stream are being used for externalHW
			  queues of this CS
		
		  Increment CS reference. When CS reference is 0, CS is
		  done and can be signaled to user and free all its resources
		  Only increment for JOB on external or HW queues, because
		  only for those JOBs we get completion
	 We allow a CS with any queue type combination as long as it does
	  not get a completion
	
	  store the (externalHW queues) streams used by the CS in the
	  fence object for multi-CS completion
 The path below is both for good and erroneous exits 
 We finished with the CS in this function, so put the ref 
				
				  If we timedout, or if the device is not IDLE
				  while we want to do context-switch (-EBUSY),
				  we need to soft-reset because QMAN is
				  probably stuck. However, we can't call to
				  reset here directly because of deadlock, so
				  need to do it at the very end of this
				  function
 Need to wait for restore completion before execution phase 
  hl_cs_signal_sob_wraparound_handler: handle SOB value wrapaound case.
  if the SOB value reaches the max value move to the other SOB reserved
  to the queue.
  @hdev: pointer to device structure
  @q_idx: stream queue index
  @hw_sob: the HW SOB used in this signal CS.
  @count: signals count
  @encaps_sig: tells whether it's reservation for encaps signals or not.
  Note that this function must be called while hw_queues_lock is taken.
 check for wraparound 
		
		  Decrement as we reached the max value.
		  The release function won't be called here as we've
		  just incremented the refcount right before calling this
		  function.
		
		  check the other sob value, if it still in use then fail
		  otherwise make the switch
		
		  next_sob_val always points to the next available signal
		  in the sob, so in encaps signals it will be the next one
		  after reserving the required amount.
 only two SOBs are currently in use 
		
		  check if other_sob needs reset, then do it before using it
		  for the reservation or the next signal cs.
		  we do it here, and for both encaps and regular signal cs
		  cases in order to avoid possible races of two kref_put
		  of the sob which can occur at the same time if we move the
		  sob reset(kref_put) to cs_do_release function.
		  in addition, if we have combination of cs signal and
		  encaps, and at the point we need to reset the sob there was
		  no more reservations and only signal cs keep coming,
		  in such case we need signal_cs to put the refcount and
		  reset the sob.
 set reset indication for the sob 
 currently only one signal seq is supported 
 currently it is guaranteed to have only one signal seq 
	
	  No need in parsing, user CB is the patched CB.
	  We call hl_cb_destroy() out of two reasons - we don't need the CB in
	  the CB idr anymore and to decrement its refcount as it was
	  incremented inside hl_cb_kernel_create().
 increment refcount as for external queues we get completion 
	
	  Increment the SOB value by count by user request
	  to reserve those signals
	  check if the signals amount to reserve is not exceeding the max sob
	  value, if yes then switch sob.
	 set the hw_sob to the handle after calling the sob wraparound handler
	  since sob could have changed.
	 store the current sob value for unreserve validity check, and
	  signal offset support
		 Check if sob_val got out of sync due to other
		  signal submission requests which were handled
		  between the reserve-unreserve calls or SOB switch
		  upon reaching SOB max value.
		
		  Decrement the SOB value by count by user request
		  to unreserve those signals
 Release the id and free allocated memory of the handle 
 currently it is guaranteed to have only one chunk 
			 check if cs sequence has encapsulated
			  signals handle
					 get refcount to protect removing
					  this handle from idr, needed when
					  multiple wait cs are used with offset
					  to wait on reserved encaps signals.
 treat as signal CS already finished 
 validate also the signal offset value 
 signal CS already finished 
 signal CS already finished 
	
	  Save the signal CS fence for later initialization right before
	  hanging the wait CS on the queue.
	  for encaps signals case, we save the cs sequence and handle pointer
	  for later initialization.
		 store the handle pointer, so we don't have to
		  look for it again, later on the flow
		  when we need to set SOB info in hw_queue.
		 In case wait cs failed here, it means the signal cs
		  already completed. we want to free all it's related objects
		  but we don't want to fail the ioctl.
 The path below is both for good and erroneous exits 
 We finished with the CS in this function, so put the ref 
 In case this is a staged CS, user should supply the CS sequence 
  hl_cs_poll_fences - iterate CS fences to check for CS completion
  @mcs_data: multi-CS internal data
  @return 0 on success, otherwise non 0 error code
  The function iterates on all CS sequence in the list and set bit in
  completion_bitmap for each completed CS.
  while iterating, the function can extracts the stream map to be later
  used by the waiting function.
  this function shall be called after taking context ref
 get all fences under the same lock 
	
	  set to maximum time to verify timestamp is valid: if at the end
	  this value is maintained- no timestamp was updated
		
		  function won't sleep as it is called with timeout 0 (i.e.
		  poll the fence)
 CS did not finished, keep waiting on its QID
			
			  Using mcs_handling_done to avoid possibility of mcs_data
			  returns to user indicating CS completed before it finished
			  all of its mcs handling, to avoid race the next time the
			  user waits for mcs.
			
			  For all completed CSs we take the earliest timestamp.
			  For this we have to validate that the timestamp is
			  earliest of all timestamps so far.
			
			  It is possible to get an old sequence numbers from user
			  which related to already completed CSs and their fences
			  already gone. In this case, CS set as completed but
			  no need to consider its QID for mcs completion.
  hl_wait_multi_cs_completion_init - init completion structure
  @hdev: pointer to habanalabs device structure
  @stream_master_bitmap: stream master QIDs map, set bit indicates stream
                         master QID to wait on
  @return valid completion struct pointer on success, otherwise error pointer
  up to MULTI_CS_MAX_USER_CTX calls can be done concurrently to the driver.
  the function gets the first available completion (by marking it "used")
  and initialize its values.
 find free multi_cs completion structure 
  hl_wait_multi_cs_completion_fini - return completion structure and set as
                                     unused
  @mcs_compl: pointer to the completion structure
	
	  free completion structure, do it under lock to be in-sync with the
	  thread that signals completion
  hl_wait_multi_cs_completion - wait for first CS to complete
  @mcs_data: multi-CS internal data
  @return 0 on success, otherwise non 0 error code
 update timestamp 
  hl_multi_cs_completion_init - init array of multi-CS completion structures
  @hdev: pointer to habanalabs device structure
  hl_multi_cs_wait_ioctl - implementation of the multi-CS wait ioctl
  @hpriv: pointer to the private data of the fd
  @data: pointer to multi-CS wait ioctl inout args
 allocate memory for sequence array 
 copy CS sequence array from user 
 allocate array for the fences 
 initialize the multi-CS internal data 
 poll all CS fences, extract timestamp 
	
	  skip wait for CS completion when one of the below is true:
	  - an error on the poll function
	  - one or more CS in the list completed
	  - the user called ioctl with timeout 0
 wait (with timeout) for the first CS to be completed 
		
		  poll fences once again to update the CS map.
		  no timestamp should be updated this time.
		
		  if hl_wait_multi_cs_completion returned before timeout (i.e.
		  it got a completion) we expect to see at least one CS
		  completed after the poll function.
 update output args 
 if timestamp not 0- it's valid 
 update if some CS was gone 
	 Add pending user interrupt to relevant list for the interrupt
	  handler to monitor
	 We check for completion value as interrupt could have been received
	  before we added the node to the wait list
 There was no interrupt, we assume the completion is now. 
 Wait for interrupt handler to signal completion 
	 If timeout did not expire we need to perform the comparison.
	  If comparison fails, keep waiting until timeout expires
		 reinit_completion must be called before we check for user
		  completion value, otherwise, if interrupt is received after
		  the comparison and before the next wait_for_completion,
		  we will reach timeout and fail
	 If the device is not operational, no point in waiting for any command submission or
	  user interrupt
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
  struct hl_eqe_work - This structure is used to schedule work of EQ
                       entry and cpucp_reset event
  @eq_work:          workqueue object to run when EQ entry is received
  @hdev:             pointer to device structure
  @eq_entry:         copy of the EQ entry
  hl_cq_inc_ptr - increment ci or pi of cq
  @ptr: the current ci or pi value of the completion queue
  Increment ptr by 1. If it reaches the number of completion queue
  entries, set it to 0
  hl_eq_inc_ptr - increment ci of eq
  @ptr: the current ci value of the event queue
  Increment ptr by 1. If it reaches the number of event queue
  entries, set it to 0
  hl_irq_handler_cq - irq handler for completion queue
  @irq: irq number
  @arg: pointer to completion queue structure
		 Make sure we read CQ entry contents after we've
		  checked the ownership bit.
 Clear CQ entry ready bit 
 Increment free slots 
  hl_irq_handler_user_cq - irq handler for user completion queues
  @irq: irq number
  @arg: pointer to user interrupt structure
 Handle user cq interrupts registered on all interrupts 
 Handle user cq interrupts registered on this specific interrupt 
  hl_irq_handler_default - default irq handler
  @irq: irq number
  @arg: pointer to user interrupt structure
  hl_irq_handler_eq - irq handler for event queue
  @irq: irq number
  @arg: pointer to event queue structure
		
		  Make sure we read EQ entry contents after we've
		  checked the ownership bit.
 Clear EQ entry ready bit 
  hl_cq_init - main initialization function for an cq object
  @hdev: pointer to device structure
  @q: pointer to cq structure
  @hw_queue_id: The HW queue ID this completion queue belongs to
  Allocate dma-able memory for the completion queue and initialize fields
  Returns 0 on success
  hl_cq_fini - destroy completion queue
  @hdev: pointer to device structure
  @q: pointer to cq structure
  Free the completion queue memory
	
	  It's not enough to just reset the PICI because the HW may have
	  written valid completion entries before it was halted and therefore
	  we need to clean the actual queues so we won't process old entries
	  when the device is operational again
  hl_eq_init - main initialization function for an event queue object
  @hdev: pointer to device structure
  @q: pointer to eq structure
  Allocate dma-able memory for the event queue and initialize fields
  Returns 0 on success
  hl_eq_fini - destroy event queue
  @hdev: pointer to device structure
  @q: pointer to eq structure
  Free the event queue memory
	
	  It's not enough to just reset the PICI because the HW may have
	  written valid completion entries before it was halted and therefore
	  we need to clean the actual queues so we won't process old entries
	  when the device is operational again
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2021 HabanaLabs, Ltd.
  All Rights Reserved.
 use small pages for supporting non-pow2 (32M40M48M) DRAM phys page sizes 
  The va ranges in context object contain a list with the available chunks of
  device virtual memory.
  There is one range for host allocations and one for DRAM allocations.
  On initialization each range contains one chunk of all of its available
  virtual range which is a half of the total device virtual range.
  On each mapping of physical pages, a suitable virtual range chunk (with a
  minimum size) is selected from the list. If the chunk size equals the
  requested size, the chunk is returned. Otherwise, the chunk is split into
  two chunks - one to return as result and a remainder to stay in the list.
  On each Unmapping of a virtual address, the relevant virtual chunk is
  returned to the list. The chunk is added to the list and if its edges match
  the edges of the adjacent chunks (means a contiguous chunk can be created),
  the chunks are merged.
  On finish, the list is checked to have only one chunk of all the relevant
  virtual range (which is a half of the device total virtual range).
  If not (means not all mappings were unmapped), a warning is printed.
  alloc_device_memory() - allocate device memory.
  @ctx: pointer to the context structure.
  @args: host parameters containing the requested size.
  @ret_handle: result handle.
  This function does the following:
  - Allocate the requested size rounded up to 'dram_page_size' pages.
  - Return unique handle for later mapunmapfree.
  dma_map_host_va() - DMA mapping of the given host virtual address.
  @hdev: habanalabs device structure.
  @addr: the host virtual address of the memory area.
  @size: the size of the memory area.
  @p_userptr: pointer to result userptr structure.
  This function does the following:
  - Allocate userptr structure.
  - Pin the given host memory using the userptr structure.
  - Perform DMA mapping to have the DMA addresses of the pages.
  dma_unmap_host_va() - DMA unmapping of the given host virtual address.
  @hdev: habanalabs device structure.
  @userptr: userptr to free.
  This function does the following:
  - Unpins the physical pages.
  - Frees the userptr structure.
  dram_pg_pool_do_release() - free DRAM pages pool
  @ref: pointer to reference object.
  This function does the following:
  - Frees the idr structure of physical pages handles.
  - Frees the generic pool of DRAM physical pages.
	
	  free the idr here as only here we know for sure that there are no
	  allocated physical pages and hence there are no handles in use
  free_phys_pg_pack() - free physical page pack.
  @hdev: habanalabs device structure.
  @phys_pg_pack: physical page pack to free.
  This function does the following:
  - For DRAM memory only
    - iterate over the pack, scrub and free each physical block structure by
      returning it to the general pool.
      In case of error during scrubbing, initiate hard reset.
      Once hard reset is triggered, scrubbing is bypassed while freeing the
      memory continues.
  - Free the hl_vm_phys_pg_pack structure.
  free_device_memory() - free device memory.
  @ctx: pointer to the context structure.
  @args: host parameters containing the requested size.
  This function does the following:
  - Free the device memory related to the given handle.
		
		  must remove from idr before the freeing of the physical
		  pages as the refcount of the pool is also the trigger of the
		  idr destroy
  clear_va_list_locked() - free virtual addresses list.
  @hdev: habanalabs device structure.
  @va_list: list of virtual addresses to free.
  This function does the following:
  - Iterate over the list and free each virtual addresses block.
  This function should be called only when va_list lock is taken.
  print_va_list_locked() - print virtual addresses list.
  @hdev: habanalabs device structure.
  @va_list: list of virtual addresses to print.
  This function does the following:
  - Iterate over the list and print each virtual addresses block.
  This function should be called only when va_list lock is taken.
  merge_va_blocks_locked() - merge a virtual block if possible.
  @hdev: pointer to the habanalabs device structure.
  @va_list: pointer to the virtual addresses block list.
  @va_block: virtual block to merge with adjacent blocks.
  This function does the following:
  - Merge the given blocks with the adjacent blocks if their virtual ranges
    create a contiguous virtual range.
  This Function should be called only when va_list lock is taken.
  add_va_block_locked() - add a virtual block to the virtual addresses list.
  @hdev: pointer to the habanalabs device structure.
  @va_list: pointer to the virtual addresses block list.
  @start: start virtual address.
  @end: end virtual address.
  This function does the following:
  - Add the given block to the virtual blocks list and merge with other blocks
    if a contiguous virtual block can be created.
  This Function should be called only when va_list lock is taken.
 TODO: remove upon matureness 
  add_va_block() - wrapper for add_va_block_locked.
  @hdev: pointer to the habanalabs device structure.
  @va_list: pointer to the virtual addresses block list.
  @start: start virtual address.
  @end: end virtual address.
  This function does the following:
  - Takes the list lock and calls add_va_block_locked.
  is_hint_crossing_range() - check if hint address crossing specified reserved
  range.
  get_va_block() - get a virtual block for the given size and alignment.
  @hdev: pointer to the habanalabs device structure.
  @va_range: pointer to the virtual addresses range.
  @size: requested block size.
  @hint_addr: hint for requested address by the user.
  @va_block_align: required alignment of the virtual block start address.
  @range_type: va range type (host, dram)
  @flags: additional memory flags, currently only uses HL_MEM_FORCE_HINT
  This function does the following:
  - Iterate on the virtual block list to find a suitable virtual block for the
    given size, hint address and alignment.
  - Reserve the requested block and update the list.
  - Return the start address of the virtual block.
		
		  with non-power-of-2 range we work only with page granularity
		  and the start address is page aligned,
		  so no need for alignment checking.
 Check if we need to ignore hint address 
 Hint must be respected, so here we just fail 
 Calc the first possible aligned addr 
		
		  In case hint address is 0, and arc_hints_range_reservation
		  property enabled, then avoid allocating va blocks from the
		  range reserved for hint addresses
 Pick the minimal length block which has the required size 
		 Hint address must be respected. If we are here - this means
		  we could not respect it.
	
	  Check if there is some leftover range due to reserving the new
	  va block, then return it to the main virtual addresses list.
  hl_reserve_va_block() - reserve a virtual block of a given size.
  @hdev: pointer to the habanalabs device structure.
  @ctx: current context
  @type: virtual addresses range type.
  @size: requested block size.
  @alignment: required alignment in bytes of the virtual block start address,
              0 means no alignment.
  This function does the following:
  - Iterate on the virtual block list to find a suitable virtual block for the
    given size and alignment.
  - Reserve the requested block and update the list.
  - Return the start address of the virtual block.
  hl_get_va_range_type() - get va_range type for the given address and size.
  @address: the start address of the area we want to validate.
  @size: the size in bytes of the area we want to validate.
  @type: returned va_range type.
  Return: true if the area is inside a valid range, false otherwise.
  hl_unreserve_va_block() - wrapper for add_va_block to unreserve a va block.
  @hdev: pointer to the habanalabs device structure
  @ctx: pointer to the context structure.
  @start: start virtual address.
  @end: end virtual address.
  This function does the following:
  - Takes the list lock and calls add_va_block_locked.
  init_phys_pg_pack_from_userptr() - initialize physical page pack from host
                                     memory
  @ctx: pointer to the context structure.
  @userptr: userptr to initialize from.
  @pphys_pg_pack: result pointer.
  @force_regular_page: tell the function to ignore huge page optimization,
                       even if possible. Needed for cases where the device VA
                       is allocated before we know the composition of the
                       physical pages
  This function does the following:
  - Pin the physical pages related to the given virtual block.
  - Create a physical page pack from the physical pages related to the given
    virtual block.
	 Only if all dma_addrs are aligned to 2MB and their
	  sizes is at least 2MB, we can use huge page mapping.
	  We limit the 2MB optimization to this condition,
	  since later on we acquire the related VA range as one
	  consecutive block.
 align down to physical page size and save the offset 
  map_phys_pg_pack() - maps the physical page pack..
  @ctx: pointer to the context structure.
  @vaddr: start address of the virtual area to map from.
  @phys_pg_pack: the pack of physical pages to map to.
  This function does the following:
  - Maps each chunk of virtual memory to matching physical chunk.
  - Stores number of successful mappings in the given argument.
  - Returns 0 on success, error code otherwise.
		
		  unmapping on Palladium can be really long, so avoid a CPU
		  soft lockup bug by sleeping a little between unmapping pages
		 
		  In addition, on host num of pages could be huge,
		  because page size could be 4KB, so when unmapping host
		  pages sleep every 32K pages to avoid soft lockup
  unmap_phys_pg_pack() - unmaps the physical page pack.
  @ctx: pointer to the context structure.
  @vaddr: start address of the virtual area to unmap.
  @phys_pg_pack: the pack of physical pages to unmap.
		
		  unmapping on Palladium can be really long, so avoid a CPU
		  soft lockup bug by sleeping a little between unmapping pages
		 
		  In addition, on host num of pages could be huge,
		  because page size could be 4KB, so when unmapping host
		  pages sleep every 32K pages to avoid soft lockup
  map_device_va() - map the given memory.
  @ctx: pointer to the context structure.
  @args: host parameters with handlehost virtual address.
  @device_addr: pointer to result device virtual address.
  This function does the following:
  - If given a physical device memory handle, map to a device virtual block
    and return the start address of this block.
  - If given a host virtual address and size, find the related physical pages,
    map a device virtual block to this pages and return the start address of
    this block.
 Assume failure 
 get required alignment 
			
			  huge page alignment may be needed in case of regular
			  page mapping, depending on the host VA alignment
			
			  huge page alignment is needed in case of huge page
			  mapping
 increment now to avoid freeing device memory while mapping 
 DRAM VA alignment is the same as the MMU page size 
	
	  relevant for mapping device physical memory only, as host memory is
	  implicitly shared
 Fail if hint must be respected but it can't be 
  unmap_device_va() - unmap the given device virtual address.
  @ctx: pointer to the context structure.
  @args: host parameters with device virtual address to unmap.
  @ctx_free: true if in context free flow, false otherwise.
  This function does the following:
  - unmap the physical pages related to the given virtual address.
  - return the device virtual block to the virtual block list.
 protect from double entrance 
	
	  During context free this function is called in a loop to clean all
	  the context mappings. Hence the cache invalidation can be called once
	  at the loop end rather than for each iteration
	
	  If the context is closing we don't need to check for the MMU cache
	  invalidation return code and update the VA free list as in this flow
	  we invalidate the MMU cache outside of this unmap function and the VA
	  free list will be freed anyway.
  hl_hw_block_mmap() - mmap a hw block to user.
  @hpriv: pointer to the private data of the fd
  @vma: pointer to vm_area_struct of the process
  Driver increments context reference for every HW block mapped in order
  to prevent user from closing FD without unmapping first
	 We use the page offset to hold the block id and thus we need to clear
	  it before doing the mmap itself
 Driver only allows mapping of a complete HW block 
	 We would like to align the max segment size to PAGE_SIZE, so the
	  SGL will contain aligned addresses that can be easily mapped to
	  an MMU
	 If the size of each page is larger than the dma max segment size,
	  then we can't combine pages and the number of entries in the SGL
	  will just be the
	  <number of pages>  <chunks of max segment size in each page>
 Get number of non-contiguous chunks 
		 Need to split each page into the number of chunks of
		  dma_max_seg_size
 Merge pages and put them into the scatterlist 
	 Because we are not going to include a CPU list we want to have some
	  chance that other users will detect this by setting the orig_nents
	  to 0 and using only nents (length of DMA list) when going over the
	  sgl
	 The memory behind the dma-buf has always resided on the device itself, i.e. it lives
	  only in the 'device' domain (after all, it maps a PCI bar address which points to the
	  device memory).
	 
	  Therefore, it was never in the 'CPU' domain and hence, there is no need to perform
	  a sync of the memory to the CPU's cache, as it never resided inside that cache.
 Need to restore orig_nents because sg_free_table use that field 
  export_dmabuf_from_addr() - export a dma-buf object for the given memory
                              address and size.
  @ctx: pointer to the context structure.
  @device_addr:  device memory physical address.
  @size: size of device memory.
  @flags: DMA-BUF fileFD flags.
  @dmabuf_fd: pointer to result FD that represents the dma-buf object.
  Create and export a dma-buf object for an existing memory allocation inside
  the device memory, and return a FD which is associated with the dma-buf
  object.
  Return: 0 on success, non-zero for failure.
  export_dmabuf_from_handle() - export a dma-buf object for the given memory
                                handle.
  @ctx: pointer to the context structure.
  @handle: device memory allocation handle.
  @flags: DMA-BUF fileFD flags.
  @dmabuf_fd: pointer to result FD that represents the dma-buf object.
  Create and export a dma-buf object for an existing memory allocation inside
  the device memory, and return a FD which is associated with the dma-buf
  object.
  Return: 0 on success, non-zero for failure.
 increment now to avoid freeing device memory while exporting 
		 Force contiguous as there are no real MMU
		  translations to overcome physical memory gaps
		 If DRAM does not support virtual memory the driver won't
		  handle the allocationfreeing of that memory. However, for
		  system administrationmonitoring purposes, the driver will
		  keep track of the amount of DRAM memory that is allocated
		  and freed by the user. Because this code totally relies on
		  the user's input, the driver can't ensure the validity
		  of this accounting.
		 If DRAM does not support virtual memory the driver won't
		  handle the allocationfreeing of that memory. However, for
		  system administrationmonitoring purposes, the driver will
		  keep track of the amount of DRAM memory that is allocated
		  and freed by the user. Because this code totally relies on
		  the user's input, the driver can't ensure the validity
		  of this accounting.
  hl_pin_host_memory() - pins a chunk of host memory.
  @hdev: pointer to the habanalabs device structure.
  @addr: the host virtual address of the memory area.
  @size: the size of the memory area.
  @userptr: pointer to hl_userptr structure.
  This function does the following:
  - Pins the physical pages.
  - Create an SG list from those pages.
	
	  If the combination of the address and size requested for this memory
	  region causes an integer overflow, return error.
  hl_unpin_host_memory - unpins a chunk of host memory.
  @hdev: pointer to the habanalabs device structure
  @userptr: pointer to hl_userptr structure
  This function does the following:
  - Unpins the physical pages related to the host memory
  - Free the SG list
  hl_userptr_delete_list() - clear userptr list.
  @hdev: pointer to the habanalabs device structure.
  @userptr_list: pointer to the list to clear.
  This function does the following:
  - Iterates over the list and unpins the host memory and frees the userptr
    structure.
  hl_userptr_is_pinned() - returns whether the given userptr is pinned.
  @hdev: pointer to the habanalabs device structure.
  @userptr_list: pointer to the list to clear.
  @userptr: pointer to userptr to check.
  This function does the following:
  - Iterates over the list and checks if the given userptr is in it, means is
    pinned. If so, returns true, otherwise returns false.
  va_range_init() - initialize virtual addresses range.
  @hdev: pointer to the habanalabs device structure.
  @va_range: pointer to the range to initialize.
  @start: range start address.
  @end: range end address.
  This function does the following:
  - Initializes the virtual addresses list of the given range with the given
    addresses.
	
	  PAGE_SIZE alignment
	  it is the callers responsibility to align the addresses if the
	  page size is not a power of 2
  va_range_fini() - clear a virtual addresses range.
  @hdev: pointer to the habanalabs structure.
  va_range: pointer to virtual addresses rang.e
  This function does the following:
  - Frees the virtual addresses block list and its lock.
  vm_ctx_init_with_ranges() - initialize virtual memory for context.
  @ctx: pointer to the habanalabs context structure.
  @host_range_start: host virtual addresses range start.
  @host_range_end: host virtual addresses range end.
  @host_huge_range_start: host virtual addresses range start for memory
                          allocated with huge pages.
  @host_huge_range_end: host virtual addresses range end for memory allocated
                         with huge pages.
  @dram_range_start: dram virtual addresses range start.
  @dram_range_end: dram virtual addresses range end.
  This function initializes the following:
  - MMU for context.
  - Virtual address to area descriptor hashtable.
  - Virtual block list of available virtual memory.
	
	  - If MMU is enabled, init the ranges as usual.
	  - If MMU is disabled, in case of host mapping, the returned address
	    is the given one.
	    In case of DRAM mapping, the returned address is the physical
	    address of the memory related to the given handle.
  hl_vm_ctx_fini() - virtual memory teardown of context.
  @ctx: pointer to the habanalabs context structure.
  This function perform teardown the following:
  - Virtual block list of available virtual memory.
  - Virtual address to area descriptor hashtable.
  - MMU for context.
  In addition this function does the following:
  - Unmaps the existing hashtable nodes if the hashtable is not empty. The
    hashtable should be empty as no valid mappings should exist at this
    point.
  - Frees any existing physical page list from the idr which relates to the
    current context asid.
  - This function checks the virtual block list for correctness. At this point
    the list should contain one element which describes the whole virtual
    memory range of the context. Otherwise, a warning is printed.
	
	  Clearly something went wrong on hard reset so no point in printing
	  another side effect error
 invalidate the cache once after the unmapping loop 
	 In this case we need to clear the global accounting of DRAM usage
	  because the user notifies us on allocations. If the user is no more,
	  all DRAM is available
  hl_vm_init() - initialize virtual memory module.
  @hdev: pointer to the habanalabs device structure.
  This function initializes the following:
  - MMU module.
  - DRAM physical pages pool of 2MB.
  - Idr for device memory allocation handles.
  hl_vm_fini() - virtual memory module teardown.
  @hdev: pointer to the habanalabs device structure.
  This function perform teardown to the following:
  - Idr for device memory allocation handles.
  - DRAM physical pages pool of 2MB.
  - MMU module.
	
	  At this point all the contexts should be freed and hence no DRAM
	  memory should be in use. Hence the DRAM pool should be freed here.
  hl_hw_block_mem_init() - HW block memory initialization.
  @ctx: pointer to the habanalabs context structure.
  This function initializes the HW block virtual mapped addresses list and
  it's lock.
  hl_hw_block_mem_fini() - HW block memory teardown.
  @ctx: pointer to the habanalabs context structure.
  This function clears the HW block virtual mapped addresses list and destroys
  it's lock.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
 flush all writes from all cores to reach PCI 
 transform the value to physical address when writing to HW 
	
	  The value to write is actually the address of the next shadow hop +
	  flags at the 12 LSBs.
	  Hence in order to get the value to write to the physical PTE, we
	  clear the 12 LSBs and translate the shadow hop to its associated
	  physical hop, and add back the original 12 LSBs.
 do not transform the value to physical address when writing to HW 
 clear the last and present bits 
 no need to transform the value to physical address 
  put_pte - decrement the num of ptes and free the hop if possible
  @ctx: pointer to the context structure
  @hop_addr: addr of the hop
  This function returns the number of ptes left on this hop. If the number is
  0, it means the pte was freed.
	
	  Need to save the number of ptes left because free_hop might free
	  the pgt_info
 translates shadow address inside hop to a physical address 
 add hop1 and hop2 
 need only pte 0 in hops 0 and 1 
 add hop1 and hop2 
  hl_mmu_v1_init() - initialize the MMU module.
  @hdev: habanalabs device structure.
  This function does the following:
  - Create a pool of pages for pgt_infos.
  - Create a shadow table for pgt
  Return: 0 for success, non-zero for failure.
 MMU HW init will be done in device hw_init() 
  hl_mmu_fini() - release the MMU module.
  @hdev: habanalabs device structure.
  This function does the following:
  - Disable MMU in HW.
  - Free the pgt_infos pool.
  All contexts should be freed before calling this function.
 MMU HW fini was already done in device hw_fini() 
		 Make sure that if we arrive here again without init was
		  called we won't cause kernel panic. This can happen for
		  example if we fail during hard reset code at certain points
  hl_mmu_ctx_init() - initialize a context for using the MMU module.
  @ctx: pointer to the context structure to initialize.
  Initialize a mutex to protect the concurrent mapping flow, a hash to hold all
  page tables hops related to this context.
  Return: 0 on success, non-zero otherwise.
  hl_mmu_ctx_fini - disable a ctx from using the mmu module
  @ctx: pointer to the context structure
  This function does the following:
  - Free any pgts which were not freed yet
  - Free the mutex
  - Free DRAM default page mapping hops
 shifts and masks are the same in PMMU and HPMMU, use one of them 
	
	  This mapping function can map a page or a huge page. For huge page
	  there are only 3 hops rather than 4. Currently the DRAM allocation
	  uses huge pages only but user memory could have been allocated with
	  one of the two page sizes. Since this is a common code for all the
	  three cases, we need this hugs page check.
  hl_mmu_v1_swap_out - marks all mapping of the given ctx as swapped out
  @ctx: pointer to the context structure
  hl_mmu_v1_swap_in - marks all mapping of the given ctx as swapped in
  @ctx: pointer to the context structure
 huge pages use lesser hops 
 if passed over all hops then no last hop was found 
  hl_mmu_v1_prepare - prepare mmu  for working with mmu v1
  @hdev: pointer to the device structure
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2020 HabanaLabs, Ltd.
  All Rights Reserved.
  hl_mmu_init() - initialize the MMU module.
  @hdev: habanalabs device structure.
  Return: 0 for success, non-zero for failure.
  hl_mmu_fini() - release the MMU module.
  @hdev: habanalabs device structure.
  This function does the following:
  - Disable MMU in HW.
  - Free the pgt_infos pool.
  All contexts should be freed before calling this function.
  hl_mmu_ctx_init() - initialize a context for using the MMU module.
  @ctx: pointer to the context structure to initialize.
  Initialize a mutex to protect the concurrent mapping flow, a hash to hold all
  page tables hops related to this context.
  Return: 0 on success, non-zero otherwise.
  hl_mmu_ctx_fini - disable a ctx from using the mmu module
  @ctx: pointer to the context structure
  This function does the following:
  - Free any pgts which were not freed yet
  - Free the mutex
  - Free DRAM default page mapping hops
  hl_mmu_unmap_page - unmaps a virtual addr
  @ctx: pointer to the context structure
  @virt_addr: virt addr to map from
  @page_size: size of the page to unmap
  @flush_pte: whether to do a PCI flush
  This function does the following:
  - Check that the virt addr is mapped
  - Unmap the virt addr and frees pgts if possible
  - Returns 0 on success, -EINVAL if the given addr is not mapped
  Because this function changes the page tables in the device and because it
  changes the MMU hash, it must be protected by a lock.
  However, because it maps only a single page, the lock should be implemented
  in a higher level in order to protect the entire mapping of the memory area
  For optimization reasons PCI flush may be requested once after unmapping of
  large area.
	
	  The HW handles mapping of specific page sizes. Hence if the page
	  size is bigger, we break it to sub-pages and unmap them separately.
		
		  MMU page size may differ from DRAM page size.
		  In such case work with the DRAM page size and let the MMU
		  scrambling routine to handle this mismatch when
		  calculating the address to remove from the MMU page table
  hl_mmu_map_page - maps a virtual addr to physical addr
  @ctx: pointer to the context structure
  @virt_addr: virt addr to map from
  @phys_addr: phys addr to map to
  @page_size: physical page size
  @flush_pte: whether to do a PCI flush
  This function does the following:
  - Check that the virt addr is not mapped
  - Allocate pgts as necessary in order to map the virt addr to the phys
  - Returns 0 on success, -EINVAL if addr is already mapped, or -ENOMEM.
  Because this function changes the page tables in the device and because it
  changes the MMU hash, it must be protected by a lock.
  However, because it maps only a single page, the lock should be implemented
  in a higher level in order to protect the entire mapping of the memory area
  For optimization reasons PCI flush may be requested once after mapping of
  large area.
	
	  The HW handles mapping of specific page sizes. Hence if the page
	  size is bigger, we break it to sub-pages and map them separately.
		
		  MMU page size may differ from DRAM page size.
		  In such case work with the DRAM page size and let the MMU
		  scrambling routine handle this mismatch when calculating
		  the address to place in the MMU page table. (in that case
		  also make sure that the dram_page_size smaller than the
		  mmu page size)
	
	  Verify that the phys and virt addresses are aligned with the
	  MMU page size (in dram this means checking the address and MMU
	  after scrambling)
  hl_mmu_map_contiguous - implements a wrapper for hl_mmu_map_page
                          for mapping contiguous physical memory
  @ctx: pointer to the context structure
  @virt_addr: virt addr to map from
  @phys_addr: phys addr to map to
  @size: size to map
  hl_mmu_unmap_contiguous - implements a wrapper for hl_mmu_unmap_page
                            for unmapping contiguous physical memory
  @ctx: pointer to the context structure
  @virt_addr: virt addr to unmap
  @size: size to unmap
  hl_mmu_swap_out - marks all mapping of the given ctx as swapped out
  @ctx: pointer to the context structure
  hl_mmu_swap_in - marks all mapping of the given ctx as swapped in
  @ctx: pointer to the context structure
 last hop holds the phys address and flags 
 HL_VA_RANGE_TYPE_DRAM 
		
		  Bit arithmetics cannot be used for non power of two page
		  sizes. In addition, since bit arithmetics is not used,
		  we cannot ignore dram base. All that shall be considerd.
		
		  find the correct hop shift field in hl_mmu_properties
		  structure in order to determine the right masks
		  for the page offset.
 assume no scrambling 
 host-residency is the same in PMMU and HPMMU, use one of them 
 add page offset to physical address 
  hl_mmu_scramble_addr() - The generic mmu address scrambling routine.
  @hdev: pointer to device data.
  @addr: The address to scramble.
  Return: The scrambled address.
  hl_mmu_descramble_addr() - The generic mmu address descrambling
  routine.
  @hdev: pointer to device data.
  @addr: The address to descramble.
  Return: The un-scrambled address.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
  hl_pci_bars_map() - Map PCI BARs.
  @hdev: Pointer to hl_device structure.
  @name: Array of BAR names.
  @is_wc: Array with flag per BAR whether a write-combined mapping is needed.
  Request PCI regions and map them to kernel virtual addresses.
  Return: 0 on success, non-zero for failure.
 64-bit BARs 
 64-bit BARs 
  hl_pci_bars_unmap() - Unmap PCI BARS.
  @hdev: Pointer to hl_device structure.
  Release all PCI BARs and unmap their virtual addresses.
 64-bit BARs 
 Clear previous status 
  hl_pci_elbi_write() - Write through the ELBI interface.
  @hdev: Pointer to hl_device structure.
  @addr: Address to write to
  @data: Data to write
  Return: 0 on success, negative value for failure.
 Clear previous status 
  hl_pci_iatu_write() - iatu write routine.
  @hdev: Pointer to hl_device structure.
  @addr: Address to write to
  @data: Data to write
  Return: 0 on success, negative value for failure.
	 Ignore result of writing to pcie_aux_dbi_reg_addr as it could fail
	  in case the firmware security is enabled
  hl_pci_reset_link_through_bridge() - Reset PCI link.
  @hdev: Pointer to hl_device structure.
  hl_pci_set_inbound_region() - Configure inbound region
  @hdev: Pointer to hl_device structure.
  @region: Inbound region number.
  @pci_region: Inbound region parameters.
  Configure the iATU inbound region.
  Return: 0 on success, negative value for failure.
 region offset 
 Point to the specified address 
 Enable + baraddress match + match enable + bar number 
	 Return the DBI window to the default location
	  Ignore result of writing to pcie_aux_dbi_reg_addr as it could fail
	  in case the firmware security is enabled
  hl_pci_set_outbound_region() - Configure outbound region 0
  @hdev: Pointer to hl_device structure.
  @pci_region: Outbound region parameters.
  Configure the iATU outbound region 0.
  Return: 0 on success, negative value for failure.
 Outbound Region 0 
 Increase region size 
 Enable 
	 Return the DBI window to the default location
	  Ignore result of writing to pcie_aux_dbi_reg_addr as it could fail
	  in case the firmware security is enabled
  hl_get_pci_memory_region() - get PCI region for given address
  @hdev: Pointer to hl_device structure.
  @addr: device address
  @return region index on success, otherwise PCI_REGION_NUMBER (invalid
          region index)
  hl_pci_init() - PCI initialization code.
  @hdev: Pointer to hl_device structure.
  Set DMA masks, initialize the PCI controller and map the PCI BARs.
  Return: 0 on success, non-zero for failure.
 Driver must sleep in order for FW to finish the iATU configuration 
  hl_fw_fini() - PCI finalization code.
  @hdev: Pointer to hl_device structure
  Unmap PCI bars and disable PCI device.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2018 HabanaLabs, Ltd.
  All Rights Reserved.
  gaudi_set_block_as_protected - set the given block as protected
  @hdev: pointer to hl_device structure
  @base: block base address
 MME 1 is slave, hence its whole QM block is protected (with RR) 
 MME 3 is slave, hence its whole QM block is protected (with RR) 
  gaudi_init_protection_bits - Initialize protection bits of specific registers
  @hdev: pointer to hl_device structure
  All protection bits are 1 by default, means not protected. Need to set to 0
  each bit that belongs to a protected register.
	
	  In each 4K block of registers, the last 128 bytes are protection
	  bits - total of 1024 bits, one for each register. Each bit is related
	  to a specific register, by the order of the registers.
	  So in order to calculate the bit that is related to a given register,
	  we need to calculate its word offset and then the exact bit inside
	  the word (which is 4 bytes).
	 
	  Register address:
	 
	  31                 12 11           7   6             2  1      0
	  -----------------------------------------------------------------
	  |      Don't         |    word       |  bit location  |    0    |
	  |      care          |   offset      |  inside word   |         |
	  -----------------------------------------------------------------
	 
	  Bits 7-11 represents the word offset inside the 128 bytes.
	  Bits 2-6 represents the bit location inside the word.
	 
	  When a bit is cleared, it means the register it represents can only
	  be accessed by a secured entity. When the bit is set, any entity can
	  access the register.
	 
	  The last 4 bytes in the block of the PBs control the security of
	  the PBs themselves, so they always need to be configured to be
	  secured
 0x000E7FFF 
 0x00120000 
 0x001E7FFF 
 0x00490000 
 0x005FFFFF 
 0x00C49000 
 0x00C49FFF 
 0x00CE0000 
 0x00CE3FFF 
 0x00D20000 
 0x00D23FFF 
 0x00D60000 
 0x00D63FFF 
 0x00DA0000 
 0x00DA3FFF 
 0x00DE0000 
 0x00DE3FFF 
 0x00E06000 
 0x00FC8FFF 
 0x03FFFFFF 
	 Configure HBW RR:
	  1st range is the DRAM (first 512MB)
	  2nd range is the 1st 128 bytes in SRAM (for tensor DMA). This area
	  is defined as read-only for user
	  3rd range is the PSOC scratch-pad
	  4th range is the PCIe FW SRAM area
	  5th range is the SPI FLASH area
	  6th range is the host
 Protect HOST 
  gaudi_init_security - Initialize security model
  @hdev: pointer to hl_device structure
  Initialize the security model of the device
  That includes range registers and protection bit per register
	 Due to HW errata GAUDI0500, need to override default security
	  property configuration of MME SBAB and ACC to be non-privileged and
	  non-secured
		
		  On RAZWI, 0 will be returned from RR and 0xBABA0BAD from PB
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2020 HabanaLabs, Ltd.
  All Rights Reserved.
  Gaudi security scheme:
  1. Host is protected by:
         - Range registers
         - MMU
  2. DDR is protected by:
         - Range registers (protect the first 512MB)
  3. Configuration is protected by:
         - Range registers
         - Protection bits
  MMU is always enabled.
  QMAN DMA channels 0,1 (PCI DMAN):
      - DMA is not secured.
      - PQ and CQ are secured.
      - CP is secured: The driver needs to parse CB but WREG should be allowed
                       because of TDMA (tensor DMA). Hence, WREG is always not
                       secured.
  When the driver needs to use DMA it will check that Gaudi is idle, set DMA
  channel 0 to be secured, execute the DMA and change it back to not secured.
  Currently, the driver doesn't use the DMA while there are compute jobs
  running.
  The current use cases for the driver to use the DMA are:
      - Clear SRAM on context switch (happens on context switch when device is
        idle)
      - MMU page tables area clear (happens on init)
  QMAN DMA 2-7, TPC, MME, NIC:
  PQ is secured and is located on the Host (HBM CON TPC3 bug)
  CQ, CP and the engine are not secured
 256 bytes 
 2000ms 
 1ms 
 200ms 
 100ms 
 1s 
 20s 
 1s 
 4s 
 4s 
 15s 
 128KB 
 1s 
 GAUDI_QUEUE_ID_DMA_0_0 
 GAUDI_QUEUE_ID_DMA_0_1 
 GAUDI_QUEUE_ID_DMA_0_2 
 GAUDI_QUEUE_ID_DMA_0_3 
 GAUDI_QUEUE_ID_DMA_1_0 
 GAUDI_QUEUE_ID_DMA_1_1 
 GAUDI_QUEUE_ID_DMA_1_2 
 GAUDI_QUEUE_ID_DMA_1_3 
 GAUDI_QUEUE_ID_CPU_PQ 
 GAUDI_QUEUE_ID_DMA_2_0 
 GAUDI_QUEUE_ID_DMA_2_1 
 GAUDI_QUEUE_ID_DMA_2_2 
 GAUDI_QUEUE_ID_DMA_2_3 
 GAUDI_QUEUE_ID_DMA_3_0 
 GAUDI_QUEUE_ID_DMA_3_1 
 GAUDI_QUEUE_ID_DMA_3_2 
 GAUDI_QUEUE_ID_DMA_3_3 
 GAUDI_QUEUE_ID_DMA_4_0 
 GAUDI_QUEUE_ID_DMA_4_1 
 GAUDI_QUEUE_ID_DMA_4_2 
 GAUDI_QUEUE_ID_DMA_4_3 
 GAUDI_QUEUE_ID_DMA_5_0 
 GAUDI_QUEUE_ID_DMA_5_1 
 GAUDI_QUEUE_ID_DMA_5_2 
 GAUDI_QUEUE_ID_DMA_5_3 
 GAUDI_QUEUE_ID_DMA_6_0 
 GAUDI_QUEUE_ID_DMA_6_1 
 GAUDI_QUEUE_ID_DMA_6_2 
 GAUDI_QUEUE_ID_DMA_6_3 
 GAUDI_QUEUE_ID_DMA_7_0 
 GAUDI_QUEUE_ID_DMA_7_1 
 GAUDI_QUEUE_ID_DMA_7_2 
 GAUDI_QUEUE_ID_DMA_7_3 
 GAUDI_QUEUE_ID_MME_0_0 
 GAUDI_QUEUE_ID_MME_0_1 
 GAUDI_QUEUE_ID_MME_0_2 
 GAUDI_QUEUE_ID_MME_0_3 
 GAUDI_QUEUE_ID_MME_1_0 
 GAUDI_QUEUE_ID_MME_1_1 
 GAUDI_QUEUE_ID_MME_1_2 
 GAUDI_QUEUE_ID_MME_1_3 
 GAUDI_QUEUE_ID_TPC_0_0 
 GAUDI_QUEUE_ID_TPC_0_1 
 GAUDI_QUEUE_ID_TPC_0_2 
 GAUDI_QUEUE_ID_TPC_0_3 
 GAUDI_QUEUE_ID_TPC_1_0 
 GAUDI_QUEUE_ID_TPC_1_1 
 GAUDI_QUEUE_ID_TPC_1_2 
 GAUDI_QUEUE_ID_TPC_1_3 
 GAUDI_QUEUE_ID_TPC_2_0 
 GAUDI_QUEUE_ID_TPC_2_1 
 GAUDI_QUEUE_ID_TPC_2_2 
 GAUDI_QUEUE_ID_TPC_2_3 
 GAUDI_QUEUE_ID_TPC_3_0 
 GAUDI_QUEUE_ID_TPC_3_1 
 GAUDI_QUEUE_ID_TPC_3_2 
 GAUDI_QUEUE_ID_TPC_3_3 
 GAUDI_QUEUE_ID_TPC_4_0 
 GAUDI_QUEUE_ID_TPC_4_1 
 GAUDI_QUEUE_ID_TPC_4_2 
 GAUDI_QUEUE_ID_TPC_4_3 
 GAUDI_QUEUE_ID_TPC_5_0 
 GAUDI_QUEUE_ID_TPC_5_1 
 GAUDI_QUEUE_ID_TPC_5_2 
 GAUDI_QUEUE_ID_TPC_5_3 
 GAUDI_QUEUE_ID_TPC_6_0 
 GAUDI_QUEUE_ID_TPC_6_1 
 GAUDI_QUEUE_ID_TPC_6_2 
 GAUDI_QUEUE_ID_TPC_6_3 
 GAUDI_QUEUE_ID_TPC_7_0 
 GAUDI_QUEUE_ID_TPC_7_1 
 GAUDI_QUEUE_ID_TPC_7_2 
 GAUDI_QUEUE_ID_TPC_7_3 
 GAUDI_QUEUE_ID_NIC_0_0 
 GAUDI_QUEUE_ID_NIC_0_1 
 GAUDI_QUEUE_ID_NIC_0_2 
 GAUDI_QUEUE_ID_NIC_0_3 
 GAUDI_QUEUE_ID_NIC_1_0 
 GAUDI_QUEUE_ID_NIC_1_1 
 GAUDI_QUEUE_ID_NIC_1_2 
 GAUDI_QUEUE_ID_NIC_1_3 
 GAUDI_QUEUE_ID_NIC_2_0 
 GAUDI_QUEUE_ID_NIC_2_1 
 GAUDI_QUEUE_ID_NIC_2_2 
 GAUDI_QUEUE_ID_NIC_2_3 
 GAUDI_QUEUE_ID_NIC_3_0 
 GAUDI_QUEUE_ID_NIC_3_1 
 GAUDI_QUEUE_ID_NIC_3_2 
 GAUDI_QUEUE_ID_NIC_3_3 
 GAUDI_QUEUE_ID_NIC_4_0 
 GAUDI_QUEUE_ID_NIC_4_1 
 GAUDI_QUEUE_ID_NIC_4_2 
 GAUDI_QUEUE_ID_NIC_4_3 
 GAUDI_QUEUE_ID_NIC_5_0 
 GAUDI_QUEUE_ID_NIC_5_1 
 GAUDI_QUEUE_ID_NIC_5_2 
 GAUDI_QUEUE_ID_NIC_5_3 
 GAUDI_QUEUE_ID_NIC_6_0 
 GAUDI_QUEUE_ID_NIC_6_1 
 GAUDI_QUEUE_ID_NIC_6_2 
 GAUDI_QUEUE_ID_NIC_6_3 
 GAUDI_QUEUE_ID_NIC_7_0 
 GAUDI_QUEUE_ID_NIC_7_1 
 GAUDI_QUEUE_ID_NIC_7_2 
 GAUDI_QUEUE_ID_NIC_7_3 
 GAUDI_QUEUE_ID_NIC_8_0 
 GAUDI_QUEUE_ID_NIC_8_1 
 GAUDI_QUEUE_ID_NIC_8_2 
 GAUDI_QUEUE_ID_NIC_8_3 
 GAUDI_QUEUE_ID_NIC_9_0 
 GAUDI_QUEUE_ID_NIC_9_1 
 GAUDI_QUEUE_ID_NIC_9_2 
 GAUDI_QUEUE_ID_NIC_9_3 
 The order here is opposite to the order of the indexing in the hw.
  i.e. SYNC_MGR_W_S is actually 0, SYNC_MGR_E_S is 1, etc.
 2 SOBs per internal queue stream are reserved for collective 
	 1 monitor per internal queue stream are reserved for collective
	  2 monitors per external queue stream are reserved for collective
 8MB 
 PMMU and HPMMU are the same except of page size 
 shifts and masks are the same in PMMU and DMMU 
 Inbound Region 2 - Bar 4 - Point to HBM 
 Inbound Region 0 - Bar 0 - Point to SRAM + CFG 
 Inbound Region 1 - Bar 2 - Point to SPI FLASH 
 Inbound Region 2 - Bar 4 - Point to HBM 
 Outbound Region 0 - Point to Host 
 Check BAR sizes 
 If FW security is enabled at this point it means no access to ELBI 
		
		  GIC-security-bit can ONLY be set by CPUCP, so in this stage
		  decision can only be taken based on PCI ID security.
 Check whether FW is configuring iATU 
	 Before continuing in the initialization, we need to read the preboot
	  version to determine whether we run with a security-enabled firmware
  gaudi_fetch_psoc_frequency - Fetch PSOC frequency values
  @hdev: pointer to hl_device structure
 Backward compatibility 
  gaudi_init_tpc_mem() - Initialize TPC memories.
  @hdev: Pointer to hl_device structure.
  Copy TPC kernel fw from firmware file and run it to initialize TPC memories.
  Return: 0 for success, negative value for error.
 Iterate through SOB groups and assign a SOB for each slave queue 
	 Both DMA5 and TPC7 use the same resources since only a single
	  engine need to participate in the reduction process
 Set collective engine bit 
 First sob in group must be aligned to HL_MAX_SOBS_PER_MONITOR 
 Init SOB groups 
		 use the encaps signal handle store earlier in the flow
		  and set the SOB information from the encaps
		  signals handle
 Add to wait CBs using slave monitor 
	 In encaps signals case the SOB info will be retrieved from
	  the handle in gaudi_collective_slave_init_job.
 copy the SOB id and value of the signal CS 
	 check again if the signal cs already completed.
	  if yes then don't send any wait cs since the hw_sob
	  could be in reset already. if signal is not completed
	  then get refcount to hw_sob to prevent resetting the sob
	  while wait cs is not submitted.
	  note that this check is protected by two locks,
	  hw queue lock and completion object lock,
	  and the same completion object lock also protects
	  the hw_sob reset handler function.
	  The hw_queue lock prevent out of sync of hw_sob
	  refcount value, changed by signalwait flows.
 Increment kref since all slave queues are now waiting on it 
 Calculate the stream from collective master queue (1st job) 
 Handle sob group kref and wraparound 
		
		  Decrement as we reached the max value.
		  The release function won't be called here as we've
		  just incremented the refcount.
 only two SOBs are currently in use 
		 CB size of collective master queue contains
		  4 msg short packets for monitor 1 configuration
		  1 fence packet
		  4 msg short packets for monitor 2 configuration
		  1 fence packet
		  2 msg prot packets for completion and MSI-X
		 CB size of collective slave queues contains
		  4 msg short packets for monitor configuration
		  1 fence packet
		  1 additional msg short packet for sob signal
 Allocate internal mapped CB for non patched CBs 
	 since its guaranteed to have only one chunk in the collective wait
	  cs, we can use this chunk to set the encapsulated signal offset
	  in the jobs.
	
	  No need in parsing, user CB is the patched CB.
	  We call hl_cb_destroy() out of two reasons - we don't need
	  the CB in the CB idr anymore and to decrement its refcount as
	  it was incremented inside hl_cb_kernel_create().
 increment refcount as for external queues we get completion 
 Verify wait queue id is configured as master 
 Verify engine id is supported 
	 First job goes to the collective master queue, it will wait for
	  the collective slave queues to finish execution.
	  The synchronization is done using two monitors:
	  First monitor for NICs 0-7, second monitor for NICs 8-9 and the
	  reduction engine (DMA5TPC7).
	 
	  Rest of the jobs goes to the collective slave queues which will
	  all wait for the user to signal sob 'cs_cmpl->sob_val'.
 Stop and disable unused NIC QMANs 
 Scrub both SRAM and DRAM 
	 We only support a single ASID for the user, so for the sake of optimization, just
	  initialize the ASID one time during device initialization with the fixed value of 1
	
	  The device CPU works with 40-bits addresses, while bit 39 must be set
	  to '1' when accessing the host.
	  Bits 49:39 of the full host address are saved for a later
	  configuration of the HW to perform extension to 50 bits.
	  Because there is a single HW register that holds the extension bits,
	  these bits must be identical in all allocated range.
 CFG 
 SRAM 
 DRAM 
 SP SRAM 
 Allocate device structure 
 Create DMA pool for small allocations 
  For backward compatibility, new MSI interrupts should be set after the
  existing CPU and NIC interrupts.
 Wait for all pending IRQs to be finished 
 Mask all arithmetic interrupts from TPC 
 Set 16 cache lines 
 Make sure 1st 128 bytes in SRAM are 0 for Tensor DMA 
 The following configuration is needed only once per QMAN 
 Configure RAZWI IRQ 
 Increase ARB WDT to support streams architecture 
 Set to maximum possible according to physical size 
 WA for HW bug H3-2116 
 STOP_ON bit implies no completion to operation in case of RAZWI 
 If the channel is secured, it should be in MMU bypass mode 
		
		  For queues after the CPU Q need to add 1 to get the correct
		  queue. In addition, need to add the CPU EQ and NIC IRQs in
		  order to get the correct MSI register.
 Configure RAZWI IRQ 
 Increase ARB WDT to support streams architecture 
 Configure DMA5 CP_MSG_BASE 23 for sync stream collective 
			 
			   Add the CPU queue in order to get the correct queue
			   number as all internal queue are placed after it
 Initializing lower CP for HBM DMA QMAN 
 Configure RAZWI IRQ 
 Increase ARB WDT to support streams architecture 
	
	  map GAUDI_QUEUE_ID_MME_0_X to the N_W_MME (mmMME2_QM_BASE)
	  and GAUDI_QUEUE_ID_MME_1_X to the S_W_MME (mmMME0_QM_BASE)
 Initializing lower CP for MME QMANs 
 Configure RAZWI IRQ 
 Increase ARB WDT to support streams architecture 
 Configure TPC7 CP_MSG_BASE 23 for sync stream collective 
 Initializing lower CP for TPC QMAN 
 Enable the QMAN and TPC channel 
 Configure NIC CP_MSG_BASE 23 for sync stream collective 
 Configure RAZWI IRQ 
 Increase ARB WDT to support streams architecture 
 Enable the QMAN 
 Stop upper CPs of QMANs 0.0 to 1.3 and 5.0 to 5.3 
 Stop CPs of HBM DMA QMANs 
 Stop CPs of MME QMANs 
 Stop upper CPs of QMANs 
 WA for H3-1800 bug: do ACC and SBAB writes twice 
	 In case we are during debug session, don't enable the clock gate
	  as it may interfere
		 GC sends work to DMA engine through Upper CP in DMA5 so
		  we need to not enable clock gating in that DMA
 Disable the timestamp counter 
 Zero the lowerupper parts of the 64-bit counter 
 Enable the counter 
 Disable the timestamp counter 
 init MMU cache manage page 
 mem cache invalidation 
	
	  The HW expects the first PI after init to be 1. After wraparound
	  we'll write 0.
	
	  here we update initial values for few specific dynamic regs (as
	  before reading the first descriptor from FW those value has to be
	  hard-coded) in later stages of the protocol those values will be
	  updated automatically by reading the FW descriptor so data there
	  will always be up-to-date
 fill common fields 
	
	  The device CPU works with 40 bits addresses.
	  This register sets the extension to 50 bits.
 Used for EQ CI 
 update FW application security bits 
 Perform read from the device to make sure device is up 
		 Set the access through PCI bars (Linux driver only) as
		  secured
		 Perform read to flush the waiting writes to ensure
		  configuration was set in the device
	
	  Let's mark in the HW that we have reached this point. We check
	  this value in the reset_before_init function to understand whether
	  we need to reset the chip before doing HW init. This register is
	  cleared by the HW upon HW reset
	 If iATU is done by FW, the HBM bar ALWAYS points to DRAM_PHYS_BASE.
	  So we set it here and if anyone tries to move it later to
	  a different address, there will be an error
	
	  Before pushing u-bootlinux to device, need to set the hbm bar to
	  base address of dram
	 In case the clock gating was enabled in preboot we need to disable
	  it here before touching the MMETPC registers.
	  There is no need to take clk gating mutex because when this function
	  runs, no other relevant code can run
 SRAM scrambler must be initialized after CPU is running from HBM 
 This is here just in case we are working without CPU 
 MSI must be enabled before CPU queues and NIC are initialized 
 must be called after MSI was enabled 
 Perform read from the device to flush all configuration 
	 Set device to handle FLR by HW as we will put the device CPU to
	  halt mode
	 If linux is loaded in the device CPU we need to communicate with it
	  via the GIC. Otherwise, we need to use COMMS or the MSG_TO_CPU
	  registers in case of old FWs
		 Configure the reset registers. Must be done as early as
		  possible in case we fail during HW initialization
 Tell ASIC not to re-initialize PCIe 
 Restart BTLBLR upon hard-reset 
	
	  After hard reset, we can't poll the BTM_FSM register because the PSOC
	  itself is in reset. Need to wait until the reset is deasserted
 Should never get here 
 ring the doorbell 
 make sure device CPU will read latest data from host 
 The QMANs are on the host memory so a simple copy suffice 
 Shift to the device's base physical address of host memory 
 Cancel the device's base physical address of host memory 
 Wait till device is idle 
 dummy ,
 dummy ,
 Scrub SRAM 
 Scrub HBM using all DMA channels in parallel 
	
	  check capability here as send_cpu_message() won't update the result
	  value if no capability
 Shift to the device's base physical address of host memory 
 Cancel the device's base physical address of host memory 
 Shift to the device's base physical address of host memory 
 Cancel the device's base physical address of host memory 
	
	  Special handling for DMA with size 0. Bypass all validations
	  because no transactions will be done except for WR_COMP, which
	  is not a security issue
 cb_user_size is more than 0 so loop will always be executed 
	
	  The new CB should have space at the end for two MSG_PROT packets:
	  1. A packet that will act as a completion packet
	  2. A packet that will generate MSI-X interrupt
 Fix the last dma packet - wrcomp must be as user set it 
 cb_user_size is more than 0 so loop will always be executed 
	
	  The new CB should have space at the end for two MSG_PROT pkt:
	  1. A packet that will act as a completion packet
	  2. A packet that will generate MSI interrupt
 hl_cb_get should never fail 
	
	  The check that parser->user_cb_size <= parser->user_cb->size was done
	  in validate_queue_index().
 Validate patched CB instead of user CB 
	
	  Always call cb destroy here because we still have 1 reference
	  to it by calling cb_get earlier. After the job will be completed,
	  cb_put will release it, but here we want to remove it from the
	  idr
 hl_cb_get should never fail here 
	
	  Always call cb destroy here because we still have 1 reference
	  to it by calling cb_get earlier. After the job will be completed,
	  cb_put will release it, but here we want to remove it from the
	  idr
 For internal queue jobs just check if CB address is valid 
 PMMU and HPMMU addresses are equal, check only one of them 
 Verify DMA is OK 
 Verify DMA is OK 
 write the value 
		 For DMAs 2-7, need to restore WR_AWUSER_31_11 as it can be
		  modified by the user for SRAM reduction
 Verify DMA is OK 
	 TODO: remove this by mapping the DMA temporary buffer to the MMU
	  using the compute ctx ASID, if exists. If not, use the kernel ctx
	  ASID
 Verify DMA is OK 
	 TODO: remove this by mapping the DMA temporary buffer to the MMU
	  using the compute ctx ASID, if exists. If not, use the kernel ctx
	  ASID
 mask to zero the MMBP and ASID bits 
   +-------------------+------------------------------------------------------+
   | Configuration Reg |                     Description                      |
   |      Address      |                                                      |
   +-------------------+------------------------------------------------------+
   |  0xF30 - 0xF3F    |ECC single error indication (1 bit per memory wrapper)|
   |                   |0xF30 memory wrappers 31:0 (MSB to LSB)               |
   |                   |0xF34 memory wrappers 63:32                           |
   |                   |0xF38 memory wrappers 95:64                           |
   |                   |0xF3C memory wrappers 127:96                          |
   +-------------------+------------------------------------------------------+
   |  0xF40 - 0xF4F    |ECC double error indication (1 bit per memory wrapper)|
   |                   |0xF40 memory wrappers 31:0 (MSB to LSB)               |
   |                   |0xF44 memory wrappers 63:32                           |
   |                   |0xF48 memory wrappers 95:64                           |
   |                   |0xF4C memory wrappers 127:96                          |
   +-------------------+------------------------------------------------------+
 Set invalid wrapper index 
 Iterate through memory wrappers, a single bit must be set 
 Clear error indication 
  gaudi_queue_idx_dec - decrement queue index (pici) and handle wrap
  @idx: the current pici value
  @q_len: the queue length (power of 2)
  @return the cyclically decremented index
	
	  modular decrement is equivalent to adding (queue_size -1)
	  later we take LSBs to make sure the value is in the
	  range [0, queue_len - 1]
  gaudi_print_sw_config_stream_data - print SW config stream data
  @hdev: pointer to the habanalabs device structure
  @stream: the QMAN's stream
  @qman_base: base address of QMAN registers block
  gaudi_print_last_pqes_on_err - print last PQEs on error
  @hdev: pointer to the habanalabs device structure
  @qid_base: first QID of the QMAN (out of 4 streams)
  @stream: the QMAN's stream
  @qman_base: base address of QMAN registers block
  @pr_sw_conf: if true print the SW config stream data (CQ PTR and SIZE)
 we should start printing form ci -1 
 len 0 means uninitialized entry- break 
 get previous ci, wrap if needed 
  print_qman_data_on_err - extract QMAN data on error
  @hdev: pointer to the habanalabs device structure
  @qid_base: first QID of the QMAN (out of 4 streams)
  @stream: the QMAN's stream
  @qman_base: base address of QMAN registers block
  This function attempt to exatract as much data as possible on QMAN error.
  On upper CP print the SW config stream data and last 8 PQEs.
  On lower CP print SW config data and last PQEs of ALL 4 upper CPs
 Iterate through all stream GLBL_STS1 registers + Lower CP 
 Write 1 clear errors 
 Flip the bits as the enum is ordered in the opposite way 
 skip GAUDI_QUEUE_ID_CPU_PQ if necessary 
	 Unmask all IRQs since some could have been received
	  during the soft reset
 Clear interrupts 
 Should never happen 
	 Accessing the TPC_INTR_CAUSE registers requires disabling the clock
	  gating, and thus cannot be done in CPU-CP and should be done instead
	  by the driver.
 If this is QM error, we need to soft-reset 
 Clear interrupts 
 L0 & L1 invalidation 
	 Treat as invalidate all because there is no range invalidation
	  in Gaudi
 MME 1 & 3 are slaves, no need to check their QMANs 
  this function should be used only during initialization andor after reset,
  when there are no active users.
 set a valid LUT pointer, content is of no significance 
 wait a bit for the engine to start executing 
 wait until engine has finished executing 
 wait a bit for the engine to start executing 
 wait until engine has finished executing 
 Inc by 1, Mode ADD 
 write the value 
 W_S SOB base 
 W_S MON base 
 last pkt MB 
	
	  monitor_base should be the content of the base0 address registers,
	  so it will be added to the msg short offsets
 Monitor config packet: bind the monitor to a sync object 
 GREATER OR EQUAL
 write the value 
 W_S MON base 
	
	  monitor_base should be the content of the base0 address registers,
	  so it will be added to the msg short offsets
 First monitor config packet: low address of the sync 
 Second monitor config packet: high address of the sync 
	
	  Third monitor config packet: the payload, i.e. what to write when the
	  sync triggers
	 Reg value represents a partial address of sync object,
	  it is used as unique identifier. For this we need to
	  clear the cutoff cfg base bits from the value.
 create a new hash entry 
 Iterate over TPC engines 
 TPC registered must be accessed with clock gating disabled 
 We can reenable clock_gating 
 Iterate over MME engines 
			 MME registered must be accessed with clock gating
			  disabled
 We can reenable clock_gating 
 Iterate over DMA engines 
	 Sync object ID is calculated as follows:
	  (8  group_id + cleared bits in mask)
 The actual print 
  gaudi_set_asic_funcs - set GAUDI function pointers
  @hdev: pointer to hl_device structure
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2018 HabanaLabs, Ltd.
  All Rights Reserved.
 SW-2176 - SW WA for HW bug 
 maximum address length is 50 bits 
 PMMU and HPMMU addresses are equal, check only one of them 
 make ETR not privileged 
 make ETR non-secured (inverted logic) 
			
			  Workaround for H3 #HW-2075 bug: use small data
			  chunks
			
			  The trace buffer address is 50 bits wide. The end of
			  the buffer is set in the RWP register (lower 32
			  bits), and in the RWPHI register (upper 8 bits).
			  The 10 msb of the 50-bit address are stored in a
			  global configuration register.
 Do nothing as this opcode is deprecated 
 Perform read from the device to flush all configuration 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
 make ETR not privileged 
 make ETR non-secured (inverted logic) 
 burst size 8 
			
			  The trace buffer address is 40 bits wide. The end of
			  the buffer is set in the RWP register (lower 32
			  bits), and in the RWPHI register (upper 8 bits).
 PCIE IF BMON bug WA 
 Do nothing as this opcode is deprecated 
 Perform read from the device to flush all configuration 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
  goya_set_block_as_protected - set the given block as protected
  @hdev: pointer to hl_device structure
  @block: block base address
 TODO: change to real reg name when Soc Online is updated 
  goya_init_protection_bits - Initialize protection bits for specific registers
  @hdev: pointer to hl_device structure
  All protection bits are 1 by default, means not protected. Need to set to 0
  each bit that belongs to a protected register.
	
	  In each 4K block of registers, the last 128 bytes are protection
	  bits - total of 1024 bits, one for each register. Each bit is related
	  to a specific register, by the order of the registers.
	  So in order to calculate the bit that is related to a given register,
	  we need to calculate its word offset and then the exact bit inside
	  the word (which is 4 bytes).
	 
	  Register address:
	 
	  31                 12 11           7   6             2  1      0
	  -----------------------------------------------------------------
	  |      Don't         |    word       |  bit location  |    0    |
	  |      care          |   offset      |  inside word   |         |
	  -----------------------------------------------------------------
	 
	  Bits 7-11 represents the word offset inside the 128 bytes.
	  Bits 2-6 represents the bit location inside the word.
  goya_init_security - Initialize security model
  @hdev: pointer to hl_device structure
  Initialize the security model of the device
  That includes range registers and protection bit per register
 Protect HOST 
	
	  Protect DDR @
	  DRAM_VIRT_BASE : DRAM_VIRT_BASE + DRAM_VIRT_END
	  The mask protects the first 512MB
 Protect registers 
 Protect HOST 
	
	  Protect DDR @
	  DRAM_VIRT_BASE : DRAM_VIRT_BASE + DRAM_VIRT_END
	  The mask protects the first 512MB
 Protect HOST 
	
	  Protect DDR @
	  DRAM_VIRT_BASE : DRAM_VIRT_BASE + DRAM_VIRT_END
	  The mask protects the first 512MB
 Protect HOST 
	
	  Protect DDR @
	  DRAM_VIRT_BASE : DRAM_VIRT_BASE + DRAM_VIRT_END
	  The mask protects the first 512MB
 Protect HOST 
	
	  Protect DDR @
	  DRAM_VIRT_BASE : DRAM_VIRT_BASE + DRAM_VIRT_END
	  The mask protects the first 512MB
 Protect HOST 
	
	  Protect DDR @
	  DRAM_VIRT_BASE : DRAM_VIRT_BASE + DRAM_VIRT_END
	  The mask protects the first 512MB
 Protect HOST 
	
	  Protect DDR @
	  DRAM_VIRT_BASE : DRAM_VIRT_BASE + DRAM_VIRT_END
	  The mask protects the first 512MB
 Protect HOST 
	
	  Protect DDR @
	  DRAM_VIRT_BASE : DRAM_VIRT_BASE + DRAM_VIRT_END
	  The mask protects the first 512MB
 Protect HOST 
	
	  Protect DDR @
	  DRAM_VIRT_BASE : DRAM_VIRT_BASE + DRAM_VIRT_END
	  The mask protects the first 512MB
 Protect HOST 
	
	  Protect DDR @
	  DRAM_VIRT_BASE : DRAM_VIRT_BASE + DRAM_VIRT_END
	  The mask protects the first 512MB
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
  GOYA security scheme:
  1. Host is protected by:
         - Range registers (When MMU is enabled, DMA RR does NOT protect host)
         - MMU
  2. DRAM is protected by:
         - Range registers (protect the first 512MB)
         - MMU (isolation between users)
  3. Configuration is protected by:
         - Range registers
         - Protection bits
  When MMU is disabled:
  QMAN DMA: PQ, CQ, CP, DMA are secured.
  PQ, CB and the data are on the host.
  QMAN TPCMME:
  PQ, CQ and CP are not secured.
  PQ, CB and the data are on the SRAMDRAM.
  Since QMAN DMA is secured, the driver is parsing the DMA CB:
      - checks DMA pointer
      - WREG, MSG_PROT are not allowed.
      - MSG_LONGSHORT are allowed.
  A readwrite transaction by the QMAN to a protected area will succeed if
  and only if the QMAN's CP is secured and MSG_PROT is used
  When MMU is enabled:
  QMAN DMA: PQ, CQ and CP are secured.
  MMU is set to bypass on the Secure props register of the QMAN.
  The reasons we don't enable MMU for PQ, CQ and CP are:
      - PQ entry is in kernel address space and the driver doesn't map it.
      - CP writes to MSIX register and to kernel address space (completion
        queue).
  DMA is not secured but because CP is secured, the driver still needs to parse
  the CB, but doesn't need to check the DMA addresses.
  For QMAN DMA 0, DMA is also secured because only the driver uses this DMA and
  the driver doesn't map memory in MMU.
  QMAN TPCMME: PQ, CQ and CP aren't secured (no change from MMU disabled mode)
  DMA RR does NOT protect host because DMA is not secured
 256 bytes 
 500ms 
 20s 
 1ms 
 100ms 
 1s 
 100ms 
 1s 
 4s 
 15s 
 128KB 
 8MB 
 shifts and masks are the same in PMMU and DMMU 
 PMMU and HPMMU are the same except of page size 
  goya_pci_bars_map - Map PCI BARS of Goya device
  @hdev: pointer to hl_device structure
  Request PCI regions and map them to kernel virtual addresses.
  Returns 0 on success
 Inbound Region 1 - Bar 4 - Point to DDR 
  goya_init_iatu - Initialize the iATU unit inside the PCI controller
  @hdev: pointer to hl_device structure
  This is needed in case the firmware doesn't initialize the iATU
 Inbound Region 0 - Bar 0 - Point to SRAM and CFG 
 Inbound Region 1 - Bar 4 - Point to DDR 
 Outbound Region 0 - Point to Host  
  goya_early_init - GOYA early initialization code
  @hdev: pointer to hl_device structure
  Verify PCI bars
  Set DMA masks
  PCI controller initialization
  Map PCI bars
 Check BAR sizes 
 If FW security is enabled at this point it means no access to ELBI 
 Check whether FW is configuring iATU 
	 Before continuing in the initialization, we need to read the preboot
	  version to determine whether we run with a security-enabled firmware
  goya_early_fini - GOYA early finalization code
  @hdev: pointer to hl_device structure
  Unmap PCI bars
 mask to zero the MMBP and ASID bits 
  goya_fetch_psoc_frequency - Fetch PSOC frequency values
  @hdev: pointer to hl_device structure
	 Now that we have the DRAM size in ASIC prop, we need to check
	  its size and configure the DMA_IF DDR wrap protection (which is in
	  the MMU block) accordingly. The value is the log2 of the DRAM size
  goya_late_fini - GOYA late tear-down code
  @hdev: pointer to hl_device structure
  Free sensors allocated structures
 CFG 
 SRAM 
 DRAM 
  goya_sw_init - Goya software initialization code
  @hdev: pointer to hl_device structure
 Allocate device structure 
 according to goya_init_iatu 
 Create DMA pool for small allocations 
  goya_sw_fini - Goya software tear-down code
  @hdev: pointer to hl_device structure
 PQ has buffer of 2 cache lines, while CQ has 8 lines 
  goya_init_dma_qmans - Initialize QMAN DMA registers
  @hdev: pointer to hl_device structure
  Initialize the HW registers of the QMAN DMA channels
  goya_disable_external_queues - Disable external queues
  @hdev: pointer to hl_device structure
 use the values of TPC0 as they are all the same
 if QMAN is stuck in fence no need to check for stop 
  goya_stop_external_queues - Stop external queues
  @hdev: pointer to hl_device structure
  Returns 0 on success
  goya_init_cpu_queues - Initialize PQCQEQ of CPU
  @hdev: pointer to hl_device structure
  Returns 0 on success
 Used for EQ CI 
 update FW application security bits 
	
	  Workaround for Bug H2 #2443 :
	  "TPC SB is not initialized on chip reset"
 Workaround for H2 #2443 
  goya_init_golden_registers - Initialize golden registers
  @hdev: pointer to hl_device structure
  Initialize the HW registers of the device
 Mask all arithmetic interrupts from TPC 
		
		  Workaround for Bug H2 #2441 :
		  "ST.NOP set trace event illegal opcode"
	
	  Workaround for H2 #HW-23 bug
	  Set DMA max outstanding read requests to 240 on DMA CH 1.
	  This limitation is still large enough to not affect Gen4 bandwidth.
	  We need to only limit that DMA channel because the user can only read
	  from Host using DMA CH 1
 QMAN CQ has 8 cache lines 
 CMDQ CQ has 20 cache lines 
  goya_disable_internal_queues - Disable internal queues
  @hdev: pointer to hl_device structure
  goya_stop_internal_queues - Stop internal queues
  @hdev: pointer to hl_device structure
  Returns 0 on success
	
	  Each queue (QMAN) is a separate HW logic. That means that each
	  QMAN can be stopped independently and failure to stop one does NOT
	  mandate we should not try to stop other QMANs
 Wait for all pending IRQs to be finished 
 Disable the timestamp counter 
 Zero the lowerupper parts of the 64-bit counter 
 Enable the counter 
 Disable the timestamp counter 
  goya_load_firmware_to_device() - Load LINUX FW code to device.
  @hdev: Pointer to hl_device structure.
  Copy LINUX fw code from firmware file to HBM BAR.
  Return: 0 on success, non-zero for failure.
  goya_load_boot_fit_to_device() - Load boot fit to device.
  @hdev: Pointer to hl_device structure.
  Copy boot fit file to SRAM BAR.
  Return: 0 on success, non-zero for failure.
	
	  here we update initial values for few specific dynamic regs (as
	  before reading the first descriptor from FW those value has to be
	  hard-coded) in later stages of the protocol those values will be
	  updated automatically by reading the FW descriptor so data there
	  will always be up-to-date
 fill common fields 
	
	  Before pushing u-bootlinux to device, need to set the ddr bar to
	  base address of dram
 init MMU cache manage page 
 Remove follower feature due to performance bug 
  goya_hw_init - Goya hardware initialization code
  @hdev: pointer to hl_device structure
  Returns 0 on success
 Perform read from the device to make sure device is up 
	
	  Let's mark in the HW that we have reached this point. We check
	  this value in the reset_before_init function to understand whether
	  we need to reset the chip before doing HW init. This register is
	  cleared by the HW upon HW reset
	
	  After CPU initialization is finished, change DDR bar mapping inside
	  iATU to point to the start address of the MMU page tables
 MSI-X must be enabled before CPU queues are initialized 
 Perform read from the device to flush all MSI-X configuration 
		 I don't know what is the state of the CPU so make sure it is
		  stopped in any means necessary
	
	  After hard reset, we can't poll the BTM_FSM register because the PSOC
	  itself is in reset. In either reset we need to wait until the reset
	  is deasserted
 Chicken bit to re-initiate boot sequencer flow 
 Move boot manager FSM to pre boot sequencer init state 
 Should never get here 
 ring the doorbell 
 make sure device CPU will read latest data from host 
 The QMANs are on the SRAM so need to copy to IO space 
 Shift to the device's base physical address of host memory 
 Cancel the device's base physical address of host memory 
	
	  check capability here as send_cpu_message() won't update the result
	  value if no capability
 Shift to the device's base physical address of host memory 
 Cancel the device's base physical address of host memory 
 Shift to the device's base physical address of host memory 
 Cancel the device's base physical address of host memory 
	
	  Special handling for DMA with size 0. The HW has a bug where
	  this can cause the QMAN DMA to get stuck, so block it here.
	
	  WA for HW-23.
	  We can't allow user to read from Host using QMANs other than 1.
	  PMMU and HPMMU addresses are equal, check only one of them.
	
	  With MMU, DMA channels are not secured, so it doesn't matter where
	  the WR COMP will be written to because it will go out with
	  non-secured property
 cb_user_size is more than 0 so loop will always be executed 
			
			  Although it is validated after copy in patch_cb(),
			  need to validate here as well because patch_cb() is
			  not called in MMU path while this function is called
	
	  The new CB should have space at the end for two MSG_PROT packets:
	  1. A packet that will act as a completion packet
	  2. A packet that will generate MSI-X interrupt
 Fix the last dma packet - rdcompwrcomp must be as user set them 
 cb_user_size is more than 0 so loop will always be executed 
	
	  The new CB should have space at the end for two MSG_PROT pkt:
	  1. A packet that will act as a completion packet
	  2. A packet that will generate MSI-X interrupt
 hl_cb_get should never fail here 
	
	  The check that parser->user_cb_size <= parser->user_cb->size was done
	  in validate_queue_index().
 validate patched CB instead of user CB 
	
	  Always call cb destroy here because we still have 1 reference
	  to it by calling cb_get earlier. After the job will be completed,
	  cb_put will release it, but here we want to remove it from the
	  idr
 hl_cb_get should never fail here 
	
	  Always call cb destroy here because we still have 1 reference
	  to it by calling cb_get earlier. After the job will be completed,
	  cb_put will release it, but here we want to remove it from the
	  idr
 For internal queue jobs, just check if CB address is valid 
 Flush all WREG to prevent race 
  goya_debugfs_read32 - read a 32bit value from a given device or a host mapped
                        address.
  @hdev:	pointer to hl_device structure
  @addr:	device or host mapped address
  @val:	returned value
  In case of DDR address that is not mapped into the default aperture that
  the DDR bar exposes, the function will configure the iATU so that the DDR
  bar will be positioned at a base address that allows reading from the
  required address. Configuring the iATU during normal operation can
  lead to undefined behavior and therefore, should be done with extreme care
  goya_debugfs_write32 - write a 32bit value to a given device or a host mapped
                         address.
  @hdev:	pointer to hl_device structure
  @addr:	device or host mapped address
  @val:	returned value
  In case of DDR address that is not mapped into the default aperture that
  the DDR bar exposes, the function will configure the iATU so that the DDR
  bar will be positioned at a base address that allows writing to the
  required address. Configuring the iATU during normal operation can
  lead to undefined behavior and therefore, should be done with extreme care
 data should be aligned to 8 bytes in order to CPU-CP to copy it 
 total_pkt_size is casted to u16 later on 
	 We must perform any necessary endianness conversation on the irq
	  array being passed to the goya hardware
	
	  Unmask all IRQs since some could have been received
	  during the soft reset
 we need to reset registers that the user is allowed to change 
 Make sure configuration is flushed to device 
 zero the MMBP and ASID bits and then set the ASID 
 no need in L1 only invalidation in Goya 
 L0 & L1 invalidation 
	 Treat as invalidate all because there is no range invalidation
	  in Goya
 clock gating not supported in Goya 
 clock gating not supported in Goya 
 Not implemented 
 Not implemented 
 Not implemented 
 Not implemented 
 Not implemented 
  goya_set_asic_funcs - set Goya function pointers
  @hdev: pointer to hl_device structure
 SPDX-License-Identifier: GPL-2.0
  Copyright 2016-2019 HabanaLabs, Ltd.
  All Rights Reserved.
 Make sure we are in LOW PLL when changing modes 
			 Must release the lock because the work thread also
			  takes this lock. But before we release it, set
			  the mode to manual so nothing will change if a user
			  suddenly opens the device
			 Flush the current work so we can return to the user
			  knowing that he is the only one changing frequencies
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2014 IBM Corp.
  Allocates space for a CXL context.
  Initialises a CXL context.
 Set in start work ioctl 
		
		  Allocate the segment table before we put it in the IDR so that we
		  can always access it when dereferenced from IDR. For the same
		  reason, the segment table is only destroyed after the context is
		  removed from the IDR.  Access to this in the IOCTL is protected by
		  Linux filesystem semantics (can't IOCTL until open is complete).
	
	  When we have to destroy all contexts in cxl_context_detach_all() we
	  end up with afu_release_irqs() called from inside a
	  idr_for_each_entry(). Hence we need to make sure that anything
	  dereferenced from this IDR is ok before we allocate the IDR here.
	  This clears out the IRQ ranges to ensure this.
	
	  Allocating IDR! We better make sure everything's setup that
	  dereferences from it.
 assigned when attaching 
	
	  take a ref on the afu so that it stays alive at-least till
	  this context is reclaimed inside reclaim_ctx.
  Map a per-context mmio space into the given vma.
			
			  Make sure there is a valid problem state
			  area space for this AFU.
 Can't mmap until the AFU is enabled 
 Make sure there is a valid per process space for this AFU 
 Can't mmap until the AFU is enabled 
  Detach a context from the hardware. This disables interrupts and doesn't
  return until all outstanding interrupts for this context have completed. The
  hardware should no longer access ctx after this has returned.
	 Only warn if we detached while the link was OK.
	  If detach fails when hw is down, we don't care.
 Only needed for dedicated process 
	
	  Wait until no further interrupts are presented by the PSL
	  for this context.
 release the reference to the group leader and mm handling pid 
 Decrease the attached context count on the adapter 
 Decrease the mm count on the context 
  Detach the given context from the AFU. This doesn't actually
  free the context but it should stop the context running in hardware
  (ie. prevent this context from generating any further interrupts
  so that it can be freed).
  Detach all contexts on the given AFU.
		
		  Anything done in here needs to be setup before the IDR is
		  created and torn down after the IDR removed
		
		  We are force detaching - remove any active PSA mappings so
		  userspace cannot interfere with the card if it comes back.
		  Easiest way to exercise this is to unbind and rebind the
		  driver via sysfs while it is in use.
 Drop ref to the afu device taken during cxl_context_init 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2014 IBM Corp.
  Since we want to track memory mappings to be able to force-unmap
  when the AFU is no longer reachable, we need an inode. For devices
  opened through the cxl user API, this is not a problem, but a
  userland process can also get a cxl fd through the cxl_get_fd()
  API, which is used by the cxlflash driver.
  Therefore we implement our own simple pseudo-filesystem and inode
  allocator. We don't use the anonymous inode, as we need the
  meta-data associated with it (address_space) and it is shared by
  other driversprocesses, so it could lead to cxl unmapping VMAs
  from random processes.
 strongly inspired by anon_inode_getfile() 
 Make it a slave context.  We can promote it later? 
		 In a guest, the PSL interrupt is not multiplexed. It was
		  allocated above, and we need to set its handler
	
	  Find interrupt we are to register.
  Start a context
  Code here similar to afu_ioctl_start_work().
 already started 
	
	  Increment the mapped context count for adapter. This also checks
	  if adapter_context_lock is taken.
 acquire a reference to the task's mm 
 ensure this mm_struct can't be freed 
 decrement the use count from above 
 make TLBIs for this context global 
	
	  Increment driver use count. Enables global TLBIs for hash
	  and callbacks to handle the segment table
 See the comment in afu_ioctl_start_work() 
 Stop a context.  Returns 0 on success, otherwise -Errno 
 wrappers around afu_ file ops which are EXPORTED 
 Get a struct file and fd for a context and attach the ops 
 only allow one per context 
 This code is similar to anon_inode_getfd() 
	
	  Patch the file ops.  Needs to be careful that this is rentrant safe.
 use default ops 
 code taken from afu_ioctl_start_work 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015 IBM Corp.
 perform a reset 
 suspend a process from being executed 
 resume a process to be executed 
 read the error state 
 collect the AFU error buffer 
 collect configuration record 
 query to return download status 
 terminate the process before completion 
 collect VPD 
 read the function-wide error data based on an interrupt 
 acknowledge function-wide error data based on an interrupt 
 retrieve the Platform Log ID (PLID) of an error log 
 perform a reset 
 collect VPD 
 download adapter image 
 validate adapter image 
 0 undefined 
 1 
 2 
 3 
 4 
 5 
 6 
 7 
 8 
 9 
 10 undefined 
 11 
 12 
 13 
 0 undefined 
 1 
 2 
 0 undefined 
 1 
 2 
 The process info is attached to the coherent platform function 
 An incorrect parameter was supplied. 
 The function is not supported. 
 The partition does not have authority to perform this hcall 
 The coherent platform function does not have enough additional resource to attach the process 
 A hardware event prevented the attach operation 
 The coherent platform function is not in a valid state 
  cxl_h_detach_process - Detach a process element from a coherent
                         platform function.
 The process was detached from the coherent platform function 
 An incorrect parameter was supplied. 
 The partition does not have authority to perform this hcall 
 The function has page table mappings for MMIO 
 A hardware event prevented the detach operation 
 The coherent platform function is not in a valid state 
  cxl_h_control_function - This H_CONTROL_CA_FUNCTION hypervisor call allows
                           the partition to manipulate or query
                           certain coherent platform function behaviors.
 The operation is completed for the coherent platform function 
 An incorrect parameter was supplied. 
 The function is not supported. 
 The operation supplied was not valid 
 The operation cannot be performed because the AFU has not been downloaded 
 An block list entry was invalid 
 The partition does not have authority to perform this hcall 
 The function has page table mappings for MMIO 
 A hardware event prevented the attach operation 
 The coherent platform function is not in a valid state 
  cxl_h_reset_afu - Perform a reset to the coherent platform function.
  cxl_h_suspend_process - Suspend a process from being executed
  Parameter1 = process-token as returned from H_ATTACH_CA_PROCESS when
               process was attached.
  cxl_h_resume_process - Resume a process to be executed
  Parameter1 = process-token as returned from H_ATTACH_CA_PROCESS when
               process was attached.
  cxl_h_read_error_state - Checks the error state of the coherent
                           platform function.
  R4 contains the error state
  cxl_h_get_afu_err - collect the AFU error buffer
  Parameter1 = byte offset into error buffer to retrieve, valid values
               are between 0 and (ibm,error-buffer-size - 1)
  Parameter2 = 4K aligned real address of error buffer, to be filled in
  Parameter3 = length of error buffer, valid values are 4K or less
  cxl_h_get_config - collect configuration record for the
                     coherent platform function
  Parameter1 = # of configuration record to retrieve, valid values are
               between 0 and (ibm,#config-records - 1)
  Parameter2 = byte offset into configuration record to retrieve,
               valid values are between 0 and (ibm,config-record-size - 1)
  Parameter3 = 4K aligned real address of configuration record buffer,
               to be filled in
  Parameter4 = length of configuration buffer, valid values are 4K or less
  cxl_h_terminate_process - Terminate the process before completion
  Parameter1 = process-token as returned from H_ATTACH_CA_PROCESS when
               process was attached.
  cxl_h_collect_vpd - Collect VPD for the coherent platform function.
  Parameter1 = # of VPD record to retrieve, valid values are between 0
               and (ibm,#config-records - 1).
  Parameter2 = 4K naturally aligned real buffer containing block
               list entries
  Parameter3 = number of block list entries in the block list, valid
               values are between 0 and 256
  cxl_h_get_fn_error_interrupt - Read the function-wide error data based on an interrupt
  cxl_h_ack_fn_error_interrupt - Acknowledge function-wide error data
                                 based on an interrupt
  Parameter1 = value to write to the function-wide error interrupt register
  cxl_h_get_error_log - Retrieve the Platform Log ID (PLID) of
                        an error log
  cxl_h_collect_int_info - Collect interrupt info about a coherent
                           platform function after an interrupt occurred.
 The interrupt info is returned in return registers. 
 An incorrect parameter was supplied. 
 The partition does not have authority to perform this hcall. 
 A hardware event prevented the collection of the interrupt info.
 The coherent platform function is not in a valid state to collect interrupt info. 
  cxl_h_control_faults - Control the operation of a coherent platform
                         function after a fault occurs.
  Parameters
     control-mask: value to control the faults
                   looks like PSL_TFC_An shifted >> 32
     reset-mask: mask to control reset of function faults
                 Set reset_mask = 1 to reset PSL errors
 Faults were successfully controlled for the function. 
 An incorrect parameter was supplied. 
 A hardware event prevented the control of faults. 
 The function was in an invalid state. 
 The partition does not have authority to perform this hcall; the coherent platform facilities may need to be licensed. 
 The function is not supported 
 The operation supplied was not valid 
  cxl_h_control_facility - This H_CONTROL_CA_FACILITY hypervisor call
                           allows the partition to manipulate or query
                           certain coherent platform facility behaviors.
 The operation is completed for the coherent platform facility 
 An incorrect parameter was supplied. 
 The function is not supported. 
 The operation supplied was not valid 
 The operation cannot be performed because the AFU has not been downloaded 
 An block list entry was invalid 
 The partition does not have authority to perform this hcall 
 The function has page table mappings for MMIO 
 A hardware event prevented the attach operation 
 The coherent platform facility is not in a valid state 
  cxl_h_reset_adapter - Perform a reset to the coherent platform facility.
  cxl_h_collect_vpd - Collect VPD for the coherent platform function.
  Parameter1 = 4K naturally aligned real buffer containing block
               list entries
  Parameter2 = number of block list entries in the block list, valid
               values are between 0 and 256
  cxl_h_download_facility - This H_DOWNLOAD_CA_FACILITY
                     hypervisor call provide platform support for
                     downloading a base adapter image to the coherent
                     platform facility, and for validating the entire
                     image after the download.
  Parameters
     op: operation to perform to the coherent platform function
       Download: operation = 1, the base image in the coherent platform
                                facility is first erased, and then
                                programmed using the image supplied
                                in the scattergather list.
       Validate: operation = 2, the base image in the coherent platform
                                facility is compared with the image
                                supplied in the scattergather list.
     list_address: 4K naturally aligned real buffer containing
                   scattergather list entries.
     num: number of block list entries in the scattergather list.
 The operation is completed for the coherent platform facility 
 An incorrect parameter was supplied 
 The function is not supported. 
 An block list entry was invalid 
 Image verification failed 
 The partition does not have authority to perform this hcall 
 The function has page table mappings for MMIO 
 A hardware event prevented the attach operation 
 The coherent platform facility is not in a valid state 
 More data is needed for the complete image 
  cxl_h_download_adapter_image - Download the base image to the coherent
                                 platform facility.
  cxl_h_validate_adapter_image - Validate the base image in the coherent
                                 platform facility.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2014 IBM Corp.
 protected by rcu 
 we don't need to rcu this, as we hold a reference to the module 
 !defined CONFIG_CXL_MODULE 
 CONFIG_CXL_MODULE 
 AFU refcount management 
	
	  Scan for compatible devices in guest only
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015 IBM Corp.
 Get address and size of the node 
 Helper to read a big number; size is in cells (not bytes) 
 unit address 
 p2 area 
 problem state area 
 Properties are read in the same order as listed in PAPR 
		 One extra interrupt for the PSL interrupt is already
		  included. Remove it now to keep only AFU interrupts and
		  match the native case.
	
	  if "ibm,process-mmio" doesn't exist then per-process mmio is
	  not supported
	
	  encoded array of two cells per entry, each cell encoded as
	  with encode-int
 Properties are read in the same order as listed in PAPR 
 init adapter 
 init afu 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015 IBM Corp.
 number of entries in the list 
		
		  hcall returns in 'out' the size of available VPDs.
		  It fills the buffer with as much data as possible.
 config record is not writable from guest 
 config record is not writable from guest 
 config record is not writable from guest 
 Must be 8 byte aligned and cannot cross a 4096 byte boundary 
 Unused 
 disable 
 disable 
 disable 
	
	  Ensure we have at least one interrupt allocated to take faults for
	  kernel contexts that may not have allocated any AFU IRQs at all:
			
			  There's no property in the device tree to read the
			  pp_size. We only find out at the 1st attach.
			  Compared to bare-metal, it is too late and we
			  should really lock here. However, on powerVM,
			  pp_size is really only used to display in sys.
			  Being discussed with pHyp for their next release.
 from PAPR: process element is bytes 4-7 of process token 
 dedicated mode not supported on FW840 
	
	  After we call this function we must not free the afu directly, even
	  if it returns an error!
	
	  pHyp doesn't expose the programming models supported by the
	  AFU. pHyp currently only supports directed mode. If it adds
	  dedicated mode later, this version of cxl has no way to
	  detect it. So we'll initialize the driver, but the first
	  attach will fail.
	  Being discussed with pHyp to do better (likely new property)
	
	  wake up the cpu periodically to check the state
	  of the AFU using "afu" stored in the guest structure.
 flush and stop pending job 
	 The absence of this property means that the operational
	  status is unknown or okay
	
	  Hypervisor controls PSL timebase initialization (p1 register).
	  On FW840, PSL is initialized.
	
	  After we call this function we must not free the adapter directly,
	  even if it returns an error!
 release the context lock as the adapter is configured 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2014 IBM Corp.
 If we see these features we won't try to use the card 
 Power 89 uses this 
 RO 
 RW 
 RW 
 This works a little different than the p1p2 register accesses to make it
  Mostly using these wrappers to avoid confusion:
  priv 1 is BAR2, while priv 2 is BAR0
	
	  POWER 8:
	   - For chips other than POWER8NVL, we only have CAPP 0,
	     irrespective of which PHB is used.
	   - For POWER8NVL, assume CAPP 0 is attached to PHB0 and
	     CAPP 1 is attached to PHB1.
	
	  POWER 9:
	    PEC0 (PHB0). Capp ID = CAPP0 (0b1100_0000)
	    PEC1 (PHB1 - PHB2). No capi mode
	    PEC2 (PHB3 - PHB4 - PHB5): Capi mode on PHB3 only. Capp ID = CAPP1 (0b1110_0000)
 legacy values 
	
	  CAPI Identifier bits [0:7]
	  bit 61:60 MSI bits --> 0
	  bit 59 TVT selector --> 0
	
	  Tell XSL where to route data to.
	  The field chipid should match the PHB CAPI_CMPM register
 Bit 57 
 nMMU_ID Defaults to: b‚Äô000001001‚Äô
	
	  Used to identify CAPI packets which should be sorted into
	  the Non-Blocking queues by the PHB. This field should match
	  the PHB PBL_NBW_CMPM register
	  nbwind=0x03, bits [57:58], must include capi indicator.
	  Not supported on P9 DD1.
	
	  Upper 16b address bits of ASB_Notify messages sent to the
	  system. Need to match the PHB‚Äôs ASN CompareMask Register.
	  Not supported on P9 DD1.
 Set fir_cntl to recommended value for production env 
 ce_report 
 FIR_report 
 ce_thresh 
	 Setup the PSL to transmit packets on the PCIe before the
	  CAPP is enabled. Make sure that CAPP virtual machines are disabled
	
	  A response to an ASB_Notify request is returned by the
	  system as an MMIO write to the address defined in
	  the PSL_TNR_ADDR register.
	  keep the Reset Value: 0x00020000E0000000
 Enable XSL rty limit 
 Change XSL_INV dummy read threshold 
 disable machines 31-47 and 20-27 for DMA 
 Snoop machines 
 Enable NORST and DD2 features 
	
	  Check if PSL has data-cache. We need to flush adapter datacache
	  when as its about to be removed.
 pteupd ttype, scdone 
 MMIO hang pulse: 256 us 
 Tell PSL where to route data to 
 snoop write mask 
 set fir_cntl to recommended value for production env 
 ce_report 
 FIR_report 
 ce_thresh 
 for debugging with trace arrays 
 PSL 
 For the PSL this is a multiple for 0 < n <= 7: 
 Do not fail when CAPP timebase sync is not supported by OPAL 
	
	  Setup PSL Timebase Control and Status register
	  with the recommended Timebase Sync Count value
 Enable PSL Timebase 
 readwrite masks for this slice 
 APC readwrite masks for this slice 
 for debugging with trace arrays 
 Safety check in case we get backported to < 3.17 without M64 
	
	  BAR 45 has a special meaning for CXL and must be programmed with a
	  special value corresponding to the CXL protocol address range.
	  For POWER 89 that means bits 48:49 must be set to 10
 pciex node: ibm,opal-m64-window = <0x3d058 0x0 0x3d058 0x0 0x8 0x0>; 
	
	  The CAIA spec (v0.12 11.6 Bi-modal Device Support) states
	  we must wait 100ms after this mode switch before touching
	  PCIe config space.
 Expects AFU struct to have recently been zeroed out 
 eb_len is in multiple of 4K 
 eb_off is 4K aligned so lower 12 bits are always zero 
 indicate that no afu buffer exists 
		
		  We could also check this for the dedicated process model
		  since the architecture indicates it should be set to 1, but
		  in that case we ignore the value and I'd rather not risk
		  breaking any existing dedicated process AFUs that left it as
		  0 (not that I'm aware of any). It is clearly an error for an
		  AFU directed AFU to set this to 0, and would have previously
		  triggered a bug resulting in the maximum not being enforced
		  at all since idr_alloc treats 0 as no maximum.
	
	  Clear out any regs that contain either an IVTE or address or may be
	  waiting on an acknowledgment to try to be a bit safer as we bring
	  it online
	
	  Clear out any regs that contain either an IVTE or address or may be
	  waiting on an acknowledgement to try to be a bit safer as we bring
	  it online
  afu_eb_read:
  Called from sysfs and reads the afu error info buffer. The hw only supports
  48 bytes aligned access. So in case the requested offsetcount arent 8 byte
  aligned the function uses a bounce buffer which can be max PAGE_SIZE.
 calculate aligned read window 
 max we can copy in one read is PAGE_SIZE 
 use bounce buffer for copy 
 perform aligned read from the mmio region 
 We need to reset the AFU before we can read the AFU descriptor 
	
	  It's okay to deconfigure when AFU is already locked, otherwise wait
	  until there are no readers
 Don't care if this fails 
	
	  After we call this function we must not free the afu directly, even
	  if it returns an error!
	
	  The adapter is about to be reset, so ignore errors.
	 pcie_warm_reset requests a fundamental pci reset which includes a
	  PERST assertdeassert.  PERST triggers a loading of the image
	 Convert everything to bytes, because there is NO WAY I'd look at the
 Total IRQs - 1 PSL ERROR - #AFU(1 slice error + 1 DSI) 
  Workaround a PCIe Host Bridge defect on some cards, that can cause
  malformed Transaction Layer Packet (TLP) errors to be erroneously
  reported. Mask this error in the Uncorrectable Error Mask Register.
  The upper nibble of the PSL revision is used to distinguish between
  different cards. The affected ones have it set to 0.
		 Once we support dynamic reprogramming we can use the card if
 Clear PSL tberror bit by writing 1 to it 
 do not invalidate ERAT entries when not reloading on PERST 
 This should contain only operations that can safely be done in
  both creation and recovery.
 Required for devices using CAPP DMA mode, harmless for others 
	 If recovery happened, the last step is to turn on snooping.
 Ignore error, adapter init is not dependant on timebase sync 
 read each tracearray state and issue mmio to stop them is needed 
 issue mmio if the trace array isn't in FIN state 
 Stop the trace 
 Stop the slice traces 
	 Set defaults for parameters which need to persist over
	  configurereconfigure
 Don't care if this one fails: 
	
	  After we call this function we must not free the adapter directly,
	  even if it returns an error!
 Release the context lock as adapter is configured 
	 This should mirror cxl_remove_adapter, except without the
	  sysfs parts
	
	  Flush adapter datacache as its about to be removed.
	
	  Lock to prevent someone grabbing a ref through the adapter list as
	  we are removing it
	 There should only be one entry, but go through the list
	  anyway
 Disconnect trumps all, NONE trumps NEED_RESET 
	 At this point, we could still have an interrupt pending.
	  Let's try to get them out of the way before they do
	  anything we don't like.
 If we're permanently dead, give up. 
			
			  Tell the AFU drivers; but we don't care what they
			  say, we're going away.
	 Are we reflashing?
	 
	  If we reflash, we could come back as something entirely
	  different, including a non-CAPI card. As such, by default
	  we don't participate in the process. We'll be unbound and
	  the slot re-probed. (TODO: check EEH doesn't blindly rebind
	  us!)
	 
	  However, this isn't the entire story: for reliablity
	  reasons, we usually want to reflash the FPGA on PERST in
	  order to get back to a more reliable known-good state.
	 
	  This causes us a bit of a problem: if we reflash we can't
	  trust that we'll come back the same - we could have a new
	  image and been PERSTed in order to load that
	  image. However, most of the time we actually will come
	  back the same - for example a regular EEH event.
	 
	  Therefore, we allow the user to assert that the image is
	  indeed the same and that we should continue on into EEH
	  anyway.
 TODO take the PHB out of CXL mode 
	
	  At this point, we want to try to recover.  We'll always
	  need a complete slot reset: we don't trust any other reset.
	 
	  Now, we go through each AFU:
	   - We send the driver, if bound, an error_detected callback.
	     We expect it to clean up, but it can also tell us to give
	     up and permanently detach the card. To simplify things, if
	     any bound AFU driver doesn't support EEH, we give up on EEH.
	 
	   - We detach all contexts associated with the AFU. This
	     does not free them, but puts them into a CLOSED state
	     which causes any the associated files to return useful
	     errors to userland. It also unmaps, but does not free,
	     any IRQs.
	 
	   - We clean up our side: releasing and unmapping resources we hold
	     so we can wire them up again when the hardware comes back up.
	 
	  Driver authors should note:
	 
	   - Any contexts you create in your kernel driver (except
	     those associated with anonymous file descriptors) are
	     your responsibility to free and recreate. Likewise with
	     any attached resources.
	 
	   - We will take responsibility for re-initialising the
	     device context (the one set up for you in
	     cxl_pci_enable_device_hook and accessed through
	     cxl_get_context). If you've attached IRQs or other
	     resources to it, they remains yours to free.
	 
	  You can call the same functions to release resources as you
	  normally would: we make sure that these functions continue
	  to work when the hardware is down.
	 
	  Two examples:
	 
	  1) If you normally free all your resources at the end of
	     each request, or if you use anonymous FDs, your
	     error_detected callback can simply set a flag to tell
	     your driver not to start any new calls. You can then
	     clear the flag in the resume callback.
	 
	  2) If you normally allocate your resources on startup:
	       Set a flag in error_detected as above.
	       Let CXL detach your contexts.
	       In slot_reset, free the old resources and allocate new ones.
	       In resume, clear the flag to allow things to start.
 Make sure no one else changes the afu list 
 Disconnect trumps all, NONE trumps NEED_RESET 
 should take the context lock here 
	
	  Unlock context activation for the adapter. Ideally this should be
	  done in cxl_pci_resume but cxlflash module tries to activate the
	  master context as part of slot_reset callback.
			 Reset the device context.
			  TODO: make this less disruptive
			 If there's a driver attached, allow it to
			  chime in on recovery. Drivers should check
			  if everything has come back OK, but
			  shouldn't start new work until we call
			  their resume function.
	 All the bits that happen in both error_detected and cxl_remove
	  should be idempotent, so we don't need to worry about leaving a mix
	  of unconfigured and reconfigured resources.
	 Everything is back now. Drivers should restart work now.
	  This is not the place to be checking if everything came back up
	  properly, because there's no return value: do that in slot_reset.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2014 IBM Corp.
 Helpers to export CXL mmaped IO registers via debugfs 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2014 IBM Corp.
 Total to reserve 
	
	  taking a ref to the afu so that it doesn't go away
	  for rest of the function. This ref is released before
	  we return.
 indicate success 
 release the ref taken earlier 
	
	  Delete the context's mapping pointer, unless it's created by the
	  kernel API, in which case leave it so it can be freed by reclaim_ctx()
	
	  At this this point all bottom halfs have finished and we should be
	  getting no more IRQs from the hardware for this context.  Once it's
	  removed from the IDR (and RCU synchronised) it's safe to free the
	  sstp and context.
	 Do this outside the status_mutex to avoid a circular dependency with
	
	  if any of the reserved fields are set or any of the unused
	  flags are set it's invalid
	
	  Increment the mapped context count for adapter. This also checks
	  if adapter_context_lock is taken.
	
	  We grab the PID here and not in the file open to allow for the case
	  where a process (master, some daemon, etc) has opened the chardev on
	  behalf of another process, so the AFU's mm gets bound to the process
	  that performs this ioctl and not the process that opened the file.
	  Also we grab the PID of the group leader so that if the task that
	  has performed the attach operation exits the mm context of the
	  process is still accessible.
 acquire a reference to the task's mm 
 ensure this mm_struct can't be freed 
 decrement the use count from above 
 make TLBIs for this context global 
	
	  Increment driver use count. Enables global TLBIs for hash
	  and callbacks to handle the segment table
	
	  A barrier is needed to make sure all TLBIs are global
	  before we attach and the context starts being used by the
	  adapter.
	 
	  Needed after mm_context_add_copro() for radix and
	  cxl_ctx_get() for hashp8.
	 
	  The barrier should really be mb(), since it involves a
	  device. However, it's only useful when we have local
	  vs. global TLBIs, i.e SMP=y. So keep smp_mb().
 set the flag bit in case the afu is a slave 
 AFU must be started before we can MMIO 
		 Only error on closed when there are no futher events pending
 Check event 
 Check event size 
 Copy event header 
 Copy event data 
 Success 
  Note: if this is updated, we need to update api.c to patch the new ones in
  too
		
		  These minor numbers will eventually be used to program the
		  PSL and AFUs once we have dynamic reprogramming support
 Uses master fops 
	
	  Future: When we support dynamically reprogramming the PSL & AFU we
	  will expose the interface to do that via a chardev:
	  adapter->dev.devt = CXL_CARD_MKDEV(adapter);
	
	  If these change we really need to update API.  Either change some
	  flags or update API version number CXL_API_VERSION.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2014 IBM Corp.
		
		  Workaround for a bug in the XSL used in the Mellanox CX4
		  that fails to clear the RA bit after an AFU reset,
		  preventing subsequent AFU resets from working.
 This will disable as well as reset 
	
	  Re-enable any masked interrupts when the AFU is not
	  activated to avoid side effects after attaching a process
	  in dedicated mode.
	
	  From the CAIA:
	     end_of_SPA_area = SPA_Base + ((n+4)  128) + (( ((n8) + 127) >> 7)  128) + 255
	  Most of that junk is really just an overly-complicated way of saying
	  the last 256 bytes are __aligned(128), so it's really:
	     end_of_SPA_area = end_of_PSL_queue_area + __aligned(128) 255
	  and
	     end_of_PSL_queue_area = SPA_Base + ((n+4)  128) + (n8) - 1
	  so
	     sizeof(SPA) = ((n+4)  128) + (n8) + __aligned(128) 256
	  Ignore the alignment (which is safe in this case as long as we are
	  careful with our rounding) and solve for n:
 Work out how many pages to allocate 
  Invalidation of all ERAT entries is no longer required by CAIA2. Use
  only for debug.
 Invalidates all ERAT entries for Radix or HPT 
	
	  Do a datacache flush only if datacache is available.
	  In case of PSL9D datacache absent hence flush operation.
	  would timeout.
 1. Disable SSTP by writing 0 to SSTP1[V] 
 2. Invalidate all SLB entries 
 3. Set SSTP0_An 
 4. Set SSTP1_An 
 Using per slice version may improve performance here. (ie. SLBIA_An) 
		
		  The command won't finish in the PSL if there are
		  outstanding DSIs.  Hence we need to yield here in
		  case there are outstanding DSIs that we need to
		  service.  Tuning possiblity: we could wait for a
		  while before sched
 fast path terminate if it's already invalid 
	 We could be asked to terminate when the hw is down. That
	  should always succeed: it's not running if the hw has gone
	  away and is being reset.
 Remove Valid bit 
	 We could be asked to remove when the hw is down. Again, if
	  the hw is down, the PE is gone, so we succeed.
	
	  Theoretically we could use the update llcmd, instead of a
	  terminateremoveadd (or if an atomic update was required we could
	  do a suspendupdateresume), however it seems there might be issues
	  with the update llcmd on some cards (including those using an XSL on
	  an ASIC) so for now it's safest to go with the commands that are
	  known to work. In the future if we come across a situation where the
	  card may be performing transactions using the same PE while we are
	  doing this update we might need to revisit this.
 disable 
 disable 
 Assign a unique TIDR (thread id) for the current thread 
 disable 
	
	  Ensure we have the multiplexed PSL interrupt set up to take faults
	  for kernel contexts that may not have allocated any AFU IRQs at all:
 fill the process element entry 
 first guy needs to enable 
 disable 
 disable 
 disable 
 disable 
 disable 
	
	  Ensure we have the multiplexed PSL interrupt set up to take faults
	  for kernel contexts that may not have allocated any AFU IRQs at all:
 first guy needs to enable 
	
	  The CAIA section 2.2.1 indicates that the procedure for starting and
	  stopping an AFU in AFU directed mode is AFU specific, which is not
	  ideal since this code is generic and with one exception has no
	  knowledge of the AFU. This is in contrast to the procedure for
	  disabling a dedicated process AFU, which is documented to just
	  require a reset. The architecture does indicate that both an AFU
	  reset and an AFU disable should result in the AFU being disabled and
	  we do both followed by a PSL purge for safety.
	 
	  Notably we used to have some issues with the disable sequence on PSL
	  cards, which is why we ended up using this heavy weight procedure in
	  the first place, however a bug was discovered that had rendered the
	  disable operation ineffective, so it is conceivable that was the
	  sole explanation for those difficulties. Careful regression testing
	  is recommended if anyone attempts to remove or reorder these
	  operations.
	 
	  The XSL on the Mellanox CX4 behaves a little differently from the
	  PSL based cards and will time out an AFU reset if the AFU is still
	  enabled. That card is special in that we do have a means to identify
	  it from this code, so in that case we skip the reset and just use a
	  disablepurge to avoid the timeout and corresponding noise in the
	  kernel log.
	
	  If XSL is set to dedicated mode (Set in PSL_SCNTL reg), the
	  XSL and AFU are programmed to work with a single context.
	  The context information should be configured in the SPA area
	  index 0 (so PSL_SPAP must be configured before enabling the
	  AFU).
 disable 
 disable 
 disable 
 disable 
 disable 
 disable 
 fill the process element entry 
	
	  Ideally we should do a wmb() here to make sure the changes to the
	  PE are visible to the card before we call afu_enable.
	  On ppc64 though all mmios are preceded by a 'sync' instruction hence
	  we dont dont need one here.
 master only context for dedicated 
	
	  The CAIA section 2.1.1 indicates that we need to do an AFU reset to
	  stop the AFU in dedicated mode (we therefore do not make that
	  optional like we do in the afu directed path). It does not indicate
	  that we need to do an explicit disable (which should occur
	  implicitly as part of the reset) or purge, but we do these as well
	  to be on the safe side.
	 
	  Notably we used to have some issues with the disable sequence
	  (before the sequence was spelled out in the architecture) which is
	  why we were so heavy weight in the first place, however a bug was
	  discovered that had rendered the disable operation ineffective, so
	  it is conceivable that was the sole explanation for those
	  difficulties. Point is, we should be careful and do some regression
	  testing if we ever attempt to remove any part of this procedure.
	 If the adapter has gone away, we can't get any meaningful
	  information.
 check if eeh kicked in while the interrupt was in flight 
 Mask the pe-handle from register value 
	
	  Wait until no further interrupts are presented by the PSL
	  for this context.
		
		  We are waiting for the workqueue to process our
		  irq, so need to let that run here.
	
	  slice err interrupt is only used with full PSL (no XSL)
 mask off the IRQ so it won't retrigger until the AFU is reset 
		
		  By default, all errors are masked. So don't set all masks.
		  Slice errors will be transfered.
 Clear PSL_DSISR[PE] 
 Write 1s to clear error status bits 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2014 IBM Corp.
  This finds a free SSTE for the given SLB, or returns NULL if it's already in
  the segment table.
 SSTP0[SegTableSize] 
 256M 
 Nothing free, select an entry to cast out 
 mask is the group index, we search primary and secondary here. 
 Order seg table write to TFC MMIO write 
	
	  Add the fault handling cpu to task mm cpumask so that we
	  can do a safe lockless page table walk when inserting the
	  hash page table entry. This function get called with a
	  valid mm for user space addresses. Hence using the if (mm)
	  check is sufficient here.
		
		  We need to make sure we walk the table only after
		  we update the cpumask. The other side of the barrier
		  is explained in serialize_against_pte_lookup()
		
		  update_mmu_cache() will not have loaded the hash since current->trap
		  is not a 0x400 or 0x300, so just call hash_page_mm() here.
  Returns the mm_struct corresponding to the context ctx.
  mm_users == 0, the context may be in the process of being closed.
			 Most likely explanation is harmless - a dedicated
			  process has detached and these were cleared by the
			  PSL purge, but warn about it just in case
 Early return if the context is being  has been detached 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2014 IBM Corp.
	
	  MSI should never be set but need still need to provide this call
	  back.
	
	  Allocate a context to do cxl things too.  If we eventually do real
	  DMA ops, we'll need a default context to attach them to
 Should we do an AFU reset here ? 
 Grab a reader lock on afu. 
 Grab a reader lock on afu. 
	
	  If there are no AFU configuration records we won't have anything to
	  expose under the vPHB, so skip creating one, returning success since
	  this is still a valid case. This will also opt us out of EEH
	  handling since we won't have anything special to do if there are no
	  kernel drivers attached to the vPHB, and EEH handling is not yet
	  supported in the peer model.
	 The parent device is the adapter. Reuse the device node of
	  the adapter.
	  We don't seem to care what device node is used for the vPHB,
	  but tools such as lsvpd walk up the device parents looking
	  for a valid location code, so we might as well show devices
	  attached to the adapter as being located on that adapter.
 Alloc and setup PHB data structure 
 Setup parent in sysfs 
 Setup the PHB using arch provided callback 
 Scan the bus 
 Set release hook on root bus 
	 Claim resources. This might need some rework as well depending
	  whether we are doing probe-only or not, like assigning unassigned
	  resources etc...
 Add probed PCI devices to the device model 
 If there is no configuration record we won't have one of these 
	
	  We don't free phb here - that's handled by
	  pcibios_free_controller_deferred()
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2014 IBM Corp.
  Adapter attributes  
 Recompute the status only in native mode 
 CORE TB and PSL TB difference <= 16usecs ? 
	
	  See if we can lock the context mapping that's only allowed
	  when there are no contexts attached to the adapter. Once
	  taken this will also prevent any context from getting activated.
 In case reset failed release context lock 
 Perform a forced adapter reset 
  AFU master specific attributes  
  AFU attributes  
 Not safe to reset if it is currently in use 
 pHyp sets a per-AFU limit 
 only allowed when not in radix mode 
 can't change this if we have a user 
	
	  afu_deactivate_mode needs to be done outside the lock, prevent
	  other contexts coming in before we are ready:
	
	  Export raw AFU PCIe like config record. For now this is read only by
	  root - we can expand that later to be readable by non-root and maybe
	  even writable provided we have a good use-case. Once we support
	  exposing AFUs through a virtual PHB they will get that for free from
	  Linux' PCI infrastructure, but until then it's not clear that we
	  need it for anything since the main use case is just identifying
	  AFUs, which can be done via the vendor, device and class attributes.
 remove the err buffer bin attribute 
 conditionally create the add the binary file for error info buffer 
 reset the eb_len as we havent created the bin attr 
 SPDX-License-Identifier: GPL-2.0
 nothing to do 
 nothing to do, just move pointer 
 base adapter image header 
 number of entries in the list 
	          < -- MAX_CHUNK_SIZE = 4096  256 = 1048576 bytes -->
	  chunk 0  ----------------------------------------------------
	           | header   |  data                                 |
	           ----------------------------------------------------
	  chunk 1  ----------------------------------------------------
	           | data                                             |
	           ----------------------------------------------------
	  ....
	  chunk n  ----------------------------------------------------
	           | data                                             |
	           ----------------------------------------------------
 add adapter image header 
 image offset 
 copy data 
 fill in the list 
	
	  downloadvalidate the adapter image to the coherent
	  platform facility
 success of downloadvalidation operation 
			 The entire image has now been
			  downloaded and the validation has
			  been successfully performed.
			  After that, the partition should call
			  ibm,update-nodes and
			  ibm,update-properties to receive the
			  current configuration
	
	  Make sure reserved fields and bits are set to 0
 Allows one process to open the device by using a semaphore 
	 aligned buffer containing list entries which describes up to
	  1 megabyte of data (256 entries of 4096 bytes each)
	   Logical real address of buffer 0  -  Buffer 0 length in bytes
	   Logical real address of buffer 1  -  Buffer 1 length in bytes
	   Logical real address of buffer 2  -  Buffer 2 length in bytes
	   ....
	   ....
	   Logical real address of buffer N  -  Buffer N length in bytes
 reload the module 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2014 IBM Corp.
			
			  This shouldn't happen - the PSL treats these errors
			  as fatal and will have reset the AFU, so there's not
			  much point buffering multiple AFU errors.
			  OTOH if we DO ever see a storm of these come in it's
			  probably best that we log them somewhere:
		
		  We don't inherently need to sleep to handle this, but we do
		  need to get a ref to the task's mm, which we can't do from
		  irq context without the potential for a deadlock since it
		  takes the task_lock. An alternate option would be to keep a
		  reference to the task's mm the entire time it has cxl open,
		  but to do that we need to solve the issue where we hold a
		  ref to the mm, but the mm can hold a ref to the fd after an
		  mmap preventing anything from being cleaned up.
		
		  In some cases we might be able to handle the fault
		  immediately if hash_page would succeed, but we still need
		  the task's mm, which as above we can't get without a lock
			
			  This shouldn't happen - the PSL treats these errors
			  as fatal and will have reset the AFU, so there's not
			  much point buffering multiple AFU errors.
			  OTOH if we DO ever see a storm of these come in it's
			  probably best that we log them somewhere:
	
	  Look for the interrupt number.
	  On bare-metal, we know range 0 only contains the PSL
	  interrupt so we could start counting at range 1 and initialize
	  afu_irq at 1.
	  In a guest, range 0 also contains AFU interrupts, so it must
	  be counted for. Therefore we initialize afu_irq at 0 to take into
	  account the PSL interrupt.
	 
	  For code-readability, it just seems easier to go over all
	  the ranges on bare-metal and guest. The end result is the same.
 IRQ Domain? 
	
	  In native mode, range 0 is reserved for the multiplexed
	  PSL interrupt. It has been allocated when the AFU was initialized.
	 
	  In a guest, the PSL interrupt is not mutliplexed, but per-context,
	  and is the first interrupt from range 0. It still needs to be
	  allocated, so bump the count by one.
 Multiplexed PSL Interrupt 
	
	  Allocate names first.  If any fail, bail out before allocating
	  actual hardware IRQs.
 Add to tail so next look get the correct order 
 We've allocated all memory now, so let's do the irq allocations 
				
				  The very first interrupt of range 0 is
				  always the PSL interrupt, but we only
				  need to connect a handler for guests,
				  because there's one PSL interrupt per
				  context.
				  On bare-metal, the PSL interrupt is
				  multiplexed and was setup when the AFU
				  was configured.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2017 IBM Corp.
 No flags currently supported 
 on p9, some pci slots are not connected to a CAPP unit 
	
	  Dummy read buffer is 128-byte long, aligned on a
	  256-byte boundary and we need the physical address.
		
		  We currently don't support going back to PCI mode
		  However, we'll turn the invalidations off, so that
		  the firmware doesn't have to ack them and can do
		  things like reset, etc.. with no worries.
		  So always return EPERM (can't go back to PCI) or
		  EBUSY if we couldn't even turn off snooping
 DMA only supported on TVT1 for the time being 
  When switching the PHB to capi mode, the TVT#1 entry for
  the Partitionable Endpoint is set in bypass mode, like
  in PCI mode.
  Configure the device dma to use TVT#1, which is done
  by calling dma_set_mask() with a mask large enough.
		
		  Caller is keeping a reference on mm_users for as long
		  as XSL uses the memory context
	
	  The buffer we have to process can extend over several pages
	  and may also cover several VMAs.
	  We iterate over all the pages. The page size could vary
	  between VMAs.
			
			  We don't hold mm->mmap_lock while iterating, since
			  the lock is required by one of the lower-level page
			  fault processing functions and it could
			  create a deadlock.
			 
			  It means the VMAs can be altered between 2
			  loop iterations and we could theoretically
			  miss a page (however unlikely). But that's
			  not really a problem, as the driver will
			  retry access, get another page fault on the
			  missing page and call us again.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015 IBM Corp.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2014 IBM Corp.
		 If the adapter has gone down, we can assume that we
		  will PERST it and that will invalidate everything.
 XXX: Make this lookup faster with link from mm to ctx 
   Top 14 bits of VSID 
 Store calculated sstp hardware points for use later 
 print buffer content as integers when debugging 
	
	  We want to regroup up to 4 integers per line, which means they
	  need to be in the same pr_devel() statement
 DEBUG 
 Find a CXL adapter by it's number and increase it's refcount 
 start with context lock taken 
 We don't fail this so the user can inspect sysfs 
 no active contexts -> contexts_num == 0 
	
	  contexts lock taken -> contexts_num == -1
	  If not true then show a warning and force reset the lock.
	  This will happen when context_unlock was requested without
	  doing a context_lock.
	
	  we don't register the callback on P9. slb callack is only
	  used for the PSL8 MMU and CX4.
 SPDX-License-Identifier: GPL-2.0+
   Pvpanic MMIO Device Support
   Copyright (C) 2013 Fujitsu.
   Copyright (C) 2018 ZTE.
   Copyright (C) 2021 Oracle.
 initialize capability by RDPT 
 SPDX-License-Identifier: GPL-2.0+
   Pvpanic Device Support
   Copyright (C) 2013 Fujitsu.
   Copyright (C) 2018 ZTE.
   Copyright (C) 2021 Oracle.
 let this called before broken drm_fb_helper() 
 SPDX-License-Identifier: GPL-2.0+
   Pvpanic PCI Device Support
   Copyright (C) 2021 Oracle.
 initlize capability by RDPT 
 SPDX-License-Identifier: GPL-2.0-or-later
  SN Platform GRU Driver
               FILE OPERATIONS & DRIVER INITIALIZATION
  This file supports the user system call for file open, close, mmap, etc.
  This also incudes the driver initialization code.
   (C) Copyright 2020 Hewlett Packard Enterprise Development LP
   Copyright (c) 2008-2014 Silicon Graphics, Inc.  All Rights Reserved.
 Guaranteed user available resources on each node 
  gru_vma_close
  Called when unmapping a device mapping. Frees all gru resources
  and tables belonging to the vma.
  gru_file_mmap
  Called when mmapping the device.  Initializes the vma with a fault handler
  and private data structure necessary to allocate, track, and free the
  underlying pages.
  Create a new GRU context
  Get GRU configuration info (temp - for emulator testing)
  gru_file_unlocked_ioctl
  Called to update file attributes via IOCTL calls.
  Called at init time to build tables for all GRUs that are present in the
  system.
 -1 if no memory on blade 
	
	  We target the cores of a blade and not the hyperthreads themselves.
	  There is a max of 8 cores per socket and 2 sockets per blade,
	  making for a max total of 16 cores (i.e., 16 CPUs without
	  hyperthreading and 32 CPUs with hyperthreading).
  gru_init
  Called at boot or module load time to initialize the GRUs.
 ZZZZZZZZZZZZZZZZZZZ fixme 
 SPDX-License-Identifier: GPL-2.0-or-later
  SN Platform GRU Driver
             Dump GRU State
   Copyright (c) 2008 Silicon Graphics, Inc.  All Rights Reserved.
 Currently, only dump by gid is implemented 
 SPDX-License-Identifier: GPL-2.0-or-later
               GRU KERNEL MCS INSTRUCTIONS
   Copyright (c) 2008 Silicon Graphics, Inc.  All Rights Reserved.
 10 sec 
 Extract the status field from a kernel handle 
 setting CMDSTATUS bits must be last 
	
	  Stop speculation into the GSEG being mapped by the previous ALLOCATE.
	  The GSEG memory does not exist until the ALLOCATE completes.
	
	  Stop speculation into the GSEG being unmapped by the previous
	  DEALLOCATE.
 SPDX-License-Identifier: GPL-2.0-or-later
  SN Platform GRU Driver
             DRIVER TABLE MANAGER + GRU CONTEXT LOADUNLOAD
   Copyright (c) 2008 Silicon Graphics, Inc.  All Rights Reserved.
  Select a gru fault map to be used by the current cpu. Note that
  multiple cpus may be using the same map.
 	ZZZ should be inline but did not work on emulator
--------- ASID Management -------------------------------------------
   Initially, assign asids sequentially from MIN_ASID .. MAX_ASID.
   Once MAX is reached, flush the TLB & start over. However,
   some asids may still be in use. There won't be many (percentage wise) still
   in use. Search active contexts & determine the value of the first
   asid in use ("x"s below). Set "limit" to this value.
   This defines a block of assignable asids.
   When "limit" is reached, search forward from limit+1 and determine the
   next block of assignable asids.
   Repeat until MAX_ASID is reached, then start over again.
   Each time MAX_ASID is reached, increment the asid generation. Since
   the search for in-use asids only checks contexts with GRUs currently
   assigned, asids in some contexts will be missed. Prior to loading
   a context, the asid generation of the GTS asid is rechecked. If it
   doesn't match the current generation, a new asid will be assigned.
    	0---------------x------------x---------------------x----|
 	  ^-next	^-limit	   				^-MAX_ASID
  All asid manipulation & context loadingunloading is protected by the
  gs_lock.
 Hit the asid limit. Start over 
 Find the next chunk of unused asids 
				
				  empty range: reset the range limit and
				  start over
 Assign a new ASID to a thread context.  
  Clear n bits in a word. Return a word indicating the bits that were cleared.
  Optionally, build an array of chars that contain the bit numbers allocated.
  Check if a GRU has sufficient free resources to satisfy an allocation
  request. Note: GRU locks may or may not be held when this is called. If
  not held, recheck after acquiring the appropriate locks.
  Returns 1 if sufficient resources, 0 if not
  TLB manangment requires tracking all GRU chiplets that have loaded a GSEG
  context.
  Decrement the reference count on a GTS structure. Free the structure
  if the reference count goes to zero.
  Locate the GTS structure for the current thread.
  Allocate a thread state structure.
 zero out header 
  Allocate a vma private data structure.
  Find the thread state structure for the current thread.
  Allocate a new thread state for a GSEG. Note that races may allow
  another thread to race to create a gts.
  Free the GRU context assigned to the thread state.
  Prefetching cachelines help hardware performance.
  (Strictly a performance enhancement. Not functionally required).
 Flush CBE to hide race in context restart 
 CBEs may not be coherent. Flush them from cache 
 Let the CL flush complete 
  Load a GRU context by copying it from the thread data structure in memory
  to the GRU.
 For now, ints go to cpu 0 
  Update fields in an active CCH:
  	- retarget interrupts on local blade
  	- update sizeavail mask
  Update CCH tlb interrupt select. Required when all the following is true:
  	- task's GRU context is loaded into a GRU
  	- task is using interrupt notification for TLB faults
  	- task has migrated to a different cpu on the same blade where
  	  it was previously running.
  Check if a GRU context is allowed to use a specific chiplet. By default
  a context is assigned to any blade-local chiplet. However, users can
  override this.
  	Returns 1 if assignment allowed, 0 otherwise
  Unload the gru context if it is not assigned to the correct blade or
  chiplet. Misassignment can occur if the process migrates to a different
  blade or if the user changes the selected bladechiplet.
	
	  If the current task is the context owner, verify that the
	  context is correctly placed. This test is skipped for non-owner
	  references. Pthread apps use non-owner references to the CBRs.
  Insufficient GRU resources available on the local blade. Steal a context from
  a process. This is a hack until a _real_ resource scheduler is written....
				
			 	 We are grabbing locks out of order, so trylock is
			 	 needed. GTSs are usually not locked, so the odds of
			 	 success are high. If trylock fails, try to steal a
			 	 different GSEG.
  Assign a gru context.
  Scan the GRUs on the local blade & assign a GRU context.
  gru_nopage
  Map the user's GRU segment
  	Note: gru segments alway mmaped on GRU_GSEG_PAGESIZE boundaries.
 The following check ensures vaddr is a valid address in the VMA 
 true hack ZZZ 
 SPDX-License-Identifier: GPL-2.0-or-later
  SN Platform GRU Driver
               KERNEL SERVICES THAT USE THE GRU
   Copyright (c) 2008 Silicon Graphics, Inc.  All Rights Reserved.
  Kernel GRU Usage
  The following is an interim algorithm for management of kernel GRU
  resources. This will likely be replaced when we better understand the
  kerneluser requirements.
  Blade percpu resources reserved for kernel use. These resources are
  reserved whenever the the kernel context for the blade is loaded. Note
  that the kernel context is not guaranteed to be always available. It is
  loaded on demand & can be stolen by a user if the user demand exceeds the
  kernel demand. The kernel can always reload the kernel context but
  a SLEEP may be required!!!.
  Async Overview:
  	Each blade has one "kernel context" that owns GRU kernel resources
  	located on the blade. Kernel drivers use GRU resources in this context
  	for sending messages, zeroing memory, etc.
  	The kernel context is dynamically loaded on demand. If it is not in
  	use by the kernel, the kernel context can be unloaded & given to a user.
  	The kernel context will be reloaded when needed. This may require that
  	a context be stolen from a user.
  		NOTE: frequent unloadingreloading of the kernel context is
  		expensive. We are depending on batch schedulers, cpusets, sane
  		drivers or some other mechanism to prevent the need for frequent
 	 	stealingreloading.
  	The kernel context consists of two parts:
  		- 1 CB & a few DSRs that are reserved for each cpu on the blade.
  		  Each cpu has it's own private resources & does not share them
  		  with other cpus. These resources are used serially, ie,
  		  locked, used & unlocked  on each call to a function in
  		  grukservices.
  		  	(Now that we have dynamic loading of kernel contexts, I
  		  	 may rethink this & allow sharing between cpus....)
 		- Additional resources can be reserved long term & used directly
 		  by UV drivers located in the kernel. Drivers using these GRU
 		  resources can use asynchronous GRU instructions that send
 		  interrupts on completion.
 		  	- these resources must be explicitly lockedunlocked
 		  	- locked resources prevent (obviously) the kernel
 		  	  context from being unloaded.
 			- drivers using these resource directly issue their own
 			  GRU instruction and must waitcheck completion.
  		  When these resources are reserved, the caller can optionally
  		  associate a wait_queue with the resources and use asynchronous
  		  GRU instructions. When an async GRU instruction completes, the
  		  driver will do a wakeup on the event.
 GRU instruction attributes for all instructions 
 GRU cacheline size is always 64 bytes - even on arches with 128 byte lines 
 Default retry count for GRU errors on kernel instructions 
 Status of message queue sections 
----------------- RESOURCE MANAGEMENT -------------------------------------
 optimized for x86_64 
 CL 0 
 DW 1 
 CL 1 
 CL 2 
 First word in every message - used by mesq interface 
  Reload the blade's kernel context into a GRU chiplet. Called holding
  the bs_kgts_sema for READ. Will steal user contexts if necessary.
  Free all kernel contexts that are not currently in use.
    Returns 0 if all freed, else number of inuse context.
 Ignore busy contexts. Don't want to block here.  
  Lock & load the kernel context for the specified blade.
 Handle the case where migration occurred while waiting for the sema 
  Unlock the kernel context for the specified blade. Context is not
  unloaded but may be stolen before next use.
  Reserve & get pointers to the DSRCBRs reserved for the current cpu.
  	- returns with preemption disabled
  Free the current cpus reserved DSRCBR resources.
  Reserve GRU resources to be used asynchronously.
    Note: currently supports only 1 reservation per blade.
  	input:
  		blade_id  - blade on which resources should be reserved
  		cbrs	  - number of CBRs
  		dsr_bytes - number of DSR bytes needed
 	output:
 		handle to identify resource
 		(0 = async resources already reserved)
 Verify no resources already reserved 
 Resources changed. Unload context if already loaded 
  Release async resources previously reserved.
 	input:
 		han - handle to identify resources
  Wait for async GRU instructions to complete.
 	input:
 		han - handle to identify resources
  Lock previous reserved async GRU resources
 	input:
 		han - handle to identify resources
 	output:
 		cb  - pointer to first CBR
 		dsr - pointer to first DSR
  Unlock previous reserved async GRU resources
 	input:
 		han - handle to identify resources
----------------------------------------------------------------------
	
	  Locate kgts for cb. This algorithm is SLOW but
	  this function is rarely called (ie., almost never).
	  Performance does not matter.
 CBE not coherent 
------------------------------ MESSAGE QUEUES -----------------------------
 Internal status . These are NOT returned to the user. 
 try again 
  Saverestore the "present" flag that is in the second line of 2-line
  messages
  Create a message queue.
  	qlines - message queue size in cache lines. Includes 2-line header.
  Send a NOOP message to a message queue
  	Returns:
  		 0 - if queue is full after the send. This is the normal case
  		     but various races can change this.
 		-1 - if mesq sent successfully but queue not full
 		>0 - unexpected error. MQE_xxx returned
  Handle a gru_mesq full.
 Determine if switching to firstsecond half of q 
 Try to get lock for switching head pointer 
 Got the lock. Send optional NOP if queue not full, 
 Then flip queuehead to other half of queue. 
 If not successfully in swapping queue head, clear the hstatus lock 
  Handle a PUT failure. Note: if message was a 2-line message, one of the
  lines might have successfully have been written. Before sending the
  message, "present" must be cleared in BOTH lines to prevent the receiver
  from prematurely seeing the full message.
 experimentally determined 
	
	  Send a noop message in order to deliver a cross-partition interrupt
	  to the SSI that contains the target message queue. Normally, the
	  interrupt is automatically delivered by hardware following mesq
	  operations, but some error conditions require explicit delivery.
	  The noop message will trigger delivery. Otherwise partition failures
	  could cause unrecovered errors.
		
		  Don't indicate to the app to resend the message, as it's
		  already been successfully sent.  We simply send an OK
		  (rather than fail the send with MQE_UNEXPECTED_CB_ERR),
		  assuming that the other side is receiving enough
		  interrupts to get this message processed anyway.
  Handle a gru_mesq failure. Some of these failures are software recoverable
  or retryable.
  Send a message to a message queue
  	mqd	message queue descriptor
  	mesg	message. ust be vaddr within a GSEG
  	bytes	message size (<= 2 CL)
  Advance the receive pointer for the queue to the next message.
  Get next message from message queue. Return NULL if no message
  present. User must call next_message() to move to next message.
  	rmq	message queue
 skip NOOP messages 
 Wait for both halves of 2 line messages 
 ---------------------- GRU DATA COPY FUNCTIONS ---------------------------
  Load a DW from a global GPA. The GPA can be a memory or MMR address.
  Copy a block of data using the GRU resources
 ------------------- KERNEL QUICKTESTS RUN AT STARTUP ----------------
 	Temp - will delete after we gain confidence in the GRU		
 Need  1K cacheline aligned that does not cross page boundary 
 don't handle this CBR again 
  Debugging only. User hook for various kernel tests
  of driver & gru.
 SPDX-License-Identifier: GPL-2.0-or-later
  SN Platform GRU Driver
               PROC INTERFACES
  This file supports the proc interfaces for the GRU driver
   Copyright (c) 2008 Silicon Graphics, Inc.  All Rights Reserved.
 INDENT-OFF 
 SPDX-License-Identifier: GPL-2.0-or-later
  SN Platform GRU Driver
  		MMUOPS callbacks  + TLB flushing
  This file handles emu notifier callbacks from the core kernel. The callbacks
  are used to update the TLB in the GRU as a result of changes in the
  state of a process address space. This file also handles TLB invalidates
  from the GRU driver.
   Copyright (c) 2008 Silicon Graphics, Inc.  All Rights Reserved.
 ---------------------------------- TLB Invalidation functions --------
  get_tgh_handle
  Find a TGH to use for issuing a TLB invalidate. For GRUs that are on the
  local blade, use a fixed TGH that is a function of the blade-local cpu
  number. Normally, this TGH is private to the cpu & no contention occurs for
  the TGH. For offblade GRUs, select a random TGH in the range above the
  private TGHs. A spinlock is required to access this TGH & the lock must be
  released when the invalidate is completes. This sucks, but it is the best we
  can do.
  Note that the spinlock is IN the TGH handle so locking does not involve
  additional cache lines.
  gru_flush_tlb_range
  General purpose TLB invalidation function. This function scans every GRU in
  the ENTIRE system (partition) looking for GRUs where the specified MM has
  been accessed by the GRU. For each GRU found, the TLB must be invalidated OR
  the ASID invalidated. Invalidating an ASID causes a new ASID to be assigned
  on the next fault. This effectively flushes the ENTIRE TLB for the MM at the
  cost of (possibly) a large number of future TLBmisses.
  The current algorithm is optimized based on the following (somewhat true)
  assumptions:
  	- GRU contexts are not loaded into a GRU unless a reference is made to
  	  the data segment or control block (this is true, not an assumption).
  	  If a DSCB is referenced, the user will also issue instructions that
  	  cause TLBmisses. It is not necessary to optimize for the case where
  	  contexts are loaded but no instructions cause TLB misses. (I know
  	  this will happen but I'm not optimizing for it).
  	- GRU instructions to invalidate TLB entries are SLOOOOWWW - normally
  	  a few usec but in unusual cases, it could be longer. Avoid if
  	  possible.
  	- intrablade process migration between cpus is not frequent but is
  	  common.
  	- a GRU context is not typically migrated to a different GRU on the
  	  blade because of intrablade migration
 	- interblade migration is rare. Processes migrate their GRU context to
 	  the new blade.
 	- if interblade migration occurs, migration back to the original blade
 	  is very very rare (ie., no optimization for this case)
 	- most GRU instruction operate on a subset of the user REGIONS. Code
 	  & shared library regions are not likely targets of GRU instructions.
  To help improve the efficiency of TLB invalidation, the GMS data
  structure is maintained for EACH address space (MM struct). The GMS is
  also the structure that contains the pointer to the mmu callout
  functions. This structure is linked to the mm_struct for the address space
  using the mmu "register" function. The mmu interfaces are used to
  provide the callbacks for TLB invalidation. The GMS contains:
  	- asid[maxgrus] array. ASIDs are assigned to a GRU when a context is
  	  loaded into the GRU.
  	- asidmap[maxgrus]. bitmap to make it easier to find non-zero asids in
  	  the above array
 	- ctxbitmap[maxgrus]. Indicates the contexts that are currently active
 	  in the GRU for the address space. This bitmap must be passed to the
 	  GRU to do an invalidate.
  The current algorithm for invalidating TLBs is:
  	- scan the asidmap for GRUs where the context has been loaded, ie,
  	  asid is non-zero.
  	- for each gru found:
  		- if the ctxtmap is non-zero, there are active contexts in the
  		  GRU. TLB invalidate instructions must be issued to the GRU.
 		- if the ctxtmap is zero, no context is active. Set the ASID to
 		  zero to force a full TLB invalidation. This is fast but will
 		  cause a lot of TLB misses if the context is reloaded onto the
 		  GRU
 ZZZ TODO - handle huge pages 
  Flush the entire TLB on a chiplet.
  MMUOPS notifier callout functions
 ..._and_test() provides needed barrier 
  Setup TGH parameters. There are:
  	- 24 TGH handles per GRU chiplet
  	- a portion (MAX_LOCAL_TGH) of the handles are reserved for
  	  use by blade-local cpus
  	- the rest are used by off-blade cpus. This usage is
  	  less frequent than blade-local usage.
  For now, use 16 handles for local flushes, 8 for remote flushes. If the blade
  has less tan or equal to 16 cpus, each cpu has a unique handle that it can
  use.
 n = cpus rounded up to next power of 2 
		
		  shift count for converting local cpu# to TGH index
		       0 if cpus <= MAX_LOCAL_TGH,
		       1 if cpus <= 2MAX_LOCAL_TGH,
		       etc
 first starting TGH index to use for remote purges 
 SPDX-License-Identifier: GPL-2.0-or-later
  SN Platform GRU Driver
               FAULT HANDLER FOR GRU DETECTED TLB MISSES
  This file contains code that handles TLB misses within the GRU.
  These misses are reported either via interrupts or user polling of
  the user CB.
   Copyright (c) 2008 Silicon Graphics, Inc.  All Rights Reserved.
 Return codes for vtop functions 
  Test if a physical address is a valid GRU GSEG address
  Find the vma of a GRU segment. Caller must hold mmap_lock.
  Find and lock the gts that contains the specified user vaddr.
  Returns:
  	- gts with the mmap_lock locked for read and the GTS locked.
 	- NULL if vaddr invalid OR is not a valid GSEG vaddr.
  Unlock a GTS that was previously locked with gru_find_lock_gts().
  Set a CB.istatus to active using a user virtual address. This must be done
  just prior to a TFH RESTART. The new cb.istatus is an in-cache status ONLY.
  If the line is evicted, the status may be lost. The in-cache update
  is necessary to prevent the user from seeing a stale cb.istatus that will
  change as soon as the TFH restart is complete. Races may cause an
  occasional failure to clear the cb.istatus, but that is ok.
  Read & clear a TFM
  The GRU has an array of fault maps. A map is private to a cpu
  Only one cpu will be accessing a cpu's fault map.
  This function scans the cpu-private fault map & clears all bits that
  are set. The function returns a bitmap that indicates the bits that
  were cleared. Note that sense the maps may be updated asynchronously by
  the GRU, atomic operations must be used to clear bits.
 Helps on hardware, required for emulator 
	
	  Not functionally required but helps performance. (Required
	  on emulator)
  Atomic (interrupt context) & non-atomic (user context) functions to
  convert a vaddr into a physical address. The size of the page
  is returned in pageshift.
  	returns:
  		  0 - successful
  		< 0 - error code
  		  1 - (atomic only) try again in non-atomic context
  atomic_pte_lookup
  Convert a user virtual address to a physical address
  Only supports Intel large pages (2MB only) on x86_64.
 	ZZZ - hugepage support is incomplete
  NOTE: mmap_lock is already held on entry to this function. This
  guarantees existence of the page tables.
	
	  Atomic lookup is faster & usually works even if called in non-atomic
	  context.
 Mustcheck ms_range_active before loading PTEs 
  Flush a CBE from cache. The CBE is clean in the cache. Dirty the
  CBE cacheline so that the line will be written back to home agent.
  Otherwise the line may be silently dropped. This has no impact
  except on performance.
 make CL dirty 
  Preload the TLB with entries that may be required. Currently, preloading
  is implemented only for BCOPY. Preload  <tlb_preload_count> pages OR to
  the end of the bcopy tranfer, whichever is smaller.
  Drop a TLB entry into the GRU. The fault is described by info in an TFH.
 	Input:
 		cb    Address of user CBR. Null if not running in user context
  	Return:
  		  0 = dropin, exception, or switch to UPM successful
  		  1 = range invalidate active
  		< 0 = error code
	
	  NOTE: The GRU contains magic hardware that eliminates races between
	  TLB invalidates and TLB dropins. If an invalidate occurs
	  in the window between reading the TFH and the subsequent TLB dropin,
	  the dropin is ignored. This eliminates the need for additional locks.
	
	  Prefetch the CBE if doing TLB preloading
	
	  Error if TFH state is IDLE or FMM mode & the user issuing a UPM call.
	  Might be a hardware race OR a stupid user. Ignore FMM because FMM
	  is a transient state.
 TFH must be cache resident before reading ms_range_active 
	
	  TFH is cache resident - at least briefly. Fail the dropin
	  if a range invalidate is active.
 No asid (delayed unload). 
 Atomic failure switch CBR to UPM 
 FMM state on UPM call 
 TFH status did not show exception pending 
 TFH state was idle  - no miss pending 
 All errors (atomic & non-atomic) switch CBR to EXCEPTION state 
 Range invalidate active. Switch to UPM iff atomic 
  Process an external interrupt from the GRU. This interrupt is
  caused by a TLB miss.
  Note that this is the interrupt handler that is registered with linux
  interrupt handlers.
 Helps on hdw, required for emulator 
		
		  When hardware sets a bit in the faultmap, it implicitly
		  locks the GRU context so that it cannot be unloaded.
		  The gts cannot change until a TFH startwritestart command
		  is issued.
 Spurious interrupts can cause this. Ignore. 
		
		  This is running in interrupt context. Trylock the mmap_lock.
		  If it fails, retry the fault in user context.
 Helps on hdw, required for emulator 
  This interface is called as a result of a user detecting a "call OS" bit
  in a user CB. Normally means that a TLB fault has occurred.
  	cb - user virtual address of the CB
 sanity check the cb pointer 
	
	  CCH may contain stale data if ts_force_cch_reload is set.
  Fetch the exception detail information for a CB that terminated with
  an exception.
 CBE not coherent 
 make sure we are have current data 
  User request to unload a context. Content is saved for possible reload.
  User request to flush a range of virtual addresses from the GRU TLB
  (Mainly for testing).
  Fetch GSEG statisticss
	
	  The library creates arrays of contexts for threaded programs.
	  If no gts exists in the array, the context has never been used & all
	  statistics are implicitly 0.
  Register the current task as the user of the GSEG slice.
  Needed for TLB fault interrupt targeting.
 Select bladechiplet for GRU context 
 Register the current task as the GSEG owner 
 Set the CCH slice option 
 SPDX-License-Identifier: GPL-2.0-only
  lis3lv02d_spi - SPI glue layer for lis3lv02d
  Copyright (c) 2009 Daniel Mack <daniel@caiaq.de>
 power up the device 
 SPDX-License-Identifier: GPL-2.0-or-later
   lis3lv02d.c - ST LIS3LV02DL accelerometer driver
   Copyright (C) 2007-2008 Yan Burman
   Copyright (C) 2008 Eric Piel
   Copyright (C) 2008-2009 Pavel Machek
 joystick device poll interval in milliseconds 
 In milliseconds 
  The sensor can also generate interrupts (DRDY) but it's pretty pointless
  because they are generated even if the data do not change. So it's better
  to keep the interrupt for the free-fall event. The values are updated at
  40Hz (at the lowest frequency), but as it can be pretty time consuming on
  some low processor, we poll the sensor only at 20Hz... enough for the
  joystick.
  LIS3LV02D spec says 1024 LSBs corresponds 1 G -> 1LSB is 10001024 mG
  LIS302D spec says: 18 mG  digit
  LIS3_ACCURACY is used to increase accuracy of the intermediate
  calculation results.
 Sensitivity values for -2G +2G scale 
  LIS331DLH spec says 1LSBs corresponds 4G4096 -> 1LSB is 10001024 mG.
  Below macros defines sensitivity values for +-2G. Dataout bits for
  +-2G range is 12 bits so 4 bits adjustment must be done to get 12bit
  data from 16bit value. Currently this driver supports only 2G range.
 just like param_set_int() but does sanity-check so that it won't point
  over the axis array size
 In "12 bit right justified" mode, bit 6, bit 7, bit 8 = bit 5 
 12bits for 2G range, 13 bits for 4G range and 14 bits for 8G range 
  lis3lv02d_get_axis - For the given axis, give the value converted
  @axis:      1,2,3 - can also be negative
  @hw_values: raw values returned by the hardware
  Returns the converted value.
  lis3lv02d_get_xyz - Get X, Y and Z axis values from the accelerometer
  @lis3: pointer to the device struct
  @x:    where to store the X axis value
  @y:    where to store the Y axis value
  @z:    where to store the Z axis value
  Note that 40Hz input device can eat up about 10% CPU at 800MHZ
 Data: x, dummy, y, dummy, z 
 conversion btw sampling rate and the register values 
 ODR is Output Data Rate 
 Power-down mode, not sampling no need to sleep 
 LIS3 power on delay is quite long 
 # of possible values 
 Change interrupt cfg to data ready for selftest 
 Read directly to avoid axis remap 
 back to normal settings 
 Restore original interrupt configuration 
 Check against selftest acceptance limits 
 test passed 
  Order of registers in the list affects to order of the restore process.
  Perhaps it is a good idea to set interrupt enable register as a last one
  after all other configurations
 disable X,Y,Z axis and power down 
	
	  Common configuration
	  BDU: (12 bits sensors only) LSB and MSB values are not updated until
	       both have been read. So the value read will always be correct.
	  Set BOOT bit to refresh factory tuning values.
	
	  Update coordinates for the case where poll interval is 0 and
	  the chip in running purely under interrupt control
	
	  Be careful: on some HP laptops the bios force DD when on battery and
	  the lid is closed. This leads to interrupts as soon as a little move
	  is done.
 Dummy read to ack interrupt 
 already open 
 release the device 
	 make sure we are not going into copy_to_user() with
 Sysfs stuff 
	
	  SYSFS functions are fast visitors so put-call
	  immediately after the get-call. However, keep
	  chip running for a while and schedule delayed
	  suspend. This way periodic sysfs calls doesn't
	  suffer from relatively long power up time.
 Barrier after the sysfs remove 
 SYSFS may have left chip running. Turn off if necessary 
 pdata value + 1 to keep this backward compatible
 Xor to keep compatible with old pdata
 pdata value + 1 to keep this backward compatible
 Xor to keep compatible with old pdata
 Configure hipass filters 
  Initialise the accelerometer and the various subsystems.
  Should be rather independent of the bus system.
 12 bits for 2G 
	 passing in platform specific data is purely optional and only
 bail if we did not get an IRQ from the bus layer 
	
	  The sensor can generate interrupts for free-fall and direction
	  detection (distinguishable with FF_WU_SRC and DD_SRC) but to keep
	  the things simple and _fast_ we activate it only for free-fall, so
	  no need to read register (very slow with ACPI). For the same reason,
	  we forbid shared interrupts.
	 
	  IRQF_TRIGGER_RISING seems pointless on HP laptops because the
	  io-apic is not configurable (and generates a warning) but I keep it
	  in case of support for other hardware.
 SPDX-License-Identifier: GPL-2.0-only
  drivershwmonlis3lv02d_i2c.c
  Implements I2C interface for lis3lv02d (STMicroelectronics) accelerometer.
  Driver is based on corresponding SPI driver written by Daniel Mack
  (lis3lv02d_spi.c (C) 2009 Daniel Mack <daniel@caiaq.de> ).
  Copyright (C) 2009 Nokia Corporation andor its subsidiary(-ies).
  Contact: Samu Onkalo <samu.p.onkalo@nokia.com>
 Chip needs time to wakeup. Not mentioned in datasheet 
 7th bit enables address auto incrementation 
 power up the device 
 Default axis mapping but it can be overwritten by platform data 
 Provide power over the init call 
	
	  pm_runtime documentation says that devices should always
	  be powered on at resume. Pm_runtime turns them off after system
	  wide resume is complete.
 CONFIG_PM_SLEEP 
 CONFIG_PM 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2004 - 2006 rt2x00 SourceForge Project
  <http:rt2x00.serialmonkey.com>
  Module: eeprom_93cx6
  Abstract: EEPROM reader routines for 93cx6 chipsets.
  Supported chipsets: 93c46 & 93c66.
rt2x00.serialmonkey.com");
	
	  Add a short delay for the pulse to work.
	  According to the specifications the "maximum minimum"
	  time should be 450ns.
	
	  Add a short delay for the pulse to work.
	  According to the specifications the "maximum minimum"
	  time should be 450ns.
	
	  Clear all flags, and enable chip select.
	
	  kick a pulse.
	
	  Clear chip_select and data_in flags.
	
	  kick a pulse.
	
	  Clear data flags.
	
	  Start writing all bits.
		
		  Check if this bit needs to be set.
		
		  Write the bit to the eeprom register.
		
		  Kick a pulse.
	
	  Clear data flags.
	
	  Start reading all bits.
		
		  Clear data_in flag.
		
		  Read if the bit has been set.
  eeprom_93cx6_read - Read a word from eeprom
  @eeprom: Pointer to eeprom structure
  @word: Word index from where we should start reading
  @data: target pointer where the information will have to be stored
  This function will read the eeprom data as host-endian word
  into the given data pointer.
	
	  Initialize the eeprom register
	
	  Select the read opcode and the word to be read.
	
	  Read the requested 16 bits.
	
	  Cleanup eeprom register.
  eeprom_93cx6_multiread - Read multiple words from eeprom
  @eeprom: Pointer to eeprom structure
  @word: Word index from where we should start reading
  @data: target pointer where the information will have to be stored
  @words: Number of words that should be read.
  This function will read all requested words from the eeprom,
  this is done by calling eeprom_93cx6_read() multiple times.
  But with the additional change that while the eeprom_93cx6_read
  will return host ordered bytes, this method will return little
  endian words.
  eeprom_93cx6_readb - Read a byte from eeprom
  @eeprom: Pointer to eeprom structure
  @byte: Byte index from where we should start reading
  @data: target pointer where the information will have to be stored
  This function will read a byte of the eeprom data
  into the given data pointer.
	
	  Initialize the eeprom register
	
	  Select the read opcode and the byte to be read.
	
	  Read the requested 8 bits.
	
	  Cleanup eeprom register.
  eeprom_93cx6_multireadb - Read multiple bytes from eeprom
  @eeprom: Pointer to eeprom structure
  @byte: Index from where we should start reading
  @data: target pointer where the information will have to be stored
  @bytes: Number of bytes that should be read.
  This function will read all requested bytes from the eeprom,
  this is done by calling eeprom_93cx6_readb() multiple times.
  eeprom_93cx6_wren - set the write enable state
  @eeprom: Pointer to eeprom structure
  @enable: true to enable writes, otherwise disable writes
  Set the EEPROM write enable state to either allow or deny
  writes depending on the @enable value.
 start the command 
 create command to enabledisable 
  eeprom_93cx6_write - write data to the EEPROM
  @eeprom: Pointer to eeprom structure
  @addr: Address to write data to.
  @data: The data to write to address @addr.
  Write the @data to the specified @addr in the EEPROM and
  waiting for the device to finish writing.
  Note, since we do not expect large number of write operations
  we delay in between parts of the operation to avoid using excessive
  amounts of CPU time busy waiting.
 start the command 
 send write command 
 send data 
 get ready to check for busy 
 wait at-least 250ns to get DO to be the busy signal 
 wait for DO to go high to signify finish 
 SPDX-License-Identifier: GPL-2.0-or-later
  ee1004 - driver for DDR4 SPD EEPROMs
  Copyright (C) 2017-2019 Jean Delvare
  Based on the at24 driver:
  Copyright (C) 2005-2007 David Brownell
  Copyright (C) 2008 Wolfram Sang, Pengutronix
  DDR4 memory modules use special EEPROMs following the Jedec EE1004
  specification. These are 512-byte EEPROMs using a single I2C address
  in the 0x50-0x57 range for data. One of two 256-byte page is selected
  by writing a command to I2C address 0x36 or 0x37 on the same I2C bus.
  Therefore we need to request these 2 additional addresses, and serialize
  access to all such EEPROMs with a single mutex.
  We assume it is safe to read up to 32 bytes at once from these EEPROMs.
  We use SMBus access even if I2C is available, these EEPROMs are small
  enough, and reading from them infrequent enough, that we favor simplicity
  over performance.
  Mutex protects ee1004_set_page and ee1004_dev_count, and must be held
  from page selection to end of read.
-------------------------------------------------------------------------
 Nack means page 1 is selected 
 Anything else is a real error, bail out 
 Ack means page 0 is selected, returned value meaningless 
 Data is ignored 
	
	  Don't give up just yet. Some memory modules will select the page
	  but not ack the command. Check which page is selected now.
 Can't cross page boundaries 
	
	  Read data from chip, protecting against concurrent access to
	  other EE1004 SPD EEPROMs on the same adapter.
 Make sure we can operate on this adapter 
 Use 2 dummy devices for page select command 
 Remember current page to avoid unneeded page select 
 Remove page select clients if this is the last device 
-------------------------------------------------------------------------
 SPDX-License-Identifier: GPL-2.0-only
  Driver for 93xx46 EEPROMs
  (C) 2011 DENX Software Engineering, Anatolij Gustschin <agust@denx.de>
 The opcode in front of the address is three bits. 
 have to wait at least Tcsl ns 
 The opcode in front of the address is three bits. 
 have to wait at least Tcsl ns 
 The opcode in front of the address is three bits. 
 have to wait program cycle time Twc ms 
 only write even number of bytes on 16-bit devices 
 erasewrite enable 
 erasewrite disable 
 The opcode in front of the address is three bits. 
 have to wait erase cycle time Tec ms 
 SPDX-License-Identifier: GPL-2.0-only
  max6875.c - driver for MAX6874MAX6875
  Copyright (C) 2005 Ben Gardner <bgardner@wabtec.com>
  Based on eeprom.c
  The MAX6875 has a bank of registers and two banks of EEPROM.
  Address ranges are defined as follows:
    0x0000 - 0x0046 = configuration registers
    0x8000 - 0x8046 = configuration EEPROM
    0x8100 - 0x82FF = user EEPROM
  This driver makes the user EEPROM available for read.
  The registers & config EEPROM should be accessed via i2c-dev.
  The MAX6875 ignores the lowest address bit, so each chip responds to
  two addresses - 0x500x51 and 0x520x53.
  Note that the MAX6875 uses i2c_smbus_write_byte_data() to set the read
  address, so this driver is destructive if loaded for the wrong EEPROM chip.
 The MAX6875 can only readwrite 16 bytes at a time 
 USER EEPROM is at addresses 0x8100 - 0x82FF 
 MAX6875 commands 
 Each client has this additional data 
 select the eeprom address 
 refresh slices which contain requested bytes 
 Only bind to even addresses 
 A fake client is created on the odd address 
 Init real i2c_client 
 SPDX-License-Identifier: GPL-2.0-or-later
  at25.c -- support most SPI EEPROMs, such as Atmel AT25 models
 	     and Cypress FRAMs FM25 models
  Copyright (C) 2006 David Brownell
  NOTE: this is an EEPROM driver.  The vagaries of product naming
  mean that some AT25 products are EEPROMs, and others are FLASH.
  Handle FLASH chips with the driversmtddevicesm25p80.c driver,
  not this one!
  EEPROMs that can be used with this driver include, for example:
    AT25M02, AT25128B
 serial number length 
 latch the write enable 
 reset the write enable 
 read status register 
 write status register 
 read byte(s) 
 write byte(s)sector 
 enter sleep mode 
 read device ID 
 read SN 
 nRDY = write-in-progress 
 write enable (latched) 
 BP for software writeprotect 
 writeprotect enable 
 Additional address bit in instr 
 ID length 
 24 bit addresses, up to 2 MBytes 
 Specs often allow 5 msec for a page write, sometimes 20 msec;
  it's important to recover from write timeouts.
-------------------------------------------------------------------------
 bytes 
 81624-bit address is written MSB first 
 case 3 
 can't happen: for better codegen 
	 Read it all at once.
	 
	  REVISIT that's potentially a problem with large chips, if
	  other devices on the bus need to be accessed regularly or
	  this chip is clocked very slowly
  read extra registers as ID or serial number
 Temp buffer starts with command and address 
	 For write, rollover is within the page ... so we write at
	  most one page, then manually roll over to the next page.
 81624-bit address is written MSB first 
 case 3 
 can't happen: for better codegen 
 Write as much of a page as we can 
		 REVISIT this should detect (or prevent) failed writes
		  to readonly sections of the EEPROM...
 Wait for non-busy status 
 at HZ=100, this is sloooow 
-------------------------------------------------------------------------
 Chip description 
	 Ping the chip ... the status register is pretty portable,
	  unlike probing manufacturer IDs.  We do expect that system
	  firmware didn't write it in the past few milliseconds!
 Get ID of chip 
 set size found in ID 
 swap byte order 
 For now we only support 81624 bit addressing 
-------------------------------------------------------------------------
 SPDX-License-Identifier: GPL-2.0-only
    Copyright (C) 2016 T-Platforms. All Rights Reserved.
  IDT PCIe-switch NTB Linux driver
  Contact Information:
  Serge Semin <fancer.lancer@gmail.com>, <Sergey.Semin@t-platforms.ru>
            NOTE of the IDT 89HPESx SMBus-slave interface driver
     This driver primarily is developed to have an access to EEPROM device of
  IDT PCIe-switches. IDT provides a simple SMBus interface to perform IO-
  operations fromto EEPROM, which is located at private (so called Master)
  SMBus of switches. Using that interface this the driver creates a simple
  binary sysfs-file in the device directory:
  sysbusi2cdevices<bus>-<devaddr>eeprom
  In case if read-only flag is specified in the dts-node of device desription,
  User-space applications won't be able to write to the EEPROM sysfs-node.
     Additionally IDT 89HPESx SMBus interface has an ability to writeread
  data of device CSRs. This driver exposes debugf-file to perform simple IO
  operations using that ability for just basic debug purpose. Particularly
  next file is created in the specific debugfs-directory:
  syskerneldebugidt_csr
  Format of the debugfs-node is:
  $ cat syskerneldebugidt_csr<bus>-<devaddr><devname>;
  <CSR address>:<CSR value>
  So reading the content of the file gives current CSR address and it value.
  If User-space application wishes to change current CSR address,
  it can just write a proper value to the sysfs-file:
  $ echo "<CSR address>" > syskerneldebugidt_csr<bus>-<devaddr><devname>
  If it wants to change the CSR value as well, the format of the write
  operation is:
  $ echo "<CSR address>:<CSR value>" > \
         syskerneldebugidt_csr<bus>-<devaddr><devname>;
  CSR address and value can be any of hexadecimal, decimal or octal format.
  csr_dbgdir - CSR readwrite operations Debugfs directory
  struct idt_89hpesx_dev - IDT 89HPESx device data structure
  @eesize:	Size of EEPROM in bytes (calculated from "idt,eecompatible")
  @eero:	EEPROM Read-only flag
  @eeaddr:	EEPROM custom address
  @inieecmd:	Initial cmd value for EEPROM readwrite operations
  @inicsrcmd:	Initial cmd value for CSR readwrite operations
  @iniccode:	Initialial command code value for IO-operations
  @csr:	CSR address to perform read operation
  @smb_write:	SMBus write method
  @smb_read:	SMBus read method
  @smb_mtx:	SMBus mutex
  @client:	i2c client used to perform IO operations
  @ee_file:	EEPROM readwrite sysfs-file
  struct idt_smb_seq - sequence of data to be readwritten fromto IDT 89HPESx
  @ccode:	SMBus command code
  @bytecnt:	Byte count of operation
  @data:	Data to by written
  struct idt_eeprom_seq - sequence of data to be readwritten fromto EEPROM
  @cmd:	Transaction CMD
  @eeaddr:	EEPROM custom address
  @memaddr:	Internal memory address of EEPROM
  @data:	Data to be written at the memory address
  struct idt_csr_seq - sequence of data to be readwritten fromto CSR
  @cmd:	Transaction CMD
  @csraddr:	Internal IDT device CSR address
  @data:	Data to be readwritten fromto the CSR address
  SMBus command code macros
  @CCODE_END:		Indicates the end of transaction
  @CCODE_START:	Indicates the start of transaction
  @CCODE_CSR:		CSR readwrite transaction
  @CCODE_EEPROM:	EEPROM readwrite transaction
  @CCODE_BYTE:		Supplied data has BYTE length
  @CCODE_WORD:		Supplied data has WORD length
  @CCODE_BLOCK:	Supplied data has variable length passed in bytecnt
 			byte right following CCODE byte
  EEPROM command macros
  @EEPROM_OP_WRITE:	EEPROM write operation
  @EEPROM_OP_READ:	EEPROM read operation
  @EEPROM_USA:		Use specified address of EEPROM
  @EEPROM_NAERR:	EEPROM device is not ready to respond
  @EEPROM_LAERR:	EEPROM arbitration loss error
  @EEPROM_MSS:		EEPROM misplace start & stop bits error
  @EEPROM_WR_CNT:	Bytes count to perform write operation
  @EEPROM_WRRD_CNT:	Bytes count to write before reading
  @EEPROM_RD_CNT:	Bytes count to perform read operation
  @EEPROM_DEF_SIZE:	Fall back size of EEPROM
  @EEPROM_DEF_ADDR:	Defatul EEPROM address
  @EEPROM_TOUT:	Timeout before retry read operation if eeprom is busy
  CSR command macros
  @CSR_DWE:		Enable all four bytes of the operation
  @CSR_OP_WRITE:	CSR write operation
  @CSR_OP_READ:	CSR read operation
  @CSR_RERR:		Read operation error
  @CSR_WERR:		Write operation error
  @CSR_WR_CNT:		Bytes count to perform write operation
  @CSR_WRRD_CNT:	Bytes count to write before reading
  @CSR_RD_CNT:		Bytes count to perform read operation
  @CSR_MAX:		Maximum CSR address
  @CSR_DEF:		Default CSR address
  @CSR_REAL_ADDR:	CSR real unshifted address
  IDT 89HPESx basic register
  @IDT_VIDDID_CSR:	PCIe VID and DID of IDT 89HPESx
  @IDT_VID_MASK:	Mask of VID
  IDT 89HPESx can send NACK when new command is sent before previous one
  fininshed execution. In this case driver retries operation
  certain times.
  @RETRY_CNT:		Number of retries before giving up and fail
  @idt_smb_safe:	Generate a retry loop on corresponding SMBus method
===========================================================================
                          i2c bus level IO-operations
 ===========================================================================
  idt_smb_write_byte() - SMBus write method when I2C_SMBUS_BYTE_DATA operation
                         is only available
  @pdev:	Pointer to the driver data
  @seq:	Sequence of data to be written
 Loop over the supplied data sending byte one-by-one 
 Collect the command code byte 
 Send data to the device 
  idt_smb_read_byte() - SMBus read method when I2C_SMBUS_BYTE_DATA operation
                         is only available
  @pdev:	Pointer to the driver data
  @seq:	Buffer to read data to
 Loop over the supplied buffer receiving byte one-by-one 
 Collect the command code byte 
 Read data from the device 
  idt_smb_write_word() - SMBus write method when I2C_SMBUS_BYTE_DATA and
                         I2C_FUNC_SMBUS_WORD_DATA operations are available
  @pdev:	Pointer to the driver data
  @seq:	Sequence of data to be written
 Calculate the even count of data to send 
 Loop over the supplied data sending two bytes at a time 
 Collect the command code byte 
 Send word data to the device 
 If there is odd number of bytes then send just one last byte 
 Collect the command code byte 
 Send byte data to the device 
  idt_smb_read_word() - SMBus read method when I2C_SMBUS_BYTE_DATA and
                        I2C_FUNC_SMBUS_WORD_DATA operations are available
  @pdev:	Pointer to the driver data
  @seq:	Buffer to read data to
 Calculate the even count of data to send 
 Loop over the supplied data reading two bytes at a time 
 Collect the command code byte 
 Read word data from the device 
 If there is odd number of bytes then receive just one last byte 
 Collect the command code byte 
 Read last data byte from the device 
  idt_smb_write_block() - SMBus write method when I2C_SMBUS_BLOCK_DATA
                          operation is available
  @pdev:	Pointer to the driver data
  @seq:	Sequence of data to be written
 Return error if too much data passed to send 
 Collect the command code byte 
 Send block of data to the device 
  idt_smb_read_block() - SMBus read method when I2C_SMBUS_BLOCK_DATA
                         operation is available
  @pdev:	Pointer to the driver data
  @seq:	Buffer to read data to
 Return error if too much data passed to send 
 Collect the command code byte 
 Read block of data from the device 
  idt_smb_write_i2c_block() - SMBus write method when I2C_SMBUS_I2C_BLOCK_DATA
                              operation is available
  @pdev:	Pointer to the driver data
  @seq:	Sequence of data to be written
  NOTE It's usual SMBus write block operation, except the actual data length is
  sent as first byte of data
 Return error if too much data passed to send 
 Collect the data to send. Length byte must be added prior the data 
 Collect the command code byte 
 Send length and block of data to the device 
  idt_smb_read_i2c_block() - SMBus read method when I2C_SMBUS_I2C_BLOCK_DATA
                             operation is available
  @pdev:	Pointer to the driver data
  @seq:	Buffer to read data to
  NOTE It's usual SMBus read block operation, except the actual data length is
  retrieved as first byte of data
 Return error if too much data passed to send 
 Collect the command code byte 
 Read length and block of data from the device 
 Copy retrieved data to the output data buffer 
===========================================================================
                           EEPROM IO-operations
 ===========================================================================
  idt_eeprom_read_byte() - read just one byte from EEPROM
  @pdev:	Pointer to the driver data
  @memaddr:	Start EEPROM memory address
  @data:	Data to be written to EEPROM
 Initialize SMBus sequence fields 
	
	  Sometimes EEPROM may respond with NACK if it's busy with previous
	  operation, so we need to perform a few attempts of read cycle
 Send EEPROM memory address to read data from 
 Perform read operation 
 Restart read operation if the device is busy 
 Check whether IDT successfully read data from EEPROM 
 Save retrieved data and exit the loop 
 Return the status of operation 
  idt_eeprom_write() - EEPROM write operation
  @pdev:	Pointer to the driver data
  @memaddr:	Start EEPROM memory address
  @len:	Length of data to be written
  @data:	Data to be written to EEPROM
 Initialize SMBus sequence fields 
 Send data byte-by-byte, checking if it is successfully written 
 Lock IDT SMBus device 
 Perform write operation 
		
		  Check whether the data is successfully written by reading
		  from the same EEPROM memory address.
 Check whether the read byte is the same as written one 
 Unlock IDT SMBus device 
  idt_eeprom_read() - EEPROM read operation
  @pdev:	Pointer to the driver data
  @memaddr:	Start EEPROM memory address
  @len:	Length of data to read
  @buf:	Buffer to read data to
 Read data byte-by-byte, retrying if it wasn't successful 
 Lock IDT SMBus device 
 Just read the byte to the buffer 
 Unlock IDT SMBus device 
 Return error if read operation failed 
===========================================================================
                           CSR IO-operations
 ===========================================================================
  idt_csr_write() - CSR write operation
  @pdev:	Pointer to the driver data
  @csraddr:	CSR address (with no two LS bits)
  @data:	Data to be written to CSR
 Initialize SMBus sequence fields 
 Lock IDT SMBus device 
 Perform write operation 
 Send CSR address to read data from 
 Perform read operation 
 Check whether IDT successfully retrieved CSR data 
 Unlock IDT SMBus device 
  idt_csr_read() - CSR read operation
  @pdev:	Pointer to the driver data
  @csraddr:	CSR address (with no two LS bits)
  @data:	Data to be written to CSR
 Initialize SMBus sequence fields 
 Lock IDT SMBus device 
 Send CSR register address before reading it 
 Perform read operation 
 Check whether IDT successfully retrieved CSR data 
 Save data retrieved from IDT 
 Unlock IDT SMBus device 
===========================================================================
                           Sysfsdebugfs-nodes IO-operations
 ===========================================================================
  eeprom_write() - EEPROM sysfs-node write callback
  @filep:	Pointer to the file system node
  @kobj:	Pointer to the kernel object related to the sysfs-node
  @attr:	Attributes of the file
  @buf:	Buffer to write data to
  @off:	Offset at which data should be written to
  @count:	Number of bytes to write
 Retrieve driver data 
 Perform EEPROM write operation 
  eeprom_read() - EEPROM sysfs-node read callback
  @filep:	Pointer to the file system node
  @kobj:	Pointer to the kernel object related to the sysfs-node
  @attr:	Attributes of the file
  @buf:	Buffer to write data to
  @off:	Offset at which data should be written to
  @count:	Number of bytes to write
 Retrieve driver data 
 Perform EEPROM read operation 
  idt_dbgfs_csr_write() - CSR debugfs-node write callback
  @filep:	Pointer to the file system file descriptor
  @buf:	Buffer to read data from
  @count:	Size of the buffer
  @offp:	Offset within the file
  It accepts either "0x<reg addr>:0x<value>" for saving register address
  and writing value to specified DWORD register or "0x<reg addr>" for
  just saving register address in order to perform next read operation.
  WARNING No spaces are allowed. Incoming string must be strictly formated as:
  "<reg addr>:<value>". Register address must be aligned within 4 bytes
  (one DWORD).
 Copy data from User-space 
 Find position of colon in the buffer 
	
	  If there is colon passed then new CSR value should be parsed as
	  well, so allocate buffer for CSR address substring.
	  If no colon is found, then string must have just one number with
	  no new CSR value
 Copy the register address to the substring buffer 
 Register value must follow the colon 
 if (str_colon == NULL)  {
 Just to shut warning up 
 Convert CSR address to u32 value 
 Check whether passed register address is valid 
 Shift register address to the right so to have u16 address 
 Parse new CSR value and send it to IDT, if colon has been found 
 Free memory only if colon has been found 
 Free buffer allocated for data retrieved from User-space 
  idt_dbgfs_csr_read() - CSR debugfs-node read callback
  @filep:	Pointer to the file system file descriptor
  @buf:	Buffer to write data to
  @count:	Size of the buffer
  @offp:	Offset within the file
  It just prints the pair "0x<reg addr>:0x<value>" to passed buffer.
 Perform CSR read operation 
 Shift register address to the left so to have real address 
 Print the "0x<reg addr>:0x<value>" to buffer 
 Copy data to User-space 
  eeprom_attribute - EEPROM sysfs-node attributes
  NOTE Size will be changed in compliance with OF node. EEPROM attribute will
  be read-only as well if the corresponding flag is specified in OF node.
  csr_dbgfs_ops - CSR debugfs-node readwrite operations
===========================================================================
                        Driver initdeinit methods
 ===========================================================================
  idt_set_defval() - disable EEPROM access by default
  @pdev:	Pointer to the driver data
 If OF info is missing then use next values 
  idt_ee_match_id() - check whether the node belongs to compatible EEPROMs
 Search through the device name 
  idt_get_fw_data() - get IDT i2c-device parameters from device tree
  @pdev:	Pointer to the driver data
 If there is no fwnode EEPROM device, then set zero size 
 Retrieve EEPROM size 
 Get custom EEPROM address from 'reg' attribute 
 Check EEPROM 'read-only' flag 
 if (!fwnode_property_read_bool(node, "read-only")) 
  idt_create_pdev() - create and init data structure of the driver
  @client:	i2c client of IDT PCIe-switch device
 Allocate memory for driver data 
 Initialize basic fields of the data 
 Read firmware nodes information 
 Initialize basic CSR CMD field - use full DWORD-sized rw ops 
 Enable Packet Error Checking if it's supported by adapter 
 PEC is unsupported  {
  idt_free_pdev() - free data structure of the driver
  @pdev:	Pointer to the driver data
 Clear driver data from device private field 
  idt_set_smbus_ops() - set supported SMBus operations
  @pdev:	Pointer to the driver data
  Return status of smbus check operations
 Check i2c adapter read functionality 
 no supported smbus read operations  {
 Check i2c adapter write functionality 
 no supported smbus write operations  {
 Initialize IDT SMBus slave interface mutex 
  idt_check_dev() - check whether it's really IDT 89HPESx device
  @pdev:	Pointer to the driver data
  Return status of i2c adapter check operation
 Read VID and DID directly from IDT memory space 
 Check whether it's IDT device 
  idt_create_sysfs_files() - create sysfs attribute files
  @pdev:	Pointer to the driver data
  Return status of operation
 Don't do anything if EEPROM isn't accessible 
 Allocate memory for attribute file 
 Copy the declared EEPROM attr structure to change some of fields 
 In case of read-only EEPROM get rid of write ability 
 Create EEPROM sysfs file 
  idt_remove_sysfs_files() - remove sysfs attribute files
  @pdev:	Pointer to the driver data
 Don't do anything if EEPROM wasn't accessible 
 Remove EEPROM sysfs file 
  idt_create_dbgfs_files() - create debugfs files
  @pdev:	Pointer to the driver data
 Create Debugfs directory for CSR file 
 Create Debugfs file for CSR readwrite operations 
  idt_remove_dbgfs_files() - remove debugfs files
  @pdev:	Pointer to the driver data
 Remove CSR directory and it sysfs-node 
  idt_probe() - IDT 89HPESx driver probe() callback method
 Create driver data 
 Set SMBus operations 
 Check whether it is truly IDT 89HPESx device 
 Create sysfs files 
 Create debugfs files 
  idt_remove() - IDT 89HPESx driver remove() callback method
 Remove debugfs files first 
 Remove sysfs files 
 Discard driver data structure 
  ee_ids - array of supported EEPROMs
  idt_ids - supported IDT 89HPESx devices
 No SMBus-slave iface 
 No SMBus-slave iface 
 END OF LIST  }
  idt_driver - IDT 89HPESx driver structure
  idt_init() - IDT 89HPESx driver init() callback method
 Create Debugfs directory first 
 Add new i2c-device driver 
  idt_exit() - IDT 89HPESx driver exit() callback method
 Discard debugfs directory and all files if any 
 Unregister i2c-device driver 
 SPDX-License-Identifier: GPL-2.0-only
  EEPROMs access control driver for display configuration EEPROMs
  on DigsyMTC board.
  (C) 2011 DENX Software Engineering, Anatolij Gustschin <agust@denx.de>
  FIXME: this driver is used on a device-tree probed platform: it
  should be defined as a bit-banged SPI device and probed from the device
  tree and not like this with static grabbing of a few numbered GPIO
  lines at random.
  Add proper SPI and EEPROM in archpowerpcbootdtsdigsy_mtc.dts
  and delete this driver.
 enable 
 disable 
 SPDX-License-Identifier: GPL-2.0-or-later
  at24.c - handle most I2C EEPROMs
  Copyright (C) 2005-2007 David Brownell
  Copyright (C) 2008 Wolfram Sang, Pengutronix
 Address pointer is 16 bit. 
 sysfs-entry will be read-only. 
 sysfs-entry will be world-readable. 
 Take always 8 addresses (24c00). 
 Factory-programmed serial number. 
 Factory-programmed mac address. 
 Does not auto-rollover reads to the next slave address. 
  I2C EEPROMs from most vendors are inexpensive and mostly interchangeable.
  Differences between different vendor product lines (like Atmel AT24C or
  MicroChip 24LC, etc) won't much matter for typical readwrite access.
  There are also I2C RAM chips, likewise interchangeable. One example
  would be the PCF8570, which acts like a 24c02 EEPROM (256 bytes).
  However, misconfiguration can lose data. "Set 16-bit memory address"
  to a part with 8-bit addressing will overwrite data. Writing with too
  big a page size also loses data. And it's not safe to assume that the
  conventional addresses 0x50..0x57 only hold eeproms; a PCF8563 RTC
  uses 0x51, for just one example.
  Accordingly, explicit board-specific configuration data should be used
  in almost all cases. (One partial exception is an SMBus used to access
  "SPD" data for DRAM sticks. Those only use 24c02 EEPROMs.)
  So this driver uses "new style" I2C driver binding, expecting to be
  told what devices exist. That may be in archXmach-Yboard-Z.c or
  similar kernel-resident tables; or, configuration data coming from
  a bootloader.
  Other than binding model, current differences from "eeprom" driver are
  that this one handles write access and isn't restricted to 24c02 devices.
  It also handles larger devices (32 kbit and up) with two-byte addresses,
  which won't work on pure SMBus systems.
	
	  Lock protects against activities from other Linux tasks,
	  but not from changes by other I2C masters.
	
	  Some chips tie up multiple I2C addresses; dummy devices reserve
	  them for us, and we'll use them with SMBus calls.
  This parameter is to help this driver avoid blocking other drivers out
  of I2C for potentially troublesome amounts of time. With a 100 kHz I2C
  clock, one 256 byte read takes about 143 second which is excessive;
  but the 1170 second it takes at 400 kHz may be quite reasonable; and
  at 1 MHz (Fm+) a 1430 second delay could easily be invisible.
  This value is forced to be a power of two so that writes align on pages.
  Specs often allow 5 msec for a page write, sometimes 20 msec;
  it's important to recover from write timeouts.
	
	  Hide VAIO private settings to regular users:
	  - BIOS passwords: bytes 0x00 to 0x0f
	  - UUID: bytes 0x10 to 0x1f
	  - Serial number: 0xc0 to 0xdf
 needs 8 addresses as A0-A2 are ignored 
 old variants can't be handled with this generic entry! 
 spd is a 24c02 in memory DIMMs 
 24c02_vaio is a 24c02 on some Sony laptops 
 24rf08 quirk is handled at i2c-core 
 identical to 24c08 ? 
 END OF LIST  }
 END OF LIST  },
 END OF LIST  }
  This routine supports chips which consume multiple I2C addresses. It
  computes the addressing information to be used for a given rw request.
  Assumes that sanity checks for offset happened at sysfs-layer.
  Slave address and byte offset derive from the offset. Always
  set the byte address; on a multi-master board, another master
  may have changed the chip's "current" address pointer.
	
	  In case of multi-address chips that don't rollover reads to
	  the next slave address: truncate the count to the slave boundary,
	  so that the read never straddles slaves.
 adjust offset for mac and serial read ops 
		
		  The timestamp shall be taken before the actual operation
		  to avoid a premature timeout in case of high CPU load.
  Note that if the hardware write-protect pin is pulled high, the whole
  chip is normally write protected. But there are plenty of product
  variants here, including OTP fuses and partial chip protect.
  We only use page mode writes; the alternative is sloooow. These routines
  write at most one page.
 write_max is at most a page 
 Never roll over backwards, to the start of this page 
		
		  The timestamp shall be taken before the actual operation
		  to avoid a premature timeout in case of high CPU load.
	
	  Read data from chip, protecting against concurrent updates
	  from this host, but not from other I2C masters.
	
	  Write data to chip, protecting against concurrent updates
	  from this host, but not from other I2C masters.
	
	  The I2C core allows OF nodes compatibles to match against the
	  I2C device ID table as a fallback, so check not only if an OF
	  node is present but also if it matches an OF device ID entry.
 EUI-48 starts from 0x9a, EUI-64 from 0x98 
		
		  For 16 bit address pointers, the word address must contain
		  a '10' sequence in bits 11 and 10 regardless of the
		  intended position of the address pointer.
		
		  Otherwise the word address must begin with a '10' sequence,
		  regardless of the intended address.
		
		  This is slow, but we can't know all eeproms, so we better
		  play safe. Specifying custom eeprom-types via device tree
		  or properties is recommended anyhow.
 use dummy devices for multiple-address chips 
	
	  We initialize nvmem_config.id to NVMEM_DEVID_AUTO even if the
	  label property is set as some platform can have multiple eeproms
	  with same label and we can not register each of those with same
	  label. Failing to register those eeproms trigger cascade failure
	  on such platform.
	
	  Perform a one-byte test read to verify that the chip is functional,
	  unless powering on the device is to be avoided during probe (i.e.
	  it's powered off right now).
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 1998, 1999  Frodo Looijaard <frodol@dds.nl> and
                            Philip Edelbrock <phil@netroedge.com>
  Copyright (C) 2003 Greg Kroah-Hartman <greg@kroah.com>
  Copyright (C) 2003 IBM Corp.
  Copyright (C) 2004 Jean Delvare <jdelvare@suse.de>
 Addresses to scan 
 Size of EEPROM in bytes 
 possible types of eeprom devices 
 Each client has this additional data 
 bitfield, bit!=0 if slice is valid 
 In jiffies, 8 slices 
 Register values 
 Only refresh slices which contain requested bytes 
	 Hide Vaio private settings to regular users:
	   - BIOS passwords: bytes 0x00 to 0x0f
	   - UUID: bytes 0x10 to 0x1f
 Return 0 if detection is successful, -ENODEV otherwise 
	 EDID EEPROMs are often 24C00 EEPROMs, which answer to all
	   addresses 0x50-0x57, but we only care about 0x50. So decline
	 There are four ways we can read the EEPROM data:
	   (1) I2C block reads (faster, but unsupported by most adapters)
	   (2) Word reads (128% overhead)
	   (3) Consecutive byte reads (88% overhead, unsafe)
	   (4) Regular byte data reads (265% overhead)
	   The third and fourth methods are not implemented by this driver
	 Detect the Vaio nature of EEPROMs.
 Let the users know they are using deprecated driver 
 create the sysfs eeprom file 
 SPDX-License-Identifier: GPL-2.0
  This is for all the tests related to copy_to_user() and copy_from_user()
  hardening.
  Many of the tests here end up using const sizes, but those would
  normally be ignored by hardened usercopy, so force the compiler
  into choosing the non-const path to make sure we trigger the
  hardened usercopy checks by added "unconst" to all the const copies,
  and making sure "cache_size" isn't optimized into a const.
  Instead of adding -Wno-return-local-addr, just pass the stack address
  through a function to obfuscate it from the compiler.
 Exercise stack to avoid everything living in registers. 
 Exercise stack to avoid everything living in registers. 
 This is a pointer to outside our current stack frame. 
 Put start address just inside stack. 
		
		  There isn't a safe way to not be protected by usercopy
		  if we're going to write to another thread's stack.
  This checks for whole-object size validation with hardened usercopy,
  with or without usercopy whitelisting.
  This checks for the specific whitelist window within an object. If this
  test passes, then do_usercopy_heap_size() tests will pass too.
 Make sure cache was prepared. 
	
	  Allocate a buffer with a whitelisted window in the buffer.
 Allocate user memory we'll poke at. 
 Whitelisted window in buffer, from kmem_cache_create_usercopy. 
 Callable tests. 
 Prepare cache that lacks SLAB_USERCOPY flag. 
 SPDX-License-Identifier: GPL-2.0
  This code tests that the current task stack is properly erased (filled
  with STACKLEAK_POISON).
  Authors:
    Alexander Popov <alex.popov@linux.com>
    Tycho Andersen <tycho@tycho.ws>
	
	  For the details about the alignment of the poison values, see
	  the comment in stackleak_track_stack().
	
	  One 'long int' at the bottom of the thread stack is reserved
	  and not poisoned.
	
	  Search for 'check_depth' poison values in a row (just like
	  stackleak_erase() does).
 The rest of thread stack should be erased 
 SPDX-License-Identifier: GPL-2.0
 Inserts new slb entries 
 Inject slb multihit on vmalloc-ed address i.e 0xD00... 
	
	  This triggers exception, If handled correctly we must recover
	  from this error.
 Inject slb multihit on kmalloc-ed address i.e 0xC00... 
	
	  This triggers exception, If handled correctly we must recover
	  from this error.
  Few initial SLB entries are bolted. Add a test to inject
  multihit in bolted entry 0.
 for i !=0 we would need to mask out the old entry number 
 for i !=0 we would need to mask out the old entry number 
		
		  These need not be separate tests, And they do pretty
		  much same thing. In any case we must recover from the
		  errors introduced by these functions, machine would not
		  survive these tests in case of failure to handle.
 SPDX-License-Identifier: GPL-2.0
  This is for all the tests relating directly to Control Flow Integrity.
 Function taking one argument, without a return value. 
 Function taking one argument, returning int. 
  This tries to call an indirect function with a mismatched prototype.
	
	  Matches lkdtm_increment_void()'s prototype, but not
	  lkdtm_increment_int()'s prototype.
 SPDX-License-Identifier: GPL-2.0
  This is for all the tests relating directly to heap memory, including
  page allocation and slab allocations.
  Using volatile here means the compiler cannot ever make assumptions
  about this value. This means compile-time length checks involving
  this variable cannot be performed; only run-time checks.
  If there aren't guard pages, it's likely that a consecutive allocation will
  let us overflow into the second allocation without overwriting something real.
  This tries to stay within the next largest power-of-2 kmalloc cache
  to avoid actually overwriting anything important if it's not detected
  correctly.
	
	  The slub allocator uses the first word to store the free
	  pointer in some configurations. Use the middle of the
	  allocation to avoid running into the freelist
 Attempt to notice the overwrite. 
	
	  The slub allocator will use the either the first word or
	  the middle of the allocation to store the free pointer,
	  depending on configurations. Store in the second word to
	  avoid running into the freelist.
 Good! Poisoning happened, so declare a win. 
 Attempt to notice the overwrite. 
 Good! Poisoning happened, so declare a win. 
 Just make sure we got real memory. 
 Just make sure we got real memory. 
  We have constructors to keep the caches distinctly separated without
  needing to boot with "slab_nomerge".
 SPDX-License-Identifier: GPL-2.0
  This is for all the tests related to logic bugs (e.g. bad dereferences,
  bad alignment, bad loops, bad locking, bad scheduling, deep stacks, and
  lockups) along with other things that don't fit well into existing LKDTM
  test source files.
  Make sure our attempts to over run the kernel stack doesn't trigger
  a compiler warning when CONFIG_FRAME_WARN is set. Then make sure we
  recurse past the end of THREAD_SIZE by default.
  Make sure compiler does not optimize this function or stack frame away:
  - function marked noinline
  - stack variables are marked volatile
  - stack variables are written (memset()) and read (pr_info())
  - function has external effects (pr_info())
 If the depth is negative, use the default, otherwise keep parameter. 
 This should trip the stack canary, not corrupt the return address. 
 Use default char array length that triggers stack protection. 
 Same as above but will only get a canary with -fstack-protector-strong 
 Do our best to find the canary in a 16 word window ... 
		
		  If the canary doesn't match what's in the task_struct,
		  we're either using a global canary or the stack frame
		  layout changed.
 Reset the test. 
 Use default char array length that triggers stack protection. 
 Must be called twice to trigger. 
 Let sparse know we intended to exit holding the lock. 
 Intentionally using old-style flex array definition of 1 byte. 
 For both, touch all bytes in the actual member size. 
	
	  For the uninstrumented flex array member, also touch 1 byte
	  beyond to verify it is correctly uninstrumented.
	
	  Initially, an empty list via LIST_HEAD:
	 	test_head.next = &test_head
	 	test_head.prev = &test_head
	
	  Adding to the list performs these actions:
	 	test_head.next->prev = &good.node
	 	good.node.next = test_head.next
	 	good.node.prev = test_head
	 	test_head.next = good.node
	
	  In simulating this "write what where" primitive, the "what" is
	  the address of &bad.node, and the "where" is the address held
	  by "redirection".
 As with the list_add() test above, this corrupts "next". 
 Test that VMAP_STACK is actually allocating with a leading guard page 
 Test that VMAP_STACK is actually allocating with a trailing guard page 
	
	  To test the post-write pinning verification we need to call
	  directly into the middle of native_write_cr4() where the
	  cr4 write happens, skipping any pinning. This searches for
	  the cr4 writing instruction.
 mov %rdi, %cr4 
 mov %rdi,%rax; mov %rax, %cr4 
	
	  Trigger #DF by setting the stack limit to zero.  This clobbers
	  a GDT TLS slot, which is okay because the current task will die
	  anyway due to the double fault.
 expand-up, writable, accessed data 
 present 
 32-bit 
 limit in bytes 
 not system 
	
	  Put our zero-limit segment in SS and then trigger a fault.  The
	  4-byte access to (%esp) will fault with #SS, and the attempt to
	  deliver the fault will recursively cause #SS and result in #DF.
	  This whole process happens while NMIs and MCEs are blocked by the
	  MOV SS window.  This is nice because an NMI with an invalid SS
	  would also double-fault, resulting in the NMI or MCE being lost.
 Reset the keys of current task 
	
	  PAC is a hash value computed from input keys, return address and
	  stack pointer. As pac has fewer bits so there is a chance of
	  collision, so iterate few times to reduce the collision probability.
 SPDX-License-Identifier: GPL-2.0-or-later
  Linux Kernel Dump Test Module for testing kernel crashes conditions:
  induces system failures at predefined crashpoints and under predefined
  operational conditions in order to evaluate the reliability of kernel
  sanity checking and crash dumps obtained using different dumping
  solutions.
  Copyright (C) IBM Corporation, 2006
  Author: Ankita Garg <ankita@in.ibm.com>
  It is adapted from the Linux Kernel Dump Test Tool by
  Fernando Luis Vazquez Cao <http:lkdtt.sourceforge.net>
  Debugfs support added by Simon Kagstrom <simon.kagstrom@netinsight.net>
  See Documentationfault-injectionprovoke-crashes.rst for instructions
 Crash points 
 Define the possible places where we can trigger a crash point. 
 Crash types. 
 Define the possible types of crashes that can be triggered. 
 Global kprobe entry and crashtype. 
 Module parameters 
 For test debug reporting. 
 Return the crashtype number or NULL if the name is invalid 
  This is forced noinline just so it distinctly shows up in the stackdump
  which makes validation of expected lkdtm crashes easier.
 If this doesn't have a symbol, just call immediately. 
 Global crash counter and spinlock. 
 Called by kprobe entry points. 
 NULL-terminate and remove enter 
 Generic read callback that just prints out the available crash types 
 Special entry to just crash directly. Available without KPROBEs 
 NULL-terminate and remove enter 
  To avoid needing to export parse_args(), just don't use this code
  when LKDTM is built as a module.
 short circuit if we already found a value. 
 Neither or both of these need to be set 
 Refuse unknown crashpoints. 
 Set crash count. 
 Common initialization. 
 Handle test-specific initialization. 
 Register debugfs interface 
 Install debugfs trigger files. 
 Install crashpoint if one was selected. 
 Handle test-specific clean-up. 
 SPDX-License-Identifier: GPL-2.0
  This is for all the tests related to validating kernel memory
  permissions: non-executable regions, non-writable regions, and
  even non-readable regions.
 Whether or not to fill the target memory area with do_nothing(). 
 How many bytes to copy to be sure we've copied enough of do_nothing(). 
 This is non-const, so it will end up in the .data section. 
 This is cost, so it will end up in the .rodata section. 
 This is marked __ro_after_init, so it should ultimately be .rodata. 
  This just returns to the caller. It is designed to be copied into
  non-executable memory regions.
 Must immediately follow do_nothing for size calculuations to work out. 
 Intentionally crossing kerneluser memory boundary. 
 Explicitly cast away "const" for the test and make volatile. 
	
	  Verify we were written to during init. Since an Oops
	  is considered a "success", a failure is to just skip the
	  real test.
 Make sure we can write to __ro_after_init values during __init 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2020 Francis Laniel <laniel_francis@privacyrequired.com>
  Add tests related to fortified functions in this file.
	
	  Using volatile prevents the compiler from determining the value of
	  'size' at compile time. Without that, we would get a compile error
	  rather than a runtime error.
 Store result to global to prevent the code from being eliminated 
	
	  memcpy(target.a, src, 20); will hit a compile error because the
	  compiler knows at build time that target.a < 20 bytes. Use a
	  volatile to force a runtime error.
 Store result to global to prevent the code from being eliminated 
  Calls fortified strscpy to test that it returns the same result as vanilla
  strscpy and generate a panic because there is a write overflow (i.e. src
  length is greater than dst length).
 Vanilla strscpy returns -E2BIG if size is 0. 
 Vanilla strscpy returns -E2BIG if src is truncated. 
 After above call, dst must contain "foob" because src was truncated. 
 Shrink src so the strscpy() below succeeds. 
	
	  Vanilla strscpy returns number of character copied if everything goes
	  well.
 After above call, dst must contain "foo" because src was copied. 
 Test when src is embedded inside a union. 
 Restore src to its initial value. 
	
	  Use strlen here so size cannot be known at compile time and there is
	  a runtime write overflow.
 SPDX-License-Identifier: GPL-2.0
  This is for all the tests related to refcount bugs (e.g. overflow,
  underflow, reaching zero untested, etc).
  A refcount_inc() above the maximum value of the refcount implementation,
  should at least saturate, and at most also WARN.
 refcount_add() should behave just like refcount_inc() above. 
 refcount_inc_not_zero() should behave just like refcount_inc() above. 
 refcount_add_not_zero() should behave just like refcount_inc() above. 
  A refcount_dec(), as opposed to a refcount_dec_and_test(), when it hits
  zero it should either saturate (when inc-from-zero isn't protected)
  or stay at zero (when inc-from-zero is protected) and should WARN for both.
	
	  refcount_t refuses to move a refcount at all on an
	  over-sub, so we have to track our starting position instead of
	  looking only at zero-pinning.
 A refcount_dec() going negative should saturate and may WARN. 
  A refcount_dec_and_test() should act like refcount_dec() above when
  going negative.
  A refcount_sub_and_test() should act like refcount_dec_and_test()
  above when going negative.
  A refcount_inc() from zero should pin to zero or saturate and may WARN.
  A refcount_add() should act like refcount_inc() above when starting
  at zero.
  A refcount_inc() from a saturated value should at most warn about
  being saturated already.
 Should act like refcount_inc() above from saturated. 
 Should act like refcount_inc() above from saturated. 
 Should act like refcount_inc() above from saturated. 
 Should act like refcount_inc() above from saturated. 
 Should act like refcount_inc() above from saturated. 
 Should act like refcount_inc() above from saturated. 
 Used to time the existing atomic_t when used for reference counting 
  This can be compared to ATOMIC_TIMING when implementing fast refcount
  protections. Looking at the number of CPU cycles tells the real story
  about performance. For example:
     cd syskerneldebugprovoke-crash
     perf stat -B -- cat <(echo REFCOUNT_TIMING) > DIRECT
 SPDX-License-Identifier: GPL-2.0
  This includes functions that are meant to live entirely in .rodata
  (via objcopy tricks), to validate the non-executability of .rodata.
 Does nothing. We just want an architecture agnostic "return". 
 SPDX-License-Identifier: GPL-2.0-only
   Silicon Labs C2 port core Linux support
   Copyright (c) 2007 Rodolfo Giometti <giometti@linux.it>
   Copyright (c) 2007 Eurotech S.p.A. <info@eurotech.it>
  Local variables
  C2 registers & commands defines
 C2 registers 
 C2 interface commands 
 C2 status return codes 
  C2 port low level signal managements
	 To reset the device we have to keep clock line low for at least
	  20us.
	 During hi-low-hi transition we disable local IRQs to avoid
	  interructions since C2 port specification says that it must be
	  shorter than 5us, otherwise the microcontroller may consider
	  it as a reset signal!
  C2 port basic functions
 START field 
 INS field (11b, LSB first) 
 ADDRESS field 
 STOP field 
 START field 
 INS field (10b, LSB first) 
 ADDRESS field 
 shift in 8-bit ADDRESS field LSB first 
 STOP field 
 START field 
 INS field (01b, LSB first) 
 LENGTH field (00b, LSB first -> 1 byte) 
 DATA field 
 WAIT field 
 STOP field 
 START field 
 INS field (00b, LSB first) 
 LENGTH field (00b, LSB first -> 1 byte) 
 WAIT field 
 DATA field 
 shift in 8-bit DATA field LSB first 
 STOP field 
 erase flash needs long time... 
  sysfs methods
	 If access is "on" clock should be HIGH _before_ setting the line
 Check the device access status 
 Select DEVICEID register for C2 data register accesses 
 Read and return the device ID register 
 Check the device access status 
 Select REVID register for C2 data register accesses 
 Read and return the revision ID register 
 Check the device access status 
 Check the device access status 
 If flash_access is off we have nothing to do... 
	 Target the C2 flash programming control register for C2 data
 Write the first keycode to enable C2 Flash programming 
 Write the second keycode to enable C2 Flash programming 
	 Delay for at least 20ms to ensure the target is ready for
	 Target the C2 flash programming data register for C2 data register
	  access.
 Send device erase command 
 Wait for input acknowledge 
 Should check status before starting FLASH access sequence 
 Wait for status information 
 Read flash programming interface status 
	 Send a three-byte arming sequence to enable the device erase.
	  If the sequence is not received correctly, the command will be
	  ignored.
	  Sequence is: 0xde, 0xad, 0xa5.
 Check the device and flash access status 
 Check for flash end 
	 Target the C2 flash programming data register for C2 data register
 Send flash block read command 
 Wait for input acknowledge 
 Should check status before starting FLASH access sequence 
 Wait for status information 
 Read flash programming interface status 
 Send address high byte 
 Send address low byte 
 Send address block size 
 Should check status before reading FLASH block 
 Wait for status information 
 Read flash programming interface status 
 Read flash block 
 Check the device and flash access status 
 Check for flash end 
	 Target the C2 flash programming data register for C2 data register
 Send flash block write command 
 Wait for input acknowledge 
 Should check status before starting FLASH access sequence 
 Wait for status information 
 Read flash programming interface status 
 Send address high byte 
 Send address low byte 
 Send address block size 
 Should check status before writing FLASH block 
 Wait for status information 
 Read flash programming interface status 
 Write flash block 
 Wait for last flash write to complete 
 Check the device access status 
 size is computed at run-time 
  Class attributes
  Exported functions
 By default C2 port access is off 
  Module stuff
 SPDX-License-Identifier: GPL-2.0-only
   Silicon Labs C2 port Linux support for Eurotech Duramar 2150
   Copyright (c) 2008 Rodolfo Giometti <giometti@linux.it>
   Copyright (c) 2008 Eurotech S.p.A. <info@eurotech.it>
  C2 port operations
 0 = input, 1 = output 
		 When access is "off" is important that both lines are set
 bytes 
 total flash size: 15360 bytes 
  Module stuff
 Setup the GPIOs as input by default (access = 0) 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2018-2020 Broadcom.
 default firmware images names 
 Location of memory base addresses of interest in BAR1 
 Load Boot1 to start of ITCM 
 Allow minimum 1s for Load Image timeout responses 
 Image startup timeouts 
 1ms wait for checking the transfer complete status 
 MSIX usages 
 Number of bits set in DMA mask
 Ucode boot wait time 
 50% margin 
 deinit time for the card os after receiving doorbell 
  module parameters
  alerts that could be generated from peer
 alerts detected by the host 
 if notification is not pending, set bit and schedule work 
 read interface register 
	
	  if major number is 0, it is pre-release and it would be allowed
	  to continue, else, check versions accordingly
			
			  if there is difference between stored cnt and it
			  is greater than threshold, log it.
 print a log as info 
 perform range checking for rdwr idx 
 update rd idx at the end 
 handle peer alerts and then locally detected ones 
 turn off access 
 check and make copy of alert with lock and then free lock 
 call display with copy 
	
	  If it is a sys fault or heartbeat timeout, we would like extract
	  log msg from the card so that we would know what is the last fault
 check for any boot err condition 
 first read the offset from spare register 
 based on the offset, read info to internal card info structure 
	
	  get the peer log pointer, only need the offset, and get record
	  of the log buffer information which would be used for checking
	  before dump, in case the BAR2 memory has been corrupted.
	
	  Do a range checking and if out of bound, the record will be zeroed
	  which guarantees that nothing would be dumped.  In other words,
	  peer dump is disabled.
 calculate offset which is based on peerlog offset 
 first read the num and entry size 
 check for max allowed 
 read it once that will capture those static info 
 check for marker, but allow diags mode to skip sync 
	
	  Write down scratch addr which is used for DMA. For
	  signed part, BAR1 is accessible only after boot2 has come
	  up
 get static card info, only need to read once 
 get the proc mon info once 
	
	  kill all the apps except for the process that is resetting.
	  If not called during reset, reset_pid will be 0, and all will be
	  killed.
 set msgq_inited to 0 so that all rdwr will be blocked 
 update the dma address to the card 
		
		  After POR, enable VK soft BOOTSRC so bootrom do not clear
		  the pushed image (the TCM memories).
 Write a 1 to request SRAM open bit 
 Wait for VK to respond 
 Wait for VK to respond 
 wait until done 
 To send more data to VK than max_buf allowed at a time 
			
			  Check for ack from card. when Ack is received,
			  it means all the data is received by card.
			  Exit the loop after ack is received.
 exit the loop, if there is no response from card 
 Wait for VK to open BAR space to copy new data 
 reload timeout after every codepush 
 wait for fw status bits to indicate app ready 
			
			  Next, initialize Message Q if we are loading boot2.
			  Do a force sync
 sync & channel other info 
 default for unknown 
 Log status so that we know different stages 
 get the chip id to decide sub-class 
 Default to A0 firmware for all other chip revs 
 log a message to know the relative loading order 
  deferred work queue for draining and auto download.
 check wq offload bit map to perform various operations 
 clear bit right the way for notification 
		
		  at the end of operation, clear AUTO bit and pending
		  bit
 next, try to drain 
	
	  if something is pending download already.  This could only happen
	  for now when the driver is being loaded, or if someone has issued
	  another download command in another shell.
 Use default image name if NULL 
 Image idx starts with boot1 
 Ensure filename is NULL terminated 
	
	  Reset could be triggered when the card in several state:
	    i)   in bootROM
	    ii)  after boot1
	    iii) boot2 running
	 
	  i) & ii) - no status bits will be updated.  If vkboot1
	  runs automatically after reset, it  will update the reason
	  to be unknown reason
	  iii) - reboot reason match + deinit done.
 immediate exit if interface goes down 
	
	  if some of the deinit bits are set, but done
	  bit is not, this is a failure if triggered while boot2 is running
 clean up before pressing the door bell 
 make tag '\0' terminated 
	
	  When boot request fails, the CODE_PUSH_OFFSET stays persistent.
	  Allowing us to debug the failure. When we call reset,
	  we should clear CODE_PUSH_OFFSET so ROM does not execute
	  boot again (and fails again) and instead waits for a new
	  codepush.  And, if previous boot has encountered error, need
	  to clear the entry values
 special reset handling 
		
		  if card is in ramdump mode, it is hitting an error.  Don't
		  reset the reboot reason as it will contain valid info that
		  is important - simply use special reset
 reset fw_status with proper reason, and press db 
 clear other necessary registers and alert records 
 clear 4096 bits of bitmap 
 check if any download is in-progress, if so return error 
	
	  The following is the sequence of reset:
	  - send card level graceful shut down
	  - wait enough time for VK to handle its business, stopping DMA etc
	  - kill host apps
	  - Trigger interrupt with DB
	
	  Wait enough time for card os to deinit
	  and populate the reset reason.
 if it is special ramdump reset, return the type to user 
 only BAR2 is mmap possible, which is bar num 4 due to 64bit 
 allocate vk structure which is tied to kref for freeing 
 make sure DMA is good 
 The tdma is a scratch area for some DMA testings. 
 multiple by 2 for 64 bit BAR mapping 
 one irq for notification from VK 
 create dedicated workqueue 
 sync other info 
 register for panic notifier 
	
	  lets trigger an auto download.  We don't want to do it serially here
	  because at probing time, it is not supposed to block for a long time.
 enable hb 
	
	  Trigger a reset to card and wait enough time for UCODE to rerun,
	  which re-initialize the card into its default state.
	  This ensures when driver is re-enumerated it will start from
	  a completely clean state.
 unregister panic notifier 
 remove if name is set which means misc dev registered 
 simply trigger a reset interrupt to park it 
		
		  The boot status only reflects boot condition since last reset
		  As ucode will run only once to configure pcie, if multiple
		  resets happen, we lost track if ucode has run or not.
		  Here, read the current link speed and use that to
		  sync up the bootstatus properly so that on reboot-back-up,
		  it has the proper state to start with autoload
 SPDX-License-Identifier: GPL-2.0
  Copyright 2018-2020 Broadcom.
 TTYVK base offset is 0x30000 into BAR1 
 Each TTYVK channel (TO or FROM) is 0x10000 
 Each TTYVK channel has TO and FROM, hence the  2 
 TO TTYVK channel base comes before FROM for each index 
 Poll every 110 of second - temp hack till we use MSI interrupt 
 Check the card status that the tty channel is ready 
 Don't increment read index if tty app is closed 
 Fetch the wr offset in buffer from VK 
 safe to ignore until bar read gives proper size 
 Need to signal and close device in this case 
		
		  Simple read of circular buffer and
		  insert into tty flip buffer
 Update read offset from shadow register to card 
 initialize the pointer in case something fails 
 Do not allow tty device to be opened if tty on card not ready 
	
	  Get shadow registers of the buffer sizes and the "to" write offset
	  and "from" read offset
 Simple write each byte to circular buffer 
 Update write offset from shadow register to card 
 Save struct tty_driver for uninstalling the device 
 initialize the tty driver 
 register the tty driver 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2018-2020 Broadcom.
  Valkyrie has a hardware limitation of 16M transfer size.
  So limit the SGL chunks to 16M.
 Uncomment to dump SGLIST 
 #define BCM_VK_DUMP_SGLIST 
 Get 64-bit user address 
 offset into first page 
 Calculate number of pages 
 Allocate DMA pages 
 Get user pages into memory 
 Max size of sg list is 1 per mapped page + fields at start 
 Allocate sglist 
 Map all pages into DMA 
		
		  Compress SG list entry when pages are contiguous
		  and transfer size less or equal to BCM_VK_MAX_SGL_CHUNK
 pages are contiguous, add to same sg entry 
 pages are not contiguous, write sg entry 
 start new sg entry 
 Write last sg list entry 
 Update pointers and size field to point to sglist 
 Convert user addresses to DMA SG List 
			
			  If both size and address are non-zero
			  then DMA alloc.
			
			  If one of size and address are zero
			  there is a problem.
			
			  If size and address are both zero
			  don't convert, but return success.
 Unmap all pages in the sglist 
 Free allocated sglist 
 Release lock on all pages 
 Free allocated dma pages 
 Unmap and free all pages and sglists 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2018-2020 Broadcom.
 functions to manipulate the transport id in msg block 
 number x q_size will be the max number of msg processed per loop 
 module parameter 
 number of retries when enqueue message fails before returning EAGAIN 
 use irqsave version as this maybe called inside timer interrupt 
  Heartbeat related defines
  The heartbeat from host is a last resort.  If stuck condition happens
  on the card, firmware is supposed to detect it.  Therefore, the heartbeat
  values used will be more relaxed on the driver, which need to be bigger
  than the watchdog timeout on the card.  The watchdog timeout on the card
  is 20s, with a jitter of 2s => 22s.  We use a value of 27s here.
 read uptime from register and compare 
 reset to avoid accumulation 
		
		  if the interface goes down without any activity, a value
		  of 0xFFFFFFFF will be continuously read, and the detection
		  will be happened eventually.
 reset heart beat lost cnt 
 next, check if heartbeat exceeds limit 
 re-arm timer 
  allocate a ctx per file struct
 check if it is in reset, if so, don't allow 
 set the pid and insert it to hash table 
 increase kref 
 clear counter 
		
		  first time come in this loop, msg_id will be 0
		  and the first one tested will be 1.  We skip
		  VK_SIMPLEX_MSG_ID (0) for one way host2vk
		  communication
 Remove it from hash list and see if it is the last one. 
 batch clean up 
 if it is specific ctx, log for any stuck 
  Function to sync up the messages queue info that is provided by BAR1
	
	  If the driver is loaded at startup where vk OS is not up yet,
	  the msgq-info may not be available until a later time.  In
	  this case, we skip and the sync function is supposed to be
	  called again.
 each side is always half the total  
 first msgq location 
	
	  if this function is called when it is already inited,
	  something is wrong
 fall back to default 
 formulate and record static info 
 set low threshold as 50% or 12 
 check if high watermark is hit, and if so, skip 
 round up size 
 local copy 
 if not enough space, return EAGAIN and let app handles it 
 at this point, mutex is taken and there is enough space 
 update debug seq number 
 flush the write pointer 
 log new info for debugging 
	
	  press door bell based on queue number. 1 is added to the wr_idx
	  to avoid the value of 0 appearing on the VK side to distinguish
	  from initial value.
	
	  check if the marker is still good.  Sometimes, the PCIe interface may
	  have gone done, and if so and we ship down thing based on broken
	  values, kernel may panic.
 fill up necessary data 
 always 1 block 
	
	  don't send down or do anything if message queue is not initialized
	  and if it is the reset session, clear it.
 only need to do it if it is not the reset process 
 put reset_pid to 0 if it is exiting last session 
	
	  drain all the messages from the queues, and find its pending
	  entry in the to_v queue, based on msg_id & q_num, and move the
	  entry to the to_h pending queue, waiting for user space
	  program to extract
			
			  Make a local copy and get pointer to src blk
			  The rd_idx is masked before getting the pointer to
			  avoid out of bound access in case the interface goes
			  down.  It will end up pointing to the last block in
			  the buffer, but subsequent src->size check would be
			  able to catch this.
 copy messages and linearize it 
				
				  if we could not allocate memory in kernel,
				  that is fatal.
 flush rd pointer after a message is dequeued 
 log new info for debugging 
			
			  No need to search if it is an autonomous one-way
			  message from driver, as these messages do not bear
			  a to_v pending item. Currently, only the shutdown
			  message falls into this category.
 lookup original message in to_v direction 
			
			  if there is message to does not have prior send,
			  this is the location to add here
 Fetch wr_idx to handle more back-to-back events 
			
			  cap the max so that even we try to handle more back-to-back events,
			  so that it won't hold CPU too long or in case rdwr idexes are
			  corrupted which triggers infinite looping.
  init routine for all required data structures
 self identity 
 initialize hash table 
 get a context and set it up for file 
		
		  set up context and replace private data with context for
		  other methods to use.  Reason for the context is because
		  it is allowed for multiple sessions to open the sysfs, and
		  for each file open, when upper layer query the response,
		  only those that are tied to a specific open should be
		  returned.  The context->idx will be used for such binding
	
	  search through the pendq on the to_h chan, and return only those
	  that belongs to the same context.  Search is always from the high to
	  the low priority queues
 buffer not big enough 
 retrieve the passed down msg_id 
		
		  in this case, return just the first block, so
		  that app knows what size it is looking for.
 first, do sanity check where count should be multiple of basic blk 
 allocate the work entry + buffer for size count and inband sgl 
 now copy msg from user space, and then formulate the work entry 
 do a check on the blk size which could not exceed queue space 
 Use internal message id 
 Convert any pointers to sg list 
		
		  check if we are in reset, if so, no buffer transfer is
		  allowed and return error.
 Calculate vk_data location 
 Go to end of the message 
 Now back up to the start of the pointers 
 Convert user addresses to DMA SG List 
 try to embed inband sgl 
		
		  Init happens in 2 stages, only the first stage contains the
		  pid that needs translating.
		
		  translate the pid into the unique host space as user
		  may run sessions inside containers or process
		  namespaces.
	
	  store work entry to pending queue until a response is received.
	  This needs to be done before enqueuing the message
 remove message from pending list 
	
	  if there are outstanding DMA transactions, need to delay long enough
	  to ensure that the card side would have stopped touching the host buffer
	  and its SGL list.  A race condition could happen if the host app is killed
	  abruptly, eg kill -9, while some DMA transfer orders are still inflight.
	  Nothing could be done except for a delay as host side is running in a
	  completely async fashion.
 read msgq info if ready 
 drain all pending items 
 SPDX-License-Identifier: GPL-2.0-only
   cb710sgbuf2.c
   Copyright by Micha≈Ç Miros≈Çaw, 2008-2009
  cb710_sg_dwiter_read_next_block() - get next 32-bit word from sg buffer
  @miter: sg mapping iterator used for reading
  Description:
    Returns 32-bit word starting at byte pointed to by @miter@
    handling any alignment issues.  Bytes past the buffer's end
    are not accessed (read) but are returned as zeroes.  @miter@
    is advanced by 4 bytes or to the end of buffer whichever is
    closer.
  Context:
    Same requirements as in sg_miter_next().
  Returns:
    32-bit word just read.
  cb710_sg_dwiter_write_next_block() - write next 32-bit word to sg buffer
  @miter: sg mapping iterator used for writing
  @data: data to write to sg buffer
  Description:
    Writes 32-bit word starting at byte pointed to by @miter@
    handling any alignment issues.  Bytes which would be written
    past the buffer's end are silently discarded. @miter@ is
    advanced by 4 bytes or to the end of buffer whichever is closer.
  Context:
    Same requirements as in sg_miter_next().
 SPDX-License-Identifier: GPL-2.0-only
   cb710core.c
   Copyright by Micha≈Ç Miros≈Çaw, 2008-2009
 Some magic writes based on Windows driver init code 
 incl. smp_rmb() 
 slot struct can be freed now 
	 slot->irq_handler == NULL here; this needs to be
		 device_initialize() called from platform_device_register()
 slot->irq_handler == NULL here anyway, so no lock needed 
 complementary to spin_unlock() in cb710_set_irq_handler() 
 slot->irq_handler == NULL here, so no lock needed 
 this is actually magic... 
 MMCSD slot 
 MemoryStick slot 
 SmartMedia slot 
 SPDX-License-Identifier: GPL-2.0-only
   cb710debug.c
   Copyright by Micha≈Ç Miros≈Çaw, 2008-2009
 SPDX-License-Identifier: GPL-2.0-only
  IBM Accelerator Family 'GenWQE'
  (C) Copyright IBM Corp. 2013
  Author: Frank Haverkamp <haver@linux.vnet.ibm.com>
  Author: Joerg-Stephan Vogt <jsvogt@de.ibm.com>
  Author: Michael Jung <mijung@gmx.net>
  Author: Michael Ruettger <michael@ibmra.de>
  Device Driver Control Block (DDCB) queue support. Definition of
  interrupt handlers for queue support as well as triggering the
  health monitor code in case of problems. The current hardware uses
  an MSI interrupt which is shared between error handling and
  functional code.
  N: next DDCB, this is where the next DDCB will be put.
  A: active DDCB, this is where the code will look for the next completion.
  x: DDCB is enqueued, we are waiting for its completion.
  Situation (1): Empty queue
   +---+---+---+---+---+---+---+---+
   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
   |   |   |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+
            AN
   enqueued_ddcbs = A - N = 2 - 2 = 0
  Situation (2): Wrapped, N > A
   +---+---+---+---+---+---+---+---+
   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
   |   |   | x | x |   |   |   |   |
   +---+---+---+---+---+---+---+---+
             A       N
   enqueued_ddcbs = N - A = 4 - 2 = 2
  Situation (3): Queue wrapped, A > N
   +---+---+---+---+---+---+---+---+
   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
   | x | x |   |   | x | x | x | x |
   +---+---+---+---+---+---+---+---+
             N       A
   enqueued_ddcbs = queue_max  - (A - N) = 8 - (4 - 2) = 6
  Situation (4a): Queue full N > A
   +---+---+---+---+---+---+---+---+
   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
   | x | x | x | x | x | x | x |   |
   +---+---+---+---+---+---+---+---+
     A                           N
   enqueued_ddcbs = N - A = 7 - 0 = 7
  Situation (4a): Queue full A > N
   +---+---+---+---+---+---+---+---+
   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
   | x | x | x |   | x | x | x | x |
   +---+---+---+---+---+---+---+---+
                 N   A
   enqueued_ddcbs = queue_max - (A - N) = 8 - (4 - 3) = 7
 must never ever happen! 
  Use of the PRIV field in the DDCB for queue debugging:
  (1) Trying to get rid of a DDCB which saw a timeout:
      pddcb->priv[6] = 0xcc;   # cleared
  (2) Append a DDCB via NEXT bit:
      pddcb->priv[7] = 0xaa;	# appended
  (3) DDCB needed tapping:
      pddcb->priv[7] = 0xbb;   # tapped
  (4) DDCB marked as correctly finished:
      pddcb->priv[6] = 0xff;	# finished
 tapped 
 appended 
 cleared 
 finished 
 not tapped 
  genwqe_crc16() - Generate 16-bit crc as required for DDCBs
  @buff:       pointer to data buffer
  @len:        length of data for calculation
  @init:       initial crc (0xffff at start)
  Polynomial = x^16 + x^12 + x^5 + 1   (0x1021)
  Example: 4 bytes 0x01 0x02 0x03 0x04 with init = 0xffff
           should result in a crc16 of 0x89c3
  Return: crc16 checksum in big endian format !
  ddcb_requ_finished() - Returns the hardware state of the associated DDCB
  @cd:          pointer to genwqe device descriptor
  @req:         DDCB work request
  Status of ddcb_requ mirrors this hardware state, but is copied in
  the ddcb_requ on interruptpolling function. The lowlevel code
  should check the hardware state directly, the higher level code
  should check the copy.
  This function will also return true if the state of the queue is
  not GENWQE_CARD_USED. This enables us to purge all DDCBs in the
  shutdown case.
  enqueue_ddcb() - Enqueue a DDCB
  @cd:         pointer to genwqe device descriptor
  @queue:	queue this operation should be done on
  @pddcb:      pointer to ddcb structure
  @ddcb_no:    pointer to ddcb number being tapped
  Start execution of DDCB by tapping or append to queue via NEXT
  bit. This is done by an atomic 'compare and swap' instruction and
  checking SHI and HSI of the previous DDCB.
  This function must only be called with ddcb_lock held.
  Return: 1 if new DDCB is appended to previous
          2 if DDCB queue is tapped via registersimulation
	
	  For performance checks a Dispatch Timestamp can be put into
	  DDCB It is supposed to use the SLU's free running counter,
	  but this requires PCIe cycles.
 check previous DDCB if already fetched 
	
	  It might have happened that the HSI.FETCHED bit is
	  set. Retry in this case. Therefore I expect maximum 2 times
	  trying.
 read SHIHSI in BE32 
 try to append via NEXT bit if prev DDCB is not completed 
 need to ensure write ordering 
 appended to queue 
 Queue must be re-started by updating QUEUE_OFFSET 
 need to ensure write ordering 
 start queue 
  copy_ddcb_results() - Copy output state from real DDCB to request
  @req:        pointer to requested DDCB parameters
  @ddcb_no:    pointer to ddcb number being tapped
  Copy DDCB ASV to request struct. There is no endian
  conversion made, since data structure in ASV is still
  unknown here.
  This is needed by:
    - genwqe_purge_ddcb()
    - genwqe_check_ddcb_queue()
 copy status flags of the variant part 
  genwqe_check_ddcb_queue() - Checks DDCB queue for completed work requests.
  @cd:         pointer to genwqe device descriptor
  @queue:	queue to be checked
  Return: Number of DDCBs which were finished
 FIXME avoid soft locking CPU 
 not completed, continue waiting 
  Add sync to decouple prev. read operations 
 Note: DDCB could be purged 
 this occurs if DDCB is purged, not an error 
 Move active DDCB further; Nothing to do anymore. 
		
		  HSI=0x44 (fetched and completed), but RETC is
		  0x101, or even worse 0x000.
		 
		  In case of seeing the queue in inconsistent state
		  we read the errcnts and the queue status to provide
		  a trigger for our PCIe analyzer stop capturing.
 take from queue 
 calculate CRC_16 to see if VCRC is correct 
		 wake up process waiting for this DDCB, and
  __genwqe_wait_ddcb(): Waits until DDCB is completed
  @cd:         pointer to genwqe device descriptor
  @req:        pointer to requsted DDCB parameters
  The Service Layer will update the RETC in DDCB when processing is
  pending or done.
  Return: > 0 remaining jiffies, DDCB completed
            -ETIMEDOUT	when timeout
            -ERESTARTSYS when ^C
            -EINVAL when unknown error condition
  When an error is returned the called needs to ensure that
  purge_ddcb() is being called to get the &req removed from the
  queue.
	
	  We need to distinguish 3 cases here:
	    1. rc == 0              timeout occurred
	    2. rc == -ERESTARTSYS   signal received
	    3. rc > 0               remaining jiffies condition is true
		
		  Timeout may be caused by long task switching time.
		  When timeout happens, check if the request has
		  meanwhile completed.
		
		  EINTR:       Stops the application
		  ERESTARTSYS: Restartable systemcall; called again
 Severe error occured. Driver is forced to stop operation 
  get_next_ddcb() - Get next available DDCB
  @cd:         pointer to genwqe device descriptor
  @queue:      DDCB queue
  @num:        internal DDCB number
  DDCB's content is completely cleared but presets for PRE and
  SEQNUM. This function must only be called when ddcb_lock is held.
  Return: NULL if no empty DDCB available otherwise ptr to next DDCB.
 queue is  full 
 find new ddcb 
 if it is not completed, we are not allowed to use it 
 barrier(); 
 internal DDCB number 
 clear important DDCB fields 
 offs 0x00 (ICRC,HSI,SHI,...) 
 offs 0x01 (ACFUNC,CMD...) 
 destroy previous results in ASV 
 offs 0x80 (ASV + 0) 
 offs 0x88 (ASV + 0x08) 
 offs 0x90 (ASV + 0x10) 
 offs 0x98 (ASV + 0x18) 
 offs 0xd0 (RETC,ATTN...) 
 128 
  __genwqe_purge_ddcb() - Remove a DDCB from the workqueue
  @cd:         genwqe device descriptor
  @req:        DDCB request
  This will fail when the request was already FETCHED. In this case
  we need to wait until it is finished. Else the DDCB can be
  reused. This function also ensures that the request data structure
  is removed from ddcb_req[].
  Do not forget to call this function when genwqe_wait_ddcb() fails,
  such that the request gets really removed from ddcb_req[].
  Return: 0 success
 unsigned long flags; 
 Check if req was meanwhile finished 
 try to set PURGE bit if FETCHEDCOMPLETED are not set 
 read SHIHSI in BE32 
 normal finish with HSI bit 
		
		  Here the check_ddcb() function will most likely
		  discover this DDCB to be finished some point in
		  time. It will mark the req finished and free it up
		  in the list.
 for the failing case 
 sleep for 110 second and try again 
 delete from array 
 Move active DDCB further; Nothing to do here anymore. 
		
		  We need to ensure that there is at least one free
		  DDCB in the queue. To do that, we must update
		  ddcb_act only if the COMPLETED bit is set for the
		  DDCB we are working on else we treat that DDCB even
		  if we PURGED it as occupied (hardware is supposed
		  to set the COMPLETED bit yet!).
	
	  If the card is dead and the queue is forced to stop, we
	  might see this in the queue status register.
  __genwqe_enqueue_ddcb() - Enqueue a DDCB
  @cd:         pointer to genwqe device descriptor
  @req:        pointer to DDCB execution request
  @f_flags:    file mode: blocking, non-blocking
  Return: 0 if enqueuing succeeded
          -EIO if card is unusablePCIe problems
          -EBUSY if enqueuing failed
	 FIXME circumvention to improve performance when no irq is
	  there.
	
	  It must be ensured to process all DDCBs in successive
	  order. Use a lock here in order to prevent nested DDCB
	  enqueuing.
 get ptr and num 
 interrupted by a signal 
 functional unit 
	
	  We know that we can get retc 0x104 with CRC error, do not
	  stop the queue in those cases for this command. XDIR = 1
	  does not work for old SLU versions.
	 
	  Last bitstream with the old XDIR behavior had SLU_ID
	  0x34199.
	
	  If copying the whole DDCB_ASIV_LENGTH is impacting
	  performance we need to change it to
	  req->cmd.asiv_length. But simulation benefits from some
	  non-architectured bits behind the architectured content.
	 
	  How much data is copied depends on the availability of the
	  ATS field, which was introduced late. If the ATS field is
	  supported ASIV is 8 bytes shorter than it used to be. Since
	  the ATS field is copied too, the code should do exactly
	  what it did before, but I wanted to make copying of the ATS
	  field very explicit.
 destination 
 source 
 req->cmd.asiv_length 
 destination 
 source 
 req->cmd.asiv_length 
 for crc 
	
	  Calculate CRC_16 for corresponding range PSP(7:4). Include
	  empty 4 bytes prior to the data.
 enable DDCB completion irq 
		 use the kernel copy of debug data. copying back to
  __genwqe_execute_raw_ddcb() - Setup and execute DDCB
  @cd:         pointer to genwqe device descriptor
  @cmd:        user provided DDCB command
  @f_flags:    file mode: blocking, non-blocking
 error or signal interrupt 
	
	  Higher values than 0x102 indicate completion with faults,
	  lower values than 0x102 indicate processing faults. Note
	  that DDCB might have been purged. E.g. Cntl+C.
		 This might happen e.g. flash read, and needs to be
 not processederror retc 
  genwqe_next_ddcb_ready() - Figure out if the next DDCB is already finished
  @cd:         pointer to genwqe device descriptor
  We use this as condition for our wait-queue code.
 empty queue 
 ddcb ready 
  genwqe_ddcbs_in_flight() - Check how many DDCBs are in flight
  @cd:         pointer to genwqe device descriptor
  Keep track on the number of DDCBs which ware currently in the
  queue. This is needed for statistics as well as condition if we want
  to wait or better do polling in case of no interrupts available.
 statistics 
 start sequence number 
 DDCBs 
 requests 
 waitqueues 
 queue is empty 
 lastptr 
 iCRCvCRC 
	
	  In case of fatal FIR error the queue is stopped, such that
	  we can safely check it without risking anything.
	
	  Checking for errors before kicking the queue might be
	  safer, but slower for the good-case ... See above.
			
			  Since we use raw accessors, EEH errors won't be
			  detected by the platform until we do a non-raw
			  MMIO or config space read
 Don't do anything if the PCI channel is frozen 
		
		  By default GFIRs causes recovery actions. This
		  count is just for debug when recovery is masked.
  genwqe_card_thread() - Work thread for the DDCB queue
  @data:         pointer to genwqe device descriptor
  The idea is to check if there are DDCBs in processing. If there are
  some finished DDCBs, we process them and wakeup the
  requestors. Otherwise we give other processes time using
  cond_resched().
		
		  Avoid soft lockups on heavy loads; we do not want
		  to disable our interrupts.
  genwqe_setup_service_layer() - Setup DDCB queue
  @cd:         pointer to genwqe device descriptor
  Allocate DDCBs. Configure Service Layer Controller (SLC).
  Return: 0 success
	
	  We must have all wait-queues initialized when we enable the
	  interrupts. Otherwise we might crash if we get an early
	  irq.
  queue_wake_up_all() - Handles fatal error case
  @cd:         pointer to genwqe device descriptor
  The PCI device got unusable and we have to stop all pending
  requests as fast as we can. The code after this must purge the
  DDCBs in question and ensure that all mappings are freed.
  genwqe_finish_queue() - Remove any genwqe devices and user-interfaces
  @cd:         pointer to genwqe device descriptor
  Relies on the pre-condition that there are no users of the card
  device anymore e.g. with open file-descriptors.
  This function must be robust enough to be called twice.
 Do not wipe out the error state. 
	 Wake up all requests in the DDCB queue such that they
 We must wait to get rid of the DDCBs in flight 
		
		  Severe severe error situation: The card itself has
		  16 DDCB queues, each queue has e.g. 32 entries,
		  each DDBC has a hardware timeout of currently 250
		  msec but the PFs have a hardware timeout of 8 sec
		  ... so I take something large.
  genwqe_release_service_layer() - Shutdown DDCB queue
  @cd:       genwqe device descriptor
  This function must be robust enough to be called twice.
 SPDX-License-Identifier: GPL-2.0-only
  IBM Accelerator Family 'GenWQE'
  (C) Copyright IBM Corp. 2013
  Author: Frank Haverkamp <haver@linux.vnet.ibm.com>
  Author: Joerg-Stephan Vogt <jsvogt@de.ibm.com>
  Author: Michael Jung <mijung@gmx.net>
  Author: Michael Ruettger <michael@ibmra.de>
  Debugfs interfaces for the GenWQE card. Help to debug potential
  problems. Dump internal chip state for debugging and failure
  determination.
 halt the traps while dumping data 
 invalid entries 
 do not print 0x0 FIRs 
 invalid entries 
 do not print 0x0 FIRs 
 Hardware State 
 month 
 day 
 year 
 non privileged interfaces are done here 
 privileged interfaces follow here 
 SPDX-License-Identifier: GPL-2.0-only
  IBM Accelerator Family 'GenWQE'
  (C) Copyright IBM Corp. 2013
  Author: Frank Haverkamp <haver@linux.vnet.ibm.com>
  Author: Joerg-Stephan Vogt <jsvogt@de.ibm.com>
  Author: Michael Jung <mijung@gmx.net>
  Author: Michael Ruettger <michael@ibmra.de>
  Miscelanous functionality used in the other GenWQE driver parts.
  __genwqe_writeq() - Write 64-bit register
  @cd:	        genwqe device descriptor
  @byte_offs:  byte offset within BAR
  @val:        64-bit value
  Return: 0 if success; < 0 if error
  __genwqe_readq() - Read 64-bit register
  @cd:         genwqe device descriptor
  @byte_offs:  offset within BAR
  Return: value from register
  __genwqe_writel() - Write 32-bit register
  @cd:	        genwqe device descriptor
  @byte_offs:  byte offset within BAR
  @val:        32-bit value
  Return: 0 if success; < 0 if error
  __genwqe_readl() - Read 32-bit register
  @cd:         genwqe device descriptor
  @byte_offs:  offset within BAR
  Return: Value from register
  genwqe_read_app_id() - Extract app_id
  @cd:	        genwqe device descriptor
  @app_name:   carrier used to pass-back name
  @len:        length of data for name
  app_unitcfg need to be filled with valid data first
  genwqe_init_crc32() - Prepare a lookup table for fast crc32 calculations
  Existing kernel functions seem to use a different polynom,
  therefore we could not use them here.
  Genwqe's Polynomial = 0x20044009
 crc32 lookup table 
  genwqe_crc32() - Generate 32-bit crc as required for DDCBs
  @buff:       pointer to data buffer
  @len:        length of data for calculation
  @init:       initial crc (0xffffffff at start)
  polynomial = x^32  + x^29 + x^18 + x^14 + x^3 + 1 (0x20044009)
  Example: 4 bytes 0x01 0x02 0x03 0x04 with init=0xffffffff should
  result in a crc32 of 0xf33cb7d3.
  The existing kernel crc functions did not cover this polynom yet.
  Return: crc32 checksum.
 establish DMA mapping for requested pages 
 map_offs 
 FIXME rdrw 
  genwqe_alloc_sync_sgl() - Allocate memory for sgl and overlapping pages
  Allocates memory for sgl and overlapping pages. Pages which might
  overlap other user-space memory blocks are being cached for DMAs,
  such that we do not run into syncronization issues. Data is copied
  from user-space into the cached pages.
 Only use buffering on incomplete pages 
 Sync with user memory 
 Sync with user memory 
 next block if neededdma_offset 
 offset in first page 
 first set of 8 entries 
 page 
 always write the chaining entry, cleanup is done later 
 DMA mapping for requested page, offs, size 
				 pr_info("daddr combining: "
					"%016llx%08x -> %016llx\n",
 process next page 
 nothing to do 
 start new entry 
 process next page 
 nothing to do 
 continue 8 elements further 
 combining happened on last entry! 
 full shift needed on previous sgl block 
 shift all elements 
 move elements 1 up 
  genwqe_free_sync_sgl() - Free memory for sgl and overlapping pages
  @cd:	        genwqe device descriptor
  @sgl:        scatter gather list describing user-space memory
  After the DMA transfer has been completed we free the memory for
  the sgl and the cached pages. Data is being transferred from cached
  pages into user-space buffers.
  genwqe_user_vmap() - Map user-space memory to virtual kernel memory
  @cd:         pointer to genwqe device
  @m:          mapping params
  @uaddr:      user virtual address
  @size:       size of memory to be mapped
  We need to think about how we could speed this up. Of course it is
  not a good idea to do this over and over again, like we are
  currently doing it. Nevertheless, I am curious where on the path
  the performance is spend. Most probably within the memory
  allocation functions, but maybe also in the DMA mapping code.
  Restrictions: The maximum size of the possible mapping currently depends
                on the amount of memory we can get using kzalloc() for the
                page_list and pci_alloc_consistent for the sg_list.
                The sg_list is currently itself not scattered, which could
                be fixed with some effort. The page_list must be split into
                PAGE_SIZE chunks too. All that will make the complicated
                code more complicated.
  Return: 0 if success
 mark unused and not added 
 determine space needed for page_list. 
 mark unused and not added 
 mark unused and not added 
 pin user pages in memory 
 page aligned addr 
 readablewritable 
 ptrs to pages 
 assumption: pin_user_pages can be killed by signals. 
 mark unused and not added 
  genwqe_user_vunmap() - Undo mapping of user-space mem to virtual kernel
                         memory
  @cd:         pointer to genwqe device
  @m:          mapping params
 mark as unused and not added 
  genwqe_card_type() - Get chip type SLU Configuration Register
  @cd:         pointer to the genwqe device descriptor
  Return: 0: Altera Stratix-IV 230
          1: Altera Stratix-IV 530
          2: Altera Stratix-V A4
          3: Altera Stratix-V A7
  genwqe_card_reset() - Reset the card
  @cd:         pointer to the genwqe device descriptor
 new SL 
	
	  Read-modify-write to preserve the stealth bits
	 
	  For SL >= 039, Stealth WE bit allows removing
	  the read-modify-wrote.
	  r-m-w may require a mask 0x3C to avoid hitting hard
	  reset again for error reset (should be 0, chicken).
 give ERRORRESET some time to finish 
  genwqe_set_interrupt_capability() - Configure MSI capability structure
  @cd:         pointer to the device
  @count:      number of vectors to allocate
  Return: 0 if no error
  genwqe_reset_interrupt_capability() - Undo genwqe_set_interrupt_capability()
  @cd:         pointer to the device
  set_reg_idx() - Fill array with data. Ignore illegal offsets.
  @cd:         card device
  @r:          debug register array
  @i:          index to desired entry
  @m:          maximum possible entries
  @addr:       addr which is read
  @idx:        index in debug array
  @val:        read value
 Global FIR 
 UnitCfg for SLU 
 0x00000000 
 UnitCfg for APP 
 0x02000000 
 Check all chip Units 
 Unit FIR 
 Unit FEC 
 wherever there is a primary 1, read the 2ndary 
 fill with invalid data until end 
  genwqe_ffdc_buff_size() - Calculates the number of dump registers
  @cd:	        genwqe device descriptor
  @uid:	unit ID
 38:24 
 39 
 repeat 
 size in bytes! 
  genwqe_ffdc_buff_read() - Implements LogoutExtendedErrorRegisters procedure
  @cd:	        genwqe device descriptor
  @uid:	unit ID
  @regs:       register information
  @max_regs:   number of register entries
 23:0 
 38:24 
 39 
 Size in bytes! 
	
	  To save time, there are only 6 traces poplulated on Uid=2,
	  Ring=1. each with iters=512.
	for (ring = 0; ring < 8; ring++) {  0 is fls, 1 is fds,
 Number of Traps	
 Number of Traces	
 Entries per trace	
 Note: This is a combined loop that dumps both the traps 
 (for the trace == 0 case) as well as the traces 1 to    
 'traces'.						   
  genwqe_write_vreg() - Write register in virtual window
  @cd:	        genwqe device descriptor
  @reg:	register (byte) offset within BAR
  @val:	value to write
  @func:	PCI virtual function
  Note, these registers are only accessible to the PF through the
  VF-window. It is not intended for the VF to access.
  genwqe_read_vreg() - Read register in virtual window
  @cd:	        genwqe device descriptor
  @reg:	register (byte) offset within BAR
  @func:	PCI virtual function
  Note, these registers are only accessible to the PF through the
  VF-window. It is not intended for the VF to access.
  genwqe_base_clock_frequency() - Deteremine base clock frequency of the card
  @cd:	        genwqe device descriptor
  Note: From a design perspective it turned out to be a bad idea to
  use codes here to specifiy the frequencyspeed values. An old
  driver cannot understand new codes and is therefore always a
  problem. Better is to measure out the value or put the
  speedfrequency directly into a register which is always a valid
  value for old as well as for new software.
  Return: Card clock in MHz
         MHz  MHz  MHz  MHz 
 illegal value 
  genwqe_stop_traps() - Stop traps
  @cd:	        genwqe device descriptor
  Before reading out the analysis data, we need to stop the traps.
  genwqe_start_traps() - Start traps
  @cd:	        genwqe device descriptor
  After having read the data, we canmust enable the traps again.
 SPDX-License-Identifier: GPL-2.0-only
  IBM Accelerator Family 'GenWQE'
  (C) Copyright IBM Corp. 2013
  Author: Frank Haverkamp <haver@linux.vnet.ibm.com>
  Author: Joerg-Stephan Vogt <jsvogt@de.ibm.com>
  Author: Michael Jung <mijung@gmx.net>
  Author: Michael Ruettger <michael@ibmra.de>
  Character device representation of the GenWQE device. This allows
  user-space applications to communicate with the card.
  genwqe_search_pin() - Search for the mapping for a userspace address
  @cfile:	Descriptor of opened file
  @u_addr:	User virtual address
  @size:	Size of buffer
  @virt_addr:	Virtual address to be updated
  Return: Pointer to the corresponding mapping	NULL if not found
  __genwqe_search_mapping() - Search for the mapping for a userspace address
  @cfile:	descriptor of opened file
  @u_addr:	user virtual address
  @size:	size of buffer
  @dma_addr:	DMA address to be updated
  @virt_addr:	Virtual address to be updated
  Return: Pointer to the corresponding mapping	NULL if not found
			 match found: current is as expected and
		
		  This is really a bug, because those things should
		  have been already tidied up.
		 
		  GENWQE_MAPPING_RAW should have been removed via mmunmap().
		  GENWQE_MAPPING_SGL_TEMP should be removed by tidy up code.
 we allocated this dynamically 
 we use dma_map statically from the request 
		
		  This is not a bug, because a killed processed might
		  not call the unpin ioctl, which is supposed to free
		  the resources.
		 
		  Pinnings are dymically allocated and need to be
		  deleted.
  genwqe_kill_fasync() - Send signal to all processes with open GenWQE files
  @cd: GenWQE device information
  @sig: Signal to send out
  E.g. genwqe_send_signal(cd, SIGIO);
  genwqe_open() - file open
  @inode:      file system information
  @filp:	file handle
  This function is executed whenever an application calls
  open("devgenwqe",..).
  Return: 0 if successful or <0 if errors
 list of raw memory allocations 
 list of user pinned memory 
  genwqe_fasync() - Setup process to receive SIGIO.
  @fd:        file descriptor
  @filp:      file handle
  @mode:      file mode
  Sending a signal is working as following:
  if (cdev->async_queue)
          kill_fasync(&cdev->async_queue, SIGIO, POLL_IN);
  Some devices also implement asynchronous notification to indicate
  when the device can be written; in this case, of course,
  kill_fasync must be called with a mode of POLL_OUT.
  genwqe_release() - file close
  @inode:      file system information
  @filp:       file handle
  This function is executed whenever an application calls 'close(fd_genwqe)'
  Return: always 0
 there must be no entries in these lists! 
 remove this filp from the asynchronously notified filp's 
	
	  For this to work we must not release cd when this cfile is
	  not yet released, otherwise the list entry is invalid,
	  because the list itself gets reinstantiated!
 nothing ... 
  genwqe_vma_close() - Called each time when vma is unmapped
  @vma: VMA area to close
  Free memory which got allocated by GenWQE mmap().
  genwqe_mmap() - Provide contignous buffers to userspace
  @filp:	File pointer (unused)
  @vma:	VMA area to map
  We use mmap() to allocate contignous buffers used for DMA
  transfers. After the buffer is allocated we remap it to user-space
  and remember a reference to our dma_mapping data structure, where
  we store the associated DMA address and allocated size.
  When we receive a DDCB execution request with the ATS bits set to
  plain buffer, we lookup our dma_mapping list to find the
  corresponding DMA address for the associated user-space address.
 we use 256k blocks 
  do_flash_update() - Excute flash update (write image or CVPD)
  @cfile:	Descriptor of opened file
  @load:      details about image load
  Return: 0 if successful
 FIXME Bits have changed for new service layer! 
 downloaderase_firstpart_0 
 downloaderase_firstpart_1 
 downloaderase_firstvpd 
		
		  We must be 4 byte aligned. Buffer must be 0 appened
		  to have defined values when calculating CRC.
 prepare DDCB for SLU process 
 prepare invariant values 
 for simulation only 
 bytes included in crc calc 
 setup DDCB for ATS architecture 
 resvd 
 for simulation only 
 Rd only 
 bytes included in crc calc 
 For Genwqe5 we get back the calculated CRC 
 0x80 
 FIXME Bits have changed for new service layer! 
 uploadpart_0 
 uploadpart_1 
 uploadvpd 
		
		  We must be 4 byte aligned. Buffer must be 0 appened
		  to have defined values when calculating CRC.
 prepare DDCB for SLU process 
 prepare invariant values 
 CRC ;
 bytes included in crc calc 
 setup DDCB for ATS architecture 
 resvd 
 CRC 
 rdwr 
 bytes included in crc calc 
 we only get back the calculated CRC 
 0x80 
 We know that we can get retc 0x104 with CRC err 
 Normally ignore CRC error 
 Everything was fine 
  ddcb_cmd_cleanup() - Remove dynamically created fixup entries
  @cfile:	Descriptor of opened file
  @req:	DDCB work request
  Only if there are any. Pinnings are not removed.
  ddcb_cmd_fixups() - Establish DMA fixupssglists for user memory references
  @cfile:	Descriptor of opened file
  @req:	DDCB work request
  Before the DDCB gets executed we need to handle the fixups. We
  replace the user-space addresses with DMA addresses or do
  additional setup work e.g. generating a scatter-gather list which
  is used to describe the memory referred to in the fixup.
 nothing to do here 
			
			  No data available. Ignore u_addr in this
			  case and set addr to 0. Hardware must not
			  fetch the buffer.
			
			  No data available. Ignore u_addr in this
			  case and set addr to 0. Hardware must not
			  fetch the empty sgl.
 create genwqe style scatter gather list 
  genwqe_execute_ddcb() - Execute DDCB using userspace address fixups
  @cfile:	Descriptor of opened file
  @cmd:        Command identifier (passed from user)
  The code will build up the translation tables or lookup the
  contignous memory allocation table to find the right translations
  and DMA addresses.
	 Copy back only the modifed fields. Do not copy ASIV
  genwqe_ioctl() - IO control
  @filp:       file handle
  @cmd:        command identifier (passed from user)
  @arg:        argument (passed from user)
  Return: 0 success
 Return -EIO if card hit EEH 
 Register access 
 Flash updatereading 
 known to fail for old versions 
 memory pinning and unpinning 
 launch an DDCB and wait for completion 
  genwqe_device_create() - Create and configure genwqe char device
  @cd:      genwqe device descriptor
  This function must be called before we create any more genwqe
  character devices, because it is allocating the major and minor
  number which are supposed to be used by the client drivers.
	
	  Here starts the individual setup per client. It must
	  initialize its own cdev data structure with its own fops.
	  The appropriate devnum needs to be created. The ranges must
	  not overlap.
	
	  Finally the device in dev... must be created. The rule is
	  to use card%d_clientname for each created device.
 give kill_timeout seconds to close file descriptors ... 
 if no open files we can safely continue, else ... 
 Give kill_timout more seconds to end processes 
  genwqe_device_remove() - Remove genwqe's char device
  @cd: GenWQE device information
  This function must be called after the client devices are removed
  because it will free the majorminor number range for the genwqe
  drivers.
  This function must be robust enough to be called twice.
	
	  We currently do wait until all filedescriptors are
	  closed. This leads to a problem when we abort the
	  application which will decrease this reference from
	  1unused to 0illegal and not from 2used 1empty.
 SPDX-License-Identifier: GPL-2.0-only
  IBM Accelerator Family 'GenWQE'
  (C) Copyright IBM Corp. 2013
  Author: Frank Haverkamp <haver@linux.vnet.ibm.com>
  Author: Joerg-Stephan Vogt <jsvogt@de.ibm.com>
  Author: Michael Jung <mijung@gmx.net>
  Author: Michael Ruettger <michael@ibmra.de>
  Sysfs interfaces for the GenWQE card. There are attributes to query
  the version of the bitstream as well as some for the driver. For
  debugging, please also see the debugfs interfaces of this driver.
  curr_bitstream_show() - Show the current bitstream id
  There is a bug in some old versions of the CPLD which selects the
  bitstream, which causes the IO_SLU_BITSTREAM register to report
  unreliable data in very rare cases. This makes this sysfs
  unreliable up to the point were a new CPLD version is being used.
  Unfortunately there is no automatic way yet to query the CPLD
  version, such that you need to manually ensure via programming
  tools that you have a recent version of the CPLD software.
  The proposed circumvention is to use a special recovery bitstream
  on the backup partition (0) to identify problems while loading the
  image.
  next_bitstream_show() - Show the next activated bitstream
  IO_SLC_CFGREG_SOFTRESET: This register can only be accessed by the PF.
 error 
  Create device_attribute structures  params: name, mode, show, store
  additional flag if valid in VF
  genwqe_is_visible() - Determine if sysfs attribute should be visible or not
  VFs have restricted mmio capabilities, so not all sysfs entries
  are allowed in VFs.
 SPDX-License-Identifier: GPL-2.0-only
  IBM Accelerator Family 'GenWQE'
  (C) Copyright IBM Corp. 2013
  Author: Frank Haverkamp <haver@linux.vnet.ibm.com>
  Author: Joerg-Stephan Vogt <jsvogt@de.ibm.com>
  Author: Michael Jung <mijung@gmx.net>
  Author: Michael Ruettger <michael@ibmra.de>
  Module initialization and PCIe setup. Card health monitoring and
  recovery functionality. Character device creation and deletion are
  controlled from here.
 PCI structure for identifying device by PCI vendor and device ID 
 Initial SR-IOV bring-up image 
 VF Vendor ID 
 VF Device ID 
 Fixed up image 
 VF Vendor ID 
 VF Device ID 
 Even one more ... 
 0 terminated list. 
  genwqe_dev_alloc() - Create and prepare a new card descriptor
  Return: Pointer to card descriptor, or ERR_PTR(err) on error
	
	  This comes from kernel config option and can be overritten via
	  debugfs.
  genwqe_bus_reset() - Card recovery
  @cd: GenWQE device information
  pci_reset_function() will recover the device and ensure that the
  registers are accessible again when it completes with success. If
  not, the card will stay dead and registers will be unaccessible
  still.
	
	  FirmwareBIOS might change memory mapping during bus reset.
	  Settings like enable bus-mastering, ... are backuped and
	  restored by the pci_reset_function().
	
	  Here is the right spot to clear the register read
	  failure. pci_bus_reset() does this job in real systems.
  Hardware circumvention section. Certain bitstreams in our test-lab
  had different kinds of problems. Here is where we adjust those
  bitstreams to function will with this version of our device driver.
  Thise circumventions are applied to the physical function only.
  The magical numbers below are identifying developmentmanufacturing
  versions of the bitstream used on the card.
  Turn off error reporting for oldmanufacturing images.
 Mask FIRs for development images 
  genwqe_recovery_on_fatal_gfir_required() - Version depended actions
  @cd: GenWQE device information
  Bitstreams older than 2013-02-17 have a bug where fatal GFIRs must
  be ignored. This is e.g. true for the bitstream we gave to the card
  manufacturer, but also for some old bitstreams we released to our
  test-lab.
  genwqe_T_psec() - Calculate PFVF timeout register content
  @cd: GenWQE device information
  Note: From a design perspective it turned out to be a bad idea to
  use codes here to specifiy the frequencyspeed values. An old
  driver cannot understand new codes and is therefore always a
  problem. Better is to measure out the value or put the
  speedfrequency directly into a register which is always a valid
  value for old as well as for new software.
 T = 1f 
 1f -> 250,  200,  166,  175 
 illegal value 
  genwqe_setup_pf_jtimer() - Setup PF hardware timeouts for DDCB execution
  @cd: GenWQE device information
  Do this _after_ card_reset() is called. Otherwise the values will
  vanish. The settings need to be done when the queues are inactive.
  The max. timeout value is 2^(10+x)  T (6ns for 166MHz)  1516.
  The min. timeout value is 2^(10+x)  T (6ns for 166MHz)  1416.
 PF: large value needed, flash update 2sec per block 
  genwqe_setup_vf_jtimer() - Setup VF hardware timeouts for DDCB execution
  @cd: GenWQE device information
 currently support only the debug units mentioned here 
		
		  regs == NULL is ok, the using code treats this as no regs,
		  Printing warning is ok in this case.
	
	  Is access to all registers possible? If we are a VF the
	  answer is obvious. If we run fully virtualized, we need to
	  check if we can access all registers. If we do not have
	  full access we will cause an UR and some informational FIRs
	  in the PF, but that should not harm.
 do this after the tweaks. alloc fail is acceptable 
 Collect registers e.g. FIRs, UNITIDs, traces ... 
			
			  Stealth Mode: Reload chip on either hot
			  reset or PERST.
			
			  Re-read the IDs because
			  it could happen that the bitstream load
			  failed!
 does a reset to the card 
 code is running _after_ reset 
  genwqe_stop() - Stop card operation
  @cd: GenWQE device information
  Recovery notes:
    As long as genwqe_thread runs we might access registers during
    error data capture. Same is with the genwqe_health_thread.
    When genwqe_bus_reset() fails this function might called two times:
    first by the genwqe_health_thread() and later by genwqe_remove() to
    unbind the device. We must be able to survive that.
  This function must be robust enough to be called twice.
 no register access 
 device removed, procs killed 
 here genwqe_thread is stopped 
 access pci config space 
  genwqe_recover_card() - Try to recover the card if it is possible
  @cd: GenWQE device information
  @fatal_err: Indicate whether to attempt soft reset
  If fatal_err is set no register access is possible anymore. It is
  likely that genwqe_start fails in that situation. Proper error
  handling is required in this case.
  genwqe_bus_reset() will cause the pci code to call genwqe_remove()
  and later genwqe_probe() for all virtual functions.
	
	  Make sure chip is not reloaded to maintain FFDC. Write SLU
	  Reset Register, CPLDReset field to 0.
  genwqe_fir_checking() - Check the fault isolation registers of the card
  @cd: GenWQE device information
  If this code works ok, can be tried out with help of the genwqe_poke tool:
    sudo .toolsgenwqe_poke 0x8 0xfefefefefef
  Now the relevant FIRssFIRs should be printed out and the driver should
  invoke recovery (devices are removed and readded).
	
	  Avoid printing when to GFIR bit is on prevents contignous
	  printout e.g. for the following bug:
	    FIR set without a 2ndary FIRFIR cannot be cleared
	  Comment out the following if to get the prints:
 fatal errors 
 0..2 in zEDC 
 read the primary FIR (pfir) 
 no error in this unit 
 read primary FEC 
 secondary fir empty, skip it 
			 gfir turned on during routine! get out and
 do not clear if we entered with a fatal gfir 
 NEW clear by mask the logged bits 
				
				  note, these cannot be error-Firs
				  since gfir_masked is 0 after sfir
				  was read. Also, it is safe to do
				  this write if sfir=0. Still need to
				  clear the primary. This just means
				  there is no secondary FIR.
 clear by mask the logged bit. 
		
		  Check once more that it didn't go on after all the
		  FIRS were cleared.
  genwqe_pci_fundamental_reset() - trigger a PCIe fundamental reset on the slot
  @pci_dev:	PCI device information struct
  Note: pci_set_pcie_reset_state() is not implemented on all archs, so this
  reset method will not work in all cases.
  Return: 0 on success or error code from pci_set_pcie_reset_state()
	
	  lock pci config space access from userspace,
	  save state and issue PCIe fundamental reset
 keep PCIe reset asserted for 250ms 
 Wait for 2s to reload flash and train the link 
 Clear out error injection flags 
 Try recoverying the card with fundamental reset 
  genwqe_reload_bistream() - reload card bitstream
  @cd: GenWQE device information
  Set the appropriate register and call fundamental reset to reaload the card
  bitstream.
  Return: 0 on success, error code otherwise
	
	  Cause a CPLD reprogram with the 'next_bitstream'
	  partition on PCIe hot or fundamental reset
		
		  A fundamental reset failure can be caused
		  by lack of support on the arch, so we just
		  log the error and try to start the card
		  again.
  genwqe_health_thread() - Health checking thread
  @data: GenWQE device information
  This thread is only started for the PF of the card.
  This thread monitors the health of the card. A critical situation
  is when we read registers which contain -1 (IO_ILLEGAL_VALUE). In
  this case we need to be recovered from outside. Writing to
  registers will very likely not work either.
  This thread must only exit if kthread_should_stop() becomes true.
  Condition for the health-thread to trigger:
    a) when a kthread_stop() request comes in or
    b) a critical GFIR occured
  Informational GFIRs are checked and potentially printed in
  GENWQE_HEALTH_CHECK_INTERVAL seconds.
		
		  GFIR ErrorTrigger bits set => reset the card!
		  Never do this for oldmanufacturing images!
 FIXME Card is unusable and needs unbind! 
 Userspace requested card bitstream reload 
		
		  Since we use raw accessors, EEH errors won't be detected
		  by the platform until we do a non-raw MMIO or config space
		  read
 We do nothing if the card is going over PCI recovery 
		
		  If it's supported by the platform, we try a fundamental reset
		  to recover from a fatal error. Otherwise, we continue to wait
		  for an external recovery procedure to take care of it.
 Bring down logical devices to inform user space via udev remove. 
 genwqe_bus_reset failed(). Now wait for genwqe_remove(). 
 valid for disabling the service 
 moved before request_irq() 
 init_waitqueue_head(&cd->health_waitq); 
  genwqe_pci_setup() - Allocate PCIe related resources for our card
  @cd: GenWQE device information
 Reserve PCI IO and memory resources 
 check for 64-bit DMA address supported (DAC) 
 check for 32-bit DMA address supported (SAC) 
 EEH recovery requires PCIe fundamental reset 
 request complete BAR-0 space (length = 0) 
  genwqe_pci_remove() - Free PCIe related resources for our card
  @cd: GenWQE device information
  genwqe_probe() - Device initialization
  @pci_dev:	PCI device information struct
  @id:		PCI device ID
  Callable for multiple cards. This function is called on bind.
  Return: 0 if succeeded, < 0 when failed
  genwqe_remove() - Called when device is removed (hot-plugable)
  @pci_dev:	PCI device information struct
  Or when driver is unloaded respecitively when unbind is done.
	
	  genwqe_stop() must survive if it is called twice
	  sequentially. This happens when the health thread calls it
	  and fails on genwqe_bus_reset().
  genwqe_err_error_detected() - Error detection callback
  @pci_dev:	PCI device information struct
  @state:	PCI channel state
  This callback is called by the PCI subsystem whenever a PCI bus
  error is detected.
 Stop the card 
	
	  On permanent failure, the PCI code will call device remove
	  after the return of this function.
	  genwqe_stop() can be called twice.
  genwqe_devnode() - Set default access mode for genwqe devices.
  @dev:	Pointer to device (unused)
  @mode:	Carrier to pass-back given mode (permissions)
  Default mode should be rw for everybody. Do not change default
  device name.
  genwqe_init_module() - Driver registration and initialization
  genwqe_exit_module() - Driver exit
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2018 Oleksij Rempel <linux@rempel-privat.de>
  Driver for Alcor Micro AU6601 and AU6621 controllers
	
	  A device might be attached to root complex directly and
	  priv->parent_pdev will be NULL. In this case we don't check its
	  capability and disable ASPM completely.
 link capability 
 make sure irqs are disabled 
 CONFIG_PM_SLEEP 
 SPDX-License-Identifier: GPL-2.0-or-later
 Driver for Realtek PCI-Express card reader
  Copyright(c) 2018-2019 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Ricky WU <ricky_wu@realtek.com>
    Rui FENG <rui_feng@realsil.com.cn>
    Wei WANG <wei_wang@realsil.com.cn>
 0x724~0x727 
 0x814~0x817 
 Set relink_time to 0 
 SD Pull Control Enable:
      SD_DAT[3:0] ==> pull up
      SD_CD       ==> pull up
      SD_WP       ==> pull up
      SD_CMD      ==> pull up
      SD_CLK      ==> pull down
 SD Pull Control Disable:
      SD_DAT[3:0] ==> pull down
      SD_CD       ==> pull up
      SD_WP       ==> pull down
      SD_CMD      ==> pull down
      SD_CLK      ==> pull down
 Initialize SD_CFG1 register 
 Reset SD_CFG3 register 
 set pad drive 
 LED shine disabled, set initial shine cycle period 
 Configure driving 
	
	  If u_force_clkreq_0 is enabled, CLKREQ# PIN will be forced
	  to drive low, and we forcibly request clock.
 run, latency: 60us 
 l1off, latency: 300us 
 We use 250k(around) here, in initial stage 
 Wait SSC clock stable 
 init latency of active, idle, L1OFF to 60us, 300us, 3ms 
 SPDX-License-Identifier: GPL-2.0-only
 Driver for Realtek USB card reader
  Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Roger Tseng <rogerable@realtek.com>
 4-byte aligned part 
 unaligned part 
 usb_control_msg may return positive when success 
 We use 250k(around) here, in initial stage 
 Converting clock value into internal settings: n and div 
 Make sure that the SSC clock div_n is not less than MIN_DIV_N 
 Wait SSC clock stable 
	
	  If get status fails, return 0 (ok) for the exclusive check
	  and let the flow fail at somewhere else.
 config non-crystal mode 
 power on SSC 
 determine IC version 
 determine package 
 determine IC variations 
 initialize 
 initialize USB SG transfer timer 
 Defer the autosuspend if card exists 
 There is an ongoing operation
 CONFIG_PM 
 CONFIG_PM 
 SPDX-License-Identifier: GPL-2.0-or-later
 Driver for Realtek PCI-Express card reader
  Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Wei WANG <wei_wang@realsil.com.cn>
 Configure GPIO as output 
 Reset ASPM state to default value 
 Force CLKREQ# PIN to drive 0 to request clock 
 Switch LDO3318 source from DV33 to card_3v3 
 LED shine disabled, set initial shine cycle period 
 Configure driving 
 Optimize RX sensitivity 
 To avoid too large in-rush current 
 SD Pull Control Enable:
      SD_DAT[3:0] ==> pull up
      SD_CD       ==> pull up
      SD_WP       ==> pull up
      SD_CMD      ==> pull up
      SD_CLK      ==> pull down
 For RTS5229 version C 
 SD Pull Control Disable:
      SD_DAT[3:0] ==> pull down
      SD_CD       ==> pull up
      SD_WP       ==> pull down
      SD_CMD      ==> pull down
      SD_CLK      ==> pull down
 For RTS5229 version C 
 MS Pull Control Enable:
      MS CD       ==> pull up
      others      ==> pull down
 MS Pull Control Disable:
      MS CD       ==> pull up
      others      ==> pull down
 SPDX-License-Identifier: GPL-2.0-or-later
 Driver for Realtek PCI-Express card reader
  Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Wei WANG <wei_wang@realsil.com.cn>
 Fixes DMA transfer timout issue after disabling ASPM on RTS5260 
 If pci device removed, don't queue idle work any more 
 Hardware Auto Response 
 set up data structures for the wakeup system 
 Hardware Auto Response 
 Wait for TRANS_OK_INT 
 Enable Bus Interrupt 
 We use 250k(around) here, in initial stage 
 Reduce card clock by 20MHz each time a DMA transfer error occurs 
 Make sure that the SSC clock div_n is not less than MIN_DIV_N_PCR 
 Wait SSC clock stable 
		 When using single PMOS, accessing card is not permitted
		  if the existing card is not the designated one.
 Clear interrupt flag 
 Set relink_time to 0 
 Power on SSC 
 Gating real mcu clock 
 Wait SSC power stable 
 Set mcu_cnt to 7 to ensure data can be sampled properly 
 Disable card clock 
 Reset delink mode 
 Card driving select 
 Enable SSC Clock 
 Disable cd_pwr_save 
 Clear Link Ready Interrupt 
	 Enlarge the estimation window of PERST# glitch
	  to reduce the chance of invalid card interrupt
	 Update RC oscillator to 400k
	  bit[0] F_HIGH: for RC oscillator, Rst_value is 1'b1
	                 1: 2M  0: 400k
	 Set interrupt write clear
	  bit 1: U_elbi_if_rd_clr_en
	 	1: Enable ELBI interrupt[31:22] & [7:0] flag read clear
	 	0: ELBI interrupt flag[31:22] & [7:0] only can be write clear
init ocp
 Enable clk_request_n to enable clock power management 
 Enter L1 when host tx idle 
	 No CD interrupt if probing driver with card inserted.
	  So we need to initialize pcr->card_exist here.
 Disable interrupts at the pcr level 
 CONFIG_PM 
 CONFIG_PM 
 SPDX-License-Identifier: GPL-2.0-or-later
 Driver for Realtek PCI-Express card reader
  Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Wei WANG <wei_wang@realsil.com.cn>
    Roger Tseng <rogerable@realtek.com>
 Configure GPIO as output 
 Reset ASPM state to default value 
 Switch LDO3318 source from DV33 to card_3v3 
 LED shine disabled, set initial shine cycle period 
 Configure LTR 
 Configure OBFF 
 Configure driving 
 Configure force_clock_req 
 Optimize RX sensitivity 
 To avoid too large in-rush current 
 set pad drive 
 SD Pull Control Enable:
      SD_DAT[3:0] ==> pull up
      SD_CD       ==> pull up
      SD_WP       ==> pull up
      SD_CMD      ==> pull up
      SD_CLK      ==> pull down
 SD Pull Control Disable:
      SD_DAT[3:0] ==> pull down
      SD_CD       ==> pull up
      SD_WP       ==> pull down
      SD_CMD      ==> pull down
      SD_CLK      ==> pull down
 MS Pull Control Enable:
      MS CD       ==> pull up
      others      ==> pull down
 MS Pull Control Disable:
      MS CD       ==> pull up
      others      ==> pull down
 Power down OCP for power consumption 
 set pad drive 
 run, latency: 60us 
 l1off, latency: 300us 
 rts522a operations mainly derived from rts5227, except phyhw init setting.
 init latency of active, idle, L1OFF to 60us, 300us, 3ms 
 SPDX-License-Identifier: GPL-2.0-or-later
 Driver for Realtek PCI-Express card reader
  Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Wei WANG <wei_wang@realsil.com.cn>
 Turn off LED 
 Reset ASPM state to default value 
 Force CLKREQ# PIN to drive 0 to request clock 
 Configure GPIO as output 
 Configure driving 
 To avoid too large in-rush current 
 SD Pull Control Enable:
      SD_DAT[3:0] ==> pull up
      SD_CD       ==> pull up
      SD_WP       ==> pull up
      SD_CMD      ==> pull up
      SD_CLK      ==> pull down
 SD Pull Control Disable:
      SD_DAT[3:0] ==> pull down
      SD_CD       ==> pull up
      SD_WP       ==> pull down
      SD_CMD      ==> pull down
      SD_CLK      ==> pull down
 MS Pull Control Enable:
      MS CD       ==> pull up
      others      ==> pull down
 MS Pull Control Disable:
      MS CD       ==> pull up
      others      ==> pull down
 SPDX-License-Identifier: GPL-2.0-or-later
 Driver for Realtek PCI-Express card reader
  Copyright(c) 2016-2017 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Steven FENG <steven_feng@realsil.com.cn>
    Rui FENG <rui_feng@realsil.com.cn>
    Wei WANG <wei_wang@realsil.com.cn>
 SD Pull Control Enable:
      SD_DAT[3:0] ==> pull up
      SD_CD       ==> pull up
      SD_WP       ==> pull up
      SD_CMD      ==> pull up
      SD_CLK      ==> pull down
 SD Pull Control Disable:
      SD_DAT[3:0] ==> pull down
      SD_CD       ==> pull up
      SD_WP       ==> pull down
      SD_CMD      ==> pull down
      SD_CLK      ==> pull down
 MS Pull Control Enable:
      MS CD       ==> pull up
      others      ==> pull down
 MS Pull Control Disable:
      MS CD       ==> pull up
      others      ==> pull down
 Initialize SD_CFG1 register 
 Reset SD_CFG3 register 
 set pad drive 
 Rest L1SUB Config 
Option cut APHY
CDR DEC
PWMPFM
No Power Saving WA
 Set mcu_cnt to 7 to ensure data can be sampled properly 
 force no MDIO
Modify SDVCC Tune Default Parameters!
	
	  If u_force_clkreq_0 is enabled, CLKREQ# PIN will be forced
	  to drive low, and we forcibly request clock.
 run, latency: 60us 
 l1off, latency: 300us 
 init latency of active, idle, L1OFF to 60us, 300us, 3ms 
 SPDX-License-Identifier: GPL-2.0-or-later
 Driver for Realtek PCI-Express card reader
  Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Wei WANG <wei_wang@realsil.com.cn>
 Wait transfer end 
 Wait transfer end 
 Wait transfer end 
 Rest L1SUB Config 
 Configure GPIO as output 
 Reset ASPM state to default value 
 Switch LDO3318 source from DV33 to card_3v3 
 LED shine disabled, set initial shine cycle period 
 Configure driving 
	
	  If u_force_clkreq_0 is enabled, CLKREQ# PIN will be forced
	  to drive low, and we forcibly request clock.
 set pad drive 
 SD Pull Control Enable:
      SD_DAT[3:0] ==> pull up
      SD_CD       ==> pull up
      SD_WP       ==> pull up
      SD_CMD      ==> pull up
      SD_CLK      ==> pull down
 SD Pull Control Disable:
      SD_DAT[3:0] ==> pull down
      SD_CD       ==> pull up
      SD_WP       ==> pull down
      SD_CMD      ==> pull down
      SD_CLK      ==> pull down
 MS Pull Control Enable:
      MS CD       ==> pull up
      others      ==> pull down
 MS Pull Control Disable:
      MS CD       ==> pull up
      others      ==> pull down
 Init latency of active, idle, L1OFF to 60us, 300us, 3ms 
 Run, latency: 60us 
 L1off, latency: 300us 
 SPDX-License-Identifier: GPL-2.0-or-later
 Driver for Realtek PCI-Express card reader
  Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Wei WANG <wei_wang@realsil.com.cn>
    Roger Tseng <rogerable@realtek.com>
 To avoid too large in-rush current 
 Enable card CD 
 Enable card interrupt 
 Disable SD interrupt 
 Disable MS interrupt 
 SD Pull Control Enable:
      SD_DAT[3:0] ==> pull up
      SD_CD       ==> pull up
      SD_WP       ==> pull up
      SD_CMD      ==> pull up
      SD_CLK      ==> pull down
 SD Pull Control Disable:
      SD_DAT[3:0] ==> pull down
      SD_CD       ==> pull up
      SD_WP       ==> pull down
      SD_CMD      ==> pull down
      SD_CLK      ==> pull down
 MS Pull Control Enable:
      MS CD       ==> pull up
      others      ==> pull down
 MS Pull Control Disable:
      MS CD       ==> pull up
      others      ==> pull down
 SPDX-License-Identifier: GPL-2.0-or-later
 Driver for Realtek PCI-Express card reader
  Copyright(c) 2018-2019 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Rui FENG <rui_feng@realsil.com.cn>
    Wei WANG <wei_wang@realsil.com.cn>
 0x814~0x817 
 Not support MMC default 
 TO do: need to add rtd3 function 
 0x724~0x727 
 Set relink_time to 0 
 SD Pull Control Enable:
      SD_DAT[3:0] ==> pull up
      SD_CD       ==> pull up
      SD_WP       ==> pull up
      SD_CMD      ==> pull up
      SD_CLK      ==> pull down
 SD Pull Control Disable:
      SD_DAT[3:0] ==> pull down
      SD_CD       ==> pull up
      SD_WP       ==> pull down
      SD_CMD      ==> pull down
      SD_CLK      ==> pull down
 Initialize SD_CFG1 register 
 Reset SD_CFG3 register 
 set pad drive 
 Wait transfer end 
 0x816 
 power off efuse 
 Release PRSNT# 
 LED shine disabled, set initial shine cycle period 
 Configure driving 
	
	  If u_force_clkreq_0 is enabled, CLKREQ# PIN will be forced
	  to drive low, and we forcibly request clock.
 Clear Enter RTD3_cold Information
 run, latency: 60us 
 l1off, latency: 300us 
 We use 250k(around) here, in initial stage 
 Wait SSC clock stable 
 init latency of active, idle, L1OFF to 60us, 300us, 3ms 
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  Copyright (c) 2004-2009 Silicon Graphics, Inc.  All Rights Reserved.
  Cross Partition Communication (XPC) channel support.
 	This is the part of XPC that manages the channels and
 	sendsreceives messages across them tofrom other partitions.
  Process a connect message from a remote partition.
  Note: xpc_process_connect() is expecting to be called with the
  spin_lock_irqsave held and will leave it locked upon return.
 nothing more to do for now 
 clear all else 
  spin_lock_irqsave() is expected to be held on entry.
 make sure all activity has settled down first 
 can't proceed until the other side disengages from us 
 as long as the other side is up do the full protocol 
 wake those waiting for notify completion 
 we do callout while holding ch->lock, callout can't block 
 both sides are disconnected now 
 it's now safe to free the channel's message queues 
	
	  Mark the channel disconnected and clear all other flags, including
	  XPC_C_SETUP (because of call to
	  xpc_arch_ops.teardown_msg_structures()) but not including
	  XPC_C_WDISCONNECT (if it was set).
 we won't lose the CPU since we're holding ch->lock 
 time to take action on any delayed chctl flags 
  Process a change in the channel's remote connection state.
		
		  Delay processing chctl flags until thread waiting disconnect
		  has had a chance to see that the channel is disconnected.
		
		  If RCLOSEREQUEST is set, we're probably waiting for
		  RCLOSEREPLY. We should find it and a ROPENREQUEST packed
		  with this RCLOSEREQUEST in the chctl_flags.
 both sides have finished disconnecting 
		
		  The meaningful CLOSEREQUEST connection state fields are:
		       reason = reason connection is to be closed
 both sides have finished disconnecting 
		
		  The meaningful OPENREQUEST connection state fields are:
		       entry_size = size of channel's messages in bytes
		       local_nentries = remote partition's local_nentries
 assume OPENREQUEST was delayed by mistake 
		
		  The meaningful OPENREPLY connection state fields are:
		       local_msgqueue_pa = physical address of remote
		                           partition's local_msgqueue
		       local_nentries = remote partition's local_nentries
		       remote_nentries = remote partition's remote_nentries
  Attempt to establish a channel connection to a remote partition.
 add info from the channel connect registration to the channel 
 the local and remote sides aren't the same 
			
			  Because XPC_DISCONNECT_CHANNEL() can block we're
			  forced to up the registration sema before we unlock
			  the channel lock. But that's okay here because we're
			  done with the part that required the registration
			  sema. XPC_DISCONNECT_CHANNEL() requires that the
			  channel lock be locked and will unlock and relock
			  the channel lock as needed.
 initiate the connection 
	
	  Initiate channel connections for registered channels.
	 
	  For each connected channel that has pending messages activate idle
	  kthreads andor create new kthreads as needed.
		
		  Process any open or close related chctl flags, and then deal
		  with connecting or disconnecting the channel as required.
 need an atomic snapshot of flags 
		
		  Process any message related chctl flags, this may involve
		  the activation of kthreads to deliver any pending messages
		  sent from the other partition.
  XPC's heartbeat code calls this function to inform XPC that a partition is
  going down.  XPC responds by tearing down the XPartition Communication
  infrastructure used for the just downed partition.
  XPC's heartbeat code will never call this function and xpc_partition_up()
  at the same time. Nor will it ever make multiple calls to either function
  at the same time.
 infrastructure for this partition isn't currently set up 
 disconnect channels associated with the partition going down 
  Called by XP at the time of channel connection registration to cause
  XPC to establish connections to all currently active partitions.
			
			  Initiate the establishment of a connection on the
			  newly registered channel to the remote partition.
 let the registerer know that a connection has been established 
  Called by XP at the time of channel connection unregistration to cause
  XPC to teardown all current connections for the specified channel.
  Before returning xpc_initiate_disconnect() will wait until all connections
  on the specified channel have been closedtorndown. So the caller can be
  assured that they will not be receiving any more callouts from XPC to the
  function they registered via xpc_connect().
  Arguments:
 	ch_number - channel # to unregister.
 initiate the channel disconnect for every active partition 
  To disconnect a channel, and reflect it back to all who may be waiting.
  An OPEN is not allowed until XPC_C_DISCONNECTING is cleared by
  xpc_process_disconnect(), and if set, XPC_C_WDISCONNECT is cleared by
  xpc_disconnect_wait().
  THE CHANNEL IS TO BE LOCKED BY THE CALLER AND WILL REMAIN LOCKED UPON RETURN.
 some of these may not have been set 
 wake all idle kthreads so they can exit 
 start a kthread that will do the xpDisconnecting callout 
 wake those waiting to allocate an entry from the local msg queue 
	
	  Let the channel's registerer know that the channel is being
	  disconnected. We don't want to do this if the registerer was never
	  informed of a connection being made.
  Wait for a message entry to become available for the specified channel,
  but don't wait any longer than 1 jiffy.
  Send a message that contains the user's payload on the specified channel
  connected to the specified partition.
  NOTE that this routine can sleep waiting for a message entry to become
  available. To not sleep, pass in the XPC_NOWAIT flag.
  Once sent, this routine will not wait for the message to be received, nor
  will notification be given when it does happen.
  Arguments:
 	partid - ID of partition to which the channel is connected.
 	ch_number - channel # to send message on.
 	flags - see xp.h for valid flags.
 	payload - pointer to the payload which is to be sent.
 	payload_size - size of the payload in bytes.
  Send a message that contains the user's payload on the specified channel
  connected to the specified partition.
  NOTE that this routine can sleep waiting for a message entry to become
  available. To not sleep, pass in the XPC_NOWAIT flag.
  This routine will not wait for the message to be sent or received.
  Once the remote end of the channel has received the message, the function
  passed as an argument to xpc_initiate_send_notify() will be called. This
  allows the sender to free up or re-use any buffers referenced by the
  message, but does NOT mean the message has been processed at the remote
  end by a receiver.
  If this routine returns an error, the caller's function will NOT be called.
  Arguments:
 	partid - ID of partition to which the channel is connected.
 	ch_number - channel # to send message on.
 	flags - see xp.h for valid flags.
 	payload - pointer to the payload which is to be sent.
 	payload_size - size of the payload in bytes.
 	func - function to call with asynchronous notification of message
 		  receipt. THIS FUNCTION MUST BE NON-BLOCKING.
 	key - user-defined key to be passed to the function when it's called.
  Deliver a message's payload to its intended recipient.
		
		  This ref is taken to protect the payload itself from being
		  freed before the user is finished with it, which the user
		  indicates by calling xpc_initiate_received().
 deliver the message to its intended recipient 
  Acknowledge receipt of a delivered message's payload.
  This function, although called by users, does not call xpc_part_ref() to
  ensure that the partition infrastructure is in place. It relies on the
  fact that we called xpc_msgqueue_ref() in xpc_deliver_payload().
  Arguments:
 	partid - ID of partition to which the channel is connected.
 	ch_number - channel # message received on.
 	payload - pointer to the payload area allocated via
 			xpc_initiate_send() or xpc_initiate_send_notify().
 the call to xpc_msgqueue_ref() was done by xpc_deliver_payload()  
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  Copyright (c) 2008-2009 Silicon Graphics, Inc.  All Rights Reserved.
  Cross Partition Communication (XPC) uv-based functions.
      Architecture specific implementation of common functions.
 enable generation of irq when GRU mq operation occurs to this mq 
 allow other partitions to access this GRU mq 
 something went wrong 
 disallow other partitions to access GRU mq 
 unregister irq handler and release mq irqvector mapping 
 disable generation of irq when GRU mq op occurs to this mq 
 !!! handle QLimit reached; delay & try again 
 ??? Do we add a limit to the number of retries? 
 !!! handle LB Overflow; simply try again 
 ??? Do we add a limit to the number of retries? 
 !!! Currently this is MQE_UNEXPECTED_CB_ERR 
 syncing of remote_act_state was just done above 
		
		  ??? Do we deal here with ts_jiffies being different
		  ??? if act_state != XPC_P_AS_INACTIVE instead of
		  ??? below?
 !!! _pa is _gpa 
 get hb checker to deactivate from the remote partition 
		
		  ??? Does what we do here need to be sensitive to
		  ??? act_state or remote_act_state?
 ??? Is holding a spin_lock (ch->lock) during this call a bad idea? 
 ensure a fresh copy of part_uv->flags 
	
	  !!! Make our side think that the remote partition sent an activate
	  !!! mq message our way by doing what the activate IRQ handler would
	  !!! do had one really been sent.
 !!! _pa here is really _gpa 
	
	  ??? Is it a good idea to make this conditional on what is
	  ??? potentially stale state information?
	
	  ??? Is it a good idea to make this conditional on what is
	  ??? potentially stale state information?
 nothing needs to be done 
  Setup the channel structures that are uv specific.
  Teardown the channel structures that are uv specific.
 nothing needs to be done 
	
	  We send a sync msg to get the remote partition's remote_act_state
	  updated to our current act_state which at this point should
	  be XPC_P_AS_ACTIVATING.
 wait a 14 of a second or so 
  Allocate msg_slots associated with the channel.
  Free up msg_slots and clear other stuff that were setup for the specified
  channel.
 wakeup anyone waiting for a free msg slot 
 get hb checker to deactivate from the remote partition 
 see if we're really dealing with an ACK for a previously sent msg 
 we're dealing with a normal message sent via the notify_mq 
		
		  If there is an existing idle kthread get it to deliver
		  the payload, otherwise we'll have to get the channel mgr
		  for this partition to create a kthread to do the delivery.
 a non-NULL func must hit memory after the key 
		
		  Try to NULL the msg_slot's func field. If we fail, then
		  xpc_notify_senders_of_disconnect_uv() beat us to it, in which
		  case we need to pretend we succeeded to send the message
		  since the user will get a callout for the disconnect error
		  by xpc_notify_senders_of_disconnect_uv(), and to also get an
		  error returned here will confuse them. Additionally, since
		  in this case the channel is being disconnected we don't need
		  to put the the msg_slot back on the free list.
  Tell the callers of xpc_send_notify() that the status of their payloads
  is unknown because the channel is now disconnecting.
  We don't worry about putting these msg_slots on the free list since the
  msg_slots themselves are about to be kfree'd.
  Get the next deliverable message's payload.
 return an ACK to the sender of this message 
 size of zero indicates this is an ACK 
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  (C) Copyright 2020 Hewlett Packard Enterprise Development LP
  Copyright (c) 2004-2009 Silicon Graphics, Inc.  All Rights Reserved.
  Cross Partition Communication (XPC) support - standard version.
 	XPC provides a message passing capability that crosses partition
 	boundaries. This module is made up of two parts:
 	    partition	This part detects the presenceabsence of other
 			partitions. It provides a heartbeat and monitors
 			the heartbeats of other partitions.
 	    channel	This part manages the channels and sendsreceives
 			messages across them tofrom other partitions.
 	There are a couple of additional functions residing in XP, which
 	provide an interface to XPC for its users.
 	Caveats:
 	  . Currently on sn2, we have no way to determine which nasid an IRQ
 	    came from. Thus, xpc_send_IRQ_sn2() does a remote amo write
 	    followed by an IPI. The amo indicates where data is to be pulled
 	    from, so after the IPI arrives, the remote partition checks the amo
 	    word. The IPI can actually arrive before the amo however, so other
 	    code must periodically check for this case. Also, remote amo
 	    operations do not reliably time out. Thus we do a remote PIO read
 	    solely to know whether the remote partition is down and whether we
 	    should stop sending IPIs to it. This remote PIO read operation is
 	    set up in a special nofault region so SAL knows to ignore (and
 	    cleanup) any errors due to the remote amo write, PIO read, andor
 	    PIO write operations.
 	    Ifwhen new hardware solves this IPI problem, we should abandon
 	    the current approach.
 define two XPC debug device structures to be used with dev_dbg() et al 
 set to "part" at xpc_init() time 
 set to "chan" at xpc_init() time 
 systune related variables for procsys directories 
 = 0 
 non-zero if any remote partition disengage was timed out 
 #of activate IRQs received and not yet processed 
 IRQ handler notifies this wait queue on receipt of an IRQ 
 notification that the xpc_hb_checker thread has exited 
 notification that the xpc_discovery thread has exited 
  Timer function to enforce the timelimit on the partition disengage.
  Timer to produce the heartbeat.  The timer structures function is
  already set when this is initially called.  A tunable is used to
  specify when the next timeout should occur.
  At periodic intervals, scan through all active partitions and ensure
  their heartbeat is still active.  If not, the partition is deactivated.
  This thread is responsible for nearly all of the partition
  activationdeactivation.
 this thread was marked active by xpc_hb_init() 
 set our heartbeating to other partitions into motion 
 checking of remote heartbeats is skewed by IRQ handling 
 check for outstanding IRQs 
 wait for IRQ or timeout 
 mark this thread as having exited 
  This thread will attempt to discover other partitions to activate
  based on info provided by SAL. This new thread is short lived and
  will exit once discovery is complete.
 mark this thread as having exited 
  The first kthread assigned to a newly activated partition is the one
  created by XPC HB with which it calls xpc_activating(). XPC hangs on to
  that kthread until the partition is brought down, at which time that kthread
  returns back to XPC HB. (The return of that kthread will signify to XPC HB
  that XPC has dismantled all communication infrastructure for the associated
  partition.) This kthread becomes the channel manager for that partition.
  Each active partition has a channel manager, who, besides connecting and
  disconnecting channels, will ensure that each of the partition's connected
  channels has the required number of assigned kthreads to get the work done.
		
		  Wait until we've been requested to activate kthreads or
		  all of the channel's message queues have been torn down or
		  a signal is pending.
		 
		  The channel_mgr_requests is set to 1 after being awakened,
		  This is done to prevent the channel mgr from making one pass
		  through the loop for each request, since he will
		  be servicing all the requests in one pass. The reason it's
		  set to 1 instead of 0 is so that other kthreads will know
		  that the channel mgr is running and won't bother trying to
		  wake him up.
  Guarantee that the kzalloc'd memory is cacheline aligned.
 see if kzalloc will give us cachline aligned memory by default 
 nope, we'll have to do it ourselves 
  Setup the channel structures necessary to support XPartition Communication
  between the specified remote partition and the local one.
	
	  Allocate all of the channel structures as a contiguous chunk of
	  memory.
 allocate the remote open and close args 
	
	  With the setting of the partition setup_state to XPC_P_SS_SETUP,
	  we're declaring that this partition is ready to go.
 setup of ch structures failed 
  Teardown the channel structures necessary to support XPartition Communication
  between the specified remote partition and the local one.
	
	  Make this partition inaccessible to local processes by marking it
	  as no longer setup. Then wait before proceeding with the teardown
	  until all existing references cease.
 now we can begin tearing down the infrastructure 
  When XPC HB determines that a partition has come up, it will create a new
  kthread and that kthread will call this function to attempt to set up the
  basic infrastructure used for Cross Partition Communication with the newly
  upped partition.
  The kthread that was created by XPC HB and which setup the XPC
  infrastructure will remain assigned to the partition becoming the channel
  manager for that partition until the partition is deactivating, at which
  time the kthread will teardown the XPC infrastructure and then exit.
 indicate the thread is activating 
 this will always succeed 
 won't return until partition is deactivating 
 interrupting ourselves results in activating partition 
 only wakeup the requested number of kthreads 
  This function is where XPC's kthreads wait for messages to deliver.
 deliver messages to their intended recipients 
 too many idle kthreads on this channel 
 let registerer know that connection has been established 
			
			  It is possible that while the callout was being
			  made that the remote partition sent some messages.
			  If that is the case, we may need to activate
			  additional kthreads to help deliver them. We only
			  need one less than total #of messages to deliver.
 let registerer know that connection is disconnecting 
  For each partition that XPC has established communications with, there is
  a minimum of one kernel thread assigned to perform any operation that
  may potentially sleep or block (basically the callouts to the asynchronous
  functions registered via xpc_connect()).
  Additional kthreads are created and destroyed by XPC as the workload
  demands.
  A kthread is assigned to one of the active channels that exists for a given
  partition.
		
		  The following is done on behalf of the newly created
		  kthread. That kthread is responsible for doing the
		  counterpart to the following before it exits.
 kthreads assigned had gone to zero 
 the fork failed 
			
			  NOTE: if (ignore_disconnecting &&
			  !(ch->flags & XPC_C_DISCONNECTINGCALLOUT)) is true,
			  then we'll deadlock if all other kthreads assigned
			  to this channel are blocked in the channel's
			  registerer, because the only thing that will unblock
			  them is the xpDisconnecting callout that this
			  failed kthread_run() would have made.
				
				  Flag this as an error only if we have an
				  insufficient #of kthreads for the channel
				  to function.
 now wait for all callouts to the caller's function to cease 
	
	  The first few fields of each entry of xpc_partitions[] need to
	  be initialized now so that calls to xpc_connect() and
	  xpc_disconnect() can be made prior to the activation of any remote
	  partition. NOTE THAT NONE OF THE OTHER FIELDS BELONGING TO THESE
	  ENTRIES ARE MEANINGFUL UNTIL AFTER AN ENTRY'S CORRESPONDING
	  PARTITION HAS BEEN ACTIVATED.
 a 'rmmod XPC' and a 'reboot' cannot both end up here together 
	
	  Let the heartbeat checker thread and the discovery thread
	  (if one is running) know that they should exit. Also wake up
	  the heartbeat checker thread in case it's sleeping.
 wait for the discovery thread to exit 
 wait for the heartbeat checker thread to exit 
 sleep for a 13 of a second or so 
 wait for all partitions to become inactive 
 sleep for a 13 of a second or so 
 clear the interface to XPC's functions 
  This function is called when the system is being rebooted.
 Used to only allow one cpu to complete disconnect 
  Notify other partitions to deactivate from us by first disengaging from all
  references to our memory.
 keep xpc_hb_checker thread from doing anything (just in case) 
indicate we're deactivated 
	
	  Though we requested that all other partitions deactivate from us,
	  we only wait until they've all disengaged or we've reached the
	  defined timelimit.
	 
	  Given that one iteration through the following while-loop takes
	  approximately 200 microseconds, calculate the #of loops to take
	  before bailing and the #of loops before printing a waiting message.
  This function is called when the system is being restarted or halted due
  to some sort of system failure. If this is the case we need to notify the
  other partitions to disengage from all references to our memory.
  This function can also be called when our heartbeater could be offlined
  for a time. In this case we need to notify other partitions to not worry
  about the lack of a heartbeat.
 !!! temporary kludge 
 Should lack of heartbeat be ignored by other partitions? 
 Is lack of heartbeat being ignored by other partitions? 
	
	  Fill the partition reserved page with the information needed by
	  other partitions to discover we are alive and establish initial
	  communications.
 add ourselves to the reboot_notifier_list 
 add ourselves to the die_notifier list 
	
	  The real work-horse behind xpc.  This processes incoming
	  interrupts and monitors remote heartbeats.
	
	  Startup a thread that will attempt to discover other partitions to
	  activate based on info provided by SAL. This new thread is short
	  lived and will exit once discovery is complete.
 mark this new thread as a non-starter 
 set the interface to point at XPC's functions 
 initialization was not successful 
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  (C) Copyright 2020 Hewlett Packard Enterprise Development LP
  Copyright (c) 2008 Silicon Graphics, Inc.  All Rights Reserved.
  Cross Partition (XP) uv-based functions.
       Architecture specific implementation of common functions.
  Convert a virtual memory address to a physical memory address.
  Convert a global physical to socket physical address.
 ??? Is this same as sn2 nasid in machpart bitmaps set up by SAL? 
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  (C) Copyright 2020 Hewlett Packard Enterprise Development LP
  Copyright (c) 2004-2008 Silicon Graphics, Inc.  All Rights Reserved.
  Cross Partition (XP) base.
 	XP provides a base from which its users can interact
 	with XPC, yet not be dependent on XPC.
 define the XP debug device structures to be used with dev_dbg() et al 
 set to "" 
 max #of partitions possible 
  xpc_registrations[] keeps track of xpc_connect()'s done by the kernel-level
  users of XPC.
  Initialize the XPC interface to NULL to indicate that XPC isn't loaded.
  XPC calls this when it (the XPC module) has been loaded.
  XPC calls this when it (the XPC module) is being unloaded.
  Register for automatic establishment of a channel connection whenever
  a partition comes up.
  Arguments:
 	ch_number - channel # to register for connection.
 	func - function to call for asynchronous notification of channel
 	       state changes (i.e., connection, disconnection, error) and
 	       the arrival of incoming messages.
       key - pointer to optional user-defined value that gets passed back
 	      to the user on any callouts made to func.
 	payload_size - size in bytes of the XPC message's payload area which
 		       contains a user-defined message. The user should make
 		       this large enough to hold their largest message.
 	nentries - max #of XPC message entries a message queue can contain.
 		   The actual number, which is determined when a connection
  		   is established and may be less then requested, will be
 		   passed to the user via the xpConnected callout.
 	assigned_limit - max number of kthreads allowed to be processing
  			 messages (per connection) at any given instant.
 	idle_limit - max number of kthreads allowed to be idle at any given
  		     instant.
 if XPC_CHANNEL_REGISTERED(ch_number) 
 register the channel for connection 
  Remove the registration for automatic connection of the specified channel
  when a partition comes up.
  Before returning this xpc_disconnect() will wait for all connections on the
  specified channel have been closedtorndown. So the caller can be assured
  that they will not be receiving any more callouts from XPC to their
  function registered via xpc_connect().
  Arguments:
 	ch_number - channel # to unregister.
	
	  We've decided not to make this a down_interruptible(), since we
	  figured XPC's users will just turn around and call xpc_disconnect()
	  again anyways, so we might as well wait, if need be.
 if !XPC_CHANNEL_REGISTERED(ch_number) 
 remove the connection registration for the specified channel 
 initialize the connection registration mutex 
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  (C) Copyright 2020 Hewlett Packard Enterprise Development LP
  Copyright (C) 1999-2009 Silicon Graphics, Inc. All rights reserved.
  Cross Partition Network Interface (XPNET) support
 	XPNET provides a virtual network layered on top of the Cross
 	Partition communication layer.
 	XPNET provides direct point-to-point and broadcast-like support
 	for an ethernet-like device.  The ethernet broadcast medium is
 	replaced with a point-to-point message structure which passes
 	pointers to a DMA-capable block that a remote partition should
 	retrieve and pass to the upper level networking layer.
  The message payload transferred by XPC.
  buf_pa is the physical address where the DMA should pull from.
  NOTE: for performance reasons, buf_pa should _ALWAYS_ begin on a
  cacheline boundary.  To accomplish this, we record the number of
  bytes from the beginning of the first cacheline to the first useful
  byte of the skb (leadin_ignore) and the number of bytes from the
  last useful byte of the skb to the end of the last cacheline
  (tailout_ignore).
  size is the number of bytes to transfer which includes the skb->len
  (useful bytes of the senders skb) plus the leadin and tailout
 Version for this message 
 #of bytes embedded in XPC message 
 Special number indicating this is xpnet 
 phys address of buffer to retrieve 
 #of bytes in buffer 
 #of bytes to ignore at the beginning 
 #of bytes to ignore at the end 
 body of small packets 
  Determine the size of our message, the cacheline aligned size,
  and then the number of message will request from XPC.
  XPC expects each message to exist in an individual cacheline.
  Version number of XPNET implementation. XPNET can always talk to versions
  with same major #, and never talk to versions with a different version.
 version 1.0 
 version 1.1 
 "XNET" 
  When messages are queued with xpc_send_notify, a kmalloc'd buffer
  of the following type is passed as a notification cookie.  When the
  notification function is called, we use the cookie to decide
  whether all outstanding message sends have completed.  The skb can
  then be released.
  When we are notified of other partitions activating, we add them to
  our bitmask of partitions to which we broadcast.
 protect above 
  Since the Block Transfer Engine (BTE) is being used for the transfer
  and it relies upon cache-line size transfers, we need to reserve at
  least one cache-line for head and tail alignment.  The BTE is
  limited to 8MB transfers.
  Testing has shown that changing MTU to greater than 64KB has no effect
  on TCP as the two sides negotiate a Max Segment Size that is limited
  to 64K.  Other protocols May use packets greater than this, but for
  now, the default is 64KB.
 68 comes from min TCP+IP+MAC header 
 32KB has been determined to be the ideal 
  The partid is encapsulated in the MAC address beginning in the following
  octet and it consists of two octets.
 Define the XPNET debug device structures to be used with dev_dbg() et al 
 set to "" 
  Packet was recevied by XPC and forwarded to us.
		
		  Packet with a different XPC version.  Ignore.
 reserve an extra cache line 
	
	  The allocated skb has some reserved space.
	  In order to use xp_remote_memcpy(), we need to get the
	  skb->data pointer moved forward.
	
	  Update the tail pointer to indicate data actually
	  transferred.
	
	  Move the data over from the other side.
			
			  !!! Need better way of cleaning skb.  Currently skb
			  !!! appears in_use and we can't just call
			  !!! dev_kfree_skb.
  This is the handler which XPC calls during any sort of change in
  state or message reception on a connection.
 message received 
 connection completed to a partition 
  Notification that the other end has received the message and
  DMA'd the skb information.  At this point, they are done with
  our side.  When all recipients are done processing, we
  release the skb and then release our pending message structure.
  Network layer has formatted a packet (skb) and is ready to place it
  "on the wire".  Prepare and send an xpnet_message to all partitions
  which have connected with us and are targets of this packet.
  MAC-NOTE:  For the XPNET driver, the MAC address contains the
  destination partid.  If the destination partid octets are 0xffff,
  this packet is to be broadcast to all connected partitions.
 nothing needed to be done 
	
	  The xpnet_pending_msg tracks how many outstanding
	  xpc_send_notifies are relying on this skb.  When none
	  remain, release the skb.
 get the beginning of the first cacheline and end of last 
 calculate how many bytes to embed in the XPC message 
 skb->data does fit so embed 
	
	  Since the send occurs asynchronously, we set the count to one
	  and begin sending.  Any sends that happen to complete before
	  we are done sending will not free the skb.  We will be left
	  with that task during exit.  This also handles the case of
	  a packet destined for a partition which is no longer up.
 we are being asked to broadcast to all partitions 
  Deal with transmit timeouts coming from the network layer.
	
	  use ether_setup() to init the majority of our device
	  structure and then override the necessary pieces.
	
	  Multicast assumes the LSB of the first octet is set for multicast
	  MAC addresses.  We chose the first octet of the MAC to be unlikely
	  to collide with any vendor's officially issued MAC.
 locally administered, no OUI 
	
	  ether_setup() sets this to a multicast device.  We are
	  really not supporting multicast at this time.
	
	  No need to checksum as it is a DMA transfer.  The BTE will
	  report an error if the data is not retrievable and the
	  packet will be dropped.
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  (C) Copyright 2020 Hewlett Packard Enterprise Development LP
  Copyright (c) 2004-2008 Silicon Graphics, Inc.  All Rights Reserved.
  Cross Partition Communication (XPC) partition support.
 	This is the part of XPC that detects the presenceabsence of
 	other partitions. It provides a heartbeat and monitors the
 	heartbeats of other partitions.
 XPC is exiting flag 
 this partition's reserved page pointers 
 #of bytes in nasid mask 
 #of longs in nasid mask 
  Guarantee that the kmalloc'd memory is cacheline aligned.
 see if kmalloc will give us cachline aligned memory by default 
 nope, we'll have to do it ourselves 
  Given a nasid, get the physical address of the  partition's reserved page
  for that nasid. This function returns 0 on any error.
 seed with nasid 
		 !!! rp_pa will need to be _gpa on UV.
		  ??? So do we save it into the architecture specific parts
		  ??? of the xpc_partition structure? Do we rename this
		  ??? function or have two versions? Rename rp_pa for UV to
		  ??? rp_gpa?
  Fill the partition reserved page with the information needed by
  other partitions to discover we are alive and establish initial
  communications.
 get the local reserved page's address 
 SAL_versions < 3 had a SAL_partid defined as a u8 
 establish the actual sizes of the nasid masks 
 SAL_version 1 didn't set the nasids_size field 
 setup the pointers to the various items in the reserved page 
	
	  Set timestamp of when reserved page was setup by XPC.
	  This signifies to the remote partition that our reserved
	  page is initialized.
 a zero timestamp indicates our rsvd page is not initialized 
  Get a copy of a portion of the remote partition's rsvd page.
  remote_rp points to a buffer that is cacheline aligned for BTE copies and
  is large enough to contain a copy of their reserved page header and
  part_nasids mask.
 get the reserved page's physical address 
 pull over the reserved page header and part_nasids mask 
 zero timestamp indicates the reserved page has not been setup 
 check that both remote and local partids are valid for each side 
  See if the other side has responded to a partition deactivate request
  from us. Though we requested the remote partition to deactivate with regard
  to us, we really only need to wait for the other side to disengage from us.
 timelimit hasn't been reached yet 
			
			  Other side hasn't responded to our deactivate
			  request in a timely fashion, so assume it's dead.
 Cancel the timer function if not called from it 
  Mark specified partition as active.
  Start the process of deactivating the specified partition.
 we interrupt ourselves to reactivate partition 
 ask remote partition to deactivate with regard to us 
 set a timelimit on the disengage phase of the deactivation request 
  Mark specified partition as inactive.
  SAL has provided a partition and machine mask.  The partition mask
  contains a bit for each even nasid in our partition.  The machine
  mask contains a bit for each even nasid in the entire machine.
  Using those two bit arrays, we can determine which nasids are
  known in the machine.  Each should also have a reserved page
  initialized if they are available for partitioning.
	
	  The term 'region' in this context refers to the minimum number of
	  nodes that can comprise an access protection grouping. The access
	  protection is in regards to memory, IOI and IPI.
 pull over the rsvd page header & part_nasids mask 
  Given a partid, get the nasids owned by that partition from the
  remote partition's reserved page.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2012-2019, Intel Corporation. All rights reserved.
  Intel Management Engine Interface (Intel MEI) Linux driver
  __mei_cl_send - internal client send (write)
  @cl: host client
  @buf: buffer to send
  @length: buffer length
  @vtag: virtual tag
  @mode: sending mode
  Return: written size bytes or < 0 on error
 Check if we have an ME client device 
 Check if vtag is supported by client 
  __mei_cl_recv - internal client receive (read)
  @cl: host client
  @buf: buffer to receive
  @length: buffer length
  @mode: io mode
  @vtag: virtual tag
  @timeout: recv timeout, 0 for infinite timeout
  Return: read size in bytes of < 0 on error
 wait on event only if there is no other waiter 
 synchronized under device mutex 
  mei_cldev_send_vtag - me device send with vtag  (write)
  @cldev: me client device
  @buf: buffer to send
  @length: buffer length
  @vtag: virtual tag
  Return:
    written size in bytes
    < 0 on error
  mei_cldev_recv_vtag - client receive with vtag (read)
  @cldev: me client device
  @buf: buffer to receive
  @length: buffer length
  @vtag: virtual tag
  Return:
   read size in bytes
    < 0 on error
  mei_cldev_recv_nonblock_vtag - non block client receive with vtag (read)
  @cldev: me client device
  @buf: buffer to receive
  @length: buffer length
  @vtag: virtual tag
  Return:
   read size in bytes
   -EAGAIN if function will block.
   < 0 on other error
  mei_cldev_send - me device send  (write)
  @cldev: me client device
  @buf: buffer to send
  @length: buffer length
  Return:
    written size in bytes
    < 0 on error
  mei_cldev_recv - client receive (read)
  @cldev: me client device
  @buf: buffer to receive
  @length: buffer length
  Return: read size in bytes of < 0 on error
  mei_cldev_recv_nonblock - non block client receive (read)
  @cldev: me client device
  @buf: buffer to receive
  @length: buffer length
  Return: read size in bytes of < 0 on error
          -EAGAIN if function will block.
  mei_cl_bus_rx_work - dispatch rx event for a bus device
  @work: work
  mei_cl_bus_notif_work - dispatch FW notif event for a bus device
  @work: work
  mei_cl_bus_notify_event - schedule notify cb on bus client
  @cl: host client
  Return: true if event was scheduled
          false if the client is not waiting for event
  mei_cl_bus_rx_event - schedule rx event
  @cl: host client
  Return: true if event was scheduled
          false if the client is not waiting for event
  mei_cldev_register_rx_cb - register Rx event callback
  @cldev: me client devices
  @rx_cb: callback function
  Return: 0 on success
          -EALREADY if an callback is already registered
          <0 on other errors
  mei_cldev_register_notif_cb - register FW notification event callback
  @cldev: me client devices
  @notif_cb: callback function
  Return: 0 on success
          -EALREADY if an callback is already registered
          <0 on other errors
  mei_cldev_get_drvdata - driver data getter
  @cldev: mei client device
  Return: driver private data
  mei_cldev_set_drvdata - driver data setter
  @cldev: mei client device
  @data: data to store
  mei_cldev_uuid - return uuid of the underlying me client
  @cldev: mei client device
  Return: me client uuid
  mei_cldev_ver - return protocol version of the underlying me client
  @cldev: mei client device
  Return: me client protocol version
  mei_cldev_enabled - check whether the device is enabled
  @cldev: mei client device
  Return: true if me client is initialized and connected
  mei_cl_bus_module_get - acquire module of the underlying
     hw driver.
  @cldev: mei client device
  Return: true on success; false if the module was removed.
  mei_cl_bus_module_put -  release the underlying hw module.
  @cldev: mei client device
  mei_cl_bus_vtag - get bus vtag entry wrapper
      The tag for bus client is always first.
  @cl: host client
  Return: bus vtag or NULL
  mei_cl_bus_vtag_alloc - add bus client entry to vtag map
  @cldev: me client device
  Return:
   0 on success
   -ENOMEM if memory allocation failed
	
	  Bail out if the client does not supports vtags
	  or has already allocated one
  mei_cl_bus_vtag_free - remove the bus entry from vtag map
  @cldev: me client device
  mei_cldev_enable - enable me client device
      create connection with me client
  @cldev: me client device
  Return: 0 on success and < 0 on error
 update pointers 
  mei_cldev_unregister_callbacks - internal wrapper for unregistering
   callbacks.
  @cldev: client device
  mei_cldev_disable - disable me client device
      disconnect form the me client
  @cldev: me client device
  Return: 0 on success and < 0 on error
 Flush queues and remove any pending read 
  mei_cl_device_find - find matching entry in the driver id table
  @cldev: me client device
  @cldrv: me client driver
  Return: id on success; NULL if no id is matching
  mei_cl_device_match  - device match function
  @dev: device
  @drv: driver
  Return:  1 if matching device was found 0 otherwise
  mei_cl_device_probe - bus probe function
  @dev: device
  Return:  0 on success; < 0 otherwise
  mei_cl_device_remove - remove device from the bus
  @dev: device
  Return:  0 on success; < 0 otherwise
  mei_cl_device_uevent - me client bus uevent handler
  @dev: device
  @env: uevent kobject
  Return: 0 on success -ENOMEM on when add_uevent_var fails
  mei_cl_bus_set_name - set device name for me client device
   <controller>-<client device>
   Example: 0000:00:16.0-55213584-9a29-4916-badf-0fb7ed682aeb
  @cldev: me client device
  mei_cl_bus_dev_alloc - initialize and allocate mei client device
  @bus: mei device
  @me_cl: me client
  Return: allocated device structur or NULL on allocation failure
  mei_cl_bus_dev_setup - setup me client device
     run fix up routines and set the device name
  @bus: mei device
  @cldev: me client device
  Return: true if the device is eligible for enumeration
 the device name can change during fix up 
  mei_cl_bus_dev_add - add me client devices
  @cldev: me client device
  Return: 0 on success; < 0 on failre
  mei_cl_bus_dev_stop - stop the driver
  @cldev: me client device
  mei_cl_bus_dev_destroy - destroy me client devices object
  @cldev: me client device
  Locking: called under "dev->cl_bus_lock" lock
  mei_cl_bus_remove_device - remove a devices form the bus
  @cldev: me client device
  mei_cl_bus_remove_devices - remove all devices form the bus
  @bus: mei device
  mei_cl_bus_dev_init - allocate and initializes an mei client devices
      based on me client
  @bus: mei device
  @me_cl: me client
  Locking: called under "dev->cl_bus_lock" lock
  mei_cl_bus_rescan - scan me clients list and add create
     devices for eligible clients
  @bus: mei device
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2016-2018 Intel Corporation. All rights reserved.
  mei_dmam_dscr_alloc() - allocate a managed coherent buffer
      for the dma descriptor
  @dev: mei_device
  @dscr: dma descriptor
  Return:
   0       - on success or zero allocation request
   -EINVAL - if size is not power of 2
   -ENOMEM - of allocation has failed
  mei_dmam_dscr_free() - free a managed coherent buffer
      from the dma descriptor
  @dev: mei_device
  @dscr: dma descriptor
  mei_dmam_ring_free() - free dma ring buffers
  @dev: mei device
  mei_dmam_ring_alloc() - allocate dma ring buffers
  @dev: mei device
  Return: -ENOMEM on allocation failure 0 otherwise
  mei_dma_ring_is_allocated() - check if dma ring is allocated
  @dev: mei device
  Return: true if dma ring is allocated
  mei_dma_ring_reset() - reset the dma control block
  @dev: mei device
  mei_dma_copy_from() - copy from dma ring into buffer
  @dev: mei device
  @buf: data buffer
  @offset: offset in slots.
  @n: number of slots to copy.
  mei_dma_copy_to() - copy to a buffer to the dma ring
  @dev: mei device
  @buf: data buffer
  @offset: offset in slots.
  @n: number of slots to copy.
  mei_dma_ring_read() - read data from the ring
  @dev: mei device
  @buf: buffer to read into: may be NULL in case of droping the data.
  @len: length to read.
 if buf is NULL we drop the packet by advancing the pointer.
  mei_dma_ring_empty_slots() - calaculate number of empty slots in dma ring
  @dev: mei_device
  Return: number of empty slots
 easier to work in slots 
  mei_dma_ring_write - write data to dma ring host buffer
  @dev: mei_device
  @buf: data will be written
  @len: data length
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2003-2020, Intel Corporation. All rights reserved.
  Intel Management Engine Interface (Intel MEI) Linux driver
 mei_pci_tbl - PCI Device ID Table 
 required last entry 
 CONFIG_PM 
  mei_me_quirk_probe - probe for devices that doesn't valid ME interface
  @pdev: PCI device structure
  @cfg: per generation config
  Return: true if ME Interface is valid, false otherwise
  mei_me_probe - Device Initialization Routine
  @pdev: PCI device structure
  @ent: entry in kcs_pci_tbl
  Return: 0 on success, <0 on failure.
 enable pci dev 
 set PCI host mastering  
 pci request regions and mapping IO device memory for mei driver 
 allocates and initializes the mei dev structure 
 request and enable interrupt 
	
	  MEI requires to resume from runtime suspend mode
	  in order to perform link reset flow upon system suspend.
	
	  ME maps runtime suspendresume to D0i states,
	  hence we need to go around native PCI runtime service which
	  eventually brings the device into D3coldhot state,
	  but the mei device cannot wake up from D3 unlike from D0i3.
	  To get around the PCI device native runtime pm,
	  ME uses runtime pm domain handlers which take precedence
	  over the driver's pm handlers.
  mei_me_shutdown - Device Removal Routine
  @pdev: PCI device structure
  mei_me_shutdown is called from the reboot notifier
  it's a simplified version of remove so we go down
  faster.
  mei_me_remove - Device Removal Routine
  @pdev: PCI device structure
  mei_me_remove is called by the PCI subsystem to alert the driver
  that it should release a PCI device.
 request and enable interrupt 
 Start timer if stopped in suspend 
 CONFIG_PM_SLEEP 
  mei_me_set_pm_domain - fill and set pm domain structure for device
  @dev: mei_device
  mei_me_unset_pm_domain - clean pm domain structure for device
  @dev: mei_device
 stop using pm callbacks if any 
 CONFIG_PM 
   PCI driver structure
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2013-2020, Intel Corporation. All rights reserved.
  Intel Management Engine Interface (Intel MEI) Linux driver
  mei_txe_reg_read - Reads 32bit data from the txe device
  @base_addr: registers base address
  @offset: register offset
  Return: register value
  mei_txe_reg_write - Writes 32bit data to the txe device
  @base_addr: registers base address
  @offset: register offset
  @value: the value to write
  mei_txe_sec_reg_read_silent - Reads 32bit data from the SeC BAR
  @hw: the txe hardware structure
  @offset: register offset
  Doesn't check for aliveness while Reads 32bit data from the SeC BAR
  Return: register value
  mei_txe_sec_reg_read - Reads 32bit data from the SeC BAR
  @hw: the txe hardware structure
  @offset: register offset
  Reads 32bit data from the SeC BAR and shout loud if aliveness is not set
  Return: register value
  mei_txe_sec_reg_write_silent - Writes 32bit data to the SeC BAR
    doesn't check for aliveness
  @hw: the txe hardware structure
  @offset: register offset
  @value: value to write
  Doesn't check for aliveness while writes 32bit data from to the SeC BAR
  mei_txe_sec_reg_write - Writes 32bit data to the SeC BAR
  @hw: the txe hardware structure
  @offset: register offset
  @value: value to write
  Writes 32bit data from the SeC BAR and shout loud if aliveness is not set
  mei_txe_br_reg_read - Reads 32bit data from the Bridge BAR
  @hw: the txe hardware structure
  @offset: offset from which to read the data
  Return: the byte read.
  mei_txe_br_reg_write - Writes 32bit data to the Bridge BAR
  @hw: the txe hardware structure
  @offset: offset from which to write the data
  @value: the byte to write
  mei_txe_aliveness_set - request for aliveness change
  @dev: the device structure
  @req: requested aliveness value
  Request for aliveness change and returns true if the change is
    really needed and false if aliveness is already
    in the requested state
  Locking: called under "dev->device_lock" lock
  Return: true if request was send
  mei_txe_aliveness_req_get - get aliveness requested register value
  @dev: the device structure
  Extract HICR_HOST_ALIVENESS_RESP_ACK bit from
  from HICR_HOST_ALIVENESS_REQ register value
  Return: SICR_HOST_ALIVENESS_REQ_REQUESTED bit value
  mei_txe_aliveness_get - get aliveness response register value
  @dev: the device structure
  Return: HICR_HOST_ALIVENESS_RESP_ACK bit from HICR_HOST_ALIVENESS_RESP
          register
  mei_txe_aliveness_poll - waits for aliveness to settle
  @dev: the device structure
  @expected: expected aliveness value
  Polls for HICR_HOST_ALIVENESS_RESP.ALIVENESS_RESP to be set
  Return: 0 if the expected value was received, -ETIME otherwise
  mei_txe_aliveness_wait - waits for aliveness to settle
  @dev: the device structure
  @expected: expected aliveness value
  Waits for HICR_HOST_ALIVENESS_RESP.ALIVENESS_RESP to be set
  Return: 0 on success and < 0 otherwise
  mei_txe_aliveness_set_sync - sets an wait for aliveness to complete
  @dev: the device structure
  @req: requested aliveness value
  Return: 0 on success and < 0 otherwise
  mei_txe_pg_in_transition - is device now in pg transition
  @dev: the device structure
  Return: true if in pg transition, false otherwise
  mei_txe_pg_is_enabled - detect if PG is supported by HW
  @dev: the device structure
  Return: true is pg supported, false otherwise
  mei_txe_pg_state  - translate aliveness register value
    to the mei power gating state
  @dev: the device structure
  Return: MEI_PG_OFF if aliveness is on and MEI_PG_ON otherwise
  mei_txe_input_ready_interrupt_enable - sets the Input Ready Interrupt
  @dev: the device structure
 Enable the SEC_IPC_HOST_INT_MASK_IN_RDY interrupt 
  mei_txe_input_doorbell_set - sets bit 0 in
     SEC_IPC_INPUT_DOORBELL.IPC_INPUT_DOORBELL.
  @hw: the txe hardware structure
 Clear the interrupt cause 
  mei_txe_output_ready_set - Sets the SICR_SEC_IPC_OUTPUT_STATUS bit to 1
  @hw: the txe hardware structure
  mei_txe_is_input_ready - check if TXE is ready for receiving data
  @dev: the device structure
  Return: true if INPUT STATUS READY bit is set
  mei_txe_intr_clear - clear all interrupts
  @dev: the device structure
  mei_txe_intr_disable - disable all interrupts
  @dev: the device structure
  mei_txe_intr_enable - enable all interrupts
  @dev: the device structure
  mei_txe_synchronize_irq - wait for pending IRQ handlers
  @dev: the device structure
  mei_txe_pending_interrupts - check if there are pending interrupts
 	only Aliveness, Input ready, and output doorbell are of relevance
  @dev: the device structure
  Checks if there are pending interrupts
  only Aliveness, Readiness, Input ready, and Output doorbell are relevant
  Return: true if there are pending interrupts
  mei_txe_input_payload_write - write a dword to the host buffer
 	at offset idx
  @dev: the device structure
  @idx: index in the host buffer
  @value: value
  mei_txe_out_data_read - read dword from the device buffer
 	at offset idx
  @dev: the device structure
  @idx: index in the device buffer
  Return: register value at index
 Readiness 
  mei_txe_readiness_set_host_rdy - set host readiness bit
  @dev: the device structure
  mei_txe_readiness_clear - clear host readiness bit
  @dev: the device structure
  mei_txe_readiness_get - Reads and returns
 	the HICR_SEC_IPC_READINESS register value
  @dev: the device structure
  Return: the HICR_SEC_IPC_READINESS register value
  mei_txe_readiness_is_sec_rdy - check readiness
   for HICR_SEC_IPC_READINESS_SEC_RDY
  @readiness: cached readiness state
  Return: true if readiness bit is set
  mei_txe_hw_is_ready - check if the hw is ready
  @dev: the device structure
  Return: true if sec is ready
  mei_txe_host_is_ready - check if the host is ready
  @dev: the device structure
  Return: true if host is ready
  mei_txe_readiness_wait - wait till readiness settles
  @dev: the device structure
  Return: 0 on success and -ETIME on timeout
  mei_txe_fw_status - read fw status register from pci config space
  @dev: mei device
  @fw_status: fw status register values
  Return: 0 on success, error otherwise
  mei_txe_hw_config - configure hardware at the start of the devices
  @dev: the device structure
  Configure hardware at the start of the device should be done only
    once at the device probe time
  Return: always 0
  mei_txe_write - writes a message to device.
  @dev: the device structure
  @hdr: header of message
  @hdr_len: header length in bytes - must multiplication of a slot (4bytes)
  @data: payload
  @data_len: paylead length in bytes
  Return: 0 if success, < 0 - otherwise.
 Enable Input Ready Interrupt. 
 after each write the whole buffer is consumed 
 Set Input-Doorbell 
  mei_txe_hbuf_depth - mimics the me hbuf circular buffer
  @dev: the device structure
  Return: the TXE_HBUF_DEPTH
  mei_txe_hbuf_empty_slots - mimics the me hbuf circular buffer
  @dev: the device structure
  Return: always TXE_HBUF_DEPTH
  mei_txe_count_full_read_slots - mimics the me device circular buffer
  @dev: the device structure
  Return: always buffer size in dwords count
 read buffers has static size 
  mei_txe_read_hdr - read message header which is always in 4 first bytes
  @dev: the device structure
  Return: mei message header
  mei_txe_read - reads a message from the txe device.
  @dev: the device structure
  @buf: message buffer will be written
  @len: message size will be read
  Return: -EINVAL on error wrong argument and 0 on success
 skip header: index starts from 1 
  mei_txe_hw_reset - resets host and fw.
  @dev: the device structure
  @intr_enable: if interrupt should be enabled after reset.
  Return: 0 on success and < 0 in case of error
	
	  read input doorbell to ensure consistency between  Bridge and SeC
	  return value might be garbage return
 Disable interrupts in this stage we will poll 
	
	  If Aliveness Request and Aliveness Response are not equal then
	  wait for them to be equal
	  Since we might have interrupts disabled - poll for it
	
	  If Aliveness Request and Aliveness Response are set then clear them
	
	  Set readiness RDY_CLR bit
  mei_txe_hw_start - start the hardware after reset
  @dev: the device structure
  Return: 0 on success an error code otherwise
 bring back interrupts 
	
	  If HISR.INT2_STS interrupt status bit is set then clear it.
 Clear the interrupt cause of OutputDoorbell 
	 enable input ready interrupts:
	  SEC_IPC_HOST_INT_MASK.IPC_INPUT_READY_INT_MASK
  Set the SICR_SEC_IPC_OUTPUT_STATUS.IPC_OUTPUT_READY bit 
	 Set bit SICR_HOST_IPC_READINESS.HOST_RDY
  mei_txe_check_and_ack_intrs - translate multi BAR interrupt into
   single bit mask and acknowledge the interrupts
  @dev: the device structure
  @do_ack: acknowledge interrupts
  Return: true if found interrupts to process.
 read interrupt registers 
 Save the interrupt causes 
		 Clear the interrupts in hierarchy:
  mei_txe_irq_quick_handler - The ISR of the MEI device
  @irq: The irq number
  @dev_id: pointer to the device structure
  Return: IRQ_WAKE_THREAD if interrupt is designed for the device
          IRQ_NONE otherwise
  mei_txe_irq_thread_handler - txe interrupt thread
  @irq: The irq number
  @dev_id: pointer to the device structure
  Return: IRQ_HANDLED
 initialize our complete list 
 show irq events 
	 Readiness:
	  Detection of TXE driver going through reset
	  or TXE driver resetting the HECI interface.
 Check if SeC is going through reset 
	 Check interrupt cause:
	  Aliveness: Detection of SeC acknowledge of host request that
	  it remain alive or host cancellation of that request.
 Clear the interrupt cause 
	 Output Doorbell:
	  Detection of SeC having sent output to host
 Read from TXE 
 Input Ready: Detection if host can write to SeC 
 get the real register value 
  mei_txe_dev_init - allocates and initializes txe hardware specific structure
  @pdev: pci device
  Return: struct mei_device  on success or NULL
  mei_txe_setup_satt2 - SATT2 configuration for DMA support.
  @dev:   the device structure
  @addr:  physical address start of the range
  @range: physical range size
  Return: 0 on success an error code otherwise
 SATT is limited to 36 Bits 
 SATT has to be 16Byte aligned 
 SATT range has to be 4Bytes aligned 
 SATT is limited to 32 MB range
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2003-2018, Intel Corporation. All rights reserved.
  Intel Management Engine Interface (Intel MEI) Linux driver
  mei_irq_compl_handler - dispatch complete handlers
 	for the completed callbacks
  @dev: mei device
  @cmpl_list: list of completed cbs
  mei_cl_hbm_equal - check if hbm is addressed to the client
  @cl: host client
  @mei_hdr: header of mei client message
  Return: true if matches, false otherwise
  mei_irq_discard_msg  - discard received message
  @dev: mei device
  @hdr: message header
  @discard_len: the length of the message to discard (excluding header)
	
	  no need to check for size as it is guarantied
	  that length fits into rd_msg_buf
  mei_cl_irq_read_msg - process client message
  @cl: reading client
  @mei_hdr: header of mei client message
  @meta: extend meta header
  @cmpl_list: completion list
  Return: always 0
 catch for integer overflow 
  for DMA read 0 length to generate interrupt to the device 
  mei_cl_irq_disconnect_rsp - send disconnection response message
  @cl: client
  @cb: callback block.
  @cmpl_list: complete list.
  Return: 0, OK; otherwise, error.
  mei_cl_irq_read - processes client read related operation from the
 	interrupt thread context - request for flow control credits
  @cl: client
  @cb: callback block.
  @cmpl_list: complete list.
  Return: 0, OK; otherwise, error.
  mei_irq_read_handler - bottom half read routine after ISR to
  handle the read processing.
  @dev: the device structure
  @cmpl_list: An instance of our list structure
  @slots: slots to read.
  Return: 0 on success, <0 on failure.
 we can't read the message 
  HBM message 
 find recipient cl 
 if no recipient cl was found we assume corrupted header 
		 A message for not connected fixed address clients
		  should be silently discarded
		  On power down client may be force cleaned,
		  silently discard such messages
 reset the number of slots and header 
 overflow - reset 
 set the event since message has been read 
  mei_irq_write_handler -  dispatch write requests
   after irq received
  @dev: the device structure
  @cmpl_list: An instance of our list structure
  Return: 0 on success, <0 on failure.
 complete all waiting for write CB 
 complete control write list CB 
 send disconnect message 
 send flow control message 
 connect message 
 send disconnect resp 
 complete  write list CB 
  mei_connect_timeout  - connectdisconnect timeouts
  @cl: host client
  mei_schedule_stall_timer - re-arm stall_timer work
  Schedule stall timer
  @dev: the device structure
  mei_timer - timer function.
  @work: pointer to the work_struct structure
 Catch interrupt stalls during HBM init handshake 
 connectdisconnect timeouts 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2003-2020, Intel Corporation. All rights reserved.
  Intel Management Engine Interface (Intel MEI) Linux driver
  mei_me_cl_init - initialize me client
  @me_cl: me client
  mei_me_cl_get - increases me client refcount
  @me_cl: me client
  Locking: called under "dev->device_lock" lock
  Return: me client or NULL
  mei_me_cl_release - free me client
  Locking: called under "dev->device_lock" lock
  @ref: me_client refcount
  mei_me_cl_put - decrease me client refcount and free client if necessary
  Locking: called under "dev->device_lock" lock
  @me_cl: me client
  __mei_me_cl_del  - delete me client from the list and decrease
      reference counter
  @dev: mei device
  @me_cl: me client
  Locking: dev->me_clients_rwsem
  mei_me_cl_del - delete me client from the list and decrease
      reference counter
  @dev: mei device
  @me_cl: me client
  mei_me_cl_add - add me client to the list
  @dev: mei device
  @me_cl: me client
  __mei_me_cl_by_uuid - locate me client by uuid
 	increases ref count
  @dev: mei device
  @uuid: me client uuid
  Return: me client or NULL if not found
  Locking: dev->me_clients_rwsem
  mei_me_cl_by_uuid - locate me client by uuid
 	increases ref count
  @dev: mei device
  @uuid: me client uuid
  Return: me client or NULL if not found
  Locking: dev->me_clients_rwsem
  mei_me_cl_by_id - locate me client by client id
 	increases ref count
  @dev: the device structure
  @client_id: me client id
  Return: me client or NULL if not found
  Locking: dev->me_clients_rwsem
  __mei_me_cl_by_uuid_id - locate me client by client id and uuid
 	increases ref count
  @dev: the device structure
  @uuid: me client uuid
  @client_id: me client id
  Return: me client or null if not found
  Locking: dev->me_clients_rwsem
  mei_me_cl_by_uuid_id - locate me client by client id and uuid
 	increases ref count
  @dev: the device structure
  @uuid: me client uuid
  @client_id: me client id
  Return: me client or null if not found
  mei_me_cl_rm_by_uuid - remove all me clients matching uuid
  @dev: the device structure
  @uuid: me client uuid
  Locking: called under "dev->device_lock" lock
  mei_me_cl_rm_by_uuid_id - remove all me clients matching client id
  @dev: the device structure
  @uuid: me client uuid
  @id: me client id
  Locking: called under "dev->device_lock" lock
  mei_me_cl_rm_all - remove all me clients
  @dev: the device structure
  Locking: called under "dev->device_lock" lock
  mei_io_cb_free - free mei_cb_private related memory
  @cb: mei callback struct
  mei_tx_cb_enqueue - queue tx callback
  Locking: called under "dev->device_lock" lock
  @cb: mei callback struct
  @head: an instance of list to queue on
  mei_tx_cb_dequeue - dequeue tx callback
  Locking: called under "dev->device_lock" lock
  @cb: mei callback struct to dequeue and free
  mei_cl_set_read_by_fp - set pending_read flag to vtag struct for given fp
  Locking: called under "dev->device_lock" lock
  @cl: mei client
  @fp: pointer to file structure
  mei_io_cb_init - allocate and initialize io callback
  @cl: mei client
  @type: operation type
  @fp: pointer to file structure
  Return: mei_cl_cb pointer or NULL;
  mei_io_list_flush_cl - removes cbs belonging to the cl.
  @head:  an instance of our list structure
  @cl:    host client
  mei_io_tx_list_free_cl - removes cb belonging to the cl and free them
  @head: An instance of our list structure
  @cl: host client
  @fp: file pointer (matching cb file object), may be NULL
  mei_io_list_free_fp - free cb from a list that matches file pointer
  @head: io list
  @fp: file pointer (matching cb file object), may be NULL
  mei_cl_free_pending - free pending cb
  @cl: host client
  mei_cl_alloc_cb - a convenient wrapper for allocating read cb
  @cl: host client
  @length: size of the buffer
  @fop_type: operation type
  @fp: associated file pointer (might be NULL)
  Return: cb on success and NULL on failure
  mei_cl_enqueue_ctrl_wr_cb - a convenient wrapper for allocating
      and enqueuing of the control commands cb
  @cl: host client
  @length: size of the buffer
  @fop_type: operation type
  @fp: associated file pointer (might be NULL)
  Return: cb on success and NULL on failure
  Locking: called under "dev->device_lock" lock
 for RX always allocate at least client's mtu 
  mei_cl_read_cb - find this cl's callback in the read list
      for a specific file
  @cl: host client
  @fp: file pointer (matching cb file object), may be NULL
  Return: cb on success, NULL if cb is not found
  mei_cl_flush_queues - flushes queue lists belonging to cl.
  @cl: host client
  @fp: file pointer (matching cb file object), may be NULL
  Return: 0 on success, -EINVAL if cl or cl->dev is NULL.
 free pending and control cb only in final flush 
  mei_cl_init - initializes cl.
  @cl: host client to be initialized
  @dev: mei device
  mei_cl_allocate - allocates cl  structure and sets it up.
  @dev: mei device
  Return:  The allocated file or NULL on failure
  mei_cl_link - allocate host id in the host map
  @cl: host client
  Return: 0 on success
 	-EINVAL on incorrect values
 	-EMFILE if open count exceeded.
  mei_cl_unlink - remove host client from the list
  @cl: host client
  Return: always 0
 don't shout on error exit path 
 never clear the 0 bit 
  mei_hbuf_acquire - try to acquire host buffer
  @dev: the device structure
  Return: true if host buffer was acquired
  mei_cl_wake_all - wake up readers, writers and event waiters so
                  they can be interrupted
  @cl: host client
 synchronized under device mutex 
 synchronized under device mutex 
 synchronized under device mutex 
 synchronized under device mutex 
  mei_cl_set_disconnected - set disconnected state and clear
    associated states and resources
  @cl: host client
 only one connection is allowed for fixed address clients 
  mei_cl_send_disconnect - send disconnect request
  @cl: host client
  @cb: callback block
  Return: 0, OK; otherwise, error.
  mei_cl_irq_disconnect - processes close related operation from
 	interrupt thread context - send disconnect request
  @cl: client
  @cb: callback block.
  @cmpl_list: complete list.
  Return: 0, OK; otherwise, error.
  __mei_cl_disconnect - disconnect host client from the me one
      internal function runtime pm has to be already acquired
  @cl: host client
  Return: 0 on success, <0 on failure.
 we disconnect also on error 
  mei_cl_disconnect - disconnect host client from the me one
  @cl: host client
  Locking: called under "dev->device_lock" lock
  Return: 0 on success, <0 on failure.
  mei_cl_is_other_connecting - checks if other
     client with the same me client id is connecting
  @cl: private data of the file object
  Return: true if other client is connected, false - otherwise.
  mei_cl_send_connect - send connect request
  @cl: host client
  @cb: callback block
  Return: 0, OK; otherwise, error.
  mei_cl_irq_connect - send connect request in irq_thread context
  @cl: host client
  @cb: callback block
  @cmpl_list: complete list
  Return: 0, OK; otherwise, error.
  mei_cl_connect - connect host client to the me one
  @cl: host client
  @me_cl: me client
  @fp: pointer to file structure
  Locking: called under "dev->device_lock" lock
  Return: 0 on success, <0 on failure.
 run hbuf acquire last so we don't have to undo 
			  ignore disconnect return valuue;
			   in case of failure reset will be invoked
 timeout or something went really wrong 
  mei_cl_alloc_linked - allocate and link host client
  @dev: the device structure
  Return: cl on success ERR_PTR on failure
  mei_cl_tx_flow_ctrl_creds - checks flow_control credits for cl.
  @cl: host client
  Return: 1 if tx_flow_ctrl_creds >0, 0 - otherwise.
  mei_cl_tx_flow_ctrl_creds_reduce - reduces transmit flow control credits
    for a client
  @cl: host client
  Return:
 	0 on success
 	-EINVAL when ctrl credits are <= 0
  mei_cl_vtag_alloc - allocate and fill the vtag structure
  @fp: pointer to file structure
  @vtag: vm tag
  Return:
   Pointer to allocated struct - on success
   ERR_PTR(-ENOMEM) on memory allocation failure
  mei_cl_fp_by_vtag - obtain the file pointer by vtag
  @cl: host client
  @vtag: virtual tag
  Return:
   A file pointer - on success
   ERR_PTR(-ENOENT) if vtag is not found in the client vtag list
 The client on bus has one fixed fp 
  mei_cl_reset_read_by_vtag - reset pending_read flag by given vtag
  @cl: host client
  @vtag: vm tag
  mei_cl_read_vtag_add_fc - add flow control for next pending reader
                            in the vtag list
  @cl: host client
  mei_cl_vt_support_check - check if client support vtags
  @cl: host client
  Return:
   0 - supported, or not connected at all
   -EOPNOTSUPP - vtags are not supported by client
  mei_cl_add_rd_completed - add read completed callback to list with lock
                            and vtag check
  @cl: host client
  @cb: callback block
 client already disconnected, discarding 
  mei_cl_del_rd_completed - free read completed callback with lock
  @cl: host client
  @cb: callback block
   mei_cl_notify_fop2req - convert fop to proper request
  @fop: client notification start response command
  Return:  MEI_HBM_NOTIFICATION_STARTSTOP
   mei_cl_notify_req2fop - convert notification request top file operation type
  @req: hbm notification request type
  Return:  MEI_FOP_NOTIFY_STARTSTOP
  mei_cl_irq_notify - send notification request in irq_thread context
  @cl: client
  @cb: callback block.
  @cmpl_list: complete list.
  Return: 0 on such and error otherwise.
  mei_cl_notify_request - send notification stopstart request
  @cl: host client
  @fp: associate request with file
  @request: 1 for start or 0 for stop
  Locking: called under "dev->device_lock" lock
  Return: 0 on such and error otherwise.
  mei_cl_notify - raise notification
  @cl: host client
  Locking: called under "dev->device_lock" lock
  mei_cl_notify_get - get or wait for notification event
  @cl: host client
  @block: this request is blocking
  @notify_ev: true if notification event was received
  Locking: called under "dev->device_lock" lock
  Return: 0 on such and error otherwise.
  mei_cl_read_start - the start read client message function.
  @cl: host client
  @length: number of bytes to read
  @fp: pointer to file structure
  Return: 0 on success, <0 on failure.
 HW currently supports only one pending read 
  mei_msg_hdr_init - allocate and initialize mei message header
  @cb: message callback structure
  Return: a pointer to initialized header or ERR_PTR on failure
 Extended header for vtag is attached only on the first fragment 
 Compute extended header size 
  mei_cl_irq_write - write a message to device
 	from the interrupt thread context
  @cl: client
  @cb: callback block.
  @cmpl_list: complete list.
  Return: 0, OK; otherwise error.
	
	  Split the message only if we can write the whole host buffer
	  otherwise wait for next time the host buffer is empty.
  mei_cl_write - submit a write cb to mei device
 	assumes device_lock is locked
  @cl: host client
  @cb: write callback with filled data
  Return: number of bytes sent on success, <0 on failure.
 restore return value 
 wait_event_interruptible returns -ERESTARTSYS 
  mei_cl_complete - processes completed operation for a client
  @cl: private data of the file object.
  @cb: callback block.
  mei_cl_all_disconnect - disconnect forcefully all connected clients
  @dev: mei device
  mei_cl_irq_dma_map - send client dma map request in irq_thread context
  @cl: client
  @cb: callback block.
  @cmpl_list: complete list.
  Return: 0 on such and error otherwise.
  mei_cl_irq_dma_unmap - send client dma unmap request in irq_thread context
  @cl: client
  @cb: callback block.
  @cmpl_list: complete list.
  Return: 0 on such and error otherwise.
  mei_cl_dma_alloc_and_map - send client dma map request
  @cl: host client
  @fp: pointer to file structure
  @buffer_id: id of the mapped buffer
  @size: size of the buffer
  Locking: called under "dev->device_lock" lock
  Return:
   -ENODEV
   -EINVAL
   -EOPNOTSUPP
   -EPROTO
   -ENOMEM;
  mei_cl_dma_unmap - send client dma unmap request
  @cl: host client
  @fp: pointer to file structure
  Locking: called under "dev->device_lock" lock
  Return: 0 on such and error otherwise.
 do not allow unmap for connected client 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2012-2016, Intel Corporation. All rights reserved
  Intel Management Engine Interface (Intel MEI) Linux driver
  if the driver is not enabled the list won't be consistent 
  if the driver is not enabled the list won't be consistent 
  mei_dbgfs_deregister - Remove the debugfs files and directories
  @dev: the mei device structure
  mei_dbgfs_register - Add the debugfs files
  @dev: the mei device structure
  @name: the mei device name
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2012-2019, Intel Corporation. All rights reserved.
  Intel Management Engine Interface (Intel MEI) Linux driver
  mei_fw_status2str - convert fw status registers to printable string
  @fw_status:  firmware status
  @buf: string buffer at minimal size MEI_FW_STATUS_STR_SZ
  @len: buffer len must be >= MEI_FW_STATUS_STR_SZ
  Return: number of bytes written or -EINVAL if buffer is to small
 drop last space 
  mei_cancel_work - Cancel mei background jobs
  @dev: the device structure
  mei_reset - resets host and fw.
  @dev: the device structure
  Return: 0 on success or < 0 if the reset hasn't succeeded
	 we're already in reset, cancel the init timer
	  if the reset was called due the hbm protocol error
	  we need to call it before hw start
	  so the hbm watchdog won't kick in
 enter reset flow 
 fall through and remove the sw state even if hw reset has failed 
 no need to clean up software state in case of power up 
  mei_start - initializes host and fw to start work.
  @dev: the device structure
  Return: 0 on success, <0 on failure.
 acknowledge interrupt and stop interrupts 
  mei_restart - restart device after suspend
  @dev: the device structure
  Return: 0 on success or -ENODEV if the restart hasn't succeeded
 try to start again 
 retry reset in case of failure 
 move device to disabled state unconditionally 
  mei_write_is_idle - check if the write queues are idle
  @dev: the device structure
  Return: true of there is no pending write
  mei_device_init  -- initialize mei_device structure
  @dev: the mei device
  @device: the device structure
  @hw_ops: hw operations
 setup our list array 
	
	  Reserving the first client ID
	  0: Reserved for MEI Bus Message communications
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2013-2020, Intel Corporation. All rights reserved.
  Intel Management Engine Interface (Intel MEI) Linux driver
 Baytrail 
 Cherrytrail 
 CONFIG_PM 
  mei_txe_probe - Device Initialization Routine
  @pdev: PCI device structure
  @ent: entry in mei_txe_pci_tbl
  Return: 0 on success, <0 on failure.
 enable pci dev 
 set PCI host mastering  
 pci request regions and mapping IO device memory for mei driver 
 allocates and initializes the mei dev structure 
 clear spurious interrupts 
 request and enable interrupt  
	
	  MEI requires to resume from runtime suspend mode
	  in order to perform link reset flow upon system suspend.
	
	  TXE maps runtime suspendresume to own power gating states,
	  hence we need to go around native PCI runtime service which
	  eventually brings the device into D3coldhot state.
	  But the TXE device cannot wake up from D3 unlike from own
	  power gating. To get around PCI device native runtime pm,
	  TXE uses runtime pm domain handlers which take precedence.
  mei_txe_shutdown- Device Shutdown Routine
  @pdev: PCI device structure
   mei_txe_shutdown is called from the reboot notifier
   it's a simplified version of remove so we go down
   faster.
  mei_txe_remove - Device Removal Routine
  @pdev: PCI device structure
  mei_remove is called by the PCI subsystem to alert the driver
  that it should release a PCI device.
 request and enable interrupt 
 CONFIG_PM_SLEEP 
 keep irq on we are staying in D0 
  mei_txe_set_pm_domain - fill and set pm domain structure for device
  @dev: mei_device
  mei_txe_unset_pm_domain - clean pm domain structure for device
  @dev: mei_device
 stop using pm callbacks if any 
 CONFIG_PM 
   PCI driver structure
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2013-2020, Intel Corporation. All rights reserved.
  Intel Management Engine Interface (Intel MEI) Linux driver
  number_of_connections - determine whether an client be on the bus
     according number of connections
     We support only clients:
        1. with single connection
        2. and fixed clients (max_number_of_connections == 0)
  @cldev: me clients device
  blacklist - blacklist a client from the bus
  @cldev: me clients device
  whitelist - forcefully whitelist client
  @cldev: me clients device
 receive timeout in msec 
		
		  Should be at least one version block,
		  error out if nothing found
 No need to enable the client if nothing is needed from it 
  mei_wd - wd client on the bus, change protocol version
    as the API has changed.
  @cldev: me clients device
 CONFIG_INTEL_MEI_ME 
 Vendors 
 Radio types 
  mei_nfc_if_version - get NFC interface version
  @cl: host client (nfc info)
  @ver: NFC interface version to be filled in
  Return: 0 on success; < 0 otherwise
 to be sure on the stack we alloc memory 
  mei_nfc_radio_name - derive nfc radio name from the interface version
  @ver: NFC radio version
  Return: radio name string
  mei_nfc - The nfc fixup function. The function retrieves nfc radio
     name and set is as device attribute so we can load
     the proper device driver for it
  @cldev: me client device (nfc)
 we need to connect to INFO GUID 
  vt_support - enable on bus clients with vtag support
  @cldev: me clients device
  mei_cl_bus_dev_fixup - run fixup handlers
  @cldev: me client device
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2015-2016, Intel Corporation. All rights reserved.
  Intel Management Engine Interface (Intel MEI) Linux driver
 sparse doesn't like tracepoint macros 
 __CHECKER__ 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2003-2020, Intel Corporation. All rights reserved.
  Intel Management Engine Interface (Intel MEI) Linux driver
  mei_cl_conn_status_to_errno - convert client connect response
  status to error code
  @status: client connect response status
  Return: corresponding error code
  mei_hbm_write_message - wrapper for sending hbm messages.
  @dev: mei device
  @hdr: mei header
  @data: payload
  mei_hbm_idle - set hbm to idle state
  @dev: the device structure
  mei_hbm_reset - reset hbm counters and book keeping data structurs
  @dev: the device structure
  mei_hbm_hdr - construct hbm header
  @mei_hdr: hbm header
  @length: payload length
  mei_hbm_cl_hdr - construct client hbm header
  @cl: client
  @hbm_cmd: host bus message command
  @buf: buffer for cl header
  @len: buffer length
  mei_hbm_cl_write - write simple hbm client message
  @dev: the device structure
  @cl: client
  @hbm_cmd: host bus message command
  @buf: message buffer
  @len: buffer length
  Return: 0 on success, <0 on failure.
  mei_hbm_cl_addr_equal - check if the client's and
 	the message address match
  @cl: client
  @cmd: hbm client message
  Return: true if addresses are the same
  mei_hbm_cl_find_by_cmd - find recipient client
  @dev: the device structure
  @buf: a buffer with hbm cl command
  Return: the recipient client or NULL if not found
  mei_hbm_start_wait - wait for start response message.
  @dev: the device structure
  Return: 0 on success and < 0 on failure
  mei_hbm_start_req - sends start request message.
  @dev: the device structure
  Return: 0 on success and < 0 on failure
 host start message 
  mei_hbm_dma_setup_req() - setup DMA request
  @dev: the device structure
  Return: 0 on success and < 0 on failure
  mei_hbm_capabilities_req - request capabilities
  @dev: the device structure
  Return: 0 on success and < 0 on failure
  mei_hbm_enum_clients_req - sends enumeration client request message.
  @dev: the device structure
  Return: 0 on success and < 0 on failure
 enumerate clients 
  mei_hbm_me_cl_add - add new me client to the list
  @dev: the device structure
  @res: hbm property response
  Return: 0 on success and -ENOMEM on allocation failure
  mei_hbm_add_cl_resp - send response to fw on client add request
  @dev: the device structure
  @addr: me address
  @status: response status
  Return: 0 on success and < 0 on failure
  mei_hbm_fw_add_cl_req - request from the fw to add a client
  @dev: the device structure
  @req: add client request
  Return: 0 on success and < 0 on failure
  mei_hbm_cl_notify_req - send notification request
  @dev: the device structure
  @cl: a client to disconnect from
  @start: true for start false for stop
  Return: 0 on success and -EIO on write failure
   notify_res_to_fop - convert notification response to the proper
       notification FOP
  @cmd: client notification start response command
  Return:  MEI_FOP_NOTIFY_START or MEI_FOP_NOTIFY_STOP;
  mei_hbm_cl_notify_start_res - update the client state according
        notify start response
  @dev: the device structure
  @cl: mei host client
  @cmd: client notification start response command
  mei_hbm_cl_notify_stop_res - update the client state according
        notify stop response
  @dev: the device structure
  @cl: mei host client
  @cmd: client notification stop response command
 TODO: spec is not clear yet about other possible issues 
  mei_hbm_cl_notify - signal notification event
  @dev: the device structure
  @cmd: notification client message
  mei_hbm_cl_dma_map_req - send client dma map request
  @dev: the device structure
  @cl: mei host client
  Return: 0 on success and -EIO on write failure
  mei_hbm_cl_dma_unmap_req - send client dma unmap request
  @dev: the device structure
  @cl: mei host client
  Return: 0 on success and -EIO on write failure
  mei_hbm_prop_req - request property for a single client
  @dev: the device structure
  @start_idx: client index to start search
  Return: 0 on success and < 0 on failure
 We got all client properties 
  mei_hbm_pg - sends pg command
  @dev: the device structure
  @pg_cmd: the pg command code
  Return: -EIO on write failure
          -EOPNOTSUPP if the operation is not supported by the protocol
  mei_hbm_stop_req - send stop request message
  @dev: mei device
  Return: -EIO on write failure
  mei_hbm_cl_flow_control_req - sends flow control request.
  @dev: the device structure
  @cl: client info
  Return: -EIO on write failure
  mei_hbm_add_single_tx_flow_ctrl_creds - adds single buffer credentials.
  @dev: the device structure
  @fctrl: flow control response bus message
  Return: 0 on success, < 0 otherwise
  mei_hbm_cl_tx_flow_ctrl_creds_res - flow control response from me
  @dev: the device structure
  @fctrl: flow control response bus message
 single receive buffer 
  mei_hbm_cl_disconnect_req - sends disconnect message to fw.
  @dev: the device structure
  @cl: a client to disconnect from
  Return: -EIO on write failure
  mei_hbm_cl_disconnect_rsp - sends disconnect respose to the FW
  @dev: the device structure
  @cl: a client to disconnect from
  Return: -EIO on write failure
  mei_hbm_cl_disconnect_res - update the client state according
        disconnect response
  @dev: the device structure
  @cl: mei host client
  @cmd: disconnect client response host bus message
  mei_hbm_cl_connect_req - send connection request to specific me client
  @dev: the device structure
  @cl: a client to connect to
  Return: -EIO on write failure
  mei_hbm_cl_connect_res - update the client state according
         connection response
  @dev: the device structure
  @cl: mei host client
  @cmd: connect client response host bus message
  mei_hbm_cl_res - process hbm response received on behalf
          an client
  @dev: the device structure
  @rs:  hbm client message
  @fop_type: file operation type
  mei_hbm_fw_disconnect_req - disconnect request initiated by ME firmware
   host sends disconnect response
  @dev: the device structure.
  @disconnect_req: disconnect request bus message from the me
  Return: -ENOMEM on allocation failure
  mei_hbm_pg_enter_res - PG enter response received
  @dev: the device structure.
  Return: 0 on success, -EPROTO on state mismatch
  mei_hbm_pg_resume - process with PG resume
  @dev: the device structure.
  mei_hbm_pg_exit_res - PG exit response received
  @dev: the device structure.
  Return: 0 on success, -EPROTO on state mismatch
		
		 If the driver is not waiting on this then
		 this is HW initiated exit from PG.
		 Start runtime pm resume sequence to exit from PG.
  mei_hbm_config_features - check what hbm features and commands
         are supported by the fw
  @dev: the device structure
 Power Gating Isolation Support 
 disconnect on connect timeout instead of link reset 
 Notification Event Support 
 Fixed Address Client Support 
 OS ver message Support 
 DMA Ring Support 
 VTag Support 
 Capability message Support 
 Client DMA Support 
  mei_hbm_version_is_supported - checks whether the driver can
      support the hbm version of the device
  @dev: the device structure
  Return: true if driver can support hbm version of the device
  mei_hbm_dispatch - bottom half read routine after ISR to
  handle the read bus message cmd processing.
  @dev: the device structure
  @hdr: header of bus message
  Return: 0 on success and < 0 on failure
 read the message to our buffer 
	 ignore spurious message and prevent reset nesting
	  hbm is put to idle during system reset
 request property for the next client 
 first property request 
 force the reset 
		
		  after the host receives the enum_resp
		  message clients may be added or removed
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2003-2020, Intel Corporation. All rights reserved.
  Intel Management Engine Interface (Intel MEI) Linux driver
  mei_me_reg_read - Reads 32bit data from the mei device
  @hw: the me hardware structure
  @offset: offset from which to read the data
  Return: register value (u32)
  mei_me_reg_write - Writes 32bit data to the mei device
  @hw: the me hardware structure
  @offset: offset from which to write the data
  @value: register value to write (u32)
  mei_me_mecbrw_read - Reads 32bit data from ME circular buffer
   read window register
  @dev: the device structure
  Return: ME_CB_RW register value (u32)
  mei_me_hcbww_write - write 32bit data to the host circular buffer
  @dev: the device structure
  @data: 32bit data to be written to the host circular buffer
  mei_me_mecsr_read - Reads 32bit data from the ME CSR
  @dev: the device structure
  Return: ME_CSR_HA register value (u32)
  mei_hcsr_read - Reads 32bit data from the host CSR
  @dev: the device structure
  Return: H_CSR register value (u32)
  mei_hcsr_write - writes H_CSR register to the mei device
  @dev: the device structure
  @reg: new register value
  mei_hcsr_set - writes H_CSR register to the mei device,
  and ignores the H_IS bit for it is write-one-to-zero.
  @dev: the device structure
  @reg: new register value
  mei_hcsr_set_hig - set host interrupt (set H_IG)
  @dev: the device structure
  mei_me_d0i3c_read - Reads 32bit data from the D0I3C register
  @dev: the device structure
  Return: H_D0I3C register value (u32)
  mei_me_d0i3c_write - writes H_D0I3C register to device
  @dev: the device structure
  @reg: new register value
  mei_me_trc_status - read trc status register
  @dev: mei device
  @trc: trc status register value
  Return: 0 on success, error otherwise
  mei_me_fw_status - read fw status register from pci config space
  @dev: mei device
  @fw_status: fw status register values
  Return: 0 on success, error otherwise
  mei_me_hw_config - configure hw dependent settings
  @dev: mei device
  Return:
    -EINVAL when read_fws is not set
    0 on success
 Doesn't change in runtime 
  mei_me_pg_state  - translate internal pg state
    to the mei power gating state
  @dev:  mei device
  Return: MEI_PG_OFF if aliveness is on and MEI_PG_ON otherwise
  me_intr_disable - disables mei device interrupts
       using supplied hcsr register value.
  @dev: the device structure
  @hcsr: supplied hcsr register value
  me_intr_clear - clear and stop interrupts
  @dev: the device structure
  @hcsr: supplied hcsr register value
  mei_me_intr_clear - clear and stop interrupts
  @dev: the device structure
  mei_me_intr_enable - enables mei device interrupts
  @dev: the device structure
  mei_me_intr_disable - disables mei device interrupts
  @dev: the device structure
  mei_me_synchronize_irq - wait for pending IRQ handlers
  @dev: the device structure
  mei_me_hw_reset_release - release device from the reset
  @dev: the device structure
  mei_me_host_set_ready - enable device
  @dev: mei device
  mei_me_host_is_ready - check whether the host has turned ready
  @dev: mei device
  Return: bool
  mei_me_hw_is_ready - check whether the me(hw) has turned ready
  @dev: mei device
  Return: bool
  mei_me_hw_is_resetting - check whether the me(hw) is in reset
  @dev: mei device
  Return: bool
  mei_me_hw_ready_wait - wait until the me(hw) has turned ready
   or timeout is reached
  @dev: mei device
  Return: 0 on success, error otherwise
  mei_me_hw_start - hw start routine
  @dev: mei device
  Return: 0 on success, error otherwise
  mei_hbuf_filled_slots - gets number of device filled buffer slots
  @dev: the device structure
  Return: number of filled slots
  mei_me_hbuf_is_empty - checks if host buffer is empty.
  @dev: the device structure
  Return: true if empty, false - otherwise.
  mei_me_hbuf_empty_slots - counts write empty slots.
  @dev: the device structure
  Return: -EOVERFLOW if overflow, otherwise empty slots count
 check for overflow 
  mei_me_hbuf_depth - returns depth of the hw buffer.
  @dev: the device structure
  Return: size of hw buffer in slots
  mei_me_hbuf_write - writes a message to host hw buffer.
  @dev: the device structure
  @hdr: header of message
  @hdr_len: header length in bytes: must be multiplication of a slot (4bytes)
  @data: payload
  @data_len: payload length in bytes
  Return: 0 if success, < 0 - otherwise.
  mei_me_count_full_read_slots - counts read full slots.
  @dev: the device structure
  Return: -EOVERFLOW if overflow, otherwise filled slots count
 check for overflow 
  mei_me_read_slots - reads a message from mei device.
  @dev: the device structure
  @buffer: message buffer will be written
  @buffer_length: message size will be read
  Return: always 0
  mei_me_pg_set - write pg enter register
  @dev: the device structure
  mei_me_pg_unset - write pg exit register
  @dev: the device structure
  mei_me_pg_legacy_enter_sync - perform legacy pg entry procedure
  @dev: the device structure
  Return: 0 on success an error code otherwise
  mei_me_pg_legacy_exit_sync - perform legacy pg exit procedure
  @dev: the device structure
  Return: 0 on success an error code otherwise
  mei_me_pg_in_transition - is device now in pg transition
  @dev: the device structure
  Return: true if in pg transition, false otherwise
  mei_me_pg_is_enabled - detect if PG is supported by HW
  @dev: the device structure
  Return: true is pg supported, false otherwise
  mei_me_d0i3_set - write d0i3 register bit on mei device.
  @dev: the device structure
  @intr: ask for interrupt
  Return: D0I3C register value
 read it to ensure HW consistency 
  mei_me_d0i3_unset - clean d0i3 register bit on mei device.
  @dev: the device structure
  Return: D0I3C register value
 read it to ensure HW consistency 
  mei_me_d0i3_enter_sync - perform d0i3 entry procedure
  @dev: the device structure
  Return: 0 on success an error code otherwise
 we are in d0i3, nothing to do 
 PGI entry procedure 
 FIXME: should we reset here? 
 end PGI entry procedure 
  mei_me_d0i3_enter - perform d0i3 entry procedure
    no hbm PG handshake
    no waiting for confirmation; runs with interrupts
    disabled
  @dev: the device structure
  Return: 0 on success an error code otherwise
 we are in d0i3, nothing to do 
  mei_me_d0i3_exit_sync - perform d0i3 exit procedure
  @dev: the device structure
  Return: 0 on success an error code otherwise
 we are not in d0i3, nothing to do 
  mei_me_pg_legacy_intr - perform legacy pg processing
 			   in interrupt thread handler
  @dev: the device structure
  mei_me_d0i3_intr - perform d0i3 processing in interrupt thread handler
  @dev: the device structure
  @intr_source: interrupt source
				
				  force H_RDY because it could be
				  wiped off during PG
		
		  HW sent some data and we are in D0i3, so
		  we got here because of HW initiated exit from D0i3.
		  Start runtime pm resume sequence to exit low power state.
  mei_me_pg_intr - perform pg processing in interrupt thread handler
  @dev: the device structure
  @intr_source: interrupt source
  mei_me_pg_enter_sync - perform runtime pm entry procedure
  @dev: the device structure
  Return: 0 on success an error code otherwise
  mei_me_pg_exit_sync - perform runtime pm exit procedure
  @dev: the device structure
  Return: 0 on success an error code otherwise
  mei_me_hw_reset - resets fw via mei csr register.
  @dev: the device structure
  @intr_enable: if interrupt should be enabled after reset.
  Return: 0 on success an error code otherwise
	 H_RST may be found lit before reset is started,
	  for example if preceding reset flow hasn't completed.
	  In that case asserting H_RST will be ignored, therefore
	  we need to clean H_RST bit to start a successful reset sequence.
	
	  Host reads the H_CSR once to ensure that the
	  posted write to H_CSR completes.
  mei_me_irq_quick_handler - The ISR of the MEI device
  @irq: The irq number
  @dev_id: pointer to the device structure
  Return: irqreturn_t
 disable interrupts on device 
  mei_me_irq_thread_handler - function called after ISR to handle the interrupt
  processing.
  @irq: The irq number
  @dev_id: pointer to the device structure
  Return: irqreturn_t
 initialize our complete list 
 check if ME wants a reset 
  check if we need to start the dev 
 check slots available for reading 
		 There is a race between ME write and interrupt delivery:
		  Not all data is always available immediately after the
		  interrupt, so try to read again on the next interrupt.
	
	  During PG handshake only allowed write is the replay to the
	  PG exit message, so block calling write function
	  if the pg event is in PG handshake
  mei_me_fw_type_nm() - check for nm sku
  Read ME FW Status register to check for the Node Manager (NM) Firmware.
  The NM FW is only signaled in PCI function 0.
  __Note__: Deprecated by PCH8 and newer.
  @pdev: pci device
  Return: true in case of NM firmware
 make sure that bit 9 (NM) is up and bit 10 (DM) is down 
  mei_me_fw_type_sps_4() - check for sps 4.0 sku
  Read ME FW Status register to check for SPS Firmware.
  The SPS FW is only signaled in the PCI function 0.
  __Note__: Deprecated by SPS 5.0 and newer.
  @pdev: pci device
  Return: true in case of SPS firmware
  mei_me_fw_type_sps() - check for sps sku
  Read ME FW Status register to check for SPS Firmware.
  The SPS FW is only signaled in pci function 0
  @pdev: pci device
  Return: true in case of SPS firmware
 ICH Legacy devices 
 ICH devices 
 PCH6 devices 
 PCH7 devices 
 PCH Cougar Point and Patsburg with quirk for Node Manager exclusion 
 PCH8 Lynx Point and newer devices 
 PCH8 Lynx Point and newer devices - iTouch 
 PCH8 Lynx Point with quirk for SPS Firmware exclusion 
 LBG with quirk for SPS (4.0) Firmware exclusion 
 Cannon Lake and newer devices 
 Cannon Lake with quirk for SPS 5.0 and newer Firmware exclusion 
 Cannon Lake itouch with quirk for SPS 5.0 and newer Firmware exclusion
  wo DMA support.
 Tiger Lake and newer devices 
 Tiger Lake with quirk for SPS 5.0 and newer Firmware exclusion 
  mei_cfg_list - A list of platform platform specific configurations.
  Note: has to be synchronized with  enum mei_cfg_idx.
  mei_me_dev_init - allocates and initializes the mei device structure
  @parent: device associated with physical device (pciplatform)
  @cfg: per device generation config
  Return: The mei_device pointer on success, NULL on failure.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2003-2020, Intel Corporation. All rights reserved.
  Intel Management Engine Interface (Intel MEI) Linux driver
  mei_open - the open function
  @inode: pointer to inode structure
  @file: pointer to file structure
  Return: 0 on success, <0 on error
  mei_cl_vtag_remove_by_fp - remove vtag that corresponds to fp from list
  @cl: host client
  @fp: pointer to file structure
  mei_release - the release function
  @inode: pointer to inode structure
  @file: pointer to file structure
  Return: 0 on success, <0 on error
	
	  Check again: This is necessary since disconnect releases the lock
	  and another client can connect in the meantime.
  mei_read - the read function.
  @file: pointer to file structure
  @ubuf: pointer to user buffer
  @length: buffer length
  @offset: data offset in buffer
  Return: >=0 data length on success , <0 on error
 now copy the data to user space 
	 length is being truncated to PAGE_SIZE,
 not all data was read, keep the cb 
  mei_cl_vtag_by_fp - obtain the vtag by file pointer
  @cl: host client
  @fp: pointer to file structure
  Return: vtag value on success, otherwise 0
  mei_write - the write function.
  @file: pointer to file structure
  @ubuf: pointer to user buffer
  @length: buffer length
  @offset: data offset in buffer
  Return: >=0 data length on success , <0 on error
  mei_ioctl_connect_client - the connect to fw client IOCTL function
  @file: private data of the file object
  @in_client_uuid: requested UUID for connection
  @client: IOCTL connect data, output parameters
  Locking: called under "dev->device_lock" lock
  Return: 0 on success, <0 on failure.
 find ME client we're trying to connect to 
 prepare the output buffer 
  mei_vt_support_check - check if client support vtags
  Locking: called under "dev->device_lock" lock
  @dev: mei_device
  @uuid: client UUID
  Return:
 	0 - supported
 	-ENOTTY - no such client
 	-EOPNOTSUPP - vtags are not supported by client
  mei_ioctl_connect_vtag - connect to fw client with vtag IOCTL function
  @file: private data of the file object
  @in_client_uuid: requested UUID for connection
  @client: IOCTL connect data, output parameters
  @vtag: vm tag
  Locking: called under "dev->device_lock" lock
  Return: 0 on success, <0 on failure.
 malicious connect from another thread may push vtag 
 only search for same UUID 
 if tag already exist try another fp 
 replace cl with acquired one 
  mei_ioctl_client_notify_request -
      propagate event notification request to client
  @file: pointer to file structure
  @request: 0 - disable, 1 - enable
  Return: 0 on success , <0 on error
  mei_ioctl_client_notify_get -  wait for notification request
  @file: pointer to file structure
  @notify_get: 0 - disable, 1 - enable
  Return: 0 on success , <0 on error
  mei_ioctl - the IOCTL function
  @file: pointer to file structure
  @cmd: ioctl command
  @data: pointer to mei message structure
  Return: 0 on success , <0 on error
 if all is ok, copying the data back to user. 
 if all is ok, copying the data back to user. 
  mei_poll - the poll function
  @file: pointer to file structure
  @wait: pointer to poll_table structure
  Return: poll mask
  mei_cl_is_write_queued - check if the client has pending writes.
  @cl: writing host client
  Return: true if client is writing, false otherwise.
  mei_fsync - the fsync handler
  @fp:       pointer to file structure
  @start:    unused
  @end:      unused
  @datasync: unused
  Return: 0 on success, -ENODEV if client is not connected
  mei_fasync - asynchronous io support
  @fd: file descriptor
  @file: pointer to file structure
  @band: band bitmap
  Return: negative on error,
          0 if it did no changes,
          and positive a process was added or deleted
  trc_show - mei device trc attribute show method
  @device: device pointer
  @attr: attribute pointer
  @buf:  char out buffer
  Return: number of the bytes printed into buf or error
  fw_status_show - mei device fw_status attribute show method
  @device: device pointer
  @attr: attribute pointer
  @buf:  char out buffer
  Return: number of the bytes printed into buf or error
  hbm_ver_show - display HBM protocol version negotiated with FW
  @device: device pointer
  @attr: attribute pointer
  @buf:  char out buffer
  Return: number of the bytes printed into buf or error
  hbm_ver_drv_show - display HBM protocol version advertised by driver
  @device: device pointer
  @attr: attribute pointer
  @buf:  char out buffer
  Return: number of the bytes printed into buf or error
  fw_ver_show - display ME FW version
  @device: device pointer
  @attr: attribute pointer
  @buf:  char out buffer
  Return: number of the bytes printed into buf or error
  dev_state_show - display device state
  @device: device pointer
  @attr: attribute pointer
  @buf:  char out buffer
  Return: number of the bytes printed into buf or error
  mei_set_devstate: set to new device state and notify sysfs file.
  @dev: mei_device
  @state: new device state
  kind_show - display device kind
  @device: device pointer
  @attr: attribute pointer
  @buf: char out buffer
  Return: number of the bytes printed into buf or error
  file operations structure will be used for mei char device.
  mei_minor_get - obtain next free device minor number
  @dev:  device pointer
  Return: allocated minor, or -ENOSPC if no free minor left
  mei_minor_free - mark device minor number as free
  @dev:  device pointer
 class device 
 Fill in the data structures 
 Add the device 
 SPDX-License-Identifier: GPL-2.0
  Copyright ¬© 2019 Intel Corporation
  mei_hdcp.c: HDCP client driver for mei bus
  Author:
  Ramalingam C <ramalingam.c@intel.com>
  DOC: MEI_HDCP Client Driver
  The mei_hdcp driver acts as a translation layer between HDCP 2.2
  protocol  implementer (I915) and ME FW by translating HDCP2.2
  negotiation messages to ME FW command payloads and vice versa.
  mei_hdcp_initiate_session() - Initiate a Wired HDCP2.2 Tx Session in ME FW
  @dev: device corresponding to the mei_cl_device
  @data: Intel HW specific hdcp data
  @ake_data: AKE_Init msg output.
  Return:  0 on Success, <0 on Failure.
  mei_hdcp_verify_receiver_cert_prepare_km() - Verify the Receiver Certificate
  AKE_Send_Cert and prepare AKE_Stored_KmAKE_No_Stored_Km
  @dev: device corresponding to the mei_cl_device
  @data: Intel HW specific hdcp data
  @rx_cert: AKE_Send_Cert for verification
  @km_stored: Pairing status flag output
  @ek_pub_km: AKE_Stored_KmAKE_No_Stored_Km output msg
  @msg_sz : size of AKE_XXXXX_Km output msg
  Return: 0 on Success, <0 on Failure
  mei_hdcp_verify_hprime() - Verify AKE_Send_H_prime at ME FW.
  @dev: device corresponding to the mei_cl_device
  @data: Intel HW specific hdcp data
  @rx_hprime: AKE_Send_H_prime msg for ME FW verification
  Return: 0 on Success, <0 on Failure
  mei_hdcp_store_pairing_info() - Store pairing info received at ME FW
  @dev: device corresponding to the mei_cl_device
  @data: Intel HW specific hdcp data
  @pairing_info: AKE_Send_Pairing_Info msg input to ME FW
  Return: 0 on Success, <0 on Failure
  mei_hdcp_initiate_locality_check() - Prepare LC_Init
  @dev: device corresponding to the mei_cl_device
  @data: Intel HW specific hdcp data
  @lc_init_data: LC_Init msg output
  Return: 0 on Success, <0 on Failure
  mei_hdcp_verify_lprime() - Verify lprime.
  @dev: device corresponding to the mei_cl_device
  @data: Intel HW specific hdcp data
  @rx_lprime: LC_Send_L_prime msg for ME FW verification
  Return: 0 on Success, <0 on Failure
  mei_hdcp_get_session_key() - Prepare SKE_Send_Eks.
  @dev: device corresponding to the mei_cl_device
  @data: Intel HW specific hdcp data
  @ske_data: SKE_Send_Eks msg output from ME FW.
  Return: 0 on Success, <0 on Failure
  mei_hdcp_repeater_check_flow_prepare_ack() - Validate the Downstream topology
  and prepare rep_ack.
  @dev: device corresponding to the mei_cl_device
  @data: Intel HW specific hdcp data
  @rep_topology: Receiver ID List to be validated
  @rep_send_ack : repeater ack from ME FW.
  Return: 0 on Success, <0 on Failure
  mei_hdcp_verify_mprime() - Verify mprime.
  @dev: device corresponding to the mei_cl_device
  @data: Intel HW specific hdcp data
  @stream_ready: RepeaterAuth_Stream_Ready msg for ME FW verification.
  Return: 0 on Success, <0 on Failure
  mei_hdcp_enable_authentication() - Mark a port as authenticated
  through ME FW
  @dev: device corresponding to the mei_cl_device
  @data: Intel HW specific hdcp data
  Return: 0 on Success, <0 on Failure
  mei_hdcp_close_session() - Close the Wired HDCP Tx session of ME FW per port.
  This also disables the authenticated state of the port.
  @dev: device corresponding to the mei_cl_device
  @data: Intel HW specific hdcp data
  Return: 0 on Success, <0 on Failure
  mei_hdcp_component_match - compare function for matching mei hdcp.
     The function checks if the driver is i915, the subcomponent is HDCP
     and the grand parent of hdcp and the parent of i915 are the same
     PCH device.
  @dev: master device
  @subcomponent: subcomponent to match (I915_COMPONENT_HDCP)
  @data: compare data (mei hdcp device)
  Return:
   1 - if components match
   0 - otherwise
 SPDX-License-Identifier: GPL-2.0
  Copyright ¬© 2020 - 2021 Intel Corporation
  DOC: MEI_PXP Client Driver
  The mei_pxp driver acts as a translation layer between PXP
  protocol  implementer (I915) and ME FW by translating PXP
  negotiation messages to ME FW command payloads and vice versa.
  mei_pxp_send_message() - Sends a PXP message to ME FW.
  @dev: device corresponding to the mei_cl_device
  @message: a message buffer to send
  @size: size of the message
  Return: 0 on Success, <0 on Failure
 temporary drop const qualifier till the API is fixed 
  mei_pxp_receive_message() - Receives a PXP message from ME FW.
  @dev: device corresponding to the mei_cl_device
  @buffer: a message buffer to contain the received message
  @size: size of the buffer
  Return: bytes sent on Success, <0 on Failure
  mei_pxp_component_match - compare function for matching mei pxp.
     The function checks if the driver is i915, the subcomponent is PXP
     and the grand parent of pxp and the parent of i915 are the same
     PCH device.
  @dev: master device
  @subcomponent: subcomponent to match (I915_COMPONENT_PXP)
  @data: compare data (mei pxp device)
  Return:
   1 - if components match
   0 - otherwise
 fbf6fcf1-96cf-4e2e-a6a6-1bab8cbe36b1 : PAVP GUID
 SPDX-License-Identifier: GPL-2.0-or-later
  altera-jtag.c
  altera FPGA driver
  Copyright (C) Altera Corporation 1998-2001
  Copyright (C) 2010 NetUP Inc.
  Copyright (C) 2010 Igor M. Liplianin <liplianin@netup.ru>
  This structure shows, for each JTAG state, which state is reached after
  a single TCK clock cycle with TMS high or TMS low, respectively.  This
  describes all possible state transitions in the JTAG state machine.
 RESET     	{ RESET,	IDLE },
 IDLE      	{ DRSELECT,	IDLE },
 DRSELECT  	{ IRSELECT,	DRCAPTURE },
 DRCAPTURE 	{ DREXIT1,	DRSHIFT },
 DRSHIFT   	{ DREXIT1,	DRSHIFT },
 DREXIT1   	{ DRUPDATE,	DRPAUSE },
 DRPAUSE   	{ DREXIT2,	DRPAUSE },
 DREXIT2   	{ DRUPDATE,	DRSHIFT },
 DRUPDATE  	{ DRSELECT,	IDLE },
 IRSELECT  	{ RESET,	IRCAPTURE },
 IRCAPTURE 	{ IREXIT1,	IRSHIFT },
 IRSHIFT   	{ IREXIT1,	IRSHIFT },
 IREXIT1   	{ IRUPDATE,	IRPAUSE },
 IRPAUSE   	{ IREXIT2,	IRPAUSE },
 IREXIT2   	{ IRUPDATE,	IRSHIFT },
 IRUPDATE  	{ DRSELECT,	IDLE }
  This table contains the TMS value to be used to take the NEXT STEP on
  the path to the desired state.  The array index is the current state,
  and the bit position is the desired endstate.  To find out which state
  is used as the intermediate state, look up the TMS value in the
  altera_transitions[] table.
 RST	RTI	SDRS	CDR	SDR	E1DR	PDR	E2DR 
 UDR	SIRS	CIR	SIR	E1IR	PIR	E2IR	UIR 
 Flag bits for alt_jtag_io() function 
 initial JTAG state is unknown 
 initialize to default state 
 Go to Test Logic Reset (no matter what the starting state may be) 
 Now step to Run Test  Idle 
 initialize JTAG chain to known state 
		
		  We are already in the desired state.
		  If it is a stable state, loop here.
		  Otherwise do nothing (no clock cycles).
 Get TMS value to take a step toward desired state 
 Take a step 
		
		  Set TMS high to loop in RESET state
		  Set TMS low to loop in any other stable state
  Causes JTAG hardware to sit in the specified stable
  state for the specified duration of real time.  If
  no JTAG operations have been performed yet, then only
  a delay is performed.  This permits the WAIT USECS
  statement to be used in VECTOR programs without causing
  any JTAG operations.
  Returns 0 for success, else appropriate error code.
 Wait for specified time interval 
  Copies preamble data, target data, and postamble data
  into one buffer for IR or DR scans.
 First go to DRSHIFT state 
 IDLE 
 DRSELECT 
 DRCAPTURE 
 DRSHIFT 
 DRPAUSE 
 DREXIT2 
 DRUPDATE 
 DRSELECT 
 DRCAPTURE 
 DRSHIFT 
 IRPAUSE 
 IREXIT2 
 IRUPDATE 
 DRSELECT 
 DRCAPTURE 
 DRSHIFT 
 loop in the SHIFT-DR state 
 DRPAUSE 
 First go to IRSHIFT state 
 IDLE 
 DRSELECT 
 IRSELECT 
 IRCAPTURE 
 IRSHIFT 
 DRPAUSE 
 DREXIT2 
 DRUPDATE 
 DRSELECT 
 IRSELECT 
 IRCAPTURE 
 IRSHIFT 
 IRPAUSE 
 IREXIT2 
 IRUPDATE 
 DRSELECT 
 IRSELECT 
 IRCAPTURE 
 IRSHIFT 
 loop in the SHIFT-IR state 
 IRPAUSE 
  Copies target data from scan buffer, filtering out
  preamble and postamble data.
 Shifts data into instruction register 
		
		  Copy preamble data, IR data,
		  and postamble data into a buffer
 Do the IRSCAN 
 alt_jtag_irscan() always ends in IRPAUSE state 
 Shifts data into instruction register, capturing output data 
		
		  Copy preamble data, IR data,
		  and postamble data into a buffer
 Do the IRSCAN 
 alt_jtag_irscan() always ends in IRPAUSE state 
 Now extract the returned data from the buffer 
 Shifts data into data register (ignoring output data) 
		
		  Copy preamble data, DR data,
		  and postamble data into a buffer
 Do the DRSCAN 
 alt_jtag_drscan() always ends in DRPAUSE state 
 Shifts data into data register, capturing output data 
		
		  Copy preamble data, DR data,
		  and postamble data into a buffer
 Do the DRSCAN 
 alt_jtag_drscan() always ends in DRPAUSE state 
 Now extract the returned data from the buffer 
 If the JTAG interface was used, reset it to TLR 
 SPDX-License-Identifier: GPL-2.0-or-later
  altera-comp.c
  altera FPGA driver
  Copyright (C) Altera Corporation 1998-2001
  Copyright (C) 2010 NetUP Inc.
  Copyright (C) 2010 Igor M. Liplianin <liplianin@netup.ru>
 Look for the highest non-zero bit position 
 Read number of bytes in data. 
 A 0 bit indicates literal data. 
 A 1 bit indicates offsetlength to follow. 
 SPDX-License-Identifier: GPL-2.0-or-later
  altera.c
  altera FPGA driver
  Copyright (C) Altera Corporation 1998-2001
  Copyright (C) 2010,2011 NetUP Inc.
  Copyright (C) 2010,2011 Igor M. Liplianin <liplianin@netup.ru>
 This function checks if enough parameters are available on the stack. 
 Read header information 
		
		  use bit 7 of attribute byte to indicate that
		  this buffer was dynamically allocated
		  and should be freed later
		
		  Attribute bits:
		  bit 0: 0 = read-only, 1 = read-write
		  bit 1: 0 = not compressed, 1 = compressed
		  bit 2: 0 = not initialized, 1 = initialized
		  bit 3: 0 = scalar, 1 = array
		  bit 4: 0 = Boolean, 1 = integer
		  bit 5: 0 = declared variable,
		 	1 = compiler created temporary variable
 initialized scalar variable 
 initialized compressed Boolean array 
 allocate a buffer for the uncompressed data 
 set flag so buffer will be freed later 
 uncompress the data 
 decompression failed 
 initialized Boolean array 
 initialized integer array 
 uninitialized array 
 flag attrs so that memory is freed 
 integer array 
 Boolean array 
 zero out memory 
	
	  For JBC version 2, we will execute the procedures corresponding to
	  the selected ACTION
 check procedure attribute byte 
				
				  BIT0 - OPTIONAL
				  BIT1 - RECOMMENDED
				  BIT6 - FORCED OFF
				  BIT7 - FORCED ON
			
			  Set current_proc to the first procedure
			  to be executed
 there are no procedures to execute! 
				
				  We completed one of the main procedures
				  of an ACTION.
				  Find the next procedure
				  to be executed and jump to it.
				  If there are no more procedures, then EXIT.
 no procedures to execute! 
 success 
			
			  Array short compare
			  ...stack 0 is source 1 value
			  ...stack 1 is source 2 value
			  ...stack 2 is mask value
			  ...stack 3 is count
			
			  PRINT add integer
			  ...stack 0 is integer value
 PRINT finish 
			
			  DRSCAN short
			  ...stack 0 is scan data
			  ...stack 1 is count
			
			  DRSCAN short with capture
			  ...stack 0 is scan data
			  ...stack 1 is count
			
			  IRSCAN short
			  ...stack 0 is scan data
			  ...stack 1 is count
			
			  IRSCAN short with capture
			  ...stack 0 is scan data
			  ...stack 1 is count
			
			  DRPRE with literal data
			  ...stack 0 is count
			  ...stack 1 is literal data
			
			  DRPOST
			  ...stack 0 is count
			
			  DRPOST with literal data
			  ...stack 0 is count
			  ...stack 1 is literal data
			
			  IRPRE with literal data
			  ...stack 0 is count
			  ...stack 1 is literal data
			
			  IRPOST
			  ...stack 0 is count
			
			  IRPOST with literal data
			  ...stack 0 is count
			  ...stack 1 is literal data
					
					  character code out of range
					  instead of flagging an error,
					  force the value to 127
			
			  Batch operation 0
			  SWP
			  SWPN 7
			  SWP
			  SWPN 6
			  DUPN 8
			  SWPN 2
			  SWP
			  DUPN 6
			  DUPN 6
 SWP  
 SWPN 7 
 SWP  
 SWPN 6 
 DUPN 8 
 SWPN 2 
 SWP  
 DUPN 6 
 DUPN 6 
			
			  Process FOR  NEXT loop
			  ...argument 0 is variable ID
			  ...stack 0 is step value
			  ...stack 1 is end value
			  ...stack 2 is top address
			
			  PRINT add string
			  ...argument 0 is string ID
			
			  STATE intermediate state
			  ...argument 0 is state code
			
			  STATE final state
			  ...argument 0 is state code
			
			  IRSTOP state
			  ...argument 0 is state code
			
			  DRSTOP state
			  ...argument 0 is state code
			
			  Exchange top with Nth stack value
			  ...argument 0 is 0-based stack entry
			  to swap with top element
			
			  Duplicate Nth stack value
			  ...argument 0 is 0-based stack entry to duplicate
			
			  Pop stack into scalar variable
			  ...argument 0 is variable ID
			  ...stack 0 is value
			
			  Pop stack into integer array element
			  ...argument 0 is variable ID
			  ...stack 0 is array index
			  ...stack 1 is value
			
			  If variable is read-only,
			  convert to writable array
 Allocate a writable buffer for this array 
 copy previous contents into buffer 
				
				  set bit 7 - buffer was
				  dynamically allocated
 clear bit 2 - variable is writable 
 check that variable is a writable integer array 
 pop the array index 
 pop the value and store it into the array 
			
			  Pop stack into Boolean array
			  ...argument 0 is variable ID
			  ...stack 0 is count
			  ...stack 1 is array index
			  ...stack 2 is value
			
			  If variable is read-only,
			  convert to writable array
 Allocate a writable buffer for this array 
 zero the buffer 
 copy previous contents into buffer 
				
				  set bit 7 - buffer was
				  dynamically allocated
 clear bit 2 - variable is writable 
			
			  check that variable is
			  a writable Boolean array
 pop the count (number of bits to copy) 
 pop the array index 
				
				  stack 0 = array right index
				  stack 1 = array left index
 reverse POPA is not supported 
 pop the data 
			
			  Pop stack and branch if zero
			  ...argument 0 is address
			  ...stack 0 is condition value
			
			  DRSCAN
			  IRSCAN
			  ...argument 0 is scan data variable ID
			  ...stack 0 is array index
			  ...stack 1 is count
				
				  stack 0 = array right index
				  stack 1 = array left index
				  stack 2 = count
				
				  allocate a buffer
				  and reverse the data order
 DS 
 IS 
			
			  DRPRE with array data
			  ...argument 0 is variable ID
			  ...stack 0 is array index
			  ...stack 1 is count
				
				  stack 0 = array right index
				  stack 1 = array left index
			
			  DRPOST with array data
			  ...argument 0 is variable ID
			  ...stack 0 is array index
			  ...stack 1 is count
				
				  stack 0 = array right index
				  stack 1 = array left index
			
			  IRPRE with array data
			  ...argument 0 is variable ID
			  ...stack 0 is array index
			  ...stack 1 is count
				
				  stack 0 = array right index
				  stack 1 = array left index
			
			  IRPOST with array data
			  ...argument 0 is variable ID
			  ...stack 0 is array index
			  ...stack 1 is count
				
				  stack 0 = array right index
				  stack 1 = array left index
			
			  EXPORT
			  ...argument 0 is string ID
			  ...stack 0 is integer expression
			
			  Push integer array element
			  ...argument 0 is variable ID
			  ...stack 0 is array index
 check variable type 
 writable integer array 
 read-only integer array 
			
			  Push Boolean array
			  ...argument 0 is variable ID
			  ...stack 0 is count
			  ...stack 1 is array index
 check that variable is a Boolean array 
 pop the count (number of bits to copy) 
 pop the array index 
				
				  stack 0 = array right index
				  stack 1 = array left index
			
			  Dynamically change size of array
			  ...argument 0 is variable ID
			  ...stack 0 is new size
 allocate integer array 
 allocate Boolean array 
				
				  If the buffer was previously allocated,
				  free it
				
				  Allocate a new buffer
				  of the requested size
				
				  Set the attribute bit to indicate that
				  this buffer was dynamically allocated and
				  should be freed later
 zero out memory 
			
			  Export Boolean array
			  ...argument 0 is string ID
			  ...stack 0 is variable ID
			  ...stack 1 is array right index
			  ...stack 2 is array left index
 EXPV is not supported in JBC 1.0 
 right indx 
 left indx 
 reverse indices not supported 
 free allocated buffer 
			
			  Array copy
			  ...argument 0 is dest ID
			  ...argument 1 is source ID
			  ...stack 0 is count
			  ...stack 1 is dest index
			  ...stack 2 is source index
				
				  stack 0 = source right index
				  stack 1 = source left index
				  stack 2 = destination right index
				  stack 3 = destination left index
 copy_index = source start index 
 source start index 
 destination start index 
					
					  If either the source or destination
					  is reversed, we can't tolerate
					  a length mismatch, because we
					  "left justify" arrays when copying.
					  This won't work correctly
					  with reversed arrays.
			
			  If destination is a read-only array,
			  allocate a buffer and convert it to a writable array
 Allocate a writable buffer for this array 
 zero the buffer 
 copy previous contents into buffer 
				
 clear bit 2 - variable is writable 
 check if destination is a writable Boolean array 
			
			  DRSCAN with capture
			  IRSCAN with capture
			  ...argument 0 is scan data variable ID
			  ...argument 1 is capture variable ID
			  ...stack 0 is capture index
			  ...stack 1 is scan data index
			  ...stack 2 is count
				
				  stack 0 = capture right index
				  stack 1 = capture left index
				  stack 2 = scan right index
				  stack 3 = scan left index
				  stack 4 = count
			
			  If capture array is read-only, allocate a buffer
			  and convert it to a writable array
 Allocate a writable buffer for this array 
 zero the buffer 
 copy previous contents into buffer 
				
				  set bit 7 - buffer was
				  dynamically allocated
 clear bit 2 - variable is writable 
			
			  check that capture array
			  is a writable Boolean array
 DSC 
 ISC 
			
			  WAIT
			  ...argument 0 is wait state
			  ...argument 1 is end state
			  ...stack 0 is cycles
			  ...stack 1 is microseconds
 throw away MAX cycles 
 throw away MAX microseconds 
			
			  Array compare
			  ...argument 0 is source 1 ID
			  ...argument 1 is source 2 ID
			  ...argument 2 is mask ID
			  ...stack 0 is source 1 index
			  ...stack 1 is source 2 index
			  ...stack 2 is mask index
			  ...stack 3 is count
				
				  stack 0 = source 1 right index
				  stack 1 = source 1 left index
				  stack 2 = source 2 right index
				  stack 3 = source 2 left index
				  stack 4 = mask right index
				  stack 5 = mask left index
 source 1 count 
 source 2 count 
 mask count 
 source 2 start index 
 mask start index 
 failure 
 Unrecognized opcode -- ERROR! 
 Free all dynamically allocated arrays 
  Gets key and value of NOTE fields in the JBC file.
  Can be called in two modes:  if offset pointer is NULL,
  then the function searches for note fields which match
  the key string provided.  If offset is not NULL, then
  the function finds the next note field of any key,
  starting at the offset specified by the offset pointer.
  Returns 0 for success, else appropriate error code
 Read header information 
		
		  We will search for the first note with a specific key,
		  and return only the value
		
		  We will search for the next note, regardless of the key,
		  and return both the value and the key
 Read header information 
 add record to end of linked list 
 SPDX-License-Identifier: GPL-2.0-or-later
  altera-lpt.c
  altera FPGA driver
  Copyright (C) Altera Corporation 1998-2001
  Copyright (C) 2010 NetUP Inc.
  Copyright (C) 2010 Abylay Ospan <aospan@netup.ru>
 SPDX-License-Identifier: GPL-2.0-only
  SpanDSP - a series of DSP components for telephony
  echo.c - A line echo canceller.  This code is being developed
           against and partially complies with G168.
  Written by Steve Underwood <steveu@coppice.org>
          and David Rowe <david_at_rowetel_dot_com>
  Copyright (C) 2001, 2003 Steve Underwood, 2007 David Rowe
  Based on a bit from here, a bit from there, eye of toad, ear of
  bat, 15 years of failed attempts by David and a few fried brain
  cells.
  All rights reserved.
! \file 
 Implementation Notes
   David Rowe
   April 2007
   This code started life as Steve's NLMS algorithm with a tap
   rotation algorithm to handle divergence during double talk.  I
   added a Geigel Double Talk Detector (DTD) [2] and performed some
   G168 tests.  However I had trouble meeting the G168 requirements,
   especially for double talk - there were always cases where my DTD
   failed, for example where near end speech was under the 6dB
   threshold required for declaring double talk.
   So I tried a two path algorithm [1], which has so far given better
   results.  The original tap rotationGeigel algorithm is available
   in SVN http:svn.rowetel.comsoftwareoslectagsbefore_16bit.
   It's probably possible to make it work if some one wants to put some
   serious work into it.
   At present no special treatment is provided for tones, which
   generally cause NLMS algorithms to diverge.  Initial runs of a
   subset of the G168 tests for tones (e.g .echo_test 6) show the
   current algorithm is passing OK, which is kind of surprising.  The
   full set of tests needs to be performed to confirm this result.
   One other interesting change is that I have managed to get the NLMS
   code to work with 16 bit coefficients, rather than the original 32
   bit coefficents.  This reduces the MIPs and storage required.
   I evaulated the 16 bit port using g168_tests.sh and listening tests
   on 4 real-world samples.
   I also attempted the implementation of a block based NLMS update
   [2] but although this passes g168_tests.sh it didn't converge well
   on the real-world samples.  I have no idea why, perhaps a scaling
   problem.  The block based code is also available in SVN
   http:svn.rowetel.comsoftwareoslectagsbefore_16bit.  If this
   code can be debugged, it will lead to further reduction in MIPS, as
   the block update code maps nicely onto DSP instruction sets (it's a
   dot product) compared to the current sample-by-sample update.
   Steve also has some nice notes on echo cancellers in echo.h
   References:
   [1] Ochiai, Areseki, and Ogihara, "Echo Canceller with Two Echo
       Path Models", IEEE Transactions on communications, COM-25,
       No. 6, June
       1977.
       https:www.rowetel.comimagesechodual_path_paper.pdf
   [2] The classic, very useful paper that tells you how to
       actually build a real world echo canceller:
	 Messerschmitt, Hedberg, Cole, Haoui, Winship, "Digital Voice
	 Echo Canceller with a TMS320020,
	 https:www.rowetel.comimagesechospra129.pdf
   [3] I have written a series of blog posts on this work, here is
       Part 1: http:www.rowetel.comblog?p=18
   [4] The source code http:svn.rowetel.comsoftwareoslec
   [5] A nice reference on LMS filters:
	 https:en.wikipedia.orgwikiLeast_mean_squares_filter
   Credits:
   Thanks to Steve Underwood, Jean-Marc Valin, and Ramakrishnan
   Muthukrishnan for their suggestions and email discussions.  Thanks
   also to those people who collected echo samples for me such as
   Mark, Pawel, and Pavel.
 600 samples, or 75ms     
 log2() of DC filter Beta 
 adapting coeffs using the traditional stochastic descent (N)LMS algorithm 
 Update the FIR taps 
 Dual Path Echo Canceller 
	
	  Input scaling was found be required to prevent problems when tx
	  starts clipping.  Another possible way to handle this would be the
	  filter coefficent scaling.
	
	  Filter DC, 3dB point is 160Hz (I think), note 32 bit precision
	  required otherwise values do not track down to 0. Zero at DC, Pole
	  at (1-Beta) on real axis.  Some chip sets (like Si labs) don't
	  need this, but something like a $10 X100P card does.  Any DC really
	  slows down convergence.
	 
	  Note: removes some low frequency from the signal, this reduces the
	  speech quality when listening to samples through headphones but may
	  not be obvious through a telephone handset.
	 
	  Note that the 3dB frequency in radians is approx Beta, e.g. for Beta
	  = 2^(-3) = 0.125, 3dB freq is 0.125 rads = 159Hz.
		
		  Make sure the gain of the HPF is 1.0. This can still
		  saturate a little under impulse conditions, and it might
		  roll to 32768 and need clipping on sustained peak level
		  signals. However, the scale of such clipping is small, and
		  the error due to any saturation should not markedly affect
		  the downstream processing.
		
		  hard limit filter to prevent clipping.  Note that at this
		  stage rx should be limited to +- 16383 due to right shift
		  above
	 Block average of power in the filter states.  Used for
		 efficient "out with the old and in with the new" algorithm so
		   we don't have to recalculate over the whole block of
 Calculate short term average levels using simple single pole IIRs 
 Foreground filter 
 Background filter 
 Background Filter adaption 
	 Almost always adap bg filter, just simple DT and energy
	   detection to minimise adaption in cases of strong double talk.
	   However this is not critical for the dual path algorithm.
		 Determine:
		   f = Beta  clean_bg_rxP ------ (1)
		   where P is the total power in the filter states.
		   The Boffins have shown that if we obey (1) we converge
		   quickly and avoid instability.
		   The correct factor f must be in Q30, as this is the fixed
		   point format required by the lms_adapt_bg() function,
		   therefore the scaled version of (1) is:
		   (2^30)  f  = (2^30)  Beta  clean_bg_rxP
		   factor      = (2^30)  Beta  clean_bg_rxP     ----- (2)
		   We have chosen Beta = 0.25 by experiment, so:
		   factor      = (2^30)  (2^-2)  clean_bg_rxP
		   (30 - 2 - log2(P))
		   factor      = clean_bg_rx 2                     ----- (3)
		   To avoid a divide we approximate log2(P) as top_bit(P),
		   which returns the position of the highest non-zero bit in
		   P.  This approximation introduces an error as large as a
		   factor of 2, but the algorithm seems to handle it OK.
		   Come to think of it a divide may not be a big deal on a
		   modern DSP, so its probably worth checking out the cycles
		   for a divide versus a top_bit() implementation.
	 very simple DTD to make sure we dont try and adapt with strong
 Transfer logic 
	 These conditions are from the dual path paper [1], I messed with
 (ec->Lclean_bg < 0.875ec->Lclean) 
 (ec->Lclean_bg < 0.125ec->Ltx) 
			
			  BG filter has had better results for 6 consecutive
			  samples
 Non-Linear Processing 
		
		  Non-linear processor - a fancy way to say "zap small
		  signals, to avoid residual echo due to (uLawALaw)
		  non-linearity in the channel.".
			
			  Our ec has improved echo by at least 24 dB (each
			  factor of 2 is 6dB, so 2222=16 is the same as
			  6+6+6+6=24dB)
				
				  Very elementary comfort noise generation.
				  Just random numbers rolled off very vaguely
				  Hoth-like.  DR: This noise doesn't sound
				  quite right to me - I suspect there are some
				  overflow issues in the filtering as it's too
				  "crackly".
				  TODO: debug this, maybe just play noise at
				  high level or look at spectrum.
 This sounds much better than CNG 
				
				  just mute the residual, doesn't sound very
				  good, used mainly in G168 tests
			
			  Background noise estimator.  I tried a few
			  algorithms here without much luck.  This very simple
			  one seems to work best, we just average the level
			  using a slow (1 sec time const) filter if the
			  current level is less than a (experimentally
			  derived) constant.  This means we dont include high
			  level signals like near end speech.  When combined
			  with CNG or especially CLIP seems to work OK.
 Roll around the taps buffer 
 Output scaled back up again to match input scaling 
 This function is separated from the echo canceller is it is usually called
   as part of the tx process.  See rx HP (DC blocking) filter above, it's
   the same design.
   Some soft phones send speech signals with a lot of low frequency
   energy, e.g. down to 20Hz.  This can make the hybrid non-linear
   which causes the echo canceller to fall over.  This filter can help
   by removing any low frequency before it gets to the tx port of the
   hybrid.
   It can also help by removing and DC in the tx signal.  DC is bad
   for LMS algorithms.
   This is one of the classic DC removal filters, adjusted to provide
   sufficient bass rolloff to meet the above requirement to protect hybrids
   from things that upset them. The difference between successive samples
   produces a lousy HPF, and then a suitably placed pole flattens things out.
   The final result is a nicely rolled off bass end. The filtering is
   implemented with extended fractional precision, which noise shapes things,
   giving very clean DC removal.
		
		  Make sure the gain of the HPF is 1.0. The first can still
		  saturate a little under impulse conditions, and it might
		  roll to 32768 and need clipping on sustained peak level
		  signals. However, the scale of such clipping is small, and
		  the error due to any saturation should not markedly affect
		  the downstream processing.
 SPDX-License-Identifier: GPL-2.0-or-later
  IBM ASM Service Processor Device Driver
  Copyright (C) IBM Corporation, 2004
  Author: Max Asb√∂ck <amax@us.ibm.com>
	 read the uart scratch register to determine if the UART
	  is dedicated to the service processor or if the OS can use it
 SPDX-License-Identifier: GPL-2.0-or-later
  IBM ASM Service Processor Device Driver
  Copyright (C) IBM Corporation, 2004
  Author: Max Asb√∂ck <amax@us.ibm.com>
 SPDX-License-Identifier: GPL-2.0-or-later
  IBM ASM Service Processor Device Driver
  Copyright (C) IBM Corporation, 2004
  Author: Max Asb√∂ck <amax@us.ibm.com>
  Dispatch an incoming message to the specific handler for the message.
  Called from interrupt context.
  send the 4.3.5.10 dot command (driver VPD) to the service processor
  send the 4.3.6 dot command (os state) to the service processor
  During driver init this function is called with os state "up".
  This causes the service processor to start sending heartbeats the
  driver.
  During driver exit the function is called with os state "down",
  causing the service processor to stop the heartbeats.
 SPDX-License-Identifier: GPL-2.0-or-later
  IBM ASM Service Processor Device Driver
  Copyright (C) IBM Corporation, 2004
  Author: Max Asb√∂ck <amax@us.ibm.com>
  Parts of this code are based on an article by Jonathan Corbet
  that appeared in Linux Weekly News.
  The IBMASM file virtual filesystem. It creates the following hierarchy
  dynamically when mounted from user space:
     ibmasm
     |-- 0
     |   |-- command
     |   |-- event
     |   |-- reverse_heartbeat
     |   `-- remote_video
     |       |-- depth
     |       |-- height
     |       `-- width
     .
     .
     .
     `-- n
         |-- command
         |-- event
         |-- reverse_heartbeat
         `-- remote_video
             |-- depth
             |-- height
             `-- width
  For each service processor the following files are created:
  command: execute dot commands
 	write: execute a dot command on the service processor
 	read: return the result of a previously executed dot command
  events: listen for service processor events
 	read: sleep (interruptible) until an event occurs
       write: wakeup sleeping event listener
  reverse_heartbeat: send a heartbeat to the service processor
 	read: sleep (interruptible) until the reverse heartbeat fails
       write: wakeup sleeping heartbeat listener
  remote_videowidth
  remote_videoheight
  remote_videowidth: control remote display settings
 	write: set value
 	read: read value
 struct to save state between command file operations 
 struct to save state between event file operations 
 struct to save state between reverse heartbeat file operations 
 commands are executed sequentially, only one command at a time 
 allow only one reverse heartbeat per process 
 SPDX-License-Identifier: GPL-2.0-or-later
  IBM ASM Service Processor Device Driver
  Copyright (C) IBM Corporation, 2004
  Authors: Max Asb√∂ck <amax@us.ibm.com>
           Vernon Mauery <vernux@us.ibm.com>
 Remote mouse and keyboard event handling functions 
 set up the mouse input device 
 so we don't try to free it again below 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) IBM Corporation, 2004
  Author: Max Asb√∂ck <amax@us.ibm.com>
  Reverse Heartbeat, i.e. heartbeats sent from the driver to the
  service processor.
  These heartbeats are initiated by user level programs.
 the reverse heartbeat dot command 
  start_reverse_heartbeat
  Loop forever, sending a reverse heartbeat dot command to the service
  processor, then sleeping. The loop comes to an end if the service
  processor fails to respond 3 times or we were interrupted.
 SPDX-License-Identifier: GPL-2.0-or-later
  IBM ASM Service Processor Device Driver
  Copyright (C) IBM Corporation, 2004
  Author: Max Asb√∂ck <amax@us.ibm.com>
  ASM service processor event handling routines.
  Events are signalled to the device drivers through interrupts.
  They have the format of dot commands, with the type field set to
  sp_event.
  The driver does not interpret the events, it simply stores them in a
  circular buffer.
  receive_event
  Called by the interrupt handler when a dot command of type sp_event is
  received.
  Store the event in the circular event buffer, wake up any sleeping
  event readers.
  There is no reader marker in the buffer, therefore readers are
  responsible for keeping up with the writer, or they will lose events.
 copy the event into the next slot in the circular buffer 
 advance indices in the buffer 
  get_next_event
  Called by event readers (initiated from user space through the file
  system).
  Sleeps until a new event is available.
 SPDX-License-Identifier: GPL-2.0-or-later
  IBM ASM Service Processor Device Driver
  Copyright (C) IBM Corporation, 2004
  Author: Max Asb√∂ck <amax@us.ibm.com>
  This driver is based on code originally written by Pete Reynolds
  and others.
  The ASM device driver does the following things:
  1) When loaded it sends a message to the service processor,
  indicating that an OS is  running. This causes the service processor
  to send periodic heartbeats to the OS.
  2) Answers the periodic heartbeats sent by the service processor.
  Failure to do so would result in system reboot.
  3) Acts as a pass through for dot commands sent from user applications.
  The interface for this is the ibmasmfs file system.
  4) Allows user applications to register for event notification. Events
  are sent to the driver through interrupts. They can be read from user
  space through the ibmasmfs file system.
  5) Allows user space applications to send heartbeats to the service
  processor (aka reverse heartbeats). Again this happens through ibmasmfs.
  6) Handles remote mouse and keyboard event interrupts and makes them
  available to user applications through ibmasmfs.
 vnc client won't work without bus-mastering 
 SPDX-License-Identifier: GPL-2.0-or-later
  IBM ASM Service Processor Device Driver
  Copyright (C) IBM Corporation, 2004
  Author: Max Asb√∂ck <amax@us.ibm.com>
  Once the driver indicates to the service processor that it is running
  - see send_os_state() - the service processor sends periodic heartbeats
  to the driver. The driver must respond to the heartbeats or else the OS
  will be rebooted.
  In the case of a panic the interrupt handler continues to work and thus
  continues to respond to heartbeats, making the service processor believe
  the OS is still running and thus preventing a reboot.
  To prevent this from happening a callback is added the panic_notifier_list.
  Before responding to a heartbeat the driver checks if a panic has happened,
  if yes it suspends heartbeat, causing the service processor to reboot as
  expected.
 return the received dot command to sender 
 SPDX-License-Identifier: GPL-2.0-or-later
  IBM ASM Service Processor Device Driver
  Copyright (C) IBM Corporation, 2004
  Author: Max Asb√∂ck <amax@us.ibm.com>
  exec_command
  send a command to a service processor
  Commands are executed sequentially. One command (sp->current_command)
  is sent to the service processor. Once the interrupt handler gets a
  message of type command_response, the message is copied into
  the current commands buffer,
  Sleep until a command has failed or a response has been received
  and the command status been updated by the interrupt handler.
  (see receive_response).
  receive_command_response
  called by the interrupt handler when a dot command of type command_response
  was received.
 SPDX-License-Identifier: GPL-2.0-only
   Shared Transport driver
 	HCI-LL module responsible for TI proprietary HCI_LL protocol
   Copyright (C) 2009-2010 Texas Instruments
   Author: Pavan Savoy <pavan_savoy@ti.com>
 internal functions 
 sanity check 
 update state 
 communicate to platform about chip asleep 
 diff actions in diff states 
 send wake_ack 
 duplicate wake_ind 
 duplicate wake_ind 
 duplicate wake_ind 
 update state 
 communicate to platform about chip wakeup 
 functions invoked by ST Core 
 called when ST Core wants to
 called when ST Core local module wants to
 called when ST Core wants to update the state 
 WAKE_IND 
 don't send the duplicate wake_indication 
 called when ST Core wants the state 
 called from ST Core, when a PM related packet arrives 
 sleep ind 
 sleep ack 
 wake ind 
 wake ack 
 Called from ST CORE to initialize ST LL 
 set state to invalid 
 Called from ST CORE to de-initialize ST LL 
 SPDX-License-Identifier: GPL-2.0-only
   Shared Transport Line discipline driver Core
 	This hooks up ST KIM driver and ST LL driver
   Copyright (C) 2009-2010 Texas Instruments
   Author: Pavan Savoy <pavan_savoy@ti.com>
  function pointer pointing to either,
  st_kim_recv during registration to receive fw download responses
  st_int_recv after registration to receive proto stack responses
 list now has the channel id as index itself 
	st_gdata->list[proto->chnl_id] = NULL; 
  called from KIM during firmware download.
  This is a wrapper function to tty->ops->write_room.
  It returns number of free space available in
  uart tx buffer.
  can be called in from
  -- KIM (during fw download)
  -- ST Core (during st_write)
   This is the internal write function - a wrapper
   to tty->ops->write
  push the skb received to relevant
  protocol stacks
	
	  this cannot fail
	  this shouldn't take long
	  - should be just skb_queue_tail for the
	    protocol stack driver
  st_reg_complete - to call registration complete callbacks
  of all protocol stack drivers
  This function is being called with spin lock held, protocol drivers are
  only expected to complete their waits and do nothing more than that.
 cleanup registered protocol 
		
		  Received packet has only packet header and
		  has zero length payload. So, ask ST CORE to
		  forward the packet to protocol driver (BTFMGPS)
		
		  Received packet's payload length is larger.
		  We can't accommodate it in created skb.
		
		  Packet header has non-zero payload length and
		  we have enough space in created skb. Lets read
 Change ST state to continue to process next packet 
  st_wakeup_ack - internal function for action when wake-up ack
 	received
	
	  de-Q from waitQ and Q in txQ now that the
	  chip is awake
 state forwarded to ST LL 
 wake up to send the recently copied skbs from waitQ 
  st_int_recv - ST's internal receive function.
 	Decodes received RAW data and forwards to corresponding
 	client drivers (Bluetooth,FM,GPS..etc).
 	This can receive various types of packets,
 	HCI-Events, ACL, SCO, 4 types of HCI-LL PM packets
 	CH-8 packets from FM, CH-9 packets from GPS cores.
 tty_receive sent null ? 
 Decode received bytes here 
 Check ST RX state machine , where are we? 
 Waiting for complete packet ? 
				
				  Ask ST CORE to forward
				  the packet to protocol driver
 parse the header to know details 
 1 byte len field 
 end of switch rx_state 
 end of if rx_count 
		
		  Check first byte of packet and identify module
		  owner (BTFMGPS)
			
			  this takes appropriate action based on
			  sleep state received --
			
			  if WAKEUP_IND collides copy from waitq to txq
			  and assume chip awake
 wake up ack received 
 Unknow packet? 
			
			  Default case means non-HCILL packets,
			  possibilities are packets for:
			  (a) valid protocol -  Supported Protocols within
			      the ST_MAX_CHANNELS.
			  (b) registered protocol - Checked by
			      "st_gdata->list[type] == NULL)" are supported
			      protocols only.
			   Rules out any invalid protocol and
			   unregistered protocols with channel ID < 16.
 next 2 required for BT only 
pkt_type
incoming
  st_int_dequeue - internal de-Q function.
 	If the previous data set was not written
 	completely, return that skb which has the pending data.
 	In normal cases, return top of txq.
  st_int_enqueue - internal Q-ing function.
 	Will either Q the skb to txq or the tx_waitq
 	depending on the ST LL state.
 	If the chip is asleep, then Q it onto waitq and
 	wakeup the chip.
 	txq and waitq needs protection since the other contexts
 	may be sending data, waking up chip.
  internal wakeup function
  called from either
  - TTY layer when write's finished
  - st_write (in context of the protocol stack)
 for irq save flags 
 check for sending & set flag sending here 
 keep sending 
		 TX_WAKEUP will be checked in another
		  context
 come back if st_tx_wakeup is set 
 woke-up to write 
 enable wake-up from TTY 
 if skb->len = len as expected, skb->len=0 
 would be the next skb to be sent 
 if wake-up is set in another context- restart sending 
 clear flag sending 
 functions called from ST KIM
  functions called from protocol stack drivers
  to be EXPORT-ed
 can be from process context only 
 fw download in progress 
 enable the ST LL - to set default chip state 
 release lock previously held - re-locked below 
		
		  this may take a while to complete
		  since it involves BT fw download
		
		  this is where all pending registration
		  are signalled to be complete by calling callback functions
		
		  check for already registered once more,
		  since the above check is old
 if fw is already downloaded & new stack registers protocol 
 lock already held before entering else 
  to unregister a protocol -
  to be called from protocol stack driver
 stop traffic on tty 
 all chnl_ids now unregistered 
 disable ST LL 
  called in protocol stack drivers
  via the write function pointer
 st_ll to decide where to enqueue the skb 
 wake up 
 return number of bytes written 
 for protocols making use of shared transport 
  functions called from TTY layer
 don't do an wakeup for now 
	 mem already allocated
 Flush any pending characters in the driver and discipline. 
	
	  signal to UIM via KIM that -
	  installation of N_TI_WL ldisc is complete
	
	  TODO:
	  if a protocol has been registered & line discipline
	  un-installed for some reason - what should be done ?
	
	  signal to UIM via KIM that -
	  N_TI_WL ldisc is un-installed
 Flush any pending characters in the driver and discipline. 
 empty out txq and tx_waitq 
 reset the TTY Rx states of ST 
	
	  if fw download is in progress then route incoming data
	  to KIM for validation
  wake-up function called in from the TTY layer
  inside the internal wakeup function will be called
 don't do an wakeup for now 
	
	  schedule the internal wakeup instead of calling directly to
	  avoid lockup (port->lock needed in tty->ops->write is
	  already taken here
	 Initialize ST TxQ and Tx waitQ queue head. All BTFMGPS module skb's
	  will be pushed in this queue for actual transmission.
 Locking used in st_int_enqueue() to avoid multiple execution 
 internal module cleanup 
 Free ST Tx Qs and skbs 
 TTY ldisc cleanup 
 free the global data pointer 
 SPDX-License-Identifier: GPL-2.0-only
   Shared Transport Line discipline driver Core
 	Init Manager module responsible for GPIO control
 	and firmware download
   Copyright (C) 2009-2010 Texas Instruments
   Author: Pavan Savoy <pavan_savoy@ti.com>
 Imagine 1 on each UART for now 
 internal functions 
  st_get_plat_device -
 	function which returns the reference to the platform device
 	requested by id. As of now only 1 such device exists (id=0)
 	the context requesting for reference can get the id to be
 	requested by a. The protocol driver which is registering or
 	b. the tty device which is opened.
  validate_firmware_response -
 	function to return whether the firmware response was proper
 	in case of error don't complete so that waiting for proper
 	response times out
	
	  these magic numbers are the position in the response buffer which
	  allows us to distinguish whether the response is for the read
	  version info. command
 fw version response 
 keep waiting for the proper response 
 becos of all the script being downloaded 
  check for data len received inside kim_int_recv
  most often hit the last case to update state to waiting for data
		
		  Received packet's payload length is larger.
		  We can't accommodate it in created skb.
		
		  Packet header has non-zero payload length and
		  we have enough space in created skb. Lets read
	
	  Change ST LL state to continue to process next
	  packet
  kim_int_recv - receive function called during firmware download
 	firmware download responses on different UART drivers
 	have been observed to come in bursts of different
 	tty_receive and hence the logic
 Decode received bytes here 
 Check ST RX state machine , where are we? 
 Waiting for complete packet ? 
 Waiting for Bluetooth event header ? 
 end of switch 
 end of if rx_state 
 Bluetooth event packet? 
	
	  the positions 12 & 13 in the response buffer provide with the
	  chip, major & minor numbers
 to be accessed later via sysfs entry 
 warn user on not commenting these in firmware 
  download_firmware -
 	internal function which parses through the .bts firmware
 	script file intreprets SEND, DELAY actions only as of now
 40 char long bts scr name? 
	
	  bts_header to remove out magic number and
	  version
 action send 
				
				  ignore remote change
				  baud rate HCI VS command
			
			  Make sure we have enough free space in uart
			  tx buffer to write current firmware command
 wait 1ms before checking room 
 Timeout happened ? 
			
			  reinit completion before sending for the
			  relevant wait
			
			  Free space found in uart buffer, call st_int_write
			  to send current firmware command to the uart tx
			  buffer.
			
			  Check number of bytes written to the uart tx buffer
			  and requested command write size
 wait 
 timed out 
 sleep 
 fw download complete 
 functions called from ST core 
 called from ST Core, when REG_IN_PROGRESS (registration in progress)
  can be because of
  1. response to read local version
  2. during sendrecv's of firmware download
	
	  proceed to gather all data and distinguish read fw version response
	  from other fw responses when data gathering is complete
  to signal completion of line discipline installation
  called from ST Core, upon tty_open
  st_kim_start - called from ST Core upon 1st registration
 	This involves toggling the chip enable gpio, reading
 	the firmware version from chip, forming the fw file name
 	based on the chip version, requesting the fw, parsing it
 	and perform download(sendrecv).
 platform specific enabling code here 
 Configure BT nShutdown to HIGH state 
 FIXME: a proper toggle 
 re-initialize the completion 
 send notification to UIM 
 wait for ldisc to be installed 
			
			  ldisc installation timeout,
			  flush uart, power cycle BT_EN
 ldisc installed now 
				
				  ldisc installed but fw download failed,
				  flush uart & power cycle BT_EN
 on success don't retry 
  st_kim_stop - stop communication with chip.
 	This can be called from ST CoreKIM, on the-
 	(a) last un-register when chip need not be powered there-after,
 	(b) upon failure to either install ldisc or download firmware.
 	The function is responsible to (a) notify UIM about un-installation,
 	(b) flush UART if the ldisc was installed.
 	(c) reset BT_EN - pull down nshutdown at the end.
 	(d) invoke platform's chip disabling routine.
 can be called before ldisc is installed 
 Flush any pending characters in the driver and discipline. 
 send uninstall notification to UIM 
 wait for ldisc to be un-installed 
 timeout 
 By default configure BT nShutdown to LOW state 
 platform specific disable 
 functions called from subsystems 
 called when debugfs entry is read from 
 if DEBUG 
 structures specific for sysfs entries 
 TODO: move this to debug-fs if possible 
 TODO: move to debugfs 
  st_kim_ref - reference the core's data
 	This references the per-ST platform device in the archxx
 	board-xx.c file.
 	This would enable multiple such platform devices to exist
 	on a given platform
 get kim_gdata reference from platform device 
 functions called from platform device driver subsystem
  need to have a relevant platform device entry in the platform's
  board-.c file
 multiple devices could exist 
 platform's sure about existence of 1 device 
 refer to itself 
 Claim the chip enable nShutdown gpio from the system 
 Configure nShutdown GPIO as output=0 
 get reference of pdev for request_firmware 
 copying platform data 
 free the GPIOs requested 
	
	  Free the BluetoothFMGPIO
	  nShutdown gpio from the system
 entry point for ST KIM module, called in from ST Core 
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2017 IBM Corp.
	
	  Keep a reference on the AFU to make sure it's valid for the
	  duration of the life of the context
  Callback for when a translation fault triggers an error
  data:	a pointer to the context which triggered the fault
  addr:	the address that triggered the error
  dsisr:	the value of the PPC64 dsisr register
 Locks both status & tidr
 only one page 
 check offset validty 
	
	  trigger page should only be accessible in write mode.
	 
	  It's a bit theoretical, as a page mmaped with only
	  PROT_WRITE is currently readable, but it doesn't hurt.
		
		  If we timeout waiting for the AFU to terminate the
		  pasid, then it's dangerous to clean up the Process
		  Element entry in the SPA, as it may be referenced
		  in the future by the AFU. In which case, we would
		  checkstop because of an invalid PE access (FIR
		  register 2, bit 42). So leave the PE
		  defined. Caller shouldn't free the context so that
		  PASID remains allocated.
		 
		  A link reset will be required to cleanup the AFU
		  and the SPA.
		
		  We are force detaching - remove any active mmio
		  mappings so userspace cannot interfere with the
		  card if it comes back.  Easiest way to exercise
		  this is to unbind and rebind the driver via sysfs
		  while it is in use.
 reference to the AFU taken in ocxl_context_alloc() 
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2019 IBM Corp.
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2019 IBM Corp.
  Any opencapi device which wants to use this 'generic' driver should
  use the 0x062B device ID. Vendors should define the subsystem
  vendordevice ID to help differentiate devices.
 Cleanup handled within ocxl_file_register_afu()
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2017 IBM Corp.
 Total to reserve 
 Make sure reserved fields are not set for forward compatibility 
 Locks both status & tidr
  Are there any events pending on the AFU
  ctx: The AFU context
  Returns: true if there are events pending
  Populate the supplied buffer with a single XSL error
  ctx:	The AFU context to report the error from
  header: the event header to populate
  buf: The buffer to write the body into (should be at least
       AFU_EVENT_BODY_XSL_ERROR_SIZE)
  Return: the amount of buffer that was populated
  Reports events on the AFU
  Format:
 	Header (struct ocxl_kernel_event_header)
 	Body (struct ocxl_kernel_event_)
 	Header...
 Require offset to be 0 
 Free the info struct
 safe to call even if register failed
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2017 IBM Corp.
 Fall through to unlock
 Just drop it on the ground
	
	  We limit the number of afu irqs per context and per link to
	  avoid a single process or user depleting the pool of IPIs
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2017 IBM Corp.
  get_function_0() - Find a related PCI device (function 0)
  @dev: PCI device to match
  Returns a pointer to the related device, or null if not found
		
		  PASID capability is not mandatory, but there
		  shouldn't be any AFU
	
	  vendor specific DVSEC, for IBM images only. Some older
	  images may not have it
	 
	  It's only used on function 0 to specify the version of some
	  logic blocks and to give access to special registers to
	  enable host-based flashing.
 Protect 'data valid' bit 
  read_template_version() - Read the template version from the AFU
  @dev: the device for the AFU
  @fn: the AFU offsets
  @len: outputs the template length
  @version: outputs the major<<8,minor version
  Returns 0 on success, negative on failure
 AFU index map can have holes, in which case we read all 0's 
 v0.5 was used prior to the spec approval
 play safe 
	
	  Global MMIO
	
	  Per-process MMIO
	
	  Permitted Characters : Alphanumeric, hyphen, underscore, comma
 digits  ||
 upper case  ||
 lower case  ||
 NULL  ||
 -  ||
 _  ||
 , )
  read_afu_lpc_memory_info() - Populate AFU metadata regarding LPC memory
  @dev: the device for the AFU
  @fn: the AFU offsets
  @afu: the AFU struct to populate the LPC metadata into
  Returns 0 on success, negative on failure
	
	  For AFUs following template v1.0, the LPC memory covers the
	  total memory. Its size is a power of 2.
	 
	  For AFUs with template >= v1.01, the total memory size is
	  still a power of 2, but it is split in 2 parts:
	  - the LPC memory, whose size can now be anything
	  - the remainder memory is a special purpose memory, whose
	    definition is AFU-dependent. It is not accessible through
	    the usual commands for LPC memory
 No LPC memory 
	
	  The configuration space spec allows for a memory size of up
	  to 2^255 bytes.
	 
	  Current generation hardware uses 56-bit physical addresses,
	  but we won't be able to get near close to that, as we won't
	  have a hole big enough in the memory map.  Let it pass in
	  the driver for now. We'll get an error from the firmware
	  when trying to configure something too big.
	
	  First, we need to write the AFU idx for the AFU we want to
	  access.
	
	  This is really a simple wrapper for the kernel API, to
	  avoid an external driver using ocxl as a library to call
	  platform-dependent code
	
	  Skip on function != 0, as the TL can only be defined on 0
	
	  The spec defines 64 templates for messages in the
	  Transaction Layer (TL).
	 
	  The host and device each support a subset, so we need to
	  configure the transmitters on each side to send only
	  templates the receiver understands, at a rate the receiver
	  can process.  Per the spec, template 0 must be supported by
	  everybody. That's the template which has been used by the
	  host and device so far.
	 
	  The sending rate limit must be set before the template is
	  enabled.
	
	  Device -> host
	
	  Host -> device
	
	  Opencapi commands needing to be retried are classified per
	  the TL in 2 groups: short and long commands.
	 
	  The short back off timer it not used for now. It will be
	  for opencapi 4.0.
	 
	  The long back off timer is typically used when an AFU hits
	  a page fault but the NPU is already processing one. So the
	  AFU needs to wait before it can resubmit. Having a value
	  too low doesn't break anything, but can generate extra
	  traffic on the link.
	  We set it to 1.6 us for now. It's shorter than, but in the
	  same order of magnitude as the time spent to process a page
	  fault.
 long timer = 1.6 us 
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2017 IBM Corp.
	
	  device_remove_bin_file is safe to call if the file is not added as
	  the files are removed by name, and early exit if not found
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2019 IBM Corp.
	
	  if there were not enough actags for the function, each afu
	  reduces its count as well
	
	  We only support the case where the function configuration
	  requested enough PASIDs to cover all AFUs.
	
	  Leave an empty page between the per-process mmio area and
	  the AFU interrupt mappings
 matches the implicit get in alloc_afu
 A function may not require any PASID 
	
	  Once it has been confirmed to work on our hardware, we
	  should reset the function, to force the adapter to restart
	  from scratch.
	  A function reset would also reset all its AFUs.
	 
	  Some hints for implementation:
	 
	  - there's not status bit to know when the reset is done. We
	    should try reading the config space to know when it's
	    done.
	  - probably something like:
	 	Reset
	 	wait 100ms
	 	issue config read
	 	allow device up to 1 sec to return success on config
	 	read before declaring it broken
	 
	  Some shared logic on the card (CFG, TLX) won't be reset, so
	  there's no guarantee that it will be enough.
 Device detection & initialisation
 AFU Metadata
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2017 IBM Corp.
 Each SPA is 4 Mb 
 Hashed page table (HPT) mode 
 Radix on HPT mode 
 Radix on Radix mode 
 Translation fault 
 Store operation 
 callback to trigger when a translation fault occurs 
 opaque pointer to be passed to the above callback 
 Maps PE handles to pe_data 
	
	  The following field are used by the memory fault
	  interrupt handler. We can only have one interrupt at a
	  time. The NPU won't raise another interrupt until the
	  previous one has been ack'd by writing to the TFC register
  A opencapi link can be used be by several PCI functions. We have
  one link per device slot.
  A linked list of opencapi links should suffice, as there's a
  limited number of opencapi slots on a system and lookup is only
  done when the device is probed
 ATSD register virtual address 
 to serialize shootdowns 
 continue is not supported 
	
	  We must release a reference on mm_users whenever exiting this
	  function (taken in the memory fault interrupt handler)
		
		  update_mmu_cache() will not have loaded the hash
		  since current->trap is not a 0x400 or 0x300, so
		  just call hash_page_mm() here.
	 We could be reading all null values here if the PE is being
	  removed while an interrupt kicks in. It's not supposed to
	  happen if the driver notified the AFU to terminate the
	  PASID, and the AFU waited for pending operations before
	  acknowledging. But even if it happens, we won't find a
	  memory context below and fail silently, so it should be ok.
		
		  Could only happen if the driver didn't notify the
		  AFU about PASID termination before removing the PE,
		  or the AFU didn't wait for all memory access to
		  have completed.
		 
		  Either way, we fail early, but we shouldn't log an
		  error message, as it is a valid (if unexpected)
		  scenario
		
		  translation fault from a kernel context - an OpenCAPI
		  device tried to access a bad kernel address
 mm_users count released by bottom half 
	
	  At some point, we'll need to look into allowing a higher
	  number of interrupts. Could we have an IRQ domain per link?
 platform specific hook 
	 if link->arva is not defeined, MMIO registers are not used to
	  generate TLB invalidate. PowerBus snooping is enabled.
	  Otherwise, PowerBus snooping is disabled. TLB Invalidates are
	  initiated using MMIO registers.
 The functions of a device all share the same link 
 call platform code before releasing data 
	
	  For user contexts, register a copro so that TLBIs are seen
	  by the nest MMU. If we have a kernel context, TLBIs are
	  already global.
			 Use MMIO registers for the TLB Invalidate
			  operations.
	
	  Barrier is to make sure PE is visible in the SPA before it
	  is used by the device. It also helps with the global TLBI
	  invalidation
	
	  The mm must stay valid for as long as the device uses it. We
	  lower the count when the context is removed from the SPA.
	 
	  We grab mm_count (and not mm_users), as we don't want to
	  end up in a circular dependency if a process mmaps its
	  mmio, therefore incrementing the file ref count when
	  calling mmap(), and forgets to unmap before exiting. In
	  that scenario, when the kernel handles the death of the
	  process, the file is not cleaned because unmap was not
	  called, and the mm wouldn't be freed because we would still
	  have a reference on mm_users. Incrementing mm_count solves
	  the problem.
	
	  The barrier makes sure the PE is updated
	  before we clear the NPU context cache below, so that the
	  old PE cannot be reloaded erroneously.
	
	  hook to platform code
	  On powerpc, the entry needs to be cleared from the context
	  cache of the NPU.
	
	  About synchronization with our memory fault handler:
	 
	  Before removing the PE, the driver is supposed to have
	  notified the AFU, which should have cleaned up and make
	  sure the PASID is no longer in use, including pending
	  interrupts. However, there's no way to be sure...
	 
	  We clear the PE and remove the context from our radix
	  tree. From that point on, any new interrupt for that
	  context will fail silently, which is ok. As mentioned
	  above, that's not expected, but it could happen if the
	  driver or AFU didn't do the right thing.
	 
	  There could still be a bottom half running, but we don't
	  need to waitflush, as it is managing a reference count on
	  the mm it reads from the radix tree.
	
	  The barrier makes sure the PE is removed from the SPA
	  before we clear the NPU context cache below, so that the
	  old PE cannot be reloaded erroneously.
	
	  hook to platform code
	  On powerpc, the entry needs to be cleared from the context
	  cache of the NPU.
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2017 IBM Corp.
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2017 IBM Corp.
 SPDX-License-Identifier: GPL-2.0+
 Copyright 2017 IBM Corp.
 SPDX-License-Identifier: GPL-2.0-or-later
  uacce_alloc() - alloc an accelerator
  @parent: pointer of uacce parent device
  @interface: pointer of uacce_interface for register
  Returns uacce pointer if success and ERR_PTR if not
  Need check returned negotiated uacce->flags
  uacce_register() - add the accelerator to cdev and export to user space
  @uacce: The initialized uacce device
  Return 0 if register succeeded, or an error.
  uacce_remove() - remove the accelerator
  @uacce: the accelerator to remove
	
	  unmap remaining mapping from user space, preventing user still
	  access the mmaped area while parent device is already removed
 ensure no open queue remains 
 disable sva now since no opened queues 
 SPDX-License-Identifier: GPL-2.0-only
  VMware VMCI Driver
  Copyright (C) 2012 VMware, Inc. All rights reserved.
  Gets a resource (if one exists) matching given handle from the hash table.
  Find an unused resource ID and return it. The first
  VMCI_RESERVED_RESOURCE_ID_MAX are reserved so we start from
  its value + 1.
  Returns VMCI resource id on success, VMCI_INVALID_ID on failure.
	
	  Generate a unique resource ID.  Keep on trying until we wrap around
	  in the RID space.
 Skip the reserved rids. 
 Remove resource from hash table. 
  Get a reference to given resource.
 Verify the resource has been unlinked from hash table 
 Signal that container of this resource can now be destroyed 
  Resource's release function will get called if last reference.
  If it is the last reference, then we are sure that nobody else
  can increment the count again (it's gone from the resource hash
  table), so there's no need for locking here.
	
	  We propagate the information back to caller in case it wants to know
	  whether entry was freed.
 SPDX-License-Identifier: GPL-2.0-only
  VMware VMCI Driver
  Copyright (C) 2012 VMware, Inc. All rights reserved.
  DoorbellEntry describes the a doorbell notification handle allocated by the
  host.
 Only used by guest personality 
 The VMCI index table keeps track of currently registered doorbells. 
 Index table lock 
  The max_notify_idx is one larger than the currently known bitmap index in
  use, and is used to determine how much of the bitmap needs to be scanned.
  The notify_idx_count is used for determining whether there are free entries
  within the bitmap (if notify_idx_count + 1 < max_notify_idx).
  The last_notify_idx_reserved is used to track the last index handed out - in
  the case where multiple handles share a notification index, we hand out
  indexes round robin based on last_notify_idx_reserved.
 This is a one entry cache used to by the index allocation. 
  Utility function that retrieves the privilege flags associated
  with a given doorbell handle. For guest endpoints, the
  privileges are determined by the context ID, but for host
  endpoints privileges are associated with the complete
  handle. Hypervisor endpoints are not yet supported.
		
		  Hypervisor endpoints for notifications are not
		  supported (yet).
  Find doorbell entry by bitmap index.
  Add the given entry to the index table.  This willi take a reference to the
  entry's resource so that the entry is not deleted before it is removed from
  the  table.
	
	  Below we try to allocate an index in the notification
	  bitmap with "not too much" sharing between resources. If we
	  use less that the full bitmap, we either add to the end if
	  there are no unused flags within the currently used area,
	  or we search for unused ones. If we use the full bitmap, we
	  allocate the index round robin.
  Remove the given entry from the index table.  This will release() the
  entry's resource.
		
		  If we delete an entry with the maximum known
		  notification index, we take the opportunity to
		  prune the current max. As there might be other
		  unused indices immediately below, we lower the
		  maximum until we hit an index in use.
  Creates a link between the given doorbell handle and the given
  index in the bitmap in the device backend. A notification state
  is created in hypervisor.
  Unlinks the given doorbell handle from an index in the bitmap in
  the device backend. The notification state is destroyed in hypervisor.
  Notify another guest or the host.  We send a datagram down to the
  host via the hypervisor with the notification info.
  Calls the specified callback in a delayed context.
  Dispatches a doorbell notification to the host context.
  Register the notification bitmap with the host.
  Executes or schedules the handlers for a given notify index.
  Scans the notification bitmap, collects pending notifications,
  resets the bitmap and invokes appropriate callbacks.
  vmci_doorbell_create() - Creates a doorbell
  @handle:     A handle used to track the resource.  Can be invalid.
  @flags:      Flag that determines context of callback.
  @priv_flags: Privileges flags.
  @notify_cb:  The callback to be ivoked when the doorbell fires.
  @client_data:        A parameter to be passed to the callback.
  Creates a doorbell with the given callback. If the handle is
  VMCI_INVALID_HANDLE, a free handle will be assigned, if
  possible. The callback can be run immediately (potentially with
  locks held - the default) or delayed (in a kernel thread) by
  specifying the flag VMCI_FLAG_DELAYED_CB. If delayed execution
  is selected, a given callback may not be run if the kernel is
  unable to allocate memory for the delayed execution (highly
  unlikely).
 Let resource code allocate a free ID for us 
		
		  Validate the handle.  We must do both of the checks below
		  because we can be acting as both a host and a guest at the
		  same time. We always allow the host context ID, since the
		  host functionality is in practice always there with the
		  unified driver.
  vmci_doorbell_destroy() - Destroy a doorbell.
  @handle:     The handle tracking the resource.
  Destroys a doorbell previously created with vmcii_doorbell_create. This
  operation may block waiting for a callback to finish.
			
			  The only reason this should fail would be
			  an inconsistency between guest and
			  hypervisor state, where the guest believes
			  it has an active registration whereas the
			  hypervisor doesn't. One case where this may
			  happen is if a doorbell is unregistered
			  following a hibernation at a time where the
			  doorbell state hasn't been restored on the
			  hypervisor side yet. Since the handle has
			  now been removed in the guest, we just
			  print a warning and return success.
	
	  Now remove the resource from the table.  It might still be in use
	  after this, in a callback or still on the delayed work queue.
  vmci_doorbell_notify() - Ring the doorbell (and hide in the bushes).
  @dst:        The handlle identifying the doorbell resource
  @priv_flags: Priviledge flags.
  Generates a notification on the doorbell identified by the
  handle. For host side generation of notifications, the caller
  can specify what the privilege of the calling side is.
 SPDX-License-Identifier: GPL-2.0-only
  VMware VMCI Driver
  Copyright (C) 2012 VMware, Inc. All rights reserved.
 on one of subscriber lists 
 We free all memory at exit. 
			
			  We should never get here because all events
			  should have been unregistered before we try
			  to unload the driver module.
  Find entry. Assumes subscriber_mutex is held.
  Actually delivers the events to the subscribers.
  The callback function for each subscriber is invoked.
  Dispatcher for the VMCI_EVENT_RECEIVE datagrams. Calls all
  subscribers for given event.
  vmci_event_subscribe() - Subscribe to a given event.
  @event:      The event to subscribe to.
  @callback:   The callback to invoke upon the event.
  @callback_data:      Data to pass to the callback.
  @subscription_id:    ID used to track subscription.  Used with
               vmci_event_unsubscribe()
  Subscribes to the provided event. The callback specified will be
  fired from RCU critical section and therefore must not sleep.
 Creation of a new event is always allowed. 
		
		  We try to get an id a couple of time before
		  claiming we are out of resources.
 Test for duplicate id. 
  vmci_event_unsubscribe() - unsubscribe from an event.
  @sub_id:     A subscription ID as provided by vmci_event_subscribe()
  Unsubscribe from given event. Removes it from list and frees it.
  Will return callback_data if requested by caller.
 SPDX-License-Identifier: GPL-2.0-only
  VMware VMCI Driver
  Copyright (C) 2012 VMware, Inc. All rights reserved.
 reallocate. 
  Handle that was removed, VMCI_INVALID_HANDLE if entry not found.
  Handle that was removed, VMCI_INVALID_HANDLE if array was empty.
  Handle at given index, VMCI_INVALID_HANDLE if invalid index.
  NULL if the array is empty. Otherwise, a pointer to the array
  of VMCI handles in the handle array.
 SPDX-License-Identifier: GPL-2.0-only
  VMware VMCI Driver
  Copyright (C) 2012 VMware, Inc. All rights reserved.
  VMCI driver initialization. This block can also be used to
  pass initial group membership etc.
 VMCIqueue_pairAllocInfo_VMToVM 
 User VA. 
 User VA. 
 Size of the file name array. 
 Size of the file name array. 
 VMCISetNotifyInfo: Used to pass notify flag's address to the host driver. 
  Per-instance host state
 Mutex lock for vmci context access 
  Determines whether the VMCI host personality is
  available. Since the core functionality of the host driver is
  always present, all guests could possibly use the host
  personality. However, to minimize the deviation from the
  pre-unified driver state of affairs, we only consider the host
  device active if there is no active guest device or if there
  are VMX'en with active VMCI contexts using the host device.
  Called on open of devvmci.
  Called on close of devvmci, most often when the process
  exits.
		
		  The number of active contexts is used to track whether any
		  VMX'en are using the host personality. It is incremented when
		  a context is created through the IOCTL_VMCI_INIT_CONTEXT
		  ioctl.
  This is used to wake up the VMX when a VMCI call arrives, or
  to wake up select() or poll() at the next clock tick.
 Check for VMCI calls to this VM context. 
  Copies the handles of a handle array into a user buffer, and
  returns the new length in userBufferSize. If the copy to the
  user buffer fails, the functions still returns VMCI_SUCCESS,
  but retval != 0.
  Sets up a given context for notify to work. Maps the notify
  boolean in user VA into kernel space.
	
	  We are using 'bool' internally, but let's make sure we explicit
	  about the size.
	
	  Lock physical page backing a given user VA.
	
	  Map the locked page and set up notify pointer.
	
	  The basic logic here is:
	 
	  If the user sends in a version of 0 tell it our version.
	  If the user didn't send in a version, tell it our version.
	  If the user sent in an old version, tell it -its- version.
	  If the user sent in an newer version, tell it our version.
	 
	  The rationale behind telling the caller its version is that
	  Workstation 6.5 required that VMX and VMCI kernel module were
	  version sync'd.  All new VMX users will be programmed to
	  handle the VMCI kernel module version.
	
	  Copy cid to userlevel, we do this to allow the VMX
	  to enforce its policy on cid generation.
 Get source context id. 
		
		  VMX is passing down a new VA for the queue
		  pair mapping.
		
		  The queue pair is about to be unmapped by
		  the VMX.
	
	  Communicate success pre-emptively to the caller.  Note that the
	  basic premise is that it is incumbent upon the caller not to look at
	  the info.result field until after the ioctl() returns.  And then,
	  only if the ioctl() result indicates no error.  We send up the
	  SUCCESS status before calling SetPageStore() store because failing
	  to copy up the result code means unwinding the SetPageStore().
	 
	  It turns out the logic to unwind a SetPageStore() opens a can of
	  worms.  For example, if a host had created the queue_pair and a
	  guest attaches and SetPageStore() is successful but writing success
	  fails, then ... the host has to be stopped from writing (anymore)
	  data into the queue_pair.  That means an additional test in the
	  VMCI_Enqueue() code path.  Ugh.
		
		  In this case, we can't write a result field of the
		  caller's info block.  So, we don't even try to
		  SetPageStore().
			
			  Note that in this case the SetPageStore()
			  call failed but we were unable to
			  communicate that to the caller (because the
			  copy_to_user() call failed).  So, if we
			  simply return an error (in this case
			  -EFAULT) then the caller will know that the
			   SetPageStore failed even though we couldn't
			   put the result code in the result field and
			   indicate exactly why it failed.
			 
			  That says nothing about the issue where we
			  were once able to write to the caller's info
			  memory and now can't.  Something more
			  serious is probably going on than the fact
			  that SetPageStore() didn't work.
 SPDX-License-Identifier: GPL-2.0-only
  VMware VMCI Driver
  Copyright (C) 2012 VMware, Inc. All rights reserved.
  In the following, we will distinguish between two kinds of VMX processes -
  the ones with versions lower than VMCI_VERSION_NOVMVM that use specialized
  VMCI page files in the VMX and supporting VM to VM communication and the
  newer ones that use the guest memory directly. We will in the following
  refer to the older VMX versions as old-style VMX'en, and the newer ones as
  new-style VMX'en.
  The state transition datagram is as follows (the VMCIQPB_ prefix has been
  removed for readability) - see below for more details on the transtions:
             --------------  NEW  -------------
             |                                |
            \_                              \_
      CREATED_NO_MEM <-----------------> CREATED_MEM
             |    |                           |
             |    o-----------------------o   |
             |                            |   |
            \_                          \_ \_
      ATTACHED_NO_MEM <----------------> ATTACHED_MEM
             |                            |   |
             |     o----------------------o   |
             |     |                          |
            \_   \_                        \_
      SHUTDOWN_NO_MEM <----------------> SHUTDOWN_MEM
             |                                |
             |                                |
             -------------> gone <-------------
  In more detail. When a VMCI queue pair is first created, it will be in the
  VMCIQPB_NEW state. It will then move into one of the following states:
  - VMCIQPB_CREATED_NO_MEM: this state indicates that either:
      - the created was performed by a host endpoint, in which case there is
        no backing memory yet.
      - the create was initiated by an old-style VMX, that uses
        vmci_qp_broker_set_page_store to specify the UVAs of the queue pair at
        a later point in time. This state can be distinguished from the one
        above by the context ID of the creator. A host side is not allowed to
        attach until the page store has been set.
  - VMCIQPB_CREATED_MEM: this state is the result when the queue pair
      is created by a VMX using the queue pair device backend that
      sets the UVAs of the queue pair immediately and stores the
      information for later attachers. At this point, it is ready for
      the host side to attach to it.
  Once the queue pair is in one of the created states (with the exception of
  the case mentioned for older VMX'en above), it is possible to attach to the
  queue pair. Again we have two new states possible:
  - VMCIQPB_ATTACHED_MEM: this state can be reached through the following
    paths:
      - from VMCIQPB_CREATED_NO_MEM when a new-style VMX allocates a queue
        pair, and attaches to a queue pair previously created by the host side.
      - from VMCIQPB_CREATED_MEM when the host side attaches to a queue pair
        already created by a guest.
      - from VMCIQPB_ATTACHED_NO_MEM, when an old-style VMX calls
        vmci_qp_broker_set_page_store (see below).
  - VMCIQPB_ATTACHED_NO_MEM: If the queue pair already was in the
      VMCIQPB_CREATED_NO_MEM due to a host side create, an old-style VMX will
      bring the queue pair into this state. Once vmci_qp_broker_set_page_store
      is called to register the user memory, the VMCIQPB_ATTACH_MEM state
      will be entered.
  From the attached queue pair, the queue pair can enter the shutdown states
  when either side of the queue pair detaches. If the guest side detaches
  first, the queue pair will enter the VMCIQPB_SHUTDOWN_NO_MEM state, where
  the content of the queue pair will no longer be available. If the host
  side detaches first, the queue pair will either enter the
  VMCIQPB_SHUTDOWN_MEM, if the guest memory is currently mapped, or
  VMCIQPB_SHUTDOWN_NO_MEM, if the guest memory is not mapped
  (e.g., the host detaches while a guest is stunned).
  New-style VMX'en will also unmap guest memory, if the guest is
  quiesced, e.g., during a snapshot operation. In that case, the guest
  memory will no longer be available, and the queue pair will transition from
  _MEM state to a _NO_MEM state. The VMX may later map the memory once more,
  in which case the queue pair will transition from the _NO_MEM state at that
  point back to the _MEM state. Note that the _NO_MEM state may have changed,
  since the peer may have either attached or detached in the meantime. The
  values are laid out such that ++ on a state will move from a _NO_MEM to a
  _MEM state, and vice versa.
 The Kernel specific component of the struct vmci_queue structure. 
 Protects the queue. 
 Shared by producer and consumer queues. 
 Number of pages incl. header. 
 Host or guest? 
 Used by the guest. 
 Used by the host. 
  This structure is opaque to the clients.
  In the queue pair broker, we always use the guest point of view for
  the produce and consume queue values and references, e.g., the
  produce queue size stored is the guests produce queue size. The
  host endpoint will need to swap these around. The only exception is
  the local queue pairs on the host, in which case the host endpoint
  that creates the queue pair will have the right orientation, and
  the attaching host endpoint will need to swap.
 Created by VMX using VMCI page files 
 Kernel memory for local queue pair 
 Protect queue list. 
  Frees kernel VA space for a given queue and its queue header, and
  frees physical data pages.
 Given size does not include header, so add in a page here. 
  Allocates kernel queue pages of specified size with IOMMU mappings,
  plus space for the queue structurekernel interface and the queue
  header.
 Size excl. the header. 
 Queue header is the first page. 
  Copies from a given buffer or iovector to a VMCI Queue.  Uses
  kmap()kunmap() to dynamically mapunmap required portions of the queue
  by traversing the offset -> page translation structure for the queue.
  Assumes that offset + size does not wrap around in the queue.
 Skip header. 
 Enough payload to fill up from this page. 
  Copies to a given buffer or iovector from a VMCI Queue.  Uses
  kmap()kunmap() to dynamically mapunmap required portions of the queue
  by traversing the offset -> page translation structure for the queue.
  Assumes that offset + size does not wrap around in the queue.
 Skip header. 
 Enough payload to fill up this page. 
  Allocates two list of PPNs --- one for the pages in the produce queue,
  and the other for the pages in the consume queue. Intializes the list
  of PPNs with the page frame numbers of the KVA for the two queues (and
  the queue headers).
  Frees the two list of PPNs for a queue pair.
 Do not call these functions on NULL inputs. 
  Populates the list of PPNs in the hypercall structure with the PPNS
  of the produce queue and the consume queue.
  Allocates kernel VA space of specified size plus space for the queue
  and kernel interface.  This is different from the guest queue allocator,
  because we do not allocate our own queue headerdata pages here but
  share those of the guest.
  Frees kernel memory for a given queue (header plus translation
  structure).
  Initialize the mutex for the pair of queues.  This mutex is used to
  protect the q_header and the buffer from changing out from under any
  users of either queue.  Of course, it's only any good if the mutexes
  are actually acquired.  Queue structure must lie on non-paged memory
  or we cannot guarantee access to the mutex.
	
	  Only the host queue has shared state - the guest queues do not
	  need to synchronize access using a queue mutex.
  Cleans up the mutex for the pair of queues.
  Acquire the mutex for the queue.  Note that the produce_q and
  the consume_q share a mutex.  So, only one of the two need to
  be passed in to this routine.  Either will work just fine.
  Release the mutex for the queue.  Note that the produce_q and
  the consume_q share a mutex.  So, only one of the two need to
  be passed in to this routine.  Either will work just fine.
  Helper function to release pages in the PageStoreAttachInfo
  previously obtained using get_user_pages.
  Lock the user pages referenced by the {produce,consume}Buffer
  struct into memory and populate the {produce,consume}Pages
  arrays in the attach structure with them.
  Registers the specification of the user pages used for backing a queue
  pair. Enough information to map in pages is stored in the OS specific
  part of the struct vmci_queue structure.
	
	  The new style and the old style mapping only differs in
	  that we either get a single or two UVAs, so we split the
	  single UVA range at the appropriate spot.
  Releases and removes the references to user pages stored in the attach
  struct.  Pages are released from the page cache and may become
  swappable again.
  Once qp_host_register_user_memory has been performed on a
  queue, the queue pair headers can be mapped into the
  kernel. Once mapped, they must be unmapped with
  qp_host_unmap_queues prior to calling
  qp_host_unregister_user_memory.
  Pages are pinned.
  Unmaps previously mapped queue pair headers from the kernel.
  Pages are unpinned.
  Finds the entry in the list corresponding to a given handle. Assumes
  that the list is locked.
  Finds the entry in the list corresponding to a given handle.
  Finds the entry in the list corresponding to a given handle.
  Dispatches a queue pair event message directly into the local event
  queue.
  Allocates and initializes a qp_guest_endpoint structure.
  Allocates a queue_pair rid (and handle) iff the given entry has
  an invalid handle.  0 through VMCI_RESERVED_RESOURCE_ID_MAX
  are reserved handles.  Assumes that the QP list mutex is held
  by the caller.
 One page each for the queue headers. 
 Add resource obj 
  Frees a qp_guest_endpoint structure.
 Unlink from resource hash table and free callback 
  Helper to make a queue_pairAlloc hypercall when the driver is
  supporting a guest device.
  Helper to make a queue_pairDetach hypercall when the driver is
  supporting a guest device.
  Adds the given entry to the list. Assumes that the list is locked.
  Removes the given entry from the list. Assumes that the list is locked.
  Helper for VMCI queue_pair detach interface. Frees the physical
  pages for the queue pair.
 To avoid compiler warning below 
			
			  We can fail to notify a local queuepair
			  because we can't allocate.  We still want
			  to release the entry if that happens, so
			  don't bail out yet.
			
			  We failed to notify a non-local queuepair.
			  That other queuepair might still be
			  accessing the shared memory, so don't
			  release the entry yet.  It will get cleaned
			  up by VMCIqueue_pair_Exit() if necessary
			  (assuming we are going away, otherwise why
			  did this fail?).
	
	  If we get here then we either failed to notify a local queuepair, or
	  we succeeded in all cases.  Release the entry if required.
 If we didn't remove the entry, this could change once we unlock. 
  This functions handles the actual allocation of a VMCI queue
  pair guest endpoint. Allocates physical pages for the queue
  pair. It makes OS dependent calls through generic wrappers.
 Local attach case. 
			
			  Do a local attach.  We swap the consume and
			  produce queues for the attacher and deliver
			  an attach event.
	
	  It's only necessary to notify the host if this queue pair will be
	  attached to from another context.
 Local create case. 
		
		  Enforce similar checks on local queue pairs as we
		  do for regular ones.  The handle's context must
		  match the creator or attacher context id (here they
		  are both the current context id) and the
		  attach-only flag cannot exist during create.  We
		  also ensure specified peer is this context or an
		  invalid one.
	
	  We should initialize the queue pair header pages on a local
	  queue pair create.  For non-local queue pairs, the
	  hypervisor initializes the header pages in the create step.
 The queues will be freed inside the destroy routine. 
 This path should only be used when an existing entry was found. 
  The first endpoint issuing a queue pair allocation will create the state
  of the queue pair in the queue pair broker.
  If the creator is a guest, it will associate a VMX virtual address range
  with the queue pair as specified by the page_store. For compatibility with
  older VMX'en, that would use a separate step to set the VMX virtual
  address range, the virtual address range can be registered later using
  vmci_qp_broker_set_page_store. In that case, a page_store of NULL should be
  used.
  If the creator is the host, a page_store of NULL should be used as well,
  since the host is not able to supply a page store for the queue pair.
  For older VMX and host callers, the queue pair will be created in the
  VMCIQPB_CREATED_NO_MEM state, and for current VMX callers, it will be
  created in VMCOQPB_CREATED_MEM state.
 Do not create if the caller asked not to. 
	
	  Creator's context ID should match handle's context ID or the creator
	  must allow the context in handle's context ID as the "peer".
	
	  Creator's context ID for local queue pairs should match the
	  peer, if a peer is specified.
		
		  The queue pair broker entry stores values from the guest
		  point of view, so a creating host side endpoint should swap
		  produce and consume values -- unless it is a local queue
		  pair, in which case no swapping is necessary, since the local
		  attacher will swap queues.
		
		  The VMX already initialized the queue pair headers, so no
		  need for the kernel side to do that.
		
		  A create without a page_store may be either a host
		  side create (in which case we are waiting for the
		  guest side to supply the memory) or an old style
		  queue pair create (in which case we will expect a
		  set page store call as the next step).
 Add to resource obj 
  Enqueues an event datagram to notify the peer VM attached to
  the given queue pair handle about attachdetach event by the
  given VM.  Returns Payload size of datagram enqueued on
  success, error code otherwise.
	
	  In vmci_ctx_enqueue_datagram() we enforce the upper limit on
	  number of pending events from the hypervisor to a given VM
	  otherwise a rogue VM could do an arbitrary number of attach
	  and detach operations causing memory pressure in the host
	  kernel.
  The second endpoint issuing a queue pair allocation will attach to
  the queue pair registered with the queue pair broker.
  If the attacher is a guest, it will associate a VMX virtual address
  range with the queue pair as specified by the page_store. At this
  point, the already attach host endpoint may start using the queue
  pair, and an attach event is sent to it. For compatibility with
  older VMX'en, that used a separate step to set the VMX virtual
  address range, the virtual address range can be registered later
  using vmci_qp_broker_set_page_store. In that case, a page_store of
  NULL should be used, and the attach event will be generated once
  the actual page store has been set.
  If the attacher is the host, a page_store of NULL should be used as
  well, since the page store information is already set by the guest.
  For new VMX and host callers, the queue pair will be moved to the
  VMCIQPB_ATTACHED_MEM state, and for older VMX callers, it will be
  moved to the VMCOQPB_ATTACHED_NO_MEM state.
	
	  If we are attaching from a restricted context then the queuepair
	  must have been created by a trusted endpoint.
	
	  If we are attaching to a queuepair that was created by a restricted
	  context then we must be trusted.
	
	  If the creator specifies VMCI_INVALID_ID in "peer" field, access
	  control check is not performed.
		
		  Do not attach if the caller doesn't support Host Queue Pairs
		  and a host created this queue pair.
		
		  Do not attach a host to a user created queue pair if that
		  user doesn't support host queue pair end points.
		
		  The queue pair broker entry stores values from the guest
		  point of view, so an attaching guest should match the values
		  stored in the entry.
		
		  If a guest attached to a queue pair, it will supply
		  the backing memory.  If this is a pre NOVMVM vmx,
		  the backing memory will be supplied by calling
		  vmci_qp_broker_set_page_store() following the
		  return of the vmci_qp_broker_alloc() call. If it is
		  a vmx of version NOVMVM or later, the page store
		  must be supplied as part of the
		  vmci_qp_broker_alloc call.  Under all circumstances
		  must the initially created queue pair not have any
		  memory associated with it already.
			
			  Patch up host state to point to guest
			  supplied memory. The VMX already
			  initialized the queue pair headers, so no
			  need for the kernel side to do that.
		
		  The host side is attempting to attach to a queue
		  pair that doesn't have any memory associated with
		  it. This must be a pre NOVMVM vmx that hasn't set
		  the page store information yet, or a quiesced VM.
 The host side has successfully attached to a queue pair. 
	
	  When attaching to local queue pairs, the context already has
	  an entry tracking the queue pair, so don't add another one.
  queue_pair_Alloc for use when setting up queue pair endpoints
  on the host.
	
	  In the initial argument check, we ensure that non-vmkernel hosts
	  are not allowed to create local queue pairs.
  This function implements the kernel API for allocating a queue
  pair.
			
			  If this is a local queue pair, the attacher
			  will swap around produce and consume
			  queues.
  Allocates a VMCI queue_pair. Only checks validity of input
  arguments. The real work is done in the host or guest
  specific function.
  This function implements the host kernel API for detaching from
  a queue pair.
  Detaches from a VMCI queue_pair. Only checks validity of input argument.
  Real work is done in the host or guest specific function.
  Returns the entry from the head of the list. Assumes that the list is
  locked.
  Requests that a queue pair be allocated with the VMCI queue
  pair broker. Allocates a queue pair entry if one does not
  exist. Attaches to one if it exists, and retrieves the page
  files backing that queue_pair.  Assumes that the queue pair
  broker lock is held.
  VMX'en with versions lower than VMCI_VERSION_NOVMVM use a separate
  step to add the UVAs of the VMX mapping of the queue pair. This function
  provides backwards compatibility with such VMX'en, and takes care of
  registering the page store for a queue pair previously allocated by the
  VMX during create or attach. This function will move the queue pair state
  to either from VMCIQBP_CREATED_NO_MEM to VMCIQBP_CREATED_MEM or
  VMCIQBP_ATTACHED_NO_MEM to VMCIQBP_ATTACHED_MEM. If moving to the
  attached state with memory, the queue pair is ready to be used by the
  host peer, and an attached event will be generated.
  Assumes that the queue pair broker lock is held.
  This function is only used by the hosted platform, since there is no
  issue with backwards compatibility for vmkernel.
	
	  We only support guest to host queue pairs, so the VMX must
	  supply UVAs for the mapped page files.
	
	  If I'm the owner then I can set the page store.
	 
	  Or, if a host created the queue_pair and I'm the attached peer
	  then I can set the page store.
  Resets saved queue headers for the given QP broker
  entry. Should be used when guest memory becomes available
  again, or the guest detaches.
  The main entry point for detaching from a queue pair registered with the
  queue pair broker. If more than one endpoint is attached to the queue
  pair, the first endpoint will mainly decrement a reference count and
  generate a notification to its peer. The last endpoint will clean up
  the queue pair state registered with the broker.
  When a guest endpoint detaches, it will unmap and unregister the guest
  memory backing the queue pair. If the host is still attached, it will
  no longer be able to access the queue pair content.
  If the queue pair is already in a state where there is no memory
  registered for the queue pair (any _NO_MEM state), it will transition to
  the VMCIQPB_SHUTDOWN_NO_MEM state. This will also happen, if a guest
  endpoint is the first of two endpoints to detach. If the host endpoint is
  the first out of two to detach, the queue pair will move to the
  VMCIQPB_SHUTDOWN_MEM state.
		
		  Pre NOVMVM vmx'en may detach from a queue pair
		  before setting the page store, and in that case
		  there is no user memory to detach from. Also, more
		  recent VMX'en may detach from a queue pair in the
		  quiesced state.
 Unlink from resource hash table and free callback 
  Establishes the necessary mappings for a queue pair given a
  reference to the queue pair guest memory. This is usually
  called when a guest is unquiesced and the VMX is allowed to
  map guest memory once again.
 Move state from _NO_MEM to _MEM 
  Saves a snapshot of the queue headers for the given QP broker
  entry. Should be used when guest memory is unmapped.
  Results:
  VMCI_SUCCESS on success, appropriate error code if guest memory
  can't be accessed..
		
		   If the headers have already been saved, we don't need to do
		   it again, and we don't want to map in the headers
		   unnecessarily.
  Removes all references to the guest memory of a given queue pair, and
  will move the queue pair from state _MEM to _NO_MEM. It is usually
  called when a VM is being quiesced where access to guest memory should
  avoided.
		
		  On hosted, when we unmap queue pairs, the VMX will also
		  unmap the guest memory, so we invalidate the previously
		  registered memory. If the queue pair is mapped again at a
		  later point in time, we will need to reregister the user
		  memory with a possibly new user VA.
		
		  Move state from _MEM to _NO_MEM.
  Destroys all guest queue pair endpoints. If active guest queue
  pairs still exist, hypercalls to attempt detach from these
  queue pairs will be made. Any failure to detach is silently
  ignored.
 Don't make a hypercall for local queue_pairs. 
 We cannot fail the exit, so let's reset ref_count. 
  Helper routine that will lock the queue pair before subsequent
  operations.
  Note: Non-blocking on the host side is currently only implemented in ESX.
  Since non-blocking isn't yet implemented on the host personality we
  have no reason to acquire a spin lock.  So to avoid the use of an
  unnecessary lock only acquire the mutex if we can block.
  Helper routine that unlocks the queue pair after calling
  qp_lock.
  The queue headers may not be mapped at all times. If a queue is
  currently not mapped, it will be attempted to do so.
  Helper routine that will retrieve the produce and consume
  headers of a given queue pair. If the guest memory of the
  queue pair is currently not available, the saved queue headers
  will be returned, if these are available.
  Callback from VMCI queue pair broker indicating that a queue
  pair that was previously not ready, now either is ready or
  gone forever.
  Makes the calling thread wait for the queue pair to become
  ready for host side access.  Returns true when thread is
  woken up after queue pair state change, false otherwise.
  Enqueues a given buffer to the produce queue using the provided
  function. As many bytes as possible (space available in the queue)
  are enqueued.  Assumes the queue->mutex has been acquired.  Returns
  VMCI_ERROR_QUEUEPAIR_NOSPACE if no space was available to enqueue
  data, VMCI_ERROR_INVALID_SIZE, if any queue pointer is outside the
  queue (as defined by the queue size), VMCI_ERROR_INVALID_ARGS, if
  an error occured when accessing the buffer,
  VMCI_ERROR_QUEUEPAIR_NOTATTACHED, if the queue pair pages aren't
  available.  Otherwise, the number of bytes written to the queue is
  returned.  Updates the tail pointer of the produce queue.
 Tail pointer wraps around. 
  Dequeues data (if available) from the given consume queue. Writes data
  to the user provided buffer using the provided function.
  Assumes the queue->mutex has been acquired.
  Results:
  VMCI_ERROR_QUEUEPAIR_NODATA if no data was available to dequeue.
  VMCI_ERROR_INVALID_SIZE, if any queue pointer is outside the queue
  (as defined by the queue size).
  VMCI_ERROR_INVALID_ARGS, if an error occured when accessing the buffer.
  Otherwise the number of bytes dequeued is returned.
  Side effects:
  Updates the head pointer of the consume queue.
 Head pointer wraps around. 
  vmci_qpair_alloc() - Allocates a queue pair.
  @qpair:      Pointer for the new vmci_qp struct.
  @handle:     Handle to track the resource.
  @produce_qsize:      Desired size of the producer queue.
  @consume_qsize:      Desired size of the consumer queue.
  @peer:       ContextID of the peer.
  @flags:      VMCI flags.
  @priv_flags: VMCI priviledge flags.
  This is the client interface for allocating the memory for a
  vmci_qp structure and then attaching to the underlying
  queue.  If an error occurs allocating the memory for the
  vmci_qp structure no attempt is made to attach.  If an
  error occurs attaching, then the structure is freed.
	
	  Restrict the size of a queuepair.  The device already
	  enforces a limit on the total amount of memory that can be
	  allocated to queuepairs for a guest.  However, we try to
	  allocate this memory before we make the queuepair
	  allocation hypercall.  On Linux, we allocate each page
	  separately, which means rather than fail, the guest will
	  thrash while it tries to allocate, and will become
	  increasingly unresponsive to the point where it appears to
	  be hung.  So we place a limit on the size of an individual
	  queuepair here, and leave the device to enforce the
	  restriction on total queuepair memory.  (Note that this
	  doesn't prevent all cases; a user with only this much
	  physical memory could still get into trouble.)  The error
	  used by the device is NO_RESOURCES, so use that here too.
  vmci_qpair_detach() - Detatches the client from a queue pair.
  @qpair:      Reference of a pointer to the qpair struct.
  This is the client interface for detaching from a VMCIQPair.
  Note that this routine will free the memory allocated for the
  vmci_qp structure too.
	
	  The guest can fail to detach for a number of reasons, and
	  if it does so, it will cleanup the entry (if there is one).
	  The host can fail too, but it won't cleanup the entry
	  immediately, it will do that later when the context is
	  freed.  Either way, we need to release the qpair struct
	  here; there isn't much the caller can do, and we don't want
	  to leak.
  vmci_qpair_get_produce_indexes() - Retrieves the indexes of the producer.
  @qpair:      Pointer to the queue pair struct.
  @producer_tail:      Reference used for storing producer tail index.
  @consumer_head:      Reference used for storing the consumer head index.
  This is the client interface for getting the current indexes of the
  QPair from the point of the view of the caller as the producer.
  vmci_qpair_get_consume_indexes() - Retrieves the indexes of the consumer.
  @qpair:      Pointer to the queue pair struct.
  @consumer_tail:      Reference used for storing consumer tail index.
  @producer_head:      Reference used for storing the producer head index.
  This is the client interface for getting the current indexes of the
  QPair from the point of the view of the caller as the consumer.
  vmci_qpair_produce_free_space() - Retrieves free space in producer queue.
  @qpair:      Pointer to the queue pair struct.
  This is the client interface for getting the amount of free
  space in the QPair from the point of the view of the caller as
  the producer which is the common case.  Returns < 0 if err, else
  available bytes into which data can be enqueued if > 0.
  vmci_qpair_consume_free_space() - Retrieves free space in consumer queue.
  @qpair:      Pointer to the queue pair struct.
  This is the client interface for getting the amount of free
  space in the QPair from the point of the view of the caller as
  the consumer which is not the common case.  Returns < 0 if err, else
  available bytes into which data can be enqueued if > 0.
  vmci_qpair_produce_buf_ready() - Gets bytes ready to read from
  producer queue.
  @qpair:      Pointer to the queue pair struct.
  This is the client interface for getting the amount of
  enqueued data in the QPair from the point of the view of the
  caller as the producer which is not the common case.  Returns < 0 if err,
  else available bytes that may be read.
  vmci_qpair_consume_buf_ready() - Gets bytes ready to read from
  consumer queue.
  @qpair:      Pointer to the queue pair struct.
  This is the client interface for getting the amount of
  enqueued data in the QPair from the point of the view of the
  caller as the consumer which is the normal case.  Returns < 0 if err,
  else available bytes that may be read.
  vmci_qpair_enqueue() - Throw data on the queue.
  @qpair:      Pointer to the queue pair struct.
  @buf:        Pointer to buffer containing data
  @buf_size:   Length of buffer.
  @buf_type:   Buffer type (Unused).
  This is the client interface for enqueueing data into the queue.
  Returns number of bytes enqueued or < 0 on error.
  vmci_qpair_dequeue() - Get data from the queue.
  @qpair:      Pointer to the queue pair struct.
  @buf:        Pointer to buffer for the data
  @buf_size:   Length of buffer.
  @buf_type:   Buffer type (Unused).
  This is the client interface for dequeueing data from the queue.
  Returns number of bytes dequeued or < 0 on error.
  vmci_qpair_peek() - Peek at the data in the queue.
  @qpair:      Pointer to the queue pair struct.
  @buf:        Pointer to buffer for the data
  @buf_size:   Length of buffer.
  @buf_type:   Buffer type (Unused on Linux).
  This is the client interface for peeking into a queue.  (I.e.,
  copy data from the queue without updating the head pointer.)
  Returns number of bytes dequeued or < 0 on error.
  vmci_qpair_enquev() - Throw data on the queue using iov.
  @qpair:      Pointer to the queue pair struct.
  @iov:        Pointer to buffer containing data
  @iov_size:   Length of buffer.
  @buf_type:   Buffer type (Unused).
  This is the client interface for enqueueing data into the queue.
  This function uses IO vectors to handle the work. Returns number
  of bytes enqueued or < 0 on error.
  vmci_qpair_dequev() - Get data from the queue using iov.
  @qpair:      Pointer to the queue pair struct.
  @iov:        Pointer to buffer for the data
  @iov_size:   Length of buffer.
  @buf_type:   Buffer type (Unused).
  This is the client interface for dequeueing data from the queue.
  This function uses IO vectors to handle the work. Returns number
  of bytes dequeued or < 0 on error.
  vmci_qpair_peekv() - Peek at the data in the queue using iov.
  @qpair:      Pointer to the queue pair struct.
  @iov:        Pointer to buffer for the data
  @iov_size:   Length of buffer.
  @buf_type:   Buffer type (Unused on Linux).
  This is the client interface for peeking into a queue.  (I.e.,
  copy data from the queue without updating the head pointer.)
  This function uses IO vectors to handle the work. Returns number
  of bytes peeked or < 0 on error.
 SPDX-License-Identifier: GPL-2.0-only
  VMware VMCI Driver
  Copyright (C) 2012 VMware, Inc. All rights reserved.
 protects vmci_vsock_transport_cb 
  vmci_get_context_id() - Gets the current context ID.
  Returns the current context ID.  Note that since this is accessed only
  from code running in the host, this always returns the host context ID.
  vmci_register_vsock_callback() - Register the VSOCK vmci_transport callback.
  The callback will be called when the first host or guest becomes active,
  or if they are already active when this function is called.
  To unregister the callback, call this function with NULL parameter.
  Returns 0 on success. -EBUSY if a callback is already registered.
	 In the host, this function could be called multiple times,
	  but we want to register it only once.
 SPDX-License-Identifier: GPL-2.0-only
  VMware VMCI Driver
  Copyright (C) 2012 VMware, Inc. All rights reserved.
  Make a routing decision for the given source and destination handles.
  This will try to determine the route using the handles and the available
  devices.  Will set the source context if it is invalid.
	
	  "from_guest" is only ever set to true by
	  IOCTL_VMCI_DATAGRAM_SEND (or by the vmkernel equivalent),
	  which comes from the VMX, so we know it is coming from a
	  guest.
	 
	  To avoid inconsistencies, test these once.  We will test
	  them again when we do the actual send to ensure that we do
	  not touch a non-existent device.
 Must have a valid destination context. 
 Anywhere to hypervisor. 
		
		  If this message already came from a guest then we
		  cannot send it to the hypervisor.  It must come
		  from a local client.
		
		  We must be acting as a guest in order to send to
		  the hypervisor.
 And we cannot send if the source is the host context. 
		
		  If the client passed the ANON source handle then
		  respect it (both context and resource are invalid).
		  However, if they passed only an invalid context,
		  then they probably mean ANY, in which case we
		  should set the real context here before passing it
		  down.
 Send from local client down to the hypervisor. 
 Anywhere to local client on host. 
		
		  If it is not from a guest but we are acting as a
		  guest, then we need to send it down to the host.
		  Note that if we are also acting as a host then this
		  will prevent us from sending from local client to
		  local client, but we accept that restriction as a
		  way to remove any ambiguity from the host context.
			
			  If the hypervisor is the source, this is
			  host local communication. The hypervisor
			  may send vmci event datagrams to the host
			  itself, but it will never send datagrams to
			  an "outer host" through the guest device.
 If no source context then use the current. 
 Send it from local client down to the host. 
		
		  Otherwise we already received it from a guest and
		  it is destined for a local client on this host, or
		  it is from another local client on this host.  We
		  must be acting as a host to service it.
			
			  If it came from a guest then it must have a
			  valid context.  Otherwise we can use the
			  host context.
 Route to local client. 
	
	  If we are acting as a host then this might be destined for
	  a guest.
 It will have a context if it is meant for a guest. 
				
				  If it came from a guest then it
				  must have a valid context.
				  Otherwise we can use the host
				  context.
				
				  VM to VM communication is not
				  allowed. Since we catch all
				  communication destined for the host
				  above, this must be destined for a
				  VM since there is a valid context.
 Pass it up to the guest. 
			
			  The host is attempting to reach a CID
			  without an active context, and we can't
			  send it down, since we have no guest
			  device.
	
	  We must be a guest trying to send to another guest, which means
	  we need to send it down to the host. We do not filter out VM to
	  VM communication here, since we want to be able to use the guest
	  driver on older versions that do support VM to VM communication.
		
		  Ending up here means we have neither guest nor host
		  device.
 If no source context then use the current context. 
	
	  Send it from local client down to the host, which will
	  route it to the other guest for us.
 SPDX-License-Identifier: GPL-2.0-only
  VMware VMCI Driver
  Copyright (C) 2012 VMware, Inc. All rights reserved.
 Use a wide upper bound for the maximum contexts. 
  List of current VMCI contexts.  Contexts can be added by
  vmci_ctx_create() and removed via vmci_ctx_destroy().
  These, along with context lookup, are protected by the
  list structure's lock.
 Spinlock for context list operations 
 Used by contexts that did not set up notify flag pointers 
  If nothing requires the attention of the guest, clears both
  notify flag and call.
  Sets the context's notify flag iff datagrams are pending for this
  context.  Called from vmci_setup_notify().
  Allocates and initializes a VMCI context.
 Initialize host-specific VMCI context. 
	
	  If we collide with an existing context we generate a new
	  and use it instead. The VMX will determine if regeneration
	  is okay. Since there isn't 4B - 16 VMs running on a given
	  host, the below loop will terminate.
 We reserve the lowest 16 ids for fixed contexts. 
  Destroy VMCI context.
  Fire notification for all contexts interested in given cid.
	
	  We create an array to hold the subscribers we find when
	  scanning through all contexts.
	
	  Scan all contexts to find who is interested in being
	  notified about given contextID.
		
		  We only deliver notifications of the removal of
		  contexts, if the two contexts are allowed to
		  interact.
 Fire event to all subscribers. 
 We continue to enqueue on next subscriber. 
  Returns the current number of pending datagrams. The call may
  also serve as a synchronization point for the datagram queue,
  as no enqueue operations can occur concurrently.
  Queues a VMCI datagram for the appropriate target VM context.
 Get the target VM's VMCI context. 
 Allocate guest call entry and add it to the target VM's queue. 
	
	  We put a higher limit on datagrams from the hypervisor.  If
	  the pending datagram is not from hypervisor, then we check
	  if enqueueing it would exceed the
	  VMCI_MAX_DATAGRAM_QUEUE_SIZE limit on the destination.  If
	  the pending datagram is from hypervisor, we allow it to be
	  queued at the destination side provided we don't reach the
	  VMCI_MAX_DATAGRAM_AND_EVENT_QUEUE_SIZE limit.
  Verifies whether a context with the specified context ID exists.
  FIXME: utility is dubious as no decisions can be reliably made
  using this data as context can appear and disappear at any time.
  Retrieves VMCI context corresponding to the given cid.
			
			  The context owner drops its own reference to the
			  context only after removing it from the list and
			  waiting for RCU grace period to expire. This
			  means that we are not about to increase the
			  reference count of something that is in the
			  process of being destroyed.
  Deallocates all parts of a context data structure. This
  function doesn't lock the context, because it assumes that
  the caller was holding the last reference to context.
	
	  Fire event to all contexts interested in knowing this
	  context is dying.
	
	  Cleanup all queue pair resources attached to context.  If
	  the VM dies without cleaning up, this code will make sure
	  that no resources are leaked.
			
			  When vmci_qp_broker_detach() succeeds it
			  removes the handle from the array.  If
			  detach fails, we must remove the handle
			  ourselves.
	
	  It is fine to destroy this without locking the callQueue, as
	  this is the only thread having a reference to the context.
  Drops reference to VMCI context. If this is the last reference to
  the context it will be deallocated. A context is created with
  a reference count of one, and on destroy, it is removed from
  the context list before its reference count is decremented. Thus,
  if we reach zero, we are sure that nobody else are about to increment
  it (they need the entry in the context list for that), and so there
  is no need for locking.
  Dequeues the next datagram and returns it to caller.
  The caller passes in a pointer to the max size datagram
  it can handle and the datagram is only unqueued if the
  size is less than max_size. If larger max_size is set to
  the size of the datagram to give the caller a chance to
  set up a larger buffer for the guestcall.
 Dequeue the next datagram entry. 
 Check size of caller's buffer. 
		
		  Return the size of the next datagram.
		
		  The following size_t -> int truncation is fine as
		  the maximum size of a (routable) datagram is 68KB.
 Caller must free datagram. 
  Reverts actions set up by vmci_setup_notify().  Unmaps and unlocks the
  page mappedlocked by vmci_setup_notify().
  Add remote_cid to list of contexts current contexts wants
  notifications fromabout.
  Remove remote_cid from current context's list of contexts it is
  interested in getting notifications fromabout.
 FIXME: want GFP_KERNEL 
  Get current context's checkpoint state of given type.
		
		  For compatibility with VMX'en with VM to VM communication, we
		  always return zero wellknown handles.
  Set current context's checkpoint state of given type.
		
		  We would end up here if VMX with VM to VM communication
		  attempts to restore a checkpoint with wellknown handles.
  Retrieves the specified context's pending notifications in the
  form of a handle array. The handle arrays returned are the
  actual data - not a copy and should not be modified by the
  caller. They must be released using
  vmci_ctx_rcv_notifications_release.
  Releases handle arrays with pending notifications previously
  retrieved using vmci_ctx_rcv_notifications_get. If the
  notifications were not successfully handed over to the guest,
  success must be false.
		
		  New notifications may have been added while we were not
		  holding the context lock, so we transfer any new pending
		  doorbell notifications to the old array, and reinstate the
		  old array.
  Registers that a new doorbell handle has been allocated by the
  context. Only doorbell handles registered can be notified.
  Unregisters a doorbell handle that was previously registered
  with vmci_ctx_dbell_create.
  Unregisters all doorbell handles that were previously
  registered with vmci_ctx_dbell_create.
  Registers a notification of a doorbell handle initiated by the
  specified source context. The notification of doorbells are
  subject to the same isolation rules as datagram delivery. To
  allow host side senders of notifications a finer granularity
  of sender rights than those assigned to the sending context
  itself, the host context is required to specify a different
  set of privilege flags that will override the privileges of
  the source context.
 Get the target VM's VMCI context. 
  Registers that a new queue pair handle has been allocated by
  the context.
  Unregisters a queue pair handle that was previously registered
  with vmci_ctx_qp_create.
  Determines whether a given queue pair handle is registered
  with the given context.
  vmci_context_get_priv_flags() - Retrieve privilege flags.
  @context_id: The context ID of the VMCI context.
  Retrieves privilege flags of the given VMCI context ID.
  vmci_is_context_owner() - Determimnes if user is the context owner
  @context_id: The context ID of the VMCI context.
  @uid:        The host user id (real kernel value).
  Determines whether a given UID is the owner of given VMCI context.
 SPDX-License-Identifier: GPL-2.0-only
  VMware VMCI Driver
  Copyright (C) 2012 VMware, Inc. All rights reserved.
  struct datagram_entry describes the datagram entity. It is used for datagram
  entities created only on the host.
 msg and msg_payload must be together. 
 Number of in-flight host->host datagrams 
  Create a datagram entry given a handle pointer.
 Make datagram resource live. 
  Internal utility function with the same purpose as
  vmci_datagram_get_priv_flags that also takes a context_id.
  Calls the specified callback in a delayed context.
  Dispatch datagram as a host, to the host, or other vm context. This
  function cannot dispatch to hypervisor context handlers. This should
  have been handled before we get here by vmci_datagram_dispatch.
  Returns number of bytes sent on success, error code otherwise.
 Host cannot send to the hypervisor. 
 Check that source handle matches sending context. 
 Get hold of privileges of sending endpoint. 
 Determine if we should route to host or guest destination. 
 Route to host datagram entry. 
		
		  If a VMCI datagram destined for the host is also sent by the
		  host, we always run it delayed. This ensures that no locks
		  are held when the datagram callback runs.
 Route to destination VM context. 
				
				  If the sending context is a VM, it
				  cannot reach another VM.
 We make a copy to enqueue. 
	
	  We currently truncate the size to signed 32 bits. This doesn't
	  matter for this handler as it only support 4Kb messages.
  Dispatch datagram as a guest, down through the VMX and potentially to
  the host.
  Returns number of bytes sent on success, error code otherwise.
  Dispatch datagram.  This will determine the routing for the datagram
  and dispatch it accordingly.
  Returns number of bytes sent on success, error code otherwise.
  Invoke the handler for the given datagram.  This is intended to be
  called only when acting as a guest and receiving a datagram from the
  virtual device.
  vmci_datagram_create_handle_priv() - Create host context datagram endpoint
  @resource_id:        The resource ID.
  @flags:      Datagram Flags.
  @priv_flags: Privilege Flags.
  @recv_cb:    Callback when receiving datagrams.
  @client_data:        Pointer for a datagram_entry struct
  @out_handle: vmci_handle that is populated as a result of this function.
  Creates a host context datagram endpoint and returns a handle to it.
  vmci_datagram_create_handle() - Create host context datagram endpoint
  @resource_id:        Resource ID.
  @flags:      Datagram Flags.
  @recv_cb:    Callback when receiving datagrams.
  @client_ata: Pointer for a datagram_entry struct
  @out_handle: vmci_handle that is populated as a result of this function.
  Creates a host context datagram endpoint and returns a handle to
  it.  Same as vmci_datagram_create_handle_priv without the priviledge
  flags argument.
  vmci_datagram_destroy_handle() - Destroys datagram handle
  @handle:     vmci_handle to be destroyed and reaped.
  Use this function to destroy any datagram handles created by
  vmci_datagram_create_handle{,Priv} functions.
  vmci_datagram_send() - Send a datagram
  @msg:        The datagram to send.
  Sends the provided datagram on its merry way.
 SPDX-License-Identifier: GPL-2.0-only
  VMware VMCI Driver
  Copyright (C) 2012 VMware, Inc. All rights reserved.
 PCI device we are attached to 
 vmci_dev singleton device and supporting data
  VM to hypervisor call mechanism. We use the standard VMware naming
  convention since shared code is calling this function as well.
 Check args. 
	
	  Need to acquire spinlock on the device because the datagram
	  data may be spread over multiple pages and the monitor may
	  interleave device user rpc calls from multiple
	  VCPUs. Acquiring the spinlock precludes that
	  possibility. Disabling interrupts to avoid incoming
	  datagrams during a "rep out" and possibly landing up in
	  this function.
  Gets called with the new context id if updated or resumed.
  Context id.
  Verify that the host supports the hypercalls we need. If it does not,
  try to find fallback hypercalls and use those instead.  Returns
  true if required hypercalls (or fallback hypercalls) are
  supported by the host, false otherwise.
 Checks that hyper calls are supported 
 We need the vector. There are no fallbacks. 
  Reads datagrams from the data in port and dispatches them. We
  always start reading datagrams into only the first page of the
  datagram buffer. If the datagrams don't fit into one page, we
  use the maximum datagram buffer size for the remainder of the
  invocation. This is a simple heuristic for not penalizing
  small datagrams.
  This function assumes that it has exclusive access to the data
  in port for the duration of the call.
		
		  When the input buffer spans multiple pages, a datagram can
		  start on any page boundary in the buffer.
			
			  If the remaining bytes in the datagram
			  buffer doesn't contain the complete
			  datagram, we first make sure we have enough
			  room for it and then we read the reminder
			  of the datagram and possibly any following
			  datagrams.
					
					  We move the partial
					  datagram to the front and
					  read the reminder of the
					  datagram and possibly
					  following calls into the
					  following bytes.
			
			  We special case event datagrams from the
			  hypervisor.
 On to the next datagram. 
			
			  Datagram doesn't fit in datagram buffer of maximal
			  size. We drop it.
 Get the next batch of datagrams. 
  Scans the notification bitmap for raised flags, clears them
  and handles the notifications.
  Interrupt handler for legacy or MSI interrupt, or for first MSI-X
  interrupt (vector VMCI_INTR_DATAGRAM).
	
	  If we are using MSI-X with exclusive vectors then we simply schedule
	  the datagram tasklet, since we know the interrupt was meant for us.
	  Otherwise we must read the ICR to determine what to do.
 Acknowledge interrupt and determine what needs doing. 
  Interrupt handler for MSI-X interrupt vector VMCI_INTR_NOTIFICATION,
  which is for the notification bitmap.  Will only get called if we are
  using MSI-X with exclusive vectors.
 For MSI-X we can just assume it was meant for us. 
  Most of the initialization at module load time is done here.
 To enable queue_pair functionality. 
	
	  Verify that the VMCI Device supports the capabilities that
	  we need. If the device is missing capabilities that we would
	  like to use, check for fallback capabilities and use those
	  instead (so we can run a new VM on old hosts). Fail the load if
	  a required capability is missing and there is no fallback.
	 
	  Right now, we need datagrams. There are no fallbacks.
	
	  Use 64-bit PPNs if the device supports.
	 
	  There is no check for the return value of dma_set_mask_and_coherent
	  since this driver can handle the default mask values if
	  dma_set_mask_and_coherent fails.
	
	  If the hardware supports notifications, we will use that as
	  well.
 Let the host know which capabilities we intend to use. 
 Set up global device so that we can start sending datagrams 
	
	  Register notification bitmap with device if that capability is
	  used.
 Check host capabilities. 
 Enable device. 
	
	  We subscribe to the VMCI_EVENT_CTX_ID_UPDATE here so we can
	  update the internal context id when needed.
	
	  Enable interrupts.  Try MSI-X first, then MSI, and then fallback on
	  legacy interrupts.
	
	  Request IRQ for legacy or MSI interrupts, or for first
	  MSI-X vector.
	
	  For MSI-X with exclusive vectors we need to request an
	  interrupt for each vector so that we get a separate
	  interrupt handler routine.  This allows us to distinguish
	  between the vectors.
 Enable specific interrupt bits. 
 Enable interrupts. 
 The rest are managed resources and will be freed by PCI core 
	
	  Free IRQ and then disable MSIMSI-X as appropriate.  For
	  MSI-X, we might have multiple vectors, each with their own
	  IRQ, which we must free too.
		
		  The device reset above cleared the bitmap state of the
		  device, so we can safely free it here.
 The rest are managed resources and will be freed by PCI core 
 SPDX-License-Identifier: GPL-2.0
  Host AP crypt: host-based TKIP encryption implementation for Host AP driver
  Copyright (c) 2003-2004, Jouni Malinen <jkmaline@cc.hut.fi>
 scratch buffers for virt_to_page() (crypto API) 
 Initialize the 80-bit TTAK from TSC (IV32) and TA[0..5] 
	 Make temporary area overlap WEP seed so that the final copy can be
	  avoided on little endian hosts.
 Step 1 - make copy of TTAK and bring in TSC 
 Step 2 - 96-bit bijective mixing using S-box 
	 Step 3 - bring in last of TK bits, assign 24-bit WEP IV value
	  WEPSeed[0..2] is transmitted as WEP IV
 Ext IV included ;
				 Previously cached Phase1 result was already
				  lost, so it needs to be recalculated for the
				  next packet.
	 Update real counters only after Michael MIC verification has
	  completed
 Remove IV and ICV 
 DA 
 SA 
 DA 
 SA 
 DA 
 SA 
 DA 
 SA 
 priority 
 reserved 
 TODO: needed parameters: count, keyid, key type, TSC 
	 Update TSC counters for RX now that the packet verification has
	  completed.
 TSC is initialized to 1 
 Return the sequence number of the last transmitted frame. 
 IV + ExtIV 
 ICV 
 MIC 
 SPDX-License-Identifier: GPL-2.0
 IEEE 802.11 SoftMAC layer
  Copyright (c) 2005 Andrea Merello <andrea.merello@gmail.com>
  Mostly extracted from the rtl8180-sa2400 driver for the
  in-kernel generic ieee802.11 stack.
  Some pieces of code might be stolen from ipw2100 driver
  copyright of who own it's copyright ;-)
  PS wx handler mostly stolen from hostap, copyright who
  own it's copyright ;-)
 FIXME: add A freqs 
 if setting by freq convert to channel 
 hack to fall through 
 Set the channel 
 We want avoid to give to the user inconsistent infos
 use ifconfig hw ether 
	 just to avoid to give inconsistent infos in the
	  get wx method. not really needed otherwise
 We want avoid to give to the user inconsistent infos
 no auto select 
 notify AP to be in PS mode 
 wait for ps packet to be kicked out successfully 
 Notify AP that I wake up again 
 intentionally forget to up sem 
	 this is just to be sure that the GET wx callback
	  has consistent infos. not needed otherwise
 this is mostly stolen from hostap 
 this is stolen from hostap 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Contact Information: wlanfae <wlanfae@realtek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Contact Information: wlanfae <wlanfae@realtek.com>
 SPDX-License-Identifier: GPL-2.0
  Original code based Host AP (software wireless LAN access point) driver
  for Intersil Prism22.53 - hostap.o module, common routines
  Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
  <jkmaline@cc.hut.fi>
  Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
  Copyright (c) 2004, Intel Corporation
  Few modifications for Realtek's Wi-Fi drivers by
  Andrea Merello <andrea.merello@gmail.com>
  A special thanks goes to Realtek for their support !
 Called only as a tasklet (software IRQ) 
 Called only as a tasklet (software IRQ) 
 Reserve enough space to fit maximum frame length 
 LLC  +
 alignment  +
 WEP  +
 WDS  +
 QOS Control 
		 received a fragment of a frame for which the head fragment
		  should have already been received
 Called only as a tasklet (software IRQ) 
 rtllib_rx_frame_mgtmt
  Responsible for handling management control frames
  Called by rtllib_rx
	 On the struct stats definition there is written that
	  this is not mandatory.... but seems that the probe
	  response parser uses it
 See IEEE 802.1H for LLCSNAP encapsulationdecapsulation
  Ethernet-II snap header (RFC1042 for most EtherTypes)
 Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) 
 No encapsulation header if EtherType < 0x600 (=length) 
 Called by rtllib_rx_frame_decrypt 
 check that the frame is unicast frame to us 
 ToDS frame with own addr BSSID and DA 
 FromDS frame with own addr as DA 
 check for port access entity Ethernet type 
 Called only as a tasklet (software IRQ), by rtllib_rx 
 Called only as a tasklet (software IRQ), by rtllib_rx 
 this function is stolen from ipw2200 driver
 out-of-order fragment 
 convert hdr + possible LLC headers into Ethernet header 
				 remove RFC1042 or Bridge-Tunnel encapsulation
				  and replace EtherType
 Leave Ethernet header part of hdr and full payload 
 Indicate the packets to upper layer 
 802.11 crc not sufficient 
 Rx Reorder initialize condition.
 Drop out the packet which SeqNum is smaller than WinStart 
	 Sliding window manipulation. Conditions includes:
	  1. Incoming SeqNum is equal to WinStart =>Window shift 1
	  2. Incoming SeqNum is larger than the WinEnd => Window shift N
	 Indication process.
	  After Packet dropping and Sliding Window shifting as above, we can
	  now just indicate the packets with the SeqNum smaller than latest
	  WinStart and struct buffer other packets.
	 
	  For Rx Reorder condition:
	  1. All packets with SeqNum smaller than WinStart => Indicate
	  2. All packets with SeqNum larger than or equal to
	 	 WinStart => Buffer it.
 Current packet is going to be indicated.
 Current packet is going to be inserted into pending list.
			 Make a reorder entry and insert
			  into a the packet list.
			 Packets are dropped if there are not enough reorder
			  entries. This part should be modified!! We can just
			  indicate all the packets in struct buffer and get
			  reorder entries.
 Check if there is any packet need indicate.
 This protect struct buffer from overflow. 
	 Handling pending timer. Set this timer to prevent from long time
	  Rx buffering.
 just for debug purpose 
		 altered by clark 3302010
		  The struct buffer size of the skb indicated to upper layer
		  must be less than 5000, or the defraged IP datagram
		  in the IP layer will exceed "ipfrag_high_tresh" and be
		  discarded. so there must not use the function
		  "skb_copy" and "skb_clone" for "skb".
 Allocate new skb for releasing to upper layer 
 Offset 12 denote 2 mac address 
 move the data point to data content 
		 altered by clark 3302010
		  The struct buffer size of the skb indicated to upper layer
		  must be less than 5000, or the defraged IP datagram
		  in the IP layer will exceed "ipfrag_high_tresh" and be
		  discarded. so there must not use the function
		  "skb_copy" and "skb_clone" for "skb".
 Allocate new skb for releasing to upper layer 
 Filter frames from different BSS 
 Filter packets sent by an STA that will be forwarded by AP 
	 Nullfunc frames may have PS-bit set, so they must be passed to
	  hostap_handle_sta_rx() before being dropped here.
 packets from our adapter are dropped (echo) 
 {broad,multi}cast packets to our BSS go through 
		 allow NULL decrypt to indicate an station specific override
		  for default encryption
			 This seems to be triggered by some (multicast?)
			  frames from other than current BSS, so just drop the
			  frames silently instead of filling system log with
			  these reports.
			 copy first fragment (including full headers) into
			  beginning of the fragment cache skb
			 append frame payload to the end of the fragment
			  cache skb
			 more fragments expected - leave the skb in fragment
			  cache for now; it will be delivered to upper layers
			  after all fragments have been received
		 this was the last fragment and the frame will be
		  delivered, so remove skb from fragment cache
	 skb: hdr + (possible reassembled) full MSDU payload; possibly still
	  encryptedauthenticated
ieee->ieee802_1x &&
			 pass unencrypted EAPOL frames even if encryption is
			  configured
			 convert hdr + possible LLC headers
			  into Ethernet header
				 remove RFC1042 or Bridge-Tunnel encapsulation
				  and replace EtherType
				 Leave Ethernet header part of hdr
				  and full payload
 Indicate the packets to upper layer 
 802.11 crc not sufficient 
Filter pkt not to me
Filter pkt has too small length 
 Filter Duplicate pkt 
 Filter CTRL Frame 
 Filter MGNT Frame 
 Filter WAPI DATA Frame 
 Update statstics for AP roaming 
 Data frame - extract srcdst addresses 
 Filter Data frames 
 Send pspoll based on moredata 
			 more data bit is set, let's request a new frame
			  from the AP
 Get crypt if encrypted 
 Decrypt data frame (including reassemble) 
 Get TS for Rx Reorder  
 Parse rx data frame (For AMSDU) 
 skb: hdr + (possible reassembled) full plaintext payload 
 to parse amsdu packets 
 qos data packets & reserved bit is 1 
		 only to free rxb, and not submit the packets
		  to upper layer
 Update WAPI PN 
 Check if leave LPS 
 Indicate packets to upper layer or Rx Reorder 
	 Returning 0 indicates to caller that we have not handled the SKB--
	  so it is still allocated and can be used again by underlying
	  hardware as a DMA target
 All received frames are sent to this function. @skb contains the frame in
  IEEE 802.11 format, i.e., in the format it was sent over air.
  This function is called only as a tasklet (software IRQ).
 Make ther structure we read from the beacon packet has the right values 
 Parse a QoS parameter element 
 Parse a QoS information element 
 Write QoS parameters from the ac parameters. 
 BIT(0) | BIT(3) 
 BIT(4) | BIT(5) 
 BIT(6) | BIT(7) 
 BIT(1) | BIT(2) 
 WMM spec P.11: The minimum value for AIFSN shall be 2 
 we have a generic data element which it may contain QoS information or
  parameters element. check the information element length to decide
  which type to read
			 We stop processing but don't return an error here
			  because some misbehaviour APs break this rule. ie.
			  Orinoco AP1000.
 TODO 
 Pull out fixed field data 
 Where to pull this? beacon->listen_interval;
 for A band (No DS info) 
	 A network is only a duplicate if the channel, BSSID, ESSID
	  and the capability field (in particular IBSS and BSS) all match.
	  We treat all <hidden> with the same BSSID and channel
	  as one network
 qos related parameters 
	 The network parsed correctly -- so now we scan our known networks
	  to see if we can find it in our list.
	 
	  NOTE:  This search is definitely not optimized.  Once its doing
	 	the "right thing" we'll optimize it for efficiency if
	 	necessary
	 Search for this entry in the list and update it if it is
	  already there.
	 If we didn't find a match, then get a new network slot to initialize
	  with this beacon's information
 If there are no more slots, expire the oldest 
 Otherwise just pull from the free list 
		 we have an entry and we are going to update it. But this
		   entry may be already expired. In this case we do the same
		  as we found a new net and call the new_net handler
 SPDX-License-Identifier: GPL-2.0
 Host AP crypt: host-based CCMP encryption implementation for Host AP driver
  Copyright (c) 2003-2004, Jouni Malinen <jkmaline@cc.hut.fi>
 scratch buffers for virt_to_page() (crypto API) 
	 In CCM, the initial vectors (IV) used for CTR mode encryption and CBC
	  mode authentication are not allowed to collide, yet both are derived
	  from the same vector. We only set L := 1 here to indicate that the
	  data size can be represented in (L+1) bytes. The CCM layer will take
	  care of storing the data length in the top (L+1) bytes and setting
	  and clearing the other bits as is required to derive the two IVs.
 Nonce: QC | A2 | PN 
	 AAD:
	  FC with bits 4..6 and 11..13 masked to zero; 14 is always one
	  A1 | A2 | A3
	  SC with bits 4..15 (seq#) masked to zero
	  A4 (if present)
	  QC (if present)
 all bits masked 
 rest of QC masked 
 Ext IV included ;
 Remove hdr and MIC 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2004 Intel Corporation. All rights reserved.
  Portions of this file are based on the WEP enablement code provided by the
  Host AP project hostap-drivers v0.1.3
  Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
  <jkmaline@cc.hut.fi>
  Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
  Contact Information:
  James P. Ketrenos <ipw2100-admin@linux.intel.com>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
 Default fragmentation threshold is maximum payload size 
 Default to enabling full open WEP with host based encryptdecrypt 
 Default to supporting 802.1x 
 SAM FIXME 
 SPDX-License-Identifier: GPL-2.0
 IEEE 802.11 SoftMAC layer
  Copyright (c) 2005 Andrea Merello <andrea.merello@gmail.com>
  Mostly extracted from the rtl8180-sa2400 driver for the
  in-kernel generic ieee802.11 stack.
  Few lines might be stolen from other part of the rtllib
  stack. Copyright who own it's copyright
  WPA code stolen from the ipw2200 driver.
  Copyright who own it's copyright.
 returns the total length needed for placing the RATE MFIE
  tag and the EXTENDED RATE MFIE tag if needed.
  It encludes two bytes per tag for the tag itself and its len
 place the MFIE rate, tag to the memory (double) pointed.
  Then it updates the pointer so that
  it points after the new MFIE tag added.
	 We may add an option for custom rates that specific HW
	  might support
	 We may add an option for custom rates that specific HW might
	  support
 if the queue is full but we have newer frames then
  just overwrites the oldest.
  if (nh == ieee->mgmt_queue_tail)
 		return -1;
 called with 2nd param 0, no mgmt lock required 
 avoid watchdog triggers 
 check whether the managed packet queued greater than 5 
			 insert the skb packet to the management queue
			 
			  as for the completion function, it does not need
			  to check it any more.
 avoid watchdog triggers 
 Enables network monitor mode, all rx packets will be received. 
 Disables network monitor mode. Only packets destinated to
  us will be received.
 Enables the specialized promiscuous mode required by Intel.
  In this mode, Intel intends to hear traffics fromto other STAs in the
  same BSS. Therefore we don't have to disable checking BSSID and we only need
  to allow all dest. BUT: if we enable checking BSSID then we can't recv
  packets from other STA.
 Disables the specialized promiscuous mode required by Intel.
  See MgntEnableIntelPromiscuousMode for detail.
 this performs syncro scan blocking the caller until all channels
  in the allowed channel map has been checked.
 scan completed 
		 this function can be called in two situations
		  1- We have switched to ad-hoc mode and we are
		     performing a complete syncro scan before conclude
		     there are no interesting cell and to create a
		     new one. In this case the link state is
		     RTLLIB_NOLINK until we found an interesting cell.
		     If so the ieee8021_new_net, called by the RX path
		     will set the state to RTLLIB_LINKED, so we stop
		     scanning
		  2- We are linked and the root uses run iwlist scan.
		     So we switch to RTLLIB_LINKED_SCANNING to remember
		     that we are still logically linked (not interested in
		     new network events, despite for updating the net list,
		     but we are temporarly 'unlinked' as the driver shall
		     not filter RX frames and the channel is changing.
		  So the only situation in which are interested is to check
		  if the state become LINKED because of the #1 situation
		 this prevent excessive time wait when we
		  need to wait for a syncro scan to end..
 no good chans 
 called with ieee->lock held 
 called with wx_mutex held 
	 don't scan, and avoid to have the RX path possibily
	  try again to associate. Even do not react to AUTH or
	  ASSOC response. Just wait for the retry wq to be scheduled.
	  Here we will check if there are good nets to associate
	  with, so we retry or just get back to NO_LINK and scanning
	 we are interested in new new only if we are not associated
	  and we are not associating  authenticating
		 if the user specified the AP MAC, we need also the essid
		  This could be obtained by beacons or, if the network does not
		  broadcast it, it can be put manually.
		 if the user set the AP check if match.
		  if the network does not broadcast essid we check the
		 	 user supplied ANY essid
		  if the network does broadcast and the user does not set
		 	 essid it is OK
		  if the network does broadcast and the user did set essid
		  check if essid match
		  if the ap is not set, check that the user set the bssid
		  and the network does broadcast and that those two bssid match
			 Save the essid so that if it is hidden, it is
			  replaced with the essid provided by the user.
 Join the network for the first time 
		 if the state become different that NOLINK means
		  we had found what we are searching for
 corrupted 
 point to the len field 
 point to the last data byte of the tag 
 point to the next tag 
 ssid not found in tagged param 
	 there's no need to nofity AP that I find you buffered
	  with broadcast packet
 2 wake, 1 sleep, 0 do nothing 
 Null frame with PS bit set 
		 if the card report not success we can't be sure the AP
		  has not RXed so we can't assume the AP believe us awake
 21112005 - tx again null without PS bit if lost 
 station support qos 
 Let the register setting default with Legacy station 
 aid could not been allocated 
 Dummy wirless mode setting to avoid encryption issue 
TODO
	 FIXME for now repeat all the association procedure
	  both for disassociation and deauthentication
 following are for a simpler TX queue management.
  Instead of using netif_[stopwake]_queue the driver
  will use these two functions (plus a reset one), that
  will internally use the kernel netif_ and takes
  care of the ieee802.11 fragmentation.
  So the driver receives a fragment per time and might
  call the stop function when it wants to not
  have enough room to TX an entire packet.
  This might be useful if each fragment needs it's own
  descriptor, thus just keep a total free memory > than
  the max fragmentation threshold is not enough.. If the
  ieee802.11 stack passed a TXB struct then you need
  to keep N free descriptors where
  N = MAX_PACKET_SIZE  MIN_FRAG_TRESHOLD
  In this way you need just one and the 802.11 stack
  will take care of buffering fragments and pass them to
  the driver later, when it wakes the queue.
 called with 2nd parm 0, no tx mgmt lock required 
 update the tx status 
	 if xmit available, just xmit it immediately, else just insert it to
	  the wait queue
			 insert the skb packet to the wait queue
			  as for the completion function, it does not need
			  to check it any more.
 called in user context only 
 reset hardware status 
	 iwconfig mode ad-hoc will schedule this and return
	  on the other hand this will block further iwconfig SET
	  operations because of the wx_mutex hold.
	  Anyway some most set operations set a flag to speed-up
	  (abort) this wq (when syncro scanning) before sleeping
	  on the mutex
 check if we have this cell in our network list 
	 if not then the state is not linked. Maybe the user switched to
	  ad-hoc mode just after being in monitor mode, or just after
	  being very few time in managed mode (so the card have had no
	  time to scan all the chans..) or we have just run up the iface
	  after setting ad-hoc mode. So we have to give another try..
	  Here, in ibss mode, should be safe to do this without extra care
	  (in bss mode we had to make sure no-one tried to associate when
	  we had just checked the ieee->state and we was going to start the
	  scan) because in ibss mode the rtllib_new_net function, when
	  finds a good net, just set the ieee->state to RTLLIB_LINKED,
	  so, at worst, we waste a bit of time to initiate an unneeded syncro
	  scan, that will stop at the first round because it sees the state
	  associated.
 the network definitively is not here.. create a new cell 
 this is called only in user context, with wx_mutex held 
	 check if we have already found the net we
	  are interested in (if any).
	  if not (we are disassociated and we are not
	  in associating  authenticating phase) start the background scanning.
	 ensure no-one start an associating process (thus setting
	  the ieee->state to rtllib_ASSOCIATING) while we
	  have just checked it and we are going to enable scan.
	  The rtllib_new_net function is always called with
	  lock held (from both rtllib_softmac_check_all_nets and
	  the rx path), so we cannot be in the middle of such function
 called only in userspace context 
	 until we do not set the state to RTLLIB_NOLINK
	  there are no possibility to have someone else trying
	  to start an association procedure (we get here with
	  ieee->state = RTLLIB_ASSOCIATING).
	  When we set the state to RTLLIB_NOLINK it is possible
	  that the RX path run an attempt to associate, but
	  both rtllib_softmac_check_all_nets and the
	  RX path works with ieee->lock held so there are no
	  problems. If we are still disassociated then start a scan.
	  the lock here is necessary to ensure no one try to start
	  an association procedure when we have just checked the
	  state and we are going to start the scan.
 no channel found 
	 if the user set the MAC of the ad-hoc cell and then
	  switch to managed mode, shall we  make sure that association
	  attempts does not fail just because the user provide the essid
	  and the nic is still checking for the AP MAC ??
 simply judge  
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
  Contact Information:
  James P. Ketrenos <ipw2100-admin@linux.intel.com>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
  Few modifications for Realtek's Wi-Fi drivers by
  Andrea Merello <andrea.merello@gmail.com>
  A special thanks goes to Realtek for their support !
 802.11 Data Frame
  802.11 frame_control for data frames - 2 bytes
       ,--------------------------------------------------------------------.
  bits | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |  9 |  a |  b  |  c  |  d  | e  |
       |---|---|---|---|---|---|---|---|---|----|----|-----|-----|-----|----|
  val  | 0 | 0 | 0 | 1 | x | 0 | 0 | 0 | 1 |  0 |  x |  x  |  x  |  x  | x  |
       |---|---|---|---|---|---|---|---|---|----|----|-----|-----|-----|----|
  desc |  ver  | type  |  ^-subtype-^  |to |from|more|retry| pwr |more |wep |
       |       |       | x=0 data      |DS | DS |frag|     | mgm |data |    |
       |       |       | x=1 data+ack  |   |    |    |     |     |     |    |
       '--------------------------------------------------------------------'
                                            \
                                            |
  802.11 Data Frame                         |
           ,--------- 'ctrl' expands to >---'
           |
        ,--'---,-------------------------------------------------------------.
  Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
        |------|------|---------|---------|---------|------|---------|------|
  Desc. | ctrl | dura |  DARA  |   TA    |    SA   | Sequ |  Frame  |  fcs |
        |      | tion | (BSSID) |         |         | ence |  data   |      |
        `--------------------------------------------------|         |------'
  Total: 28 non-data bytes                                 `----.----'
                                                                |
         .- 'Frame data' expands to <---------------------------'
         |
         V
        ,---------------------------------------------------.
  Bytes |  1   |  1   |    1    |    3     |  2   |  0-2304 |
        |------|------|---------|----------|------|---------|
  Desc. | SNAP | SNAP | Control |Eth Tunnel| Type | IP      |
        | DSAP | SSAP |         |          |      | Packet  |
        | 0xAA | 0xAA |0x03 (UI)|0x00-00-F8|      |         |
        `-----------------------------------------|         |
  Total: 8 non-data bytes                         `----.----'
                                                       |
         .- 'IP Packet' expands, if WEP enabled, to <--'
         |
         V
        ,-----------------------.
  Bytes |  4  |   0-2296  |  4  |
        |-----|-----------|-----|
  Desc. | IV  | Encrypted | ICV |
        |     | IP Packet |     |
        `-----------------------'
  Total: 8 non-data bytes
  802.3 Ethernet Data Frame
        ,-----------------------------------------.
  Bytes |   6   |   6   |  2   |  Variable |   4  |
        |-------|-------|------|-----------|------|
  Desc. | Dest. | Source| Type | IP Packet |  fcs |
        |  MAC  |  MAC  |      |	   |      |
        `-----------------------------------------'
  Total: 18 non-data bytes
  In the event that fragmentation is required, the incoming payload is split
  into N parts of size ieee->fts.  The first fragment contains the SNAP header
  and the remaining packets are just data.
  If encryption is enabled, each fragment payload size is reduced by enough
  space to add the prefix and postfix (IV and ICV totalling 8 bytes in
  the case of WEP) So if you have 1500 bytes of payload with ieee->fts set to
  500 without encryption it will take 3 frames.  With WEP it will take 4 frames
  as the payload of each frame is reduced to 492 bytes.
  SKB visualization
  ,- skb->data
  |
  |    ETHERNET HEADER        ,-<-- PAYLOAD
  |                           |     14 bytes from skb->data
  |  2 bytes for Type --> ,T. |     (sizeof ethhdr)
  |                       | | |
  |,-Dest.--. ,--Src.---. | | |
  |  6 bytes| | 6 bytes | | | |
  v         | |         | | | |
  0         | v       1 | v | v           2
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
      ^     | ^         | ^ |
      |     | |         | | |
      |     | |         | `T' <---- 2 bytes for Type
      |     | |         |
      |     | '---SNAP--' <-------- 6 bytes for SNAP
      |     |
      `-IV--' <-------------------- 4 bytes for IV (WEP)
       SNAP HEADER
	 To encrypt, frame format is:
	  IV (4 bytes), clear payload (including SNAP), ICV (4 bytes)
	 Host-based IEEE 802.11 fragmentation for TX is not yet supported, so
	  call both MSDU and MPDU encryption functions from here.
 VO -> VI 
 VI -> BE 
 BE -> BK 
 Ensure zero initialized 
	 If there is no driver handler to take the TXB, don't bother
	  creating it...
 Save source and destination addresses 
 Advance the SKB to the start of the payload 
 Determine total amount of storage required for TXB packets 
			 To DS: Addr1 = BSSID, Addr2 = SA,
			  Addr3 = DA
			 not FromTo DS: Addr1 = DA, Addr2 = SA,
			  Addr3 = BSSID
		 Determine fragmentation size based on destination (multicast
		  and broadcast are not fragmented)
 in case we are a client verify acm is not set for this ac 
		 Determine amount of payload per fragment.  Regardless of if
		  this stack is providing the full 802.11 header, one will
		  eventually be affixed to this fragment -- so we must account
		  for it when determining the amount of payload space.
		 Each fragment may need to have room for encrypting
		  prepostfix
		 Number of fragments is the total bytes_per_frag 
		  payload_per_fragment
		 When we allocate the TXB we allocate enough space for the
		  reserve and full fragment bytes (bytes_per_frag doesn't
		  include prefix, postfix, header, FCS, etc.)
			 If this is not the last fragment, then add the
			  MOREFRAGS bit to the frame control
 The last fragment has the remaining length 
 Put a SNAP header on the first fragment 
 Advance the SKB... 
			 Encryption routine will move the header forward in
			  order to insert the IV between the header and the
			  payload
 SPDX-License-Identifier: GPL-2.0
  Host AP crypt: host-based WEP encryption implementation for Host AP driver
  Copyright (c) 2002-2004, Jouni Malinen <jkmaline@cc.hut.fi>
 start WEP IV from a random value 
 Perform WEP encryption on given skb that has at least 4 bytes of headroom
  for IV and 4 bytes of tailroom for ICV. Both IV and ICV will be transmitted,
  so the payload length increases with 8 bytes.
  WEP frame payload: IV + TX key idx, RC4(data), ICV = RC4(CRC32(data))
	 Fluhrer, Mantin, and Shamir have reported weaknesses in the key
	  scheduling algorithm of RC4. At least IVs (KeyByte + 3, 0xff, N)
	  can be used to speedup attacks, so avoid using them.
 Prepend 24-bit IV to RC4 key and TX frame 
 Copy rest of the WEP key (the secret part) 
 Append little-endian CRC32 and encrypt it to produce ICV 
 Perform WEP decryption on given struct buffer. Buffer includes whole WEP
  part of the frame: IV (4 bytes), encrypted payload (including SNAP header),
  ICV (4 bytes). len includes both IV and ICV.
  Returns 0 if frame was decrypted successfully and ICV was correct and -1 on
  failure. If frame is OK, IV and ICV will be removed.
 Copy rest of the WEP key (the secret part) 
 Apply RC4 to data and compute CRC32 over decrypted data 
 ICV mismatch - drop frame 
 Remove IV and ICV 
 IV 
 ICV 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Contact Information:
  wlanfae <wlanfae@realtek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Contact Information: wlanfae <wlanfae@realtek.com>
	 unmark bEnableHT flag here is the same reason why unmarked in
	  function rtllib_softmac_new_net. WB 2008.09.10
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2004 Intel Corporation. All rights reserved.
  Portions of this file are based on the WEP enablement code provided by the
  Host AP project hostap-drivers v0.1.3
  Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
  <jkmaline@cc.hut.fi>
  Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
  Contact Information:
  James P. Ketrenos <ipw2100-admin@linux.intel.com>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
 First entry MUST be the AP MAC address 
 Remaining entries will be displayed in the order we provide them 
 Add the ESSID 
 Add the protocol name 
 Add mode 
 Add frequencychannel 
 Add encryption capability 
 Add basic and extended rates 
 Add quality statistics 
 TODO: Fix these values... 
 add info for WZC 
	 Add EXTRA: Age to display seconds since last beaconprobe response
	  for given network.
		 Check all the keys to see if any are still configured,
		  and if no key index was provided, de-init them all
		 changing to use WEP; deinit previously used algorithm
		  on this key
 take WEP into use 
 If a new key was provided, set it up 
		 This ensures a key will be activated if no key is
		  explicitly set
 Set a default key of all 0 
 No key data - just set the default TX key index 
	 For now we just support WEP, so only set that security level...
	  TODO: When WPA is added this is one place that needs to change
 40 and 104 bit WEP 
	 Do not reset port if card is in Managed mode since resetting will
	  generate new IEEE 802.11 authentication which may end up in looping
	  with IEEE 802.1X.  If your hardware requires a reset after WEP
	  configuration (for example... Prism2), implement the reset_port in
	  the callbacks structures used to initialize the 802.11 stack.
 some Cisco APs use idx>0 for unicast in dynamic WEP 
 Don't set sec level for group keys. 
		 Host AP driver does not use these parameters and allows
		  wpa_supplicant to control them internally.
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Contact Information: wlanfae <wlanfae@realtek.com>
---------------------------Define Local Constant---------------------------
 12 dB 
 11 dB 
 -24 dB 
---------------------------Define Local Constant---------------------------
------------------------Define global variable-----------------------------
------------------------Define global variable-----------------------------
------------------------Define local variable------------------------------
------------------------Define local variable------------------------------
---------------------Define local function prototype-----------------------
---------------------Define local function prototype-----------------------
---------------------------Define function prototype------------------------
-----------------------------------------------------------------------------
  Function:	dm_CtrlInitGainBeforeConnectByRssiAndFalseAlarm()
  Overview:	Driver monitor RSSI and False Alarm to change initial gain.
			Only change initial gain during link in progress.
  Input:		IN	PADAPTER	pAdapter
  Output:		NONE
  Return:		NONE
  Revised History:
 	When		Who		Remark
 	03042009	hpfan	Create Version 0.
---------------------------Define function prototype------------------------
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Contact Information: wlanfae <wlanfae@realtek.com>
 Informative stuff (to choose between different interface) 
 To give an idea... 
	 In theory this value should be the maximum benchmarked
	  TCPIP throughput, because with most of these devices the
	  bit rate is meaningless (overhead an co) to estimate how
	  fast the connection will go and pick the fastest one.
	  I suggest people to play with Netperf or any benchmark...
 NWID (or domain id) 
 Minimal NWID we are able to set 
 Maximal NWID we are able to set 
 Old Frequency (backward compat - moved lower ) 
 Scan capabilities 
 ~130 Mbs real (802.11n) 
 signal level threshold range 
 Updated all three 
 > 8% missed beacons is 'bad' 
 Updated all three 
 Event capability (kernel + driver) 
 active 
 no auto select 
 can't be disabled 
 we have not this support for this radio 
 we have not this support for this radio 
 the following rule need to be following,
  Odd : get (world access),
  even : set (root access)
SIOCIWSECONDPRIV
 -100 dBm 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Based on the r8180 driver, which is:
  Copyright 2004-2005 Andrea Merello <andrea.merello@gmail.com>, et al.
  Contact Information: wlanfae <wlanfae@realtek.com>
 RTL8225 Radio frontend 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Contact Information: wlanfae <wlanfae@realtek.com>
 Swap endian - firmware is packaged in invalid endiannes
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Based on the r8180 driver, which is:
  Copyright 2004-2005 Andrea Merello <andrea.merello@gmail.com>, et al.
  Contact Information: wlanfae <wlanfae@realtek.com>
 BSSIDR 2 byte alignment 
 no matter what checkpatch says, the braces are needed 
 no matter what checkpatch says, braces are needed 
 check this 
sCrcLng);
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Based on the r8180 driver, which is:
  Copyright 2004-2005 Andrea Merello <andrea.merello@gmail.com>, et al.
  Contact Information: wlanfae <wlanfae@realtek.com>
 Driver name   
 PCI_ID table  
 probe fn      
 remove fn 
   -----------------------------IO STUFF-------------------------
   -----------------------------GENERAL FUNCTION-------------------------
  -------------------------------WATCHDOG STUFF---------------------------
  ---------------------------- NIC TXRX STUFF---------------------------
 QueryRxPwrPercentage 
		 if allocation of new skb failed - drop current packet
		  and reuse skb
sCrcLng);
 unicast packet 
  ---------------------------- NIC STARTCLOSE STUFF---------------------------
  ---------------------------- PCI_STUFF---------------------------
 If the revisionid is 0x10, the device uses rtl8192se. 
  ------------------- module init  exit stubs ----------------
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Contact Information: wlanfae <wlanfae@realtek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Contact Information: wlanfae <wlanfae@realtek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Contact Information: wlanfae <wlanfae@realtek.com>
Define local function prototype
for (Number of RF paths)
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Based on the r8180 driver, which is:
  Copyright 2004-2005 Andrea Merello <andrea.merello@gmail.com>, et al.
  Contact Information: wlanfae <wlanfae@realtek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Based on the r8180 driver, which is:
  Copyright 2004-2005 Andrea Merello <andrea.merello@gmail.com>, et al.
  Contact Information: wlanfae <wlanfae@realtek.com>
 RTL8225 Radio frontend 
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Based on the r8180 driver, which is:
  Copyright 2004-2005 Andrea Merello <andrea.merello@gmail.com>, et al.
  Contact Information: wlanfae <wlanfae@realtek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Contact Information: wlanfae <wlanfae@realtek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Contact Information: wlanfae <wlanfae@realtek.com>
 SPDX-License-Identifier: GPL-2.0
  Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  Based on the r8180 driver, which is:
  Copyright 2004-2005 Andrea Merello <andrea.merello@gmail.com>, et al.
  Contact Information: wlanfae <wlanfae@realtek.com>
 EEPROM is configured as x16 
 SPDX-License-Identifier: GPL-2.0
   driversusbgadgetemxx_udc.c
      EMXX FCD (Function Controller Driver) for USB.
   Copyright (C) 2010 Renesas Electronics Corporation
===========================================================================
 Prototype 
static void _nbu2ss_ep0_disable(struct nbu2ss_udc );
===========================================================================
 Macro 
===========================================================================
 Global 
-------------------------------------------------------------------------
 Read 
-------------------------------------------------------------------------
 Write 
-------------------------------------------------------------------------
 Set Bit 
-------------------------------------------------------------------------
 Clear Bit 
-------------------------------------------------------------------------
 UDC_DEBUG_DUMP 
-------------------------------------------------------------------------
 Endpoint 0 Callback (Complete) 
-------------------------------------------------
 SET_FEATURE 
-------------------------------------------------------------------------
 Initialization usb_request 
-------------------------------------------------------------------------
 Acquisition of the first address of RAM(FIFO) 
 Single Buffer 
 Double Buffer 
-------------------------------------------------------------------------
 Construction of Endpoint 
-------------------------------------------------------------
 RAM Transfer Address 
-------------------------------------------------------------
 Interrupt Enable 
-------------------------------------------------------------
 Endpoint Type(Mode) 
   Bulk, Interrupt, ISO 
---------------------------------------------------------
 OUT 
---------------------------------------------------------
 IN 
-------------------------------------------------------------------------
 Release of Endpoint 
-------------------------------------------------------------
 RAM Transfer Address 
-------------------------------------------------------------
 Interrupt Disable 
---------------------------------------------------------
 OUT 
---------------------------------------------------------
 IN 
-------------------------------------------------------------------------
 DMA setting (without Endpoint 0) 
 Not Support DMA 
---------------------------------------------------------
 OUT 
---------------------------------------------------------
 Transfer Direct 
---------------------------------------------------------
 DMA Mode etc. 
---------------------------------------------------------
 IN 
---------------------------------------------------------
 DMA Mode etc. 
-------------------------------------------------------------------------
 DMA setting release 
 VBUS OFF 
 Not Support DMA 
---------------------------------------------------------
 OUT 
---------------------------------------------------------
 IN 
-------------------------------------------------------------------------
 Abort DMA 
 DCR1_EPN_REQEN Clear 
-------------------------------------------------------------------------
 Start IN Transfer 
 Writing of 1-4 bytes 
 Writing of 1-4 bytes 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 Endpoint 0 OUT Transfer (PIO) 
 PIO Read 
-------------------------------------------------------------------------
 Endpoint 0 OUT Transfer (PIO, OverBytes) 
-------------------------------------------------------------------------
 Endpoint 0 IN Transfer (PIO) 
------------------------------------------------------------
 Transfer Length 
------------------------------------------------------------
 PIO 
-------------------------------------------------------------------------
 Endpoint 0 IN Transfer (PIO, OverBytes) 
-------------------------------------------------------------------------
 Transfer NULL Packet (Epndoint 0) 
-------------------------------------------------------------------------
 Receive NULL Packet (Endpoint 0) 
-------------------------------------------------------------------------
 IN Data Buffer 
-------------------------------------------------------------
 End confirmation 
 Transfer End 
-------------------------------------------------------------
 NAK release 
-------------------------------------------------------------
 Data transfer 
-------------------------------------------------------------------------
-------------------------------------------------------------
 Receive data confirmation 
-------------------------------------------------------------
 End confirmation 
 Transfer End 
 Short Packet Transfer End 
---------------------------------------------------
 NACK release 
-------------------------------------------------------------------------
 DMA is forwarded 
 DMA Address 
 Number of transfer packets 
 Burst OFF 
-------------------------------------------------------------------------
 DMA is forwarded 
---------------------------------------------------------
 Copy of every four bytes 
---------------------------------------------------------
 Copy of fraction byte 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------
 Receive Length 
-------------------------------------------------------------------------
 MaxPacketSize 
 Last Packet Data Size 
 IN Data Size 
 DMA is forwarded 
 MAX Packet Size 
------------------------------------------------------------
 Number of transmission packets 
 Packet setting 
 Address setting 
 Packet and DMA setting 
 Packet setting of EPC 
DMA setting of EPC 
-------------------------------------------------------------------------
 DMA is forwarded 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------
 State confirmation of FIFO 
 Not Empty 
 Not Empty 
-------------------------------------------------------------
 Start transfer 
-------------------------------------------------------------------------
 EP0 
 EPN 
 OUT 
 IN 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
	Endpoint Toggle Reset 
-------------------------------------------------------------------------
	Endpoint STALL set 
 Set STALL 
 Clear STALL 
 Set STALL 
 Clear STALL 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 ep0 state control 
--------------------------------------
 Status Stage 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 Send Stall 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 DMA is forwarded 
---------------------------------------------------------
 remainder of data 
-----------------------------------------
 0 Length Packet 
---------------------------------------------------------
 Complete 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 Interrupt Status 
 Interrupt Clear 
 pr_warn("=== %s(%d) req == NULL\n", __func__, epnum); 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 Endpoint Disable 
 DMA Disable 
 called with irqs blocked 
-------------------------------------------------------------------------
 Endpoint n 
-------------------------------------------------------------------------
 D+ Pullup 
 D+ Pulldown 
-------------------------------------------------------------------------
 EP0 
 EPN 
-------------------------------------------------------------------------
 Reset 
 1us wait 
 1ms wait 
 1us wait 
 EP0 
 USB Interrupt Enable 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 chattering 
 wait (ms) 
 VBUS ON Check
 VBUS OFF 
 _nbu2ss_reset_controller(udc); 
 wait (5ms) 
 VBUS ON 
 UDC_DEBUG_DUMP 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 VBUS (GPIO153) Interrupt 
-------------------------------------------------------------------------
 Interrupt (udc) 
 USB Reset 
 Resume 
 Suspend 
 EP INT 
-------------------------------------------------------------------------
 usb_ep_ops 
 DMA setting 
 Endpoint setting 
-------------------------------------------------------------------------
 dequeue request 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 catch various bogus parameters 
-------------------------------------------------------------------------
 catch various bogus parameters 
 pr_err("%s, bad param(1)\n", __func__); 
 make sure it's actually queued on this endpoint 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 usb_gadget_ops 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 platform_driver 
 init Endpoint 
 init Gadget 
 udc->gadget.is_dualspeed = 1; 
 	probe - binds to the platform device
 require IO memory and IRQ to be provided as resources 
 IO Memory 
 USB Function Controller Interrupt 
 Driver Initialization 
 Error 
 VBUS Interrupt 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 Interrupt Handler - Release 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
 SPDX-License-Identifier: GPL-2.0
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  Copyright (C) 2008 Cavium Networks
  Some parts of the code were originally released under BSD license:
  Copyright (c) 2003-2010 Cavium Networks (support@cavium.com). All rights
  reserved.
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:
     Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
     Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation andor other materials provided
      with the distribution.
     Neither the name of Cavium Networks nor the names of
      its contributors may be used to endorse or promote products
      derived from this software without specific prior written
      permission.
  This Software, including technical data, may be subject to U.S. export
  control laws, including the U.S. Export Administration Act and its associated
  regulations, and may be subject to export or import regulations in other
  countries.
  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
  AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR
  WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
  THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION
  OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
  SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
  MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
  VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
  CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR
  PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
  enum cvmx_usb_speed - the possible USB device speeds
  @CVMX_USB_SPEED_HIGH: Device is operation at 480Mbps
  @CVMX_USB_SPEED_FULL: Device is operation at 12Mbps
  @CVMX_USB_SPEED_LOW:  Device is operation at 1.5Mbps
  enum cvmx_usb_transfer - the possible USB transfer types
  @CVMX_USB_TRANSFER_CONTROL:	   USB transfer type control for hub and status
 				   transfers
  @CVMX_USB_TRANSFER_ISOCHRONOUS: USB transfer type isochronous for low
 				   priority periodic transfers
  @CVMX_USB_TRANSFER_BULK:	   USB transfer type bulk for large low priority
 				   transfers
  @CVMX_USB_TRANSFER_INTERRUPT:   USB transfer type interrupt for high priority
 				   periodic transfers
  enum cvmx_usb_direction - the transfer directions
  @CVMX_USB_DIRECTION_OUT: Data is transferring from Octeon to the devicehost
  @CVMX_USB_DIRECTION_IN:  Data is transferring from the devicehost to Octeon
  enum cvmx_usb_status - possible callback function status codes
  @CVMX_USB_STATUS_OK:		  The transaction  operation finished without
 				  any errors
  @CVMX_USB_STATUS_SHORT:	  FIXME: This is currently not implemented
  @CVMX_USB_STATUS_CANCEL:	  The transaction was canceled while in flight
 				  by a user call to cvmx_usb_cancel
  @CVMX_USB_STATUS_ERROR:	  The transaction aborted with an unexpected
 				  error status
  @CVMX_USB_STATUS_STALL:	  The transaction received a USB STALL response
 				  from the device
  @CVMX_USB_STATUS_XACTERR:	  The transaction failed with an error from the
 				  device even after a number of retries
  @CVMX_USB_STATUS_DATATGLERR:	  The transaction failed with a data toggle
 				  error even after a number of retries
  @CVMX_USB_STATUS_BABBLEERR:	  The transaction failed with a babble error
  @CVMX_USB_STATUS_FRAMEERR:	  The transaction failed with a frame error
 				  even after a number of retries
  struct cvmx_usb_port_status - the USB port status information
  @port_enabled:	1 = Usb port is enabled, 0 = disabled
  @port_over_current:	1 = Over current detected, 0 = Over current not
 			detected. Octeon doesn't support over current detection.
  @port_powered:	1 = Port power is being supplied to the device, 0 =
 			power is off. Octeon doesn't support turning port power
 			off.
  @port_speed:		Current port speed.
  @connected:		1 = A device is connected to the port, 0 = No device is
 			connected.
  @connect_change:	1 = Device connected state changed since the last set
 			status call.
  struct cvmx_usb_iso_packet - descriptor for Isochronous packets
  @offset:	This is the offset in bytes into the main buffer where this data
 		is stored.
  @length:	This is the length in bytes of the data.
  @status:	This is the status of this individual packet transfer.
  enum cvmx_usb_initialize_flags - flags used by the initialization function
  @CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI:    The USB port uses a 12MHz crystal
 					      as clock source at USB_XO and
 					      USB_XI.
  @CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND:   The USB port uses 122448MHz 2.5V
 					      board clock source at USB_XO.
 					      USB_XI should be tied to GND.
  @CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK: Mask for clock speed field
  @CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ:    Speed of reference clock or
 					      crystal
  @CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ:    Speed of reference clock
  @CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ:    Speed of reference clock
  @CVMX_USB_INITIALIZE_FLAGS_NO_DMA:	      Disable DMA and used polled IO for
 					      data transfer use for the USB
 Bits 3-4 used to encode the clock frequency 
  enum cvmx_usb_pipe_flags - internal flags for a pipe.
  @CVMX_USB_PIPE_FLAGS_SCHEDULED: Used internally to determine if a pipe is
 				   actively using hardware.
  @CVMX_USB_PIPE_FLAGS_NEED_PING: Used internally to determine if a high speed
 				   pipe is in the ping state.
 Maximum number of times to retry failed transactions 
 Maximum number of hardware channels supported by the USB block 
  The low level hardware can transfer a maximum of this number of bytes in each
  transfer. The field is 19 bits wide
  The low level hardware can transfer a maximum of this number of packets in
  each transfer. The field is 10 bits wide
  Logical transactions may take numerous low level
  transactions, especially when splits are concerned. This
  enum represents all of the possible stages a transaction can
  be in. Note that split completes are always even. This is so
  the NAK handler can backup to the previous low level
  transaction with a simple clearing of bit 0.
  struct cvmx_usb_transaction - describes each pending USB transaction
 				 regardless of type. These are linked together
 				 to form a list of pending requests for a pipe.
  @node:		List node for transactions in the pipe.
  @type:		Type of transaction, duplicated of the pipe.
  @flags:		State flags for this transaction.
  @buffer:		User's physical buffer address to readwrite.
  @buffer_length:	Size of the user's buffer in bytes.
  @control_header:	For control transactions, physical address of the 8
 			byte standard header.
  @iso_start_frame:	For ISO transactions, the starting frame number.
  @iso_number_packets:	For ISO transactions, the number of packets in the
 			request.
  @iso_packets:	For ISO transactions, the sub packets in the request.
  @actual_bytes:	Actual bytes transfer for this transaction.
  @stage:		For control transactions, the current stage.
  @urb:		URB.
  struct cvmx_usb_pipe - a pipe represents a virtual connection between Octeon
 			  and some USB device. It contains a list of pending
 			  request to the device.
  @node:		List node for pipe list
  @next:		Pipe after this one in the list
  @transactions:	List of pending transactions
  @interval:		For periodic pipes, the interval between packets in
 			frames
  @next_tx_frame:	The next frame this pipe is allowed to transmit on
  @flags:		State flags for this pipe
  @device_speed:	Speed of device connected to this pipe
  @transfer_type:	Type of transaction supported by this pipe
  @transfer_dir:	IN or OUT. Ignored for Control
  @multi_count:	Max packet in a row for the device
  @max_packet:		The device's maximum packet size in bytes
  @device_addr:	USB device address at other end of pipe
  @endpoint_num:	USB endpoint number at other end of pipe
  @hub_device_addr:	Hub address this device is connected to
  @hub_port:		Hub port this device is connected to
  @pid_toggle:		This toggles between 01 on every packet send to track
 			the data pid needed
  @channel:		Hardware DMA channel for this pipe
  @split_sc_frame:	The low order bits of the frame number the split
 			complete should be sent on
  struct octeon_hcd - the state of the USB block
  lock:		   Serialization lock.
  init_flags:		   Flags passed to initialize.
  index:		   Which USB block this is for.
  idle_hardware_channels: Bit set for every idle hardware channel.
  usbcx_hprt:		   Stored port status so we don't need to read a CSR to
 			   determine splits.
  pipe_for_channel:	   Map channels to pipes.
  pipe:		   Storage for pipes.
  indent:		   Used by debug output to indent functions.
  port_status:		   Last port status used for change notification.
  idle_pipes:		   List of open pipes that have no transactions.
  active_pipes:	   Active pipes indexed by transfer type.
  frame_number:	   Increments every SOF interrupt for time keeping.
  active_split:	   Points to the current active split, or NULL.
 serialization lock 
  This macro logically sets a single field in a CSR. It does the sequence
  read, modify, and write
 Returns the IO address to pushpop stuff data from the FIFOs 
  struct octeon_temp_buffer - a bounce buffer for USB transfers
  @orig_buffer: the original buffer passed by the USB stack
  @data:	 the newly allocated temporary buffer (excluding meta-data)
  Both the DMA engine and FIFO mode will always transfer full 32-bit words. If
  the buffer is too short, we need to allocate a temporary one, and this struct
  represents it.
  octeon_alloc_temp_buffer - allocate a temporary buffer for USB transfer
                             (if needed)
  @urb:	URB.
  @mem_flags:	Memory allocation flags.
  This function allocates a temporary bounce buffer whenever it's needed
  due to HW limitations.
  octeon_free_temp_buffer - free a temporary buffer used by USB transfers.
  @urb: URB.
  Frees a buffer allocated by octeon_alloc_temp_buffer().
  octeon_map_urb_for_dma - Octeon-specific map_urb_for_dma().
  @hcd:	USB HCD structure.
  @urb:	URB.
  @mem_flags:	Memory allocation flags.
  octeon_unmap_urb_for_dma - Octeon-specific unmap_urb_for_dma()
  @hcd:	USB HCD structure.
  @urb:	URB.
  Read a USB 32bit CSR. It performs the necessary address swizzle
  for 32bit CSRs and logs the value in a readable format if
  debugging is on.
  @usb:     USB block this access is for
  @address: 64bit address to read
  Returns: Result of the read
  Write a USB 32bit CSR. It performs the necessary address
  swizzle for 32bit CSRs and logs the value in a readable format
  if debugging is on.
  @usb:     USB block this access is for
  @address: 64bit address to write
  @value:   Value to write
  Return non zero if this pipe connects to a non HIGH speed
  device through a high speed hub.
  @usb:    USB block this access is for
  @pipe:   Pipe to check
  Returns: Non zero if we need to do split transactions
  Trivial utility function to return the correct PID for a pipe
  @pipe:   pipe to check
  Returns: PID for pipe
 Data1 
 Data0 
 Loops through register until txfflsh or rxfflsh become zero.
	
	  Program the USBC_GRXFSIZ register to select the size of the receive
	  FIFO (25%).
	
	  Program the USBC_GNPTXFSIZ register to select the size and the start
	  address of the non-periodic transmit FIFO for nonperiodic
	  transactions (50%).
	
	  Program the USBC_HPTXFSIZ register to select the size and start
	  address of the periodic transmit FIFO for periodic transactions
	  (25%).
 Flush all FIFOs 
  Shutdown a USB port after a call to cvmx_usb_initialize().
  The port should be disabled with all pipes closed when this
  function is called.
  @usb: USB device state populated by cvmx_usb_initialize().
  Returns: 0 or a negative error code.
 Make sure all pipes are closed 
 Disable the clocks and put them in power on reset 
  Initialize a USB port for use. This must be called before any
  other access to the Octeon USB port is made. The port starts
  off in the disabled state.
  @dev:	 Pointer to struct device for logging purposes.
  @usb:	 Pointer to struct octeon_hcd.
  Returns: 0 or a negative error code.
	
	  Power On Reset and PHY Initialization
	 
	  1. Wait for DCOK to assert (nothing to do)
	 
	  2a. Write USBN01_CLK_CTL[POR] = 1 and
	      USBN01_CLK_CTL[HRST,PRST,HCLK_RST] = 0
	
	  2b. Select the USB reference clockcrystal parameters by writing
	      appropriate values to USBN01_CLK_CTL[P_C_SEL, P_RTYPE, P_COM_ON]
		
		  The USB port uses 122448MHz 2.5V board clock
		  source at USB_XO. USB_XI should be tied to GND.
		  Most Octeon evaluation boards require this setting
 From CN56XX,CN50XX,CN31XX,CN30XX manuals 
 p_rclk=1 & p_xenbn=0 
 From CN52XX manual 
		
		  The USB port uses a 12MHz crystal as clock source
		  at USB_XO and USB_XI
 From CN31XX,CN30XX manual 
 p_rclk=1 & p_xenbn=1 
 From CN56XX,CN52XX,CN50XX manuals. 
	
	  2c. Select the HCLK via writing USBN01_CLK_CTL[DIVIDE, DIVIDE2] and
	      setting USBN01_CLK_CTL[ENABLE] = 1. Divide the core clock down
	      such that USB is as close as possible to 125Mhz
 Lower than 4 doesn't seem to work properly 
 2d. Write USBN01_CLK_CTL[HCLK_RST] = 1 
 2e.  Wait 64 core-clock cycles for HCLK to stabilize 
	
	  3. Program the power-on reset field in the USBN clock-control
	     register:
	     USBN_CLK_CTL[POR] = 0
 4. Wait 1 ms for PHY clock to start 
	
	  5. Program the Reset input from automatic test equipment field in the
	     USBP control and status register:
	     USBN_USBP_CTL_STATUS[ATE_RESET] = 1
 6. Wait 10 cycles 
	
	  7. Clear ATE_RESET field in the USBN clock-control register:
	     USBN_USBP_CTL_STATUS[ATE_RESET] = 0
	
	  8. Program the PHY reset field in the USBN clock-control register:
	     USBN_CLK_CTL[PRST] = 1
	
	  9. Program the USBP control and status register to select host or
	     device mode. USBN_USBP_CTL_STATUS[HST_MODE] = 0 for host, = 1 for
	     device
 10. Wait 1 us 
	
	  11. Program the hreset_n field in the USBN clock-control register:
	      USBN_CLK_CTL[HRST] = 1
 12. Proceed to USB core initialization 
	
	  USB Core Initialization
	 
	  1. Read USBC_GHWCFG1, USBC_GHWCFG2, USBC_GHWCFG3, USBC_GHWCFG4 to
	     determine USB core configuration parameters.
	 
	     Nothing needed
	 
	  2. Program the following fields in the global AHB configuration
	     register (USBC_GAHBCFG)
	     DMA mode, USBC_GAHBCFG[DMAEn]: 1 = DMA mode, 0 = slave mode
	     Burst length, USBC_GAHBCFG[HBSTLEN] = 0
	     Nonperiodic TxFIFO empty level (slave mode only),
	     USBC_GAHBCFG[NPTXFEMPLVL]
	     Periodic TxFIFO empty level (slave mode only),
	     USBC_GAHBCFG[PTXFEMPLVL]
	     Global interrupt mask, USBC_GAHBCFG[GLBLINTRMSK] = 1
	
	  3. Program the following fields in USBC_GUSBCFG register.
	     HSFS timeout calibration, USBC_GUSBCFG[TOUTCAL] = 0
	     ULPI DDR select, USBC_GUSBCFG[DDRSEL] = 0
	     USB turnaround time, USBC_GUSBCFG[USBTRDTIM] = 0x5
	     PHY low-power clock select, USBC_GUSBCFG[PHYLPWRCLKSEL] = 0
	
	  4. The software must unmask the following bits in the USBC_GINTMSK
	     register.
	     OTG interrupt mask, USBC_GINTMSK[OTGINTMSK] = 1
	     Mode mismatch interrupt mask, USBC_GINTMSK[MODEMISMSK] = 1
 We need RX FIFO interrupts if we don't have DMA 
	
	  Disable all channel interrupts. We'll enable them per channel later.
	
	  Host Port Initialization
	 
	  1. Program the host-port interrupt-mask field to unmask,
	     USBC_GINTMSK[PRTINT] = 1
	
	  2. Program the USBC_HCFG register to select full-speed host
	     or high-speed host.
	
	  If the controller is getting port events right after the reset, it
	  means the initialization failed. Try resetting the controller again
	  in such case. This is seen to happen after cold boot on DSR-1000N.
  Reset a USB port. After this call succeeds, the USB port is
  online and servicing requests.
  @usb: USB device state populated by cvmx_usb_initialize().
 Program the port reset bit to start the reset process 
	
	  Wait at least 50ms (high speed), or 10ms (full speed) for the reset
	  process to complete.
 Program the port reset bit to 0, USBC_HPRT[PRTRST] = 0 
	
	  Read the port speed field to get the enumerated speed,
	  USBC_HPRT[PRTSPD].
  Disable a USB port. After this call the USB port will not
  generate data transfers and will not generate events.
  Transactions in process will fail and call their
  associated callbacks.
  @usb: USB device state populated by cvmx_usb_initialize().
  Returns: 0 or a negative error code.
 Disable the port 
  Get the current state of the USB port. Use this call to
  determine if the usb port has anything connected, is enabled,
  or has some sort of error condition. The return value of this
  call has "changed" bits to signal of the value of some fields
  have changed between calls.
  @usb: USB device state populated by cvmx_usb_initialize().
  Returns: Port status information
  Open a virtual pipe between the host and a USB device. A pipe
  must be opened before data can be transferred between a device
  and Octeon.
  @usb:	     USB device state populated by cvmx_usb_initialize().
  @device_addr:
 		     USB device address to open the pipe to
 		     (0-127).
  @endpoint_num:
 		     USB endpoint number to open the pipe to
 		     (0-15).
  @device_speed:
 		     The speed of the device the pipe is going
 		     to. This must match the device's speed,
 		     which may be different than the port speed.
  @max_packet:	     The maximum packet length the device can
 		     transmitreceive (low speed=0-8, full
 		     speed=0-1023, high speed=0-1024). This value
 		     comes from the standard endpoint descriptor
 		     field wMaxPacketSize bits <10:0>.
  @transfer_type:
 		     The type of transfer this pipe is for.
  @transfer_dir:
 		     The direction the pipe is in. This is not
 		     used for control pipes.
  @interval:	     For ISOCHRONOUS and INTERRUPT transfers,
 		     this is how often the transfer is scheduled
 		     for. All other transfers should specify
 		     zero. The units are in frames (8000sec at
 		     high speed, 1000sec for full speed).
  @multi_count:
 		     For high speed devices, this is the maximum
 		     allowed number of packet per microframe.
 		     Specify zero for non high speed devices. This
 		     value comes from the standard endpoint descriptor
 		     field wMaxPacketSize bits <12:11>.
  @hub_device_addr:
 		     Hub device address this device is connected
 		     to. Devices connected directly to Octeon
 		     use zero. This is only used when the device
 		     is fulllow speed behind a high speed hub.
 		     The address will be of the high speed hub,
 		     not and full speed hubs after it.
  @hub_port:	     Which port on the hub the device is
 		     connected. Use zero for devices connected
 		     directly to Octeon. Like hub_device_addr,
 		     this is only used for fulllow speed
 		     devices behind a high speed hub.
  Returns: A non-NULL value is a pipe. NULL means an error.
	
	  All pipes use interval to rate limit NAK processing. Force an
	  interval if one wasn't supplied
 Force start splits to be schedule on uFrame 0 
	
	  We don't need to tell the hardware about this pipe yet since
	  it doesn't have any submitted requests
  Poll the RX FIFOs and remove data as needed. This function is only used
  in non DMA mode. It is very important that this function be called quickly
  enough to prevent FIFO overflow.
  @usb:	USB device state populated by cvmx_usb_initialize().
 Only read data if IN data is there 
 Check if no data is available 
 Get where the DMA engine would have written this data 
 Loop writing the FIFO data for this packet into memory 
  Fill the TX hardware fifo with data out of the software
  fifos
  @usb:	    USB device state populated by cvmx_usb_initialize().
  @fifo:	    Software fifo to use
  @available:	    Amount of space in the hardware fifo
  Returns: Non zero if the hardware fifo was too small and needs
 	    to be serviced again.
	
	  We're done either when there isn't anymore space or the software FIFO
	  is empty
 Limit the amount of data to what the SW fifo has 
 Update the next locations and counts 
		
		  Write the HW fifo data. The read every three writes is due
		  to an errata on CN3XXX chips
  Check the hardware FIFOs and fill them as needed
  @usb:	USB device state populated by cvmx_usb_initialize().
  Fill the TX FIFO with an outgoing packet
  @usb:	  USB device state populated by cvmx_usb_initialize().
  @channel:	  Channel number to get packet from
 We only need to fill data on outbound channels 
 OUT Splits only have data on the start and not the complete 
	
	  Find out how many bytes we need to fill and convert it into 32bit
	  words.
  Perform channel specific setup for Control transactions. All
  the generic stuff will already have been done in cvmx_usb_start_channel().
  @usb:	  USB device state populated by cvmx_usb_initialize().
  @channel:	  Channel to setup
  @pipe:	  Pipe for control transaction
 Setup 
 All Control operations start with a setup going OUT 
		
		  Setup send the control header instead of the buffer data. The
		  buffer data will be used in the next stage
 Setup 
 All Control operations start with a setup going OUT 
	
	  Make sure the transfer never exceeds the byte limit of the hardware.
	  Further bytes will be sent as continued transactions
 Round MAX_TRANSFER_BYTES to a multiple of out packet size 
	
	  Calculate the number of packets to transfer. If the length is zero
	  we still need to transfer one packet
		
		  Limit to one packet when not using DMA. Channels must be
		  restarted between every packet for IN transactions, so there
		  is no reason to do multiple packets in a row
		
		  Limit the number of packet and data transferred to what the
		  hardware can handle
  Start a channel to perform the pipe's head transaction
  @usb:	  USB device state populated by cvmx_usb_initialize().
  @channel:	  Channel to setup
  @pipe:	  Pipe to start
 Make sure all writes to the DMA region get flushed 
 Attach the channel to the pipe 
 Mark this channel as in use 
 Enable the channel interrupt bits 
 Clear all channel status bits 
			
			  Channels need these extra interrupts when we aren't
			  in DMA mode.
				
				  Splits don't generate xfercompl, so we need
				  ACK and NYET.
 Enable the channel interrupt to propagate 
 Setup the location the DMA engine uses. 
 Setup both the size of the transfer and the SPLIT characteristics 
		
		  ISOCHRONOUS transactions store each individual transfer size
		  in the packet structure, not the global buffer_length
		
		  We need to do split transactions when we are talking to non
		  high speed devices that are behind a high speed hub
			
			  On the start split phase (stage is even) record the
			  frame number we will need to send the split complete.
			  We only store the lower two bits since the time ahead
			  can only be two frames
			
			  SPLIT transactions can only ever transmit one data
			  packet so limit the transfer size to the max packet
			  size
			
			  ISOCHRONOUS OUT splits are unique in that they limit
			  data transfers to 188 byte chunks representing the
			  beginmiddleend of the data or all
				
				  Clear the split complete frame number as
				  there isn't going to be a split complete
				
				  See if we've started this transfer and sent
				  data
					
					  Nothing sent yet, this is either a
					  begin or the entire payload
 Entire payload in one go 
 First part of payload 
					
					  Continuing the previous data, we must
					  either be in the middle or at the end
 End of payload 
 Middle of payload 
				
				  Again, the transfer size is limited to 188
				  bytes
		
		  Make sure the transfer never exceeds the byte limit of the
		  hardware. Further bytes will be sent as continued
		  transactions
			
			  Round MAX_TRANSFER_BYTES to a multiple of out packet
			  size
		
		  Calculate the number of packets to transfer. If the length is
		  zero we still need to transfer one packet
			
			  Limit to one packet when not using DMA. Channels must
			  be restarted between every packet for IN
			  transactions, so there is no reason to do multiple
			  packets in a row
			
			  Limit the number of packet and data transferred to
			  what the hardware can handle
 Update the DATA0DATA1 toggle 
		
		  High speed pipes may need a hardware ping before they start
 Setup the Host Channel Characteristics Register 
		
		  Set the startframe oddeven properly. This is only used for
		  periodic
		
		  Set the number of back to back packets allowed by this
		  endpoint. Split transactions interpret "ec" as the number of
		  immediate retries of failure. These retries happen too
		  quickly, so we disable these entirely for splits
 Set the rest of the endpoint specific settings 
 Do transaction type specific fixups as needed 
			
			  ISO transactions require different PIDs depending on
			  direction and how many packets are needed
 Need DATA0 
 Need MDATA 
 Remember when we start a split transaction 
  Find a pipe that is ready to be scheduled to hardware.
  @usb:	 USB device state populated by cvmx_usb_initialize().
  @xfer_type:	 Transfer type
  Returns: Pipe or NULL if none are ready
 Find a pipe needing service. 
		
		  Only process periodic pipes on SOF interrupts. This way we
		  are sure that the periodic data is sent in the beginning of
		  the frame.
  Called whenever a pipe might need to be scheduled to the
  hardware.
  @usb:	 USB device state populated by cvmx_usb_initialize().
  @is_sof:	 True if this schedule was called on a SOF interrupt.
		
		  Without DMA we need to be careful to not schedule something
		  at the end of a frame and cause an overrun.
 Find an idle channel 
	
	  Only enable SOF interrupts when we have transactions pending in the
	  future that might need to be scheduled
	 For Isochronous transactions we need to update the URB packet status
	  list from data in our private copy
		
		  The pointer to the private list is stored in the setup_packet
		  field.
 Recalculate the transfer size by adding up each packet 
 Free the private list now that we don't need it anymore 
  Signal the completion of a transaction and free it. The
  transaction will be removed from the pipe transaction list.
  @usb:	 USB device state populated by cvmx_usb_initialize().
  @pipe:	 Pipe the transaction is on
  @transaction:
 		 Transaction that completed
  @complete_code:
 		 Completion code
 If this was a split then clear our split in progress marker 
	
	  Isochronous transactions need extra processing as they might not be
	  done after a single data transfer
 Update the number of bytes transferred in this ISO packet 
		
		  If there are more ISOs pending and we succeeded, schedule the
		  next one
 No bytes transferred for this packet as of yet 
 One less ISO waiting to transfer 
 Increment to the next location in our packet array 
 Remove the transaction from the pipe list 
  Submit a usb transaction to a pipe. Called for all types
  of transactions.
  @usb:
  @pipe:	    Which pipe to submit to.
  @type:	    Transaction type
  @buffer:	    User buffer for the transaction
  @buffer_length:
 		    User buffer's length in bytes
  @control_header:
 		    For control transactions, the 8 byte standard header
  @iso_start_frame:
 		    For ISO transactions, the start frame
  @iso_number_packets:
 		    For ISO, the number of packet in the transaction.
  @iso_packets:
 		    A description of each ISO packet
  @urb:	    URB for the callback
  Returns: Transaction or NULL on failure.
 FIXME: This is not used, implement it. 
		
		  We may need to schedule the pipe if this was the head of the
		  pipe.
  Call to submit a USB Bulk transfer to a pipe.
  @usb:	    USB device state populated by cvmx_usb_initialize().
  @pipe:	    Handle to the pipe for the transfer.
  @urb:	    URB.
  Returns: A submitted transaction or NULL on failure.
 control_header 
 iso_start_frame 
 iso_number_packets 
 iso_packets 
  Call to submit a USB Interrupt transfer to a pipe.
  @usb:	    USB device state populated by cvmx_usb_initialize().
  @pipe:	    Handle to the pipe for the transfer.
  @urb:	    URB returned when the callback is called.
  Returns: A submitted transaction or NULL on failure.
 control_header 
 iso_start_frame 
 iso_number_packets 
 iso_packets 
  Call to submit a USB Control transfer to a pipe.
  @usb:	    USB device state populated by cvmx_usb_initialize().
  @pipe:	    Handle to the pipe for the transfer.
  @urb:	    URB.
  Returns: A submitted transaction or NULL on failure.
 iso_start_frame 
 iso_number_packets 
 iso_packets 
  Call to submit a USB Isochronous transfer to a pipe.
  @usb:	    USB device state populated by cvmx_usb_initialize().
  @pipe:	    Handle to the pipe for the transfer.
  @urb:	    URB returned when the callback is called.
  Returns: A submitted transaction or NULL on failure.
 control_header 
  Cancel one outstanding request in a pipe. Canceling a request
  can fail if the transaction has already completed before cancel
  is called. Even after a successful cancel call, it may take
  a frame or two for the cvmx_usb_poll() function to call the
  associated callback.
  @usb:	 USB device state populated by cvmx_usb_initialize().
  @pipe:	 Pipe to cancel requests in.
  @transaction: Transaction to cancel, returned by the submit function.
  Returns: 0 or a negative error code.
	
	  If the transaction is the HEAD of the queue and scheduled. We need to
	  treat it special
		
		  If the channel isn't enabled then the transaction already
		  completed.
  Cancel all outstanding requests in a pipe. Logically all this
  does is call cvmx_usb_cancel() in a loop.
  @usb:	 USB device state populated by cvmx_usb_initialize().
  @pipe:	 Pipe to cancel requests in.
  Returns: 0 or a negative error code.
 Simply loop through and attempt to cancel each transaction 
  Close a pipe created with cvmx_usb_open_pipe().
  @usb:	 USB device state populated by cvmx_usb_initialize().
  @pipe:	 Pipe to close.
  Returns: 0 or a negative error code. EBUSY is returned if the pipe has
 	    outstanding transfers.
 Fail if the pipe has pending transactions 
  Get the current USB protocol level frame number. The frame
  number is always in the range of 0-0x7ff.
  @usb: USB device state populated by cvmx_usb_initialize().
  Returns: USB frame number
 This should be impossible 
			
			  For setup OUT data that are splits,
			  the hardware doesn't appear to count
			  transferred data. Here we manually
			  update the data transferred
	
	  The only time a bulk transfer isn't complete when it finishes with
	  an ACK is during a split transaction. For splits we need to continue
	  the transfer if more data is needed.
		
		  ISOCHRONOUS OUT splits don't require a complete split stage.
		  Instead they use a sequence of begin OUT splits to transfer
		  the data 188 bytes at a time. Once the transfer is complete,
		  the pipe sleeps until the next schedule interval.
			
			  If no space left or this wasn't a max size packet
			  then this transfer is complete. Otherwise start it
			  again to send the next 188 bytes
			
			  We are in the incoming data phase. Keep getting data
			  until we run out of space or get a small packet
  Poll a channel for status
  @usb:     USB device
  @channel: Channel to poll
  Returns: Zero on success
 Read the interrupt status bits for the channel 
			
			  There seems to be a bug in CN31XX which can cause
			  interrupt IN transfers to get stuck until we do a
			  write of HCCHARX without changing things
		
		  In non DMA mode the channels don't halt themselves. We need
		  to manually disable channels that are left running
 Disable all interrupts except CHHLTD 
				
				  Successful INOUT with transfer complete.
				  Channel halt isn't needed.
		
		  There is are no interrupts that we need to process when the
		  channel is still running
 Disable the channel interrupts now that it is done 
 Make sure this channel is tied to a valid pipe 
	
	  Disconnect this pipe from the HW channel. Later the schedule
	  function will figure out which pipe needs to go
	
	  Read the channel config info so we can figure out how much data
	  transferred
	
	  Calculating the number of bytes successfully transferred is dependent
	  on the transfer direction
		
		  IN transactions are easy. For every byte received the
		  hardware decrements xfersize. All we need to do is subtract
		  the current value of xfersize from its starting value and we
		  know how many bytes were written to the buffer
		
		  OUT transaction don't decrement xfersize. Instead pktcnt is
		  decremented on every successful packet send. The hardware
		  does this when it receives an ACK, or NYET. If it doesn't
		  receive one of these responses pktcnt doesn't change
		
		  The last packet may not be a full transfer if we didn't have
		  enough data
 Figure out how many bytes were in the last packet of the transfer 
	
	  As a special case, setup transactions output the setup header, not
	  the user's data. For this reason we don't count setup data as bytes
	  transferred
	
	  Add the bytes transferred to the running total. It is important that
	  bytes_this_transfer doesn't count any data that needs to be
	  retransmitted
	
	  We need to remember the PID toggle state for the next transaction.
	  The hardware already updated it for the next transaction
	
	  For high speed bulk out, assume the next transaction will need to do
	  a ping before proceeding. If this isn't true the ACK processing below
	  will clear this flag
		
		  In some rare cases the DMA engine seems to get stuck and
		  keeps substracting same byte count over and over again. In
		  such case we just need to fail every transaction.
		
		  STALL as a response means this transaction cannot be
		  completed because the device can't process transactions. Tell
		  the user. Any data that was transferred will be counted on
		  the actual bytes transferred
		
		  XactErr as a response means the device signaled
		  something wrong with the transfer. For example, PID
		  toggle errors cause these.
 Babble Error (BblErr) 
 Data toggle error 
		
		  NYET as a response is only allowed in three cases: as a
		  response to a ping, as a response to a split transaction, and
		  as a response to a bulk out. The ping case is handled by
		  hardware, so we only have splits and bulk out
			
			  If there is more data to go then we need to try
			  again. Otherwise this transaction is complete
			
			  Split transactions retry the split complete 4 times
			  then rewind to the start split and do the entire
			  transactions again
				
				  Rewind to the beginning of the transaction by
				  anding off the split complete bit
		
		  The ACK bit can only be checked after the other error bits.
		  This is because a multi packet transfer may succeed in a
		  number of packets and then get a different response on the
		  last packet. In this case both ACK and the last response bit
		  will be set. If none of the other response bits is set, then
		  the last packet must have been an ACK
		 
		  Since we got an ACK, we know we don't need to do a ping on
		  this pipe
		
		  If this was a split then clear our split in progress marker.
		
		  NAK as a response means the device couldn't accept the
		  transaction, but it should be retried in the future. Rewind
		  to the beginning of the transaction by anding off the split
		  complete bit. Retry in the next interval
 We'll retry the exact same transaction again 
			
			  We get channel halted interrupts with no result bits
			  sets when the cable is unplugged
  Poll the USB block for status and call all needed callback
  handlers. This function is meant to be called in the interrupt
  handler for the USB controller. It can also be called
  periodically in a loop for non-interrupt based operation.
  @usb: USB device state populated by cvmx_usb_initialize().
  Returns: 0 or a negative error code.
 Update the frame counter 
 Read the pending interrupts 
 Clear the interrupts now that we know about them 
		
		  RxFIFO Non-Empty (RxFLvl)
		  Indicates that there is at least one packet pending to be
		  read from the RxFIFO.
		 
		  In DMA mode this is handled by hardware
 Fill the Tx FIFOs when not in DMA mode 
		
		  Disconnect Detected Interrupt (DisconnInt)
		  Asserted when a device disconnect is detected.
		 
		  Host Port Interrupt (PrtInt)
		  The core sets this bit to indicate a change in port status of
		  one of the O2P USB core ports in Host mode. The application
		  must read the Host Port Control and Status (HPRT) register to
		  determine the exact event that caused this interrupt. The
		  application must clear the appropriate status bit in the Host
		  Port Control and Status register to clear this bit.
		 
		  Call the user's port callback
 Clear the port change bits 
		
		  Host Channels Interrupt (HChInt)
		  The core sets this bit to indicate that an interrupt is
		  pending on one of the channels of the core (in Host mode).
		  The application must read the Host All Channels Interrupt
		  (HAINT) register to determine the exact number of the channel
		  on which the interrupt occurred, and then read the
		  corresponding Host Channel-n Interrupt (HCINTn) register to
		  determine the exact cause of the interrupt. The application
		  must clear the appropriate status bit in the HCINTn register
		  to clear this bit.
 convert between an HCD pointer and the corresponding struct octeon_hcd 
		
		  For slow devices on high speed ports we need to find the hub
		  that does the speed translation so we know where to send the
		  split transactions.
			
			  Start at this device and work our way up the usb
			  tree.
				
				  If our parent is high speed then he'll
				  receive the splits.
				
				  Move up the tree one level. If we make it all
				  the way up the tree, then the port must not
				  be in high speed mode and we don't need a
				  split.
		
		  Allocate a structure to use for our private list of
		  isochronous packets.
 Fill the list with the data from the URB 
			
			  Store a pointer to the list in the URB setup_packet
			  field. We know this currently isn't being used and
			  this saves us a bunch of logic.
			
			  If submit failed we need to free our private packet
			  list.
 Nothing required here 
 Not supported on Octeon 
 Not supported on Octeon 
 Port inidicator not supported 
 Clears drivers internal connect status change flag 
			
			  Clears the driver's internal Port Reset Change flag.
			
			  Clears the driver's internal Port EnableDisable
			  Change flag.
			
			  Clears the driver's internal Port Suspend Change
			  flag, which is set when resume signaling on the host
			  port is complete.
 Clears the driver's overcurrent Change flag 
 No HUB features supported 
			
			  Program the port power bit to drive VBUS on the USB.
 Not supported 
 Defective device tree, but we know how to fix it. 
	
	  Set the DMA mask to 64bits so we get buffers already translated for
	  DMA.
	
	  Only cn52XX and cn56XX have DWC_OTG USB hardware and the
	  IOB priority registers.  Under heavy network load USB
	  hardware can be starved by the IOB causing a crash.  Give
	  it a priority boost if it has been waiting more than 400
	  cycles to avoid this situation.
	 
	  Testing indicates that a cnt_val of 8192 is not sufficient,
	  but no failures are seen with 4096.  We choose a value of
	  400 to give a safety factor of 10.
 Initialize the USB state structure 
 Due to an errata, CN31XX doesn't support DMA 
 Only use one channel with non DMA 
 CN5XXX have an errata with channel 3 
 SPDX-License-Identifier: GPL-2.0
 Un-pause the RISC 
 Pause the RISC 
 Reset the RISC 
 wait for reg to come ready 
 set up for reg read 
 wait for reg to come ready 
 get the data 
 wait for reg to come ready 
 write the data to the data reg 
 trigger the write 
 wait for reg to come ready 
 Determine if we are in charge of the firmware. If
  we are the lower of the 2 NIC pcie functions, or if
  we are the higher function and the lower function
  is not enabled.
	 If we are the lower of the 2 NIC functions
	  on the chip the we are responsible for
	  core dump and firmware reset after an error.
	 If we are the higher of the 2 NIC functions
	  on the chip and the lower function is not
	  enabled, then we are responsible for
	  core dump and firmware reset after an error.
 does flush too 
 Wait for a single mailbox command to complete.
  Returns zero on success.
 100ms 
 Execute a single mailbox command.
  Caller must hold PROC_ADDR semaphore.
	
	  Make sure there's nothing pending.
	  This shouldn't happen.
	
	  Fill the outbound mailboxes.
	
	  Wake up the MPI firmware.
 We are being asked by firmware to accept
  a change to the port.  This is only
  a change to max frame sizes (TxRx), pause
  parameters, or loopback mode. We wake up a worker
  to handler processing this since a mailbox command
  will need to be sent to ACK the request.
	 Get the status data and start up a thread to
	  handle the request.
		 Begin polled mode early so
		  we don't get another interrupt
		  when we leave mpi_worker.
 Process an inter-device event completion.
  If good, signal the caller's completion.
		 Wake up the sleeping mpi_idc_work thread that is
		  waiting for this event.
	 If we're coming back from an IDC event
	  then set up the CAM and frame routing.
	 Queue up a worker to check the frame
	  size information, and fix it if it's not
	  to our liking.
		 Begin polled mode early so
		  we don't get another interrupt
		  when we leave mpi_worker dpc.
 Process an async event and clear it unless it's an
  error condition.
   This can get called iteratively from the mpi_work thread
   when events arrive via an interrupt.
   It also gets called when a mailbox command is polling for
   it's completion.
 Just get mailbox zero for now. 
		 This case is only active when we arrive here
		  as a result of issuing a mailbox command to
		  the firmware.
		 We can only get mailbox status if we're polling from an
		  unfinished command.  Get the rest of the status data and
		  return back to the caller.
		  We only end up here when we're polling for a mailbox
		  command completion.
		 We are being asked by firmware to accept
		  a change to the port.  This is only
		  a change to max frame sizes (TxRx), pause
		  parameters, or loopback mode.
		 Process and inbound IDC event.
		  This will happen when we're trying to
		  change txrx max frame size, change pause
		  parameters or loopback mode.
		 If we're in process on executing the firmware,
		  then convert the status to normal mailbox status.
		 This event can arrive at boot time or after an
		  MPI reset if the firmware failed to initialize.
		 If we're in process on executing the firmware,
		  then convert the status to normal mailbox status.
 Need to support AEN 8110 
 Clear the MPI firmware status. 
	 Restore the original mailbox count to
	  what the caller asked for.  This can get
	  changed when a mailbox command is waiting
	  for a response and an AEN arrives and
	  is handled.
 Execute a single mailbox command.
  mbcp is a pointer to an array of u32.  Each
  element in the array contains the value for it's
  respective mailbox register.
 Begin polled mode for MPI 
 Load the mailbox registers and wake up MPI RISC. 
	 If we're generating a system error, then there's nothing
	  to wait for.
	 Wait for the command to complete. We loop
	  here because some AEN might arrive while
	  we're waiting for the mailbox command to
	  complete. If more than 5 seconds expire we can
	  assume something is wrong.
 Wait for the interrupt to come in. 
		 Process the event.  If it's an AEN, it
		  will be handled in-line or a worker
		  will be spawned. If it's our completion
		  we will catch it below.
		 It's either the completion for our mailbox
		  command complete or an AEN.  If it's our
		  completion then get out.
	 Now we can clear the interrupt condition
	  and look at our status.
 End polled mode for MPI 
 Get MPI firmware version. This will be used for
  driver banner and for ethtool info.
  Returns zero on success.
 Store the firmware version 
 Get functional state for MPI firmware.
  Returns zero on success.
	 If bit zero is set in mbx 1 then the firmware is
	  running, but not initialized.  This should never
	  happen.
 Send and ACK mailbox command to the firmware to
  let it continue with the change.
 Get link settings and maximum frame size settings
  for the current port.
  Most likely will block.
 Issue a mailbox command to dump RISC RAM. 
 Get link settings and maximum frame size settings
  for the current port.
  Most likely will block.
 IDC - Inter Device Communication...
  Some firmware commands require consent of adjacent FCOE
  function.  This function waits for the OK, or a
  counter-request for a little more time.i
  The firmware will complete the request if the other
  function doesn't respond.
		 Wait here for the command to complete
		  via the IDC process.
		 Now examine the response from the IDC process.
		  We might have a good completion or a request for
		  more wait time.
		 This indicates that the firmware is
		  already in the state we are trying to
		  change it to.
 Returns a negative error code or the mailbox command status. 
 API called in work thread context to set new TXRX
  maximum frame size values to match MTU.
 The following routines are worker threads that process
  events that may sleep waiting for completion.
 This thread gets the maximum TX and RX frame size values
  from the firmware and, if necessary, changes them to match
  the MTU setting.
 Process an inter-device request.  This is issues by
  the firmware in response to another function requesting
  a change to the port. We set a flag to indicate a change
  has been made and then send a mailbox command ACKing
  the change request.
		 Signal the resulting link up AEN
		  that the frame routing and mac addr
		  needs to be set.
 Do ACK if required 
 success 
		 These sub-commands issued by another (FCoE)
		  function are requesting to do an operation
		  on the shared resource (MPI environment).
		  We currently don't issue these so we just
		  ACK the request.
		 Drop the link, reload the routing
		  table when link comes up.
  an IDC without params 
 Do ACK if required 
 success 
 Begin polled mode for MPI 
		 Don't continue if an async event
		  did not complete properly.
 End polled mode for MPI 
	 If we're not the dominant NIC function,
	  then there is nothing to do.
 SPDX-License-Identifier: GPL-2.0-or-later
 SPDX-License-Identifier: GPL-2.0
 Read a NIC register from the alternate function. 
 Write a NIC register from the alternate function. 
 check for errors 
 wait for reg to come ready 
 set up for reg read 
 wait for reg to come ready 
 get the data 
 Read out the SERDES registers 
 wait for reg to come ready 
 set up for reg read 
 wait for reg to come ready 
 get the data 
 Dead fill any failures or invalids. 
 Dead fill any failures or invalids. 
 The XAUI needs to be read out per port 
	
	  XFI register is shared so only need to read one
	  functions and then check the bits.
 now see if i'm NIC 1 or NIC 2 
 I'm NIC 2, so the indirect (NIC1) xfi is up. 
 now see if i'm NIC 1 or NIC 2 
 I'm NIC 2, so the indirect (NIC1) xfi is up. 
 Get XAUI_AN register block. 
 Function 2 is direct	
 Function 1 is direct	
 Get XAUI_HSS_PCS register block. 
 Get XAUI_XFI_AN register block. 
 Get XAUI_XFI_TRAIN register block. 
 Get XAUI_XFI_HSS_PCS register block. 
 Get XAUI_XFI_HSS_TX register block. 
 Get XAUI_XFI_HSS_RX register block. 
 Get XAUI_XFI_HSS_PLL register block. 
 wait for reg to come ready 
 set up for reg read 
 wait for reg to come ready 
 get the data 
 Read the 400 xgmac controlstatistics registers
  skipping unused locations.
		 We're reading 400 xgmac registers, but we filter out
		  several locations that are non-responsive to reads.
 lower MAC address 
 upper MAC address 
 output 
 lower Mcast address 
 upper Mcast address 
 Read the MPI Processor shadow registers 
 Read the MPI Processor core registers 
 Read the ASIC probe dump 
 First we have to enable the probe mux 
 Read out the routing index registers 
 Read out the MAC protocol registers 
 CAM 
 Multicast MAC Address 
 VLAN filter mask 
 MC filter mask 
 FC MAC addresses 
 Mgmt MAC addresses 
 Mgmt VLAN addresses 
 Mgmt IPv4 address 
 Mgmt IPv6 address 
 Mgmt TCPUDP Dest port 
 if the read failed then dead fill the element. 
 Create a coredump segment header 
  This function should be called when a coredump  probedump
  is to be extracted from the HBA. It is assumed there is a
  qdev structure that contains the base address of the register
  space for this function as well as a coredump structure that
  will contain the dump.
	 Try to get the spinlock, but dont worry if
	  it isn't available.  If the firmware died it
	  might be holding the sem.
 Insert the global header 
 Get generic NIC reg dump 
 Get XGMac registers. (Segment 18, Rev C. step 21) 
 Odd means our function is NIC 2 
 Even means our function is NIC 1 
 Rev C. Step 20a 
 Rev C. Step 20b 
 Get the MPI Core Registers 
 Get the 16 MPI shadow registers 
 Get the Test Logic Registers 
 Get the RMII Registers 
 Get the FCMAC1 Registers 
 Get the FCMAC2 Registers 
 Get the FC1 MBX Registers 
 Get the IDE Registers 
 Get the NIC1 MBX Registers 
 Get the SMBus Registers 
 Get the FC2 MBX Registers 
 Get the NIC2 MBX Registers 
 Get the I2C Registers 
 Get the MEMC Registers 
 Get the PBus Registers 
 Get the MDE Registers 
 Segment 31 
 Get indexed register values. 
 Segment 34 (Rev C. step 23) 
 Get the semaphore registers for all 5 functions 
 Prevent the mpi restarting while we dump the memory.
 clear the pause 
 Reset the RISC so we can dump RAM 
 Insert the segment header 
 does flush too 
 segment 16 
 Segment 16, Rev C. Step 18 
 Get generic reg dump 
 Segment 31 
 Get indexed register values. 
 Segment 34 (Rev C. step 23) 
	
	  If the dump has already been taken and is stored
	  in our internal buffer and if force dump is set then
	  just start the spool to dump it to the log file
	  and also, take a snapshot of the general regs
	  to the user's buffer or else take complete dump
	  to the user's buffer if force is not set.
 SPDX-License-Identifier: GPL-2.0-only
  QLogic qlge NIC HBA Driver
  Copyright (c)  2003-2008 QLogic Corporation
  Author:     Linux qlge network device driver by
                       Ron Mercer <ron.mercer@qlogic.com>
 defaults above 
 required last entry 
 This hardware semaphore causes exclusive access to
  resources shared between the NIC driver, MPI firmware,
  FCOE firmware and the FC driver.
 flush 
 This function waits for a specific bit to come ready
  in a given register.  It is used mostly by the initialize
  process, but is also used in kernel thread API such as
  netdev->set_multi, netdev->set_mac_address, netdev->vlan_rx_add_vid.
 check for errors 
 The CFG register is used to download TX and RX control blocks
  to the chip. This function waits for an operation to complete.
 Used to issue init control blocks to hw. Maps control block,
  sets address, triggers download, waits for completion.
	
	  Wait for the bit to clear after signaling hw.
 does flush too 
 Get a specific MAC address from the CAM.  Used for debug and reg dump. 
 offset 
 index 
 type 
 offset 
 index 
 type 
 offset 
 index 
 type 
 Set up a MAC, multicast or VLAN address for the
  inbound frame matching.
 offset 
 index 
 type 
 offset 
 index 
 type 
 offset 
 index 
 type 
		 This field should also include the queue id
		  and possibly the function id.  Right now we hardcode
		  the route field to NIC core.
 route to NIC core 
		 For VLAN, the addr actually holds a bit that
		  either enables or disables the vlan id we are
		  addressing. It's either MAC_ADDR_E on or off.
		  That's bit-27 we're talking about.
 offset 
 index 
 type 
 enabledisable 
 Set or clear MAC address in hardware. We sometimes
  have to clear it to prevent wrong frame routing
  especially in a bonding environment.
 Get a specific frame routing value from the CAM.
  Used for debug and reg dump.
 The NIC function for this chip has 16 routing indexes.  Each one can be used
  to route different frame types to various inbound queues.  We send broadcast
  multicasterror frames to the default queue for slow handling,
  and CAM hitRSS frames to the fast handling queues.
 Return error if no mask match. 
 dest 
 type 
 index 
 Promiscuous Mode frames. 
 dest 
 type 
 index 
 Pass up MAC,IP,TCPUDP error frames. 
 dest 
 type 
 index 
 Pass up IP CSUM error frames. 
 dest 
 type 
 index 
 Pass up TCPUDP CSUM error frames. 
 dest 
 type 
 index 
 Pass up Broadcast frames to default Q. 
 dest 
 type 
 index 
 Pass up All Multicast frames. 
 dest 
 type 
 index 
 Pass up matched Multicast frames. 
 dest 
 type 
 index 
 Pass up matched RSS frames. 
 dest 
 type 
 index 
 Clear the E-bit on an entry. 
 dest 
 type 
 index 
 wait for reg to come ready 
 set up for reg read 
 wait for reg to come ready 
	 This data is stored on flash as an array of
	  __le32.  Since qlge_read32() returns cpu endian
	  we need to swap it back.
	 Get flash offset for function and adjust
	  for dword access.
	 Extract either manufacturer or BOFM modified
	  MAC address.
	 Second function's parameters follow the first
	  function's.
 xgmac register are located behind the xgmac_addr and xgmac_data
  register pair.  Each readwrite requires us to wait for the ready
  bit before readingwriting the data.
 wait for reg to come ready 
 write the data to the data reg 
 trigger the write 
 xgmac register are located behind the xgmac_addr and xgmac_data
  register pair.  Each readwrite requires us to wait for the ready
  bit before readingwriting the data.
 wait for reg to come ready 
 set up for reg read 
 wait for reg to come ready 
 get the data 
 This is used for reading the 64-bit statistics regs. 
	
	  Get MPI firmware version for driver banner
	  and ethool info.
 Wake up a worker to getset the TXRX frame sizes. 
 Take the MAC Core out of reset.
  Enable statistics counting.
  Take the transmitterreceiver out of reset.
  This functionality may be done in the MPI firmware at a
  later date.
		 Another function has the semaphore, so
		  wait for the port init bit to come ready.
 Set the core reset. 
 Clear the core reset and turn on jumbo for receiver. 
 Clear core reset. 
 Turn on jumbo. 
 Enable transmitter, and clear it's reset. 
 Clear the TX MAC reset. 
 Enable the transmitter. 
 Enable receiver and clear it's reset. 
 Clear the RX MAC reset. 
 Enable the receiver. 
 Turn on jumbo. 
 Signal to the world that the port is enabled.        
 last chunk of the master page 
 Update an rx ring index. 
 return 0 or negative error 
 return 0 or negative error 
	 Adjust the master page chunk for next
	  buffer get.
 return 0 or negative error 
	 Minimum number of buffers needed to be able to receive at least one
	  frame of any format:
	  sbq: 1 for header + 1 for data
	  lbq: mtu 9000  lb size
	  Below this, the queue might stall.
		 Allocations can take a long time in certain cases (ex.
		  reclaim). Therefore, use a workqueue for long-running
		  work items.
	 napi_disable() might have prevented incomplete napi work from being
	  rescheduled.
 trigger softirq processing 
 Unmaps tx buffers.  Can be called from send() if a pci mapping
  fails at some stage, or from the interrupt when a tx completes.
			
			  Unmap the skb->data area, or the
			  external sglist (AKA the Outbound
			  Address List (OAL)).
			  If its the zeroeth element, then it's
			  the skb->data area.  If it's the 7th
			  element and there is more than 6 frags,
			  then its an OAL.
 Map the buffers for this transmit.  This will return
  NETDEV_TX_BUSY or NETDEV_TX_OK based on success.
	
	  Map the skb buffer first.
	
	  This loop fills the remainder of the 8 address descriptors
	  in the IOCB.  If there are more than 7 fragments, then the
	  eighth address desc will point to an external list (OAL).
	  When this happens, the remainder of the frags will be stored
	  in this list.
			 Let's tack on an sglist.
			  Our control block will now
			  look like this:
			  iocb->seg[0] = skb->data
			  iocb->seg[1] = frag[0]
			  iocb->seg[2] = frag[1]
			  iocb->seg[3] = frag[2]
			  iocb->seg[4] = frag[3]
			  iocb->seg[5] = frag[4]
			  iocb->seg[6] = frag[5]
			  iocb->seg[7] = ptr to OAL (external sglist)
			  oal->seg[0] = frag[6]
			  oal->seg[1] = frag[7]
			  oal->seg[2] = frag[8]
			  oal->seg[3] = frag[9]
			  oal->seg[4] = frag[10]
			       etc...
 Tack on the OAL in the eighth segment of IOCB. 
			
			  The length is the number of fragments
			  that remain to be mapped times the length
			  of our sglist (OAL).
 Save the number of segments we've mapped. 
 Terminate the last segment. 
	
	  If the first frag mapping failed, then i will be zero.
	  This causes the unmap of the skb->data area.  Otherwise
	  we pass in the number of frags that mapped successfully
	  so they can be umapped.
 Categorizing receive firmware frame errors 
  qlge_update_mac_hdr_len - helper routine to update the mac header length
  based on vlan tags if present
 Look for stacked vlan tags in ethertype field 
 Process an inbound completion from an rx ring. 
 Frame error, so drop the packet. 
 Process an inbound completion from an rx ring. 
 Frame error, so drop the packet. 
 Update the MAC header length
	 The max framesize filter on this chip is set higher than
	  MTU since FCoE uses 2k frames.
 TCP frame. 
 Unfragmented ipv4 UDP frame. 
 Process an inbound completion from an rx ring. 
 Allocate new_skb and copy 
 Frame error, so drop the packet. 
 loopback self test for ethtool 
	 The max framesize filter on this chip is set higher than
	  MTU since FCoE uses 2k frames.
	 If rx checksum is on, and there are no
	  csum or frame errors.
 TCP frame. 
 Unfragmented ipv4 UDP frame. 
	 Undo the skb_reserve(skb,32) we did before
	  giving to hardware, and realign data on
	  a 2-byte boundary.
  This function builds an skb for the given inbound
  completion.  It will be rewritten for readability in the near
  future, but for not it works well.
	
	  Handle the header buffer if present.
		
		  Headers fit nicely into a small buffer.
	
	  Handle the data buffer(s).
 Is there data too? 
			
			  Data is less than small buffer size so it's
			  stuffed in a small buffer.
			  For this case we append the data
			  from the "data" small buffer to the "header" small
			  buffer.
			
			  The data is in a single large buffer.  We
			  chain it to the header buffer's skb and let
			  it rip.
			
			  The headers and data are in a single large buffer. We
			  copy it to a new skb and let it go. This can happen with
			  jumbo mtu on a non-TCPUDP frame.
		
		  The data is in a chain of large buffers
		  pointed to by a small buffer.  We loop
		  thru and chain them to the our small header
		  buffer's skb.
		  frags:  There are 18 max frags and our small
		          buffer will hold 32 of them. The thing is,
		          we'll use 3 max for our 9000 byte jumbo
		          frames.  If the MTU goes up we could
		           eventually be in trouble.
			
			  This is an non TCPUDP IP frame, so
			  the headers aren't split into a small
			  buffer.  We have to use the small buffer
			  that contains our sg list as our skb to
			  send upstairs. Copy the sg list here to
			  a local buffer and use it to find the
			  pages to chain.
 Process an inbound completion from an rx ring. 
 Frame error, so drop the packet. 
	 The max framesize filter on this chip is set higher than
	  MTU since FCoE uses 2k frames.
 loopback self test for ethtool 
	 If rx checksum is on, and there are no
	  csum or frame errors.
 TCP frame. 
 Unfragmented ipv4 UDP frame. 
 Process an inbound completion from an rx ring. 
		 The data and headers are split into
		  separate buffers.
		 The data fit in a single small buffer.
		  Allocate a new skb, copy the data and
		  return the buffer to the free pool.
		 TCP packet in a page chunk that's been checksummed.
		  Tack it on to our GRO skb and let it go.
		 Non-TCP packet in a page chunk. Allocate an
		  skb, tack it on frags, and send it up.
		 Non-TCPUDP large frames that span multiple buffers
		  can be processed corrrectly by the split frame logic.
 Process an outbound completion from an rx ring. 
 Fire up a handler to reset the MPI processor. 
	 Clear adapter up bit to signal the recovery
	  process that it shouldn't kill the reset worker
	  thread
	 Set asic recovery bit to indicate reset process that we are
	  in fatal error recovery process rather than normal close
 While there are entries in the completion queue. 
			
			  The queue got stopped because the tx_ring was full.
			  Wake it up, because it's now at least 25% empty.
 While there are entries in the completion queue. 
	 Service the TX rings first.  They start
	  right after the RSS rings.
		 If this TX completion ring belongs to this vector and
		  it's not empty then service it.
	
	  Now service the RSS ring if it's active.
  qlge_update_hw_vlan_features - helper routine to reinitialize the adapter
  based on the features to enabledisable hardware vlan accel
 update the features with resent change 
 Update the behavior of vlan accel in the adapter 
 MSI-X Multiple Vector Interrupt Handler for inbound completions. 
 This handles a fatal error, MPI activity, and the default
  rx_ring in an MSI-X multiple vector environment.
  In MSILegacy environment it also process the rest of
  the rx_rings.
	 Experience shows that when using INTx interrupts, interrupts must
	  be masked manually.
	  When using MSI mode, INTR_EN_EN must be explicitly disabled
	  (even though it is auto-masked), otherwise a later command to
	  enable it is not effective.
	
	  Check for fatal error.
	
	  Check MPI processor activity.
		
		  We've got an async event or mailbox completion.
		  Handle it and clear the source of the interrupt.
	
	  Get the bit-mask that shows the active queues for this
	  pass.  Compare it to the queues that this irq services
	  and call napi if there's a match.
		 Experience shows that the device sometimes signals an
		  interrupt but no work is scheduled from this function.
		  Nevertheless, the interrupt is auto-masked. Therefore, we
		  systematically re-enable the interrupt if we didn't
		  schedule napi.
	 We use the upper 32-bits to store the tx queue for this IO.
	  When we get the completion we can use it to establish the context.
			
			  The queue got stopped because the tx_ring was full.
			  Wake it up, because it's now at least 25% empty.
 Free all large and small rx buffers associated
  with the completion queues for this device.
 Free the small buffer queue. 
 Free the small buffer queue control blocks. 
 Free the large buffer queue. 
 Free the large buffer queue control blocks. 
 Free the rx queue. 
 Allocate queues and buffers for this completions queue based
  on the values in the parameter structure.
	
	  Allocate the completion queue for this rx_ring.
	
	  Loop through all queues and free
	  any resources.
 Allocate space for our shadow registers and such. 
 Allocate tx queue resources 
 Set up the rx ring control block and pass it to the chip.
  The control block is defined as
  "Completion Queue Initialization Control Block", or cqicb.
 Set up the shadow registers for this ring. 
 PCI doorbell mem area + 0x00 for consumer index register 
 PCI doorbell mem area + 0x04 for valid register 
 PCI doorbell mem area + 0x18 for large buffer consumer 
 PCI doorbell mem area + 0x1c 
	
	  Set up the control block load flags.
 Load queue base address 
 Load MSI-X vector 
 Load irq delay values 
 Load lbq values 
 Load sbq values 
		 Inbound completion handling rx_rings run in
		  separate NAPI contexts.
	
	  Assign doorbell registers for this tx_ring.
 TX PCI doorbell mem area for tx producer index 
 TX PCI doorbell mem area + 0x04 
	
	  Assign shadow registers for this tx_ring.
 We start by trying to get the number of vectors
  stored in qdev->intr_count. If we don't get that
  many then we reduce the count and try again.
 Get the MSIX vectors. 
		 Try to alloc space for the msix struct,
		  if it fails then go to MSIlegacy.
 Each vector services 1 RSS ring and 1 or more
  TX completion rings.  This function loops through
  the TX completion rings and assigns the vector that
  will service it.  An example would be if there are
  2 vectors (so 2 RSS rings) and 8 TX completion rings.
  This would mean that vector 0 would service RSS ring 0
  and TX completion rings 0,1,2 and 3.  Vector 1 would
  service RSS ring 1 and TX completion rings 4,5,6 and 7.
 Assign irq vectors to TX rx_rings.
		 For single vector all rings have an irq
		  of zero.
 Set the interrupt mask for this vector.  Each vector
  will service 1 RSS ring and 1 or more TX completion
  rings.  This function sets up a bit mask per vector
  that indicates which rings it services.
		 Add the RSS ring serviced by this vector
		  to the mask.
		 Add the TX ring(s) serviced by this vector
		  to the mask.
		 For single vector we just shift each queue's
		  ID into the mask.
  Here we build the intr_context structures based on
  our rx_ring count and intr vector count.
  The intr_context structure is used to hook each vector
  to possibly different handlers.
		 Each rx_ring has it's
		  own intr_context since we have separate
		  vectors for each queue.
			 Set up this vector's bit-mask that indicates
			  which queues it services.
			
			  We set up each vectors enabledisableread bits so
			  there's no bitmask calculations in the critical path.
				 The first vectorqueue handles
				  broadcastmulticast, fatal errors,
				  and firmware events.  This in addition
				  to normal inbound NAPI processing.
				
				  Inbound queues handle unicast frames only.
		
		  All rx_rings use the same intr_context since
		  there is only one vector.
		
		  We set up each vectors enabledisableread bits so
		  there's no bitmask calculations in the critical path.
			 Experience shows that when using INTx interrupts,
			  the device does not always auto-mask INTR_EN_EN.
			  Moreover, masking INTR_EN_EN manually does not
			  immediately prevent interrupt generation.
		
		  Single interrupt means one handler for all rings.
		 Set up this vector's bit-mask that indicates
		  which queues it services. In this case there is
		  a single vector so it will service all RSS and
		  TX completion rings.
	 Tell the TX completion rings which MSIx vector
	  they will be using.
	
	  Fill out the Indirection Table.
 Clear all the entries in the routing table. 
 Initialize the frame-to-queue routing. 
 Clear all the entries in the routing table. 
	 If we have more than one inbound queue, then turn on RSS in the
	  routing block.
	 If check if the link is up and use to
	  determine if we are setting or clearing
	  the MAC address in the CAM.
	
	  Set up the System register to halt on errors.
 Set the default queue, and VLAN behavior. 
 Set the MPI interrupt to enabled. 
 Enable the function, set pagesize, enable error checking. 
 Setclear header splitting. 
	 Set RX packet routing to use portpci function on which the
	  packet arrived on in addition to usual frame routing.
	  This is helpful on bonding where both interfaces can have
	  the same MAC address.
	 Reroute all packets to our Interface.
	  They may have been routed to MPI firmware
	  due to WOL.
 Sticky reg needs clearing due to WOL. 
 Default WOL is enable on Mezz cards 
 Start up the rx queues. 
	 If there is more than one inbound completion queue
	  then download a RICB to configure RSS.
 Start up the tx queues. 
 Initialize the port and set the max framesize. 
 Set up the MAC address and frame routing filter. 
 Start NAPI for the RSS queues. 
 Issue soft reset to chip. 
 Clear all the entries in the routing table. 
	 Check if bit is set then skip the mailbox command and
	  clear the bit, else we are in normal reset process.
 Stop management traffic. 
 Wait for the NIC and MGMNT FIFOs to empty. 
 Resume management traffic. 
	 The CAM is still intact after a reset, but if we
	  are doing WOL, then we may need to program the
	  routing regs. We would also need to issue the mailbox
	  commands to instruct the MPI what to do per the ethtool
	  settings.
	 Don't kill the reset worker thread if we
	  are in the process of recovery.
 Call netif_napi_del() from common point. 
	 If the port is initialized and the
	  link is up the turn on the carrier.
 Restore rx mode. 
 Restore vlan setting. 
	 If we hit pci_channel_io_perm_failure
	  failure condition, then we already
	  brought the adapter down.
	
	  Wait for device to recover from a reset.
	  (Rarely happens, but possible.)
 Make sure refill_work doesn't re-enable napi 
	 In a perfect world we have one RSS ring for each CPU
	  and each has it's own vector.  To do that we ask for
	  cpu_cnt vectors.  qlge_enable_msix() will adjust the
	  vector count to what we actually get.  We then
	  allocate an RSS ring for each.
	  Essentially, we are doing min(cpu_count, msix_vector_count).
 Adjust the RSS ring count to the actual vector count. 
		
		  The completion queue ID for the tx rings start
		  immediately after the rss rings.
 CPU to run handler on. 
			
			  Inbound (RSS) queues.
			
			  Outbound queue handles outbound completions only.
 outbound cq is same size as tx_ring it services. 
 Wait for an outstanding reset to complete. 
 Get RX stats. 
 Get TX stats. 
	
	  Set or clear promiscuous mode if a
	  transition is taking place.
	
	  Set or clear all multicast mode if a
	  transition is taking place.
 Update local copy of current mac address. 
 Restore rx mode. 
 Find the pcie function number for the other NIC
  on this chip.  Since both NIC functions share a
  common firmware we have the lowest enabled function
  do any common work.  Examples would be resetting
  after a fatal firmware error, or doing a firmware
  coredump.
 Set PCIe read request size 
 Set PCIe reset type for EEH to fundamental. 
 make sure the EEPROM is good 
 Keep local copy of current mac address. 
 Set up the default ring sizes. 
 Set up the coalescing parameters. 
	
	  Set up the operating parameters.
 vlan gets same features (except vlan filter) 
	
	  Set up net_device structure.
	 MTU range: this driver only supports 1500 or 9000, so this only
	  filters out values above or below, and we'll rely on
	  qlge_change_mtu to make sure only 1500 or 9000 are allowed
	 Start up the timer to trigger EEH if
	  the bus goes dead
 Clean up resources without touching hardware. 
 Disabling the timer 
  This callback is called by the PCI subsystem whenever
  a PCI bus error is detected.
 Request a slot reset. 
  This callback is called after the PCI buss has been reset.
  Basically, this tries to restart the card from scratch.
  This is a shortened version of the device probediscovery code,
  it resembles the first-half of the () routine.
 SPDX-License-Identifier: GPL-2.0
	 Skip the default queue, and update the outbound handler
	  queues if they changed.
 Update the inbound (RSS) handler queues if they changed. 
	
	  Get TX statistics.
	
	  Get RX statistics.
 Update receive mac error statistics 
	
	  Get Per-priority TX pause frame counter statistics.
	
	  Get Per-priority RX pause frame counter statistics.
	
	  Get RX NIC FIFO DROP statistics.
 WOL is only supported for mezz card. 
 WOL is only supported for mezz card. 
 Save the current LED settings 
 Start blinking 
 Restore LED settings 
 Give queue time to settle before testing results. 
 Offline tests 
 Online tests 
		 Give link time to come up after
		  port configuration changes.
	 This chip coalesces as follows:
	  If a packet arrives, hold off interrupts until
	  cqicb->int_delay expires, but if no other packets arrive don't
	  wait longer than cqicb->pkt_int_delay. But ethtool doesn't use a
	  timer to coalesce on a frame basis.  So, we have to take ethtool's
	  max_coalesced_frames value and convert it to a delay in microseconds.
	  We do this by using a basic thoughput of 1,000,000 frames per
	  second @ (1024 bytes).  This means one frame per usec. So it's a
	  simple one to one ratio.
 Validate user parameters. 
 Don't wait more than 10 usec. 
 Verify a change took place before updating the hardware. 
 SPDX-License-Identifier: GPL-2.0
  Mainly by David Woodhouse, somewhat modified by Jordan Crouse
  Copyright ¬© 2006-2007  Red Hat, Inc.
  Copyright ¬© 2006-2007  Advanced Micro Devices, Inc.
  Copyright ¬© 2009       VIA Technology, Inc.
  Copyright (c) 2010  Andres Salomon <dilinger@queued.net>
 Turn off the event enable for GPIO7 just to be safe 
	
	  Determine the current state by reading the GPIO bit; earlier
	  stages of the boot process have established the state.
	 
	  Note that we read GPIO_OUTPUT_VAL rather than GPIO_READ_BACK here;
	  this is because OFW will disable input for the pin and set a value..
	  READ_BACK will only contain a valid value if input is enabled and
	  then a value is set.  So, future readings of the pin can use
	  READ_BACK, but the first one cannot.  Awesome, huh?
 Set the directions for the GPIO pins 
 Set up the interrupt mappings 
 Set the IRQ to pair 2 
 Enable group 2 to trigger the DCON interrupt 
 Select edge level for interrupt (in PIC) 
 Register the interrupt handler 
 Clear INV_EN for GPIO7 (DCONIRQ) 
 Enable filter for GPIO12 (DCONBLANK) 
 Disable filter for GPIO7 
 Disable event counter for GPIO7 (DCONIRQ) and GPIO12 (DCONBLANK) 
 Add GPIO12 to the Filter Event Pair #7 
 Turn off negative Edge Enable for GPIO12 
 Enable negative Edge Enable for GPIO7 
 Zero the filter amount for Filter Event Pair #7 
 Clear the negative edge status for GPIO7 and GPIO12 
 FIXME:  Clear the positive status as well, just to be sure 
 Enable events for GPIO7 (DCONIRQ) and GPIO12 (DCONBLANK) 
	
	  According to HiMax, when powering the DCON up we should hold
	  SMB_DATA high for 8 SMB_CLK cycles.  This will force the DCON
	  state machine to reset to a (sane) initial state.  Mitch Bradley
	  did some testing and discovered that holding for 16 SMB_CLK cycles
	  worked a lot more reliably, so that's what we do here.
	 
	  According to the cs5536 spec, to set GPIO14 to SMB_CLK we must
	  simultaneously set AUX1 INOUT to GPIO14; ditto for SMB_DATA and
	  GPIO15.
 Clear the negative edge status for GPIO7 
 SPDX-License-Identifier: GPL-2.0
  Mainly by David Woodhouse, somewhat modified by Jordan Crouse
  Copyright ¬© 2006-2007  Red Hat, Inc.
  Copyright ¬© 2006-2007  Advanced Micro Devices, Inc.
  Copyright ¬© 2009       VIA Technology, Inc.
  Copyright (c) 2010-2011  Andres Salomon <dilinger@queued.net>
 Module definitions 
 I2C structures 
 Platform devices 
 ===== API functions - these are called by a variety of users ==== 
 SDRAM setuphold time 
 clear option bits 
 Colour swizzle, AA, no passthrough, backlight 
 Set the scanline to interrupt on during resume 
  The smbus doesn't always come back due to what is believed to be
  hardware (power rail) bugs.  For older models where this is known to
  occur, our solution is to attempt to wait for the bus to stabilize;
  if it doesn't happen, cut power to the dcon, repower it, and wait
  for the bus to stabilize.  Rinse, repeat until we have a working
  smbus.  For newer models, we simply BUG(); we want to know if this
  still happens despite the power fixes that have been made!
 we'll be conservative 
 argh, stupid hardware.. 
 Purposely turn off the backlight when we go to level 0 
 Set the output type to either color or mono 
 For now, this will be really stupid - we need to address how
  DCONLOAD works in a sleep and account for it accordingly
 Turn off the backlight and put the DCON to sleep 
 Only re-enable the backlight if the backlight value is set 
 Restore backlight 
 We should turn off some stuff in the framebuffer - but what? 
 the DCON seems to get confused if we change DCONLOAD too
  frequently -- i.e., approximately faster than frame time.
  normally we don't change it this fast, so in general we won't
  delay here.
 Set the source of the display (CPU or DCON) 
 Enable the scanline interrupt bit 
 Wait up to one second for the scanline interrupt 
 Turn off the scanline interrupt 
		
		  Ideally we'd like to disable interrupts here so that the
		  fb unblanking and DCON turn on happen at a known time value;
		  however, we can't do that right now with fb_blank
		  messing with semaphores.
		 
		  For now, we just hope..
 And turn off the DCON 
 Clear DCONLOAD - this implies that the DCON is in control 
			 sometimes the DCON doesn't follow its own rules,
			  and doesn't wait for two vsync pulses before
			  ack'ing the frame load with an IRQ.  the result
			  is that the display shows the previously
			  loaded frame.  we can detect this by looking at
			  the time between asserting DCONLOAD and the IRQ --
			  if it's less than 20msec, then the DCON couldn't
			  have seen two VSYNC pulses.  in that case we
			  deassert and reassert, and hope for the best.
			  see http:dev.laptop.orgticket9664
 normally unused 
 power down the DCON when the screen is blanked 
 Turn off the DCON. Entirely. 
 Add the DCON device 
 Add the backlight device for the DCON 
 Set up the DCON to have the source 
 CONFIG_PM 
 switch to DCON mode 
 switch to CPU mode 
		 workaround resume case:  the DCON (on 1.5) doesn't
		  ever assert status 0x01 when switching to CPU mode
		  during resume.  this is because DCONLOAD is de-asserted
		  _immediately_ upon exiting S3, so the actual release
		  of the DCON happened long before this point.
		  see http:dev.laptop.orgticket9869
 XO-1.5 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2009,2010       One Laptop per Child
 TODO: this eventually belongs in linuxvx855.h 
 Hardware setup on the XO 1.5:
 	DCONLOAD connects to VX855_GPIO1 (not SMBCK2)
 	DCONBLANK connects to VX855_GPIO8 (not SSPICLK)  unused in driver
 	DCONSTAT0 connects to VX855_GPI10 (not SSPISDI)
 	DCONSTAT1 connects to VX855_GPI11 (not nSSPISS)
 	DCONIRQ connects to VX855_GPIO12
 	DCONSMBDATA connects to VX855 graphics CRTSPD
 	DCONSMBCLK connects to VX855 graphics CRTSPCLK
 PMIO_Rx4c-4f 
 PMIO_Rx50 
 PMIO_Rx52 
 irq status will appear in PMIO_Rx50[6] (RW1C) on gpio12 
 irq status will appear in PMIO_Rx50[6] on gpio12 
 Add GPIO look up table 
 Get GPIO descriptor 
 set   PMIO_Rx52[6] to enable SCISMI on gpio12 
 Determine the current state of DCONLOAD, likely set by firmware 
 GPIO1 
 we're sharing the IRQ with ACPI 
 FIXME: This directly accesses the CRT GPIO controller !!! 
	
	  According to HiMax, when powering the DCON up we should hold
	  SMB_DATA high for 8 SMB_CLK cycles.  This will force the DCON
	  state machine to reset to a (sane) initial state.  Mitch Bradley
	  did some testing and discovered that holding for 16 SMB_CLK cycles
	  worked a lot more reliably, so that's what we do here.
 set   PMIO_Rx52[6] to enable SCISMI on gpio12 
 i believe this is the same as "inb(0x44b) & 3" 
 SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1)
  Functions that talk to the USB variant of the Intersil hfa384x MAC
  Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
  --------------------------------------------------------------------
  linux-wlan
    The contents of this file are subject to the Mozilla Public
    License Version 1.1 (the "License"); you may not use this file
    except in compliance with the License. You may obtain a copy of
    the License at http:www.mozilla.orgMPL
    Software distributed under the License is distributed on an "AS
    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
    implied. See the License for the specific language governing
    rights and limitations under the License.
    Alternatively, the contents of this file may be used under the
    terms of the GNU Public License version 2 (the "GPL"), in which
    case the provisions of the GPL are applicable instead of the
    above.  If you wish to allow the use of your version of this file
    only under the terms of the GPL and not to allow others to use
    your version of this file under the MPL, indicate your decision
    by deleting the provisions above and replace them with the notice
    and other provisions required by the GPL.  If you do not delete
    the provisions above, a recipient may use your version of this
    file under either the MPL or the GPL.
  --------------------------------------------------------------------
  Inquiries regarding the linux-wlan Open Source project can be
  made directly to:
  AbsoluteValue Systems Inc.
  info@linux-wlan.com
  http:www.linux-wlan.com
  --------------------------------------------------------------------
  Portions of the development of this software were funded by
  Intersil Corporation as part of PRISM(R) chipset product development.
  --------------------------------------------------------------------
  This file implements functions that correspond to the prism2hfa384x
  802.11 MAC hardware and firmware host interface.
  The functions can be considered to represent several levels of
  abstraction.  The lowest level functions are simply C-callable wrappers
  around the register accesses.  The next higher level represents C-callable
  prism2 API functions that match the Intersil documentation as closely
  as is reasonable.  The next higher layer implements common sequences
  of invocations of the API layer (e.g. write to bap, followed by cmd).
  Common sequences:
  hfa384x_drvr_xxx	Highest level abstractions provided by the
 			hfa384x code.  They are driver defined wrappers
 			for common sequences.  These functions generally
 			use the services of the lower levels.
  hfa384x_drvr_xxxconfig  An example of the drvr level abstraction. These
 			functions are wrappers for the RID getset
 			sequence. They call copy_[to|from]_bap() and
 			cmd_access(). These functions operate on the
 			RIDs and buffers without validation. The caller
 			is responsible for that.
  API wrapper functions:
  hfa384x_cmd_xxx	functions that provide access to the fw commands.
 			The function arguments correspond to each command
 			argument, even command arguments that get packed
 			into single registers.  These functions _just_
 			issue the command by setting the cmdparm regs
 			& reading the statusresp regs.  Additional
 			activities required to fully use a command
 			(readwrite fromto bap, getset int status etc.)
 			are implemented separately.  Think of these as
 			C-callable prism2 commands.
  Lowest Layer Functions:
  hfa384x_docmd_xxx	These functions implement the sequence required
 			to issue any prism2 command.  Primarily used by the
 			hfa384x_cmd_xxx functions.
  hfa384x_bap_xxx	BAP readwrite access functions.
 			Note: we usually use BAP0 for non-interrupt context
 			 and BAP1 for interrupt context.
  hfa384x_dl_xxx	download related functions.
  Driver State Issues:
  Note that there are two pairs of functions that manage the
  'initialized' and 'running' states of the hwMAC combo.  The four
  functions are create(), destroy(), start(), and stop().  create()
  sets up the data structures required to support the hfa384x_
  functions and destroy() cleans them up.  The start() function gets
  the actual hardware running and enables the interrupts.  The stop()
  function shuts the hardware down.  The sequence should be:
  create()
  start()
   .
   .  Do interesting things w the hardware
   .
  stop()
  destroy()
  Note that destroy() can be called without calling stop() first.
  --------------------------------------------------------------------
---------------------------------------------------
 Callbacks 
---------------------------------------------------
 Functions to support the prism2 usb command queue 
---------------------------------------------------
 Low level reqresp CTLX formatters and submitters 
----------------------------------------------------------------
  submit_rx_urb
  Listen for input data on the BULK-IN pipe. If the pipe has
  stalled then schedule it to be reset.
  Arguments:
 	hw		device struct
 	memflags	memory allocation flags
  Returns:
 	error code from submission
  Call context:
 	Any
 ----------------------------------------------------------------
 Post the IN urb 
 Check whether we need to reset the RX pipe 
 Don't leak memory if anything should go wrong 
----------------------------------------------------------------
  submit_tx_urb
  Prepares and submits the URB of transmitted data. If the
  submission fails then it will schedule the output pipe to
  be reset.
  Arguments:
 	hw		device struct
 	tx_urb		URB of data for transmission
 	memflags	memory allocation flags
  Returns:
 	error code from submission
  Call context:
 	Any
 ----------------------------------------------------------------
 Test whether we need to reset the TX pipe 
----------------------------------------------------------------
  hfa394x_usb_defer
  There are some things that the USB stack cannot do while
  in interrupt context, so we arrange this function to run
  in process context.
  Arguments:
 	hw	device structure
  Returns:
 	nothing
  Call context:
 	process (by design)
 ----------------------------------------------------------------
	 Don't bother trying to reset anything if the plug
	  has been pulled ...
 Reception has stopped: try to reset the input pipe 
 Cannot be holding spinlock! 
 Resume receiving data back from the device. 
 Transmission has stopped: try to reset the output pipe 
			 Stopping the BULK-OUT pipe also blocked
			  us from sending any more CTLX URBs, so
			  we need to re-run our queue ...
 Resume transmitting. 
----------------------------------------------------------------
  hfa384x_create
  Sets up the struct hfa384x data structure for use.  Note this
  does _not_ initialize the actual hardware, just the data structures
  we use to keep track of its state.
  Arguments:
 	hw		device structure
 	irq		device irq number
 	iobase		io base address for register access
 	membase		memory base address for register access
  Returns:
 	nothing
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
 Set up the waitq 
 Initialize the command queue 
 Initialize the authentication queue 
----------------------------------------------------------------
  hfa384x_destroy
  Partner to hfa384x_create().  This function cleans up the hw
  structure so that it can be freed by the caller using a simple
  kfree.  Currently, this function is just a placeholder.  If, at some
  point in the future, an hw in the 'shutdown' state requires a 'deep'
  kfree, this is where it should be done.  Note that if this function
  is called on a _running_ hw structure, the drvr_stop() function is
  called.
  Arguments:
 	hw		device structure
  Returns:
 	nothing, this function is not allowed to fail.
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
 Now to clean out the auth queue 
----------------------------------------------------------------
  Completor object:
  This completor must be passed to hfa384x_usbctlx_complete_sync()
  when processing a CTLX that returns a struct hfa384x_cmdresult structure.
 ----------------------------------------------------------------
----------------------------------------------------------------
  Completor object:
  This completor must be passed to hfa384x_usbctlx_complete_sync()
  when processing a CTLX that reads a RID.
 ----------------------------------------------------------------
 Validate the length, note body len calculation in bytes 
----------------------------------------------------------------
  Completor object:
  Interprets the results of a synchronous RID-write
 ----------------------------------------------------------------
----------------------------------------------------------------
  Completor object:
  Interprets the results of a synchronous memory-write
 ----------------------------------------------------------------
----------------------------------------------------------------
  Completor object:
  Interprets the results of a synchronous memory-read
 ----------------------------------------------------------------
----------------------------------------------------------------
  hfa384x_cb_status
  Ctlx_complete handler for async CMD type control exchanges.
  mark the hw struct as such.
  Note: If the handling is changed here, it should probably be
        changed in docmd as well.
  Arguments:
 	hw		hw struct
 	ctlx		completed CTLX
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
 ----------------------------------------------------------------
----------------------------------------------------------------
  hfa384x_cmd_initialize
  Issues the initialize command and sets the hw->state based
  on the result.
  Arguments:
 	hw		device structure
  Returns:
 	0		success
 	>0		fw reported error - fw status code
 	<0		driver reported error
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
----------------------------------------------------------------
  hfa384x_cmd_disable
  Issues the disable command to stop communications on one of
  the MACs 'ports'.
  Arguments:
 	hw		device structure
 	macport		MAC port number (host order)
  Returns:
 	0		success
 	>0		fw reported failure - fw status code
 	<0		driver reported error (timeout|bad arg)
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
----------------------------------------------------------------
  hfa384x_cmd_enable
  Issues the enable command to enable communications on one of
  the MACs 'ports'.
  Arguments:
 	hw		device structure
 	macport		MAC port number
  Returns:
 	0		success
 	>0		fw reported failure - fw status code
 	<0		driver reported error (timeout|bad arg)
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
----------------------------------------------------------------
  hfa384x_cmd_monitor
  Enables the 'monitor mode' of the MAC.  Here's the description of
  monitor mode that I've received thus far:
   "The "monitor mode" of operation is that the MAC passes all
   frames for which the PLCP checks are correct. All received
   MPDUs are passed to the host with MAC Port = 7, with a
   receive status of good, FCS error, or undecryptable. Passing
   certain MPDUs is a violation of the 802.11 standard, but useful
   for a debugging tool."  Normal communication is not possible
   while monitor mode is enabled.
  Arguments:
 	hw		device structure
 	enable		a code (0x0b|0x0f) that enablesdisables
 			monitor mode. (host order)
  Returns:
 	0		success
 	>0		fw reported failure - fw status code
 	<0		driver reported error (timeout|bad arg)
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
----------------------------------------------------------------
  hfa384x_cmd_download
  Sets the controls for the MAC controller codedata download
  process.  The arguments set the mode and address associated
  with a download.  Note that the aux registers should be enabled
  prior to setting one of the download enable modes.
  Arguments:
 	hw		device structure
 	mode		0 - Disable programming and begin code exec
 			1 - Enable volatile mem programming
 			2 - Enable non-volatile mem programming
 			3 - Program non-volatile section from NV download
 			    buffer.
 			(host order)
 	lowaddr
 	highaddr	For mode 1, sets the high & low order bits of
 			the "destination address".  This address will be
 			the execution start address when download is
 			subsequently disabled.
 			For mode 2, sets the high & low order bits of
 			the destination in NV ram.
 			For modes 0 & 3, should be zero. (host order)
 			NOTE: these are CMD format.
 	codelen		Length of the data to write in mode 2,
 			zero otherwise. (host order)
  Returns:
 	0		success
 	>0		fw reported failure - fw status code
 	<0		driver reported error (timeout|bad arg)
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
----------------------------------------------------------------
  hfa384x_corereset
  Perform a reset of the hfa38xx MAC core.  We assume that the hw
  structure is in its "created" state.  That is, it is initialized
  with proper values.  Note that if a reset is done after the
  device has been active for awhile, the caller might have to clean
  up some leftover cruft in the hw structure.
  Arguments:
 	hw		device structure
 	holdtime	how long (in ms) to hold the reset
 	settletime	how long (in ms) to wait after releasing
 			the reset
  Returns:
 	nothing
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
----------------------------------------------------------------
  hfa384x_usbctlx_complete_sync
  Waits for a synchronous CTLX object to complete,
  and then handles the response.
  Arguments:
 	hw		device structure
 	ctlx		CTLX ptr
 	completor	functor object to decide what to
 			do with the CTLX's result.
  Returns:
 	0		Success
 	-ERESTARTSYS	Interrupted by a signal
 	-EIO		CTLX failed
 	-ENODEV		Adapter was unplugged
 	???		Result from completor
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
	
	  We can only handle the CTLX if the USB disconnect
	  function has not run yet ...
		
		  We were probably interrupted, so delete
		  this CTLX asynchronously, kill the timers
		  and the URB, and then start the next
		  pending CTLX.
		 
		  NOTE: We can only delete the timers and
		        the URB if this CTLX is active.
			
			  This scenario is so unlikely that I'm
			  happy with a grubby "goto" solution ...
		
		  The completion task will send this CTLX
		  to the reaper the next time it runs. We
		  are no longer in a hurry.
----------------------------------------------------------------
  hfa384x_docmd
  Constructs a command CTLX and submits it.
  NOTE: Any changes to the 'post-submit' code in this function
        need to be carried over to hfa384x_cbcmd() since the handling
        is virtually identical.
  Arguments:
 	hw		device structure
        cmd             cmd structure.  Includes all arguments and result
                        data points.  All in host order. in host order
  Returns:
 	0		success
 	-EIO		CTLX failure
 	-ERESTARTSYS	Awakened on signal
 	>0		command indicated error, Status and Resp0-2 are
 			in hw structure.
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
 Initialize the command 
----------------------------------------------------------------
  hfa384x_dorrid
  Constructs a read rid CTLX and issues it.
  NOTE: Any changes to the 'post-submit' code in this function
        need to be carried over to hfa384x_cbrrid() since the handling
        is virtually identical.
  Arguments:
 	hw		device structure
 	mode		DOWAIT or DOASYNC
 	rid		Read RID number (host order)
 	riddata		Caller supplied buffer that MAC formatted RID.data
 			record will be written to for DOWAIT calls. Should
 			be NULL for DOASYNC calls.
 	riddatalen	Buffer length for DOWAIT calls. Zero for DOASYNC calls.
 	cmdcb		command callback for async calls, NULL for DOWAIT calls
 	usercb		user callback for async calls, NULL for DOWAIT calls
 	usercb_data	user supplied data pointer for async calls, NULL
 			for DOWAIT calls
  Returns:
 	0		success
 	-EIO		CTLX failure
 	-ERESTARTSYS	Awakened on signal
 	-ENODATA	riddatalen != macdatalen
 	>0		command indicated error, Status and Resp0-2 are
 			in hw structure.
  Side effects:
  Call context:
 	interrupt (DOASYNC)
 	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------
 Initialize the command 
 Submit the CTLX 
----------------------------------------------------------------
  hfa384x_dowrid
  Constructs a write rid CTLX and issues it.
  NOTE: Any changes to the 'post-submit' code in this function
        need to be carried over to hfa384x_cbwrid() since the handling
        is virtually identical.
  Arguments:
 	hw		device structure
 	enum cmd_mode	DOWAIT or DOASYNC
 	rid		RID code
 	riddata		Data portion of RID formatted for MAC
 	riddatalen	Length of the data portion in bytes
        cmdcb           command callback for async calls, NULL for DOWAIT calls
 	usercb		user callback for async calls, NULL for DOWAIT calls
 	usercb_data	user supplied data pointer for async calls
  Returns:
 	0		success
 	-ETIMEDOUT	timed out waiting for register ready or
 			command completion
 	>0		command indicated error, Status and Resp0-2 are
 			in hw structure.
  Side effects:
  Call context:
 	interrupt (DOASYNC)
 	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------
 Initialize the command 
 Submit the CTLX 
----------------------------------------------------------------
  hfa384x_dormem
  Constructs a readmem CTLX and issues it.
  NOTE: Any changes to the 'post-submit' code in this function
        need to be carried over to hfa384x_cbrmem() since the handling
        is virtually identical.
  Arguments:
 	hw		device structure
 	page		MAC address space page (CMD format)
 	offset		MAC address space offset
 	data		Ptr to data buffer to receive read
 	len		Length of the data to read (max == 2048)
  Returns:
 	0		success
 	-ETIMEDOUT	timed out waiting for register ready or
 			command completion
 	>0		command indicated error, Status and Resp0-2 are
 			in hw structure.
  Side effects:
  Call context:
 	process (DOWAIT)
 ----------------------------------------------------------------
 Initialize the command 
----------------------------------------------------------------
  hfa384x_dowmem
  Constructs a writemem CTLX and issues it.
  NOTE: Any changes to the 'post-submit' code in this function
        need to be carried over to hfa384x_cbwmem() since the handling
        is virtually identical.
  Arguments:
 	hw		device structure
 	page		MAC address space page (CMD format)
 	offset		MAC address space offset
 	data		Ptr to data buffer containing write data
 	len		Length of the data to read (max == 2048)
  Returns:
 	0		success
 	-ETIMEDOUT	timed out waiting for register ready or
 			command completion
 	>0		command indicated error, Status and Resp0-2 are
 			in hw structure.
  Side effects:
  Call context:
 	interrupt (DOWAIT)
 	process (DOWAIT)
 ----------------------------------------------------------------
 Initialize the command 
----------------------------------------------------------------
  hfa384x_drvr_disable
  Issues the disable command to stop communications on one of
  the MACs 'ports'.  Only macport 0 is valid  for stations.
  APs may also disable macports 1-6.  Only ports that have been
  previously enabled may be disabled.
  Arguments:
 	hw		device structure
 	macport		MAC port number (host order)
  Returns:
 	0		success
 	>0		fw reported failure - fw status code
 	<0		driver reported error (timeout|bad arg)
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
----------------------------------------------------------------
  hfa384x_drvr_enable
  Issues the enable command to enable communications on one of
  the MACs 'ports'.  Only macport 0 is valid  for stations.
  APs may also enable macports 1-6.  Only ports that are currently
  disabled may be enabled.
  Arguments:
 	hw		device structure
 	macport		MAC port number
  Returns:
 	0		success
 	>0		fw reported failure - fw status code
 	<0		driver reported error (timeout|bad arg)
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
----------------------------------------------------------------
  hfa384x_drvr_flashdl_enable
  Begins the flash download state.  Checks to see that we're not
  already in a download state and that a port isn't enabled.
  Sets the download state and retrieves the flash download
  buffer location, buffer size, and timeout length.
  Arguments:
 	hw		device structure
  Returns:
 	0		success
 	>0		fw reported error - fw status code
 	<0		driver reported error
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
 Check that a port isn't active 
 Check that we're not already in a download state 
 Retrieve the buffer loc&size and timeout 
----------------------------------------------------------------
  hfa384x_drvr_flashdl_disable
  Ends the flash download state.  Note that this will cause the MAC
  firmware to restart.
  Arguments:
 	hw		device structure
  Returns:
 	0		success
 	>0		fw reported error - fw status code
 	<0		driver reported error
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
 Check that we're already in the download state 
 There isn't much we can do at this point, so I don't 
  bother  w the return value 
----------------------------------------------------------------
  hfa384x_drvr_flashdl_write
  Performs a FLASH download of a chunk of data. First checks to see
  that we're in the FLASH download state, then sets the download
  mode, uses the aux functions to 1) copy the data to the flash
  buffer, 2) sets the download 'write flash' mode, 3) readback and
  compare.  Lather rinse, repeat as many times an necessary to get
  all the given data into flash.
  When all data has been written using this function (possibly
  repeatedly), call drvr_flashdl_disable() to end the download state
  and restart the MAC.
  Arguments:
 	hw		device structure
 	daddr		Card address to write to. (host order)
 	buf		Ptr to data to write.
 	len		Length of data (host order).
  Returns:
 	0		success
 	>0		fw reported error - fw status code
 	<0		driver reported error
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
 Check that we're in the flash download state 
 Convert to flat address for arithmetic 
 NOTE: dlbuffer RID stores the address in AUX format 
	 Calculations to determine how many fills of the dlbuffer to do
	  and how many USB wmemreq's to do for each fill.  At this point
	  in time, the dlbuffer size and the wmemreq size are the same.
	  Therefore, nwrites should always be 1.  The extra complexity
	  here is a hedge against future changes.
 Figure out how many times to do the flash programming 
 For each flash program cycle, how many USB wmemreq's are needed? 
 For each burn 
 Get the dest address and len 
 Set the download mode 
 copy the data to the flash download buffer 
 set the download 'write flash' mode 
 TODO: We really should do a readback and compare. 
 Leave the firmware in the 'post-prog' mode.  flashdl_disable will 
  actually disable programming mode.  Remember, that will cause the 
  the firmware to effectively reset itself. 
----------------------------------------------------------------
  hfa384x_drvr_getconfig
  Performs the sequence necessary to read a configinfo item.
  Arguments:
 	hw		device structure
 	rid		configinfo record id (host order)
 	buf		host side record buffer.  Upon return it will
 			contain the body portion of the record (minus the
 			RID and len).
 	len		buffer length (in bytes, should match record length)
  Returns:
 	0		success
 	>0		fw reported error - fw status code
 	<0		driver reported error
 	-ENODATA	length mismatch between argument and retrieved
 			record.
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
----------------------------------------------------------------
  hfa384x_drvr_setconfig_async
  Performs the sequence necessary to write a configinfo item.
  Arguments:
        hw              device structure
        rid             configinfo record id (in host order)
        buf             host side record buffer
        len             buffer length (in bytes)
        usercb          completion callback
        usercb_data     completion callback argument
  Returns:
        0               success
        >0              fw reported error - fw status code
        <0              driver reported error
  Side effects:
  Call context:
        process
 ----------------------------------------------------------------
----------------------------------------------------------------
  hfa384x_drvr_ramdl_disable
  Ends the ram download state.
  Arguments:
 	hw		device structure
  Returns:
 	0		success
 	>0		fw reported error - fw status code
 	<0		driver reported error
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
 Check that we're already in the download state 
 There isn't much we can do at this point, so I don't 
  bother  w the return value 
----------------------------------------------------------------
  hfa384x_drvr_ramdl_enable
  Begins the ram download state.  Checks to see that we're not
  already in a download state and that a port isn't enabled.
  Sets the download state and calls cmd_download with the
  ENABLE_VOLATILE subcommand and the exeaddr argument.
  Arguments:
 	hw		device structure
 	exeaddr		the card execution address that will be
                        jumped to when ramdl_disable() is called
 			(host order).
  Returns:
 	0		success
 	>0		fw reported error - fw status code
 	<0		driver reported error
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
 Check that a port isn't active 
 Check that we're not already in a download state 
 Call the download(1,addr) function 
 Set the download state 
----------------------------------------------------------------
  hfa384x_drvr_ramdl_write
  Performs a RAM download of a chunk of data. First checks to see
  that we're in the RAM download state, then uses the [read|write]mem USB
  commands to 1) copy the data, 2) readback and compare.  The download
  state is unaffected.  When all data has been written using
  this function, call drvr_ramdl_disable() to end the download state
  and restart the MAC.
  Arguments:
 	hw		device structure
 	daddr		Card address to write to. (host order)
 	buf		Ptr to data to write.
 	len		Length of data (host order).
  Returns:
 	0		success
 	>0		fw reported error - fw status code
 	<0		driver reported error
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
 Check that we're in the ram download state 
 How many dowmem calls?  
 Do blocking wmem's 
 make address args 
 Do blocking ctlx 
 TODO: We really should have a readback. 
----------------------------------------------------------------
  hfa384x_drvr_readpda
  Performs the sequence to read the PDA space.  Note there is no
  drvr_writepda() function.  Writing a PDA is
  generally implemented by a calling component via calls to
  cmd_download and writing to the flash download buffer via the
  aux regs.
  Arguments:
 	hw		device structure
 	buf		buffer to store PDA in
 	len		buffer length
  Returns:
 	0		success
 	>0		fw reported error - fw status code
 	<0		driver reported error
 	-ETIMEDOUT	timeout waiting for the cmd regs to become
 			available, or waiting for the control reg
 			to indicate the Aux port is enabled.
 	-ENODATA	the buffer does NOT contain a valid PDA.
 			Either the card PDA is bad, or the auxdata
 			reads are giving us garbage.
  Side effects:
  Call context:
 	process or non-card interrupt.
 ----------------------------------------------------------------
 word offset of the current pdr 
 pdr length in bytes, host order 
 pdr code, host order 
 Read the pda from each known address.  
 Make address 
 units of bytes 
 Test for garbage 
 initially assume good 
 Test the record length 
 Test the code 
 Test for completion 
 Move to the next pdr (if necessary) 
 note the access to pda[], need words here 
----------------------------------------------------------------
  hfa384x_drvr_setconfig
  Performs the sequence necessary to write a configinfo item.
  Arguments:
 	hw		device structure
 	rid		configinfo record id (in host order)
 	buf		host side record buffer
 	len		buffer length (in bytes)
  Returns:
 	0		success
 	>0		fw reported error - fw status code
 	<0		driver reported error
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
----------------------------------------------------------------
  hfa384x_drvr_start
  Issues the MAC initialize command, sets up some data structures,
  and enables the interrupts.  After this function completes, the
  low-level stuff should be ready for anyall commands.
  Arguments:
 	hw		device structure
  Returns:
 	0		success
 	>0		fw reported error - fw status code
 	<0		driver reported error
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
	 Clear endpoint stalls - but only do this if the endpoint
	  is showing a stall status. Some prism2 cards seem to behave
	  badly if a clear_halt is called when the endpoint is already
	  ok
 Synchronous unlink, in case we're trying to restart the driver 
 Post the IN urb 
	 Call initialize twice, with a 1 second sleep in between.
	  This is a nasty work-around since many prism2 cards seem to
	  need time to settle after an init from cold. The second
	  call to initialize in theory is not necessary - but we call
	  it anyway as a double insurance policy:
	  1) If the first init should fail, the second may well succeed
	     and the card can still be used
	  2) It helps ensures all is well with the card after the first
	     init and settle time.
----------------------------------------------------------------
  hfa384x_drvr_stop
  Shuts down the MAC to the point where it is safe to unload the
  driver.  Any subsystem that may be holding a data or function
  ptr into the driver must be cleareddeinitialized.
  Arguments:
 	hw		device structure
  Returns:
 	0		success
 	>0		fw reported error - fw status code
 	<0		driver reported error
  Side effects:
  Call context:
 	process
 ----------------------------------------------------------------
	 There's no need for spinlocks here. The USB "disconnect"
	  function sets this "removed" flag and then calls us.
 Call initialize to leave the MAC in its 'reset' state 
 Cancel the rxurb 
 Clear all the port status 
----------------------------------------------------------------
  hfa384x_drvr_txframe
  Takes a frame from prism2sta and queues it for transmission.
  Arguments:
 	hw		device structure
 	skb		packet buffer struct.  Contains an 802.11
 			data frame.
        p80211_hdr      points to the 802.11 header for the packet.
  Returns:
 	0		Success and more buffs available
 	1		Success but no more buffs
 	2		Allocation failure
 	4		Buffer full or queue busy
  Side effects:
  Call context:
 	interrupt
 ----------------------------------------------------------------
 Build Tx frame structure 
 Set up the control field 
 Setup the usb type field 
 Set up the sw_support field to identify this frame 
 Tx complete and Tx exception disable per dleach.  Might be causing
  buf depletion
 #define DOEXC  SLP -- doboth breaks horribly under load, doexc less so. 
 copy the header over to the txdesc 
 if we're using host WEP, increase size by IV+ICV 
 copy over the WEP IV if we are using host WEP 
 copy over the packet data 
 copy over the WEP ICV if we are using host WEP 
 Send the USB packet 
----------------------------------------------------------------
  hfa384x_usbctlx_reaper_task
  Tasklet to delete dead CTLX objects
  Arguments:
 	data	ptr to a struct hfa384x
  Returns:
  Call context:
 	Interrupt
 ----------------------------------------------------------------
	 This list is guaranteed to be empty if someone
	  has unplugged the adapter.
----------------------------------------------------------------
  hfa384x_usbctlx_completion_task
  Tasklet to call completion handlers for returned CTLXs
  Arguments:
 	data	ptr to struct hfa384x
  Returns:
 	Nothing
  Call context:
 	Interrupt
 ----------------------------------------------------------------
	 This list is guaranteed to be empty if someone
	  has unplugged the adapter ...
		 Call the completion function that this
		  command was assigned, assuming it has one.
			 Make sure we don't try and complete
			  this CTLX more than once!
			 Did someone yank the adapter out
			  while our list was (briefly) unlocked?
		
		  "Reapable" CTLXs are ones which don't have any
		  threads waiting for them to die. Hence they must
		  be delivered to The Reaper!
			 Move the CTLX off the "completing" list (hopefully)
			  on to the "reapable" list where the reaper task
			  can find it. And "reapable" means that this CTLX
			  isn't sitting on a wait-queue somewhere.
----------------------------------------------------------------
  unlocked_usbctlx_cancel_async
  Mark the CTLX dead asynchronously, and ensure that the
  next command on the queue is run afterwards.
  Arguments:
 	hw	ptr to the struct hfa384x structure
 	ctlx	ptr to a CTLX structure
  Returns:
 	0	the CTLX's URB is inactive
  -EINPROGRESS	the URB is currently being unlinked
  Call context:
 	Either process or interrupt, but presumably interrupt
 ----------------------------------------------------------------
	
	  Try to delete the URB containing our request packet.
	  If we succeed, then its completion handler will be
	  called with a status of -ECONNRESET.
		
		  The OUT URB had either already completed
		  or was still in the pending queue, so the
		  URB's completion function will not be called.
		  We will have to complete the CTLX ourselves.
----------------------------------------------------------------
  unlocked_usbctlx_complete
  A CTLX has completed.  It may have been successful, it may not
  have been. At this point, the CTLX should be quiescent.  The URBs
  aren't active and the timers should have been stopped.
  The CTLX is migrated to the "completing" queue, and the completing
  tasklet is scheduled.
  Arguments:
 	hw		ptr to a struct hfa384x structure
 	ctlx		ptr to a ctlx structure
  Returns:
 	nothing
  Side effects:
  Call context:
 	Either, assume interrupt
 ----------------------------------------------------------------
	 Timers have been stopped, and ctlx should be in
	  a terminal state. Retire it from the "active"
	  queue.
 This are the correct terminating states. 
 switch 
----------------------------------------------------------------
  hfa384x_usbctlxq_run
  Checks to see if the head item is running.  If not, starts it.
  Arguments:
 	hw	ptr to struct hfa384x
  Returns:
 	nothing
  Side effects:
  Call context:
 	any
 ----------------------------------------------------------------
 acquire lock 
	 Only one active CTLX at any one time, because there's no
	  other (reliable) way to match the response URB to the
	  correct CTLX.
	 
	  Don't touch any of these CTLXs if the hardware
	  has been removed or the USB subsystem is stalled.
 This is the first pending command 
 We need to split this off to avoid a race condition 
 Fill the out packet 
 Now submit the URB and update the CTLX's state 
 This CTLX is now running on the active queue 
 Start the OUT wait timer 
 Start the IN wait timer 
			 The OUT pipe needs resetting, so put
			  this CTLX back in the "pending" queue
			  and schedule a reset ...
 while 
----------------------------------------------------------------
  hfa384x_usbin_callback
  Callback for URBs on the BULKIN endpoint.
  Arguments:
 	urb		ptr to the completed urb
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
 ----------------------------------------------------------------
 Check for error conditions within the URB 
 Check for short packet 
 Save values from the RX URB before reposting overwrites it. 
 Repost the RX URB 
 Handle any USB-IN packet 
	 Note: the check of the sw_support field, the type field doesn't
	        have bit 12 set like the docs suggest.
 ALWAYS, ALWAYS, ALWAYS handle this CTLX!!!! 
 switch 
----------------------------------------------------------------
  hfa384x_usbin_ctlx
  We've received a URB containing a Prism2 "response" message.
  This message needs to be matched up with a CTLX on the active
  queue and our state updated accordingly.
  Arguments:
 	hw		ptr to struct hfa384x
 	usbin		ptr to USB IN packet
 	urb_status	status of this Bulk-In URB
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
 ----------------------------------------------------------------
	 There can be only one CTLX on the active queue
	  at any one time, and this is the CTLX that the
	  timers are waiting for.
	 Remove the "response timeout". It's possible that
	  we are already too late, and that the timeout is
	  already running. And that's just too bad for us,
	  because we could lose our CTLX from the active
	  queue here ...
		
		  Bad CTLX, so get rid of it. But we only
		  remove it from the active queue if we're no
		  longer expecting the OUT URB to complete.
		
		  Check that our message is what we're expecting ...
 This URB has succeeded, so grab the data ... 
			
			  We have received our response URB before
			  our request has been acknowledged. Odd,
			  but our OUT URB is still alive...
			
			  This is the usual path: our request
			  has already been acknowledged, and
			  now we have received the reply too.
			
			  Throw this CTLX away ...
 switch 
----------------------------------------------------------------
  hfa384x_usbin_txcompl
  At this point we have the results of a previous transmit.
  Arguments:
 	wlandev		wlan device
 	usbin		ptr to the usb transfer buffer
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
 ----------------------------------------------------------------
 yeah I know it says type... 
 Was there an error? 
----------------------------------------------------------------
  hfa384x_usbin_rx
  At this point we have a successful received a rx frame packet.
  Arguments:
 	wlandev		wlan device
 	usbin		ptr to the usb transfer buffer
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
 ----------------------------------------------------------------
 Byte order convert once up front. 
 Now handle frame based on port# 
 If exclude and we receive an unencrypted, drop it 
 How much header data do we have? 
 Pull off the descriptor 
		 Now shunt the header block up against the data block
		  with an "overlapping" copy
 And set the frame length properly 
 The prism2 series does not return the CRC 
 Attach the rxmeta, set some stuff 
 Copy to wlansnif skb 
----------------------------------------------------------------
  hfa384x_int_rxmonitor
  Helper function for int_rx.  Handles monitor frames.
  Note that this function allocates space for the FCS and sets it
  to 0xffffffff.  The hfa384x doesn't give us the FCS value but the
  higher layers expect it.  0xffffffff is used as a flag to indicate
  the FCS is bogus.
  Arguments:
 	wlandev		wlan device structure
 	rxfrm		rx descriptor read from card in int_rx
  Returns:
 	nothing
  Side effects:
 	Allocates an skb and passes it up via the PF_PACKET interface.
  Call context:
 	interrupt
 ----------------------------------------------------------------
 Remember the status, time, and data_len fields are in host order 
 Figure out how big the frame is 
 Allocate an ind message+framesize skb 
 sanity check the length 
 only prepend the prism header if in the right mode 
 The NEW header format! 
 dss_dot11_b 
 unknown 
 unknown 
 rssi_raw 
 unknown 
 cck 
	 Copy the 802.11 header to the skb
	  (ctl frames may be less than a full header)
 If any, copy the data from the card to the skb 
 check for unencrypted stuff if WEP bit set. 
 wep set 
 clear wep; it's the 802.2 header! 
 Set the FCS 
 pass it back up 
----------------------------------------------------------------
  hfa384x_usbin_info
  At this point we have a successful received a Prism2 info frame.
  Arguments:
 	wlandev		wlan device
 	usbin		ptr to the usb transfer buffer
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
 ----------------------------------------------------------------
----------------------------------------------------------------
  hfa384x_usbout_callback
  Callback for URBs on the BULKOUT endpoint.
  Arguments:
 	urb		ptr to the completed urb
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
 ----------------------------------------------------------------
 Ignorable errors 
 switch 
----------------------------------------------------------------
  hfa384x_ctlxout_callback
  Callback for control data on the BULKOUT endpoint.
  Arguments:
 	urb		ptr to the completed urb
  Returns:
  nothing
  Side effects:
  Call context:
  interrupt
 ----------------------------------------------------------------
	
	  Only one CTLX at a time on the "active" list, and
	  none at all if we are unplugged. However, we can
	  rely on the disconnect function to clean everything
	  up if someone unplugged the adapter.
	
	  Having something on the "active" queue means
	  that we have timers to worry about ...
			
			  This timer was actually running while we
			  were trying to delete it. Let it terminate
			  gracefully instead.
 Request portion of a CTLX is successful 
 This OUT-ACK received before IN 
			 IN already received before this OUT-ACK,
			  so this command must now be complete.
 This is NOT a valid CTLX "success" state! 
 switch 
 If the pipe has stalled then we need to reset it 
		 If someone cancels the OUT URB then its status
		  should be either -ECONNRESET or -ENOENT.
----------------------------------------------------------------
  hfa384x_usbctlx_reqtimerfn
  Timer response function for CTLX request timeouts.  If this
  function is called, it means that the callback for the OUT
  URB containing a Prism2.x XXX_Request was never called.
  Arguments:
 	data		a ptr to the struct hfa384x
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
 ----------------------------------------------------------------
	 Removing the hardware automatically empties
	  the active list ...
		
		  We must ensure that our URB is removed from
		  the system, if it hasn't already expired.
			 This URB was active, but has now been
			  cancelled. It will now have a status of
			  -ECONNRESET in the callback function.
			 
			  We are cancelling this CTLX, so we're
			  not going to need to wait for a response.
			  The URB's callback function will check
			  that this timer is truly dead.
----------------------------------------------------------------
  hfa384x_usbctlx_resptimerfn
  Timer response function for CTLX response timeouts.  If this
  function is called, it means that the callback for the IN
  URB containing a Prism2.x XXX_Response was never called.
  Arguments:
 	data		a ptr to the struct hfa384x
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
 ----------------------------------------------------------------
	 The active list will be empty if the
	  adapter has been unplugged ...
----------------------------------------------------------------
  hfa384x_usb_throttlefn
  Arguments:
 	data	ptr to hw
  Returns:
 	Nothing
  Side effects:
  Call context:
 	Interrupt
 ----------------------------------------------------------------
		
		  We need to check BOTH the RX and the TX throttle controls,
		  so we use the bitwise OR instead of the logical OR.
----------------------------------------------------------------
  hfa384x_usbctlx_submit
  Called from the doxxx functions to submit a CTLX to the queue
  Arguments:
 	hw		ptr to the hw struct
 	ctlx		ctlx structure to enqueue
  Returns:
 	-ENODEV if the adapter is unplugged
 	0
  Side effects:
  Call context:
 	process or interrupt
 ----------------------------------------------------------------
----------------------------------------------------------------
  hfa384x_isgood_pdrcore
  Quick check of PDR codes.
  Arguments:
 	pdrcode		PDR code number (host order)
  Returns:
 	zero		not good.
 	one		is good.
  Side effects:
  Call context:
 ----------------------------------------------------------------
 code is OK 
 code is OK, but we don't know exactly what it is 
 bad code 
 SPDX-License-Identifier: GPL-2.0
 cfg80211 Interface for prism2_usb module 
 Prism2 channelfrequencybitrate declarations 
 prism2 device private data 
 Helper Functions 
 The interface functions, called by the cfg80211 layer 
 Set Operation mode to the PORT TYPE RID 
 send key to driver 
	 There is no direct way in the hardware (AFAIK) of removing
	  a key, so we will cheat by setting the key to a bogus value
 send key to driver 
 build request message 
 send message to nsd 
 Now retrieve scan results 
 Conversion to signed type 
 Set the channel 
 Set the authorization 
 Set the encryption - we only support wep 
 send key to driver 
		 Assume we should set privacy invoked and exclude unencrypted
		  We could possible use sme->privacy here, but the assumption
		  seems reasonable anyways
		 Assume we should unset privacy invoked
		  and exclude unencrypted
	 Now do the actual join. Note there is no way that I can
	  see to request a specific bssid
 Do a join, with a bogus ssid. Thats the only way I can think of 
 Interface callback functions, passing data back up to the cfg80211 layer 
 Structures for declaring wiphy interface 
 Functions to createfree wiphy interface 
 SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1)
  Ether802.11 conversions and packet buffer routines
  Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
  --------------------------------------------------------------------
  linux-wlan
    The contents of this file are subject to the Mozilla Public
    License Version 1.1 (the "License"); you may not use this file
    except in compliance with the License. You may obtain a copy of
    the License at http:www.mozilla.orgMPL
    Software distributed under the License is distributed on an "AS
    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
    implied. See the License for the specific language governing
    rights and limitations under the License.
    Alternatively, the contents of this file may be used under the
    terms of the GNU Public License version 2 (the "GPL"), in which
    case the provisions of the GPL are applicable instead of the
    above.  If you wish to allow the use of your version of this file
    only under the terms of the GPL and not to allow others to use
    your version of this file under the MPL, indicate your decision
    by deleting the provisions above and replace them with the notice
    and other provisions required by the GPL.  If you do not delete
    the provisions above, a recipient may use your version of this
    file under either the MPL or the GPL.
  --------------------------------------------------------------------
  Inquiries regarding the linux-wlan Open Source project can be
  made directly to:
  AbsoluteValue Systems Inc.
  info@linux-wlan.com
  http:www.linux-wlan.com
  --------------------------------------------------------------------
  Portions of the development of this software were funded by
  Intersil Corporation as part of PRISM(R) chipset product development.
  --------------------------------------------------------------------
  This file defines the functions that perform Ethernet tofrom
  802.11 frame conversions.
  --------------------------------------------------------------------
 ================================================================
----------------------------------------------------------------
  p80211pb_ether_to_80211
  Uses the contents of the ether frame and the etherconv setting
  to build the elements of the 802.11 frame.
  We don't actually set
  up the frame header here.  That's the MAC's job.  We're only handling
  conversion of DIXII or 802.3+LLC frames to something that works
  with 802.11.
  Note -- 802.11 header is NOT part of the skb.  Likewise, the 802.11
          FCS is also not present and will need to be added elsewhere.
  Arguments:
 	ethconv		Conversion type to perform
 	skb		skbuff containing the ether frame
        p80211_hdr      802.11 header
  Returns:
 	0 on success, non-zero otherwise
  Call context:
 	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------
 simplest case 
 here, we don't care what kind of ether frm. Just stick it 
  in the 80211 payload 
 which is to say, leave the skb alone. 
 step 1: classify ether frame, DIX or 802.3? 
 codes <= 1500 reserved for 802.3 lengths 
 it's 802.3, pass ether payload unchanged,  
 trim off ethernet header 
   leave off any PAD octets.  
 it's DIXII, time for some conversion 
 trim off ethernet header 
 tack on SNAP 
 tack on llc 
 SNAP, see IEEE 802 
 Set up the 802.11 header 
 It's a data frame 
 XXXX need to pick keynum other than default? 
      skb->nh.raw = skb->data; 
 jkriegl: from orinoco, modified 
	 Gather wireless spy statistics: for each packet, compare the
	  source address with out list, and if match, get the stats...
----------------------------------------------------------------
  p80211pb_80211_to_ether
  Uses the contents of a received 802.11 frame and the etherconv
  setting to build an ether frame.
  This function extracts the src and dest address from the 802.11
  frame to use in the construction of the eth frame.
  Arguments:
 	ethconv		Conversion type to perform
 	skb		Packet buffer containing the 802.11 frame
  Returns:
 	0 on success, non-zero otherwise
  Call context:
 	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------
 setup some vars for convenience 
 perform de-wep if necessary.. 
 de-wep failed, drop skb. 
 subtract the IV+ICV length off the payload 
 chop off the IV 
 chop off the ICV. 
 Test for the various encodings 
 802.3 Encapsulated 
 Test for an overlength frame 
 A bogus length ethfrm has been encap'd. 
 Is someone trying an oflow attack? 
 Chop off the 802.11 header.  it's already sane. 
 chop off the 802.11 CRC 
 it's a SNAP + RFC1042 frame && protocol is in STT 
 build 802.3 + RFC1042 
 Test for an overlength frame 
 A bogus length ethfrm has been sent. 
 Is someone trying an oflow attack? 
 chop 802.11 header from skb. 
 create 802.3 header at beginning of skb. 
 chop off the 802.11 CRC 
		 it's an 802.1h frame || (an RFC1042 && protocol not in STT)
		  build a DIXII + RFC894
 Test for an overlength frame 
 A bogus length ethfrm has been sent. 
 Is someone trying an oflow attack? 
 chop 802.11 header from skb. 
 chop llc header from skb. 
 chop snap header from skb. 
 create 802.3 header at beginning of skb. 
 chop off the 802.11 CRC 
 any NON-ENCAP 
 it's a generic 80211+LLC or IPX 'Raw 802.3' 
  build an 802.3 frame 
 allocate space and setup hostbuf 
 Test for an overlength frame 
 A bogus length ethfrm has been sent. 
 Is someone trying an oflow attack? 
 Chop off the 802.11 header. 
 create 802.3 header at beginning of skb. 
 chop off the 802.11 CRC 
	
	  Note that eth_type_trans() expects an skb w skb->data pointing
	  at the MAC header, it then sets the following skb members:
	  skb->mac_header,
	  skb->data, and
	  skb->pkt_type.
	  It then _returns_ the value that _we're_ supposed to stuff in
	  skb->protocol.  This is nuts.
 jkriegl: process signal and noise as set in hfa384x_int_rx() 
 jkriegl: only process signalnoise if requested by iwspy 
 Free the metadata 
----------------------------------------------------------------
  p80211_stt_findproto
  Searches the 802.1h Selective Translation Table for a given
  protocol.
  Arguments:
 	proto	protocol number (in host order) to search for.
  Returns:
 	1 - if the table is empty or a match is found.
 	0 - if the table is non-empty and a match is not found.
  Call context:
 	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------
 Always return found for now.  This is the behavior used by the 
 Zoom Win95 driver when 802.1h mode is selected 
	 TODO: If necessary, add an actual search we'll probably
	  need this to match the CMAC's way of doing things.
	  Need to do some testing to confirm.
 APPLETALK 
----------------------------------------------------------------
  p80211skb_rxmeta_detach
  Disconnects the frmmeta and rxmeta from an skb.
  Arguments:
 	wlandev		The wlandev this skb belongs to.
 	skb		The skb we're attaching to.
  Returns:
 	0 on success, non-zero otherwise
  Call context:
 	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------
 Sanity checks 
 bad skb 
 no magic 
 bad meta ptr 
 Free rxmeta 
 Clear skb->cb 
----------------------------------------------------------------
  p80211skb_rxmeta_attach
  Allocates a p80211rxmeta structure, initializes it, and attaches
  it to an skb.
  Arguments:
 	wlandev		The wlandev this skb belongs to.
 	skb		The skb we're attaching to.
  Returns:
 	0 on success, non-zero otherwise
  Call context:
 	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------
 If these already have metadata, we error out! 
 Allocate the rxmeta 
 Initialize the rxmeta 
 Overlay a frmmeta_t onto skb->cb 
----------------------------------------------------------------
  p80211skb_free
  Frees an entire p80211skb by checking and freeing the meta struct
  and then freeing the skb.
  Arguments:
 	wlandev		The wlandev this skb belongs to.
 	skb		The skb we're attaching to.
  Returns:
 	0 on success, non-zero otherwise
  Call context:
 	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------
 SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1)
  WEP encodedecode for P80211.
  Copyright (C) 2002 AbsoluteValue Systems, Inc.  All Rights Reserved.
  --------------------------------------------------------------------
  linux-wlan
    The contents of this file are subject to the Mozilla Public
    License Version 1.1 (the "License"); you may not use this file
    except in compliance with the License. You may obtain a copy of
    the License at http:www.mozilla.orgMPL
    Software distributed under the License is distributed on an "AS
    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
    implied. See the License for the specific language governing
    rights and limitations under the License.
    Alternatively, the contents of this file may be used under the
    terms of the GNU Public License version 2 (the "GPL"), in which
    case the provisions of the GPL are applicable instead of the
    above.  If you wish to allow the use of your version of this file
    only under the terms of the GPL and not to allow others to use
    your version of this file under the MPL, indicate your decision
    by deleting the provisions above and replace them with the notice
    and other provisions required by the GPL.  If you do not delete
    the provisions above, a recipient may use your version of this
    file under either the MPL or the GPL.
  --------------------------------------------------------------------
  Inquiries regarding the linux-wlan Open Source project can be
  made directly to:
  AbsoluteValue Systems Inc.
  info@linux-wlan.com
  http:www.linux-wlan.com
  --------------------------------------------------------------------
  Portions of the development of this software were funded by
  Intersil Corporation as part of PRISM(R) chipset product development.
  --------------------------------------------------------------------
================================================================
 System Includes 
 keylen in bytes! 
  4-byte IV at start of buffer, 4-byte ICV at end of buffer.
  if successful, buf start is payload begin, length -= 8;
 Needs to be at least 8 bytes of payload 
 initialize the first bytes of the key from the IV 
 copy the rest of the key over from the designated key 
 add in IV bytes 
 set up the RC4 state 
 Apply the RC4 to the data, update the CRC32 
 now let's check the crc 
 ICV mismatch 
 encrypts in-place. 
 no point in WEPping an empty frame 
 we need to have a real key.. 
 use a random IV.  And skip known weak ones. 
 copy the rest of the key over from the designated key 
 add in IV bytes 
 set up the RC4 state 
 Update CRC32 then apply RC4 to the data 
 now let's encrypt the crc 
 SPDX-License-Identifier: GPL-2.0
 terminator 
 Initialize the hw data 
	 Register the wlandev, this gets us a name and registers the
	  linux netdevice.
 Do a chip-level reset on the MAC 
 Try and load firmware, then enable card before we register 
		 There's no hardware to shutdown, but the driver
		  might have some tasks or tasklets that must be
		  stopped before we can tear everything down.
		 Unlink all the URBs. This "removes the wheels"
		  from the entire CTLX handling mechanism.
		 Now we complete any outstanding commands
		  and tell everyone who is waiting for their
		  responses that we have shut down.
		 Give any outstanding synchronous commands
		  a chance to complete. All they need to do
		  is "wake up", so that's easy.
		  (I'd like a better way to do this, really.)
 Now delete the CTLXs, because no-one else can now. 
 Unhook the wlandev 
 Do a chip-level reset on the MAC 
 CONFIG_PM 
 fops, minor? 
 SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1)
  Linux Kernel net device interface
  Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
  --------------------------------------------------------------------
  linux-wlan
    The contents of this file are subject to the Mozilla Public
    License Version 1.1 (the "License"); you may not use this file
    except in compliance with the License. You may obtain a copy of
    the License at http:www.mozilla.orgMPL
    Software distributed under the License is distributed on an "AS
    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
    implied. See the License for the specific language governing
    rights and limitations under the License.
    Alternatively, the contents of this file may be used under the
    terms of the GNU Public License version 2 (the "GPL"), in which
    case the provisions of the GPL are applicable instead of the
    above.  If you wish to allow the use of your version of this file
    only under the terms of the GPL and not to allow others to use
    your version of this file under the MPL, indicate your decision
    by deleting the provisions above and replace them with the notice
    and other provisions required by the GPL.  If you do not delete
    the provisions above, a recipient may use your version of this
    file under either the MPL or the GPL.
  --------------------------------------------------------------------
  Inquiries regarding the linux-wlan Open Source project can be
  made directly to:
  AbsoluteValue Systems Inc.
  info@linux-wlan.com
  http:www.linux-wlan.com
  --------------------------------------------------------------------
  Portions of the development of this software were funded by
  Intersil Corporation as part of PRISM(R) chipset product development.
  --------------------------------------------------------------------
  The functions required for a Linux network device are defined here.
  --------------------------------------------------------------------
 netdevice method functions 
----------------------------------------------------------------
  p80211knetdev_init
  Init method for a Linux netdevice.  Called in response to
  register_netdev.
  Arguments:
 	none
  Returns:
 	nothing
 ----------------------------------------------------------------
 Called in response to register_netdev 
 This is usually the probe function, but the probe has 
 already been done by the MSD and the create_kdev 
 function.  All we do here is return success 
----------------------------------------------------------------
  p80211knetdev_open
  Linux netdevice open method.  Following a successful call here,
  the device is supposed to be ready for tx and rx.  In our
  situation that may not be entirely true due to the state of the
  MAC below.
  Arguments:
 	netdev		Linux network device structure
  Returns:
 	zero on success, non-zero otherwise
 ----------------------------------------------------------------
 success 
 Check to make sure the MSD is running 
 Tell the MSD to open 
----------------------------------------------------------------
  p80211knetdev_stop
  Linux netdevice stop (close) method.  Following this call,
  no frames should go up or down through this interface.
  Arguments:
 	netdev		Linux network device structure
  Returns:
 	zero on success, non-zero otherwise
 ----------------------------------------------------------------
----------------------------------------------------------------
  p80211netdev_rx
  Frame receive function called by the mac specific driver.
  Arguments:
 	wlandev		WLAN network device structure
 	skb		skbuff containing a full 802.11 frame.
  Returns:
 	nothing
  Side effects:
 ----------------------------------------------------------------
 Enqueue for post-irq processing 
  p80211_convert_to_ether - conversion from 802.11 frame to ethernet frame
  @wlandev: pointer to WLAN device
  @skb: pointer to socket buffer
  Returns: 0 if conversion succeeded
 	    CONV_TO_ETHER_FAILED if conversion failed
 	    CONV_TO_ETHER_SKIPPED if frame is ignored
	 perform mcast filtering: allow my local address through but reject
	  anything else that isn't multicast
  p80211netdev_rx_bh - deferred processing of all received frames
  @t: pointer to the tasklet associated with this handler
 Let's empty our queue 
 RAW frame; we shouldn't convert it 
 XXX Append the Prism Header here instead. 
 set up various data fields 
----------------------------------------------------------------
  p80211knetdev_hard_start_xmit
  Linux netdevice method for transmitting a frame.
  Arguments:
 	skb	Linux sk_buff containing the frame.
 	netdev	Linux netdevice.
  Side effects:
 	If the lower layers report that buffers are full. netdev->tbusy
 	will be set to prevent higher layers from sending more traffic.
 	Note: If this function returns non-zero, higher layers retain
 	      ownership of the skb.
  Returns:
 	zero on success, non-zero on failure.
 ----------------------------------------------------------------
 Check to see that a valid mode is set 
		 Mode isn't set yet, just drop the frame
		  and return success .
		  TODO: we need a saner way to handle this
 Check for raw transmits 
 move the header over 
 convert failed 
 count only the packet payload 
 success and more buf 
 avail, re: hw_txdata 
 success, no more avail 
 netdev->tbusy = 1;  don't set here, irqhdlr 
   may have already cleared it 
 alloc failure, drop frame 
 buffer full or queue busy, drop frame. 
 Free up the WEP buffer if it's not the same as the skb 
 we always free the skb here, never in a lower level. 
----------------------------------------------------------------
  p80211knetdev_set_multicast_list
  Called from higher layers whenever there's a need to setclear
  promiscuous mode or rewrite the multicast list.
  Arguments:
 	none
  Returns:
 	nothing
 ----------------------------------------------------------------
 TODO:  real multicast support as well 
----------------------------------------------------------------
  p80211knetdev_siocdevprivate
  Handle an ioctl call on one of our devices.  Everything Linux
  ioctl specific is done here.  Then we pass the contents of the
  ifr->data to the request message handler.
  Arguments:
 	dev	Linux kernel netdevice
 	ifr	Our private ioctl request structure, typed for the
 		generic struct ifreq so we can use ptr to func
 		wo cast.
  Returns:
 	zero on success, a negative errno on failure.  Possible values:
 		-ENETDOWN Device isn't up.
 		-EBUSY	cmd already in progress
 		-ETIME	p80211 cmd timed out (MSD may have its own timers)
 		-EFAULT memory fault copying msg from user buffer
 		-ENOMEM unable to allocate kernel msg buffer
 		-EINVAL	bad magic, it the cmd really for us?
 		-EintR	sleeping on cmd, awakened by signal, cmd cancelled.
  Call Context:
 	Process thread (ioctl caller).  TODO: SMP support may require
 	locks.
 ----------------------------------------------------------------
 Test the magic, assume ifr is good if it's there 
 If allocate,copyfrom or copyto fails, return errno 
----------------------------------------------------------------
  p80211knetdev_set_mac_address
  Handles the ioctl for changing the MACAddress of a netdevice
  references: linuxnetdevice.h and driversnetnet_init.c
  NOTE: [MSM] We only prevent address changes when the netdev is
  up.  We don't control anything based on dot11 state.  If the
  address is changed on a STA that's currently associated, you
  will probably lose the ability to send and receive data frames.
  Just be aware.  Therefore, this should usually only be done
  prior to scanjoinauthassoc.
  Arguments:
 	dev	netdevice struct
 	addr	the new MACAddress (a struct)
  Returns:
 	zero on success, a negative errno on failure.  Possible values:
 		-EBUSY	device is bussy (cmd not possible)
 		-and errors returned by: p80211req_dorequest(..)
  by: Collin R. Mulliner <collin@mulliner.org>
 ----------------------------------------------------------------
 If we're running, we don't allow MAC address changes 
 Set up some convenience pointers. 
 Set up a dot11req_mibset 
 Set up the mibattribute argument 
 Set up the resultcode argument 
 now fire the request 
	 If the request wasn't successful, report an error and don't
	  change the netdev address
 everything's ok, change the addr in netdev 
----------------------------------------------------------------
  wlan_setup
  Roughly matches the functionality of ether_setup.  Here
  we set up any members of the wlandevice structure that are common
  to all devices.  Additionally, we allocate a linux 'struct device'
  and perform the same setup as ether_setup.
  Note: It's important that the caller have setup the wlandev->name
 	ptr prior to calling this function.
  Arguments:
 	wlandev		ptr to the wlandev structure for the
 			interface.
 	physdev		ptr to usb device
  Returns:
 	zero on success, non-zero otherwise.
  Call Context:
 	Should be process thread.  We'll assume it might be
 	interrupt though.  When we add support for statically
 	compiled drivers, this function will be called in the
 	context of the kernel startup code.
 ----------------------------------------------------------------
 Set up the wlandev 
 Set up the rx queue 
 Allocate and initialize the wiphy struct 
 Allocate and initialize the struct device 
		 2312 is max 802.11 payload, 20 is overhead,
		  (ether + llc + snap) and another 8 for wep.
----------------------------------------------------------------
  wlan_unsetup
  This function is paired with the wlan_setup routine.  It should
  be called after unregister_wlandev.  Basically, all it does is
  free the 'struct device' that's associated with the wlandev.
  We do it here because the 'struct device' isn't allocated
  explicitly in the driver code, it's done in wlan_setup.  To
  do the free in the driver might seem like 'magic'.
  Arguments:
 	wlandev		ptr to the wlandev structure for the
 			interface.
  Call Context:
 	Should be process thread.  We'll assume it might be
 	interrupt though.  When we add support for statically
 	compiled drivers, this function will be called in the
 	context of the kernel startup code.
 ----------------------------------------------------------------
----------------------------------------------------------------
  register_wlandev
  Roughly matches the functionality of register_netdev.  This function
  is called after the driver has successfully probed and set up the
  resources for the device.  It's now ready to become a named device
  in the Linux system.
  First we allocate a name for the device (if not already set), then
  we call the Linux function register_netdevice.
  Arguments:
 	wlandev		ptr to the wlandev structure for the
 			interface.
  Returns:
 	zero on success, non-zero otherwise.
  Call Context:
 	Can be either interrupt or not.
 ----------------------------------------------------------------
----------------------------------------------------------------
  unregister_wlandev
  Roughly matches the functionality of unregister_netdev.  This
  function is called to remove a named device from the system.
  First we tell linux that the device should no longer exist.
  Then we remove it from the list of known wlan devices.
  Arguments:
 	wlandev		ptr to the wlandev structure for the
 			interface.
  Returns:
 	zero on success, non-zero otherwise.
  Call Context:
 	Can be either interrupt or not.
 ----------------------------------------------------------------
 Now to clean out the rx queue 
----------------------------------------------------------------
  p80211netdev_hwremoved
  Hardware removed notification. This function should be called
  immediately after an MSD has detected that the underlying hardware
  has been yanked out from under us.  The primary things we need
  to do are:
    - Mark the wlandev
    - Prevent any further traffic from the knetdev if
    - Prevent any further requests from mgmt if
    - If there are any waitq'd mgmt requests or mgmt-frame exchanges,
      shut them down.
    - Call the MSD hwremoved function.
  The remainder of the cleanup will be handled by unregister().
  Our primary goal here is to prevent as much tickling of the MSD
  as possible since the MSD is already in a 'wounded' state.
  TODO: As new features are added, this function should be
        updated.
  Arguments:
 	wlandev		WLAN network device structure
  Returns:
 	nothing
  Side effects:
  Call context:
 	Usually interrupt.
 ----------------------------------------------------------------
----------------------------------------------------------------
  p80211_rx_typedrop
  Classifies the frame, increments the appropriate counter, and
  returns 0|1|2 indicating whether the driver should handle, ignore, or
  drop the frame
  Arguments:
 	wlandev		wlan device structure
 	fc		frame control field
  Returns:
 	zero if the frame should be handled by the driver,
        one if the frame should be ignored
        anything else means we drop it.
  Side effects:
  Call context:
 	interrupt
 ----------------------------------------------------------------
 Classify frame, increment counter 
 printk("assocreq"); 
 printk("assocresp"); 
 printk("reassocreq"); 
 printk("reassocresp"); 
 printk("probereq"); 
 printk("proberesp"); 
 printk("beacon"); 
 printk("atim"); 
 printk("disassoc"); 
 printk("authen"); 
 printk("deauthen"); 
 printk("unknown"); 
 printk("\n"); 
 printk("pspoll"); 
 printk("rts"); 
 printk("cts"); 
 printk("ack"); 
 printk("cfend"); 
 printk("cfendcfack"); 
 printk("unknown"); 
 printk("\n"); 
 printk("unknown"); 
 SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1)
  RequestIndicationMacMgmt interface handling functions
  Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
  --------------------------------------------------------------------
  linux-wlan
    The contents of this file are subject to the Mozilla Public
    License Version 1.1 (the "License"); you may not use this file
    except in compliance with the License. You may obtain a copy of
    the License at http:www.mozilla.orgMPL
    Software distributed under the License is distributed on an "AS
    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
    implied. See the License for the specific language governing
    rights and limitations under the License.
    Alternatively, the contents of this file may be used under the
    terms of the GNU Public License version 2 (the "GPL"), in which
    case the provisions of the GPL are applicable instead of the
    above.  If you wish to allow the use of your version of this file
    only under the terms of the GPL and not to allow others to use
    your version of this file under the MPL, indicate your decision
    by deleting the provisions above and replace them with the notice
    and other provisions required by the GPL.  If you do not delete
    the provisions above, a recipient may use your version of this
    file under either the MPL or the GPL.
  --------------------------------------------------------------------
  Inquiries regarding the linux-wlan Open Source project can be
  made directly to:
  AbsoluteValue Systems Inc.
  info@linux-wlan.com
  http:www.linux-wlan.com
  --------------------------------------------------------------------
  Portions of the development of this software were funded by
  Intersil Corporation as part of PRISM(R) chipset product development.
  --------------------------------------------------------------------
  This file contains the functions, types, and macros to support the
  MLME request interface that's implemented via the device ioctls.
  --------------------------------------------------------------------
----------------------------------------------------------------
  p80211req_dorequest
  Handles an MLME requestconfirm message.
  Arguments:
 	wlandev		WLAN device struct
 	msgbuf		Buffer containing a request message
  Returns:
 	0 on success, an errno otherwise
  Call context:
 	Potentially blocks the caller, so it's a good idea to
 	not call this function from an interrupt context.
 ----------------------------------------------------------------
 Check to make sure the MSD is running 
 Check Permissions 
 Check for busy status 
 Allow p80211 to look at msg and handle if desired. 
 So far, all p80211 msgs are immediate, no waitqtimer necessary 
 This may change. 
 Pass it down to wlandev via wlandev->mlmerequest 
 if result==0, msg->status still may contain an err 
----------------------------------------------------------------
  p80211req_handlemsg
  p80211 message handler.  Primarily looks for messages that
  belong to p80211 and then dispatches the appropriate response.
  TODO: we don't do anything yet.  Once the linuxMIB is better
 	defined we'll need a getset handler.
  Arguments:
 	wlandev		WLAN device struct
 	msg		message structure
  Returns:
 	nothing (any results are set in the status field of the msg)
  Call context:
 	Process thread
 ----------------------------------------------------------------
 switch msg->msgcode 
 SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1)
 from srcprism2downloadprism2dl.c
  utility for downloading prism2 images moved into kernelspace
  Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
  --------------------------------------------------------------------
  linux-wlan
    The contents of this file are subject to the Mozilla Public
    License Version 1.1 (the "License"); you may not use this file
    except in compliance with the License. You may obtain a copy of
    the License at http:www.mozilla.orgMPL
    Software distributed under the License is distributed on an "AS
    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
    implied. See the License for the specific language governing
    rights and limitations under the License.
    Alternatively, the contents of this file may be used under the
    terms of the GNU Public License version 2 (the "GPL"), in which
    case the provisions of the GPL are applicable instead of the
    above.  If you wish to allow the use of your version of this file
    only under the terms of the GPL and not to allow others to use
    your version of this file under the MPL, indicate your decision
    by deleting the provisions above and replace them with the notice
    and other provisions required by the GPL.  If you do not delete
    the provisions above, a recipient may use your version of this
    file under either the MPL or the GPL.
  --------------------------------------------------------------------
  Inquiries regarding the linux-wlan Open Source project can be
  made directly to:
  AbsoluteValue Systems Inc.
  info@linux-wlan.com
  http:www.linux-wlan.com
  --------------------------------------------------------------------
  Portions of the development of this software were funded by
  Intersil Corporation as part of PRISM(R) chipset product development.
  --------------------------------------------------------------------
================================================================
 System Includes 
================================================================
 Local Constants 
================================================================
 Local Types 
 start address 
 in bytes 
 CRC value (if it falls at a chunk boundary) 
================================================================
 Local Static Definitions 
----------------------------------------------------------------
 s-record image processing 
 Data records 
 Plug records 
 CRC records 
 Info records 
 S7 record (there _better_ be only one) 
 Load image chunks 
 Note that for the following pdrec_t arrays, the len and code 
   fields are stored in HOST byte order. The mkpdrlist() function 
   does the conversion.  
----------------------------------------------------------------
 PDA, built from [card|newfile]+[addfile1+addfile2...] 
================================================================
 Local Function Declarations 
================================================================
 Function Definitions 
----------------------------------------------------------------
  prism2_fwtry
  Try and get firmware into memory
  Arguments:
 	udev	usb device structure
 	wlandev wlan device structure
  Returns:
 	0	- success
 	~0	- failure
 ----------------------------------------------------------------
----------------------------------------------------------------
  prism2_fwapply
  Apply the firmware loaded into memory
  Arguments:
 	rfptr	firmware image in kernel memory
 	wlandev device
  Returns:
 	0	- success
 	~0	- failure
 ----------------------------------------------------------------
 Initialize the data structures 
 clear the pda and add an initial END record 
 len in words 
-----------------------------------------------------
 Put card into fwload state 
 Build the PDA we're going to use. 
 read the card's PRI-SUP 
 DIDmsg_dot11req_mibget 
 Already in host order 
 Read the S3 file 
 Make the image chunks 
 Do any plugging 
 Insert any CRCs 
 Write the image 
 clear any allocated memory 
----------------------------------------------------------------
  crcimage
  Adds a CRC16 in the two bytes prior to each block identified by
  an S3 CRC record.  Currently, we don't actually do a CRC we just
  insert the value 0xC0DE in hfa384x order.
  Arguments:
 	fchunk		Array of image chunks
 	nfchunks	Number of image chunks
 	s3crc		Array of crc records
 	ns3crc		Number of crc records
  Returns:
 	0	success
 	~0	failure
 ----------------------------------------------------------------
 Find chunk 
 the line below does an address & len match search 
 unfortunately, I've found that the len fields of 
 some crc records don't match with the length of 
 the actual data, so we're not checking right now 
 if (crcstart-2 >= cstart && crcend <= cend) break; 
 note the -2 below, it's to make sure the chunk has 
 space for the CRC value 
 Insert crc 
----------------------------------------------------------------
  free_chunks
  Clears the chunklist data structures in preparation for a new file.
  Arguments:
 	none
  Returns:
 	nothing
 ----------------------------------------------------------------
----------------------------------------------------------------
  free_srecs
  Clears the srec data structures in preparation for a new file.
  Arguments:
 	none
  Returns:
 	nothing
 ----------------------------------------------------------------
----------------------------------------------------------------
  mkimage
  Scans the currently loaded set of S records for data residing
  in contiguous memory regions.  Each contiguous region is then
  made into a 'chunk'.  This function assumes that we're building
  a new chunk list.  Assumes the s3data items are in sorted order.
  Arguments:	none
  Returns:
 	0	- success
 	~0	- failure (probably an errno)
 ----------------------------------------------------------------
 There may already be data in the chunklist 
 Establish the location and size of each chunk 
 existing chunk, grow it 
 New chunk 
 Expand the chunk if there is a CRC record at 
 their beginning bound 
 We're currently assuming there aren't any overlapping chunks 
  if this proves false, we'll need to add code to coalesce. 
 Allocate buffer space for chunks 
 Copy srec data to chunks 
----------------------------------------------------------------
  mkpdrlist
  Reads a raw PDA and builds an array of pdrec_t structures.
  Arguments:
 	pda	buffer containing raw PDA bytes
 	pdrec	ptr to an array of pdrec_t's.  Will be filled on exit.
 	nrec	ptr to a variable that will contain the count of PDRs
  Returns:
 	0	- success
 	~0	- failure (probably an errno)
 ----------------------------------------------------------------
 in 'words' 
----------------------------------------------------------------
  plugimage
  Plugs the given image using the given plug records from the given
  PDA and filename.
  Arguments:
 	fchunk		Array of image chunks
 	nfchunks	Number of image chunks
 	s3plug		Array of plug records
 	ns3plug		Number of plug records
 	pda		Current pda data
  Returns:
 	0	success
 	~0	failure
 ----------------------------------------------------------------
 plug index 
 index of PDR or -1 if fname plug 
 chunk index 
 for each plug record 
 find the matching PDR (or filename) 
 not filename 
  if no matching PDR, fail 
 and move on to the next PDR 
			 MSM: They swear that unless it's the MAC address,
			  the serial number, or the TX calibration records,
			  then there's reasonable defaults in the fw
			  image.  Therefore, missing PDRs in the card
			  should only be a warning, not fatal.
			  TODO: add fatals for the PDRs mentioned above.
 Validate plug len against PDR len 
		
		  Validate plug address against
		  chunk data and identify chunk
 Plug data 
 plug the filename 
 plug a PDR 
----------------------------------------------------------------
  read_cardpda
  Sends the command for the driver to read the pda from the card
  named in the device variable.  Upon success, the card pda is
  stored in the "cardpda" variables.  Note that the pda structure
  is considered 'well formed' after this function.  That means
  that the nrecs is valid, the rec array has been set up, and there's
  a valid PDAEND record in the raw PDA data.
  Arguments:
 	pda		pda structure
 	wlandev		device
  Returns:
 	0	- success
 	~0	- failure (probably an errno)
 ----------------------------------------------------------------
 set up the msg 
 prism2mgmt_readpda prints an errno if appropriate 
 resultcode must've been something other than success 
----------------------------------------------------------------
  read_fwfile
  Reads the given fw file which should have been compiled from an srec
  file. Each record in the fw file will either be a plain data record,
  a start address record, or other records used for plugging.
  Note that data records are expected to be sorted into
  ascending address order in the fw file.
  Note also that the start address record, originally an S7 record in
  the srec file, is expected in the fw file to be like a data record but
  with a certain address to make it identifiable.
  Here's the SREC format that the fw should have come from:
  S[37]nnaaaaaaaaddd...dddcc
        nn - number of bytes starting with the address field
  aaaaaaaa - address in readable (or big endian) format
  dd....dd - 0-245 data bytes (two chars per byte)
        cc - checksum
  The S7 record's (there should be only one) address value gets
  converted to an S3 record with address of 0xff400000, with the
  start address being stored as a 4 byte data word. That address is
  the start execution address used for RAM downloads.
  The S3 records have a collection of subformats indicated by the
  value of aaaaaaaa:
    0xff000000 - Plug record, data field format:
                 xxxxxxxxaaaaaaaassssssss
                 x - PDR code number (little endian)
                 a - Address in load image to plug (little endian)
                 s - Length of plug data area (little endian)
    0xff100000 - CRC16 generation record, data field format:
                 aaaaaaaassssssssbbbbbbbb
                 a - Start address for CRC calculation (little endian)
                 s - Length of data to  calculate over (little endian)
                 b - Boolean, true=write crc, false=don't write
    0xff200000 - Info record, data field format:
                 ssssttttdd..dd
                 s - Size in words (little endian)
                 t - Info type (little endian), see #defines and
                     struct s3inforec for details about types.
                 d - (s - 1) little endian words giving the contents of
                     the given info type.
    0xff400000 - Start address record, data field format:
                 aaaaaaaa
                 a - Address in load image to plug (little endian)
  Arguments:
 	record	firmware image (ihex record structure) in kernel memory
  Returns:
 	0	- success
 	~0	- failure (probably an errno)
 ----------------------------------------------------------------
 Point into data for different word lengths 
 parse what was an S3 srec and put it in the right array 
 Data record 
----------------------------------------------------------------
  writeimage
  Takes the chunks, builds p80211 messages and sends them down
  to the driver for writing to the card.
  Arguments:
 	wlandev		device
 	fchunk		Array of image chunks
 	nfchunks	Number of image chunks
  Returns:
 	0	success
 	~0	failure
 ----------------------------------------------------------------
 Initialize the messages 
 Send xxx_state(enable) 
 Now, loop through the data chunks and send WRITESIZE_MAX data 
 TODO Move this to a separate function 
 Setup the message 
 Send flashdl_write(pda) 
 Check the results 
 Send xxx_state(disable) 
 MAC compat range 
 PRI compat range 
 SEC compat range 
 FIXME: isn't something missing here? 
 walk through 
 SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1)
  Management request handler functions.
  Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
  --------------------------------------------------------------------
  linux-wlan
    The contents of this file are subject to the Mozilla Public
    License Version 1.1 (the "License"); you may not use this file
    except in compliance with the License. You may obtain a copy of
    the License at http:www.mozilla.orgMPL
    Software distributed under the License is distributed on an "AS
    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
    implied. See the License for the specific language governing
    rights and limitations under the License.
    Alternatively, the contents of this file may be used under the
    terms of the GNU Public License version 2 (the "GPL"), in which
    case the provisions of the GPL are applicable instead of the
    above.  If you wish to allow the use of your version of this file
    only under the terms of the GPL and not to allow others to use
    your version of this file under the MPL, indicate your decision
    by deleting the provisions above and replace them with the notice
    and other provisions required by the GPL.  If you do not delete
    the provisions above, a recipient may use your version of this
    file under either the MPL or the GPL.
  --------------------------------------------------------------------
  Inquiries regarding the linux-wlan Open Source project can be
  made directly to:
  AbsoluteValue Systems Inc.
  info@linux-wlan.com
  http:www.linux-wlan.com
  --------------------------------------------------------------------
  Portions of the development of this software were funded by
  Intersil Corporation as part of PRISM(R) chipset product development.
  --------------------------------------------------------------------
  The functions in this file handle management requests sent from
  user mode.
  Most of these functions have two separate blocks of code that are
  conditional on whether this is a station or an AP.  This is used
  to separate out the STA and AP responses to these management primitives.
  It's a choice (good, bad, indifferent?) to have the code in the same
  place so it's clear that the same primitive is implemented in both
  cases but has different behavior.
  --------------------------------------------------------------------
 Converts 802.11 format rate specifications to prism2 
----------------------------------------------------------------
  prism2mgmt_scan
  Initiate a scan for BSSs.
  This function corresponds to MLME-scan.request and part of
  MLME-scan.confirm.  As far as I can tell in the standard, there
  are no restrictions on when a scan.request may be issued.  We have
  to handle in whatever state the driverMAC happen to be.
  Arguments:
 	wlandev		wlan device structure
 	msgp		ptr to msg buffer
  Returns:
 	0	success and done
 	<0	success, but we're waiting for something to finish.
 	>0	an error occurred while handling the message.
  Side effects:
  Call context:
 	process thread  (usually)
 	interrupt
 ----------------------------------------------------------------
 gatekeeper check 
 save current roaming mode 
 drop into mode 3 for the scan 
 active or passive? 
 set up the txrate to be 2MBPS. Should be fastest basicrate... 
 set up the channel list 
 channel 1 is BIT 0 ... channel 14 is BIT 13 
 set up the ssid, if present. 
 Enable the MAC port if it's not already enabled  
		 Construct a bogus SSID and assign it to OwnSSID and
		  DesiredSSID
 bsstype 
 ibss options 
 Figure out our timeout first Kus, then HZ 
 Issue the scan request 
 sleep until info frame arrives 
 Disable port if we temporarily enabled it. 
 restore original roaming mode 
----------------------------------------------------------------
  prism2mgmt_scan_results
  Retrieve the BSS description for one of the BSSs identified in
  a scan.
  Arguments:
 	wlandev		wlan device structure
 	msgp		ptr to msg buffer
  Returns:
 	0	success and done
 	<0	success, but we're waiting for something to finish.
 	>0	an error occurred while handling the message.
  Side effects:
  Call context:
 	process thread  (usually)
 	interrupt
 ----------------------------------------------------------------
 signal and noise 
 BSSID 
 SSID 
 supported rates 
 beacon period 
 timestamps 
 atim window 
 Channel 
 capinfo bits 
 privacy flag 
 cfpollable 
 cfpollreq 
 bsstype 
----------------------------------------------------------------
  prism2mgmt_start
  Start a BSS.  Any station can do this for IBSS, only AP for ESS.
  Arguments:
 	wlandev		wlan device structure
 	msgp		ptr to msg buffer
  Returns:
 	0	success and done
 	<0	success, but we're waiting for something to finish.
 	>0	an error occurred while handling the message.
  Side effects:
  Call context:
 	process thread  (usually)
 	interrupt
 ----------------------------------------------------------------
 Set the SSID 
 ADHOC IBSS 
 see if current fw is less than 8c3 
 Ad-Hoc not quite supported on Prism2 
 STATION 
 Set the REQUIRED config items 
 SSID 
 bsstype - we use the default in the ap firmware 
 IBSS port 
 beacon period 
 dschannel 
 Basic rates 
 Operational rates (supprates and txratecontrol) 
 Set the macmode so the frame setup code knows what to do 
 lets extend the data length a bit 
 Enable the Port 
----------------------------------------------------------------
  prism2mgmt_readpda
  Collect the PDA data and put it in the message.
  Arguments:
 	wlandev		wlan device structure
 	msgp		ptr to msg buffer
  Returns:
 	0	success and done
 	<0	success, but we're waiting for something to finish.
 	>0	an error occurred while handling the message.
  Side effects:
  Call context:
 	process thread  (usually)
 ----------------------------------------------------------------
	 We only support collecting the PDA when in the FWLOAD
	  state.
		  Call drvr_readpda(), it handles the auxport enable
		   and validating the returned PDA.
----------------------------------------------------------------
  prism2mgmt_ramdl_state
  Establishes the beginningend of a card RAM download session.
  It is expected that the ramdl_write() function will be called
  one or more times between the 'enable' and 'disable' calls to
  this function.
  Note: This function should not be called when a mac comm port
        is active.
  Arguments:
 	wlandev		wlan device structure
 	msgp		ptr to msg buffer
  Returns:
 	0	success and done
 	<0	success, but we're waiting for something to finish.
 	>0	an error occurred while handling the message.
  Side effects:
  Call context:
 	process thread  (usually)
 ----------------------------------------------------------------
	
	  Note: Interrupts are locked out if this is an AP and are NOT
	  locked out if this is a station.
----------------------------------------------------------------
  prism2mgmt_ramdl_write
  Writes a buffer to the card RAM using the download state.  This
  is for writing code to card RAM.  To just read or write raw data
  use the aux functions.
  Arguments:
 	wlandev		wlan device structure
 	msgp		ptr to msg buffer
  Returns:
 	0	success and done
 	<0	success, but we're waiting for something to finish.
 	>0	an error occurred while handling the message.
  Side effects:
  Call context:
 	process thread  (usually)
 ----------------------------------------------------------------
 first validate the length 
 call the hfa384x function to do the write 
----------------------------------------------------------------
  prism2mgmt_flashdl_state
  Establishes the beginningend of a card Flash download session.
  It is expected that the flashdl_write() function will be called
  one or more times between the 'enable' and 'disable' calls to
  this function.
  Note: This function should not be called when a mac comm port
        is active.
  Arguments:
 	wlandev		wlan device structure
 	msgp		ptr to msg buffer
  Returns:
 	0	success and done
 	<0	success, but we're waiting for something to finish.
 	>0	an error occurred while handling the message.
  Side effects:
  Call context:
 	process thread  (usually)
 ----------------------------------------------------------------
	
	  Note: Interrupts are locked out if this is an AP and are NOT
	  locked out if this is a station.
		 NOTE: At this point, the MAC is in the post-reset
		  state and the driver is in the fwload state.
		  We need to get the MAC back into the fwload
		  state.  To do this, we set the nsdstate to HWPRESENT
		  and then call the ifstate function to redo everything
		  that got us into the fwload state.
----------------------------------------------------------------
  prism2mgmt_flashdl_write
  Arguments:
 	wlandev		wlan device structure
 	msgp		ptr to msg buffer
  Returns:
 	0	success and done
 	<0	success, but we're waiting for something to finish.
 	>0	an error occurred while handling the message.
  Side effects:
  Call context:
 	process thread  (usually)
 ----------------------------------------------------------------
	
	  Note: Interrupts are locked out if this is an AP and are NOT
	  locked out if this is a station.
 first validate the length 
 call the hfa384x function to do the write 
----------------------------------------------------------------
  prism2mgmt_autojoin
  Associate with an ESS.
  Arguments:
 	wlandev		wlan device structure
 	msgp		ptr to msg buffer
  Returns:
 	0	success and done
 	<0	success, but we're waiting for something to finish.
 	>0	an error occurred while handling the message.
  Side effects:
  Call context:
 	process thread  (usually)
 	interrupt
 ----------------------------------------------------------------
 Set the SSID 
 Disable the Port 
 STATION 
 Set the TxRates 
 Set the auth type 
 Set the ssid 
 Set the PortType 
 Enable the Port 
 Set the resultcode 
----------------------------------------------------------------
  prism2mgmt_wlansniff
  Start or stop sniffing.
  Arguments:
 	wlandev		wlan device structure
 	msgp		ptr to msg buffer
  Returns:
 	0	success and done
 	<0	success, but we're waiting for something to finish.
 	>0	an error occurred while handling the message.
  Side effects:
  Call context:
 	process thread  (usually)
 	interrupt
 ----------------------------------------------------------------
 Confirm that we're in monitor mode 
 Disable monitor mode 
 Disable port 0 
 Clear the driver state 
 Restore the wepflags 
 Set the port to its prior type and enable (if necessary) 
 Enable the port 
 Disable the port (if enabled), only check Port 0 
 Save macport 0 state 
 Save the wepflags state 
 Disable the port 
 Set the channel we wish to sniff  
 Now if we're already sniffing, we can skip the rest 
 Set the port type to pIbss 
 Set the wepflags for no decryption 
 Do we want to strip the FCS in monitor mode? 
 Do we want to truncate the packets? 
 Enable the port 
 Enable monitor mode 
 Set the driver state 
 Do we want the prism2 header? 
 SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1)
  Management request for mibsetmibget
  Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
  --------------------------------------------------------------------
  linux-wlan
    The contents of this file are subject to the Mozilla Public
    License Version 1.1 (the "License"); you may not use this file
    except in compliance with the License. You may obtain a copy of
    the License at http:www.mozilla.orgMPL
    Software distributed under the License is distributed on an "AS
    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
    implied. See the License for the specific language governing
    rights and limitations under the License.
    Alternatively, the contents of this file may be used under the
    terms of the GNU Public License version 2 (the "GPL"), in which
    case the provisions of the GPL are applicable instead of the
    above.  If you wish to allow the use of your version of this file
    only under the terms of the GPL and not to allow others to use
    your version of this file under the MPL, indicate your decision
    by deleting the provisions above and replace them with the notice
    and other provisions required by the GPL.  If you do not delete
    the provisions above, a recipient may use your version of this
    file under either the MPL or the GPL.
  --------------------------------------------------------------------
  Inquiries regarding the linux-wlan Open Source project can be
  made directly to:
  AbsoluteValue Systems Inc.
  info@linux-wlan.com
  http:www.linux-wlan.com
  --------------------------------------------------------------------
  Portions of the development of this software were funded by
  Intersil Corporation as part of PRISM(R) chipset product development.
  --------------------------------------------------------------------
  The functions in this file handle the mibsetmibget management
  functions.
  --------------------------------------------------------------------
 Max length of RID record (in bytes). 
 MIB is supported on stations. 
 MIB may be read. 
 MIB may be written. 
 dot11smt MIB's 
 dot11mac MIB's 
 dot11phy MIB's 
 p2Static MIB's 
 p2MAC MIB's 
 And finally, lnx mibs 
  prism2mgmt_mibset_mibget
  Set the value of a mib item.
  Arguments:
 	wlandev		wlan device structure
 	msgp		ptr to msg buffer
  Returns:
 	0	success and done
 	<0	success, but we're waiting for something to finish.
 	>0	an error occurred while handling the message.
  Side effects:
  Call context:
 	process thread  (usually)
 	interrupt
	
	  Determine if this is an Access Point or a station.
	
	  Find the MIB in the MIB table.  Note that a MIB may be in the
	  table twice...once for an AP and once for a station.  Make sure
	  to get the correct one.  Note that DID=0 marks the end of the
	  MIB table.
	
	  Determine if this is a "mibget" or a "mibset".  If this is a
	  "mibget", then make sure that the MIB may be read.  Otherwise,
	  this is a "mibset" so make sure that the MIB may be written.
	
	  Execute the MIB function.  If things worked okay, then make
	  sure that the MIB function also worked okay.  If so, and this
	  is a "mibget", then the status value must be set for both the
	  "mibattribute" parameter and the mib item within the data
	  portion of the "mibattribute".
  prism2mib_bytearea2pstr
  Getset pstr data tofrom a byte area.
  MIB record parameters:
        parm1    Prism2 RID value.
        parm2    Number of bytes of RID data.
        parm3    Not used.
  Arguments:
        mib      MIB record.
        isget    MIBGETMIBSET flag.
        wlandev  wlan device structure.
        priv     "priv" structure.
        hw       "hw" structure.
        msg      Message structure.
        data     Data buffer.
  Returns:
        0   - Success.
        ~0  - Error.
  prism2mib_uint32
  Getset uint32 data.
  MIB record parameters:
        parm1    Prism2 RID value.
        parm2    Not used.
        parm3    Not used.
  Arguments:
        mib      MIB record.
        isget    MIBGETMIBSET flag.
        wlandev  wlan device structure.
        priv     "priv" structure.
        hw       "hw" structure.
        msg      Message structure.
        data     Data buffer.
  Returns:
        0   - Success.
        ~0  - Error.
  prism2mib_flag
  Getset a flag.
  MIB record parameters:
        parm1    Prism2 RID value.
        parm2    Bit to getset.
        parm3    Not used.
  Arguments:
        mib      MIB record.
        isget    MIBGETMIBSET flag.
        wlandev  wlan device structure.
        priv     "priv" structure.
        hw       "hw" structure.
        msg      Message structure.
        data     Data buffer.
  Returns:
        0   - Success.
        ~0  - Error.
  prism2mib_wepdefaultkey
  Getset WEP default keys.
  MIB record parameters:
        parm1    Prism2 RID value.
        parm2    Number of bytes of RID data.
        parm3    Not used.
  Arguments:
        mib      MIB record.
        isget    MIBGETMIBSET flag.
        wlandev  wlan device structure.
        priv     "priv" structure.
        hw       "hw" structure.
        msg      Message structure.
        data     Data buffer.
  Returns:
        0   - Success.
        ~0  - Error.
 Should never happen. 
  prism2mib_privacyinvoked
  Getset the dot11PrivacyInvoked value.
  MIB record parameters:
        parm1    Prism2 RID value.
        parm2    Bit value for PrivacyInvoked flag.
        parm3    Not used.
  Arguments:
        mib      MIB record.
        isget    MIBGETMIBSET flag.
        wlandev  wlan device structure.
        priv     "priv" structure.
        hw       "hw" structure.
        msg      Message structure.
        data     Data buffer.
  Returns:
        0   - Success.
        ~0  - Error.
  prism2mib_fragmentationthreshold
  Getset the fragmentation threshold.
  MIB record parameters:
        parm1    Prism2 RID value.
        parm2    Not used.
        parm3    Not used.
  Arguments:
        mib      MIB record.
        isget    MIBGETMIBSET flag.
        wlandev  wlan device structure.
        priv     "priv" structure.
        hw       "hw" structure.
        msg      Message structure.
        data     Data buffer.
  Returns:
        0   - Success.
        ~0  - Error.
  prism2mib_priv
  Getset values in the "priv" data structure.
  MIB record parameters:
        parm1    Not used.
        parm2    Not used.
        parm3    Not used.
  Arguments:
        mib      MIB record.
        isget    MIBGETMIBSET flag.
        wlandev  wlan device structure.
        priv     "priv" structure.
        hw       "hw" structure.
        msg      Message structure.
        data     Data buffer.
  Returns:
        0   - Success.
        ~0  - Error.
		
		  This can never work: wpa is on the stack
		  and has no bytes allocated in wpa.data.
			
			pstr->len = le16_to_cpu(wpa.datalen);
			memcpy(pstr->data, wpa.data, pstr->len);
			
			wpa.datalen = cpu_to_le16(pstr->len);
			memcpy(wpa.data, pstr->data, pstr->len);
  prism2mgmt_pstr2bytestr
  Convert the pstr data in the WLAN message structure into an hfa384x
  byte string format.
  Arguments:
 	bytestr		hfa384x byte string data type
 	pstr		wlan message data
  Returns:
 	Nothing
  prism2mgmt_bytestr2pstr
  Convert the data in an hfa384x byte string format into a
  pstr in the WLAN message.
  Arguments:
 	bytestr		hfa384x byte string data type
 	msg		wlan message
  Returns:
 	Nothing
  prism2mgmt_bytearea2pstr
  Convert the data in an hfa384x byte area format into a pstr
  in the WLAN message.
  Arguments:
 	bytearea	hfa384x byte area data type
 	msg		wlan message
  Returns:
 	Nothing
 SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1)
  Implements the station functionality for prism2
  Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
  --------------------------------------------------------------------
  linux-wlan
    The contents of this file are subject to the Mozilla Public
    License Version 1.1 (the "License"); you may not use this file
    except in compliance with the License. You may obtain a copy of
    the License at http:www.mozilla.orgMPL
    Software distributed under the License is distributed on an "AS
    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
    implied. See the License for the specific language governing
    rights and limitations under the License.
    Alternatively, the contents of this file may be used under the
    terms of the GNU Public License version 2 (the "GPL"), in which
    case the provisions of the GPL are applicable instead of the
    above.  If you wish to allow the use of your version of this file
    only under the terms of the GPL and not to allow others to use
    your version of this file under the MPL, indicate your decision
    by deleting the provisions above and replace them with the notice
    and other provisions required by the GPL.  If you do not delete
    the provisions above, a recipient may use your version of this
    file under either the MPL or the GPL.
  --------------------------------------------------------------------
  Inquiries regarding the linux-wlan Open Source project can be
  made directly to:
  AbsoluteValue Systems Inc.
  info@linux-wlan.com
  http:www.linux-wlan.com
  --------------------------------------------------------------------
  Portions of the development of this software were funded by
  Intersil Corporation as part of PRISM(R) chipset product development.
  --------------------------------------------------------------------
  This file implements the module and linux pcmcia routines for the
  prism2 driver.
  --------------------------------------------------------------------
 Reset hold time in ms 
 Reset settle time in ms 
 Do a reset at init? 
  prism2sta_open
  WLAN device open method.  Called from p80211netdev when kernel
  device open (start) method is called in response to the
  SIOCSIIFFLAGS ioctl changing the flags bit IFF_UP
  from clear to set.
  Arguments:
 	wlandev		wlan device structure
  Returns:
 	0	success
 	>0	fw reported error
 	<0	driver reported error
  Side effects:
  Call context:
 	process thread
	 We don't currently have to do anything else.
	  The setup of the MAC should be subsequently completed via
	  the mlme commands.
	  Higher layers know we're ready from dev->start==1 and
	  dev->tbusy==0.  Our rx path knows to pass up received
	  frames because of dev->flags&IFF_UP is true.
  prism2sta_close
  WLAN device close method.  Called from p80211netdev when kernel
  device close method is called in response to the
  SIOCSIIFFLAGS ioctl changing the flags bit IFF_UP
  from set to clear.
  Arguments:
 	wlandev		wlan device structure
  Returns:
 	0	success
 	>0	fw reported error
 	<0	driver reported error
  Side effects:
  Call context:
 	process thread
	 We don't currently have to do anything else.
	  Higher layers know we're not ready from dev->start==0 and
	  dev->tbusy==1.  Our rx path knows to not pass up received
	  frames because of dev->flags&IFF_UP is false.
  prism2sta_reset
  Currently not implemented.
  Arguments:
 	wlandev		wlan device structure
 	none
  Returns:
 	nothing
  Side effects:
  Call context:
 	process thread
  prism2sta_txframe
  Takes a frame from p80211 and queues it for transmission.
  Arguments:
 	wlandev		wlan device structure
 	pb		packet buffer struct.  Contains an 802.11
 			data frame.
        p80211_hdr      points to the 802.11 header for the packet.
  Returns:
 	0		Success and more buffs available
 	1		Success but no more buffs
 	2		Allocation failure
 	4		Buffer full or queue busy
  Side effects:
  Call context:
 	process thread
 If necessary, set the 802.11 WEP bit 
  prism2sta_mlmerequest
  wlan command message handler.  All we do here is pass the message
  over to the prism2sta_mgmt_handler.
  Arguments:
 	wlandev		wlan device structure
 	msg		wlan command message
  Returns:
 	0		success
 	<0		successful acceptance of message, but we're
 			waiting for an async process to finish before
 			we're done with the msg.  When the asynch
 			process is done, we'll call the p80211
 			function p80211req_confirm() .
 	>0		An error occurred while we were handling
 			the message.
  Side effects:
  Call context:
 	process thread
		
		  Prism2 specific messages
		
		  Linux specific messages
 ignore me. 
  prism2sta_ifstate
  Interface state.  This is the primary WLAN interface enabledisable
  handler.  Following the driverloaddeviceprobe sequence, this
  function must be called with a state of "enable" before any other
  commands will be accepted.
  Arguments:
 	wlandev		wlan device structure
 	msgp		ptr to msg buffer
  Returns:
 	A p80211 message resultcode value.
  Side effects:
  Call context:
 	process thread  (usually)
 	interrupt
			
			  Initialize the device+driver sufficiently
			  for firmware loading.
			 probe() had a problem or the msdstate contains
			  an unrecognized value, there's nothing we can do.
			 Initialize the device+driver for full
			  operation. Note that this might me an FWLOAD
			  to RUNNING transition so we must not do a chip
			  or board level reset.  Note that on failure,
			  the MSD state is set to HWPRESENT because we
			  can't make any assumptions about the state
			  of the hardware or a previous firmware load.
 Do nothing, we're already in this state. 
			 probe() had a problem or the msdstate contains
			  an unrecognized value, there's nothing we can do.
 Do nothing, we're already in this state. 
			
			  TODO: Shut down the MAC completely. Here a chip
			  or board level reset is probably called for.
			  After a "disable" _all_ results are lost, even
			  those from a fwload.
			 probe() had a problem or the msdstate contains
			  an unrecognized value, there's nothing we can do.
  prism2sta_getcardinfo
  Collect the NICID, firmware version and any other identifiers
  we'd like to have in host-side data structures.
  Arguments:
 	wlandev		wlan device structure
  Returns:
 	0	success
 	>0	fw reported error
 	<0	driver reported error
  Side effects:
  Call context:
 	Either.
 Collect version and compatibility info 
  Some are critical, some are not 
 NIC identity 
 get all the nic id fields in host byte order 
 Primary fw identity 
 get all the private fw id fields in host byte order 
 Station (Secondary?) fw identity 
 get all the station fw id fields in host byte order 
 strip out the 'special' variant bits 
 Compatibility range, Modem supplier 
	 get all the Compatibility range, modem interface supplier
	  fields in byte order
 Compatibility range, Controller supplier 
	 get all the Compatibility range, controller interface supplier
	  fields in byte order
 Compatibility range, Primary fw supplier 
	 get all the Compatibility range, primary firmware supplier
	  fields in byte order
 Compatibility range, Station fw supplier 
	 get all the Compatibility range, station firmware supplier
	  fields in byte order
 Compatibility range, primary fw actor, CFI supplier 
	 get all the Compatibility range, primary fw actor, CFI supplier
	  fields in byte order
 Compatibility range, sta fw actor, CFI supplier 
	 get all the Compatibility range, station fw actor, CFI supplier
	  fields in byte order
 Compatibility range, sta fw actor, MFI supplier 
	 get all the Compatibility range, station fw actor, MFI supplier
	  fields in byte order
 Serial Number 
 Collect the MAC address 
 short preamble is always implemented 
 find out if hardware wep is implemented 
 get the dBm Scaling constant 
 Only enable scan by default on newer firmware 
 TODO: Set any internally managed config items 
  prism2sta_globalsetup
  Set any global RIDs that we want to set at device activation.
  Arguments:
 	wlandev		wlan device structure
  Returns:
 	0	success
 	>0	fw reported error
 	<0	driver reported error
  Side effects:
  Call context:
 	process thread
 Set the maximum frame size 
 If we're not ready, what's the point? 
  prism2sta_inf_handover
  Handles the receipt of a Handover info frame. Should only be present
  in APs only.
  Arguments:
 	wlandev		wlan device structure
 	inf		ptr to info frame (contents in hfa384x order)
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
  prism2sta_inf_tallies
  Handles the receipt of a CommTallies info frame.
  Arguments:
 	wlandev		wlan device structure
 	inf		ptr to info frame (contents in hfa384x order)
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
	
	  Determine if these are 16-bit or 32-bit tallies, based on the
	  record length of the info record.
  prism2sta_inf_scanresults
  Handles the receipt of a Scan Results info frame.
  Arguments:
 	wlandev		wlan device structure
 	inf		ptr to info frame (contents in hfa384x order)
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
 Get the number of results, first in bytes, then in results 
 Print em 
 issue a join request 
  prism2sta_inf_hostscanresults
  Handles the receipt of a Scan Results info frame.
  Arguments:
 	wlandev		wlan device structure
 	inf		ptr to info frame (contents in hfa384x order)
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
 Notifywake the sleeping caller. 
  prism2sta_inf_chinforesults
  Handles the receipt of a Channel Info Results info frame.
  Arguments:
 	wlandev		wlan device structure
 	inf		ptr to info frame (contents in hfa384x order)
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
 First let's process the auth frames 
 Now let's handle the linkstatus stuff 
		 I'm currently assuming that this is the initial link
		  state.  It should only be possible immediately
		  following an Enable command.
		  Response:
		  Block Transmits, Ignore receives of data frames
		 This one indicates a successful scanjoinauthassoc.
		  When we have the full MLME complement, this event will
		  signify successful completion of both mlme_authenticate
		  and mlme_associate.  State management will get a little
		  ugly here.
		  Response:
		  Indicate authentication andor association
		  Enable Transmits, Receives and pass up data frames
		 If we are joining a specific AP, set our
		  state and reset retries
 Don't call this in monitor mode 
 For non-usb devices, we can use the sync versions 
 Collect the BSSID, and set state to allow tx 
 Collect the port status 
 signal back up to cfg80211 layer 
 Get the ball rolling on the comms quality stuff 
		 This one indicates that our association is gone.  We've
		  lost connection with the AP andor been disassociated.
		  This indicates that the MAC has completely cleared it's
		  associated state.  We  should send a deauth indication
		  (implying disassoc) up  to the MLME.
		  Response:
		  Indicate Deauthentication
		  Block Transmits, Ignore receives of data frames
 signal back up to cfg80211 layer 
		 This one indicates that the MAC has decided to and
		  successfully completed a change to another AP.  We
		  should probably implement a reassociation indication
		  in response to this one.  I'm thinking that the
		  p80211 layer needs to be notified in case of
		  bufferingqueueing issues.  User mode also needs to be
		  notified so that any BSS dependent elements can be
		  updated.
		  associated state.  We  should send a deauth indication
		  (implying disassoc) up  to the MLME.
		  Response:
		  Indicate Reassociation
		  Enable Transmits, Receives and pass up data frames
 signal back up to cfg80211 layer 
		 This one indicates that the MAC has decided that the
		  AP is out of range, but hasn't found a better candidate
		  so the MAC maintains its "associated" state in case
		  we get back in range.  We should block transmits and
		  receives in this state.  Do we need an indication here?
		  Probably not since a polling user-mode element would
		  get this status from p2PortStatus(FD40). What about
		  p80211?
		  Response:
		  Block Transmits, Ignore receives of data frames
		 This one indicates that the MAC has decided that the
		  AP is back in range.  We continue working with our
		  existing association.
		  Response:
		  Enable Transmits, Receives and pass up data frames
		 This one is actually a peer to CONNECTED.  We've
		  requested a join for a given SSID and optionally BSSID.
		  We can use this one to indicate authentication and
		  association failures.  The trick is going to be
		  1) identifying the failure, and 2) state management.
		  Response:
		  Disable Transmits, Ignore receives of data frames
 Send the join request 
 signal back up to cfg80211 layer 
 This is bad, IO port problems? 
  prism2sta_inf_linkstatus
  Handles the receipt of a Link Status info frame.
  Arguments:
 	wlandev		wlan device structure
 	inf		ptr to info frame (contents in hfa384x order)
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
  prism2sta_inf_assocstatus
  Handles the receipt of an Association Status info frame. Should
  be present in APs only.
  Arguments:
 	wlandev		wlan device structure
 	inf		ptr to info frame (contents in hfa384x order)
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
	
	  Find the address in the list of authenticated stations.
	  If it wasn't found, then this address has not been previously
	  authenticated and something weird has happened if this is
	  anything other than an "authentication failed" message.
	  If the address was found, then set the "associated" flag for
	  that station, based on whether the station is associating or
	  losing its association.  Something weird has also happened
	  if we find the address in the list of authenticated stations
	  but we are getting an "authentication failed" message.
  prism2sta_inf_authreq
  Handles the receipt of an Authentication Request info frame. Should
  be present in APs only.
  Arguments:
 	wlandev		wlan device structure
 	inf		ptr to info frame (contents in hfa384x order)
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
	
	  Build the AuthenticateStation record.  Initialize it for denying
	  authentication.
	
	  Authenticate based on the access mode.
		
		  Deny all new authentications.  However, if a station
		  is ALREADY authenticated, then accept it.
		
		  Allow all authentications.
		
		  Only allow the authentication if the MAC address
		  is in the list of allowed addresses.
		 
		  Since this is the interrupt handler, we may be here
		  while the access list is in the middle of being
		  updated.  Choose the list which is currently okay.
		  See "prism2mib_priv_accessallow()" for details.
		
		  Allow the authentication UNLESS the MAC address is
		  in the list of denied addresses.
		 
		  Since this is the interrupt handler, we may be here
		  while the access list is in the middle of being
		  updated.  Choose the list which is currently okay.
		  See "prism2mib_priv_accessdeny()" for details.
	
	  If the authentication is okay, then add the MAC address to the
	  list of authenticated stations.  Don't add the address if it
	  is already in the list. (802.11b does not seem to disallow
	  a station from issuing an authentication request when the
	  station is already authenticated. Does this sort of thing
	  ever happen?  We might as well do the check just in case.)
	
	  Send back the results of the authentication.  If this doesn't work,
	  then make sure to remove the address from the authenticated list if
	  it was added.
  prism2sta_inf_psusercnt
  Handles the receipt of a PowerSaveUserCount info frame. Should
  be present in APs only.
  Arguments:
 	wlandev		wlan device structure
 	inf		ptr to info frame (contents in hfa384x order)
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
  prism2sta_ev_info
  Handles the Info event.
  Arguments:
 	wlandev		wlan device structure
 	inf		ptr to a generic info frame
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
 Dispatch 
  prism2sta_ev_txexc
  Handles the TxExc event.  A Transmit Exception event indicates
  that the MAC's TX process was unsuccessful - so the packet did
  not get transmitted.
  Arguments:
 	wlandev		wlan device structure
 	status		tx frame status word
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
  prism2sta_ev_tx
  Handles the Tx event.
  Arguments:
 	wlandev		wlan device structure
 	status		tx frame status word
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
 update linux network stats 
  prism2sta_ev_alloc
  Handles the Alloc event.
  Arguments:
 	wlandev		wlan device structure
  Returns:
 	nothing
  Side effects:
  Call context:
 	interrupt
  create_wlan
  Called at module init time.  This creates the struct wlandevice structure
  and initializes it with relevant bits.
  Arguments:
 	none
  Returns:
 	the created struct wlandevice structure.
  Side effects:
 	also allocates the privhw structures.
  Call context:
 	process thread
 Alloc our structures 
 Initialize the network device object. 
 Initialize the device private data structure. 
 we don't care if we're in AP mode 
 It only makes sense to poll these in non-IBSS 
 Get the signal rate 
 Lastly, we need to make sure the BSSID didn't change on us 
 Reschedule timer 
 SPDX-License-Identifier: GPL-2.0+
 Assert and Deassert CCLK 
 Serialize byte and clock each bit on target's DIN and CCLK pins 
	
	  supports 1 and 2 bytes programming mode
  generic bit swap for xilinx SYSTEMMAP FPGA programming
  configurable per device type for different IO config
 SPDX-License-Identifier: GPL-2.0+
 fake device for request_firmware 
 read section char 
 read length 
  read bitdata length
 read section char 
 make sure it is section 'e' 
 read 4bytes length 
  read first 13 bytes to check bitstream magic number
 magic length 
  NOTE: supports only bitstream format
 DEBUG_FPGA 
 Bring csi_b, rdwr_b Low and program_b High 
 Configuration reset 
 Wait for Device Initialization 
 Check INIT_B 
 Compensate for Special Startup Conditions 
  NOTE: supports systemmap parallel programming
 SPDX-License-Identifier: GPL-2.0+
  Driver for Realtek PCI-Express card reader
  Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Wei WANG (wei_wang@realsil.com.cn)
    Micky Ching (micky_ching@realsil.com.cn)
 SPDX-License-Identifier: GPL-2.0+
  Driver for Realtek PCI-Express card reader
  Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Wei WANG (wei_wang@realsil.com.cn)
    Micky Ching (micky_ching@realsil.com.cn)
 This function can't write data more than one page 
 Check 'Busy Status' 
		 Maximum current consumption, check whether current is
		  acceptable; bit[511:496] = 0x0000 means some error happened.
 Get supported functions 
 Function Group 1: Access Mode 
		 Do not try to switch current limit if the card doesn't
		  support UHS mode or we don't want it to support UHS mode
 Function Group 4: Current Limit 
 ROM card or OTP 
 Check SD Machanical Write-Protect Switch 
 Start Initialization Process of SD Card 
			 Set sd_switch_fail here, because we needn't
			  switch to UHS mode
 Check the card whether follow SD1.1 spec or higher 
 Test Bus Procedure 
 MMC 4.x Cards 
 SUPPORT_SD_LOCK 
 SUPPORT_SD_LOCK 
 SPDX-License-Identifier: GPL-2.0+
  Driver for Realtek PCI-Express card reader
  Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Wei WANG (wei_wang@realsil.com.cn)
    Micky Ching (micky_ching@realsil.com.cn)
 Byte[47:49] 
 Byte[47:49] 
 Byte[50]: MG, MS, MSPro, MSXC 
 Byte[50]: MS, MSPro, MSXC 
 Byte[51]: Category Specific Commands 
 Byte[52]: Access Control and feature 
 Byte[53:55] 
 Additional Length 
 Media disabled 
 Media shall be unload 
 Logical Unit Not Ready Format in Progress 
 Format Command Failed 
 Reset Sense Data 
 Mode Data Length 
 Mode Data Length (MSB) 
 Mode Data Length (LSB) 
 Medium Type Code 
 WP 
 MediaType 
 WP 
 Reserved 
 Reserved 
 Block descriptor length(MSB) 
 Block descriptor length(LSB) 
 The Following Data is the content of "Page 0x20" 
 Page Code 
 Page Length 
 No Access Control 
 SF, SGM 
 The Following Data is the content of "Page 0x20" 
 Page Code 
 Page Length 
 No Access Control 
 SF, SGM 
 96 Bytes Attribute Data 
		 Accessing to any card is forbidden
		  until the erase procedure of SD is completed
	 In some test, we will receive a start_sec like 0xFFFFFFFF.
	  In this situation, start_sec + sec_cnt will overflow, so we
	  need to judge start_sec at first
 Capacity List Length 
 Variable Clock 
  GET Memory Stick Media Information Response Header 
 Data length MSB 
 Data length LSB 
 Device Information Type Code 
 SGM bit 
 Reserved 
 Number of Device Information 
  Device Information Body 
 Device Information ID Number 
 Device Information Length 
 Data length MSB 
 Data length LSB 
 Valid Bit 
 System Information 
 Model Name 
		 Block all SCSI command except for
		  REQUEST_SENSE and rs_ppstatus
 Logical Unit Not Ready Format in Progress 
 Logical Unit Not Ready Format in Progress 
 SPDX-License-Identifier: GPL-2.0+
  Driver for Realtek PCI-Express card reader
  Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Wei WANG (wei_wang@realsil.com.cn)
    Micky Ching (micky_ching@realsil.com.cn)
 SPDX-License-Identifier: GPL-2.0+
  Driver for Realtek PCI-Express card reader
  Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Wei WANG (wei_wang@realsil.com.cn)
    Micky Ching (micky_ching@realsil.com.cn)
 Read ID to check if the timing setting is right 
 Check if the xD card is supported 
 Confirm timing setting 
 Search CIS block 
 Check CIS data 
 SPDX-License-Identifier: GPL-2.0+
  Driver for Realtek PCI-Express card reader
  Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Wei WANG (wei_wang@realsil.com.cn)
    Micky Ching (micky_ching@realsil.com.cn)
  Scatter-gather transfer buffer access routines
  Copy a buffer of length buflen tofrom the srb's transfer buffer.
  (Note: for scatter-gather transfers (srb->use_sg > 0), srb->request_buffer
  points to a list of s-g entries and we ignore srb->request_bufflen.
  For non-scatter-gather transfers, srb->request_buffer points to the
  transfer buffer itself and srb->request_bufflen is the buffer's length.)
  Update the index and offset variables so that the next copy will
  pick up from where this one left off.
 If not using scatter-gather, just transfer the data directly. 
	
	  Using scatter-gather.  We have to go through the list one entry
	  at a time.  Each s-g entry contains some number of pages, and
	  each page has to be kmap()'ed separately.
		
		  This loop handles a single s-g list entry, which may
		  include multiple pages.  Find the initial page structure
		  and the starting offset within the page, and update
		  the offset and index values for the next loop.
 Transfer ends within this s-g entry 
 Transfer continues to next s-g entry 
 Start at the beginning of the next page 
 Return the amount actually transferred 
  Store the contents of buffer into srb's transfer buffer and set the
  SCSI residue.
  Transport routines
  Invoke the transport and basic error-handlingrecovery methods
  This is used to send the message to the device and receive the response.
	
	  if the command gets aborted by the higher layers, we need to
	  short-circuit all other processing.
 if there is a transport error, reset and don't auto-sense 
	
	  If we have a failure, we're going to do a REQUEST_SENSE
	  automatically.  Note that we differentiate between a command
	  "failure" and an "error" in the transport mechanism.
 set the result so the higher layers expect this data 
 Hardware Auto Response 
 set up data structures for the wakeup system 
 Hardware Auto Response 
 Wait for TRANS_OK_INT 
 set up data structures for the wakeup system 
	
	  Usually the next entry will be @sg@ + 1, but if this sg element
	  is part of a chained scatterlist, it could jump to the start of
	  a new scatterlist array. So here we use sg_next to move to
	  the proper sg.
 Wait for TRANS_OK_INT 
 set up data structures for the wakeup system 
 Wait for TRANS_OK_INT 
 set up data structures for the wakeup system 
 Wait for TRANS_OK_INT 
 don't transfer data during abort processing 
 don't transfer data during abort processing 
 SPDX-License-Identifier: GPL-2.0+
  Driver for Realtek PCI-Express card reader
  Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Wei WANG (wei_wang@realsil.com.cn)
    Micky Ching (micky_ching@realsil.com.cn)
 SPDX-License-Identifier: GPL-2.0+
  Driver for Realtek PCI-Express card reader
  Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Wei WANG (wei_wang@realsil.com.cn)
    Micky Ching (micky_ching@realsil.com.cn)
  Host functions
	
	  Set the INQUIRY transfer length to 36.  We don't use any of
	  the extra data and many devices choke if asked for more or
	  less than 36 bytes.
	
	  Scatter-gather buffers (all but the last) must have a length
	  divisible by the bulk maxpacket size.  Otherwise a data packet
	  would end up being short, causing a premature end to the data
	  transfer.  Since high-speed bulk pipes have a maxpacket size
	  of 512, we'll use that as the scsi device queue's DMA alignment
	  mask.  Guaranteeing proper alignment of the first buffer will
	  have the desired effect because, except at the beginning and
	  the end, scatter-gather buffers follow page boundaries.
	 Set the SCSI level to at least 2.  We'll leave it at 3 if that's
	  what is originally reported.  We need this to avoid confusing
	  the SCSI layer with devices that report 0 or 1, but need 10-byte
	  commands (ala ATAPI devices behind certain bridges, or devices
	  which simply have broken INQUIRY data).
	 
	  NOTE: This means devsg programs (ala cdrecord) will get the
	  actual information.  This seems to be the preference for
	  programs like that.
	 
	  NOTE: This also means that procscsiscsi and sysfs may report
	  the actual value or the modified one, depending on where the
	  data comes from.
  procscsi functions
 we use this macro to help us write into the buffer 
 queue a command 
 This is always called with scsi_lock(host) held 
 check for state-transition errors 
 fail the command if we are disconnecting 
 enqueue the command and wake up the control thread 
  Error handling functions
 Command timeout and abort 
 Is this command still active? 
 Wait for the aborted command to finish 
  This invokes the transport reset mechanism to reset the state of the
  device
  this defines our host template, with which we'll allocate hosts
 basic userland interface stuff 
 command interface -- queued only 
 error and abort handlers 
 queue commands only, only one command per LUN 
 unknown initiator id 
 lots of sg segments can be handled 
 limit the total size of a transfer to 120 KB 
 emulated HBA 
 we do our own delay after a device or bus reset 
 module management 
  power management
 lock the device pointers 
 unlock the device pointers 
 lock the device pointers 
 unlock the device pointers 
 unlock the device pointers 
 lock the device pointers 
 if the device has disconnected, we are free to exit 
 lock access to the state 
 has the command aborted ? 
		 reject the command if the direction indicator
		  is UNKNOWN
		 reject if target != 0 or if LUN is higher than
		  the maximum known LUN
 we've got a command, let's do it! 
 lock access to the state 
 did the command already complete because of a disconnect? 
 nothing to do 
 indicate that the command is done 
 finished working on this command 
 unlock the device pointers 
 for (;;) 
	 notify the exit routine that we're actually exiting now
	 
	  complete()wait_for_completion() is similar to up()down(),
	  except that complete() is safe in the case where the structure
	  is getting deleted in a parallel mode of execution (i.e. just
	  after the down() -- that's necessary for the thread-shutdown
	  case.
	 
	  complete_and_exit() goes even further than this -- it is safe in
	  the case that the thread of the caller is going away (not just
	  the structure) -- this is necessary for the module-remove case.
	  This is important in preemption kernels, which transfer the flow
	  of execution immediately upon a complete().
 Wait until SCSI scan finished 
 lock the device pointers 
 if the device has disconnected, we are free to exit 
 lock the device pointers 
 unlock the device pointers 
  interrupt handler
 card not exist, return TRANS_RESULT_FAIL 
 Release all our dynamic resources 
	 Tell the control thread to exit.  The SCSI host must
	  already have been removed so it won't try to queue
	  any more commands.
  First stage of disconnect processing: stop all commands and remove
  the host
	
	  Prevent new transfers, stop the current command, and
	  interrupt a SCSI-scan or device-reset delay
 Wait some time to let other threads exist 
	
	  queuecommand won't accept any new commands and the control
	  thread won't execute a previously-queued command.  If there
	  is such a command pending, complete it with an error.
 Now we own no commands so it's safe to remove the SCSI host 
 Second stage of disconnect processing: deallocate all resources 
	
	  Drop our reference to the host; the SCSI core will free it
	  when the refcount becomes 0.
 Thread to carry out delayed SCSI-device scanning 
 Wait for the timeout to expire or for a disconnect 
 If the device is still connected, perform the scanning 
 Should we unbind if no devices were detected? 
	
	  Ask the SCSI layer to allocate a host structure, with extra
	  space at the end for our private rtsx_dev structure.
	
	  Using "unsigned long" cast here to eliminate gcc warning in
	  64-bit system
	
	  set the supported max_lun and max_id for the scsi host
	  NOTE: the minimal value of max_id is 1
 Start up our control thread 
 Start up the thread for delayed SCSI-device scanning 
 Start up the thread for polling thread 
 We come here if there are any problems 
 PCI IDs 
 pci_driver definition 
 SPDX-License-Identifier: GPL-2.0+
  Driver for Realtek PCI-Express card reader
  Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Wei WANG (wei_wang@realsil.com.cn)
    Micky Ching (micky_ching@realsil.com.cn)
 Enable Bus Interrupt 
 Enable SDIO internal clock 
 Disable sdio_bus_auto_switch 
 Enable sdio_bus_auto_switch 
 Disable card clock 
 SSC power on, OCD power on 
 OC power down 
 Turn off LED 
 Reset delink mode 
 Card driving select 
 Enable SSC Clock 
	
	  Disable cd_pwr_save (u_force_rst_core_en=0, u_cd_rst_core_en=0)
	     0xFE5B
	     bit[1]    u_cd_rst_core_en	rst_value = 0
	     bit[2]    u_force_rst_core_en	rst_value = 0
	     bit[5]    u_mac_phy_rst_n_dbg	rst_value = 1
	     bit[4]	u_non_sticky_rst_n_dbg	rst_value = 0
 Enable ASPM 
 HW_AUTO_SWITCH_SD_BUS 
 HW_AUTO_SWITCH_SD_BUS 
 Turn off main power when entering S3S4 state 
 Reset card 
  rtsx_stop_cmd - stop command transfer and DMA transfer
  @chip: Realtek's card reader chip
  @card: flash card type
  Stop command transfer and DMA transfer.
  This function is called in error handler.
			
			  If multi-luns, it's possible that
			  when pluggingunplugging one card
			  there is another card which still
			  exists in the slot. In this case,
			  all existed cards should be reset.
 Enable sdio_bus_auto_switch 
 Enable sdio_bus_auto_switch 
 u_force_clkreq_0 
 SPDX-License-Identifier: GPL-2.0+
  Driver for Realtek PCI-Express card reader
  Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
  Author:
    Wei WANG (wei_wang@realsil.com.cn)
    Micky Ching (micky_ching@realsil.com.cn)
 Read Packet 
 Write Packet 
 Confirm CPU StartUp 
 --  end confirm CPU startup 
 Switch MS-PRO into Parallel mode 
 If MSPro HG Card, We shall try to switch to 8-bit bus 
 Signature code is wrong 
 Parallel interface 
 Serial interface 
 set page status as 1:NG,and block status keep 1:OK 
 set page status as 0:Data Error,and block status keep 1:OK 
 Block, page OK, data erased 
 Search Boot Block 
 Read MS system information as sys_info 
 Read useful block contents 
	 Block ID error
	  HEADER_ID0, HEADER_ID1
	 Page size error
	  PAGE_SIZE_0, PAGE_SIZE_1
 BLOCK_SIZE_0, BLOCK_SIZE_1 
 Block size 16KB 
 Block size 8KB 
 BLOCK_COUNT_0, BLOCK_COUNT_1 
 4MB or 8MB 
 Effective block for 4MB: 0x1F0 
 Effective block for 8MB: 0x3E0 
 16MB, 32MB, 64MB or 128MB 
 Effective block for 16MB: 0x3E0 
 Effective block for 32MB: 0x7C0 
 Effective block for 64MB: 0xF80 
 Effective block for 128MB: 0x1F00 
 EBLOCK_COUNT_0, EBLOCK_COUNT_1 
 Switch IF Mode 
 Logical Address Confirmation Process 
 Make boot block be the first normal block 
		 Build table for the last segment,
		  to check if L2P table block exists, erasing it
 SUPPORT_MAGIC_GATE 
 SPDX-License-Identifier: GPL-2.0
 mmashmem.c
  Anonymous Shared Memory Subsystem, ashmem
  Copyright (C) 2008 Google, Inc.
  Robert Love <rlove@google.com>
  struct ashmem_area - The anonymous shared memory area
  @name:		The optional name in procpidmaps
  @unpinned_list:	The list of all ashmem areas
  @file:		The shmem-based backing file
  @size:		The size of the mapping, in bytes
  @prot_mask:		The allowed protection bits, as vm_flags
  The lifecycle of this structure is from our parent file's open() until
  its release(). It is also protected by 'ashmem_mutex'
  Warning: Mappings do NOT pin this structure; It dies on close()
  struct ashmem_range - A range of unpinnedevictable pages
  @lru:	         The entry in the LRU list
  @unpinned:	         The entry in its area's unpinned list
  @asma:	         The associated anonymous shared memory area.
  @pgstart:	         The starting page (inclusive)
  @pgend:	         The ending page (inclusive)
  @purged:	         The purge status (ASHMEM_NOT or ASHMEM_WAS_PURGED)
  The lifecycle of this structure is from unpin to pin.
  It is protected by 'ashmem_mutex'
 LRU list of unpinned pages, protected by ashmem_mutex 
  long lru_count - The count of pages on our LRU list.
  This is protected by ashmem_mutex.
  ashmem_mutex - protects the list of and each individual ashmem_area
  Lock Ordering: ashmex_mutex -> i_mutex -> i_alloc_sem
  A separate lockdep class for the backing shmem inodes to resolve the lockdep
  warning about the race between kswapd taking fs_reclaim before inode_lock
  and write syscall taking inode_lock and then fs_reclaim.
  Note that such race is impossible because ashmem does not support write
  syscalls operating on the backing shmem.
  lru_add() - Adds a range of memory to the LRU list
  @range:     The memory range being added.
  The range is first added to the end (tail) of the LRU list.
  After this, the size of the range is added to @lru_count
  lru_del() - Removes a range of memory from the LRU list
  @range:     The memory range being removed
  The range is first deleted from the LRU list.
  After this, the size of the range is removed from @lru_count
  range_alloc() - Allocates and initializes a new ashmem_range structure
  @asma:	   The associated ashmem_area
  @prev_range:	   The previous ashmem_range in the sorted asma->unpinned list
  @purged:	   Initial purge status (ASMEM_NOT_PURGED or ASHMEM_WAS_PURGED)
  @start:	   The starting page (inclusive)
  @end:	   The ending page (inclusive)
  @new_range:	   The placeholder for the new range
  This function is protected by ashmem_mutex.
  range_del() - Deletes and deallocates an ashmem_range structure
  @range:	 The associated ashmem_range that has previously been allocated
  range_shrink() - Shrinks an ashmem_range
  @range:	    The associated ashmem_range being shrunk
  @start:	    The starting byte of the new range
  @end:	    The ending byte of the new range
  This does not modify the data inside the existing range in any way - It
  simply shrinks the boundaries of the range.
  Theoretically, with a little tweaking, this could eventually be changed
  to range_resize, and expand the lru_count if the new range is larger.
  ashmem_open() - Opens an Anonymous Shared Memory structure
  @inode:	   The backing file's index node(?)
  @file:	   The backing file
  Please note that the ashmem_area is not returned by this function - It is
  instead written to "file->private_data".
  Return: 0 if successful, or another code if unsuccessful.
  ashmem_release() - Releases an Anonymous Shared Memory structure
  @ignored:	      The backing file's Index Node(?) - It is ignored here.
  @file:	      The backing file
  Return: 0 if successful. If it is anything else, go have a coffee and
  try again.
 If size is not set, or set to 0, always return EOF. 
	
	  asma and asma->file are used outside the lock here.  We assume
	  once asma->file is set it will never be changed, and will not
	  be destroyed until all references to the file are dropped and
	  ashmem_release is called.
 Copy f_pos from backing file, since f_ops->llseek() sets it 
 do not allow to mmap ashmem backing shmem file directly 
 user needs to SET_SIZE before mapping 
 requested mapping size larger than object size 
 requested protection bits must match our allowed protection mask 
 ... and allocate the backing shmem file 
		
		  override mmap operation of the vmfile so that it can't be
		  remapped which would lead to creation of a new vma with no
		  asma permission checks. Have to override get_unmapped_area
		  as well to prevent VM_BUG_ON check for f_ops modification.
	
	  XXX - Reworked to use shmem_zero_setup() instead of
	  shmem_set_file while we're in staging. -jstultz
 XXX: merge this with the get_file() above if possible 
  ashmem_shrink - our cache shrinker, called from mmvmscan.c
  'nr_to_scan' is the number of objects to scan for freeing.
  'gfp_mask' is the mask of the allocation that got us into this mess.
  Return value is the number of objects freed or -1 if we cannot
  proceed without risk of deadlock (due to gfp_mask).
  We approximate LRU via least-recently-unpinned, jettisoning unpinned partial
  chunks of ashmem regions LRU-wise one-at-a-time until we hit 'nr_to_scan'
  pages freed.
 We might recurse into filesystem code, so bail out if necessary 
	
	  note that lru_count is count of pages on the lru, not a count of
	  objects on the list. This means the scan function needs to return the
	  number of pages freed, not the number of objects scanned.
	
	  XXX (dchinner): I wish people would comment on why they need on
	  significant changes to the default value here
 the user can only remove, not add, protection bits 
 does the application expect PROT_READ to imply PROT_EXEC? 
	
	  Holding the ashmem_mutex while doing a copy_from_user might cause
	  an data abort which would try to access mmap_lock. If another
	  thread has invoked ashmem_mmap then it will be holding the
	  semaphore and will be waiting for ashmem_mutex, there by leading to
	  deadlock. We'll release the mutex and take the name to a local
	  variable that does not need protection and later copy the local
	  variable to the structure member with lock held.
 cannot change an existing mapping's name 
	
	  Have a local variable to which we'll copy the content
	  from asma with the lock held. Later we can copy this to the user
	  space safely without holding any locks. So even if we proceed to
	  wait for mmap_lock, it won't lead to deadlock.
		
		  Copying only `len', instead of ASHMEM_NAME_LEN, bytes
		  prevents us from revealing one user's stack to another.
	
	  Now we are just copying from the stack variable to userland
	  No lock held
  ashmem_pin - pin the given ashmem region, returning whether it was
  previously purged (ASHMEM_WAS_PURGED) or not (ASHMEM_NOT_PURGED).
  Caller must hold ashmem_mutex.
 moved past last applicable page; we can short circuit 
		
		  The user can ask us to pin pages that span multiple ranges,
		  or to pin pages that aren't even unpinned, so this is messy.
		 
		  Four cases:
		  1. The requested range subsumes an existing range, so we
		     just remove the entire matching range.
		  2. The requested range overlaps the start of an existing
		     range, so we just update that range.
		  3. The requested range overlaps the end of an existing
		     range, so we just update that range.
		  4. The requested range punches a hole in an existing range,
		     so we have to update one side of the range and then
		     create a new range for the other side.
 Case #1: Easy. Just nuke the whole thing. 
 Case #2: We overlap from the start, so adjust it 
 Case #3: We overlap from the rear, so adjust it 
			
			  Case #4: We eat a chunk out of the middle. A bit
			  more complicated, we allocate a new range for the
			  second half and adjust the first chunk's endpoint.
  ashmem_unpin - unpin the given range of pages. Returns zero on success.
  Caller must hold ashmem_mutex.
 short circuit: this is our insertion point 
		
		  The user can ask us to unpin pages that are already entirely
		  or partially pinned. We handle those two cases here.
  ashmem_get_pin_status - Returns ASHMEM_IS_UNPINNED if _any_ pages in the
  given interval are unpinned and ASHMEM_IS_PINNED otherwise.
  Caller must hold ashmem_mutex.
 per custom, you can pass zero for len to mean "everything onward" 
 support of 32bit userspace on 64bit platforms 
 SPDX-License-Identifier: GPL-2.0-only
  Implementation of the host-to-chip commands (aka requestconfirmation) of the
  hardware API.
  Copyright (c) 2017-2020, Silicon Laboratories, Inc.
  Copyright (c) 2010, ST-Ericsson
 Do not wait for any reply if chip is frozen 
	 Note: call to complete() below has an implicit memory barrier that
	  hopefully protect buf_send
		 Chip won't reply. Give enough time to the wq to send the
		  buffer.
 This function is special. After HIF_REQ_ID_SHUT_DOWN, chip won't reply to any
  request anymore. Obviously, only call this function during device unregister.
 body associated to HIF_REQ_ID_STOP_SCAN is empty 
 FIXME: only send necessary bits 
 FIXME: swap bytes as necessary in body 
		 Legacy firmwares expect that add_key to be sent on right
		  interface.
 API 2.0 has changed queue IDs values 
 Firmware does not support more than 128ms 
 SPDX-License-Identifier: GPL-2.0-only
  Interrupt bottom half (BH).
  Copyright (c) 2017-2020, Silicon Laboratories, Inc.
  Copyright (c) 2010, ST-Ericsson
		 completion.h does not provide any function to wait
		  completion without consume it (a kind of
		  wait_for_completion_done_timeout()). So we have to emulate
		  it.
			 Older firmwares have a race in sleepwake-up process.
			  Redo the process is sufficient to unfreeze the
			  chip.
 Add 2 to take into account piggyback size 
 wfx_handle_rx takes care on SKB livetime 
 ctrl_reg units are 16bits words 
 In SDIO mode, it is necessary to make an access to a register to acknowledge
  last received message. It could be possible to restrict this acknowledge to
  SDIO mode and only if last operation was rx.
 An IRQ from chip did occur 
 Driver want to send data 
 If IRQ is not available, this function allow to manually poll the control
  register and simulate an IRQ ahen an event happened.
  Note that the device has a bug: If an IRQ raise while host read control
  register, the IRQ is lost. So, use this function carefully (only duing
  device initialisation).
 SPDX-License-Identifier: GPL-2.0-only
  Scan related functions.
  Copyright (c) 2017-2020, Silicon Laboratories, Inc.
  Copyright (c) 2010, ST-Ericsson
 It is not really necessary to run scan request asynchronously. However,
  there is a bug in "iw scan" when ieee80211_scan_completed() is called before
  wfx_hw_scan() return
 SPDX-License-Identifier: GPL-2.0-only
  Implementation of mac80211 API.
  Copyright (c) 2017-2020, Silicon Laboratories, Inc.
  Copyright (c) 2010, ST-Ericsson
 The device only supports 2GHz 
 Device recover normal temperature 
 Device is too hot 
	 Notes:
	    - Probe responses (FIF_BCN_PRBRESP_PROMISC) are never filtered
	    - PS-Poll (FIF_PSPOLL) are never filtered
	    - RTS, CTS and Ack (FIF_CONTROL) are always filtered
	    - Broken frames (FIF_FCSFAIL and FIF_PLCPFAIL) are always filtered
	    - Firmware does (yet) allow to forward unicast traffic sent to
	      other stations (aka. promiscuous mode)
		 Note: FIF_BCN_PRBRESP_PROMISC covers probe response and
		  beacons from other BSS
 In AP mode, chip can reply to probe request itself 
 It is useless to enable PS if channels are the same. 
		 It is necessary to enable PS if channels
		  are different.
	 RSSI: signed Q8.0, RCPI: unsigned Q7.1
	  RSSI = RCPI  2 - 110
 In station mode, the firmware interprets new link-id as a TDLS peer 
 See note in wfx_sta_add() 
 FIXME add a mutex? 
 protect ssidie 
		 Due to beacon filtering it is possible that the
		  AP's beacon is not known for the mac80211 stack.
		  Disable filtering temporary to make sure the stack
		  receives at least one
 protect sta 
	 beacon_loss_count is defined to 7 in netmac80211mlme.c. Let's use
	  the same value.
	 Driver has Content After DTIM Beacon in queue. Driver is waiting for
	  a signal from the firmware. Since we are going to stop to send
	  beacons, this signal will never happens. See also
	  wfx_suspend_resume_mc()
		 We temporary forwarded beacon for join process. It is now no
		  more necessary.
 Firmware handles DTIM counter internally 
 Setreset aid0 bit 
	 Device won't be able to honor CAB if a scan is in progress on any
	  interface. Prefer to skip this DTIM and wait for the next one.
 Aggregation is implemented fully in firmware 
 Just acknowledge it to enable frame re-ordering 
 Leave the firmware doing its business for tx aggregation 
 FIXME: prefer use of container_of() to get vif 
 link-id 0 is reserved for multicast 
 Combo mode does not support Block Acks. We can re-enable them 
 Combo mode does not support Block Acks. We can re-enable them 
 SPDX-License-Identifier: GPL-2.0-only
  Key management related functions.
  Copyright (c) 2017-2020, Silicon Laboratories, Inc.
  Copyright (c) 2010, ST-Ericsson
 Use Tx MIC Key 
 Use Rx MIC Key 
 SPDX-License-Identifier: GPL-2.0-only
  Handling of the chip-to-host events (aka indications) of the hardware API.
  Copyright (c) 2017-2020, Silicon Laboratories, Inc.
  Copyright (c) 2010, ST-Ericsson
 All confirm messages start with status 
 drop header 
 Older firmware send a generic indication beside RxStats 
 Following errors only exists in old firmware versions: 
 Confirmations 
 Indications 
 FIXME: allocate skb_p from hif_receive_indication and make it generic 
{ HIF_IND_ID_RX,                 hif_receive_indication },
 hif_receive_indication take care of skb lifetime 
	 Note: mutex_is_lock cause an implicit memory barrier that protect
	  buf_send
 SPDX-License-Identifier: GPL-2.0-only
  Firmware loading.
  Copyright (c) 2017-2020, Silicon Laboratories, Inc.
  Copyright (c) 2010, ST-Ericsson
 Addresses below are in SRAM area 
 (32  DNLD_BLOCK_SIZE) 
 Download Control Area (DCA) 
 milliseconds 
 milliseconds 
 request_firmware() allocate data using vmalloc(). It is not compatible with
  underlying hardware that use DMA. Function below detect this case and
  allocate a bounce buffer if necessary.
  Notice that, in doubt, you can enable CONFIG_DEBUG_SG to ask kernel to
  detect this problem at runtime  (else, kernel silently fail).
  NOTE: it may also be possible to use 'pages' from struct firmware and avoid
  bounce buffer
 Legacy firmware format 
		 The device seems to not support writing 0 in this register
		  during first loop
 Fifo init 
 Legacy ROM support 
 ms 
 SPDX-License-Identifier: GPL-2.0-only
  Data receiving implementation.
  Copyright (c) 2017-2020, Silicon Laboratories, Inc.
  Copyright (c) 2010, ST-Ericsson
	 Block ack negotiation is offloaded by the firmware. However,
	  re-ordering must be done by the mac80211.
 SPDX-License-Identifier: GPL-2.0-only
  Implementation of the host-to-chip MIBs of the hardware API.
  Copyright (c) 2017-2020, Silicon Laboratories, Inc.
  Copyright (c) 2010, ST-Ericsson
  Copyright (C) 2010, ST-Ericsson SA
 extended_count_table is wider than count_table 
 Caution: type of addr is __be32 
 SPDX-License-Identifier: GPL-2.0-only
  Data transmitting implementation.
  Copyright (c) 2017-2020, Silicon Laboratories, Inc.
  Copyright (c) 2010, ST-Ericsson
	 The device only support 2GHz, else band information should be
	  retrieved from ieee80211_tx_info
 TX policy cache implementation 
 Pack two values in each byte of policy->rates 
		 If policy is not found create a new one using the oldest
		  entry in "free" list
 Tx implementation 
 Firmware is not able to mix rates with different flags 
 Sort rates and remove duplicates 
 Ensure that MCS0 or 1Mbps is present at the end of the retry list 
 == hw->max_rate_tries 
 All retries use long GI 
 From now tx_info->control is unusable 
 Fill tx_priv 
 Fill hif_msg 
 Fill tx request 
	 packet_id just need to be unique on device. 32bits are more than
	  necessary for that task, so we tae advantage of it to add some extra
	  data for debug.
 Queue index are inverted between firmware and Linux 
 Auxiliary operations 
 control.vif can be NULL for injected frames 
	 Because of TX_AMPDU_SETUP_IN_HW, mac80211 does not try to send any
	  BlockAck session management frame. The check below exist just in case.
 Also report success 
 Note that wfx_pending_get_pkt_us_delay() get data from tx_info 
	 From now, you can touch to tx_info->status, but do not touch to
	  tx_priv anymore
 FIXME: use ieee80211_tx_info_clear_status() 
 DTIM period elapsed 
 SPDX-License-Identifier: GPL-2.0-only
  Debugfs interface.
  Copyright (c) 2017-2020, Silicon Laboratories, Inc.
  Copyright (c) 2010, ST-Ericsson
 Entries 4 and 5 does not exist 
	 wfx_cmd_send() checks that reply buffer is wide enough, but does not
	  return precise length read. User have to know how many bytes should
	  be read. Filling reply buffer with a memory pattern may help user.
	 Be careful, write() is waiting for a full message while read()
	  only returns a payload
 SPDX-License-Identifier: GPL-2.0-only
  Queue between the tx operation and the bh workqueue.
  Copyright (c) 2017-2020, Silicon Laboratories, Inc.
  Copyright (c) 2010, ST-Ericsson
 Do not wait for any reply if chip is frozen 
 FIXME: drop pending frames here 
	 The device is in charge to respect the details of the QoS parameters.
	  The driver just ensure that it roughtly respect the priorities to
	  avoid any shortage.
		 Note: since only AP can have mcast frames in queue and only
		  one vif can be AP, all queued frames has same interface id
 sort the queues 
			 Note: since only AP can have mcast frames in queue
			  and only one vif can be AP, all queued frames has
			  same interface id
 No more multicast to sent 
 SPDX-License-Identifier: GPL-2.0-only
  Low-level IO functions.
  Copyright (c) 2017-2020, Silicon Laboratories, Inc.
  Copyright (c) 2010, ST-Ericsson
  Internal helpers.
  About CONFIG_VMAP_STACK:
  When CONFIG_VMAP_STACK is enabled, it is not possible to run DMA on stack
  allocated data. Functions below that work with registers (aka functions
  ending with "32") automatically reallocate buffers with kmalloc. However,
  functions that work with arbitrary length buffers let's caller to handle
  memory location. In doubt, enable CONFIG_DEBUG_SG to detect badly located
  buffer.
 Never return undefined value 
 Never return undefined value 
 Never return undefined value 
 SPDX-License-Identifier: GPL-2.0-only
  SDIO interface.
  Copyright (c) 2017-2020, Silicon Laboratories, Inc.
  Copyright (c) 2010, ST-Ericsson
 Use queue mode buffers 
 Use queue mode buffers 
 FIXME: discards 'const' qualifier for src 
 FIXME: ignore VIDPID and only rely on device tree 
 return -ENODEV;
 Block of 64 bytes is more efficient than 512B for frame sizes < 4k 
 FIXME: ignore VIDPID and only rely on device tree 
 { SDIO_DEVICE(SDIO_ANY_ID, SDIO_ANY_ID) },
 SPDX-License-Identifier: GPL-2.0-only
  SPI interface.
  Copyright (c) 2017-2020, Silicon Laboratories, Inc.
  Copyright (c) 2011, Sagrad Inc.
  Copyright (c) 2010, ST-Ericsson
 usage: and operation 
 usage: or operation 
 The chip reads 16bits of data at time and place them directly into (little
  endian) CPU register. So, the chip expects bytes order to be "B1 B0 B3 B2"
  (while LE is "B0 B1 B2 B3" and BE is "B3 B2 B1 B0")
  A little endian host with bits_per_word == 16 should do the right job
  natively. The code below to support big endian host and commonly used SPI
  8bits.
 FIXME: use a bounce buffer 
	 Register address and CONFIG content always use 16bit big endian
	  ("BADC" order)
	 Most of SPI controllers avoid DMA if buffer size is not 32bit aligned
 Trace below is also displayed by spi_setup() if compiled with DEBUG 
 For dynamic driver binding, kernel does not use OF to match driver. It only
  use modalias and modalias is a copy of 'compatible' DT node with vendor
  stripped.
 SPDX-License-Identifier: GPL-2.0-only
  Device probe and register.
  Copyright (c) 2017-2020, Silicon Laboratories, Inc.
  Copyright (c) 2010, ST-Ericsson
  Copyright (c) 2008, Johannes Berg <johannes@sipsolutions.net>
  Copyright (c) 2008 Nokia Corporation andor its subsidiary(-ies).
  Copyright (c) 2007-2009, Christian Lamparter <chunkeey@web.de>
  Copyright (c) 2006, Michael Wu <flamingice@sourmilk.net>
  Copyright (c) 2004-2006 Jean-Baptiste Note <jbnote@gmail.com>, et al.
 Receive caps 
 MCS0 to MCS7 
 The device needs data about the antenna configuration. This information in
  provided by PDS (Platform Data Set, this is the wording used in WF200
  documentation) files. For hardware integrators, the full process to create
  PDS files is described here:
    https:github.comSiliconLabswfx-firmwareblobmasterPDSREADME.md
  So this function aims to send PDS to the device. However, the PDS file is
  often bigger than Rx buffers of the chip, so it has to be sent in multiple
  parts.
  In add, the PDS data cannot be split anywhere. The PDS files contains tree
  structures. Braces are used to enterleave a level of the tree (in a JSON
  fashion). PDS files can only been split between root nodes.
 alignment  + 8 
 FIXME: also copy wfx_rates and wfx_2ghz_chantable 
	 During first part of boot, gpio_wakeup cannot yet been used. So
	  prevent bh() to touch it.
 FIXME: fill wiphy::hw_version 
 SPDX-License-Identifier: GPL-2.0+
   Copyright (C) 2015, Michael Lee <igvtee@gmail.com>
   MTK HSDMA support
 HSDMA_REG_INFO 
 HSDMA_REG_GLO_CFG 
 HSDMA_REG_RST_CFG 
 HSDMA_REG_DELAY_INT 
 HSDMA_REG_INT_STATUS 
 txrx dma desc flags 
 align 4 bytes 
 align size 128bytes 
 disable dma 
 disable intr 
 init desc value 
 reset 
 enable intr 
 enable dma 
 wait dma transfer complete 
 tx desc 
 update index 
 rx desc 
 update index 
 make sure desc and index all up to date 
 clean intr bits 
 update rx crx 
 init tx ring value 
 init desc 
 tx 
 rx 
 reset 
 enable rx intr 
 enable dma 
 hardware info 
 disable dma 
 disable intr 
 free desc 
 tx 
 rx 
 reset 
 init hardware 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: Provide functions to setup NIC operation mode
  Functions:
       s_vSafeResetTx - Rest Tx
       CARDvSetRSPINF - Set RSPINF
       CARDvUpdateBasicTopRate - Update BasicTopRate
       CARDbAddBasicRate - Add to BasicRateSet
       CARDbIsOFDMinBasicRate - Check if any OFDM rate is in BasicRateSet
       CARDqGetTSFOffset - Calculate TSFOffset
       CARDbGetCurrentTSF - Read Current NIC TSF counter
       CARDqGetNextTBTT - Calculate Next Beacon TSF counter
       CARDvSetFirstNextTBTT - Set NIC Beacon time
       CARDvUpdateNextTBTT - Sync. NIC Beacon time
       CARDbRadioPowerOff - Turn Off NIC Radio Power
  Revision History:
       06-10-2003 Bryan YC Fan:  Re-write codes to support VT3253 spec.
       08-26-2003 Kyle Hsu:      Modify the definition type of iobase.
       09-01-2003 Bryan YC Fan:  Add vUpdateIFS().
---------------------  Static Definitions -------------------------
 micro sec. 
 micro sec. 
 micro sec. 
 slot time 
 slot time 
 Times 
---------------------  Static Variables  --------------------------
---------------------  Static Functions  --------------------------
---------------------  Export Functions  --------------------------
  Description: Calculate TxRate and RsvTime fields for RSPINF in OFDM mode.
  Parameters:
   In:
       wRate           - Tx Rate
       byPktType       - Tx Packet type
   Out:
       pbyTxRate       - pointer to RSPINF TxRate field
       pbyRsvTime      - pointer to RSPINF RsvTime field
  Return Value: none
 5GHZ 
 5GHZ 
 5GHZ 
 5GHZ 
 5GHZ 
 5GHZ 
 5GHZ 
 5GHZ 
---------------------  Export Functions  --------------------------
  Description: Update IFS
  Parameters:
   In:
       priv             - The adapter to be set
   Out:
       none
  Return Value: None.
 Set SIFS, DIFS, EIFS, SlotTime, CwMin 
 AL7230 use single PAPE and connect to PAPE_2.4G 
 PK_TYPE_11GA & PK_TYPE_11GB 
		
		  bcs TX_PE will reserve 3 us hardware's processing
		  time here is 2 us.
		
		  TX_PE will reserve 3 us for MAX2829 A mode only, it is for
		  better TX throughput; MAC will need 2 us to process, so the
		  SIFS, DIFS can be shorter by 2 us.
  Description: Sync. TSF counter to BSS
               Get TSF offset and write to HW
  Parameters:
   In:
       priv         - The adapter to be sync.
       byRxRate        - data rate of receive beacon
       qwBSSTimestamp  - Rx BCN's TSF
       qwLocalTSF      - Local TSF
   Out:
       none
  Return Value: none
 adjust TSF, HW's TSF add TSF Offset reg 
  Description: Set NIC TSF counter for first Beacon time
               Get NEXTTBTT from adjusted TSF and Beacon Interval
  Parameters:
   In:
       priv         - The adapter to be set.
       wBeaconInterval - Beacon Interval
   Out:
       none
  Return Value: true if succeed; otherwise false
 Get Local TSF counter 
 set HW beacon interval 
 Set NextTBTT 
  Description: Turn off Radio power
  Parameters:
   In:
       priv         - The adapter to be turned off
   Out:
       none
 LED issue 
 initialize TD index 
 init all Tx Packet pointer to NULL 
 init all Tx Packet pointer to NULL 
 set MAC TD pointer 
 set MAC Beacon TX pointer 
  Description:
       Reset Rx
  Parameters:
   In:
       priv     - Pointer to the adapter
   Out:
       none
  Return Value: none
 initialize RD index 
 init state, all RD is chip's 
 init state, all RD is chip's 
 set perPkt mode 
 set MAC RD pointer 
  Description: Get response Control frame rate in CCK mode
  Parameters:
   In:
       priv             - The adapter to be set
       wRateIdx            - Receiving data rate
   Out:
       none
  Return Value: response Control frame rate
  Description: Get response Control frame rate in OFDM mode
  Parameters:
   In:
       priv             - The adapter to be set
       wRateIdx            - Receiving data rate
   Out:
       none
  Return Value: response Control frame rate
  Description: Set RSPINF
  Parameters:
   In:
       priv             - The adapter to be set
   Out:
       none
  Return Value: None.
 For OFDM 
 Set to Page1 
 RSPINF_b_1 
 swap over to get correct write order 
 RSPINF_b_2 
 RSPINF_b_5 
 RSPINF_b_11 
 RSPINF_a_6 
 RSPINF_a_9 
 RSPINF_a_12 
 RSPINF_a_18 
 RSPINF_a_24 
 RSPINF_a_36 
 RSPINF_a_48 
 RSPINF_a_54 
 RSPINF_a_72 
 Set to Page0 
 Determines the highest basic rate. 
  Description: Calculate TSF offset of two TSF input
               Get TSF Offset from RxBCN's TSF and local TSF
  Parameters:
   In:
       priv         - The adapter to be sync.
       qwTSF1          - Rx BCN's TSF
       qwTSF2          - Local TSF
   Out:
       none
  Return Value: TSF Offset value
  Description: Read NIC TSF counter
               Get local TSF counter
  Parameters:
   In:
       priv         - The adapter to be read
   Out:
       qwCurrTSF       - Current TSF counter
  Return Value: true if success; otherwise false
  Description: Read NIC TSF counter
               Get NEXTTBTT from adjusted TSF and Beacon Interval
  Parameters:
   In:
       qwTSF           - Current TSF counter
       wbeaconInterval - Beacon Interval
   Out:
       qwCurrTSF       - Current TSF counter
  Return Value: TSF value of next Beacon
  Description: Set NIC TSF counter for first Beacon time
               Get NEXTTBTT from adjusted TSF and Beacon Interval
  Parameters:
   In:
       iobase          - IO Base
       wBeaconInterval - Beacon Interval
   Out:
       none
  Return Value: none
 Get Local TSF counter 
 Set NextTBTT 
  Description: Sync NIC TSF counter for Beacon time
               Get NEXTTBTT and write to HW
  Parameters:
   In:
       priv         - The adapter to be set
       qwTSF           - Current TSF counter
       wBeaconInterval - Beacon Interval
   Out:
       none
  Return Value: none
 Set NextTBTT 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose:  MAC routines
  Author: Tevin Chen
  Date: May 21, 1996
  Functions:
       MACbIsRegBitsOff - Test if All test Bits Off
       MACbIsIntDisable - Test if MAC interrupt disable
       MACvSetShortRetryLimit - Set 802.11 Short Retry limit
       MACvSetLongRetryLimit - Set 802.11 Long Retry limit
       MACvSetLoopbackMode - Set MAC Loopback Mode
       MACvSaveContext - Save Context of MAC Registers
       MACvRestoreContext - Restore Context of MAC Registers
       MACbSoftwareReset - Software Reset MAC
       MACbSafeRxOff - Turn Off MAC Rx
       MACbSafeTxOff - Turn Off MAC Tx
       MACbSafeStop - Stop MAC function
       MACbShutdown - Shut down MAC
       MACvInitialize - Initialize MAC
       MACvSetCurrRxDescAddr - Set Rx Descriptors Address
       MACvSetCurrTx0DescAddr - Set Tx0 Descriptors Address
       MACvSetCurrTx1DescAddr - Set Tx1 Descriptors Address
       MACvTimer0MicroSDelay - Micro Second Delay Loop by MAC
  Revision History:
       08-22-2003 Kyle Hsu     :  Porting MAC functions from sim53
       09-03-2003 Bryan YC Fan :  Add MACvClearBusSusInd()&
 				   MACvEnableBusSusEn()
       09-18-2003 Jerry Chen   :  Add MACvSetKeyEntry & MACvDisableKeyEntry
  Description:
       Test if all test bits off
  Parameters:
   In:
       io_base    - Base Address for MAC
       byRegOfs    - Offset of MAC Register
       byTestBits  - Test bits
   Out:
       none
  Return Value: true if all test bits Off; otherwise false
  Description:
       Test if MAC interrupt disable
  Parameters:
   In:
       io_base    - Base Address for MAC
   Out:
       none
  Return Value: true if interrupt is disable; otherwise false
  Description:
       Set 802.11 Short Retry Limit
  Parameters:
   In:
       io_base    - Base Address for MAC
       byRetryLimit- Retry Limit
   Out:
       none
  Return Value: none
 set SRT 
  Description:
       Set 802.11 Long Retry Limit
  Parameters:
   In:
       io_base    - Base Address for MAC
       byRetryLimit- Retry Limit
   Out:
       none
  Return Value: none
 set LRT 
  Description:
       Set MAC Loopback mode
  Parameters:
   In:
       io_base        - Base Address for MAC
       byLoopbackMode  - Loopback Mode
   Out:
       none
  Return Value: none
 set TCR 
  Description:
       Save MAC registers to context buffer
  Parameters:
   In:
       io_base    - Base Address for MAC
   Out:
       cxt_buf   - Context buffer
  Return Value: none
 read page0 register 
 read page1 register 
  Description:
       Restore MAC registers from context buffer
  Parameters:
   In:
       io_base    - Base Address for MAC
       cxt_buf   - Context buffer
   Out:
       none
  Return Value: none
 restore page1 
 restore RCR,TCR,IMR... 
 restore MAC Config. 
 restore PS Config. 
 restore CURR_RX_DESC_ADDR, CURR_TX_DESC_ADDR 
  Description:
       Software Reset MAC
  Parameters:
   In:
       io_base    - Base Address for MAC
   Out:
       none
  Return Value: true if Reset Success; otherwise false
 turn on HOSTCR_SOFTRST, just write 0x01 to reset 
  Description:
       save some important register's value, then do reset, then restore
 	register's value
  Parameters:
   In:
       io_base    - Base Address for MAC
   Out:
       none
  Return Value: true if success; otherwise false
	 PATCH....
	  save some important register's value, then do
	  reset, then restore register's value
 save MAC context 
 do reset 
 restore MAC context, except CR0 
  Description:
       Turn Off MAC Rx
  Parameters:
   In:
       io_base    - Base Address for MAC
   Out:
       none
  Return Value: true if success; otherwise false
 turn off wow temp for turn off Rx safely 
 Clear RX DMA0,1 
 try to safe shutdown RX 
 W_MAX_TIMEOUT is the timeout period 
  Description:
       Turn Off MAC Tx
  Parameters:
   In:
       io_base    - Base Address for MAC
   Out:
       none
  Return Value: true if success; otherwise false
 Clear TX DMA 
 Tx0 
 AC0 
 try to safe shutdown TX 
 W_MAX_TIMEOUT is the timeout period 
  Description:
       Stop MAC function
  Parameters:
   In:
       io_base    - Base Address for MAC
   Out:
       none
  Return Value: true if success; otherwise false
  Description:
       Shut Down MAC
  Parameters:
   In:
       io_base    - Base Address for MAC
   Out:
       none
  Return Value: true if success; otherwise false
 disable MAC IMR 
 stop the adapter 
  Description:
       Initialize MAC
  Parameters:
   In:
       io_base    - Base Address for MAC
   Out:
       none
  Return Value: none
 clear sticky bits 
 disable force PME-enable 
 only 3253 A 
 do reset 
 reset TSF counter 
 enable TSF counter 
  Description:
       Set the chip with current rx descriptor address
  Parameters:
   In:
       io_base        - Base Address for MAC
       curr_desc_addr  - Descriptor Address
   Out:
       none
  Return Value: none
  Description:
       Set the chip with current rx descriptor address
  Parameters:
   In:
       io_base        - Base Address for MAC
       curr_desc_addr  - Descriptor Address
   Out:
       none
  Return Value: none
  Description:
       Set the chip with current tx0 descriptor address
  Parameters:
   In:
       io_base        - Base Address for MAC
       curr_desc_addr  - Descriptor Address
   Out:
       none
  Return Value: none
  Description:
       Set the chip with current AC0 descriptor address
  Parameters:
   In:
       io_base        - Base Address for MAC
       curr_desc_addr  - Descriptor Address
   Out:
       none
  Return Value: none
 TxDMA1 = AC0DMA 
  Description:
       Micro Second Delay via MAC
  Parameters:
   In:
       io_base    - Base Address for MAC
       uDelay      - Delay time (timer resolution is 4 us)
   Out:
       none
  Return Value: none
 assume max PCI clock is 66Mhz 
  Description:
       Micro Second One shot timer via MAC
  Parameters:
   In:
       io_base    - Base Address for MAC
       uDelay      - Delay time
   Out:
       none
  Return Value: none
 Read PSCTL 
 Disable PS 
 Check if SyncFlushOK 
  Description:
       Set the Key by MISCFIFO
  Parameters:
   In:
       io_base        - Base Address for MAC
   Out:
       none
  Return Value: none
 always push 128 bits 
  Description:
       Disable the Key Entry by MISCFIFO
  Parameters:
   In:
       io_base        - Base Address for MAC
   Out:
       none
  Return Value: none
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: handle dpc rx functions
  Author: Lyndon Chen
  Date: May 20, 2003
  Functions:
  Revision History:
 [31:16]RcvByteCount ( not include 4-byte Status ) 
 Drop packet 
 Frame Size error drop this packet.
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: Implement functions for 802.11i Key management
  Author: Jerry Chen
  Date: May 29, 2003
 default key last entry 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: Implement functions to access baseband
  Author: Kyle Hsu
  Date: Aug.22, 2002
  Functions:
       bb_get_frame_time	 - Calculate data frame transmitting time
       bb_read_embedded	 - Embedded read baseband register via MAC
       bb_write_embedded	 - Embedded write baseband register via MAC
       bb_vt3253_init		 - VIA VT3253 baseband chip init code
  Revision History:
       06-10-2003 Bryan YC Fan:  Re-write codes to support VT3253 spec.
       08-07-2003 Bryan YC Fan:  Add MAXIM28272825 and RFMD2959 support.
       08-26-2003 Kyle Hsu    :  Modify BBuGetFrameTime() and
 				  BBvCalculateParameter().
                                 cancel the setting of MAC_REG_SOFTPWRCTL on
 				  BBbVT3253Init().
                                 Add the comments.
       09-01-2003 Bryan YC Fan:  RF & BB tables updated.
                                 Modified BBvLoopbackOn & BBvLoopbackOff().
---------------------  Static Classes  ----------------------------
---------------------  Static Variables  --------------------------
---------------------  Static Functions  --------------------------
---------------------  Export Variables  --------------------------
---------------------  Static Definitions -------------------------
---------------------  Static Classes  ----------------------------
---------------------  Static Variables  --------------------------
 For RFMD2959 
 For AIROHA 
 RobertYu:20050125, request by JJSue 
 For UW2451 
 RobertYu:20050125, request by JJSue 
 For AIROHA 
---------------------  Export Variables  --------------------------
  Description: Calculate data frame transmitting time
  Parameters:
   In:
       preamble_type     - Preamble Type
       by_pkt_type        - PK_TYPE_11A, PK_TYPE_11B, PK_TYPE_11GB, PK_TYPE_11GA
       cb_frame_length   - Baseband Type
       tx_rate           - Tx Rate
   Out:
  Return Value: FrameTime
 CCK mode 
 ????? 
 ???????? 
 ??????? 
 ?????? 
 ?????? 
  Description: Calculate Length, Service, and Signal fields of Phy for Tx
  Parameters:
   In:
       priv         - Device Structure
       frame_length   - Tx Frame Length
       tx_rate           - Tx Rate
   Out:
 	struct vnt_phy_field phy
 		- pointer to Phy Length field
 		- pointer to Phy Service field
 		- pointer to Phy Signal field
  Return Value: none
  Description: Read a byte from BASEBAND, by embedded programming
  Parameters:
   In:
       iobase      - IO base address
       by_bb_addr  - address of register in Baseband
   Out:
       pby_data    - data read
  Return Value: true if succeeded; false if failed.
 BB reg offset 
 turn on REGR 
 W_MAX_TIMEOUT is the timeout period 
 get BB data 
  Description: Write a Byte to BASEBAND, by embedded programming
  Parameters:
   In:
       iobase      - IO base address
       by_bb_addr  - address of register in Baseband
       by_data     - data to write
   Out:
       none
  Return Value: true if succeeded; false if failed.
 BB reg offset 
 set BB data 
 turn on BBREGCTL_REGW 
 W_MAX_TIMEOUT is the timeout period 
  Description: VIA VT3253 Baseband chip init function
  Parameters:
   In:
       iobase      - IO base address
       byRevId     - Revision ID
       byRFType    - RF type
   Out:
       none
  Return Value: true if succeeded; false if failed.
		 Init ANT B select,
		  TX Config CR09 = 0x61->0x45,
		  0x45->0x41(VC1VC2 define, make the ANT_A, ANT_B inverted)
bResult &= bb_write_embedded(iobase,0x09,0x41);
		 Init ANT B select,
		  RX Config CR10 = 0x28->0x2A,
		  0x2A->0x28(VC1VC2 define,
		  make the ANT_A, ANT_B inverted)
bResult &= bb_write_embedded(iobase,0x0a,0x28);
 Select VC1VC2, CR215 = 0x02->0x06 
 {{RobertYu:20050125, request by Jack 
 }} 
 {{RobertYu:20050221, request by Jack 
 }} 
 }} RobertYu 
 Fix VT3226 DFC system timing issue 
 {{ RobertYu: 20050104 
 {{ RobertYu:20050223, request by JerryChung 
		 Init ANT B select,TX Config CR09 = 0x61->0x45,
		  0x45->0x41(VC1VC2 define, make the ANT_A, ANT_B inverted)
 bResult &= bb_write_embedded(iobase,0x09,0x41);
		 Init ANT B select,RX Config CR10 = 0x28->0x2A,
		  0x2A->0x28(VC1VC2 define, make the ANT_A, ANT_B inverted)
 bResult &= BBbWriteEmbedded(iobase,0x0a,0x28);
 Select VC1VC2, CR215 = 0x02->0x06 
 }} 
 }} RobertYu 
 No VGA Table now 
  Description: Set ShortSlotTime mode
  Parameters:
   In:
       priv     - Device Structure
   Out:
       none
  Return Value: none
 CR10 
 1101 1111 
 0010 0000 
 patch for 3253B0 Baseband with Cardbus module 
 0010 0000 
 CR10 
 CR10 
 patch for 3253B0 Baseband with Cardbus module 
 0010 0000 
 1101 1111 
 0010 0000 
 CR10 
  Description: Baseband SoftwareReset
  Parameters:
   In:
       iobase      - IO base address
   Out:
       none
  Return Value: none
  Description: Baseband Power Save Mode ON
  Parameters:
   In:
       iobase      - IO base address
   Out:
       none
  Return Value: none
  Description: Baseband Power Save Mode OFF
  Parameters:
   In:
       iobase      - IO base address
   Out:
       none
  Return Value: none
  Description: Set Tx Antenna mode
  Parameters:
   In:
       priv          - Device Structure
       by_antenna_mode    - Antenna Mode
   Out:
       none
  Return Value: none
 CR09 
 bit 1 is diversity 
 bit 2 is ANTSEL 
 1111 1001 
 1111 1101 
 CR09 
  Description: Set Rx Antenna mode
  Parameters:
   In:
       priv          - Device Structure
       by_antenna_mode   - Antenna Mode
   Out:
       none
  Return Value: none
 CR10 
 1111 1100 
 1111 1110 
 CR10 
  Description: bb_set_deep_sleep
  Parameters:
   In:
       priv          - Device Structure
   Out:
       none
  Return Value: none
 CR12 
 CR13 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: Handles 802.11 power management  functions
  Author: Lyndon Chen
  Date: July 17, 2002
  Functions:
       PSvEnablePowerSaving - Enable Power Saving Mode
       PSvDiasblePowerSaving - Disable Power Saving Mode
       PSbConsiderPowerDown - Decide if we can Power Down
       PSvSendPSPOLL - Send PS-POLL packet
       PSbSendNullPacket - Send Null packet
       PSbIsNextTBTTWakeUp - Decide if we need to wake up at next Beacon
  Revision History:
---------------------  Static Definitions -------------------------
---------------------  Static Classes  ----------------------------
---------------------  Static Functions  --------------------------
---------------------  Export Variables  --------------------------
---------------------  Export Functions  --------------------------
  Routine Description:
  Enable hw power saving functions
  Return Value:
     None.
 set period of power up before TBTT 
 set AID 
 Set AutoSleep 
 Set HWUTSF 
 clear always listen beacon 
 first time set listen next beacon 
 always listen beacon 
 enable power saving hw function 
  Routine Description:
  Disable hw power saving functions
  Return Value:
     None.
 disable power saving hw function 
 clear AutoSleep 
 clear HWUTSF 
 set always listen beacon 
  Routine Description:
  Check if Next TBTT must wake up
  Return Value:
     None.
 Turn on wake up to listen next beacon 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: handle WMAC802.3802.11 rx & tx functions
  Author: Lyndon Chen
  Date: May 20, 2003
  Functions:
       s_vGenerateTxParameter - Generate tx dma required parameter.
       vGenerateMACHeader - Translate 802.3 to 802.11 header
       cbGetFragCount - Calculate fragment number count
       csBeacon_xmit - beacon tx function
       csMgmt_xmit - management tx function
       s_cbFillTxBufHead - fulfill tx dma buffer header
       s_uGetDataDuration - get tx data required duration
       s_uFillDataHead- fulfill tx data duration header
       s_uGetRTSCTSDuration- get rtxcts required duration
       get_rtscts_time- get rtscts reserved time
       s_uGetTxRsvTime- get frame reserved time
       s_vFillCTSHead- fulfill CTS ctl header
       s_vFillFragParameter- Set fragment ctl parameter.
       s_vFillRTSHead- fulfill RTS ctl header
       s_vFillTxKey- fulfill tx encrypt key
       s_vSWencryption- Software encrypt header
       vDMA0_tx_80211- tx 802.11 frame via dma0
       vGenerateFIFOHeader- Generate tx FIFO ctl header
  Revision History:
---------------------  Static Definitions -------------------------
---------------------  Static Classes  ----------------------------
---------------------  Static Variables  --------------------------
---------------------  Static Functions  --------------------------
---------------------  Static Definitions -------------------------
 if packet size < 256 -> in-direct send
  vpacket size >= 256 -> direct send
 Long Preamble 
 Short Preamble 
 fallback_rate0 
 fallback_rate1 
 fallback_rate0 
 fallback_rate1 
---------------------  Static Functions  --------------------------
---------------------  Export Variables  --------------------------
 byPktType : PK_TYPE_11A     0
  PK_TYPE_11B     1
  PK_TYPE_11GB    2
  PK_TYPE_11GA    3
	
	  CCK mode  - 11b
	  OFDM mode - 11g 2.4G & 11a 5G
 byFreqType: 0=>5GHZ 1=>2.4GHZ 
 RTSTxRrvTime_bb 
 RTSTxRrvTime_ba, only in 2.4GHZ 
 RTSTxRrvTime_aa 
 CTSTxRrvTime_ba, only in 2.4GHZ 
 RTSRrvTime 
 byFreqType 0: 5GHz, 1:2.4Ghz 
 DATADUR_B 
 Non Frag or Last Frag 
 First Frag or Mid Frag 
 DATADUR_A 
 Non Frag or Last Frag 
 First Frag or Mid Frag 
 DATADUR_A_F0 
 DATADUR_A_F1 
 Non Frag or Last Frag 
 First Frag or Mid Frag 
 byFreqType: 0=>5GHZ 1=>2.4GHZ 
 RTSDuration_bb 
 RTSDuration_ba 
 RTSDuration_aa 
 CTSDuration_ba 
 RTSDuration_ba_f0 
 RTSDuration_aa_f0 
 RTSDuration_ba_f1 
 RTSDuration_aa_f1 
 CTSDuration_ba_f0 
 CTSDuration_ba_f1 
 Auto Fallback 
 Get SignalField, ServiceField & Length 
 Get Duration and TimeStamp 
 Get SignalField, ServiceField & Length 
 Get Duration and TimeStamp 
 if (byFBOption == AUTO_FB_NONE) 
 Auto Fallback 
 Get SignalField, ServiceField & Length 
 Get Duration and TimeStampOff 
 Get SignalField, ServiceField & Length 
 Get Duration and TimeStampOff 
 Get SignalField, ServiceField & Length 
 Get Duration and TimeStampOff 
		 When CRCDIS bit is on, HW forgot to generate FCS for
		  RTS frame, in this case we need to decrease its length by 4.
	 Note: So far RTSHead doesn't appear in ATIM & Beacom DMA,
	  so we don't need to take them into account.
	  Otherwise, we need to modify codes for them.
 Get SignalField, ServiceField & Length 
 Get Duration 
 Get RTS Frame body 
 Get SignalField, ServiceField & Length 
 Get Duration 
 Get RTS Frame body 
 if (byFBOption == AUTO_FB_NONE) 
 Get SignalField, ServiceField & Length 
 Get Duration 
 Get RTS Frame body 
 Get SignalField, ServiceField & Length 
 Get Duration 
 Get RTS Frame body 
 Get SignalField, ServiceField & Length 
 Get Duration 
 Get RTS Frame body 
		 When CRCDIS bit is on, HW forgot to generate FCS for
		  CTS frame, in this case we need to decrease its length by 4.
 Auto Fall back 
 Get SignalField, ServiceField & Length 
 Get CTSDuration_ba_f0 
 Get CTSDuration_ba_f1 
 Get CTS Frame body 
 if (byFBOption != AUTO_FB_NONE && uDMAIdx != TYPE_ATIMDMA && uDMAIdx != TYPE_BEACONDMA) 
 Get SignalField, ServiceField & Length 
 Get CTSDuration_ba 
 Get CTS Frame body 
  Description:
       Generate FIFO control for MAC & Baseband controller
  Parameters:
   In:
       pDevice         - Pointer to adapter
       pTxDataHead     - Transmit Data Buffer
       pTxBufHead      - pTxBufHead
       pvRrvTime        - pvRrvTime
       pvRTS            - RTS Buffer
       pCTS            - CTS Buffer
       cbFrameSize     - Transmit Data Length (Hdr+Payload+FCS)
       bNeedACK        - If need ACK
       uDescIdx        - Desc Index
   Out:
       none
  Return Value: none
 -
  unsigned int cbFrameSize, Hdr+Payload+FCS
 RTS_need 
 Fill RsvTime 
 RTS_needless, PCF mode 
 Fill CTS 
 RTS_need, non PCF mode 
 Fill RTS 
 RTS_needless, non PCF mode 
 RTS_need, non PCF mode 
 Fill RTS 
 RTS_needless, non PCF mode 
 FFinfo size 
 MAC Header should be padding 0 to DW alignment. 
	
	  Use for AUTO FALL BACK
 Set RrvTimeRTSCTS Buffer 
 802.11g packet 
 RTS_need 
 RTS_needless 
 Auto Fall Back 
 RTS_need 
 RTS_needless 
 Auto Fall Back 
 802.11ab packet 
 RTS_needless, need MICHDR 
 Auto Fall Back 
 RTS_need 
 RTS_needless 
 Auto Fall Back 
 Fill FIFO,RrvTime,RTS,and CTS 
 Fill DataHead 
 Copy the Packet into a tx Buffer 
 strip header and icv len from payload 
Set fifo controls 
 generate interrupt 
 legacy rates TODO use ieee80211_tx_rate 
 Get SignalField,ServiceField,Length 
 Get Duration and TimeStampOff 
 Get SignalField,ServiceField,Length 
 Get Duration and TimeStampOff 
 Copy Beacon 
 time stamp always 0 
 Set auto Transmit on 
 Poll Transmit the adapter 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: rf function code
  Author: Jerry Chen
  Date: Feb. 19, 2004
  Functions:
       IFRFbWriteEmbedded      - Embedded write RF register via MAC
  Revision History:
 	RobertYu 2005
 	chester 2008
 24bit 
 us 
 24bit 
 us 
 channel = 1, Tf = 2412MHz 
 channel = 2, Tf = 2417MHz 
 channel = 3, Tf = 2422MHz 
 channel = 4, Tf = 2427MHz 
 channel = 5, Tf = 2432MHz 
 channel = 6, Tf = 2437MHz 
 channel = 7, Tf = 2442MHz 
 channel = 8, Tf = 2447MHz 
 channel = 9, Tf = 2452MHz 
 channel = 10, Tf = 2457MHz 
 channel = 11, Tf = 2462MHz 
 channel = 12, Tf = 2467MHz 
 channel = 13, Tf = 2472MHz 
 channel = 14, Tf = 2412M 
 channel = 1, Tf = 2412MHz 
 channel = 2, Tf = 2417MHz 
 channel = 3, Tf = 2422MHz 
 channel = 4, Tf = 2427MHz 
 channel = 5, Tf = 2432MHz 
 channel = 6, Tf = 2437MHz 
 channel = 7, Tf = 2442MHz 
 channel = 8, Tf = 2447MHz 
 channel = 9, Tf = 2452MHz 
 channel = 10, Tf = 2457MHz 
 channel = 11, Tf = 2462MHz 
 channel = 12, Tf = 2467MHz 
 channel = 13, Tf = 2472MHz 
 channel = 14, Tf = 2412M 
 40MHz reference frequency
  Need to Pull PLLON(PE3) low when writing channel registers through 3-wire.
 Need modify for 11a 
 Need modify for 11a 
 Need modify for 11a: 451FE2 
 Need modify for 11a: 5FDFA3 
 Need modify for 11a 
 RoberYu:20050113, Rev0.47 Register Setting Guide 
 Need modify for 11a: 8D1B55 
 Need modify for 11a: 860207 
 Need modify for 11a: E0600A 
 init 0x080B1B00 => 0x080F1B00 for 3 wire control TxGain(D10) 
 RoberYu:20050113, Rev0.47 Register Setting Guide 
 Need modify for 11a: 00143C 
 Need modify for 11a: 12BACF 
 Need modify for 11bg 
 Need modify for 11bg 
 Need modify for 11bg 
 Need modify for 11bg 
 Need modify for 11bg 
 Need modify for 11bg, RoberYu:20050113 
 Need modify for 11bg 
 Need modify for 11bg 
 init 0x080B1B00 => 0x080F1B00 for 3 wire control TxGain(D10) 
 Need modify for 11bg 
 Need modify for 11bg 
 channel =  1, Tf = 2412MHz 
 channel =  2, Tf = 2417MHz 
 channel =  3, Tf = 2422MHz 
 channel =  4, Tf = 2427MHz 
 channel =  5, Tf = 2432MHz 
 channel =  6, Tf = 2437MHz 
 channel =  7, Tf = 2442MHz 
RobertYu: 20050218, update for APNode 0.49 
RobertYu: 20050218, update for APNode 0.49 
RobertYu: 20050218, update for APNode 0.49 
RobertYu: 20050218, update for APNode 0.49 
RobertYu: 20050218, update for APNode 0.49 
RobertYu: 20050218, update for APNode 0.49 
 channel = 14, Tf = 2484MHz 
 4.9G => Ch 183, 184, 185, 187, 188, 189, 192, 196  (Value:15 ~ 22) 
 channel = 183, Tf = 4915MHz (15) 
 channel = 184, Tf = 4920MHz (16) 
 channel = 185, Tf = 4925MHz (17) 
 channel = 187, Tf = 4935MHz (18) 
 channel = 188, Tf = 4940MHz (19) 
 channel = 189, Tf = 4945MHz (20) 
 channel = 192, Tf = 4960MHz (21) 
 channel = 196, Tf = 4980MHz (22) 
	 5G => Ch 7, 8, 9, 11, 12, 16, 34, 36, 38, 40, 42, 44, 46, 48, 52, 56, 60, 64,
	  100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161, 165  (Value 23 ~ 56)
 channel =   7, Tf = 5035MHz (23) 
 channel =   8, Tf = 5040MHz (24) 
 channel =   9, Tf = 5045MHz (25) 
 channel =  11, Tf = 5055MHz (26) 
 channel =  12, Tf = 5060MHz (27) 
 channel =  16, Tf = 5080MHz (28) 
 channel =  34, Tf = 5170MHz (29) 
 channel =  36, Tf = 5180MHz (30) 
RobertYu: 20050218, update for APNode 0.49 
 channel =  40, Tf = 5200MHz (32) 
 channel =  42, Tf = 5210MHz (33) 
 channel =  44, Tf = 5220MHz (34) 
 channel =  46, Tf = 5230MHz (35) 
 channel =  48, Tf = 5240MHz (36) 
 channel =  52, Tf = 5260MHz (37) 
 channel =  56, Tf = 5280MHz (38) 
 channel =  60, Tf = 5300MHz (39) 
 channel =  64, Tf = 5320MHz (40) 
 channel = 100, Tf = 5500MHz (41) 
 channel = 104, Tf = 5520MHz (42) 
 channel = 108, Tf = 5540MHz (43) 
 channel = 112, Tf = 5560MHz (44) 
 channel = 116, Tf = 5580MHz (45) 
 channel = 120, Tf = 5600MHz (46) 
 channel = 124, Tf = 5620MHz (47) 
 channel = 128, Tf = 5640MHz (48) 
 channel = 132, Tf = 5660MHz (49) 
 channel = 136, Tf = 5680MHz (50) 
 channel = 140, Tf = 5700MHz (51) 
 channel = 149, Tf = 5745MHz (52) 
 channel = 153, Tf = 5765MHz (53) 
 channel = 157, Tf = 5785MHz (54) 
 channel = 161, Tf = 5805MHz (55) 
 channel = 165, Tf = 5825MHz (56) 
 channel =  1, Tf = 2412MHz 
 channel =  2, Tf = 2417MHz 
 channel =  3, Tf = 2422MHz 
 channel =  4, Tf = 2427MHz 
 channel =  5, Tf = 2432MHz 
 channel =  6, Tf = 2437MHz 
 channel =  7, Tf = 2442MHz 
 channel =  8, Tf = 2447MHz 
 channel =  9, Tf = 2452MHz 
 channel = 10, Tf = 2457MHz 
 channel = 11, Tf = 2462MHz 
 channel = 12, Tf = 2467MHz 
 channel = 13, Tf = 2472MHz 
 channel = 14, Tf = 2484MHz 
 4.9G => Ch 183, 184, 185, 187, 188, 189, 192, 196  (Value:15 ~ 22) 
 channel = 183, Tf = 4915MHz (15) 
 channel = 184, Tf = 4920MHz (16) 
 channel = 185, Tf = 4925MHz (17) 
 channel = 187, Tf = 4935MHz (18) 
 channel = 188, Tf = 4940MHz (19) 
 channel = 189, Tf = 4945MHz (20) 
 channel = 192, Tf = 4960MHz (21) 
 channel = 196, Tf = 4980MHz (22) 
	 5G => Ch 7, 8, 9, 11, 12, 16, 34, 36, 38, 40, 42, 44, 46, 48, 52, 56, 60, 64,
	  100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161, 165  (Value 23 ~ 56)
 channel =   7, Tf = 5035MHz (23) 
 channel =   8, Tf = 5040MHz (24) 
 channel =   9, Tf = 5045MHz (25) 
 channel =  11, Tf = 5055MHz (26) 
 channel =  12, Tf = 5060MHz (27) 
 channel =  16, Tf = 5080MHz (28) 
 channel =  34, Tf = 5170MHz (29) 
 channel =  36, Tf = 5180MHz (30) 
 channel =  38, Tf = 5190MHz (31) 
 channel =  40, Tf = 5200MHz (32) 
 channel =  42, Tf = 5210MHz (33) 
 channel =  44, Tf = 5220MHz (34) 
 channel =  46, Tf = 5230MHz (35) 
 channel =  48, Tf = 5240MHz (36) 
 channel =  52, Tf = 5260MHz (37) 
 channel =  56, Tf = 5280MHz (38) 
 channel =  60, Tf = 5300MHz (39) 
 channel =  64, Tf = 5320MHz (40) 
 channel = 100, Tf = 5500MHz (41) 
 channel = 104, Tf = 5520MHz (42) 
 channel = 108, Tf = 5540MHz (43) 
 channel = 112, Tf = 5560MHz (44) 
 channel = 116, Tf = 5580MHz (45) 
 channel = 120, Tf = 5600MHz (46) 
 channel = 124, Tf = 5620MHz (47) 
 channel = 128, Tf = 5640MHz (48) 
 channel = 132, Tf = 5660MHz (49) 
 channel = 136, Tf = 5680MHz (50) 
 channel = 140, Tf = 5700MHz (51) 
 channel = 149, Tf = 5745MHz (52) 
 channel = 153, Tf = 5765MHz (53) 
 channel = 157, Tf = 5785MHz (54) 
 channel = 161, Tf = 5805MHz (55) 
 channel = 165, Tf = 5825MHz (56) 
 channel =  1, Tf = 2412MHz 
 channel =  2, Tf = 2417MHz 
 channel =  3, Tf = 2422MHz 
 channel =  4, Tf = 2427MHz 
 channel =  5, Tf = 2432MHz 
 channel =  6, Tf = 2437MHz 
 channel =  7, Tf = 2442MHz 
 channel =  8, Tf = 2447MHz 
 channel =  9, Tf = 2452MHz 
 channel = 10, Tf = 2457MHz 
 channel = 11, Tf = 2462MHz 
 channel = 12, Tf = 2467MHz 
 channel = 13, Tf = 2472MHz 
 channel = 14, Tf = 2484MHz 
 4.9G => Ch 183, 184, 185, 187, 188, 189, 192, 196  (Value:15 ~ 22) 
 channel = 183, Tf = 4915MHz (15) 
 channel = 184, Tf = 4920MHz (16) 
 channel = 185, Tf = 4925MHz (17) 
 channel = 187, Tf = 4935MHz (18) 
 channel = 188, Tf = 4940MHz (19) 
 channel = 189, Tf = 4945MHz (20) 
 channel = 192, Tf = 4960MHz (21) 
 channel = 196, Tf = 4980MHz (22) 
	 5G => Ch 7, 8, 9, 11, 12, 16, 34, 36, 38, 40, 42, 44, 46, 48, 52, 56, 60, 64,
	  100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161, 165  (Value 23 ~ 56)
 channel =   7, Tf = 5035MHz (23) 
 channel =   8, Tf = 5040MHz (24) 
 channel =   9, Tf = 5045MHz (25) 
 channel =  11, Tf = 5055MHz (26) 
 channel =  12, Tf = 5060MHz (27) 
 channel =  16, Tf = 5080MHz (28) 
 channel =  34, Tf = 5170MHz (29) 
 channel =  36, Tf = 5180MHz (30) 
 channel =  38, Tf = 5190MHz (31) 
 channel =  40, Tf = 5200MHz (32) 
 channel =  42, Tf = 5210MHz (33) 
 channel =  44, Tf = 5220MHz (34) 
 channel =  46, Tf = 5230MHz (35) 
 channel =  48, Tf = 5240MHz (36) 
 channel =  52, Tf = 5260MHz (37) 
 channel =  56, Tf = 5280MHz (38) 
 channel =  60, Tf = 5300MHz (39) 
 channel =  64, Tf = 5320MHz (40) 
 channel = 100, Tf = 5500MHz (41) 
 channel = 104, Tf = 5520MHz (42) 
 channel = 108, Tf = 5540MHz (43) 
 channel = 112, Tf = 5560MHz (44) 
 channel = 116, Tf = 5580MHz (45) 
 channel = 120, Tf = 5600MHz (46) 
 channel = 124, Tf = 5620MHz (47) 
 channel = 128, Tf = 5640MHz (48) 
 channel = 132, Tf = 5660MHz (49) 
 channel = 136, Tf = 5680MHz (50) 
 channel = 140, Tf = 5700MHz (51) 
 channel = 149, Tf = 5745MHz (52) 
 channel = 153, Tf = 5765MHz (53) 
 channel = 157, Tf = 5785MHz (54) 
 channel = 161, Tf = 5805MHz (55) 
 channel = 165, Tf = 5825MHz (56) 
  Description: AIROHA IFRF chip init function
  Parameters:
   In:
       iobase      - IO base address
   Out:
       none
  Return Value: true if succeeded; false if failed.
 3-wire control for normal mode 
 RobertYu:20050106, have DC value for Calibration 
 PLL On 
 Calibration 
 150us 
 TXDCOC:active, RCK:disable 
 30us 
 TXDCOC:disable, RCK:active 
 30us 
 TXDCOC:disable, RCK:disable 
 RobertYu:20050106 
 PE1: TX_ON, PE2: RX_ON, PE3: PLLON 
 3-wire control for power saving mode 
 1100 0000 
 Need to Pull PLLON low when writing channel registers through
  3-wire interface
 PLLON Off 
 PLLOn On 
 Set Channel[7] = 0 to tell HW channel is changing now. 
 Set Channel[7] = 1 to tell HW channel change is done. 
  Description: Write to IFRF, by embedded programming
  Parameters:
   In:
       iobase      - IO base address
       dwData      - data to write
   Out:
       none
  Return Value: true if succeeded; false if failed.
 W_MAX_TIMEOUT is the timeout period 
  Description: AIROHA IFRF chip init function
  Parameters:
   In:
       iobase      - IO base address
   Out:
       none
  Return Value: true if succeeded; false if failed.
 3-wire control for normal mode 
 PLL  Off 
 patch abnormal AL2230 frequency output 
 delay 30 us 
 PLL On 
 150us 
 30us 
 30us 
 3-wire control for power saving mode 
 1100 0000 
 Set Channel[7] = 0 to tell HW channel is changing now. 
 Set Channel[7] = 1 to tell HW channel change is done. 
  Description: RF init function
  Parameters:
   In:
       byBBType
       byRFType
   Out:
       none
  Return Value: true if succeeded; false if failed.
  Description: Select channel
  Parameters:
   In:
       byRFType
       byChannel    - Channel number
   Out:
       none
  Return Value: true if succeeded; false if failed.
{{ RobertYu: 20050104 
}} RobertYu 
  Description: Write WakeProgSyn
  Parameters:
   In:
       iobase      - IO base address
       channel     - channel number
       bySleepCnt  - SleepProgSyn count
  Return Value: None.
 Init Reg + Channel Reg (2) 
 Need to check, PLLON need to be low for channel setting 
 Init Reg + Channel Reg (3) 
  Description: Set Tx power
  Parameters:
   In:
       iobase         - IO base address
       dwRFPowerTable - RF Tx Power Setting
   Out:
       none
  Return Value: true if succeeded; false if failed.
  Description: Set Tx power
  Parameters:
   In:
       iobase         - IO base address
       dwRFPowerTable - RF Tx Power Setting
   Out:
       none
  Return Value: true if succeeded; false if failed.
		 0x080F1B00 for 3 wire control TxGain(D10)
		  and 0x31 as TX Gain value
  Routine Description:
      Translate RSSI to dBm
  Parameters:
   In:
       priv         - The adapter to be translated
       byCurrRSSI      - RSSI to be translated
   Out:
       pdwdbm          - Translated dbm number
  Return Value: none
 Post processing for the 11bg and 11a.
  for save time on changing Reg2,3,5,7,10,12,15
	 if change between 11 bg and 11a need to update the following
	  register
	  Channel Index 1~14
 Change from 2.4G to 5G [Reg] 
 Change from 5G to 2.4G [Reg] 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose:Implement functions to access eeprom
  Author: Jerry Chen
  Date: Jan 29, 2003
  Functions:
       SROMbyReadEmbedded - Embedded read eeprom via MAC
       SROMbWriteEmbedded - Embedded write eeprom via MAC
       SROMvRegBitsOn - Set Bits On in eeprom
       SROMvRegBitsOff - Clear Bits Off in eeprom
       SROMbIsRegBitsOn - Test if Bits On in eeprom
       SROMbIsRegBitsOff - Test if Bits Off in eeprom
       SROMvReadAllContents - Read all contents in eeprom
       SROMvWriteAllContents - Write all contents in eeprom
       SROMvReadEtherAddress - Read Ethernet Address in eeprom
       SROMvWriteEtherAddress - Write Ethernet Address in eeprom
       SROMvReadSubSysVenId - Read Sub_VID and Sub_SysId in eeprom
       SROMbAutoLoad - Auto Load eeprom to MAC register
  Revision History:
---------------------  Static Definitions -------------------------
---------------------  Static Classes  ----------------------------
---------------------  Static Variables  --------------------------
---------------------  Static Functions  --------------------------
---------------------  Export Variables  --------------------------
---------------------  Export Functions  --------------------------
  Description: Read a byte from EEPROM, by MAC I2C
  Parameters:
   In:
       iobase          - IO base address
       byContntOffset  - address of EEPROM
   Out:
       none
  Return Value: data read
 turn off hardware retry for getting NACK 
 issue read command 
 wait DONE be set 
  Description: Read all contents of eeprom to buffer
  Parameters:
   In:
       iobase          - IO base address
   Out:
       pbyEepromRegs   - EEPROM content Buffer
  Return Value: none
 ii = Rom Address 
  Description: Read Ethernet Address from eeprom to buffer
  Parameters:
   In:
       iobase          - IO base address
   Out:
       pbyEtherAddress - Ethernet Address buffer
  Return Value: none
 ii = Rom Address 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  Purpose: driver entry for initial, open, close, tx and rx.
  Author: Lyndon Chen
  Date: Jan 8, 2003
  Functions:
    vt6655_probe - module initial (insmod) driver entry
    vt6655_remove - module remove entry
    device_free_info - device structure resource free function
    device_print_info - print out resource
    device_rx_srv - rx service function
    device_alloc_rx_buf - rx buffer pre-allocated function
    device_free_rx_buf - free rx buffer function
    device_free_tx_buf - free tx buffer function
    device_init_rd0_ring - initial rd dma0 ring
    device_init_rd1_ring - initial rd dma1 ring
    device_init_td0_ring - initial tx dma0 ring buffer
    device_init_td1_ring - initial tx dma1 ring buffer
    device_init_registers - initial MAC & BBP & RF internal registers.
    device_init_rings - initial txrx ring buffer
    device_free_rings - free all allocated ring buffer
    device_tx_srv - tx interrupt service function
  Revision History:
---------------------  Static Definitions -------------------------
  Define module options
 BasebandType[] baseband type selected
  0: indicate 802.11a type
  1: indicate 802.11b type
  2: indicate 802.11g type
  Static vars definitions
---------------------  Static Functions  --------------------------
---------------------  Export Variables  --------------------------
---------------------  Export Functions  --------------------------
  Initialisation of MAC & BBP registers
 Do MACbSoftwareReset in MACvInitialize 
 Only used in 11g type, sync with ERP IE 
 init MAC 
 Get Local ID 
 Get Channel range 
 Get Antena 
 if not set default is All 
 Set initial antenna mode 
 zonetype initial 
 Init RF module 
 Get Desire Power Value 
 Load power Table 
 recover 12,13 ,14channel for EUROPE by 11 channel 
 Load OFDM A Power Table 
 use relative tx timeout and 802.11i D4 
 set performance parameter by registry 
 reset TSF counter 
 enable TSF counter 
 initialize BBP registers 
 Set BB and packet type at the same time. 
 Set Short Slot Time, xIFS, and RSPINF. 
 Get GPIO 
 get Permanent network address 
 reset Tx pointer 
 reset Rx pointer 
 Turn On Rx DMA 
 start the adapter 
allocate all RDTD rings a single pool
 vir_pool: pvoid type 
 Init the RD0 ring entries 
 Init the RD1 ring entries 
 Init the TD ring entries 
-----------------------------------------------------------------
 FIX cast 
 Only the status of first TD in the chain is correct 
 first VGA diff gain 
 Read low level stats 
	
	  TBD....
	  Must do this after doing rxtx, cause ISR bit is slow
	  than RDTD write back
	  update ISR counter
 TODO: adhoc PS mode 
 If both buffers available wake the queue 
 Set TSR1 & ReqCount in TxDescHead 
 Poll Transmit the adapter 
 second memory barrier 
 reset TSF counter 
 do reset 
 initial to reload eeprom 
 Get RFType 
------------------------------------------------------------------
 SPDX-License-Identifier: GPL-2.0+
  Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  All rights reserved.
  set_channel() - Set NIC media channel
  @priv: The adapter to be set
  @ch: Channel to be set
  Return Value: true if succeeded; false if failed.
 Set VGA to max sensitivity 
 clear NAV 
	 TX_PE will reserve 3 us for MAX2829 A mode only,
	  it is for better TX throughput
 Init Synthesizer Table 
 set HW default power register 
 SPDX-License-Identifier: GPL-2.0
    Driver for KeyStream wireless LAN cards.
    Copyright (C) 2005-2008 KeyStream Corp.
    Copyright (C) 2009 Renesas Technology Corp.
 length check in advance ! 
 power save 
 Compute the MIC value
	
	  IEEE802.11i  page 47
	  Figure 43g TKIP MIC processing format
	  +--+--+--------+--+----+--+--+--+--+--+--+--+--+
	  |6 |6 |1       |3 |M   |1 |1 |1 |1 |1 |1 |1 |1 | Octet
	  +--+--+--------+--+----+--+--+--+--+--+--+--+--+
	  |DA|SA|Priority|0 |Data|M0|M1|M2|M3|M4|M5|M6|M7|
	  +--+--+--------+--+----+--+--+--+--+--+--+--+--+
 Information Element ID 
 WPA 
 WPA OUI check 
 id & size field 
 +size offset 
 pointer update 
 MIC save 
 MIC FAILURE 
  range 1-60 
  needed parameters: count, keyid, key type, TSC 
 indicate data size 
 min length check 
 AuthType 
 Reserve Area 
 source address check 
  for WPA 
 check 13th byte at rx data 
 (SNAP+UI..) skip 
 8802FDDI MAC copy 
 NETBEUI size add 
 copy after Type 
 other rx data 
 rx indication 
 mib_val_size 
 mib_val_type 
 wake_up_interruptible_all(&priv->confirm_wait); 
 in case of error 
 for power save 
 bssid check 
 disconnect indication 
 infrastructure mode cancel 
 result_code 
 infrastructure mode set 
 infrastructure mode set 
 noise 
 invalid noise value 
 wake_up_interruptible_all(&priv->confirm_wait); 
 wake_up_all(&priv->confirm_wait); 
 add event to hostt buffer 
 allocate size bytes, set header size and event 
 power save wakeup 
 skb check 
 dest and src MAC address copy 
 EtherTypeLength check 
 ProtocolEAP = (buffer+1) + (buffer << 8); 
 SAPCTLOUI(6 byte) add 
 DSAP 
 SSAP 
 CTL 
 OUI ("000000") 
 OUI ("000000") 
 OUI ("000000") 
 Length(2 byte) delete 
 pp->data copy 
 for WPA 
 for MIC FAILURE REPORT check 
 no encryption 
 header value set 
 tx request 
 MIC FAILURE REPORT check 
 pbcc not support 
 default value 
 default value 
 specified SSID SCAN 
 Device IO Receive indicate 
 rx event count inc 
 rate setting if rate segging is auto for changing phy_type (#94) 
 D_11G_ONLY_MODE or D_11BG_COMPATIBLE_MODE 
 rate mask by phy setting 
 D_11G_ONLY_MODE or D_11BG_COMPATIBLE_MODE 
 rate set update 
 execute sme 
 initialize 
 for power save 
 wake_up_interruptible_all(&priv->confirm_wait); 
 send to Station Management Entity module 
 enqueue sme event 
 in case of buffer overflow 
 SPDX-License-Identifier: GPL-2.0
    Driver for KeyStream 11bg wireless LAN
    Copyright (C) 2005-2008 KeyStream Corp.
    Copyright (C) 2009 Renesas Technology Corp.
 Include Wireless Extension definition and check version 
 enable iwspy support 
 New driver API 
 Frequency list (map channels to frequencies) 
 A few details needed for WEP (Wireless Equivalent Privacy) 
 128 (?) bits 
 40 bits RC4 - WEP 
 40-bit and 104-bit keys 
 	function prototypes
 not finished initialize 
 The status 
 Operation mode 
 Signal quality and co. But where is the noise level ??? 
 interruptible_sleep_on_timeout(&priv->confirm_wait, HZ2); 
 1sec 
  Initial Wireless Extension code for Ks_Wlannet driver by :
 	Jean Tourrilhes <jt@hpl.hp.com> - HPL - 17 November 00
  Conversion to new driver API by :
 	Jean Tourrilhes <jt@hpl.hp.com> - HPL - 26 March 02
  Javier also did a good amount of work here, adding some new extensions
  and fixing my code. Let's just say that without him this code just
  would not work at all... - Jean II
 for SLEEP MODE 
 for SLEEP MODE 
 If setting by frequency, convert to a channel 
 Hack to fall through... 
 Setting by channel number 
	 We should do a better check than that,
	  based on the card capability !!!
 Yes ! We can set it !!! 
 Call commit handler 
 for SLEEP MODE 
 for SLEEP MODE 
 Check if we asked for `any' 
 Just send an empty SSID list 
 iwconfig uses nul termination in SSID.. 
 Check the size of the string 
 Set the SSID 
 Write it to the card 
 for SLEEP MODE 
	 Note : if dwrq->flags != 0, we should
	  get the relevant SSID from the SSID list...
 Get the current SSID 
 If none, we may want to get the one that was set 
 Push it out ! 
 active 
 ANY 
 for SLEEP MODE 
 Write it to the card 
 Call commit handler 
 for SLEEP MODE 
 for SLEEP MODE 
 Check the size of the string 
 Call commit handler 
 for SLEEP MODE 
 for SLEEP MODE 
 vwrq->fixed == 0 
 D_11B_ONLY_MODE or  D_11BG_COMPATIBLE_MODE 
 vwrq->fixed == 0 
 vwrq->value == 6000000 
 Call commit handler 
 for SLEEP MODE 
 for SLEEP MODE 
 Call commit handler 
 for SLEEP MODE 
 for SLEEP MODE 
 Get an even value - is it really needed ??? 
 Call commit handler 
 for SLEEP MODE 
 Call commit handler 
 If not managed, assume it's ad-hoc 
 for SLEEP MODE 
 Is WEP supported ? 
 Basic checking: do we have a key to set ? 
 Check if the key is not marked as invalid 
 Cleanup 
 Copy the key in the driver 
 Send the key to the card 
 set_wep_key(priv, index, 0, 0, 1);   xxx 
 Commit the changes if needed 
 for SLEEP MODE 
 Check encryption mode 
 Which key do we want ? -1 -> tx index 
 dwrq->flags |= IW_ENCODE_NOKEY; 
 Copy the key to the user buffer 
 for SLEEP MODE 
	 Should be based on cap_rid.country to give only
	  what the current card support
 channel 1 -- 13 
 List index 
 Values in table in MHz ->  10^5  10 
 channel 14 
 List index 
 Values in table in MHz ->  10^5  10 
 Hum... Should put the right values there 
 0 dBm? 
 D_11G_ONLY_MODE or D_11BG_COMPATIBLE_MODE 
	 Set an indication of the max TCP throughput
	  in bits that we can expect using this interface.
	  May be use for QoS stuff... Jean II
 WEP: RC4 40 bits 
 WEP: RC4 ~128 bits 
 power management not support 
 Transmit Power - values are in dBm( or mW) 
 range->txpower_capa = IW_TXPOW_MWATT; 
	 Experimental measurements - boundary 115.5 Mbs
	 
	  Note : with or without the (local->rssi), results
	  are somewhat different. - Jean II
 -70 dBm 
 Event capability (kernel + driver) 
 encode extension (WPA) capability 
 for SLEEP MODE 
 for SLEEP MODE 
 not supported 
 not supported 
 Note : this is deprecated in favor of IWSCAN 
 for SLEEP MODE 
 invalid noise value 
 Should be define'd 
 for SLEEP MODE 
 specified SSID SCAN 
 At this point, just return to the user. 
  Translate scan data returned from the card to a card independent
  format that the Wireless Tools will understand - Jean II
 struct ks_wlan_private priv = (struct ks_wlan_private )dev->priv; 
 Temporary buffer 
 For rates 
 First entry MUST be the AP MAC address 
 Other entries will be displayed in the order we give them 
 Add the ESSID 
 Add mode 
 Add frequency 
 Add quality statistics 
 invalid noise value 
 Add encryption capability 
	
	  Rate : stuffing multiple values in a single event
	  require a bit more of magic - Jean II
 These two flags are ignored... 
 Max 16 values 
 NULL terminated 
 Bit rate given in 500 kbs units (+ 0x80) 
 Add new value to event 
 Check if we added any event 
	
	  The other data in the scan result are not really
	  interesting, so for now drop it - Jean II
 for SLEEP MODE 
		 Client error, no scan results...
		  The caller need to restart the scan.
 Read and parse all entries 
 Translate to WE format this entry 
 Length of data 
 called after a bunch of SET operations 
 set association ie params 
 for SLEEP MODE 
      return -EOPNOTSUPP;
 for SLEEP MODE 
 0 
 1 
 2 
 3 
 NONE or 802_1X_NO_WPA 
 WPA_NONE 
 6 
 7 
 10 
 4 
 5 
 8 
 9 
 return -EINPROGRESS; 
 for SLEEP MODE 
  WPA (not used ?? wpa_supplicant) 
 OK??? 
 return -EOPNOTSUPP; 
 set encoding token & mode (WPA)
 for SLEEP MODE 
 WPA_NONE 
 get encoding token & mode (WPA)
 for SLEEP MODE 
	 WPA (not used ?? wpa_supplicant)
	  struct ks_wlan_private priv = (struct ks_wlan_private )dev->priv;
	  struct iw_encode_ext enc;
	  enc = (struct iw_encode_ext )extra;
	  int index = dwrq->flags & IW_ENCODE_INDEX;
	  WPA (not used ?? wpa_supplicant)
 for SLEEP MODE 
 search cache data 
 not find address. 
 new cache data 
 overwrite old cache data 
 search cache data 
 not find address. 
	
	  Packets discarded in the wireless adapter due to wireless
	  specific problems
 Rx invalid nwid      
 Rx invalid crypt     
 Rx invalid frag      
 Tx excessive retries 
 Invalid misc         
 Missed beacon        
 for SLEEP MODE 
 for SLEEP MODE 
 Call commit handler 
 for SLEEP MODE 
 for SLEEP MODE 
 for SLEEP MODE 
 for SLEEP MODE 
 for SLEEP MODE 
 Call commit handler 
 for SLEEP MODE 
 for SLEEP MODE 
 Call commit handler 
 for SLEEP MODE 
 for SLEEP MODE 
 Call commit handler 
 for SLEEP MODE 
 for SLEEP MODE 
 for SLEEP MODE 
 length check 
 IE header + IE + sizeof(len) 
 IE header + IE 
 for SLEEP MODE 
 for SLEEP MODE 
 for SLEEP MODE 
 for SLEEP MODE 
 get host command history 
 Structures to export the Wireless Handlers 
{ cmd, set_args, get_args, name[16] } 
 private_handler 
 0 
 1, KS_WLAN_GET_DRIVER_VERSION 
 2 
 3 KS_WLAN_GET_FIRM_VERSION 
 4 KS_WLAN_SET_WPS_ENABLE 
 5 KS_WLAN_GET_WPS_ENABLE 
 6 KS_WLAN_SET_WPS_PROBE_REQ 
 7 KS_WLAN_GET_CONNECT 
 8 KS_WLAN_SET_PREAMBLE 
 9 KS_WLAN_GET_PREAMBLE 
 10 KS_WLAN_SET_POWER_SAVE 
 11 KS_WLAN_GET_POWER_SAVE 
 12 KS_WLAN_SET_SCAN_TYPE 
 13 KS_WLAN_GET_SCAN_TYPE 
 14 KS_WLAN_SET_RX_GAIN 
 15 KS_WLAN_GET_RX_GAIN 
 16 KS_WLAN_HOSTT 
 17 
 18 KS_WLAN_SET_BECAN_LOST 
 19 KS_WLAN_GET_BECAN_LOST 
 20 KS_WLAN_SET_TX_GAIN 
 21 KS_WLAN_GET_TX_GAIN 
 22 KS_WLAN_SET_PHY_TYPE 
 23 KS_WLAN_GET_PHY_TYPE 
 24 KS_WLAN_SET_CTS_MODE 
 25 KS_WLAN_GET_CTS_MODE 
 26 
 27 
 28 KS_WLAN_SET_SLEEP_MODE 
 29 KS_WLAN_GET_SLEEP_MODE 
 30 
 31 
 KS_WLAN_SET_STOP_REQ 
 All other calls are currently unsupported
 not finished initialize 
 not finished initialize 
  Set or clear the multicast filter for this adaptor.
  This routine is not state sensitive and need not be SMP locked.
 not finished initialize 
 Operational parameters that usually are not changed. 
 Time in jiffies before concluding the transmitter is hung. 
 int rc; 
 phy information update timer 
 dummy address set 
 The ks_wlan-specific entries in the device structure. 
  is_connect_status() - return true if status is 'connected'
  @status: high bit is used as FORCE_DISCONNECT, low bits used for
 	connect status.
  is_disconnect_status() - return true if status is 'disconnected'
  @status: high bit is used as FORCE_DISCONNECT, low bits used for
 	disconnect status.
 SPDX-License-Identifier: GPL-2.0
    Driver for KeyStream, KS7010 based SDIO cards.
    Copyright (C) 2006-2008 KeyStream Corp.
    Copyright (C) 2009 Renesas Technology Corp.
    Copyright (C) 2016 Sang Engineering, Wolfram Sang
  SDIO KeyStream vendor and device 
 Older sources suggest earlier versions were named 7910 or 79xx 
 ReadWrite Status Register 
 Read Index Register 
 Read Data Size Register 
 Write Index Register 
  Write StatusRead Data Size Register
  for network packet (less than 2048 bytes data)
 Write Status Register value 
 Read Data Size Register value [10:4] 
 ARM to SD interrupt Enable 
 ARM to SD interrupt Pending 
 General Communication Register A 
 General Communication Register B 
 Wakeup Register 
 AHB Data Window  0x010000-0x01FFFF 
  struct ks_sdio_card - SDIO device data.
  Structure is used as the &struct sdio_func private data.
  @func: Pointer to the SDIO function device.
  @priv: Pointer to the &struct net_device private data.
 Read single byte from device address into byte (CMD52) 
 Read length bytes from device address into buffer (CMD53) 
 Write single byte to device address (CMD52) 
 Write length bytes to device address from buffer (CMD53) 
 clear request 
 clear request 
 write data 
 TX Complete 
 add event to hostt buffer 
 receive data 
 length check 
 length check fail 
 wait after DOZE 
 wait after WAKEUP 
 power save wakeup 
 sleep mode doze 
 sleep mode wakeup 
 read (WriteStatusReadDataSize FN1:00_0014) 
 Read schedule 
 schedule task for interrupt status 
 bit7 -> Write General Communication B register 
 read (General Communication B register) 
 bit5 -> Write Status Idle 
 bit2 -> Read Status Busy  
 read (WriteStatusReadDataSize FN1:00_0014) 
 Read schedule 
 tx buffer clear 
 TX Complete 
 Firmware running ? 
 Firmware running check 
 wait_ms(10); 
 get mac address & firmware version 
 interrupt disable 
 setup interrupt handler 
	
	  interrupt setting
	  clear Interrupt status write
	  (ARMtoSD_InterruptPending FN1:00_0024)
 enable ks7010sdio interrupt 
 private memory initialize 
 sleep mode 
 private memory allocate 
 send stop request to MAC 
 interrupt disable 
 memory allocation failure 
 all zero  }
 SPDX-License-Identifier: GPL-2.0
  hal.c - DIM2 HAL implementation
  (MediaLB, Device Interface Macro IP, OS62420)
  Copyright (C) 2015-2016, Microchip Technology Germany II GmbH & Co. KG
 Author: Andrey Shvetsov <andrey.shvetsov@k2l.de> 
  Size factor for isochronous DBR buffer.
  Minimal value is 3.
  Number of 32-bit units for DBR map.
  1: block size is 512, max allocation is 16K
  2: block size is 256, max allocation is 8K
  4: block size is 128, max allocation is 4K
  8: block size is 64, max allocation is 2K
  Min allocated space is block size.
  Max possible allocated space is 32 blocks.
 -------------------------------------------------------------------------- 
 not configurable area 
 specified by IP 
 -------------------------------------------------------------------------- 
 generic helper functions and macros 
 -------------------------------------------------------------------------- 
 types and local variables 
 DIM2 core base address 
 -------------------------------------------------------------------------- 
  alloc_dbr() - Allocates DBR memory.
  @size: Allocating memory size.
  Returns: Offset in DBR memory by success or DBR_SIZE if out of memory.
 out of memory 
 out of memory 
 do shift left with 2 steps in case mask_size == 32 
 out of memory 
 -------------------------------------------------------------------------- 
 wait for transfer completion 
 clear transfer complete 
 clear transfer complete 
 clear transfer complete 
 unmask interrupt for used channel, enable mlb_sys_int[0] interrupt 
 mask interrupt for used channel, disable mlb_sys_int[0] interrupt 
 clear channel status bit 
 -------------------------------------------------------------------------- 
 trace async tx dbr fill state 
 -------------------------------------------------------------------------- 
 channel state helpers 
 -------------------------------------------------------------------------- 
 macro helper functions 
 too small 
 too big 
 too big 
 too small 
 too big 
 too small buffer for given packet_length 
 too small buffer for given bytes_per_frame 
 disable MediaLB 
 disable mlb_int interrupt 
 clear status for all dma channels 
 mask interrupts for all channels 
 configure and enable MediaLB 
 activate all HBI channels 
 enable HBI 
 configure DMA 
 -------------------------------------------------------------------------- 
 channel help routines 
 clear channel status bit 
 -------------------------------------------------------------------------- 
 channel init routines 
 returns true if channel interrupt state is cleared 
 -------------------------------------------------------------------------- 
 API 
 MediaLB clock: 0 - 256 fs, 1 - 512 fs, 2 - 1024 fs, 3 - 2048 fs 
 MediaLB clock: 4 - 3072 fs, 5 - 4096 fs, 6 - 6144 fs, 7 - 8192 fs 
  Retrieves maximal possible correct buffer size for isochronous data type
  conform to given packet length and not bigger than given buffer size.
  Returns non-zero correct buffer size or zero by error.
  Retrieves maximal possible correct buffer size for synchronous data type
  conform to given bytes per frame and not bigger than given buffer size.
  Returns non-zero correct buffer size or zero by error.
	
	  Use while-loop and a flag to make sure the age is changed back at
	  least once, otherwise the interrupt may never come if CPU generates
	  interrupt on changing age.
	  This cycle runs not more than number of channels, because
	  channel_service_interrupt() routine doesn't start the channel again.
 SPDX-License-Identifier: GPL-2.0
  dim2.c - MediaLB DIM2 Hardware Dependent Module
  Copyright (C) 2015-2016, Microchip Technology Germany II GmbH & Co. KG
 channel 0 is a system channel 
  The parameter representing the number of frames per sub-buffer for
  synchronous channels.  Valid values: [0 .. 6].
  The values 0, 1, 2, 3, 4, 5, 6 represent corresponding number of frames per
  sub-buffer 1, 2, 4, 8, 16, 32, 64.
 (1 << fcnt) frames per subbuffer 
  struct hdm_channel - private structure to keep channel specific data
  @name: channel name
  @is_initialized: identifier to know whether the channel is initialized
  @ch: HAL specific channel data
  @reset_dbr_size: reset DBR data buffer size
  @pending_list: list to keep MBO's before starting transfer
  @started_list: list to keep MBO's after starting transfer
  @direction: channel direction (TX or RX)
  @data_type: channel data type
 before dim_enqueue_buffer() 
 after dim_enqueue_buffer() 
  struct dim2_hdm - private structure to keep interface specific data
  @hch: an array of channel specific data
  @most_iface: most interface structure
  @capabilities: an array of channel capability data
  @io_base: IO register base address
  @netinfo_task: thread to deliver network status
  @netinfo_waitq: waitq for the thread to sleep
  @deliver_netinfo: to identify whether network status received
  @mac_addrs: INIC mac address
  @link_state: network link state
  @atx_idx: index of async tx channel
 Macro to identify a network status message 
  dimcb_on_error - callback from HAL to report miscommunication between
  HDM and HAL
  @error_id: Error ID
  @error_message: Error message. Some text in a free format
  try_start_dim_transfer - try to transfer a buffer on a channel
  @hdm_ch: channel specific data
  Transfer a buffer from pending_list if the channel is ready
  deliver_netinfo_thread - thread to deliver network status to mostcore
  @data: private data
  Wait for network status and deliver it to mostcore once it is received
  retrieve_netinfo - retrieve network status from received buffer
  @dev: private data
  @mbo: received MBO
  Parse the message in buffer and get node address, link state, MAC address.
  Wake up a thread to deliver this status to mostcore
  service_done_flag - handle completed buffers
  @dev: private data
  @ch_idx: channel index
  Return back the completed buffers to mostcore, using completion callback
  dim2_tasklet_fn - tasklet function
  @data: private data
  Service each initialized channel, if needed
  dim2_ahb_isr - interrupt service routine
  @irq: irq number
  @_dev: private data
  Acknowledge the interrupt and schedule a tasklet to service channels.
  Return IRQ_HANDLED.
  complete_all_mbos - complete MBO's in a list
  @head: list head
  Delete all the entries in list and return back MBO's to mostcore using
  completion call back.
  configure_channel - initialize a channel
  @most_iface: interface the channel belongs to
  @ch_idx: channel index to be configured
  @ccfg: structure that holds the configuration information
  Receives configuration information from mostcore and initialize
  the corresponding channel. Return 0 on success, negative on failure.
 do not reset if the property was set by user, see poison_channel 
 zero value is default dbr_size, see dim2 hal 
  enqueue - enqueue a buffer for data transfer
  @most_iface: intended interface
  @ch_idx: ID of the channel the buffer is intended for
  @mbo: pointer to the buffer object
  Push the buffer into pending_list and try to transfer one buffer from
  pending_list. Return 0 on success, negative on failure.
  request_netinfo - triggers retrieving of network info
  @most_iface: pointer to the interface
  @ch_idx: corresponding channel ID
  @on_netinfo: call-back used to deliver network status to mostcore
  Send a command to INIC which triggers retrieving of network info by means of
  "Message exchange over MDPMEP". Return 0 on success, negative on failure.
 PML High byte 
 PML Low byte 
 PMHL 
 FPH 
 FMF (FIFO cmd msg - Triggers NAOverMDP) 
  poison_channel - poison buffers of a channel
  @most_iface: pointer to the interface the channel to be poisoned belongs to
  @ch_idx: corresponding channel ID
  Destroy a channel and complete all the buffers in both started_list &
  pending_list. Return 0 on success, negative on failure.
  get_dim2_clk_speed - converts string to DIM2 clock speed value
  @clock_speed: string in the format "{NUMBER}fs"
  @val: pointer to get one of the CLK_{NUMBER}FS values
  By success stores one of the CLK_{NUMBER}FS in the val and returns 0,
  otherwise returns -EINVAL.
  dim2_probe - dim2 probe handler
  @pdev: platform device structure
  Register the dim2 interface with mostcore and initialize it.
  Return 0 on success, negative on failure.
  dim2_remove - dim2 remove handler
  @pdev: platform device structure
  Unregister the interface from mostcore
 platform specific functions [[ 
 enable pll 
 enable MLP pll and LVDS drivers 
 set bias 
 PLL 
 BBCR = 0b11 
 disable PLLs and LVDS drivers 
 PLL 
 BBCR = 0b11 
 disable PLLs and LVDS drivers 
 ]] platform specific functions 
 SPDX-License-Identifier: GPL-2.0
  i2c.c - Hardware Dependent Module for I2C Interface
  Copyright (C) 2013-2015, Microchip Technology Germany II GmbH & Co. KG
  list_first_mbo - get the first mbo from a list
  @ptr:	the list head to take the mbo from.
  configure_channel - called from MOST core to configure a channel
  @most_iface: interface the channel belongs to
  @ch_idx: channel to be configured
  @channel_config: structure that holds the configuration information
  Return 0 on success, negative on failure.
  Receives configuration information from MOST core and initialize the
  corresponding channel.
  enqueue - called from MOST core to enqueue a buffer for data transfer
  @most_iface: intended interface
  @ch_idx: ID of the channel the buffer is intended for
  @mbo: pointer to the buffer object
  Return 0 on success, negative on failure.
  Transmit the data over I2C if it is a "write" request or push the buffer into
  list if it is an "read" request
 RX 
 TX 
  poison_channel - called from MOST core to poison buffers of a channel
  @most_iface: pointer to the interface the channel to be poisoned belongs to
  @ch_idx: corresponding channel ID
  Return 0 on success, negative on failure.
  If channel direction is RX, complete the buffers in list with
  status MBO_E_CLOSE
 Read PML (2 bytes) 
 Read the whole message, including PML 
  pending_rx_work - Read pending messages through I2C
  @work: definition of this work item
  Invoked by the Interrupt Service Routine, most_irq_handler()
  most_irq_handler - Interrupt Service Routine
  @irq: irq number
  @_dev: private data
  Schedules a delayed work
  By default the interrupt line behavior is Active Low. Once an interrupt is
  generated by the device, until driver clears the interrupt (by reading
  the PMP message), device keeps the interrupt line in low state. Since i2c
  read is done in work queue, the interrupt line must be disabled temporarily
  to avoid ISR being called repeatedly. Re-enable the interrupt in workqueue,
  after reading the message.
  Note: If we use the interrupt line in Falling edge mode, there is a
  possibility to miss interrupts when ISR is getting executed.
  i2c_probe - i2c probe handler
  @client: i2c client device structure
  @id: i2c client device id
  Return 0 on success, negative on failure.
  Register the i2c client device as a MOST interface
 ID format: i2c-<bus>-<address> 
  i2c_remove - i2c remove handler
  @client: i2c client device structure
  Return 0 on success.
  Unregister the i2c client device as a MOST interface
 Terminating entry 
 SPDX-License-Identifier: GPL-2.0
  video.c - V4L2 component for Mostcore
  Copyright (C) 2015, Microchip Technology Germany II GmbH & Co. KG
 must be the first field of this struct! 
	
	  We need to put MBOs back before we call most_stop_channel()
	  to deallocate MBOs.
	  From the other hand mostcore still calling rx_completion()
	  to deliver MBOs until most_stop_channel() is called.
	  Use mute to work around this issue.
	  This must be implemented in core.
 wait for the first buffer 
 only wait if no data is available 
 allocate and fill v4l2 video struct 
 Fill the video capture device struct 
 Register the v4l2 device 
 Create the v4l2_device 
	
	  As the mostcore currently doesn't call disconnect_channel()
	  for linked channels while we call most_deregister_component()
	  we simulate this call here.
	  This must be fixed in core.
 SPDX-License-Identifier: GPL-2.0
  net.c - Networking component for Mostcore
  Copyright (C) 2015, Microchip Technology Germany II GmbH & Co. KG
 ch->linked = true, most_nd_open 
 list_head, ch->linked = false, dev_hold 
 end of FPH here 
	
	  Set default MTU for the given packet type.
	  It is still possible to change MTU using ip tools afterwards.
		
		  do not call most_stop_channel() here, because channels are
		  going to be closed in ndo_stop() after unregister_netdev()
 dest 
 src 
 eth type 
  on_netinfo - callback for HDM to be informed about HW's MAC
  @iface: most interface instance
  @link_stat: link status
  @mac_addr: MAC address
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2012 GCT Semiconductor, Inc. All rights reserved. 
  Netlink protocol number
  Default MTU Size
 Check for skb->len, discard if empty 
 Format the mac header so that it can be put to skb 
 Get the pointer of the original request 
 Get the pointer of the outgoing response 
 Copy the arp header 
 Copy the arp payload: based on 2 bytes of mac and fill the IP 
 Fill the destination mac with source mac of the received packet 
 Fill the source mac with nic's source mac 
 Alloc skb and reserve align 
 Format the mac header so that it can be put to skb 
 Check if this is IPv6 ICMP packet 
 Check if this is NDP packet 
 Check RS 
 Check NS 
 Duplicate Address Detection: Source IP is all zero 
 R=0, S=1, O=1 
 Fill the destination mac with source mac of the received packet 
 Fill the source mac with nic's source mac 
 Alloc skb and reserve align 
 NIC TYPE is based on the nic_id of this net_device 
 Get ethernet protocol 
 Process packet for nic type 
 Check DHCPv4 
 Check NDP request  {
 Check DHCPv6  {
	
	  Need byte shift (that is, remove VLAN tag) if there is one
	  For the case of ARP, this breaks the offset as vlan_ethhdr+4
	  is treated as ethhdr	However, it shouldn't be a problem as
	  the response starts from arp_hdr and ethhdr is created by this
	  driver based on the NIC mac
	 If it is a ICMPV6 packet, clear all the other bits :
	  for backward compatibility with the firmware
	 If it is not a dhcp packet, clear all the flag bits :
	  original NIC, otherwise the special flag (IPVX | DHCP)
 Updates tx stats 
		 Change the destination mac address
		  with the one requested the IP
 BOOTREQUEST or BOOTREPLY 
				u8 htype;    hardware address type.
					      1 = 10mb ethernet
 hardware address length 
 used by relay agents only 
 unique id 
				u16 secs;    elapsed since client began
					      acquisitionrenewal
 only one flag so far: 
 "I need broadcast replies" 
				u32 ciaddr;  client IP (if client is in
					      BOUND, RENEW or REBINDING state)
 'your' (client) IP address 
				 IP address of next server to use in
				  bootstrap, returned in DHCPOFFER,
				  DHCPACK by server
 relay agent IP address 
				u8 chaddr[16];    link-layer client hardware
						   address (MAC)
 server host name (ASCIZ) 
 boot file name (ASCIZ) 
				u32 cookie;       fixed first four option
						   bytes (99,130,83,99 dec)
 Format the data so that it can be put to skb 
		 Should be response: Only happens because
		  there was a request from the host
 Alloc skb and reserve align 
 Form the dev_addr 
	 The last byte of the mac address
	  should be less than or equal to 0xFC
	 Create random nic src and copy the first
	  3 bytes to be the same as dev_addr
 Copy the nic_dest from dev_addr
 if zero address or multicast bit set, restore the default value 
 Create device name lteXpdnX 
 Allocate netdev 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2012 GCT Semiconductor, Inc. All rights reserved. 
 GCT GDM7240 
 GCT GDM7243 
 GCT GDM7243 
 LGIT Phoenix 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2012 GCT Semiconductor, Inc. All rights reserved. 
 GCT GDM7240 
 GCT GDM7243 
	 List up hosts with big endians, otherwise,
	  defaults to little endian
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2012 GCT Semiconductor, Inc. All rights reserved. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2012 GCT Semiconductor, Inc. All rights reserved. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2012 GCT Semiconductor, Inc. All rights reserved. 
 SPDX-License-Identifier: GPL-2.0+
  NVIDIA Tegra Video decoder driver
  Copyright (C) 2016-2019 GRATE-DRIVER project
 SPDX-License-Identifier: GPL-2.0+
  NVIDIA Tegra Video decoder driver
  Copyright (C) 2016-2019 GRATE-DRIVER project
	
	  We're using some static addresses that are not accessible by VDE
	  to trap invalid memory accesses.
	
	  BSEV's end-address wraps around due to integer overflow during
	  of hardware context preparation if IOVA is allocated at the end
	  of address space and VDE can't handle that. Hence simply reserve
	  the last page to avoid the problem.
 SPDX-License-Identifier: GPL-2.0+
  NVIDIA Tegra Video decoder driver
  Copyright (C) 2016-2017 Dmitry Osipenko <digetx@gmail.com>
	
	  The IRAM mapping is write-combine, ensure that CPU buffers have
	  been flushed at this point.
	
	  We rely on the VDE registers reset value, otherwise VDE
	  causes bus lockup.
	
	  At first reset memory client to avoid resetting VDE HW in the
	  middle of DMA which could result into memory corruption or hang
	  the whole system.
	
	  VDE partition may be left ON after bootloader, hence let's
	  power-cycle it in order to put hardware into a predictable lower
	  power state.
	
	  As it increments RPM usage_count even on errors, we don't need to
	  check the returned code here.
	
	  Balance RPM state, the VDE power domain is left ON and hardware
	  is clock-gated. It's safe to reboot machine now.
	
	  On some devices bootloader isn't ready to a power-gated VDE on
	  a warm-reboot, machine will hang in that case.
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2018 BayLibre, SAS
  Author: Maxime Jourdan <mjourdan@baylibre.com>
 4 KiB per 64x32 block 
 32 bytes per 128x64 block 
 Y U V 
 Y U V 
 Y plane 
 U plane 
 V plane 
 Y UV 
 Y UV 
 Y plane 
 UV plane 
 Mark LAST for drained show frames during a source change 
 Buffer done probably means the vififo got freed 
 Look for our vififo offset to get the corresponding timestamp. 
			
			  Delete any record that remained unused for 32 match
			  checks
	
	  Check if the capture queue is already configured well for our
	  usecase. If so, keep decoding with it and do not send the event
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2018 Maxime Jourdan <mjourdan@baylibre.com>
 Configure decode head read mode 
 Enable 2-plane reference read mode 
 Fill the remaining unused slots with the last buffer's Y addr 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2018 Maxime Jourdan <mjourdan@baylibre.com>
  Copyright (C) 2015 Amlogic, Inc. All rights reserved.
 HEVC reg mapping 
 VP9 Constants 
 VP9 Workspace layout 
  Defines, declarations, sub-functions for vp9 de-block loop
	filter ThrLvl table update
  - struct segmentation is for loop filter only (removed something)
  - function "vp9_loop_filter_init" and "vp9_loop_filter_frame_init" will
	be instantiated in C_Entry
  - vp9_loop_filter_init run once before decoding start
  - vp9_loop_filter_frame_init run before every frame decoding start
  - set video format to VP9 is in vp9_loop_filter_init
 VP9 PROB processing defines 
 only use 3
 ((3 + 5  6)  3 + 1 padding)
 only use 21 (#  7)
 only use 90
only use 69
 VP9 COUNT mem processing defines 
 ((3 + 5  6)  5 
 Start merge_tree 
 Average of above and left pixels 
 Vertical 
 Horizontal 
 Directional 45 deg = round(arctan(11)  180pi) 
 Directional 135 deg = 180 - 45 
 Directional 117 deg = 180 - 63 
 Directional 153 deg = 180 - 27 
 Directional 207 deg = 180 + 27 
 Directional 63 deg = round(arctan(21)  180pi) 
 True-motion 
 Use a static inline to avoid possible side effect from num being reused 
1 bit
1 bit
1 bit
1 bit
1 bit
 bit 15: feature enabled; bit 8, sign; bit[5:0], data 
 Use alternate Quantizer 
 Use alternate loop filter value 
 Optional Segment reference frame 
 Optional Segment (0,0) + skip mode 
 Number of features supported 
0 = Intra, Last, GF, ARF
0 = ZERO_MV, MV
 VP9 context lock 
 Common part with the HEVC decoder 
 Buffer for the VP9 Workspace 
 Contains many information parsed from the bitstream 
 Whether we detected the bitstream as 10-bit 
 Coded resolution reported by the hardware 
 All ref frames used by the HW at a given time 
	 In case of downsampling (decoding with FBC but outputting in NV12M),
	  we need to allocate additional buffers for FBC.
 loop filter 
 For each possible value for the loop filter fill out limits
 Set loop filter parameters that control sharpness.
 Instantiate this function once when decode is started 
 dw fifo thres r and b 
 dw fifo thres r or b 
 dw fifo thres not rb 
 VP9 video format 
 VP9 video format 
	
	  n_shift is the multiplier for lf_deltas
	  the multiplier is:
	  - 1 for when filter_lvl is between 0 and 31
	  - 2 when filter_lvl is between 32 and 63
 update limits if sharpness has changed 
 Write to register 
			
			  We could get rid of this if we assume that deltas
			  are set to zero when not in use.
			  encoder always uses deltas
 Allocate some memory for the VP9 decoder's state 
 stream_fifo_hole 
 clear mailbox interrupt 
 enable mailbox interrupt 
 disable PSCALE for hardware sharing 
 Let the uCode do all the parsing 
  Program LAST & GOLDEN frames into the motion compensation reference cache
  controller
 Reset mcrcc 
 Disable on I-frame 
 Enable mcrcc progressive-mode 
 use HEVC_CM_HEADER_START_ADDR 
 enable first, compressed write 
 enable second, uncompressed write 
 dblk pipeline mode=1 for performance 
 Set endianness for 2-bytes swaps (nv12) 
 disable cm compression 
 TOFIX: Handle Amlogic Framebuffer compression 
 no downscale for NV12 
 NV12 
 clear mpred (for keyframe only) 
 ask uCode to start decoding 
  The RPM section within the workspace contains
  many information regarding the parsed bitstream
 weighted_prob 
 get binary prob 
 mode_mv_merge_probs - merge_intra_inter_prob 
 weighted prob 
 VP9_REQ_ADAPT_PROB 
 Invalidate first 3 refs 
 No frame is actually processed 
 Show the remaining frame 
 FIXME: Save refs for resized frame 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2018 BayLibre, SAS
  Author: Maxime Jourdan <mjourdan@baylibre.com>
  VDEC_1 is a video decoding block that allows decoding of
  MPEG 124, H.263, H.264, MJPEG, VC1
 AO Registers 
 VDEC_1 specific ESPARSER stuff 
 enable vdec1 isolation 
 power off vdec1 memories 
 power off vdec1 
 Configure the vdec clk to the maximum available 
 Enable power for VDEC_1 
 Reset VDEC1 
 enable VDEC Memories 
 Remove VDEC1 Isolation 
 Reset DOS top registers 
 Enable IRQ 
 Enable 2-plane output 
 Enable firmware processor 
 Let the firmware settle 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2018 Maxime Jourdan <maxi.jourdan@wanadoo.fr>
  VDEC_HEVC is a video decoding block that allows decoding of
  HEVC, VP9
 AO Registers 
 VDEC_HEVC specific ESPARSER configuration 
 set vififo_vbuf_rp_sel=>vdec_hevc 
 Disable interrupt 
 Disable firmware processor 
 Enable VDEC_HEVC Isolation 
 VDEC_HEVC Memories 
 Reset VDEC_HEVC
 VDEC_HEVC Memories 
 Remove VDEC_HEVC Isolation 
 Let the firmware settle 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2019 BayLibre, SAS
  Author: Maxime Jourdan <mjourdan@baylibre.com>
  Offset added by the firmware which must be substracted
  from the workspace phyaddr
 ISR status 
 Picture type 
 Size of Motion Vector per macroblock 
 Frame status data 
 Bitstream parsed data 
  Buffer to send to the ESPARSER to signal End Of Stream for H.264.
  This is a 16x16 encoded picture that will trigger drain firmware-side.
  There is no known alternative.
 H.264 decoder requires an extended firmware 
 Buffer for the H.264 Workspace 
 Buffer for the H.264 references MV 
 Buffer for parsed SEI data 
	
	  Tell the firmware it can recycle this buffer.
	  AV_SCRATCH_8 serves the same purpose.
 Allocate some memory for the H.264 decoder's state 
 Allocate some memory for the H.264 SEI dump 
 Enable "error correction" 
 Align to a multiple of 4 macroblocks 
 Address to store the references' MVs 
 End of ref MV 
  Configure the H.264 decoder when the parser detected a parameter set change
 Total number of 16x16 macroblocks 
 Number of macroblocks per line 
 Number of macroblock lines 
  The bitstream offset is split in half in 2 different registers.
  Fetch its MSB here, which location depends on the frame number.
		
		  A buffer decode error means it was decoded,
		  but part of the picture will have artifacts.
		  Typical reason is a temporarily corrupted bitstream
 Unused but not worth printing for 
 Decoder has some SEI data for us ; ignore 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2018 BayLibre, SAS
  Author: Maxime Jourdan <mjourdan@baylibre.com>
  The Elementary Stream Parser is a HW bitstream parser.
  It reads bitstream buffers and feeds them to the VIFIFO
 PARSER REGS (CBUS) 
  VP9 frame headers need to be appended by a 16-byte long
  Amlogic custom header
 nothing 
 Pad the packet to at least 4KiB bytes otherwise the VDEC unit won't trigger
  ISRs.
  Also append a start code 000001ff at the end to trigger
  the ESPARSER interrupt.
 6 KiB internal fifo
	
	  When max ref frame is held by VP9, this should be -= 3 to prevent a
	  shortage of CAPTURE buffers on the decoder side.
	  For the future, a good enhancement of the way this is handled could
	  be to notify new capture buffers to the decoding modules, so that
	  they could pause when there is no capture buffer available and
	  resume on this notification.
 If unable to alter buffer to add headers 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2018 BayLibre, SAS
  Author: Maxime Jourdan <mjourdan@baylibre.com>
 16 MiB for parsed bitstream swap exchange 
 We consider 50ms with no IRQ to be inactive. 
	 We need to program the complete CAPTURE buffer list
	  in registers during start_streaming, and the firmwares
	  are free to choose any of them to write frames to. As such,
	  we need all of them to be queued into the driver
 Drain remaining refs if was still running 
 Should not happen 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2018 BayLibre, SAS
  Author: Maxime Jourdan <mjourdan@baylibre.com>
 Offset substracted by the firmware from the workspace paddr 
 map firmware registers to known MPEG12 functions 
 Buffer for the MPEG12 Workspace 
 Allocate some memory for the MPEG12 decoder's state 
 Unclear what this means 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2018 BayLibre, SAS
  Author: Maxime Jourdan <mjourdan@baylibre.com>
 SPDX-License-Identifier: GPL-2.0-or-later
  Zoran ZR36016 basic configuration functions
  Copyright (C) 2001 Wolfgang Scherr <scherr@net4you.at>
 headerfile of this module 
 codec io API 
 it doesn't make sense to have more than 20 or so,
 amount of chips attached via this driver 
 debugging is available via module parameter 
 =========================================================================
   Local hardware IO functions:
   readwrite via codec layer (registers are located in the master device)
 read and write functions 
 just in case something is wrong... 
 just in case something is wrong...
 indirect read and write functions 
 the 016 supports auto-addr-increment, but
 just in case something is wrong... 
 ADDR
 DATA
 just in case something is wrong... 
 ADDR
 DATA
 =========================================================================
   Local helper function:
   version read
 version kept in datastructure 
 =========================================================================
   Local helper function:
   basic test of "connectivity", writesreads tofrom PAX-Lo register
 for testing just write 0, then the default value to a register and read
 it back in both cases
 we allow version numbers from 0-3, should be enough, though
 looks good! 
 =========================================================================
   Local helper function:
   simple loop for pushing the init datasets - NO USE --
 =========================================================================
   Basic datasets & init:
   TODO
 stop any processing
 mode setup (yuv422 in and out, compressionexpansuon due to mode)
 misc setup
 Window setup
 (no extra offset for now, norm defines offset, default width height)
 shall we continue now, please? 
 =========================================================================
   CODEC API FUNCTIONS
   this functions are accessed by the master via the API structure
 set compressionexpansion mode and launches codec -
 set picture size 
	 if () return -EINVAL;
	  trust the master driver that it knows what it does - so
	 (Ronald) This is ugly. zoran_device.c, line 387
	  already mentions what happens if h_start is even
	  (blue faces, etc., crcb inversed). There's probably
	  some good reason why h_start is 0 instead of 1, so I'm
	  leaving it to this for now, but really... This can be
	 Something to note here (I don't understand it), setting
	  v_start too high will cause the codec to 'not work'. I
	  really don't get it. values of 16 (v_start) already break
 (Ronald) dzjeeh, can't this thing do hor_decimation = 4? 
 additional control functions 
 get last status - we don't know it ... 
 not needed, do nothing 
 not available, give an error 
 =========================================================================
   Exit and unregister function:
   Deinitializes Zoran's JPEG processor
 do wee need some codec deinit here, too ???? 
 =========================================================================
   Setup and registry function:
   Initializes Zoran's JPEG processor
   Also sets pixel size, average code size, mode (compr.decompr.)
   (the given size is determined by the processor with the video interface)
mem structure init
testing
final setup
 magic not used 
 functionality 
 others are not used 
 =========================================================================
   HOOK IN DRIVER AS KERNEL MODULE
dprintk(1, "ZR36016 driver %s\n",ZR016_VERSION);
 SPDX-License-Identifier: GPL-2.0-or-later
  Zoran zr36057zr36067 PCI controller driver, for the
  PinnacleMiro DC10DC10+DC30DC30+, Iomega Buz, Linux
  Media Labs LML33LML33R10.
  Copyright (C) 2000 Serguei Miridonov <mirsev@cicese.mx>
  Changes for BUZ by Wolfgang Scherr <scherr@net4you.net>
  Changes for DC10DC30 by Laurent Pinchart <laurent.pinchart@skynet.be>
  Changes for LML33R10 by Maxim Yevtyushkin <max@linuxmedialabs.com>
  Changes for videodev2v4l2 by Ronald Bultje <rbultje@ronald.bitfreak.net>
  Based on
  Miro DC10 driver
  Copyright (C) 1999 Wolfgang Scherr <scherr@net4you.net>
  Iomega Buz driver version 1.0
  Copyright (C) 1999 Rainer Johanni <Rainer@Johanni.de>
  buz.0.0.3
  Copyright (C) 1998 Dave Perks <dperks@ibm.net>
  bttv - Bt848 frame grabber driver
  Copyright (C) 1996,97,98 Ralph  Metzler (rjkm@thp.uni-koeln.de)
                         & Marcus Metzler (mocm@thp.uni-koeln.de)
	
	  small helper function for calculating buffersizes for v4l2
	  we calculate the nearest higher power-of-two, which
	  will be the recommended buffersize
    V4L Buffer grabbing
 Check size and format of the grab wanted 
 Check against available buffer size 
 The video front end needs 4-byte alinged line sizes 
 Make sure the changes come into effect 
    ioctl routine
 fmt struct pre-zeroed, so adding '\0' not needed 
 TODO: output does not work yet 
 we actually need to set 'real' parameters now 
 check 
 tell the user what we actually did 
 TODO do not return here to fix the TRY_FMT cannot handle an invalid pixelformat
 we actually need to set 'real' parameters now 
 check 
 it's ok, so set them 
 tell the user what we actually did 
 TODO do not return here to fix the TRY_FMT cannot handle an invalid pixelformat
 tell the user the resultsmissing stuff 
 Get status of video decoder 
 TODO: output does not work yet 
 cropping (sub-frame capture) 
 move into a form that we understand 
 check validity 
 accept 
  Output is disabled temporarily
  Zoran is picky about jpeg data it accepts. At least it seems to unsupport COM and APPn.
  So until a way to filter data will be done, disable output.
	.vidioc_enum_output		    = zoran_enum_output,
	.vidioc_g_output		    = zoran_g_output,
	.vidioc_enum_fmt_vid_out	    = zoran_enum_fmt_vid_out,
	.vidioc_g_fmt_vid_out               = zoran_g_fmt_vid_out,
	.vidioc_s_fmt_vid_out               = zoran_s_fmt_vid_out,
	.vidioc_try_fmt_vid_out		    = zoran_try_fmt_vid_out,
 Switch to color bar 
 SPDX-License-Identifier: GPL-2.0-or-later
  Zoran ZR36060 basic configuration functions
  Copyright (C) 2002 Laurent Pinchart <laurent.pinchart@skynet.be>
 IO commands, error codes 
 headerfile of this module 
 codec io API 
 it doesn't make sense to have more than 20 or so, just to prevent some unwanted loops 
 amount of chips attached via this driver 
 debugging is available via module parameter 
 =========================================================================
  Local hardware IO functions:
  readwrite via codec layer (registers are located in the master device)
  =========================================================================
 just in case something is wrong...
 just in case something is wrong...
 =========================================================================
  Local helper function:
  status read
  =========================================================================
 status is kept in datastructure 
 scale factor is kept in datastructure 
 leave 0 selected for an eventually GO from master 
 wait if codec is ready to proceed (end of processing) or time is over 
 200ms, there is for sure something wrong!!!
 Basic test of "connectivity", writesreads tofrom memory the SOF marker 
 looks good! 
 simple loop for pushing the init datasets 
 =========================================================================
  Basic datasets:
  jpeg baseline setup data (you find it on lots places in internet, or just
  extract it from any regular .jpg image...)
  Could be variable, but until it's not needed it they are just fixed to save
  memory. Otherwise expand zr36060 structure with arrays, push the values to
  it and initialize from there, as e.g. the linux zr3605760 driver does it.
  =========================================================================
Marker: DQT
Length: 265+2
Pq,Tq first table
Pq,Tq second table
Marker: DHT
Length: 2AC, 2DC
DC first table
DC second table
AC first table
AC second table
 jpeg baseline setup, this is just fixed in this driver (YUV pictures) 
Y,U,V
MCU size (?)
table idx's QT
table idx's DC
table idx's AC
 horizontal 422 decimation setup (maybe we support 411 or so later, too) 
 SOF (start of frame) segment depends on width, height and sampling ratio of each color component 
 max. size of register set
 only '8' possible with zr36060
 index identifier
 sampling ratios
 Q table selection
 SOS (start of scan) segment depends on the used scan components of each color component 
 max. size of register set
 index
 ACDC tbl.sel.
 scan start
 DRI (define restart interval) 
 max. size of register set
 Setup compressiondecompression of Zoran's JPEG processor ( see also zoran 36060 manual )
  ... sorry for the spaghetti code ...
 060 communicates with 067 in master mode 
 Compression with or without variable scale factor 
FIXME: What about ptr->bitrate_ctrl? 
 Must be zero 
 Disable all IRQs - no DataErr means autoreset 
 volume control settings 
 setup the variable jpeg tables 
 setup the fixed jpeg tables - maybe variable, though - (see table init section above) 
 setup misc. data for compression (target code sizes) 
 size of compressed code to reach without header data 
 need the size in bits 
 bits without stuffing
 bits without eob
 JPEG markers to be included in the compressed stream 
 Setup the Video Frontend 
 Limit pixel range to 16..235 as per CCIR-601 
 060 communicates with 067 in master mode 
 Decompression 
 Must be zero 
 Disable all IRQs - no DataErr means autoreset 
 setup misc. data for expansion 
 setup the fixed jpeg tables - maybe variable, though - (see table init section above) 
 Setup the Video Frontend 
zr36060_write(ptr, ZR060_VCR, ZR060_VCR_FI_EXT);
this doesn't seem right and doesn't work...
 Load the tables 
 something is wrong, its timed out!!!!
 =========================================================================
  CODEC API FUNCTIONS
  this functions are accessed by the master via the API structure
  =========================================================================
 set compressiionexpansion mode and launches codec -
  this should be the last call from the master before starting processing
 set picture size (norm is ignored as the codec doesn't know about it) 
	 if () return -EINVAL;
	  trust the master driver that it knows what it does - so
	  we allow invalid startxy and norm for now ...
	 Note that VSPolHSPol bits in zr36060 have the opposite
	  meaning of their zr360x7 counterparts with the same names
	  N.b. for VSPol this is only true if FIVEdge = 0 (default,
	  left unchanged here - in accordance with datasheet).
 sync generator 
 Vtotal 
 Htotal 
 VsyncSize 
reg   = 30 - 1;                HsyncSize 
CP        reg = (zr->params.norm == 1 ? 57 : 68);
 BVstart 
 BVend 
 BHstart 
 BHend 
 active area 
 Vstart 
 Vend 
 Hstart 
 Hend 
 subimage area 
 SVstart 
 SVend 
+ 64   - 4;	
 SHend 
 Target compressed field size in bits: 
 uncompressed size in bits 
	 (Ronald) by default, quality = 100 is a compression
	  ratio 1:2. Setting low_bitrate (insmod option) sets
	  it to 1:4 (instead of 1:2, zr36060 max) as limit because the
	  buz can't handle more at decimation=1... Use low_bitrate if
	  you have a Buz, unless you know what you're doing
 Lower limit (arbitrary, 1 KB) 
 Upper limit: 78 of the code buffers 
 in bytes 
	 the MBCVR is the maximum block volume, according to the
	  JPEG ISO specs, this shouldn't be used, since that allows
	  for the best encoding quality. So set it to it's max value
 additional control functions 
 get last status 
 not needed, do nothing 
 not needed, do nothing 
 not available, give an error 
 get target volume in byte 
 get target volume in byte 
 get scaling factor 
 set scaling factor 
 get appn marker data 
 set appn marker data 
 get comment marker data 
 set comment marker data 
 =========================================================================
  Exit and unregister function:
  Deinitializes Zoran's JPEG processor
  =========================================================================
 do wee need some codec deinit here, too ???? 
 =========================================================================
  Setup and registry function:
  Initializes Zoran's JPEG processor
  Also sets pixel size, average code size, mode (compr.decompr.)
  (the given size is determined by the processor with the video interface)
  =========================================================================
mem structure init
testing
final setup
 0 or 1 - fixed file size flag (what is the difference?) 
 CHECKME 
 CHECKME, was 120 is 240 
 CHECKME, was 8 is 1 
 by default, no COM or APP markers - app should set those 
 magic not used
 functionality
 others are not used
 however, we can't just stay alive 
 SPDX-License-Identifier: GPL-2.0-or-later
  Zoran ZR36050 basic configuration functions
  Copyright (C) 2001 Wolfgang Scherr <scherr@net4you.at>
 IO commands, error codes 
 headerfile of this module 
 codec io API 
 it doesn't make sense to have more than 20 or so,
 amount of chips attached via this driver 
 debugging is available via module parameter 
 =========================================================================
   Local hardware IO functions:
   readwrite via codec layer (registers are located in the master device)
 read and write functions 
 just in case something is wrong... 
 just in case something is wrong... 
 =========================================================================
   Local helper function:
   status read
 status is kept in datastructure 
 =========================================================================
   Local helper function:
   scale factor read
 scale factor is kept in datastructure 
 leave 0 selected for an eventually GO from master 
 =========================================================================
   Local helper function:
   wait if codec is ready to proceed (end of processing) or time is over
 200ms, there is for sure something wrong!!!
 =========================================================================
   Local helper function:
   basic test of "connectivity", writesreads tofrom memory the SOF marker
 looks good! 
 =========================================================================
   Local helper function:
   simple loop for pushing the init datasets
 =========================================================================
   Basic datasets:
   jpeg baseline setup data (you find it on lots places in internet, or just
   extract it from any regular .jpg image...)
   Could be variable, but until it's not needed it they are just fixed to save
   memory. Otherwise expand zr36050 structure with arrays, push the values to
   it and initialize from there, as e.g. the linux zr3605760 driver does it.
Marker: DQT
Length: 265+2
Pq,Tq first table
Pq,Tq second table
Marker: DHT
Length: 2AC, 2DC
DC first table
DC second table
AC first table
AC second table
 jpeg baseline setup, this is just fixed in this driver (YUV pictures) 
Y,U,V
MCU size (?)
table idx's QT
table idx's DC
table idx's AC
 horizontal 422 decimation setup (maybe we support 411 or so later, too) 
 =========================================================================
   Local helper functions:
   calculation and setup of parameter-dependent JPEG baseline segments
   (needed for compression only)
 ------------------------------------------------------------------------- 
 SOF (start of frame) segment depends on width, height and sampling ratio
 max. size of register set
 only '8' possible with zr36050
 index identifier
 sampling ratios
 Q table selection
 ------------------------------------------------------------------------- 
 SOS (start of scan) segment depends on the used scan components
 max. size of register set
 index
 ACDC tbl.sel.
 scan start
 ------------------------------------------------------------------------- 
 DRI (define restart interval) 
 max. size of register set
 =========================================================================
   Setup function:
   Setup compressiondecompression of Zoran's JPEG processor
   ( see also zoran 36050 manual )
   ... sorry for the spaghetti code ...
 050 communicates with 057 in master mode 
 encoding table preload for compression 
 disable all IRQs 
 low 2 bits always 1
 volume control settings 
zr36050_write(ptr, ZR050_MBCV, ptr->max_block_vol);
 setup the variable jpeg tables 
		 setup the fixed jpeg tables - maybe variable, though -
 do the internal huffman table preload 
 launch codec
 something is wrong, its timed out!!!!
 setup misc. data for compression (target code sizes) 
 size of compressed code to reach without header data 
 need the size in bits 
 bits without stuffing
 bits without eob
 compression setup with or without bitrate control 
 this headers seem to deliver "valid AVI" jpeg frames 
 050 communicates with 055 in master mode 
 encoding table preload 
 disable all IRQs 
 low 2 bits always 1
 do the internal huffman table preload 
 launch codec
 something is wrong, its timed out!!!!
 setup misc. data for expansion 
 adr on selected, to allow GO from master 
 =========================================================================
   CODEC API FUNCTIONS
   this functions are accessed by the master via the API structure
 set compressionexpansion mode and launches codec -
 set picture size (norm is ignored as the codec doesn't know about it) 
	 if () return -EINVAL;
	  trust the master driver that it knows what it does - so
 (KM) JPEG quality 
 size in bits 
 apply quality setting 
 Minimum: 1kb 
 Maximum: 78 of code buffer 
 in bytes 
	 Set max_block_vol here (previously in zr36050_init, moved
 additional control functions 
 get last status 
 not needed, do nothing 
 not needed, do nothing 
 not available, give an error 
 get target volume in byte 
 get target volume in byte 
		 (Kieran Morrissey)
 get scaling factor 
 set scaling factor 
 get appn marker data 
 set appn marker data 
 get comment marker data 
 set comment marker data 
 =========================================================================
   Exit and unregister function:
   Deinitializes Zoran's JPEG processor
 do wee need some codec deinit here, too ???? 
 =========================================================================
   Setup and registry function:
   Initializes Zoran's JPEG processor
   Also sets pixel size, average code size, mode (compr.decompr.)
   (the given size is determined by the processor with the video interface)
mem structure init
testing
final setup
	ptr->bitrate_ctrl = 0;	 0 or 1 - fixed file size flag
 no appcom marker by default 
 magic not used
 functionality
 others are not used
 =========================================================================
   HOOK IN DRIVER AS KERNEL MODULE
dprintk(1, "ZR36050 driver %s\n",ZR050_VERSION);
 SPDX-License-Identifier: GPL-2.0-or-later
  Zoran zr36057zr36067 PCI controller driver, for the
  PinnacleMiro DC10DC10+DC30DC30+, Iomega Buz, Linux
  Media Labs LML33LML33R10.
  This part handles card-specific data and detection
  Copyright (C) 2000 Serguei Miridonov <mirsev@cicese.mx>
  The video mem address of the video card. The driver has a little database
  for some videocards to determine it from there. If your video card is not
  in there you have either to give it to the driver as a parameter or set
  in a VIDIOCSFBUF ioctl
 default = 0 - Video memory base address 
 Default input and video norm at startup of the driver. 
 default 0 = Composite, 1 = S-Video 
 6 Eyes input selection 
 default 0 = PAL, 1 = NTSC 2 = SECAM 
 devvideoN, -1 for autodetect 
 Everybody should be able to work with this setting 
 max size for 100% quality full-PAL frame 
 1=Pass through TV signal when device is not used 
 0=Show color bar when device is not used (LML33: only if lml33dpath=1) 
 number of cards found 
 videocodec bus functions ZR36060 
 videocodec bus functions ZR36050 
 reg. HIGHBYTES
 reg. LOWBYTES + read
 reg. HIGHBYTES
 reg. LOWBYTES + wr. data
 videocodec bus functions ZR36016 
 read
 hack for in zoran_device.c 
 wr. data
  Board specific information
 Pixel clock selection 
 Enable the video bus sync signals 
 some stuff from Iomega 
 Set Composite inputoutput
 AverMedia 6-Eyes original driver by Christer Weinigel
 Lifted straight from Christer's old driver and
 modified slightly by Martin Samuelsson.
 1 = BT866, 7 = VID1 
 Bt866 SLEEP on 
 ZR36060 RESET on 
 ZR36060 SLEEP on 
 MUX S0 
 FRAME on 
 Bt866 SLEEP off 
 MUX S1 
 ? 
 MUX S2 
 struct tvnorm {
      u16 wt, wa, h_start, h_sync_start, ht, ha, v_start;
 };
 The DC10 (571650) uses VActive as HSync, so h_start must be 0 
  FIXME: I cannot swap U and V in saa7114, so i do one pixel left shift in zoran (75 -> 74)
  (Maxim Yevtyushkin <max@linuxmedialabs.com>)
  FIXME: The ks0127 seem incapable of swapping U and V, too, which is why I copy Maxim's left
  shift hack for the 6 Eyes.
  Christer's driver used the unshifted norms, though...
  Sam
 AverMedia chose not to brand the 6-Eyes. Thus it can't be autodetected, and requires card=x. 
 Validity unknown Sam
 Validity unknown Sam
 Validity unknown Sam
 Validity unknown Sam
  I2C functions
 software I2C functions 
 Check a zoran_params struct for correctness, insert default params 
 Check decimation, set default values for decimation = 1, 2, 4 
 We have to check the data the user has set 
 YUY2 - YUV-4:2:2 packed 
 Set necessary params and call zoran_check_jpg_settings to set the defaults 
 default compression factor 8 
 No APPn marker 
 No COM marker 
 Avoid nonsense settings from user for default inputnorm 
 default setup (will be repeated at every open) 
 allocate memory before doing anything to the hardware in case allocation fails 
 mark as unavailable to zr36057 
 Now add the template and register the device unit. 
	
	  It's not a mem2mem device, but you can both capture and output from one and the same
	  device. This should really be split up into two device nodes, but that's a job for
	  another day.
 unregister videocodec bus 
 unregister i2c bus 
 disable PCI bus-mastering 
 put chip into reset 
 unmap and free memory 
	
	  magic and type are unused for master struct. Makes sense only at codec structs.
	  In the past, .type were initialized to the old V4L1 .hardware value,
	  as VID_HARDWARE_ZR36067
	
	  Bt819 needs to reset its FIFO buffer using #FRST pin and
	  LML33 card uses GPIO(7) for that.
    Scan for a Buz card (actually for the PCI controller ZR36057),
    request the irq and map the io memory
 Use auto-detected card type? 
	
	  even though we make this a non pointer and thus
	  theoretically allow for making changes to this struct
	  on a per-individual card basis at runtime, this is
	  strongly discouraged. This structure is intended to
	  keep general card information, no settings or anything
 set PCI latency timer 
 i2c 
 reset JPEG codec 
 video bus enabled 
 display codec revision 
 take care of Natoma chipset and a revision 1 zr36057 
 check the parameters we have been given, adjust if necessary 
 The user specifies the in KB, we want them in byte (and page aligned) 
 2 MB is arbitrary but sufficient for the maximum possible images 
 Use parameter for vidmem or try to find a video card 
 some mainboards might not do PCI-PCI data transfer well 
 SPDX-License-Identifier: GPL-2.0-or-later
  Zoran zr36057zr36067 PCI controller driver, for the
  PinnacleMiro DC10DC10+DC30DC30+, Iomega Buz, Linux
  Media Labs LML33LML33R10.
  This part handles device access (PCII2Ccodec...)
  Copyright (C) 2000 Serguei Miridonov <mirsev@cicese.mx>
static bool lml33dpath;		 default = 0
				  1 will use digital path in capture
				  mode instead of analog. It can be
				  used for picture adjustments using
				  tool like xawtv while watching image
				  on TV monitor connected to the output.
				  However, due to absence of 75 Ohm
				  load on Bt819 input, there will be
				  some image imperfections
  initialize video front end
 || zr->revision < 1) 
  General Purpose IO and Guest bus access
  This is a bit tricky. When a board lacks a GPIO function, the corresponding
  GPIO bit number in the card_info structure is set to 0.
	 Make sure the bit number is legal
	  A bit number of -1 (lacking) gives a mask of 0,
	  making it harmless
  Wait til post office is no longer busy
      while (((por = btread(ZR36057_POR)) & (ZR36057_POR_PO_PEN | ZR36057_POR_PO_TIME)) == ZR36057_POR_PO_PEN) {
 wait for something to happen 
 TODO add timeout 
 In LML33BUZ \GWS line is not connected, so it has always timeout set 
  JPEG Codec access
 Take the codec out of sleep 
    Set the registers for the size we have specified. Don't bother
    trying to understand this without the ZR36057 manual in front of
    you [AC].
  set geometry
 zr36057 
 horizontal 
	 (Ronald) Original comment:
	  "| 1 Doesn't have any effect, tested on both a DC10 and a DC10+"
	  this is false. It inverses chroma values on the LML33R10 (so Cr
	  suddenly is shown as Cb and reverse, really cool effect if you
	  want to see blue faces, not useful otherwise). So don't use |1.
	  However, the DC10 has '0' as h_start, but does need |1, so we
	  use a dirty check...
 Vertical 
 - 1; FIXME SnapShot times out with -1 in 768576 on the DC10 - LP
 scaler and pixel format 
	 RJ: I don't know, why the following has to be the opposite
	  of the corresponding ZR36060 setting, but only this way
reg |= ZR36057_VFESPFR_VCLK_POL; 
 RJ: Don't know if that is needed for NTSC also 
 NEEDED!!!!!!! Wolfgang
 5 tap filter 
 4 tap filter 
 3 tap filter 
 display configuration 
 || zr->revision < 1) 
 EnableDisable uncompressed memory grabbing of the 36057 
		 We only check SnapShot and not FrameGrab here.  SnapShot==1
		  means a capture is already in progress, but FrameGrab==1
		  doesn't necessary mean that.  It's more correct to say a 1
		  to 0 transition indicates a capture completed.  If a
		  capture is pending when capturing is tuned off, FrameGrab
		  will be stuck at 1 until capturing is turned back on.
 switch on VSync interrupts 
 Clear Interrupts
 SW
 enable SnapShot 
 Set zr36057 video front end  and enable video 
 switch off VSync interrupts 
 SW
 re-enable grabbing to screen if it was running 
   Set up the Buz-specific MJPEG part                                       
 re-initialize DMA ring stuff 
 mark as unavailable to zr36057 
 assert P_Reset, disable code transfer, deassert Active 
 MJPEG compression mode 
 RJ: The following is experimental - improves the output to screen 
if(zr->jpg_settings.VFIFO_FB) reg |= ZR36057_JMC_VFIFO_FB; 
 vertical 
 horizontal 
 field process parameters 
 Set proper VCLK Polarity, else colors will be wrong during playback 
btor(ZR36057_VFESPFR_VCLK_POL, ZR36057_VFESPFR);
 code base address 
 FIFO threshold (FIFO is 160. double words) 
 NOTE: decimal values here 
 deassert P_reset, disable code transfer, deassert Active 
 stop flushing the internal code buffer 
 enable code transfer 
 clear IRQs 
 enable the JPEG IRQs 
 \FRAME
 set the JPEG codec guest ID 
 Enable processing on the ZR36016 
 load the address of the GO register in the ZR36050 latch 
 assert Active 
 enable the Go generation 
 FRAME
		 In motion compress mode, the decoder output must be enabled, and
		  the video bus direction set to input.
 Take the JPEG codec and the VFE out of sleep 
 set JPEG appcom marker 
 Setup the JPEG codec 
 Setup the VFE 
 \P_Reset, ... Video param, FIFO
		 In motion decompression mode, the decoder output must be disabled, and
		  the video bus direction set to output.
 Take the JPEG codec and the VFE out of sleep 
 Setup the VFE 
 Setup the JPEG codec 
 \P_Reset, ... Video param, FIFO
 shut down processing 
 \Go_en
 FRAME
 CFlush
 \P_Reset,\CodTrnsEn,\Active
 when this is called the spinlock must be held 
 move frames from pending queue to DMA 
 fill 1 stat_com entry 
 fill 2 stat_com entries 
 when this is called the spinlock must be held 
 move frames from DMA queue to done queue 
	 In motion decompress we don't have a hardware frame counter,
 update sequence number with the help of the counter in stat_com 
 unused interrupts 
 Enable bus-mastering 
 Initialize the board 
 toggle JPEG codec sleep to sync PLL 
	
	  set individual interrupt enables (without GIRQ1)
	  but don't global enable until zoran_open()
 Clears interrupts
 assert P_Reset 
 set up GPIO direction - all output 
 set up GPIO pins and guest bus timing 
 SPDX-License-Identifier: GPL-2.0-or-later
  VIDEO MOTION CODECs internal API for video devices
  Interface for MJPEG (and maybe later MPEGWAVELETS) codec's
  bound to a master device.
  (c) 2002 Wolfgang Scherr <scherr@net4you.at>
 kernel config is here (procfs flag)
 ================================================= 
 function prototypes of the masterslave interface 
 ================================================= 
 attach only if the slave has at least the flags
 expected by the master
 find end
 find the end
 ===================== 
 hook in driver module 
 ===================== 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) Collabora, Ltd.
  Based on GSPCA and CODA drivers:
  Copyright (C) Jean-Francois Moine (http:moinejf.free.fr)
  Copyright (C) 2014 Philipp Zabel, Pengutronix
 Default tables from JPEG ITU-T.81
  (ISOIEC 10918-1) Annex K, tables K.1 and K.2
 Huffman tables are shared with CODA 
 For simplicity, we keep a pre-formatted JPEG header,
  and we'll use fixed offsets to change the width, height
  quantization tables, etc.
 SOI 
 DQT 
 SOF 
 DHT 
 DHT 
 DHT 
 DHT 
 SOS 
	
	  Non-linear scaling factor:
	  [5,50] -> [1000..100], [51,100] -> [98..0]
 SPDX-License-Identifier: GPL-2.0
  Hantro VPU codec driver
  Copyright (C) 2018 Rockchip Electronics Co., Ltd.
 	Jeffy Chen <jeffy.chen@rock-chips.com>
  Supported formats.
 Bump ACLK to max. possible freq. to improve performance. 
 Bump ACLKs to max. possible freq. to improve performance. 
 Bump ACLK to max. possible freq. to improve performance. 
  Supported codec ops.
  VPU variant.
 VDPU1VEPU1 
  Despite this variant has separate clocks for decoder and encoder,
  it's still required to enable all four of them for either decoding
  or encoding and we can't split it in separate g1h1 variants.
 VDPU2VEPU2 
 SPDX-License-Identifier: GPL-2.0
  Hantro VPU codec driver
  Copyright (C) 2018 Collabora, Ltd.
  Copyright 2018 Google LLC.
 	Tomasz Figa <tfiga@chromium.org>
  Based on s5p-mfc driver by Samsung Electronics Co., Ltd.
  Copyright (C) 2011 Samsung Electronics Co., Ltd.
	
	  If cancel_delayed_work returns false
	  the timeout expired. The watchdog is running,
	  and will take care of finishing the job.
 Kick the watchdog. 
	
	  Driver does mostly sequential access, so sacrifice TLB efficiency
	  for faster allocation. Also, no CPU access on the source queue,
	  so no kernel mapping needed.
	
	  When encoding, the CAPTURE queue doesn't need dma memory,
	  as the CPU needs to create the JPEG frames, from the
	  hardware-produced JPEG payload.
	 
	  For the DMA destination buffer, we use a bounce buffer.
 Only 4:0:0 and 4:2:0 are supported 
 Luma and chroma bit depth mismatch 
 Only 8-bit is supported 
 Luma and chroma bit depth mismatch 
 Only 8-bit is supported 
  V4L2 file operations.
	
	  We do not need any extra locking here, because we operate only
	  on local data here, except reading few fields from dev, which
	  do not change through device's lifetime (which is guaranteed by
	  reference on module from open()) and V4L2 internal objects (such
	  as vdev and ctx->fh), which have proper locking done in respective
	  helper functions used here.
	
	  No need for extra locking because this was the last reference
	  to this file.
 sentinel  }
 Create the three encoder entities with their pads 
 Connect the three entities 
 Create video interface 
 Connect the two DMA engines to the interface 
		
		  If the driver has a single clk, chances are there will be no
		  actual name in the DT bindings.
			
			  If the driver has a single IRQ, chances are there
			  will be no actual name in the DT bindings.
 SPDX-License-Identifier: GPL-2.0
  Hantro G1 post-processor support
  Copyright (C) 2019 Collabora, Ltd.
 Turn on pipeline mode. Must be done first. 
		
		  The buffers on this queue are meant as intermediate
		  buffers for the decoder, so no mapping is needed.
 SPDX-License-Identifier: GPL-2.0
  Hantro VPU codec driver
  Copyright (C) 2019 Pengutronix, Philipp Zabel <kernel@pengutronix.de>
 Assert 
 Release 
 Set values of the fuse registers 
  Supported formats.
  Supported codec ops.
  VPU variants.
 SPDX-License-Identifier: GPL-2.0
  Rockchip RK3288 VPU codec driver
  Copyright (c) 2014 Rockchip Electronics Co., Ltd.
 	Hertz Wong <hertz.wong@rock-chips.com>
 	Herman Chen <herman.chen@rock-chips.com>
  Copyright (C) 2014 Google, Inc.
 	Tomasz Figa <tfiga@chromium.org>
 Decoder control register 0. 
 Decoder control register 1. 
 Decoder control register 2. 
 Decoder control register 3. 
 Decoder control register 4. 
 Decoder control register 5. 
 Decoder control register 6. 
 Error concealment register. 
 Prediction filter tap register. 
 Reference picture buffer control register. 
 Reference picture buffer control register 2. 
	
	  Set up reference frame picture numbers.
	 
	  Each G1_REG_REF_PIC(x) register contains numbers of two
	  subsequential reference pictures.
	
	  Each G1_REG_BD_REF_PIC(x) register contains three entries
	  of each forward and backward picture list.
	
	  G1_REG_BD_P_REF_PIC register contains last entries (index 15)
	  of forward and backward reference picture lists and first 4 entries
	  of P forward picture list.
	
	  Each G1_REG_FWD_PIC(x) register contains six consecutive
	  entries of P forward picture list, starting from index 4.
 Set up addresses of DPB buffers. 
 Source (stream) buffer. 
 Destination (decoded frame) buffer. 
 Adjust dma addr to start at second line for bottom field 
 Higher profiles require DMV buffer appended to reference frames. 
 DMV buffer for monochrome start directly after Y-plane 
		
		  DMV buffer is split in two for field encoded frames,
		  adjust offset for bottom field
 Auxiliary buffer prepared in hantro_g1_h264_dec_prepare_table(). 
 Prepare the H264 decoder context. 
 Configure hardware registers. 
 Start decoding! 
 SPDX-License-Identifier: GPL-2.0
  Hantro VPU codec driver
  Copyright (C) 2018 Rockchip Electronics Co., Ltd.
 single plane formats we supported are all interlaced 
	
	  Quantization table registers must be written in contiguous blocks.
	  DO NOT collapse the below two "for" loops into one.
 Switch to JPEG encoder mode before writing registers 
 Make sure that all registers are written at this point. 
	
	  TODO: Rework the JPEG encoder to eliminate the need
	  for a bounce buffer.
 SPDX-License-Identifier: GPL-2.0
  Hantro VPU codec driver
  Copyright (C) 2018 Rockchip Electronics Co., Ltd.
 Source bitstream buffer 
 Destination frame buffer 
 Set forward ref frame (topbottom field) 
 Set backward ref frame (topbottom field) 
 Apply request controls if any 
 SPDX-License-Identifier: GPL-2.0
  Hantro VPU codec driver
  Copyright (C) 2018 Rockchip Electronics Co., Ltd.
  probs table with packed
 mv prob 
 coeff probs 
  filter taps taken to 7-bit precision,
  reference RFC6386#Page-16, filters[8][6]
 first probs 
unused 
 mv probs 
 is short 
 sign 
unused 
 coeff probs (header part) 
 coeff probs (footer part) 
unused 
 segment map table size calculation 
	
	  In context init the dma buffer for segment map must be allocated.
	  And the data in segment map buffer must be set to all zero.
	
	  Allocate probability table buffer,
	  total 1208 bytes, 4K page is far enough.
 SPDX-License-Identifier: GPL-2.0
  Hantro VDEC driver
  Copyright (C) 2021 Collabora Ltd, Emil Velikov <emil.velikov@collabora.com>
  Supported formats.
  Supported codec ops.
 SPDX-License-Identifier: GPL-2.0
  Hantro VPU codec driver
  Copyright (C) 2018 Rockchip Electronics Co., Ltd.
 SPDX-License-Identifier: GPL-2.0
  Hantro VPU codec driver
  Copyright (C) 2018 Rockchip Electronics Co., Ltd.
 	Jeffy Chen <jeffy.chen@rock-chips.com>
  Copyright (C) 2019 Pengutronix, Philipp Zabel <kernel@pengutronix.de>
  Copyright (C) 2021 Collabora Ltd, Emil Velikov <emil.velikov@collabora.com>
 SPDX-License-Identifier: GPL-2.0
  Rockchip RK3288 VPU codec driver
  Copyright (c) 2014 Rockchip Electronics Co., Ltd.
 	Hertz Wong <hertz.wong@rock-chips.com>
 	Herman Chen <herman.chen@rock-chips.com>
  Copyright (C) 2014 Google, Inc.
 	Tomasz Figa <tfiga@chromium.org>
 Size with u32 units. 
 Data structure describing auxiliary buffer format. 
  Constant CABAC table.
  From driversmediaplatformrk3288-vpurk3288_vpu_hw_h264d.c
  in https:chromium.googlesource.comchromiumosthird_partykernel,
  chromeos-3.14 branch.
 Only IntraInter Y lists 
		
		  Set up bit maps of valid and long term DPBs.
		  NOTE: The bits are reversed, i.e. MSb is DPB 0.
 Disable all entries by default. 
 Try to match new DPB entries with existing ones by their POCs. 
		
		  To cut off some comparisons, iterate only on target DPB
		  entries which are not used yet.
 For entries that could not be matched, use remaining free slots. 
		
		  Both arrays are of the same sizes, so there is no way
		  we can end up with no space in target array, unless
		  something is buggy.
		
		  If a DPB entry is unused or invalid, address of current
		  destination buffer is returned.
 Update the DPB with new refs. 
 Prepare data in memory. 
 Build the PB{0,1} ref lists. 
 SPDX-License-Identifier: GPL-2.0
  Hantro VPU codec driver
  Copyright (C) 2018 Collabora, Ltd.
  Copyright (C) 2018 Rockchip Electronics Co., Ltd.
 	Alpha Lin <Alpha.Lin@rock-chips.com>
 	Jeffy Chen <jeffy.chen@rock-chips.com>
  Copyright 2018 Google LLC.
 	Tomasz Figa <tfiga@chromium.org>
  Based on s5p-mfc driver by Samsung Electronics Co., Ltd.
  Copyright (C) 2010-2011 Samsung Electronics Co., Ltd.
 This only makes sense for coded formats 
	
	  When dealing with an encoder:
	   - on the capture side we want to filter out all MODE_NONE formats.
	   - on the output side we want to filter out all formats that are
	     not MODE_NONE.
	  When dealing with a decoder:
	   - on the capture side we want to filter out all formats that are
	     not MODE_NONE.
	   - on the output side we want to filter out all MODE_NONE formats.
	
	  Enumerate post-processed formats. As per the specification,
	  we enumerated these formats after natively decoded formats
	  as a hint for applications on what's the preferred fomat.
		
		  Widthheight on the CAPTURE end of a decoder are ignored and
		  replaced by the OUTPUT ones.
 Fill remaining fields 
		
		  For coded formats the application can specify
		  sizeimage. If the application passes a zero sizeimage,
		  let's default to the maximum frame size.
		
		  In order to support dynamic resolution change,
		  the decoder admits a resolution change, as long
		  as the pixelformat remains. Can't be done if streaming.
		
		  Since format change on the OUTPUT queue will reset
		  the CAPTURE queue, we can't allow doing so
		  when the CAPTURE queue has buffers allocated.
		
		  The encoder doesn't admit a format change if
		  there are OUTPUT buffers allocated.
	
	  Current raw format might have become invalid with newly
	  selected codec, so reset it to default just to be safe and
	  keep internal driver state sane. User is mandated to set
	  the raw format again after we return, so we don't need
	  anything smarter.
	  Note that hantro_reset_raw_fmt() also propagates size
	  changes to the raw format.
 Colorimetry information are always propagated. 
 Change not allowed if queue is busy. 
		
		  Since format change on the CAPTURE queue will reset
		  the OUTPUT queue, we can't allow doing so
		  when the OUTPUT queue has buffers allocated.
	
	  Current raw format might have become invalid with newly
	  selected codec, so reset it to default just to be safe and
	  keep internal driver state sane. User is mandated to set
	  the raw format again after we return, so we don't need
	  anything smarter.
	  Note that hantro_reset_raw_fmt() also propagates size
	  changes to the raw format.
 Colorimetry information are always propagated. 
	
	  Buffer's bytesused must be written by driver for CAPTURE buffers.
	  (for OUTPUT buffers, if userspace passes 0 bytesused, v4l2-core sets
	  it to buffer length).
	
	  The mem2mem framework calls v4l2_m2m_cancel_job before
	  .stop_streaming, so there isn't any job running and
	  it is safe to return all the buffers.
 SPDX-License-Identifier: GPL-2.0
  Hantro VPU codec driver
  Copyright (C) 2018 Rockchip Electronics Co., Ltd.
  JPEG encoder
  ------------
  The VPU JPEG encoder produces JPEG baseline sequential format.
  The quantization coefficients are 8-bit values, complying with
  the baseline specification. Therefore, it requires
  luma and chroma quantization tables. The hardware does entropy
  encoding using internal Huffman tables, as specified in the JPEG
  specification.
  In other words, only the luma and chroma quantization tables are
  required for the encoding operation.
  Quantization luma table values are written to registers
  VEPU_swreg_0-VEPU_swreg_15, and chroma table values to
  VEPU_swreg_16-VEPU_swreg_31. A special order is needed, neither
  zigzag, nor linear.
	
	  The pix fmt widthheight are already macroblock aligned
	  by .vidioc_s_fmt_vid_cap_mplane() callback
	
	  This register controls the input crop, as the offset
	  from the rightbottom within the last macroblock. The offset from the
	  right must be divided by 4 and so the crop must be aligned to 4 pixels
	  horizontally.
	
	  Quantization table registers must be written in contiguous blocks.
	  DO NOT collapse the below two "for" loops into one.
 Switch to JPEG encoder mode before writing registers 
 Make sure that all registers are written at this point. 
 Kick the watchdog and start encoding 
 SPDX-License-Identifier: GPL-2.0
  Hantro VPU HEVC codec driver
  Copyright (C) 2020 Safran Passenger Innovations LLC
 bytes per pixel row 
  BSD control data of current picture at tile border
  128 bits per 4x4 tile = 128(84) bytes per row
 bytes per pixel row 
 tile border coefficients of filter 
 bytes per pixel 
 Find the reference buffer in already know ones 
 Allocate a new reference buffer 
				
				  Allocate the space needed for the raw data +
				  motion vector data. Optimizations could be to
				  allocate raw data in non coherent memory and only
				  clear the motion vector data.
 Just tag buffer as unused, do not free them 
 Need to reallocate due to tiles passed via PPS 
	
	  Maximum number of tiles times width and height (2 bytes each),
	  rounding up to next 16 bytes boundary + one extra 16 byte
	  chunk (HW guys wanted to have this).
 SPDX-License-Identifier: GPL-2.0
  Hantro VP8 codec driver
  Copyright (C) 2019 Rockchip Electronics Co., Ltd.
 	ZhiChao Yu <zhichao.yu@rock-chips.com>
  Copyright (C) 2019 Google, Inc.
 	Tomasz Figa <tfiga@chromium.org>
 DCT partition base address regs 
 Loop filter level regs 
 Macroblock loop filter level adjustment regs 
 Reference frame adjustment regs 
 Quantizer 
 Quantizer delta regs 
 DCT partition start bits regs 
 Precision filter tap regs 
  Set loop filters
  Set quantization parameters
  set control partition and DCT partition regs
  VP8 frame stream data layout:
 	                     first_part_size          parttion_sizes[0]
                               ^                     ^
  src_dma                      |                     |
  ^                   +--------+------+        +-----+-----+
  |                   | control part  |        |           |
  +--------+----------------+------------------+-----------+-----+-----------+
  | tag 3B | extra 7B | hdr | mb_data | DCT sz | DCT part0 | ... | DCT partn |
  +--------+-----------------------------------+-----------+-----+-----------+
                            |         |        |                             |
                            v         +----+---+                             v
                            mb_start       |                       src_dma_end
                                           v
                                        DCT size part
                                       (num_dct-1)3B
  Note:
    1. only key-frames have extra 7-bytes
    2. all offsets are base on src_dma
    3. number of DCT parts is 1, 2, 4 or 8
    4. the addresses set to the VPU must be 64-bits aligned
	
	  Calculate control partition mb data info
	  @first_part_header_bits:	bits offset of mb data from first
	 				part start pos
	  @mb_offset_bits:		bits offset of mb data from src_dma
	 				base addr
	  @mb_offset_byte:		bytes offset of mb data from src_dma
	 				base addr
	  @mb_start_bits:		bits offset of mb data from mb data
	 				64bits alignment addr
 Macroblock data aligned base addr 
 Macroblock data start bits 
 Macroblock aligned data length 
	
	  Calculate DCT partition info
	  @dct_size_part_size: Containing sizes of DCT part, every DCT part
	 			has 3 bytes to store its size, except the last
	 			DCT part
	  @dct_part_offset:	bytes offset of DCT parts from src_dma base addr
	  @dct_part_total_len: total size of all DCT parts
 Number of DCT partitions 
 DCT partition length 
 DCT partitions base address 
  prediction filter taps
  normal 6-tap filters
 Tap filter not used. 
 Set probability table buffer address 
 Set segment map address 
 Reset segment_map buffer in keyframe 
 Frame dimensions 
 Boolean decoder 
 SPDX-License-Identifier: GPL-2.0
  Hantro VPU codec driver
  Copyright (c) 2014 Rockchip Electronics Co., Ltd.
 	Hertz Wong <hertz.wong@rock-chips.com>
 	Herman Chen <herman.chen@rock-chips.com>
  Copyright (C) 2014 Google, Inc.
 	Tomasz Figa <tfiga@chromium.org>
 Set up addresses of DPB buffers. 
 Source (stream) buffer. 
 Destination (decoded frame) buffer. 
 Adjust dma addr to start at second line for bottom field 
 Higher profiles require DMV buffer appended to reference frames. 
 DMV buffer for monochrome start directly after Y-plane 
		
		  DMV buffer is split in two for field encoded frames,
		  adjust offset for bottom field
 Auxiliary buffer prepared in hantro_g1_h264_dec_prepare_table(). 
 Prepare the H264 decoder context. 
 Start decoding! 
 SPDX-License-Identifier: GPL-2.0
  Hantro VPU codec driver
  Copyright (C) 2018 Rockchip Electronics Co., Ltd.
 Source bitstream buffer 
 Destination frame buffer 
 Set forward ref frame (topbottom field) 
 Set backward ref frame (topbottom field) 
 Kick the watchdog and start decoding 
 SPDX-License-Identifier: GPL-2.0
  Hantro VPU HEVC codec driver
  Copyright (C) 2020 Safran Passenger Innovations LLC
 write width + height for each tile in pic 
 last column 
 uniform spacing 
 There's one tile, with dimensions equal to pic size. 
 List 0 contains: short term before, short term after and long term 
 Fill the list, copying over and over 
	
	  Set max_ref_frames to non-zero to avoid HW hang when decoding
	  badly marked I-frames.
	
	  Write POC count diff from current pic. For frame decoding only compute
	  pic_order_cnt[0] and ignore pic_order_cnt[1] used in field-coding.
		
		  After the references, fill one entry pointing to itself,
		  i.e. difference is zero.
 Fill the rest with the current picture 
 We will only keep the references picture that are still used 
 Set up addresses of DPB buffers 
 Source (stream) buffer. 
 Destination (decoded frame) buffer. 
 128-bit boundary 
 write scaling lists column by column 
 Make sure the VPU is idle 
 Prepare HEVC decoder context. 
 Configure hardware registers. 
 set reference pictures 
 Don't disable output 
 Don't compress buffers 
 use NV12 as output format 
 Bus width and max burst 
 Swap 
 Start decoding! 
 SPDX-License-Identifier: GPL-2.0
  Rockchip VPU codec vp8 decode driver
  Copyright (C) 2014 Rockchip Electronics Co., Ltd.
 	ZhiChao Yu <zhichao.yu@rock-chips.com>
  Copyright (C) 2014 Google LLC.
       Tomasz Figa <tfiga@chromium.org>
  Copyright (C) 2015 Rockchip Electronics Co., Ltd.
       Alpha Lin <alpha.lin@rock-chips.com>
	
	  Calculate control partition mb data info
	  @first_part_header_bits:	bits offset of mb data from first
	 				part start pos
	  @mb_offset_bits:		bits offset of mb data from src_dma
	 				base addr
	  @mb_offset_byte:		bytes offset of mb data from src_dma
	 				base addr
	  @mb_start_bits:		bits offset of mb data from mb data
	 				64bits alignment addr
 Macroblock data aligned base addr 
	
	  Calculate DCT partition info
	  @dct_size_part_size: Containing sizes of DCT part, every DCT part
	 			has 3 bytes to store its size, except the last
	 			DCT part
	  @dct_part_offset:	bytes offset of DCT parts from src_dma base addr
	  @dct_part_total_len: total size of all DCT parts
 Number of DCT partitions 
 DCT partition length 
 DCT partitions base address 
  prediction filter taps
  normal 6-tap filters
 Tap filter not used. 
 Set probability table buffer address 
 Set segment map address 
 set output frame buffer address 
 Reset segment_map buffer in keyframe 
	
	  Extensive testing shows that the hardware does not properly
	  clear the internal state from previous a decoding run. This
	  causes corruption in decoded frames for multi-instance use cases.
	  A soft reset before programming the registers has been found
	  to resolve those problems.
 Frame dimensions 
 Boolean decoder 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2020 NVIDIA CORPORATION.  All rights reserved.
  This source file contains Tegra210 supported video formats,
  VI and CSI SoC specific data, operations and registers accessors.
 Tegra210 VI registers 
 Tegra210 VI CSI registers 
 Tegra210 CSI Pixel Parser registers: Starts from 0x838, offset 0x0 
 Tegra210 CSI PHY registers 
 CSI_PHY_CIL_COMMAND_0 offset 0x0d0 from TEGRA_CSI_PIXEL_PARSER_0_BASE 
 Tegra210 VI registers accessors 
 Tegra210 VI_CSI registers accessors 
  Tegra210 VI channel capture operations
	
	  VI Pixel transformation unit converts source pixels data format
	  into selected destination pixel format and aligns properly while
	  interfacing with memory packer.
	  This pixel transformation should be enabled for YUV and RGB
	  formats and should be bypassed for RAW formats as RAW formats
	  only support direct to memory.
	
	  For x8 source streaming, the source image is split onto two x4 ports
	  with left half to first x4 port and right half to second x4 port.
	  So, use split width and corresponding word count for each x4 port.
 disable clock gating to enable continuous clock 
	
	  Soft reset memory client interface, pixel format logic, sensor
	  control logic, and a shadow copy logic to bring VI to clean state.
 enable back VI clock gating 
	
	  Recover VI and CSI hardware blocks in case of missing frame start
	  events due to source not streaming or noisy csi inputs from the
	  external source or many outstanding frame start or MW_ACK_DONE
	  events which can cause CSI and VI hardware hang.
	  This helps to have a clean capture for next frame.
 recover VI by issuing software reset and re-setup for capture 
 recover CSI block 
 program buffer address by using surface 0 
	
	  Program surface 1 for UV plane with offset sizeimage from Y plane.
		
		  Align buffers side-by-side for all consecutive x4 ports
		  in gang ports using bytes per line based on source split
		  width.
		
		  Tegra VI block interacts with host1x syncpt to synchronize
		  programmed condition and hardware operation for capture.
		  Frame start and Memory write acknowledge syncpts has their
		  own FIFO of depth 2.
		 
		  Syncpoint trigger conditions set through VI_INCR_SYNCPT
		  register are added to HW syncpt FIFO and when HW triggers,
		  syncpt condition is removed from the FIFO and counter at
		  syncpoint index will be incremented by the hardware and
		  software can wait for counter to reach threshold to
		  synchronize capturing frame with hardware capture events.
 increase channel syncpoint threshold for FRAME_START 
 Program FRAME_START trigger condition syncpt request 
 increase channel syncpoint threshold for MW_ACK_DONE 
 Program MW_ACK_DONE trigger condition syncpt request 
 enable single shot capture after all ganged ports are ready 
		
		  Wait for syncpt counter to reach frame start event threshold
 increment syncpoint counter for timedout events 
 clear errors and recover 
 move buffer to capture done queue 
 wait up kthread for capture done 
		
		  Wait for syncpt counter to reach MW_ACK_DONE event threshold
 increment syncpoint counter for timedout event 
		
		  Source is not streaming if error is non-zero.
		  So, do not dequeue buffers on error and let the thread sleep
		  till kthread stop signal is received.
 dequeue the buffer and start capture 
 dequeue buffers and finish capture 
 clear syncpt errors 
	
	  Sync point FIFO full stalls the host interface.
	  Setting NO_STALL will drop INCR_SYNCPT methods when fifos are
	  full and the corresponding condition bits in INCR_SYNCPT_ERROR
	  register will be set.
	  This allows SW to process error recovery.
 start the pipeline 
 clear csi errors and do capture setup for all ports in gang mode 
 start kthreads to capture data to buffer and return them 
  Tegra210 VI Pixel memory format enum.
  These format enum value gets programmed into corresponding Tegra VI
  channel register bits.
 Tegra210 supported video formats 
 RAW 8 
 RAW 10 
 RAW 12 
 RGB888 
 YUV422 
 Tegra210 VI operations 
 Tegra210 VI SoC data 
 Tegra210 CSI PHY registers accessors 
 Tegra210 CSI Pixel parser registers accessors 
 Tegra210 CSI CIL AB port registers accessors 
 Tegra210 CSI Test pattern generator registers accessor 
  Tegra210 CSI operations
	
	  Recover CSI hardware in case of capture errors by issuing
	  software reset to CSICIL sensor, pixel parser, and clear errors
	  to have clean capture on  next streaming.
 reset CSI CIL sensor 
		
		  SW_STATUS_RESET resets all status bits of PPA, PPB, CILA,
		  CILB status registers and debug counters.
		  So, SW_STATUS_RESET can be used only when CSI brick is in
		  x4 mode.
 sleep for 20 clock cycles to drain the FIFO 
 reset CSICIL sensor 
 clear the errors 
 clean up status 
 CIL PHY registers setup 
	
	  The CSI unit provides for connection of up to six cameras in
	  the system and is organized as three identical instances of
	  two MIPI support blocks, each with a separate 4-lane
	  interface that can be configured as a single camera with 4
	  lanes or as a dual camera with 2 lanes available for each
	  camera.
 CSI pixel parser registers setup 
 TPG setup 
  Tegra210 CSI TPG frame rate table with horizontal and vertical
  blanking intervals for corresponding format and resolution.
  Blanking intervals are tuned values from design team for max TPG
  clock rate.
 Tegra210 CSI operations 
 Tegra210 CSI SoC data 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2020 NVIDIA CORPORATION.  All rights reserved.
 cleanup channels here as all video device nodes are released 
		
		  Both vi and csi channels are available now.
		  Register v4l2 nodes and create media links for TPG.
 vi exit ops does not clean channels, so clean them here 
 This calls v4l2_dev release callback on last reference 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2020 NVIDIA CORPORATION.  All rights reserved.
  videobuf2 queue operations
 put buffer into the capture queue 
 wait up kthread for capture 
	
	  Tegra CSI receiver can detect the first LP to HS transition.
	  So, start the CSI stream-on prior to sensor stream-on and
	  vice-versa for stream-off.
	
	  TRM has incorrectly documented to wait for done status from
	  calibration logic after CSI interface power on.
	  As per the design, calibration results are latched and applied
	  to the pads only when the link is in LP11 state which will happen
	  during the sensor stream-on.
	  CSI subdev stream-on triggers start of MIPI pads calibration.
	  Wait for calibration to finish here after sensor subdev stream-on.
	
	  Stream-off subdevices in reverse order to stream-on.
	  Remote source subdev in TPG mode is same as CSI subdev.
  V4L2 ioctl operations
	
	  The transfer alignment requirements are expressed in bytes.
	  Clamp the requested width and height to the limits.
	 Clamp the requested bytes per line value. If the maximum bytes per
	  line value is zero, the module doesn't support user configurable
	  line sizes. Override the requested value with the minimum in that
	  case.
	
	  Retrieve the format information and if requested format isn't
	  supported, keep the current format.
	
	  Attempt to obtain the format size from subdev.
	  If not available, try to get crop boundary from subdev.
 get supported format by try_fmt 
	
	  Initialize channel format to the sub-device active format if there
	  is corresponding match in the Tegra supported video formats.
	
	  Try the get selection operation and fallback to get format if not
	  implemented.
		
		  Subdev active format resolution may have changed during
		  set selection operation. So, update channel format to
		  the sub-device active format.
  V4L2 file operations
  V4L2 control operations
 pattern change takes effect on next stream 
 add test pattern control handler to v4l2 device 
 custom control 
 setup the controls 
 VI only support 2 formats in TPG mode 
	
	  Set the bitmap bits based on all the matched formats between the
	  available media bus formats of sub-device and the pre-defined Tegra
	  supported video formats.
 look for other formats with same mbus code 
	
	  Set the bitmap bit corresponding to default tegra video format if
	  there are no matched formats.
 initialize channel format to the sub-device active format 
 initialize the video format 
 initialize the media entity 
 initialize the video_device 
	
	  Do not use devm_kzalloc as memory is freed immediately
	  when device instance is unbound but application might still
	  be holding the device node open. Channel memory allocated
	  with kzalloc is freed during video device release callback.
	
	  For data lanes more than maximum csi lanes per brick, multiple of
	  x4 ports are used simultaneously for capture.
  Graph Management
		 Remote node is vi node. So use channel video entity and pad
		  as remotesink.
		
		  Skip sink ports, they will be processed from the other end
		  of the link.
 find the remote entity from notifier list 
	
	  Video device node should be created at the end of all the device
	  related initializationsetup.
	  Current video_register_device() does both initialize and register
	  video device in same API.
	 
	  TODO: Update v4l2-dev driver to split initialize and register into
	  separate APIs and then update Tegra video driver to do video device
	  initialize followed by all video device related setup and then
	  register the video device.
 create links between the entities 
	
	  Locate the entity corresponding to the bound subdev and store the
	  subdev pointer.
 parse all the remote entities and put them into the list 
 skip entities that are already processed 
	
	  Walk the links to parse the full graph. Each channel will have
	  one endpoint of the composite node. Start by parsing the
	  composite node and parse the remote entities in turn.
	  Each channel will register v4l2 async notifier to make the graph
	  independent between the channels so we can the current channel
	  in case of something wrong during graph parsing and continue with
	  next channels.
	
	  Do not cleanup the channels here as application might still be
	  holding video device nodes. Channels cleanup will happen during
	  v4l2_device release callback which gets called after all video
	  device nodes are released.
 initialize host1x interface 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2020 NVIDIA CORPORATION.  All rights reserved.
  CSI is a separate subdevice which has 6 source pads to generate
  test pattern. CSI subdevice pad ops are used only for TPG and
  allows below TPG formats.
  V4L2 Subdevice Pad Operations
 one framerate per format and resolution 
 update blanking intervals from frame rate table and format 
  V4L2 Subdevice Video Operations
	
	  CLK Settle time is the interval during which HS receiver should
	  ignore any clock lane HS transitions, starting from the beginning
	  of T-CLK-PREPARE.
	  Per DPHY specification, T-CLK-SETTLE should be between 95ns ~ 300ns
	 
	  95ns < (clk-settle-programmed + 7)  lp clk period < 300ns
	  midpoint = 197.5 ns
	
	  THS Settle time is the interval during which HS receiver should
	  ignore any data lane HS transitions, starting from the beginning
	  of THS-PREPARE.
	 
	  Per DPHY specification, T-HS-SETTLE should be between 85ns + 6UI
	  and 145ns+10UI.
	  85ns + 6UI < (Ths-settle-prog + 5)  lp_clk_period < 145ns + 10UI
	  midpoint = 115ns + 8UI
		
		  CSI MIPI pads PULLUP, PULLDN and TERM impedances need to
		  be calibrated after power on.
		  So, trigger the calibration start here and results will
		  be latched and applied to the pads when link is in LP11
		  state during start of sensor streaming.
  V4L2 Subdevice Operations
	
	  Each CSI brick has maximum of 4 lanes.
	  For lanes more than 4, use multiple of immediate CSI bricks as gang.
 allocate CSI channel for each CSI x2 ports 
		
		  Each CSI brick has maximum 4 data lanes.
		  For lanes more than 4, validate lanes to be multiple of 4
		  so multiple of consecutive CSI bricks can be ganged up for
		  streaming.
 initialize the default format 
 initialize V4L2 subdevice and media entity 
 initialize media entity pads 
 stop streaming during error recovery 
 initialize host1x interface 
 SPDX-License-Identifier: GPL-2.0
  Support for OmniVision OV2722 1080p HD camera sensor.
  Copyright (c) 2013 Intel Corporation. All Rights Reserved.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 i2c readwrite stuff 
 high byte goes out first 
 high byte comes first 
 16-bit address + data 
 high byte goes out first 
 OV2722_16BIT 
  ov2722_write_reg_array - Initializes a list of OV2722 registers
  @client: i2c driver client structure
  @reglist: list of registers to be written
  This function initializes a list of registers. When consecutive addresses
  are found in a row on the list, this function creates a buffer and sends
  consecutive data in a single i2c_transfer().
  __ov2722_flush_reg_array, __ov2722_buf_reg_array() and
  __ov2722_write_reg_is_consecutive() are internal functions to
  ov2722_write_reg_array_fast() and should be not used anywhere else.
 16-bit address + data 
 When first item is added, we need to store its starting address 
	
	  Buffer cannot guarantee free space for u32? Better flush it to avoid
	  possible lack of memory for next item.
			
			  If next address is not consecutive, data needs to be
			  flushed before proceed.
const f number for imx
 pixel clock calculattion 
 get integration time 
 get the cropping and output resolution to ISP for this mode. 
 clear VTS_DIFF on manual mode 
 set exposure 
 set analog gain 
 set digital gain 
 we should not accept the invalid value below. 
 This returns the exposure time being used. This should only be used
  for filling in EXIF data, not for actual image processing.
 get exposure 
 To Hz 
 restore settings 
	 Note: the GPIO order is asymmetric: always RESET#
	  before PWDN# when turning it on or off.
	
	 ov2722 PWDN# active high when pull down,opposite to the convention
 power control 
 according to DS, at least 5ms is needed between DOVDD and PWDN 
 gpio ctrl 
 flis clock control 
 according to DS, 20ms is needed between PWDN and i2c access 
 gpio ctrl 
 power control 
  distance - calculate the distance
  @res: resolution
  @w: width
  @h: height
  Get the gap between resolution and wh.
  res->widthheight smaller than wh wouldn't be considered.
  Returns the value of gap or -1 if fail.
 Return the nearest higher resolution index 
 TODO: remove it. 
 return the largest resolution 
	 power off the module, then power on it in future
	  as first power on by board may not fulfill the
	  power on sequqence needed by the module
 config & detect sensor 
 turn off sensor, after probed 
 SPDX-License-Identifier: GPL-2.0
  Support for GalaxyCore GC0310 VGA camera sensor.
  Copyright (c) 2013 Intel Corporation. All Rights Reserved.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 i2c readwrite stuff 
 high byte goes out first 
 high byte comes first 
 8-bit address + data 
 high byte goes out first 
  gc0310_write_reg_array - Initializes a list of GC0310 registers
  @client: i2c driver client structure
  @reglist: list of registers to be written
  This function initializes a list of registers. When consecutive addresses
  are found in a row on the list, this function creates a buffer and sends
  consecutive data in a single i2c_transfer().
  __gc0310_flush_reg_array, __gc0310_buf_reg_array() and
  __gc0310_write_reg_is_consecutive() are internal functions to
  gc0310_write_reg_array_fast() and should be not used anywhere else.
 8-bit address + data 
 When first item is added, we need to store its starting address 
	
	  Buffer cannot guarantee free space for u32? Better flush it to avoid
	  possible lack of memory for next item.
			
			  If next address is not consecutive, data needs to be
			  flushed before proceed.
const f number for imx
 pixel clock calculattion 
 16.8MHz
 get integration time 
 get the cropping and output resolution to ISP for this mode. 
 Getting crop_horizontal_start 
 Getting crop_vertical_start 
 Getting output_width 
 Getting output_height 
 Getting line_length_pck 
 Getting frame_length_lines 
 sqrt(2) 
 2  sqrt(2) 
 set analog gain 
 set digital gain 
 set exposure 
 we should not accept the invalid value below. 
 TO DO 
 TO DO 
 This returns the exposure time being used. This should only be used
  for filling in EXIF data, not for actual image processing.
 get exposure 
 set initial registers 
 restore settings 
		 The upstream module driver (written to Crystal
		  Cove) had this logic to pulse the rails low first.
		  This appears to break things on the MRD7 with the
		  X-Powers PMIC...
		 
		      ret = dev->platform_data->v1p8_ctrl(sd, 0);
		      ret |= dev->platform_data->v2p8_ctrl(sd, 0);
		      mdelay(50);
 GPIO0 == "reset" (active low), GPIO1 == "power down" 
 Pulse reset, then release power down 
 power control 
 flis clock control 
 gpio ctrl 
 gpio ctrl 
 power control 
  distance - calculate the distance
  @res: resolution
  @w: width
  @h: height
  Get the gap between resolution and wh.
  res->widthheight smaller than wh wouldn't be considered.
  Returns the value of gap or -1 if fail.
 Return the nearest higher resolution index 
 TODO: remove it. 
 return the largest resolution 
 enable per frame MIPI and sensor ctrl reset  
	 power off the module, then power on it in future
	  as first power on by board may not fulfill the
	  power on sequqence needed by the module
 config & detect sensor 
 turn off sensor, after probed 
 Use same lock for controls as for everything else. 
 SPDX-License-Identifier: GPL-2.0
  Support for GalaxyCore GC2235 2M camera sensor.
  Copyright (c) 2014 Intel Corporation. All Rights Reserved.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 i2c readwrite stuff 
 high byte goes out first 
 high byte comes first 
 16-bit address + data 
 high byte goes out first 
 8-bit address + data 
 When first item is added, we need to store its starting address 
	
	  Buffer cannot guarantee free space for u32? Better flush it to avoid
	  possible lack of memory for next item.
			
			  If next address is not consecutive, data needs to be
			  flushed before proceed.
 const f number for imx 
 pixel clock calculattion 
 get integration time 
 get the cropping and output resolution to ISP for this mode. 
 we should not accept the invalid value below. 
  This returns the exposure time being used. This should only be used
  for filling in EXIF data, not for actual image processing.
 get exposure 
 restore settings 
 power control 
 according to DS, at least 5ms is needed between DOVDD and PWDN 
 gpio ctrl 
 gpio ctrl 
 power control 
  distance - calculate the distance
  @res: resolution
  @w: width
  @h: height
  Get the gap between resolution and wh.
  res->widthheight smaller than wh wouldn't be considered.
  Returns the value of gap or -1 if fail.
 Return the nearest higher resolution index 
		
		  force gc2235 to do a reset in res change, otherwise it
		  can not output normal after switching res. and it is not
		  necessary for first time run up after power on, for the sack
		  of performance
 return the largest resolution 
	
	  power off the module, then power on it in future
	  as first power on by board may not fulfill the
	  power on sequqence needed by the module
 config & detect sensor 
 turn off sensor, after probed 
 Use same lock for controls as for everything else. 
 SPDX-License-Identifier: GPL-2.0
  Support for mt9m114 Camera Sensor.
  Copyright (c) 2010 Intel Corporation. All Rights Reserved.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  TODO: use debug parameter to actually define when debug messages should
  be printed.
 high byte goes out first 
 high byte comes first 
 high byte goes out first 
 MISENSOR_32BIT 
	
	  HACK: Need some delay here for Rev 2 sensors otherwise some
	  registers do not seem to load correctly.
  misensor_rmw_reg - ReadModifyWrite a value to a register in the sensor
  device
  @client: i2c driver client structure
  @data_length: 81632-bits length
  @reg: register address
  @mask: masked out bits
  @set: bits set
  Readmodifywrite a value to a register in the  sensor device.
  Returns zero if successful, or non-zero otherwise.
 Exit when no mask 
 @mask must not exceed data length 
 Wrong @data_length 
	
	  Perform the OR function if the @set exists.
	  Shift @set value to target bit location. @set should set only
	  bits included in @mask.
	 
	  REVISIT: This function expects @set to be non-shifted. Its shift
	  value is then defined to be equal to mask's LSB position.
	  How about to inform values in their right offset position and avoid
	  this unneeded shift operation?
	
	  REVISIT: Previously we had a delay after writing data to sensor.
	  But it was removed as our tests have shown it is not necessary
	  anymore.
 Insufficient buffer? Let's flush and get more free space. 
 When first item is added, we need to store its starting address 
  mt9m114_write_reg_array - Initializes a list of mt9m114 registers
  @client: i2c driver client structure
  @reglist: list of registers to be written
  @poll: completion polling requirement
  This function initializes a list of registers. When consecutive addresses
  are found in a row on the list, this function creates a buffer and sends
  consecutive data in a single i2c_transfer().
  __mt9m114_flush_reg_array, __mt9m114_buf_reg_array() and
  __mt9m114_write_reg_is_consecutive() are internal functions to
  mt9m114_write_reg_array() and should be not used anywhere else.
			
			  If next address is not consecutive, data needs to be
			  flushed before proceed.
	
	  Note: current modules wire only one GPIO signal (RESET#),
	  but the schematic wires up two to the connector.  BIOS
	  versions have been unfortunately inconsistent with which
	  ACPI index RESET# is on, so hit both
 power control 
 flis clock control 
 gpio ctrl 
	
	  according to DS, 44ms is needed between power up and first i2c
	  commend
 gpio ctrl 
 power control 
 according to DS, 20ms is needed after power down 
  distance - calculate the distance
  @res: resolution
  @w: width
  @h: height
  Get the gap between resolution and wh.
  res->widthheight smaller than wh wouldn't be considered.
  Returns the value of gap or -1 if fail.
 Return the nearest higher resolution index 
		
		  nearest_resolution_index() doesn't return smaller
		   resolutions. If it fails, it means the requested
		   resolution is higher than wecan support. Fallback
		   to highest possible resolution in this case.
 No mode found 
 get integration time 
 get the cropping and output resolution to ISP for this mode. 
 Sanity check 
 set sensor read_mode to Normal 
 Switch to different size 
 Set for context A 
			
			  Context B is used for resolutions larger than 640x480
			  Using YUV for Context B.
 set for context B 
		
		  Marked current sensor res as being "used"
		 
		  REVISIT: We don't need to use an "used" field on each mode
		  list entry to know which mode is selected. If this
		  information is really necessary, how about to use a single
		  variable on sensor dev struct?
	
	  mt9m114 - we don't poll for context switch
	  because it does not happen with streaming disabled.
 TODO: Update to SOC functions, remove exposure and gain 
 const f number for mt9m114 
 Horizontal flip the image. 
 ExposureTime.FrameLengthLines; 
	
	  fine_integration = ExposureTime.FineIntegrationTime;
	  frame_len_lines = ExposureTime.FrameLengthLines;
Save the first exposure values while stream is off
 digital_gain = 0x400  (((u16) digital_gain) >> 8) +		
 ((unsigned int)(0x400  (((u16) digital_gain) & 0xFF)) >>8); 
 set frame length 
 set coarse integration 
	
	  3A provide real exposure time.
	  should not translate to any value here.
	
	  set analogdigital gain
	switch(analog_gain)
	{
	case 0:
	  analog_gain_to_write = 0x0;
	  break;
	case 1:
	  analog_gain_to_write = 0x20;
	  break;
	case 2:
	  analog_gain_to_write = 0x60;
	  break;
	case 4:
	  analog_gain_to_write = 0xA0;
	  break;
	case 8:
	  analog_gain_to_write = 0xE0;
	  break;
	default:
	  analog_gain_to_write = 0x20;
	  break;
	}
	
	  analog_gain_to_write = (u16)((digital_gain << 12)
	 				| analog_gain_to_write);
  This returns the exposure time being used. This should only be used
  for filling in EXIF data, not for actual image processing.
 the fine integration time is currently not calculated 
  This function will return the sensor supported max exposure zone number.
  the sensor which supports max exposure zone number is 1.
  set exposure metering, averagecenter_weightedspotmatrix.
  This function is for touch exposure feature.
	
	  EV value only support -2 to 2
	  0: 0x37, 1:0x47, 2:0x57, -1:0x27, -2:0x17
  Fake interface
  mt9m114 now can not support 3a_lock
 config & detect sensor 
 Horizontal flip the image. 
 set for direct mode 
 enable H flip ctx A 
 ctx B 
 disable H flip ctx A 
 ctx B 
 Vertically flip the image 
 set for direct mode 
 enable H flip - ctx A 
 ctx B 
 disable H flip - ctx A 
 ctx B 
 REVISIT: Do we need pad operations? 
 Setup sensor configuration structure 
 Coverity CID 298095 - return on error 
 TODO add format code here 
 Use same lock for controls as for everything else. 
 REVISIT: Do we need media controller? 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2013 Intel Corporation. All Rights Reserved.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 Tagged binary data container structure definitions. 
!< Tag identifier, also checks endianness 
!< Container size including this header 
!< Version, format 0xYYMMDDVV 
!< Revision, format 0xYYMMDDVV 
!< Configuration flag bits set 
!< Global checksum, header included 
!< Size of record including header 
!< tbd_format_t enumeration values used 
!< Packing method; 0 = no packing 
!< tbd_class_t enumeration values used 
	
	  The configuration data contains any number of sequences where
	  the first byte (that is, uint8_t) that marks the number of bytes
	  in the sequence to follow, is indeed followed by the indicated
	  number of bytes of actual data to be written to sensor.
	  By convention, the first two bytes of actual data should be
	  understood as an address in the sensor address space (hibyte
	  followed by lobyte) where the remaining data in the sequence
	  will be written.
 How many bytes 
 Where the bytes are located 
 Accessing data beyond bounds is not tolerated 
 There may be any number of datasets present 
 In below, four variables are read from buffer 
 All data should be located within given buffer 
 We have a new valid dataset 
 See whether there is MSR data 
 If yes, update the reg info 
 Check that we have drvb block. 
 Check the size 
 Check that class id mathes tbd's drv id. 
 Size 0 shall not be treated as an error 
 SPDX-License-Identifier: GPL-2.0
  LED flash driver for LM3554
  Copyright (c) 2010-2012 Intel Corporation. All Rights Reserved.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 Registers 
 Return negative errno else zero on success 
 Return negative errno else a data byte received from the device. 
 -----------------------------------------------------------------------------
  Hardware configuration
 -----------------------------------------------------------------------------
  Hardware trigger
	
	  An abnormal high flash current is observed when strobe off the
	  flash. Workaround here is firstly set flash current to lower level,
	  wait a short moment, and then strobe off the flash.
 Flash off 
 set current to 70mA and wait a while 
 Flash on 
	
	  If timer is killed before run, flash is not strobe off,
	  so must strobe off here
 Restore flash current settings 
 Strobe on Flash 
 -----------------------------------------------------------------------------
  V4L2 controls
 NOTE: reading register clear fault status 
	
	  Accordingly to datasheet we read back '1' in bit 6.
	  Clear it first.
	
	  Do not take TX1TX2 signal as an error
	  because MSIC will not turn off flash, but turn to
	  torch mode according to gsm modem signal by hardware.
 -----------------------------------------------------------------------------
  V4L2 subdev core operations
 Put device into known state. 
 clear the flags register 
 read status 
initialize flash driver
		 Setup default values. This makes sure that the chip
		  is in a known state.
 Power up the flash driver and reset it 
 -----------------------------------------------------------------------------
   I2C driver
 CONFIG_PM 
	 Set to TX2 mode, then ENVMTX2 pin is a power amplifier sync input:
	  ENVMTX pin asserted, flash forced into torch;
	  ENVMTX pin desserted, flash set back;
 set peak current limit to be 1000mA 
 SPDX-License-Identifier: GPL-2.0
  Support for OmniVision OV2680 1080p HD camera sensor.
  Copyright (c) 2013 Intel Corporation. All Rights Reserved.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 i2c readwrite stuff 
 const f number for ov2680 
 pixel clock 
 get integration time 
 get the cropping and output resolution to ISP for this mode. 
 group hold 
 Increase the VTS to match exposure + MARGIN 
 set exposure 
 Lower four bit should be 0
 Analog gain 
 Digital gain 
 End group 
 Delay launch group 
 we should not accept the invalid value below 
 EXPOSURE CONTROL DISABLED FOR INITIAL CHECKIN, TUNING DOESN'T WORK
  This returns the exposure time being used. This should only be used
  for filling in EXIF data, not for actual image processing.
 get exposure 
 restore settings 
	
	  The OV2680 documents only one GPIO input (#XSHUTDN), but
	  existing integrations often wire two (resetpower_down)
	  because that is the way other sensors work.  There is no
	  way to tell how it is wired internally, so existing
	  firmwares expose both and we drive them symmetrically.
 Ignore return from second gpio, it may not be there 
 power control 
 according to DS, at least 5ms is needed between DOVDD and PWDN 
 gpio ctrl 
 flis clock control 
 according to DS, 20ms is needed between PWDN and i2c access 
 gpio ctrl 
 power control 
  distance - calculate the distance
  @res: resolution
  @w: width
  @h: height
  Get the gap between resolution and wh.
  res->widthheight smaller than wh wouldn't be considered.
  Returns the value of gap or -1 if fail.
 Return the nearest higher resolution index 
 return the largest resolution 
 IS IT NEEDED?
	
	  recall flip functions to avoid flip registers
	  were overridden by default setting
	
	  ret = startup(sd);
	  if (ret)
	  dev_err(&client->dev, "ov2680 startup err\n");
 restore settings 
otp valid at stream on state
if(!dev->otp_data)
	dev->otp_data = ov2680_otp_read(sd);
	
	  power off the module, then power on it in future
	  as first power on by board may not fulfill the
	  power on sequqence needed by the module
 config & detect sensor 
 turn off sensor, after probed 
 Use same lock for controls as for everything else. 
 SPDX-License-Identifier: GPL-2.0
  Support for OmniVision OV5693 1080p HD camera sensor.
  Copyright (c) 2013 Intel Corporation. All Rights Reserved.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 Value 30ms reached through experimentation on byt ecs.
  The DS specifies a much lower value but when using a smaller value
  the I2C bus sometimes locks up permanently when starting the camera.
  This issue could not be reproduced on cht, so we can reduce the
  delay value to a lower value when insmod.
 i2c readwrite stuff 
 high byte goes out first 
 high byte comes first 
  Theory: per datasheet, the two VCMs both allow for a 2-byte read.
  The DW9714 doesn't actually specify what this does (it has a
  two-byte write-only protocol, but specifies the read sequence as
  legal), but it returns the same data (zeroes) always, after an
  undocumented initial NAK.  The AD5823 has a one-byte address
  register to which all writes go, and subsequent reads will cycle
  through the 8 bytes of registers.  Notably, the default values (the
  device is always power-cycled affirmatively, so we can rely on
  these) in AD5823 are not pairwise repetitions of the same 16 bit
  word.  So all we have to do is sequentially read two bytes at a
  time and see if we detect a difference in any of the first four
  pairs.
		
		  DW9714 always fails the first read and returns
		  zeroes for subsequent ones
 16-bit address + data 
 high byte goes out first 
 OV5693_16BIT 
  ov5693_write_reg_array - Initializes a list of OV5693 registers
  @client: i2c driver client structure
  @reglist: list of registers to be written
  This function initializes a list of registers. When consecutive addresses
  are found in a row on the list, this function creates a buffer and sends
  consecutive data in a single i2c_transfer().
  __ov5693_flush_reg_array, __ov5693_buf_reg_array() and
  __ov5693_write_reg_is_consecutive() are internal functions to
  ov5693_write_reg_array_fast() and should be not used anywhere else.
 16-bit address + data 
 When first item is added, we need to store its starting address 
	
	  Buffer cannot guarantee free space for u32? Better flush it to avoid
	  possible lack of memory for next item.
			
			  If next address is not consecutive, data needs to be
			  flushed before proceed.
const f number for imx
 pixel clock 
 get integration time 
 get the cropping and output resolution to ISP for this mode. 
	
	  If coarse_itg is larger than 1<<15, can not write to reg directly.
	  The way is to write coarse_itg2 to the reg, meanwhile write 2hts
	  to the reg.
 group hold 
 Increase the VTS to match exposure + MARGIN 
 set exposure 
 Lower four bit should be 0
 Analog gain 
 Digital gain 
 End group 
 Delay launch group 
 we should not accept the invalid value below 
set bank NO and OTP read mode. 
[7:6] 2'b11 [5:0] bank no
pr_debug("write 0x%x->0x%x\n",OV5693_OTP_BANK_REG,(i|0xc0));
enable read 
 enable :1
pr_debug("write 0x%x->0x%x\n",OV5693_OTP_READ_REG,OV5693_OTP_MODE_READ);
 Reading the OTP data array 
pr_debug("BANK[%2d] %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n", i, b, (b+1), (b+2), (b+3), (b+4), (b+5), (b+6), (b+7), (b+8), (b+9), (b+10), (b+11), (b+12), (b+13), (b+14), (b+15));
Intel OTP map, try to read 320byts first.
if the first 320bytes data doesn't not exist, try to read the next 32bytes data.
if the prvious 32bytes data doesn't exist, try to read the next 32bytes data again.
 no OTP data.
  Read otp data and store it into a kmalloced buffer.
  The caller must kfree the buffer when no more needed.
  @size: set to the size of the returned otp data.
otp valid after mipi on and sw stream on
mipi off and sw stream off after otp read
 Driver has failed to find valid data 
 No need to copy data if size is 0 
 Correct read_size value only if bigger than maximum 
 Return correct size 
  This returns the exposure time being used. This should only be used
  for filling in EXIF data, not for actual image processing.
 get exposure 
 set reg VCM_CODE_MSB Bit[1:0] 
 set reg VCM_CODE_LSB Bit[7:0] 
 set required vcm move time 
 allow enum to grow in the future 
 vcm init test 
change the mode
change initial focus value for ad5823
	
	  This driver assumes "internal DVDD, PWDNB tied to DOVDD".
	  In this set up only gpio0 (XSHUTDN) should be available
	  but in some products (for example ECS) gpio1 (PWDNB) is
	  also available. If gpio1 is available we emulate it being
	  tied to DOVDD here.
 power control 
 according to DS, at least 5ms is needed between DOVDD and PWDN 
 add this delay time to 10~11ms
 gpio ctrl 
 flis clock control 
 gpio ctrl 
 power control 
 restore settings 
  distance - calculate the distance
  @res: resolution
  @w: width
  @h: height
  Get the gap between res_wres_h and wh.
  distance = (res_wres_h - wh)  (wh)  8192
  res->widthheight smaller than wh wouldn't be considered.
  The gap of ratio larger than 18 wouldn't be considered.
  Returns the value of gap or -1 if fail.
 Return the nearest higher resolution index
  Firstly try to find the approximate aspect ratio resolution
  If we find multiple same AR resolutions, choose the
  minimal size.
 TODO: remove it. 
 return the largest resolution 
	
	  After sensor settings are set to HW, sometimes stream is started.
	  This would cause ISP timeout because ISP is not ready to receive
	  data yet. So add stop streaming here.
	 power off the module, then power on it in future
	  as first power on by board may not fulfill the
	  power on sequqence needed by the module
 config & detect sensor 
 turn off sensor, after probed 
	
	  Firmware workaround: Some modules use a "secondary default"
	  address of 0x10 which doesn't appear on schematics, and
	  some BIOS versions haven't gotten the memo.  Work around
	  via config.
 Use same lock for controls as for everything else. 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 if the SP is not running we should not access its dmem 
 Suppres warnings in CRUN 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 sh_css_update_host2sp_mipi_frame sh_css_update_host2sp_num_mipi_frames ... 
 IA_CSS_PSYS_SW_EVENT_MIPI_BUFFERS_READY 
 Initialized in mipi_init 
  Check if a source port or TPGPRBS ID is valid
 Assumptions:
 	- A line is multiple of 4 bytes = 1 word.
 	- Each frame has SOF and EOF (each 1 word).
 	- Each line has format header and optionally SOL and EOL (each 1 word).
 	- Odd and even lines of YUV420 format are different in bites per pixel size.
 	- Custom size of embedded data.
   -- Interleaved frames are not taken into account.
   -- Lines are multiples of 8B, and not necessary of (custom 3B, or 7B
   etc.).
  Result is given in DDR mem words, 32B or 256 bits
	 The changes will be reverted as soon as RAW
	  Buffers are deployed by the 2401 Input System
	  in the non-continuous use scenario.
 4p, 3B, 24bits 
 8p, 7B, 56bits 
 1p, 1B, 8bits 
  8bits, TODO: check. 
 odd 2p, 2B, 16bits, even 2p, 4B, 32bits 
 odd 4p, 5B, 40bits, even 4p, 10B, 80bits 
 4p, 5B, 40bits 
		 The changes will be reverted as soon as RAW
		  Buffers are deployed by the 2401 Input System
		  in the non-continuous use scenario.
 2p, 3B, 24bits 
 2p, 3B, 24bits 
 4p, 7B, 56bits 
 1p, 2B, 16bits 
 1p, 2B, 16bits 
 1p, 2B, 16bits 
 2p, 4B, 32bits 
 4p, 9B, 72bits 
 2p, 5B, 40bits 
 1p, 3B, 24bits 
 Not supported 
 Not supported 
 TODO: not specified in MIPI SPEC, check 
 ceil ( bits per line  8) 
 Even lines for YUV420 formats are double in bits_per_pixel. 
 ceil ( bits per line  8) 
	  a frame represented in memory:  ()- optional; data - payload words.
	  addr		0	1	2	3	4	5	6	7:
	  first	SOF	(SOL)	PACK_H	data	data	data	data	data
			data	data	data	data	data	data	data	data
			...
			data	data	0	0	0	0	0	0
	  second	(EOL)	(SOL)	PACK_H	data	data	data	data	data
			data	data	data	data	data	data	data	data
			...
			data	data	0	0	0	0	0	0
	  ...
	  last		(EOL)	EOF	0	0	0	0	0	0
	
	  Embedded lines are regular lines stored before the first and after
	  payload lines.
 ceil(odd_line_bytes4); word = 4 bytes 
 + SOF +packet header + optionally (SOL), but (EOL) is not in the first line 
 each non-first line has format header, and optionally (SOL) and (EOL). 
 ceil(words_per_odd_line8); mem_word = 32 bytes, 8 words 
 last line consisit of the optional (EOL) and EOF 
 ceil (height2) - 1 (first line is calculated separatelly) 
 floor(height2) 
 ceil(words8); mem word is 32B = 8words. 
 Check if the above is still needed. 
 do nothing 
	
	  zhengjie.lu@intel.com
	 
	  NOTE
	  - In the struct "ia_css_stream_config", there
	    are two members: "input_config" and "isys_config".
	    Both of them provide the same information, e.g.
	    input_res and format.
	 
	    Question here is that: which one shall be used?
 end of NOTE 
	
	  zhengjie.lu@intel.com
	 
	  NOTE
	  - The following code is derived from the
	    existing code "ia_css_mipi_frame_calculate_size()".
	 
	    Question here is: why adding "2  ISP_VEC_NELEMS"
	    to "width_padded", but not making "width_padded"
	    aligned with "2  ISP_VEC_NELEMS"?
	 The changes will be reverted as soon as RAW
	  Buffers are deployed by the 2401 Input System
	  in the non-continuous use scenario.
 end of NOTE 
 ceil ( bits per line  8) 
 Even lines for YUV420 formats are double in bits_per_pixel. 
 ceil ( bits per line  8) 
 ceil(odd_line_bytes4); word = 4 bytes 
 ceil(words_per_odd_line8); mem_word = 32 bytes, 8 words 
 AM TODO: Check  
	 2401 system allows multiple streams to use same physical port. This is not
	  true for 2400 system. Currently 2401 uses MIPI buffers as a temporary solution.
	  TODO AM: Once that is changed (removed) this code should be removed as well.
	  In that case only 2400 related code should remain.
 AM TODO: mipi frames number should come from stream struct. 
 Incremental allocation (per stream), not for all streams at once. 
 limit the scope of i,j 
 free previous frame 
 check if new frame is needed 
 allocate new frame 
 free previous metadata buffer 
 check if need to allocate a new metadata buffer 
 allocate new metadata buffer 
 assert(pipe != NULL); TEMP: TODO: Should be assert only. 
 no streams are using this buffer, so free it 
				 2401 system allows multiple streams to use same physical port. This is not
				  true for 2400 system. Currently 2401 uses MIPI buffers as a temporary solution.
				  TODO AM: Once that is changed (removed) this code should be removed as well.
				  In that case only 2400 related code should remain.
 pipe ==NULL 
 AM TEMP: free-ing all mipi buffers just like a legacy code. 
 multi stream video needs mipi buffers 
 nothing to be done in other cases. 
 TODO: AM: maybe this should be returning an error. 
 Hand-over the SP-internal mipi buffers 
 Need to include the ofset for port. 
	
	  Send an event to inform the SP
	  that all MIPI frames are passed.
 SP is not running. The queues are not valid 
 not used );
 SPDX-License-Identifier: GPL-2.0
  Support for Medifield PNW Camera Imaging ISP subsystem.
  Copyright (c) 2010 Intel Corporation. All Rights Reserved.
  Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
to fake
 only raw8 grbg is supported by TPG 
to fake
to fake
to fake
to fake
 Register the subdev and video nodes. 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 This file will contain the code to implement the functions declared in ia_css_stream.h
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 This file will contain the code to implement the functions declared in ia_css_metadata.h
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 ISP 
 SP 
 MMU 
  MMU0_ID: The data MMU
  MMU1_ID: The icache MMU
 DMA 
 IRQ 
	0x0000000000000500ULL};
 GDC 
 FIFO_MONITOR (not a subset of GP_DEVICE) 
const hrt_address GP_REGS_BASE[N_GP_REGS_ID] = {
	0x0000000000000000ULL};
const hrt_address GP_DEVICE_BASE[N_GP_DEVICE_ID] = {
	0x0000000000090000ULL};
 GP_DEVICE (single base for all separate GP_REG instances) 
GP TIMER , all timer registers are inter-twined,
  so, having multiple base addresses for
 GPIO 
 TIMED_CTRL 
 INPUT_FORMATTER 
 memcpy() 
 INPUT_SYSTEM 
	0x0000000000081000ULL,  
	0x0000000000082000ULL,  
	0x0000000000083000ULL,  
	0x0000000000084000ULL,  
	0x0000000000085000ULL,  
	0x0000000000089000ULL,  
	0x000000000008A000ULL,  
	0x000000000008B000ULL,  
	0x000000000008C000ULL,  
 RX, the MIPI lane control regs start at offset 0 
 IBUF_CTRL, part of the Input System 2401 
 ibuf controller A 
 ibuf controller B 
 ibuf controller C 
 ISYS IRQ Controllers, part of the Input System 2401 
 port a 
 port b 
 port c 
 CSI FE, part of the Input System 2401 
 csi fe controller A 
 csi fe controller B 
 csi fe controller C 
 CSI BE, part of the Input System 2401 
 csi be controller A 
 csi be controller B 
 csi be controller C 
 PIXEL Generator, part of the Input System 2401 
 pixel gen controller A 
 pixel gen controller B 
 pixel gen controller C 
 Stream2MMIO, part of the Input System 2401 
 stream2mmio controller A 
 stream2mmio controller B 
 stream2mmio controller C 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 N_DMA_CHANNEL_ID 
 HRT_GDC_N 
#include "sp.h"	
 Event IDs.
 true if SP supports frame loop and host2sp_commands 
 For the moment there is only code that sets this bool to true 
 TODO: add code that sets this bool to false 
 This data is stored every frame 
 [WW07.5]type casting will cause potential issues 
	 moved to sh_css_sp_init_stage
	   sh_css_sp_stage.enable.vf_output =
	   sh_css_isp_stage.binary_info.enable.vf_veceven ||
	   sh_css_isp_stage.binary_info.num_output_pins > 1;
 Clear for next frame 
 To get rid of warning in CRUN 
 No parameters 
 sp_bin_copy_init on the SP does not deal with dynamicastatic yet 
 For now always update the dynamic data from out frames. 
		
		  Clear sh_css_sp_stage for easy debugging.
		  program_input_circuit must be saved as it is set outside
		  this function.
	 TODO: next indicates from which queues parameters need to be
		
		  Clear sh_css_sp_stage for easy debugging.
		  program_input_circuit must be saved as it is set outside
		  this function.
 No parameters 
 To get rid of warning in CRUN 
 To get rid of warning in CRUN 
		
		  value >=0 indicates that function init_frame_pointers()
		  should use the dynamic data address
		 Klocwork assumes assert can be disabled;
		   Since we can get there with any type, and it does not
		   know that frame_in->dynamic_data_index can only be set
		   for one of the types in the assert) it has to assume we
		   can get here for any type. however this could lead to an
		   out of bounds reference when indexing buf_type about 10
		   lines below. In order to satisfy KW an additional if
		   has been added. This one will always yield true.
		 This should not happen, but in case it does,
		  nullify the planes
 the dual output pin 
 for vf_veceven 
	
	  The SP group is only loaded at SP boot time and is read once
	  change flags as "input_circuit_cfg_changed" must be reset on the SP
	 we don't pass this error back to the upper layer, so we add a assert here
 decide whether the frame is processed online or offline 
	
	  FIXME: args->delay_frames can be NULL here
	 
	  Somehow, the driver at the Intel Atom Yocto tree doesn't seem to
	  suffer from the same issue.
	 
	  Anyway, the function below should now handle a NULL delay_frames
	  without crashing, but the pipeline should likely be built without
	  adding it at the first place (or there are a hidden bug somewhere)
		
		  Clear sh_css_sp_stage for easy debugging.
		  program_input_circuit must be saved as it is set outside
		  this function.
	
	  TODO: Make the Host dynamically determine
	  the stage type.
	 Copy the frame infos first, to be overwritten by the frames,
	   if these are present.
 Make sure binary name is smaller than allowed string size 
	
	  Even when a stage does not need uds and does not params,
	  ia_css_uds_sp_scale_params() seems to be called (needs
	  further investigation). This function can not deal with
	  dx, dy = {0, 0}
 TODO: move it to a better place 
avoid build warning
	 we do this only for preview pipe because in fill_binary_info function
	  we assign vf_out res to out res, but for ISP internal processing, we need
	  the original out res. for video pipe, it has two output pins --- out and
		 TODO: Remove this after preview output decimation is fixed
	
	  Initialiser required because of the "else" path below.
	  Is this a valid path ?
	 note: the var below is made static as it is quite large;
	   if it is not static it ends up on the stack which could
	   cause issues for drivers
	 LA: should be ia_css_data, should not contain host pointer.
	   However, CSSDDR pointer is not available yet.
	   Hack is to store it in params->ddr_ptrs and then copy it late in the SP just before vmem init.
	   TODO: Call this after CSSDDR allocation and store that pointer.
	   Best is to allocate it at stage creation time together with host pointer.
	   Remove vmem from params.
 SP stage 
		 binary and blob_info are now NULL.
		   These will be passed to sh_css_sp_init_stage
		   and dereferenced there, so passing a NULL
 TBI 
			internal_frame_origin_bqs_on_sctbl,  Origin of internal frame
 Get first stage 
 should not happen but KW does not know 
 we should be able to return an error 
 Count stages 
 Init pipeline data 
 if (first_binary != NULL) 
 Signal the host immediately after start for SP_ISYS_COPY only 
 Init stage data 
	 TODO: next indicates from which queues parameters need to be
	 For continuous use-cases, SP copy is responsible for sampling the
		 For the shading correction type 1 (the legacy shading table conversion in css is not used),
		 the parameters are passed to the isp for the shading table centering.
memset(&sh_css_sp_group.pipe[thread_id], 0, sizeof(struct sh_css_sp_pipeline));
 Suppres warnings in CRUN 
 Previous command must be handled by SP (by design) 
 Suppres warnings in CRUN 
  Frame data is no longer part of the sp_stage structure but part of a
  separate structure. The aim is to make the sp_data struct static
  (it defines a pipeline) and that the dynamic (per frame) data is stored
  separetly.
  This function must be called first every where were you start constructing
  a new pipeline by defining one or more stages with use of variable
  sh_css_sp_stage. Even the special cases like accelerator and copy_frame
  These have a pipeline of just 1 stage.
 Clean table 
 Suppres warnings in CRUN 
	
	  rvanimme: don't clean it to save static frame info line ref_in
	  ref_out, and tnr_frames. Once this static data is in a
	  separate data struct, this may be enable (but still, there is
	  no need for it)
  @brief Update the offline frame information in host_sp_communication.
  Refer to "sh_css_sp.h" for more details.
 Write new frame data into SP DMEM 
 Write metadata buffer into SP DMEM 
  @brief Update the mipi frame information in host_sp_communication.
  Refer to "sh_css_sp.h" for more details.
 MIPI buffers are dedicated to port, so now there are more of them. 
 Write new frame data into SP DMEM 
  @brief Update the mipi metadata information in host_sp_communication.
  Refer to "sh_css_sp.h" for more details.
 MIPI buffers are dedicated to port, so now there are more of them. 
 Write new frame data into SP DMEM 
 Write new frame data into SP DMEM 
 Write new frame data into SP DMEM 
 Suppress warnings in CRUN 
	 Linux kernel does not have UINT16_MAX
	  Therefore decided to comment out these 2 asserts for Linux
	  Alternatives that were not chosen:
	  - add a conditional #define for UINT16_MAX
	  - compare with (uint16_t)~0 or 0xffff
	  - different assert for Linux and Windows
 Suppres warnings in CRUN 
 Suppres warnings in CRUN 
 Suppres warnings in CRUN 
 no longer here, sp started immediately 
ia_css_debug_pipe_graph_dump_epilogue();
	 Note 1: The sp_start_isp function contains a wait till
	  the input network is configured by the SP.
	  Note 2: Not all SP binaries supports host2sp_commands.
	  In case a binary does support it, the host2sp_command
	  will have status cmd_ready after return of the function
	  sh_css_hrt_sp_start_isp. There is no race-condition here
	  because only after the process_frame command has been
	  received, the SP starts configuring the input network.
	 we need to set sp_running before we call ia_css_mmu_invalidate_cache
	  as ia_css_mmu_invalidate_cache checks on sp_running to
	  avoid that it accesses dmem while the SP is not powered
 Invalidate all MMU caches 
 Suppres warnings in CRUN 
  @brief Initialize the DMA software-mask in the debug mode.
  Refer to "sh_css_sp.h" for more details.
 enable all the DMA channels 
 enable the writing request 
 enable the reading request 
  @brief Set the DMA software-mask in the debug mode.
  Refer to "sh_css_sp.h" for more details.
 get the software-mask 
 get the offest of the target bit 
 clear the value of the target bit 
 set the value of the bit for the DMA channel 
 update the software status of DMA channels 
 SPDX-License-Identifier: GPL-2.0
  Support for atomisp driver sysfs interface
  Copyright (c) 2014 Intel Corporation. All Rights Reserved.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  _iunit_debug:
  dbglvl: iunit css driver trace level
  dbgopt: iunit debug option:
         bit 0: binary list
         bit 1: running binary
         bit 2: memory statistic
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 This file will contain the code to implement the functions declared in ia_css_shading.h
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
	
	  MW: We don't want to store the coordinates
	  full range in memory: Truncate
 SPDX-License-Identifier: GPL-2.0
  Support for Medifield PNW Camera Imaging ISP subsystem.
  Copyright (c) 2010 Intel Corporation. All Rights Reserved.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 disabled due to clang warnings
 no valid V4L2 MBUS code for metadata format, so leave it 0. 
  V4L2 subdev operations
  isp_subdev_ioctl - CCDC module private ioctl's
  @sd: ISP V4L2 subdevice
  @cmd: ioctl command
  @arg: ioctl argument
  Return 0 on success or a negative error code otherwise.
  isp_subdev_set_power - Power onoff the CCDC module
  @sd: ISP V4L2 subdevice
  @on: power onoff
  Return 0 on success or a negative error code otherwise.
  isp_subdev_enum_mbus_code - Handle pixel format enumeration
  @sd: pointer to v4l2 subdev structure
  @fh : V4L2 subdev file handle
  @code: pointer to v4l2_subdev_pad_mbus_code_enum structure
  return -EINVAL or zero on success
 Only crop target supported on sink pad. 
 Only crop target supported on sink pad. 
		 Workaround for BYT 1080p perfectshot since the maxinum resolution of
 if subdev type is SOC camera,we do not need to set DVS 
			 This resolution contains 20 % of DVS slack
			  (of the desired captured image before
			  scaling, or 1  6 of what we get from the
			  sensor) in both width and height. Remove
			
			  For CSS2.0, digital zoom needs to set dvs envelope to 12
			  when dvs is disabled.
 Only compose target is supported on source pads. 
 Scaling is disabled in this mode 
		
		  do cropping on sensor input if ratio of required resolution
		  is different with sensor output resolution ratio:
		 
		  ratio = width  height
		 
		  if ratio_output < ratio_sensor:
		 	effect_width = sensor_height  out_width  out_height;
		 	effect_height = sensor_height;
		  else
		 	effect_width = sensor_width;
		 	effect_height = sensor_width  out_height  out_width;
		 
 Set format dimensions on non-sink pads as well. 
	
	  ISP needs to know binning factor from sensor.
	  In case horizontal and vertical sensor's binning factors
	  are different or sensor does not support binning factor CID,
	  ISP will apply default 0 value.
  isp_subdev_get_format - Retrieve the video format on a pad
  @sd : ISP V4L2 subdevice
  @fh : V4L2 subdev file handle
  @pad: Pad number
  @fmt: Format
  Return 0 on success or -EINVAL if the pad is invalid or doesn't correspond
  to the format type.
  isp_subdev_set_format - Set the video format on a pad
  @sd : ISP subdev V4L2 subdevice
  @fh : V4L2 subdev file handle
  @pad: Pad number
  @fmt: Format
  Return 0 on success or -EINVAL if the pad is invalid or doesn't correspond
  to the format type.
 V4L2 subdev core operations 
 V4L2 subdev pad operations 
 V4L2 subdev operations 
 parameters initialization 
 isp_subdev_link_setup - Setup isp subdev connections
 @entity: ispsubdev media entity
 @local: Pad at the local end of the link
 @remote: Pad at the remote end of the link
 @flags: Link flags
 return -EINVAL or zero on success
 Read from the sensor CSI2-ports. 
 read from memory 
 always write to memory 
 always write to memory 
 always write to memory 
 always write to memory 
 media operations 
	 .set_power = v4l2_subdev_set_power,	
 vfpp always enabled 
 CSS into video mode and disable 
 CSS into still mode and disable 
  Control for ISP continuous mode
  When enabled, capture processing is possible without
  stopping the preview pipeline. When disabled, ISP needs
  to be restarted between preview and capture.
  Control for continuous mode raw buffer size
  The size of the RAW ringbuffer sets limit on how much
  back in time application can go when requesting capture
  frames to be rendered, and how many frames can be rendered
  in a burst at full sensor rate.
  Note: this setting has a big impact on memory consumption of
  the CSS subsystem.
 depends on CSS version, runtime checked 
  Control for enabling continuous viewfinder
  When enabled, and ISP is in continuous mode (see ctrl_continuous_mode ),
  preview pipeline continues concurrently with capture
  processing. When disabled, and continuous mode is used,
  preview is paused while captures are processed, but
  full pipeline restart is not needed.
  By setting this to disabled, capture processing is
  essentially given priority over preview, and the effective
  capture output rate may be higher than with continuous
  viewfinder enabled.
  Control for enabling Lock&Unlock Raw Buffer mechanism
  When enabled, Raw Buffer can be locked and unlocked.
  Application can hold the exp_id of Raw Buffer
  and unlock it when no longer needed.
  Note: Make sure set this configuration before creating stream.
  Control to disable digital zoom of the whole stream
  When it is true, pipe configuration enable_dz will be set to false.
  This can help get a better performance by disabling pp binary.
  Note: Make sure set this configuration before creating stream.
  Control for ISP depth mode
  When enabled, that means ISP will deal with dual streams and sensors will be
  in slavemaster mode.
  slave sensor will have no output until master sensor is streamed on.
  Control for selectting ISP version
  When enabled, that means ISP version will be used ISP2.7. when disable, the
  isp will default to use ISP2.2.
  Note: Make sure set this configuration before creating stream.
  isp_subdev_init_entities - Initialize V4L2 subdev and media entity
  @asd: ISP CCDC module
  Return 0 on success and a negative error code on failure.
 Make controls visible on subdev as well. 
		
		  file input only supported on subdev0
		  so do not create pad link for subdevs other then subdev0
	
	  FIXME: check if all device caps are properly initialized.
	  Should any of those use V4L2_CAP_META_OUTPUT? Probably yes.
 Register the subdev and video node. 
	
	  file input only supported on subdev0
	  so do not create video node for subdevs other then subdev0
  atomisp_subdev_init - ISP Subdevice  initialization.
  @dev: Device pointer specific to the ATOM ISP.
  TODO: Get the initialisation values from platform data.
  Return 0 on success or a negative error code otherwise.
	
	  CSS2.0 running ISP2400 support
	  multiple streams
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
! \file 
 only for file 2 MIPI 
 sh_css_sp_group 
 Event IDs.
 mmu_set_page_table_base_index(), ... 
 sh_css_mmu_set_page_table_base_index() 
 HRT_GDC_N 
 dma_set_max_burst_size() 
 virq 
 cnd_sp_irq_enable() 
 cnd_isp_irq_enable, ISP_VEC_NELEMS 
 gp_device_reg_store() 
 WITH_PC_MONITORING 
 clock_value_t 
 Name of the sp program: should not be built-in 
 Size of Refcount List 
 for JPEG, we don't know the length of the image upfront,
  but since we support sensor upto 16MP, we take this as
  upper limit.
 modes of work: stream_create and stream_destroy will update the saverestore data
   only when in working mode, not suspendresume
 a stream seed, to save and restore the stream data.
   the stream seed contains all the data required to "grow" the seed again after it was closed.
 pointer to restore the original handle 
 handle, used as ID too.
 stream config struct 
 pipe handles 
 pointer to restore original handle 
 pipe config structs 
 A global struct for saverestore to hold all the data that should sustain power-down:
   MMU base, IRQ type, env for routines, binary loaded FW and the stream seeds.
 the last mmu_base 
 fw struct previously loaded 
 driver-supplied env copy 
 if my_css_save was initialized 
 pqiao NOTICE: this is for css internal buffer recycling when stopping pipeline,
 Taking the biggest Size for number of Elements 
  Local prototypes
 ISP 2401 
  @brief Stop all "ia_css_pipe" instances in the target
  "ia_css_stream" instance.
  @param[in] stream	Point to the target "ia_css_stream" instance.
  @return
  - 0, if the "stop" requests have been successfully sent out.
  - CSS error code, otherwise.
  NOTE
  This API sends the "stop" requests to the "ia_css_pipe"
  instances in the same "ia_css_stream" instance. It will
  return without waiting for all "ia_css_pipe" instatnces
  being stopped.
  @brief Check if all "ia_css_pipe" instances in the target
  "ia_css_stream" instance have stopped.
  @param[in] stream	Point to the target "ia_css_stream" instance.
  @return
  - true, if all "ia_css_pipe" instances in the target "ia_css_stream"
    instance have ben stopped.
  - false, otherwise.
 ISP 2401 
 ISP 2401 
 ISP 2401 
 Verify whether the selected output format is can be produced
  by the copy binary given the stream format.
 TODO: move define to proper file in tools 
		
		  The frame format layout is shown below.
		 
		 		Line	0:	UYY0 UYY0 ... UYY0
		 		Line	1:	VYY0 VYY0 ... VYY0
		 		Line	2:	UYY0 UYY0 ... UYY0
		 		Line	3:	VYY0 VYY0 ... VYY0
		 		...
		 		Line (n-2):	UYY0 UYY0 ... UYY0
		 		Line (n-1):	VYY0 VYY0 ... VYY0
		 
		 	In this frame format, the even-line is
		 	as wide as the odd-line.
		 	The 0 is introduced by the input system
		 	(mipi backend).
		
		  The frame format layout is shown below.
		 
		 		Line	0:	YYYY YYYY ... YYYY
		 		Line	1:	UYVY UYVY ... UYVY UYVY
		 		Line	2:	YYYY YYYY ... YYYY
		 		Line	3:	UYVY UYVY ... UYVY UYVY
		 		...
		 		Line (n-2):	YYYY YYYY ... YYYY
		 		Line (n-1):	UYVY UYVY ... UYVY UYVY
		 
		  In this frame format, the odd-line is twice
		  wider than the even-line.
		
		  The frame format layout is shown below.
		 
		 		Line	0:	UYVY UYVY ... UYVY
		 		Line	1:	UYVY UYVY ... UYVY
		 		Line	2:	UYVY UYVY ... UYVY
		 		Line	3:	UYVY UYVY ... UYVY
		 		...
		 		Line (n-2):	UYVY UYVY ... UYVY
		 		Line (n-1):	UYVY UYVY ... UYVY
		 
		  In this frame format, the even-line is
		  as wide as the odd-line.
		
		  The frame format layout is shown below.
		 
		 		Line	0:	ABGR ABGR ... ABGR
		 		Line	1:	ABGR ABGR ... ABGR
		 		Line	2:	ABGR ABGR ... ABGR
		 		Line	3:	ABGR ABGR ... ABGR
		 		...
		 		Line (n-2):	ABGR ABGR ... ABGR
		 		Line (n-1):	ABGR ABGR ... ABGR
		 
		  In this frame format, the even-line is
		  as wide as the odd-line.
		
		  The frame format layout is shown below.
		 
		 		Line	0:	Pixel Pixel ... Pixel
		 		Line	1:	Pixel Pixel ... Pixel
		 		Line	2:	Pixel Pixel ... Pixel
		 		Line	3:	Pixel Pixel ... Pixel
		 		...
		 		Line (n-2):	Pixel Pixel ... Pixel
		 		Line (n-1):	Pixel Pixel ... Pixel
		 
		  In this frame format, the even-line is
		  as wide as the odd-line.
		
		  TODO
		  - Make "color_cfg" as part of "ia_css_tpg_config".
		
		  TODO
		  - Make "sync_gen_cfg" as part of "ia_css_tpg_config".
		
		  TODO
		  - Make "sync_gen_cfg" as part of "ia_css_prbs_config".
 metadata 
			 For new input system, number of str2mmio requests must be even.
 HW needs subpixel info for their settings 
	
	  Early polling is required for timestamp accuracy in certain case.
	  The ISYS HW polling is started on
	  ia_css_isys_stream_capture_indication() instead of
	  ia_css_pipeline_sp_wait_for_isys_stream_N() as isp processing of
	  capture takes longer than getting an ISYS frame
	 
	  Only 2401 relevant ??
 FIXME: NOT USED on Yocto Aero
			
			  We need to poll the ISYS HW in capture_indication itself
			  for "non-continuous" capture usecase for getting accurate
			  isys frame capture timestamps.
			  This is because the capturepipe propcessing takes longer
			  to execute than the input system frame capture.
			  2401 specific
		 this was being done in ifmtr in 2400.
		  online and cont bypass the init_in_frameinfo_memory_defaults
		  so need to do it here
 get the SP thread id 
 get the target input terminal 
 initialization 
 translate the stream configuration to the Input System (2401) configuration 
 create the virtual Input System (2401) 
 calculate the configuration of the virtual Input System (2401) 
 get the pipe that consumes the stream 
 (un)register all valid "virtual isys streams" within the ia_css_stream 
 Handle for the monitoring thread 
 Enable sampling in the thread 
 WITH_PC_MONITORING 
 Acceleration uses firmware, the binary thus can be NULL 
 start the copy function on the SP 
 all callers are in this file and call with non null argument 
	 Enable IRQ on the SP which signals that SP goes to idle
 Set the IRQ device 0 to either level or pulse 
 Enable SW interrupt 0, this is used to signal ISYS events 
 Enable SW interrupt 1, this is used to signal PSYS events 
 entry function ptr on SP 
 we have already loaded before so get rid of the old stuff 
 Reset everything to zero 
 Initialize the non zero values
	 All should be 0: but memset does it already.
	  default_css.num_mipi_frames[N_CSI_PORTS] = 0;
Set the defaults to the output 
 make sure we initialize my_css 
 in case we are called twice 
	
	  The C99 standard does not specify the exact object representation of structs;
	  the representation is compiler dependent.
	 
	  The structs that are communicated between host and SPISP should have the
	  exact same object representation. The compiler that is used to compile the
	  firmware is hivecc.
	 
	  To check if a different compiler, used to compile a host application, uses
	  another object representation, macros are defined specifying the size of
	  the structs as expected by the firmware.
	 
	  A host application shall verify that a sizeof( ) of the struct is equal to
	  the SIZE_OF_XXX macro of the corresponding struct. If they are not
	  equal, functionality will break.
 Check struct sh_css_ddr_address_map 
 Check struct host_sp_queues 
 Check struct host_sp_communication 
 Check struct sh_css_hmm_buffer 
 Check struct ia_css_init_dmem_cfg 
	 In case this has been programmed already, update internal
 configure GPIO to output mode 
 in case we already had firmware loaded 
	 can be called here, queuing works, but:
	   - when sp is started later, it will wipe queued items
	   so for now we leave it for later and make sure
	   updates are not called to frequently.
	sh_css_init_buffer_queues();
 For Acceleration API: Flush FW (shared buffer pointer) arguments 
 Mapping sp threads. Currently, this is done when a stream is created and
  pipelines are ready to be converted to sp pipelines. Be careful if you are
  doing it from stream_create since we could run out of sp threads due to
 Firmware expects copy pipe to be the last pipe mapped. (if needed) 
 DH regular multi pipe - not continuous mode: map the next pipes too 
 creates a host pipeline skeleton for all pipes in a stream. Called during
 DH regular multi pipe - not continuous mode: create the next pipelines too 
 creates a host pipeline for all pipes in a stream. Called during
	 No continuous frame allocation for capture pipe. It uses the
		 About pipe_id == IA_CSS_PIPE_ID_PREVIEW && stream->config.mode != IA_CSS_INPUT_MODE_MEMORY:
		  The original condition pipe_id == IA_CSS_PIPE_ID_PREVIEW is too strong. E.g. in SkyCam (with memory
		  based input frames) there is no continuous mode and thus no need for allocated continuous frames
		  This is not only for SkyCam but for all preview cases that use DDR based input frames. For this
		  reason the stream->config.mode != IA_CSS_INPUT_MODE_MEMORY has beed added.
 old isys: need to allocate_mipi_frames() even in IA_CSS_PIPE_MODE_COPY 
 DH regular multi pipe - not continuous mode: create the next pipelines too 
 Initialize pipe to pre-defined defaults 
 TODO: JB should not be needed, but temporary backward reference 
 Assign a new pipe_num .... search for empty place 
position is reserved 
 Max number of pipes already allocated 
 loop through the stages and unload them 
		 need to take into account that this function is also called
 Temporarily, not every sh_css_pipe has an acc_extension. 
 TODO: JB: implement decent check and handling of freeing mipi frames 
assert(ref_count_mipi_allocation == 0); 
 cleanup generic data 
 needed for reprogramming the inputformatter after power cycle of css 
 check and free any remaining mipi frames 
 irq_infos can be NULL, but that would make the function useless 
 assert(irq_infos != NULL); 
			 When SP goes to idle, info is available in the
 pqiao TODO: also assumption here 
 Just ignore those unused IRQs without printing errors 
 configure and load the copy binary, the next binary is used to
 next_binary can be NULL 
TODO: &copy_vf_info);
 should not happen 
 For CSI2+, the continuous frame will hold the full input frame 
 Ensure padded width is aligned for 2401 
 Write format back to binary 
 should not happen 
 free previous frame 
 free previous metadata buffer 
 check if new frame needed 
 allocate new frame 
 allocate metadata buffer 
 preview only have 1 output pin now 
	 Note: the current selection of vf_pp binary and
	  parameterization of the preview binary contains a few pieces
	  of hardcoded knowledge. This needs to be cleaned up such that
	  the binary selection becomes more generic.
	  The vf_pp binary is needed if one or more of the following features
	  are required:
	  1. YUV downscaling.
	  2. Digital zoom.
	  3. An output format that is not supported by the preview binary.
	     In practice this means something other than yuv_line or nv12.
	  The decision if the vf_pp binary is needed for YUV downscaling is
	  made after the preview binary selection, since some preview binaries
	  can perform the requested YUV downscaling.
 Preview step 1 
	 If vf_pp is needed, then preview must output yuv_line.
	  The exception is when vf_pp is manually disabled, that is only
	  used in combination with a pipeline extension that requires
	  yuv_line as input.
		 The delay latency determines the number of invalid frames after
 The vf_pp binary is needed when (further) YUV downscaling is required 
	 When vf_pp is needed, then the output format of the selected
	  preview binary must be yuv_line. If this is not the case,
	  then the preview binary selection is done again.
 Preview step 2 
 Viewfinder post-processing 
	 When the input system is 2401, only the Direct Sensor Mode
	  Offline Preview uses the ISP copy binary.
	 About pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY:
	  This is typical the case with SkyCam (which has no input system) but it also applies to all cases
	  where the driver chooses for memory based input frames. In these cases, a copy binary (which typical
	  copies sensor data to DDR) does not have much use.
 Copy 
 fw can be NULL 
 all args can be NULL ??? 
 out_frame can be NULL ??? 
 out_frame can be NULL ??? 
 If a firmware produce vf_pp output, we set that as vf_pp input 
 out_frame can be NULL ??? 
 If a firmware produce vf_pp output, we set that as vf_pp input 
 set "host_sp_queues_initialized" to "true" 
 This function is to get the sum of all extra pixels in addition to the effective
	 The dvs envelope info may not be correctly sent down via pipe config
	  The check is made and the correct value is populated in the binary info
	  Use this value when computing crop, else excess lines may get trimmed
	
	  TODO:
	  1. Require the special support for RAW10 packed mode.
	  2. Require the special support for the online use cases.
	 ISP expects GRBG bayer order, we skip one line andor one row
	  to correct in case the input bayer order is different.
 Create stages for video pipe 
 pipeline already created as part of create_host_pipeline_structure 
	 When the input system is 2401, always enable 'in_frameinfo_memory'
	  except for the following: online or continuous
 Construct in_frame info (only in case we have dynamic input 
 Construct in_frame info (only in case we have dynamic input 
		 When continuous is enabled, configure in_frame with the
		  last pipe, which is the copy pipe.
	 when the video binary supports a second output pin,
 If we use copy iso video, the input must be yuv iso raw 
	 when the video binary supports only 1 output pin, vf_pp is needed to
 Append Extension on Video out, if enabled 
 InOut Frame mapping to support output frame extension.
 we use output port 1 as internal output port 
 Reset pipe_qos_config to default disable all QOS extension stages 
 Create stages for preview 
 pipeline already created as part of create_host_pipeline_structure 
	 When the input system is 2401, always enable 'in_frameinfo_memory'
	  except for the following:
	  - Direct Sensor Mode Online Preview
	  - Buffered Sensor Mode Online Preview
	  - Direct Sensor Mode Continuous Preview
	  - Buffered Sensor Mode Continuous Preview
 Construct in_frame info (only in case we have dynamic input 
		 When continuous is enabled, configure in_frame with the
		  last pipe, which is the copy pipe.
 If we use copy iso preview, the input must be yuv iso raw 
 in case of copy, use the vf frame as output frame 
 Hand-over all the SP-internal buffers 
 multi stream video needs mipi buffers 
 Construct and load the copy pipe 
		 make the preview pipe start with mem mode input, copy handles
 Construct and load the capture pipe 
 continuous 
 offline 
 continuous 
 offline 
	 following code will be enabled when IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME
 SP is not running. The queues are not valid 
 start of test for using rmgr for acqrel memory 
 TODO: change next to correct pool for optimization 
			 The SP will read the params
 there is a stage that needs it 
	
	  Tell the SP which queues are not empty,
	  by sending the software event.
 SP is not running. The queues are not valid 
  TODO: Free up the hmm memory space.
 SP is not running. The queues are not valid 
 Validate the ddr_buffer_addr and buf_type 
			 valid hmm_buffer_record found. Save the kernel_ptr
			  for validation after performing hmm_load.  The
			  vbuf handle and buffer_record can be released.
		 if the kernel_ptr is 0 or an invalid, return an error.
		  do not access the buffer via the kernal_ptr.
			 buffer->exp_id : all instances to be removed later once the driver change
					 free mipi frames only for old input system
					  for 2401 it is done in ia_css_stream_destroy call
	
	  Tell the SP which queues are not full,
	  by sending the software event.
 SP is not running. The queues are not valid 
  Cannot Move this to event module as it is of ia_css_event_type which is declared in ia_css.h
  TODO: modify and move it if possible.
  !!!IMPORTANT!!! KEEP THE FOLLOWING IN SYNC:
  1) "enum ia_css_event_type"					(ia_css_event_public.h)
  2) "enum sh_css_sp_event_type"				(sh_css_internal.h)
  3) "enum ia_css_event_type event_id_2_event_mask"		(event_handler.sp.c)
  4) "enum ia_css_event_type convert_event_sp_to_host_domain"	(sh_css.c)
 Output frame ready. 
 Second output frame ready. 
 Viewfinder Output frame ready. 
 Second viewfinder Output frame ready. 
 Indication that 3A statistics are available. 
 Indication that DIS statistics are available. 
 Pipeline Done event, sent after last pipeline stage. 
 Frame tagged. 
 Input frame ready. 
 Metadata ready. 
 Indication that LACE statistics are available. 
 Extension stage executed. 
 Timing measurement data. 
 End Of Frame event, sent when in buffered sensor mode. 
 Performance warning encountered by FW 
 Assertion hit by FW 
 error if sp passes  SH_CSS_SP_EVENT_NR_OF_TYPES as a valid event. 
	TODO:
	  a) use generic decoding function , same as the one used by sp.
	  b) group decode and dequeue into eventQueue module
	 
	  We skip the IA_CSS_ENTER logging call
	  to avoid flooding the logs when the host application
 SP is not running. The queues are not valid 
 dequeue the event (if any) from the psys event queue 
 Tell the SP that we dequeued an event from the event queue. 
	 Events are decoded into 4 bytes of payload, the first byte
	  contains the sp event type. This is converted to a host enum.
 Some sane default values since not all events use all fields. 
 timer event ??? get the 2nd event and decode the data into the event struct 
 1st event: LSB 16-bit timer data and code 
 no 2nd event ??? an error 
			 Putting IA_CSS_ERROR is resulting in failures in
 It's a timer 
 2nd event data: MSB 16-bit timer and subcode 
		 It's a non timer event. So clear first half of the timer event data.
		 If the second part of the TIMER event is not received, we discard
		 the first half of the timer data and process the non timer event without
		 affecting the flow. So the non timer event falls through
 exp_id is only available in these warning types 
 module 
 payload[2] is line_no>>8, payload[3] is line_no&0xff 
		 pipe related events.
		  payload[1] contains the pipe_num,
 Check to see if pipe still exists 
 find the capture pipe that goes with this 
 payload[3] contains the acc fw handle. 
	 We skip the IA_CSS_ENTER logging call
	  to avoid flooding the logs when the host application
 SP is not running. The queues are not valid 
 Update SP state to indicate that element was dequeued. 
 Fill return struct with appropriate info 
 EOF events are associated with a CSI port, not with a pipe 
 DH regular multi pipe - not continuous mode: start the next pipes too 
	 Force ISP parameter calculation after a mode change
	  Acceleration API examples pass NULL for stream but they
	  don't use ISP parameters anyway. So this should be okay.
	  The SP binary (jpeg) copy does not use any parameters.
 SP is not running. The queues are not valid 
 DH regular multi pipe - not continuous mode: enqueue event to the next pipes too 
 in case of continuous capture mode, we also start capture thread and copy thread
 by the time we reach here q is initialized and handle is available.
 by the time we reach here q is initialized and handle is available.
 in case of PREVIEW mode, check whether QOS acc_pipe is available, then start the qos pipe 
 by the time we reach here q is initialized and handle is available.
 ISP2400 
my_css.cont_capt = enable;
 ISP2400 
 ok, value allowed 
 TODO: check what to regarding initialization 
 ISP2401 
  @brief Stop all "ia_css_pipe" instances in the target
  "ia_css_stream" instance.
  Refer to "Local prototypes" for more info.
 ISP2401 
	
	  Stop all "ia_css_pipe" instances in this target
	  "ia_css_stream" instance.
 send the "stop" request to the "ia_css_pipe" instance 
		
		 Exit this loop if "ia_css_pipeline_request_stop()"
		 returns the error code.
		
		 The error code would be generated in the following
		 two cases:
		 (1) The Scalar Processor has already been stopped.
		 (2) The "Host->SP" event queue is full.
		
		 As the convention of using CSS API 2.02.1, such CSS
		 error code would be propogated from the CSS-internal
		 API returned value to the CSS API returned value. Then
		 the CSS driver should capture these error code and
		 handle it in the driver exception handling mechanism.
	
	  In the CSS firmware use scenario "Continuous Preview"
	  as well as "Continuous Video", the "ia_css_pipe" instance
	  "Copy Pipe" is activated. This "Copy Pipe" is private to
	  the CSS firmware so that it is not listed in the target
	  "ia_css_stream" instance.
	 
	  We need to stop this "Copy Pipe", as well.
 get the reference to "Copy Pipe" 
 return the error code if "Copy Pipe" does NOT exist 
 send the "stop" request to "Copy Pipe" 
  @brief Check if all "ia_css_pipe" instances in the target
  "ia_css_stream" instance have stopped.
  Refer to "Local prototypes" for more info.
 ISP2401 
	
	  Check if every "ia_css_pipe" instance in this target
	  "ia_css_stream" instance has stopped.
	
	  In the CSS firmware use scenario "Continuous Preview"
	  as well as "Continuous Video", the "ia_css_pipe" instance
	  "Copy Pipe" is activated. This "Copy Pipe" is private to
	  the CSS firmware so that it is not listed in the target
	  "ia_css_stream" instance.
	 
	  We need to check if this "Copy Pipe" has stopped, as well.
 get the reference to "Copy Pipe" 
 return if "Copy Pipe" does NOT exist 
 check if "Copy Pipe" has stopped or not 
		 Other function calls can be added here when other shading correction types will be added
		  in the future.
		 When the pipe does not have a binary which has the shading
		  correction, this function does not need to fill the shading
		  information. It is not a error case, and then
		  this function should return 0.
 copy pipe does not have ISP binary
 ISP2401 
  @brief Check if a format is supported by the pipe.
	 we only test the video_binary because offline video doesn't need a
	  vf_pp binary and online does not (always use) the copy_binary.
	  All are always reset at the same time anyway.
	
	  There is no explicit input format requirement for raw or yuv
	  What matters is that there is a binary that supports the stream format.
	  This is checked in the binary_find(), so no need to check it here
 cannot have online video and input_mode memory 
 Video 
 we build up the pipeline starting at the end 
 YUV post-processing if needed 
 NV12 is the common format that is supported by both 
 yuv_scaler and the video_xx_isp2_min binaries. 
		 In the case where video_vf_info is not NULL, this allows
		  us to find a potential video library with desired vf format.
		  If success, no vf_pp binary is needed.
		  If failed, we will look up video binary with YUV_LINE vf format
 This will do another video binary lookup later for YUV_LINE format
			 The first video binary lookup is successful, but we may
			 If the binary has dual output pins, we need vf_pp if the resolution
			 If the binary has single output pin, we need vf_pp if additional
 save the current vf_info format for restoration later 
 restore original vf_info format 
	 If a video binary does not use a ref_frame, we set the frame delay
	 The delay latency determines the number of invalid frames after
	 Viewfinder frames also decrement num_invalid_frames. If the pipe
	  outputs a viewfinder output, then we need double the number of
 pqiao TODO: temp hack for PO, should be removed after offline YUVPP is enabled 
 Copy 
		 TODO: what exactly needs doing, prepend the copy binary to
		 	 video base this only on !online?
			 output from main binary is not yuv line. currently this is
			 Select resolution for TNR. If
			 output_system_in_resolution(GDC_out_resolution) is
			 being used, then select that as it will also be in resolution for
 Make tnr reference buffers output block width(in pix) align 
 Make tnr reference buffers output block height align 
 multi stream video needs mipi buffers 
 Construct and load the copy pipe 
		 make the video pipe start with mem mode input, copy handles
 Construct and load the capture pipe 
 continuous 
 offline 
 We could print the pointer as input arg, and the values as output 
 offline video does not generate viewfinder output 
 ldc and capture_pp are not supported in the same pipeline 
	 determine whether we need to use the capture_pp binary.
	  This is needed for:
	    1. XNR or
	    2. Digital Zoom or
	    3. YUV downscaling
	 we use the vf output info to get the primarycapture_pp binary
	   configured for vf_veceven. It will select the closest downscaling
	
	  WARNING: The #if def flag has been added below as a
	  temporary solution to solve the problem of enabling the
	  view finder in a single binary in a capture flow. The
	  vf-pp stage has been removed for Skycam in the solution
	  provided. The vf-pp stage should be re-introduced when
	  required. This should not be considered as a clean solution.
	  Proper investigation should be done to come up with the clean
	  solution.
	 TODO: All this yuv_scaler and capturepp calculation logic
	  can be shared later. Capture_pp is also a yuv_scale binary
	  with extra XNR funcionality. Therefore, it can be made as the
 TODO Do we disable ldc for skycam 
 ldc and capt_pp are not supported in the same pipeline 
 we build up the pipeline starting at the end 
 Capture post-processing 
 Primary 
 Viewfinder post-processing 
	
	     WARNING: The #if def flag has been added below as a
	     temporary solution to solve the problem of enabling the
	     view finder in a single binary in a capture flow. The
	     vf-pp stage has been removed for Skycam in the solution
	     provided. The vf-pp stage should be re-introduced when
	     required. Thisshould not be considered as a clean solution.
	     Proper   investigation should be done to come up with the clean
	     solution.
	 When the input system is 2401, only the Direct Sensor Mode
	     Offline Capture uses the ISP copy binary.
 ISP Copy 
		The ref frame expects
		    	1. Y plane
		    	2. UV plane with line interleaving, like below
		    		UUUUUU(width2 times) VVVVVVVV..(width2 times)
		    
		    	This format is not YUV420(which has Y, U and V planes).
		    	Its closer to NV12, except that the UV plane has UV
		    	interleaving, like UVUVUVUVUVUVUVUVU...
		    
		    	TODO: make this ref_frame format as a separate frame format
		The ref frame expects
		    	1. Y plane
		    	2. UV plane with line interleaving, like below
		    		UUUUUU(width2 times) VVVVVVVV..(width2 times)
		    
		    	This format is not YUV420(which has Y, U and V planes).
		    	Its closer to NV12, except that the UV plane has UV
		    	interleaving, like UVUVUVUVUVUVUVUVU...
		    
		    	TODO: make this ref_frame format as a separate frame format
 we build up the pipeline starting at the end 
 Capture post-processing 
 Post-gdc 
 Gdc 
 Pre-gdc 
 Viewfinder post-processing 
 Copy 
 For CSI2+, only the direct sensor modeonline requires ISP copy 
 we build up the pipeline starting at the end 
 Capture post-processing 
 Post-anr 
 Anr 
 Pre-anr 
 Viewfinder post-processing 
 Copy 
 For CSI2+, only the direct sensor modeonline requires ISP copy 
	 in primary, advanced,low light or bayer,
 TODO: make generic function 
 A non-zero width means it is a valid output port 
 TODO: it is temporarily created from ia_css_pipe_create_cas_scaler_desc 
 which has some hard-coded knowledge which prevents reuse of the function. 
 Later, merge this with ia_css_pipe_create_cas_scaler_desc 
 We assume that this function is used only for single output port case. 
 use the same horizontal and vertical downscaling factor for simplicity 
 FIXME: merge most of this and single output version 
 Find out how much scaling we need for each output 
 use the same horizontal and vertical scaling factor for simplicity 
 Set both must_be_raw and must_be_yuv to false then yuvpp can take rgb inputs 
 we build up the pipeline starting at the end 
 Capture post-processing 
	
	     NOTES
	     - Why does the "yuvpp" pipe needs "isp_copy_binary" (i.e. ISP Copy) when
	       its input is "ATOMISP_INPUT_FORMAT_YUV422_8"?
	    
	       In most use cases, the first stage in the "yuvpp" pipe is the "yuv_scale_
	       binary". However, the "yuv_scale_binary" does NOT support the input-frame
	       format as "IA_CSS_STREAM _FORMAT_YUV422_8".
	    
	       Hence, the "isp_copy_binary" is required to be present in front of the "yuv
	       _scale_binary". It would translate the input-frame to the frame formats that
	       are supported by the "yuv_scale_binary".
	    
	       Please refer to "FrameWorkcssisppipescapture_ppcapture_pp_1.0capture_
	       pp_defs.h" for the list of input-frame formats that are supported by the
	       "yuv_scale_binary".
 !ISP2401 
  ISP2401 
		
		     NOTES
		     - Why is "pipe->pipe_settings.capture.copy_binary.online" specified?
		    
		       In some use cases, the first stage in the "yuvpp" pipe is the
		       "isp_copy_binary". The "isp_copy_binary" is designed to process
		       the input from either the system DDR or from the IPU internal VMEM.
		       So it provides the flag "online" to specify where its input is from,
		       i.e.:
		    
		          (1) "online <= true", the input is from the IPU internal VMEM.
		          (2) "online <= false", the input is from the system DDR.
		    
		       In other use cases, the first stage in the "yuvpp" pipe is the
		       "yuv_scale_binary". "The "yuv_scale_binary" is designed to process the
		       input ONLY from the system DDR. So it does not provide the flag "online"
		       to specify where its input is from.
 Viewfinder post-processing 
 multi stream video needs mipi buffers 
 PIPE_MODE_COPY has no binaries, but has output frames to outside
 PIPE_MODE_COPY has no binaries, but has output frames to outside
			 currently css does not support multiple error returns in a single function,
	 When the input system is 2401, always enable 'in_frameinfo_memory'
	     except for the following:
	     - Direct Sensor Mode Online Capture
	     - Direct Sensor Mode Continuous Capture
	     - Buffered Sensor Mode Continuous Capture
 Construct in_frame info (only in case we have dynamic input 
	 the input frame can come from:
	      a) memory: connect yuvscaler to me->in_frame
 TODO: improve for different input formats. 
		
		     "pipe->stream->config.input_config.format" represents the sensor output
		     frame format, e.g. YUV422 8-bit.
		    
		     "in_frame_format" represents the imaging pipe's input frame format, e.g.
		     Bayer-Quad RAW.
			
			     When the sensor output frame format is "ATOMISP_INPUT_FORMAT_YUV422_8",
			     the "isp_copy_var" binary is selected as the first stage in the yuvpp
			     pipe.
			    
			     For the "isp_copy_var" binary, it reads the YUV422-8 pixels from
			     the frame buffer (at DDR) to the frame-line buffer (at VMEM).
			    
			     By now, the "isp_copy_var" binary does NOT provide a separated
			     frame-line buffer to store the YUV422-8 pixels. Instead, it stores
			     the YUV422-8 pixels in the frame-line buffer which is designed to
			     store the Bayer-Quad RAW pixels.
			    
			     To direct the "isp_copy_var" binary reading from the RAW frame-line
			     buffer, its input frame format must be specified as "IA_CSS_FRAME_
			     FORMAT_RAW".
 Construct vf_frame info (only in case we have VF) 
 After isp copy is enabled in_frame needs to be passed. 
 if we use yuv scaler binary, vf output should be from there 
 for yuvpp pipe, it should always be enabled 
 connect output of copy binary to input of yuv scaler 
 we use output port 1 as internal output port 
 pipeline already created as part of create_host_pipeline_structure 
 Construct out_frame info 
 Construct out_frame info 
	 When the input system is 2401, always enable 'in_frameinfo_memory'
	     except for the following:
	     - Direct Sensor Mode Online Capture
	     - Direct Sensor Mode Online Capture
	     - Direct Sensor Mode Continuous Capture
	     - Buffered Sensor Mode Continuous Capture
 Construct in_frame info (only in case we have dynamic input 
 Construct vf_frame info (only in case we have VF) 
 These modes don't support viewfinder output 
			
			     WARNING: The #if def flag has been added below as a
			     temporary solution to solve the problem of enabling the
			     view finder in a single binary in a capture flow. The
			     vf-pp stage has been removed from Skycam in the solution
			     provided. The vf-pp stage should be re-introduced when
			     required. This   should not be considered as a clean solution.
			     Proper investigation should be done to come up with the clean
			     solution.
		 If we use copy iso primary,
 ldc and capture_pp not supported in same pipeline 
 we use output port 1 as internal output port 
	
	     WARNING: The #if def flag has been added below as a
	     temporary solution to solve the problem of enabling the
	     view finder in a single binary in a capture flow. The vf-pp
	     stage has been removed from Skycam in the solution provided.
	     The vf-pp stage should be re-introduced when required. This
	     should not be considered as a clean solution. Proper
	     investigation should be done to come up with the clean solution.
 old isys: need to send_mipi_frames() in all pipe modes 
	
	     old isys: for IA_CSS_PIPE_MODE_COPY pipe, isys rx has to be configured,
	     which is currently done in start_binary(); but COPY pipe contains no binary,
	     and does not call start_binary(); so we need to configure the rx here.
firmware->next = NULL; 
 removing single and multiple firmware is handled in acc_unload_extension() 
 should not happen 
 unload and remove multiple firmwares 
 Load firmware for extension 
 Unload firmware for extension 
 In QoS case, load_extension already called, so skipping 
     @brief Tag a specific frame in continuous capture.
     Refer to "sh_css_internal.h" for details.
 Only continuous streams have a tagger 
 SP is not running. The queues are not valid 
 Create the tag descriptor from the parameters 
 Encode the tag descriptor into a 32-bit value 
	 Enqueue the encoded tag to the host2sp queue.
	     Note: The pipe and stage IDs for tag_cmd queue are hard-coded to 0
	     on both host and the SP side.
     @brief Configure the continuous capture.
     Refer to "sh_css_internal.h" for details.
 Check if the tag descriptor is valid 
 Create the tag descriptor from the parameters 
 Encode the tag descriptor into a 32-bit value 
 SP is not running. The queues are not valid 
	 Enqueue the encoded tag to the host2sp queue.
	     Note: The pipe and stage IDs for tag_cmd queue are hard-coded to 0
	     on both host and the SP side.
 Suppres warnings in CRUN 
  create the internal structures and fill in the configuration data
	 temporary default value for backwards compatibility.
	     This field used to be hardcoded within CSS but this has now
 There is not meaning for num_execs = 0 semantically. Run atleast once. 
 do not allow to create more than the maximum limit 
 now we have a pipe structure to fill 
		 Temporary hack to migrate acceleration to CSS 2.0.
		     In the future the code for all pipe types should be
 if no acc binary and no standalone stage 
 Use config value when dvs_frame_delay setting equal to 2, otherwise always 1 by default 
	 we still keep enable_raw_binning for backward compatibility, for any new
	    fractional bayer downscaling, we should use bayer_ds_out_res. if both are
	    specified, bayer_ds_out_res will take precedence.if none is specified, we
	    set bayer_ds_out_res equal to IF output resolution(IF may do cropping on
 fill some code here, if no code is needed, please remove it during integration 
 YUV downscaling 
 handle bayer downscaling output info 
 handle output info, assume always needed 
 handle vf output info, when configured 
 set all info to zeroes first 
 all went well, return the pipe 
 we succeeded return the info 
 Configuration of INPUT_SYSTEM_VERSION_2401 is done on SP 
 AM: this code is not reliable, especially for 2400 
		 not implemented yet, requires extension of the rx_cfg_t
 Map SP threads before doing anything. 
 Either both width and height should be set or neither 
	 We round up the stride to a multiple of the width
 ISP2401 
 some checks 
 We don't support metadata for JPEG stream, since they both use str2mem 
 check if mipi size specified 
 Temp change: Default for backwards compatibility. 
 Currently we only supported metadata up to a certain size. 
 allocate the stream instance 
 default all to 0 
 allocate pipes 
 store pipes 
 take over stream config 
 in case driver doesn't configure init number of raw buffers, configure it here 
 Enable locking & unlocking of buffers in RAW buffer pool 
 copy mode specific stuff 
 set current stream 
 take over effective info 
			 The aspect ratio cropping is currently only
					 in case of error fallback to default
 sensor binning 
 loop over pipes 
	 Temporary hack: we give the preview pipe a reference to the capture
 Search for the preview pipe and create the copy pipe 
 Create copy pipe here, since it may not be exposed to the driver 
 preview + QoS case will not need cont_capt switch 
 We do not support preview and video pipe at the same time 
 set current stream 
 take over effective info 
 sensor binning per pipe 
 now pipes have been configured, info should be available 
 handle each pipe 
 Map SP threads before doing anything. 
 Create host side pipeline objects without stages 
 assign curr_stream 
 working mode: enter into the seed list 
 get the SP thread id 
 get the target input terminal 
				 free any mipi frames that are remaining:
				     some test stream create-destroy cycles do not generate output frames
				     and the mipi buffer is not freed in the deque function
 remove references from pipes to stream 
 clear reference to stream 
 check internal copy pipe 
 free associated memory of stream struct 
 working mode: take out of the seed list 
     Rebuild a stream, including allocating structs, setting configuration and
     building the required pipes.
     The data is taken from the css_save struct updated upon stream creation.
     The stream handle is used to identify the correct entry in the css_save struct
 TODO remove function - DEPRECATED 
 Create host side pipeline. 
 Initialize mipi size checks 
 De-initialize mipi size checks 
	 Ideally, unmapping should happen after pipeline_stop, but current
 err = map_sp_threads(stream, false); 
 ISP2400 
     Destroy the stream and all the pipes related to it.
     The stream handle is used to identify the correct entry in the css_save struct
 some checks 
 First we find the video pipe 
 set the config also just in case (redundant info? why do we save config in pipe?) 
	 KW was not sure this function was not returning a value
	    that was out of range; so added an assert, and, for the
	    case when asserts are not enabled, clip to the largest
	    value; pipe_num is unsigned so the value cannot be too small
 waiting for the SP is completely started 
 Workaround, in order to run two streams in parallel. See TASK 4271
 TODO: Fix this. 
 buffers should be initialized only when sp is started 
 AM: At the moment it will be done only when there is no stream active. 
    	Time to wait SP for termincate. Only condition when this can happen
    	is a fatal hw failure, but we must be able to detect this and emit
    	a proper error trace.
 Return an error - stop SP should not have been called by driver 
 For now, stop whole SP 
 clear pending param sets from refcount 
 map required buffer queues to resources 
 TODO: to be improved 
 currently we support configuration on frame enqueue only on YUV formats 
 on other formats the padded_width is zeroed for no configuration override 
 nothing to do if width == padded width or padded width is zeroed (the same) 
	 Only continuous streams have a tagger to which we can send the
	 Send the event. Since we verified that the exp_id is valid,
 @brief	Set the state (Enable or Disable) of the Extension stage in the
    		given pipe.
 Parameter Check 
 Query the threadid and stage_num for the Extension firmware
 Set the Extension State;. TODO: Add check for stage firmware.type (QOS)
	@brief	Get the state (Enable or Disable) of the Extension stage in the
    	given pipe.
 Parameter Check 
 Query the threadid and stage_num corresponding to the Extension firmware
 Get the Extension State 
 ISP2401 
 Parameter Check 
 Query the thread_id and stage_num corresponding to the Extension firmware 
 Get the Extension State 
 Update mapped arg only when extension stage is not enabled 
		 in case of error fallback to default
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 for memcpy() 
 PMEM_WIDTH_LOG2 
  The string STR is a place holder
  which will be replaced with the actual RELEASE_VERSION
  during package generation. Please do not modify
 Only ISP blob info (no SP) 
 This includes 1 SP binary 
  Split the loaded firmware into blobs
 Setup spsp1 binary 
 Special case: only one binary in fw 
 sanity check 
 sanity check, note the padding bytes added for section to DDR alignment 
 copy ia_css_memory_offsets 
 copy ia_css_config_memory_offsets 
 copy ia_css_state_memory_offsets 
 For now, let's just accept a wrong version, even if wrong 
 some sanity checks 
 Only allocate memory for ISP blob info 
		
		  note: the var below is made static as it is quite large;
		  if it is not static it ends up on the stack which could
		  cause issues for drivers
			
			  All subsequent binaries
			  (including bootloaders) (i>NUM_OF_SPS)
			  are ISP firmware
 cannot happen but KW does not see this 
 release firmware minibuffer 
	
	  this will allocate memory aligned to a DDR word boundary which
	  is required for the CSS DMA to read the instructions.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 System independent 
	
	  Wait till SP is idle or till there is a SW2 interrupt
	  The SW2 interrupt will be used when frameloop runs on SP
	  and signals an event with similar meaning as SP idle
	  (e.g. frame_done)
 SPDX-License-Identifier: GPL-2.0
  Support for Medifield PNW Camera Imaging ISP subsystem.
  Copyright (c) 2010 Intel Corporation. All Rights Reserved.
  Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 max size 15 
 max size 31 
  FIXME: ISP should not know beforehand all CIDs supported by sensor.
  Instead, it needs to propagate to sensor unkonwn CIDs.
  supported V4L2 fmts and resolutions
 This one is for parallel sensors! DO NOT USE! 
 This is a custom format being used by M10MO to send the RAW data 
  v4l2 ioctls
  return ISP capabilities
  enum input are used to check primarysecondary camera
	
	  HACK: append actuator's name to sensor's
	  As currently userspace can't talk directly to subdev nodes, this
	  ioctl is the only way to enum inputs + possible external actuators
	  for 3A tuning purpose.
  get input are used to get current primarysecondary camera
  set input are used to set current primarysecondary camera
	
	  check whether the request camera:
	  1: already in use
	  2: if in use, whether it is used by other streams
 power off the current owned sensor, as it is not used this time 
 clear the asd field to show this camera is not used 
 powe on the new sensor 
	
	  Some sensor driver resets the run mode during power-on, thus force
	  update the run mode to sensor after power-on.
 select operating sensor 
 mark this camera is used by the current stream 
	rval = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
				video, enum_mbus_fmt, 0, &code.code);
		
		  Is the atomisp-supported format is valid for the
		  sensor (configuration)? If not, skip it.
 Found a match. Now let's pick f->index'th one. 
 This function looks up the closest available resolution. 
  Free videobuffer buffer priv data
  this function is used to free video buffer queue
  Initiate Memory Mapping or User Pointer IO
 clear request config id 
	
	  for user pointer type, buffers are not really allocated here,
	  buffers are setup in QBUF operation through v4l2_buffer structure
	
	  Allocate the real frame here for selected node using our
	  memory management function
 application query the status of a buffer 
  Applications call the VIDIOC_QBUF ioctl to enqueue an empty (capturing) or
  filled (output) buffer in the drivers incoming queue.
	
	  For userptr type frame, we convert user space address to physic
	  address and reprograme out page table properly
		
		  For mmap, frames were allocated at request buffers
 this buffer will have a per-frame parameter 
 TODO: do this better, not best way to queue to css 
	
	  Workaround: Due to the design of HALv3,
	  sometimes in ZSL or SDV mode HAL needs to
	  capture multiple images within one streaming cycle.
	  But the capture number cannot be determined by HAL.
	  So HAL only sets the capture number to be 1 and queue multiple
	  buffers. Atomisp driver needs to check this case and re-trigger
	  CSS to do capture when new buffer is queued.
  Applications call the VIDIOC_DQBUF ioctl to dequeue a filled (capturing) or
  displayed (output buffer)from the driver's outgoing queue
	
	  Hack:
	  Currently frame_status in the enum type which takes no more lower
	  8 bit.
	  use bit[31:16] for exp_id as it is only in the range of 1~255
	
	  Disable vf_pp and run CSS in video mode. This allows using ISP
	  scaling but it has one frame delay due to CSS internal buffering.
	
	  Disable vf_pp and run CSS in still capture mode. In this mode
	  CSS does not cause extra latency with buffering, but scaling
	  is not available.
	
	  ISP only support 2 streams now so ignore multiple masterslave
	  case to reduce the delay between 2 stream_on calls.
 FIXME! ISP2400 
 FIXME! ISP2401 
 Input system HW workaround 
 Input system address translation corrupts burst during 
 invalidate. SW workaround for this is to set burst length 
 manually to 128 in case of 13MPx snapshot and to 1 otherwise. 
  This ioctl start the capture during streaming IO.
 Input system HW workaround 
	
	  The number of streaming video nodes is based on which
	  binary is going to be run.
 Reset pending capture request count. 
 trigger still capture 
 handle per_frame_setting parameter and buffers 
			
			  only ZSLSDV capture request will be here, raise
			  the ISP freq to the highest possible to minimize
			  the S2S latency.
			
			  When asd->enable_raw_buffer_lock->val is true,
			  An extra IOCTL is needed to call
			  atomisp_css_exp_id_capture and trigger real capture
 handle per_frame_setting parameter and buffers 
 Only start sensor when the last streaming instance started 
		
		  set freq to max when streaming count > 1 which indicate
		  dual camera would run
 Enable the CSI interface on ANN B0K0 
 stream on the sensor 
	
	  do only videobuf_streamoff for capture & vf pipes in
	  case of continuous capture
 stop continuous still capture if needed 
		
		  Currently there is no way to flush buffers queued to css.
		  When doing videobuf_streamoff, active buffers will be
		  marked as VIDEOBUF_NEEDS_INIT. HAL will be able to use
		  these buffers again, and these buffers might be queued to
		  css more than once! Warn here, if HAL has not dequeued all
		  buffers back before calling streamoff.
			
			  Buffers remained in css maybe dequeued out in the
			  next stream on, while this will causes serious
			  issues as buffers already get invalid after
			  previous stream off.
			 
			  No way to flush buffers but to reset the whole css
 if other streams are running, should not disable watch dog 
		
		  must stop sending pixels into GP_FIFO before stop
		  the pipeline.
 cancel work queue
 cleanup css here 
 no need for this, as ISP will be reset anyway 
atomisp_flush_bufs_in_css(isp);
 if other streams are running, isp should not be powered off 
 Disable the CSI interface on ANN B0K0 
	
	  ISP work around, need to reset isp
	  Is it correct time to reset ISP when first node does streamoff?
		
		  It is possible that the other asd stream is in the stage
		  that v4l2_setfmt is just get called on it, which will
		  create css stream on that stream. But at this point, there
		  is no way to destroy the css stream created on that stream.
		 
		  So force stream destroy here.
 disable  PUNITISP acknowledehandshake - SRSE=3 
  To get the current value of a control.
  applications initialize the id field of a struct v4l2_control and
  call this ioctl with a pointer to this structure
  To change the value of a control.
  applications initialize the id and value fields of a struct v4l2_control
  and call this ioctl.
  To query the attributes of a control.
  applications set the id field of a struct v4l2_queryctrl and call the
  this ioctl with a pointer to this structure. The driver fills
  the rest of the structure.
 ISP2401 
			
			  Exposure related control will be handled by sensor
			  driver
 This ioctl allows the application to get multiple controls by class 
	
	  input_lock is not need for the Camera related IOCTLs
	  The input_lock downgrade the FPS of 3A
				
				  When flash mode is changed we need to reset
				  flash state
 This ioctl allows the application to set multiple controls by class 
	
	  input_lock is not need for the Camera related IOCTLs
	  The input_lock downgrade the FPS of 3A
  vidioc_gs_param are used to switch isp running mode
 we do not need take isp->mutex for these IOCTLs 
 SPDX-License-Identifier: GPL-2.0
  Support for Medifield PNW Camera Imaging ISP subsystem.
  Copyright (c) 2010 Intel Corporation. All Rights Reserved.
  Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 We should never need to run the flash for more than 2 frames.
  At 15fps this means 133ms. We set the timeout a bit longer.
  Each flash driver is supposed to set its own timeout, but
  just in case someone else changed the timeout, we set it
 ms 
  get sensor:dis71430ov2720 related info from v4l2_subdev->priv data field.
  subdev->priv is set in mrst.c
  get struct atomisp_video_pipe from v4l2 video_device
  get struct atomisp_acc_pipe from v4l2 video_device
  DFS progress is shown as follows:
  1. Target frequency is calculated according to FPSResolutionISP running
     mode.
  2. Ratio is calculated using formula: 2  HPLL  target frequency - 1
     with proper rounding.
  3. Set ratio to ISPFREQ40, 1 to FREQVALID and ISPFREQGUAR40
     to 200MHz in ISPSSPM1.
  4. Wait for FREQVALID to be cleared by P-Unit.
  5. Wait for field ISPFREQSTAT40 in ISPSSPM1 turn to ratio set in 3.
 FIXME! Only use subdev[0] status yet 
	
	  For continuous mode, we need to make the capture setting applied
	  since preview mode, because there is no chance to do this when
	  starting image capture.
 search for the target frequency by looping freq rules
  reset and restore ISP
 Reset ISP by power-cycling it 
  interrupt disable functions
  interrupt clean function
 Clear irq reg 
 Check which isp subdev to send eof 
 interrupt handling function
		
		  Current SOF only support one stream, so the SOF only valid
		  either solely one stream is running
			 If sequence_temp and sequence are the same
			  there where no frames lost so we can increase
			  sequence_temp.
			  If not then processing of frame is still in progress
			  and driver needs to keep old sequence_temp value.
			  NOTE: There is assumption here that ISP will not
			  start processing next frame from sensor before old
 handle mipi receiver error 
 EOF Event does not have the css_pipe returned 
 ISP2400 
 ISP2401 
 0x100000 is the start of dmem inside SP 
 Returns queued buffers back to video-core 
 clean out the parameters that did not apply 
 Re-queue per-frame parameters 
 find atomisp_video_pipe with css pipe id, buffer type and atomisp run_mode 
 video is same in online as in continuouscapture mode 
		
		  Disable vf_pp and run CSS in still capture mode. In this
		  mode, CSS does not cause extra latency with buffering, but
		  scaling is not available.
		
		  Disable vf_pp and run CSS in video mode. This allows using
		  ISP scaling but it has one frame delay due to CSS internal
		  buffering.
		
		  to SOC camera, yuvpp pipe is run for capturevideoSDVZSL.
 SDV case 
 ZSL case 
 For online video or SDV video pipe. 
 For online preview or ZSL preview pipe. 
 For capture pipe. 
 online capture pipe 
 need to know the atomisp pipe for frame buffers 
		 FIXME:
		  YUVPP doesn't set postview exp_id correctlly in SDV mode.
		  This is a WORKAROUND to set exp_id. see HSDES-1503911606.
		 FIXME:
		  YUVPP doesn't set preview exp_id correctlly in ZSL mode.
		  This is a WORKAROUND to set exp_id. see HSDES-1503911606.
 free the parameters 
 Check if flashing sequence is done 
		
		  Only after enabled the raw buffer lock
		  and in continuous mode.
		  in previewvideo pipe, each buffer will
		  be locked automatically, so record it here.
			 New global dvs 6axis config should be blocked
			  here if there's a buffer with per-frame parameters
			  pending in CSS frame buffer queue.
			  This is to aviod zooming vibration since global
			  parameters take effect immediately while
			  per-frame parameters are taken after previous
			  buffers in CSS got processed.
			 The update flag should not be cleaned here
			  since it is still going to be used to make up
			  following per-frame parameters.
			  This will introduce more copy work since each
			  time when updating global parameters, the whole
			  parameter set are applied.
			  FIXME: A new set of parameter copy functions can
			  be added to make up per-frame parameters based on
			  solid structures stored in asd->params.css_param
			  instead of using shadow pointers in update flag.
mark videobuffer done for dequeue
		
		  Frame capture done, wake up any process block on
		  current active buffer
		  possibly hold by videobuf_dqbuf()
	
	  Requeue should only be done for 3a and dis buffers.
	  Queuedequeue order will change if driver recycles image buffers.
		 If there are no buffers queued then
 SOF irq should not reset wdt timer. 
	
	  to SOC camera, use yuvpp pipe and no support continuous mode.
 signal streamon after delayed init is done 
		
		 AtomISP::waitStageUpdate is blocked when WDT happens.
		 By calling acc_done() for all loaded fw_handles,
		 HAL will be unblocked.
 stream off sensor 
 notify HAL the CSS reset 
 clear irq 
 Set the SRSE to 3 before resetting 
 reset ISP and restore its state 
		
		  dequeueing buffers is not needed. CSS will recycle
		  buffers that it has.
 Requeue unprocessed per-frame parameters. 
sh_css_dump_sp_state();
sh_css_dump_isp_state();
 Disable wdt 
 Start recover 
 Restore wdt 
 ISP2400 
 ISP2401 
 Override next if it has been pushed beyon the "next" time 
 Override next if it has been pushed beyon the "next" time 
 ISP2401 
 ISP 2401 
 make sure the timeout is set before setting flash mode 
	
	  The standard CSS2.0 API tells the following calling sequence of
	  dequeue ready buffers:
	  while (ia_css_dequeue_event(...)) {
	 	switch (event.type) {
	 	...
	 	ia_css_pipe_dequeue_buffer()
	 	}
	  }
	  That is, dequeue event and buffer are one after another.
	 
	  But the following implementation is to first deuque all the event
	  to a FIFO, then process the event in the FIFO.
	  This will not have issue in single stream mode, but it do have some
	  issue in multiple stream case. The issue is that
	  ia_css_pipe_dequeue_buffer() will not return the corrent buffer in
	  a specific pipe.
	 
	  This is due to ia_css_pipe_dequeue_buffer() does not take the
	  ia_css_pipe parameter.
	 
	  So:
	  For CSS2.0: we change the way to not dequeue all the event at one
	  time, instead, dequue one and process one, then another
 FIXME! FIX ACC implementation 
  utils for buffer allocationfree
  Get internal fmt according to V4L2 fmt
  raw format match between SH format and V4L2 format
 raw type now 
  ISP features control function
  Set ISP capture mode based on current settings
 ISP2401 
  Function to enabledisable lens geometry distortion correction (GDC) and
  chromatic aberration correction (CAC)
  Function to enabledisable low light mode including ANR
  Function to enabledisable extra noise reduction (XNR) in low light
  condition
  Function to configure bayer noise reduction
 Get nr config from current setup 
 Set nr config to isp parameters 
  Function to configure temporal noise reduction (TNR)
 Get tnr config from current setup 
 Get tnr config from current setup 
 Set tnr config to isp parameters 
  Function to configure black level compensation
 Get ob config from current setup 
 Set ob config to isp parameters 
  Function to configure edge enhancement
 Get ee config from current setup 
 Set ee config to isp parameters 
  Function to update Gamma table for gamma, brightness and contrast config
 Get gamma table from current setup 
 Set gamma table to isp parameters 
  Function to update Ctc table for Chroma Enhancement
 Get ctc table from current setup 
 Set ctc table to isp parameters 
  Function to update gamma correction parameters
 Get gamma correction params from current setup 
 Set gamma correction params to isp parameters 
  Function to update narrow gamma flag
 Get narrow gamma flag from current setup 
 Set narrow gamma flag to isp parameters 
	 We must free all buffers because they no longer match
 Failure for 3A buffers does not influence DIS buffers 
			 For SOC sensor happens s3a_output_bytes == 0,
  Function to update Gdc table for gdc
 Get gdc table from current setup 
 free first if we have one 
 allocate new one 
 Get macc table from current setup 
  Function to setget image stablization statistics
  Function  set camrea_prefiles.xml current sensor pixel array size
  Function to get DVS2 BQ resolution settings
 the GDC output resolution 
 the GDC input resolution 
		
		  Bad pixels caused by spatial filter processing
		  ISP filter resolution should be given by CSSFW, but for now
		  there is not such API to query, and it is fixed value, so
		  hardcoded here.
 spatial filter shift, always 4 pixels 
		 For GDC:
		  gdc_effective_input = effective_input + envelope
		 
		  From the comment and formula in BZ1786,
		  we see the source_bq should be:
		  effective_input  bayer_ds_ratio
			
			  We adjust the ispfilter_bq to:
			  ispfilter_bq = 128BDS
			  we still need firmware team to provide an offical
			  formula for SDV.
 No additional left padding for ISYS2401 
				
				  For the w_padding and gdc_shift_bq cacluation
				  Please see the BZ 1786 and 4358 for more info.
				  Just test that this formula can work now,
				  but we still have no offical formula.
				 
				  w_padding = ceiling(gdc_effective_input
				              128, 1)  128 - effective_width
				  gdc_shift_bq = w_paddingBDS2 + ispfilter_bq2
 No additional left padding for ISYS2401 
  Function to setget 3A stat from isp
 sanity check to avoid writing into unallocated memory. 
		 If the grid info in the argument differs from the current
		   grid info, we tell the caller to reset the grid size and
 Move to free buffer list 
	 We always return the resolution and stride even if there is
	  no valid metadata. This allows the caller to get the information
	 sanity check to avoid writing into unallocated memory.
	  This does not return an error because it is a valid way
 This is done in the atomisp_buf_done() 
	 We always return the resolution and stride even if there is
	  no valid metadata. This allows the caller to get the information
	 sanity check to avoid writing into unallocated memory.
	  This does not return an error because it is a valid way
 This is done in the atomisp_buf_done() 
  Function to calculate real zoom region for every pipe
no need crop region
	 FIXME:
	  This is not the correct implementation with Google's definition, due
	  to firmware limitation.
	  map real crop region base on above calculating base max crop region.
		
		  Set same ratio of crop region resolution and current pipe output
		  resolution
  Function to check the zoom region whether is effective
 setting error zoom region 
	
	  These configurations are on used by ISP1.x, not for ISP2.x,
	  so do not handle them. see comments of ia_css_isp_config.
	  1 cc_config
	  2 ce_config
	  3 de_config
	  4 gc_config
	  5 gamma_table
	  6 ctc_table
	  7 dvs_coefs
	
	  These configurations are on used by ISP1.x, not for ISP2.x,
	  so do not handle them. see comments of ia_css_isp_config.
	  1 cc_config
	  2 ce_config
	  3 de_config
	  4 gc_config
	  5 gamma_table
	  6 ctc_table
	  7 dvs_coefs
 user config is to disable the shading table. 
 Generate a minimum table with enable = 0. 
 Setting a new table. Validate first - all tables must be set 
 Shading table size per color 
 No need to update shading table if it is the same 
 set LSC to CSS 
			 If the grid info in the argument differs from the current
			grid info, we tell the caller to reset the grid size and
 DIS coefficients. 
			 If the grid info in the argument differs from the current
			grid info, we tell the caller to reset the grid size and
 DIS coefficients. 
 check whether need to reallocate for 6 axis config 
  Check parameter queue list and buffer queue list to find out if matched items
  and then set parameter to CSS and enqueue buffer to CSS.
  Of course, if the buffer in buffer waiting list is not bound to a per-frame
  parameter, it will be enqueued into CSS as long as the per-frame setting
  buffers before it get enqueued.
	
	  CSSFW requires set parameter and enqueue buffer happen after ISP
	  is streamon.
				
				  clear the request config id as the buffer
				  will be handled and enqueued into CSS soon
 The is the end, stop further loop 
 Function to configure ISP parameters
		
		  Per-frame setting enabled, we allocate a new parameter
		  buffer to cache the parameters and only when frame buffers
		  are ready, the parameters will be set to CSS.
		  per-frame setting only works for the main output frame.
 indicate to CSS that we have parameters to be updated 
  Function to setget isp parameters to isp
 Read parameter for 3A binary info 
		 We always return the resolution and stride even if there is
		  no valid metadata. This allows the caller to get the
 update dvs grid info 
 update dvs envelop info 
  Function to configure color effect of the image
	
	  if set color effect to sensor successfully, return
	  0 directly.
	
	  isp_subdev->params.macc_en should be set to false.
  Function to configure bad pixel correction
  Function to configure bad pixel correction params
 Get bad pixel from current setup 
 Set bad pixel to isp parameters 
  Function to enabledisable video image stablization
  Function to configure fixed pattern noise
 Add function to get black from from sensor with shutter off 
	 The following cases could be removed, but we leave them
	 Note: the padded width on an ia_css_frame is in elements, not in
	   bytes. The RAW frame we use here should always be a 16bit RAW
  Function to configure fixed pattern noise table
  Function to configure false color correction
 Get nr config from current setup 
 Set nr config to isp parameters 
  Function to configure bad pixel correction params
 Get false color from current setup 
 Set false color to isp parameters 
  Function to configure white balance params
 Get white balance from current setup 
 Set white balance to isp parameters 
 Get white balance from current setup 
 Set white balance to isp parameters 
  Function to setup digital zoom
  Function to get sensor specific info for current resolution,
  which will be used for auto exposure conversion.
 assign virtual channel id return from sensor driver query 
 This function looks up the closest available resolution. 
	
	  If the format is jpeg or custom RAW, then the width and height will
	  not satisfy the normal atomisp requirements and no need to check
	  the below conditions. So just assign to what is being returned from
	  the sensor driver.
		 Set the flag when resolution requested is
		  beyond the max value supported by sensor
 app vs isp 
	 Compatibility for sensors which provide no media bus code
 Input stream config is still needs configured 
 TODO: Check if this is necessary 
 in case of ANR, force capture pipe to offline mode 
  Resets CSS parameters that depend on input resolution.
  Update params like CSS RAW binning, 2ppc mode and pp_input
  which depend on input size, but are not automatically
  handled in CSS when the input resolution is changed.
 Note for all checks: ffmt includes pad_w+pad_h 
			
			  For preview pipe, enable only if resolution
			  is >= 3M for ISP2400.
	
	  If sensor input changed, which means metadata resolution changed
	  together. Release all metadata buffers here to let it re-allocated
	  next time in reqbufs.
	
	  TODO: atomisp_css_preview_configure_pp_input() not
	        reset due to CSS bug tracked as PSI BZ 115124
	
	  Configure viewfinder also when vfpp is disabled: the
	  CSS still requires viewfinder configuration.
		 FIXME: proper format name for this one. See
 ISP2401 new input system need to use copy pipe 
 video same in continuouscapture and online modes 
		 CSS doesn't support low light mode on SOC cameras, so disable
		  it. FIXME: if this is done elsewhere, it gives corrupted
		  colors into thumbnail image.
 in case of ANR, force capture pipe to offline mode 
	
	  to SOC camera, use yuvpp pipe.
 Free the raw_dump buffer first 
 if subdev type is SOC camera,we do not need to set DVS 
 envelope is 20% of the output resolution 
		
		  dvs envelope cannot be round up.
		  it would cause ISP timeout and color switch issue
 Only used for the new input system 
 Disable dvs if resolution can't be supported by sensor 
 For M10MO outputing YUV preview images. 
				
				  If viewfinder was configured into copy_mode,
				  we switch to using yuvpp pipe instead.
	
	  Check whether main resolution configured smaller
	  than snapshot resolution. If so, force main resolution
	  to be the same as snapshot resolution
 Pipeline configuration done through subdevs. Bail out now. 
 get sensor resolution and format 
 construct resolution supported by isp 
		
		  The ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE should get resolutions
		  properly set otherwise, it should not be the capture_pad.
	
	  set format info to sensor
	  In continuous mode, resolution is set only if it is higher than
	  existing value. This because preview pipe will be configured after
	  capture pipe and usually has lower resolution than capture pipe.
		
		  For jpeg or custom raw format the sensor will return constant
		  width and height. Because we already had quried try_mbus_fmt,
		  f->fmt.pix.width and f->fmt.pix.height has been changed to
		  this fixed width and height. So we cannot select the correct
		  resolution with that information. So use the original width
		  and height while set_mbus_fmt() so actual resolutions are
		  being used in while set media bus format.
 Reset variable 
	 Try to enable YUV downscaling if ISP input is 10 % (either
		 for continuous mode, preview size might be smaller than
		  still capture size. if preview size still needs crop,
		  pick the larger one between crop size of preview and
		  still capture.
		 WORKAROUND: this override is universally enabled in
		  GMIN to work around a CTS failures (GMINL-539)
		  which appears to be related by a hardware
		  performance limitation.  It's unclear why this
	
	  If in video 480P case, no GFX throttle
 If enabling, all tables must be set 
 Shading table size per color 
Turn off ISP dphy 
 if ISP timeout, we can force powerdown 
	
	  MRFLD IUNIT DPHY is located in an always-power-on island
	  MRFLD HW design need all CSI ports are disabled before
	  powering down the IUNIT.
Turn on ISP dphy 
	
	 In case of M10MO ZSL capture case, we need to issue a separate
	 capture request to M10MO which will output captured jpeg image
 TODO: use the cvf_config 
			 TODO: this can be removed once user-space
  set auto exposure metering window to camera sensor
 Coverity CID 298071 - initialzize struct 
 a requested flash is still in progress. 
 Check if the raw buffer after next is still locked!!! 
 WORKAROUND unlock the raw buffer compulsively 
 fail through 
 External ISP 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
Initialize new struct with latest config settings
 UV = Y2, depens on colour format YUV 4.2.0
 UV = Y2, depens on colour format YUV 4.2.0
 Generate Y buffers  
 Generate UV buffers  
 we might have allocated some memory, release this 
 Envelope dimensions set in Ypixels hence offset UV = offset Y2 
 Envelope dimensions set in Ypixels hence offset UV = offset Y2 
 Free up UV buffers 
 = Y2, depens on colour format YUV 4.2.0
 SPDX-License-Identifier: GPL-2.0
  Support for Medifield PNW Camera Imaging ISP subsystem.
  Copyright (c) 2010 Intel Corporation. All Rights Reserved.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  csi2_enum_mbus_code - Handle pixel format enumeration
  @sd     : pointer to v4l2 subdev structure
  @fh     : V4L2 subdev file handle
  @code   : pointer to v4l2_subdev_pad_mbus_code_enum structure
  return -EINVAL or zero on success
  csi2_get_format - Handle get format by pads subdev method
  @sd : pointer to v4l2 subdev structure
  @fh : V4L2 subdev file handle
  @pad: pad num
  @fmt: pointer to v4l2 format structure
  return -EINVAL or zero on success
 FIXME: DPCM decompression 
  csi2_set_format - Handle set format by pads subdev method
  @sd : pointer to v4l2 subdev structure
  @fh : V4L2 subdev file handle
  @pad: pad num
  @fmt: pointer to v4l2 format structure
  return -EINVAL or zero on success
  csi2_set_stream - EnableDisable streaming on the CSI2 module
  @sd: ISP CSI2 V4L2 subdevice
  @enable: Enabledisable stream (10)
  Return 0 on success or a negative error code otherwise.
 subdev core operations 
 subdev video operations 
 subdev pad operations 
 subdev operations 
  csi2_link_setup - Setup CSI2 connections.
  @entity : Pointer to media entity structure
  @local  : Pointer to local pad array
  @remote : Pointer to remote pad array
  @flags  : Link flags
  return -EINVAL or zero on success
 not supported yet 
 Link from camera to CSI2 is fixed... 
 media operations 
  ispcsi2_init_entities - Initialize subdev and media entity.
  @csi2: Pointer to ispcsi2 structure.
  return -ENOMEM or zero on success
 Register the subdev and video nodes. 
 Limit numeric range into 31 bits 
 Delay counter accuracy, 10.0625 for ANNCHT, 10.125 for BXT 
 1  COUNT_ACC 
	
	  The ISP2401 new input system CSI2+ receiver has several
	  parameters affecting the receiver timings. These depend
	  on the MIPI bus frequency F in Hz (sensor transmitter rate)
	  as follows:
	 	register value = (A1e9 + B  UI)  COUNT_ACC
	  where
	 	UI = 1  (2  F) in seconds
	 	COUNT_ACC = counter accuracy in seconds
	 	For ANN and CHV, COUNT_ACC = 0.0625 ns
	 	For BXT,  COUNT_ACC = 0.125 ns
	  A and B are coefficients from the table below,
	  depending whether the register minimum or maximum value is
	  calculated.
	 				       Minimum     Maximum
	  Clock lane			       A     B     A     B
	  reg_rx_csi_dly_cnt_termen_clane     0     0    38     0
	  reg_rx_csi_dly_cnt_settle_clane    95    -8   300   -16
	  Data lanes
	  reg_rx_csi_dly_cnt_termen_dlane0    0     0    35     4
	  reg_rx_csi_dly_cnt_settle_dlane0   85    -2   145    -6
	  reg_rx_csi_dly_cnt_termen_dlane1    0     0    35     4
	  reg_rx_csi_dly_cnt_settle_dlane1   85    -2   145    -6
	  reg_rx_csi_dly_cnt_termen_dlane2    0     0    35     4
	  reg_rx_csi_dly_cnt_settle_dlane2   85    -2   145    -6
	  reg_rx_csi_dly_cnt_termen_dlane3    0     0    35     4
	  reg_rx_csi_dly_cnt_settle_dlane3   85    -2   145    -6
	 
	  We use the minimum values in the calculations below.
 Number of lanes on each port, excluding clock lane 
  atomisp_mipi_csi2_cleanup - Routine for module driver cleanup
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Bilinear interpolation on shading tables:
  For each target point T, we calculate the 4 surrounding source points:
  ul (upper left), ur (upper right), ll (lower left) and lr (lower right).
  We then calculate the distances from the T to the source points: x0, x1,
  y0 and y1.
  We then calculate the value of T:
    dx0dy0Slr + dx0dy1Sur + dx1dy0Sll + dx1dy1Sul.
  We choose a grid size of 1x1 which means:
    dx1 = 1-dx0
    dy1 = 1-dy0
    Sul dx0         dx1      Sur
     .<----->|<------------->.
     ^
  dy0|
     v        T
     -        .
     ^
     |
  dy1|
     v
     .                        .
    Sll                      Slr
  Padding:
  The area that the ISP operates on can include padding both on the left
  and the right. We need to padd the shading table such that the shading
  values end up on the correct pixel values. This means we must padd the
  shading table to match the ISP padding.
  We can have 5 cases:
  1. All 4 points fall in the left padding.
  2. The left 2 points fall in the left padding.
  3. All 4 points fall in the cropped (target) region.
  4. The right 2 points fall in the right padding.
  5. All 4 points fall in the right padding.
  Cases 1 and 5 are easy to handle: we simply use the
  value 1 in the shading table.
  Cases 2 and 4 require interpolation that takes into
  account how far into the padding area the pixels
  fall. We extrapolate the shading table into the
  padded area and then interpolate.
 can be negative to indicate padded space 
		 calculate target point and make sure it falls within
		 calculate closest source points in shading table and
 calculate closest source points for distance computation 
 calculate distance between source and target pixels 
 calculate target point 
 calculate closest source points. 
 if src points fall in padding, select closest ones.
			 calculate closest source points for distance
			 calculate distances between source and target
			 if we're at the edge, we just use the closest
			   point still in the grid. We make up for the divider
			   in this case by setting the distance to
 get source pixel values 
 initialize table with ones, shift becomes zero 
	
	  We use the ISP input resolution for the shading table because
	  shading correction is performed in the bayer domain (before bayer
	  down scaling).
	 @deprecated{This part of the code will be replaced by the code
	  in the #else section below to make the calculation same across
	  all platforms.
	  Android and Windows platforms interpret the binning_factor parameter
	  differently. In Android, the binning factor is expressed in the form
	  2^N  2^N, whereas in Windows platform, the binning factor is NN}
	 We take into account the binning done by the sensor. We do this
	   by cropping the non-binned part of the shading table and then
	 We also scale the padding by the same binning factor. This will
	   make it much easier later on to calculate the padding of the
USE_WINDOWS_BINNING_FACTOR
	 during simulation, the used resolution can exceed the sensor
	 This prepare_shading_table() function is called only in legacy API (not in new API).
	 now we crop the original shading table and then interpolate to the
	 We only output logging when the table is not NULL, otherwise
	  logs will give the impression that a table was freed.
 SPDX-License-Identifier: GPL-2.0
  Support for Medifield PNW Camera Imaging ISP subsystem.
  Copyright (c) 2010 Intel Corporation. All Rights Reserved.
  Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 only support file injection on subdev0 
 only support file injection on subdev0 
 only support file injection on subdev0 
to fake
 to fake 
to fake
to fake
to fake
 Register the subdev and video nodes. 
 SPDX-License-Identifier: GPL-2.0
  Support for Medifield PNW Camera Imaging ISP subsystem.
  Copyright (c) 2010-2017 Intel Corporation. All Rights Reserved.
  Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 Timeouts to wait for all subdevs to be registered 
 ms 
 up to 2 seconds 
 G-Min addition: pull this in from intel_mid_pm.h 
 set reserved memory pool size in page 
 set dynamic memory pool size in page 
 memory optimization: deferred firmware loading 
 cross componnet debug message flag 
 log function switch 
set to 16x16 since this is the amount of lines and pixels the sensor
exports extra. If these are kept at the 10x8 that they were on, in yuv
downscaling modes incorrect resolutions where requested to the sensor
driver with strange outcomes as a result. The proper way tot do this
would be to have a list of tables the specify the sensor res, mipi rec,
output res, and isp output res. however since we do not have this yet,
  FIXME: this is a hack to make easier to support ISP2401 variant.
  As a given system will either be ISP2401 or not, we can just use
  a boolean, in order to replace existing #ifdef ISP2401 everywhere.
  Once this driver gets into a better shape, however, the best would
  be to replace this to something stored inside atomisp allocated
  structures.
 Merrifield and Moorefield DFS rules 
 This one should be visible also by atomisp_cmd.c 
 Initialize the video device. 
 Initialize the video device. 
 isp->saved_regs.ispmmadr is set from the atomisp_pci_probe() 
 Ensure readwrite combining is enabled. 
	
	  Hardware bugs require setting CSI_HS_OVR_CLK_GATE_ON_UPDATE.
	  ANNCHV: RCOMP updates do not happen when using CSI2+ path
	  and sensor sending "continuous clock".
	  TNGANNCHV: MIPI packets are lost if the HS entry sequence
	  is missed, and IUNIT can hang.
	  For both issues, setting this bit is a workaround.
	
	  On CHT CSI_READY bit should be enabled before stream on
	
	  for MRFLD, Softwarefirmware needs to write a 1 to bit0
	  of the register at CSI_RECEIVER_SELECTION_REG to enable
	  SH CSI backend write 0 will enable Arasan CSI backend,
	  which has bugs(like sighting:4567697 and 4567699) and
	  will be removed in B0
	
	  MRFLD HAS requirement: cannot power off i-unit if
	  ISP has IRQ not serviced.
	  So, here we need to check if there is any pending
	  IRQ, if so, waiting for it to be served
	
	 MRFLD WORKAROUND:
	 before powering off IUNIT, clear the pending interrupts
	 and disable the interrupt. driver should avoid writing 0
	 to IIR. It could block subsequent interrupt messages.
	 HW sighting:4568410.
 WA for DDR DVFS enabledisable
 By default, ISP will force DDR DVFS 1600MHz before disable DVFS
 Check Req_ACK to see freq status, wait until door_bell is cleared 
WA:Enable DVFS
	
	  FIXME:WA for ECS28A, with this sleep, CTS
	  android.hardware.camera2.cts.CameraDeviceTest#testCameraDeviceAbort
	  PASS, no impact on other platforms
 Write to ISPSSPM0 bit[1:0] to power onoff the IUNIT 
WA:Enable DVFS
	
	  There should be no IUNIT access while power-down is
	  in progress. HW sighting: 4567865.
	  Wait up to 50 ms for the IUNIT to shut down.
	  And we do the same for power on.
 Wait until ISPSSPM0 bit[25:24] shows the right value 
 FIXME: experienced value for delay 
 Workaround for pmu_nc_set_power_state not ready in MRFLD 
 Workaround for pmu_nc_set_power_state not ready in MRFLD 
Turn off the ISP d-phy
Turn on ISP d-phy 
restore register values for iUnit and iUnitPHY registers
 FIXME: only has one isp_subdev at present 
	
	  FIXME: Suspend is not supported by sensors. Abort if any video
	  node was opened.
Turn off the ISP d-phy 
Turn on ISP d-phy 
restore register values for iUnit and iUnitPHY registers
 TangierMerrifield available lane configurations 
 00000 
 00001 
 00010 
 00011 
 00100 
 01000 
 01001 
 01010 
 AnniedaleMoorefield only configurations 
 10000 
 10001 
 10010 
 10011 
 10100 
 11000 
 11001 
 11010 
 Merrifield 
 Moorefield  Cherryview 
 Merrifield  Moorefield legacy input system 
 Moorefield  Cherryview new input system 
 Found matching setting 
 FIXME: should return -EPROBE_DEFER if not all subdevs were probed 
 Wait more time to give more time for subdev init code to finish 
 FIXME: should, instead, use I2C probe 
		 In G-Min, the sensor devices will already be probed
		  (via ACPI) and registered, do not create new
			
			  initialize the subdev frame size, then next we can
			  judge whether frame_size store effective value via
			  pixel_format.
	
	  HACK: Currently VCM belongs to primary sensor only, but correct
	  approach must be to acquire from platform code which sensor
	  owns it.
 Proceed even if no modules detected. For COS mode and no modules. 
 Register internal entities 
 error case 
 deregister all registered CSI ports 
  Check for flags the driver was compiled with against the PCI
  device. Always returns true on other than ISP 2400.
	
	  FIXME:
	  remove the if once the driver become generic
 Pointer to struct device. 
 This is not a true PCI device on SoC, so the delay is not needed. 
		
		  Note: some Intel-based tablets with Android use a different
		  DFS table. Based on the comments at the Yocto Aero meta
		  version of this driver (at the ssid.h header), they're
		  identified via a "spid" var:
		 
		 	androidboot.spid=vend:cust:manu:plat:prod:hard
		 
		  As we don't have this upstream, nor we know enough details
		  to use a DMI or PCI match table, the old code was just
		  removed, but let's keep a note here as a reminder that,
		  for certain devices, we may need to limit the max DFS
		  frequency to be below certain values, adjusting the
		  resolution accordingly.
		
		  HPLL frequency is known to be device-specific, but we don't
		  have specs yet for exactly how it varies.  Default to
		  BYT-CR but let provisioning set it via EFI variable
		
		  for BYTCHT we are put isp into D3cold to avoid pci registers access
		  in power off. Set d3cold_delay to 0 since default 100ms is not
		  necessary.
 Load isp firmware from user space 
	
	  for MRFLD, Softwarefirmware needs to write a 1 to bit 0 of
	  the register at CSI_RECEIVER_SELECTION_REG to enable SH CSI
	  backend write 0 will enable Arasan CSI backend, which has
	  bugs(like sighting:4567697 and 4567699) and will be removed
	  in B0
		
		  Workaround for imbalance data eye issue which is observed
		  on TNG B0.
 init atomisp wdts 
 save the iunit context only once after all the values are init'ed. 
 Init ISP memory management 
 Load firmware into ISP memory 
 Clear FW image from memory 
	
	  Switch off ISP, as keeping it powered on would prevent
	  reaching S0ix states.
	 
	  The following lines have been copied from atomisp suspend path
 Address later when we worry about the ...field chips 
 Merrifield 
 Baytrail 
 Anniedale (Merrifield+  Moorefield) 
 Cherrytrail 
 SPDX-License-Identifier: GPL-2.0
  Support for Clovertrail PNW Camera Imaging ISP subsystem.
  Copyright (c) 2013 Intel Corporation. All Rights Reserved.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 Assume max number of ACC stages 
 Ideally, this should come from CSS headers 
  to serialize MMIO access , this is due to ISP2400 silicon issue Sighting
  #4684168, if concurrency access happened, system may hard hang.
 apply default pipe config 
 apply isp 2.2 specific config for baytrail
		 enable capture ppdz manually or digital zoom would
			 the isp default to use ISP2.2 and the camera hal will
		 enable reduced pipe to have binary
 Init ISP 
 set css env 
 load isp fw into ISP memory 
 in_reset == true, extension firmwares are reloaded after the recovery 
	
	  For dual steam case, it is possible that:
	  1: for this stream, it is at the stage that:
	  - after set_fmt is called
	  - before stream on is called
	  2: for the other stream, the stream off is called which css reset
	  has been done.
	 
	  Thus the stream created in set_fmt get destroyed and need to be
	  recreated in the next stream on.
	
	  SP can only be started one time
	  if atomisp_subdev_streaming_count() tell there already has some
	  subdev at streamming, then SP should already be started previously,
	  so need to skip start sp procedure
	 css 2.0 API limitation: ia_css_stop_sp() could be only called after
	  destroy all pipes
	
	  SP can not be stop if other streams are in use
	
	  FIXME!
	  for ISP2401 new input system, this api is under development.
	  Calling it would cause kernel panic.
	 
	  VIED BZ: 1458
	 
	  Check if it is Cherry Trail and also new input system
 3A statistics use vmalloc, DIS use kmalloc 
	
	  Record which css pipe enables s3a_grid.
	  Currently would have one css pipe that need it
	 If the grid info has not changed and the buffers for 3A and
	  DIS statistics buffers are allocated or buffer size would be zero
 3A statistics. These can be big, so we use vmalloc. 
 DIS coefficients. 
 DIS projections. 
	 We allocate the cpu-side buffer used for communication with user
	
	  FIXME!
	  Pipe ID reported in CSS event is not correct for new system's
	  copy pipe.
	  VIED BZ: 1463
	
	  Set all isys configs to not valid.
	  Currently we support only one stream per channel
		
		  TODO: sensor needs to export the embedded_data_size_words
		  information to atomisp for each setting.
		  Here using a large safe value.
	
	  To SOC camera, there is only one YUVPP pipe in any case
	  including ZSLSDVcontinuous viewfinder, so always set
	  stream_config.continuous to 0.
	
	  Calculate rx_count as follows:
	  Input: mipi_freq                 : CSI-2 bus frequency in Hz
	  UI = 1  (2  mipi_freq)         : period of one bit on the bus
	  min = 85e-9 + 6  UI             : Limits for rx_count in seconds
	  max = 145e-9 + 10  UI
	  rxcount0 = min  (4  mipi_freq) : convert seconds to byte clocks
	  rxcount = rxcount0 - 2           : adjust for better results
	  The formula below is simplified version of the above with
	  10-bit fixed points for improved accuracy.
 if is called in atomisp_reset(), force destroy stream 
 if is called in atomisp_reset(), force destroy all pipes 
	
	  SP can not be stop if other streams are in use
 move stats buffers to free queue list 
		 Currently only YUVPP mode supports YUV420_Legacy format.
		  Revert this when other pipe modes can support
		  YUV420_Legacy format.
 isp binary 2.2 specific setting
	
	  second_output will be as video main output in SDV mode
	  with SOC camera. output will be as video main output in
	  normal video mode.
 isp binary 2.2 specific setting
  For CSS2.1, capture pipe uses capture_pp_in_res to configure yuv
  downscaling input resolution.
 here just copy the calculation in css 
  For CSS2.1, preview pipe could support bayer downscaling, yuv decimation and
  yuv downscaling, which needs addtional configurations.
	
	  BZ201033: YUV decimation factor of 4 causes couple of rightmost
	  columns to be shaded. Remove this factor to work around the CSS bug.
	  const unsigned int yuv_dec_fct[] = {4, 2};
	
	  The ISP could do bayer downscaling, yuv decimation and yuv
	  downscaling:
	  1: Bayer Downscaling: between effective resolution and
	  bayer_ds_res_out;
	  2: YUV Decimation: between bayer_ds_res_out and vf_pp_in_res;
	  3: YUV Downscaling: between vf_pp_in_res and final vf output
	 
	  Rule for Bayer Downscaling: support factor 2, 1.5 and 1.25
	  Rule for YUV Decimation: support factor 2, 4
	  Rule for YUV Downscaling: arbitrary value below 2
	 
	  General rule of factor distribution among these stages:
	  1: try to do Bayer downscaling first if not in online mode.
	  2: try to do maximum of 2 for YUV downscaling
	  3: the remainling for YUV decimation
	 
	  Note:
	  Do not configure bayer_ds_out_res if:
	  online == 1 or continuous == 0 or raw_binning = 0
	
	  calculate YUV Decimation, YUV downscaling facor:
	  YUV Downscaling factor must not exceed 2.
	  YUV Decimation factor could be 2, 4.
 first decide the yuv_ds input resolution 
 find out the yuv decimation factor 
  For CSS2.1, offline video pipe could support bayer decimation, and
  yuv downscaling, which needs addtional configurations.
	
	  If DVS is enabled,  video binary will take care the dvs envelope
	  and usually the bayer_ds_out_res should be larger than 120% of
	  destination resolution, the extra 20% will be cropped as DVS
	  envelope. But,  if the bayer_ds_out_res is less than 120% of the
	  destination. The ISP can still work,  but DVS quality is not good.
 taking at least 10% as envelope 
	
	  calculate bayer decimate factor:
	  1: only 1.5, 2, 4 and 8 get supported
	  2: Do not configure bayer_ds_out_res if:
	     online == 1 or continuous == 0 or raw_binning = 0
	
	  DVS is cropped from BDS output, so we do not really need to set the
	  envelope to 20% of output resolution here. always set it to 12x12
	  per firmware requirement.
	
	  second_vf_output will be as video viewfinder in SDV mode
	  with SOC camera. vf_output will be as video viewfinder in
	  normal video mode.
 FIXME! No need to destroyrecreate all streams 
	
	  to SOC camera, use yuvpp pipe.
	
	  to SOC camera, use yuvpp pipe.
	
	  to SOC camera, use yuvpp pipe.
	
	  to SOC camera, use yuvpp pipe.
	
	  to SOC camera, video will use yuvpp pipe.
	
	  to SOC camera, video will use yuvpp pipe.
 capture cmd queue is full 
 workaround: if ctc_table is all 0, do not apply it 
		 If the grid info in the argument differs from the current
		   grid info, we tell the caller to reset the grid size and
 FIXME! 
	asd->params.dis_proj_data_valid = false; 
 Get gamma correction params from current setup 
 Get white balance from current setup 
 Get narrow gamma from current setup 
 Digital Zoom 
  Function to setget image stablization statistics
 isp needs to be streaming to get DIS statistics 
		 If the grid info in the argument differs from the current
		   grid info, we tell the caller to reset the grid size and
 CSS 2.0 doesn't support this API. 
 Unlock the isp mutex taken in IOCTL handler before sleeping! 
 Set the ACC binary arguments 
 Load acc binary extension 
 Unload acc binary extension 
	
	  We delay the ACC pipeline creation to atomisp_css_start_acc_pipe,
	  because pipe configuration will soon be changed by
	  atomisp_css_load_acc_binary()
	 css 2.0 API limitation: ia_css_stop_sp() could be only called after
	  destroy all pipes
			
			  Received FW assertion signal,
			  trigger WDT to recover
 ISP running 
 ISP running 
 ISP running 
 ISP running 
 ISP2400: If there are no buffers queued then delete wdt timer. 
 SOF irq should not reset wdt timer. 
 Loop for each css stream 
 Loop for each css vc stream 
	
	  The sh_css_load_firmware function discard the initial
	  "SPS" binaries
 SPDX-License-Identifier: GPL-2.0
  Support for Medifield PNW Camera Imaging ISP subsystem.
  Copyright (c) 2010 Intel Corporation. All Rights Reserved.
  Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 equal to 2NWAY 
  input image data, and current frame resolution for test
  Videobuf ops
 we have reached CSS queue depth 
 we have reached CSS queue depth 
 got from head, so return back to the head 
 we have reached CSS queue depth 
 got from tail, so return back to the tail 
		
		  If there is a per_frame setting to apply on the buffer,
		  do it before buffer en-queueing.
			
			  WORKAROUND:
			  Because the camera halv3 can't ensure to set zoom
			  region to per_frame setting and global setting at
			  same time and only set zoom region to pre_frame
			  setting now.so when the pre_frame setting include
			  zoom region,I will set it to global setting.
 Enqueue buffer 
 enqueue 3ADISmetadata buffers 
 when run ZSL case 
when run SDV case
other case: default setting
 queue all available buffers to css 
 ATOMISP_RUN_MODE_STILL_CAPTURE 
		
		  use yuvpp pipe for SOC camera.
		
		  use yuvpp pipe for SOC camera.
 else for ext isp use case 
		
		  use yuvpp pipe for SOC camera.
		
		  use yuvpp pipe for SOC camera.
	
	  when a frame buffer meets following conditions, it should be put into
	  the waiting list:
	  1.  It is not a main output frame, and it has a per-frame parameter
	      to go with it.
	  2.  It is not a main output frame, and the waiting buffer list is not
	      empty, to keep the FIFO sequence of frame buffer processing, it
	      is put to waiting list until previous per-frame parameter buffers
	      get enqueued.
 init locks 
 ext_lock: NULL 
 ext_lock: NULL 
	
	  For Merrifield, frequency is scalable.
	  After boot-up, the default frequency is 200MHz.
 s3a grid not enabled for any pipe 
 Add for channel 
  file operation functions
 Deferred firmware loading case. 
 No need to keep FW in memory anymore. 
	
	  atomisp does not allow multiple open
 runtime power management, turn on ISP 
 Init ISP 
 Need to clean up CSS init if it fails. 
	
	  A little trick here:
	  file injection input resolution is recorded in the sink pad,
	  therefore can not be cleared when releaseing one device node.
	  The sink pad setting can only be cleared when all device nodes
	  get released.
 clear the sink pad for file input 
 clear the asd field to show this camera is not used 
  Memory help functions for image frame and private parameters
 The input frame contains left and right padding that need to be removed.
  There is always ISP_LEFT_PAD padding on the left side.
  There is also padding on the right (padded_width - width).
		 Map private buffer.
		  Set VM_SHARED to the flags since we need
		  to map the buffer page by page.
		  Without VM_SHARED, remap_pfn_range() treats
		  this kind of mapping as invalid.
 mmap for ISP offline raw data 
	
	  mmap for normal frames
	
	  this was removed because of bugs, the interface
	  needs to be made safe for compat tasks instead.
	.compat_ioctl32 = atomisp_compat_ioctl32,
 .compat_ioctl32 = atomisp_compat_ioctl32, 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 This file will contain the code to implement the functions declared in ia_css_morph.h
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 gdc_lut_store(), ... 
 ISP_VEC_ELEMBITS 
 !defined(HAS_NO_HMEM) 
 Event IDs 
 NOT_USED 
 max(), min()  EVEN_FLOOR()
 Include all kernel host interfaces for ISP1 
 Include additional kernel host interfaces for ISP2 
 height should be the larger height between new api and legacy api  \
 We keep a second copy of the ptr struct for the SP to access.
 sp group address on DDR 
 END DO NOT MOVE INTO VIMALS_WORLD 
 Digital Zoom lookup table. See documentation for more details about the
  contents of this table.
 ------ deprecated(bz675) : from ------ 
	1	 enable shading table conversion in the css
 ------ deprecated(bz675) : to ------ 
 out 
 out 
  Each coefficient is stored as 7bits to fit 2 of them into one
  ISP vector element, so we will store 4 coefficents on every
  memory word (32bits)
  0: Coefficient 0 used bits
  1: Coefficient 1 used bits
  2: Coefficient 2 used bits
  3: Coefficient 3 used bits
  x: not used
  xx33333332222222 | xx11111110000000
 Find the maximum value in the table 
		 Make sure FPN value can be represented in 13-bit unsigned
		  number (ISP precision - 1), but note that actual input range
		  depends on precision of input frame data.
 Checkpatch patch 
 Checkpatch patch 
 MW: BUG, is "13" a system or application property 
	 Find the lowest shift value to remap the values in the range
	  0..maxval to 0..2^shiftval63.
 MW: BUG, is "63" a system or application property 
 Adjust the values in the table for the shift value 
 update the other buffers to the pipe specific copies 
	 Currently we check if 10bpp DPC configuration is required based
	  on the use case,i.e. if BDS and DPC is both enabled. The more cleaner
	  design choice would be to expose the type of DPC (either 10bpp or 13bpp)
	  using the binary info, but the current control flow does not allow this
	  implementation. (This is because the configuration is set before a
	  binary is selected, and the binary info is not available)
 check if DPC is enabled from the host 
check if BDS is enabled
we use 10bpp BDS configuration
	 this function desperately needs to be moved to the ISP or SP such
	  that it can use the DMA.
 store raw to fpntbl 
 byte system address 
 byte system address 
 raw -> fpn 
 overwrite isp parameter 
		 Not very clean, this goes to sh_css.c to invalidate the
		  shading table for all pipes. Should replaced by a loop
		  and a pipe-specific call.
 store the shading table to ddr 
 first_stage can be  NULL 
 Go through all stages to udate uds and cropping 
		 note: the var below is made static as it is quite large;
		   if it is not static it ends up on the stack which could
		   cause issues for drivers
 we will use pipe_in_res to scale the zoom crop region if needed 
 MW 2400 advanced requires different scaling 
	 Windows compiler does not like adding sizes to a void 
	 GCC complains when we assign a char  to a void , so these
 Parameter encoding is not yet orthogonal.
   This function hnadles some of the exceptions.
 Copy also to DP. Should be done by the driver. 
 ISP2401 
 JK: Why isp params changed?? 
 JK: Why do isp params change? 
 Now commit all changes to the SP 
	 The following code is intentional. The sh_css_init_isp_params_from_config interface
	  throws an error when both DPC and BDS is enabled. The CSS API must pass this error
	  information to the caller, ie. the host. We do not return this error immediately,
	  but instead continue with updating the ISP params to enable testing of features
	 create per-frame ISP params object with default values
	  from stream->isp_params_configs if one doesn't already exist
 update new ISP params object with the new config 
 create per pipe reference to general ddr_ptrs 
 now commit to ddr 
	 The following code is intentional. The sh_css_init_sp_params_from_config and
	  sh_css_init_isp_params_from_config throws an error when both DPC and BDS is enabled.
	  The CSS API must pass this error information to the caller, ie. the host.
	  We do not return this error immediately, but instead continue with updating the ISP params
 ------ deprecated(bz675) : from ------ 
 ------ deprecated(bz675) : to ------ 
	 Currently we do not offer CSS interface to set different
	  configurations for DPC, i.e. depending on DPC being enabled
	  before (NORM+OBC) or after. The folllowing code to set the
	  DPC configuration should be updated when this interface is made
		 return an error when both DPC and BDS is enabled by the
		 we do not exit from this point immediately to allow internal
 ------ deprecated(bz675) : from ------ 
 ------ deprecated(bz675) : to ------ 
  coding style says the return of "mmgr_NULL" is the error signal
  Deprecated: Implement mmgr_realloc()
	 Possible optimization: add a function sh_css_isp_css_mm_realloc()
 don't reallocate if single ref to buffer and same size 
 MW: Does "grid->enable" also control the histogram output ?? 
 All subsections need to be aligned to the system bus width 
		 The enter and leave macros are placed inside
		  the condition to avoid false logging of metadata
		  free events when metadata is disabled.
		  We found this to be confusing during development
 TMP: tracking of paramsets 
		 we do not return the error immediately to enable internal
 create per pipe reference to general ddr_ptrs 
 ------ deprecated(bz675) : from ------ 
 ------ deprecated(bz675) : to ------ 
					 set the return value as false if both DPC and
					 BDS is enabled by the user. But we do not return
					 the value immediately to enable internal firmware
 ------ deprecated(bz675) : from ------ 
 ------ deprecated(bz675) : to ------ 
				 set the return value as false if both DPC and
				  BDS is enabled by the user. But we do not return
				  the value immediately to enable internal firmware
 FIXME: should it ignore this error? 
 Only IA_CSS_PIPE_ID_VIDEO & IA_CSS_PIPE_ID_CAPTURE will support dvs_6axis_config
 TMP: tracking of paramsets 
 Note that allocation is in ipu address space. 
	 If the pipe belongs to a stream and the stream has started, it is not
	  safe to store lut to gdc HW. If pipe->stream is NULL, then no stream is
	  created with this pipe, so it is safe to do this operation as long as
 Free any existing tables. 
 if pipe is NULL, returns default lut addr. 
 Is table already mapped? Nothing to do if it is mapped. 
  MW: we can define hmm_free() to return a NULL
  then you can write ptr = hmm_free(ptr);
 free buffers 
 free existing ddr_ptr maps 
 Free up theDVS table memory blocks before recomputing new table 
 Free up sc_config (temporal shading table) if it is allocated. 
 go through the pools to clear references 
	 currently we don't have morph table interpolation yet,
	  so we allow a wider table to be used. This will be removed
unsigned int pipe_num void)
 SP is not running. The queues are not valid 
 clean-up old copy 
			 TMP: keep track of dequeued param set count
	 Copy stage uds parameters to config, since they can differ per stage.
 Call parameter process functions for all kernels 
 Skip SC, since that is called on a temp sc table 
 now make the map available to the sp 
	 enqueue a copies of the mem_map to
 SP is not running. The queues are not valid 
		 TODO: Normally, zoom and motion parameters shouldn't
		  be part of "isp_params" as it is resolutionpipe dependent
		  Therefore, move the zoom config elsewhere (e.g. shading
		  table can be taken as an example! @GC
 we have to do this per pipeline because 
 the processing is a.o. resolution dependent 
 check if to actually update the parameters for this pipe 
		 When API change is implemented making good distinction between
 BZ 125915, should be moved till after "update other buff" 
 update the other buffers to the pipe specific copies 
 for 
 update isp_params to pipe specific copies 
 last make referenced copy 
 Update Parameters ID 
 Update output frame pointer 
 now write the copy to ddr 
 enqueue the set to sp 
			 TMP: check discrepancy between nr of enqueued
			  parameter sets and dequeued sets
			
			  Tell the SP which queues are not empty,
			  by sending the software event.
 SP is not running. The queues are not valid 
 clean-up old copy 
pipe_num);
 end for each 'active' pipeline 
	 clear the changed flags after all params
 ------ deprecated(bz675) : from ------ 
 ------ deprecated(bz675) : to ------ 
 struct is > 128 bytes so it should not be on stack (see checkpatch) 
 store the shading table to ddr 
 set sc_config to isp 
 generate the identical shading table 
 store the shading table to ddr 
 set sc_config to isp 
 free the shading table 
 legacy 
 ------ deprecated(bz675) : from ------ 
 shading table is full resolution, reduce 
 store the shading table to ddr 
 set sc_config to isp 
 free the shading table 
 ------ deprecated(bz675) : to ------ 
	 DPC configuration is made pipe specific to allow flexibility in positioning of the
	  DPC kernel. The code below sets the pipe specific configuration to
		 because UV is packed into the Y plane, calc total
		  YYU size = 2 gives size of UV-only,
		  total YYU size = UV-only  3.
				When delay frames are present(as in case of video),
Otherwise, use input frame to configure DVS
 Generate default DVS unity table on start up
 After special cases like SC, FPN since they may change parameters 
 generate the identical shading table 
				 The sc_config will be freed in the
 ------ deprecated(bz675) : from ------ 
		 following code is copied from function ia_css_stream_get_shading_correction_binary()
			 The sc_config will be freed in the
 ------ deprecated(bz675) : to ------ 
	 we will use a union to copy things; overlaying an array
	   with the struct; that way adding fields in the struct
	   will keep things working, and we will not get type errors.
 copy map using size info 
 sanity check - ptr must be valid 
 copy map using size info 
 sanity check - ptr must be valid 
 Mark all parameters as changed to force recomputing the derived ISP parameters 
Free up theDVS table memory blocks before recomputing new table  
 out 
 out 
			
			  we calculate with the envelope that we can actually
			  use, the min dvs envelope is for the filter
			  initialization.
			
			  for digital zoom, we use the dvs envelope and make
			  sure that we don't include the 8 leftmost pixels or
			  8 topmost rows.
 clip the motion vector to +- half the envelope 
 uds can be pipelined, remove top lines 
 clip the motion vector to +- half the envelope 
			 for video with downscaling, the envelope is included
			 ds == 2 (yuv_ds) can be pipelined, remove top
			 video nodz: here we can only crop. We make sure we
 Must enforce that the crop position is even 
 for down scaling, we always use the center of the image 
 out 
 out 
	 Note:
	 Filter_Envelope = 0 for NNDLUT
	 Filter_Envelope = 1 for BCI
	 Filter_Envelope = 3 for BLI
	 Currently, not considering this filter envelope because, In uds.sp.c is recalculating
	 the dxdy based on filter envelope and other information (ia_css_uds_sp_scale_params)
	 Ideally, That should be done on host side not on sp side.
		 Zoom region is only supported by the UDS module on ISP
			 A. Calculate dxdy based on crop region using in_frame_info
			 Scale the crop region if in_frame_info to the stage is not same as
			 actual effective input of the pipeline
 B. Calculate xcyc based on crop region 
 No weighted histogram, no structure, treat the histogram data as a byte dump in a byte array 
 Backward compatibility by default consider pipe as Video
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 STOP the ISP 
 RESUME the ISP 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
 Valid clock number range from 0 to 5 
 X-Powers AXP288 register set 
 TI SND9039 PMIC register set 
 0x2e selects 2.85V ...      
 ... bottom bit is "enabled" 
 0x58 selects 1.80V ...      
 ... bottom bit is "enabled" 
 CRYSTAL COVE PMIC register set 
 For PMIC AXP 
 ACPI HIDs for the PMICs that could be used by this driver 
 XPower AXP288 PMIC 
 Dollar Cove TI PMIC 
 Crystal Cove PMIC 
 The atomisp uses type==0 for the end-of-list marker, so leave space. 
  Legacystub behavior copied from upstream platform_camera.c.  The
  atomisp driver relies on these values being non-NULL in a few
  places, even though they are hard-coded in all current
  implementations.
	 The windows driver model (and thus most BIOSes by default)
	  uses ACPI runtime power management for camera devices, but
	  we don't.  Disable it, or else the rails will be needlessly
	  tickled during suspendresume.  This has caused power and
	  performance issues on multiple devices.
	 Note subtlety of initialization order: at the point where
	  this registration API gets called, the platform data
	  callbacks have probably already been invoked, so the
	  gmin_subdev struct is already initialized for us.
 Convert i2c_client to i2c_board_info 
 Cribbed from MCG defaults in the mt9m114 driver, not actually verified
  vs. T100 hardware
 "pmc_plt_clk_[0..5]" 
	
	  FIXME: Right now, the intel_pmic driver just write values
	  directly at the regmap, instead of properly implementing
	  i2c_transfer() mechanism. Let's use the same interface here,
	  as otherwise we may face issues.
			
			  We could abort here, but let's parse all resources,
			  as this is helpful for debugging purposes
WA:CHT requires XTAL clock as PLL is not stable.
	
	  Those are used only when there is an external regulator apart
	  from the PMIC that would be providing power supply, like on the
	  two cases below:
	 
	  The ECS E7 board drives camera 2.8v from an external regulator
	  instead of the PMIC.  There's a gmin_CamV2P8 config variable
	  that specifies the GPIO to handle this particular case,
	  but this needs a broader architecture for handling camera power.
	 
	  The CHT RVP board drives camera 1.8v from an external regulator
	  instead of the PMIC just like ECS E7 board.
	
	  FIXME:
	 
	  The ACPI handling code checks for the _PR? tables in order to
	  know what is required to switch the device from power state
	  D0 (_PR0) up to D3COLD (_PR3).
	 
	  The adev->flags.power_manageable is set to true if the device
	  has a _PR0 table, which can be checked by calling
	  acpi_device_power_manageable(adev).
	 
	  However, this only says that the device can be set to power off
	  mode.
	 
	  At least on the DSDT tables we've seen so far, there's no _PR3,
	  nor _PS3 (which would have a somewhat similar effect).
	  So, using ACPI for power management won't work, except if adding
	  an ACPI override logic somewhere.
	 
	  So, at least for the existing devices we know, the check below
	  will always be false.
	
	  The code below is here due to backward compatibility with devices
	  whose ACPI BIOS may not contain everything that would be needed
	  in order to set clocks and do power management.
	
	  According with :
	    https:github.comprojectceladonhardware-intel-kernelflingerblobmasterdocfastboot.md
	 
	  The "CamClk" EFI var is set via fastboot on some Android devices,
	  and seems to contain the number of the clock used to feed the
	  sensor.
	 
	  On systems with a proper ACPI table, this is given via the _PR0
	  power resource table. The logic below should first check if there
	  is a power resource already, falling back to the EFI vars detection
	  otherwise.
 Try first to use ACPI to get the clock resource 
 Fall-back use EFI andor DMI match 
	
	  The firmware might enable the clock at
	  boot (this information may or may not
	  be reflected in the enable clock register).
	  To change the rate we must disable the clock
	  first to cover these cases. Due to common
	  clock framework restrictions that do not allow
	  to disable a clock that has not been enabled,
	  we need to enable the clock first.
		 Note: ideally we would initialize v[12]p8_on to the
		  output of regulator_is_enabled(), but sadly that
		  API is broken with the current drivers, returning
		  "1" for a regulator that will then emit a
		  "unbalanced disable" WARNing if we try to disable
		  it.
	
	  This sleep comes out of the gc2235 driver, which is the
	  only one I currently see that wants to set both 1.8v rails.
 use regulator for PMIC 
 TODO:v1p2 may need to extend to other PMICs 
 Use the ACPI power management to control it 
	
	  The data reported by "CamClk" seems to be either 0 or 1 at the
	  _DSM table.
	 
	  At the ACPI tables we looked so far, this is not related to the
	  actual clock source for the sensor, which is given by the
	  _PR0 ACPI table. So, ignore it, as otherwise this will be
	  set to a wrong value.
 Return on unexpected object type 
 Just for debugging purposes 
 Seek for the desired var 
 Next element should be the required value 
	
	  While it could be possible to have an ACPI_TYPE_INTEGER,
	  and read the value from cur->integer.value, the table
	  seen so far uses the string type. So, produce a warning
	  if it founds something different than string, letting it
	  to fall back to the old code.
 Retrieves a device-specific configuration variable.  The dev
  argument should be a device with an ACPI companion, as all
  configuration is based on firmware ID.
 For sensors, try first to use the _DSM table 
 Fall-back to other approaches 
	 First check a hard-coded list of board-specific variables.
	  Some device firmwares lack the ability to set EFI variables at
	  runtime.
	 Our variable names are ASCII by construction, but EFI names
	  are wide chars.  Convert and zero-pad.
	 Not sure this API usage is kosher; efivar_entry_get()'s
	  implementation simply uses VariableName and VendorGuid from
	  the struct and ignores the rest, but it seems like there
	  ought to be an "official" efivar_entry registered
	  somewhere?
 PCI quirk: The BYT ISP advertises PCI runtime PM but it doesn't
  work.  Disable so the kernel framework doesn't hang the device
  trying.  The driver itself does direct calls to the PUNIT to manage
  ISP power.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 for uint, size_t 
 for hrt_address 
 for ia_css_hw_access_env 
 for assert 
 SPDX-License-Identifier: GPL-2.0
  Support for Clovertrail PNW Camera Imaging ISP subsystem.
  Copyright (c) 2012 Intel Corporation. All Rights Reserved.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  This file implements loadable acceleration firmware API,
  including ioctls to map and unmap acceleration parameters and buffers.
  Allocate struct atomisp_acc_fw along with space for firmware.
  The returned struct atomisp_acc_fw is cleared (firmware region is not).
 Stop acceleration if already running 
 Unload all loaded acceleration binaries 
 Free all mapped memory blocks 
 Binary has to be enabled at least for one pipeline 
 We do not support other flags yet 
	
	  correct isp firmware type in order ISP firmware can be appended
	  to correct pipe properly
 Invalidate caches. FIXME: should flush only necessary buffers 
 Add the binary into the pipeline 
 Refuse creating pipelines with no binaries 
 Buffer to map must be page-aligned 
 Allocate private buffer. 
 Unless the parameter is cleared, check that it exists 
  Appends the loaded acceleration binary extensions to the
  current ISP mode. Must be called just before sh_css_start().
 Invalidate caches. FIXME: should flush only necessary buffers 
			
			  QoS (ACC pipe) acceleration stages are
			  currently allowed only in continuous mode.
			  Skip them for all other modes.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010-2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 __INLINE_ISP__ 
 Enabling the IRQ immediately triggers an interrupt, clear it 
 Patch to avoid compiler unused symbol warning in C_RUN build 
	
		stall->icache_master =
			!isp_ctrl_getbit(ID, ISP_ICACHE_MT_SINK_REG,
				ISP_ICACHE_MT_SINK_BIT);
 ISP functions to control the ISP state from the host, even in crun. 
 Inspect readiness of an ISP indexed by ID 
 Inspect sleeping of an ISP indexed by ID 
 To be called by the host immediately before starting ISP ID. 
 Wake up ISP ID. 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010-2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 __INLINE_EVENT__ 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010-2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 The name "gdc.h is already taken" 
  Local function declarations
 __INLINE_GDC__ 
  Exported function implementations
  Input LUT format:
  c0[0-1023], c1[0-1023], c2[0-1023] c3[0-1023]
  Output LUT format (interleaved):
  c0[0], c1[0], c2[0], c3[0], c0[1], c1[1], c2[1], c3[1], ....
  c0[1023], c1[1023], c2[1023], c3[1023]
  The first format needs c0[0], c1[0] (which are 1024 words apart)
  to program gdc LUT registers. This makes it difficult to do piecemeal
  reads in SP side gdc_lut_store
  Interleaved format allows use of contiguous bytes to store into
  gdc LUT registers.
  See gdc_lut_store() definition in hostgdc.c vs spgdc_private.h
  Local function implementations
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010-2016, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 __INLINE_DMA__ 
reg  [3:0] : flags error [3], stall, run, idle [0]
reg  [9:4] : command
reg[14:10] : channel
reg [23:15] : param
 state->last_command = (dma_commands_t)tmp; 
 if the enumerator is made non-linear 
 AM: the list below does not cover all the cases
  and these are not correct 
 therefore for just dumpinmg this command
	
		if (tmp == 0)
			state->last_command = DMA_COMMAND_READ;
		if (tmp == 1)
			state->last_command = DMA_COMMAND_WRITE;
		if (tmp == 2)
			state->last_command = DMA_COMMAND_SET_CHANNEL;
		if (tmp == 3)
			state->last_command = DMA_COMMAND_SET_PARAM;
		if (tmp == 4)
			state->last_command = DMA_COMMAND_READ_SPECIFIC;
		if (tmp == 5)
			state->last_command = DMA_COMMAND_WRITE_SPECIFIC;
		if (tmp == 8)
			state->last_command = DMA_COMMAND_INIT;
		if (tmp == 12)
			state->last_command = DMA_COMMAND_INIT_SPECIFIC;
		if (tmp == 15)
			state->last_command = DMA_COMMAND_RST;
 No sub-fields, idx = 0 
 state->fsm_ctrl_state = (dma_ctrl_states_t)tmp; 
 state->read_state = (dma_rw_states_t)tmp; 
 state->write_state = (dma_rw_states_t)tmp; 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010-2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 __INLINE_INPUT_FORMATTER__ 
 MW Should be part of system_global.h, where we have the main enumeration 
	 TEMPORARY HACK: THIS RESET BREAKS THE METADATA FEATURE
	  WICH USES THE STREAM2MEMRY BLOCK.
	  MUST BE FIXED PROPERLY
 cnd_input_formatter_reg_store() 
 We'll change this into an intelligent function to get switch info per IF 
	
		state->reset = input_formatter_reg_load(ID,
			HIVE_IF_RESET_ADDRESS);
 FSM 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010-2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 __INLINE_GP_DEVICE__ 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010-2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 __INLINE_HMEM__ 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010-2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 __INLINE_SP__ 
 Enabling the IRQ immediately triggers an interrupt, clear it 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010-015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 __INLINE_INPUT_SYSTEM__ 
 MW: CSI is previously named as "rx" short for "receiver"
 MIPI_FORMAT_YUV420_8_LEGACY is not YUV420 
 should not happen 
(sub_id >= CAPTURE_UNIT0_ID) && (sub_id <= CAPTURE_UNIT2_ID));
	AM: Illegal read from following registers.
		state->Init = input_system_sub_system_reg_load(ID,
			sub_id,
			CAPT_INIT_REG_ID);
		state->Start = input_system_sub_system_reg_load(ID,
			sub_id,
			CAPT_START_REG_ID);
		state->Stop = input_system_sub_system_reg_load(ID,
			sub_id,
			CAPT_STOP_REG_ID);
	AM: Illegal read from following registers.
		state->Init = input_system_sub_system_reg_load(ID,
			sub_id,
			ACQ_INIT_REG_ID);
	AM: Illegal read from following registers.
		state->ctrl_init = input_system_sub_system_reg_load(ID,
			sub_id,
			ISYS_CTRL_INIT_REG_ID);
 See Table 7.1.17,..., 7.1.24 
 MW: "2400" in the name is not good, but this is to avoid a naming conflict
 Disable all ports.
 AM: Additional actions for stopping receiver?
Single function to reset all the devices mapped via GP_DEVICE.
 gp_device_reg_store(ID, _REG_GP_SYNCGEN_FREE_RUNNING_ADDR, ZERO);
 gp_device_reg_store(ID, _REG_GP_SYNCGEN_PAUSE_ADDR, ONE);
 gp_device_reg_store(ID, _REG_GP_NR_FRAMES_ADDR, ZERO);
 gp_device_reg_store(ID, _REG_GP_SYNGEN_NR_PIX_ADDR, ZERO);
 gp_device_reg_store(ID, _REG_GP_SYNGEN_NR_PIX_ADDR, ZERO);
 gp_device_reg_store(ID, _REG_GP_SYNGEN_NR_LINES_ADDR, ZERO);
 gp_device_reg_store(ID, _REG_GP_SYNGEN_HBLANK_CYCLES_ADDR, ZERO);
 gp_device_reg_store(ID, _REG_GP_SYNGEN_VBLANK_CYCLES_ADDR, ZERO);
 AM: Following calls cause strange warnings. Probably they should not be initialized.
	gp_device_reg_store(ID, _REG_GP_ISEL_SOF_ADDR, ZERO);
	gp_device_reg_store(ID, _REG_GP_ISEL_EOF_ADDR, ZERO);
	gp_device_reg_store(ID, _REG_GP_ISEL_SOL_ADDR, ZERO);
	gp_device_reg_store(ID, _REG_GP_ISEL_EOL_ADDR, ZERO);
gp_device_reg_store(ID, _REG_GP_ISEL_CH_ID_ADDR, ZERO);
gp_device_reg_store(ID, _REG_GP_ISEL_FMT_TYPE_ADDR, ZERO);
	gp_device_reg_store(ID, _REG_GP_SYNCGEN_HOR_CNT_ADDR, ZERO);
	gp_device_reg_store(ID, _REG_GP_SYNCGEN_VER_CNT_ADDR, ZERO);
	gp_device_reg_store(ID, _REG_GP_SYNCGEN_FRAME_CNT_ADDR, ZERO);
 AM: Maybe this soft reset is not safe.
 Initialize the data&hsync LUT.
 Initialize the vsync LUT.
 Initialize the data&hsync LUT.
 Initialize the vsync LUT.
 Reset all 3 multicasts.
 Reset stream mux.
 Reset 3 capture units.
 Reset acquisition unit.
 DMA unit reset is not needed.
 Reset controller units.
 NB: In future we need to keep part of ctrl_state for split capture and
AM: Is there any named constant?
 Function that resets current configuration.
target_rst();
 Reset IRQ_CTRLs.
 Reset configuration data structures.
config.acq_allocated_ib_mem_words		 = 0;
 Set the start of the session cofiguration.
 MW: Comments are good, but doxygen is required, place it at the declaration
 Function that appends the channel to current configuration.
 Check if channel is not already configured.
 Input switch channel configurations must be combined in united config.
 Other targets are just copied and marked as set.
 Function that partitions input buffer space with determining addresses.
.csi_cfg;
 Check and set csi buffer in input buffer.
 Well, not used.
 Check acquisition buffer specified but set it later since it has to be unique.
 Nothing to do.
 Check if specified acquisition buffer is the same as specified before.
 end of for ( port )
 Set the acquisition buffer at the end.
(sub_id >= CAPTURE_UNIT0_ID) && (sub_id <=
 Commented part is always true.
 Set all 3 multicasts.
 Set stream mux.
 Set capture units.
 Set acquisition units.
 No DMA configuration needed. Ctrl_unit will fully control it.
 Set controller units.
 Determine stream multicasts setting based on the mode of csi_cfg_t.
 AM: This should be moved towards earlier function call, e.g. in
 the commit function.
break;
 for
 First set input network around CSI receiver.
 Set the CSI receiver.
...
 end of switch (source_type)
 Set input selector.
 Set input switch.
 Set input formatters.
 AM: IF are set dynamically.
 Function that applies the whole configuration.
 The last configuration step is to configure the input buffer.
 Translate the whole configuration into registers.
 Translate the whole configuration into ctrl commands etc.
 FIFO
channel.source
channel.source
 SRAM
	uint32_t				acq_mem_reg_size,
	uint32_t				acq_nof_mem_regs,
channel.source
XMEM
 Collects all parameters and puts them in channel_cfg_t.
channel.source
channel.source
channel.backend_ch	= backend_ch;
channel.source
channel.source_cfg.csi_cfg.backend_ch		= backend_ch;
 Non - CSI
not used yet
not used yet
 MW: Don't use system specific names, (even in system specific files) "cfg2400" -> cfg
not used yet
 Private specialized functions for channel setting.
 Fills the parameters to config.csi_value[port]
check if port > N_INPUT_SYSTEM_MULTIPLEX
 Check for conflicts on source (implicitly on multicast, capture unit and input buffer).
 Check for conflicts on mux.
 Shared resource, so it should be blocked.
config.mux_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
config.csi_buffer_flags[port] |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
config.acquisition_buffer_unique_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
 Check for conflicts on mux.
 Shared resource, so it should be blocked.
config.mux_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
config.csi_buffer_flags[port] |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
config.acquisition_buffer_unique_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
 Check for conflicts on mux.
 Shared resource, so it should be blocked.
config.mux_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
config.csi_buffer_flags[port] |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
config.acquisition_buffer_unique_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
 Test flags and set structure.
 MW: Not enough asserts
 Check for consistency with already set value.
 Check the value (individually).
 Set the value.
 Test flags and set structure.
 check for consistency with already set value.
		if (lhs->backend_ch == rhs.backend_ch
 Check the value (individually).
 no check for backend_ch
 no check for nof_xmem_buffers
 Check if required memory is available in input buffer (SRAM).
 Set the value.
lhs[port]->backend_ch		= rhs.backend_ch;
 ALX: NB: Here we just set buffer parameters, but still not allocate it
 (no addresses determined). That will be done during commit.
  FIXIT:	acq_memory_required is not deducted, since it can be allocated multiple times.
assert(config.unallocated_ib_mem_words >=0);
 Test flags and set structure.
 Check for consistency with already set value.
 Check the value (individually).
 Set the value.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010-2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 __INLINE_FIFO_MONITOR__ 
 __INLINE_FIFO_MONITOR__ 
 ISP_STR_MON_PORT_ISP2SP 
 ISP_STR_MON_PORT_SP2ISP 
 ISP_STR_MON_PORT_SP2ISP 
 ISP_STR_MON_PORT_ISP2SP 
 ISP_STR_MON_PORT_ISP2PIFA 
 MOD_STR_MON_PORT_CELLS2PIFA 
 MOD_STR_MON_PORT_PIFA2CELLS 
 ISP_STR_MON_PORT_PIFA2ISP 
 ISP_STR_MON_PORT_ISP2PIFA 
 MOD_STR_MON_PORT_CELLS2PIFB 
 MOD_STR_MON_PORT_PIFB2CELLS 
 ISP_STR_MON_PORT_PIFB2ISP 
 ISP_STR_MON_PORT_ISP2DMA 
 MOD_STR_MON_PORT_ISP2DMA 
 MOD_STR_MON_PORT_DMA2ISP 
 ISP_STR_MON_PORT_DMA2ISP 
 ISP_STR_MON_PORT_ISP2GDC1 
 MOD_STR_MON_PORT_CELLS2GDC1 
 MOD_STR_MON_PORT_GDC12CELLS 
 ISP_STR_MON_PORT_GDC12ISP 
 ISP_STR_MON_PORT_ISP2GPD 
 no monitor connected 
 no monitor connected 
 ISP_STR_MON_PORT_FA2ISP 
 SP_STR_MON_PORT_SP2PIFA 
 MOD_STR_MON_PORT_CELLS2PIFA 
 MOD_STR_MON_PORT_PIFA2CELLS 
 SP_STR_MON_PORT_PIFA2SP 
 SP_STR_MON_PORT_SP2PIFB 
 MOD_STR_MON_PORT_CELLS2PIFB 
 MOD_STR_MON_PORT_PIFB2CELLS 
 SP_STR_MON_PORT_PIFB2SP 
 SP_STR_MON_PORT_SP2SIF 
 MOD_STR_MON_PORT_SP2SIF 
 MOD_STR_MON_PORT_SIF2SP 
 SP_STR_MON_PORT_SIF2SP 
 SP_STR_MON_PORT_SP2DMA 
 MOD_STR_MON_PORT_SP2DMA 
 MOD_STR_MON_PORT_DMA2SP 
 SP_STR_MON_PORT_DMA2SP 
 SP_STR_MON_PORT_SP2GPD 
 no monitor connected 
 no monitor connected 
 SP_STR_MON_PORT_FA2SP 
 SP_STR_MON_PORT_SP2MC 
 MOD_STR_MON_PORT_SP2MC 
 SP_STR_MON_PORT_MC2SP 
 MOD_STR_MON_PORT_MC2SP 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 __INLINE_TIMED_CTRL__ 
 pqiao TODO: make sure the following commands get
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010-2016, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 __INLINE_DEBUG__ 
 The address of the remote copy 
 The local copy 
 set the ddr queue 
 set the local copy 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010-2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 The name "mmu.h is already taken" 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010 - 2016, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Copied from SDK: sim_semantics.c 
 subword bits move like this:         MSB[____xxxx____]LSB -> MSB[00000000xxxx]LSB 
 inverse subword bits move like this: MSB[xxxx____xxxx]LSB -> MSB[xxxx0000xxxx]LSB 
 overlap 
 pointers into wide_type: 
 easy case for speedup: 
 only one (<=64 bits) element needs to be (partly) copied: 
 general case: handles edge spanning cases (includes >64bit elements) 
 pointers into wide_type: 
 easy case for speedup: 
 only one element needs to be (partly) copied: 
 Need 2 vectors to work around vmem hss bug 
 Spend at least 1 cycles per vector 
 Need 2 vectors to work around vmem hss bug 
load_vector (&v[1][0], &to[ISP_NWAY]);  Fetch the next vector, since it will be overwritten. 
hrt_mem_store (ISP, VMEM, (unsigned)to, &v, siz);  This will overwrite the next vector as well 
 Spend at least 1 cycles per vector 
 In t_vmem_elem 
 In t_vmem_elem 
 In t_vmem_elem 
 In t_vmem_elem )
 In t_vmem_elem 
 In t_vmem_elem )
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010-2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
uint32_t 
#include "gp_timer.h"   system_local.h,
device_access.h
 __INLINE_GP_TIMER__ 
 FIXME: not sure if reg_load(), reg_store() should be API.
 set_overall_enable
set enable
 set signal select 
set count type 
reset gp timer 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010-2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 _REG_GP_IRQ_REQUEST_ADDR 
 __INLINE_IRQ__ 
  Do we want the user to be able to set the signalling method ?
 rising edge 
 to avoid mishaps configuration must follow the following order 
 mask this interrupt 
 rising edge at input 
 enable interrupt to output 
 clear current irq only 
 unmask interrupt from input 
 output is given as edge, not pulse 
 enable interrupt to output 
 unmask interrupt from input 
 clear current irq only 
 find the first irq bit 
 now check whether there are more bits set 
 The SW IRQ pins are remapped to offset zero 
 It is not allowed to enable the pin of a nested IRQ directly 
 Single level nesting, otherwise we'd need to recurse 
 Only disable the top if the nested ones are empty 
 The error condition is an IRQ pulse received with no IRQ status written 
 find the first irq bit on device 0 
 Check whether there are more bits set on device 0 
 Check whether we have an IRQ on one of the nested devices 
 If we have a nested IRQ, load that state, discard the device 0 state 
 find the first irq bit on device "id" 
 Alternatively check whether there are more bits set on this device 
 If this device is empty, clear the state on device 0 
 if (ID != IRQ0_ID) 
 Here we proceed to clear the IRQ on detected device, if no nested IRQ, this is device 0 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Generated code: do not edit or commmit. 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Generated code: do not edit or commmit. 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_param_process_table() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_global_access_function() 
 Code generated by genparamgencode.c:gen_global_access_function() 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Generated code: do not edit or commmit. 
 Code generated by genparamgenstate.c:gen_init_function() 
 Code generated by genparamgenstate.c:gen_init_function() 
 Code generated by genparamgenstate.c:gen_init_function() 
 Code generated by genparamgenstate.c:gen_init_function() 
 Code generated by genparamgenstate.c:gen_init_function() 
 Code generated by genparamgenstate.c:gen_init_function() 
 Code generated by genparamgenstate.c:gen_init_function() 
 Code generated by genparamgenstate.c:gen_init_function() 
 Code generated by genparamgenstate.c:gen_state_init_table() 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
  Forward declarations.
  @brief Read the oldest element from the circular buffer.
  Read the oldest element WITHOUT checking whehter the
  circular buffer is empty or not. The oldest element is
  also removed out from the circular buffer.
  @param cb The pointer to the circular buffer.
  @return the oldest element.
  @brief Shift a chunk of elements in the circular buffer.
  A chunk of elements (i.e. the ones from the "start" position
  to the "chunk_src" position) are shifted in the circular buffer,
  along the direction of new elements coming.
  @param cb	     The pointer to the circular buffer.
  @param chunk_src  The position at which the first element in the chunk is.
  @param chunk_dest The position to which the first element in the chunk would be shift.
  @brief Get the "val" field in the element.
  @param elem The pointer to the element.
  @return the "val" field.
  Non-inline functions.
  @brief Create the circular buffer.
  Refer to "ia_css_circbuf.h" for details.
 Initialize to defaults 
  @brief Destroy the circular buffer.
  Refer to "ia_css_circbuf.h" for details.
  @brief Pop a value out of the circular buffer.
  Refer to "ia_css_circbuf.h" for details.
 read an element from the buffer 
  @brief Extract a value out of the circular buffer.
  Refer to "ia_css_circbuf.h" for details.
 get the maximum offest 
	
	  Step 1: When the target element is at the "start" position.
	
	  Step 2: When the target element is out of the range.
	
	  Step 3: When the target element is between the "start" and
	  "end" position.
 get the position of the target element 
 get the value from the target element 
 shift the elements 
  @brief Peek an element from the circular buffer.
  Refer to "ia_css_circbuf.h" for details.
 get the value at the position 
  @brief Get the value of an element from the circular buffer.
  Refer to "ia_css_circbuf.h" for details.
 get the value at the position 
 @brief increase size of a circular buffer.
  Use 'CAUTION' before using this function. This was added to
  support  fix issue with increasing size for tagger only
  Please refer to "ia_css_circbuf.h" for details.
	 We assume cb was pre defined as global to allow
 FM: are we sure this cannot cause size to become too big? 
 overflow in size 
	 If elems are passed update them else we assume its been taken
		 cb element array size will not be increased dynamically,
		  but pointers to new elements can be added at the end
		  of existing pre defined cb element array of
 Fix Start  End 
 Easily fix End 
 Move elements and fix Start
  Inline functions.
  @brief Get the "val" field in the element.
  Refer to "Forward declarations" for details.
  @brief Read the oldest element from the circular buffer.
  Refer to "Forward declarations" for details.
 get the element from the target position 
 clear the target position 
 adjust the "start" position 
  @brief Shift a chunk of elements in the circular buffer.
  Refer to "Forward declarations" for details.
 get the chunk offset and size 
 shift each element to its terminal position 
 copy the element from the source to the destination 
 clear the source position 
 adjust the sourceterminal positions 
 adjust the index "start" 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 TODO: enable for other memory aswell
 for new entry 
 found entry 
		 driver verifier tool has issues with &arr[i]
		   and prefers arr + i; as these are actually equivalent
		   the line below uses + i
				ia_css_debug_dtrace(IA_CSS_DBG_TRACE,
				"ia_css_refcount_uninit: freeing (%x)\n",
				 ia_css_debug_dtrace(IA_CSS_DBEUG_TRACE,
	 SHOULD NOT HAPPEN: ptr not managed by refcount, or not
		 driver verifier tool has issues with &arr[i]
		   and prefers arr + i; as these are actually equivalent
		   the line below uses + i
 clear using provided function 
 SPDX-License-Identifier: GPL-2.0
  Support for Medifield PNW Camera Imaging ISP subsystem.
  Copyright (c) 2010 Intel Corporation. All Rights Reserved.
  Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  ISP MMU management wrap code
 for GFP_ATOMIC 
 for kmalloc 
  64-bit x86 processor physical address layout:
  0		- 0x7fffffff		DDR RAM	(2GB)
  0x80000000	- 0xffffffff		MMIO	(2GB)
  0x100000000	- 0x3fffffffffff	DDR RAM	(64TB)
  So if the system has more than 2GB DDR memory, the lower 2GB occupies the
  physical address 0 - 0x7fffffff and the rest will start from 0x100000000.
  We have to make sure memory is allocated from the lower 2GB for devices
  that are only 32-bit capable(e.g. the ISP MMU).
  For any confusion, contact bin.gao@intel.com.
  allocate a uncacheable page table.
  return physical address.
	
	  we need a uncacheable page table.
 NEED CHECK 
	
	  reset the page to write back before free
  Update L2 page table according to isp virtual address and page physical
  address
 free all mapped pages 
  Update L1 page table according to isp virtual address and page physical
  address
 free all mapped pages 
 free all mapped pages 
  Update page table according to isp virtual address and page physical
  address
		
		  allocate 1 new page for L1 page table
		
		  setup L1 page table physical addr to MMU
  Free L2 page table according to isp virtual address and page physical
  address
  Free L1 page table according to isp virtual address and page physical
  address
		
		  use the same L2 page next time, so we don't
		  need to invalidate and free this PT.
      atomisp_set_pte(l1_pt, idx, NULL_PTE); 
  Free page table according to isp virtual address and page physical
  address
  Free page tables according to isp start virtual address and end virtual
  address.
MMU init for internal structure
 error 
 error 
Free L1 and L2 page table
 SPDX-License-Identifier: GPL-2.0
  Support for Merrifield PNW Camera Imaging ISP subsystem.
  Copyright (c) 2012 Intel Corporation. All Rights Reserved.
  Copyright (c) 2012 Silicon Hive www.siliconhive.com.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  include SH header file here
  callback to flush tlb.
  tlb_flush_range will at least flush TLBs containing
  address mapping from addr to addr + size.
  tlb_flush_all will flush all TLBs.
  tlb_flush_all is must be provided. if tlb_flush_range is
  not valid, it will set to tlb_flush_all by default.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010 - 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
				 Adding back the workaround which was removed
				   while refactoring queues. When reading size
				   through sp_dmem_load_, sometimes we get back
				   the value as zero. This causes division by 0
				   exception as the size is used in a modular
 doing DMA transfer of entire structure 
 Not supported yet 
 doing DMA transfer of entire structure 
 Not supported yet 
 Not supported yet 
 Not supported yet 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
  Queue Public APIs
 Invalid parameters, return error
 Mark the queue as Local 
 Create a local circular buffer queue
 Invalid parameters, return error
 Mark the queue as remote
 Copy over the local queue descriptor
	 If queue is remote, we let the local processor
	  do its init, before using it. This is just to get us
	  started, we can remove this restriction as we go ahead
 Load the required queue object 
 Local queues are created. Destroy it
 1. Load the required queue object 
		 Directly de-ref the object and
		  operate on the queue
 Cannot push the element. Return
 Push the element
 a. Load the queue cb_desc from remote 
 b. Operate on the queue 
 c. Store the queue object 
		 Set only fields requiring update with
		  valid value. Avoids uncessary calls
		  to loadstore functions
 1. Load the required queue object 
		 Directly de-ref the object and
		  operate on the queue
 Nothing to pop. Return empty queue
 a. Load the queue from remote 
 b. Operate on the queue 
 c. Store the queue object 
		 Set only fields requiring update with
		  valid value. Avoids uncessary calls
		  to loadstore functions
 1. Load the required queue object 
		 Directly de-ref the object and
		  operate on the queue
 a. Load the queue from remote 
 b. Operate on the queue 
 1. Load the required queue object 
		 Directly de-ref the object and
		  operate on the queue
 a. Load the queue from remote 
 b. Operate on the queue 
 1. Load the required queue object 
		 Directly de-ref the object and
		  operate on the queue
 a. Load the queue from remote 
 b. Operate on the queue 
 1. Load the required queue object 
		 Directly de-ref the object and
		  operate on the queue
 Check if offset is valid 
 a. Load the queue from remote 
 Check if offset is valid 
 1. Load the required queue object 
		 Directly de-ref the object and
		  operate on the queue
 a. Load the queue from remote 
 b. Operate on the queue 
 1. Load the required queue object 
		 Directly de-ref the object and
		  operate on the queue
 Return maximum usable capacity 
 a. Load the queue from remote 
 Return maximum usable capacity 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 assert 
 Bufq API's 
 ia_css_queue_t 
 Event IDs.
 ia_css_eventq_recv()
 ia_css_debug_dtrace
 sh_css_queue_type 
 sp_address_of 
 sh_css_sp_fw
 Global Queue objects used by CSS                      
 Host2SP buffer queue 
 SP2Host buffer queue 
 Host2SP event queue 
 SP2Host event queue 
 Host2SP ISYS event queue 
 SP2Host ISYS event queue 
 Tagger command queue 
 Static variables
 Static functions
 Public functions
  @brief Query the internal queue ID.
 Static functions
 queue 0 is reserved for parameters because it doesn't depend on events 
 queue 1 is reserved for per frame parameters because it doesn't depend on events 
 Local function to initialize a buffer queue. This reduces
  the chances of copy-paste errors or typos.
 Setup queue location as SP and proc id as SP0_ID 
 Initialize the queue instance and obtain handle 
 Setup all the local queue descriptors for Host2SP Buffer Queues 
 Setup all the local queue descriptors for SP2Host Buffer Queues 
 Host2SP event queue
 SP2Host event queue 
 Host2SP ISYS event queue 
 SP2Host ISYS event queue
 Host2SP tagger command queue 
 Get the queue for communication 
	 No ENTERLEAVE in this function since this is polled
	  by some test apps. Enablign logging here floods the log
	 No ENTERLEAVE in this function since this is polled
	  by some test apps. Enablign logging here floods the log
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010 - 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 location of dmem_cfg  in SP dmem 
 entry function ptr on SP 
 sp firmware location in host mem-DDR
 used in case of PLATFORM_SIM 
 Load firmware 
	 store code (text + icache) and data to DDR
	 
	  Data used to be stored separately, because of access alignment constraints,
	  fix the FW generation instead
	 now we program the base address into the icache and
	  invalidate the cache.
 ISP2401 
 reload pre-loaded FW 
	 now we program the base address into the icache and
	  invalidate the cache.
  freeup the resource 
 Initialize dmem_cfg in SP dmem  and  start SP program
 Set descr in the SP to initialize the SP DMEM 
	
	  The FW stores user-space pointers to the FW, the ISP pointer
	  is only available here
	 
 set the start address 
 Query the state of SP1 
 Suppres warnings in CRUN 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010 - 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010 - 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
(1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_NO_CORRECTION_BIT) | 
(1U << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT); 
	
	  The CSI is nested into the Iunit IRQ's
 This function converts between the enum used on the CSS API and the
  internal DLI enum type.
  We do not use an array for this since we cannot use named array
  initializers in Windows. Without that there is no easy way to guarantee
  that the array values would be in the correct order.
	 In this module the validity of the inptu variable should
	  have been checked already, so we do not check for erroneous
 Translate register bits to CSS API enum mask 
 MW: Why do we remap the receiver bitmap 
 #if !defined(ISP2401) 
	
	  Custom (user defined) modes. Used for compressed
	  MIPI transfers
	 
	  Checkpatch thinks the indent before "if" is suspect
	  I think the only suspect part is the missing "else"
	  because of the return.
	
	  This mapping comes from the Arasan CSS function spec
	  (CSS_func_spec1.08_ahb_sep29_08.pdf).
	 
	  MW: For some reason the mapping is not 1-to-1
		 This is not specified by Arasan, so we use
		  17 for now.
		 compression register bit slicing
		4 bit for each user defined data type
			3 bit indicate compression scheme
				000 No compression
				001 10-6-10
				010 10-7-10
				011 10-8-10
				100 12-6-12
				101 12-6-12
				100 12-7-12
				110 12-8-12
			1 bit indicate predictor
 No compression 
		 Planar YUV formats need to have all planes aligned, this means
	 AM: Check whether this is a problem with multiple
 AM: Check whether this is a problem with multiple streams. 
			 MW: A bit of a hack, straight wiring of the capture
			 MW: Like the integration test example we overwite,
			
			  AM: A bit of a hack, wiring the input system.
	
	  The 2ppc is shared for all ports, so we cannot
	  disable->configure->enable individual ports
 AM: Check whether this is a problem with multiple streams. 
	 MS: 2ppc should be a property per binary and should be
	  enableddisabled per binary.
	  Currently it is implemented as a system wide setting due
 TODO: JB: need to add the beneath used define to mizuchi 
	 sh_css_sw_hive_isp_css_2400_system_20121224_0125\css
	                       \hrt\input_system_defs.h
	  #define INPUT_SYSTEM_CSI_RECEIVER_SELECT_BACKENG 0X207
	 TODO: need better name for define
	  input_system_reg_store(INPUT_SYSTEM0_ID,
	                 INPUT_SYSTEM_CSI_RECEIVER_SELECT_BACKENG, 1);
 if !defined(ISP2401) 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010 - 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 isys2401_dma_set_max_burst_size() 
ch_id                 
port                  
backend_ch            
mem_region_size       
nof_mem_regions       
acq_mem_region_size   
acq_nof_mem_regions   
target                
nof_xmem_buffers      
ch_id                 
port                  
backend_ch            
mem_region_size       
nof_mem_regions       
acq_mem_region_size   
acq_nof_mem_regions   
target                
nof_xmem_buffers      
ch_id                 
port                  
backend_ch            
mem_region_size       
nof_mem_regions       
acq_mem_region_size   
acq_nof_mem_regions   
target                
nof_xmem_buffers      
 Non Burst DMA transactions );
 Enable 2401 input system IRQ status for driver to retrieve 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010 - 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010 - 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 ia_css_pipeline_get_pipe_io_status() 
#include "sh_css_internal.h"	 sh_css_sp_pipeline_io_status
				  SH_CSS_MAX_SP_THREADS
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 for memcpy() 
  Forwarded Declaration
 end of Forwarded Declaration 
  Public Methods
Reset isys_stream to 0
	
	  Early polling is required for timestamp accuracy in certain cause.
	  The ISYS HW polling is started on
	  ia_css_isys_stream_capture_indication() instead of
	  ia_css_pipeline_sp_wait_for_isys_stream_N() as isp processing of
	  capture takes longer than getting an ISYS frame
 create metadata channel 
 Destroy metadata channel only if its allocated
 configure metadata channel 
 end of Public Methods 
  Private Methods
 for metadata 
Free the backend lut allocated for metadata
 See also: ia_css_dma_configure_from_info() 
 use double buffering for online usecases 
	
	#ifndef ISP2401
	  zhengjie.lu@intel.com:
	#endif
	  "dest_buf_cfg" should be part of the input system output
	  port configuration.
	 
	  TODO: move "dest_buf_cfg" to the input system output
	  port configuration.
	 input_buf addr only available in sched mode;
	   this buffer is allocated in isp, crun mode addr
	
	#ifndef ISP2401
	  zhengjie.lu@intel.com:
	#endif
	  "items_per_store" is hard coded as "1", which is ONLY valid
	  when the CSI-MIPI long packet is transferred.
	 
	  TODO: After the 1st stage of MERR+,  make the proper solution to
	  configure "items_per_store" so that it can also handle the CSI-MIPI
	  short packet.
 TODO: Define conditions as when to use store words vs store packets 
	 only onlinesensor mode goto vmem
 See also: ia_css_dma_configure_from_info() 
 TODO: Move metadata away from isys_cfg to application layer 
 end of Private Methods 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
	 Check if there is an available un-used handle with the size
	  that will fulfill the request.
		 There were no available handles that fulfilled the
		  request. Allocate a new handle with the requested size.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010 - 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 MIPI_PREDICTOR_NONE,... 
 System independent 
 The data type is used to send special cases:
  yuv420: odd lines (1, 3 etc) are twice as wide as even
          lines (0, 2, 4 etc).
  rgb: for two pixels per clock, the R and B values are sent
       to output_0 while only G is sent to output_1. This means
       that output_1 only gets half the number of values of output_0.
       WARNING: This type should also be used for Legacy YUV420.
  regular: used for all other data types (RAW, YUV422, etc)
  Maintain a basic streaming to Mipi administration with ch_id as index
  ch_id maps on the "Mipi virtual channel ID" and can have value 0..3
 Streaming to MIPI 
 static inline unsigned inputfifo_wrap_marker( 
 static inline void inputfifo_send_data_a( 
 static inline void inputfifo_send_data_b( 
 static inline void inputfifo_send_data( 
 static inline void inputfifo_send_sol(void) 
 static inline void inputfifo_send_eol(void) 
 static inline void inputfifo_send_sof(void) 
 static inline void inputfifo_send_eof(void) 
     static inline
	 we send an zero marker, this will wrap the ch_id and
	  fmt_type automatically.
 static inline void inputfifo_send_empty_token(void) 
 static inline void inputfifo_start_frame( 
		 for RGB in two_ppc, we only actually send 2 pixels per
		  clock in the even pixels (0, 2 etc). In the other cycles,
		  we only send 1 pixel, to data[0].
				 for jpg (binary) copy, this can occur
				  if the file contains an odd number of bytes.
 Additional increment because we send 2 pixels 
		 for RGB in two_ppc, we only actually send 2 pixels per
		  clock in the even pixels (0, 2 etc). In the other cycles,
		  we only send 1 pixel, to data2[0].
				 for jpg (binary) copy, this can occur
				  if the file contains an odd number of bytes.
 Additional increment because we send 2 pixels 
 Send a frame of data into the input network via the GP FIFO.
   Parameters:
    - data: array of 16 bit values that contains all data for the frame.
    - width: width of a line in number of subpixels, for yuv420 it is the
             number of Y components per line.
    - height: height of the frame in number of lines.
    - ch_id: channel ID.
    - fmt_type: format type.
    - hblank_cycles: length of horizontal blanking in cycles.
    - marker_cycles: number of empty cycles after start-of-line and before
                     end-of-frame.
    - two_ppc: boolean, describes whether to send one or two pixels per clock
               cycle. In this mode, we sent pixels N and N+1 in the same cycle,
               to IF_PRIM_A and IF_PRIM_B respectively. The caller must make
               sure the input data has been formatted correctly for this.
               For example, for RGB formats this means that unused values
               must be inserted.
    - yuv420: boolean, describes whether (non-legacy) yuv420 data is used. In
              this mode, the odd lines (1,3,5 etc) are half as long as the
              even lines (2,4,6 etc).
              Note that the first line is odd (1) and the second line is even
              (2).
  This function does not do any reordering of pixels, the caller must make
  sure the data is in the righ format. Please refer to the CSS receiver
  documentation for details on the data formats.
 Set global variables that indicate channel_id and format_type 
 Set format_type for metadata line. 
 Set global variables that indicate channel_id and format_type 
 Call existing HRT function 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010 - 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 encode_sw_event 
 cnd_sp_irq_enable() 
 Static variables
 Static functions
 Public functions
 @brief destroy a pipeline
  @param[in] pipeline
  @return    None
 Free the pipeline number 
 Run a pipeline and wait till it completes. 
 queues are invalid
  @brief Query the SP thread ID.
  Refer to "sh_css_internal.h" for details.
 Send stop event to the sp
	 This needs improvement, stop on all the pipes available
 queues are invalid 
 @brief Add a stage to pipeline.
  @param       pipeline      Pointer to the pipeline to be added to.
  @param[in]   stage_desc    The description of the stage
  @param[out]	stage         The successor of the stage.
  @return      0 or error code upon error.
  Add a new stage to a non-NULL pipeline.
  The stage consists of an ISP binary or firmware and input and
  output arguments.
 other arguments can be NULL 
 Find the last stage 
	 if in_frame is not set, we use the out_frame from the previous
	  stage, if no previous stage, it's an error.
 Do this only for ISP stages
 Create the new stage 
 Output the new stage 
 First find acceleration firmware at end of pipe 
 If no firmware, find binary in pipe 
	 Android compilation files if made an local variable
	stack size on android is limited to 2k and this structure
	is around 2.5K, in place of static malloc can be done but
	if this call is made too often it will lead to fragment memory
 Static functions
 Pipeline:
  To organize the several different binaries for each type of mode,
  we use a pipeline. A pipeline contains a number of stages, each with
  their own binary and frame pointers.
  When stages are added to a pipeline, output frames that are not passed
  from outside are automatically allocated.
  When input frames are not passed from outside, each stage will use the
  output frame of the previous stage as input (the full resolution output,
  not the viewfinder output).
  Pipelines must be cleaned and re-created when settings of the binaries
  change.
 pipe is not mapped to any thread 
 Make sure a mapping is found 
	 I could do:
		assert(i < SH_CSS_MAX_SP_THREADS);
		But the below is more descriptive.
 Verify input parameters
	 VF frame is not needed in case of need_pp
	   However, the capture binary needs a vf frame to write to.
 only mark as allocated if buffer pointer available 
 in preview pipeline, vf_pp stage should do zoom 
 in capture pipeline, capture_pp stage should do zoom 
 in video pipeline, video stage should do zoom 
 in yuvpp pipeline, first yuv_scaler stage should do zoom 
Copy pipe ports configured to "offline" mode
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
	Static functions declarations
	CSS API functions, exposed by ia_css.h
 Create the frame structure 
	 If we are setting a valid data.
	  Make sure that there is enough
	  room for the expected frame format
	Module public functions
	 yuyv and uyvu have the same frame layout, only the data
	  positioning differs.
 Needs 3 extra lines to allow vf_pp prefetching 
	 nv12 and nv21 have the same frame layout, only the data
	  positioning differs.
	 nv16 and nv61 have the same frame layout, only the data
	  positioning differs.
	 frames with a U and V plane of 8 bits per pixel need to have
	   all planes aligned, this means double the alignment for the
 AM: Body coppied from frame_allocate_with_data(). 
 Not valid format yet 
 Get the data size 
	Static functions
	 Frame height needs to be even number - needed by hw ISYS2401
	   In case of odd number, round up to even.
	   Images won't be impacted by this round up,
	   only needed by jpegembedded data.
	   As long as buffer allocation and release are using data_bytes,
 810241024 
 To indicate it is not valid frame. 
 bytes per pixel 
 bytes per pixel 
 bytes per pixel 
	 Note: Essentially NV12_16 is a 2 bytes per pixel format, this return value is used
	  to configure DMA for the output buffer,
	  At least in SKC this data is overwritten by isp_output_init.sp.c except for elements(elems),
	  which is configured from this return value,
 bytes per pixel 
 bytes per pixel 
 bytes per pixel 
 bytes per pixel 
 bytes per pixel 
 Default is 1 byte per pixel 
 ISP2401 
	 If aspect ratio (widthheight) of out_res is higher than the aspect
	  ratio of the in_res, then we crop vertically, otherwise we crop
	  horizontally.
	 Round new (cropped) width and height to an even number.
	  binarydesc_calculate_bds_factor is such that we should consider as
	  much of the input as possible. This is different only when we end up
	  with an odd number in the last step. So, we take the next even number
	  if it falls within the input, otherwise take the previous even no.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 for uint32_t 
struct ia_css_clock_tick 
 IA_CSS_PIPE_ID_NUM
gp_timer_read()
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010 - 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Set functions for parameter memory descriptors 
 Get functions for parameter memory descriptors 
	 By protocol b0 of the mandatory uint32_t first field of the
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010 - 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
  Static functions declarations
  Public functions
 ISP expects GRBG bayer order, we skip one line andor one row
  to correct in case the input bayer order is different.
 Determine which input formatter config set is targeted. 
 Index is equal to the CSI-2 port used. 
		 This should correspond to the input buffer definition for
 sp raw copy pipe (IA_CSS_PIPE_MODE_COPY): binary is NULL 
	 TODO: check to see if input is RAW and if current mode interprets
	  RAW data in any particular bayer order. copy binary with output
	  format other than raw should not result in dropping lines andor
	  columns.
 sp raw copy pipe: set left_padding value 
		 todo: in case of left padding,
		   num_vectors is vectors per line,
 half lines 
 full lines 
 Patch from bayer to yuv 
 Even lines are half size 
 Patch from bayer to yuv 
 Even lines are half size 
 BR in if_a, G in if_b 
 BR in if_a, G in if_b 
 BGR 
 Patch from bayer to rgb 
			 When two_ppc is enabled AND we need to crop one extra
			  column, if_a crops by one extra and we swap the
			  output offsets to interleave the bayer pattern in
			  the correct order.
 !binary -> sp raw copy pipe, no deinterleaving 
 Must be multiple of deinterleaving 
 !binary -> sp raw copy pipe 
 B buffer is one line further 
 Default values 
 !binary -> sp raw copy pipe 
 workaround for TPG in video mode 
 Patch from bayer to rgb 
 Set the ifconfigs to SP group 
 Set the ifconfigs to SP group 
  Static functions
	 TODO: next could cause issues when streams are started after
IF should not be reconfiguredreset from host 
	 On the hardware, we want to use the middle of the input, so we
	 in case the number of extra columns is 2 or odd, we round the start
	 now we add the one column (if needed) to correct for the bayer
	  order).
	 On the hardware, we want to use the middle of the input, so we
	  divide the start line by 2. On the simulator, we cannot handle extra
	  lines at the end of the frame.
	 in case the number of extra lines is 2 or odd, we round the start
	  line down.
 now we add the one line (if needed) to correct for the bayer order 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010 - 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 N_DMA_CHANNEL_ID 
 HRT_GDC_N 
#include "sp.h"	
 host_sp_enqueue_XXX 
 ia_css_event_encode 
  @brief Encode the information into the software-event.
  Refer to "sw_event_public.h" for details.
 initialize the output 
 get the number of bits per information 
 compress the all inputs into a signle output 
 get the return value 
	 First decode according to the common case
	  In case of a PORT_EOF event we overwrite with
	  the specific values
	  This is somewhat ugly but probably somewhat efficient
	  (and it avoids some code duplication)
event_code 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010-2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 memset 
  @brief VBUF resource handles
  @brief VBUF resource pool - refpool
  @brief VBUF resource pool - writepool
  @brief VBUF resource pool - hmmbufferpool
  @brief Initialize the reference count (host, vbuf)
 initialize the refcount table 
  @brief Retain the reference count for a handle (host, vbuf)
  @param handle	The pointer to the handle
 new vbuf to count on 
		 if the loop dus not break and handle == NULL
		  this is an error handle and report it.
  @brief Release the reference count for a handle (host, vbuf)
  @param handle	The pointer to the handle
 decrease reference count 
 remove from admin 
  @brief Initialize the resource pool (host, vbuf)
  @param pool	The pointer to the pool
 initialize the recycle pool if used 
 allocate memory for storing the handles 
 just in case, set the size to 0 
  @brief Uninitialize the resource pool (host, vbuf)
  @param pool	The pointer to the pool
 free the hmm buffers 
 free memory 
 remove from refcount admin 
 now free the pool handles list 
  @brief Push a handle to the pool
  @param pool		The pointer to the pool
  @param handle	The pointer to the handle
  @brief Pop a handle from the pool
  @param pool		The pointer to the pool
  @param handle	The pointer to the handle
			 dont release, we are returning it...
			  ia_css_rmgr_refcount_release_vbuf(handle);
  @brief Acquire a handle from the pool (host, vbuf)
  @param pool		The pointer to the pool
  @param handle	The pointer to the handle
 only one reference, reuse (no new retain) 
 more than one reference, release current buffer 
 store current values 
 release ref to current buffer 
 get new buffer for needed size 
 try and pop from pool 
 we need to allocate 
 we popped a buffer 
 Note that handle will change to an internally maintained one 
  @brief Release a handle to the pool (host, vbuf)
  @param pool		The pointer to the pool
  @param handle	The pointer to the handle
 release the handle 
 non recycling pool, free mem 
 recycle to pool 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010 - 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
  @brief Uninitialize resource pool (host)
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 sp2host_dequeue_irq_event() 
#include "ia_css_event.h"	 ia_css_event_encode()
				ia_css_event_decode()
 dequeue the IRQ event 
 check whether the IRQ event is available or not 
  @brief The Host sends the event to the SP.
  Refer to "sh_css_sp.h" for details.
	
	  Encode the queue type, the thread ID and
	  the queue ID into the event.
 queue the software event (busy-waiting) 
			 We were able to successfully send the event
 Wait for the queue to be not full and try again
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 HR_GDC_N 
 ISP_VEC_NELEMS 
 FRAC_ACC 
 A => B 
 ISP binaries only (no SP) 
		    TODO: hack to make video_us case work. this should be reverted after
	 We first calculate the resolutions used by the ISP. After that,
 ISP2400 
 Computation results of the origin coordinate of bayer on the shading table. 
 Horizontal ratio (in) of bayer scaling. 
 Horizontal ratio (out) of bayer scaling. 
 Vertical ratio (in) of bayer scaling. 
 Vertical ratio (out) of bayer scaling. 
 X coordinate (in bqs) of bayer origin on shading table. 
 Y coordinate (in bqs) of bayer origin on shading table. 
 ISP2401 
 Requirements for the shading correction. 
 Bayer scaling factor, for the scaling which is applied before shading correction. 
 Horizontal ratio (in) of scaling applied BEFORE shading correction. 
 Horizontal ratio (out) of scaling applied BEFORE shading correction. 
 Vertical ratio (in) of scaling applied BEFORE shading correction. 
 Vertical ratio (out) of scaling applied BEFORE shading correction. 
 ISP internal frame is composed of the real sensor data and the padding data. 
	u32 sensor_data_origin_x_bqs_on_internal;  X origin (in bqs) of sensor data on internal frame
	u32 sensor_data_origin_y_bqs_on_internal;  Y origin (in bqs) of sensor data on internal frame
 ISP2400: Get the requirements for the shading correction. 
 [in] 
 [in] 
 [in] 
 [out] 
	 Numerator and denominator of the fixed bayer downscaling factor.
	 HorizontalVertical ratio of bayer scaling
 Left padding set by InputFormatter. 
 in bqs 
 Flag for the NEED_BDS_FACTOR_2_00 macro defined in isp kernels. 
 Left padding adjusted inside the isp. 
 in bqs 
	 Bad pixels caused by filters.
	NxN-filter (beforeafter bayer scaling) moves the image position
	to rightbottom directions by a few pixels.
	It causes bad pixels at lefttop sides,
 in bqs 
 in bqs 
 in bqs 
 in bqs 
 Get the numerator and denominator of bayer downscaling factor. 
	 Set the horizontalvertical ratio of bayer scaling
 Set the left padding set by InputFormatter. (ifmtr.c) 
	 Set the left padding adjusted inside the isp.
	When bds_factor 2.00 is needed, some padding is added to left_padding
	inside the isp, before bayer downscaling. (raw.isp.c)
	(Hopefully, left_cropleft_paddingtop_crop should be defined in css
	appropriately, depending on bds_factor.)
	 Currently, the bad pixel caused by filters before bayer scaling
	is NOT considered, because the bad pixel is subtle.
	When some large filter is used in the future,
	we need to consider the bad pixel.
	Currently, when bds_factor isn't 1.00, 3x3 anti-alias filter is applied
	to each color plane(GrRBGb) before bayer downscaling.
	This filter moves each color plane to rightbottom directions
	by 1 pixel at the most, depending on downscaling factor.
	 Currently, the bad pixel caused by filters after bayer scaling
	is NOT considered, because the bad pixel is subtle.
	When some large filter is used in the future,
	we need to consider the bad pixel.
	Currently, when DPC&BNR is processed between bayer scaling and
	shading correction, DPC&BNR moves each color plane to
	rightbottom directions by 1 pixel.
	 Calculate the origin of bayer (real sensor data area)
 "+ bs_hor_ratio_in2": rounding for division by bs_hor_ratio_in 
 "+ bs_ver_ratio_in2": rounding for division by bs_ver_ratio_in 
 ISP2401: Get the requirements for the shading correction. 
 [in] 
 [in] 
 [in] 
 [out] 
 Numerator and denominator of the fixed bayer downscaling factor. (numerator >= denominator) 
 HorizontalVertical ratio of bayer scaling between input area and output area. 
 Left padding set by InputFormatter. 
	 Flags corresponding to NEED_BDS_FACTOR_2_00NEED_BDS_FACTOR_1_50NEED_BDS_FACTOR_1_25 macros
 Left padding adjusted inside the isp kernels. 
 Top padding padded inside the isp kernel for bayer downscaling binaries. 
 Bayer downscaling factor 1.0 by fixed-point. 
 FRAC_ACC is defined in ia_css_fixedbds_param.h. 
 RightDown shift amount caused by filters applied BEFORE shading corrertion. 
 right shift before bayer scaling 
 right shift after bayer scaling 
 down shift before bayer scaling 
 down shift after bayer scaling 
 Origin of the real sensor data area on the internal frame at shading correction. 
 scaling factor 1.0 in fixed point 
 scaling ratio in fixed point 
 Get the numerator and denominator of the required bayer downscaling factor. 
 Set the horizontalvertical ratio of bayer scaling between input area and output area. 
 Set the left padding set by InputFormatter. (ia_css_ifmtr_configure() in ifmtr.c) 
	 Set the left padding adjusted inside the isp kernels.
	 When the bds_factor isn't 1.00, the left padding size is adjusted inside the isp,
	 before bayer downscaling. (scaled_hor_plane_index(), raw_compute_hphase() in raw.isp.c)
		
		 downscale 2.0  -> first_vec_adjusted_bqs = 128
		 downscale 1.5  -> first_vec_adjusted_bqs = 96
		 downscale 1.25 -> first_vec_adjusted_bqs = 80
	 Set the top padding padded inside the isp kernel for bayer downscaling binaries.
	 When the bds_factor isn't 1.00, the top padding is padded inside the isp
	 before bayer downscaling, because the top cropping size (input margin) is not enough.
	 (calculate_input_line(), raw_compute_vphase(), dma_read_raw() in raw.isp.c)
	 NOTE: In dma_read_raw(), the factor passed to raw_compute_vphase() is got by get_bds_factor_for_dma_read().
	       This factor is BDS_FPVAL_100BDS_FPVAL_125BDS_FPVAL_150BDS_FPVAL_200.
 Calculation from calculate_input_line() and raw_compute_vphase() in raw.isp.c. 
 top cropping (in bqs) 
 downscaling factor by fixed-point 
 top padding by fixed-point (in bqs) 
	 Set the rightdown shift amount caused by filters applied BEFORE bayer scaling,
	 which scaling is applied BEFORE shading corrertion.
	
	 When the bds_factor isn't 1.00, 3x3 anti-alias filter is applied to each color plane(GrRBGb)
	 before bayer downscaling.
	 This filter shifts each color plane (GrRBGb) to rightdown directions by 1 pixel.
	 Set the rightdown shift amount caused by filters applied AFTER bayer scaling,
	 which scaling is applied BEFORE shading corrertion.
	
	 When DPC&BNR is processed between bayer scaling and shading correction,
	 DPC&BNR moves each color plane (GrRBGb) to rightdown directions by 1 pixel.
 if DPC&BNR is enabled in the binary 
 "+ bs_in2": rounding 
 "+ bs_in2": rounding 
 Get the shading information of Shading Correction Type 1. 
 [in] 
 [in] 
 [in] 
 [out] 
 Initialize by default values. 
 Get the shading information of Shading Correction Type 1. 
 [in] 
 [in] 
 [in] 
 [out] 
 [out] 
 Initialize by default values. 
 Set the input size from sensor, which includes lefttop crop size. 
	
	  Frame size internally used in ISP, including sensor data and padding.
	  This is the frame size, to which the shading correction is applied.
 Shading table. 
	
	  Real sensor data area on the internal frame at shading correction.
	  Filters and scaling are applied to the internal frame before
	  shading correction, depending on the binary.
 scaling factor 1.0 in fixed point (8 == FRAC_ACC macro in ISP) 
 scaling ratio in fixed point 
 "+ bs_in2": rounding 
 "+ bs_in2": rounding 
 Center of the sensor data on the internal frame at shading correction. 
 Size of leftrightupperlower sides of the sensor center on the internal frame. 
 Align the size of leftrightupperlower sides to a multiple of the grid cell size. 
 Shading table should cover the adjusted frame size. 
 Origin of the internal frame on the shading table. 
 Origin of the real sensor data area on the shading table. 
 The shading information necessary as API is stored in the shading_info. 
 The shading information related to ISP (but, not necessary as API) is stored in the pipe_config. 
 [in] 
 [in] 
 [in] 
 [in] 
 [out] 
 [out] 
	 for DIS, we use a division instead of a ceil_div. If this is smaller
	  than the 3a grid size, it indicates that the outer values are not
	  valid for DIS.
 3A statistics grid 
 move to host part of output module 
 move to host part of bds module 
 we don't have this binary, skip it 
 When binaries are put at the beginning, they will only
  be selected if no other primary matches.
 Prepend new binary information 
 @brief Compute decimation factor for 3A statistics and shading correction.
  @param[in]	width	Frame width in pixels.
  @param[in]	height	Frame height in pixels.
  @return	Log2 of decimation factor (= grid cell size) in bayer quads.
	 3AShading decimation factor spcification (at August 2008)
	  ------------------------------------------------------------------
	  [Image Width (BQ)] [Decimation Factor (BQ)] [Resulting grid cells]
	#ifndef ISP2401
	  1280 ?c             32                       40 ?c
	   640 ?c 1279        16                       40 ?c 80
	       ?c  639         8                          ?c 80
	#else
	  from 1280                   32                 from 40
	  from  640 to 1279           16                 from 40 to 80
	            to  639            8                         to 80
	#endif
	  ------------------------------------------------------------------
 Maximum and minimum decimation factor by the specification 
 the smallest frame width in bayer quads when decimation factor (log2) is 5 or 4, by the specification 
 the smallest factor (log2) where the number of cells does not exceed the limitation 
 the factor (log2) which satisfies the specification 
 Currently supported maximum width and height are 5120(=8064) and 3840(=6064). 
 Compute the smallest factor. 
 Get the factor by the specification. 
	 If smallest_factor is smaller than or equal to spec_factor, choose spec_factor to follow the specification.
	   If smallest_factor is larger than spec_factor, choose smallest_factor.
		ex. width=2560, height=1920
			smallest_factor=4, spec_factor=5
			smallest_factor < spec_factor   ->   return spec_factor
		ex. width=300, height=3000
			smallest_factor=5, spec_factor=3
			smallest_factor > spec_factor   ->   return smallest_factor
 number of paddings pixels on the left of an image line 
 the output image line of Input System 2401 does not have the left paddings  
 in other cases, the left padding pixels are always 128 
		 In SDV use-case, we need to match left-padding of
 Different than before, we do left&right padding. 
 Different than before, we do left&right padding. 
 can be NULL 
 can be NULL 
 can be NULL 
 can be NULL 
 Resolution at SC3ADIS kernel. 
 Resolution at SC3ADIS kernel. 
 Resolution at SC3ADIS kernel. 
 binary->css_params has been filled by accelerator itself. 
 binary_dvs_env has to be equal or larger than SH_CSS_MIN_DVS_ENVELOPE 
 internal resolution calculation 
 internal frame info 
 { 
 } 
 input info 
				 Only relevant for RAW format.
				  At the moment, all outputs are raw, 16 bit per pixel, except for copy.
				  To do this cleanly, the binary should specify in its info
				  the bit depth per output channel.
 viewfinder output info 
 For preview mode, output pin is used instead of vf. 
			 we also store the raw downscaled width. This is
			  used for digital zoom in preview to zoom only on
			  the width that we actually want to keep, not on
		 TODO: Next, "internal_frame_info" should be derived from
 MW: used after an error check, may accept NULL, but doubtfull 
 width==0 means that there is no vf pin (e.g. in SkyCam preview case) 
 Video is the only mode that has a nodz variant. 
 print a map of the binary file 
 printf("sh_css_binary_find: pipe version %d\n", isp_pipe_version); 
		 printf("sh_css_binary_find: evaluating candidate:
		
		  MW: Only a limited set of jointly configured binaries can
		  be used in a continuous previewvideo mode unless it is
		  the copy mode and runs on SP.
 when we require vf output, we need to have vf_veceven 
 or variable vf vec even 
 or more than one output pin. 
 internal_res check considers input, output, and dvs envelope sizes 
 in case we have a second output pin, 
 and we need vf output. 
 in case we have a second output pin, 
 and we need vf output. 
		     check if the required vf format
 Check if vf_veceven supports the requested vf format 
 Check if vf_veceven supports the requested vf width 
 and we need vf output. 
 reconfigure any variable properties of the binary 
 This is (should be) true for IPU1 and IPU2 
 For IPU3 (SkyCam) this pointer is guaranteed to be NULL simply because such a binary does not exist  
 -1 to account for sp binary which is not stored in all_binaries 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 for strscpy() 
 ISP2401 
 CEIL_DIV 
 input_formatter_reg_load 
 sh_css_sp_get_debug_state() 
 tracer 
 for ia_css_device_load_uint32 
 Include all kernel host interfaces for ISP1 
 Include additional kernel host interfaces for ISP2 
  TODO:SH_CSS_MAX_SP_THREADS is not the max number of sp threads
  future rework should fix this and remove the define MAX_THREAD_NUM
 [SH_CSS_QUEUE_A_ID]     = "queue_A",
 [SH_CSS_QUEUE_B_ID]     = "queue_B",
 [SH_CSS_QUEUE_C_ID]     = "queue_C",
 [SH_CSS_QUEUE_D_ID]     = "queue_D",
 [SH_CSS_QUEUE_E_ID]     = "queue_E",
 [SH_CSS_QUEUE_F_ID]     = "queue_F",
 [SH_CSS_QUEUE_G_ID]     = "queue_G",
 [SH_CSS_QUEUE_H_ID]     = "queue_H"
 [IA_CSS_PIPE_ID_PREVIEW]   = "preview",
 [IA_CSS_PIPE_ID_COPY]      = "copy",
 [IA_CSS_PIPE_ID_VIDEO]     = "video",
 [IA_CSS_PIPE_ID_CAPTURE]   = "capture",
 [IA_CSS_PIPE_ID_YUVPP]     = "yuvpp",
 [IA_CSS_PIPE_ID_ACC]       = "accelerator"
	 When size is not multiple of four, last word is only relevant for
 Flag that tells whether the IF gives backpressure on frames 
	
	  FYI, this is only on the frame request (indicate), when the IF has
	  synch'd on a frame it will always give back pressure
	 note: the var below is made static as it is quite large;
	   if it is not static it ends up on the stack which could
	   cause issues for drivers
 Print header for DMA dump status 
 Print FSM command flag state 
 Print last command along with the channel 
 Print DMA registers 
 Remember last_index because we only want to print new entries 
 SP has been reset 
 last index can be multiple rounds behind 
 while trace size is only SH_CSS_SP_DBG_TRACE_DEPTH 
	
	  This is just an example how TRACE_FILE_ID (see ia_css_debug.sp.h) will
	  me mapped on the file name string.
	 
	  Adjust this to your trace case!
 Example SH_CSS_SP_DBG_NR_OF_TRACES==1 
 Adjust this to your trace case 
 Remember host_index_last because we only want to print new entries 
 SP has been reset 
 last index can be multiple rounds behind 
 while trace size is only SH_CSS_SP_DBG_TRACE_DEPTH 
 mipi port state 
 end of mipi port state 
 rx channel state 
 end of rx channel state 
 configuration 
 end of configuration 
 capture unit state 
 end of capture unit state 
 acquisition unit state 
 end of acquisition unit state 
 control unit state 
 end of control unit state 
 this function is for debug use, it can make SP go to sleep
  state after each frame, then user can dump the stable SP dmem.
  this function can be called after ia_css_start_sp()
  and before sh_css_init_buffer_queues()
 Suppres warnings in CRUN 
hrt_ctl_start(SP); 
 Find a stage that support the kernel and return the parameters for that kernel 
 only indicate if copy loop is active 
 do the handling 
 do the handling 
 N_MIPI_PORT_ID + 1: 3 Capture Units and 1 Acquire Unit. 
  @brief Initialize the debug mode.
  Refer to "ia_css_debug.h" for more details.
  @brief Disable the DMA channel.
  Refer to "ia_css_debug.h" for more details.
  @brief Enable the DMA channel.
  Refer to "ia_css_debug.h" for more details.
		 An input stream format has been set so assume we have
		  an input system and sensor
 Reset temp strings 
 Guard in case of binaries that don't have any binary_info 
		 Split it in 2 function-calls to keep the amount of
		  parameters per call "reasonable"
 And merge them into one string 
 Replace last ',' with \0 if present 
 Too big for one line, find last comma 
 Last comma found, copy till that comma 
 The 2nd line fits 
					 we cannot use ei as argument because
					  it is not guaranteed dword aligned
 2nd line is still too long 
 The 3rd line fits 
						 we cannot use ei as argument because
						 it is not guaranteed dword aligned
 3rd line is still too long 
		
		  There are some implicite assumptions about which bin is the
		  input binary e.g. which one is connected to the input system
		  Priority:
		  1) sp_raw_copy bin has highest priority
		  2) First stage==0 binary of preview, video or capture
    Trace support.
    This tracer is using a buffer to trace the flow of the FW and dump misc values (see below for details).
    Currently, support is only for SKC.
    To enable support for other platforms:
     - Allocate a buffer for tracing in DMEM. The longer the better.
     - Use the DBG_init routine in sp.hive.c to initiatilize the tracer with the address and size selected.
     - Add trace points in the SP code wherever needed.
     - Enable the dump below with the required address and required adjustments.
	   Dump is called at the end of ia_css_debug_dump_sp_state().
 dump_trace() : dump the trace points from DMEM2.
 for every trace point, the following are printed: index, major:minor and the 16-bit attached value.
 The routine looks for the first 0, and then prints from it cyclically.
 Data forma in DMEM2:
  first 4 DWORDS: header
   DWORD 0: data description
    byte 0: version
    byte 1: number of threads (for future use)
    byte 2+3: number ot TPs
   DWORD 1: command byte + data (for future use)
    byte 0: command
    byte 1-3: command signature
   DWORD 2-3: additional data (for future use)
  Following data is 4-byte oriented:
    byte 0:   major
	byte 1:   minor
	byte 2-3: data
 using a static buffer here as the driver has issues allocating memory 
 read the header and parse it 
 Loading byte-by-byte as using the master routine had issues 
 copy the TPs and find the first 0 
 two 0s in the beginning: empty buffer 
 no overrun: start from 0 
 first 0 is at the end - border case 
 did not make a full cycle after the memset 
 overrun: limit is the first non-zero after the first zero 
 print the TPs 
				
				 When tid value is 111b, the data will be interpreted differently:
				 tid val is ignored, major field contains 2 bits (msb) for format type
 ISP2400 
 ISP2400 
 ISP2401 
 ISP2401 
 HAS_TRACER_V2 
 TRACE_ENABLE_SP0 || TRACE_ENABLE_SP1 || TRACE_ENABLE_ISP 
 Tagger state dump function. The tagger is only available when the CSS
 This variable is not used in crun 
 2400 and 2401 only have 1 SP, so the tagger lives on SP0 
 ISP2401 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Generated code: do not edit or commmit. 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 Code generated by genparamgenconfig.c:gen_configure_function() 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Generated code: do not edit or commmit. 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_process_function() 
 Code generated by genparamgencode.c:gen_param_process_table() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_get_function() 
 Code generated by genparamgencode.c:gen_set_function() 
 Code generated by genparamgencode.c:gen_global_access_function() 
 Code generated by genparamgencode.c:gen_global_access_function() 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Generated code: do not edit or commmit. 
 Code generated by genparamgenstate.c:gen_init_function() 
 Code generated by genparamgenstate.c:gen_init_function() 
 Code generated by genparamgenstate.c:gen_init_function() 
 Code generated by genparamgenstate.c:gen_init_function() 
 Code generated by genparamgenstate.c:gen_init_function() 
 Code generated by genparamgenstate.c:gen_init_function() 
 Code generated by genparamgenstate.c:gen_init_function() 
 Code generated by genparamgenstate.c:gen_init_function() 
 Code generated by genparamgenstate.c:gen_state_init_table() 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
  Include definitions for isys irq private functions. isys_irq.h includes
  declarations of these functions by including isys_irq_public.h.
 Public interface 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 4 entries at CSI_RX_BACKEND0_ID
 4 entries at CSI_RX_BACKEND1_ID
 4 entries at CSI_RX_BACKEND2_ID
 8 entries at CSI_RX_BACKEND0_ID
 4 entries at CSI_RX_BACKEND1_ID
 4 entries at CSI_RX_BACKEND2_ID
 4 dlanes for CSI_RX_FR0NTEND0_ID 
 4 dlanes for CSI_RX_FR0NTEND1_ID 
 4 dlanes for CSI_RX_FR0NTEND2_ID 
 sid_width for CSI_RX_BACKEND<N>_ID 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 IBUF_CTRL0_ID supports at most 8 processes 
 IBUF_CTRL1_ID supports at most 4 processes 
 IBUF_CTRL2_ID supports at most 4 processes 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 HRT_GDC_N 
 This module provides a binary descriptions to used to find a binary. Since,
  every stage is associated with a binary, it implicity helps stage
  description. Apart from providing a binary description, this module also
 Generic descriptor for offline binaries. Internal function. 
 in_info, out_info, vf_info can be NULL 
 out_info can be NULL 
 out_info can be NULL ??? 
 Loop over all bds factors until a match is found 
	 Throw an error since bds_factor cannot be found
 delta in pixels to account for rounding margin in the calculation 
 Assert if the resolutions are not set 
 Loop over all bds factors until a match is found 
		 See width-wise and height-wise if this bds_factor
 Throw an error since a suitable bds_factor cannot be found 
	
	  Set up the info of the input frame with
	  the ISP required resolution
 TODO: Remove this when bds_out_info is available! 
 TODO: Remove this when bds_out_info->is available! 
	 bayer ds and fractional ds cannot be enabled at the same time,
	
	   ----Preview binary-----
	   --in-->|--out->|vf_veceven|--|--->vf
	   -----------------------
	    Preview binary normally doesn't have a vf_port but
	    instead it has an output port. However, the output is
	    generated by vf_veceven module in which we might have
	    a downscaling (by 1x, 2x, or 4x). Because the resolution
	    might change, we need two different info, namely out_info
	    & vf_info. In fill_binary_info we use out&vf info to
	    calculate vf decimation factor.
	 In case of preview_ds binary, we can do any fractional amount
	  of downscale, so there is no DS needed in vf_veceven. Therefore,
	  out and vf infos will be the same. Otherwise, we set out resolution
 TODO: Change this when bds_out_info is available! 
 vf_info can be NULL 
 assert(vf_info != NULL); 
	 The solution below is not optimal; we should move to using ia_css_pipe_get_copy_binarydesc()
	  But for now this fixes things; this code used to be there but was removed
	  with gerrit 8908 as this was wrong for Skycam; however 240x still needs this
		 bayer ds and fractional ds cannot be enabled
		at the same time, so we disable bds_out_info when
	 Note: if the following assert fails, the number of ports has been
	  changed; in that case an additional initializer must be added
	  a few lines below after which this assert can be updated.
	 add initializers here if
	  assert(IA_CSS_BINARY_MAX_OUTPUT_PORTS == ...);
	  fails
	 the in_info is only used for resolution to enable
 lookup table for high quality primary binaries 
 vf_info can be NULL - example video_binarydescr 
assert(vf_info != NULL);
		 We have both striped and non-striped primary binaries,
		  if continuous viewfinder is required, then we must select
		  a striped one. Otherwise we prefer to use a non-striped
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 for ia_css_binary_max_vf_width() 
 MW: Table look-up ??? 
 height can be odd number for jpegembedded data from ISYS2401 
 ISP2401 
 ISP2401 
 ISP2401 
	 raw_14 and raw_16 are not supported as input formats to the ISP.
	  They can only be copied to a frame in memory using the
	  copy binary.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 We use a different set of DPC configuration parameters when
  DPC is used before OBC and NORM. Currently these parameters
  are used in usecases which selects both BDS and DPC.
struct sh_css_isp_dp_vmem_state  state,
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Assume divisiblity here, may need to generalize to fixed point. 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 MW: These areMIPI  ISYS properties, not camera function properties 
 2401 input system uses input width width 
in some cases, in_info is NULL
 Assume divisiblity here, may need to generalize to fixed point. 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 0 -> ineffective 
 0 -> ineffective 
 0 -> ineffective 
 0 -> ineffective 
 0.5 
 0.5 
 0.5 
 0.5 
 1 
 1 
 -1 
 -1 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 YNR (Y Noise Reduction) 
 YEE (Y Edge Enhancement) 
 1.125 ->[s4.8] 
 (  -.25)->[s4.8] 
 0.875 ->[s4.8] 
 ( .25 ) ->[s4.8] 
struct sh_css_isp_ynr_vmem_state  state,
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Multi-Axes Color Correction table for ISP1.
 	64values = 2x2matrix for 16area, [s2.13]
 	ineffective: 16 of "identity 2x2 matix" {8192,0,0,8192}
 Multi-Axes Color Correction table for ISP2.
 	64values = 2x2matrix for 16area, [s1.12]
 	ineffective: 16 of "identity 2x2 matix" {4096,0,0,4096}
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Multi-Axes Color Correction table for ISP2.
 	64values = 2x2matrix for 16area, [s1.12]
 	ineffective: 16 of "identity 2x2 matix" {4096,0,0,4096}
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 FIXME: See BZ 4427 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 FIXME: See BZ 4427 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 default threshold 6400 translates to 25 on ISP. 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 for memcpy() 
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 
 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 
 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 
 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Maximum value for alpha on ISP interface 
 Minimum value for sigma on host interface. Lower values translate to
  max_alpha.
  division look-up table
  Refers to XNR3.0.5
  Default kernel parameters. In general, default is bypass mode or as close
  to the ineffective values as possible. Due to the chroma down+upsampling,
  perfect bypass mode is not possible for xnr3 filter itself. Instead, the
  'blending' parameter is used to create a bypass.
 sigma 
 coring 
 blending 
  Compute an alpha value for the ISP kernel from sigma value on the host
  parameter interface as: alpha_scale  1(sigmasigma_scale)
  Compute the scaled coring value for the ISP kernel from the value on the
  host parameter interface.
 fixed-point 0.5 
	 Convert from public host-side scale factor to isp-side scale
	  factor. Clip to [0, isp_scale-1).
  Compute the scaled blending strength for the ISP kernel from the value on
  the host parameter interface.
 fixed-point 0.5 
	 Convert from public host-side scale factor to isp-side scale
	  factor. The blending factor is positive on the host side, but
	  negative on the ISP side because +1.0 cannot be represented
	  exactly as s0.11 fixed point, but -1.0 can.
	 The adjust factor is the next power of 2
 alpha's are represented in qN.5 format 
 coring parameters are expressed in q1.NN format 
 blending strength is expressed in q1.NN format 
 ISP2401 
 (void) = ia_css_xnr3_vmem_encode(to, from)
  -----------------------------------------------
  VMEM Encode Function to translate UV parameters from userspace into ISP space
 Init 
	 Constraints on "x":
	  - values should be greater or equal to 0.
	  - values should be ascending.
	 The implementation of the calulating 1x is based on the availability
	  of the OP_vec_shuffle16 operation.
	  A 64 element vector is split up in 4 blocks of 16 element. Each array is copied to
	  a vector 4 times, (starting at 0, 16, 32 and 48). All array elements are copied or
	  initialised as described in the KFS. The remaining elements of a vector are set to 0.
 TODO: guard this code with above assumptions 
 Dummy Function added as the tool expects it
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 for min and max 
 WARNING1: Number of inv points should be less or equal to 16,
  due to implementation limitation. See kernel design document
  for more details.
  WARNING2: Do not modify the number of inv points without correcting
  the EED1_8 kernel implementation assumptions.
 Init 
	 Constraints on dew_enhance_seg_x and dew_enhance_seg_y:
	  - values should be greater or equal to 0.
	  - values should be ascending.
	  - value of index zero is equal to 0.
 Checking constraints: 
	 TODO: investigate if an assert is the right way to report that
	  the constraints are violated.
	 Constraints on chgrinv_x, tcinv_x and fcinv_x:
	  - values should be greater or equal to 0.
	  - values should be ascending.
	  - value of index zero is equal to 0.
	 The implementation of the calulating 1x is based on the availability
	  of the OP_vec_shuffle16 operation.
	  A 64 element vector is split up in 4 blocks of 16 element. Each array is copied to
	  a vector 4 times, (starting at 0, 16, 32 and 48). All array elements are copied or
	  initialised as described in the KFS. The remaining elements of a vector are set to 0.
 TODO: guard this code with above assumptions 
			 Convert dew_enhance_seg_exp to flag:
			  0 -> 0
			  1...13 -> 1
		 Hard-coded to 0, in order to be able to handle out of
		  range input in the same way as the other segments.
		  See KFS for more details.
	 Note: (ISP_VEC_ELEMBITS -1)
	  TODO: currently the testbench does not support to use
	  ISP_VEC_ELEMBITS. Investigate how to fix this
 Encode DEWEnhance exp (e_dew_enh_asr) 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Assume divisiblity here, may need to generalize to fixed point. 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Assume divisiblity here, may need to generalize to fixed point. 
 compute the log2 of the downscale factor needed to get closest
  to the requested viewfinder resolution on the upper side. The output cannot
  be smaller than the requested viewfinder resolution.
	 downscale until width smaller than the viewfinder width. We don't
	 test for the height since the vmem buffers only put restrictions on
	 the width of a line, not on the number of lines in a frame.
 now width is smaller, so we go up one step 
 TODO: use actual max input resolution of vf_pp binary 
 First compute value 
 Then store it in isp config section 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 number of blocks per height and width 
 round num_x up to blockdim_x, if it concerns the Y0Y1 block (uv_flag==0) round up to even
 format is Y0 Y1 UV, so UV starts at 3rd position 
 the width and height of the provided morphing table should be 1 more than the number of blocks
 Assert that right column's X is greater 
 Assert that bottom row's Y is greater 
			 similar to topleft_y calculation, but round up if ymax
 block should fit within the boundingbox.
 block size should be greater than zero.
 storage format:
 Y0 Y1 UV0 Y2 Y3 UV1
			 if uv_flag equals true increment with 2 incase x is odd, this to
DVS only supports input frame of YUV420 or NV12. Fail for all other cases
 Y plane 
YUV420 has half the stride for UV plane
 UV plane (packed inside the y plane) 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Assume divisiblity here, may need to generalize to fixed point. 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Code generated by genparamgenconfig.c:gen_configure_function() 
 ISP2401 
 ISP2401 
 The internal_frame_origin_x_bqs_on_sctbl is separated to 8 times of slice_vec. 
 ISP2401 
 ------ deprecated(bz675) : from ------ 
 It looks like @parameter{} (in .pipe) is used to generate the processgetset functions,
   for parameters which should be used in the isp kernels.
   However, the ia_css_shading_settings structure has a parameter which is used only in the css,
   and does not have a parameter which is used in the isp kernels.
   Then, I did not use @parameter{} to generate the getset function
 ------ deprecated(bz675) : to ------ 
 SPDX-License-Identifier: GPL-2.0
 Release Version: irci_stable_candrpv_0415_20150521_0458 
 Release Version: irci_ecr-master_20150911_0724 
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 YUV Anti-Aliasing configuration. 
 default should be 0 
 Bayer Anti-Aliasing configuration. 
 default should be 0 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
	
	  No weighted histogram, hence no grid definition
 Deinterleave 
		 sh_css_print ("hmem[%d] = %d, %d, %d, %d\n",
 coefficients to calculate Y 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2010 - 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 The base_address of the input frame will be set in the ISP
 SPDX-License-Identifier: GPL-2.0
Support for Intel Camera Imaging ISP subsystem.
Copyright (c) 2010 - 2015, Intel Corporation.
This program is free software; you can redistribute it andor modify it
under the terms and conditions of the GNU General Public License,
version 2, as published by the Free Software Foundation.
This program is distributed in the hope it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
more details.
 The base_address of the input frame will be set in the ISP
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
#include "sh_css_frac.h"
 FIXME: See BZ 4427 
 FIXME: See BZ 4427 
 FIXME: See BZ 4427 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 keep the interface here, it is not enabled yet because host doesn't know the size of individual state 
struct sh_css_isp_cnr_vmem_state  state,
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
struct sh_css_isp_cnr_vmem_state  state,
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 TODO: AM: This needs a proper implementation. 
 TODO: AM: This needs a proper implementation. 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
Default configuration of parameters for Ctc2
 (dydx) = ctc2_slope(y1, y0, x1, x0)
  -----------------------------------------------
  Calculation of the Slope of a Line = ((y1 - y0) >> 8)(x1 - x0)
  Note: y1, y0 , x1 & x0 must lie within the range 0 <-> 8191
Protection for parameter values, & avoiding zero divisions
	the slope must lie within the range
	  (-max_slope-1) >= (dydx) >= (max_slope)
 (void) = ia_css_ctc2_vmem_encode(to, from)
  -----------------------------------------------
  VMEM Encode Function to translate Y parameters from userspace into ISP space
	
	  Calculation of slopes of lines interconnecting
	  0.0 -> y_x1 -> y_x2 -> y _x3 -> y_x4 -> 1.0
	Fill 3 arrays with:
	  - Luma input gain values y_y0, y_y1, y_y2, y_3, y_y4
	  - Luma kneepoints 0, y_x1, y_x2, y_x3, y_x4
	  - Calculated slopes dydx0, dyxd1, dydx2, dydx3, dydx4
	 
	  - Each 64-element array is divided in blocks of 16 elements:
	    the 5 parameters + zeros in the remaining 11 positions
	  - All blocks of the same array will contain the same data
 (void) = ia_css_ctc2_encode(to, from)
  -----------------------------------------------
  DMEM Encode Function to translate UV parameters from userspace into ISP space
Slope Calculation
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 max_dydx = the maxinum gradient = the maximum y (gain) 
	 search "sft" which meets this condition:
		   (1 << (IA_CSS_CTC_COEF_SHIFT - 1))
		<= (((float)dy  (float)dx)  (1 << sft))
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 0.5 
 0.5 
 0.5 
 0.5 
 0.5 
 0.5 
 To be implemented 
 To be implemented 
 To be implemented 
 To be implemented 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 for memcpy() 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 coefficients to calculate Y 
 AWB level gate 
 af fir coefficients 
 pixel counts(BQ) for 3A area 
	 Calculate sum of histogram of R,
 histogram is invalid 
 Verify for sum of histogram of RGBY 
 histogram is invalid 
	
	  Limit the histogram area only to 3A area.
	  In DSP, the histogram of 0 is incremented for pixels
	  which are outside of 3A area. That amount should be subtracted here.
	    hist[0] = hist[0] - ((sum of all hist[]) - (pixel count for 3A area))
	 Getting 3A statistics from DMEM does not involve any
	  transformation (like the VMEM version), we just copy the data
 MW: this is an ISP function 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Copy the table, add padding 
 Copy the table, add padding 
 Only video pipe supports DVS 
 Host side: reflecting the true width in bytes 
 DDR side: need to be aligned to the system bus width 
 statistics table width in terms of 32-bit words
 horizontal stats 
 vertical stats 
 hor stats 
 ver stats 
 aligned table width 
	 on ISP 2 SDIS DMA model, every row of projection table width must be
	   aligned to HIVE_ISP_DDR_WORD_BYTES
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Copy the table, add padding 
 Copy the table, add padding 
 Only video pipe supports DVS 
	 Windows compiler does not like adding sizes to a void 
	 GCC complains when we assign a char  to a void , so these
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Assume divisiblity here, may need to generalize to fixed point. 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Assume divisiblity here, may need to generalize to fixed point. 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 23 
 1.0 
 0.0 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
struct sh_css_isp_de_vmem_state  state,
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 ia_css_debug_dtrace() 
 Encodes a look-up table from BNLM public parameters to vmem parameters.
  Input:
 	lut	:	bnlm_lut struct containing encoded vmem parameters look-up table
 	lut_thr	:	array containing threshold values for lut
 	lut_val	:	array containing output values related to lut_thr
 	lut_size:	Size of lut_val array
	 Create VMEM LUTs from the threshold and value arrays.
	 
	  Min size of the LUT is 2 entries.
	 
	  Max size of the LUT is 16 entries, so that the LUT can fit into a
	  single group of 16 elements inside a vector.
	  Then these elements are copied into other groups inside the same
	  vector. If the LUT size is less than 16, then remaining elements are
	  set to 0.
 array lut_thr has (lut_size-1) entries 
 Check if the lut_thr is monotonically increasing 
 Initialize 
 Copy all data 
 val has one more element than thr 
 Copy data from first block to all blocks 
  - Encodes BNLM public parameters into VMEM parameters
  - Generates VMEM parameters which will needed internally ISP
 Initialize LUTs in VMEM parameters 
 Initialize arrays in VMEM parameters 
 - Encodes BNLM public parameters into DMEM parameters 
 Prints debug traces for BNLM public parameters 
 ToDo: print traces for LUTs 
 IA_CSS_NO_DEBUG 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 TODO: include ob.isp.h to get isp knowledge and
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Blacklevels types are u0_16 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 Assume divisiblity here, may need to generalize to fixed point. 
 Packed by 2x 
 Packed by 2x 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
	 Use in_info iso binary->in_frame_info.
	  They can differ in padded width in case of scaling, e.g. for capture_pp.
	  Find out why.
	 we do this only for preview pipe because in fill_binary_info function
	  we assign vf_out res to out res, but for ISP internal processing, we need
	  the original out res. for video pipe, it has two output pins --- out and
		 TODO: Remove this after preview output decimation is fixed
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 BNR (Bayer Noise Reduction) 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 ia_css_debug_dtrace() 
 Default kernel parameters. 
 IA_CSS_NO_DEBUG 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 for memcpy() 
 Identical default gamma table for R, G, and B. 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 FIXME: See BZ 4427 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 for memcpy() 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 FIXME: See BZ 4427 
 SPDX-License-Identifier: GPL-2.0
  Support for Intel Camera Imaging ISP subsystem.
  Copyright (c) 2015, Intel Corporation.
  This program is free software; you can redistribute it andor modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.
  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.
 NULL 
  @brief	Creates the tag description from the given parameters.
  @param[in]	num_captures
  @param[in]	skip
  @param[in]	offset
  @param[out]	tag_descr
  @brief	Encodes the members of tag description into a 32-bit value.
  @param[in]	tag		Pointer to the tag description
  @return	(unsigned int)	Encoded 32-bit tag-info
 we encode either an exp_id or capture data 
 SPDX-License-Identifier: GPL-2.0
  Support for Medifield PNW Camera Imaging ISP subsystem.
  Copyright (c) 2010 Intel Corporation. All Rights Reserved.
  Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  This file contains functions for buffer object structure management
 for GFP_ATOMIC 
 for kmalloc 
 prevent zero size buffer object 
 init the bo->list HEAD as an element of entire_bo_list 
	 NOTE: All nodes on free rbtree have a 'prev' that points to NULL.
	  1. check if 'this->next' is NULL:
	 	yes: erase 'this' node and rebalance rbtree, return 'this'.
	 NOTE: if 'this->next' is not NULL, always return 'this->next' bo.
	  2. check if 'this->next->next' is NULL:
	 	yes: change the related 'nextprev' pointer,
	 		return 'this->next' but the rbtree stays unchanged.
	 There are 4 situations when we take off a known bo from free rbtree:
	  1. if bo->next && bo->prev == NULL, bo is a rbtree node
	 	and does not have a linked list after bo, to take off this bo,
	 	we just need erase bo directly and rebalance the free rbtree
		 2. when bo->next != NULL && bo->prev == NULL, bo is a rbtree node,
		 	and has a linked list,to take off this bo we need erase bo
		 	first, then, insert bo->next into free rbtree and rebalance
		 	the free rbtree
		 3. when bo->prev != NULL && bo->next == NULL, bo is not a rbtree
		 	node, bo is the last element of the linked list after rbtree
		 	node, to take off this bo, we just need set the "prevnext"
		 	pointers to NULL, the free rbtree stays unchaged
		 4. when bo->prev != NULL && bo->next != NULL ,bo is not a rbtree
		 	node, bo is in the middle of the linked list after rbtree node,
		 	to take off this bo, we just set take the "prevnext" pointers
		 	to NULL, the free rbtree stays unchaged
  hmm_bo_device functions.
	
	  FIX ME:
	 
	  how to destroy the bo when it is stilled MMAPED?
	 
	  ideally, this will not happened as hmm_bo_release
	  will only be called when kref reaches 0, and in mmap
	  operation the hmm_bo_ref will eventually be called.
	  so, if this happened, something goes wrong.
	
	  release all allocated bos even they a in use
	  and all bos will be merged into a big bo
 free all bos to release all ISP virtual memory 
 pass bo which has no vm_node allocated 
		
		  HMM_PAGE_TYPE_GENERAL indicates that pages are from system
		  memory, so when free them, they should be put into dynamic
		  pool.
		
		  if dynamic memory pool doesn't exist, need to free
		  pages to system directly.
			
			WA: set_pages_wb seldom return value = -EFAULT
			indicate that address of page is not in valid
			range(0xffff880000000000~0xffffc7ffffffffff)
			then, _free_pages would panic; Do not know why page
			address be valid,it maybe memory corruption by lowmemory
Allocate pages which will be used only by ISP
 REVISIT: need __GFP_FS too? 
	
	  get physical pages from dynamic pages pool.
	
	  get physical pages from reserved pages pool for atomisp.
		
		  if be short of memory, we will set order to 0
		  everytime.
		
		  When order > HMM_MIN_ORDER, for performance reasons we don't
		  want alloc_pages() to sleep. In case it fails and fallbacks
		  to HMM_MIN_ORDER or in case the requested order is originally
		  the minimum value, we can allow alloc_pages() to sleep for
		  robustness purpose.
		 
		  REVISIT: why __GFP_FS is necessary?
			
			  in low memory case, if allocation page fails,
			  we turn to try if order=0 allocation could
			  succeed. if order=0 fails too, that means there is
			  no memory left.
			
			  if fail two times continuously, we think be short
			  of memory now.
				
				  set memory to uncacheable -- UC_MINUS
			
			  if order is not reduced this time, clear
			  failure_number.
  Convert user space virtual address into pages list
	
	  Handle frame buffer allocated in other kerenl space driver
	  and map to user space
Handle frame buffer allocated in user space
 can be written by caller, not forced 
  allocatefree physical pages for the bo.
  type indicate where are the pages from. currently we have 3 types
  of memory: HMM_BO_PRIVATE, HMM_BO_USER, HMM_BO_SHARE.
  from_highmem is only valid when type is HMM_BO_PRIVATE, it will
  try to alloc memory from highmem if from_highmem is set.
  userptr is only valid when type is HMM_BO_USER, it indicates
  the start address from user space task.
  from_highmem and userptr will both be ignored when type is
  HMM_BO_SHARE.
	
	  TO DO:
	  add HMM_BO_USER type
  free physical pages of the bo.
 clear the flag anyway. 
  get physical page info of the bo.
  bind the physical pages to a virtual address space.
	
	  flush TBL here.
	 
	  theoretically, we donot need to flush TLB as we didnot change
	  any existed address mappings, but for Silicon Hive's MMU, its
	  really a bug here. I guess when fetching PTEs (page table entity)
	  to TLB, its MMU will fetch additional INVALID PTEs automatically
	  for performance issue. EX, we only set up 1 page address mapping,
	  meaning updating 1 PTE, but the MMU fetches 4 PTE at one time,
	  so the additional 3 PTEs are invalid.
 unbind the physical pages with related virtual address space 
  unbind the physical pages with related virtual address space.
	
	  flush TLB as the address mapping has been removed and
	  related TLBs should be invalidated.
 cached status need to be changed, so vunmap first 
  mmap the bo to user space.
	
	  check vma's virtual address space size and buffer object's size.
	  must be the same.
	
	  call hmm_bo_vm_open explicitly.
 SPDX-License-Identifier: GPL-2.0
  Support for Medifield PNW Camera Imaging ISP subsystem.
  Copyright (c) 2010 Intel Corporation. All Rights Reserved.
  Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  This file contains functions for dynamic memory pool management
  dynamic memory pool ops.
 free page directly back to system 
		
		WA: set_pages_wb seldom return value = -EFAULT
		indicate that address of page is not in valid
		range(0xffff880000000000~0xffffc7ffffffffff)
		then, _free_pages would panic; Do not know why page
		address be valid, it maybe memory corruption by lowmemory
 free page directly 
	
	  add to pages_list of pages_pool
 can cause thread sleep, so cannot be put into spin_lock 
 SPDX-License-Identifier: GPL-2.0
  Support for Medifield PNW Camera Imaging ISP subsystem.
  Copyright (c) 2010 Intel Corporation. All Rights Reserved.
  Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  This file contains functions for reserved memory pool management
  reserved memory pool ops.
 if fail five times, will goto end 
 FIXME: whether is the mechanism is ok? 
		
		WA: set_pages_wb seldom return value = -EFAULT
		indicate that address of page is not in valid
		range(0xffff880000000000~0xffffc7ffffffffff)
		then, _free_pages would panic; Do not know why
		page address be valid, it maybe memory corruption by lowmemory
 SPDX-License-Identifier: GPL-2.0
  Support for Medifield PNW Camera Imaging ISP subsystem.
  Copyright (c) 2010-2017 Intel Corporation. All Rights Reserved.
  Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version
  2 as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  This file contains entry functions for memory management of ISP driver
 for kmap 
 for page_to_phys 
  p: private
  s: shared
  u: user
  i: ion
 Add trailing zero, not included by scnprintf 
 Add trailing zero, not included by scnprintf 
 Add trailing zero, not included by scnprintf 
	
	  As hmm use NULL to indicate invalid ISP virtual address,
	  and ISP_VM_START is defined to 0 too, so we allocate
	  one piece of dummy memory, which should return value 0,
	  at the beginning, to avoid hmm_alloc return 0 in the
	  further allocation.
 free dummy memory first 
	
	  Check if we are initialized. In the ideal world we wouldn't need
	  this but we can tackle it once the driver is a lot cleaner
 Get page number from size 
 Buffer object structure init 
 Allocate pages for memory 
 Combine the virtual address and pages together 
 Read function in ISP memory management 
 update virt for next loop 
 Read function in ISP memory management 
 Read function in ISP memory management 
 Flush hmm data from the data cache 
 Write function in ISP memory management 
			
			  Note: kunmap_atomic requires return addr from
			  kmap_atomic, not the page. See linuxhighmem.h
 memset function in ISP memory management 
 Virtual address to physical address convert 
 Map ISP virtual address into IA virtual address 
 Flush the memory which is mapped as cached memory through hmm_vmap 
 Just use the "normal" pool
 Just use the "normal" pool
 vmunmap will be done in hmm_bo_release() 
 If reserved mem pool is not enabled, set its "mem stat" values as -1. 
 If dynamic memory pool is not enabled, set its "mem stat" values as -1. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018 Intel Corporation
 Same for lumachroma 
 lumachroma dependent 
 Set up the CSS scaler look up table 
 flip table to for convolution reverse indexing 
 Add +"0.5" 
  Calculates the exact output image widthheight, based on phase_step setting
  (must be perfectly aligned with hardware).
  Calculate the output width and height, given the luma
  and chroma details of a scaler
	
	  Calculate scaled output width. If the horizontal and vertical scaling
	  factor is different, then choose the biggest and crop off excess
	  lines or columns after formatting.
 Osys routines for scaler
 For now, assume use default values 
  Function calculates input frame stripe offset, based
  on output frame stripe offset and filter parameters.
  Calculate input frame phase, given the output frame
  stripe offset and filter parameters
  This function calculates input frame stripe width,
  based on output frame stripe offset and filter parameters
  This function calculates output frame stripe width, basedi
  on output frame stripe offset and filter parameters
 Output pins 
  frame_params - size IMGU_ABI_OSYS_PINS
  stripe_params - size IPU3_UAPI_MAX_STRIPES
 Frame parameters 
 Input width for Output System is output width of DVS (with GDC) 
 Input height for Output System is output height of DVS (with GDC) 
 Configure the frame parameters for all output pins 
				
				  When input and output resolution is
				  different instead of scaling, cropping
				  should happen. Determine the crop factor
				  to do the symmetric cropping
					
					  If resolution is different at input
					  and output of OSYS, scaling is
					  considered except when pin is MAIN.
					  Later it will be decide whether
					  scaler factor is 1 or other
					  and cropping has to be done or not.
 Scaling factor <= 0.5 
 0.5 <= Scaling factor <= 1.0 
 Scaling factor <= 0.875 
 1.0 <= Scaling factor <= 1.75 
	
	  Calculate scaler configuration parameters based on input and output
	  resolution.
		
		  When aspect ratio is different between target resolution and
		  required resolution, determine the crop factor to do
		  symmetric cropping
 Stripe parameters 
		
		  in case scaler output is not enabled
		  take output width as input width since
		  there is no scaling at main pin.
		  Due to the fact that main pin can be different
		  from input resolution to osys in the case of cropping,
		  main pin resolution is not taken.
 Calculate stripe offsets 
 Calculate stripe phase init 
				
				  Chunk boundary corner case - luma and chroma
				  start from different input chunks.
					
					  Match starting lumachroma chunks.
					  Decrease offset for UV and add output
					  cropping.
				
				  FW workaround for a HW bug: if the first
				  chroma pixel is generated exactly at the end
				  of chunck scaler HW may not output the pixel
				  for downscale factors smaller than 1.5
				  (timing issue).
					
					  Decrease input offset and add
					  output cropping
				
				  Calculate block and column offsets for the
				  input stripe
 Left padding is only for the first stripe 
 Right padding is only for the last stripe 
 Calculate target output stripe width 
 Calculate input stripe width 
				
				  The scaler requires that the last stripe
				  spans at least two input blocks.
			
			  Spec: input stripe width must be a multiple of 8.
			  Increase the input width and recalculate the output
			  width. This may produce an extra column of junk
			  blocks which will be overwritten by the
			  next stripe.
		
		  Following section executes and process parameters
		  for both cases - Striping or No Striping.
Input resolution 
					
					  Output stripe resolution and offset
					  as produced by the scaler; actual
					  output resolution may be slightly
					  smaller.
 Unscaled pin 
 If no pin use scale, we use BYPASS mode 
  This function configures the Output Formatter System, given the number of
  stripes, scaler luma and chrome parameters
 Compute the frame and stripe params 
 Output formatter system parameters 
 OUTPUT 0  PIN 0 is only Scaler output 
		
		  = (IMGU_OSYS_BLOCK_WIDTH  IMGU_VMEM1_ELEMS_PER_VEC)
		  = (2  IPU3_UAPI_ISP_VEC_ELEMS) 
		    (IMGU_HIVE_OF_SYS_OF_SYSTEM_NWAYS)
		  = 2  64  32 = 4
		
		  = (IMGU_VMEM1_V_OFFSET + VMEM1_uv_size)
		  = (IMGU_VMEM1_U_OFFSET + VMEM1_uv_size) +
		 	(VMEM1_y_size  4)
		  = (VMEM1_y_size) + (VMEM1_y_size  4) +
		  (IMGU_OSYS_BLOCK_HEIGHT  IMGU_VMEM1_Y_STRIDE)4
		  = (IMGU_OSYS_BLOCK_HEIGHT  IMGU_VMEM1_Y_STRIDE)
 Output buffers 
 Intermediate buffers 
 Context buffers 
 Addresses for release-input and process-output tokens 
 Settings dimensions, padding, cropping 
 Frame parameters 
 Stripe parameters 
 Only first stripe should do left cropping 
				
				  Stripe offset for other strips should be
				  adjusted according to the cropping done
				  at the first strip
 Formatter: configurations 
			
			  Get the dimensions of the input blocks of the
			  formatter, which is the same as the output
			  blocks of the scaler.
			
			  The inputoutput line stride depends on the
			  block size.
			
			  Tiled outputs use a different output buffer
			  configuration. The input (= scaler output) block
			  width translates to a tile height, and the block
			  height to the tile width. The default block size of
			  128x32 maps exactly onto a 4kB tile (512x8) for Y.
			  For UV, the tile width is always half.
			
			  Store the output buffer line stride. Will be
			  used to compute buffer offsets in boundary
			  conditions when output blocks are partially
			  outside the image.
				
				  The input buffs are the intermediate
				  buffers (scalers' output)
				
				  The input bufferss are the buffers
				  filled by the SP
			
			  The formatter input width must be rounded to
			  the block width. Otherwise the formatter will
			  not recognize the end of the line, resulting
			  in incorrect tiling (system may hang!) and
			  possibly other problems.
			
			  Process-output tokens must be sent to the SP.
			  When scaling, the release-input tokens can be
			  sent directly to the scaler, otherwise the
			  formatter should send them to the SP.
 Formatter 
 Mostly 3A operations 
  This function creates a "TO-DO list" (operations) for the sp code.
  There are 2 types of operations:
  1. Transfer: Issue DMA transfer request for copying grid cells from DDR to
     accelerator space (NOTE that this space is limited) associated data:
     DDR address + accelerator's config set index(acc's address).
  2. Issue "Process Lines Command" to shd accelerator
     associated data: #lines + which config set to use (actually, accelerator
     will use x AND (x+1)%num_of_sets - NOTE that this implies the restriction
     of not touching config sets x & (x+1)%num_of_sets when process_lines(x)
     is active).
  Basically there are 2 types of operations "chunks":
  1. "initial chunk": Initially, we do as much transfers as we can (and need)
     [0 - max sets(3) ] followed by 1 or 2 "process lines" operations.
  2. "regular chunk" - 1 transfer followed by 1 process line operation.
     (in some cases we might need additional transfer ate the last chunk).
  for some case:
  --> init
 	tr (0)
 	tr (1)
 	tr (2)
 	pl (0)
 	pl (1)
  --> ack (0)
 	tr (3)
 	pl (2)
  --> ack (1)
 	pl (3)
  --> ack (2)
 	do nothing
  --> ack (3)
 	do nothing
 We currently support only abs(y_start) > grid_height_per_slice 
	
	  When the number of lines for the last process lines command
	  is equal to a set height, we need another line of grid cell -
	  additional transfer is required.
 Add "process lines" command to the list of operations 
 Add DMA xfer (config set) command to the list of ops 
	
	  Available partial grid (the part that fits into #IMGU_SHD_SETS sets)
	  doesn't cover whole frame - need to process in chunks
 partial grid covers whole frame 
 Init operations lists and counters 
 Cyclic counters that holds config set number [0,IMGU_SHD_SETS) 
	
	  Always start with a transfer - process lines command must be
	  initiated only after appropriate config sets are in place
	  (2 configuration sets per process line command, except for last one).
 Transfer ops 
 Process-lines ops 
			
			  In case we have 2 process lines commands -
			  don't stop after the first one
			
			  Initiate last process lines command -
			  end of operation list.
			
			  Intermediate process line command - end of operation
			  "chunk" (meaning few "transfers" followed by few
			  "process lines" commands).
 first process line operation 
 Last process line operation 
 "regular" process lines operation 
		
		  Initially, we always transfer
		  min(IMGU_SHD_SETS, num_of_sets) - after that we fill in the
		  corresponding process lines commands.
		
		  We have finished the "initial" operations chunk -
		  be ready to get more chunks.
 Stop conditions for each operation type 
  The follow handshake procotol is the same for AF, AWB and AWB FR.
  for n sets of meta-data, the flow is:
  --> init
   process-lines  (0)
   process-lines  (1)	 eoc
   --> ack (0)
   read-meta-data (0)
   process-lines  (2)	 eoc
   --> ack (1)
   read-meta-data (1)
   process-lines  (3)	 eoc
   ...
   --> ack (n-3)
   read-meta-data (n-3)
   process-lines  (n-1) eoc
   --> ack (n-2)
   read-meta-data (n-2) eoc
   --> ack (n-1)
   read-meta-data (n-1) eof
  for 2 sets we get:
  --> init
  pl (0)
  pl (1) eoc
  --> ack (0)
  pl (2) - rest of image, if applicable)
  rmd (0) eoc
  --> ack (1)
  rmd (1) eof
  --> (ack (2))
  do nothing
  for only one set:
  --> init
  pl(0)   eoc
  --> ack (0)
  rmd (0) eof
  grid smaller than image case
  for example 128x128 grid (block size 8x8, 16x16 num of blocks)
  start at (0,0)
  1st set holds 160 cells - 10 blocks vertical, 16 horizontal
  => 1st process lines = 80
  we're left with 128-80=48 lines (6 blocks vertical)
  => 2nd process lines = 48
  last process lines to cover the image - image_height - 128
  --> init
  pl (0) first
  pl (1) last-in-grid
  --> ack (0)
  rmd (0)
  pl (2) after-grid
  --> ack (1)
  rmd (1) eof
  --> ack (2)
  do nothing
 max operation 
 max transaction 
 Helper to config intra_frame_operations_data. 
 Account for two line delay inside the FF 
 Read meta-data 
 The last operation is always a tr 
					
					  No additional pl op left -
					  this op is left as lats of cycle
					
					  We still have to process-lines after
					  the grid so have one more pl op
 Default - usually there's a pl after a tr 
 process_lines 
 Only one pl op 
 On init - do two pl ops 
 Usually pl is the end of the ack cycle 
 First process line 
 Last in grid 
 After the grid 
 Inside the grid 
 config computation 
 acc_param: osys_config 
 acc_param: stripe data 
	
	  For the striped case the approach is as follows:
	  1. down-scaled stripes are calculated - with 128 overlap
	     (this is the main limiter therefore it's first)
	  2. input stripes are derived by up-scaling the down-scaled stripes
	     (there are no alignment requirements on input stripes)
	  3. output stripes are derived from down-scaled stripes too
 Image processing is divided into two stripes 
		
		  Sum of width of the two stripes should not be smaller
		  than output width and must be even times of overlapping
		  unit f.
 Overlap between stripes is IPU3_UAPI_ISP_VEC_ELEMS  4 
 Two stripes 
 Disable DVS statistics 
  Configure `acc' parameters. `acc_old' contains the old values (or is NULL)
  and `acc_user' contains new prospective values. `use' contains flags
  telling which fields to take from the old values (or generate if it is NULL)
  and which to take from the new user values.
 Block width log2 
 Update stripe using chroma and luma 
 acc_param: input_feeder_config 
 acc_param: bnr_static_config 
	
	  Originate from user or be the original default values if user has
	  never set them before, when user gives a new set of parameters,
	  for each chunk in the parameter structure there is a flag use->xxx
	  whether to use the user-provided parameter or not. If not, the
	  parameter remains unchanged in the driver:
	  it's value is taken from acc_old.
 Take values from user 
 Use old value 
 Calculate from scratch 
 acc_param: bnr_static_config_green_disparity 
 Take values from user 
 Use old value 
 Calculate from scratch 
 acc_param: dm_config 
 Take values from user 
 Use old value 
 Calculate from scratch 
 acc_param: ccm_mat_config 
 Take values from user 
 Use old value 
 Calculate from scratch 
 acc_param: gamma_config 
 Take values from user 
 Use old value 
 Calculate from scratch 
 acc_param: csc_mat_config 
 Take values from user 
 Use old value 
 Calculate from scratch 
 acc_param: cds_params 
 Take values from user 
 Use old value 
 Calculate from scratch 
 acc_param: shd_config 
 Take values from user 
 Use old value 
 Calculate from scratch 
 acc_param: dvs_stat_config 
 acc_param: yuvp1_iefd_config 
 Take values from user 
 Use old value 
 Calculate from scratch 
 acc_param: yuvp1_yds_config yds_c0 
 Take values from user 
 Use old value 
 Calculate from scratch 
 acc_param: yuvp1_chnr_config chnr_c0 
 Take values from user 
 Use old value 
 Calculate from scratch 
 acc_param: yuvp1_y_ee_nr_config 
 Take values from user 
 Use old value 
 Calculate from scratch 
 acc_param: yuvp1_yds_config yds 
 Take values from user 
 Use old value 
 Calculate from scratch 
 acc_param: yuvp1_chnr_config chnr 
 Take values from user 
 Use old value 
 Calculate from scratch 
 acc_param: yuvp2_y_tm_lut_static_config 
 Always disabled on IPU3 
 acc_param: yuvp1_yds_config yds2 
 Take values from user 
 Use old value 
 Calculate from scratch 
 acc_param: yuvp2_tcc_static_config 
 Take values from user 
 Use old value 
 Calculate from scratch 
 acc_param: dpc_config 
 Not supported yet 
 Just disable by default 
 acc_param: bds_config 
 acc_param: anr_config 
 Take values from user 
 Use old value 
 Calculate from scratch 
 Always enabled 
 acc_param: awb_fr_config 
 Take values from user 
 Use old value 
 Set from scratch 
 Enable only for rightmost stripe, disable left 
 Enable only for leftmost stripe, disable right 
 Enable for both stripes 
 width for grid end 
		
		  To reduce complexity of debubbling and loading
		  statistics fix grid_height_per_slice to 1 for both
		  stripes.
 acc_param: ae_config 
 Take values from user 
 Use old value 
 Set from scratch 
 Enable only for rightmost stripe, disable left 
 Enable only for leftmost stripe, disable right 
 Enable for both stripes 
 acc_param: af_config 
 Take values from user 
 Use old value 
 Set from scratch 
 Enable only for rightmost stripe, disable left 
 Enable only for leftmost stripe, disable right 
 Enable for both stripes 
		
		  To reduce complexity of debubbling and loading statistics
		  fix grid_height_per_slice to 1 for both stripes
 acc_param: awb_config 
 Take values from user 
 Use old value 
 Set from scratch 
 Enable only for rightmost stripe, disable left 
 Enable only for leftmost stripe, disable right 
 Enable for both stripes 
		
		  To reduce complexity of debubbling and loading statistics
		  fix grid_height_per_slice to 1 for both stripes
  Fill the indicated structure in `new_binary_params' from the possible
  sources based on `use_user' flag: if the flag is false, copy from
  `old_binary_params', or if the flag is true, copy from `user_setting'
  and return NULL (or error pointer on error).
  If the flag is false and `old_binary_params' is NULL, return pointer
  to the structure inside `new_binary_params'. In that case the caller
  should calculate and fill the structure from scratch.
 Corrupted firmware 
 Take new user parameters 
 Take previous value 
 Need to calculate 
 Copied from other value 
  Configure VMEM0 parameters (late binding parameters).
 Configure VMEM0 
 Configure Linearization VMEM0 parameters 
 Generate parameter from scratch 
 Configure TNR3 VMEM parameters 
 Generate parameter from scratch 
 Configure XNR3 VMEM parameters 
  Configure DMEM0 parameters (late binding parameters).
 Configure DMEM0 
 Configure TNR3 DMEM0 parameters 
 Generate parameter from scratch 
 Configure XNR3 DMEM0 parameters 
 Generate parameter from scratch 
 Generate unity morphing table without morphing effect 
 Bytes per pixel 
 Global luma settings 
 Global chroma settings 
 Calculate block offsets for luma and chroma 
 Luma blocks 
 Chroma block 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018 Intel Corporation
 v4l2_subdev_ops 
 Initialize try_fmt 
 grab ctrl after streamon and return after off 
 This is handled specially 
 Initialize CSS formats 
 No need to reconfig meta nodes 
 Enable VF output only when VF queue requested by user 
 Clamp the w and h based on the hardware capabilities 
 media_entity_operations 
 enable input node to enable the pipe 
 vb2_ops 
 Called when each buffer is freed 
 Transfer buffer ownership to me 
 Initialize buffer queue 
 Check if all enabled video nodes are streaming, exception ignored 
 Return all buffers 
 Start streaming of the whole pipeline now 
 Was this the first node with streaming disabled? 
 Yes, really stop streaming now 
 v4l2_ioctl_ops 
 VID_CAPTURE or VID_OUTPUT not both 
 format descriptions for capture and preview 
 Find the first matched format, return default if not found 
 Propagate forward always the format from the CIO2 subdev 
  Set inputoutput format. Unless it is just a try, this also resets
  selections (ie. effective and BDS resolutions) to defaults.
 Skip the meta node 
 CSS expects some format on OUT queue 
 eff and bds res got by imgu_s_sel 
 suppose that pad fmt was set by subdev s_fmt before 
 ret is the binary number in the firmware blob 
	
	  imgu doesn't set the node to the value given by user
	  before we return success from this function, so set it here.
 From driversmediav4l2-corev4l2-ioctl.c 
 Each node is dedicated to only one meta format 
 function pointers 
 vb2_ops of the Q 
 v4l2_file_operations 
 v4l2_ioctl_ops 
 buffer queue management 
 meta capture 
 meta output 
 Framework registration 
 helper function to config node's video properties 
 Should not happen 
 Initialize subdev media entity 
 Initialize subdev 
 Initialize formats to default values 
 Initialize miscellaneous variables 
 Initialize formats to default values 
 Initialize media entities 
 Initialize vbq 
 can streamon wo buffers 
 Initialize vdev 
 Create link between video node and the subdev pad 
 Initialize miscellaneous variables 
 Set up media device 
 Set up v4l2 device 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018 Intel Corporation
 Check and display fw header info 
 Validate and display info on fw binaries 
 Allocate and map fw binaries into IMGU 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018 Intel Corporation
 IRQ configuration 
 Denominator 
 Some sane limits for resolutions 
 minimal envelope size(GDC in - out) should be 4 
  pre-allocated buffer size for CSS ABI, auxiliary frames
  after BDS and before GDC. Those values should be tuned
  to big enough to avoid buffer re-allocation when
  streaming to lower streaming latency.
 Formats supported by IPU3 Camera Sub System 
 Each 32 bytes contains 25 10-bit pixels 
 Initialize queue based on given format, adjust format as needed 
 Disable 
 Could not find any suitable format 
 css hw 
 In the style of writesl() defined in includeasm-genericio.h 
 Wait until register `reg', masked with `mask', becomes `cmp' 
 Initialize the IPU3 CSS hardware and associated hw blocks 
 Clear the CSS busy signal 
 Wait for idle signal 
 Reset the css 
 Prepare CSS 
 Power up CSS using wrapper 
 Set the busy bit 
 Set CSS clock frequency 
 get pm_ctrl 
 wait for cio idle signal 
 wait for css idle signal 
 do halt-halted handshake with css 
 de-assert the busy bit 
 Set up interrupts 
	
	  Enable IRQ on the SP which signals that SP goes to idle
	  (aka ready state) and set trigger to pulse
 Enable IRQs from the IMGU wrapper 
 Clear 
 Enable IRQs from main IRQ controller 
 Wait for write complete 
 Enable IRQs from SP0 and SP1 controllers 
 Wait for write complete 
 For checking that streaming monitor statuses are valid 
 Set instruction cache address and inv bit for ISP, SP, and SP1 
 Check that IMGU hardware is ready 
 Initialize GDC with default values 
 Boot the given IPU3 CSS SP 
 Start the IPU3 CSS ImgU (Imaging Unit) and all the SPs 
 Start bootloader 
 load sp1 first, then sp0 
 Start ISP 
 Enable all events for all queues 
 Start SP1 
 Stop fw 
 Reset CSS 
 Clear the CSS busy signal 
 Wait for idle signal 
 Reset the css 
  This function initializes various stages of the
  IPU3 CSS ISP pipeline
 Bytes per component 
 Configure iterator 
 Configure reference (delay) frames 
 Configure DVS (digital video stabilization) 
 Configure TNR (temporal noise reduction) 
 Configure ref dmem state parameters 
 Configure tnr dmem state parameters 
 Configure ISP stage 
 Configure SP stage 
 Configure SP group 
 Initialize parameter pools 
 Sent data to sp using given buffer queue, or if queue < 0, event queue. 
 Queue full 
 Receive data using given buffer queue, or if queue < 0, event queue. 
 Queue empty 
 Acknowledge events dequeued from event queue 
 Free binary-specific resources 
 allocate binary-specific resources 
 Bytes per component 
 Allocate parameter memory blocks for this binary 
 Allocate internal frame buffers 
 Reference frames for DVS, FRAME_FORMAT_YUV420_16 
 TNR frames for temporal noise reduction, FRAME_FORMAT_YUV_LINE 
 +3 for vf_pp prefetch 
 Initialize parameters to default 
 Allocate and map common structures with imgu hardware 
 Initialize main data structure 
 Select a binary matching the required resolutions and formats 
 Find out the strip size boundary 
 Check that binary supports memory-to-memory processing 
 Check that binary supports raw10 input 
 Check binary mode 
 Since input is RGGB bayer, need to process colors 
 All checks passed, select the binary 
 Can not find suitable binary for these parameters 
  Check that there is a binary matching requirements. Parameters may be
  NULL indicating disabled inputoutput. Return negative if given
  parameters can not be supported or on error, zero or positive indicating
  found binary number. May modify the given parameters if not exact match
  is found.
 Adjust all formats, get statistics buffer sizes and formats 
 For now, force known good resolutions 
 Always require one input and vf only if out is also enabled 
 Final adjustment and set back the queried formats 
		
		  Sanity check for the parameter struct size. This must
		  not change!
  Queue given buffer to CSS. imgu_css_buf_prepare() must have been first
  called for the buffer. May be called from interrupt context.
  Returns 0 on success, -EBUSY if the buffer queue is full, or some other
  code on error conditions.
 CSS or buffer in wrong state 
 Fill struct abi_buffer for firmware 
  Get next ready CSS buffer. Returns -EAGAIN in which case the function
  should be called again, or -EBUSY which means that there are no more
  buffers available. May be called from interrupt context.
 Force real error, not -EBUSY 
  Get a new set of parameters from pool and initialize them based on
  the parameters params, gdc, and obgrid. Any of these may be NULL,
  in which case the previously set parameters are used.
  If parameters haven't been set previously, initialize from scratch.
  Return index to css->parameter_set_info which has the newly created
  parameters or negative value on error.
 Destination buffers which are filled here 
 Get a new acc only if new parameters given, or none yet 
 Get new VMEM0 only if needed, or none yet 
 Get new DMEM0 only if needed, or none yet 
 Configure acc parameter cluster 
 get acc_old 
 user acc 
 Configure late binding parameters 
 Get a new gdc only if a new gdc is given, or none yet 
 Get a new obgrid only if a new obgrid is given, or none yet 
 Configure optical black level grid (obgrid) 
 Configure parameter set info, queued to `queue_id' 
 Then queue the new parameter buffer 
 Finally dequeue all old parameter buffers 
	
	  A failure, most likely the parameter queue was full.
	  Return error but continue streaming. User can try submitting new
	  parameters again later.
 SP SW interrupt 
 Wait for write to complete 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2017 - 2018 Intel Corporation
  Copyright 2017 Google LLC
  Based on Intel IPU4 driver.
  pre-allocated buffer size for IMGU dummy buffers. Those
  values should be tuned to big enough to avoid buffer
  re-allocation when streaming to lower streaming latency.
 Dummy buffers 
		
		  Do not enable dummy buffers for master queue,
		  always require that real buffers from user are
		  available.
 Allocate a dummy buffer for each queue where buffer is optional 
			
			  Do not enable dummy buffers for VF if it is not
			  requested by the user.
 May be called from atomic context 
 dummybufs are not allocated for master q 
 Buffer should not be allocated here 
 Check if given buffer is a dummy buffer 
 Find first free buffer from the node 
 There were no free buffers, try to return a dummy buffer 
  Queue as many buffers to CSS as possible. If all buffers don't fit into
  CSS buffer queues, they remain unqueued and will be queued later.
 Buffer set is queued to FW only when input buffer is ready 
 No parameters for this frame 
	
	  On error, mark all buffers as failed which are not
	  yet queued to CSS
 If we were called from streamon(), no need to finish bufs 
 Skip disabled queues 
 Was already queued, skip 
 input larger than 20481152, ask imgu to work on high freq 
 Stop streaming 
 Block new buffers to be queued to CSS. 
 Set Power 
 Start CSS streaming 
 Initialize dummy buffers 
 Queue as many buffers from queue as possible 
 Set initial formats and initialize formats of video nodes 
 Pre-allocate dummy buffers 
 PCI interface 
 Dequeue  queue buffers 
 All done 
 It was a dummy buffer, skip it 
 Fill vb2 buffer entries and tell it's ready 
	
	  Try to queue more buffers for CSS.
	  qbuf_barrier is used to disable new buffers
	  to be queued to CSS.
 acknowledge interruption 
 ISP programming 
 v4l2 sub-device registration 
 Block new buffers to be queued to CSS. 
	
	  Wait for currently running irq handler to be done so that
	  no new buffers will be queued to fw later.
 Wait until all buffers in CSS are done. 
 Start CSS streaming 
  PCI rpm framework checks the existence of driver rpm callbacks.
  Place a dummy callback here to avoid rpm going into error state.
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018 Intel Corporation
  Don't care value 
 Scale factor 32  (32 + 0) = 1 
 Scale factor 32  (32 + 1) = 0.969697 
 Scale factor 32  (32 + 2) = 0.941176 
 Scale factor 32  (32 + 3) = 0.914286 
 Scale factor 32  (32 + 4) = 0.888889 
 Scale factor 32  (32 + 5) = 0.864865 
 Scale factor 32  (32 + 6) = 0.842105 
 Scale factor 32  (32 + 7) = 0.820513 
 Scale factor 32  (32 + 8) = 0.8 
 Scale factor 32  (32 + 9) = 0.780488 
 Scale factor 32  (32 + 10) = 0.761905 
 Scale factor 32  (32 + 11) = 0.744186 
 Scale factor 32  (32 + 12) = 0.727273 
 Scale factor 32  (32 + 13) = 0.711111 
 Scale factor 32  (32 + 14) = 0.695652 
 Scale factor 32  (32 + 15) = 0.680851 
 Scale factor 32  (32 + 16) = 0.666667 
 Scale factor 32  (32 + 17) = 0.653061 
 Scale factor 32  (32 + 18) = 0.64 
 Scale factor 32  (32 + 19) = 0.627451 
 Scale factor 32  (32 + 20) = 0.615385 
 Scale factor 32  (32 + 21) = 0.603774 
 Scale factor 32  (32 + 22) = 0.592593 
 Scale factor 32  (32 + 23) = 0.581818 
 Scale factor 32  (32 + 24) = 0.571429 
 Scale factor 32  (32 + 25) = 0.561404 
 Scale factor 32  (32 + 26) = 0.551724 
 Scale factor 32  (32 + 27) = 0.542373 
 Scale factor 32  (32 + 28) = 0.533333 
 Scale factor 32  (32 + 29) = 0.52459 
 Scale factor 32  (32 + 30) = 0.516129 
 Scale factor 32  (32 + 31) = 0.507937 
 Scale factor 32  (32 + 32) = 0.5 
 Scale factor 32  (32 + 33) = 0.492308 
 Scale factor 32  (32 + 34) = 0.484848 
 Scale factor 32  (32 + 35) = 0.477612 
 Scale factor 32  (32 + 36) = 0.470588 
 Scale factor 32  (32 + 37) = 0.463768 
 Scale factor 32  (32 + 38) = 0.457143 
 Scale factor 32  (32 + 39) = 0.450704 
 Scale factor 32  (32 + 40) = 0.444444 
 Scale factor 32  (32 + 41) = 0.438356 
 Scale factor 32  (32 + 42) = 0.432432 
 Scale factor 32  (32 + 43) = 0.426667 
 Scale factor 32  (32 + 44) = 0.421053 
 Scale factor 32  (32 + 45) = 0.415584 
 Scale factor 32  (32 + 46) = 0.410256 
 Scale factor 32  (32 + 47) = 0.405063 
 Scale factor 32  (32 + 48) = 0.4 
 Scale factor 32  (32 + 49) = 0.395062 
 Scale factor 32  (32 + 50) = 0.390244 
 Scale factor 32  (32 + 51) = 0.385542 
 Scale factor 32  (32 + 52) = 0.380952 
 Scale factor 32  (32 + 53) = 0.376471 
 Scale factor 32  (32 + 54) = 0.372093 
 Scale factor 32  (32 + 55) = 0.367816 
 Scale factor 32  (32 + 56) = 0.363636 
 Scale factor 32  (32 + 57) = 0.359551 
 Scale factor 32  (32 + 58) = 0.355556 
 Scale factor 32  (32 + 59) = 0.351648 
 Scale factor 32  (32 + 60) = 0.347826 
 Scale factor 32  (32 + 61) = 0.344086 
 Scale factor 32  (32 + 62) = 0.340426 
 Scale factor 32  (32 + 63) = 0.336842 
 Scale factor 32  (32 + 64) = 0.333333 
 Scale factor 32  (32 + 65) = 0.329897 
 Scale factor 32  (32 + 66) = 0.326531 
 Scale factor 32  (32 + 67) = 0.323232 
 Scale factor 32  (32 + 68) = 0.32 
 Scale factor 32  (32 + 69) = 0.316832 
 Scale factor 32  (32 + 70) = 0.313725 
 Scale factor 32  (32 + 71) = 0.31068 
 Scale factor 32  (32 + 72) = 0.307692 
 Scale factor 32  (32 + 73) = 0.304762 
 Scale factor 32  (32 + 74) = 0.301887 
 Scale factor 32  (32 + 75) = 0.299065 
 Scale factor 32  (32 + 76) = 0.296296 
 Scale factor 32  (32 + 77) = 0.293578 
 Scale factor 32  (32 + 78) = 0.290909 
 Scale factor 32  (32 + 79) = 0.288288 
 Scale factor 32  (32 + 80) = 0.285714 
 Scale factor 32  (32 + 81) = 0.283186 
 Scale factor 32  (32 + 82) = 0.280702 
 Scale factor 32  (32 + 83) = 0.278261 
 Scale factor 32  (32 + 84) = 0.275862 
 Scale factor 32  (32 + 85) = 0.273504 
 Scale factor 32  (32 + 86) = 0.271186 
 Scale factor 32  (32 + 87) = 0.268908 
 Scale factor 32  (32 + 88) = 0.266667 
 Scale factor 32  (32 + 89) = 0.264463 
 Scale factor 32  (32 + 90) = 0.262295 
 Scale factor 32  (32 + 91) = 0.260163 
 Scale factor 32  (32 + 92) = 0.258065 
 Scale factor 32  (32 + 93) = 0.256 
 Scale factor 32  (32 + 94) = 0.253968 
 Scale factor 32  (32 + 95) = 0.251969 
 Scale factor 32  (32 + 96) = 0.25 
 settings for Geometric Distortion Correction 
 settings for Bayer Noise Reduction 
 wb_gains 
 wb_gains_thr 
 thr_coeffs 
 thr_ctrl_shd 
 opt_center 
 lut 
 bp_ctrl 
 dn_detect_ctrl 
 settings for Gamma correction 
 ds_nf 
 csc_en 
 uv_bin_output 
 frame settings for Auto White Balance 
 settings for Auto Exposure 
 settings for Auto Exposure color correction matrix 
 gain_grrbgb 
 settings for Auto Focus 
 settings for Auto White Balance 
 rgbs_thr_grrgbb 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018 Intel Corporation.
  Copyright 2018 Google LLC.
  Author: Tuukka Toivonen <tuukka.toivonen@intel.com>
  Author: Sakari Ailus <sakari.ailus@linux.intel.com>
  Author: Samu Onkalo <samu.onkalo@intel.com>
  Author: Tomasz Figa <tfiga@chromium.org>
 27-bit pfn 
 protect access to l2pts, l1pt 
  imgu_mmu_tlb_invalidate - invalidate translation look-aside buffer
  @mmu: MMU to perform the invalidate operation on
  This function invalidates the whole TLB. Must be called when the hardware
  is powered on.
  imgu_mmu_set_halt - set CIO gate halt bit
  @mmu: MMU to set the CIO gate bit in.
  @halt: Desired state of the gate bit.
  This function sets the CIO gate bit that controls whether external memory
  accesses are allowed. Must be called when the hardware is powered on.
  imgu_mmu_alloc_page_table - allocate a pre-filled page table
  @pteval: Value to initialize for page table entries with.
  Return: Pointer to allocated page table or NULL on failure.
  imgu_mmu_free_page_table - free page table
  @pt: Page table to free.
  address_to_pte_idx - split IOVA into L1 and L2 page table indices
  @iova: IOVA to split.
  @l1pt_idx: Output for the L1 page table index.
  @l2pt_idx: Output for the L2 page index.
  imgu_mmu_map - map a buffer to a physical address
  @info: MMU mappable range
  @iova: the virtual address
  @paddr: the physical address
  @size: length of the mappable area
  The function has been adapted from iommu_map() in
  driversiommuiommu.c .
	
	  both the virtual address and the physical one, as well as
	  the size of the mapping, must be aligned (at least) to the
	  size of the smallest page supported by the hardware
  imgu_mmu_map_sg - Map a scatterlist
  @info: MMU mappable range
  @iova: the virtual address
  @sg: the scatterlist to map
  @nents: number of entries in the scatterlist
  The function has been adapted from default_iommu_map_sg() in
  driversiommuiommu.c .
 must be IPU3_PAGE_SIZE aligned to be mapped singlely 
 undo mappings already done 
  imgu_mmu_unmap - Unmap a buffer
  @info: MMU mappable range
  @iova: the virtual address
  @size: the length of the buffer
  The function has been adapted from iommu_unmap() in
  driversiommuiommu.c .
	
	  The virtual address, as well as the size of the mapping, must be
	  aligned (at least) to the size of the smallest page supported
	  by the hardware
	
	  Keep iterating until we either unmap 'size' bytes (or more)
	  or we hit an area that isn't mapped.
  imgu_mmu_init() - initialize IPU3 MMU block
  @parent:	struct device parent
  @base:	IOMEM base of hardware registers.
  Return: Pointer to IPU3 MMU private data pointer or ERR_PTR() on error.
 Disallow external memory access when having no valid page tables. 
	
	  The MMU does not have a "valid" bit, so we have to use a dummy
	  page for invalid entries.
	
	  Allocate a dummy L2 page table with all entries pointing to
	  the dummy page.
	
	  Allocate the array of L2PT CPU pointers, initialized to zero,
	  which means the dummy L2PT allocated above.
 Allocate the L1 page table. 
  imgu_mmu_exit() - clean up IPU3 MMU block
  @info: MMU mappable range
 We are going to free our page tables, no more memory access. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018 Intel Corporation
  Allocate a new parameter via recycling the oldest entry in the pool.
 Get the oldest entry 
  Undo, for all practical purposes, the effect of pool_get().
  imgu_css_pool_last - Retrieve the nth pool entry from last
  @pool: a pointer to &struct imgu_css_pool.
  @n: the distance to the last index.
  Returns:
   The nth entry from last or null map to indicate no frame stored.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018 Intel Corporation
  Copyright 2018 Google LLC.
  Author: Tomasz Figa <tfiga@chromium.org>
  Author: Yong Zhi <yong.zhi@intel.com>
  Free a buffer allocated by imgu_dmamap_alloc_buffer()
  Based on the implementation of __iommu_dma_alloc_pages()
  defined in driversiommudma-iommu.c
 Allocate mem for array of page ptrs 
  imgu_dmamap_alloc - allocate and map a buffer into KVA
  @imgu: struct device pointer
  @map: struct to store mapping variables
  @len: size required
  Returns:
   KVA on success
   %NULL on failure
 Call IOMMU driver to setup pgt 
  Counterpart of imgu_dmamap_alloc
 SPDX-License-Identifier: GPL-2.0
  Cedrus VPU driver
  Copyright (C) 2016 Florent Revest <florent.revest@free-electrons.com>
  Copyright (C) 2018 Paul Kocialkowski <paul.kocialkowski@bootlin.com>
  Copyright (C) 2018 Bootlin
 Activate MPEG engine. 
 Set intra quantisation matrix. 
 Set non-intra quantisation matrix. 
 Set MPEG picture header. 
 Set frame dimensions. 
 Forward and backward prediction reference buffers. 
 Destination luma and chroma buffers. 
 Source offset and length in bits. 
 Source beginning and end addresses. 
 Macroblock address: start at the beginning. 
 Clear previous errors. 
 Clear correct macroblocks register. 
 Enable appropriate interruptions and components. 
 Trigger MPEG engine. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Cedrus VPU driver
  Copyright (c) 2019 Jernej Skrabec <jernej.skrabec@siol.net>
  VP8 in Cedrus shares same engine as H264.
  Note that it seems necessary to call bitstream parsing functions,
  to parse frame header, otherwise decoded image is garbage. This is
  contrary to what is driver supposed to do. However, values are not
  really used, so this might be acceptable. It's possible that bitstream
  parsing functions set some internal VPU state, which is later necessary
  for proper decoding. Biggest suspect is "VP8 probs update" trigger.
  This table comes from the concatenation of k_coeff_entropy_update_probs,
  kf_ymode_prob, default_mv_context, etc. It is provided in this form in
  order to avoid computing it every time the driver is initialised, and is
  suitable for direct consumption by the hardware.
 k_coeff_entropy_update_probs 
 block 0 
 block 1 
 block 2 
 block 3 
 kf_y_mode_probs 
 split_mv_probs 
 bmode_prob 
 sub_mv_ref_prob 
 mv_counts_to_probs 
 kf_y_mode_tree 
 y_mode_tree 
 uv_mode_tree 
 small_mv_tree 
 small_mv_tree again 
 split_mv_tree 
 b_mode_tree 
 submv_ref_tree 
 mv_ref_tree 
  This table is a copy of k_mv_entropy_update_probs from the VP8
  specification.
  FIXME: If any other driver uses it, we can consider moving
  this table so it can be shared.
 y_ac_qi 
 Parses y_dc_delta, y2_dc_delta, etc. 
	
	  FIXME: There is a problem if frame header is skipped (adding
	  first_part_header_bits to offset). It seems that functions
	  for parsing bitstreams change internal state of VPU in some
	  way that can't be otherwise set. Maybe this can be bypassed
	  by somehow fixing probability table buffer?
 reset registers changed by HW 
	
	  This offset has been discovered by reverse engineering, we don‚Äôt know
	  what it actually means.
 SPDX-License-Identifier: GPL-2.0
  Cedrus VPU driver
  Copyright (C) 2016 Florent Revest <florent.revest@free-electrons.com>
  Copyright (C) 2018 Paul Kocialkowski <paul.kocialkowski@bootlin.com>
  Copyright (C) 2018 Bootlin
  Based on the vim2m driver, that is:
  Copyright (c) 2009-2010 Samsung Electronics Co., Ltd.
  Pawel Osciak, <pawel@osciak.com>
  Marek Szyprowski, <m.szyprowski@samsung.com>
 Only 4:2:0 is supported 
 Luma and chroma bit depth mismatch 
 Only 8-bit is supported 
 Only 4:2:0 is supported 
 Luma and chroma bit depth mismatch 
 Only 8-bit and 10-bit are supported 
 Only 8-bit is supported 
	
	  We only expose supported profiles information,
	  and not levels as it's not clear what is supported
	  for each hardwarecore version.
	  In any case, TRYS_FMT will clamp the format resolution
	  to the maximum supported.
	
	  TILED_NV12 has more strict requirements, so copy the width and
	  height to src_fmt to ensure that is matches the dst_fmt resolution.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  Cedrus VPU driver
  Copyright (C) 2016 Florent Revest <florent.revest@free-electrons.com>
  Copyright (C) 2018 Paul Kocialkowski <paul.kocialkowski@bootlin.com>
  Copyright (C) 2018 Bootlin
  Based on the vim2m driver, that is:
  Copyright (c) 2009-2010 Samsung Electronics Co., Ltd.
  Pawel Osciak, <pawel@osciak.com>
  Marek Szyprowski, <m.szyprowski@samsung.com>
 Apply request(s) controls if needed. 
 Complete request(s) controls if needed. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Cedrus VPU driver
  Copyright (c) 2013 Jens Kuske <jenskuske@gmail.com>
  Copyright (c) 2018 Bootlin
 Adjust for the position 
 Adjust for the field 
  It turns out that using VE_H264_VLD_OFFSET to skip bits is not reliable. In
  rare cases frame is not decoded correctly. However, setting offset to 0 and
  skipping appropriate amount of bits with flush bits trigger always works.
	
	  FIXME: Since the bitstream parsing is done in software, and
	  in userspace, this shouldn't be needed anymore. But it
	  turns out that removing it breaks the decoding process,
	  without any clear indication why.
 picture parameters
	
	  FIXME: the kernel headers are allowing the default value to
	  be passed, but the libva doesn't give us that.
 sequence parameters
 slice parameters
 clear status flags
 enable int
	
	  NOTE: All buffers allocated here are only used by HW, so we
	  can add DMA_ATTR_NO_KERNEL_MAPPING flag when allocating them.
 Formula for picture buffer size is taken from CedarX source. 
	
	  FIXME: If V4L2_H264_SPS_FLAG_FRAME_MBS_ONLY is set,
	  there is no need to multiply by 2.
	
	  That buffer is supposed to be 16kiB in size, and be aligned
	  on 16kiB as well. However, dma_alloc_attrs provides the
	  guarantee that we'll have a DMA address aligned on the
	  smallest page order that is greater to the requested size,
	  so we don't have to overallocate.
	
	  FIXME: This is actually conditional to
	  V4L2_H264_SPS_FLAG_DIRECT_8X8_INFERENCE not being set, we
	  might have to rework this if memory efficiency ever is
	  something we need to work on.
	
	  FIXME: This is actually conditional to
	  V4L2_H264_SPS_FLAG_FRAME_MBS_ONLY not being set, we might
	  have to rework this if memory efficiency ever is something
	  we need to work on.
		
		  Formulas for deblock and intra prediction buffer sizes
		  are taken from CedarX source.
		
		  NOTE: Multiplying by two deviates from CedarX logic, but it
		  is for some unknown reason needed for H264 4K decoding on H6.
 SPDX-License-Identifier: GPL-2.0
  Cedrus VPU driver
  Copyright (C) 2016 Florent Revest <florent.revest@free-electrons.com>
  Copyright (C) 2018 Paul Kocialkowski <paul.kocialkowski@bootlin.com>
  Copyright (C) 2018 Bootlin
  Based on the vim2m driver, that is:
  Copyright (c) 2009-2010 Samsung Electronics Co., Ltd.
  Pawel Osciak, <pawel@osciak.com>
  Marek Szyprowski, <m.szyprowski@samsung.com>
	
	  FIXME: This is only valid on 32-bits DDR's, we should test
	  it on the A13A33.
 H.264 and VP8 both use the same decoding mode bit. 
 SPDX-License-Identifier: GPL-2.0
  Cedrus VPU driver
  Copyright (C) 2016 Florent Revest <florent.revest@free-electrons.com>
  Copyright (C) 2018 Paul Kocialkowski <paul.kocialkowski@bootlin.com>
  Copyright (C) 2018 Bootlin
  Based on the vim2m driver, that is:
  Copyright (c) 2009-2010 Samsung Electronics Co., Ltd.
  Pawel Osciak, <pawel@osciak.com>
  Marek Szyprowski, <m.szyprowski@samsung.com>
 Limit to hardware minmax. 
 Zero bytes per line for encoded source. 
 Choose some minimum size since this can't be 0 
 32-aligned stride. 
 32-aligned height. 
 Luma plane size. 
 Chroma plane size. 
 16-aligned stride. 
 16-aligned height. 
 Luma plane size. 
 Chroma plane size. 
 Index among formats that match the requested direction. 
 Matched format. 
	
	  In order to support dynamic resolution change,
	  the decoder admits a resolution change, as long
	  as the pixelformat remains. Can't be done if streaming.
	
	  Since format change on the OUTPUT queue will reset
	  the CAPTURE queue, we can't allow doing so
	  when the CAPTURE queue has buffers allocated.
 Propagate format information to capture. 
	
	  Buffer's bytesused must be written by driver for CAPTURE buffers.
	  (for OUTPUT buffers, if userspace passes 0 bytesused, v4l2-core sets
	  it to buffer length).
 SPDX-License-Identifier: GPL-2.0-or-later
  Cedrus VPU driver
  Copyright (C) 2013 Jens Kuske <jenskuske@gmail.com>
  Copyright (C) 2018 Paul Kocialkowski <paul.kocialkowski@bootlin.com>
  Copyright (C) 2018 Bootlin
  These are the sizes for side buffers required by the hardware for storing
  internal decoding metadata. They match the values used by the early BSP
  implementations, that were initially exposed in libvdpau-sunxi.
  Subsequent BSP implementations seem to double the neighbor info buffer size
  for the H6 SoC, which may be related to 10 bit H265 support.
 Each SRAM word gathers up to 4 references. 
 Write the word to SRAM and clear it for the next batch. 
 MV column buffer size and allocation. 
		
		  Each CTB requires a MV col buffer with a specific unit size.
		  Since the address is given with missing lsb bits, 1 KiB is
		  added to each buffer to ensure proper alignment.
 Buffer is never accessed by CPU, so we can skip kernel mapping. 
 TODO: Abort the process here.
 Activate H265 engine. 
 Source offset and length in bits. 
 Source beginning and end addresses. 
 Coding tree block address 
 Clear the number of correctly-decoded coding tree blocks. 
 Initialize bitstream access. 
 Bitstream parameters. 
 SPS. 
 PPS. 
 TODO: VE_DEC_H265_DEC_PPS_CTRL1_FLAG_TILES_ENABLED 
 Slice Parameters. 
 Decoded picture size. 
 Scaling list. 
 Neightbor information address. 
 Write decoded picture buffer in pic list. 
 Output frame. 
 Reference picture list 0 (for PB frames). 
 Reference picture list 1 (for B frames). 
 Enable appropriate interruptions. 
 The buffer size is calculated at setup time. 
 Buffer is never accessed by CPU, so we can skip kernel mapping. 
 SPDX-License-Identifier: GPL-2.0+
  V4L2 Media Controller Driver for Freescale i.MX56 SOC
  Copyright (c) 2016-2019 Mentor Graphics Inc.
 async subdev bound notifier 
 register the IPU internal subdevs 
 async subdev complete notifier 
 call the imx567 common probe completion handler 
 async subdev complete notifier 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0+
  V4L2 Capture CSI Subdev for Freescale i.MX56 SOC
  Copyright (c) 2014-2017 Mentor Graphics Inc.
  Copyright (C) 2017 Pengutronix, Philipp Zabel <kernel@pengutronix.de>
  MinMax supported width and heights.
  We allow planar output, so we have to align width by 16 pixels
  to meet IDMAC alignment requirements.
  TODO: move this into pad format negotiation, if capture device
  has not requested planar formats, we should allow 8 pixel
  alignment.
 multiple of 2 pixels 
 multiple of 2 lines 
 multiple of 2 
  struct csi_skip_desc - CSI frame skipping descriptor
  @keep - number of frames kept per max_ratio frames
  @max_ratio - width of skip_smfc, written to MAX_RATIO bitfield
  @skip_smfc - skip pattern written to the SKIP_SMFC bitfield
 the video device at IDMAC output pad 
 lock to protect all members below 
 active vb2 buffers to send to video dev sink 
 ipu double buffer index: 0-1 
 the sink for the captured frames 
 the source subdev 
 the mipi virtual channel number at link validate 
 the upstream endpoint CSI is receiving from 
 protect eof_irq handler 
 streaming counter 
 frame sequence counter 
 waiting for last EOF at stream off 
 NFB4EOF encountered during streaming 
 swap topbottom lines when interweaving 
  Check for conditions that require the IPU to handle the
  data internally as generic data, aka passthrough mode:
  - raw bayer media bus formats, or
  - BT.656 and BT.1120 (810-bit YUV422) data can always be processed
    on-the-fly
  - the CSI is receiving from a 16-bit parallel bus, or
  - the CSI is receiving from an 8-bit parallel bus and the incoming
    media bus format is other than UYVY8_2X8YUYV8_2X8.
 including BT.1120
  Parses the fwnode endpoint from the source pad of the entity
  connected to this CSI. This will either be the entity directly
  upstream from the CSI-2 receiver, directly upstream from the
  video mux, or directly upstream from the CSI itself. The endpoint
  is needed to determine the bus type and bus config coming into
  the CSI.
		
		  CSI is connected directly to CSI mux, skip up to
		  CSI-2 receiver if it is in the path, otherwise stay
		  with the CSI mux.
		
		  the source is neither the CSI mux nor the CSI-2 receiver,
		  get the source pad directly upstream from CSI itself.
 get source pad of entity directly upstream from sd 
 get next queued buffer 
 call frame interval monitor 
 select new IPU buf 
 toggle IPU double-buffer index 
 bump the EOF timeout timer 
	
	  this is not an unrecoverable error, just mark
	  the next captured frame with vb2 error flag.
  EOF timeout timer function. This is an unrecoverable condition
  without a stream restart.
 signal a fatal error to capture device 
 return any remaining active frames with return_status 
 init the SMFC IDMAC channel 
	
	  If the field type at capture interface is interlaced, and
	  the output IDMAC pad is sequential, enable interweave at
	  the IDMAC output channel.
		
		  Skip writing U and V components to odd rows (but not
		  when enabling IDMAC interweaving, they are incompatible).
 non-passthrough RGB565 (CSI-2 bus) 
 start interweave scan at 1st top line (2nd line) 
 start interweave scan at 1st top line (2nd line) 
	
	  Set the channel for the direct CSI-->memory via SMFC
	  use-case to very high priority, by enabling the watermark
	  signal in the SMFC, enabling WM in the channel, and setting
	  the channel priority to high.
	 
	  Refer to the i.mx6 rev. D TRM Table 36-8: Calculated priority
	  value.
	 
	  The WM's are set very low by intention here to ensure that
	  the SMFC FIFOs do not overflow.
 set buffers ready 
 enable the channels 
 init EOF completion waitq 
 start the EOF timeout timer 
 mark next EOF interrupt as the last before stream off 
	
	  and then wait for interrupt handler to mark completion.
 cancel the EOF timeout timer 
 Update the CSI whole sensor and active windows 
 compose mbus_config from the upstream endpoint 
	
	  if cycles is set, we need to handle this over multiple cycles as
	  genericbayer data
 start upstream 
 Skip first few frames from a BT.656 source 
 start the frame interval monitor 
	
	  Disable the CSI asap, after syncing with the last EOF.
	  Doing so after the IDMA channel is disabled has shown to
	  create hard system-wide hangs.
 stop upstream 
 stop the frame interval monitor 
 Keep all frames 
 Skip every sixth frame 
 Skip every fifth frame 
 Skip every fourth frame 
 Skip every third frame 
 Skip frames 1 and 3 of every 5 
 Skip every second frame 
 Keep frames 1 and 4 of every 5 
 Keep one in three frames 
 Keep one in four frames 
 Keep one in five frames 
 Keep one in six frames 
 Reduce fraction to lowest terms 
  Find the skip pattern to produce the output frame interval closest to the
  requested one, for the given input frame interval. Updates the output frame
  interval to the exact value.
 Default to 1:1 ratio 
 Find the reduction closest to the requested time per frame 
  V4L2 subdev operations.
 No limits on valid input frame intervals 
 Reset output intervals and frame skipping ratio to 1:1 
		
		  frame interval at IDMAC output pad depends on input
		  interval, modified by frame skipping.
		
		  frame interval at DIRECT output pad is same as input
		  interval.
	
	  enabledisable streaming only if stream_count is
	  going from 0 to 1  1 to 0.
 this is a source pad 
 do not apply IC burst alignment in csi_try_crop 
 record which output pad is now active 
 set CSI destination 
		
		  NOTE! It seems the virtual channels from the mipi csi-2
		  receiver are used only for routing by the video mux's,
		  or for hard-wired routing to the CSI's. Once the stream
		  enters the CSI's however, they are treated internally
		  in the IPU as virtual channel 0.
 select either parallel or MIPI-CSI2 as input to CSI 
 adjust crop leftwidth to hw alignment restrictions 
 multiple of 8 pixels (IC burst) 
 multiple of 2 pixels 
	
	  FIXME: not sure why yet, but on interlaced bt.656,
	  changing the vertical cropping causes loss of vertical
	  sync, so fix it to NTSCPAL active lines. NTSC contains
	  2 extra lines of active video that need to be cropped.
	
	  no restrictions on sink pad field type except must
	  be initialized.
		
		  If the user requests sequential at the source pad,
		  allow it (along with possibly inverting field order).
		  Otherwise passthrough the field type.
		
		  This driver does not support alternate field mode, and
		  the CSI captures a whole frame, so the CSI never presents
		  alternate mode at its source pads. If user has not
		  already requested sequential, translate ALTERNATE at
		  sink pad to SEQ_TB or SEQ_BT at the source pad depending
		  on input height (assume NTSC BT order if 480 total active
		  frame lines, otherwise PAL TB order).
 Passthrough for all other input field types 
 propagate colorimetry from sink 
 Reset crop and compose rectangles 
 propagate format to source pads 
		
		  Modifying the crop rectangle always changes the format on
		  the source pads. If the KEEP_CONFIG flag is set, just return
		  the current crop rectangle.
 Reset scaling to 1:1 
		
		  Modifying the compose rectangle always changes the format on
		  the source pads. If the KEEP_CONFIG flag is set, just return
		  the current compose rectangle.
 Reset source pads to sink compose rectangle 
 get handle to IPU CSI 
 set a default mbus format  
 init default frame interval 
 disable frame skipping 
 init default crop and compose rectangle sizes 
  The CSI has only one fwnode endpoint, at the sink pad. Verify the
  endpoint belongs to us, and return CSI_SINK_PAD.
	
	  If the subdev is a video mux, it must be one of the CSI
	  muxes. Mark it as such via its group id.
 get this CSI's port id 
 OK if asd already exists 
 get parent IPU 
 get our CSI id 
	
	  The IPUv3 driver did not assign an of_node to this
	  device. As a result, pinctrl does not automatically
	  configure our pin groups, so we need to do that manually
	  here, after setting this device's of_node.
 SPDX-License-Identifier: GPL-2.0+
  V4L2 Media Controller Driver for Freescale i.MX56 SOC
  Copyright (c) 2016 Mentor Graphics Inc.
  List of supported pixel formats for the subdevs.
 YUV formats start here 
 RGB formats start here 
 raw bayer and grayscale formats start here 
  Search in the pixel_formats[] array for an entry with the given fourcc
  that matches the requested selection criteria and return it.
  @fourcc: Search for an entry with the given fourcc pixel format.
  @fmt_sel: Allow entries only with the given selection criteria.
  Search in the pixel_formats[] array for an entry with the given media
  bus code that matches the requested selection criteria and return it.
  @code: Search for an entry with the given media-bus code.
  @fmt_sel: Allow entries only with the given selection criteria.
  Enumerate entries in the pixel_formats[] array that match the
  requested selection criteria. Return the fourcc that matches the
  selection criteria at the requested match index.
  @fourcc: The returned fourcc that matches the search criteria at
           the requested match index.
  @index: The requested match index.
  @fmt_sel: Include in the enumeration entries with the given selection
            criteria.
  @code: If non-zero, only include in the enumeration entries matching this
 	media bus code.
		
		  If a media bus code is specified, only consider formats that
		  match it.
  Enumerate entries in the pixel_formats[] array that match the
  requested search criteria. Return the media-bus code that matches
  the search criteria at the requested match index.
  @code: The returned media-bus code that matches the search criteria at
         the requested match index.
  @index: The requested match index.
  @fmt_sel: Include in the enumeration entries with the given selection
            criteria.
  Initializes the TRY format to the ACTIVE format on all pads
  of a subdev. Can be used as the .init_cfg pad operation.
  Default the colorspace in tryfmt to SRGB if set to an unsupported
  colorspace or not initialized. Then set the remaining colorimetry
  parameters based on the colorspace if they are uninitialized.
  tryfmt->code must be set on entry.
  If this format is destined to be routed through the Image Converter,
  Y`CbCr encoding must be fixed. The IC supports only BT.601 Y`CbCr
  or Rec.709 Y`CbCr encoding.
	
	  TODO: the IPU currently does not support the AYUV32 format,
	  so until it does convert to a supported YUV format.
 Round up width for minimum burst size 
 Round up stride for IDMAC line start address alignment 
 form a subdev name given a group id and ipu id 
  Adds a video device to the master video device list. This is called
  when a video device is registered.
  Search upstreamdownstream for a subdevice or video device pad in the
  current pipeline, starting from start_entity. Returns the device's
  sourcesink pad that it was reached from. Must be called with
  mdev->graph_mutex held.
  If grp_id != 0, finds a subdevice's pad of given grp_id.
  Else If buftype != 0, finds a video device's pad of given buffer type.
  Else, returns the nearest sourcesink pad to start_entity.
  Search upstreamdownstream for a subdev or video device in the current
  pipeline. Must be called with mdev->graph_mutex held.
  Find the upstream mipi-csi2 virtual channel reached from the given
  start entity in the current pipeline.
  Must be called with mdev->graph_mutex held.
  Find a subdev reached upstream from the given start entity in
  the current pipeline.
  Must be called with mdev->graph_mutex held.
  Find a subdev reached upstream from the given start entity in
  the current pipeline.
  Must be called with mdev->graph_mutex held.
  Find a fwnode endpoint that maps to the given subdevice's pad.
  If there are multiple endpoints that map to the pad, only the
  first endpoint encountered is returned.
  On success the refcount of the returned fwnode endpoint is
  incremented.
  Turn current pipeline streaming onoff starting from entity.
 SPDX-License-Identifier: GPL-2.0-or-later
  i.MX IPUv3 IC PP mem2mem CSCScaler driver
  Copyright (C) 2011 Pengutronix, Sascha Hauer
  Copyright (C) 2018 Pengutronix, Philipp Zabel
 mem2mem device mutex 
 Per-queue, driver-specific private data 
  mem2mem callbacks
  Video ioctls
 Reset croppingcomposing rectangle 
 Set colorimetry on the output queue 
 Propagate colorimetry to the capture queue 
	
	  TODO: Setting colorimetry on the capture queue is currently not
	  supported by the V4L2 API
	 The input's frame width to the IC must be a multiple of 8 pixels
	  When performing resizing the frame width must be multiple of burst
	  size - 8 or 16 pixels as defined by CB#_BURST_16 parameter.
 V4L2_SEL_FLAG_KEEP_CONFIG is only valid for subdevices 
  Queue operations
 Switch width & height to keep aspect ratio intact 
 Check if output format needs to be changed 
 Check if capture format needs to be changed 
  File operations
 SPDX-License-Identifier: GPL-2.0+
  Media driver for Freescale i.MX56 SOC
  Open Firmware parsing.
  Copyright (c) 2016 Mentor Graphics Inc.
 add CSI fwnode to async notifier 
 unavailable or already added is not an error 
 other error, can't continue 
 SPDX-License-Identifier: GPL-2.0+
  V4L2 Capture IC Preprocess Subdev for Freescale i.MX56 SOC
  This subdevice handles capture of video frames from the CSI or VDIC,
  which are routed directly to the Image Converter preprocess tasks,
  for resizing, colorspace conversion, and rotation.
  Copyright (c) 2012-2017 Mentor Graphics Inc.
  MinMax supported width and heights.
 multiple of 16 pixels 
 multiple of 2 lines 
 multiple of 2 
 lock to protect all members below 
 the CSI id at link validate 
 set IC to receive from CSI or VDI depending on source 
  V4L2 subdev operations.
 Output pads mirror input pad 
 this is a source pad 
		
		  the ->PRPENC link cannot be enabled if the source
		  is the VDIC
 the source is a CSI 
	
	  enabledisable streaming only if stream_count is
	  going from 0 to 1  1 to 0.
 startstop upstream 
 No limits on valid frame intervals 
 init default frame interval 
 set a default mbus format  
 SPDX-License-Identifier: GPL-2.0+
  Media driver for Freescale i.MX56 SOC
  Adds the IPU internal subdevices and the media links between them.
  Copyright (c) 2016 Mentor Graphics Inc.
 max pads per internal-sd 
 max links per internal-sd pad 
 skip if this link already created 
 create the source->sink links 
 record this IPU 
 register the synchronous subdevs 
		
		  skip if this sync subdev already registered or its
		  not a sync subdev (one of the CSIs)
	
	  all the sync subdevs are registered, create the media links
	  between them.
 SPDX-License-Identifier: GPL-2.0+
  Video Capture Subdev for Freescale i.MX56 SOC
  Copyright (c) 2012-2016 Mentor Graphics Inc.
 Media device 
 Physical device 
 Video device 
 Video device pad 
 Source subdev 
 Source subdev pad 
 Protect vdev operations 
 The videobuf2 queue 
 List of queued buffers 
 Protect ready_q 
 Controls inherited from subdevs 
 Use the legacy (pre-MC) API 
 In bytes, per queue 
 -----------------------------------------------------------------------------
  MC-Centric Video IOCTLs
	
	  TODO: The constraints are hardware-specific and may depend on the
	  pixel format. This should come from the driver using
	  imx_media_capture.
	
	  Find the pixel format, default to the first supported format if not
	  found.
 Allow IDMAC interweave but enforce field order from source. 
 The compose rectangle is fixed to the source format. 
		
		  The hardware writes with a configurable but fixed DMA burst
		  size. If the source format width is not burst size aligned,
		  the written frame contains padding to the right.
 -----------------------------------------------------------------------------
  Legacy Video IOCTLs
 allow IDMAC interweave but enforce field order from source 
 -----------------------------------------------------------------------------
  Queue Operations
 Retrieve the media bus format on the source subdev. 
	
	  Verify that the media bus size matches the size set on the video
	  node. It is sufficient to check the compose rectangle size without
	  checking the rounded size from vdev.fmt, as the rounded size is
	  derived directly from the compose rectangle size, and will thus
	  always match if the compose rectangle matches.
	
	  Verify that the media bus code is compatible with the pixel format
	  set on the video node.
 release all active buffers 
 -----------------------------------------------------------------------------
  File Operations
 -----------------------------------------------------------------------------
  Public API
 get next queued buffer 
 get media device 
 Initialize the default format and compose rectangle. 
 Register the video device. 
 Create the link from the src_sd devnode pad to device node. 
 Add vdev to the video devices list. 
 Allocate and initialize the video device. 
 Initialize the video device pad. 
 Initialize the vb2 queue. 
 Initialize the control handler. 
 SPDX-License-Identifier: GPL-2.0
  NXP i.MX8MQ SoC series MIPI-CSI2 receiver driver
  Copyright (C) 2021 Purism SPC
 Register map definition 
 i.MX8MQ CSI-2 controller CSR 
  The send level configures the number of entries that must accumulate in
  the Pixel FIFO before the data will be transferred to the video output.
  The exact value needed for this configuration is dependent on the rate at
  which the sensor transfers data to the CSI-2 Controller and the user
  video clock.
  The calculation is the classical rate-in rate-out type of problem: If the
  video bandwidth is 10% faster than the incoming mipi data and the video
  line length is 500 pixels, then the fifo should be allowed to fill
  10% of the line length or 50 pixels. If the gap data is ok, then the level
  can be set to 16 and ignored.
 Protect csi2_fmt, format_mbus, state, hs_settle 
 -----------------------------------------------------------------------------
  Format helpers
 RAW (Bayer and greyscale) formats. 
 YUV formats 
 -----------------------------------------------------------------------------
  Hardware configuration
	
	  these are most likely self-clearing reset bits. to make it
	  more clear, the reset-imx7 driver should implement the
	  .reset() operation.
	
	  0x180 bit 0 controls the Virtual Channel behaviour: when set the
	  interface ignores the Virtual Channel (VC) field in received packets;
	  when cleared it causes the interface to only accept packets whose VC
	  matches the value to which VC is set at offset 0x184.
 Calculate the line rate from the pixel rate. 
	
	  The D-PHY specification requires Ths-settle to be in the range
	  85ns + 6UI to 140ns + 10UI, with the unit interval UI being half
	  the clock period.
	 
	  The Ths-settle value is expressed in the hardware as a multiple of
	  the Esc clock period:
	 
	  Ths-settle = (PRG_RXHS_SETTLE + 1)  Tperiod of RxClkInEsc
	 
	  Due to the one cycle inaccuracy introduced by rounding, the
	  documentation recommends picking a value away from the boundaries.
	  Let's pick the average.
 -----------------------------------------------------------------------------
  V4L2 subdev operations
	
	  We can't transcode in any way, the source format is identical
	  to the sink format.
	
	  The device can't transcode in any way, the source format can't be
	  modified.
 Propagate the format from sink to source. 
 Store the CSI2 format descriptor for active formats. 
 -----------------------------------------------------------------------------
  Media entity operations
 -----------------------------------------------------------------------------
  Async subdev notifier
 -----------------------------------------------------------------------------
  Suspendresume
 -----------------------------------------------------------------------------
  Proberemove & platform driver
 Optional interconnect request 
 Acquire resources. 
 Enable runtime PM. 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0+
  Frame Interval Monitor.
  Copyright (c) 2016 Mentor Graphics Inc.
 FIM disabled by default 
 average 8 frames 
 skip 2 frames after restart 
 usec 
 no max tolerance (unbounded) 
 the owning subdev of this fim instance 
 FIM's control handler 
 control clusters 
 protect control values 
 current control values 
 usec 
 usec 
 input capture method of measuring FI 
 usec 
 usec 
 disable tolerance range if max <= min 
 num_skip must be >= 1 if input capture not used 
  Monitor an averaged frame interval. If the average deviates too much
  from the nominal frame rate, send the frame interval error event. The
  frame intervals are averaged in order to quiet noise from
  (presumably random) interrupt latency.
 max error is less than l00¬µs, so use 32-bit division or fail 
  Input Capture method of measuring frame intervals. Not subject
  to interrupt latency.
 CONFIG_IMX_GPT_ICAP 
 CONFIG_IMX_GPT_ICAP 
  In case we are monitoring the first frame interval after streamon
  (when fim->num_skip = 0), we need a valid fim->last_ts before we
  can begin. This only applies to the input capture method. It is not
  possible to accurately measure the first FI after streamon using the
  EOF method, so fim->num_skip minimum is set to 1 in that case, so this
  function is a noop when the EOF method is used.
 FIM Controls 
 no averaging 
 average 64 frames 
 skip no frames 
 skip 256 frames 
 input capture disabled by default 
  Monitor frame intervals via EOF interrupt. This method is
  subject to uncertainty errors introduced by interrupt latency.
  This is a noop if the Input Capture method is being used, since
  the frame_interval_monitor() is called by the input capture event
  callback handler in that case.
 Called by the subdev in its s_stream callback 
 add the FIM controls to the calling subdev ctrl handler 
 Called by the subdev in its subdev registered callback 
